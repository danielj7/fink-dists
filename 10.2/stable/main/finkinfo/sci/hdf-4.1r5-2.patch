diff -rc HDF4.1r4/configure.in HDF4.1r4-osx/configure.in
*** HDF4.1r4/configure.in	Wed Aug 30 12:41:09 2000
--- HDF4.1r4-osx/configure.in	Thu May  3 22:37:25 2001
***************
*** 93,98 ****
--- 93,99 ----
    *-cray-unicos*)         host_makefile_frag=config/mh-unicos ;;
    t3*-cray-craympp)       host_makefile_frag=config/mh-t3e ;;
    S370-fujitsu-sysv*)     host_makefile_frag=config/mh-fujivp ;;
+   *-apple-darwin*)	  host_makefile_frag=config/mh-darwin ;;
    *-mac-*)                host_makefile_frag=config/mh-mac ;;
  esac
  fi
***************
*** 167,172 ****
--- 168,174 ----
    *-cray-unicos*)         files="mfhdf/libsrc/config/netcdf-unicos.h mfhdf/fortran/config/jackets-unicos.c mfhdf/fortran/config/netcdf-unicos.inc mfhdf/fortran/config/ftest-unicos.f" ;;
    t3*-cray-craympp)       files="mfhdf/libsrc/config/netcdf-t3e.h mfhdf/fortran/config/jackets-t3e.c mfhdf/fortran/config/netcdf-t3e.inc mfhdf/fortran/config/ftest-t3e.f" ;;
    S370-fujitsu-sysv*)     files="mfhdf/libsrc/config/netcdf-fujivp.h mfhdf/fortran/config/jackets-fujivp.c mfhdf/fortran/config/netcdf-fujivp.inc mfhdf/fortran/config/ftest-fujivp.f" ;;
+   *-apple-darwin*)	  files="mfhdf/libsrc/config/netcdf-darwin.h mfhdf/fortran/config/jackets-darwin.c mfhdf/fortran/config/netcdf-darwin.inc mfhdf/fortran/config/ftest-darwin.f" ;;
    *-mac-*)		          files="mfhdf/libsrc/config/netcdf-mac.h mfhdf/fortran/config/jackets-mac.c mfhdf/fortran/config/netcdf-mac.inc mfhdf/fortran/config/ftest-mac.f" ;;
  esac
  fi
Only in HDF4.1r4-osx/hdf/fmpool/config: fmpdarwin.h
Only in HDF4.1r4-osx/hdf/fmpool/config: mh-darwin
diff -rc HDF4.1r4/hdf/fmpool/configure.in HDF4.1r4-osx/hdf/fmpool/configure.in
*** HDF4.1r4/hdf/fmpool/configure.in	Tue May 23 12:03:23 2000
--- HDF4.1r4-osx/hdf/fmpool/configure.in	Thu May  3 15:42:20 2001
***************
*** 49,54 ****
--- 49,55 ----
    *-cray-unicos*)         host_makefile_frag=config/mh-unicos ;;
    t3*-cray-craympp)       host_makefile_frag=config/mh-t3e ;;
    S370*)                  host_makefile_frag=config/mh-fujivp ;;
+   *-apple-darwin*)	  host_makefile_frag=config/mh-darwin ;;
    *-mac-*)		          host_makefile_frag=config/mh-mac ;;
  esac
  fi
***************
*** 120,125 ****
--- 121,127 ----
    *-cray-unicos*)         files=config/fmpunicos.h ;;
    t3*-cray-craympp)       files=config/fmpt3e.h ;;
    S370*)                  files=config/fmpfujivp.h ;;
+   *-apple-darwin*)	  files=config/fmpdarwin.h ;;
    *-mac-*)		          files=config/fmpmac.h ;;
  esac
  fi
Only in HDF4.1r4-osx/hdf/jpeg/config: jdarwin.h
Only in HDF4.1r4-osx/hdf/jpeg/config: mh-darwin
diff -rc HDF4.1r4/hdf/jpeg/configure.in HDF4.1r4-osx/hdf/jpeg/configure.in
*** HDF4.1r4/hdf/jpeg/configure.in	Tue May 23 12:03:26 2000
--- HDF4.1r4-osx/hdf/jpeg/configure.in	Thu May  3 15:17:39 2001
***************
*** 49,54 ****
--- 49,55 ----
    *-cray-unicos*)         host_makefile_frag=config/mh-unicos ;;
    t3*-cray-craympp)       host_makefile_frag=config/mh-t3e ;;
    S370*)                  host_makefile_frag=config/mh-fujivp ;;
+   *-apple-darwin*)	  host_makefile_frag=config/mh-darwin ;;
    *-mac-*)		          host_makefile_frag=config/mh-mac ;;
  esac
  fi
***************
*** 120,125 ****
--- 121,127 ----
    *-cray-unicos*)         files=config/junicos.h ;;
    t3*-cray-craympp)       files=config/jt3e.h ;;
    S370*)                  files=config/jfujivp.h ;;
+   *-apple-darwin*)	  files=config/jdarwin.h ;;
    *-mac-*)	              files=config/jmac.h ;;
  esac
  fi
diff -rc HDF4.1r4/hdf/src/hdfi.h HDF4.1r4-osx/hdf/src/hdfi.h
*** HDF4.1r4/hdf/src/hdfi.h	Tue Aug 22 14:26:57 2000
--- HDF4.1r4-osx/hdf/src/hdfi.h	Thu May  3 16:30:33 2001
***************
*** 949,955 ****
  #endif /* INTEL86 */
  #endif /* !(defined(macintosh) || defined(MAC)) */
  
! #if defined(NEXT) || defined(NeXT)
  
  #ifndef NEXT
  #define NEXT
--- 949,955 ----
  #endif /* INTEL86 */
  #endif /* !(defined(macintosh) || defined(MAC)) */
  
! #if defined(NEXT) || defined(NeXT) || defined(__APPLE__)
  
  #ifndef NEXT
  #define NEXT
Only in HDF4.1r4-osx/mfhdf/fortran/config: ftest-darwin.f
Only in HDF4.1r4-osx/mfhdf/fortran/config: jackets-darwin.c
Only in HDF4.1r4-osx/mfhdf/fortran/config: netcdf-darwin.inc
Only in HDF4.1r4-osx/mfhdf/libsrc/config: netcdf-darwin.h
--- HDF-4.1r4/config/mh-darwin	Mon Sep 17 06:39:06 2001
+++ HDF-4.1r4/config/mh-darwin	Mon May  7 11:48:19 2001
@@ -0,0 +1,180 @@
+# $Id: hdf-4.1r4-2.patch,v 1.1 2001/09/19 14:46:18 jswhit Exp $
+
+# You can override the following variables here
+#
+# Sections in Host makefile fragments
+# ----------------------------------:
+# 1. General Macros for HDF
+# 2. Macros for Pablo Instrumentation
+# 3. Macros for File Cache
+# 4. General macros for NETCDF
+# 4.1 XDR Macros for NETCDF
+# 4.2 libsrc Macros for NETCDF
+# 4.3 Port Macros for NETCDF
+#
+
+# ------------ General Macros for HDF --------------------
+# Version of the library
+PACKAGE	 = HDF
+VERSION  = 4.0
+#
+# Compiliers:
+# For gcc version
+CC=cc
+CFLAGS=-ansi -D_BSD_SOURCE -O -no-cpp-precomp
+
+# Fortran compilier
+#FC = f77
+FC = fort77
+#FC = g77
+FFLAGS = -O -Nx800
+
+# Name of achive randomizer, usually ranlib (use 'true' if non-existant)
+RANLIB = ranlib
+
+# Name of library archiver and flags to send, default 'AR=ar', 'ARFLAGS=r'
+AR = ar
+ARFLAGS = r
+
+# Name of remove utility, default 'RM=/bin/rm', 'RMFLAGS=-f'
+RM = /bin/rm
+RMFLAGS = -f
+
+# Extra libraries to be include like '-lm' for fabs()
+# e.g with naitve HP-ANSI compilier
+#LIBSX = -lm
+
+# ------------ Macros for Pablo Instrumentation  --------------------
+# Uncomment the following lines to create a Pablo Instrumentation
+# version of the HDF core library called 'libdf-inst.a'
+# See the documentation in the directory 'hdf/pablo' for further 
+# information about Pablo and what platforms it is supported on
+# before enabling. 
+# You need to set 'PABLO_INCDIR' to the Pablo distribution 
+# include directory to get to files 'IOTrace.h', 'IOTrace_SD.h' and others.
+
+#PABLO_FLAGS  = -DHAVE_PABLO
+#PABLO_INCDIR = /usr/local/include/pablo-5.1
+#PABLO_INCLUDE = -I$(PABLO_INCDIR)
+
+# ------------ Macros for File Cache(fmpool) ------
+# Uncomment the following lines to enable shared memory file buffer pool
+# version of the HDF core library libdf.a. Please read the
+# documentation before enabling this feature.
+
+#FMPOOL_FLAGS  = -DHAVE_FMPOOL
+
+# ------------ General Macros for NETCDF --------------------
+# Operating system, Used in fortran directory to generate fortran
+# wrappers. Possible values are osf, aix, hpux, irix, sunos, ultrix
+# unicos, convex, Linux, freebsd
+OS	= Linux
+
+CPP	      = $(CC) -E
+
+# for endianess, for little endian byte order need -DSWAP
+# for FreeBSD and Linux(anny x86 UNIX)
+#SWAP          = -DSWAP
+#SWAP          = 
+
+# for 32bit 'network long' integer, possible value -DNETLONG=int
+NETLONG       = 
+
+# additional CFLAGS
+CFLAGS_NETCDF = 
+
+# Additional flags for preproccesor. Some no longer used because
+#   library now requires ANSI compilier.
+#
+# for no function prototypes add -DNO_HAVE_PROTOTYPES
+# for no strerror()          add -DNO_STRERROR
+# for no variadic function support add -DNO_STDARG
+#
+# They all require -DHDF and -DNDEBUG 
+# Any special preprocessor requirements go here
+#
+# for Unicos 
+# CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -DBIG_SHORTS -DBIG_LONGS
+#
+# for OSF(dec alpha) 
+# CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -DBIG_LONGS -std1
+#
+# for IRIX6(64-bit) 
+# CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -DBIG_LONGS
+#
+# for AIX
+# CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -D_ALL_SOURCE
+#
+# for Sunos and Linux
+#CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -DNO_STRERROR
+#
+# for IRIX6.0 (32-bit mode). If you prefer other 32 bit option like -n32, 
+#  replace '-32' below
+# CPPFLAGS_HDF  = -32 $(FMPOOL_FLAGS) -DNDEBUG -DHDF
+#
+# normal
+CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF
+
+#
+# Unix commands/utilities
+#
+# neqn(1)
+NEQN	= neqn
+# tbl(1)
+TBL	= tbl
+# which(1)
+WHICH	= which
+# lex(1)
+#LEX	= lex    # GNU flex?
+LEX	= flex    # GNU flex?
+# yacc(1)
+YACC	= yacc   # GNU bison?
+
+#diff(1)
+DIFF    = diff   # GNU diff?
+DIFF_FLAGS = -w
+
+# Other Macros
+NCDUMP	= 
+NCGEN	= 
+FTPDIR	= 
+VERSION_NETCDF	= 2.3.2
+
+# ------------ XDR Macros for NETCDF --------------------
+# This is where the location of system XDR library includes
+# and location of the library are set
+#
+# Location of <xdr.h> if you are using the system
+# one, Else you need to comment it out
+CPP_XDR		= -I/usr/include/rpc
+
+# If XDR library not present on the system then you need
+# uncomment the following and comment the one below it
+#XDR_LIBOBJS    = xdr.o xdrfloat.o xdrstdio.o xdrarray.o
+XDR_LIBOBJS     =
+
+# Location of library, sometimes the sunos requires -lsun
+LD_XDR		= 
+
+#
+XDR_INSTALL_DEPS =
+
+# ------------ libsrc Macros for NETCDF --------------------
+# Possible values are xdrposix and xdrstdio
+# This sets which version of the XDR interface to use.
+XDRFILE		= xdrposix
+
+# ------------ Port Macros for NETCDF --------------------
+# Major and Minor numbe of NETCDF library version
+MAJOR_NO	= 2
+MINOR_NO	= 3
+PORT_CFORTRAN	= 
+NEED_FORTC	= 
+FORTC		= 
+
+# possible values are limits.h, float.h, stddef.h, stdlib.h,
+# string.h time.h signal.h unistd.h
+PORT_HEADERS	= 
+PORT_SUBDIRS    =
+LIBOBJS		= uddummy.o 
+
--- HDF-4.1r4/hdf/fmpool/config/fmpdarwin.h	Mon Sep 17 06:39:27 2001
+++ HDF-4.1r4/hdf/fmpool/config/fmpdarwin.h	Mon May  7 11:49:11 2001
@@ -0,0 +1,44 @@
+/****************************************************************************
+ * NCSA HDF                                                                 *
+ * Software Development Group                                               *
+ * National Center for Supercomputing Applications                          *
+ * University of Illinois at Urbana-Champaign                               *
+ * 605 E. Springfield, Champaign IL 61820                                   *
+ *                                                                          *
+ * For conditions of distribution and use, see the accompanying             *
+ * hdf/COPYING file.                                                        *
+ *                                                                          *
+ ****************************************************************************/
+
+/*****************************************************************************
+ * File: fmpsun.h
+ *
+ *****************************************************************************/ 
+
+/* $Id: hdf-4.1r4-2.patch,v 1.1 2001/09/19 14:46:18 jswhit Exp $ */
+
+#ifndef _FMPCONF_H
+#define _FMPCONF_H
+
+#define HAVE_PROTOTYPES
+#define HAVE_UCHAR
+#define HAVE_UINT
+#define HAVE_ULONG
+#define HAVE_USHORT
+#define HAVE_SIZE_T
+#define HAVE_SSIZE_T
+#define HAVE_SIGSET_T
+#define HAVE_LIMITS_H
+#define HAVE_UNISTD_H
+#define HAVE_STDLIB
+#define HAVE_STDIO_H
+#define HAVE_FCNTL
+#define HAVE_STAT
+#define HAVE_MIN_MAX
+#define HAVE_CDEFS_H
+
+#endif /* _FMPCONF_H */
+
+
+
+
--- HDF-4.1r4/hdf/fmpool/config/mh-darwin	Mon Sep 17 06:39:21 2001
+++ HDF-4.1r4/hdf/fmpool/config/mh-darwin	Mon May  7 11:49:30 2001
@@ -0,0 +1,40 @@
+# This makefile fragemnt will override the default options found at the top
+# of the 'Makefile' in the source directory. See 'Makefile.in'
+# for discussion of the various options.
+#
+
+# Gnu GCC
+CC=cc
+CFLAGS= -O -ansi -no-cpp-precomp
+
+# -DPURIFY     -> when using purify
+# -DSTATISTICS -> when you want statistics
+# -DMPOOL_DEBUG -> debugging fmpool_xxx interface
+# -DMP_DEBUG    -> debugging MPxxx interface
+# 
+#AUXFLAGS= -DPURIFY -DSTATISTICS -DMPOOL_DEBUG -DMP_DEBUG -DDEBUG
+#AUXFLAGS= -DPURIFY -DSTATISTICS -DMPOOL_DEBUG -DMP_DEBUG -DCIRCLEQ_DEBUG
+#AUXFLAGS= -DPURIFY -DSTATISTICS -DMP_DEBUG -DDEBUG
+#AUXFLAGS= -DPURIFY -DSTATISTICS -DSTAT_DEBUG
+#AUXFLAGS= -DHAVE_GETRUSAGE -DSTATISTICS
+#AUXFLAGS= -DDEBUG
+#AUXFLAGS= 
+
+LDFLAGS= 
+LDLIBS= 
+
+# Name of achive randomizer, usually ranlib (use 'true' if non-existant)
+RANLIB = ranlib
+
+# Name of library archiver and flags to send, default 'AR=ar', 'ARFLAGS=r'
+AR = ar
+ARFLAGS = r
+
+# Name of remove utility, default 'RM=/bin/rm', 'RMFLAGS=-f'
+RM = /bin/rm
+RMFLAGS = -f
+
+# Move command
+MV= mv
+
+
--- HDF-4.1r4/hdf/jpeg/config/jdarwin.h	Mon Sep 17 06:39:56 2001
+++ HDF-4.1r4/hdf/jpeg/config/jdarwin.h	Mon May  7 11:50:38 2001
@@ -0,0 +1,45 @@
+/* jconfig.h.  Generated automatically by configure.  */
+/* jconfig.cfg --- source file edited by configure script */
+/* see jconfig.doc for explanations */
+
+#define HAVE_PROTOTYPES 
+#define HAVE_UNSIGNED_CHAR 
+#define HAVE_UNSIGNED_SHORT 
+#undef void
+#undef const
+#undef CHAR_IS_UNSIGNED
+#define HAVE_STDDEF_H 
+#define HAVE_STDLIB_H 
+#undef NEED_BSD_STRINGS
+#undef NEED_SYS_TYPES_H
+#undef NEED_FAR_POINTERS
+#undef NEED_SHORT_EXTERNAL_NAMES
+/* Define this if you get warnings about undefined structures. */
+#undef INCOMPLETE_TYPES_BROKEN
+
+#ifdef JPEG_INTERNALS
+
+#undef RIGHT_SHIFT_IS_UNSIGNED
+#undef INLINE
+/* These are for configuring the JPEG memory manager. */
+#undef DEFAULT_MAX_MEM
+#undef NO_MKTEMP
+
+#endif /* JPEG_INTERNALS */
+
+#ifdef JPEG_CJPEG_DJPEG
+
+#define BMP_SUPPORTED		/* BMP image file format */
+#define GIF_SUPPORTED		/* GIF image file format */
+#define PPM_SUPPORTED		/* PBMPLUS PPM/PGM image file format */
+#undef RLE_SUPPORTED		/* Utah RLE image file format */
+#define TARGA_SUPPORTED		/* Targa image file format */
+
+#undef TWO_FILE_COMMANDLINE
+#undef NEED_SIGNAL_CATCHER
+#undef DONT_USE_B_MODE
+
+/* Define this if you want percent-done progress reports from cjpeg/djpeg. */
+#undef PROGRESS_REPORT
+
+#endif /* JPEG_CJPEG_DJPEG */
--- HDF-4.1r4/hdf/jpeg/config/mh-darwin	Mon Sep 17 06:39:49 2001
+++ HDF-4.1r4/hdf/jpeg/config/mh-darwin	Mon May  7 11:50:54 2001
@@ -0,0 +1,41 @@
+# This makefile fragemnt will override the default options found at the top
+# of the 'Makefile' in the jpeg source directory. See 'Makefile.in'
+# for discussion of the various options.
+#
+
+ANSI2KNRFLAGS= 
+LDFLAGS= 
+LDLIBS= 
+SYSDEPMEM= jmemnobs.o
+RM = /bin/rm 
+RMFLAGS = -f
+MV= mv
+AR = ar
+ARFLAGS = rc
+
+# The following segment should not really be the fragments but I 
+# couldn't find a way to avoid this.-GV
+#
+# Uncomment the following line if you don't have an ANSI compilier
+# and comment out the one below it
+#all: @ANSI2KNR@ libjpeg.a cjpeg djpeg rdjpgcom wrjpgcom
+all: libjpeg.a cjpeg djpeg rdjpgcom wrjpgcom
+
+# Uncomment the following rule if you don't have an ANSI compilier
+# This rule causes ansi2knr to be invoked.
+# .c.o:
+# 	./ansi2knr $(srcdir)/$*.c T$*.c
+# 	$(CC) $(CFLAGS) -c T$*.c
+# 	$(RM) $(RMFLAGS) T$*.c $*.o
+# 	$(MV) T$*.o $*.o
+
+ansi2knr: ansi2knr.c
+	$(CC) $(CFLAGS) $(ANSI2KNRFLAGS) -o ansi2knr ansi2knr.c
+
+# Uncomment the following line if you don't have an ANSI compilier
+# and comment out the one below it
+#libjpeg.a: @ANSI2KNR@ $(LIBOBJECTS)
+libjpeg.a: $(LIBOBJECTS)
+	$(RM) $(RMFLAGS) libjpeg.a
+	$(AR) $(ARFLAGS) libjpeg.a  $(LIBOBJECTS)
+	$(AR2) libjpeg.a
--- HDF-4.1r4/mfhdf/fortran/config/ftest-darwin.f	Mon Sep 17 06:40:42 2001
+++ HDF-4.1r4/mfhdf/fortran/config/ftest-darwin.f	Mon May  7 11:51:42 2001
@@ -0,0 +1,1220 @@
+c********************************************************************
+c   Copyright 1993, UCAR/Unidata
+c   See netcdf/COPYRIGHT file for copying and redistribution conditions.
+c   $Id: hdf-4.1r4-2.patch,v 1.1 2001/09/19 14:46:18 jswhit Exp $
+c********************************************************************/
+
+
+
+c
+c     program to test the Sun Fortran jacket interface to the netCDF
+c
+      program ftest
+      
+      include 'netcdf.inc'
+
+c     name of first test cdf
+      character*31 name
+c     name of second test cdf
+      character*31 name2
+      
+c     Returned error code.
+      integer iret 
+c     netCDF ID
+      integer ncid
+c     ID of dimension lat
+      integer  latdim
+c     ID of dimension lon
+      integer londim
+c     ID of dimension level
+      integer leveldim
+c     ID of dimension time
+      integer timedim
+c     ID of dimension len
+      integer lendim
+
+c     variable used to control error-handling behavior
+      integer ncopts
+      integer dimsiz(MAXNCDIM)
+C      allowable roundoff 
+      real epsilon
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+      data name/'test.nc'/
+      data name2/'copy.nc'/
+      data epsilon /.000001/
+      
+100   format('*** Testing ', a, ' ...')
+c     set error-handling to verbose and non-fatal
+      ncopts = NCVERBOS
+      call ncpopt(ncopts)
+
+c     create a netCDF named 'test.nc'
+      write(*,100) 'nccre'
+      ncid = nccre(name, NCCLOB, iret)
+
+c     test ncddef
+      write(*,100) 'ncddef'
+      call tncddef(ncid)
+
+c     test ncvdef
+      write(*,100) 'ncvdef'
+      call tncvdef(ncid)
+
+c     test ncapt
+      write(*, 100) 'ncapt, ncaptc'
+      call tncapt(ncid)
+
+c     close 'test.nc'
+      write(*, 100) 'ncclos'
+      call ncclos(ncid, iret)
+
+c     test ncvpt1
+      write(*, 100) 'ncvpt1'
+      call tncvpt1(name)
+
+c     test ncvgt1
+      write(*, 100) 'ncvgt1'
+      call tncvgt1(name)
+
+c     test ncvpt
+      write(*, 100) 'ncvpt'
+      call tncvpt(name)
+
+c     test ncinq
+      write(*, 100) 'ncopn, ncinq, ncdinq, ncvinq, ncanam, ncainq'
+      call tncinq(name)
+
+c     test ncvgt
+      write(*, 100) 'ncvgt, ncvgtc'
+      call tncvgt(name)
+
+c     test ncagt
+      write(*, 100) 'ncagt, ncagtc'
+      call tncagt(name)
+
+c     test ncredf
+      write(*, 100) 'ncredf, ncdren, ncvren, ncaren, ncendf'
+      call tncredf(name)
+
+      call tncinq(name)
+
+c     test ncacpy
+      write(*, 100) 'ncacpy'
+      call tncacpy(name, name2)
+
+c     test ncadel
+      write(*, 100) 'ncadel'
+      call tncadel(name2)
+      end
+c
+c     subroutine to test ncacpy
+c
+      subroutine tncacpy(iname, oname)
+      character*31 iname, oname
+      include 'netcdf.inc'
+      integer ndims, nvars, natts, recdim, iret
+      character*31 vname, attnam
+      integer attype, attlen
+      integer vartyp, nvdims, vdims(MAXVDIMS), nvatts
+      integer lenstr
+c     existing netCDF id
+      integer incdf
+c     netCDF id of the output netCDF file to which the attribute
+c     will be copied
+      integer outcdf
+
+      integer mattlen
+      parameter (mattlen = 80)
+      character*80 charval
+      double precision doubval(2)
+      real flval(2)
+      integer lngval(2)
+      integer*2 shval(2)
+      integer i, j, k
+      character*31 varnam, attname(2,7), gattnam(2)
+      byte bytval(2)
+      common /atts/attname, gattnam
+      integer*2 svalidrg(2)
+      real rvalidrg(2)
+      integer lvalidrg(2)
+      double precision dvalidrg(2)
+      byte bvalidrg(2)
+      character*31 gavalue(2), cavalue(2)
+      real epsilon
+
+      data bvalidrg/1,110/
+      data svalidrg/-100,100/
+      data lvalidrg/0,360/
+      data rvalidrg/0.0, 5000.0/
+      data dvalidrg/0D0,500D0/
+      data gavalue/'NWS', '88/10/25 12:00:00'/
+      data cavalue/'test string', 'a'/
+      data lenstr/80/	
+      data epsilon /.000001/
+
+      incdf = ncopn(iname, NCNOWRIT, iret)
+      outcdf = nccre(oname, NCCLOB, iret)
+      call tncddef(outcdf)
+      call tncvdef(outcdf)
+      call ncinq (incdf, ndims, nvars, natts, recdim, iret)
+      do 5 j = 1, natts
+         call ncanam (incdf, NCGLOBAL, j, attnam, iret)
+         call ncacpy (incdf, NCGLOBAL, attnam, outcdf, NCGLOBAL, iret)
+ 5    continue
+      do 10 i = 1, nvars
+         call ncvinq (incdf, i, vname, vartyp, nvdims,
+     +        vdims, nvatts, iret)
+         do 20 k = 1, nvatts
+            call ncanam (incdf, i, k, attnam, iret)
+            call ncacpy (incdf, i, attnam, outcdf, i, iret)
+ 20      continue
+ 10   continue
+c     
+c     get global attributes first
+c     
+      do 100 i = 1, natts
+         call ncanam (outcdf, NCGLOBAL, i, attnam, iret)
+         call ncainq (outcdf, NCGLOBAL, attnam, attype, attlen,
+     +        iret)
+         if (attlen .gt. mattlen) then
+            write (*,*) 'global attribute too big!', attlen, mattlen
+            stop 'Stopped'
+         else if (attype .eq. NCBYTE) then
+            call ncagt (outcdf, NCBYTE, attnam, bytval, iret)
+         else if (attype .eq. NCCHAR) then
+            call ncagtc (outcdf, NCGLOBAL, attnam, charval, 
+     +           lenstr, iret)
+            if (attnam .ne. gattnam(i)) write(*,*) 'error in ncagt G'
+            if (charval .ne. gavalue(i))
+     + write(*,*) 'error in ncagt G2', lenstr, charval, gavalue(i)
+                  charval = ' '                                    
+         else if (attype .eq. NCSHORT) then
+            call ncagt (outcdf, NCGLOBAL, attnam, shval, iret) 
+         else if (attype .eq. NCLONG) then
+            call ncagt (outcdf, NCGLOBAL, attnam, lngval, iret)            
+         else if (attype .eq. NCFLOAT) then
+            call ncagt (outcdf, NCGLOBAL, attnam, flval, iret)
+         else 
+            call ncagt (outcdf, NCGLOBAL, attnam, doubval,iret)          
+         end if
+ 100   continue
+c
+c     get variable attributes
+c
+      do 200 i = 1, nvars
+         call ncvinq (outcdf, i, varnam, vartyp, nvdims, vdims,
+     +                nvatts, iret)
+         do 250 j = 1, nvatts
+            call ncanam (outcdf, i, j, attnam, iret)
+            call ncainq (outcdf, i, attnam, attype, attlen,
+     +                   iret)
+            if (attlen .gt. mattlen) then
+               write (*,*) 'variable ', i,  'attribute too big !'
+               stop 'Stopped'
+            else 
+               if (attype .eq. NCBYTE) then
+                  call ncagt (outcdf, i, attnam, bytval, 
+     +                 iret)
+                  if (attnam .ne. attname(j,i))
+     +       write(*,*) 'error in ncagt BYTE N'
+                  if (bytval(j) .ne. bvalidrg(j)) write(*,*)
+     + 'ncacpy: byte ', bytval(j), ' .ne. ', bvalidrg(j)
+               else if (attype .eq. NCCHAR) then
+                  call ncagtc (outcdf, i, attnam, charval, 
+     +                 lenstr, iret)
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     +  'error in ncagt CHAR N'
+                  if (charval .ne. cavalue(j)) write(*,*)
+     +  'error in ncagt'
+                  charval = ' '                                   
+               else if (attype .eq. NCSHORT) then
+                  call ncagt (outcdf, i, attnam, shval, 
+     +                 iret)  
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt SHORT N'
+                  if (shval(j) .ne. svalidrg(j)) then
+                     write(*,*) 'error in ncagt SHORT'
+                  end if
+               else if (attype .eq. NCLONG) then
+                  call ncagt (outcdf, i, attnam, lngval, 
+     +                 iret)
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt LONG N'
+                  if (lngval(j) .ne. lvalidrg(j)) write(*,*)
+     + 'error in ncagt LONG'
+               else if (attype .eq. NCFLOAT) then
+                  call ncagt (outcdf, i, attnam, flval, 
+     +                 iret)            
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt FLOAT N'
+                  if (flval(j) .ne. rvalidrg(j)) write(*,*)
+     + 'error in ncagt FLOAT'
+               else if (attype .eq. NCDOUBLE) then
+                  call ncagt (outcdf, i, attnam, doubval,
+     +                 iret)          
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt DOUBLE N'
+                  if ( abs(doubval(j) - dvalidrg(j)) .gt. epsilon)
+     + write(*,*) 'error in ncagt DOUBLE'
+               end if
+            end if
+ 250     continue
+ 200   continue
+      call ncclos(incdf, iret)
+      call ncclos(outcdf, iret)
+      return
+      end
+
+
+      
+c     
+c     subroutine to test ncadel
+c
+      subroutine tncadel (cdfname)
+      character*31 cdfname
+      include 'netcdf.inc'
+      
+      integer  bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+      integer ncid, iret, i, j
+      integer ndims, nvars, natts, recdim
+      integer vartyp, nvdims, vdims(MAXVDIMS), nvatts
+      character*31 varnam, attnam
+
+      ncid = ncopn(cdfname, NCWRITE, iret)
+c     put cdf in define mode
+      call ncredf (ncid,iret)
+c     get number of global attributes
+      call ncinq (ncid, ndims, nvars, natts, recdim, iret)
+      do 10 i = natts, 1, -1
+c     get name of global attribute
+         call ncanam (ncid, NCGLOBAL, i, attnam, iret)
+c     delete global attribute
+         call ncadel (ncid, NCGLOBAL, attnam, iret)
+ 10   continue
+
+      do 100 i = 1, nvars
+c     get number of variable attributes
+         call ncvinq (ncid, i, varnam, vartyp, nvdims, vdims,
+     +        nvatts, iret)
+         do 200 j = nvatts, 1, -1
+            call ncanam (ncid, i, j, attnam, iret)
+            call ncadel (ncid, i, attnam, iret)
+ 200     continue
+ 100  continue
+      call ncinq (ncid, ndims, nvars, natts, recdim, iret)
+      if (natts .ne. 0) write(*,*) 'error in ncadel'
+c     put netCDF into data mode
+      call ncendf (ncid, iret)
+      call ncclos (ncid, iret)
+      return
+      end
+
+c
+c     subroutine to test ncagt and ncagtc
+
+      subroutine tncagt(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+            
+c     maximum length of an attribute
+      integer mattlen
+      parameter (mattlen = 80)
+      integer ncid, ndims, nvars, natts, recdim
+      integer bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+      integer i, j
+      integer attype, attlen, lenstr, iret
+      character*31 attnam
+      character*80 charval
+      double precision doubval(2)
+      real flval(2)
+      integer lngval(2)
+      integer*2 shval(2)
+      byte bytval(2)
+      integer vartyp, nvdims, vdims(MAXVDIMS), nvatts
+
+      character*31 varnam, attname(2,7), gattnam(2)
+      common /atts/attname, gattnam
+      integer*2 svalidrg(2)
+      real rvalidrg(2)
+      integer lvalidrg(2)
+      double precision dvalidrg(2)
+      byte bvalidrg(2)
+      character*31 gavalue(2), cavalue(2)
+      real epsilon
+
+      data bvalidrg/1,110/
+      data svalidrg/-100,100/
+      data lvalidrg/0,360/
+      data rvalidrg/0.0, 5000.0/
+      data dvalidrg/0D0,500D0/
+      data gavalue/'NWS', '88/10/25 12:00:00'/
+      data cavalue/'test string', 'a'/
+      data lenstr/80/	
+      data epsilon /.000001/
+      
+      ncid = ncopn (cdfname, NCNOWRIT, iret)
+      call ncinq (ncid, ndims, nvars, natts, recdim, iret)
+c     
+c     get global attributes first
+c     
+      do 10 i = 1, natts
+c     get name of attribute
+         call ncanam (ncid, NCGLOBAL, i, attnam, iret)
+c     get attribute type and length
+         call ncainq (ncid, NCGLOBAL, attnam, attype, attlen,
+     +        iret)
+         if (attlen .gt. mattlen) then
+            write (*,*) 'global attribute too big!'
+            stop 'Stopped'
+         else if (attype .eq. NCBYTE) then
+            call ncagt (ncid, NCBYTE, attnam, bytval, iret)
+         else if (attype .eq. NCCHAR) then
+            call ncagtc (ncid, NCGLOBAL, attnam, charval, 
+     +           lenstr, iret)
+            if (attnam .ne. gattnam(i)) write(*,*) 'error in ncagt'
+            if (charval .ne. gavalue(i)) write(*,*) 'error in ncagt'
+            charval = '                                        '
+         else if (attype .eq. NCSHORT) then
+            call ncagt (ncid, NCGLOBAL, attnam, shval, iret) 
+         else if (attype .eq. NCLONG) then
+            call ncagt (ncid, NCGLOBAL, attnam, lngval, iret)            
+         else if (attype .eq. NCFLOAT) then
+            call ncagt (ncid, NCGLOBAL, attnam, flval, iret)
+         else 
+            call ncagt (ncid, NCGLOBAL, attnam, doubval,iret)          
+         end if
+ 10   continue
+
+c
+c     get variable attributes
+c
+      do 20 i = 1, nvars
+         call ncvinq (ncid, i, varnam, vartyp, nvdims, vdims,
+     +                nvatts, iret)
+         do 25 j = 1, nvatts
+            call ncanam (ncid, i, j, attnam, iret)
+            call ncainq (ncid, i, attnam, attype, attlen,
+     +                   iret)
+            if (attlen .gt. mattlen) then
+               write (*,*) 'variable ', i,  'attribute too big !'
+               stop 'Stopped'
+            else 
+               if (attype .eq. NCBYTE) then
+                  call ncagt (ncid, i, attnam, bytval, 
+     +                 iret)
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt BYTE name'
+                  if (bytval(j) .ne. bvalidrg(j)) write(*,*)
+     + 'ncacpy: byte ', bytval(j), ' .ne. ', bvalidrg(j)
+               else if (attype .eq. NCCHAR) then
+                  call ncagtc (ncid, i, attnam, charval, 
+     +                 lenstr, iret)
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt CHAR name'
+                  if (charval .ne. cavalue(j)) write(*,*)
+     + 'error in ncagt CHAR name'
+	         charval = '                                        '
+               else if (attype .eq. NCSHORT) then
+                  call ncagt (ncid, i, attnam, shval, 
+     +                 iret)  
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt SHORT name'
+                  if (shval(j) .ne. svalidrg(j)) then
+                     write(*,*) 'error in ncagt SHORT'
+                  end if
+               else if (attype .eq. NCLONG) then
+                  call ncagt (ncid, i, attnam, lngval, 
+     +                 iret)
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt LONG name'
+                  if (lngval(j) .ne. lvalidrg(j)) write(*,*)
+     + 'error in ncagt LONG'
+               else if (attype .eq. NCFLOAT) then
+                  call ncagt (ncid, i, attnam, flval, 
+     +                 iret)            
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt FLOAT name'
+                  if (flval(j) .ne. rvalidrg(j)) write(*,*)
+     + 'error in ncagt FLOAT'
+               else if (attype .eq. NCDOUBLE) then
+                  call ncagt (ncid, i, attnam, doubval,
+     +                 iret)          
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt DOUBLE name'
+                  if ( abs(doubval(j) - dvalidrg(j)) .gt. epsilon)
+     + write(*,*) 'error in ncagt DOUBLE'
+               end if
+            end if
+ 25      continue
+ 20   continue
+      call ncclos(ncid, iret)
+      return
+      end
+c
+c     subroutine to test ncapt
+c
+      subroutine tncapt (ncid)
+      include 'netcdf.inc'
+      integer ncid, iret
+
+c attribute vectors
+      integer*2 svalidrg(2)
+      real rvalidrg(2)
+      integer lvalidrg(2)
+      double precision dvalidrg(2)
+      byte bvalidrg(2)
+
+c     variable ids
+      integer  bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+
+c assign attributes
+      
+c
+c     byte
+c
+      
+      bvalidrg(1) = 1
+      bvalidrg(2) = 250
+      call ncapt (ncid, bid, 'validrange', NCBYTE, 2,
+     +bvalidrg, iret)
+
+c
+c     short
+c
+
+      svalidrg(1) = -100
+      svalidrg(2) = 100
+      call ncapt (ncid, sid, 'validrange', NCSHORT, 2, 
+     +svalidrg, iret)
+
+c
+c     long
+c
+
+      lvalidrg(1) = 0
+      lvalidrg(2) = 360
+      call ncapt (ncid, lid, 'validrange', NCLONG, 2,
+     +lvalidrg, iret)
+      
+c
+c     float
+c
+
+      rvalidrg(1) = 0.0
+      rvalidrg(2) = 5000.0
+      call ncapt (ncid, fid, 'validrange', NCFLOAT, 2,
+     +rvalidrg, iret)
+
+c
+c     double
+c
+
+      dvalidrg(1) = 0D0
+      dvalidrg(2) = 500D0
+      call ncapt (ncid, did, 'validrange', NCDOUBLE, 2,
+     +dvalidrg, iret)
+
+c
+c     global
+c
+
+      call ncaptc (ncid, NCGLOBAL, 'source', NCCHAR, 3, 
+     +'NWS', iret)
+      call ncaptc (ncid, NCGLOBAL, 'basetime', NCCHAR, 17, 
+     +'88/10/25 12:00:00', iret)
+
+c
+c     char
+c
+
+      call ncaptc (ncid, chid, 'longname', NCCHAR, 11,
+     +'test string', iret)
+
+      call ncaptc (ncid, chid, 'id', NCCHAR, 1,
+     +'a', iret)
+
+      return
+      end
+
+c
+c     initialize variables in labelled common blocks
+c
+      block data
+      common /cdims/ dimnam
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+      common /varn/varnam
+      common /atts/attname, gattnam
+      integer  latdim, londim, leveldim, timedim, lendim
+
+c     should include 'netcdf.inc' for MAXNCDIM, but it has EXTERNAL
+c     declaration, which is not permitted in a BLOCK DATA unit.
+
+c      integer dimsiz(MAXNCDIM)
+      integer dimsiz(32)
+c      character*31 dimnam(MAXNCDIM)
+      character*31 dimnam(32)
+      character*31 varnam(7)
+      character*31 attname(2,7)
+      character*31 gattnam(2)
+
+      data dimnam /'time', 'lat', 'lon', 'level',
+     + 'length', 27*'0'/
+      data dimsiz /4, 5, 5, 4, 80, 27*0/
+      data varnam/'bytev', 'shortv', 'longv', 'floatv', 'doublev', 
+     + 'chv', 'cv'/
+      
+      data attname/'validrange', '0', 'validrange', '0', 'validrange',
+     + '0', 'validrange', '0', 'validrange', '0', 'longname', 'id',
+     + '0', '0'/
+      data gattnam/'source','basetime'/
+      end
+
+
+c
+c     subroutine to test ncddef
+c
+
+      subroutine tncddef(ncid)
+      include 'netcdf.inc'
+      integer ncid
+
+c     sizes of dimensions of 'test.nc' and 'copy.nc'
+      integer  ndims
+      parameter(ndims=5)
+c dimension ids
+      integer  latdim, londim, leveldim, timedim, lendim
+      integer iret
+c     function to define a netCDF dimension
+      integer dimsiz(MAXNCDIM)
+      character*31 dimnam(MAXNCDIM)
+      
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+      common /cdims/ dimnam
+
+c define dimensions
+      timedim = ncddef(ncid, dimnam(1), NCUNLIM, iret)
+      latdim = ncddef(ncid, dimnam(2), dimsiz(2), iret)
+      londim = ncddef(ncid, dimnam(3), dimsiz(3), iret)
+      leveldim = ncddef(ncid, dimnam(4), dimsiz(4), iret)
+      lendim = ncddef(ncid, dimnam(5), dimsiz(5), iret)
+      return
+      end
+c
+c     subroutine to test ncinq, ncdinq, ncdid, ncvinq, ncanam
+c     and ncainq
+c
+      subroutine tncinq(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+
+c     netCDF id
+      integer ncid
+c     returned number of dimensions
+      integer ndims
+c     returned number of variables
+      integer nvars
+c     returned number of global attributes
+      integer natts
+c     returned id of the unlimited dimension
+      integer recdim
+c     returned error code
+      integer iret
+c     returned name of record dimension
+      character*31 recnam
+c     returned size of record dimension
+      integer recsiz
+c     loop control variables
+      integer i, j, k
+c     returned size of dimension
+      integer dsize
+c     returned dimension ID
+      integer dimid
+c     returned dimension name
+      character*31 dname
+c     returned variable name
+      character*31 vname
+c     returned attribute name
+      character*31 attnam
+c     returned netCDF datatype of variable
+      integer vartyp
+c     returned number of variable dimensions
+      integer nvdims
+c     returned number of variable attributes
+      integer nvatts
+c     returned vector of nvdims dimension IDS corresponding to the
+c     variable dimensions
+      integer vdims(MAXNCDIM)
+c     returned attribute length
+      integer attlen
+c     returned attribute type
+      integer attype
+      character*31 dimnam(MAXNCDIM)
+      character*31 varnam(7)
+      character*31 attname(2,7)
+      character*31 gattnam(2)
+      integer vdlist(5,7), vtyp(7), vndims(7), vnatts(7)
+      integer attyp(2,7),atlen(2,7),gattyp(2),gatlen(2)
+      integer timedim,latdim,londim,leveldim,lendim
+      integer dimsiz(MAXNCDIM)
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+      common /varn/varnam
+      common /atts/attname, gattnam
+      common /cdims/ dimnam
+
+      data vdlist/1,0,0,0,0,1,0,0,0,0,2,0,0,0,0,4,3,2,1,0,4,3,2,1,0,
+     + 5,1,0,0,0,1,0,0,0,0/
+      data vtyp/NCBYTE, NCSHORT, NCLONG, NCFLOAT, NCDOUBLE, NCCHAR,
+     + NCCHAR/
+      data vndims/1,1,1,4,4,2,1/
+      data vnatts/1,1,1,1,1,2,0/
+      data attyp/NCBYTE, 0, NCSHORT, 0, NCLONG, 0, NCFLOAT, 0,
+     + NCDOUBLE, 0, NCCHAR, NCCHAR, 0, 0/
+      data atlen/2,0,2,0,2,0,2,0,2,0,11,1, 0, 0/
+      data gattyp/NCCHAR,NCCHAR/
+      data gatlen/3,17/
+
+      ncid = ncopn (cdfname, NCNOWRIT, iret)
+      call ncinq (ncid, ndims, nvars, natts, recdim, iret)
+      if (ndims .ne. 5) write(*,*) 'error in ncinq or ncddef'
+      if (nvars .ne. 7) write(*,*) 'error in ncinq or ncvdef'
+      if (natts .ne. 2) write(*,*) 'error in ncinq or ncapt'
+      call ncdinq (ncid, recdim, recnam, recsiz, iret)
+      if (recnam .ne. 'time') write(*,*) 'error: bad recdim from ncinq'
+c
+c     dimensions
+c
+      do 10 i = 1, ndims
+         call ncdinq (ncid, i, dname, dsize, iret)
+         if (dname .ne. dimnam(i)) write(*,*)
+     + 'error in ncdinq or ncddef, dname=', dname
+         if (dsize .ne. dimsiz(i)) write(*,*)
+     + 'error in ncdinq or ncddef, dsize=',dsize
+         dimid = ncdid (ncid, dname, iret)
+         if (dimid .ne. i) write(*,*)
+     +      'error in ncdinq or ncddef, dimid=', dimid
+ 10   continue
+c
+c     variables
+c
+      do 30 i = 1, nvars
+         call ncvinq (ncid, i, vname, vartyp, nvdims,
+     +        vdims, nvatts, iret)
+         if (vname .ne. varnam(i)) write(*,*)
+     +  'error: from ncvinq, wrong  name returned: ', vname,
+     +  ' .ne. ', varnam(i)
+         if (vartyp .ne. vtyp(i)) write(*,*)
+     + 'error: from ncvinq, wrong type returned: ', vartyp,
+     + ' .ne. ', vtyp(i)
+         if (nvdims .ne. vndims(i)) write(*,*)
+     + 'error: from ncvinq, wrong num dims returned: ', vdims,
+     + ' .ne. ', vndims(i)
+         do 35 j = 1, nvdims
+            if (vdims(j) .ne. vdlist(j,i)) write(*,*)
+     + 'error: from ncvinq wrong dimids: ', vdims(j),
+     + ' .ne. ', vdlist(j,i)
+ 35      continue
+         if (nvatts .ne. vnatts(i)) write(*,*)
+     + 'error in ncvinq or ncvdef'
+c
+c     attributes
+c
+         do 45 k = 1, nvatts
+            call ncanam (ncid, i, k, attnam, iret)
+            call ncainq (ncid, i, attnam, attype, attlen, iret)
+            if (attnam .ne. attname(k,i)) write(*,*)
+     + 'error in ncanam or ncapt'
+            if (attype .ne. attyp(k,i)) write(*,*)
+     + 'error in ncainq or ncapt'
+            if (attlen .ne. atlen(k,i)) write(*,*)
+     + 'error in ncainq or ncapt'
+ 45      continue
+ 30   continue
+      do 40 i = 1, natts
+         call ncanam (ncid, NCGLOBAL, i, attnam, iret)
+         call ncainq (ncid, NCGLOBAL, attnam, attype, attlen, iret)
+         if (attnam .ne. gattnam(i)) write(*,*)
+     + 'error in ncanam or ncapt'
+         if (attype .ne. gattyp(i)) write(*,*)
+     + 'error in ncainq or ncapt'
+         if (attlen .ne. gatlen(i)) write(*,*)
+     + 'error in ncainq or ncapt'
+ 40   continue
+      call ncclos(ncid, iret)
+      return
+      end
+      
+      
+      
+c     subroutine to test ncredf, ncdren, ncvren, ncaren, and 
+c     ncendf
+
+      subroutine tncredf(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+      character*31 attname(2,7)
+      character*31 gattnam(2)
+      common /atts/attname, gattnam
+      common /cdims/ dimnam
+      character*31 dimnam(MAXNCDIM)
+      character*31 varnam(7)
+      common /varn/varnam
+      integer ncid, iret, latid, varid
+
+      dimnam(2) = 'latitude'
+      varnam(4) = 'realv'
+      attname(1,6) = 'stringname'
+      gattnam(1) = 'agency'
+      ncid = ncopn(cdfname, NCWRITE, iret)
+      call ncredf(ncid, iret)
+      latid = ncdid(ncid, 'lat', iret)
+      call ncdren(ncid, latid, 'latitude', iret)
+      varid = ncvid(ncid, 'floatv', iret)
+      call ncvren(ncid, varid, 'realv', iret)
+      varid = ncvid(ncid, 'chv', iret)
+      call ncaren(ncid, varid, 'longname', 'stringname', iret)
+      call ncaren(ncid, NCGLOBAL, 'source', 'agency', iret)
+      call ncendf(ncid, iret)
+      call ncclos(ncid, iret)
+      return
+      end
+c     
+c     subroutine to test ncvdef
+c
+
+      subroutine tncvdef(ncid)
+      include 'netcdf.inc'
+      integer ncid
+
+c     function to define a netCDF variable
+      integer dimsiz(MAXNCDIM)
+      integer  latdim, londim, leveldim, timedim, lendim
+      common /dims/timedim, latdim, londim, leveldim, lendim, 
+     + dimsiz
+
+c variable ids
+      integer  bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+
+c variable shapes
+      integer  bdims(1), fdims(4), ddims(4), ldims(1), sdims(1) 
+      integer chdims(2), cdims(1)
+
+      integer iret
+c
+c define variables
+c
+c     byte
+c 
+      bdims(1) = timedim
+      bid = ncvdef(ncid, 'bytev', NCBYTE, 1, bdims, iret)
+c
+c     short
+c
+      sdims(1) = timedim
+      sid = ncvdef (ncid, 'shortv', NCSHORT, 1, sdims, iret)
+c
+c     long
+c
+      ldims(1) = latdim
+      lid = ncvdef (ncid, 'longv', NCLONG, 1, ldims, iret)
+c
+c     float
+c
+      fdims(4) = timedim
+      fdims(1) = leveldim
+      fdims(2) = londim
+      fdims(3) = latdim
+      fid = ncvdef (ncid, 'floatv', NCFLOAT, 4, fdims, iret)
+c
+c     double
+c
+      ddims(4) = timedim
+      ddims(1) = leveldim
+      ddims(2) = londim
+      ddims(3) = latdim
+      did = ncvdef (ncid, 'doublev', NCDOUBLE, 4, ddims, iret)
+c
+c     char
+c
+      chdims(2) = timedim
+      chdims(1) = lendim
+      chid = ncvdef (ncid, 'chv', NCCHAR, 2, chdims, iret)
+
+      cdims(1) = timedim
+      cid = ncvdef (ncid, 'cv', NCCHAR, 1, cdims, iret)
+
+
+      return
+      end
+
+
+c    
+c     subroutine to test ncvgt and ncvgtc
+c
+      subroutine tncvgt(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+
+      integer ndims, times, lats, lons, levels, lenstr
+      parameter (times=4, lats=5, lons=5, levels=4)
+
+      integer start(MAXNCDIM), count(MAXNCDIM)
+      integer ncid, iret, i, m
+      integer  latdim, londim, leveldim, timedim, lendim
+      integer dimsiz(MAXNCDIM)
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+
+      integer bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+      integer itime, ilev, ilat, ilon
+
+c     arrays of data values to be read
+      byte barray(times), byval(times)
+      integer*2 sarray(times), shval(times)
+      integer larray(lats)
+      real farray(levels, lats, lons, times)
+      double precision darray(levels, lats, lons, times)
+c     character array of data values to be read
+      character*31 string
+      character*31 varnam
+      integer nvars, natts, recdim
+      integer vartyp, nvdims, vdims(MAXVDIMS), nvatts
+
+      data start/1,1,1,1, 28*0/, count/levels, lats, lons, times, 28*0/
+      data byval /97, 98, 99, 100/
+      data shval /10, 11, 12, 13/
+
+      ncid = ncopn (cdfname, NCWRITE, iret)
+c     get number of variables in netCDF
+      call ncinq (ncid, ndims, nvars, natts, recdim, iret)
+      do 5 m = 1, nvars-1
+c     get variable name, datatype, number of dimensions
+c     vector of dimension ids, and number of variable attributes
+         call ncvinq (ncid, m, varnam, vartyp, nvdims, vdims,
+     +                nvatts, iret)
+         if (vartyp .eq. NCBYTE) then
+c
+c     byte
+c
+            count(1) = times
+            call ncvgt (ncid, m, start, count, barray, iret)
+            do 10 i = 1, times
+               if (barray(i) .ne. byval(i)) then 
+                  write(*,*) 'ncvgt of bytes, got ', barray(i), ' .ne. '
+     +			     , byval(i)
+               end if
+ 10         continue
+         else if (vartyp .eq. NCSHORT) then
+c
+c     short
+c
+            count(1) = times
+            call ncvgt (ncid, m, start, count, sarray, iret)
+            do 20 i = 1, times
+               if (sarray(i) .ne. shval(i)) then 
+                  write(*,*) 'ncvgt of short, got ', sarray(i), ' .ne. '
+     +			     , shval(i)
+               end if
+ 20         continue
+         else if (vartyp .eq. NCLONG) then
+c     
+c     long
+c
+            count(1) = lats
+            call ncvgt (ncid, m, start, count, larray, iret)
+            do 30 i = 1, lats
+               if (larray(i) .ne. 1000) then 
+                  write(*,*) 'long error in ncvgt'
+               end if
+ 30         continue
+         else if (vartyp .eq. NCFLOAT) then
+c     
+c     float
+c
+            count(1) = levels
+            call ncvgt (ncid, m, start, count, farray, iret)
+            i = 0
+            do 40 itime = 1,times
+               do 40 ilon = 1, lons
+                  do 40 ilat = 1, lats
+                     do 40 ilev = 1, levels
+                        i = i + 1
+                        if (farray(ilev, ilat, ilon, itime) .ne.
+     + real(i)) then
+                           write (*,*) 'float error in ncvgt'
+                        end if
+ 40         continue
+         else if (vartyp .eq. NCDOUBLE) then
+c
+c     double
+c
+            count(1) = levels
+            call ncvgt (ncid, m, start, count, darray, iret)
+            i = 0
+            do 50 itime = 1, times
+               do 50 ilon = 1, lons
+                  do 50 ilat = 1, lats
+                     do 50 ilev = 1, levels
+                        i = i + 1
+                        if (darray(ilev, ilat, ilon, itime) .ne.
+     +                       real(i)) then
+                           write(*,*) 'double error in ncvgt:', i,
+     +              darray(ilev, ilat, ilon, itime), '.ne.', real(i)
+                        end if
+ 50         continue
+         else 
+c     
+c     char
+c
+	    count(1) = 3
+	    count(2) = 4
+	    lenstr = 31
+            call ncvgtc (ncid, m, start, count, string, lenstr, iret)
+            if (string .ne. 'testhikin of') then 
+               write(*,*) 'error in ncvgt, returned string =', string
+            end if
+         end if
+ 5    continue
+      call ncclos(ncid, iret)
+      return
+      end
+
+      
+      subroutine tncvgt1(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+
+      integer ncid, iret
+      integer  latdim, londim, leveldim, timedim, lendim
+      integer dimsiz(MAXNCDIM)
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+
+      integer bindx, sindx, lindx, findx(4), dindx(4), cindx
+
+      integer bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+
+      byte bvalue
+      integer*2 svalue
+      integer lvalue
+      real fvalue
+      double precision dvalue
+      character*1 c
+      real epsilon
+      double precision onethird
+
+      data epsilon /.000001/
+      data lindx/1/, bindx/1/, sindx/1/, findx/1,1,1,1/
+     +dindx/1,1,1,1/, cindx/1/
+      data onethird/0.3333333333D0/
+      
+      ncid = ncopn (cdfname, NCNOWRIT, iret)
+c
+c     test ncvgt1 for byte
+c
+      call ncvgt1 (ncid, bid, bindx, bvalue, iret)
+      if (bvalue .ne. ichar('z')) write(*,*) 'error in ncvgt1 byte:',
+     + bvalue, ' .ne.', ichar('z')
+c
+c     test ncvgt1 for short
+c
+      call ncvgt1 (ncid, sid, sindx, svalue, iret)
+      if (svalue .ne. 10) write(*,*) 'error in ncvgt1 short:',
+     + svalue, ' .ne.', 10
+c     
+c     test ncvgt1 for long
+c
+      call ncvgt1 (ncid, lid, lindx, lvalue, iret)
+      if (lvalue .ne. 1000) write(*,*) 'error in ncvgt1 long:',
+     + lvalue,  ' .ne.', 1000
+c
+c     test ncvgt1 for float
+c
+      call ncvgt1 (ncid, fid, findx, fvalue, iret)
+      if (abs(fvalue - 3.14159) .gt. epsilon) write(*,*)
+     + 'error in ncvgt1 float:', fvalue, ' not close to', 3.14159
+c
+c     test ncvgt1 for double
+c
+      call ncvgt1 (ncid, did, dindx, dvalue, iret)
+      if (abs(dvalue - onethird) .gt. epsilon) write(*,*)
+     + 'error in ncvgt1 double:', dvalue, ' not close to',
+     +     onethird
+c
+c     test ncvg1c for char
+c
+      call ncvg1c (ncid, cid, cindx, c, iret)
+      if (c .ne. 'a') write(*,*) 'error in ncvg1c'
+      call ncclos(ncid, iret)
+      return
+      end
+
+      
+      
+c
+c     subroutine to test ncvpt and ncvptc
+c
+      subroutine tncvpt(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+
+c     size of dimensions
+      integer times, lats, lons, levels
+      parameter (times=4, lats=5, lons=5, levels=4)
+
+      integer ncid, iret
+c     loop control variables
+      integer itime, ilev, ilon, ilat, i
+      integer  latdim, londim, leveldim, timedim, lendim
+      integer dimsiz(MAXNCDIM)
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+      integer lenstr
+      integer bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+
+c     vector of integers specifying the corner of the  hypercube
+c     where the first of the data values will be written
+      integer start(MAXNCDIM)
+c     vector of integers specifying the edge lengths from the
+c     corner of the hypercube where the first of the data values
+c     will be written
+      integer count(MAXNCDIM)
+
+c     arrays of data values to be written
+      byte barray(times)
+      integer*2 sarray(times)
+      integer larray(lats)
+      real farray(levels, lats, lons, times)
+      double precision darray(levels, lats, lons, times)
+      character*31 string
+
+      data start/1,1,1,1, 28*0/, count/levels, lats, lons, times, 28*0/
+      data barray /97, 98, 99, 100/
+      data sarray /10, 11, 12, 13/
+
+      ncid = ncopn (cdfname, NCWRITE, iret)
+
+c
+c     byte
+c
+      count(1) = times
+      call ncvpt (ncid, bid, start, count, barray, iret)
+c
+c     short
+c
+      count(1) = times
+      call ncvpt (ncid, sid, start, count, sarray, iret)
+c
+c     long
+c
+      do 30 i = 1,lats
+         larray(i) = 1000
+ 30   continue
+      count(1) = lats
+      call ncvpt (ncid, lid, start, count, larray, iret)
+c
+c     float
+c
+      i = 0
+      do 40 itime = 1,times
+         do 40 ilon = 1, lons
+            do 40 ilat = 1, lats
+               do 40 ilev = 1, levels
+                  i = i + 1
+                  farray(ilev, ilat, ilon, itime) = real(i)
+ 40   continue
+      count(1) = levels
+      call ncvpt (ncid, fid, start, count, farray, iret)
+c
+c     double
+c
+      i = 0
+      do 50 itime = 1, times
+         do 50 ilon = 1, lons
+            do 50 ilat = 1, lats
+               do 50 ilev = 1, levels
+                  i = i + 1
+                  darray(ilev, ilat, ilon, itime) = real(i)
+ 50   continue
+      count(1) = levels
+      call ncvpt (ncid, did, start, count, darray, iret)
+c
+c     char
+c
+      start(1) = 1
+      start(2) = 1
+      count(1) = 4
+      count(2) = 4
+      lenstr = 31	
+      string = 'testthiskind of '
+      call ncvptc (ncid, chid,start, count, string, lenstr, iret)
+      call ncclos(ncid, iret)
+      return
+      end
+
+      
+      subroutine tncvpt1(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+
+
+      integer iret, ncid
+      integer  latdim, londim, leveldim, timedim, lendim
+      integer dimsiz(MAXNCDIM)
+      common /dims/timedim, latdim, londim, leveldim, lendim, 
+     + dimsiz
+
+      integer bindx, sindx, lindx, findx(4), dindx(4), cindx
+
+      integer lvalue
+      integer*2 svalue
+      byte bvalue
+      double precision onethird
+      integer bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+      data lindx/1/, bindx/1/, sindx/1/, findx/1,1,1,1/
+     +dindx/1,1,1,1/, cindx/1/
+      data lvalue /1000/
+      data svalue/10/
+      data onethird/0.3333333333D0/
+
+      bvalue = ichar('z')
+      
+      ncid = ncopn (cdfname, NCWRITE, iret)
+c
+c     test ncvpt1 for byte
+c
+      call ncvpt1 (ncid, bid, bindx, bvalue, iret)
+c
+c     test ncvpt1 for short
+c
+      call ncvpt1 (ncid, sid, sindx, svalue, iret)
+c     
+c     test ncvpt1 for long
+c
+      call ncvpt1 (ncid, lid, lindx, lvalue, iret)
+c
+c     test ncvpt1 for float
+c
+      call ncvpt1 (ncid, fid, findx, 3.14159, iret)
+c
+c     test ncvpt1 for double
+c
+      call ncvpt1 (ncid, did, dindx, onethird, iret)
+c
+c     test ncvp1c for char
+c
+      call ncvp1c (ncid, cid, cindx, 'a', iret)
+      call ncclos (ncid, iret)
+      return
+      end
--- HDF-4.1r4/mfhdf/fortran/config/jackets-darwin.c	Mon Sep 17 06:40:42 2001
+++ HDF-4.1r4/mfhdf/fortran/config/jackets-darwin.c	Mon May  7 11:51:59 2001
@@ -0,0 +1,2196 @@
+/*
+ *	Copyright 1990, University Corporation for Atmospheric Research
+ *      See netcdf/COPYRIGHT file for copying and redistribution conditions.
+ */
+/* $Id: hdf-4.1r4-2.patch,v 1.1 2001/09/19 14:46:18 jswhit Exp $ */
+/*
+ * OVERVIEW
+ *
+ * This file contains jacket routines written in C for interfacing Fortran
+ * netCDF function calls to the actual C binding for the NetCDF.  This code
+ * is written explicitly for Sun.  In general, these functions handle
+ * character-string parameter conventions, convert between
+ * column-major-order arrays and row-major-order arrays, and map between
+ * array indices beginning at one and array indices beginning at zero.
+ *
+ */
+
+/* LINTLIBRARY */
+#include	<ctype.h>
+#include        <string.h>
+#include	<stdlib.h>
+#include	<stdio.h>
+#ifdef HDF
+#include        "local_nc.h"
+#else /* HDF */
+#include	"netcdf.h"
+#endif /* HDF */
+
+
+
+
+
+#if !NC_OLD_FILLVALUES
+
+struct ncfils {			/* This will be a common block from Fortran */
+    double dd;
+#ifdef __alpha
+    int ll;
+#else
+    long ll;
+#endif
+    float ff;
+    short ss;
+    char cc;
+    char bb;
+} ncfils_ = {
+    FILL_DOUBLE,
+    FILL_LONG,
+    FILL_FLOAT,
+    FILL_SHORT,
+    FILL_CHAR,
+    FILL_BYTE
+};
+
+#else	/* NC_OLD_FILLVALUES below */
+
+/*
+ * This section is provided for backward compatibility only.  Using
+ * XDR infinities for floating-point fill values has caused more problems
+ * than it has solved.  We encourage you to define your own data-specific
+ * fill values rather than use default ones.  
+ * If, however, you *must* use default fill values, then you should use
+ * the above fill values rather than the ones in this section.
+ */
+
+struct ncfils {			/* This will be a common block from Fortran */
+    double dd;
+#ifdef __alpha
+    int ll;
+#else
+    long ll;
+#endif
+    float ff;
+    short ss;
+    char cc;
+    char bb;
+} ncfils_ = {
+    XDR_D_INFINITY,		/* You may have to insert a constant here */
+    FILL_LONG,
+    XDR_F_INFINITY,		/* You may have to insert a constant here */
+    FILL_SHORT,
+    FILL_CHAR,
+    FILL_BYTE
+};
+
+#endif	/* NC_OLD_FILLVALUES above */
+
+
+/*
+ * global integer used for suppressing error messages and determining
+ * the fatality of errors.
+ */
+extern int ncopts;		/* default is (NC_FATAL | NC_VERBOSE) */
+
+/* global integer that contains a netCDF-specific error code */
+extern int ncerr;
+
+/* blank fill C string to make FORTRAN string */
+static void
+fcdcpy (fstring, fslen, sstring)
+    char *fstring;		/* output string to be blank-filled */
+    int fslen;			/* length of output string */
+    char *sstring;		/* input string, null-terminated */
+{
+    int i, len = strlen(sstring);
+
+    for (i = 0; i < len; i++)
+	*(fstring + i) = *(sstring + i);
+    for (i = len; i < fslen; i++)
+	*(fstring + i) = ' ';
+}
+
+
+static void
+reverse (array, length)
+    int array[];		/* array to be reversed */
+    int length;			/* length of array */
+{
+    int temp, i, j;
+
+    for (i = 0, j = length - 1; i < j; i++, j--) {
+	temp = array[i];
+	array[i] = array[j];
+	array[j] = temp;
+    }
+}
+
+
+static void
+revlongs (array, length)
+    long array[];		/* array to be reversed */
+    int length;			/* length of array */
+{
+    int i, j;
+    long temp;
+
+    for (i = 0, j = length - 1; i < j; i++, j--) {
+	temp = array[i];
+	array[i] = array[j];
+	array[j] = temp;
+    }
+}
+
+
+/* error handling function */
+static void
+handle_err (pname, rcode)
+    char *pname;		/* procedure name */
+    int rcode;			/* error return */
+{
+    cdf_routine_name = pname;
+    NCadvise(rcode, "string won't fit in CHARACTER variable provided");
+}
+
+/* copy function used to copy strings with embedded blanks */
+static void
+fstrncpy (target, source, maxlen)
+    char *target;		/* space to be copied into */
+    char *source;		/* string to be copied */
+    int maxlen;			/* maximum length of *source */
+{
+    while (maxlen-- && *source != '\0')
+	*target++ = *source++;
+    *target = '\0';
+}
+
+/* copy function used to copy strings terminated with blanks */
+static void
+nstrncpy (target, source, maxlen)
+    char *target;		/* space to be copied into */
+    char *source;		/* string to be copied */
+    int maxlen;			/* maximum length of *source */
+{
+    while (maxlen-- && *source != ' ')
+	*target++ = *source++;
+    *target = '\0';
+}
+
+
+/*
+ * Compute product of dimensions.
+ */
+static long
+dimprod (dims, ndims)
+     long *dims;			/* list of dimensions */
+     int ndims;			/* number of dimensions in list */
+{
+    long *ip;
+    long prod = 1;
+
+    for (ip = dims; ip < &dims[ndims]; ip++)
+      prod *= *ip;
+    return prod;
+}
+
+
+#ifdef FORTRAN_HAS_NO_BYTE
+/*
+ * Convert multi-dimensional array of bytes stored in ints to packed array of
+ * bytes, in malloc'ed space.  Returns pointer to bytes or NULL if malloc
+ * failed.
+ */
+static char *
+itob(ints, dims, ndims)
+     int *ints;			/* multi-dimensional array of integers */
+     long *dims;			/* list of dimensions */
+     int ndims;			/* number of dimensions in list */
+{
+    long iocount = dimprod (dims, ndims);	/* product of dimensions */
+    char *bytes = (char *) malloc (iocount * sizeof (char));
+    int *ip;
+    char *bp = bytes;
+
+    if (bytes != NULL)
+      for (ip = ints; iocount > 0; iocount--)
+	*bp++ = (char) *ip++;
+    return bytes;
+}
+
+/*
+ * Convert a generalized multi-dimensional array of bytes stored in ints to 
+ * packed array of bytes, in malloc'ed space.  Returns pointer to bytes or 
+ * NULL if malloc failed.
+ */
+static char *
+itobg(ints, dims, basis, ndims)
+     int *ints;			/* multi-dimensional array of integers */
+     long *dims;			/* list of dimensions */
+     long *basis;			/* memory access basis vector */
+     int ndims;			/* number of dimensions in list */
+{
+    long iocount = dimprod (dims, ndims);	/* product of dimensions */
+    char *bytes = (char *) malloc (iocount * sizeof (char));
+
+    if (bytes != NULL && iocount > 0) {
+	int	idim;
+	char	*bp	= bytes;
+	char	*ip	= (char*)ints;
+	long	length[MAX_NC_DIMS];
+	long	coords[MAX_NC_DIMS];
+
+	for (idim = 0; idim < ndims; ++idim) {
+	    length[idim]	= dims[idim]*basis[idim];
+	    coords[idim]	= 0;
+	}
+
+	for (;;) {
+	    *bp++	= (char)*(int*)ip;
+	    idim	= ndims - 1;
+	carry:
+	    ip	+= basis[idim];
+	    if (++coords[idim] >= dims[idim]) {
+		coords[idim]	= 0;
+		ip		-= length[idim];
+		if (--idim < 0)
+		    break;
+		goto carry;
+	    }
+        }
+    }
+
+    return bytes;
+}
+
+/*
+ * Convert a packed array of bytes into a generalized multi-dimensional array
+ * of ints.
+ */
+static void
+btoig(bytes, ints, dims, basis, ndims)
+     char *bytes;		/* packed array of bytes */
+     int *ints;			/* multi-dimensional array of integers */
+     long *dims;		/* list of dimensions */
+     long *basis;		/* memory access basis vector */
+     int ndims;			/* number of dimensions in list */
+{
+    if (dimprod (dims, ndims) > 0) {
+	int	idim;
+	char	*bp	= bytes;
+	char	*ip	= (char*)ints;
+	long	length[MAX_NC_DIMS];
+	long	coords[MAX_NC_DIMS];
+
+	for (idim = 0; idim < ndims; ++idim) {
+	    length[idim]	= dims[idim]*basis[idim];
+	    coords[idim]	= 0;
+	}
+
+	for (;;) {
+	    *(int*)ip	= *bp++;
+	    idim	= ndims - 1;
+	carry:
+	    ip	+= basis[idim];
+	    if (++coords[idim] >= dims[idim]) {
+		coords[idim]	= 0;
+		ip		-= length[idim];
+		if (--idim < 0)
+		    break;
+		goto carry;
+	    }
+        }
+    }
+}
+#endif /* FORTRAN_HAS_NO_BYTE */
+
+#ifdef FORTRAN_HAS_NO_SHORT
+/*
+ * Convert multi-dimensional array of shorts stored in ints to packed array of
+ * shorts, in malloc'ed space.  Returns pointer to shorts or NULL if malloc
+ * failed.
+ */
+static short *
+itos(ints, dims, ndims)
+     int *ints;		/* multi-dimensional array of ints */
+     long *dims;			/* list of dimensions */
+     int ndims;			/* number of dimensions in list */
+{
+    long iocount = dimprod (dims, ndims);	/* product of dimensions */
+    short *shorts = (short *) malloc (iocount * sizeof (short));
+    int *ip;
+    short *sp = shorts;
+
+    if (shorts != NULL)
+      for (ip = ints; iocount > 0; iocount--)
+	*sp++ = (short) *ip++;
+    return shorts;
+}
+
+/*
+ * Convert a generalized multi-dimensional array of shorts stored in ints to 
+ * packed array of shorts, in malloc'ed space.  Returns pointer to shorts or 
+ * NULL if malloc failed.
+ */
+static short *
+itosg(ints, dims, basis, ndims)
+     int *ints;			/* multi-dimensional array of integers */
+     long *dims;			/* list of dimensions */
+     long *basis;			/* memory access basis vector */
+     int ndims;			/* number of dimensions in list */
+{
+    long iocount = dimprod (dims, ndims);	/* product of dimensions */
+    short *shorts = (short *) malloc (iocount * sizeof (short));
+
+    if (shorts != NULL && iocount > 0) {
+	int	idim;
+	char	*ip	= (char*)ints;
+	short	*sp	= shorts;
+	long	length[MAX_NC_DIMS];
+	long	coords[MAX_NC_DIMS];
+
+	for (idim = 0; idim < ndims; ++idim) {
+	    length[idim]	= dims[idim]*basis[idim];
+	    coords[idim]	= 0;
+	}
+
+	for (;;) {
+	    *sp++	= (short)*(int*)ip;
+	    idim	= ndims - 1;
+	carry:
+	    ip	+= basis[idim];
+	    if (++coords[idim] >= dims[idim]) {
+		coords[idim]	= 0;
+		ip		-= length[idim];
+		if (--idim < 0)
+		    break;
+		goto carry;
+	    }
+        }
+    }
+
+    return shorts;
+}
+
+/*
+ * Convert a packed array of shorts into a generalized multi-dimensional array
+ * of ints.
+ */
+static void
+stoig(shorts, ints, dims, basis, ndims)
+     short *shorts;		/* packed array of shorts */
+     int *ints;			/* multi-dimensional array of integers */
+     long *dims;		/* list of dimensions */
+     long *basis;		/* memory access basis vector */
+     int ndims;			/* number of dimensions in list */
+{
+    if (dimprod (dims, ndims) > 0) {
+	int	idim;
+	short	*sp	= shorts;
+	char	*ip	= (char*)ints;
+	long	length[MAX_NC_DIMS];
+	long	coords[MAX_NC_DIMS];
+
+	for (idim = 0; idim < ndims; ++idim) {
+	    length[idim]	= dims[idim]*basis[idim];
+	    coords[idim]	= 0;
+	}
+
+	for (;;) {
+	    *(int*)ip	= *sp++;
+	    idim	= ndims - 1;
+	carry:
+	    ip	+= basis[idim];
+	    if (++coords[idim] >= dims[idim]) {
+		coords[idim]	= 0;
+		ip		-= length[idim];
+		if (--idim < 0)
+		    break;
+		goto carry;
+	    }
+        }
+    }
+}
+#endif /* FORTRAN_HAS_NO_SHORT */
+
+#ifdef __alpha
+/*
+ * Convert multi-dimensional array of NCLONGs stored in ints to packed
+ * array of longs, in malloc'ed space.  Returns pointer to longs or NULL
+ * if malloc failed.
+ */
+static long *
+itol(ints, dims, ndims)
+    int		*ints;		/* multi-dimensional array of ints */
+    long	*dims;		/* list of dimensions */
+    int		ndims;		/* number of dimensions in list */
+{
+    long	iocount = dimprod (dims, ndims);
+    long	*longs = (long *) malloc (iocount * sizeof (long));
+    int		*ip;
+    long	*lp = longs;
+
+    if (longs != NULL)
+	for (ip = ints; iocount > 0; iocount--)
+	    *lp++ = (long) *ip++;
+    return longs;
+}
+
+/*
+ * Convert a generalized multi-dimensional array of longs stored in ints to 
+ * packed array of longs, in malloc'ed space.  Returns pointer to longs or 
+ * NULL if malloc failed.
+ */
+static long *
+itolg(ints, dims, imap, ndims)
+    int		*ints;		/* multi-dimensional array of integers */
+    long	*dims;		/* list of dimensions */
+    long	*imap;		/* memory access index mapping vector */
+    int		ndims;		/* number of dimensions in list */
+{
+    long	iocount = dimprod (dims, ndims);
+    long	*longs = (long *) malloc (iocount * sizeof (long));
+
+    if (longs != NULL && iocount > 0) {
+	int	idim;
+	char	*ip	= (char*)ints;
+	long	*lp	= longs;
+	long	length[MAX_NC_DIMS];
+	long	coords[MAX_NC_DIMS];
+
+	for (idim = 0; idim < ndims; ++idim) {
+	    length[idim]	= dims[idim]*imap[idim];
+	    coords[idim]	= 0;
+	}
+
+	for (;;) {
+	    *lp++	= (long)*(int*)ip;
+	    idim	= ndims - 1;
+	carry:
+	    ip	+= imap[idim];
+	    if (++coords[idim] >= dims[idim]) {
+		coords[idim]	= 0;
+		ip		-= length[idim];
+		if (--idim < 0)
+		    break;
+		goto carry;
+	    }
+        }
+    }
+
+    return longs;
+}
+
+/*
+ * Convert a packed array of longs into a generalized multi-dimensional array
+ * of ints.
+ */
+static void
+ltoig(longs, ints, dims, imap, ndims)
+    long	*longs;		/* packed array of longs */
+    int		*ints;		/* multi-dimensional array of integers */
+    long	*dims;		/* list of dimensions */
+    long	*imap;		/* memory access index mapping vector */
+    int		ndims;		/* number of dimensions in list */
+{
+    if (dimprod (dims, ndims) > 0) {
+	int	idim;
+	long	*lp	= longs;
+	char	*ip	= (char*)ints;
+	long	length[MAX_NC_DIMS];
+	long	coords[MAX_NC_DIMS];
+
+	for (idim = 0; idim < ndims; ++idim) {
+	    length[idim]	= dims[idim]*imap[idim];
+	    coords[idim]	= 0;
+	}
+
+	for (;;) {
+	    *(int*)ip	= *lp++;
+	    idim	= ndims - 1;
+	carry:
+	    ip	+= imap[idim];
+	    if (++coords[idim] >= dims[idim]) {
+		coords[idim]	= 0;
+		ip		-= length[idim];
+		if (--idim < 0)
+		    break;
+		goto carry;
+	    }
+        }
+    }
+}
+#endif	/* Alpha platform above */
+
+/* ------------ Sun FORTRAN jackets for netCDF Functions ------------ */
+
+/* used to set the C global variable ncopts from Fortran */
+void
+ncpopt_(val)
+    int		*val;	
+{
+    ncopts = *val;
+}
+
+
+/* used to get the C global variable ncopts from Fortran */
+void
+ncgopt_(val)
+    int		*val;	
+{
+    *val = ncopts;
+}
+
+/*
+ * creates a new netCDF file, returning a netCDF ID.  New netCDF
+ * file is placed in define mode.
+ */
+int
+nccre_(pathname, clobmode, rcode, pathnamelen)
+    char	*pathname;	
+    int		pathnamelen;
+    int		*clobmode;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int cdfid;
+
+    nstrncpy (name, pathname, pathnamelen);
+    if ((cdfid = nccreate (name, *clobmode)) != -1) {
+	*rcode = 0;
+	return (cdfid);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+
+/* opens an existing netCDF file for access */
+int
+ncopn_(pathname, rwmode, rcode, pathnamelen)
+    char	*pathname;	
+    int		pathnamelen;
+    int		*rwmode;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int cdfid;
+
+    nstrncpy (name, pathname, pathnamelen);
+    if ((cdfid = ncopen (name, *rwmode)) != -1) {
+	*rcode = 0;
+	return (cdfid);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+
+/* adds a new dimension to an open netCDF file in define mode */
+int
+ncddef_(cdfid, dimname, dimlen, rcode, dimnamelen)
+    int		*cdfid;	
+    char	*dimname;	
+    int		dimnamelen;
+    int		*dimlen;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int dimid;
+
+    nstrncpy (name, dimname, dimnamelen);
+    if ((dimid = ncdimdef (*cdfid, name, (long)*dimlen)) != -1) {
+	*rcode = 0;
+	return (dimid + 1);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+
+/*
+ * returns the ID of a netCDF dimension, given the name of the
+ * dimension
+ */
+int
+ncdid_(cdfid, dimname, rcode, dimnamelen)
+    int		*cdfid;	
+    char	*dimname;	
+    int		dimnamelen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int dimid;
+
+    nstrncpy (name, dimname, dimnamelen);
+    if ((dimid = ncdimid (*cdfid, name)) != -1) {
+	*rcode = 0;
+	return (dimid + 1);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+
+/* adds a new variable to an open netCDF file in define mode */
+int
+ncvdef_(cdfid, varname, datatype, ndims, dimarray, rcode, varnamelen)
+    int		*cdfid;	
+    char	*varname;	
+    int		varnamelen;
+    int		*datatype;	
+    int		*ndims;	
+    int		*dimarray;	
+    int		*rcode;	
+{
+    int varid, i, dimid[MAX_VAR_DIMS];
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, varname, varnamelen);
+    for (i = 0; i < *ndims; i++)
+	dimid[i] = dimarray[i] - 1;
+    reverse (dimid, *ndims);
+    if ((varid = ncvardef (*cdfid, name, (nc_type) *datatype, *ndims,
+			   dimid)) != -1) {
+	*rcode = 0;
+	return (varid + 1);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+
+/* returns the ID of a netCDF variable given its name */
+int
+ncvid_(cdfid, varname, rcode, varnamelen)
+    int		*cdfid;	
+    char	*varname;	
+    int		varnamelen;
+    int		*rcode;	
+{
+    int varid;
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, varname, varnamelen);
+    if ((varid = ncvarid (*cdfid, name)) != -1) {
+	*rcode = 0;
+	return (varid + 1);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+
+/* returns number of bytes per netCDF data type */
+int
+nctlen_(datatype, rcode)
+    int		*datatype;	
+    int		*rcode;	
+{
+    int itype;
+
+    if ((itype = nctypelen ((nc_type) *datatype)) != -1) {
+	*rcode = 0;
+	return (itype);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+/* closes an open netCDF file */
+void
+ncclos_(cdfid, rcode)
+    int		*cdfid;	
+    int		*rcode;	
+{
+    *rcode = 0;
+    if (ncclose (*cdfid) == -1)
+	*rcode = ncerr;
+}
+
+/* puts an open netCDF into define mode */
+void
+ncredf_(cdfid, rcode)
+    int		*cdfid;	
+    int		*rcode;	
+{
+    *rcode = 0;
+    if (ncredef (*cdfid) == -1)
+	*rcode = ncerr;
+}
+
+/* takes an open netCDF out of define mode */
+void
+ncendf_(cdfid, rcode)
+    int		*cdfid;	
+    int		*rcode;	
+{
+    *rcode = 0;
+    if (ncendef (*cdfid) == -1)
+	*rcode = ncerr;
+}
+
+/* returns information about an open netCDF file given its netCDF ID */
+void
+ncinq_(cdfid, ndims, nvars, natts, recdim, rcode)
+    int		*cdfid;	
+    int		*ndims;	
+    int		*nvars;	
+    int		*natts;	
+    int		*recdim;	
+    int		*rcode;	
+{
+    *rcode = 0;
+    if (ncinquire (*cdfid, ndims, nvars, natts, recdim) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    if (*recdim != -1)
+	(*recdim)++;
+}
+
+/*
+ * makes sure that the disk copy of a netCDF file open for writing
+ * is current
+ */
+void
+ncsnc_(cdfid, rcode)
+    int		*cdfid;	
+    int		*rcode;	
+{
+    *rcode = 0;
+    if (ncsync (*cdfid) == -1)
+	*rcode = ncerr;
+}
+
+/*
+ * restores the netCDF to a known consistent state in case anything
+ * goes wrong during the definition of new dimensions, variables
+ * or attributes
+ */
+void
+ncabor_(cdfid, rcode)
+    int		*cdfid;	
+    int		*rcode;	
+{
+    *rcode = 0;
+    if (ncabort (*cdfid) == -1)
+	*rcode = ncerr;
+}
+
+/* returns the name and size of a dimension, given its ID */
+void
+ncdinq_(cdfid, dimid, dimname, size, rcode, dimnamelen)
+    int		*cdfid;	
+    int		*dimid;	
+    char	*dimname;	
+    int		dimnamelen;
+    int		*size;	
+    int		*rcode;	
+{
+    long siz;
+    char name[MAX_NC_NAME + 1];
+
+    *rcode = 0;
+    if (ncdiminq (*cdfid, *dimid - 1, name, &siz) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    *size = siz;
+    if (strlen (name) > dimnamelen) {
+	*rcode = NC_ESTS;
+	handle_err ("NCDINQ", *rcode);
+	return;
+    }
+    /* blank fill the input character string */
+    fcdcpy (dimname, dimnamelen, name);
+}
+
+/* renames an existing dimension in a netCDF open for writing */
+void
+ncdren_(cdfid, dimid, dimname, rcode, dimnamelen)
+    int		*cdfid;	
+    int		*dimid;	
+    char	*dimname;	
+    int		dimnamelen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, dimname, dimnamelen);
+    *rcode = 0;
+    if (ncdimrename (*cdfid, *dimid - 1, name) == -1)
+	*rcode = ncerr;
+}
+
+/* returns information about a netCDF variable, given its ID */
+void
+ncvinq_(cdfid, varid, varname, datatype, ndims, dimarray, natts, rcode, varnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*varname;	
+    int		varnamelen;
+    int		*datatype;	
+    int		*ndims;	
+    int		*dimarray;	
+    int		*natts;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int dimid[MAX_VAR_DIMS], i;
+
+    *rcode = 0;
+    if (ncvarinq (*cdfid, *varid - 1, name, (nc_type *) datatype, ndims, dimid,
+		  natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < *ndims; i++)
+	dimarray[i] = dimid[i] + 1;
+    reverse (dimarray, *ndims);
+    if (strlen (name) > varnamelen) {
+	*rcode = NC_ESTS;
+	handle_err ("NCVINQ", *rcode);
+	return;
+    }
+    fcdcpy (varname, varnamelen, name);
+}
+
+/* puts a single numeric data value into a variable of an open netCDF */
+void
+ncvpt1_(cdfid, varid, indices, value, rcode)
+    int		*cdfid;	
+    int		*varid;	
+    int		*indices;	
+    void	*value;	
+    int		*rcode;	
+{
+    int datatype, ndims, natts, i;
+    long nindices[MAX_VAR_DIMS];
+    int dimid[MAX_VAR_DIMS];
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0,
+		  (nc_type *) & datatype, &ndims, dimid, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++)
+	nindices[i] = indices[i] - 1;
+    revlongs (nindices, ndims);
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {	/* pack ints into bytes */
+	char           bytes = *(int *) value;
+	if (ncvarput1(*cdfid, *varid - 1, nindices,
+		      (ncvoid *) &bytes) == -1) {
+	    *rcode = ncerr;
+	}
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) {	/* pack ints into shorts */
+	short          shorts = *(int *)value;
+	if (ncvarput1(*cdfid, *varid - 1, nindices, (ncvoid *) &shorts) == -1) {
+	    *rcode = ncerr;
+	}
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long          longs = *(int *)value;
+	if (ncvarput1(*cdfid, *varid - 1, nindices, (ncvoid *) &longs) == -1) {
+	    *rcode = ncerr;
+	}
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long          longs = *(int *)value;
+	if (ncvarput1(*cdfid, *varid - 1, nindices, (ncvoid *) &longs) == -1) {
+	    *rcode = ncerr;
+	}
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncvarput1 (*cdfid, *varid - 1, nindices, value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/* puts a single character into an open netCDF file */
+void
+ncvp1c_(cdfid, varid, indices, chval, rcode, chvallen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*indices;	
+    char	*chval;	
+    int		chvallen;
+    int		*rcode;	
+{
+    int datatype, ndims, natts, i;
+    long nindices[MAX_VAR_DIMS];
+    int dimid[MAX_VAR_DIMS];
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0,
+		  (nc_type *) & datatype, &ndims, dimid, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++)
+	nindices[i] = indices[i] - 1;
+    revlongs (nindices, ndims);
+    *rcode = 0;
+    if (ncvarput1 (*cdfid, *varid - 1, nindices, (ncvoid *) chval) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * writes a hypercube of numeric values into a netCDF variable of an open
+ * netCDF file
+ */
+void
+ncvpt_(cdfid, varid, start, count, value, rcode)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    void	*value;	
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS], i;
+    int ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {	/* pack ints into bytes */
+	char *bytes = itob (value, ncount, ndims);
+	if (bytes == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarput (*cdfid, *varid - 1, nstart, ncount,
+	              (ncvoid *) bytes) == -1) {
+	    *rcode = ncerr;
+	}
+	free (bytes);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) { /* pack ints into shorts */
+	short *shorts = itos (value, ncount, ndims);
+	if (shorts == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarput (*cdfid, *varid - 1, nstart, ncount,
+		      (ncvoid *) shorts) == -1) {
+	    *rcode = ncerr;
+	}
+	free (shorts);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long *longs = itol (value, ncount, ndims);
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarput (*cdfid, *varid - 1, nstart, ncount,
+	              (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	}
+	free (longs);
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long *longs = itol (value, ncount, ndims);
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarput (*cdfid, *varid - 1, nstart, ncount,
+	              (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	}
+	free (longs);
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncvarput (*cdfid, *varid - 1, nstart, ncount, value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/* writes a hypercube of character values into an open netCDF file */
+void
+ncvptc_(cdfid, varid, start, count, string, lenstr, rcode, stringlen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    char	*string;	
+    int		stringlen;
+    int		*lenstr;	
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS], i;
+    int ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0,
+		  (nc_type *) & datatype, &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+    if (dimprod(ncount,ndims) > *lenstr) {
+	*rcode = NC_ESTS;
+	handle_err ("NCVPTC", *rcode);
+	return;
+    }
+    *rcode = 0;
+    if (ncvarput (*cdfid, *varid - 1, nstart, ncount, (ncvoid *) string) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * writes a generalized hypercube of numeric values into a netCDF variable of 
+ * an open netCDF file
+ */
+void
+ncvptg_(cdfid, varid, start, count, stride, basis, value, rcode)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    int		*stride;	
+    int		*basis;	
+    void	*value;	
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS], i;
+    long nstride[MAX_VAR_DIMS], nbasis[MAX_VAR_DIMS];
+    long tmpbasis;
+    int ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+#ifdef FORTRAN_HAS_NO_BYTE
+    if (datatype == NC_CHAR || datatype == NC_BYTE)
+	tmpbasis	= nctypelen(NC_LONG);
+    else
+#endif
+#ifdef FORTRAN_HAS_NO_SHORT
+    if (datatype == NC_SHORT)
+	tmpbasis	= nctypelen(NC_LONG);
+    else
+#endif
+#ifdef __alpha
+    if (datatype == NC_LONG)
+	tmpbasis	= sizeof(int);
+    else
+#endif
+	tmpbasis	= nctypelen(datatype);
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+	nstride[i] = stride[0] == 0 ? 1 : stride[i];
+	nbasis[i] = basis[0] == 0 ? tmpbasis : basis[i];
+	tmpbasis *= count[i];
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+    revlongs (nstride, ndims);
+    revlongs (nbasis, ndims);
+
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {	/* pack ints into bytes */
+	/*
+	 * Release 2.3.1 had a bug in the following line: it used count
+	 * rather than ncount.
+	 */
+	char *bytes = itobg (value, ncount, nbasis, ndims);
+	if (bytes == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarputg (*cdfid, *varid - 1, nstart, ncount, nstride, 
+		       (long*)NULL, (ncvoid *) bytes) == -1) {
+	    *rcode = ncerr;
+	}
+	free (bytes);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) { /* pack ints into shorts */
+	/*
+	 * Release 2.3.1 had a bug in the following line: it used count
+	 * rather than ncount.
+	 */
+	short *shorts = itosg (value, ncount, nbasis, ndims);
+	if (shorts == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarputg (*cdfid, *varid - 1, nstart, ncount, nstride,
+		      (long*)NULL, (ncvoid *) shorts) == -1) {
+	    *rcode = ncerr;
+	}
+	free (shorts);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long *longs = itolg (value, ncount, nbasis, ndims);
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarputg (*cdfid, *varid - 1, nstart, ncount, nstride,
+		      (long*)NULL, (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	}
+	free (longs);
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long *longs = itolg (value, ncount, nbasis, ndims);
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarputg (*cdfid, *varid - 1, nstart, ncount, nstride,
+		      (long*)NULL, (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	}
+	free (longs);
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncvarputg (*cdfid, *varid - 1, nstart, ncount, nstride, nbasis,
+		   value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * writes a generalized hypercube of character values into a netCDF variable of 
+ * an open netCDF file
+ */
+void
+ncvpgc_(cdfid, varid, start, count, stride, basis, string, rcode, stringlen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    int		*stride;	
+    int		*basis;	
+    char	*string;	
+    int		stringlen;
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS], i;
+    long nstride[MAX_VAR_DIMS], nbasis[MAX_VAR_DIMS];
+    long tmpbasis;
+    int ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    tmpbasis	= nctypelen(datatype);
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+	nstride[i] = stride[0] == 0 ? 1 : stride[i];
+	nbasis[i] = basis[0] == 0 ? tmpbasis : basis[i];
+	tmpbasis *= count[i];
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+    revlongs (nstride, ndims);
+    revlongs (nbasis, ndims);
+
+    *rcode = 0;
+    if (ncvarputg (*cdfid, *varid - 1, nstart, ncount, nstride, nbasis,
+		   (ncvoid*)string) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/* gets a single numeric value from a variable of an open netCDF file */
+void
+ncvgt1_(cdfid, varid, indices, value, rcode)
+    int		*cdfid;	
+    int		*varid;	
+    int		*indices;	
+    void	*value;	
+    int		*rcode;	
+{
+    long nindices[MAX_VAR_DIMS], i;
+    int datatype, ndims, dimarray[MAX_VAR_DIMS], natts;
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++) {
+	nindices[i] = indices[i] - 1;
+    }
+    revlongs (nindices, ndims);
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {
+	char           bytes;
+	int            *ip = (int *) value;
+	char           *bp = &bytes;
+
+	if (ncvarget1(*cdfid, *varid - 1, nindices, (ncvoid *) &bytes) == -1) {
+	    *rcode = ncerr;
+	    return;
+	}
+	*ip = *bp;
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) {
+	short          shorts;
+	int            *ip = (int *) value;
+	short          *sp = &shorts;
+
+	if (ncvarget1(*cdfid, *varid - 1, nindices, (ncvoid *) &shorts) == -1) {
+	    *rcode = ncerr;
+	    return;
+	}
+	*ip = *sp;
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long          longs;
+	int           *ip = (int *) value;
+
+	if (ncvarget1(*cdfid, *varid - 1, nindices, (ncvoid *) &longs) == -1) {
+	    *rcode = ncerr;
+	    return;
+	}
+	*ip = longs;
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long          longs;
+	int           *ip = (int *) value;
+
+	if (ncvarget1(*cdfid, *varid - 1, nindices, (ncvoid *) &longs) == -1) {
+	    *rcode = ncerr;
+	    return;
+	}
+	*ip = longs;
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncvarget1 (*cdfid, *varid - 1, nindices, value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * gets a single character data value from a variable of an open
+ * netCDF file
+ */
+void
+ncvg1c_(cdfid, varid, indices, chval, rcode, chvallen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*indices;	
+    char	*chval;	
+    int		chvallen;
+    int		*rcode;	
+{
+    long nindices[MAX_VAR_DIMS];
+    int i, datatype, ndims, dimarray[MAX_VAR_DIMS], natts;
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0,
+		  (nc_type *) & datatype, &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+
+    for (i = 0; i < ndims; i++) {
+	nindices[i] = indices[i] - 1;
+    }
+    revlongs (nindices, ndims);
+    *rcode = 0;
+    if (ncvarget1 (*cdfid, *varid - 1, nindices, (ncvoid *) chval) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * reads a hypercube of numeric values from a netCDF variable of an open
+ * netCDF file
+ */
+void
+ncvgt_(cdfid, varid, start, count, value, rcode)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    void	*value;	
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS];
+    int i, ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	char *bytes = (char *) malloc (iocount * sizeof (char));
+	int *ip;
+	char *bp = bytes;
+
+	if (bytes == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvarget (*cdfid, *varid - 1, nstart, ncount,
+		      (ncvoid *) bytes) == -1) {
+	    *rcode = ncerr;
+	    free (bytes);
+	    return;
+	}
+	for (ip = (int *) value; iocount > 0; iocount--)
+	  *ip++ = *bp++;
+	free (bytes);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	short *shorts = (short *) malloc (iocount * sizeof (short));
+	int *ip;
+	short *sp = shorts;
+
+	if (shorts == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvarget (*cdfid, *varid - 1, nstart, ncount,
+		      (ncvoid *) shorts) == -1) {
+	    *rcode = ncerr;
+	    free (shorts);
+	    return;
+	}
+	for (ip = (int *) value; iocount > 0; iocount--)
+	    *ip++ = *sp++;
+	free (shorts);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	long *longs = (long *) malloc (iocount * sizeof (long));
+	int *ip;
+	long *lp = longs;
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvarget (*cdfid, *varid - 1, nstart, ncount,
+		      (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	    free (longs);
+	    return;
+	}
+	for (ip = (int *) value; iocount > 0; iocount--)
+	    *ip++ = *lp++;
+	free (longs);
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	long *longs = (long *) malloc (iocount * sizeof (long));
+	int *ip;
+	long *lp = longs;
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvarget (*cdfid, *varid - 1, nstart, ncount,
+		      (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	    free (longs);
+	    return;
+	}
+	for (ip = (int *) value; iocount > 0; iocount--)
+	    *ip++ = *lp++;
+	free (longs);
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncvarget (*cdfid, *varid - 1, nstart, ncount, value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/* reads a hypercube of character values from a netCDF variable */
+void
+ncvgtc_(cdfid, varid, start, count, string, lenstr, rcode, stringlen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    char	*string;	
+    int		stringlen;
+    int		*lenstr;	
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS];
+    int i, ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+    int prod = 1;
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0,
+		  (nc_type *) & datatype, &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+	prod *= count[i];
+    }
+    if (prod > *lenstr) {
+	*rcode = NC_ESTS;
+	handle_err ("NCVGTC", *rcode);
+	return;
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+    *rcode = 0;
+    if (ncvarget (*cdfid, *varid - 1, nstart, ncount, (ncvoid *) string) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+
+    for (i = prod; i < *lenstr; i++)
+	string[i] = ' ';
+}
+
+/*
+ * reads a generalized hypercube of numeric values from a netCDF variable of an 
+ * open netCDF file
+ */
+void
+ncvgtg_(cdfid, varid, start, count, stride, basis, value, rcode)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    int		*stride;	
+    int		*basis;	
+    void	*value;	
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS];
+    long nstride[MAX_VAR_DIMS], nbasis[MAX_VAR_DIMS];
+    long tmpbasis;
+    int i, ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+#ifdef FORTRAN_HAS_NO_BYTE
+    if (datatype == NC_CHAR || datatype == NC_BYTE)
+	tmpbasis	= nctypelen(NC_LONG);
+    else
+#endif
+#ifdef FORTRAN_HAS_NO_SHORT
+    if (datatype == NC_SHORT)
+	tmpbasis	= nctypelen(NC_LONG);
+    else
+#endif
+#ifdef __alpha
+    if (datatype == NC_LONG)
+	tmpbasis	= sizeof(int);
+    else
+#endif
+	tmpbasis	= nctypelen(datatype);
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+	nstride[i] = stride[0] == 0 ? 1 : stride[i];
+	nbasis[i] = basis[0] == 0 ? tmpbasis : basis[i];
+	tmpbasis *= count[i];
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+    revlongs (nstride, ndims);
+    revlongs (nbasis, ndims);
+
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	char *bytes = (char *) malloc (iocount * sizeof (char));
+	int *ip;
+	char *bp = bytes;
+
+	if (bytes == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvargetg (*cdfid, *varid - 1, nstart, ncount, nstride,
+		      (long*)NULL, (ncvoid *) bytes) == -1) {
+	    *rcode = ncerr;
+	    free (bytes);
+	    return;
+	}
+	/*
+	 * Release 2.3.1 had a bug in the following line: it used basis
+	 * rather than nbasis.
+	 */
+	btoig(bytes, (int*)value, ncount, nbasis, ndims);
+	free (bytes);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	short *shorts = (short *) malloc (iocount * sizeof (short));
+	int *ip;
+	short *sp = shorts;
+
+	if (shorts == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvargetg (*cdfid, *varid - 1, nstart, ncount, nstride, 
+		       (long*)NULL, (ncvoid *) shorts) == -1) {
+	    *rcode = ncerr;
+	    free (shorts);
+	    return;
+	}
+	/*
+	 * Release 2.3.1 had a bug in the following line: it used basis
+	 * rather than nbasis.
+	 */
+	stoig(shorts, (int*)value, ncount, nbasis, ndims);
+	free (shorts);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	long *longs = (long *) malloc (iocount * sizeof (long));
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvargetg (*cdfid, *varid - 1, nstart, ncount, nstride, 
+		       (long*)NULL, (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	    free (longs);
+	    return;
+	}
+	ltoig(longs, (int*)value, ncount, nbasis, ndims);
+	free (longs);
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	long *longs = (long *) malloc (iocount * sizeof (long));
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvargetg (*cdfid, *varid - 1, nstart, ncount, nstride, 
+		       (long*)NULL, (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	    free (longs);
+	    return;
+	}
+	ltoig(longs, (int*)value, ncount, nbasis, ndims);
+	free (longs);
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncvargetg (*cdfid, *varid - 1, nstart, ncount, nstride,
+		   nbasis, value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * reads a generalized hypercube of character values from a netCDF variable 
+ * of an open netCDF file
+ */
+void
+ncvggc_(cdfid, varid, start, count, stride, basis, string, rcode, stringlen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    int		*stride;	
+    int		*basis;	
+    char	*string;	
+    int		stringlen;
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS];
+    long nstride[MAX_VAR_DIMS], nbasis[MAX_VAR_DIMS];
+    long tmpbasis;
+    int i, ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    tmpbasis	= nctypelen(datatype);
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+	nstride[i] = stride[0] == 0 ? 1 : stride[i];
+	nbasis[i] = basis[0] == 0 ? tmpbasis : basis[i];
+	tmpbasis *= count[i];
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+    revlongs (nstride, ndims);
+    revlongs (nbasis, ndims);
+
+    *rcode = 0;
+    if (ncvargetg (*cdfid, *varid - 1, nstart, ncount, nstride,
+		   nbasis, (ncvoid*)string) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/* changes the name of a netCDF variable in an open netCDF file */
+void
+ncvren_(cdfid, varid, varname, rcode, varnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*varname;	
+    int		varnamelen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, varname, varnamelen);
+    *rcode = 0;
+    if (ncvarrename (*cdfid, *varid - 1, name) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * adds or changes a numeric variable or global attribute of an open
+ * netCDF file
+ */
+void
+ncapt_(cdfid, varid, attname, datatype, attlen, value, rcode, attnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    int		*datatype;	
+    int		*attlen;	
+    void	*value;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    nstrncpy (name, attname, attnamelen);
+
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) *datatype == NC_BYTE) {	/* pack ints into bytes */
+	char *bytes = itob (value, attlen, 1);
+
+	if (bytes == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattput (*cdfid, *varid - 1, name, (nc_type) *datatype, *attlen,
+		      (ncvoid *) bytes) == -1) {
+	    *rcode = ncerr;
+	}
+	free (bytes);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) *datatype == NC_SHORT) {	/* pack ints into shorts */
+	short *shorts = itos (value, attlen, 1);
+
+	if (shorts == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattput (*cdfid, *varid - 1, name, (nc_type) *datatype, *attlen,
+		      (ncvoid *) shorts) == -1) {
+	    *rcode = ncerr;
+	}
+	free (shorts);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) *datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long *longs = itol (value, attlen, 1);
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattput (*cdfid, *varid - 1, name, (nc_type) *datatype, *attlen,
+		      (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	}
+	free (longs);
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) *datatype == NC_LONG) {
+	long *longs = itol (value, attlen, 1);
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattput (*cdfid, *varid - 1, name, (nc_type) *datatype, *attlen,
+		      (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	}
+	free (longs);
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncattput (*cdfid, *varid - 1, name, (nc_type) *datatype, *attlen,
+		  value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * adds or changes a character variable or global attribute
+ * of an open netCDF file
+ */
+void
+ncaptc_(cdfid, varid, attname, datatype, lenstr, string, rcode, attnamelen, stringlen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    int		*datatype;	
+    int		*lenstr;	
+    char	*string;	
+    int		stringlen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    char *value;
+
+    nstrncpy (name, attname, attnamelen);
+    if (((value = malloc ((unsigned) *lenstr + 1)) == NULL) || (*lenstr == 0)) {
+	*rcode = NC_ESTS;
+	handle_err ("NCAPTC", *rcode);
+	return;
+    }
+    (void) fstrncpy (value, string, *lenstr);
+    *rcode = 0;
+    if (ncattput (*cdfid, *varid - 1, name, (nc_type) *datatype, *lenstr,
+		  (ncvoid *) value) == -1) {
+	*rcode = ncerr;
+    }
+    free (value);
+}
+
+/*
+ * returns information about a netCDF attribute given its variable
+ * ID and name
+ */
+void
+ncainq_(cdfid, varid, attname, datatype, attlen, rcode, attnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    int		*datatype;	
+    int		*attlen;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, attname, attnamelen);
+    *rcode = 0;
+    if (ncattinq (*cdfid, *varid - 1, name, (nc_type *) datatype, attlen) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * gets the value of a netCDF attribute given its variable ID
+ * and name
+ */
+void
+ncagt_(cdfid, varid, attname, value, rcode, attnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    void	*value;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int datatype;
+    int attlen;
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    nstrncpy (name, attname, attnamelen);
+    *rcode = 0;
+    if (ncattinq (*cdfid, *varid - 1, name, (nc_type *) &datatype, &attlen)
+	    == -1) {
+	*rcode = ncerr;
+	return;
+    }
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {
+	char *bytes = (char *) malloc (attlen);
+	int *ip;
+	char *bp = bytes;
+
+	if (bytes == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattget (*cdfid, *varid - 1, name, (ncvoid *) bytes) == -1) {
+	    *rcode = ncerr;
+	    free (bytes);
+	    return;
+	}
+	for (ip = (int *) value; attlen > 0; attlen--)
+	    *ip++ = *bp++;
+	free (bytes);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) {
+	short *shorts = (short *) malloc (attlen * sizeof (short));
+	int *ip;
+	short *sp = shorts;
+
+	if (shorts == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattget (*cdfid, *varid - 1, name, (ncvoid *) shorts) == -1) {
+	    *rcode = ncerr;
+	    free (shorts);
+	    return;
+	}
+	for (ip = (int *) value; attlen > 0; attlen--)
+	    *ip++ = *sp++;
+	free (shorts);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long *longs = (long *) malloc (attlen * sizeof (long));
+	int *ip;
+	long *lp = longs;
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattget (*cdfid, *varid - 1, name, (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	    free (longs);
+	    return;
+	}
+	for (ip = (int *) value; attlen > 0; attlen--)
+	    *ip++ = *lp++;
+	free (longs);
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long *longs = (long *) malloc (attlen * sizeof (long));
+	int *ip;
+	long *lp = longs;
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattget (*cdfid, *varid - 1, name, (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	    free (longs);
+	    return;
+	}
+	for (ip = (int *) value; attlen > 0; attlen--)
+	    *ip++ = *lp++;
+	free (longs);
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncattget (*cdfid, *varid - 1, name, value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * gets the value of a netCDF character attribute given its variable
+ * ID and name
+ */
+void
+ncagtc_(cdfid, varid, attname, string, lenstr, rcode, attnamelen, stringlen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    char	*string;	
+    int		stringlen;
+    int		*lenstr;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int datatype;
+    int attlen;
+    int i;
+
+    nstrncpy (name, attname, attnamelen);
+    *rcode = 0;
+    if (ncattinq (*cdfid, *varid - 1, name, (nc_type *) &datatype, &attlen) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    if (attlen > *lenstr) {
+	*rcode = NC_ESTS;
+	handle_err ("NCAGTC", *rcode);
+	return;
+    }
+    if (ncattget (*cdfid, *varid - 1, name, (ncvoid *) string) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+
+    for (i = attlen; i < *lenstr; i++)
+	string[i] = ' ';
+}
+
+/* copies an attribute from one open netCDF file to another */
+void
+ncacpy_(incdfid, invarid, attname, outcdfid, outvarid, rcode, attnamelen)
+    int		*incdfid;	
+    int		*invarid;	
+    char	*attname;	
+    int		attnamelen;
+    int		*outcdfid;	
+    int		*outvarid;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, attname, attnamelen);
+    *rcode = 0;
+    if (ncattcopy (*incdfid, *invarid - 1, name,
+		   *outcdfid, *outvarid - 1) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * gets the name of an attribute given its variable ID and number
+ * as an attribute of that variable
+ */
+void
+ncanam_(cdfid, varid, attnum, attname, rcode, attnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*attnum;	
+    char	*attname;	
+    int		attnamelen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+
+    *rcode = 0;
+    if (ncattname (*cdfid, *varid - 1, *attnum - 1, name) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    if (strlen (name) > attnamelen) {
+	*rcode = NC_ESTS;
+	handle_err ("NCANAM", *rcode);
+	return;
+    }
+    fcdcpy (attname, attnamelen, name);
+}
+
+
+/* renames an attribute in an open netCDF file */
+void
+ncaren_(cdfid, varid, attname, newname, rcode, attnamelen, newnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    char	*newname;	
+    int		newnamelen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1], nname[MAX_NC_NAME + 1];
+
+    nstrncpy (name, attname, attnamelen);
+    nstrncpy (nname, newname, newnamelen);
+    *rcode = 0;
+    if (ncattrename (*cdfid, *varid - 1, name, nname) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * deletes an attribute from an open netCDF file given the attribute
+ * name
+ */
+void
+ncadel_(cdfid, varid, attname, rcode, attnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, attname, attnamelen);
+    *rcode = 0;
+    if (ncattdel (*cdfid, *varid - 1, name) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+
+/*
+ * sets the fill mode of a netCDF file open for writing
+ */
+int
+ncsfil_(cdfid, fillmode, rcode)
+    int		*cdfid;	
+    int		*fillmode;	
+    int		*rcode;	
+{
+    int retval;
+
+    if ((retval = ncsetfill (*cdfid, *fillmode)) != -1) {
+	*rcode = 0;
+	return retval;
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
--- HDF-4.1r4/mfhdf/fortran/config/netcdf-darwin.inc	Mon Sep 17 06:40:42 2001
+++ HDF-4.1r4/mfhdf/fortran/config/netcdf-darwin.inc	Mon May  7 11:52:14 2001
@@ -0,0 +1,147 @@
+c      
+c     Functions in the FORTRAN interface
+
+      integer nccre, ncopn, ncddef, ncdid, ncvdef, ncvid, nctlen
+      integer ncsfil
+      external nccre, ncopn, ncddef, ncdid, ncvdef, ncvid, nctlen
+      external ncsfil
+
+      integer NCRDWR,NCCREAT,NCEXCL,NCINDEF,NCNSYNC,NCHSYNC
+      integer NCNDIRTY,NCHDIRTY,NCLINK,NCNOWRIT,NCWRITE
+      integer NCCLOB,NCNOCLOB,NCGLOBAL,NCFILL,NCNOFILL
+      integer MAXNCOP,MAXNCDIM,MAXNCATT,MAXNCVAR
+      integer MAXNCNAM,MAXVDIMS,NCNOERR,NCEBADID
+      integer NCENFILE,NCEEXIST,NCEINVAL,NCEPERM,NCENOTIN
+      integer NCEINDEF,NCECOORD,NCEMAXDS,NCENAME
+      integer NCENOATT,NCEMAXAT,NCEBADTY,NCEBADD, NCESTS
+      integer NCEUNLIM,NCEMAXVS,NCENOTVR,NCEGLOB,NCENOTNC
+      integer NCFOOBAR,NCSYSERR,NCFATAL,NCVERBOS, NCENTOOL
+      
+      integer NCBYTE,NCCHAR,NCSHORT,NCLONG,NCFLOAT,NCDOUBLE
+      
+      parameter(NCBYTE = 1)
+      parameter(NCCHAR = 2)
+      parameter(NCSHORT = 3)
+      parameter(NCLONG = 4)
+      parameter(NCFLOAT = 5)
+      parameter(NCDOUBLE = 6)
+      
+c     
+c     masks for the struct NC flag field; passed in as 'mode' arg to
+c     nccreate and ncopen.
+c     
+      
+c     read/write, 0 => readonly 
+      parameter(NCRDWR = 1)
+c     in create phase, cleared by ncendef 
+      parameter(NCCREAT = 2)
+c     on create destroy existing file 
+      parameter(NCEXCL = 4)
+c     in define mode, cleared by ncendef 
+      parameter(NCINDEF = 8)
+c     synchronise numrecs on change (X'10')
+      parameter(NCNSYNC = 16)
+c     synchronise whole header on change (X'20')
+      parameter(NCHSYNC = 32)
+c     numrecs has changed (X'40')
+      parameter(NCNDIRTY = 64)	
+c     header info has changed (X'80')
+      parameter(NCHDIRTY = 128)
+c     prefill vars on endef and increase of record, the default behavior
+      parameter(NCFILL = 0)
+c     don't fill vars on endef and increase of record (X'100')
+      parameter(NCNOFILL = 256)
+c     isa link (X'8000')
+      parameter(NCLINK = 32768)
+      
+c     
+c     'mode' arguments for nccreate and ncopen
+c     
+      
+      parameter(NCNOWRIT = 0)
+      parameter(NCWRITE = NCRDWR)
+      parameter(NCCLOB = 11)
+      parameter(NCNOCLOB = 15)
+c     
+c     'size' argument to ncdimdef for an unlimited dimension
+c     
+      integer NCUNLIM
+      parameter(NCUNLIM = 0)
+      
+c     
+c     attribute id to put/get a global attribute
+c     
+      parameter(NCGLOBAL  = 0)
+c     
+c     Advisory Maximums
+c     
+      parameter(MAXNCOP = 32)
+      parameter(MAXNCDIM = 32)
+      parameter(MAXNCATT = 512)
+      parameter(MAXNCVAR = 512)
+c     Not enforced 
+      parameter(MAXNCNAM = 128)
+      parameter(MAXVDIMS = MAXNCDIM)
+      
+      
+c     
+c     The netcdf data types
+c     
+      
+c     
+c     Global netcdf error status variable
+c     Initialized in error.c
+c     
+      
+c     No Error 
+      parameter(NCNOERR = 0)
+c     Not a netcdf id 
+      parameter(NCEBADID = 1)
+c     Too many netcdfs open 
+      parameter(NCENFILE = 2)	
+c     netcdf file exists && NCNOCLOB
+      parameter(NCEEXIST = 3)
+c     Invalid Argument 
+      parameter(NCEINVAL = 4)
+c     Write to read only 
+      parameter(NCEPERM = 5)
+c     Operation not allowed in data mode 
+      parameter(NCENOTIN = 6)	
+c     Operation not allowed in define mode 
+      parameter(NCEINDEF = 7)	
+c     Coordinates out of Domain 
+      parameter(NCECOORD = 8)
+c     MAXNCDIMS exceeded 
+      parameter(NCEMAXDS = 9)
+c     String match to name in use 
+      parameter(NCENAME = 10)	
+c     Attribute not found 
+      parameter(NCENOATT = 11)
+c     MAXNCATTRS exceeded 
+      parameter(NCEMAXAT = 12)
+c     Not a netcdf data type 
+      parameter(NCEBADTY = 13)
+c     Invalid dimension id 
+      parameter(NCEBADD = 14)	
+c     NCUNLIMITED in the wrong index 
+      parameter(NCEUNLIM = 15)
+c     MAXNCVARS exceeded 
+      parameter(NCEMAXVS = 16)
+c     Variable not found 
+      parameter(NCENOTVR = 17)
+c     Action prohibited on NCGLOBAL varid 
+      parameter(NCEGLOB = 18)
+c     Not a netcdf file 
+      parameter(NCENOTNC = 19)
+      parameter(NCESTS = 20)
+      parameter (NCENTOOL = 21)	
+      parameter(NCFOOBAR = 32)
+      parameter(NCSYSERR = -1)
+      
+      
+c     
+c     Global options variable. Used to determine behavior of error handler.
+c     Initialized in lerror.c
+c     
+      parameter(NCFATAL = 1)
+      parameter(NCVERBOS = 2)
--- HDF-4.1r4/mfhdf/libsrc/config/netcdf-darwin.h	Mon Sep 17 06:41:04 2001
+++ HDF-4.1r4/mfhdf/libsrc/config/netcdf-darwin.h	Mon May  7 11:52:54 2001
@@ -0,0 +1,590 @@
+/* Generated automatically from netcdf.h.in by configure. */
+/*
+ *	Copyright 1993, University Corporation for Atmospheric Research
+ *
+ *  Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose without fee is hereby granted, provided
+ * that the above copyright notice appear in all copies, that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of UCAR/Unidata not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  UCAR makes no
+ * representations about the suitability of this software for any purpose.
+ * It is provided "as is" without express or implied warranty.  It is
+ * provided with no support and without obligation on the part of UCAR
+ * Unidata, to assist in its use, correction, modification, or enhancement.
+ *
+ */
+/* "$Id: hdf-4.1r4-2.patch,v 1.1 2001/09/19 14:46:18 jswhit Exp $" */
+
+#ifndef _NETCDF_
+#define _NETCDF_
+
+#ifdef __MWERKS__
+#ifndef HDF
+#define HDF
+#endif
+#endif /* __MWERKS__ */
+
+/*
+ * The definitions ncvoid, USE_ENUM, and MAX_NC_OPEN, may need to be set
+ * properly for your installation.
+ */
+
+/*
+ * Argument type in user functions (deprecated, backward compatibility)
+ */
+#ifndef UD_NO_VOID
+#define ncvoid    void
+#else
+/* system doesn't have void type */
+#define ncvoid    char
+#endif
+
+
+/*
+ *   If xdr_enum works properly on your system, you can define 
+ * USE_ENUM so that nc_type is an enum. 
+ * Otherwise, delete this definition so that the nc_type is
+ * an int and the valid values are #defined.
+ */
+#ifndef __MWERKS__
+#define USE_ENUM
+#endif
+
+
+/*
+ * The following macro is provided for backward compatibility only.  If you
+ * are a new user of netCDF, then you may safely ignore it.  If, however,
+ * you have an existing archive of netCDF files that use default
+ * floating-point fill values, then you should know that the definition of
+ * the default floating-point fill values changed with version 2.3 of the
+ * netCDF package.  Prior to this release, the default floating-point fill
+ * values were not very portable:  their correct behavior depended not only
+ * upon the particular platform, but also upon the compilation
+ * environment.  This led to the definition of new, default floating-point
+ * fill values that are portable across all platforms and compilation
+ * environments.  If you wish, however, to obtain the old, non-portable
+ * floating-point fill values, then the following macro should have a true
+ * value PRIOR TO BUILDING THE netCDF LIBRARY.
+ *
+ * Implementation details are contained in the section below on fill values.
+ */
+#define NC_OLD_FILLVALUES	0
+
+/*
+ * 	Fill values
+ * These values are stuffed into newly allocated space as appropriate.
+ * The hope is that one might use these to notice that a particular datum
+ * has not been set.
+ */
+
+#define FILL_BYTE	((char)-127)		/* Largest Negative value */
+#define FILL_CHAR	((char)0)
+#define FILL_SHORT	((short)-32767)
+#define FILL_LONG	((long)-2147483647)
+
+#if !NC_OLD_FILLVALUES
+
+#   define FILL_FLOAT	9.9692099683868690e+36 /* near 15 * 2^119 */
+#   define FILL_DOUBLE	9.9692099683868690e+36
+
+#else	/* NC_OLD_FILLVALUES below */
+
+/*
+ * This section is provided for backward compatibility only.  Using
+ * XDR infinities for floating-point fill values has caused more problems
+ * than it has solved.  We encourage you to define your own data-specific
+ * fill values rather than use default ones (see `_FillValue' below).
+ * If, however, you *must* use default fill values, then you should use
+ * the above fill values rather than the ones in this section.
+ */
+
+/*
+ * XDR_F_INFINITY is a float value whose EXTERNAL (xdr)
+ * represention is ieee floating infinity.
+ * XDR_D_INFINITY is a double value whose EXTERNAL (xdr)
+ * represention is ieee double floating point infinity.
+ * These are used as default fill values below.
+ *
+ * This section shows three techniques for setting these:
+ *  Direct assignment (vax, cray) - works for non IEEE machines
+ *		Doesn't work when IEEE machines don't allow
+ *      float or double constants whose values are infinity.
+ *  Use of a union (preferred portable method) - should work on
+ *      any ANSI compiler with IEEE floating point representations,
+ *      modulo byte order and sizeof() considerations.
+ *  Use of pointer puns - may work with many older compilers
+ *      which don't allow intialization of unions.
+ *      Often doesn't work with compilers which have strict
+ *      alignment rules.
+ */ 
+
+    /* Direct assignment. All cases should be mutually exclusive */
+
+#ifdef vax
+#define	XDR_D_INFINITY	1.7014118346046923e+38
+#define	XDR_F_INFINITY	1.70141173e+38
+#endif /* vax */
+
+#ifdef cray
+#define	XDR_D_INFINITY	1.797693134862313000e+308
+#define	XDR_F_INFINITY	XDR_D_INFINITY
+#endif /* cray */
+
+#ifdef notdef /* you might want to try these, on an IEEE machine */
+#define XDR_D_INFINITY	1.797693134862315900e+308
+#define XDR_F_INFINITY	3.40282357e+38
+#endif
+
+#ifdef __STDC__
+    /* Use of a union, assumes IEEE representation and 1 byte unsigned char */
+
+#ifndef    XDR_D_INFINITY
+#define USE_D_UNION
+     union xdr_d_union {unsigned char bb[8]; double dd;} ;
+     extern union xdr_d_union xdr_d_infs ;  /* instantiated in array.c */
+#define XDR_D_INFINITY    (xdr_d_infs.dd)
+#endif /* !XDR_D_INFINITY */
+
+#ifndef    XDR_F_INFINITY
+#define USE_F_UNION
+     union xdr_f_union {unsigned char bb[4]; float ff;} ;
+     extern union xdr_f_union xdr_f_infs ;  /* instantiated in array.c */
+#define  XDR_F_INFINITY    (xdr_f_infs.ff)
+#endif /* !XDR_F_INFINITY */
+
+
+#else /* __STDC__ */
+    /* Use of a pointer pun, assumes IEEE representation, 4 byte long */
+
+#ifndef    XDR_D_INFINITY
+#define USE_D_LONG_PUN
+     extern long xdr_d_infinity[] ;  /* instantiated in array.c */
+#define XDR_D_INFINITY *(double *)xdr_d_infinity
+#endif /* !XDR_D_INFINITY */
+
+#ifndef    XDR_F_INFINITY
+#define USE_F_LONG_PUN
+     extern long xdr_f_infinity ;  /* instantiated in array.c */
+#define XDR_F_INFINITY *((float *)&xdr_f_infinity)
+#endif /* !XDR_F_INFINITY */
+
+#endif /* __STDC__ */
+
+/* End of INFINITY           section */
+
+#define FILL_FLOAT	XDR_F_INFINITY	/* IEEE Infinity */
+#define FILL_DOUBLE	XDR_D_INFINITY
+
+#endif	/* NC_OLD_FILLVALUES above */
+
+
+/*
+ *  masks for the struct NC flags field; passed in as 'mode' arg to
+ * nccreate and ncopen.
+ *
+ */
+#define NC_RDWR  1		/* read/write, 0 => readonly */
+#define NC_CREAT 2		/* in create phase, cleared by ncendef */
+#define NC_EXCL  4		/* on create, don't destroy existing file */
+#define NC_INDEF 8		/* in define mode, cleared by ncendef */
+#define NC_NSYNC 0x10	/* synchronise numrecs on change */
+#define NC_HSYNC 0x20	/* synchronise whole header on change */
+#define NC_NDIRTY 0x40	/* numrecs has changed */
+#define NC_HDIRTY 0x80  /* header info has changed */
+#define NC_NOFILL 0x100	/* Don't fill vars on endef and increase of record */
+#define NC_LINK 0x8000	/* isa link */
+
+#define NC_FILL 0	/* argument to ncsetfill to clear NC_NOFILL */
+
+/*
+ * 'mode' arguments for nccreate and ncopen
+ */
+#define NC_NOWRITE   0
+#define NC_WRITE     NC_RDWR
+#define NC_CLOBBER   (NC_INDEF | NC_CREAT | NC_RDWR)
+#define NC_NOCLOBBER (NC_INDEF | NC_EXCL | NC_CREAT | NC_RDWR)
+
+/*
+ * 'size' argument to ncdimdef for an unlimited dimension
+ */
+#define NC_UNLIMITED 0L
+
+/*
+ * attribute id to put/get a global attribute
+ */
+#define NC_GLOBAL -1
+
+#ifndef HDF
+/*
+ * This can be as large as the maximum number of stdio streams
+ * you can have open on your system.
+ */
+#define MAX_NC_OPEN 32
+
+/*
+ * These maximums are enforced by the interface, to facilitate writing
+ * applications and utilities.  However, nothing is statically allocated to
+ * these sizes internally.
+ */
+#define MAX_NC_DIMS 5000	 /* max dimensions per file */
+#define MAX_NC_ATTRS 3000	 /* max global or per variable attributes */
+#define MAX_NC_VARS 5000	 /* max variables per file */
+#define MAX_NC_NAME 256		 /* max length of a name */
+#define MAX_VAR_DIMS 32          /* max per variable dimensions */
+
+/*
+ * Added feature. 
+ * If you wish a variable to use a different value than the above
+ * defaults, create an attribute with the same type as the variable
+ * and the following reserved name. The value you give the attribute
+ * will be used as the fill value for that variable.
+ */
+#define _FillValue	"_FillValue"
+
+#else /* HDF */
+
+#include "hlimits.h"  /* Hard coded constants for HDF library */
+
+#endif /* HDF */
+
+#ifdef USE_ENUM
+/*
+ *  The netcdf data types
+ */
+typedef enum {
+	NC_UNSPECIFIED, /* private */
+	NC_BYTE,
+	NC_CHAR,
+	NC_SHORT,
+	NC_LONG,
+	NC_FLOAT,
+	NC_DOUBLE,
+	/* private */
+	NC_BITFIELD,
+	NC_STRING,
+	NC_IARRAY,
+	NC_DIMENSION,
+	NC_VARIABLE,
+	NC_ATTRIBUTE
+} nc_type ;
+#else
+typedef int nc_type ;
+#define	NC_UNSPECIFIED 0 /* private */
+#define	NC_BYTE 1
+#define	NC_CHAR 2
+#define	NC_SHORT 3
+#define	NC_LONG 4
+#define	NC_FLOAT 5
+#define	NC_DOUBLE 6
+	/* private */
+#define	NC_BITFIELD 7
+#define	NC_STRING 8
+#define	NC_IARRAY 9
+#define	NC_DIMENSION 10
+#define	NC_VARIABLE 11
+#define	NC_ATTRIBUTE 12
+#endif
+
+
+/*
+ * C data types corresponding to netCDF data types:
+ */
+/* Don't use these or the C++ interface gets confused
+typedef char  ncchar;
+typedef char  ncbyte;
+typedef short ncshort;
+typedef float ncfloat;
+typedef double        ncdouble;
+*/
+
+/* 
+ * Variables/attributes of type NC_LONG should use the C type 'nclong'
+ */
+#if defined _CRAYMPP
+typedef short	nclong;
+#elif defined __alpha || (_MIPS_SZLONG == 64)
+typedef int     nclong;   
+#else
+typedef long    nclong;         /* default, compatible type */
+#endif
+
+
+/*
+ * Global netcdf error status variable
+ *  Initialized in error.c
+ */
+#define	NC_NOERR	0	/* No Error */
+#define	NC_EBADID	1	/* Not a netcdf id */
+#define	NC_ENFILE	2	/* Too many netcdfs open */
+#define	NC_EEXIST	3	/* netcdf file exists && NC_NOCLOBBER */
+#define	NC_EINVAL	4	/* Invalid Argument */
+#define	NC_EPERM	5	/* Write to read only */
+#define	NC_ENOTINDEFINE	6	/* Operation not allowed in data mode */
+#define	NC_EINDEFINE	7	/* Operation not allowed in define mode */
+#define	NC_EINVALCOORDS	8	/* Coordinates out of Domain */
+#define	NC_EMAXDIMS	9	/* MAX_NC_DIMS exceeded */
+#define	NC_ENAMEINUSE	10	/* String match to name in use */
+#define NC_ENOTATT	11	/* Attribute not found */
+#define	NC_EMAXATTS	12	/* MAX_NC_ATTRS exceeded */
+#define NC_EBADTYPE	13	/* Not a netcdf data type */
+#define NC_EBADDIM	14	/* Invalid dimension id */
+#define NC_EUNLIMPOS	15	/* NC_UNLIMITED in the wrong index */
+#define	NC_EMAXVARS	16	/* MAX_NC_VARS exceeded */
+#define NC_ENOTVAR	17	/* Variable not found */
+#define NC_EGLOBAL	18	/* Action prohibited on NC_GLOBAL varid */
+#define NC_ENOTNC	19	/* Not a netcdf file */
+#define NC_ESTS         20      /* In Fortran, string too short */
+#define NC_EMAXNAME     21      /* MAX_NC_NAME exceeded */
+#define NC_ENTOOL       NC_EMAXNAME   /* Backward compatibility */
+#define NC_EUNLIMIT     22      /* NC_UNLIMITED size already in use */
+
+#define	NC_EXDR		32	/* */
+#define	NC_SYSERR	-1
+
+extern int ncerr ;
+
+/*
+ * Global options variable. Used to determine behavior of error handler.
+ *  Initialized in lerror.c
+ */
+#define	NC_FATAL	1
+#define	NC_VERBOSE	2
+
+extern int ncopts ;	/* default is (NC_FATAL | NC_VERBOSE) */
+
+/*
+ * NB: The following feature-test line is too long in order to accomodate a 
+ * bug in the VMS 5.3 C compiler.
+ */
+#ifndef HAVE_PROTOTYPES
+#   if defined(__STDC__) || defined(__GNUC__) || defined(__cplusplus) || defined(c_plusplus)
+#       define	HAVE_PROTOTYPES
+#   endif
+#endif
+
+#undef PROTO
+#ifdef HAVE_PROTOTYPES 
+#   define	PROTO(x)	x
+#else
+#   define	PROTO(x)	()
+#endif
+
+#include "hdf2netcdf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int nccreate	PROTO((
+    const char*	path,
+    int		cmode
+));
+extern int ncopen	PROTO((
+    const char*	path,
+    int		mode
+));
+extern int ncredef	PROTO((
+    int		cdfid
+));
+extern int ncendef	PROTO((
+    int		cdfid
+));
+extern int ncclose	PROTO((
+    int		cdfid
+));
+extern int ncinquire	PROTO((
+    int		cdfid,
+    int*	ndims,
+    int*	nvars,
+    int*	natts, 
+    int*	recdim
+));
+extern int ncsync	PROTO((
+    int		cdfid
+));
+extern int ncabort	PROTO((
+    int		cdfid
+));
+extern int ncnobuf	PROTO((
+    int		cdfid
+));
+extern int ncdimdef	PROTO((
+    int		cdfid,
+    const char*	name,
+    long	length
+));
+extern int ncdimid	PROTO((
+    int		cdfid,
+    const char*	name
+));
+extern int ncdiminq	PROTO((
+    int		cdfid,
+    int		dimid,
+    char*	name,
+    long*	length
+));
+extern int ncdimrename	PROTO((
+    int		cdfid,
+    int		dimid,
+    const char*	name
+));
+extern int ncvardef	PROTO((
+    int		cdfid,
+    const char*	name,
+    nc_type	datatype, 
+    int		ndims,
+    const int*	dim
+));
+extern int ncvarid	PROTO((
+    int		cdfid,
+    const char*	name
+));
+extern int ncvarinq	PROTO((
+    int		cdfid,
+    int		varid,
+    char*	name,
+    nc_type*	datatype,
+    int*	ndims,
+    int*	dim,
+    int*	natts
+));
+extern int ncvarput1	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	coords,
+    const void*	value
+));
+extern int ncvarget1	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	coords,
+    void*	value
+));
+extern int ncvarput	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	start,
+    const long*	count, 
+    void*	value
+));
+extern int ncvarget	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	start,
+    const long*	count, 
+    void*	value
+));
+extern int ncvarputs	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	start,
+    const long*	count,
+    const long*	stride,
+    void*	values
+));
+extern int ncvargets	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	start,
+    const long*	count,
+    const long*	stride,
+    void*	values
+));
+extern int ncvarputg	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	start,
+    const long*	count,
+    const long*	stride,
+    const long*	imap,
+    void* values
+));
+extern int ncvargetg	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	start,
+    const long*	count,
+    const long*	stride,
+    const long*	imap,
+    void*	values
+));
+extern int ncvarrename	PROTO((
+    int		cdfid,
+    int		varid,
+    const char*	name
+));
+extern int ncattput	PROTO((
+    int		cdfid,
+    int		varid,
+    const char*	name, 
+    nc_type	datatype,
+    int		len,
+    const void*	value
+));
+extern int ncattinq	PROTO((
+    int		cdfid,
+    int		varid,
+    const char*	name, 
+    nc_type*	datatype,
+    int*	len
+));
+extern int ncattget	PROTO((
+    int		cdfid,
+    int		varid,
+    const char*	name, 
+    void*	value
+));
+extern int ncattcopy	PROTO((
+    int		incdf,
+    int		invar,
+    const char*	name, 
+    int		outcdf,
+    int		outvar
+));
+extern int ncattname	PROTO((
+    int		cdfid,
+    int		varid,
+    int		attnum,
+    char*	name
+));
+extern int ncattrename	PROTO((
+    int		cdfid,
+    int		varid,
+    const char*	name, 
+    const char*	newname
+));
+extern int ncattdel	PROTO((
+    int		cdfid,
+    int		varid,
+    const char*	name
+));
+extern int nctypelen	PROTO((
+    nc_type	datatype
+));
+extern int ncsetfill	PROTO((
+    int		cdfid,
+    int		fillmode
+));
+extern int ncrecinq		PROTO((
+    int		cdfid,
+    int*	nrecvars,
+    int*	recvarids,
+    long*	recsizes
+));
+extern int ncrecget		PROTO((
+    int		cdfid,
+    long	recnum,
+    void**	datap
+));
+extern int ncrecput		PROTO((
+    int		cdfid,
+    long	recnum,
+    void* * datap
+));
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _NETCDF_ */
