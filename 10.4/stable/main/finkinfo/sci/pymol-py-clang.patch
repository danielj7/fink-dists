--- pymol-1.5/layer0/Tetsurf.c.orig	2013-06-07 19:07:33.000000000 -0400
+++ pymol-1.5/layer0/Tetsurf.c	2013-06-07 19:08:35.000000000 -0400
@@ -679,8 +679,7 @@
   if(I->Tri) {
     VLAFreeP(I->Tri);
   }
-  if(I->PtLink);
-  {
+  if(I->PtLink) {
     VLAFreeP(I->PtLink);
   }
   if(I->VertexCodes) {
--- pymol-1.5/layer1/P.c.orig	2013-06-07 19:19:20.000000000 -0400
+++ pymol-1.5/layer1/P.c	2013-06-07 19:19:39.000000000 -0400
@@ -2613,7 +2613,7 @@
       /* don't run if we're currently banned */
       char *buffer = 0;
       int size, curSize = 0;
-      while(size = OrthoCommandOutSize(G)){
+      while((size = OrthoCommandOutSize(G))){
 	if (!curSize){
 	  buffer = VLACalloc(char, size);
 	  curSize = size;
@@ -2657,7 +2657,7 @@
   int did_work = false;
   char *buffer = 0;
   int size, curSize = 0;
-  while(size = OrthoCommandOutSize(G)){
+  while((size = OrthoCommandOutSize(G))){
     if (!curSize){
       buffer = VLACalloc(char, size);
       curSize = size;
--- pymol-1.5/layer1/Ortho.c.orig	2013-06-07 19:10:57.000000000 -0400
+++ pymol-1.5/layer1/Ortho.c	2013-06-07 19:16:16.000000000 -0400
@@ -1014,7 +1014,7 @@
         curLine = I->CurLine & OrthoSaveLines;
         if(I->PromptChar) {
           strcpy(buffer, I->Line[curLine]);
-          if(PComplete(G, buffer + I->PromptChar, sizeof(OrthoLineType) - I->PromptChar));      /* just print, don't complete */
+          PComplete(G, buffer + I->PromptChar, sizeof(OrthoLineType) - I->PromptChar);      /* just print, don't complete */
         }
       }
       break;
--- pymol-1.5/layer1/Control.c.orig	2013-06-07 19:20:31.000000000 -0400
+++ pymol-1.5/layer1/Control.c	2013-06-07 19:20:50.000000000 -0400
@@ -637,7 +637,7 @@
       but_bottom = y - (cControlBoxSize - 1);
       but_height = cControlBoxSize;
 
-      if((but_num == I->Active)) {
+      if(but_num == I->Active) {
         draw_button(but_left, but_bottom,
                     but_width, but_height, lightEdge, darkEdge, pushed);
       } else if(((but_num == 6) && ((int) SettingGet(G, cSetting_seq_view))) ||
--- pymol-1.5/layer1/Scene.c.orig	2013-06-07 19:22:02.000000000 -0400
+++ pymol-1.5/layer1/Scene.c	2013-06-07 19:41:53.000000000 -0400
@@ -7640,7 +7640,7 @@
       /* update all gadgets first (single-threaded since they're thread-unsafe) */
       rec = NULL;
       while(ListIterate(I->Obj, rec, next)) {
-        if((rec->obj->type == cObjectGadget)) {
+        if(rec->obj->type == cObjectGadget) {
           if(rec->obj->fUpdate)
             rec->obj->fUpdate(rec->obj);
         }
--- pymol-1.5/layer2/ObjectMolecule.c.orig	2013-06-07 19:42:56.000000000 -0400
+++ pymol-1.5/layer2/ObjectMolecule.c	2013-06-07 19:46:08.000000000 -0400
@@ -1448,7 +1448,7 @@
   int NPHIH, MPHIA, NHPARM, NPARM, NNB, NRES;
   int NBONA, NTHETA, NPHIA, NUMBND, NUMANG, NPTRA;
   int NATYP, NPHB, IFPERT, NBPER, NGPER, NDPER;
-  int MBPER, MGPER, MDPER, IFBOX, NMXRS, IFCAP;
+  int MBPER, MGPER, MDPER, IFBOX = 0, NMXRS, IFCAP;
   int NEXTRA, IPOL = 0;
   int wid, col;
   float BETA;
@@ -2076,7 +2076,7 @@
 
     if(IFBOX > 0) {
 
-      int IPTRES, NSPM, NSPSOL;
+      int IPTRES, NSPM = 0, NSPSOL;
 
       if(amber7) {
         p = findflag(G, buffer, "SOLVENT_POINTERS", "3I8");
@@ -10539,7 +10539,7 @@
                 rms = MatrixFitRMSTTTf(G, op->nvv1, op->vv1, vt, NULL, op->ttt);
               else
                 rms = MatrixGetRMS(G, op->nvv1, op->vv1, vt, NULL);
-              if((op->i1 == 2)) {
+              if(op->i1 == 2) {
                 ObjectMoleculeTransformTTTf(I, op->ttt, b);
 
                 if(op->i3) {
--- pymol-1.5/modules/cealign/src/tnt/tnt_array1d.h.orig	2013-06-07 19:51:46.000000000 -0400
+++ pymol-1.5/modules/cealign/src/tnt/tnt_array1d.h	2013-06-07 19:52:08.000000000 -0400
@@ -258,7 +258,7 @@
 template <class T>
 inline Array1D<T> Array1D<T>::subarray(int i0, int i1)
 {
-	if ((i0 >= 0) && (i1 < n_) || (i0 <= i1))
+	if (((i0 >= 0) && (i1 < n_)) || (i0 <= i1))
 	{
 		Array1D<T> X(*this);  /* create a new instance of this array. */
 		X.n_ = i1-i0+1;
--- pymol-1.5/modules/cealign/src/tnt/tnt_fortran_array1d.h.orig	2013-06-07 19:53:25.000000000 -0400
+++ pymol-1.5/modules/cealign/src/tnt/tnt_fortran_array1d.h	2013-06-07 19:53:54.000000000 -0400
@@ -221,7 +221,7 @@
 #ifdef TNT_DEBUG
 		std::cout << "entered subarray. \n";
 #endif
-	if ((i0 > 0) && (i1 < n_) || (i0 <= i1))
+	if (((i0 > 0) && (i1 < n_)) || (i0 <= i1))
 	{
 		Fortran_Array1D<T> X(*this);  /* create a new instance of this array. */
 		X.n_ = i1-i0+1;
--- pymol-1.5/layer3/Executive.c.orig	2013-06-07 19:55:06.000000000 -0400
+++ pymol-1.5/layer3/Executive.c	2013-06-07 19:56:00.000000000 -0400
@@ -15915,7 +15915,7 @@
                           ExecutiveSpecSetVisibility(G, rec, true, mod, false);
                           I->LastChanged = rec;
                         }
-                        if((mod == (cOrthoSHIFT | cOrthoCTRL))) {
+                        if(mod == (cOrthoSHIFT | cOrthoCTRL)) {
                           if(rec != I->LastZoomed)
                             ExecutiveWindowZoom(G, rec->name, 0.0F, -1, false, -1.0F,
                                                 true);
--- pymol-1.5/contrib/uiuc/plugins/molfile_plugin/src/gamessplugin.c.orig	2013-06-07 19:57:24.000000000 -0400
+++ pymol-1.5/contrib/uiuc/plugins/molfile_plugin/src/gamessplugin.c	2013-06-07 19:57:54.000000000 -0400
@@ -375,7 +375,7 @@
                   const char *filetype, int *natoms) {
 
   FILE *fd;
-  qmdata_t *data;
+  qmdata_t *data = NULL;
   gmsdata *gms;
 
   /* open the input file */
--- pymol-1.5/contrib/uiuc/plugins/molfile_plugin/src/moldenplugin.c.orig	2013-06-07 19:59:19.000000000 -0400
+++ pymol-1.5/contrib/uiuc/plugins/molfile_plugin/src/moldenplugin.c	2013-06-07 19:59:37.000000000 -0400
@@ -99,7 +99,7 @@
                               const char *filetype,
                               int *natoms) {
   FILE *fd;
-  qmdata_t *data;
+  qmdata_t *data = NULL;
   moldendata_t *moldendata;
   char buffer[1024];
   char keystring[20];
--- pymol-1.5/layer4/Cmd.c.orig	2013-06-07 20:01:48.000000000 -0400
+++ pymol-1.5/layer4/Cmd.c	2013-06-07 20:03:00.000000000 -0400
@@ -1846,7 +1846,7 @@
 static PyObject *CmdGetRenderer(PyObject * self, PyObject * args)
 {
   PyMOLGlobals *G = NULL;
-  char *vendor, *renderer, *version;
+  char *vendor = NULL, *renderer = NULL, *version = NULL;
   int ok = false;
   ok = PyArg_ParseTuple(args, "O", &self);
   if(ok) {
--- pymol-1.5/contrib/uiuc/plugins/molfile_plugin/src/graspplugin.cpp.orig	2013-06-07 20:04:28.000000000 -0400
+++ pymol-1.5/contrib/uiuc/plugins/molfile_plugin/src/graspplugin.cpp	2013-06-07 20:04:44.000000000 -0400
@@ -104,7 +104,7 @@
 
   ///ojo aqui le quite el  !
   if ((grassp->flag)!=POTENTIALS) {
-    if (index >=0 && index <= 4) 
+    if (index <= 4) 
       printf("graspplugin) No data available for '%s' option\n", name[index]);
     else 
       printf("graspplugin) out of range property, flag: %d index: %d\n", grassp->flag, index);
--- pymol-1.5/contrib/uiuc/plugins/molfile_plugin/src/maeffplugin.cpp.orig	2013-06-07 20:09:26.000000000 -0400
+++ pymol-1.5/contrib/uiuc/plugins/molfile_plugin/src/maeffplugin.cpp	2013-06-07 20:09:56.000000000 -0400
@@ -1983,7 +1983,7 @@
       }
     }
     catch (std::exception &e) {
-      fprintf(stderr, e.what());
+      fprintf(stderr, "%s", e.what());
       return MOLFILE_ERROR;
     }
     return MOLFILE_SUCCESS;
--- pymol-1.5/contrib/pyopengl/openglutil.c.orig	2013-06-07 20:11:42.000000000 -0400
+++ pymol-1.5/contrib/pyopengl/openglutil.c	2013-06-07 20:12:18.000000000 -0400
@@ -278,7 +278,7 @@
 	if (pix > 127.0)
 	    bitpixel |= 0x01;
 
-	fprintf(fp, "%02hx", bitpixel);
+	fprintf(fp, "%02hhx", bitpixel);
 	if (++pos >= 40) {
 	    fprintf(fp, "\n%%");
 	    pos = 0;
@@ -320,7 +320,7 @@
     curpix = (unsigned char *) pixels;
     pos = 0;
     for (i = width * height * components; i > 0; i--) {
-	fprintf(fp, "%02hx", *curpix++);
+	fprintf(fp, "%02hhx", *curpix++);
 	if (++pos >= 40) {
 	    fprintf(fp, "\n");
 	    pos = 0;
--- pymol-1.5/contrib/uiuc/plugins/molfile_plugin/src/pbeqplugin.cpp.orig	2013-06-07 20:21:43.000000000 -0400
+++ pymol-1.5/contrib/uiuc/plugins/molfile_plugin/src/pbeqplugin.cpp	2013-06-07 20:22:02.000000000 -0400
@@ -259,7 +259,7 @@
         int addr = z*nclx*ncly + y*nclx + x;
         if (fread(datablock + addr, 4, 1, fd) != 1) {
           printf("pbeqplugin) Error reading potential map cell: %d,%d,%d\n", x, y, z);
-          printf("pbeqplugin) offset: %d\n", ftell(fd));
+          printf("pbeqplugin) offset: %ld\n", ftell(fd));
           return MOLFILE_ERROR;
         }
         count++;
--- pymol-1.5/contrib/uiuc/plugins/molfile_plugin/src/vtfplugin.c.orig	2013-06-07 20:26:11.000000000 -0400
+++ pymol-1.5/contrib/uiuc/plugins/molfile_plugin/src/vtfplugin.c	2013-06-07 20:37:17.000000000 -0400
@@ -231,7 +231,7 @@
     switch (tolower(keyword[0])) {
     case 'n': {
       /* name */
-      if (sscanf(s, "%16s %n", &atom.name, &n) < 1) {
+      if (sscanf(s, "%16s %n", (char *) &atom.name, &n) < 1) {
 	vtf_error("could not get name in atom record", line);
 	return MOLFILE_ERROR;
       }
@@ -240,7 +240,7 @@
     }
     case 't': {
       /* type */
-      if (sscanf(s, "%16s %n", &atom.type, &n) < 1) {
+      if (sscanf(s, "%16s %n", (char *) &atom.type, &n) < 1) {
 	vtf_error("could not get type in atom record", line);
 	return MOLFILE_ERROR;
       }
@@ -266,7 +266,7 @@
       } else if (strcmp(keyword, "res") == 0 || 
 		 strcmp(keyword, "resname") == 0) {
 	/* resname */
-	if (sscanf(s, "%8s %n", &atom.resname, &n) < 1) {
+	if (sscanf(s, "%8s %n", (char *) &atom.resname, &n) < 1) {
 	  vtf_error("could not get resname in atom record", line);
 	  return MOLFILE_ERROR;
 	}
@@ -281,7 +281,7 @@
     }
     case 's': {
       /* segid */
-      if (sscanf(s, "%8s %n", &atom.segid, &n) < 1) {
+      if (sscanf(s, "%8s %n", (char *) &atom.segid, &n) < 1) {
 	vtf_error("could not get segid in atom record", line);
 	return MOLFILE_ERROR;
       }
@@ -290,7 +290,7 @@
     }
     case 'i': {
       /* insertion */
-      if (sscanf(s, "%2s %n", &atom.insertion, &n) < 1) {
+      if (sscanf(s, "%2s %n", (char *) &atom.insertion, &n) < 1) {
 	vtf_error("could not get insertion in atom record", line);
 	return MOLFILE_ERROR;
       }
@@ -302,7 +302,7 @@
       /* chain, charge */
       if (strlen(keyword) == 1 || 
 	  strcmp(keyword, "chain") == 0) {
-	if (sscanf(s, "%2s %n", &atom.chain, &n) < 1) {
+	if (sscanf(s, "%2s %n", (char *) &atom.chain, &n) < 1) {
 	  vtf_error("could not get chain in atom record", line);
 	  return MOLFILE_ERROR;
 	}
@@ -336,7 +336,7 @@
 	}
 	d->optflags |= MOLFILE_ATOMICNUMBER;
       } else if (strcmp(keyword, "altloc")) {
-	if (sscanf(s, "%2s %n", &atom.altloc, &n) < 1) {
+	if (sscanf(s, "%2s %n", (char *) &atom.altloc, &n) < 1) {
 	  vtf_error("could not get altloc in atom record", line);
 	  return MOLFILE_ERROR;
 	}
--- pymol-1.6.0/layer0/ShaderMgr.c.orig	2013-08-23 08:40:42.000000000 -0400
+++ pymol-1.6.0/layer0/ShaderMgr.c	2013-08-23 08:48:53.000000000 -0400
@@ -150,7 +150,7 @@
     while (replaceStrings[i]){
       slen = strlen(replaceStrings[i]);
       rlen = strlen(replaceStrings[i+1]);
-      while(rstr=strstr(dest_line, replaceStrings[i])){
+      while((rstr=strstr(dest_line, replaceStrings[i]))){
 	strcpy(tmp_line, rstr + slen);
 	strcpy(rstr, replaceStrings[i+1]);
 	strcpy(rstr+rlen, tmp_line);
@@ -488,15 +488,15 @@
   if (I){
     GLenum err ;
     glBindAttribLocation(I->id, VERTEX_POS, "a_Vertex");
-    if (err = glGetError()){
+    if ((err = glGetError())){
       PRINTFB(G, FB_ShaderMgr, FB_Warnings) "GLERROR: a_Vertex: %d\n", err ENDFB(G);
     }
     glBindAttribLocation(I->id, VERTEX_NORMAL, "a_Normal");
-    if (err = glGetError()){
+    if ((err = glGetError())){
       PRINTFB(G, FB_ShaderMgr, FB_Warnings) "GLERROR: a_Normal: %d\n", err ENDFB(G);
     }
     glBindAttribLocation(I->id, VERTEX_COLOR, "a_Color");
-    if (err = glGetError()){
+    if ((err = glGetError())){
       PRINTFB(G, FB_ShaderMgr, FB_Warnings) "GLERROR: a_Color: %d\n", err ENDFB(G);
     }
     CShaderPrg_Link(I);
@@ -510,19 +510,19 @@
   if (I){
     GLenum err ;
     glBindAttribLocation(I->id, CYLINDER_ORIGIN, "attr_origin");
-    if (err = glGetError()){
+    if ((err = glGetError())){
       PRINTFB(G, FB_ShaderMgr, FB_Warnings) "GLERROR: attr_origin: %d\n", err ENDFB(G);
     }
     glBindAttribLocation(I->id, CYLINDER_AXIS, "attr_axis");
-    if (err = glGetError()){
+    if ((err = glGetError())){
       PRINTFB(G, FB_ShaderMgr, FB_Warnings) "GLERROR: attr_axis: %d\n", err ENDFB(G);
     }
     glBindAttribLocation(I->id, CYLINDER_COLOR, "attr_color");
-    if (err = glGetError()){
+    if ((err = glGetError())){
       PRINTFB(G, FB_ShaderMgr, FB_Warnings) "GLERROR: attr_color: %d\n", err ENDFB(G);
     }
     glBindAttribLocation(I->id, CYLINDER_COLOR2, "attr_color2");
-    if (err = glGetError()){
+    if ((err = glGetError())){
       PRINTFB(G, FB_ShaderMgr, FB_Warnings) "GLERROR: attr_color2: %d\n", err ENDFB(G);
     }
     CShaderPrg_Link(I);	  
@@ -842,11 +842,11 @@
     if (indicatorShader){
       GLenum err ;
       glBindAttribLocation(indicatorShader->id, VERTEX_POS, "a_Vertex");
-      if (err = glGetError()){
+      if ((err = glGetError())){
 	PRINTFB(G, FB_ShaderMgr, FB_Warnings) "GLERROR: a_Vertex: %d\n", err ENDFB(G);
       }
       glBindAttribLocation(indicatorShader->id, VERTEX_COLOR, "a_Color");
-      if (err = glGetError()){
+      if ((err = glGetError())){
 	PRINTFB(G, FB_ShaderMgr, FB_Warnings) "GLERROR: a_Color: %d\n", err ENDFB(G);
       }
       CShaderPrg_Link(indicatorShader);	
--- pymol-1.6.0/layer1/Extrude.c.orig	2013-08-23 10:11:35.000000000 -0400
+++ pymol-1.6.0/layer1/Extrude.c	2013-08-23 10:13:25.000000000 -0400
@@ -753,7 +753,7 @@
   float *v;
   float *n;
   float *c;
-  float *sv, *sn, *tv, *tn, *tv1, *tn1, *TV, *TN;
+  float *sv, *sn, *tv, *tn, *tv1, *tn1, *TV, *TN = NULL;
   float v0[3];
   int start, stop;
   int ok = true;
@@ -1683,7 +1683,7 @@
   float *v;
   float *n;
   float *c;
-  float *sv, *sn, *tv, *tn, *tv1, *tn1, *TV, *TN;
+  float *sv, *sn, *tv, *tn, *tv1, *tn1, *TV, *TN = NULL;
   float v0[3];
   int ok = true;
 
@@ -1737,7 +1737,7 @@
     for(b = 0; ok && b < I->Ns; b += 2) {
 #ifdef _PYMOL_CGO_DRAWARRAYS
       int nverts = 2*I->N, pl = 0, plc = 0, damode = CGO_VERTEX_ARRAY | CGO_NORMAL_ARRAY | CGO_PICK_COLOR_ARRAY, nxtn = 3;
-      float *vertexVals, *normalVals, *colorVals = 0, *nxtVals = 0, *tmp_ptr;
+      float *vertexVals = NULL, *normalVals, *colorVals = 0, *nxtVals = 0, *tmp_ptr;
       float *pickColorVals;
       GLenum mode = GL_LINE_STRIP;
       if(SettingGetGlobal_i(I->G, cSetting_cartoon_debug) < 1.5)
@@ -2048,7 +2048,7 @@
       i = I->i;
       if (ok){
 	int nverts = 2*I->N, pl = 0, plc = 0, damode = CGO_VERTEX_ARRAY | CGO_NORMAL_ARRAY | CGO_PICK_COLOR_ARRAY, nxtn = 3;
-	float *vertexVals, *normalVals, *colorVals = 0, *nxtVals = 0, *tmp_ptr;
+	float *vertexVals = NULL, *normalVals, *colorVals = 0, *nxtVals = 0, *tmp_ptr;
 	float *pickColorVals;
 	if (color_override)
 	  ok &= CGOColorv(cgo, color_override);
@@ -2156,7 +2156,7 @@
   float *v;
   float *n;
   float *c;
-  float *sv, *sn, *tv, *tn, *tv1, *tn1, *TV, *TN;
+  float *sv, *sn, *tv, *tn, *tv1, *tn1, *TV, *TN = NULL;
   float v0[3], n0[3], s0[3], z[3] = { 1.0, 0.0, 1.0 };
   int subN;
   int ok = true;
--- pymol-1.6.0/layer1/Basis.c.orig	2013-08-23 08:56:15.000000000 -0400
+++ pymol-1.6.0/layer1/Basis.c	2013-08-23 08:57:18.000000000 -0400
@@ -2868,11 +2868,11 @@
   float ll;
   CPrimitive *prm;
   register int i;
-  register int *tempRef;
-  int n, h, q, x, y, z, j, k, l, e;
+  register int *tempRef = NULL;
+  int n = 0, h, q, x, y, z, j, k, l, e;
   int extra_vert = 0;
   float p[3], dd[3], *d1, *d2, vd[3], cx[3], cy[3];
-  float *tempVertex;
+  float *tempVertex = NULL;
   float xs, ys;
   int remapMode = true;         /* remap mode means that some objects will span more
                                  * than one voxel, so we have to worry about populating
--- pymol-1.6.0/layer1/CGO.c.orig	2013-08-23 08:58:55.000000000 -0400
+++ pymol-1.6.0/layer1/CGO.c	2013-08-23 09:05:57.000000000 -0400
@@ -47,7 +47,7 @@
 #define CLIP_NORMAL_VALUE(cv)  ((cv>1.f) ? 127 :  (cv < -1.f) ? -128 : pymol_roundf(((cv + 1.f)/2.f) * 255) - 128 )
 
 #define CHECK_GL_ERROR_OK(printstr)	\
-  if (err = glGetError()){    \
+  if ((err = glGetError())){    \
      PRINTFB(I->G, FB_CGO, FB_Errors) printstr, err ENDFB(I->G);	   \
   }
 
@@ -2279,7 +2279,7 @@
   *num_total_vertices = 0;
   *num_total_indexes = 0;
 
-  while(op = (CGO_MASK & CGO_read_int(pc))) {
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
     save_pc = pc;
     err = 0;
     switch (op) {
@@ -4339,7 +4339,7 @@
     GL_C_INT_TYPE *indexVals = 0;
     int tot = 4 * 4 * 3 * num_total_cylinders;
     short copyToLeftOver, copyColorToLeftOver, copyPickColorToLeftOver, copyAlphaToLeftOver, copyToReturnCGO ;
-    float *org_originVals;
+    float *org_originVals= NULL;
     float *org_axisVals;
     float *org_colorVals;
     float *org_color2Vals = NULL;
@@ -7101,7 +7101,7 @@
   int  texture_id = CGO_get_int(*pc);
   float worldPos[4], screenMin[3], screenMax[3], textExtent[4];
   CShaderPrg * shaderPrg;
-  int buf1, buf2, attr_worldpos, attr_screenoffset, attr_texcoords;
+  int buf1 = 0, buf2 = 0, attr_worldpos, attr_screenoffset, attr_texcoords;
   copy3f(*pc, worldPos);  worldPos[3] = 1.f;
   copy3f(*pc+3, screenMin);
   copy3f(*pc+6, screenMax);
@@ -7142,7 +7142,7 @@
   int  texture_id = CGO_get_int(*pc);
   float worldPos[4], screenMin[3], screenMax[3], textExtent[4];
   CShaderPrg * shaderPrg;
-  int buf1, buf2, attr_worldpos, attr_screenoffset, attr_texcoords;
+  int buf1 = 0, buf2 = 0, attr_worldpos, attr_screenoffset, attr_texcoords;
   copy3f(*pc, worldPos);  worldPos[3] = 1.f;
   copy3f(*pc+3, screenMin);
   copy3f(*pc+6, screenMax);
@@ -9528,7 +9528,7 @@
 int CGOChangeShadersTo(CGO *I, int frommode, int tomode){
   register float *pc = I->op;
   int op = 0, totops = 0;
-  while(op = (CGO_MASK & CGO_read_int(pc))) {
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
     totops++;
     switch (op) {
     case CGO_ENABLE:
--- pymol-1.6.0/layer1/Ortho.c.orig	2013-08-23 09:08:11.000000000 -0400
+++ pymol-1.6.0/layer1/Ortho.c	2013-08-23 09:08:43.000000000 -0400
@@ -1394,7 +1394,7 @@
 
   {
     if (!I->bgCGO) {
-      CGO *cgo = CGONew(G), *cgo2;
+      CGO *cgo = CGONew(G), *cgo2 = NULL;
       ok &= CGOBegin(cgo, GL_TRIANGLE_STRIP);
       if (ok)
 	ok &= CGOVertex(cgo, -1.f, -1.f, 0.98f);
--- pymol-1.6.0/layer0/Map.c.orig	2013-08-23 09:09:51.000000000 -0400
+++ pymol-1.6.0/layer0/Map.c	2013-08-23 09:10:15.000000000 -0400
@@ -588,7 +588,7 @@
   register int *link = I->Link;
   register int st, flag;
   register int *i_ptr3, *i_ptr4, *i_ptr5;
-  register int *e_list;
+  register int *e_list = NULL;
 #ifdef _MemoryCache_ON
   register int block_offset = I->block_base + cCache_map_elist_offset;
   register int group_id = I->group_id;
--- pymol-1.6.0/layer2/RepDot.c.orig	2013-08-23 09:11:34.000000000 -0400
+++ pymol-1.6.0/layer2/RepDot.c	2013-08-23 09:14:10.000000000 -0400
@@ -192,7 +192,7 @@
 	      ok &= CGOColorv(cgo, v);
 	      v += 3;
 	    }
-           /*      if(normals)  /* NORMALS do not get set for points 
+           /*      if(normals)  NORMALS do not get set for points 
                    CGONormalv(cgo, v);*/
 	    v += 3;
 	    if (ok)
@@ -210,7 +210,7 @@
 	    I->shaderCGO = CGOOptimizeSpheresToVBONonIndexed(cgo, CGO_BOUNDING_BOX_SZ + CGO_DRAW_SPHERE_BUFFERS_SZ);
 	    CHECKOK(ok, I->shaderCGO);
 	  } else {
-	    CGO *convertcgo = CGOCombineBeginEnd(cgo, 0), *tmpCGO;
+	    CGO *convertcgo = CGOCombineBeginEnd(cgo, 0), *tmpCGO = NULL;
 	    CHECKOK(ok, convertcgo);
 	    if (ok)
 	      tmpCGO = CGOOptimizeToVBONotIndexed(convertcgo, CGO_BOUNDING_BOX_SZ + I->N * 3 + 7);
@@ -344,7 +344,7 @@
   float *countPtr = NULL;
   int colorCnt, lastColor;
   Vector3f v1;
-  MapType *map;
+  MapType *map = NULL;
   SphereRec *sp = G->Sphere->Sphere[0];
   int ds;
   float max_vdw = MAX_VDW;
--- pymol-1.6.0/layer2/RepCartoon.c.orig	2013-08-23 09:15:13.000000000 -0400
+++ pymol-1.6.0/layer2/RepCartoon.c	2013-08-23 09:15:33.000000000 -0400
@@ -2615,7 +2615,7 @@
 
 #ifdef _PYMOL_CGO_DRAWARRAYS
 	int nverts = nAt * 4, pl = 0;
-	float *vertexVals, *tmp_ptr;
+	float *vertexVals = NULL, *tmp_ptr;
 	if (ok)
 	  vertexVals = CGODrawArrays(cgo, GL_LINES, CGO_VERTEX_ARRAY, nverts);      
 	CHECKOK(ok, vertexVals);
--- pymol-1.6.0/layer2/ObjectMolecule.c.orig	2013-08-23 09:16:59.000000000 -0400
+++ pymol-1.6.0/layer2/ObjectMolecule.c	2013-08-23 09:17:39.000000000 -0400
@@ -4431,7 +4431,7 @@
   AtomInfoType *ai;
   int n, nn;
   float v[3], v0[3], d;
-  CoordSet *cs;
+  CoordSet *cs = NULL;
   int ok = true;
 
   ok &= ObjectMoleculeUpdateNeighbors(I);
@@ -9755,7 +9755,7 @@
 			CoordSet * cs, int bondSearchFlag, int aic_mask, int invalidate)
 {
   PyMOLGlobals *G = I->Obj.G;
-  int *index, *outdex, *a2i, *i2a;
+  int *index, *outdex, *a2i, *i2a = NULL;
   BondType *bond = NULL;
   register int a, b, lb = 0, ac;
   int c, nb, a1, a2;
--- pymol-1.6.0/layer3/PlugIOManager.c.orig	2013-08-23 09:18:58.000000000 -0400
+++ pymol-1.6.0/layer3/PlugIOManager.c	2013-08-23 09:21:05.000000000 -0400
@@ -225,7 +225,7 @@
                       ENDFB(G);
                   }
 
-                  if(stop > 0 && cnt >= stop || max > 0 && ncnt >= max) {
+                  if((stop > 0 && cnt >= stop) || (max > 0 && ncnt >= max)) {
                     cs = NULL;
                     break;
                   }
--- pymol-1.6.0/layer2/RepSphere.c.orig	2013-08-23 09:22:18.000000000 -0400
+++ pymol-1.6.0/layer2/RepSphere.c	2013-08-23 09:33:47.000000000 -0400
@@ -1991,8 +1991,8 @@
   int a;
   SphereRec *sp = I->SP;
   float alpha;
-  int n_quad_verts;
-  float radius;
+  int n_quad_verts = 0;
+  float radius = 0.0;
   int ok = true;
   short use_shader = SettingGetGlobal_b(G, cSetting_sphere_use_shader) & 
                      SettingGetGlobal_b(G, cSetting_use_shaders);
--- pymol-1.6.0/layer2/RepSurface.c.orig	2013-08-22 16:13:32.000000000 -0400
+++ pymol-1.6.0/layer2/RepSurface.c	2013-08-23 09:30:18.000000000 -0400
@@ -3304,7 +3304,7 @@
 	    if (ok)
 	      convertcgo->use_shader = true;
 	  } else if (I->Type == 2) {
-	    CGO *convertcgo2, *simple;
+	    CGO *convertcgo2, *simple = NULL;
 	    convertcgo2 = CGOConvertLinesToShaderCylinders(I->shaderCGO, 0);
 	    CHECKOK(ok, convertcgo2);
 	    if (ok)
@@ -4503,7 +4503,7 @@
         }
 	ok &= !G->Interrupt;
         if(ok) {
-          MapType *map, *solv_map;
+          MapType *map, *solv_map = NULL;
           map = MapNewFlagged(G, I->maxVdw + probe_rad_more,
                               I->coord, VLAGetSize(I->coord) / 3, NULL, NULL);
 	  CHECKOK(ok, map);
@@ -5747,7 +5747,7 @@
                 SurfaceJobAtomInfo *j_atom_info = atom_info + j;
                 if(j > a)       /* only check if this is atom trails */
                   if((!present) || present[j]) {
-                    if((j_atom_info->vdw == a_atom_info->vdw)) {        /* handle singularities */
+                    if(j_atom_info->vdw == a_atom_info->vdw) {        /* handle singularities */
                       float *v1 = coord + 3 * j;
                       if((v0[0] == v1[0]) && (v0[1] == v1[1]) && (v0[2] == v1[2]))
                         skip_flag = true;
@@ -5842,7 +5842,7 @@
                   SurfaceJobAtomInfo *j_atom_info = atom_info + j;
                   if(j > a)     /* only check if this is atom trails */
                     if((!present) || present[j]) {
-                      if((j_atom_info->vdw == a_atom_info->vdw)) {      /* handle singularities */
+                      if(j_atom_info->vdw == a_atom_info->vdw) {      /* handle singularities */
                         float *v2 = coord + 3 * j;
                         if((v0[0] == v2[0]) && (v0[1] == v2[1]) && (v0[2] == v2[2]))
                           skip_flag = true;
@@ -6002,7 +6002,7 @@
                   SurfaceJobAtomInfo *j_atom_info = atom_info + j;
                   if(j > a)       /* only check if this is atom trails */
                     if((!present) || present[j]) {
-                      if((j_atom_info->vdw == a_atom_info->vdw)) {        /* handle singularities */
+                      if(j_atom_info->vdw == a_atom_info->vdw) {        /* handle singularities */
                         float *v1 = coord + 3 * j;
                         if((v0[0] == v1[0]) && (v0[1] == v1[1]) && (v0[2] == v1[2]))
                           skip_flag = true;
--- pymol-1.6.0/layer3/Selector.c.orig	2013-08-23 09:37:29.000000000 -0400
+++ pymol-1.6.0/layer3/Selector.c	2013-08-23 09:38:53.000000000 -0400
@@ -8615,11 +8615,11 @@
     for(a = cNDummyAtoms; a < I->NAtom; a++) {
       b = i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].protons;
       base[0].sele[a] = (
-          b >  2 && b <  5 ||
-          b > 10 && b < 14 ||
-          b > 18 && b < 32 ||
-          b > 36 && b < 51 ||
-          b > 54 && b < 85 ||
+          (b >  2 && b <  5) ||
+          (b > 10 && b < 14) ||
+          (b > 18 && b < 32) ||
+          (b > 36 && b < 51) ||
+          (b > 54 && b < 85) ||
           b > 86);
     }
     break;
--- pymol-1.6.0/layer2/ObjectMolecule2.c.orig	2013-08-22 16:13:32.000000000 -0400
+++ pymol-1.6.0/layer2/ObjectMolecule2.c	2013-08-23 09:44:20.000000000 -0400
@@ -3678,7 +3678,7 @@
 #else
   int ok = true;
   ObjectMolecule *I = NULL;
-  int discrete_flag;
+  int discrete_flag = 0;
   int ll;
   (*result) = NULL;
 
@@ -4305,7 +4305,7 @@
   register int a, b;
   CoordSet *cs, **dcs;
   AtomInfoType *atInfo;
-  int *dAtmToIdx;
+  int *dAtmToIdx = NULL;
   int ok = true;
   if(!I->DiscreteFlag) {        /* currently, discrete objects are never sorted */
     int n_bytes = sizeof(int) * I->NAtom;
--- pymol-1.6.0/layer2/RepCylBond.c.orig	2013-08-23 10:17:15.000000000 -0400
+++ pymol-1.6.0/layer2/RepCylBond.c	2013-08-23 10:17:43.000000000 -0400
@@ -1998,7 +1998,7 @@
             I->NSPC++;
           }
 
-	  if(s2 && (!marked[b2]) && (!stick_ball_filter_single_atoms || (ord==1 || adjacent_atoms[a2] && adjacent_atoms[a2][0] > 1))) {
+	  if(s2 && (!marked[b2]) && (!stick_ball_filter_single_atoms || (ord==1 || (adjacent_atoms[a2] && adjacent_atoms[a2][0] > 1)))) {
 	      /* just once for each atom..., if stick_ball_filter is on, then only for atoms that have more than one adjacent atom */
             float vdw =
               stick_ball_ratio * ((ati2->protons == cAN_H) ? bd_radius : bd_radius_full);
