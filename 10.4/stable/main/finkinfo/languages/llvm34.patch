diff --git a/CREDITS.TXT b/CREDITS.TXT
index 3c1dcb0..ffcaaf1 100644
--- a/CREDITS.TXT
+++ b/CREDITS.TXT
@@ -443,3 +443,9 @@ D: Bunches of stuff
 N: Bob Wilson
 E: bob.wilson@acm.org
 D: Advanced SIMD (NEON) support in the ARM backend.
+
+N: David Fang
+D: PowerPC-Darwin port
+
+N: Iain Sandoe
+D: PowerPC-Darwin port
diff --git a/autoconf/configure.ac b/autoconf/configure.ac
index a9d4915..68832a8 100644
--- a/autoconf/configure.ac
+++ b/autoconf/configure.ac
@@ -1752,11 +1752,11 @@ AC_LINK_IFELSE(
 ],
 [
   AC_MSG_RESULT([yes])
-  AC_DEFINE([LLVM_HAS_ATOMICS], [1], [Has gcc/MSVC atomic intrinsics])
+  AC_DEFINE([LLVM_HAS_ATOMICS], [1], [Has gcc/MSVC/Apple atomic intrinsics])
 ],
 [
   AC_MSG_RESULT([no])
-  AC_DEFINE([LLVM_HAS_ATOMICS], [0], [Has gcc/MSVC atomic intrinsics])
+  AC_DEFINE([LLVM_HAS_ATOMICS], [0], [Has gcc/MSVC/Apple atomic intrinsics])
   AC_MSG_WARN([LLVM will be built thread-unsafe because atomic builtins are missing])
 ])
 AC_LANG_POP([C++])
diff --git a/cmake/config-ix.cmake b/cmake/config-ix.cmake
index dc991a2..c7a4506 100755
--- a/cmake/config-ix.cmake
+++ b/cmake/config-ix.cmake
@@ -346,6 +346,12 @@ get_host_triple(LLVM_INFERRED_HOST_TRIPLE)
 set(LLVM_HOST_TRIPLE "${LLVM_INFERRED_HOST_TRIPLE}" CACHE STRING
     "Host on which LLVM binaries will run")
 
+if( APPLE )
+get_host_osx_version(LLVM_INFERRED_OSX_VERSION)
+set(LLVM_HOST_OSX_VERSION "${LLVM_INFERRED_OSX_VERSION}" CACHE STRING
+    "Host version of Mac OS X")
+endif( APPLE )
+
 # Determine the native architecture.
 string(TOLOWER "${LLVM_TARGET_ARCH}" LLVM_NATIVE_ARCH)
 if( LLVM_NATIVE_ARCH STREQUAL "host" )
diff --git a/cmake/modules/CheckAtomic.cmake b/cmake/modules/CheckAtomic.cmake
index 0d63a82..213b57f 100644
--- a/cmake/modules/CheckAtomic.cmake
+++ b/cmake/modules/CheckAtomic.cmake
@@ -6,6 +6,10 @@ CHECK_CXX_SOURCE_COMPILES("
 #ifdef _MSC_VER
 #include <windows.h>
 #endif
+#define	NEED_DARWIN_ATOMICS (defined(__APPLE__) && defined(__GNUC__) && (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 2)))
+#if NEED_DARWIN_ATOMICS
+#include <libkern/OSAtomic.h>
+#endif
 int main() {
 #ifdef _MSC_VER
         volatile LONG val = 1;
@@ -13,6 +17,12 @@ int main() {
         InterlockedCompareExchange(&val, 0, 1);
         InterlockedIncrement(&val);
         InterlockedDecrement(&val);
+#elif NEED_DARWIN_ATOMICS
+	int32_t val = 1;
+	OSMemoryBarrier();
+	OSAtomicCompareAndSwap32Barrier(1, 0, &val);
+	OSAtomicIncrement32(&val);
+	OSAtomicDecrement32(&val);
 #else
         volatile unsigned long val = 1;
         __sync_synchronize();
diff --git a/cmake/modules/GetHostTriple.cmake b/cmake/modules/GetHostTriple.cmake
index 671a8ce..37caa10 100644
--- a/cmake/modules/GetHostTriple.cmake
+++ b/cmake/modules/GetHostTriple.cmake
@@ -28,3 +28,15 @@ function( get_host_triple var )
   set( ${var} ${value} PARENT_SCOPE )
   message(STATUS "Target triple: ${value}")
 endfunction( get_host_triple var )
+
+# Mac OS X only: get the host version
+function( get_host_osx_version var )
+  if( APPLE )
+    execute_process(COMMAND sw_vers -productVersion COMMAND cut -d. -f1-2
+      RESULT_VARIABLE TT_RV
+      OUTPUT_VARIABLE value
+      OUTPUT_STRIP_TRAILING_WHITESPACE)
+    set( ${var} ${value} PARENT_SCOPE )
+    message(STATUS "Host OS X version: ${value}")
+  endif ( APPLE )
+endfunction( get_host_osx_version var )
diff --git a/include/llvm/ADT/SmallBitVector.h b/include/llvm/ADT/SmallBitVector.h
index 86949b2..305a054 100644
--- a/include/llvm/ADT/SmallBitVector.h
+++ b/include/llvm/ADT/SmallBitVector.h
@@ -34,7 +34,8 @@ class SmallBitVector {
   // pointer to memory containing size, allocation size, and the array of bits.
   uintptr_t X;
 
-  enum {
+// gcc-4.0 workaround: make certain enums non-anonymous
+  enum _nums {
     // The number of bits in this class.
     NumBaseBits = sizeof(uintptr_t) * CHAR_BIT,
 
diff --git a/include/llvm/Bitcode/BitstreamReader.h b/include/llvm/Bitcode/BitstreamReader.h
index dc5e095..658a2dc 100644
--- a/include/llvm/Bitcode/BitstreamReader.h
+++ b/include/llvm/Bitcode/BitstreamReader.h
@@ -136,7 +136,9 @@ public:
 ///   Record   - This is a record with a specific AbbrevID.
 ///
 struct BitstreamEntry {
-  enum {
+// anonymous enum named as workaround to g++-4.0.1 bug (fixed in 4.0.2):
+// http://gcc.gnu.org/bugzilla/show_bug.cgi?id=20589
+  enum KindEnum {
     Error,
     EndBlock,
     SubBlock,
diff --git a/include/llvm/CodeGen/ScheduleDFS.h b/include/llvm/CodeGen/ScheduleDFS.h
index 73ce99f..4f85f0d 100644
--- a/include/llvm/CodeGen/ScheduleDFS.h
+++ b/include/llvm/CodeGen/ScheduleDFS.h
@@ -68,7 +68,14 @@ struct ILPValue {
 class SchedDFSResult {
   friend class SchedDFSImpl;
 
+// workaround gcc-4.0 accessibility bug
+#if !__GNUC_PREREQ(4, 2)
+public:
+#endif
   static const unsigned InvalidSubtreeID = ~0u;
+#if !__GNUC_PREREQ(4, 2)
+private:
+#endif
 
   /// \brief Per-SUnit data computed during DFS for various metrics.
   ///
diff --git a/include/llvm/IR/InlineAsm.h b/include/llvm/IR/InlineAsm.h
index 3398a83..5497822 100644
--- a/include/llvm/IR/InlineAsm.h
+++ b/include/llvm/IR/InlineAsm.h
@@ -197,7 +197,7 @@ public:
   // These are helper methods for dealing with flags in the INLINEASM SDNode
   // in the backend.
   
-  enum LLVM_ENUM_INT_TYPE(uint32_t) {
+  enum OpFields LLVM_ENUM_INT_TYPE(uint32_t) {
     // Fixed operands on an INLINEASM SDNode.
     Op_InputChain = 0,
     Op_AsmString = 1,
diff --git a/include/llvm/MC/MCAsmInfo.h b/include/llvm/MC/MCAsmInfo.h
index 7a99394..9845623 100644
--- a/include/llvm/MC/MCAsmInfo.h
+++ b/include/llvm/MC/MCAsmInfo.h
@@ -266,13 +266,16 @@ namespace llvm {
     /// global as being a weak undefined symbol.
     const char *WeakRefDirective;            // Defaults to NULL.
 
-    /// WeakDefDirective - This directive, if non-null, is used to declare a
-    /// global as being a weak defined symbol.
-    const char *WeakDefDirective;            // Defaults to NULL.
+    /// True if we have a directive to declare a global as being a weak
+    /// defined symbol.
+    bool HasWeakDefDirective;                // Defaults to false.
 
-    /// LinkOnceDirective - This directive, if non-null is used to declare a
-    /// global as being a weak defined symbol.  This is used on cygwin/mingw.
-    const char *LinkOnceDirective;           // Defaults to NULL.
+    /// True if we have a directive to declare a global as being a weak
+    /// defined symbol that can be hidden (unexported).
+    bool HasWeakDefCanBeHiddenDirective;     // Defaults to false.
+
+    /// True if we have a .linkonce directive.  This is used on cygwin/mingw.
+    bool HasLinkOnceDirective;               // Defaults to false.
 
     /// HiddenVisibilityAttr - This attribute, if not MCSA_Invalid, is used to
     /// declare a symbol as having hidden visibility.
@@ -303,6 +306,10 @@ namespace llvm {
     /// uses relocations for references to other .debug_* sections.
     bool DwarfUsesRelocationsAcrossSections;
 
+    /// DwarfFDESymbolsUseAbsDiff - true if DWARF FDE symbol reference
+    /// relocations should be replaced by an absolute difference.
+    bool DwarfFDESymbolsUseAbsDiff;
+
     /// DwarfRegNumForCFI - True if dwarf register numbers are printed
     /// instead of symbolic register names in .cfi_* directives.
     bool DwarfRegNumForCFI;  // Defaults to false;
@@ -497,8 +504,11 @@ namespace llvm {
     bool hasIdentDirective() const { return HasIdentDirective; }
     bool hasNoDeadStrip() const { return HasNoDeadStrip; }
     const char *getWeakRefDirective() const { return WeakRefDirective; }
-    const char *getWeakDefDirective() const { return WeakDefDirective; }
-    const char *getLinkOnceDirective() const { return LinkOnceDirective; }
+    bool hasWeakDefDirective() const { return HasWeakDefDirective; }
+    bool hasWeakDefCanBeHiddenDirective() const {
+      return HasWeakDefCanBeHiddenDirective;
+    }
+    bool hasLinkOnceDirective() const { return HasLinkOnceDirective; }
 
     MCSymbolAttr getHiddenVisibilityAttr() const { return HiddenVisibilityAttr;}
     MCSymbolAttr getHiddenDeclarationVisibilityAttr() const {
@@ -528,6 +538,9 @@ namespace llvm {
     bool doesDwarfUseRelocationsAcrossSections() const {
       return DwarfUsesRelocationsAcrossSections;
     }
+    bool doDwarfFDESymbolsUseAbsDiff() const {
+      return DwarfFDESymbolsUseAbsDiff;
+    }
     bool useDwarfRegNumForCFI() const {
       return DwarfRegNumForCFI;
     }
diff --git a/include/llvm/MC/MCAssembler.h b/include/llvm/MC/MCAssembler.h
index 8735a55..97e0a67 100644
--- a/include/llvm/MC/MCAssembler.h
+++ b/include/llvm/MC/MCAssembler.h
@@ -123,7 +123,7 @@ public:
   virtual void setBundlePadding(uint8_t N) {
   }
 
-  void dump();
+  void dump() const;
 };
 
 /// Interface implemented by fragments that contain encoded instructions and/or
@@ -660,7 +660,7 @@ public:
     BundleGroupBeforeFirstInst = IsFirst;
   }
 
-  void dump();
+  void dump() const;
 
   /// @}
 };
@@ -785,7 +785,7 @@ public:
 
   /// @}
 
-  void dump();
+  void dump() const;
 };
 
 // FIXME: This really doesn't belong here. See comments below.
@@ -1175,7 +1175,7 @@ public:
 
   /// @}
 
-  void dump();
+  void dump() const;
 };
 
 } // end namespace llvm
diff --git a/include/llvm/MC/MCMachObjectWriter.h b/include/llvm/MC/MCMachObjectWriter.h
index 3ba6e65..f3f3b00 100644
--- a/include/llvm/MC/MCMachObjectWriter.h
+++ b/include/llvm/MC/MCMachObjectWriter.h
@@ -17,6 +17,16 @@
 #include "llvm/MC/MCObjectWriter.h"
 #include "llvm/Support/DataTypes.h"
 #include "llvm/Support/MachO.h"
+
+/**
+	Mach-O needs indirect symbols grouped by section.
+	Goal: 1
+ */
+#define ORDER_INDIRECT_SYMBOLS_BY_SECTION       1
+#if ORDER_INDIRECT_SYMBOLS_BY_SECTION
+#include "llvm/ADT/SetVector.h"
+#endif
+
 #include <vector>
 
 namespace llvm {
@@ -112,6 +122,22 @@ class MachObjectWriter : public MCObjectWriter {
 
   /// @}
 
+#if ORDER_INDIRECT_SYMBOLS_BY_SECTION
+  /// @name Indirect Symbol Table Data
+  /// @{
+
+  typedef std::vector<const MCSymbol*>  IndirectSymbol_list_type;
+  typedef DenseMap<const MCSectionData*, IndirectSymbol_list_type>
+						IndirectSymbol_map_type;
+  // keep sections in order of appearance
+  typedef SetVector<const MCSectionData*>	IndirectSymbolSection_set_type;
+
+  IndirectSymbol_map_type			IndirectSymbolMap;
+  IndirectSymbolSection_set_type		IndirectSymbolSections;
+
+  /// @}
+#endif
+
 public:
   MachObjectWriter(MCMachObjectTargetWriter *MOTW, raw_ostream &_OS,
                    bool _IsLittleEndian)
diff --git a/include/llvm/MC/SectionKind.h b/include/llvm/MC/SectionKind.h
index 85a91c6..fbb359a 100644
--- a/include/llvm/MC/SectionKind.h
+++ b/include/llvm/MC/SectionKind.h
@@ -133,6 +133,10 @@ class SectionKind {
 
   } K : 8;
 public:
+#if 1
+// for debugging purposes only
+  Kind getKindEnum(void) const { return K; }
+#endif
 
   bool isMetadata() const { return K == Metadata; }
   bool isText() const { return K == Text; }
diff --git a/include/llvm/Object/RelocVisitor.h b/include/llvm/Object/RelocVisitor.h
index 97912fe..8538f41 100644
--- a/include/llvm/Object/RelocVisitor.h
+++ b/include/llvm/Object/RelocVisitor.h
@@ -128,7 +128,7 @@ public:
     return RelocToApply();
   }
 
-  bool error() { return HasError; }
+  bool error() const { return HasError; }
 
 private:
   StringRef FileFormat;
diff --git a/include/llvm/Support/AlignOf.h b/include/llvm/Support/AlignOf.h
index bba3424..7faeb06 100644
--- a/include/llvm/Support/AlignOf.h
+++ b/include/llvm/Support/AlignOf.h
@@ -36,18 +36,20 @@ private:
 ///  compile-time constant (e.g., for template instantiation).
 template <typename T>
 struct AlignOf {
-  enum { Alignment =
+  enum AlignEnum { Alignment =
          static_cast<unsigned int>(sizeof(AlignmentCalcImpl<T>) - sizeof(T)) };
 
-  enum { Alignment_GreaterEqual_2Bytes = Alignment >= 2 ? 1 : 0 };
-  enum { Alignment_GreaterEqual_4Bytes = Alignment >= 4 ? 1 : 0 };
-  enum { Alignment_GreaterEqual_8Bytes = Alignment >= 8 ? 1 : 0 };
-  enum { Alignment_GreaterEqual_16Bytes = Alignment >= 16 ? 1 : 0 };
+  enum AlignPredicates {
+    Alignment_GreaterEqual_2Bytes = Alignment >= 2 ? 1 : 0,
+    Alignment_GreaterEqual_4Bytes = Alignment >= 4 ? 1 : 0, 
+    Alignment_GreaterEqual_8Bytes = Alignment >= 8 ? 1 : 0, 
+    Alignment_GreaterEqual_16Bytes = Alignment >= 16 ? 1 : 0, 
 
-  enum { Alignment_LessEqual_2Bytes = Alignment <= 2 ? 1 : 0 };
-  enum { Alignment_LessEqual_4Bytes = Alignment <= 4 ? 1 : 0 };
-  enum { Alignment_LessEqual_8Bytes = Alignment <= 8 ? 1 : 0 };
-  enum { Alignment_LessEqual_16Bytes = Alignment <= 16 ? 1 : 0 };
+    Alignment_LessEqual_2Bytes = Alignment <= 2 ? 1 : 0, 
+    Alignment_LessEqual_4Bytes = Alignment <= 4 ? 1 : 0, 
+    Alignment_LessEqual_8Bytes = Alignment <= 8 ? 1 : 0, 
+    Alignment_LessEqual_16Bytes = Alignment <= 16 ? 1 : 0
+  };
 };
 
 /// alignOf - A templated function that returns the minimum alignment of
diff --git a/include/llvm/Support/Atomic.h b/include/llvm/Support/Atomic.h
index 9ec23e8..f1a1fd9 100644
--- a/include/llvm/Support/Atomic.h
+++ b/include/llvm/Support/Atomic.h
@@ -14,14 +14,21 @@
 #ifndef LLVM_SUPPORT_ATOMIC_H
 #define LLVM_SUPPORT_ATOMIC_H
 
+#include "llvm/Support/Compiler.h"	// for __GNUC_PREREQ
 #include "llvm/Support/DataTypes.h"
 
+// convenience macro, to force use of darwin atomic functions
+// stage 1 with gcc-4.0 needs this, but maybe not stage 2?
+#define	USE_DARWIN_ATOMICS	(defined(__APPLE__) && !__GNUC_PREREQ(4, 2))
+
 namespace llvm {
   namespace sys {
     void MemoryFence();
 
 #ifdef _MSC_VER
     typedef long cas_flag;
+#elif USE_DARWIN_ATOMICS
+    typedef int32_t cas_flag;
 #else
     typedef uint32_t cas_flag;
 #endif
diff --git a/include/llvm/Support/Compiler.h b/include/llvm/Support/Compiler.h
index 860f43e..d0e6bbb 100644
--- a/include/llvm/Support/Compiler.h
+++ b/include/llvm/Support/Compiler.h
@@ -179,7 +179,8 @@
 #define LLVM_ATTRIBUTE_USED
 #endif
 
-#if __has_attribute(warn_unused_result) || __GNUC_PREREQ(3, 4)
+// gcc-4.0 spews tons of warning noise, so requiring 4.1 should silence them
+#if __has_attribute(warn_unused_result) || __GNUC_PREREQ(4, 1)
 #define LLVM_ATTRIBUTE_UNUSED_RESULT __attribute__((__warn_unused_result__))
 #else
 #define LLVM_ATTRIBUTE_UNUSED_RESULT
@@ -216,7 +217,9 @@
 #define LLVM_READNONE
 #endif
 
-#if __has_attribute(pure) || defined(__GNUC__)
+// this attribute may be buggy for older gcc-4.0.1 (apple)
+// removing this fixes bug #14244
+#if __has_attribute(pure) || __GNUC_PREREQ(4, 2)
 // aka 'PURE' but following LLVM Conventions.
 #define LLVM_READONLY __attribute__((__pure__))
 #else
diff --git a/include/llvm/Support/Format.h b/include/llvm/Support/Format.h
index aaa54e1..75b249d 100644
--- a/include/llvm/Support/Format.h
+++ b/include/llvm/Support/Format.h
@@ -231,6 +231,43 @@ inline format_object5<T1, T2, T3, T4, T5> format(const char *Fmt,const T1 &Val1,
   return format_object5<T1, T2, T3, T4, T5>(Fmt, Val1, Val2, Val3, Val4, Val5);
 }
 
+// provide some default format strings
+template <typename T1>
+struct default_format_string;
+
+// definitions in Support/Format.cpp
+#define	SPECIALIZE_DEFAULT_FORMAT_STRING(T)				\
+template <>								\
+struct default_format_string<T> {					\
+	static const char hex[];		/* e.g. "%d" */		\
+	static const char dec[];		/* e.g. "%x" */		\
+};
+
+SPECIALIZE_DEFAULT_FORMAT_STRING(int)
+SPECIALIZE_DEFAULT_FORMAT_STRING(long)
+SPECIALIZE_DEFAULT_FORMAT_STRING(long long)
+SPECIALIZE_DEFAULT_FORMAT_STRING(unsigned int)
+SPECIALIZE_DEFAULT_FORMAT_STRING(unsigned long)
+SPECIALIZE_DEFAULT_FORMAT_STRING(unsigned long long)
+
+#undef	SPECIALIZE_DEFAULT_FORMAT_STRING
+
+// format manipulators
+template <typename T>
+inline
+format_object1<T>
+hex(const T& v1) {
+  return format(default_format_string<T>::hex, v1);
+}
+
+// decimal is the default, so this isn't really needed
+template <typename T>
+inline
+format_object1<T>
+dec(const T& v1) {
+  return format(default_format_string<T>::dec, v1);
+}
+
 } // end namespace llvm
 
 #endif
diff --git a/include/llvm/Support/raw_ostream.h b/include/llvm/Support/raw_ostream.h
index ec7e06b..09cad11 100644
--- a/include/llvm/Support/raw_ostream.h
+++ b/include/llvm/Support/raw_ostream.h
@@ -192,6 +192,11 @@ public:
 
   raw_ostream &operator<<(double N);
 
+  /// basic manipulator, unary function
+  raw_ostream& operator<<(raw_ostream& (*pf)(raw_ostream&)) {
+    return (*pf)(*this);
+  }
+
   /// write_hex - Output \p N in hexadecimal, without any prefix or padding.
   raw_ostream &write_hex(unsigned long long N);
 
@@ -417,6 +422,14 @@ raw_ostream &errs();
 /// output.
 raw_ostream &nulls();
 
+/// manipulator functions
+inline
+raw_ostream& endl(raw_ostream& o) {
+  o << '\n';
+  o.flush();
+  return o;
+}
+
 //===----------------------------------------------------------------------===//
 // Output Stream Adaptors
 //===----------------------------------------------------------------------===//
diff --git a/include/llvm/Support/raw_ostream_iterator.h b/include/llvm/Support/raw_ostream_iterator.h
new file mode 100644
index 0000000..72d6065
--- /dev/null
+++ b/include/llvm/Support/raw_ostream_iterator.h
@@ -0,0 +1,79 @@
+//===--- raw_ostream.h - Raw output stream ----------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+//  This file defines the raw_ostream_iterator class.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_SUPPORT_RAW_OSTREAM_ITERATOR_H
+#define LLVM_SUPPORT_RAW_OSTREAM_ITERATOR_H
+
+#include "llvm/Support/raw_ostream.h"
+#include <iterator>
+
+namespace llvm {
+
+/// in the spirit of std::ostream_iterator
+template<typename T>
+class ostream_iterator :
+	public std::iterator<std::output_iterator_tag, void, void, void, void>
+{
+public:
+  //@{
+  /// Public typedef
+  typedef T				value_type;
+  typedef raw_ostream			ostream_type;
+  //@}
+
+private:
+  ostream_type*				_M_stream;
+  const char*				_M_delim;
+
+public:
+  /// Construct from an ostream.
+  ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_delim(0) {}
+
+  /**
+   *  Construct from an ostream with optional delimiter.
+   *  @param  s  Underlying ostream to write to.
+   *  @param  c  CharT delimiter string to insert.
+  */
+  ostream_iterator(ostream_type& __s, const char* __c) :
+    _M_stream(&__s), _M_delim(__c)  { }
+
+  /// Copy constructor.
+  ostream_iterator(const ostream_iterator& __obj) :
+    _M_stream(__obj._M_stream), _M_delim(__obj._M_delim)  { }
+
+  /// Writes @a value to underlying ostream using operator<<.  If
+  /// constructed with delimiter string, writes delimiter to ostream.
+  ostream_iterator&
+  operator=(const T& __value)
+  {
+    *_M_stream << __value;
+    if (_M_delim) *_M_stream << _M_delim;
+    return *this;
+  }
+
+  ostream_iterator&
+  operator*()
+  { return *this; }
+
+  ostream_iterator&
+  operator++()
+  { return *this; }
+
+  ostream_iterator&
+  operator++(int)
+  { return *this; }
+};	// end class raw_ostream_iterator
+
+} // end llvm namespace
+
+#endif
diff --git a/lib/AsmParser/LLParser.h b/lib/AsmParser/LLParser.h
index ded776c..391a03f 100644
--- a/lib/AsmParser/LLParser.h
+++ b/lib/AsmParser/LLParser.h
@@ -43,7 +43,7 @@ namespace llvm {
   /// type can depend on later context.  This may either be a numeric reference
   /// or a symbolic (%var) reference.  This is just a discriminated union.
   struct ValID {
-    enum {
+    enum KindEnum {
       t_LocalID, t_GlobalID,      // ID in UIntVal.
       t_LocalName, t_GlobalName,  // Name in StrVal.
       t_APSInt, t_APFloat,        // Value in APSIntVal/APFloatVal.
diff --git a/lib/CodeGen/AsmPrinter/AsmPrinter.cpp b/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
index 308b0e0..8be4dcb 100644
--- a/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
+++ b/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
@@ -222,13 +222,14 @@ void AsmPrinter::EmitLinkage(const GlobalValue *GV, MCSymbol *GVSym) const {
   case GlobalValue::WeakAnyLinkage:
   case GlobalValue::WeakODRLinkage:
   case GlobalValue::LinkerPrivateWeakLinkage:
-    if (MAI->getWeakDefDirective() != 0) {
+    if (MAI->hasWeakDefDirective()) {
       // .globl _foo
       OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Global);
 
       bool CanBeHidden = false;
 
-      if (Linkage == GlobalValue::LinkOnceODRLinkage) {
+      if (Linkage == GlobalValue::LinkOnceODRLinkage &&
+          MAI->hasWeakDefCanBeHiddenDirective()) {
         if (GV->hasUnnamedAddr()) {
           CanBeHidden = true;
         } else {
@@ -243,7 +244,7 @@ void AsmPrinter::EmitLinkage(const GlobalValue *GV, MCSymbol *GVSym) const {
         OutStreamer.EmitSymbolAttribute(GVSym, MCSA_WeakDefinition);
       else
         OutStreamer.EmitSymbolAttribute(GVSym, MCSA_WeakDefAutoPrivate);
-    } else if (MAI->getLinkOnceDirective() != 0) {
+    } else if (MAI->hasLinkOnceDirective()) {
       // .globl _foo
       OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Global);
       //NOTE: linkonce is handled by the section the symbol was assigned to.
diff --git a/lib/MC/MCAsmInfo.cpp b/lib/MC/MCAsmInfo.cpp
index 28f1c95..daf19e9 100644
--- a/lib/MC/MCAsmInfo.cpp
+++ b/lib/MC/MCAsmInfo.cpp
@@ -76,8 +76,9 @@ MCAsmInfo::MCAsmInfo() {
   HasIdentDirective = false;
   HasNoDeadStrip = false;
   WeakRefDirective = 0;
-  WeakDefDirective = 0;
-  LinkOnceDirective = 0;
+  HasWeakDefDirective = false;
+  HasWeakDefCanBeHiddenDirective = false;
+  HasLinkOnceDirective = false;
   HiddenVisibilityAttr = MCSA_Hidden;
   HiddenDeclarationVisibilityAttr = MCSA_Hidden;
   ProtectedVisibilityAttr = MCSA_Protected;
@@ -85,6 +86,7 @@ MCAsmInfo::MCAsmInfo() {
   SupportsDebugInformation = false;
   ExceptionsType = ExceptionHandling::None;
   DwarfUsesRelocationsAcrossSections = true;
+  DwarfFDESymbolsUseAbsDiff = false;
   DwarfRegNumForCFI = false;
   HasMicrosoftFastStdCallMangling = false;
   NeedsDwarfSectionOffsetDirective = false;
diff --git a/lib/MC/MCAsmInfoCOFF.cpp b/lib/MC/MCAsmInfoCOFF.cpp
index 9d9f98e..1cac71f 100644
--- a/lib/MC/MCAsmInfoCOFF.cpp
+++ b/lib/MC/MCAsmInfoCOFF.cpp
@@ -27,7 +27,7 @@ MCAsmInfoCOFF::MCAsmInfoCOFF() {
   HasSingleParameterDotFile = false;
   PrivateGlobalPrefix = "L";  // Prefix for private global symbols
   WeakRefDirective = "\t.weak\t";
-  LinkOnceDirective = "\t.linkonce discard\n";
+  HasLinkOnceDirective = true;
 
   // Doesn't support visibility:
   HiddenVisibilityAttr = HiddenDeclarationVisibilityAttr = MCSA_Invalid;
diff --git a/lib/MC/MCAsmInfoDarwin.cpp b/lib/MC/MCAsmInfoDarwin.cpp
index 704c816..351ec56 100644
--- a/lib/MC/MCAsmInfoDarwin.cpp
+++ b/lib/MC/MCAsmInfoDarwin.cpp
@@ -36,7 +36,8 @@ MCAsmInfoDarwin::MCAsmInfoDarwin() {
   InlineAsmEnd = " InlineAsm End";
 
   // Directives:
-  WeakDefDirective = "\t.weak_definition ";
+  HasWeakDefDirective = true;
+  HasWeakDefCanBeHiddenDirective = true;
   WeakRefDirective = "\t.weak_reference ";
   ZeroDirective = "\t.space\t";  // ".space N" emits N zeros.
   HasMachoZeroFillDirective = true;  // Uses .zerofill
diff --git a/lib/MC/MCAssembler.cpp b/lib/MC/MCAssembler.cpp
index 68111f1..0965d13 100644
--- a/lib/MC/MCAssembler.cpp
+++ b/lib/MC/MCAssembler.cpp
@@ -1013,7 +1013,7 @@ raw_ostream &operator<<(raw_ostream &OS, const MCFixup &AF) {
 }
 
 #if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
-void MCFragment::dump() {
+void MCFragment::dump() const {
   raw_ostream &OS = llvm::errs();
 
   OS << "<";
@@ -1124,20 +1124,20 @@ void MCFragment::dump() {
   OS << ">";
 }
 
-void MCSectionData::dump() {
+void MCSectionData::dump() const {
   raw_ostream &OS = llvm::errs();
 
   OS << "<MCSectionData";
   OS << " Alignment:" << getAlignment()
      << " Fragments:[\n      ";
-  for (iterator it = begin(), ie = end(); it != ie; ++it) {
+  for (const_iterator it = begin(), ie = end(); it != ie; ++it) {
     if (it != begin()) OS << ",\n      ";
     it->dump();
   }
   OS << "]>";
 }
 
-void MCSymbolData::dump() {
+void MCSymbolData::dump() const {
   raw_ostream &OS = llvm::errs();
 
   OS << "<MCSymbolData Symbol:" << getSymbol()
@@ -1153,19 +1153,19 @@ void MCSymbolData::dump() {
   OS << ">";
 }
 
-void MCAssembler::dump() {
+void MCAssembler::dump() const {
   raw_ostream &OS = llvm::errs();
 
   OS << "<MCAssembler\n";
   OS << "  Sections:[\n    ";
-  for (iterator it = begin(), ie = end(); it != ie; ++it) {
+  for (const_iterator it = begin(), ie = end(); it != ie; ++it) {
     if (it != begin()) OS << ",\n    ";
     it->dump();
   }
   OS << "],\n";
   OS << "  Symbols:[";
 
-  for (symbol_iterator it = symbol_begin(), ie = symbol_end(); it != ie; ++it) {
+  for (const_symbol_iterator it = symbol_begin(), ie = symbol_end(); it != ie; ++it) {
     if (it != symbol_begin()) OS << ",\n           ";
     it->dump();
   }
diff --git a/lib/MC/MCDisassembler/CMakeLists.txt b/lib/MC/MCDisassembler/CMakeLists.txt
index 5195b9e..75f6493 100644
--- a/lib/MC/MCDisassembler/CMakeLists.txt
+++ b/lib/MC/MCDisassembler/CMakeLists.txt
@@ -1,3 +1,27 @@
 add_llvm_library(LLVMMCDisassembler
   Disassembler.cpp
   )
+
+target_link_libraries(LLVMMCDisassembler
+  LLVMMC
+  LLVMMCParser
+  LLVMSupport
+  LLVMTarget
+  )
+
+foreach(t ${LLVM_TARGETS_TO_BUILD})
+  set(td ${LLVM_MAIN_SRC_DIR}/lib/Target/${t})
+  if(EXISTS ${td}/TargetInfo/CMakeLists.txt)
+    target_link_libraries(LLVMMCDisassembler "LLVM${t}Info")
+  endif()
+  if(EXISTS ${td}/MCTargetDesc/CMakeLists.txt)
+    target_link_libraries(LLVMMCDisassembler "LLVM${t}Desc")
+  endif()
+  if(EXISTS ${td}/AsmParser/CMakeLists.txt)
+    target_link_libraries(LLVMMCDisassembler "LLVM${t}AsmParser")
+  endif()
+  if(EXISTS ${td}/Disassembler/CMakeLists.txt)
+    target_link_libraries(LLVMMCDisassembler "LLVM${t}Disassembler")
+  endif()
+endforeach(t)
+
diff --git a/lib/MC/MCDwarf.cpp b/lib/MC/MCDwarf.cpp
index 1e5c2e3..9fd13ab 100644
--- a/lib/MC/MCDwarf.cpp
+++ b/lib/MC/MCDwarf.cpp
@@ -836,8 +836,9 @@ static unsigned getSizeForEncoding(MCStreamer &streamer,
   }
 }
 
-static void EmitSymbol(MCStreamer &streamer, const MCSymbol &symbol,
-                       unsigned symbolEncoding, const char *comment = 0) {
+static void EmitFDESymbol(MCStreamer &streamer, const MCSymbol &symbol,
+                       unsigned symbolEncoding, bool isEH,
+                       const char *comment = 0) {
   MCContext &context = streamer.getContext();
   const MCAsmInfo *asmInfo = context.getAsmInfo();
   const MCExpr *v = asmInfo->getExprForFDESymbol(&symbol,
@@ -845,7 +846,10 @@ static void EmitSymbol(MCStreamer &streamer, const MCSymbol &symbol,
                                                  streamer);
   unsigned size = getSizeForEncoding(streamer, symbolEncoding);
   if (streamer.isVerboseAsm() && comment) streamer.AddComment(comment);
-  streamer.EmitAbsValue(v, size);
+  if (asmInfo->doDwarfFDESymbolsUseAbsDiff() && isEH)
+    streamer.EmitAbsValue(v, size);
+  else
+    streamer.EmitValue(v, size);
 }
 
 static void EmitPersonality(MCStreamer &streamer, const MCSymbol &symbol,
@@ -1344,7 +1348,7 @@ MCSymbol *FrameEmitterImpl::EmitFDE(MCStreamer &streamer,
   unsigned PCEncoding = IsEH ? MOFI->getFDEEncoding(UsingCFI)
                              : (unsigned)dwarf::DW_EH_PE_absptr;
   unsigned PCSize = getSizeForEncoding(streamer, PCEncoding);
-  EmitSymbol(streamer, *frame.Begin, PCEncoding, "FDE initial location");
+  EmitFDESymbol(streamer, *frame.Begin, PCEncoding, IsEH, "FDE initial location");
 
   // PC Range
   const MCExpr *Range = MakeStartMinusEndExpr(streamer, *frame.Begin,
@@ -1364,8 +1368,8 @@ MCSymbol *FrameEmitterImpl::EmitFDE(MCStreamer &streamer,
 
     // Augmentation Data
     if (frame.Lsda)
-      EmitSymbol(streamer, *frame.Lsda, frame.LsdaEncoding,
-                 "Language Specific Data Area");
+      EmitFDESymbol(streamer, *frame.Lsda, frame.LsdaEncoding, true,
+                    "Language Specific Data Area");
   }
 
   // Call Frame Instructions
diff --git a/lib/MC/MachObjectWriter.cpp b/lib/MC/MachObjectWriter.cpp
index 8234aff..19531ed 100644
--- a/lib/MC/MachObjectWriter.cpp
+++ b/lib/MC/MachObjectWriter.cpp
@@ -446,6 +446,7 @@ void MachObjectWriter::BindIndirectSymbols(MCAssembler &Asm) {
     }
   }
 
+#if !ORDER_INDIRECT_SYMBOLS_BY_SECTION
   // Bind non lazy symbol pointers first.
   unsigned IndirectIndex = 0;
   for (MCAssembler::indirect_symbol_iterator it = Asm.indirect_symbol_begin(),
@@ -484,6 +485,46 @@ void MachObjectWriter::BindIndirectSymbols(MCAssembler &Asm) {
     if (Created)
       Entry.setFlags(Entry.getFlags() | 0x0001);
   }
+#else // ORDER_INDIRECT_SYMBOLS_BY_SECTION
+  // sort indirect symbols by section
+  for (MCAssembler::indirect_symbol_iterator it = Asm.indirect_symbol_begin(),
+         ie = Asm.indirect_symbol_end(); it != ie; ++it) {
+    // track their sections by order of appearance
+    IndirectSymbolSections.insert(it->SectionData);
+    IndirectSymbolMap[it->SectionData].push_back(it->Symbol);
+  }
+  // process indirect symbols by section
+  unsigned offset = 0;	// running total of indirect symbol index offset
+  IndirectSymbolSection_set_type::const_iterator
+	i(IndirectSymbolSections.begin()), e(IndirectSymbolSections.end());
+  for ( ; i!=e; ++i) {
+    const IndirectSymbol_list_type& b(IndirectSymbolMap.find(*i)->second);
+    IndirectSymbol_list_type::const_iterator bi(b.begin()), be(b.end());
+    const MCSectionMachO& Section(cast<MCSectionMachO>((*i)->getSection()));
+    switch (Section.getType()) {
+    default: break;
+    case MCSectionMachO::S_NON_LAZY_SYMBOL_POINTERS: {
+      for ( ; bi!=be; ++bi)
+        Asm.getOrCreateSymbolData(**bi);
+      break;
+    }
+    case MCSectionMachO::S_LAZY_SYMBOL_POINTERS: // fall-through
+    case MCSectionMachO::S_SYMBOL_STUBS: {
+      for ( ; bi!=be; ++bi) {
+    // Set the symbol type to undefined lazy, but only on construction.
+    // FIXME: Do not hardcode.
+        bool Created;
+        MCSymbolData &Entry(Asm.getOrCreateSymbolData(**bi, &Created));
+        if (Created)
+          Entry.setFlags(Entry.getFlags() | 0x0001);
+      }	// end for
+      break;
+    }
+    }	// end switch(sectionType)
+    IndirectSymBase.insert(std::make_pair(*i, offset));
+    offset += b.size();
+  }
+#endif	// ORDER_INDIRECT_SYMBOLS_BY_SECTION
 }
 
 /// ComputeSymbolTable - Compute the symbol table data
@@ -914,26 +955,44 @@ void MachObjectWriter::WriteObject(MCAssembler &Asm,
   // Write the symbol table data, if used.
   if (NumSymbols) {
     // Write the indirect symbol entries.
+#if ORDER_INDIRECT_SYMBOLS_BY_SECTION
+    for (IndirectSymbolSection_set_type::const_iterator
+           si(IndirectSymbolSections.begin()), se(IndirectSymbolSections.end());
+           si != se; ++si) {
+      const IndirectSymbol_list_type& l(IndirectSymbolMap.find(*si)->second);
+      for (IndirectSymbol_list_type::const_iterator
+           it(l.begin()), ie(l.end()); it != ie; ++it)
+#else
     for (MCAssembler::const_indirect_symbol_iterator
            it = Asm.indirect_symbol_begin(),
-           ie = Asm.indirect_symbol_end(); it != ie; ++it) {
+           ie = Asm.indirect_symbol_end(); it != ie; ++it)
+#endif
+    {
       // Indirect symbols in the non lazy symbol pointer section have some
       // special handling.
       const MCSectionMachO &Section =
+#if ORDER_INDIRECT_SYMBOLS_BY_SECTION
+        static_cast<const MCSectionMachO&>((*si)->getSection());
+        const MCSymbol* Sym = *it;
+#else
         static_cast<const MCSectionMachO&>(it->SectionData->getSection());
+        const MCSymbol* Sym = it->Symbol;
+#endif
       if (Section.getType() == MCSectionMachO::S_NON_LAZY_SYMBOL_POINTERS) {
         // If this symbol is defined and internal, mark it as such.
-        if (it->Symbol->isDefined() &&
-            !Asm.getSymbolData(*it->Symbol).isExternal()) {
+        if (Sym->isDefined() &&
+            !Asm.getSymbolData(*Sym).isExternal()) {
           uint32_t Flags = MachO::INDIRECT_SYMBOL_LOCAL;
-          if (it->Symbol->isAbsolute())
+          if (Sym->isAbsolute())
             Flags |= MachO::INDIRECT_SYMBOL_ABS;
           Write32(Flags);
           continue;
         }
       }
-
-      Write32(Asm.getSymbolData(*it->Symbol).getIndex());
+      Write32(Asm.getSymbolData(*Sym).getIndex());
+#if ORDER_INDIRECT_SYMBOLS_BY_SECTION
+      }
+#endif
     }
 
     // FIXME: Check that offsets match computed ones.
diff --git a/lib/Support/Atomic.cpp b/lib/Support/Atomic.cpp
index 9559ad7..389a8e9 100644
--- a/lib/Support/Atomic.cpp
+++ b/lib/Support/Atomic.cpp
@@ -21,21 +21,68 @@ using namespace llvm;
 #undef MemoryFence
 #endif
 
+// USE_DARWIN_ATOMICS conditionally defined in Atomics.h
+#if USE_DARWIN_ATOMICS
+#include <libkern/OSAtomic.h>
+// __APPLE__ should take precedence over __GNUC__
+// sys::cas_flag is int32_t from Support/Atomic.h, so use '32' variants
+// prototypes lack the 'volatile' qualifier, so we need to cast them away
+template <class T>
+static inline
+T* vcast(volatile T* ptr) { return const_cast<T*>(ptr); }
+
+// note on weakly-ordered architectures (PPC):
+/**
+DESCRIPTION
+     These functions are thread and multiprocessor safe.  For each function,
+     there is a version that does and another that does not incorporate a
+     memory barrier.  Barriers strictly order memory access on a weakly-
+     ordered architecture such as PPC.  All loads and stores executed in
+     sequential program order before the barrier will complete before any load
+     or store executed after the barrier.  On a uniprocessor, the barrier
+     operation is typically a nop.  On a multiprocessor, the barrier can be
+     quite expensive.
+
+     Most code will want to use the barrier functions to insure that memory
+     shared between threads is properly synchronized.  For example, if you
+     want to initialize a shared data structure and then atomically increment
+     a variable to indicate that the initialization is complete, then you MUST
+     use OSAtomicIncrement32Barrier() to ensure that the stores to your data
+     structure complete before the atomic add.  Likewise, the consumer of that
+     data structure MUST use OSAtomicDecrement32Barrier(), in order to ensure
+     that their loads of the structure are not executed before the atomic
+     decrement.  On the other hand, if you are simply incrementing a global
+     counter, then it is safe and potentially much faster to use OSAtomicIn-
+     crement32().  If you are unsure which version to use, prefer the barrier
+     variants as they are safer.
+
+RETURN VALUES
+     The arithmetic and logical operations return the new value, after the
+     operation has been performed.  The compare-and-swap operations return
+     true if the comparison was equal, ie if the swap occured.  The bit test
+     and set/clear operations return the original value of the bit.
+
+	-- man 3 atomic (BSD Library Functions Manual)
+**/
+#endif
+
 #if defined(__GNUC__) || (defined(__IBMCPP__) && __IBMCPP__ >= 1210)
+#if !USE_DARWIN_ATOMICS
 #define GNU_ATOMICS
 #endif
+#endif
 
 void sys::MemoryFence() {
 #if LLVM_HAS_ATOMICS == 0
   return;
-#else
-#  if defined(GNU_ATOMICS)
+#elif defined(GNU_ATOMICS)
   __sync_synchronize();
-#  elif defined(_MSC_VER)
+#elif USE_DARWIN_ATOMICS
+  OSMemoryBarrier();
+#elif defined(_MSC_VER)
   MemoryBarrier();
-#  else
+#else
 # error No memory fence implementation for your platform!
-#  endif
 #endif
 }
 
@@ -49,6 +96,18 @@ sys::cas_flag sys::CompareAndSwap(volatile sys::cas_flag* ptr,
   return result;
 #elif defined(GNU_ATOMICS)
   return __sync_val_compare_and_swap(ptr, old_value, new_value);
+/**
+These builtins perform an atomic compare and swap.
+That is, if the current value of *ptr is oldval, then write newval into *ptr.
+The bool version returns true if the comparison is successful and newval 
+was written. The val version returns the contents of *ptr before the operation. 
+	-- http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html
+**/
+#elif USE_DARWIN_ATOMICS
+  const sys::cas_flag prev = *ptr;
+  // returns new value, but we don't want it
+  OSAtomicCompareAndSwap32Barrier(old_value, new_value, vcast(ptr));
+  return prev;		// return the previous value at *ptr
 #elif defined(_MSC_VER)
   return InterlockedCompareExchange(ptr, new_value, old_value);
 #else
@@ -62,6 +121,8 @@ sys::cas_flag sys::AtomicIncrement(volatile sys::cas_flag* ptr) {
   return *ptr;
 #elif defined(GNU_ATOMICS)
   return __sync_add_and_fetch(ptr, 1);
+#elif USE_DARWIN_ATOMICS
+  return OSAtomicIncrement32Barrier(vcast(ptr));	// return new value
 #elif defined(_MSC_VER)
   return InterlockedIncrement(ptr);
 #else
@@ -75,6 +136,8 @@ sys::cas_flag sys::AtomicDecrement(volatile sys::cas_flag* ptr) {
   return *ptr;
 #elif defined(GNU_ATOMICS)
   return __sync_sub_and_fetch(ptr, 1);
+#elif USE_DARWIN_ATOMICS
+  return OSAtomicDecrement32Barrier(vcast(ptr));	// return new value
 #elif defined(_MSC_VER)
   return InterlockedDecrement(ptr);
 #else
@@ -88,6 +151,8 @@ sys::cas_flag sys::AtomicAdd(volatile sys::cas_flag* ptr, sys::cas_flag val) {
   return *ptr;
 #elif defined(GNU_ATOMICS)
   return __sync_add_and_fetch(ptr, val);
+#elif USE_DARWIN_ATOMICS
+  return OSAtomicAdd32Barrier(val, vcast(ptr));		// return new value
 #elif defined(_MSC_VER)
   return InterlockedExchangeAdd(ptr, val) + val;
 #else
diff --git a/lib/Support/CMakeLists.txt b/lib/Support/CMakeLists.txt
index 3aecf3f..f175add 100644
--- a/lib/Support/CMakeLists.txt
+++ b/lib/Support/CMakeLists.txt
@@ -22,6 +22,7 @@ add_llvm_library(LLVMSupport
   FileUtilities.cpp
   FileOutputBuffer.cpp
   FoldingSet.cpp
+  Format.cpp
   FormattedStream.cpp
   GraphWriter.cpp
   Hashing.cpp
diff --git a/lib/Support/CommandLine.cpp b/lib/Support/CommandLine.cpp
index 44a88d8..79f8ec0 100644
--- a/lib/Support/CommandLine.cpp
+++ b/lib/Support/CommandLine.cpp
@@ -539,13 +539,14 @@ static size_t parseBackslash(StringRef Src, size_t I, SmallString<128> &Token) {
   return I - 1;
 }
 
+enum StateEnum { INIT, UNQUOTED, QUOTED };
 void cl::TokenizeWindowsCommandLine(StringRef Src, StringSaver &Saver,
                                     SmallVectorImpl<const char *> &NewArgv) {
   SmallString<128> Token;
 
   // This is a small state machine to consume characters until it reaches the
   // end of the source string.
-  enum { INIT, UNQUOTED, QUOTED } State = INIT;
+  StateEnum State = INIT;
   for (size_t I = 0, E = Src.size(); I != E; ++I) {
     // INIT state indicates that the current input index is at the start of
     // the string or between tokens.
diff --git a/lib/Support/Format.cpp b/lib/Support/Format.cpp
new file mode 100644
index 0000000..ff378d4
--- /dev/null
+++ b/lib/Support/Format.cpp
@@ -0,0 +1,34 @@
+//===-- llvm/Support/FormattedStream.cpp - Formatted streams ----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the implementation of default_format_string.
+//
+//===----------------------------------------------------------------------===//
+
+#include "llvm/Support/Format.h"
+
+namespace llvm {
+
+#define	FORMAT_DEC(T, fmt) const char default_format_string<T>::dec[] = fmt;
+#define	FORMAT_HEX(T, fmt) const char default_format_string<T>::hex[] = fmt;
+
+FORMAT_DEC(int, "%d")
+FORMAT_HEX(int, "0x%x")
+FORMAT_DEC(long, "%ld")
+FORMAT_HEX(long, "0x%lx")
+FORMAT_DEC(long long, "%lld")
+FORMAT_HEX(long long, "0x%llx")
+FORMAT_DEC(unsigned int, "%u")
+FORMAT_HEX(unsigned int, "0x%x")
+FORMAT_DEC(unsigned long, "%lu")
+FORMAT_HEX(unsigned long, "0x%lx")
+FORMAT_DEC(unsigned long long, "%llu")
+FORMAT_HEX(unsigned long long, "0x%llx")
+
+}	// end namespace llvm
diff --git a/lib/Support/Path.cpp b/lib/Support/Path.cpp
index c869b30..6b53bc8 100644
--- a/lib/Support/Path.cpp
+++ b/lib/Support/Path.cpp
@@ -508,6 +508,8 @@ void system_temp_directory(bool erasedOnReboot, SmallVectorImpl<char> &result) {
   result.clear();
 
 #ifdef __APPLE__
+// macros expected in <unistd.h>
+#if defined(_CS_DARWIN_USER_TEMP_DIR) && defined(_CS_DARWIN_USER_CACHE_DIR)
   // On Darwin, use DARWIN_USER_TEMP_DIR or DARWIN_USER_CACHE_DIR.
   int ConfName = erasedOnReboot? _CS_DARWIN_USER_TEMP_DIR
                                : _CS_DARWIN_USER_CACHE_DIR;
@@ -527,6 +529,7 @@ void system_temp_directory(bool erasedOnReboot, SmallVectorImpl<char> &result) {
     result.clear();
   }
 #endif
+#endif
 
   // Check whether the temporary directory is specified by an environment
   // variable.
diff --git a/lib/Support/Unix/Memory.inc b/lib/Support/Unix/Memory.inc
index 58fda42..c431068 100644
--- a/lib/Support/Unix/Memory.inc
+++ b/lib/Support/Unix/Memory.inc
@@ -55,7 +55,8 @@ int getPosixProtectionFlags(unsigned Flags) {
 	 llvm::sys::Memory::MF_EXEC:
     return PROT_READ | PROT_WRITE | PROT_EXEC;
   case llvm::sys::Memory::MF_EXEC:
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD__) || defined(__APPLE__)
+    // patch from Roman Divacky, bug 14278
     // On PowerPC, having an executable page that has no read permission
     // can have unintended consequences.  The function InvalidateInstruction-
     // Cache uses instructions dcbf and icbi, both of which are treated by
diff --git a/lib/Support/Unix/Signals.inc b/lib/Support/Unix/Signals.inc
index b4c78d6..f387329 100644
--- a/lib/Support/Unix/Signals.inc
+++ b/lib/Support/Unix/Signals.inc
@@ -333,7 +333,8 @@ static void PrintStackTraceSignalHandler(void *) {
 void llvm::sys::PrintStackTraceOnErrorSignal() {
   AddSignalHandler(PrintStackTraceSignalHandler, 0);
 
-#if defined(__APPLE__) && defined(ENABLE_CRASH_OVERRIDES)
+// some of these constants are not defined for darwin8
+#if defined(__APPLE__) && defined(ENABLE_CRASH_OVERRIDES) && defined(MACH_EXCEPTION_CODES) && defined(EXC_MASK_CRASH)
   // Environment variable to disable any kind of crash dialog.
   if (getenv("LLVM_DISABLE_CRASH_REPORT")) {
     mach_port_t self = mach_task_self();
diff --git a/lib/Target/ARM/ARMFastISel.cpp b/lib/Target/ARM/ARMFastISel.cpp
index a4004f3..819d0fe 100644
--- a/lib/Target/ARM/ARMFastISel.cpp
+++ b/lib/Target/ARM/ARMFastISel.cpp
@@ -54,7 +54,7 @@ namespace {
 
   // All possible address modes, plus some.
   typedef struct Address {
-    enum {
+    enum BaseTypeEnum {
       RegBase,
       FrameIndexBase
     } BaseType;
diff --git a/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp b/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
index fe83fe1..b297cd8 100644
--- a/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
+++ b/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
@@ -177,6 +177,7 @@ class PPCAsmParser : public MCTargetAsmParser {
   MCAsmParser &Parser;
   const MCInstrInfo &MII;
   bool IsPPC64;
+  bool IsDarwin;
 
   MCAsmParser &getParser() const { return Parser; }
   MCAsmLexer &getLexer() const { return Parser.getLexer(); }
@@ -185,6 +186,7 @@ class PPCAsmParser : public MCTargetAsmParser {
   bool Error(SMLoc L, const Twine &Msg) { return Parser.Error(L, Msg); }
 
   bool isPPC64() const { return IsPPC64; }
+  bool isDarwin() const { return IsDarwin; }
 
   bool MatchRegisterName(const AsmToken &Tok,
                          unsigned &RegNo, int64_t &IntVal);
@@ -195,12 +197,14 @@ class PPCAsmParser : public MCTargetAsmParser {
                                         PPCMCExpr::VariantKind &Variant);
   const MCExpr *FixupVariantKind(const MCExpr *E);
   bool ParseExpression(const MCExpr *&EVal);
+  bool ParseDarwinExpression(const MCExpr *&EVal);
 
   bool ParseOperand(SmallVectorImpl<MCParsedAsmOperand*> &Operands);
 
   bool ParseDirectiveWord(unsigned Size, SMLoc L);
   bool ParseDirectiveTC(unsigned Size, SMLoc L);
   bool ParseDirectiveMachine(SMLoc L);
+  bool ParseDarwinDirectiveMachine(SMLoc L);
 
   bool MatchAndEmitInstruction(SMLoc IDLoc, unsigned &Opcode,
                                SmallVectorImpl<MCParsedAsmOperand*> &Operands,
@@ -227,6 +231,7 @@ public:
     Triple TheTriple(STI.getTargetTriple());
     IsPPC64 = (TheTriple.getArch() == Triple::ppc64 ||
                TheTriple.getArch() == Triple::ppc64le);
+    IsDarwin = TheTriple.isMacOSX();
     // Initialize the set of available features.
     setAvailableFeatures(ComputeAvailableFeatures(STI.getFeatureBits()));
   }
@@ -1081,10 +1086,16 @@ FixupVariantKind(const MCExpr *E) {
   llvm_unreachable("Invalid expression kind!");
 }
 
-/// Parse an expression.  This differs from the default "parseExpression"
-/// in that it handles complex \code @l/@ha \endcode modifiers.
+/// ParseExpression.  This differs from the default "parseExpression" in that
+/// it handles modifiers.
 bool PPCAsmParser::
 ParseExpression(const MCExpr *&EVal) {
+
+  if (isDarwin())
+    return ParseDarwinExpression(EVal);
+
+  // (ELF Platforms)
+  // Handle \code @l/@ha \endcode
   if (getParser().parseExpression(EVal))
     return true;
 
@@ -1098,6 +1109,55 @@ ParseExpression(const MCExpr *&EVal) {
   return false;
 }
 
+/// ParseDarwinExpression.  (MachO Platforms)
+/// This differs from the default "parseExpression" in that it handles detection
+/// of the \code hi16(), ha16() and lo16() \endcode modifiers.  At present,
+/// parseExpression() doesn't recognise the modifiers when in the Darwin/MachO
+/// syntax form so it is done here.  TODO: Determine if there is merit in arranging
+/// for this to be done at a higher level.
+bool PPCAsmParser::
+ParseDarwinExpression(const MCExpr *&EVal) {
+  PPCMCExpr::VariantKind Variant = PPCMCExpr::VK_PPC_None;
+  switch (getLexer().getKind()) {
+  default:
+    break;
+  case AsmToken::Identifier:
+    // Compiler-generated Darwin identifiers begin with L,l,_ or "; thus
+    // something starting with any other char should be part of the
+    // asm syntax.  If handwritten asm includes an identifier like lo16,
+    // then all bets are off - but no-one would do that, right?
+    StringRef poss = Parser.getTok().getString();
+    if (poss.equals_lower("lo16")) {
+      Variant = PPCMCExpr::VK_PPC_LO;
+    } else if (poss.equals_lower("hi16")) {
+      Variant = PPCMCExpr::VK_PPC_HI;
+    } else if (poss.equals_lower("ha16")) {
+      Variant = PPCMCExpr::VK_PPC_HA;
+    }
+    if (Variant != PPCMCExpr::VK_PPC_None) {
+      Parser.Lex(); // Eat the xx16
+      if (getLexer().isNot(AsmToken::LParen))
+        return Error(Parser.getTok().getLoc(), "expected '('");
+      Parser.Lex(); // Eat the '('
+    }
+    break;
+  }
+
+  if (getParser().parseExpression(EVal))
+    return true;
+
+  if (Variant != PPCMCExpr::VK_PPC_None) {
+    if (getLexer().isNot(AsmToken::RParen))
+      return Error(Parser.getTok().getLoc(), "expected ')'");
+    Parser.Lex(); // Eat the ')'
+    EVal = PPCMCExpr::Create(Variant, EVal, false, getParser().getContext());
+  }
+  return false;
+}
+
+/// ParseOperand
+/// This handles registers in the form 'NN', '%rNN' for ELF platforms and
+/// rNN for MachO.
 bool PPCAsmParser::
 ParseOperand(SmallVectorImpl<MCParsedAsmOperand*> &Operands) {
   SMLoc S = Parser.getTok().getLoc();
@@ -1121,12 +1181,27 @@ ParseOperand(SmallVectorImpl<MCParsedAsmOperand*> &Operands) {
     }
     return Error(S, "invalid register name");
 
+  case AsmToken::Identifier:
+    // Note that non-register-name identifiers from the compiler will begin
+    // with '_', 'L'/'l' or '"'.  Of course, handwritten asm could include
+    // identifiers like r31foo - so we fall through in the event that parsing
+    // a register name fails.
+    if (isDarwin()) {
+      unsigned RegNo;
+      int64_t IntVal;
+      if (!MatchRegisterName(Parser.getTok(), RegNo, IntVal)) {
+        Parser.Lex(); // Eat the identifier token.
+        Op = PPCOperand::CreateImm(IntVal, S, E, isPPC64());
+        Operands.push_back(Op);
+        return false;
+      }
+    }
+  // Fall-through to process non-register-name identifiers as expression.
   // All other expressions
   case AsmToken::LParen:
   case AsmToken::Plus:
   case AsmToken::Minus:
   case AsmToken::Integer:
-  case AsmToken::Identifier:
   case AsmToken::Dot:
   case AsmToken::Dollar:
     if (!ParseExpression(EVal))
@@ -1177,11 +1252,25 @@ ParseOperand(SmallVectorImpl<MCParsedAsmOperand*> &Operands) {
       break;
 
     case AsmToken::Integer:
-      if (getParser().parseAbsoluteExpression(IntVal) ||
+      if (!isDarwin()) {
+        if (getParser().parseAbsoluteExpression(IntVal) ||
           IntVal < 0 || IntVal > 31)
         return Error(S, "invalid register number");
+      } else {
+        return Error(S, "unexpected integer value");
+      }
       break;
 
+   case AsmToken::Identifier:
+    if (isDarwin()) {
+      unsigned RegNo;
+      if (!MatchRegisterName(Parser.getTok(), RegNo, IntVal)) {
+        Parser.Lex(); // Eat the identifier token.
+        break;
+      }
+    }
+    // Fall-through..
+
     default:
       return Error(S, "invalid memory operand");
     }
@@ -1261,14 +1350,19 @@ ParseInstruction(ParseInstructionInfo &Info, StringRef Name, SMLoc NameLoc,
 /// ParseDirective parses the PPC specific directives
 bool PPCAsmParser::ParseDirective(AsmToken DirectiveID) {
   StringRef IDVal = DirectiveID.getIdentifier();
-  if (IDVal == ".word")
-    return ParseDirectiveWord(2, DirectiveID.getLoc());
-  if (IDVal == ".llong")
-    return ParseDirectiveWord(8, DirectiveID.getLoc());
-  if (IDVal == ".tc")
-    return ParseDirectiveTC(isPPC64()? 8 : 4, DirectiveID.getLoc());
-  if (IDVal == ".machine")
-    return ParseDirectiveMachine(DirectiveID.getLoc());
+  if (!isDarwin()) {
+    if (IDVal == ".word")
+      return ParseDirectiveWord(2, DirectiveID.getLoc());
+    if (IDVal == ".llong")
+      return ParseDirectiveWord(8, DirectiveID.getLoc());
+    if (IDVal == ".tc")
+      return ParseDirectiveTC(isPPC64()? 8 : 4, DirectiveID.getLoc());
+    if (IDVal == ".machine")
+      return ParseDirectiveMachine(DirectiveID.getLoc());
+  } else {
+    if (IDVal == ".machine")
+      return ParseDarwinDirectiveMachine(DirectiveID.getLoc());
+  }
   return true;
 }
 
@@ -1314,7 +1408,7 @@ bool PPCAsmParser::ParseDirectiveTC(unsigned Size, SMLoc L) {
   return ParseDirectiveWord(Size, L);
 }
 
-/// ParseDirectiveMachine
+/// ParseDirectiveMachine (ELF platforms)
 ///  ::= .machine [ cpu | "push" | "pop" ]
 bool PPCAsmParser::ParseDirectiveMachine(SMLoc L) {
   if (getLexer().isNot(AsmToken::Identifier) &&
@@ -1338,6 +1432,33 @@ bool PPCAsmParser::ParseDirectiveMachine(SMLoc L) {
   return false;
 }
 
+/// ParseDarwinDirectiveMachine (Mach-o platforms)
+///  ::= .machine cpu-identifier
+bool PPCAsmParser::ParseDarwinDirectiveMachine(SMLoc L) {
+  if (getLexer().isNot(AsmToken::Identifier) &&
+      getLexer().isNot(AsmToken::String))
+    return Error(L, "unexpected token in directive");
+
+  StringRef CPU = Parser.getTok().getIdentifier();
+  Parser.Lex();
+
+  // FIXME: this is only the 'default' set of cpu variants.
+  // However we don't act on this information at present, this is simply
+  // allowing parsing to proceed with minimal sanity checking.
+  if (CPU != "ppc7400" && CPU != "ppc" && CPU != "ppc64")
+    return Error(L, "unrecognized cpu type");
+
+  if (isPPC64() && (CPU == "ppc7400" || CPU == "ppc"))
+    return Error(L, "wrong cpu type specified for 64bit");
+  if (!isPPC64() && CPU == "ppc64")
+    return Error(L, "wrong cpu type specified for 32bit");
+
+  if (getLexer().isNot(AsmToken::EndOfStatement))
+    return Error(L, "unexpected token in directive");
+
+  return false;
+}
+
 /// Force static initialization.
 extern "C" void LLVMInitializePowerPCAsmParser() {
   RegisterMCAsmParser<PPCAsmParser> A(ThePPC32Target);
diff --git a/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp b/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp
index 0d42081..87a4731 100644
--- a/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp
+++ b/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp
@@ -20,6 +20,7 @@
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/MachO.h"
 #include "llvm/Support/TargetRegistry.h"
+
 using namespace llvm;
 
 static uint64_t adjustFixupValue(unsigned Kind, uint64_t Value) {
diff --git a/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.cpp b/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.cpp
index f3dddce..3301a67 100644
--- a/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.cpp
+++ b/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.cpp
@@ -12,11 +12,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "PPCMCAsmInfo.h"
+#include "llvm/ADT/Triple.h"
+
 using namespace llvm;
 
 void PPCMCAsmInfoDarwin::anchor() { }
 
-PPCMCAsmInfoDarwin::PPCMCAsmInfoDarwin(bool is64Bit) {
+PPCMCAsmInfoDarwin::PPCMCAsmInfoDarwin(bool is64Bit, const Triple& T) {
   if (is64Bit) {
     PointerSize = CalleeSaveStackSlotSize = 8;
   }
@@ -30,6 +32,12 @@ PPCMCAsmInfoDarwin::PPCMCAsmInfoDarwin(bool is64Bit) {
 
   AssemblerDialect = 1;           // New-Style mnemonics.
   SupportsDebugInformation= true; // Debug information.
+
+  // old assembler lacks some directives
+  // FIXME: this should really be a check on the assembler characteristics
+  // rather than OS version
+  if (T.isMacOSX() && T.isMacOSXVersionLT(10, 6))
+    HasWeakDefCanBeHiddenDirective = false;
 }
 
 void PPCLinuxMCAsmInfo::anchor() { }
diff --git a/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.h b/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.h
index 1530e77..6e6152e 100644
--- a/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.h
+++ b/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.h
@@ -18,11 +18,12 @@
 #include "llvm/MC/MCAsmInfoELF.h"
 
 namespace llvm {
+class Triple;
 
   class PPCMCAsmInfoDarwin : public MCAsmInfoDarwin {
     virtual void anchor();
   public:
-    explicit PPCMCAsmInfoDarwin(bool is64Bit);
+    explicit PPCMCAsmInfoDarwin(bool is64Bit, const Triple&);
   };
 
   class PPCLinuxMCAsmInfo : public MCAsmInfoELF {
diff --git a/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp b/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
index f18d095..6a50518 100644
--- a/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
+++ b/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
@@ -72,7 +72,7 @@ static MCAsmInfo *createPPCMCAsmInfo(const MCRegisterInfo &MRI, StringRef TT) {
 
   MCAsmInfo *MAI;
   if (TheTriple.isOSDarwin())
-    MAI = new PPCMCAsmInfoDarwin(isPPC64);
+    MAI = new PPCMCAsmInfoDarwin(isPPC64, TheTriple);
   else
     MAI = new PPCLinuxMCAsmInfo(isPPC64);
 
diff --git a/lib/Target/PowerPC/PPCAsmPrinter.cpp b/lib/Target/PowerPC/PPCAsmPrinter.cpp
index ada34ed..268cbfa 100644
--- a/lib/Target/PowerPC/PPCAsmPrinter.cpp
+++ b/lib/Target/PowerPC/PPCAsmPrinter.cpp
@@ -58,6 +58,7 @@
 #include "llvm/Target/TargetInstrInfo.h"
 #include "llvm/Target/TargetOptions.h"
 #include "llvm/Target/TargetRegisterInfo.h"
+
 using namespace llvm;
 
 namespace {
@@ -896,6 +897,7 @@ static MCSymbol *GetLazyPtr(MCSymbol *Sym, MCContext &Ctx) {
   return Ctx.GetOrCreateSymbol(NoStub + "$lazy_ptr");
 }
 
+// 'L' needed to designate label as local
 static MCSymbol *GetAnonSym(MCSymbol *Sym, MCContext &Ctx) {
   // Add $tmp suffix to $stub, yielding $stub$tmp.
   return Ctx.GetOrCreateSymbol(Sym->getName() + "$tmp");
@@ -913,6 +915,7 @@ EmitFunctionStubs(const MachineModuleInfoMachO::SymbolListTy &Stubs) {
   const MCSection *LSPSection = TLOFMacho.getLazySymbolPointerSection();
   
   // Output stubs for dynamically-linked functions
+  // see http://developer.apple.com/library/mac/#documentation/developertools/reference/assembler/050-PowerPC_Addressing_Modes_and_Assembler_Instructions/ppc_instructions.html
   if (TM.getRelocationModel() == Reloc::PIC_) {
     const MCSection *StubSection = 
     OutContext.getMachOSection("__TEXT", "__picsymbolstub1",
@@ -939,10 +942,12 @@ EmitFunctionStubs(const MachineModuleInfoMachO::SymbolListTy &Stubs) {
       // mflr r0
       OutStreamer.EmitInstruction(MCInstBuilder(PPC::MFLR).addReg(PPC::R0));
       // bcl 20, 31, AnonSymbol
+      // unconditional, but doesn't push link register onto stack
       OutStreamer.EmitInstruction(MCInstBuilder(PPC::BCLalways).addExpr(Anon));
       OutStreamer.EmitLabel(AnonSymbol);
-      // mflr r11
+      // mflr r11 ; move LR to r11
       OutStreamer.EmitInstruction(MCInstBuilder(PPC::MFLR).addReg(PPC::R11));
+      // load address one half at a time
       // addis r11, r11, ha16(LazyPtr - AnonSymbol)
       const MCExpr *SubHa16 = PPCMCExpr::CreateHa(Sub, isDarwin, OutContext);
       OutStreamer.EmitInstruction(MCInstBuilder(PPC::ADDIS)
diff --git a/lib/Target/PowerPC/PPCFastISel.cpp b/lib/Target/PowerPC/PPCFastISel.cpp
index 09117e7..b7bf0b7 100644
--- a/lib/Target/PowerPC/PPCFastISel.cpp
+++ b/lib/Target/PowerPC/PPCFastISel.cpp
@@ -61,7 +61,7 @@ using namespace llvm;
 namespace {
 
 typedef struct Address {
-  enum {
+  enum BaseTypeEnum {
     RegBase,
     FrameIndexBase
   } BaseType;
diff --git a/lib/Target/PowerPC/PPCISelLowering.cpp b/lib/Target/PowerPC/PPCISelLowering.cpp
index 8da5f05..190997b 100644
--- a/lib/Target/PowerPC/PPCISelLowering.cpp
+++ b/lib/Target/PowerPC/PPCISelLowering.cpp
@@ -2611,6 +2611,7 @@ PPCTargetLowering::LowerFormalArguments_Darwin(
 
   SmallVector<SDValue, 8> MemOps;
   unsigned nAltivecParamsAtEnd = 0;
+  // for Darwin, reported as: http://llvm.org/bugs/show_bug.cgi?id=15821
   Function::const_arg_iterator FuncArg = MF.getFunction()->arg_begin();
   unsigned CurArgIdx = 0;
   for (unsigned ArgNo = 0, e = Ins.size(); ArgNo != e; ++ArgNo) {
diff --git a/lib/Target/PowerPC/PPCMCInstLower.cpp b/lib/Target/PowerPC/PPCMCInstLower.cpp
index f61c8bf..97269e7 100644
--- a/lib/Target/PowerPC/PPCMCInstLower.cpp
+++ b/lib/Target/PowerPC/PPCMCInstLower.cpp
@@ -24,6 +24,7 @@
 #include "llvm/MC/MCExpr.h"
 #include "llvm/MC/MCInst.h"
 #include "llvm/Target/Mangler.h"
+
 using namespace llvm;
 
 static MachineModuleInfoMachO &getMachOMMI(AsmPrinter &AP) {
diff --git a/lib/Target/PowerPC/PPCRegisterInfo.cpp b/lib/Target/PowerPC/PPCRegisterInfo.cpp
index 19ccbfc..a08471f3 100644
--- a/lib/Target/PowerPC/PPCRegisterInfo.cpp
+++ b/lib/Target/PowerPC/PPCRegisterInfo.cpp
@@ -284,8 +284,8 @@ void PPCRegisterInfo::lowerDynamicAlloc(MachineBasicBlock::iterator II) const {
   unsigned Reg = MF.getRegInfo().createVirtualRegister(LP64 ? G8RC : GPRC);
   
   if (MaxAlign < TargetAlign && isInt<16>(FrameSize)) {
-    BuildMI(MBB, II, dl, TII.get(PPC::ADDI), Reg)
-      .addReg(PPC::R31)
+    BuildMI(MBB, II, dl, TII.get(LP64 ? PPC::ADDI8 : PPC::ADDI), Reg)
+      .addReg(getFrameRegister(MF))
       .addImm(FrameSize);
   } else if (LP64) {
     BuildMI(MBB, II, dl, TII.get(PPC::LD), Reg)
diff --git a/lib/Target/PowerPC/PPCSubtarget.h b/lib/Target/PowerPC/PPCSubtarget.h
index c863a6e..ec8c82a 100644
--- a/lib/Target/PowerPC/PPCSubtarget.h
+++ b/lib/Target/PowerPC/PPCSubtarget.h
@@ -126,22 +126,6 @@ public:
   /// selection.
   const InstrItineraryData &getInstrItineraryData() const { return InstrItins; }
 
-  /// getDataLayoutString - Return the pointer size and type alignment
-  /// properties of this subtarget.
-  const char *getDataLayoutString() const {
-    // Note, the alignment values for f64 and i64 on ppc64 in Darwin
-    // documentation are wrong; these are correct (i.e. "what gcc does").
-    if (isPPC64() && isSVR4ABI()) {
-      if (TargetTriple.getOS() == llvm::Triple::FreeBSD)
-        return "E-p:64:64-f64:64:64-i64:64:64-v128:128:128-n32:64";
-      else
-        return "E-p:64:64-f64:64:64-i64:64:64-f128:128:128-v128:128:128-n32:64";
-    }
-
-    return isPPC64() ? "E-p:64:64-f64:64:64-i64:64:64-f128:64:128-n32:64"
-                     : "E-p:32:32-f64:64:64-i64:64:64-f128:64:128-n32";
-  }
-
   /// \brief Reset the features for the PowerPC target.
   virtual void resetSubtargetFeatures(const MachineFunction *MF);
 private:
diff --git a/lib/Target/PowerPC/PPCTargetMachine.cpp b/lib/Target/PowerPC/PPCTargetMachine.cpp
index 9acefe5..3a2bbe7 100644
--- a/lib/Target/PowerPC/PPCTargetMachine.cpp
+++ b/lib/Target/PowerPC/PPCTargetMachine.cpp
@@ -33,6 +33,44 @@ extern "C" void LLVMInitializePowerPCTarget() {
   RegisterTargetMachine<PPC64TargetMachine> C(ThePPC64LETarget);
 }
 
+/// Return the datalayout string of a subtarget.
+static std::string getDataLayoutString(const PPCSubtarget &ST) {
+  const Triple &T = ST.getTargetTriple();
+
+  // PPC is big endian
+  std::string Ret = "E";
+
+  // PPC64 has 64 bit pointers, PPC32 has 32 bit pointers.
+  if (ST.isPPC64())
+    Ret += "-p:64:64";
+  else
+    Ret += "-p:32:32";
+
+//  Ret += "-f64:64:64-i64:64:64";
+  // Note, the alignment values for f64 and i64 on ppc64 in Darwin
+  // documentation are wrong; these are correct (i.e. "what gcc does").
+  if (ST.isPPC64() || ST.isSVR4ABI())
+    Ret += "-i64:64";
+  else
+    Ret += "-f64:32:64";
+
+  // Set support for 128 floats depending on the ABI.
+  if (!ST.isPPC64() && ST.isSVR4ABI())
+    Ret += "-f128:64:128";
+
+  // Some ABIs support 128 bit vectors.
+  if (ST.isPPC64() && ST.isSVR4ABI())
+    Ret += "-v128:128:128";
+
+  // PPC64 has 32 and 64 bit register, PPC32 has only 32 bit ones.
+  if (ST.isPPC64())
+    Ret += "-n32:64";
+  else
+    Ret += "-n32";
+
+  return Ret;
+}
+
 PPCTargetMachine::PPCTargetMachine(const Target &T, StringRef TT,
                                    StringRef CPU, StringRef FS,
                                    const TargetOptions &Options,
@@ -41,7 +79,7 @@ PPCTargetMachine::PPCTargetMachine(const Target &T, StringRef TT,
                                    bool is64Bit)
   : LLVMTargetMachine(T, TT, CPU, FS, Options, RM, CM, OL),
     Subtarget(TT, CPU, FS, is64Bit),
-    DL(Subtarget.getDataLayoutString()), InstrInfo(*this),
+    DL(getDataLayoutString(Subtarget)), InstrInfo(*this),
     FrameLowering(Subtarget), JITInfo(*this, is64Bit),
     TLInfo(*this), TSInfo(*this),
     InstrItins(Subtarget.getInstrItineraryData()) {
diff --git a/lib/Target/R600/MCTargetDesc/AMDGPUMCAsmInfo.cpp b/lib/Target/R600/MCTargetDesc/AMDGPUMCAsmInfo.cpp
index 4a8e1b0..9b26af7 100644
--- a/lib/Target/R600/MCTargetDesc/AMDGPUMCAsmInfo.cpp
+++ b/lib/Target/R600/MCTargetDesc/AMDGPUMCAsmInfo.cpp
@@ -13,7 +13,6 @@
 using namespace llvm;
 AMDGPUMCAsmInfo::AMDGPUMCAsmInfo(StringRef &TT) : MCAsmInfo() {
   HasSingleParameterDotFile = false;
-  WeakDefDirective = 0;
   //===------------------------------------------------------------------===//
   HasSubsectionsViaSymbols = true;
   HasMachoZeroFillDirective = false;
@@ -58,7 +57,6 @@ AMDGPUMCAsmInfo::AMDGPUMCAsmInfo(StringRef &TT) : MCAsmInfo() {
   HasDotTypeDotSizeDirective = false;
   HasNoDeadStrip = true;
   WeakRefDirective = ".weakref\t";
-  LinkOnceDirective = 0;
   //===--- Dwarf Emission Directives -----------------------------------===//
   HasLEB128 = true;
   SupportsDebugInformation = true;
diff --git a/lib/Target/X86/MCTargetDesc/X86BaseInfo.h b/lib/Target/X86/MCTargetDesc/X86BaseInfo.h
index 1ef9814..9ddd104 100644
--- a/lib/Target/X86/MCTargetDesc/X86BaseInfo.h
+++ b/lib/Target/X86/MCTargetDesc/X86BaseInfo.h
@@ -29,7 +29,7 @@ namespace X86 {
   // a 5 operand sequence in the form:
   //   [BaseReg, ScaleAmt, IndexReg, Disp, Segment]
   // These enums help decode this.
-  enum {
+  enum AddrOpEnum {
     AddrBaseReg = 0,
     AddrScaleAmt = 1,
     AddrIndexReg = 2,
@@ -216,7 +216,7 @@ namespace X86II {
     MO_SECREL
   };
 
-  enum {
+  enum InstrEncodingEnum {
     //===------------------------------------------------------------------===//
     // Instruction encodings.  These are the standard/most common forms for X86
     // instructions.
diff --git a/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp b/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp
index 3861e1c..dc6d502 100644
--- a/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp
+++ b/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp
@@ -65,6 +65,17 @@ X86MCAsmInfoDarwin::X86MCAsmInfoDarwin(const Triple &T) {
 
   // Exceptions handling
   ExceptionsType = ExceptionHandling::DwarfCFI;
+
+  // old assembler lacks some directives
+  // FIXME: this should really be a check on the assembler characteristics
+  // rather than OS version
+  if (T.isMacOSX() && T.isMacOSXVersionLT(10, 6))
+    HasWeakDefCanBeHiddenDirective = false;
+
+  // FIXME: this should not depend on the target OS version, but on the ld64
+  // version in use.  From at least >= ld64-97.17 (Xcode 3.2.6) the abs-ified
+  // FDE relocs may be used.
+  DwarfFDESymbolsUseAbsDiff = T.isMacOSX() && !T.isMacOSXVersionLT(10, 6);
 }
 
 X86_64MCAsmInfoDarwin::X86_64MCAsmInfoDarwin(const Triple &Triple)
diff --git a/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.h b/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.h
index 41ae435..442bcbd 100644
--- a/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.h
+++ b/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.h
@@ -35,7 +35,7 @@ extern Target TheX86_32Target, TheX86_64Target;
 /// DWARFFlavour - Flavour of dwarf regnumbers
 ///
 namespace DWARFFlavour {
-  enum {
+  enum DwarfFlavorEnum {
     X86_64 = 0, X86_32_DarwinEH = 1, X86_32_Generic = 2
   };
 } 
@@ -43,7 +43,7 @@ namespace DWARFFlavour {
 /// N86 namespace - Native X86 register numbers
 ///
 namespace N86 {
-  enum {
+  enum NativeRegisterEnum {
     EAX = 0, ECX = 1, EDX = 2, EBX = 3, ESP = 4, EBP = 5, ESI = 6, EDI = 7
   };
 }
diff --git a/lib/Target/X86/X86ISelDAGToDAG.cpp b/lib/Target/X86/X86ISelDAGToDAG.cpp
index 36d1690..073ecf8 100644
--- a/lib/Target/X86/X86ISelDAGToDAG.cpp
+++ b/lib/Target/X86/X86ISelDAGToDAG.cpp
@@ -47,7 +47,7 @@ namespace {
   /// SDValue's instead of register numbers for the leaves of the matched
   /// tree.
   struct X86ISelAddressMode {
-    enum {
+    enum BaseTypeEnum {
       RegBase,
       FrameIndexBase
     } BaseType;
diff --git a/lib/Target/X86/X86InstrBuilder.h b/lib/Target/X86/X86InstrBuilder.h
index aaef4a4..8e78622 100644
--- a/lib/Target/X86/X86InstrBuilder.h
+++ b/lib/Target/X86/X86InstrBuilder.h
@@ -35,7 +35,7 @@ namespace llvm {
 /// with BP or SP and Disp being offsetted accordingly.  The displacement may
 /// also include the offset of a global value.
 struct X86AddressMode {
-  enum {
+  enum BaseTypeEnum {
     RegBase,
     FrameIndexBase
   } BaseType;
diff --git a/lib/Target/X86/X86InstrInfo.cpp b/lib/Target/X86/X86InstrInfo.cpp
index 2461773..400ae05 100644
--- a/lib/Target/X86/X86InstrInfo.cpp
+++ b/lib/Target/X86/X86InstrInfo.cpp
@@ -4911,6 +4911,13 @@ bool X86InstrInfo::shouldScheduleLoadsNear(SDNode *Load1, SDNode *Load2,
   return true;
 }
 
+// moved enum to non-local
+  enum FuseKindEnum {
+    FuseTest,
+    FuseCmp,
+    FuseInc
+  };
+
 bool X86InstrInfo::shouldScheduleAdjacent(MachineInstr* First,
                                           MachineInstr *Second) const {
   // Check if this processor supports macro-fusion. Since this is a minor
@@ -4919,11 +4926,7 @@ bool X86InstrInfo::shouldScheduleAdjacent(MachineInstr* First,
   if (!TM.getSubtarget<X86Subtarget>().hasAVX())
     return false;
 
-  enum {
-    FuseTest,
-    FuseCmp,
-    FuseInc
-  } FuseKind;
+  FuseKindEnum FuseKind;
 
   switch(Second->getOpcode()) {
   default:
diff --git a/lib/Transforms/Hello/CMakeLists.txt b/lib/Transforms/Hello/CMakeLists.txt
index 917b745..866b1f7 100644
--- a/lib/Transforms/Hello/CMakeLists.txt
+++ b/lib/Transforms/Hello/CMakeLists.txt
@@ -1,3 +1,5 @@
+# patch: this should be built as a bundle/module/plug-in
+set(MODULE TRUE)
 add_llvm_loadable_module( LLVMHello
   Hello.cpp
   )
diff --git a/lib/Transforms/Instrumentation/MemorySanitizer.cpp b/lib/Transforms/Instrumentation/MemorySanitizer.cpp
index d547adc..233ffad 100644
--- a/lib/Transforms/Instrumentation/MemorySanitizer.cpp
+++ b/lib/Transforms/Instrumentation/MemorySanitizer.cpp
@@ -219,8 +219,15 @@ class MemorySanitizer : public FunctionPass {
  private:
   void initializeCallbacks(Module &M);
 
+// workaround accessibility bug in g++-4.0
+#if !__GNUC_PREREQ(4, 2)
+ public:
+#endif
   /// \brief Track origins (allocation points) of uninitialized values.
   bool TrackOrigins;
+#if !__GNUC_PREREQ(4, 2)
+ private:
+#endif
 
   DataLayout *TD;
   LLVMContext *C;
diff --git a/lib/Transforms/Scalar/ScalarReplAggregates.cpp b/lib/Transforms/Scalar/ScalarReplAggregates.cpp
index 57b290e..a82de84 100644
--- a/lib/Transforms/Scalar/ScalarReplAggregates.cpp
+++ b/lib/Transforms/Scalar/ScalarReplAggregates.cpp
@@ -267,7 +267,7 @@ class ConvertToScalarInfo {
 
   /// ScalarKind - Tracks the kind of alloca being considered for promotion,
   /// computed based on the uses of the alloca rather than the LLVM type system.
-  enum {
+  enum ScalarKindEnum {
     Unknown,
 
     // Accesses via GEPs that are consistent with element access of a vector
diff --git a/test/CodeGen/PowerPC/anon_aggr.ll b/test/CodeGen/PowerPC/anon_aggr.ll
index 1525e05..ce07d88 100644
--- a/test/CodeGen/PowerPC/anon_aggr.ll
+++ b/test/CodeGen/PowerPC/anon_aggr.ll
@@ -119,9 +119,9 @@ unequal:
 ; CHECK: ld 3, -[[OFFSET1]](1)
 
 ; DARWIN32: _func3:
-; DARWIN32: addi r[[REG1:[0-9]+]], r[[REGSP:[0-9]+]], 40
+; DARWIN32: addi r[[REG1:[0-9]+]], r[[REGSP:[0-9]+]], 36
 ; DARWIN32: addi r[[REG2:[0-9]+]], r[[REGSP]], 24
-; DARWIN32: lwz r[[REG3:[0-9]+]], 48(r[[REGSP]])
+; DARWIN32: lwz r[[REG3:[0-9]+]], 44(r[[REGSP]])
 ; DARWIN32: lwz r[[REG4:[0-9]+]], 32(r[[REGSP]])
 ; DARWIN32: cmplw cr{{[0-9]+}}, r[[REG4]], r[[REG3]]
 ; DARWIN32: stw r[[REG3]], -[[OFFSET1:[0-9]+]]
diff --git a/test/CodeGen/PowerPC/hello-reloc.ll b/test/CodeGen/PowerPC/hello-reloc.ll
new file mode 100644
index 0000000..0fda921
--- /dev/null
+++ b/test/CodeGen/PowerPC/hello-reloc.ll
@@ -0,0 +1,281 @@
+; This tests mach-O/PPC relocation entries.
+; This test is paired with test/CodeGen/PowerPC/hello-reloc.s, 
+; which tests llvm-mc.
+
+; RUN: llc -filetype=asm -relocation-model=pic -mcpu=g4 -mtriple=powerpc-apple-darwin8 %s -o - | tee %t1 | FileCheck -check-prefix=DARWIN-G4-ASM %s
+; RUN-WORKS-BUT-SKIPPING: llc -filetype=obj -relocation-model=pic -mcpu=g4 -mtriple=powerpc-apple-darwin8 %s -o - | tee %t2 | macho-dump | tee %t3 | FileCheck -check-prefix=DARWIN-G4-DUMP %s
+
+; FIXME: validating .s->.o requires darwin asm syntax support in PPCAsmParser
+; RUN-XFAIL: llvm-mc -relocation-model=pic -mcpu=g4 -triple=powerpc-apple-darwin8 %t1 -o - | tee %t4 | macho-dump | tee %t5 | FileCheck -check-prefix=DARWIN-G4-DUMP %s
+; RUN-XFAIL: diff -u %t2 %t4 || diff -u %t3 %t5
+
+; ModuleID = 'hello-puts.c'
+; compiled with clang (-fno-common -DPIC -femit-all-decls) from:
+; extern int puts(const char*);
+; int main(int argc, char* argv[]) { puts("Hello, world!"); return 0; }
+
+target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:64:64-v128:128:128-n32"
+target triple = "powerpc-apple-macosx10.4.0"
+
+@.str = private unnamed_addr constant [14 x i8] c"Hello, world!\00", align 1
+
+; Function Attrs: nounwind
+define i32 @main(i32 %argc, i8** %argv) #0 {
+entry:
+  %retval = alloca i32, align 4
+  %argc.addr = alloca i32, align 4
+  %argv.addr = alloca i8**, align 4
+  store i32 0, i32* %retval
+  store i32 %argc, i32* %argc.addr, align 4
+  store i8** %argv, i8*** %argv.addr, align 4
+  %call = call i32 @puts(i8* getelementptr inbounds ([14 x i8]* @.str, i32 0, i32 0))
+  ret i32 0
+}
+
+declare i32 @puts(i8*) #1
+
+attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "ssp-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "ssp-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+; DARWIN-G4-ASM:	.machine ppc7400
+; DARWIN-G4-ASM:	.section	__TEXT,__textcoal_nt,coalesced,pure_instructions
+; DARWIN-G4-ASM:	.section	__TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32
+; DARWIN-G4-ASM:	.section	__TEXT,__text,regular,pure_instructions
+; DARWIN-G4-ASM:	.globl	_main
+; DARWIN-G4-ASM:	.align	4
+; DARWIN-G4-ASM:_main:                                  ; @main
+; DARWIN-G4-ASM:; BB#0:                                 ; %entry
+; DARWIN-G4-ASM:	mflr r0
+; DARWIN-G4-ASM:	stw r31, -4(r1)
+; DARWIN-G4-ASM:	stw r0, 8(r1)
+; DARWIN-G4-ASM:	stwu r1, -80(r1)
+; DARWIN-G4-ASM:	bl L0$pb
+; DARWIN-G4-ASM:L0$pb:
+; DARWIN-G4-ASM:	mr r31, r1
+; DARWIN-G4-ASM:	li [[REGA:r[0-9]+]], 0
+; DARWIN-G4-ASM:	mflr [[REGC:r[0-9]+]]
+; DARWIN-G4-ASM:	stw [[REGB:r[0-9]+]], 68(r31)
+; DARWIN-G4-ASM:	stw [[REGA]], 72(r31)
+; DARWIN-G4-ASM:	stw r4, 64(r31)
+; DARWIN-G4-ASM:	addis [[REGC]], [[REGC]], ha16(L_.str-L0$pb)
+; DARWIN-G4-ASM:	la [[REGB]], lo16(L_.str-L0$pb)([[REGC]])
+; DARWIN-G4-ASM:	bl L_puts$stub
+; DARWIN-G4-ASM:	li [[REGB]], 0
+; DARWIN-G4-ASM:	addi r1, r1, 80
+; DARWIN-G4-ASM:	lwz r0, 8(r1)
+; DARWIN-G4-ASM:	lwz r31, -4(r1)
+; DARWIN-G4-ASM:	mtlr r0
+; DARWIN-G4-ASM:	blr
+; DARWIN-G4-ASM:	.section	__TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32
+; DARWIN-G4-ASM:	.align	4
+; DARWIN-G4-ASM:L_puts$stub:
+; DARWIN-G4-ASM:	.indirect_symbol	_puts
+; DARWIN-G4-ASM:	mflr r0
+; DARWIN-G4-ASM:	bcl 20, 31, L_puts$stub$tmp
+; DARWIN-G4-ASM:L_puts$stub$tmp:
+; DARWIN-G4-ASM:	mflr [[REGD:r[0-9]+]]
+; DARWIN-G4-ASM:	addis [[REGD]], [[REGD]], ha16(L_puts$lazy_ptr-L_puts$stub$tmp)
+; DARWIN-G4-ASM:	mtlr r0
+; DARWIN-G4-ASM:	lwzu [[REGE:r[0-9]+]], lo16(L_puts$lazy_ptr-L_puts$stub$tmp)([[REGD]])
+; DARWIN-G4-ASM:	mtctr [[REGE]]
+; DARWIN-G4-ASM:	bctr
+; DARWIN-G4-ASM:	.section	__DATA,__la_symbol_ptr,lazy_symbol_pointers
+; DARWIN-G4-ASM:L_puts$lazy_ptr:
+; DARWIN-G4-ASM:	.indirect_symbol	_puts
+; DARWIN-G4-ASM:	.long	dyld_stub_binding_helper
+; DARWIN-G4-ASM:.subsections_via_symbols
+; DARWIN-G4-ASM:	.section	__TEXT,__cstring,cstring_literals
+; DARWIN-G4-ASM:L_.str:                                 ; @.str
+; DARWIN-G4-ASM:	.asciz	 "Hello, world!"
+
+; DARWIN-G4-DUMP: ('cputype', 18)
+; DARWIN-G4-DUMP: ('cpusubtype', 0)
+; DARWIN-G4-DUMP: ('filetype', 1)
+; DARWIN-G4-DUMP: ('num_load_commands', 3)
+; DARWIN-G4-DUMP: ('load_commands_size', 500)
+; DARWIN-G4-DUMP: ('flag', 8192)
+; DARWIN-G4-DUMP: ('load_commands', [
+; DARWIN-G4-DUMP: # Load Command 0
+; DARWIN-G4-DUMP: (('command', 1)
+; DARWIN-G4-DUMP: ('size', 396)
+; DARWIN-G4-DUMP: ('segment_name', '\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
+; DARWIN-G4-DUMP: ('vm_addr', 0)
+; DARWIN-G4-DUMP: ('vm_size', 130)
+; DARWIN-G4-DUMP: ('file_offset', 528)
+; DARWIN-G4-DUMP: ('file_size', 130)
+; DARWIN-G4-DUMP: ('maxprot', 7)
+; DARWIN-G4-DUMP: ('initprot', 7)
+; DARWIN-G4-DUMP: ('num_sections', 5)
+; DARWIN-G4-DUMP: ('flags', 0)
+; DARWIN-G4-DUMP: ('sections', [
+; DARWIN-G4-DUMP: # Section 0
+; DARWIN-G4-DUMP: (('section_name', '__text\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
+; DARWIN-G4-DUMP: ('segment_name', '__TEXT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
+; DARWIN-G4-DUMP: ('address', 0)
+; DARWIN-G4-DUMP: ('size', 80)
+; DARWIN-G4-DUMP: ('offset', 528)
+; DARWIN-G4-DUMP: ('alignment', 4)
+; DARWIN-G4-DUMP: ('reloc_offset', 660)
+; DARWIN-G4-DUMP: ('num_reloc', 5)
+; DARWIN-G4-DUMP: ('flags', 0x80000400)
+; DARWIN-G4-DUMP: ('reserved1', 0)
+; DARWIN-G4-DUMP: ('reserved2', 0)
+; DARWIN-G4-DUMP: ),
+; DARWIN-G4-DUMP: ('_relocations', [
+; DARWIN-G4-DUMP: # Relocation 0
+; DARWIN-G4-DUMP: (('word-0', 0x34),
+; DARWIN-G4-DUMP: ('word-1', 0x3c3)),
+; DARWIN-G4-DUMP: # Relocation 1
+; DARWIN-G4-DUMP: (('word-0', 0xab000030),
+; DARWIN-G4-DUMP: ('word-1', 0x74)),
+; DARWIN-G4-DUMP: # Relocation 2
+; DARWIN-G4-DUMP: (('word-0', 0xa1000000),
+; DARWIN-G4-DUMP: ('word-1', 0x14)),
+; DARWIN-G4-DUMP: # Relocation 3
+; DARWIN-G4-DUMP: (('word-0', 0xac00002c),
+; DARWIN-G4-DUMP: ('word-1', 0x74)),
+; DARWIN-G4-DUMP: # Relocation 4
+; DARWIN-G4-DUMP: (('word-0', 0xa1000060),
+; DARWIN-G4-DUMP: ('word-1', 0x14)),
+; DARWIN-G4-DUMP: ])
+; DARWIN-G4-DUMP: # Section 1
+; DARWIN-G4-DUMP: (('section_name', '__textcoal_nt\x00\x00\x00')
+; DARWIN-G4-DUMP: ('segment_name', '__TEXT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
+; DARWIN-G4-DUMP: ('address', 80)
+; DARWIN-G4-DUMP: ('size', 0)
+; DARWIN-G4-DUMP: ('offset', 608)
+; DARWIN-G4-DUMP: ('alignment', 0)
+; DARWIN-G4-DUMP: ('reloc_offset', 0)
+; DARWIN-G4-DUMP: ('num_reloc', 0)
+; DARWIN-G4-DUMP: ('flags', 0x8000000b)
+; DARWIN-G4-DUMP: ('reserved1', 0)
+; DARWIN-G4-DUMP: ('reserved2', 0)
+; DARWIN-G4-DUMP: ),
+; DARWIN-G4-DUMP: ('_relocations', [
+; DARWIN-G4-DUMP: ])
+; DARWIN-G4-DUMP: # Section 2
+; DARWIN-G4-DUMP: (('section_name', '__picsymbolstub1')
+; DARWIN-G4-DUMP: ('segment_name', '__TEXT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
+; DARWIN-G4-DUMP: ('address', 80)
+; DARWIN-G4-DUMP: ('size', 32)
+; DARWIN-G4-DUMP: ('offset', 608)
+; DARWIN-G4-DUMP: ('alignment', 4)
+; DARWIN-G4-DUMP: ('reloc_offset', 700)
+; DARWIN-G4-DUMP: ('num_reloc', 4)
+; DARWIN-G4-DUMP: ('flags', 0x80000408)
+; DARWIN-G4-DUMP: ('reserved1', 0)
+; DARWIN-G4-DUMP: ('reserved2', 32)
+; DARWIN-G4-DUMP: ),
+; DARWIN-G4-DUMP: ('_relocations', [
+; DARWIN-G4-DUMP: # Relocation 0
+; DARWIN-G4-DUMP: (('word-0', 0xab000014),
+; DARWIN-G4-DUMP: ('word-1', 0x70)),
+; DARWIN-G4-DUMP: # Relocation 1
+; DARWIN-G4-DUMP: (('word-0', 0xa1000000),
+; DARWIN-G4-DUMP: ('word-1', 0x58)),
+; DARWIN-G4-DUMP: # Relocation 2
+; DARWIN-G4-DUMP: (('word-0', 0xac00000c),
+; DARWIN-G4-DUMP: ('word-1', 0x70)),
+; DARWIN-G4-DUMP: # Relocation 3
+; DARWIN-G4-DUMP: (('word-0', 0xa1000018),
+; DARWIN-G4-DUMP: ('word-1', 0x58)),
+; DARWIN-G4-DUMP: ])
+; DARWIN-G4-DUMP: # Section 3
+; DARWIN-G4-DUMP: (('section_name', '__la_symbol_ptr\x00')
+; DARWIN-G4-DUMP: ('segment_name', '__DATA\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
+; DARWIN-G4-DUMP: ('address', 112)
+; DARWIN-G4-DUMP: ('size', 4)
+; DARWIN-G4-DUMP: ('offset', 640)
+; DARWIN-G4-DUMP: ('alignment', 0)
+; DARWIN-G4-DUMP: ('reloc_offset', 732)
+; DARWIN-G4-DUMP: ('num_reloc', 1)
+; DARWIN-G4-DUMP: ('flags', 0x7)
+; DARWIN-G4-DUMP: ('reserved1', 1)
+; DARWIN-G4-DUMP: ('reserved2', 0)
+; DARWIN-G4-DUMP: ),
+; DARWIN-G4-DUMP: ('_relocations', [
+; DARWIN-G4-DUMP: # Relocation 0
+; DARWIN-G4-DUMP: (('word-0', 0x0),
+; DARWIN-G4-DUMP: ('word-1', 0x250)),
+; DARWIN-G4-DUMP: ])
+; DARWIN-G4-DUMP: # Section 4
+; DARWIN-G4-DUMP: (('section_name', '__cstring\x00\x00\x00\x00\x00\x00\x00')
+; DARWIN-G4-DUMP: ('segment_name', '__TEXT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
+; DARWIN-G4-DUMP: ('address', 116)
+; DARWIN-G4-DUMP: ('size', 14)
+; DARWIN-G4-DUMP: ('offset', 644)
+; DARWIN-G4-DUMP: ('alignment', 0)
+; DARWIN-G4-DUMP: ('reloc_offset', 0)
+; DARWIN-G4-DUMP: ('num_reloc', 0)
+; DARWIN-G4-DUMP: ('flags', 0x2)
+; DARWIN-G4-DUMP: ('reserved1', 0)
+; DARWIN-G4-DUMP: ('reserved2', 0)
+; DARWIN-G4-DUMP: ),
+; DARWIN-G4-DUMP: ('_relocations', [
+; DARWIN-G4-DUMP: ])
+; DARWIN-G4-DUMP: ])
+; DARWIN-G4-DUMP: ),
+; DARWIN-G4-DUMP: # Load Command 1
+; DARWIN-G4-DUMP: (('command', 2)
+; DARWIN-G4-DUMP: ('size', 24)
+; DARWIN-G4-DUMP: ('symoff', 748)
+; DARWIN-G4-DUMP: ('nsyms', 3)
+; DARWIN-G4-DUMP: ('stroff', 784)
+; DARWIN-G4-DUMP: ('strsize', 40)
+; DARWIN-G4-DUMP: ('_string_data', '\x00_main\x00dyld_stub_binding_helper\x00_puts\x00\x00\x00')
+; DARWIN-G4-DUMP: ('_symbols', [
+; DARWIN-G4-DUMP: # Symbol 0
+; DARWIN-G4-DUMP: (('n_strx', 1)
+; DARWIN-G4-DUMP: ('n_type', 0xf)
+; DARWIN-G4-DUMP: ('n_sect', 1)
+; DARWIN-G4-DUMP: ('n_desc', 0)
+; DARWIN-G4-DUMP: ('n_value', 0)
+; DARWIN-G4-DUMP: ('_string', '_main')
+; DARWIN-G4-DUMP: ),
+; DARWIN-G4-DUMP: # Symbol 1
+; DARWIN-G4-DUMP: (('n_strx', 32)
+; DARWIN-G4-DUMP: ('n_type', 0x1)
+; DARWIN-G4-DUMP: ('n_sect', 0)
+; DARWIN-G4-DUMP: ('n_desc', 1)
+; DARWIN-G4-DUMP: ('n_value', 0)
+; DARWIN-G4-DUMP: ('_string', '_puts')
+; DARWIN-G4-DUMP: ),
+; DARWIN-G4-DUMP: # Symbol 2
+; DARWIN-G4-DUMP: (('n_strx', 7)
+; DARWIN-G4-DUMP: ('n_type', 0x1)
+; DARWIN-G4-DUMP: ('n_sect', 0)
+; DARWIN-G4-DUMP: ('n_desc', 0)
+; DARWIN-G4-DUMP: ('n_value', 0)
+; DARWIN-G4-DUMP: ('_string', 'dyld_stub_binding_helper')
+; DARWIN-G4-DUMP: ),
+; DARWIN-G4-DUMP: ])
+; DARWIN-G4-DUMP: ),
+; DARWIN-G4-DUMP: # Load Command 2
+; DARWIN-G4-DUMP: (('command', 11)
+; DARWIN-G4-DUMP: ('size', 80)
+; DARWIN-G4-DUMP: ('ilocalsym', 0)
+; DARWIN-G4-DUMP: ('nlocalsym', 0)
+; DARWIN-G4-DUMP: ('iextdefsym', 0)
+; DARWIN-G4-DUMP: ('nextdefsym', 1)
+; DARWIN-G4-DUMP: ('iundefsym', 1)
+; DARWIN-G4-DUMP: ('nundefsym', 2)
+; DARWIN-G4-DUMP: ('tocoff', 0)
+; DARWIN-G4-DUMP: ('ntoc', 0)
+; DARWIN-G4-DUMP: ('modtaboff', 0)
+; DARWIN-G4-DUMP: ('nmodtab', 0)
+; DARWIN-G4-DUMP: ('extrefsymoff', 0)
+; DARWIN-G4-DUMP: ('nextrefsyms', 0)
+; DARWIN-G4-DUMP: ('indirectsymoff', 740)
+; DARWIN-G4-DUMP: ('nindirectsyms', 2)
+; DARWIN-G4-DUMP: ('extreloff', 0)
+; DARWIN-G4-DUMP: ('nextrel', 0)
+; DARWIN-G4-DUMP: ('locreloff', 0)
+; DARWIN-G4-DUMP: ('nlocrel', 0)
+; DARWIN-G4-DUMP: ('_indirect_symbols', [
+; DARWIN-G4-DUMP: # Indirect Symbol 0
+; DARWIN-G4-DUMP: (('symbol_index', 0x1),),
+; DARWIN-G4-DUMP: # Indirect Symbol 1
+; DARWIN-G4-DUMP: (('symbol_index', 0x1),),
+; DARWIN-G4-DUMP: ])
+; DARWIN-G4-DUMP: ),
+; DARWIN-G4-DUMP: ])
diff --git a/test/CodeGen/PowerPC/hello-reloc.s b/test/CodeGen/PowerPC/hello-reloc.s
index 9bbfb38..1e3fb8f 100644
--- a/test/CodeGen/PowerPC/hello-reloc.s
+++ b/test/CodeGen/PowerPC/hello-reloc.s
@@ -1,14 +1,10 @@
 ; This tests for the basic implementation of PPCMachObjectWriter.cpp,
 ; which is responsible for writing mach-o relocation entries for (PIC)
 ; PowerPC objects.
-; NOTE: Darwin PPC asm syntax is not yet supported by PPCAsmParser,
-; so this test case uses ELF PPC asm syntax to produce a mach-o object.
-; Once PPCAsmParser supports darwin asm syntax, this test case should
-; be updated accordingly.  
 
 ; RUN: llvm-mc -filetype=obj -relocation-model=pic -mcpu=g4 -triple=powerpc-apple-darwin8 %s -o - | llvm-readobj -relocations | FileCheck -check-prefix=DARWIN-G4-DUMP %s
 
-;	.machine ppc7400
+	.machine ppc7400
 	.section	__TEXT,__textcoal_nt,coalesced,pure_instructions
 	.section	__TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32
 	.section	__TEXT,__text,regular,pure_instructions
@@ -16,40 +12,40 @@
 	.align	4
 _main:                                  ; @main
 ; BB#0:                                 ; %entry
-	mflr 0
-	stw 31, -4(1)
-	stw 0, 8(1)
-	stwu 1, -80(1)
+	mflr r0
+	stw r31, -4(r1)
+	stw r0, 8(r1)
+	stwu r1, -80(r1)
 	bl L0$pb
 L0$pb:
-	mr 31, 1
-	li 5, 0
+	mr r31, r1
+	li r5, 0
 	mflr 2
-	stw 3, 68(31)
-	stw 5, 72(31)
-	stw 4, 64(31)
-	addis 2, 2, (L_.str-L0$pb)@ha
-	la 3, (L_.str-L0$pb)@l(2)
+	stw r3, 68(r31)
+	stw r5, 72(r31)
+	stw r4, 64(r31)
+	addis r2, r2, ha16(L_.str-L0$pb)
+	la r3, lo16(L_.str-L0$pb)(r2)
 	bl L_puts$stub
-	li 3, 0
-	addi 1, 1, 80
-	lwz 0, 8(1)
-	lwz 31, -4(1)
-	mtlr 0
+	li r3, 0
+	addi r1, r1, 80
+	lwz r0, 8(r1)
+	lwz r31, -4(r1)
+	mtlr r0
 	blr
 
 	.section	__TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32
 	.align	4
 L_puts$stub:
 	.indirect_symbol	_puts
-	mflr 0
+	mflr r0
 	bcl 20, 31, L_puts$stub$tmp
 L_puts$stub$tmp:
-	mflr 11
-	addis 11, 11, (L_puts$lazy_ptr-L_puts$stub$tmp)@ha
-	mtlr 0
-	lwzu 12, (L_puts$lazy_ptr-L_puts$stub$tmp)@l(11)
-	mtctr 12
+	mflr r11
+	addis r11, r11, ha16(L_puts$lazy_ptr-L_puts$stub$tmp)
+	mtlr r0
+	lwzu r12, lo16(L_puts$lazy_ptr-L_puts$stub$tmp)(r11)
+	mtctr r12
 	bctr
 	.section	__DATA,__la_symbol_ptr,lazy_symbol_pointers
 L_puts$lazy_ptr:
diff --git a/test/CodeGen/PowerPC/weak_def_can_be_hidden.ll b/test/CodeGen/PowerPC/weak_def_can_be_hidden.ll
new file mode 100644
index 0000000..130d8fa
--- /dev/null
+++ b/test/CodeGen/PowerPC/weak_def_can_be_hidden.ll
@@ -0,0 +1,38 @@
+; taken from X86 version of the same test
+; RUN: llc -mtriple=powerpc-apple-darwin10 -O0 < %s | FileCheck %s
+; RUN: llc -mtriple=powerpc-apple-darwin9 -O0 < %s | FileCheck --check-prefix=CHECK-D89 %s
+; RUN: llc -mtriple=powerpc-apple-darwin8 -O0 < %s | FileCheck --check-prefix=CHECK-D89 %s
+
+@v1 = linkonce_odr global i32 32
+; CHECK: .globl  _v1
+; CHECK: .weak_def_can_be_hidden _v1
+
+; CHECK-D89: .globl  _v1
+; CHECK-D89: .weak_definition _v1
+
+define i32 @f1() {
+  %x = load i32 * @v1
+  ret i32 %x
+}
+
+@v2 = linkonce_odr global i32 32
+; CHECK: .globl  _v2
+; CHECK: .weak_definition _v2
+
+; CHECK-D89: .globl  _v2
+; CHECK-D89: .weak_definition _v2
+
+@v3 = linkonce_odr unnamed_addr global i32 32
+; CHECK: .globl  _v3
+; CHECK: .weak_def_can_be_hidden _v3
+
+; CHECK-D89: .globl  _v3
+; CHECK-D89: .weak_definition _v3
+
+define i32* @f2() {
+  ret i32* @v2
+}
+
+define i32* @f3() {
+  ret i32* @v3
+}
diff --git a/test/CodeGen/X86/pr10420.ll b/test/CodeGen/X86/pr10420.ll
index 3993f24..62951892 100644
--- a/test/CodeGen/X86/pr10420.ll
+++ b/test/CodeGen/X86/pr10420.ll
@@ -1,4 +1,9 @@
-; RUN: llc < %s -mtriple=x86_64-apple-macosx -disable-cfi | FileCheck %s
+; RUN: llc < %s -mtriple=x86_64-apple-macosx10.7 -disable-cfi | FileCheck --check-prefix=CHECK-64-D11 %s
+; RUN: llc < %s -mtriple=x86_64-apple-macosx10.6 -disable-cfi | FileCheck %s
+; RUN: llc < %s -mtriple=x86_64-apple-macosx10.5 -disable-cfi | FileCheck --check-prefix=CHECK-64-D89 %s
+; RUN: llc < %s -mtriple=i686-apple-macosx10.6 -disable-cfi | FileCheck --check-prefix=CHECK-I686-D10 %s
+; RUN: llc < %s -mtriple=i686-apple-macosx10.5 -disable-cfi | FileCheck --check-prefix=CHECK-I686-D89 %s
+; RUN: llc < %s -mtriple=i686-apple-macosx10.4 -disable-cfi | FileCheck --check-prefix=CHECK-I686-D89 %s
 
 define private void @foo() {
        ret void
@@ -19,3 +24,44 @@ define void @bar() {
 ; CHECK: Ltmp19:
 ; CHECK-NEXT: Ltmp20 = Ltmp2-Ltmp19                   ## FDE initial location
 ; CHECK-NEXT:         .quad   Ltmp20
+
+
+; CHECK-64-D11: Ltmp13:
+; CHECK-64-D11-NEXT: Ltmp14 = L_foo-Ltmp13                   ## FDE initial location
+; CHECK-64-D11-NEXT:         .quad   Ltmp14
+
+; CHECK-64-D11: Ltmp20:
+; CHECK-64-D11-NEXT: Ltmp21 = Ltmp2-Ltmp20                   ## FDE initial location
+; CHECK-64-D11-NEXT:         .quad   Ltmp21
+
+
+; CHECK-64-D89: Ltmp12:
+; CHECK-64-D89-NEXT: .quad	L_foo-Ltmp12                   ## FDE initial location
+; CHECK-64-D89-NEXT: Ltmp13 = (Ltmp0-L_foo)-0                   ## FDE address range
+; CHECK-64-D89-NEXT:         .quad   Ltmp13
+
+; CHECK-64-D89: Ltmp18:
+; CHECK-64-D89-NEXT: .quad	Ltmp2-Ltmp18                   ## FDE initial location
+; CHECK-64-D89-NEXT: Ltmp19 = (Ltmp4-Ltmp2)-0                   ## FDE address range
+; CHECK-64-D89-NEXT:         .quad   Ltmp19
+
+
+; CHECK-I686-D10: Ltmp12:
+; CHECK-I686-D10-NEXT: Ltmp13 = L_foo-Ltmp12                   ## FDE initial location
+; CHECK-I686-D10-NEXT:         .long   Ltmp13
+
+; CHECK-I686-D10: Ltmp19:
+; CHECK-I686-D10-NEXT: Ltmp20 = Ltmp2-Ltmp19                   ## FDE initial location
+; CHECK-I686-D10-NEXT:         .long   Ltmp20
+
+
+; CHECK-I686-D89: Ltmp12:
+; CHECK-I686-D89-NEXT: .long	L_foo-Ltmp12                   ## FDE initial location
+; CHECK-I686-D89-NEXT: Ltmp13 = (Ltmp0-L_foo)-0                   ## FDE address range
+; CHECK-I686-D89-NEXT:         .long   Ltmp13
+
+; CHECK-I686-D89: Ltmp18:
+; CHECK-I686-D89-NEXT: .long	Ltmp2-Ltmp18                   ## FDE initial location
+; CHECK-I686-D89-NEXT: Ltmp19 = (Ltmp4-Ltmp2)-0                   ## FDE address range
+; CHECK-I686-D89-NEXT:         .long   Ltmp19
+
diff --git a/test/CodeGen/X86/weak_def_can_be_hidden.ll b/test/CodeGen/X86/weak_def_can_be_hidden.ll
index f78f357..22aa135 100644
--- a/test/CodeGen/X86/weak_def_can_be_hidden.ll
+++ b/test/CodeGen/X86/weak_def_can_be_hidden.ll
@@ -1,9 +1,16 @@
-; RUN: llc -mtriple=x86_64-apple-darwin  -O0 < %s | FileCheck %s
+; RUN: llc -mtriple=x86_64-apple-darwin11 -O0 < %s | FileCheck %s
+; RUN: llc -mtriple=x86_64-apple-darwin10 -O0 < %s | FileCheck %s
+; RUN: llc -mtriple=x86_64-apple-darwin9 -O0 < %s | FileCheck --check-prefix=CHECK-D89 %s
+; RUN: llc -mtriple=i686-apple-darwin9 -O0 < %s | FileCheck --check-prefix=CHECK-D89 %s
+; RUN: llc -mtriple=i686-apple-darwin8 -O0 < %s | FileCheck --check-prefix=CHECK-D89 %s
 
 @v1 = linkonce_odr global i32 32
 ; CHECK: .globl  _v1
 ; CHECK: .weak_def_can_be_hidden _v1
 
+; CHECK-D89: .globl  _v1
+; CHECK-D89: .weak_definition _v1
+
 define i32 @f1() {
   %x = load i32 * @v1
   ret i32 %x
@@ -13,10 +20,16 @@ define i32 @f1() {
 ; CHECK: .globl  _v2
 ; CHECK: .weak_definition _v2
 
+; CHECK-D89: .globl  _v2
+; CHECK-D89: .weak_definition _v2
+
 @v3 = linkonce_odr unnamed_addr global i32 32
 ; CHECK: .globl  _v3
 ; CHECK: .weak_def_can_be_hidden _v3
 
+; CHECK-D89: .globl  _v3
+; CHECK-D89: .weak_definition _v3
+
 define i32* @f2() {
   ret i32* @v2
 }
diff --git a/test/MC/MachO/indirect-symbols.s b/test/MC/MachO/indirect-symbols.s
index 90fd231..deb9e7a 100644
--- a/test/MC/MachO/indirect-symbols.s
+++ b/test/MC/MachO/indirect-symbols.s
@@ -97,7 +97,7 @@ _e:
 // CHECK:   ('nsyms', 6)
 // CHECK:   ('stroff', 516)
 // CHECK:   ('strsize', 20)
-// CHECK:   ('_string_data', '\x00_d\x00_a\x00_b\x00_c\x00_e\x00_f\x00\x00')
+// CHECK:   ('_string_data', '\x00_a\x00_d\x00_b\x00_c\x00_e\x00_f\x00\x00')
 // CHECK:   ('_symbols', [
 // CHECK:     # Symbol 0
 // CHECK:    (('n_strx', 7)
@@ -132,7 +132,7 @@ _e:
 // CHECK:     ('_string', '_f')
 // CHECK:    ),
 // CHECK:     # Symbol 4
-// CHECK:    (('n_strx', 4)
+// CHECK:    (('n_strx', 1)
 // CHECK:     ('n_type', 0x1)
 // CHECK:     ('n_sect', 0)
 // CHECK:     ('n_desc', 1)
@@ -140,7 +140,7 @@ _e:
 // CHECK:     ('_string', '_a')
 // CHECK:    ),
 // CHECK:     # Symbol 5
-// CHECK:    (('n_strx', 1)
+// CHECK:    (('n_strx', 4)
 // CHECK:     ('n_type', 0x1)
 // CHECK:     ('n_sect', 0)
 // CHECK:     ('n_desc', 0)
diff --git a/test/MC/MachO/symbol-indirect.s b/test/MC/MachO/symbol-indirect.s
index 2412970..6f5c842 100644
--- a/test/MC/MachO/symbol-indirect.s
+++ b/test/MC/MachO/symbol-indirect.s
@@ -137,7 +137,7 @@ sym_nlp_G:
 // CHECK:   ('nsyms', 10)
 // CHECK:   ('stroff', 592)
 // CHECK:   ('strsize', 104)
-// CHECK:   ('_string_data', '\x00sym_lsp_A\x00sym_lsp_G\x00sym_nlp_A\x00sym_nlp_G\x00sym_nlp_B\x00sym_nlp_E\x00sym_lsp_B\x00sym_lsp_E\x00sym_lsp_C\x00sym_nlp_C\x00\x00\x00\x00')
+// CHECK:   ('_string_data', '\x00sym_lsp_A\x00sym_lsp_G\x00sym_nlp_A\x00sym_nlp_G\x00sym_lsp_B\x00sym_lsp_E\x00sym_nlp_B\x00sym_nlp_E\x00sym_lsp_C\x00sym_nlp_C\x00\x00\x00\x00')
 // CHECK:   ('_symbols', [
 // CHECK:     # Symbol 0
 // CHECK:    (('n_strx', 81)
@@ -180,7 +180,7 @@ sym_nlp_G:
 // CHECK:     ('_string', 'sym_lsp_A')
 // CHECK:    ),
 // CHECK:     # Symbol 5
-// CHECK:    (('n_strx', 61)
+// CHECK:    (('n_strx', 41)
 // CHECK:     ('n_type', 0x1)
 // CHECK:     ('n_sect', 0)
 // CHECK:     ('n_desc', 1)
@@ -188,7 +188,7 @@ sym_nlp_G:
 // CHECK:     ('_string', 'sym_lsp_B')
 // CHECK:    ),
 // CHECK:     # Symbol 6
-// CHECK:    (('n_strx', 71)
+// CHECK:    (('n_strx', 51)
 // CHECK:     ('n_type', 0x1)
 // CHECK:     ('n_sect', 0)
 // CHECK:     ('n_desc', 1)
@@ -204,7 +204,7 @@ sym_nlp_G:
 // CHECK:     ('_string', 'sym_nlp_A')
 // CHECK:    ),
 // CHECK:     # Symbol 8
-// CHECK:    (('n_strx', 41)
+// CHECK:    (('n_strx', 61)
 // CHECK:     ('n_type', 0x1)
 // CHECK:     ('n_sect', 0)
 // CHECK:     ('n_desc', 0)
@@ -212,7 +212,7 @@ sym_nlp_G:
 // CHECK:     ('_string', 'sym_nlp_B')
 // CHECK:    ),
 // CHECK:     # Symbol 9
-// CHECK:    (('n_strx', 51)
+// CHECK:    (('n_strx', 71)
 // CHECK:     ('n_type', 0x1)
 // CHECK:     ('n_sect', 0)
 // CHECK:     ('n_desc', 0)
diff --git a/test/Transforms/GCOVProfiling/version.ll b/test/Transforms/GCOVProfiling/version.ll
index 2f1bd70..c181058 100644
--- a/test/Transforms/GCOVProfiling/version.ll
+++ b/test/Transforms/GCOVProfiling/version.ll
@@ -1,11 +1,11 @@
 ; RUN: echo '!9 = metadata !{metadata !"%T/version.ll", metadata !0}' > %t1
 ; RUN: cat %s %t1 > %t2
 ; RUN: opt -insert-gcov-profiling -disable-output < %t2
-; RUN: head -c12 %T/version.gcno | grep '^oncg\*204MVLL$'
+; RUN: ghead -c12 %T/version.gcno | grep '^oncg\*204MVLL$'
 ; RUN: rm %T/version.gcno
 ; RUN: not opt -insert-gcov-profiling -default-gcov-version=asdfasdf -disable-output < %t2
 ; RUN: opt -insert-gcov-profiling -default-gcov-version=407* -disable-output < %t2
-; RUN: head -c12 %T/version.gcno | grep '^oncg\*704MVLL$'
+; RUN: ghead -c12 %T/version.gcno | grep '^oncg\*704MVLL$'
 ; RUN: rm %T/version.gcno
 
 define void @test() {
diff --git a/tools/bugpoint-passes/CMakeLists.txt b/tools/bugpoint-passes/CMakeLists.txt
index 05f190a..45b4a23 100644
--- a/tools/bugpoint-passes/CMakeLists.txt
+++ b/tools/bugpoint-passes/CMakeLists.txt
@@ -1,3 +1,6 @@
+# patch: this should be built as a bundle/module/plug-in
+set(MODULE TRUE)
+
 if( NOT LLVM_BUILD_TOOLS )
   set(EXCLUDE_FROM_ALL ON)
 endif()
diff --git a/utils/TableGen/AsmMatcherEmitter.cpp b/utils/TableGen/AsmMatcherEmitter.cpp
index de24cde..adb129d 100644
--- a/utils/TableGen/AsmMatcherEmitter.cpp
+++ b/utils/TableGen/AsmMatcherEmitter.cpp
@@ -325,7 +325,7 @@ struct MatchableInfo {
   /// assembler operand expands to multiple MCOperands, this represents the
   /// single assembler operand, not the MCOperand.
   struct ResOperand {
-    enum {
+    enum ResOperandEnum {
       /// RenderAsmOperand - This represents an operand result that is
       /// generated by calling the render method on the assembly operand.  The
       /// corresponding AsmOperand is specified by AsmOperandNum.
diff --git a/utils/TableGen/CodeGenInstruction.h b/utils/TableGen/CodeGenInstruction.h
index 6004f66..8bae408 100644
--- a/utils/TableGen/CodeGenInstruction.h
+++ b/utils/TableGen/CodeGenInstruction.h
@@ -30,7 +30,7 @@ namespace llvm {
   class CGIOperandList {
   public:
     class ConstraintInfo {
-      enum { None, EarlyClobber, Tied } Kind;
+      enum KindEnum { None, EarlyClobber, Tied } Kind;
       unsigned OtherTiedOperand;
     public:
       ConstraintInfo() : Kind(None) {}
@@ -300,7 +300,7 @@ namespace llvm {
 
       int64_t Imm;
     public:
-      enum {
+      enum KindEnum {
         K_Record,
         K_Imm,
         K_Reg
diff --git a/utils/TableGen/CodeGenIntrinsics.h b/utils/TableGen/CodeGenIntrinsics.h
index ababfa4..750c2da 100644
--- a/utils/TableGen/CodeGenIntrinsics.h
+++ b/utils/TableGen/CodeGenIntrinsics.h
@@ -59,7 +59,7 @@ namespace llvm {
     IntrinsicSignature IS;
 
     // Memory mod/ref behavior of this intrinsic.
-    enum {
+    enum ModRefEnum {
       NoMem, ReadArgMem, ReadMem, ReadWriteArgMem, ReadWriteMem
     } ModRef;
 
diff --git a/utils/TableGen/InstrInfoEmitter.cpp b/utils/TableGen/InstrInfoEmitter.cpp
index d3d9cc1..c75bc31 100644
--- a/utils/TableGen/InstrInfoEmitter.cpp
+++ b/utils/TableGen/InstrInfoEmitter.cpp
@@ -255,7 +255,7 @@ void InstrInfoEmitter::emitOperandNameMappings(raw_ostream &OS,
   OS << "namespace llvm {";
   OS << "namespace " << Namespace << " {\n";
   OS << "namespace " << OpNameNS << " { \n";
-  OS << "enum {\n";
+  OS << "enum OperandEnum {\n";
   for (StrUintMapIter i = Operands.begin(), e = Operands.end(); i != e; ++i)
     OS << "  " << i->first << " = " << i->second << ",\n";
 
@@ -585,7 +585,7 @@ void InstrInfoEmitter::emitEnums(raw_ostream &OS) {
     Target.getInstructionsByEnumValue();
 
   OS << "namespace " << Namespace << " {\n";
-  OS << "  enum {\n";
+  OS << "  enum InstructionEnum {\n";
   for (unsigned i = 0, e = NumberedInstructions.size(); i != e; ++i) {
     OS << "    " << NumberedInstructions[i]->TheDef->getName()
        << "\t= " << i << ",\n";
diff --git a/utils/TableGen/RegisterInfoEmitter.cpp b/utils/TableGen/RegisterInfoEmitter.cpp
index cc08df9..28cbbe6 100644
--- a/utils/TableGen/RegisterInfoEmitter.cpp
+++ b/utils/TableGen/RegisterInfoEmitter.cpp
@@ -88,7 +88,7 @@ void RegisterInfoEmitter::runEnums(raw_ostream &OS,
 
   if (!Namespace.empty())
     OS << "namespace " << Namespace << " {\n";
-  OS << "enum {\n  NoRegister,\n";
+  OS << "enum RegisterEnum {\n  NoRegister,\n";
 
   for (unsigned i = 0, e = Registers.size(); i != e; ++i)
     OS << "  " << Registers[i]->getName() << " = " <<
@@ -110,7 +110,7 @@ void RegisterInfoEmitter::runEnums(raw_ostream &OS,
     OS << "\n// Register classes\n";
     if (!Namespace.empty())
       OS << "namespace " << Namespace << " {\n";
-    OS << "enum {\n";
+    OS << "enum RegisterClassEnum {\n";
     for (unsigned i = 0, e = RegisterClasses.size(); i != e; ++i) {
       if (i) OS << ",\n";
       OS << "  " << RegisterClasses[i]->getName() << "RegClassID";
@@ -128,7 +128,7 @@ void RegisterInfoEmitter::runEnums(raw_ostream &OS,
     OS << "\n// Register alternate name indices\n";
     if (!Namespace.empty())
       OS << "namespace " << Namespace << " {\n";
-    OS << "enum {\n";
+    OS << "enum AltNameEnum {\n";
     for (unsigned i = 0, e = RegAltNameIndices.size(); i != e; ++i)
       OS << "  " << RegAltNameIndices[i]->getName() << ",\t// " << i << "\n";
     OS << "  NUM_TARGET_REG_ALT_NAMES = " << RegAltNameIndices.size() << "\n";
@@ -144,7 +144,7 @@ void RegisterInfoEmitter::runEnums(raw_ostream &OS,
       SubRegIndices[0]->getNamespace();
     if (!Namespace.empty())
       OS << "namespace " << Namespace << " {\n";
-    OS << "enum {\n  NoSubRegister,\n";
+    OS << "enum SubRegisterEnum {\n  NoSubRegister,\n";
     for (unsigned i = 0, e = SubRegIndices.size(); i != e; ++i)
       OS << "  " << SubRegIndices[i]->getName() << ",\t// " << i+1 << "\n";
     OS << "  NUM_TARGET_SUBREGS\n};\n";
diff --git a/utils/TableGen/SubtargetEmitter.cpp b/utils/TableGen/SubtargetEmitter.cpp
index b9f9d06..98d0137 100644
--- a/utils/TableGen/SubtargetEmitter.cpp
+++ b/utils/TableGen/SubtargetEmitter.cpp
@@ -141,7 +141,7 @@ void SubtargetEmitter::Enumeration(raw_ostream &OS,
     }
   } else {
     // Open enumeration
-    OS << "enum {\n";
+    OS << "enum SubtargetEnum {\n";
 
     // For each record
     for (unsigned i = 0; i < N;) {
diff --git a/utils/Target/PowerPC/darwin-to-linux-ppc-asm.sed b/utils/Target/PowerPC/darwin-to-linux-ppc-asm.sed
new file mode 100755
index 0000000..ac01cda
--- /dev/null
+++ b/utils/Target/PowerPC/darwin-to-linux-ppc-asm.sed
@@ -0,0 +1,7 @@
+#!env sed -f
+# syntactically translates darwin-ppc assembly to GNU/linux assembly
+# GNU sed required
+s|\<r\([0-9]\+\)\>|\1|g
+s|\<ha16\>\(([^(]*)\)|\1@ha|g
+s|\<lo16\>\(([^(]*)\)|\1@l|g
+# s|\<L[A-Za-z0-9.$_]\+\>|.&|g
diff --git a/utils/lit/lit/TestRunner.py b/utils/lit/lit/TestRunner.py
index 9752417..2bb3f75 100644
--- a/utils/lit/lit/TestRunner.py
+++ b/utils/lit/lit/TestRunner.py
@@ -415,11 +415,16 @@ def parseIntegratedTestScript(test, normalize_slashes=False,
                     return str(line_number - int(match.group(2)))
             ln = re.sub('%\(line *([\+-]) *(\d+)\)', replace_line_number, ln)
 
+            ln1 = ln.split(' ')[1];
             # Collapse lines with trailing '\\'.
             if script and script[-1][-1] == '\\':
                 script[-1] = script[-1][:-1] + ln
-            else:
+            # do not commit this patch
+            # exception: built-in shell commands and operators
+            elif ln[1] == '(' or ln[1] == '{' or ln[1] == '!' or ln[1] == '|' or ln1 == 'export' or ln1 == 'env' or ln1 == 'cd' or ln1 == 'pushd' or ln1 == 'set' or ln1 == 'test' or ln1 == 'umask':
                 script.append(ln)
+            else:
+                script.append('gtimeout 1m ' +ln)
         elif command_type == 'XFAIL':
             test.xfails.extend([s.strip() for s in ln.split(',')])
         elif command_type == 'REQUIRES':
