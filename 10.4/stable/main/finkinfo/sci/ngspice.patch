--- ng-spice-rework-17/doc/ngspice.info.orig	2005-08-30 04:24:02.000000000 -0400
+++ ng-spice-rework-17/doc/ngspice.info	2007-02-07 22:26:17.000000000 -0500
@@ -1,6 +1,11 @@
 This is ngspice.info, produced by makeinfo version 4.7 from
 ngspice.texi.
 
+INFO-DIR-SECTION GNU EDA Tools
+START-INFO-DIR-ENTRY
+* ngspice: (ngspice).       Electrical simulation tool
+END-INFO-DIR-ENTRY
+
    Copyright 1996 The Regents of the University of California.
 
      Permission to use, copy, modify, and distribute this software and
--- ng-spice-rework/ChangeLog:1.305	Sun Nov 30 12:47:07 2008
+++ ng-spice-rework/ChangeLog	Sat Jan 31 15:17:48 2009
@@ -1,4 +1,192 @@
-2008-11-30
+2009-01-31 Holger Vogt
+ * xpressn.c, spicenum.c, numparam.h, runcoms.c, runcoms2.c:
+   Incompatibilty to MAC OSX removed by proper variable declarations
+ * subckt.c: bug no. 2293284: preliminary change, further tests required
+ 
+2009-01-26 Lionel Sainte Cluque
+ * man/man1/ngspice.1,
+ * man/man1/nutmeg.1:
+   apply Ahmed El-Mahmoudy's patch on hyphens in manpages.
+
+2009-01-18 Paolo Nenzi
+ * src/frontend/plotting/plotit.c,
+ * src/frontend/plotting/plotcurv.c:
+   33: Fixed some of the existing problemass SMITH PLOT. There were 2 errors:
+       one in plotit() to calculate the transformation line (r-1) / (r +1) 
+       where a mistake was made in the process of plotting a single real point
+       and the other in ft_graf() that would print imaginary part = real part
+       for real data. A. Roldan - espice
+   32: Fixed some problems the existing polar PLOT. To summarize the 
+       problems were in the wrong calculation of the size of x and y axes 
+       for the plot. A. Roldan - espice		
+
+2009-01-18 Holger Vogt
+ * src/frontend/mw_coms.c: variable declarations to top of function
+ * outif.c, alloc.c: add HAS_TCLWIN flag to allow coimpilation of 
+   tclspice under MS VC++
+
+2009-01-16 Paolo Nenzi
+ * src/frontend/mw_coms.c, src/frontend/commands.c, 
+ * src/frontend/runcoms.c, src/include/fteext.h:
+   34, 
+   36, 
+   38: Added the removecirc command. This command removes the current        
+       circuit and its associated plots. This comes from an old function
+       written by M. Widlok and updated by A. Roldan for espice.
+       Note: I have changed the code to eliminate GTK functions and tested.
+       Things work but in ngspice there is a problem due to model redefinitions,
+       as it seems that in ngspice models are globals. Need further 
+       investigation. P. Nenzi
+
+ * src/frontend/commands.c, src/frontend/misccomms.c:
+   24: Added the parameter "noask" to quit command to avoid the question
+       before exiting ngspice. A. Roldan - Espice
+ 
+ * src/frontend/evaluate.c, src/frontend/typedefs.c, src/include/sim.h:
+   Added some vector types from Espice (impedance, admittance, power etc.)
+   The original implementation by A. Roldan did not fit immediatly. I had
+   to comment two definitions. I could not test "plotab". 
+
+2009-01-16 Paolo Nenzi
+ * src/frontend/evaluate.c, src/frontend/typedefs.c, src/include/sim.h:
+   Added some vector types from Espice (impedance, admittance, power etc.)
+   The original implementation by A. Roldan did not fit immediatly. I had
+   to comment two definitions. I could not test "plotab". 
+
+2009-01-15 Paolo Nenzi
+ * src/spicelib/devices/vsrc/vsrc.c,
+ * src/spicelib/devices/isrc/isrc.c,
+ * src/frontend/spiceif.c,
+ * src/frontend/device.c,
+ * src/frontend/postcoms.c,
+ * src/frontend/vectors.c:
+   17: New capability of print command. It is now possible to print and
+       alter vectors of reals like print @vin_sin[sin] to print the vector
+       of parameters defining the sinusoidal source (it works with both the 
+       sources type). It is possible to alter the parameters with the command
+       alter @vin_sin[sin] = ( 1 1 3000Hz ). A. Roldan -Espice
+       Note: alter syntax does not work in full yet, it still generate an
+       error but modifies the parameters. P. Nenzi  
+
+2009-01-15 Paolo Nenzi
+ * src/frontend/vectors.c:
+   57: Fixed  I(vx), before the if I(*) (upper case) was not recognized as the
+       function to plot the current of vx. A. Roldan - Espice
+ * src/frontend/postcoms.c:
+   7:  Fixed plot number after "destroy all" command. A. Roldan - Espice 
+ * src/include/fteext.h
+ * src/frontend/evaluate.c, src/frontend/cpitf.c, src/frontend/parse.c 
+ * src/maths/cmaths/cmath2.c, src/cmaths/cmath4.c, src/cmaths/cmath4.h:
+   16: New function to compute the group delay has been implemented.
+       Group delay is defined as -(dphase/dfrequency) and can be printed or
+       plotted by writing vg(x), where x is a complex vector. A. Roldan - Espice
+   15: Fixed existing problems in this function due to the complex nature of 
+       the frequency vector. To get the data from frequency[i], the real part
+       must be accessed. A. Roldan - Espice
+   14: New function to compute the moving average. A. Roldan - Espice
+
+2009-01-15 Paolo Nenzi
+ * src/frontend/{spiceif.c, spiceif.h, vectors.c}, src/include/fteext.h,
+ * src/main.c: 
+   3: A new function finddev_special() has been introduced to look for
+      references like @BC107[is] and to verify if we asked for a model
+      or a device and thus call the spif_getparam_special() correctly
+      in vectors.c. The new @ syntax is @{model,device}[parameter].
+      - A. Roldan - Espice.
+      Note: I have modified the implementation putting the
+      spif_getparam_special() in the if_getparam definition in main.c
+
+2009-01-15 Dietmar Warning
+ * src/include/wstdio.h: read fct. prototype for older MSC compiler
+ * src/misc/alloc.c: heap also needed under windows with tcl
+ * src/frontend/resource.c: resource info under Windows w/o psapi, still not yet perfect 
+
+2009-01-11 Dietmar Warning
+ * src/spicelib/devices/hisim/hsm1eval1xx.c, 
+   src/spicelib/devices/bsim3soi_x/b3soild.c: using ngspice.h as a central place
+
+2009-01-10 Holger Vogt
+ * windisp.c: improve plot window handling, still not yet perfect
+
+2009-01-09 Dietmar Warning
+ * src/misc/alloc.c, src/frontend/outitf.c: heap only needed under windows for zoom
+
+2009-01-05 Dietmar Warning
+ * src/math/misc/isinf.c, isnan.c, src/include/missing_math.h: small polish for 
+   HAVE_DECL_XXX macros, more elaborate isinf function
+ * src/include/memory.h: prototype for hrealloc fct.
+ * adms/hicum2/amsva/hicum2.va: update to actual version 2.22, very small 
+   modifications compared to the original va code.
+
+2009-01-04 Dietmar Warning
+ * src/math/misc/isinf.c, Makefile.am: a simple (but ugly) workaround for isinf 
+   needed by some adms generated models
+ * src/include/ngspice.h, missing_math.h: try to catch isinf by ieeefp.h
+ * adms/ekv/amsva/ekv.va: compatibility regarding S/D diode behaviour
+
+2009-01-02 Dietmar Warning
+ * adms/ekv/amsva/ekv.va: EPFL-EKV version 2.63, replacement of the long channel 
+   version with a code according to the official manual (revision II) available 
+   at http://legwww.epfl.ch/ekv, contribution of Ivan Riis Nielsen 11/2006.
+ * /src/frontend/wdisp/windisp.c, 398: windows zoom was broken - %le for double 
+   seems not more ignored, changed to more suitable %e
+
+2009-01-01 Dietmar Warning
+ * configure.in, include/missing_math.h, src/math/misc/isnan.c: POSIX conform 
+   configure isnan, isinf macros and finite function
+ * admst/ngspiceMODULEdefs.h.xml: some cc needs double cast for isinf macro
+
+2008-12-31 Holger Vogt
+  * resource.c: streamline resource info under Windows
+  * tclspice integration under Windows: dctran.c, inpfindl.c, outitf.c, alloc.c,
+    tclspice.c, winmain.c: type definitions, printf -> fprintf,
+    new heap for plot data to prevent memory fragmentation
+  * configure.in: new flags for TCL under Windows: HAS_TCLWIN 
+    (is set instead of HAS_WINDOWS), TCLWIN (for generating makefiles, 
+    instead of WINDOWS)
+  * cmath/makefile.am: prevent making test executables under TCL/Windows
+    
+2008-12-26 Dietmar Warning
+ * autogen.sh, configure.in: A hopeful way to integrate adms - ugly, but tested
+   under linux, sunOS and msys with and w/o adms enabled.
+ * src/spicelib/devices/adms/hicum0: updated verilog code with small adaption
+   to actual hicum0 version 1.2
+ * tests/adms/hicum0: using one library file for tests
+
+2008-12-23 Holger Vogt
+  * resource.c: for tclspice HAS_WINDOWS replaced by _MSC_VER and __MINGW32__
+  * outitf.c, cktdojob.c: printf replaced by fprintf
+  * cpitf.c:216 s replaced by copys
+  * tclspice.c:2168 init_rlimits( ) added to get startup system info
+  
+2008-12-22 Holger Vogt
+ * /spicelib/parser/inpdomod.c: checks for BSIM3 and BSIM4 look for
+   major versions 3.2, 3.3, 4.2 - 4.6   
+ 
+2008-12-22 Dietmar Warning
+ * adms/admst/ngspiceMakefile.am.xml: switch to libtool (unfortunately!)
+
+2008-12-20 Holger Vogt
+ * bug 2449483 removed: inpdomod.c:293 added as in b3v32check.c:42
+
+2008-12-14 Dietmar Warning
+ * src/Makefile.am: "hard wired" makefile dependency generation compiler options 
+   removed for main.c - this should be done by libtool, left it for tclspice and 
+   xspice codemodels (see below)
+ * src/xspice/icm: removed Makefile.am - not used, configuration relays
+   on makedefs.in and fixed Makefile, these files have now sun compiler 
+   specific options DEPFLAGS added
+ * src/xspice/ipc/ipc*.c: prevent some warnings under sun compiler
+ 
+2008-12-07 Dietmar Warning
+ * src/main.c: double semikolon in nutmeginfo decl. gives:
+               "syntax error:  empty declaration" under solaris ss12 
+
+2008-12-06 Holger Vogt
+ * frontend/spec.c, com_fft.c: free_pnode(first_name); moved further down to allow
+   'fft vout' instead of only 'fft v(vout)'
+
+2008-11-30 Lionel Sainte Cluque
  * configure.in: --with-tcl search path make broader to limit the need of the
         optional argument. Message in case of tclConfig.sh file not found
 	fixed by sed.
--- ng-spice-rework/autogen.sh:1.12	Sat Dec 15 13:41:48 2007
+++ ng-spice-rework/autogen.sh	Sun Dec 28 17:29:30 2008
@@ -5,7 +5,7 @@
 # package.
 #
 #
-# $Id: autogen.sh,v 1.12 2007/12/15 13:41:48 sjborley Exp $
+# $Id: autogen.sh,v 1.13 2008/12/28 17:29:30 dwarning Exp $
 #
 
 PROJECT=ngspice
@@ -23,7 +23,6 @@
 DIE=0
 
 
-
 help()
 {
  echo
@@ -115,48 +114,51 @@
 }
 
 
+cp -p configure.in configure.tmp
 
 if test "$ADMS" -eq 1; then
 
-# Build admsXml arguments list
-#    for xml in `ls $XMLPATH | grep .xml`; do
-#       if [ "$xml" != "ngspiceVersion.xml" ]; then
-#	    XMLARG="$XMLARG -e ../admst/$xml"
-#	    fi
-#    done 
-
-# Prepend ngspiceVersion.xml    
-#    XMLARG="-e ../admst/ngspiceVersion.xml $XMLARG"
-
-currentdir=`pwd`
-
-for adms_dir in `ls $ADMSDIR`
-do
-  if [ -d "$ADMSDIR/$adms_dir" ]; then
-   
-   case "$adms_dir" in
-      "CVS")
-      echo "Skipping CVS"
-      ;;
-      
-      "admst")
-      echo "Skipping scripts dir"
-      
-      ;;
-      
-      *)
-      echo "Entering into directory: $adms_dir"
-      echo "-->"$ADMSDIR/$adms_dir
-      cd $ADMSDIR/$adms_dir
-      file=`ls admsva/*.va`
-      $ADMSXML $file -Iadmsva -e ../admst/ngspiceVersion.xml \
-      -e ../admst/ngspiceMakefile.am.xml
-      
-      cd $currentdir
-      ;;
-   esac
-  fi 
-done
+  # automake needs these entries in configure.in for adms enabled
+  sed 's/${VLAMKF}/src\/spicelib\/devices\/adms\/ekv\/Makefile\
+                   src\/spicelib\/devices\/adms\/hicum0\/Makefile\
+                   src\/spicelib\/devices\/adms\/hicum2\/Makefile\
+                   src\/spicelib\/devices\/adms\/mextram\/Makefile\
+                   src\/spicelib\/devices\/adms\/psp102\/Makefile/g' configure.tmp >configure.in
+  
+  currentdir=`pwd`
+  
+  for adms_dir in `ls $ADMSDIR`
+  do
+    if [ -d "$ADMSDIR/$adms_dir" ]; then
+     
+     case "$adms_dir" in
+        "CVS")
+        echo "Skipping CVS"
+        ;;
+        
+        "admst")
+        echo "Skipping scripts dir"
+        
+        ;;
+        
+        *)
+        echo "Entering into directory: $adms_dir"
+        echo "-->"$ADMSDIR/$adms_dir
+        cd $ADMSDIR/$adms_dir
+        file=`ls admsva/*.va`
+        $ADMSXML $file -Iadmsva -e ../admst/ngspiceVersion.xml \
+        -e ../admst/ngspiceMakefile.am.xml
+        
+        cd $currentdir
+        ;;
+     esac
+    fi 
+  done
+
+else
+
+  sed '/${VLAMKF}/d' configure.tmp >configure.in
+
 fi
 
 echo "Running libtoolize"
@@ -183,4 +185,6 @@
 autoconf
 if [ $? -ne 0 ]; then  echo "autoconf failed"; exit 1 ; fi
 
+mv configure.tmp configure.in
+
 echo "Success."
--- ng-spice-rework/configure.in:1.127	Sun Nov 30 12:47:07 2008
+++ ng-spice-rework/configure.in	Thu Jan  1 20:44:49 2009
@@ -23,7 +23,7 @@
 AC_PREREQ(2.59)
 
 dnl Revison stamp the generated ./configure script
-AC_REVISION($Revision: 1.127 $)
+AC_REVISION($Revision: 1.130 $)
 
 dnl Create a configuration header
 AC_CONFIG_HEADER([config.h])
@@ -274,9 +274,18 @@
 dnl The tclSpice options
 dnl
 AM_CONDITIONAL(TCL_MODULE, false)
+AM_CONDITIONAL(TCLWIN, false)
 if test "x$with_tcl" != "x" -a "$with_tcl" != "no" ; then
    AM_CONDITIONAL(TCL_MODULE, true)
    AC_DEFINE(TCL_MODULE,1,[Tcl Module])
+   case $host_os in
+     *mingw* )
+       AM_CONDITIONAL(TCLWIN, true)
+       AC_DEFINE(HAS_TCLWIN,1,[Tcl Windows]);;
+     *)
+     ;;  
+   esac   
+   
    with_x=no
    enable_shared=no
 
@@ -587,7 +596,17 @@
 AC_CHECK_HEADERS(float.h limits.h values.h ieeefp.h)
 
 dnl Check for a few mathematical functions:
-AC_CHECK_FUNCS(erfc logb scalb scalbn asinh acosh atanh isnan)
+AC_CHECK_FUNCS(erfc logb scalb scalbn asinh acosh atanh finite)
+dnl According POSIX we should look for macros first
+AC_CHECK_DECLS([isinf], [], [], [[#include <math.h>]])
+AC_CHECK_DECLS([isnan], [], [], [[#include <math.h>]])
+dnl But may be we have still functions
+if test "$ac_cv_have_decl_isinf" != yes; then
+  AC_CHECK_FUNC(isinf)
+fi
+if test "$ac_cv_have_decl_isnan" != yes; then
+  AC_CHECK_FUNC(isnan)
+fi
 
 dnl Check for the random function:
 AC_CHECK_FUNCS(random,,AC_CHECK_LIB(iberty,random,AC_DEFINE([HAVE_RANDOM],1,[Have random in libiberty]) LIBS="$LIBS -liberty"))
@@ -837,27 +856,37 @@
    fi
    AC_DEFINE(ADMS,[1],[Support for Verilog-A(MS) models])
 
-   VLADEVDIR=" adms/hicum0 \
+   VLADEVDIR=" adms/ekv \
+               adms/hicum0 \
                adms/hicum2 \
                adms/mextram \
-               adms/ekv \
                adms/psp102 "
    
+   VLAMKF=" src/spicelib/devices/adms/ekv/Makefile \
+            src/spicelib/devices/adms/hicum0/Makefile \
+            src/spicelib/devices/adms/hicum2/Makefile \
+            src/spicelib/devices/adms/mextram/Makefile \
+            src/spicelib/devices/adms/psp102/Makefile "
+
    NOTVLADEVDIR=""
 
-   VLADEV=" spicelib/devices/adms/hicum0/libhicum0.la \
+   VLADEV=" spicelib/devices/adms/ekv/libekv.la \
+            spicelib/devices/adms/hicum0/libhicum0.la \
             spicelib/devices/adms/hicum2/libhicum2.la \
             spicelib/devices/adms/mextram/libmextram.la \
-            spicelib/devices/adms/ekv/libekv.la \
             spicelib/devices/adms/psp102/libpsp102.la "
 
 else
 
+    VLAMKF=""
     VLADEVDIR=""
     NOTVLADEVDIR="adms"
+
 fi
+
 AC_SUBST(ADMSXML)
 AC_SUBST(VLADEVDIR)
+AC_SUBST(VLAMKF)
 AC_SUBST(VLADEV)
 AC_SUBST(NOTVLADEVDIR)
 
@@ -951,6 +980,7 @@
                  src/spicelib/Makefile
                  src/spicelib/analysis/Makefile
                  src/spicelib/devices/Makefile
+                 ${VLAMKF}
                  src/spicelib/devices/asrc/Makefile
                  src/spicelib/devices/bjt/Makefile
                  src/spicelib/devices/bjt2/Makefile
--- ng-spice-rework/man/man1/ngnutmeg.1:1.1	Sun Jan 21 17:24:23 2001
+++ ng-spice-rework/man/man1/ngnutmeg.1	Mon Jan 26 07:28:42 2009
@@ -1,4 +1,4 @@
-.\" RCS Info: $Revision: 1.1 $ on $Date: 2001/01/21 17:24:23 $
+.\" RCS Info: $Revision: 1.2 $ on $Date: 2009/01/26 07:28:42 $
 .\"           $Source: /cvsroot/ngspice/ngspice/ng-spice-rework/man/man1/ngnutmeg.1,v $
 .\" Copyright (c) 1985 Wayne A. Christopher, U. C. Berkeley CAD Group
 .TH NUTMEG 1 "27 April 1987"
@@ -6,12 +6,12 @@
 .SH NAME
 nutmeg \- spice post-processor
 .SH SYNOPSIS
-\fBnutmeg [ - ] [ -n ] [ -t term ] [ datafile ... ]\fR
+\fBnutmeg [ \- ] [ \-n ] [ \-t term ] [ datafile ... ]\fR
 .SH DESCRIPTION
 .B Nutmeg
 is a post processor for \s-2SPICE\s+2 \- it takes the raw 
 output file created 
-by \fBspice -r\fR
+by \fBspice \-r\fR
 and plots the data on a graphics terminal or a workstation display.
 Note that the raw output file is different from the
 data that \s-2SPICE\s+2 writes to the standard output.
@@ -92,7 +92,7 @@
 The phase of vector.
 .IP
 \fBj(vector) \-\fR
-\fIi\fR (sqrt(-1)) times vector.
+\fIi\fR (sqrt(\-1)) times vector.
 .IP
 \fBreal(vector) \-\fR
 The real component of vector.
@@ -439,12 +439,12 @@
 \fBcpdebug\fR
 .br
 Print \fIcshpar\fR debugging information. (Must be complied with the
--DCPDEBUG flag.)
+\-DCPDEBUG flag.)
 .IP
 \fBdebug\fR 
 .br
 If set then a lot of debugging information is printed. (Must be
-compiled with the -DFTEDEBUG flag.)
+compiled with the \-DFTEDEBUG flag.)
 .IP
 \fBdevice\fR
 .br
@@ -508,7 +508,7 @@
 .br
 If this is set, when the \fBhardcopy\fR command is run the resulting file
 is automatically printed on the printer named \fBhcopydev\fR with the
-command \fIlpr -P\fBhcopydev\fI -g \fBfile\fR.
+command \fIlpr \-P\fBhcopydev\fI \-g \fBfile\fR.
 .IP
 \fBhcopydevtype\fR 
 .br
@@ -925,7 +925,7 @@
 	pi		pi
 	e		The base of natural logarithms
 	c		The speed of light
-	i		The square root of -1
+	i		The square root of \-1
 	kelvin		Absolute 0 in Centigrade
 	echarge		The charge on an electron
 	boltz		Boltzman's constant
--- ng-spice-rework/man/man1/ngspice.1:1.1	Sun Jan 21 17:24:23 2001
+++ ng-spice-rework/man/man1/ngspice.1	Mon Jan 26 07:28:42 2009
@@ -1,4 +1,4 @@
-.\" RCS Info: $Revision: 1.1 $ on $Date: 2001/01/21 17:24:23 $
+.\" RCS Info: $Revision: 1.2 $ on $Date: 2009/01/26 07:28:42 $
 .\"           $Source: /cvsroot/ngspice/ngspice/ng-spice-rework/man/man1/ngspice.1,v $
 .\" Copyright (c) 1985 Wayne A. Christopher, U. C. Berkeley CAD Group
 .TH SPICE 1 "20 March 1986"
@@ -7,8 +7,8 @@
 .SH NAME
 spice \- circuit simulator
 .SH SYNOPSIS
-\fBspice [ -n ] [ -t term ] [ -r rawfile] [ -b ]
-[ -i ] [ input file ... ]\fR
+\fBspice [ \-n ] [ \-t term ] [ \-r rawfile] [ \-b ]
+[ \-i ] [ input file ... ]\fR
 .SH DESCRIPTION
 This manual page describes the commands available for interactive
 use of \*S. For details of circuit descriptions and the
@@ -35,7 +35,7 @@
 Run in batch mode. \*S will read the standard input or the specified
 input file and do the simulation. Note that if the standard input
 is not a terminal, \*S will default to batch mode, unless the
--i flag is given.
+\-i flag is given.
 .TP
 \fB-s\fR (or \fB--server\fR)
 Run in server mode. This is like batch mode, except that a temporary
--- ng-spice-rework/src/Makefile.am:1.62	Wed Nov 26 09:40:16 2008
+++ ng-spice-rework/src/Makefile.am	Sun Dec 14 17:58:35 2008
@@ -1,5 +1,5 @@
 ## Process this file with automake to produce Makefile.in
-# $Id: Makefile.am,v 1.62 2008/11/26 09:40:16 pnenzi Exp $
+# $Id: Makefile.am,v 1.63 2008/12/14 17:58:35 dwarning Exp $
 
 SUBDIRS = misc maths frontend spicelib include @XSPICEDIR@ @CIDERDIR@
 DIST_SUBDIRS = misc maths frontend spicelib include xspice ciderlib
@@ -125,11 +125,10 @@
 endif
 
 winmain.o: winmain.c
-		$(COMPILE) -DSIMULATOR -o winmain.o  -c $(srcdir)/winmain.c
+	$(COMPILE) -DSIMULATOR -o winmain.o  -c $(srcdir)/winmain.c
 
 spice.lo: main.c
-	$(LTCOMPILE) -DSIMULATOR -MT spice.lo -MD -MP -MF $(DEPDIR)/spice.Tpo -c -o spice.o $<
-	mv -f $(DEPDIR)/spice.Tpo $(DEPDIR)/spice.Plo
+	$(LTCOMPILE) -DSIMULATOR -c -o spice.o $<
 
 
 ## nutmeg:
--- ng-spice-rework/src/main.c:1.46	Wed Nov 26 20:33:20 2008
+++ ng-spice-rework/src/main.c	Thu Jan 15 16:46:31 2009
@@ -5,7 +5,7 @@
    Author: 1985 Wayne A. Christopher
 
    The main routine for ngspice
-   $Id: main.c,v 1.46 2008/11/26 20:33:20 h_vogt Exp $
+   $Id: main.c,v 1.48 2009/01/15 16:46:31 pnenzi Exp $
 */
 
 #include "ngspice.h"
@@ -196,13 +196,10 @@
 extern struct comm spcp_coms[ ];
 struct comm *cp_coms = spcp_coms;
 
-
 extern int OUTpBeginPlot(), OUTpData(), OUTwBeginPlot(), OUTwReference();
 extern int OUTwData(), OUTwEnd(), OUTendPlot(), OUTbeginDomain();
 extern int OUTendDomain(), OUTstopnow(), OUTerror(), OUTattributes();
    
-
-
 IFfrontEnd nutmeginfo = {
 	IFnewUid,
 	IFdelUid,
@@ -219,7 +216,7 @@
 	OUTbeginDomain,
 	OUTendDomain,
 	OUTattributes
-    };;
+    };
 
 #else /* SIMULATOR */
 
@@ -545,7 +542,7 @@
     printf("Usage: %s [OPTION]... [FILE]...\n"
 	   "Simulate the electical circuits in FILE.\n"
 	   "\n"
-           "  -a  --autorun             run the loaded netlist\n"
+       "  -a  --autorun             run the loaded netlist\n"
 	   "  -b, --batch               process FILE in batch mode\n"
 	   "  -c, --circuitfile=FILE    set the circuitfile\n"
 	   "  -i, --interactive         run in interactive mode\n"
@@ -752,7 +749,7 @@
 	    {"help", 0, 0, 'h'},
 	    {"version", 0, 0, 'v'},
 	    {"batch", 0, 0, 'b'},
-            {"autorun", 0, 0, 'a'},
+        {"autorun", 0, 0, 'a'},
 	    {"circuitfile", 0, 0, 'c'},
 	    {"interactive", 0, 0, 'i'},
 	    {"no-spiceinit", 0, 0, 'n'},
@@ -876,7 +873,7 @@
 #endif
     } /* orflag */
 #ifdef SIMULATOR
-    if_getparam = spif_getparam;
+    if_getparam = spif_getparam_special;
 #else
     if_getparam = nutif_getparam;
 
--- ng-spice-rework/src/tclspice.c:1.10	Sun Nov 30 12:47:07 2008
+++ ng-spice-rework/src/tclspice.c	Wed Dec 31 14:42:49 2008
@@ -6,7 +6,7 @@
  *
  * Under LGPLv2 licence since 2008, December 1st
  *
- * $Id: tclspice.c,v 1.10 2008/11/30 12:47:07 saintel Exp $	
+ * $Id: tclspice.c,v 1.12 2008/12/31 14:42:49 h_vogt Exp $	
  */
 
 /*******************/
@@ -17,7 +17,7 @@
 #define TCLSPICE_prefix  "spice::"
 #define TCLSPICE_namespace "spice"
 #ifdef _MSC_VER
-#define TCLSPICE_version "18.0"
+#define TCLSPICE_version "18.1"
 #define	STDIN_FILENO	0
 #define	STDOUT_FILENO	1
 #define	STDERR_FILENO	2
@@ -177,6 +177,13 @@
     spice_interp = interp;\
 } while(0)
 
+
+/* global handle for the output heap */
+#if defined(_MSC_VER) || defined(__MINGW32__)
+HANDLE outheap;
+#endif
+
+
 /****************************************************************************/
 /*                          BLT and data routines                           */
 /****************************************************************************/
@@ -601,26 +608,33 @@
 static bool fl_running = FALSE;
 static bool fl_exited = TRUE;
 
-
-static void *_thread_run(void *string){
+#if defined(__MINGW32__) || defined(_MSC_VER)
+static void * WINAPI _thread_run(void *string){
+#else
+static void * _thread_run(void *string){
+#endif
   fl_exited = FALSE;
   bgtid = thread_self();
   cp_evloop((char *)string);
   FREE(string);
   bgtid = (threadId_t)0;
   fl_exited = TRUE;
-  return 0;
+  return;
 }
 
 /*Stops a running thread, hopefully */
+#if defined(__MINGW32__) || defined(_MSC_VER)
+static int WINAPI _thread_stop(){
+#else
 static int _thread_stop(){
+#endif
   int timeout = 0;
   if(fl_running) {
     while(!fl_exited && timeout < 100){
       ft_intrpt = TRUE;
       timeout++;
 #if defined(__MINGW32__) || defined(_MSC_VER)
-      Sleep(10); /* va: windows native */
+      Sleep(100); /* va: windows native */
 #else
       usleep(10000);
 #endif
@@ -663,12 +677,17 @@
   }
 #endif
 
+
   /* Catch Ctrl-C to break simulations */
+#ifndef _MSC_VER_
   oldHandler = signal(SIGINT,ft_sigintr);
   if(SETJMP(jbuf, 1)!=0) {
       signal(SIGINT,oldHandler);
       return TCL_OK;
   }
+#else
+  oldHandler = SIG_IGN;
+#endif
 
   /*build a char * to pass to cp_evloop */
   for(i=0;i<argc;i++) {
@@ -1665,6 +1684,7 @@
 #endif	
 }
 
+
 int Tcl_ExecutePerLoop() {
 
   struct watch *current;
@@ -2135,6 +2155,16 @@
 
   save_interp();
 
+
+#if defined(_MSC_VER) || defined(__MINGW32__)
+  /* create private heap for current process*/
+  outheap = HeapCreate(0, 10000000, 0);
+  if (!outheap) {
+    fprintf(stderr,"HeapCreate: Internal Error: can't allocate private output heap");
+    exit(EXIT_BAD);
+  }
+#endif
+
   {
     extern void DevInit();
     int i;
@@ -2164,6 +2194,9 @@
     /*parameter fetcher, used in show*/
     if_getparam = spif_getparam;
     
+    /* Get startup system limits */
+    init_rlimits( );
+
     /*Command prompt stuff */
     ft_cpinit();
     
--- ng-spice-rework/src/winmain.c:1.7	Sun Apr 13 14:30:28 2008
+++ ng-spice-rework/src/winmain.c	Wed Dec 31 14:42:49 2008
@@ -3,7 +3,7 @@
 	Stand: 28.10.97
 	Autor: Holger Vogt
 	Stand: 01.03.2008
- $Id: winmain.c,v 1.7 2008/04/13 14:30:28 h_vogt Exp $
+ $Id: winmain.c,v 1.8 2008/12/31 14:42:49 h_vogt Exp $
 */
 #include "config.h"
 #ifdef HAS_WINDOWS
@@ -97,6 +97,9 @@
 char* rlead(char*);
 void winmessage(char*);
 
+/* private heap for storing plot data */
+HANDLE outheap;
+
 // --------------------------<History-Verwaltung>------------------------------
 
 // Alle Puffer loeschen und Zeiger auf den Anfang setzen
@@ -844,10 +847,16 @@
 	UpdateWindow( hwMain);
 	SetFocus( swString);
 
-        status = MakeArgcArgv(lpszCmdLine,&argc,&argv);
+   status = MakeArgcArgv(lpszCmdLine,&argc,&argv);
 
+  /* create private heap for current process */
+  outheap = HeapCreate(0, 10000000, 0);
+  if (!outheap) {
+    fprintf(stderr,"HeapCreate: Internal Error: can't allocate private output heap");
+    exit(1);
+  }
 
-	// Warten, bis alles klar ist
+	// Wait util everything is settled
 	WaitForIdle();
 
 	// Ab nach main()
@@ -855,8 +864,6 @@
 	
 
 THE_END:
-	// 3D abschalten
-//	Ctl3dUnregister( hInstance);
 
 	// terminate
 	return nReturnCode;
--- ng-spice-rework/src/frontend/com_fft.c:1.3	Sun Nov 23 09:37:13 2008
+++ ng-spice-rework/src/frontend/com_fft.c	Sat Dec  6 15:09:11 2008
@@ -166,7 +166,7 @@
             ngood++;
         }
     }
-    free_pnode(first_name);
+    free_pnode_o(first_name); /* h_vogt 081206 */
     if (!ngood) {
        return;
     }
@@ -240,7 +240,6 @@
     
     tfree(tdvec);
     tfree(fdvec);    
-    
 }
 
 
--- ng-spice-rework/src/frontend/com_fft.h:1.1	Sat May 24 18:06:39 2008
+++ ng-spice-rework/src/frontend/com_fft.h	Sat Dec  6 15:09:12 2008
@@ -6,6 +6,8 @@
 #ifndef FFT_H_INCLUDED
 #define FFT_H_INCLUDED
 
+extern void free_pnode_o(struct pnode *t);
+
 void com_fft(wordlist *wl);
 
 static void fftext(float*, float*, long int, int);
--- ng-spice-rework/src/frontend/commands.c:1.9	Wed Aug 27 13:39:25 2008
+++ ng-spice-rework/src/frontend/commands.c	Fri Jan 16 15:35:00 2009
@@ -1,5 +1,5 @@
 /* NG-SPICE -- An electrical circuit simulator
- * $Id: commands.c,v 1.9 2008/08/27 13:39:25 pnenzi Exp $
+ * $Id: commands.c,v 1.10 2009/01/16 15:35:00 pnenzi Exp $
  *
  * Copyright (c) 1990 University of California
  * Copyright (c) 2000 Arno W. Peters
@@ -375,8 +375,13 @@
       { 010, 010, 010, 010 }, E_DEFHMASK, 0, LOTS,
       (void (*)()) NULL,
       "[command name] ... : Print help." } ,
+      /* to remove circuits loaded */
+    { "removecirc", com_removecirc, FALSE, TRUE, FALSE,
+      { 04, 0, 0, 0 }, E_DEFHMASK, 0, 1,
+      (void (*)()) NULL,
+      "[circuit name] : Remove the current circuit from memory." } ,
     { "quit", com_quit, FALSE, FALSE, TRUE,
-      { 0, 0, 0, 0 }, E_BEGINNING, 0, 0,
+      { 0, 0, 0, 0 }, E_BEGINNING, 0, 1,
       (void (*)()) NULL,
       ": Quit %s." } ,
     { "source", com_source, FALSE, FALSE, TRUE,
@@ -544,7 +549,7 @@
       { 0400, 0, 0, 0 }, E_DEFHMASK, 0, 1,
       (void (*)()) NULL,
       "[plotname] : Change the current working plot." } ,
-    { "setcirc", NULL, FALSE, TRUE, FALSE,
+    { "setcirc", com_scirc, FALSE, TRUE, FALSE,
       { 04, 0, 0, 0 }, E_DEFHMASK, 0, 1,
       (void (*)()) NULL,
       "[circuit name] : Change the current circuit." } ,
@@ -725,9 +730,14 @@
       (void (*)()) NULL,
       "[command name] ... : Print help." } ,
     { "quit", com_quit, FALSE, FALSE, TRUE,
-      { 0, 0, 0, 0 }, E_BEGINNING, 0, 0,
+      { 0, 0, 0, 0 }, E_BEGINNING, 0, 1,
       (void (*)()) NULL,
       ": Quit %s." } ,
+      /* to remove circuits loaded */
+    { "removecirc", com_removecirc, FALSE, TRUE, FALSE,
+      { 04, 0, 0, 0 }, E_DEFHMASK, 0, 1,
+      (void (*)()) NULL,
+      "[circuit name] : Remove the current circuit from memory." } ,
     { "source", nutcom_source, FALSE, FALSE, TRUE,
       { 1, 1, 1, 1 }, E_DEFHMASK, 1, LOTS,
       (void (*)()) NULL,
--- ng-spice-rework/src/frontend/cpitf.c:1.11	Sun Nov 23 20:47:23 2008
+++ ng-spice-rework/src/frontend/cpitf.c	Thu Jan 15 21:08:09 2009
@@ -55,7 +55,9 @@
         "vi(x,y)",  "im(v(x) - v(y))",
         "vm(x)",    "mag(v(x))",
         "vm(x,y)",  "mag(v(x) - v(y))",
-        "vp(x)",    "ph(v(x))",
+        "vg(x)",    "group_delay(v(x))", //A.Rroldan 10/06/05 group delay new function
+        "gd(x)",    "group_delay(v(x))", //A.Rroldan 10/06/05 group delay new function        
+	    "vp(x)",    "ph(v(x))",
         "vp(x,y)",  "ph(v(x) - v(y))",
         "vr(x)",    "re(v(x))",
         "vr(x,y)",  "re(v(x) - v(y))"
@@ -212,7 +214,8 @@
 
 	/* Now source the standard startup file. */
 	/* XXX strange */
-	for (copys=s=cp_tildexpand(Lib_Path); s && *s; ) {/*DG*/
+
+	for (copys=s=cp_tildexpand(Lib_Path); copys && *copys; ) {/*DG*/
 	    while (isspace(*s))
 		s++;
 	    for (r = buf; *s && !isspace(*s); r++, s++)
--- ng-spice-rework/src/frontend/device.c:1.13	Tue Oct  9 21:27:26 2007
+++ ng-spice-rework/src/frontend/device.c	Thu Jan 15 22:16:32 2009
@@ -931,8 +931,53 @@
     words = eqword->wl_next;
     names = ft_getpnames(words, FALSE);
     if (!names) {
-	fprintf(cp_err, "Error: cannot parse new parameter value.\n");
-	return;
+     /* Put this to try to resolve the case of 
+      * alter vin_sin@[sin] = (10 12 3000)
+      */
+     char *xsbuf;
+     int type = IF_REALVEC,i=0;
+
+
+      double *list;
+      double tmp;
+      int error;
+
+      xsbuf = wl_flatten(words);
+      /* fprintf(cp_err, "Chain    converted  %s \n",xsbuf); */
+      dv=(struct dvec *)MALLOC(sizeof(struct dvec));
+      dv->v_name = (char *)MALLOC(sizeof("real vector"));
+      dv->v_name = "real vector";
+       type &= IF_VARTYPES;
+       if (type == IF_REALVEC)
+       {
+        list = (double *)MALLOC(sizeof(double));
+        tmp = INPevaluate(&xsbuf,&error,1);
+        while (error == 0)
+        {
+            /*printf(" returning vector value %g\n",tmp); */
+            i++;
+            list=(double *)REALLOC((char *)list,i*sizeof(double));
+            *(list+i-1) = tmp;
+            tmp = INPevaluate(&xsbuf,&error,1);
+        }
+        dv->v_realdata=list;
+       }
+       dv->v_length=i;
+
+       if (!dv)
+          return;
+       if (dv->v_length < 1)
+       {
+        fprintf(cp_err, "Error: cannot evaluate new parameter value.\n");
+        return;
+       }
+
+       /*  	Here I was, to change the inclusion in the circuit.
+        * will have to revise that dv is right for its insertion.
+        */
+       if_setparam(ft_curckt->ci_ckt, &dev, param, dv, do_model);
+
+    return;
     }
     dv = ft_evaluate(names);
     if (!dv)
--- ng-spice-rework/src/frontend/evaluate.c:1.11	Sat Oct  4 22:44:52 2008
+++ ng-spice-rework/src/frontend/evaluate.c	Fri Jan 16 14:31:07 2009
@@ -16,6 +16,7 @@
 
 #include "evaluate.h"
 
+#include "sim.h"  /* To get SV_VOLTAGE definition */
 
 /* static declarations */
 static RETSIGTYPE sig_matherr(void);
@@ -277,8 +278,89 @@
 	    res->v_dims[i] = v2->v_dims[i];
     }
 
-    /* This depends somewhat on what the operation is.  XXX Should fix */
-    res->v_type = v1->v_type;
+    /* This depends somewhat on what the operation is.  XXX Should fix 
+     * res->v_type = v1->v_type;
+     * Introduced to show the real units coming out from an
+     * operation. A.Roldán
+     */
+    switch (what)
+    {
+	  case '*':  /* Multiplication of two vectors */
+               switch(v1->v_type)
+               {
+                case SV_VOLTAGE:
+                      switch(v2->v_type)
+                      {
+                        case SV_VOLTAGE:
+                               res->v_type = SV_VOLTAGE;
+                               break;
+                        case SV_CURRENT:
+                               res->v_type = SV_POWER;
+                               break;
+                        default:
+                             break;
+                      }
+
+                 break;
+                case SV_CURRENT:
+
+                      switch(v2->v_type)
+                      {
+                        case SV_VOLTAGE:
+                               res->v_type = SV_POWER;
+                               break;
+                        case SV_CURRENT:
+                               res->v_type = SV_CURRENT;
+                               break;
+                        default:
+                             break;
+                      }
+                      break;
+
+                default:
+
+                 break;
+               }
+               break;
+	  case '/':   //Multiplicación de 2 vectores
+               switch(v1->v_type)
+               {
+                case SV_VOLTAGE:
+                     switch(v2->v_type)
+                      {
+                        case SV_VOLTAGE:
+                               res->v_type = SV_NOTYPE;
+                               break;
+                        case SV_CURRENT:
+                               res->v_type = SV_IMPEDANCE;
+                               break;
+                        default:
+                             break;
+                      }
+                      break;
+                case SV_CURRENT:
+
+                      switch(v2->v_type)
+                      {
+                        case SV_VOLTAGE:
+                               res->v_type = SV_ADMITANCE;
+                               break;
+                        case SV_CURRENT:
+                               res->v_type = SV_NOTYPE;
+                               break;
+                        default:
+                             break;
+                      }
+                      break;
+
+                default:
+
+                 break;
+               }
+
+      default:
+          break;
+    }
     vec_new(res);
 
     /* Free the temporary data areas we used, if we allocated any. */
@@ -707,8 +789,8 @@
         }
         (void) signal(SIGILL, (SIGNAL_FUNCTION) sig_matherr);
 
-        if (eq(func->fu_name, "interpolate")
-            || eq(func->fu_name, "deriv"))       /* Ack */
+        /* Modified for passing necessary parameters to the derive function - A.Roldan */
+	if (eq(func->fu_name, "interpolate") || eq(func->fu_name, "deriv") || eq(func->fu_name, "group_delay"))       /* Ack */
 	{
 	    void *(*f)(void *data, short int type, int length,
                        int *newlength, short int *newtype, ...)=func->fu_func;
--- ng-spice-rework/src/frontend/hpgl.c:1.5	Mon May 30 20:28:30 2005
+++ ng-spice-rework/src/frontend/hpgl.c	Sat Jan 31 14:32:12 2009
@@ -75,7 +75,7 @@
                 };
 
 static FILE *plotfile;
-char psfont[128], psfontsize[32], psscale[32];
+extern char psscale[32];
 static int fontwidth  = FONTWIDTH;
 static int fontheight = FONTHEIGHT;
 static int   jgmult      = 10;
--- ng-spice-rework/src/frontend/misccoms.c:1.11	Sat Nov 22 10:31:47 2008
+++ ng-spice-rework/src/frontend/misccoms.c	Fri Jan 16 15:35:00 2009
@@ -38,7 +38,14 @@
     (void) cp_getvar("noaskquit", VT_BOOL, (char *) &noask);
     gr_clean();
     cp_ccon(FALSE);
-    
+    if(wl)
+      if(wl->wl_word)
+    if(cieq(wl->wl_word,"noask"))
+         {
+           byemesg();
+           exit(EXIT_NORMAL);
+     }
+
     /* Make sure the guy really wants to quit. */
     if (!ft_nutmeg && !noask) {
         for (cc = ft_circuits; cc; cc = cc->ci_next)
--- ng-spice-rework/src/frontend/mw_coms.c:1.4	Mon May 30 20:28:30 2005
+++ ng-spice-rework/src/frontend/mw_coms.c	Sun Jan 18 16:46:34 2009
@@ -1,5 +1,5 @@
 /* Michael Widlok 		2 Jun 1999 */
-/* $Id: mw_coms.c,v 1.4 2005/05/30 20:28:30 sjborley Exp $ */
+/* $Id: mw_coms.c,v 1.7 2009/01/18 16:46:34 pnenzi Exp $ */
 /* New commands for unloading circuits */
 
 #include "ngspice.h"
@@ -17,11 +17,22 @@
 /* Clears ckt and removes current circ. form database */
  
 void
-com_removecirc(wordlist *wl)
+com_removecirc()
 {
     struct variable *v, *next;
     struct circ *ct;
-    
+    struct circ *caux=NULL;
+    struct plot *p;
+    struct plot *paux;
+    struct wordlist *wlist;
+    int auxCir=1,i,auxPlot;
+
+    char* namecircuit;
+    char buf[80];
+
+    /* Allocation of a temp wordlist */
+    wlist = (struct wordlist *)malloc(sizeof(struct wordlist));
+
     if (ft_curckt == NULL) {
         fprintf(cp_err, "Error: there is no circuit loaded.\n");
         return;
@@ -36,8 +47,88 @@
     }
     
     ct->ci_vars = NULL;
+    caux=ft_circuits;
+    namecircuit = strdup(ft_curckt->ci_name);
+    /* The circuit  being removed is the first loaded and you have more circuits */
+    if(ft_curckt==ft_circuits&&ft_circuits->ci_next!=NULL)
+    	ft_circuits=ft_circuits->ci_next;
 
 
+    /* The circuit being removed id the first loaded and there are no more circuits */
+    else if(ft_circuits->ci_next==NULL)
+	   ft_circuits=NULL;
+    
+    else {
+	
+	   
+       /* Run over the circuit list to find how many of them are 
+        * in front of the one to be removed 
+        */
+	   for (; ft_curckt != caux&&caux; caux = caux->ci_next)
+		  auxCir++;
+	
+	   caux=ft_circuits;
+	   /* Remove the circuit and move pointer to the next one */
+	   for(i=1;i<auxCir-1;i++)
+	       caux=caux->ci_next;
+	   caux->ci_next=caux->ci_next->ci_next;
+	   /* ft_curckt=ft_circuits; */
+        
+    }
+    
+    /* If the plot is the first one and there are no other plots */
+    if(plot_list->pl_next==NULL&&strcmp(plot_list->pl_title,namecircuit)==0)
+        plot_list=NULL;
+    
+        
+    else if(plot_list&&plot_list->pl_next!=NULL){
+	p = plot_list;
+	while(p){
+        auxPlot=1;
+        /* If the plot is in the first position */
+        if(plot_list->pl_next&&strcmp(plot_list->pl_title,namecircuit)==0)
+	       plot_list=plot_list->pl_next;
+	    /* otherwise we run over the list of plots */
+        else {
+            for (; strcmp(p->pl_title,namecircuit)!=0&&p->pl_next!=NULL; p = p->pl_next)
+		        auxPlot++;
+                if(strcmp(p->pl_title,namecircuit)==0){
+                    paux = plot_list;
+	            for(i=1;i<auxPlot-1;i++)
+		            paux=paux->pl_next;
+	            paux->pl_next=paux->pl_next->pl_next;		
+        }
+      }
+    p=p->pl_next;
+    }
+    }
+    
+    /*if (ft_curckt) {
+       
+        ft_curckt->ci_devices = cp_kwswitch(CT_DEVNAMES, ft_circuits->ci_devices);
+        ft_curckt->ci_nodes = cp_kwswitch(CT_NODENAMES, ft_circuits->ci_nodes);
+    }*/
+if(ft_circuits&&caux->ci_next){
+	sprintf(buf,"%d",auxCir);
+    wlist->wl_next = NULL;
+    wlist->wl_prev = NULL;
+    wlist->wl_word = buf;
+    
+	com_scirc(wlist);
+	free(wlist);
+}
+else if(ft_circuits){
+    sprintf(buf,"%d",(auxCir-1));
+    wlist->wl_next = NULL;
+    wlist->wl_prev = NULL;
+    wlist->wl_word = buf;
+    
+	com_scirc(wlist);
+	free(wlist);
+    
+}
+else
+	ft_curckt=NULL;
     return;
 }
 
--- ng-spice-rework/src/frontend/mw_coms.h:1.1.1.1	Thu Apr 27 20:04:00 2000
+++ ng-spice-rework/src/frontend/mw_coms.h	Sun Jan 18 16:46:34 2009
@@ -6,7 +6,7 @@
 #ifndef MW_COMS_H_INCLUDED
 #define MW_COMS_H_INCLUDED
 
-void com_removecirc(wordlist *wl);
+void com_removecirc(void);
 
 
 #endif
--- ng-spice-rework/src/frontend/outitf.c:1.23	Wed Aug 27 13:39:26 2008
+++ ng-spice-rework/src/frontend/outitf.c	Sun Jan 18 12:09:57 2009
@@ -2,7 +2,7 @@
 Copyright 1990 Regents of the University of California.  All rights reserved.
 Author: 1988 Wayne A. Christopher, U. C. Berkeley CAD Group 
 Modified: 2000 AlansFixes
-$Id: outitf.c,v 1.23 2008/08/27 13:39:26 pnenzi Exp $
+$Id: outitf.c,v 1.27 2009/01/18 12:09:57 h_vogt Exp $
 **********/
 
 /*
@@ -64,6 +64,15 @@
 #endif
 /*saj*/
 
+/* plot output data shall go into extra heap 
+   to prevent massive memory fragmentation of standard process heap.
+   This is especially required by TCL for Windows, but may help
+   also under standard Windows GUI. */
+#if (defined(HAS_WINDOWS) || defined(HAS_TCLWIN)) && (defined(_MSC_VER) || defined(__MINGW32__))
+#define newrealloc hrealloc
+#else
+#define newrealloc trealloc
+#endif
 
 #define DOUBLE_PRECISION    15
 
@@ -886,7 +895,7 @@
 	place = ftell(run->fp);
 	fseek(run->fp, run->pointPos, 0);
         fprintf(run->fp, "%d", run->pointCount);
-	printf("\nNo. of Data Rows : %d\n", run->pointCount);
+	fprintf(stdout, "\nNo. of Data Rows : %d\n", run->pointCount);
 	fseek(run->fp, place, 0);
     } else {
 	/* Yet another hack-around */
@@ -973,12 +982,12 @@
     struct dvec *v = desc->vec;
 
     if (isreal(v)) {
-      v->v_realdata = (double *) trealloc((char *) v->v_realdata,
+      v->v_realdata = (double *) newrealloc((char *) v->v_realdata,
             sizeof (double) * (v->v_length + 1));
       v->v_realdata[v->v_length] = value;
     } else {
       /* a real parading as a VF_COMPLEX */
-      v->v_compdata = (complex *) trealloc((char *) v->v_compdata,
+      v->v_compdata = (complex *) newrealloc((char *) v->v_compdata,
             sizeof (complex) * (v->v_length + 1));
       v->v_compdata[v->v_length].cx_real = value;
       v->v_compdata[v->v_length].cx_imag = (double) 0;
@@ -994,7 +1003,7 @@
 {
     struct dvec *v = desc->vec;
 
-    v->v_compdata = (complex *) trealloc((char *) v->v_compdata,
+    v->v_compdata = (complex *) newrealloc((char *) v->v_compdata,
             sizeof (complex) * (v->v_length + 1));
     v->v_compdata[v->v_length].cx_real = value.real;
     v->v_compdata[v->v_length].cx_imag = value.imag;
@@ -1009,7 +1018,7 @@
 plotEnd(runDesc *run)
 {
   fprintf(stderr,"\n");
-  printf("\nNo. of Data Rows : %d\n", run->pointCount);
+  fprintf(stdout, "\nNo. of Data Rows : %d\n", run->pointCount);
   return;
 }
 
--- ng-spice-rework/src/frontend/parse.c:1.16	Mon Oct  8 15:36:56 2007
+++ ng-spice-rework/src/frontend/parse.c	Thu Jan 15 21:08:09 2009
@@ -1,7 +1,7 @@
 /**********
 Copyright 1990 Regents of the University of California.  All rights reserved.
 Author: 1985 Wayne A. Christopher, U. C. Berkeley CAD Group
-$Id: parse.c,v 1.16 2007/10/08 15:36:56 pnenzi Exp $
+$Id: parse.c,v 1.18 2009/01/15 21:08:09 pnenzi Exp $
 **********/
 
 /*
@@ -698,6 +698,8 @@
         { "rnd",    cx_rnd } ,
         { "pos",    cx_pos } ,
         { "mean",   cx_mean } ,
+        { "avg",   cx_avg } ,     //A.Rroldan 03/06/05 incremental average  new function
+        { "group_delay",  cx_group_delay } , //A.Rroldan 10/06/05 group delay new function
         { "vector", cx_vector } ,
         { "unitvec",    cx_unitvec } ,
         { "length", cx_length } ,
@@ -952,3 +954,17 @@
     }
 }
 
+/* here is the original free_node, which is needed in spec.c and com_fft.c */
+void
+free_pnode_o(struct pnode *t)
+{
+  if (!t)
+    return;
+  free_pnode(t->pn_left);
+  free_pnode(t->pn_right);
+  free_pnode(t->pn_next);
+  tfree(t);
+}
+
+
+
--- ng-spice-rework/src/frontend/postcoms.c:1.11	Wed Jul 23 19:36:50 2003
+++ ng-spice-rework/src/frontend/postcoms.c	Thu Jan 15 22:16:32 2009
@@ -120,8 +120,19 @@
         for (v = vecs; v; v = v->v_link2)
             if (v->v_length > 1) {
                 col = TRUE;
+                /* Improvement made to print cases @[sin] = (0 12 13 100K) */
+		if ( (v->v_length != v->v_plot->pl_scale->v_length) && ( (*(v->v_name))=='@') )
+                {
+                 col = FALSE;
+                }
                 break;
             }
+            /* With this I have found that the vector has less elements than the SCALE vector
+             * in the linked PLOT. But now I must make sure in case of a print @vin[sin] or 
+             * @vin[pulse]
+             * for it appear that the v->v_name begins with '@'
+             * And then be in this case.
+             */
     }
 
     out_init();
@@ -141,8 +152,18 @@
                 s--;
             }
             ll = 10;
-            if (v->v_length == 1) {
-                if (isreal(v)) {
+
+	   /* v->v_rlength = 1 when it comes to make a print @ M1 and does not want to come out on screen
+	    * Multiplier factor [m]=1
+	    *  @M1 = 0,00e+00
+	    * In any other case rlength not used for anything and only applies in the copy of the vectors.
+        */
+	   if (v->v_rlength == 0)
+	   {	   
+            if (v->v_length == 1) 
+	     {
+                if (isreal(v))
+		{
                 	printnum(numbuf, *v->v_realdata);
                     out_printf("%s = %s\n", buf, numbuf);
                 } else {
@@ -194,7 +215,8 @@
                             out_send("\t");
                     }
                 out_send(")\n");
-            }
+	      } //end if (v->v_length == 1)
+	   }  //end  if (v->v_rlength == 1)
         }
     } else {    /* Print in columns. */
         if (cp_getvar("width", VT_NUM, (char *) &i))
@@ -260,7 +282,22 @@
             if (isreal(v))
                 (void) sprintf(buf2, "%-16.15s", v->v_name);
             else
-                (void) sprintf(buf2, "%-32.31s", v->v_name);
+		{
+         /* The frequency vector is complex but often with imaginary part = 0, 
+          * this prevents to print two columns.
+          */
+		 if(eq(v->v_name, "frequency"))
+		 {
+		  if(imagpart(&v->v_compdata[0])==0.0)
+		  {
+                   (void) sprintf(buf2, "%-16.15s", v->v_name);
+		  }
+		  else
+                   (void) sprintf(buf2, "%-32.31s", v->v_name);
+		 }
+		 else
+                  (void) sprintf(buf2, "%-32.31s", v->v_name);
+		}
             (void) strcat(buf, buf2);   
         }
         lineno = 3;
@@ -290,14 +327,34 @@
                     else
                         out_send("\t\t\t\t");
                 } else {
-                    if (isreal(v)) {
-                        sprintf(out_pbuf, "%e\t", 
-                        	v->v_realdata[j]);
+                    if (isreal(v)) 
+		    {
+                        printnum(numbuf,  v->v_realdata[j]);
+                        //sprintf(out_pbuf, "%e\t",v->v_realdata[j]);
+                        (void) sprintf(out_pbuf, "%s\t",numbuf);
 			out_send(out_pbuf);
-                    } else {
-                        sprintf(out_pbuf, "%e,\t%e\t",
-                        	realpart(&v->v_compdata[j]),
-                        	imagpart(&v->v_compdata[j]));
+                    }
+		    else
+		    {
+            /* In case of a single frequency and have a real part avoids print imaginary part equals 0. */
+			if(eq(v->v_name, "frequency"))
+			{
+			 if(imagpart(&v->v_compdata[j])==0.0)
+			 {
+                          printnum(numbuf,  realpart(&v->v_compdata[j]));
+                          (void) sprintf(out_pbuf, "%s\t",numbuf);
+			 }
+			}
+			else
+			{
+                          printnum(numbuf,  realpart(&v->v_compdata[j]));
+                          printnum(numbuf2, imagpart(&v->v_compdata[j]));
+                          (void) sprintf(out_pbuf, "%s,\t%s\t",numbuf,numbuf2);
+/*                       sprintf(out_pbuf, "%e,\t%e\t",
+ *                        	realpart(&v->v_compdata[j]),
+ *                        	imagpart(&v->v_compdata[j]));
+ */
+			}
 			out_send(out_pbuf);
 		    }
                 }
@@ -582,7 +639,13 @@
         for (pl = plot_list; pl; pl = npl) {
             npl = pl->pl_next;
             if (!eq(pl->pl_typename, "const"))
-                killplot(pl);
+	    {
+             killplot(pl);
+	    }
+	    else
+	    {
+	     plot_num=1;
+	    } 
         }
     } else {
         while (wl) {
@@ -590,7 +653,10 @@
                 if (eq(pl->pl_typename, wl->wl_word))
                     break;
             if (pl)
+	    {
                 killplot(pl);
+		plot_num--;
+	    }
             else
                 fprintf(cp_err, "Error: no such plot %s\n",
                         wl->wl_word);
--- ng-spice-rework/src/frontend/resource.c:1.24	Wed Nov 19 19:45:28 2008
+++ ng-spice-rework/src/frontend/resource.c	Wed Jan 14 20:45:53 2009
@@ -1,7 +1,7 @@
 /**********
 Copyright 1990 Regents of the University of California.  All rights reserved.
 Author: 1985 Wayne A. Christopher, U. C. Berkeley CAD Group
-$Id: resource.c,v 1.24 2008/11/19 19:45:28 dwarning Exp $
+$Id: resource.c,v 1.27 2009/01/14 20:45:53 dwarning Exp $
 **********/
 
 /*
@@ -38,29 +38,32 @@
 #endif
 
 /* We  might compile for Windows, but only as a console application (e.g. tcl) */
-#if defined (HAS_WINDOWS) || defined(__MINGW32__) || defined(_MSC_VER)
+#if defined(HAS_WINDOWS) || defined(__MINGW32__) || defined(_MSC_VER)
 #define HAVE_WIN32
 #endif
 
 #ifdef HAVE_WIN32
 #define WIN32_LEAN_AND_MEAN
-/* At least Windows 2000 is needed 
- * Undefine _WIN32_WINNT 0x0500 if you want to compile under Windows ME 
- * and older (not tested under Windows ME or 98!)
- */
-#if (_MSC_VER > 1200) || defined(__MINGW32__) /* Exclude VC++ 6.0 from using the psapi */
-#define _WIN32_WINNT 0x0500
+ 
+#ifdef __MINGW32__  /* access to GlobalMemoryStatusEx in winbase.h:1558 */
+#define WINVER 0x0500
 #endif
+
 /*
  * The ngspice.h file included above defines BOOLEAN (via bool.h) and this
  * clashes with the definition obtained from windows.h (via winnt.h).
  * However, BOOLEAN is not used by this file so we can work round this problem
  * by undefining BOOLEAN before including windows.h
  * SJB - April 2005
- */
+ */ 
+ 
 #undef BOOLEAN
 #include <windows.h>
-#if ( _WIN32_WINNT >= 0x0500)
+/* At least Windows 2000 is needed 
+ * Undefine _WIN32_WINNT 0x0500 if you want to compile under Windows ME 
+ * and older (not tested under Windows ME or 98!)
+ */
+#if defined(__MINGW32__) ||  (_MSC_VER > 1200)/* Exclude VC++ 6.0 from using the psapi */
 #include <psapi.h>
 #endif
 #endif
@@ -152,7 +155,7 @@
 
 #if defined(HAVE_WIN32) || defined(HAVE__PROC_MEMINFO) 
     get_procm(&mem_ng_act);
-    usage = mem_ng_act.size*1024;
+    usage = mem_ng_act.size;
     limit = mem_t.free;    
 #else 
     static unsigned long int old_usage = 0;
@@ -463,7 +466,7 @@
 #  if defined(HAVE_WIN32) || defined(HAVE__PROC_MEMINFO) 
 
 static size_t get_procm(struct proc_mem *memall) {
-#ifdef HAS_WINDOWS
+#if defined (_MSC_VER)|| defined(__MINGW32__)
 #if ( _WIN32_WINNT >= 0x0500)
 /* Use Windows Api function to obtain size of memory */
     HANDLE hProcess;
@@ -490,7 +493,10 @@
 #else
    /* ngspice size is just the difference between free memory at start time and now */
    get_sysmem(&mem_t_act);
-   memall->size = mem_t.free - mem_t_act.free;
+   if (mem_t.free > mem_t_act.free)                     /* it can happen that that ngspice is */
+     memall->size = (mem_t.free - mem_t_act.free)/1024; /* to small compared to os memory usage */
+   else
+     memall->size = 0;                                  /* sure, it is more */
    memall->resident = 0;
    memall->trs = 0;
 #endif /* _WIN32_WINNT 0x0500 */
@@ -503,7 +509,7 @@
    (void) sprintf(fibuf, "/proc/%d/statm", getpid()); 
 
    if((fp = fopen(fibuf, "r")) == NULL) {
-      perror("fopen()");
+      perror("fopen(\"/proc/%d/statm\")");
       return 0;
    }
    bytes_read = fread (buffer, 1, sizeof (buffer), fp);
@@ -544,7 +550,7 @@
    long mem_got;
 
    if((fp = fopen("/proc/meminfo", "r")) == NULL) {
-      perror("fopen()");
+      perror("fopen(\"/proc/meminfo\")");
       return 0;
    }
    
--- ng-spice-rework/src/frontend/runcoms.c:1.18	Sun Sep 21 22:18:10 2008
+++ ng-spice-rework/src/frontend/runcoms.c	Fri Jan 16 15:35:00 2009
@@ -2,7 +2,7 @@
 Copyright 1990 Regents of the University of California.  All rights reserved.
 Author: 1985 Wayne A. Christopher, U. C. Berkeley CAD Group
 Modified: 2000 AlansFixes
-$Id: runcoms.c,v 1.18 2008/09/21 22:18:10 h_vogt Exp $
+$Id: runcoms.c,v 1.19 2009/01/16 15:35:00 pnenzi Exp $
 **********/
 
 /*
@@ -73,12 +73,20 @@
             return;
         for (p = ft_circuits; --i > 0; p = p->ci_next);
     } else {
-        for (p = ft_circuits; p; p = p->ci_next)
-            if (ciprefix(wl->wl_word, p->ci_name))
-                break;
-        if (p == NULL) {
-            fprintf(cp_err, "Warning: no such circuit \"%s\"\n",
-                    wl->wl_word);
+	for (p = ft_circuits; p; p = p->ci_next) 
+		j++;
+
+	p=NULL;
+	if ((sscanf(wl->wl_word, " %d ", &i) != 1) || (i < 0) || (i > j));
+	else
+		for (p = ft_circuits; --i > 0; p = p->ci_next);
+        /* for (p = ft_circuits; p; p = p->ci_next)
+         *   if (ciprefix(wl->wl_word, p->ci_name))
+	     *    break;
+	     */
+        if (p == NULL) 
+        {
+            fprintf(cp_err, "Warning: no such circuit \"%s\"\n",wl->wl_word);
             return;
         }
         fprintf(cp_out, "\t%s\n", p->ci_name);
--- ng-spice-rework/src/frontend/runcoms2.c:1.9	Sat Dec 29 21:11:12 2007
+++ ng-spice-rework/src/frontend/runcoms2.c	Sat Jan 31 14:32:12 2009
@@ -1,7 +1,7 @@
 /**********
 Copyright 1990 Regents of the University of California.  All rights reserved.
 Author: 1985 Wayne A. Christopher, U. C. Berkeley CAD Group
-$Id: runcoms2.c,v 1.9 2007/12/29 21:11:12 dwarning Exp $
+$Id: runcoms2.c,v 1.10 2009/01/31 14:32:12 h_vogt Exp $
 **********/
 
 /*
@@ -25,7 +25,7 @@
 #include "inpdefs.h"
 
 #define RAWBUF_SIZE 32768
-char rawfileBuf[RAWBUF_SIZE];
+extern char rawfileBuf[RAWBUF_SIZE];
 
 /* Continue a simulation. If there is non in progress, this is the
  * equivalent of "run".
--- ng-spice-rework/src/frontend/spec.c:1.8	Sun May 25 18:35:42 2008
+++ ng-spice-rework/src/frontend/spec.c	Sat Dec  6 15:09:12 2008
@@ -1,7 +1,7 @@
 /**********
 Copyright 1994 Macquarie University, Sydney Australia.  All rights reserved.
 Author:   1994 Anthony E. Parker, Department of Electronics, Macquarie Uni.
-$Id: spec.c,v 1.8 2008/05/25 18:35:42 dwarning Exp $
+$Id: spec.c,v 1.10 2008/12/06 15:09:12 h_vogt Exp $
 **********/
 
 /*
@@ -188,7 +188,7 @@
             ngood++;
         }
     }
-    free_pnode(first_name);
+    free_pnode_o(first_name); /* h_vogt 081206 */
     if (!ngood) {
        tfree(win);
        return;
--- ng-spice-rework/src/frontend/spec.h:1.3	Sun May 25 18:35:42 2008
+++ ng-spice-rework/src/frontend/spec.h	Sat Dec  6 15:09:12 2008
@@ -11,5 +11,6 @@
 #endif
 
 void com_spec(wordlist *wl);
+extern void free_pnode_o(struct pnode *t);
 
 #endif
--- ng-spice-rework/src/frontend/spiceif.c:1.23	Sat Dec 15 15:11:14 2007
+++ ng-spice-rework/src/frontend/spiceif.c	Thu Jan 15 21:08:09 2009
@@ -2,7 +2,7 @@
 Copyright 1990 Regents of the University of California.  All rights reserved.
 Author: 1985 Wayne A. Christopher, U. C. Berkeley CAD Group
 Modified: 2000 AlansFixes
-$Id: spiceif.c,v 1.23 2007/12/15 15:11:14 sjborley Exp $
+$Id: spiceif.c,v 1.25 2009/01/15 21:08:09 pnenzi Exp $
 **********/
 
 /*
@@ -81,6 +81,8 @@
 		 IFparm *opt, struct dvec *val);
 static int finddev(void *ck, char *name, void **devptr, void **modptr);
 
+/*espice fix integration */
+static int finddev_special(char *ck, char *name, void **devptr, void **modptr, int *device_or_model);
 
 /* Input a single deck, and return a pointer to the circuit. */
 
@@ -550,6 +552,182 @@
     return (INPerror(code));
 }
 
+/* Get pointers to a device, its model, and its type number given the name. If
+ * there is no such device, try to find a model with that name
+ * device_or_model says if we are referencing a device or a model.
+ *  finddev_special(ck, name, devptr, modptr,device_or_model):
+ *  Introduced to look for correct reference in expression like  print @BC107 [is] 
+ * and find out  whether a model or a device parameter is referenced and properly 
+ * call the spif_getparam_special (ckt, name, param, ind, do_model) function in
+ * vector.c - A. Roldan (espice).
+ */
+static int 
+finddev_special(
+    char *ck,
+    char *name,
+    void **devptr,
+    void **modptr,
+    int *device_or_model)
+{
+    int err;
+    int type = -1;
+
+    err = (*(ft_sim->findInstance))((void *)ck,&type,devptr,name,NULL,NULL);
+    if(err == OK)
+    {
+     *device_or_model=0;
+     return(type);
+    }
+    type = -1;
+    *devptr = (void *)NULL;
+    err = (*(ft_sim->findModel))((void *)ck,&type,modptr,name);
+    if(err == OK)
+    {
+     *device_or_model=1;
+     return(type);
+    }
+    *modptr = (void *)NULL;
+    *device_or_model=2;
+    return(-1);
+
+}
+
+/* Get a parameter value from the circuit. If name is left unspecified,
+ * we want a circuit parameter. Now works both for devices and models.
+ * A.Roldan (espice)
+ */
+struct variable *
+spif_getparam_special(void *ckt,char **name,char *param,int ind,int do_model)    
+{
+    struct variable *vv = NULL, *tv;
+    IFvalue *pv;
+    IFparm *opt;
+    int typecode, i, modelo_dispositivo;
+    GENinstance *dev=(GENinstance *)NULL;
+    GENmodel *mod=(GENmodel *)NULL;
+    IFdevice *device;
+
+    /* fprintf(cp_err, "Calling if_getparam(%s, %s)\n", *name, param); */
+
+    if (!param || (param && eq(param, "all")))
+     {
+        INPretrieve(name,(INPtables *)ft_curckt->ci_symtab);
+        typecode = finddev_special(ckt, *name, (void**)&dev, (void**)&mod,&modelo_dispositivo);
+        if (typecode == -1)
+        {
+            fprintf(cp_err,"Error: no such device or model name %s\n",*name);
+            return (NULL);
+        }
+        device = ft_sim->devices[typecode];
+        if(!modelo_dispositivo)
+        {
+          /* It is a device */
+          for (i = 0; i < *(device->numInstanceParms); i++)
+          {
+            opt = &device->instanceParms[i];
+            if(opt->dataType & IF_REDUNDANT || !opt->description) continue;
+            if(!(opt->dataType & IF_ASK)) continue;
+            pv = doask(ckt, typecode, dev, mod, opt, ind);
+            if (pv)
+            {
+             tv = parmtovar(pv, opt);
+
+	     /* With the following we pack the name and the acronym of the parameter */
+	     {
+		char auxiliar[70],*aux_pointer;
+		sprintf(auxiliar,"%s [%s]",tv->va_name, device->instanceParms[i].keyword);
+		aux_pointer=tv->va_name;
+		free(aux_pointer);
+		tv->va_name = copy(auxiliar);
+	     }
+             if (vv) tv->va_next = vv;
+             vv = tv;
+          }
+          else
+           fprintf(cp_err,"Internal Error: no parameter '%s' on device '%s'\n",
+			   device->instanceParms[i].keyword,device->name);
+         }
+         return (vv);
+        }
+        else  /* Is it a model or a device ? */
+        {
+         /* It is a model */
+         for (i = 0; i < *(device->numModelParms); i++)
+         {
+            opt = &device->modelParms[i];
+            if(opt->dataType & IF_REDUNDANT || !opt->description) continue;
+        
+            /* We check that the parameter is interesting and therefore is 
+             * implemented in the corresponding function ModelAsk. Originally
+             * the argument of "if" was: || (opt->dataType & IF_STRING)) continue;
+             * so, a model parameter defined like  OP("type",   MOS_SGT_MOD_TYPE,  
+             * IF_STRING, N-channel or P-channel MOS") would not be printed.
+             */
+
+        /* if(!(opt->dataType & IF_ASK ) || (opt->dataType & IF_UNINTERESTING ) || (opt->dataType & IF_STRING)) continue; */
+	    if(!(opt->dataType & IF_ASK ) || (opt->dataType & IF_UNINTERESTING )) continue;
+            pv = doask(ckt, typecode, dev, mod, opt, ind);
+            if (pv)
+            {
+                tv = parmtovar(pv, opt);
+		/* Inside parmtovar:
+		 * 1. tv->va_name = copy(opt->description);
+		 * 2. Copy the type of variable of IFparm into a variable (thus parm-to-var)
+		 * vv->va_type = opt->dataType
+		 * The long description of the parameter:
+		 * IFparm MOS_SGTmPTable[] = { // model parameters //
+		 * OP("type",   MOS_SGT_MOD_TYPE,  IF_STRING, "N-channel or P-channel MOS") 
+         * goes into tv->va_name to put braces around the parameter of the model
+		 * tv->va_name += device->modelParms[i].keyword;
+         */
+		{
+		 char auxiliar[70],*aux_pointer;
+		 sprintf(auxiliar,"%s [%s]",tv->va_name,device->modelParms[i].keyword);
+		 aux_pointer=tv->va_name;
+		 free(aux_pointer);
+		 tv->va_name = copy(auxiliar);
+		/* strcpy(aux_pointer,auxiliar); */
+		}
+		/* tv->va_string=device->modelParms[i].keyword;	Put the name of the variable */
+                if (vv)
+                {
+                  tv->va_next = vv;
+                }
+                vv = tv;
+            }
+            else
+                fprintf(cp_err,"Internal Error: no parameter '%s' on device '%s'\n",device->modelParms[i].keyword,device->name);
+        }
+        return (vv);
+        } 
+    }
+    else if (param)
+    {
+        INPretrieve(name,(INPtables *)ft_curckt->ci_symtab);
+        typecode = finddev_special(ckt, *name, (void**)&dev, (void**)&mod,&modelo_dispositivo);
+        if (typecode == -1)
+        {
+            fprintf(cp_err,"Error: no such device or model name %s\n",*name);
+            return (NULL);
+        }
+        device = ft_sim->devices[typecode];
+        opt = parmlookup(device, &dev, param, modelo_dispositivo, 0);
+        if (!opt)
+        {
+            fprintf(cp_err, "Error: no such parameter %s.\n",param);
+            return (NULL);
+        }
+        pv = doask(ckt, typecode, dev, mod, opt, ind);
+        if (pv)
+            vv = parmtovar(pv, opt);
+        return (vv);
+    } else
+        return (if_getstat(ckt, *name));
+}
+
+
+
+
 /* Get a parameter value from the circuit. If name is left unspecified,
  * we want a circuit parameter.
  */
@@ -764,14 +942,35 @@
             break;
         case IF_REALVEC:
             vv->va_type = VT_LIST;
-            for (i = 0; i < pv->v.numValue; i++) {
+            for (i = 0; i < pv->v.numValue; i++) 
+       {
                 nv = alloc(struct variable);
                 nv->va_next = vv->va_vlist;
                 vv->va_vlist = nv;
                 nv->va_type = VT_REAL;
-                nv->va_real = pv->v.vec.rVec[i];
-            }
-            break;
+                /* Change this so that the values are printed in order and
+                 * not in inverted order as happens in the conversion process.
+                 * Originally was  nv->va_real = pv->v.vec.rVec[i];
+                 */
+                nv->va_real = pv->v.vec.rVec[pv->v.numValue-i-1];
+      }
+            /* It is a linked list where the first node is a variable
+             * pointing to the different values of the variables.
+             *
+             * To access the values of the real variable vector must be
+             * vv->va_V.vV_real=valor node ppal that is of no use.
+             *
+             * In the case of Vin_sin 1 0 sin (0 2 2000)
+             * and of print @vin_sin[sin]
+             *
+             * vv->va_V.vV_list->va_V.vV_real=2000
+             * vv->va_V.vV_list->va_next->va_V.vV_real=2
+             * vv->va_V.vV_list->va_next->va_next->va_V.vV_real=0
+             * So the list is starting from behind, but no problem
+             * This works fine
+             */        
+       
+       break;
         default:
             fprintf(cp_err,  
             "parmtovar: Internal Error: bad PARM type %d.\n",
--- ng-spice-rework/src/frontend/spiceif.h:1.3	Mon Oct  8 21:45:01 2007
+++ ng-spice-rework/src/frontend/spiceif.h	Thu Jan 15 16:46:31 2009
@@ -1,7 +1,7 @@
 /*************
  * Header file for spiceif.c
  * 1999 E. Rouat
- * $Id: spiceif.h,v 1.3 2007/10/08 21:45:01 pnenzi Exp $
+ * $Id: spiceif.h,v 1.4 2009/01/15 16:46:31 pnenzi Exp $
  ************/
 
 #ifndef SPICEIF_H_INCLUDED
@@ -14,6 +14,7 @@
 void if_cktfree(void *ckt, char *tab);
 char * if_errstring(int code);
 struct variable * spif_getparam(void *ckt, char **name, char *param, int ind, int do_model);
+struct variable * spif_getparam_special(void *ckt,char **name,char *param,int ind,int do_model);
 void if_setparam_model(void *ckt, char **name, char *val);
 void if_setparam(void *ckt, char **name, char *param, struct dvec *val, int do_model);
 int  if_analQbyName(void *ckt, int which, void *anal, char *name, IFvalue *parm);
--- ng-spice-rework/src/frontend/subckt.c:1.27	Mon May 12 15:53:07 2008
+++ ng-spice-rework/src/frontend/subckt.c	Sat Jan 31 15:17:48 2009
@@ -2,7 +2,7 @@
 Copyright 1990 Regents of the University of California.  All rights reserved.
 Author: 1985 Wayne A. Christopher, U. C. Berkeley CAD Group 
 Modified: 2000 AlansFixes
-$Id: subckt.c,v 1.27 2008/05/12 15:53:07 dwarning Exp $
+$Id: subckt.c,v 1.28 2009/01/31 15:17:48 h_vogt Exp $
 **********/
 
 /*------------------------------------------------------------------------------
@@ -1195,20 +1195,20 @@
         } 
 	else {    /* just a normal netname . . . . */
 	    /*
-	     * 
+	     * i(vname) -> i(v.subckt.vname)
 	     */
              if ((which == 'i' || which == 'I') &&
 	        (buf[0] == 'v' || buf[0] == 'V')) {
 		*dst++ = buf[0];
 		*dst++ = '.';
-		i = 1;
-	    } else {
+		/*i = 1; */
+	    } /* else {
 		i = 0;
-	    }
+	    } */
             for (s = scname; *s; )
                 *dst++ = *s++;
             *dst++ = '.';
-            for (s = buf + i; *s; )
+            for (s = buf/* + i*/; *s; )
                 *dst++ = *s++;
         }
 
--- ng-spice-rework/src/frontend/typesdef.c:1.5	Mon May  9 20:22:27 2005
+++ ng-spice-rework/src/frontend/typesdef.c	Fri Jan 16 14:31:07 2009
@@ -14,7 +14,7 @@
 #include "typesdef.h"
 
 
-#define NUMTYPES 128        /* If this is too little we can use a list. */
+#define NUMTYPES 128+4      /* If this is too little we can use a list. */
 #define NUMPLOTTYPES 512    /* Since there may be more than 1 pat/type. */
 
 struct type {
@@ -40,14 +40,19 @@
     { "onoise-integrated", "V or A" } ,
     { "inoise-spectrum", "(V or A)^2/Hz" } ,
     { "inoise-integrated", "V or A" } ,
-    { "output-noise", NULL } ,
-    { "input-noise", NULL } ,
+    /* { "output-noise", NULL } , */
+    /* { "input-noise", NULL } , */
     { "pole", NULL } ,
     { "zero", NULL } ,
     { "s-param", NULL } ,
     { "temp-sweep", "Celsius" } ,/* Added by HT */
 
-    { "res-sweep", "Ohm" } ,/* Added by HT */
+    { "res-sweep", "Ohms" } ,/* Added by HT */
+    { "impedance", "Ohms" } ,/* Added by A.Roldan */
+    { "admittance", "Mhos" } ,/* Added by A.Roldan */
+    { "power", "W" } ,          /* Added by A.Roldan */
+    { "phase", "Degree" } ,     /* Added by A.Roldan */
+    { "decibel", "dB" } ,     /* Added by A.Roldan */
 
 } ;
 
@@ -77,7 +82,7 @@
     { "spect", "spect" },
 } ;
 
-int notypes = 15;/* change 14 to 15 by H.T*/
+int notypes = 15 ;/* change 14 to 15 by H.T*/
 int noplotabs = 20;/* change 18 to 20 by H.T*/
 
 /* A command to define types for vectors and plots.  This will generally
--- ng-spice-rework/src/frontend/variable.h:1.6	Sat Oct  4 22:44:52 2008
+++ ng-spice-rework/src/frontend/variable.h	Sun Nov 30 21:16:36 2008
@@ -1,63 +1,63 @@
-/*
-  variable.h
-  $Id: variable.h,v 1.6 2008/10/04 22:44:52 h_vogt Exp $
-*/
-
-#ifndef _VARIABLE_H
-#define _VARIABLE_H
-
-/* Variables that are accessible to the parser via $varname
- * expansions.  If the type is VT_LIST the value is a pointer to a
- * list of the elements.  */
-struct variable {
-    char va_type;
-    char *va_name;
-    union {
-        bool vV_bool;
-        int vV_num;
-        double vV_real;
-        char *vV_string;
-        struct variable *vV_list;
-    } va_V;
-    struct variable *va_next;      /* Link. */
-} ;
-
-#define va_bool   va_V.vV_bool
-#define va_num    va_V.vV_num
-#define va_real   va_V.vV_real
-#define va_string va_V.vV_string
-#define va_vlist  va_V.vV_list
-
-enum vt_types {
-  VT_BOOL,
-  VT_NUM,
-  VT_REAL,
-  VT_STRING,
-  VT_LIST
-};
-
-struct xxx {
-    struct variable *x_v;
-    char x_char;
-} ;
-
-
-extern struct variable *variables;
-extern bool cp_noglob;
-extern bool cp_nonomatch;
-extern bool cp_noclobber;
-extern bool cp_ignoreeof;
-extern bool cp_echo;
-
-/* extern struct variable *variables; */
-wordlist * cp_varwl(struct variable *var);
-void cp_vset(char *varname, char type, char *value);
-struct variable * cp_setparse(wordlist *wl);
-void cp_remvar(char *varname);
-bool cp_getvar(char *name, int type, void *retval);
-wordlist * cp_variablesubst(wordlist *wlist);
-wordlist * vareval(char *string);
-void cp_vprint(void);
-
-
-#endif /* _VARIABLE_H */
+/*
+  variable.h
+  $Id: variable.h,v 1.7 2008/11/30 21:16:36 dwarning Exp $
+*/
+
+#ifndef _VARIABLE_H
+#define _VARIABLE_H
+
+/* Variables that are accessible to the parser via $varname
+ * expansions.  If the type is VT_LIST the value is a pointer to a
+ * list of the elements.  */
+struct variable {
+    char va_type;
+    char *va_name;
+    union {
+        bool vV_bool;
+        int vV_num;
+        double vV_real;
+        char *vV_string;
+        struct variable *vV_list;
+    } va_V;
+    struct variable *va_next;      /* Link. */
+} ;
+
+#define va_bool   va_V.vV_bool
+#define va_num    va_V.vV_num
+#define va_real   va_V.vV_real
+#define va_string va_V.vV_string
+#define va_vlist  va_V.vV_list
+
+enum vt_types {
+  VT_BOOL,
+  VT_NUM,
+  VT_REAL,
+  VT_STRING,
+  VT_LIST
+};
+
+struct xxx {
+    struct variable *x_v;
+    char x_char;
+} ;
+
+
+extern struct variable *variables;
+extern bool cp_noglob;
+extern bool cp_nonomatch;
+extern bool cp_noclobber;
+extern bool cp_ignoreeof;
+extern bool cp_echo;
+
+/* extern struct variable *variables; */
+wordlist * cp_varwl(struct variable *var);
+void cp_vset(char *varname, char type, char *value);
+struct variable * cp_setparse(wordlist *wl);
+void cp_remvar(char *varname);
+bool cp_getvar(char *name, int type, void *retval);
+wordlist * cp_variablesubst(wordlist *wlist);
+wordlist * vareval(char *string);
+void cp_vprint(void);
+
+
+#endif /* _VARIABLE_H */
--- ng-spice-rework/src/frontend/vectors.c:1.8	Thu May 26 19:29:52 2005
+++ ng-spice-rework/src/frontend/vectors.c	Thu Jan 15 22:16:32 2009
@@ -1,7 +1,7 @@
 /**********
 Copyright 1990 Regents of the University of California.  All rights reserved.
 Author: 1985 Wayne A. Christopher, U. C. Berkeley CAD Group 
-$Id: vectors.c,v 1.8 2005/05/26 19:29:52 sjborley Exp $
+$Id: vectors.c,v 1.11 2009/01/15 22:16:32 pnenzi Exp $
 **********/
 
 /*
@@ -275,7 +275,8 @@
         /* ( */ ((s =strrchr(buf, ')')) != NULL) &&
             (*(s + 1) == '\0')) {
         *s = '\0';
-        if (prefix("i(", /* ) */ word)) {
+	if (prefix("i(", /* ) */ word) || prefix("I(", /* ) */ word))
+	{
             /* Spice dependency... */
             (void) sprintf(buf2, "%s#branch", buf);
             (void) strcpy(buf, buf2);
@@ -386,8 +387,14 @@
             
 	
 	if (ft_curckt) {
-	
-	    vv = (*if_getparam)(ft_curckt->ci_ckt, &name, param, 0, 0);
+             /*
+              *  This is what is done in case of "alter r1 resistance = 1234"
+              *                                r1    resistance, 0
+              * if_setparam(ft_curckt->ci_ckt, &dev, param, dv, do_model);
+              */
+
+            /* vv = (*if_getparam)(ft_curckt->ci_ckt, &name, param, 0, 0); */
+	    vv = (*if_getparam)(ft_curckt->ci_ckt, &name, param, 0, 0);	
 	    if (!vv) {
 	        tfree(whole);
 		tfree(wd);
@@ -407,7 +414,124 @@
         d->v_flags |= VF_REAL;  /* No complex values yet... */
         d->v_realdata = (double *) tmalloc(sizeof (double));
         d->v_length = 1;
-        *d->v_realdata = vv->va_real;
+    
+    /* In case the represented variable is a REAL vector this takes
+     * the actual value of the first element of the linked list which 
+     * does not make sense.
+     * This is an error.
+     */
+   
+    /* This will copy the contents of the structure vv in another structure
+     * dvec (FTEDATA.H) that do not have INTEGER so that those parameters
+     * defined as IF_INTEGER are not given their value when using 
+     * print @pot[pos_node]
+     * To fix this, it is necessary to define:
+     * OPU( "pos_node",    POT_QUEST_POS_NODE, IF_REAL,"Positive node of potenciometer"),
+     * int POTnegNode;     // number of negative node of potenciometer (Nodo_3)
+     *  case POT_QUEST_POS_NODE:
+     *  value->rValue = (double)fast->POTposNode;
+     *  return(OK);
+     *  Works but with the format 1.00000E0
+     */
+
+    /* We must make a change in format between the data that carries a variable to
+     * put in a dvec.
+     */
+   
+   /*
+    * #define va_bool  va_V.vV_bool
+    * #define va_num    va_V.vV_num
+    *#define va_real  va_V.vV_real
+    *#define va_string   va_V.vV_string
+    *#define va_vlist     va_V.vV_list
+    *enum vt_types {
+    *  VT_BOOL,
+    *  VT_NUM,
+    *  VT_REAL,
+    *  VT_STRING,
+    *  VT_LIST
+    ° };
+    */
+
+   /* The variable is a vector */
+    if (vv->va_type == VT_LIST)
+    {
+     /* Compute the length of the vector, 
+      * used with the parameters of isrc and vsrc
+      */
+     struct variable *nv;
+     double *list;
+     list = (double *)MALLOC(sizeof(double));
+     nv = alloc(struct variable);
+
+     nv = vv->va_vlist;
+     for(i=1; ;i++)
+      {
+       list=(double *)REALLOC((char *)list,i*sizeof(double));
+       *(list+i-1) = nv->va_real;
+       nv = nv->va_next;
+       if (nv==NULL) break;
+      }
+     d->v_realdata=list;
+     d->v_length = i;
+     /* To be able to identify the vector to represent
+      * belongs to a special "conunto" and should be printed in a
+      * special way.
+      */
+     d->v_dims[1]=1;
+    }
+    else if (vv->va_type == VT_NUM)   /* Variable is an integer */
+    {
+     *d->v_realdata =  (double) vv->va_num;
+    }
+    else if (vv->va_type == VT_REAL)  /* Variable is a real */
+    {
+     if (!(vv->va_next))
+     { 
+       /* Only a real data
+        * usually normal 
+        */
+     *d->v_realdata = vv->va_real;
+     }
+     else
+     { 
+       /* Real data set
+        * When you print a model @ [all]
+        * Just print numerical values, not the string
+        */
+       struct variable *nv;       
+       /* We go to print the list of values
+        * nv->va_name = Parameter description
+        * nv->va_string = Parameter
+        * nv->va_real= Value
+        */ 
+       nv=vv;  
+       for(i=1; ;i++)
+       {
+	switch(nv->va_type)
+	{
+		case  VT_REAL:
+			fprintf(stdout,"%s=%g\n",nv->va_name,nv->va_real);
+			break;
+		case  VT_STRING:
+			fprintf(stdout,"%s=%s\n",nv->va_name,nv->va_string);
+			break;	
+		case  VT_NUM:
+			fprintf(stdout,"%s=%d\n",nv->va_name,nv->va_num);
+			break;	
+	}
+	nv = nv->va_next;
+	
+        if (nv==NULL) break;
+       }
+
+      /* To distinguish those does not take anything for print screen to 
+       * make a print or M1 @ @ M1 [all] leaving only the correct data 
+       * and not the last
+       */	
+      d->v_rlength=1;
+      }
+    }
         
         tfree(vv->va_name);
         tfree(vv); /* va: tfree vv->va_name and vv (avoid memory leakages) */
@@ -476,7 +600,18 @@
     nv->v_gridtype = v->v_gridtype;
     nv->v_plottype = v->v_plottype;
     nv->v_length = v->v_length;
-    nv->v_rlength = 0; /*XXX???*/
+    
+    /* Modified to copy the rlength of origin to destination vecor 
+     * instead of always putting it to 0. 
+     * As when it comes to make a print does not leave M1 @ @ M1 = 0.0, 
+     * to do so in the event that rlength = 0 not print anything on screen
+     * nv-> v_rlength = 0; 
+     * Default -> v_rlength = 0 and only if you come from a print or M1 @ 
+     * @ M1 [all] rlength = 1, after control is one of 
+     * if (v-> v_rlength == 0) com_print (wordlist * wl)
+     */	
+    nv->v_rlength = v->v_rlength;
+    
     nv->v_outindex = 0; /*XXX???*/
     nv->v_linestyle = 0; /*XXX???*/
     nv->v_color = 0; /*XXX???*/
@@ -621,7 +756,7 @@
                 pl->pl_scale = NULL;
         }
     }
-    tfree(v->v_name);
+    if (v->v_name) tfree(v->v_name);
     if (v->v_realdata) tfree(v->v_realdata);
     if (v->v_compdata) tfree(v->v_compdata);
     tfree(v);
--- ng-spice-rework/src/frontend/numparam/numparam.h:1.8	Thu Dec 27 16:47:36 2007
+++ ng-spice-rework/src/frontend/numparam/numparam.h	Sat Jan 31 14:32:12 2009
@@ -1,6 +1,6 @@
 /*
  * numparam.h 
- * $Id: numparam.h,v 1.8 2007/12/27 16:47:36 dwarning Exp $
+ * $Id: numparam.h,v 1.9 2009/01/31 14:32:12 h_vogt Exp $
  */
 
 /*** interface to spice frontend  subckt.c ***/
@@ -76,7 +76,3 @@
  tdico * nupa_fetchinstance(void);
  char getidtype( tdico *d, char * s);
  int attrib( tdico *dico, char * t, char op );
-
-char *nupa_inst_name;
-tdico *inst_dico;
- 
--- ng-spice-rework/src/frontend/numparam/spicenum.c:1.8	Sun Jan 20 13:20:19 2008
+++ ng-spice-rework/src/frontend/numparam/spicenum.c	Sat Jan 31 14:32:12 2009
@@ -29,6 +29,9 @@
 
 extern void txfree (void *ptr);
 
+char *nupa_inst_name;
+static tdico *inst_dico;
+
 /* Uncomment this line to allow debug tracing */
 /* #define TRACE_NUMPARAMS */
 
--- ng-spice-rework/src/frontend/numparam/xpressn.c:1.16	Sat Nov 29 20:21:56 2008
+++ ng-spice-rework/src/frontend/numparam/xpressn.c	Sat Jan 31 14:32:12 2009
@@ -19,6 +19,7 @@
 static Str (150, keys);                /* all my keywords */
 static Str (150, fmath);        /* all math functions */
 
+extern char *nupa_inst_name; /* see spicenum.c */
 
 static double
 ternary_fcn (int conditional, double if_value, double else_value)
--- ng-spice-rework/src/frontend/plotting/plotcurv.c:1.3	Fri Feb  9 08:18:35 2001
+++ ng-spice-rework/src/frontend/plotting/plotcurv.c	Sun Jan 18 16:37:05 2009
@@ -108,9 +108,10 @@
                  * something useful.
                  */
                 gr_point(v, v->v_realdata[i],
-                    v->v_realdata[i],
+                    0.0, /* v->v_realdata[i], */
                     v->v_realdata[j],
-                    v->v_realdata[j], (j==i ? 1 : i));
+                    0.0, /* v->v_realdata[j], */ 
+		    (j==i ? 1 : i));
             } else {
                 gr_point(v, realpart(&v->v_compdata[i]),
                     imagpart(&v->v_compdata[i]),
--- ng-spice-rework/src/frontend/plotting/plotit.c:1.10	Wed Aug 27 13:39:27 2008
+++ ng-spice-rework/src/frontend/plotting/plotit.c	Sun Jan 18 16:37:05 2009
@@ -1,4 +1,4 @@
-/* $Id: plotit.c,v 1.10 2008/08/27 13:39:27 pnenzi Exp $ */
+/* $Id: plotit.c,v 1.11 2009/01/18 16:37:05 pnenzi Exp $ */
 #include <ngspice.h>
 #include <config.h>
 #include <bool.h>
@@ -707,7 +707,7 @@
     /* Transform for smith plots */
     if (gtype == GRID_SMITH) {
 	double	re, im, rex, imx;
-	double	r, i, x;
+	double	r;
 	struct dvec **prevvp, *n;
 	int	j;
 
@@ -743,12 +743,16 @@
 		    re = re - 1;
 
 		    /* (re, im) / (rex, imx) */
-		    x = 1 - (imx / rex) * (imx / rex);
-		    r = re / rex + im / rex * imx / rex;
-		    i = im / rex - re / rex * imx / rex;
-
-		    realpart(d->v_compdata + j) = r / x;
-		    imagpart(d->v_compdata + j) = i / x;
+		    /* x = 1 - (imx / rex) * (imx / rex);
+		     * r = re / rex + im / rex * imx / rex;
+		     * i = im / rex - re / rex * imx / rex;
+             *
+             *
+		     * realpart(d->v_compdata + j) = r / x;
+		     * imagpart(d->v_compdata + j) = i / x;
+             */
+		    realpart(d->v_compdata + j) = (rex*re+imx*imx) / (rex*rex+imx*imx);
+		    imagpart(d->v_compdata + j) = (2*imx) / (rex*rex+imx*imx);
 		}
 	    }
 	}
@@ -762,7 +766,11 @@
         ylims[0] = HUGE;
         ylims[1] = - ylims[0];
         for (d = vecs; d; d = d->v_link2) {
-		dd = ft_minmax(d, TRUE);
+		/* dd = ft_minmax(d, TRUE); */
+		/* With this we seek the maximum and minimum of imaginary part
+         * that will go to Y axis 
+         */
+		dd = ft_minmax(d, FALSE);
             if (dd[0] < ylims[0])
                 ylims[0] = dd[0];
             if (dd[1] > ylims[1])
@@ -797,7 +805,11 @@
         xlims[0] = HUGE;
         xlims[1] = - xlims[0];
         for (d = vecs; d; d = d->v_link2) {
-		dd = ft_minmax(d, FALSE);
+		/* dd = ft_minmax(d, FALSE); */
+		/* With this we seek the maximum and minimum of imaginary part
+         * that will go to Y axis 
+         */
+		dd = ft_minmax(d, TRUE);
 
             if (dd[0] < xlims[0])
                 xlims[0] = dd[0];
@@ -874,8 +886,13 @@
                 fabs(xlims[1]);
         my = (fabs(ylims[0]) > fabs(ylims[1])) ? fabs(ylims[0]) :
                 fabs(ylims[1]);
-        rad = (mx > my) ? mx : my;
-        /* rad = sqrt(mx * mx + my * my); */
+       /* rad = (mx > my) ? mx : my; */
+	   /* AM.Roldán
+        * Change this reason that this was discussed, as in the case of 1 + i want to plot point 
+        * is outside the drawing area so I'll stay as the maximum size of the hypotenuse of 
+        * the complex value
+        */
+        rad = sqrt(mx * mx + my * my);
         xlims[0] = - rad;
         xlims[1] = rad;
         ylims[0] = - rad;
--- ng-spice-rework/src/frontend/wdisp/windisp.c:1.9	Sun Sep 21 22:18:12 2008
+++ ng-spice-rework/src/frontend/wdisp/windisp.c	Sun Jan 11 00:28:14 2009
@@ -153,7 +153,7 @@
 /* (attach to window) */
 static GRAPH * pGraph( HWND hwnd)
 {
-	return (GRAPH *) GetWindowLong( hwnd, 0);
+    return (GRAPH *) GetWindowLong( hwnd, 0);
 }
 
 /* return line style for plotting */
@@ -375,7 +375,7 @@
 	/* start plot loop with argument buf	*/
 	case WM_RBUTTONUP:
 	        {
-		GRAPH * gr = pGraph( hwnd);  
+		GRAPH * gr = pGraph( hwnd);
 		InvalidateRect (hwnd, NULL, TRUE) ;
 		xe = LOWORD (lParam);
 		ye = HIWORD (lParam);
@@ -392,10 +392,11 @@
 
 		if (!eq(plot_cur->pl_typename, buf2)) {
 			(void) sprintf(buf,
-			"setplot %s; %s xlimit %1.20e %1.20e ylimit %1.20e %1.20e; setplot $curplot\n",
+//			"setplot %s; %s xlimit %e %e ylimit %e %e; setplot $curplot\n",
+         "setplot %s; %s xlimit %e %e ylimit %e %e\n",
 			buf2, gr->commandline, fx0, fxe, fy0, fye);
 		} else {
-			(void) sprintf(buf, "%s xlimit %le %le ylimit %le %le\n",
+			(void) sprintf(buf, "%s xlimit %e %e ylimit %e %e\n",
 			gr->commandline, fx0, fxe, fy0, fye);
 		}
 
@@ -407,9 +408,15 @@
 	case WM_CLOSE:	/* close window */
 		{
 			GRAPH * g = pGraph( hwnd);
-			if (g)
+
+         if (g) {
+            /* if g equals currentgraph, set a new currentgraph. 
+            Otherwise gr_resize(g) might fail. */
+            if (g == currentgraph)
+               currentgraph = FindGraph(g->graphid - 1);
 				DestroyGraph(g->graphid);
-		}
+         }
+      }
 		goto WIN_DEFAULT;
 
 	case WM_PAINT:	/* replot window (e.g. after Resize) */
@@ -436,7 +443,9 @@
 						/* switch DC */
 						saveDC = wd->hDC;
 						wd->hDC = newDC;
-						/* plot anew */
+//						currentgraph = g;
+                  
+                  /* plot anew */
 						gr_resize(g);
 						/* switch DC */
 						wd->hDC = saveDC;
--- ng-spice-rework/src/include/fteext.h:1.16	Sat May 24 18:06:41 2008
+++ ng-spice-rework/src/include/fteext.h	Fri Jan 16 15:35:00 2009
@@ -100,6 +100,7 @@
 extern void *cx_uminus(void *, short int , int , int *, short int *, ...);
 extern void *cx_rnd(void *, short int , int , int *, short int *, ...);
 extern void *cx_mean(void *, short int , int , int *, short int *, ...);
+extern void *cx_avg(void *, short int , int , int *, short int *, ...);
 extern void *cx_length(void *, short int , int , int *, short int *, ...);
 extern void *cx_vector(void *, short int , int , int *, short int *, ...);
 extern void *cx_unitvec(void *, short int , int , int *, short int *, ...);
@@ -133,6 +134,8 @@
 extern void *cx_not(void *, short int , int , int *, short int * , ...);
 extern void *cx_interpolate(void *, short int , int , int *, short int *, ...); /* struct plot *, struct plot *, int ); */
 extern void *cx_deriv(void *, short int , int , int *, short int *, ...); /*struct plot *, struct plot *, int );*/
+extern void *cx_group_delay(void *, short int , int , int *, short int *, ...); /*struct plot *, struct plot *, int );*/
+
 
 /* cmdtab.c */
 
@@ -326,6 +329,9 @@
 extern int  hcomp();
 extern void com_where();
 
+/* mw_coms.c */
+extern void com_removecirc();
+
 /* numparse.c */
 
 extern bool ft_strictnumparse;
@@ -449,6 +455,7 @@
 extern struct variable *(*if_getparam)();
 extern struct variable *nutif_getparam();
 extern struct variable *spif_getparam();
+extern struct variable *spif_getparam_special();
 extern void if_cktfree();
 extern void if_dump();
 extern int if_option();
--- ng-spice-rework/src/include/memory.h:1.6	Sat Oct 27 20:00:22 2007
+++ ng-spice-rework/src/include/memory.h	Mon Jan  5 21:32:36 2009
@@ -27,8 +27,12 @@
 #define REALLOC(x,y) trealloc((char *)(x),(unsigned)(y))
 #define ZERO(PTR,TYPE)	(bzero((PTR),sizeof(TYPE)))
 
-#ifdef CIDER
+#if defined(_MSC_VER) || defined(__MINGW32__)
+void *
+hrealloc(void *ptr, size_t num);
+#endif
 
+#ifdef CIDER
 
 #define RALLOC(ptr,type,number)\
 if ((number) && (!(ptr = (type *)calloc((number), (unsigned)(sizeof(type)))))) {\
--- ng-spice-rework/src/include/missing_math.h:1.7	Wed Nov 19 19:57:27 2008
+++ ng-spice-rework/src/include/missing_math.h	Mon Jan  5 21:31:45 2009
@@ -2,7 +2,6 @@
 Copyright 1999 Emmanuel Rouat
 **********/
 
-
 /* Decl. for missing maths functions, if any */
 
 #ifndef MISSING_MATH_H_INCLUDED
@@ -26,8 +25,24 @@
 extern double scalbn(double, int);
 #endif
 
+#if !HAVE_DECL_ISNAN
 #ifndef HAVE_ISNAN
 extern int isnan(double);
 #endif
+#endif
+
+#if !HAVE_DECL_ISINF
+#ifndef HAVE_ISINF
+#if defined(HAVE_FINITE) && (HAVE_DECL_ISNAN || defined (HAVE_ISNAN))
+#define isinf(x) (!finite(x) && !isnan(x))
+#else
+#ifdef HAVE_IEEEFP_H
+extern int isinf(double);
+#endif
+#endif
+#else  /* HAVE_ISINF */
+extern int isinf(double);
+#endif /* HAVE_ISINF */
+#endif /* HAVE_DECL_ISINF */
 
 #endif /* MISSING_MATH_H_INCLUDED */
--- ng-spice-rework/src/include/ngspice.h:1.26	Sat Nov 29 20:21:56 2008
+++ ng-spice-rework/src/include/ngspice.h	Sun Jan  4 13:23:58 2009
@@ -31,6 +31,10 @@
 #include <math.h>
 #include <stdio.h>
 
+#ifdef HAVE_IEEEFP_H
+#include <ieeefp.h>
+#endif
+
 #include "missing_math.h"
 
 #ifdef STDC_HEADERS
--- ng-spice-rework/src/include/sim.h:1.2	Mon May  9 20:20:18 2005
+++ ng-spice-rework/src/include/sim.h	Fri Jan 16 14:31:07 2009
@@ -15,7 +15,10 @@
   SV_ZERO,
   SV_SPARAM,
   SV_TEMP,
-  SV_RES
+  SV_RES,
+  SV_IMPEDANCE,	//Añadido por A.Roldán
+  SV_ADMITANCE,	//Añadido por A.Roldán
+  SV_POWER	    //Añadido por A.Roldán
 };
 
 #endif
--- ng-spice-rework/src/include/wstdio.h:1.6	Sat Oct  4 22:44:52 2008
+++ ng-spice-rework/src/include/wstdio.h	Wed Jan 14 20:44:09 2009
@@ -1,7 +1,7 @@
 /* I/O Redirection for Spice 3F4 under Win32s
 	Autor: Wolfgang Muees
 	Stand: 21.05.95
-  $Id: wstdio.h,v 1.6 2008/10/04 22:44:52 h_vogt Exp $
+  $Id: wstdio.h,v 1.7 2009/01/14 20:44:09 dwarning Exp $
 */
 
 #ifndef WSTDIO_H
@@ -44,10 +44,13 @@
 int    vp_r_i_n_t_f(const char * __format, void * __arglist);
 /*int   vs_c_a_n_f(const char * __format, void * __arglist); */
 #ifdef _MSC_VER 
+#if _MSC_VER < 1500
+/* VC++ 6.0, VC++ 2005 */
+_CRTIMP int __cdecl read(int fd,  void * __buf, unsigned int __n);
+#else
 /* VC++ 2008 */
 _CRTIMP int __cdecl read(int fd, _Out_bytecap_(_MaxCharCount) void * __buf, _In_ unsigned int __n);
-/* VC++ 2005 */
-//_CRTIMP int __cdecl read(int fd,  void * __buf, unsigned int __n);
+#endif
 #else
 int    r_e_a_d(int fd, char * __buf, int __n);
 #endif
--- ng-spice-rework/src/maths/cmaths/Makefile.am:1.10	Wed Aug 27 13:39:29 2008
+++ ng-spice-rework/src/maths/cmaths/Makefile.am	Wed Dec 31 14:42:49 2008
@@ -14,7 +14,8 @@
 		cmath4.h
 
 ## Test programs fail to build on Windows
-if !WINDOWS 
+if !WINDOWS
+if !TCLWIN 
 
 noinst_PROGRAMS = test_cx_mag test_cx_j test_cx_ph
  
@@ -44,6 +45,7 @@
 
 TESTS = test_cx_mag test_cx_j test_cx_ph
 
+endif !TCLWIN
 endif !WINDOWS
 
 
--- ng-spice-rework/src/maths/cmaths/cmath2.c:1.8	Sat Nov 29 20:21:56 2008
+++ ng-spice-rework/src/maths/cmaths/cmath2.c	Thu Jan 15 21:08:09 2009
@@ -244,6 +244,51 @@
   }
 }
 
+/* Compute the avg of a vector.
+   Created by A.M.Roldan 2005-05-21  */
+   
+void 
+*cx_avg(void *data, short int type, int length, int *newlength, short int *newtype, ...)
+{
+    complex *c;
+    double *d, sum_real = 0.0,sum_imag = 0.0;
+    complex *cc = (complex *) data;
+    double *dd = (double *) data;
+    int i;
+
+    if (type == VF_REAL) {
+        d = alloc_d(length);
+        *newtype = VF_REAL;
+    } else {
+        c = alloc_c(length);
+        *newtype = VF_COMPLEX;
+    }
+    *newlength = length;
+
+    if (type == VF_COMPLEX)
+    {
+       for (i = 0; i < length; i++)
+       {
+        sum_real= sum_real + realpart(&cc[i]);
+        realpart(&c[i]) = sum_real / (double)(i+1);
+
+        sum_imag = sum_imag + imagpart(&cc[i]);
+        imagpart(&c[i]) = sum_imag / (double)(i+1);
+       }
+       return ((char *) c);
+    }
+    else
+    {      //VF_REAL
+       for (i = 0; i < length; i++)
+       {
+        sum_real= sum_real + dd[i];
+        d[i] = sum_real / (double)(i+1);
+       }
+       return ((char *) d);
+    }
+}
+
+
 /* Compute the mean of a vector. */
 
 void *
--- ng-spice-rework/src/maths/cmaths/cmath4.c:1.7	Fri Dec 26 11:03:25 2003
+++ ng-spice-rework/src/maths/cmaths/cmath4.c	Thu Jan 15 21:08:09 2009
@@ -28,7 +28,10 @@
 #include "cmath.h"
 #include "cmath4.h"
 
+#include "sim.h" /* To get SV_TIME */
+
 #include "../../frontend/variable.h" /* for VT_NUM in cx_interpolate */
+extern bool cx_degrees;
 
 void *
 cx_and(void *data1, void *data2, short int datatype1, short int datatype2, int length)
@@ -262,67 +265,75 @@
 	scale = alloc_d(length);	/* XXX */
 	if (pl->pl_scale->v_type == VF_COMPLEX)
 	    /* Not ideal */
+	  for (i = 0; i < length; i++)
+		   scale[i] = realpart(&pl->pl_scale->v_compdata[i]);
+	 else
 	    for (i = 0; i < length; i++)
-		scale[i] = realpart(&pl->pl_scale->v_compdata[i]);
-	else
-	    for (i = 0; i < length; i++)
-		scale[i] = pl->pl_scale->v_realdata[i];
-	for (base = 0; base < length; base += grouping) {
+		   scale[i] = pl->pl_scale->v_realdata[i];
+
+	 for (base = 0; base < length; base += grouping)
+    {
 	    k = 0;
-	    for (i = degree; i < grouping; i += 1) {
+	    for (i = degree; i < grouping; i += 1)
+       {
 
-		/* real */
-		for (j = 0; j < n; j++)
+		  /* real */
+		  for (j = 0; j < n; j++)
 		    spare[j] = c_indata[j + i + base].cx_real;
-		if (!ft_polyfit(scale + i + base - degree,
+		  if (!ft_polyfit(scale + i + base - degree,
 		    spare, r_coefs, degree, scratch))
-		{
+		   {
 		    fprintf(stderr, "ft_polyfit @ %d failed\n", i);
-		}
-		ft_polyderiv(r_coefs, degree);
+		   }
+		  ft_polyderiv(r_coefs, degree);
 
-		/* for loop gets the beginning part */
-		for (j = k; j <= i - degree / 2; j++) {
+		  /* for loop gets the beginning part */
+		  for (j = k; j <= i + degree / 2; j++)
+        {
 		    x = scale[j + base];
 		    c_outdata[j + base].cx_real =
 			ft_peval(x, r_coefs, degree - 1);
-		}
+		  }
 
-		/* imag */
-		for (j = 0; j < n; j++)
+		  /* imag */
+		  for (j = 0; j < n; j++)
 		    spare[j] = c_indata[j + i + base].cx_imag;
-		if (!ft_polyfit(scale + i - degree + base,
+		  if (!ft_polyfit(scale + i - degree + base,
 		    spare, i_coefs, degree, scratch))
-		{
+		  {
 		    fprintf(stderr, "ft_polyfit @ %d failed\n", i);
-		}
-		ft_polyderiv(i_coefs, degree);
+		  }
+		  ft_polyderiv(i_coefs, degree);
 
-		/* for loop gets the beginning part */
-		for (j = k; j <= i - degree / 2; j++) {
+		  /* for loop gets the beginning part */
+        for (j = k; j <= i - degree / 2; j++)
+        {
 		    x = scale[j + base];
 		    c_outdata[j + base].cx_imag =
-			ft_peval(x, i_coefs, degree - 1);
-		}
-		k = j;
-	    }
+		    ft_peval(x, i_coefs, degree - 1);
+		  }
+		 k = j;
+	   }
 
 	    /* get the tail */
-	    for (j = k; j < length; j++) {
-		x = scale[j + base];
-		/* real */
-		c_outdata[j + base].cx_real = ft_peval(x, r_coefs, degree - 1);
-		/* imag */
-		c_outdata[j + base].cx_imag = ft_peval(x, i_coefs, degree - 1);
+	    for (j = k; j < length; j++)
+       {
+		  x = scale[j + base];
+		  /* real */
+		  c_outdata[j + base].cx_real = ft_peval(x, r_coefs, degree - 1);
+		  /* imag */
+		  c_outdata[j + base].cx_imag = ft_peval(x, i_coefs, degree - 1);
 	    }
-	}
+    }
 
 	tfree(r_coefs);
 	tfree(i_coefs);
 	tfree(scale);
 	return (void *) c_outdata;
 
-    } else {
+  }
+  else
+  {
 	/* all-real case */
 	double *coefs;
 
@@ -333,36 +344,155 @@
 	indata = (double *) data;
 	outdata = alloc_d(length);
 	scale = alloc_d(length);	/* XXX */
-	for (i = 0; i < length; i++)
-	    scale[i] = pl->pl_scale->v_realdata[i];
-	for (base = 0; base < length; base += grouping) {
+
+   /* Here I encountered a problem because when we issue an instruction like this:
+    * plot -deriv(vp(3)) to calculate something similar to the group delay, the code
+    * detects that vector vp(3) is real and it is believed that the frequency is also 
+    * real. The frequency is COMPLEX and the program aborts so I'm going to put the 
+    * check that the frequency is complex vector not to abort.
+    */
+
+
+   /* Original problematic code
+	* for (i = 0; i < length; i++)
+	*    scale[i] = pl->pl_scale->v_realdata[i];
+    */
+
+   /* Modified to deal with complex frequency vector */
+   if (pl->pl_scale->v_type == VF_COMPLEX)
+	  for (i = 0; i < length; i++)
+		   scale[i] = realpart(&pl->pl_scale->v_compdata[i]);
+	else
+	    for (i = 0; i < length; i++)
+		   scale[i] = pl->pl_scale->v_realdata[i];
+
+
+
+	for (base = 0; base < length; base += grouping)
+   {
 	    k = 0;
-	    for (i = degree; i < grouping; i += 1) {
-		if (!ft_polyfit(scale + i - degree + base,
+	    for (i = degree; i < grouping; i += 1)
+       {
+		  if (!ft_polyfit(scale + i - degree + base,
 		    indata + i - degree + base, coefs, degree, scratch))
-		{
+		   {
 		    fprintf(stderr, "ft_polyfit @ %d failed\n", i + base);
-		}
-		ft_polyderiv(coefs, degree);
+	    	}
+        ft_polyderiv(coefs, degree);
+
+		  /* for loop gets the beginning part */
+		  for (j = k; j <= i - degree / 2; j++)
+        {
+          /* Seems the same problem because the frequency vector is complex
+           * and the real part of the complex should be accessed because if we 
+           * run x = pl-> pl_scale-> v_realdata [base + j]; the execution will 
+           * abort.
+           */
+
+          if (pl->pl_scale->v_type == VF_COMPLEX)
+            x = realpart(&pl->pl_scale->v_compdata[j+base]);  /* For complex scale vector */
+          else
+            x = pl->pl_scale->v_realdata[j + base];           /* For real scale vector */
 
-		/* for loop gets the beginning part */
-		for (j = k; j <= i - degree / 2; j++) {
-		    x = pl->pl_scale->v_realdata[j + base];
 		    outdata[j + base] = ft_peval(x, coefs, degree - 1);
-		}
-		k = j;
+		  }
+	    	k = j;
 	    }
 
-	    for (j = k; j < length; j++) {
-		    x = pl->pl_scale->v_realdata[j + base];
+	    for (j = k; j < length; j++)
+       {
+          /* Again the same error */
+		  /* x = pl->pl_scale->v_realdata[j + base]; */
+          if (pl->pl_scale->v_type == VF_COMPLEX)
+            x = realpart(&pl->pl_scale->v_compdata[j+base]);  /* For complex scale vector */
+          else
+            x = pl->pl_scale->v_realdata[j + base];           /* For real scale vector */
+
 		    outdata[j + base] = ft_peval(x, coefs, degree - 1);
 	    }
-        }
+   }
 
 
 	tfree(coefs);
 	tfree(scale);	/* XXX */
-	return (void *) outdata;
+	return (char *) outdata;
+ }
+
+}
+
+
+void *
+cx_group_delay(void *data, short int type, int length, int *newlength, short int *newtype, struct plot *pl, struct plot *newpl, int grouping)
+{
+    complex *cc = (complex *) data;
+    double *v_phase = alloc_d(length);
+    double *datos,adjust_final;
+    double *group_delay = alloc_d(length);
+    int i;
+    /* char *datos_aux; */
+
+    /* Check to see if we have the frequency vector for the derivative */
+    if (!eq(pl->pl_scale->v_name, "frequency"))
+    {
+      fprintf(cp_err, "Internal error: cx_group_delay: need frequency based complex vector.\n");
+      return (NULL);
+    }
+
+
+    if (type == VF_COMPLEX)
+     for (i = 0; i < length; i++)
+     {
+      v_phase[i] = radtodeg(cph(&cc[i]));
+     }
+    else
+    {
+      fprintf(cp_err, "Signal must be complex to calculate group delay\n");
+      return (NULL);
+    }
+
+
+    type = VF_REAL;
+
+    /* datos_aux = (char *)cx_deriv((char *)v_phase, type, length, newlength, newtype, pl, newpl, grouping);
+     * datos = (double *) datos_aux;
+     */
+    datos = (double *)cx_deriv((char *)v_phase, type, length, newlength, newtype, pl, newpl, grouping);
+    
+    /* With this global variable I will change how to obtain the group delay because
+     * it is defined as:
+     *
+     *  gd()=-dphase[rad]/dw[rad/s]
+     *
+     * if you have degrees in phase and frequency in Hz, must be taken into account
+     *
+     *  gd()=-dphase[deg]/df[Hz]/360
+     *  gd()=-dphase[rad]/df[Hz]/(2*pi)
+     */
+
+    if(cx_degrees)
+     {
+       adjust_final=1.0/360;
+     }
+     else
+     {
+       adjust_final=1.0/(2*M_PI);
+     }
+
+
+    for (i = 0; i < length; i++)
+    {
+     group_delay[i] = -datos[i]*adjust_final;
     }
 
+    /* Adjust to Real because the result is Real */
+    *newtype = VF_REAL;
+
+    	
+    /* Set the type of Vector to "Time" because the speed of group units' s'
+     * The different types of vectors are INCLUDE \ Fte_cons.h
+     */
+    pl->pl_dvecs->v_type= SV_TIME;
+
+   return ((char *) group_delay);
+
 }
--- ng-spice-rework/src/maths/cmaths/cmath4.h:1.1.1.1	Thu Apr 27 20:04:01 2000
+++ ng-spice-rework/src/maths/cmaths/cmath4.h	Thu Jan 15 21:08:09 2009
@@ -13,6 +13,8 @@
 		      short int *newtype, struct plot *pl, struct plot *newpl, int grouping);
 void * cx_deriv(void *data, short int type, int length, int *newlength, short int *newtype, 
 		struct plot *pl, struct plot *newpl, int grouping);
+void * cx_group_delay(void *data, short int type, int length, int *newlength, short int *newtype, 
+		struct plot *pl, struct plot *newpl, int grouping);
 
 
 #endif
--- ng-spice-rework/src/maths/misc/Makefile.am:1.7	Sat Nov 29 20:21:56 2008
+++ ng-spice-rework/src/maths/misc/Makefile.am	Sun Jan  4 11:17:42 2009
@@ -9,6 +9,7 @@
 	bernoull.c 	\
 	erfc.c		\
 	equality.c	\
+	isinf.c		\
 	isnan.c		\
 	logb.c		\
 	scalb.c		\
--- /dev/null	Sat Jan 31 22:22:28 2009
+++ ng-spice-rework/src/maths/misc/isinf.c	Mon Jan  5 21:31:45 2009
@@ -0,0 +1,31 @@
+#include "ngspice.h"
+
+#if !HAVE_DECL_ISINF
+#ifndef HAVE_ISINF
+#ifdef HAVE_IEEEFP_H
+
+int isinf(double x) { return !finite(x) && x==x; }
+
+#else /* HAVE_IEEEFP_H */
+
+/* this is really ugly - but it is a emergency case */
+
+static int
+isinf (const double x)
+{
+  double y = x - x;
+  int s = (y != y);
+
+  if (s && x > 0)
+    return +1;
+  else if (s && x < 0)
+    return -1;
+  else
+    return 0;
+}
+
+#endif /* HAVE_IEEEFP_H */
+#else /* HAVE_ISINF */
+int Dummy_Symbol_5;
+#endif /* HAVE_ISINF */
+#endif /* HAVE_DECL_ISINF */
--- ng-spice-rework/src/maths/misc/isnan.c:1.1	Sun May 11 20:33:47 2008
+++ ng-spice-rework/src/maths/misc/isnan.c	Mon Jan  5 21:31:45 2009
@@ -1,48 +1,45 @@
-/**********
-Copyright 1991 Regents of the University of California.  All rights reserved.
-**********/
-
 #include "ngspice.h"
 
+#if !HAVE_DECL_ISNAN
 #ifndef HAVE_ISNAN
 
 /* isnan (originally) for SOI devices in MINGW32  hvogt (dev.c) */
 union ieee754_double
 {
-	double d;
-	
-	/* This is the IEEE 754 double-precision format.  */
-	struct
-	{
+  double d;
+  
+  /* This is the IEEE 754 double-precision format.  */
+  struct
+  {
     /* Together these comprise the mantissa.  */
     unsigned int mantissa1:32;
     unsigned int mantissa0:20;
     unsigned int exponent:11;
     unsigned int negative:1;
-	} ieee;
-	struct
-	{
+  } ieee;
+  struct
+  {
     /* Together these comprise the mantissa.  */
     unsigned int mantissa1:32;
     unsigned int mantissa0:19;
     unsigned int quiet_nan:1;
     unsigned int exponent:11;
     unsigned int negative:1;
-	} ieee_nan;
+  } ieee_nan;
 };
 
 int
 isnan(double value)
 {
   union ieee754_double u;
-	
+
   u.d = value;
-	
+
   /* IEEE 754 NaN's have the maximum possible
-		exponent and a nonzero mantissa.  */
+                exponent and a nonzero mantissa.  */
   return ((u.ieee.exponent & 0x7ff) == 0x7ff &&
           (u.ieee.mantissa0 != 0 || u.ieee.mantissa1 != 0));
-	
+
 }
 
 /*
@@ -51,3 +48,4 @@
 #else /* HAVE_ISNAN */
 int Dummy_Symbol_4;
 #endif /* HAVE_ISNAN */
+#endif /* HAVE_DECL_ISNAN */
--- ng-spice-rework/src/maths/sparse/spsmp.c:1.6	Wed Nov 19 19:57:27 2008
+++ ng-spice-rework/src/maths/sparse/spsmp.c	Sun Dec  7 10:08:11 2008
@@ -101,10 +101,10 @@
 #include <spmatrix.h>
 #include "spdefs.h"
 #include <smpdefs.h>
-
-#if defined (_MSC_VER)
-extern double scalbn(double, int);
-#endif
+
+#if defined (_MSC_VER)
+extern double scalbn(double, int);
+#endif
 
 static void LoadGmin(SMPmatrix *eMatrix, double Gmin);
 
--- ng-spice-rework/src/misc/alloc.c:1.6	Wed Aug 27 13:39:30 2008
+++ ng-spice-rework/src/misc/alloc.c	Sun Jan 18 12:09:57 2009
@@ -1,22 +1,26 @@
 /**********
 Copyright 1990 Regents of the University of California.  All rights reserved.
-$Id: alloc.c,v 1.6 2008/08/27 13:39:30 pnenzi Exp $
+$Id: alloc.c,v 1.10 2009/01/18 12:09:57 h_vogt Exp $
 **********/
 
 /*
  * Memory alloction functions
  */
-#include <config.h>
+#include "ngspice.h"
 
 #ifndef HAVE_LIBGC
-#include <ngspice.h>
-#include <stdio.h>
-#include <memory.h>
 
 /*saj For Tcl module locking*/
 #ifdef TCL_MODULE
 #include <tcl.h>
-//#include <tclDecls.h>
+#endif
+
+#if defined(HAS_WINDOWS) || defined(HAS_TCLWIN)
+#if defined(_MSC_VER) || defined(__MINGW32__)
+#undef BOOLEAN
+#include <windows.h>
+extern HANDLE outheap;
+#endif
 #endif
 
 /* Malloc num bytes and initialize to zero. Fatal error if the space can't
@@ -52,43 +56,6 @@
     return(s);
 }
 
-void *
-trealloc(void *ptr, size_t num)
-{
-  void *s;
-/*saj*/
-#ifdef TCL_MODULE
-  Tcl_Mutex *alloc;
-  alloc = Tcl_GetAllocMutex();
-#endif
-  if (!num) {
-    if (ptr)
-      free(ptr);
-    return NULL;
-  }
-
-  if (!ptr)
-    s = tmalloc(num);
-  else {
-/*saj*/
-#ifdef TCL_MODULE
-    Tcl_MutexLock(alloc);
-#endif
-    s = realloc(ptr, num);
-/*saj*/
-#ifdef TCL_MODULE
-  Tcl_MutexUnlock(alloc);
-#endif
-  }
-  if (!s) {
-    fprintf(stderr,"realloc: Internal Error: can't allocate %ld bytes.\n",(long)num);
-    exit(EXIT_BAD);
-  }
-  return(s);
-}
-
-
-
 /* Original Berkeley Implementation */
 /*
 void *
@@ -137,6 +104,84 @@
 
 */
 
+void *
+trealloc(void *ptr, size_t num)
+{
+  void *s;
+/*saj*/
+#ifdef TCL_MODULE
+  Tcl_Mutex *alloc;
+  alloc = Tcl_GetAllocMutex();
+#endif
+  if (!num) {
+    if (ptr)
+      free(ptr);
+    return NULL;
+  }
+
+  if (!ptr)
+    s = tmalloc(num);
+  else {
+/*saj*/
+#ifdef TCL_MODULE
+    Tcl_MutexLock(alloc);
+#endif
+    s = realloc(ptr, num);
+/*saj*/
+#ifdef TCL_MODULE
+  Tcl_MutexUnlock(alloc);
+#endif
+  }
+  if (!s) {
+    fprintf(stderr,"realloc: Internal Error: can't allocate %ld bytes.\n", (long)num);
+    exit(EXIT_BAD);
+  }
+  return(s);
+}
+
+/* realloc using the output heap. 
+   Function is used in outitf.c to prevent heap fragmentation 
+   An additional heap outheap is used to store the plot output data.
+*/
+#if defined(HAS_WINDOWS) || defined(HAS_TCLWIN)
+#if defined(_MSC_VER) || defined(__MINGW32__)
+void *
+hrealloc(void *ptr, size_t num)
+{
+  void *s;
+/*saj*/
+#ifdef TCL_MODULE
+  Tcl_Mutex *alloc;
+  alloc = Tcl_GetAllocMutex();
+#endif
+  if (!num) {
+    if (ptr)
+      free(ptr);
+    return NULL;
+  }
+
+  if (!ptr)
+    s = HeapAlloc(outheap, HEAP_ZERO_MEMORY, num);
+  else {
+/*saj*/
+#ifdef TCL_MODULE
+    Tcl_MutexLock(alloc);
+#endif
+   s = HeapReAlloc(outheap, HEAP_ZERO_MEMORY, ptr, num);
+/*saj*/
+#ifdef TCL_MODULE
+  Tcl_MutexUnlock(alloc);
+#endif
+  }
+  if (!s) {
+    fprintf(stderr,"HeapReAlloc: Internal Error: can't allocate %ld bytes.\n", (long)num);
+    exit(EXIT_BAD);
+  }
+  return(s);
+}
+#endif
+#endif
+
 
 void
 txfree(void *ptr)
--- ng-spice-rework/src/spicelib/analysis/cktdojob.c:1.10	Tue Oct  9 07:19:55 2007
+++ ng-spice-rework/src/spicelib/analysis/cktdojob.c	Tue Dec 23 18:00:10 2008
@@ -93,7 +93,7 @@
     ckt->CKTlteAbstol = task->TSKlteAbstol;
 #endif /* NEWTRUNC */
 
-printf("Doing analysis at TEMP = %f and TNOM = %f\n\n", 
+fprintf(stdout, "Doing analysis at TEMP = %f and TNOM = %f\n\n", 
         ckt->CKTtemp - CONSTCtoK, ckt->CKTnomTemp - CONSTCtoK);
     error = 0;
 
--- ng-spice-rework/src/spicelib/analysis/dctran.c:1.15	Wed Jan  2 18:52:04 2008
+++ ng-spice-rework/src/spicelib/analysis/dctran.c	Wed Dec 31 14:42:49 2008
@@ -324,9 +324,16 @@
         if(ckt->CKTminBreak==0) ckt->CKTminBreak=ckt->CKTmaxStep*5e-5;
         firsttime=0;
 	/* To get rawfile working saj*/
+        /* get namelist again */
+		error = CKTnames(ckt,&numNames,&nameList);
+        if(error) return(error);
+		/* get timeUiD again */
+        (*(SPfrontEnd->IFnewUid))((void *)ckt,&timeUid,(IFuid)NULL,
+                "time", UID_OTHER, (void **)NULL);        
 	error = (*(SPfrontEnd->OUTpBeginPlot))((void *)ckt, (void*)ckt->CKTcurJob,
 					       ckt->CKTcurJob->JOBname,timeUid,IF_REAL,666,nameList,
 					       666,&(((TRANan*)ckt->CKTcurJob)->TRANplot));/*magic 666 nums as flags */
+	tfree(nameList);
 	if(error) {
 	  fprintf(stderr, "Couldn't relink rawfile\n");
 	  return error;
--- ng-spice-rework/src/spicelib/devices/adms/admst/ngspiceMODULEdefs.h.xml:1.14	Mon Jul 23 17:24:14 2007
+++ ng-spice-rework/src/spicelib/devices/adms/admst/ngspiceMODULEdefs.h.xml	Thu Jan  1 20:48:48 2009
@@ -1,8 +1,11 @@
 <?xml version="1.0" encoding="ISO-8859-1"?>
 
 <!--
-  $Id: ngspiceMODULEdefs.h.xml,v 1.14 2007/07/23 17:24:14 dwarning Exp $
+  $Id: ngspiceMODULEdefs.h.xml,v 1.15 2009/01/01 20:48:48 dwarning Exp $
   $Log: ngspiceMODULEdefs.h.xml,v $
+  Revision 1.15  2009/01/01 20:48:48  dwarning
+  some cc needs double for isinf macro
+
   Revision 1.14  2007/07/23 17:24:14  dwarning
   unique limexp behaviour
 
@@ -132,14 +135,14 @@
 #endif
 
 #define EXIT_IF_ISNAN(var) \\
-if(isnan(var)) \\
+if(isnan((double) var)) \\
 { \\
   printf(&quot;%%s:%%i:bug:isnan:&quot;#var&quot;\\n&quot;,__FILE__,__LINE__); \\
   printf(&quot;Please send this message to laurent.lemaitre@freescale.com\\n&quot;); \\
   NGSPICE_DEBUG \\
   exit(1); /*__asm__ __volatile__ (&quot;int \$03&quot;);*/ \\
 } \\
-if(isinf(var)) \\
+if(isinf((double) var)) \\
 { \\
   printf(&quot;%%s:%%i:bug:isinf:&quot;#var&quot;\\n&quot;,__FILE__,__LINE__); \\
   printf(&quot;Please send this message to laurent.lemaitre@freescale.com\\n&quot;); \\
--- ng-spice-rework/src/spicelib/devices/adms/admst/ngspiceMakefile.am.xml:1.13	Sun Aug 24 17:12:59 2008
+++ ng-spice-rework/src/spicelib/devices/adms/admst/ngspiceMakefile.am.xml	Mon Dec 22 08:16:59 2008
@@ -1,8 +1,11 @@
 <?xml version="1.0" encoding="ISO-8859-1"?>
 
 <!--
-  $Id: ngspiceMakefile.am.xml,v 1.13 2008/08/24 17:12:59 pnenzi Exp $
+  $Id: ngspiceMakefile.am.xml,v 1.14 2008/12/22 08:16:59 dwarning Exp $
   $Log: ngspiceMakefile.am.xml,v $
+  Revision 1.14  2008/12/22 08:16:59  dwarning
+  switch to libtool
+
   Revision 1.13  2008/08/24 17:12:59  pnenzi
 
   Updated to new automake standard. Replaced all INCLUDES with AM_CPPFLAGS
@@ -110,9 +113,9 @@
 	-e \$(ADMSXMLINTERFACE)/ngspiceMODULE.c.xml
 	perl -p -i.bak -e 's/IOP\\("(\\w+)"/IOP("\\L\\1"/' $(module).c
 
-noinst_LIBRARIES = lib$(module).a
+noinst_LTLIBRARIES = lib$(module).la
 
-lib$(module)_a_SOURCES = 	\\
+lib$(module)_la_SOURCES = 	\\
 	$(module).c		\\
 	$(module).hxx		\\
 	$(module)acld.c	\\
--- ng-spice-rework/src/spicelib/devices/adms/ekv/admsva/ekv.va:1.1	Tue May  8 19:33:40 2007
+++ ng-spice-rework/src/spicelib/devices/adms/ekv/admsva/ekv.va	Sun Jan  4 11:21:26 2009
@@ -1,110 +1,661 @@
+// EPFL-EKV version 2.6: A Verilog-A description.
+// The intrinsic device is coded according to the official manual
+// (revision II) available at http://legwww.epfl.ch/ekv.
+// contribution of Ivan Riis Nielsen 11/2006, modified by Dietmar Warning 01/2009
 
-//`include "std.va" 
-//`include "const.va" 
-//Spice
-`include "constants.h"
-`include "discipline.h"
+//Default simulator: Spectre
 
 `ifdef insideADMS
- `define P(p) (*p*)
- `define PGIVEN(p)		$given(p)
- `define INITIAL_MODEL		@(initial_model)
+  `define P(txt) (*txt*)
+  `define PGIVEN(p)	$given(p)
+  `define INITIAL_MODEL	@(initial_model)
+  `define INSTANCE	@(initial_instance)
+  `define NOISE 	@(noise)
 `else
- `define P(p)
- `define PGIVEN(p)		p
- `define INITIAL_MODEL		@(initial_step)
+  `define P(txt) (txt)
+  `define PGIVEN(p) 	p
+  `define INITIAL_MODEL
+  `define INSTANCE
+  `define NOISE
 `endif
 
-//dw
-`define TMAX		326.85
-`define TMIN		-100.0
-
-
-// **************************************************************** 
-// * EKV MOS model (long channel) based on version 2.6 rev.15 
-// * Function name : ekv26_dc_long for verilog-a implementation 
-// * The model documetation: http://legwww.epfl.ch/ekv 
-// **************************************************************** 
-
-module ekv(d,g,s,b); 
-// 
-// Node definitions 
-// 
-        inout           d,g,s,b ;   // external nodes 
-        electrical      d,g,s,b ;   // external nodes 
-
-
-//dw 
-real VT,Tamb,Tdev,Tnom,dT;
-parameter real tnom	= 27	`P(spice:name="tnom" info="Temperature for which parameters are valid" unit="C");
-parameter real dt	= 0.0	`P(spice:name="dt" type="instance" info="Temperature change for particular transistor" unit="K");                   
-
-// 
-//*** Local variables 
-// 
-real x, VG, VS, VD, VGprime, VP; 
-real beta, n, iff, ir, Ispec, Id; 
-// 
-//*** model parameter definitions 
-// 
-parameter real L      =  10E-6  from[0.0:inf]; 
-parameter real W      =  10E-6  from[0.0:inf]; 
-
-//***  Threshold voltage 
-//     substrate effect parameters (long-channel) 
-parameter real VTO    =  0.5    from[0.0:inf]; 
-parameter real GAMMA  =  0.7    from[0.0:inf]; 
-parameter real PHI    =  0.5    from[0.2:inf]; 
-
-//***  Mobility parameters (long-channel) 
-parameter real KP     =  20E-6   from[0.0:inf]; 
-parameter real THETA  =  50.0E-3 from[0.0:inf]; 
-
-analog begin // EKV v2.6 long-channel 
-
-//dw 
-Tnom	= tnom+273.15;
-Tamb	= $temperature;
-Tdev	= Tamb+dt;   // selfheating instead dT later possible
-// Limit temperature to avoid FPE's in equations
-if(Tdev < `TMIN + 273.15)
-   Tdev = `TMIN + 273.15;
-else
-if (Tdev > `TMAX + 273.15)
-   Tdev = `TMAX + 273.15;
-
-VT      = `P_K*Tdev /`P_Q;
-
-
-VG = V(g); VS = V(s); VD = V(d); 
-
-// Effective gate voltage (33) 
-VGprime = VG - VTO + PHI + GAMMA * sqrt(PHI); 
-
-// Pinch-off voltage (34) 
-VP = VGprime - PHI - GAMMA 
-   * (sqrt(VGprime+(GAMMA/2.0)*(GAMMA/2.0))-(GAMMA/2.0)); 
-
-// Slope factor (39) 
-n = 1.0 + GAMMA / (2.0*sqrt(PHI + VP + 4.0*VT)); 
-
-// Mobility equation (58), (64) 
-beta = KP * (W/L) * (1.0/(1.0 + THETA * VP)); 
-
-// forward (44) and reverse (56) currents 
-x=(VP-VS)/VT; iff = (ln(1.0+exp( x /2.0)))*(ln(1.0+exp( x /2.0))); 
-x=(VP-VD)/VT; ir  = (ln(1.0+exp( x /2.0)))*(ln(1.0+exp( x /2.0))); 
-
-// Specific current (65) 
-Ispec = 2 * n * beta * VT * VT; 
-
-// Drain current (66) 
-Id = Ispec * (iff - ir); 
-
-// 
-// Branch contributions to EKV v2.6 model (long-channel) 
-// 
-I(d,s) <+ Id; 
+//ADS
+//`include "constants.vams"
+//`include "disciplines.vams"
+//`include "compact.vams"
+
+//Spectre
+`include "constants.h"
+`include "discipline.h"
+
+`define NMOS 1
+`define PMOS -1
+
+`define EPSSI `P_EPS0*11.7
+`define EPSOX `P_EPS0*3.9
+`define TREF 300.15
+
+`define SQR(x) ((x)*(x))
+
+`define VT(temp) (`P_K*temp/`P_Q)
+`define EG(temp) (1.16-0.000702*`SQR(temp)/(temp+1108))
+`define NI(temp) (1.45e16*(temp/`TREF)*exp(`EG(`TREF)/(2*`VT(`TREF))-`EG(temp)/(2*`VT(temp))))
+
+
+`define oneThird              3.3333333333333333e-01
+
+// Constants needed in safe exponential function (called "expl")
+`define se05                  2.3025850929940458e+02
+`define ke05                  1.0e-100
+`define ke05inv               1.0e100
+
+//  P3       3rd order polynomial expansion of exp()
+`define P3(u) (1.0 + (u) * (1.0 + 0.5 * ((u) * (1.0 + (u) * `oneThird))))
+
+//  expl     exp() with 3rd order polynomial extrapolation
+//           to avoid overflows and underflows and retain C-3 continuity
+`define expl(x, res) \
+if (abs(x) < `se05) begin\
+    res       = exp(x); \
+end else begin \
+    if ((x) < -`se05) begin\
+        res       = `ke05 / `P3(-`se05 - (x)); \
+    end else begin\
+        res       =  `ke05inv * `P3((x) - `se05); \
+    end \
+end
+
+
+module ekv (d,g,s,b);
+
+   // Node definitions
+
+   inout d,g,s,b;
+   electrical d,g,s,b,di,si;
+
+   // Model parameters
+   
+   parameter integer nmos=1 from [0:1] `P(info="MOS type : nmos:0");
+   parameter integer pmos=1 from [0:1] `P(info="MOS type : pmos:0");
+   parameter integer MTYPE=(nmos==0 ? (pmos==0 ? 0 : 1) : (pmos==0 ? -1 : 1));
+   parameter real TNOM=27 from (-273.15:inf) 
+                  `P(info="Nominal temperature [degC]");
+   parameter real IMAX=1 from (0:inf) 
+                  `P(info="Maximum forward junction current before linearization [A]");
+   
+   // - intrinsic model (optional, section 4.2.1)
+   parameter real TOX=0 from [0:inf) 
+                  `P(info="Oxide thickness [m]");
+   parameter real NSUB=0 from [0:inf)
+                  `P(info="Channel doping [cm^-3]");
+   parameter real VFB=1001.0 from (-inf:inf)        // use 1001V as "not specified"
+                  `P(info="Flat-band voltage [V]");
+   parameter real UO=0 from [0:inf) 
+                  `P(info="Low-field mobility [cm^2/Vs]");
+   parameter real VMAX=0 from [0:inf) 
+                  `P(info="Saturation velocity [m/s]");
+   parameter real THETA=0 from [0:inf) 
+                  `P(info="Mobility reduction coefficient [V^-1]");
+   
+   // - intrinsic model (process related, section 4.1)
+   parameter real COX=((TOX>0) ? (`EPSOX/TOX) : 0.7m) from [0:inf) 
+                  `P(info="Oxide capacitance [F/m^2]");
+   parameter real XJ=0.1u from [1n:inf) 
+                  `P(info="Junction depth [m]");
+   parameter real DL=0    from (-inf:inf) 
+                  `P(info="Length correction [m]");
+   parameter real DW=0    from (-inf:inf) 
+                  `P(info="Width correction [m]");
+   
+   // - intrinsic model (basic, section 4.2)
+   parameter real GAMMA=((NSUB>0) ? (sqrt(2*`P_Q*`EPSSI*NSUB*1e6)/COX) : 1) from [0:inf) 
+                  `P(info="Body effect parameter [V^0.5]");
+   parameter real PHI=((NSUB>0) ? (2*`VT((TNOM+273.15))*ln(max(NSUB,1)*1e6/`NI((TNOM+273.15)))) : 0.7) from [0.1:inf) 
+                  `P(info="Bulk Fermi potential (*2) [V]");
+   parameter real VTO=((VFB<1000.0) ? (VFB+MTYPE*(PHI+GAMMA*sqrt(PHI))) : 0.5) from (-inf:inf) 
+                  `P(info="Long-channel threshold voltage [V]");
+   parameter real KP=((UO>0) ? (UO*1e-4*COX) : 50u) from (0:inf) 
+                  `P(info="Transconductance parameter [A/V^2]");
+   parameter real UCRIT=(((VMAX>0) && (UO>0)) ? (VMAX/(UO*1e-4)) : 2e6 ) from [100k:inf) 
+                  `P(info="Longitudinal critical field [V/m]");
+   parameter real E0=((THETA>0) ? 0 : 1e12) from [100k:inf) 
+                  `P(info="Mobility reduction coefficient [V/m]");
+   
+   // - intrinsic model (channel length modulation and charge sharing, section 4.3)
+   parameter real LAMBDA=0.5 from [0:inf) 
+                  `P(info="Depletion length coefficient (CLM)");
+   parameter real WETA=0.25 from (-inf:inf) 
+                  `P(info="Narrow-channel effect coefficient");
+   parameter real LETA=0.1 from (-inf:inf) 
+                  `P(info="Short-channel effect coefficient");
+   
+   // - intrinsic model (reverse short channel effect, section 4.4)
+   parameter real Q0=0 from (-inf:inf) 
+                  `P(info="RSCE peak charge density [C/m^2]");
+   parameter real LK=0.29u from [10n:inf) 
+                  `P(info="RSCE characteristic length [m]");
+   
+   // - intrinsic model (impact ionization, section 4.5)
+   parameter real IBA=0 from (-inf:inf) 
+                  `P(info="First impact ionization coefficient [m^-1]");
+   parameter real IBB=3e8 from [1e8:inf) 
+                  `P(info="Second impact ionization coefficient [V/m]");
+   parameter real IBN=1 from [0.1:inf) 
+                  `P(info="Saturation voltage factor for impact ionization");
+   
+   // - intrinsic model (temperature, section 4.6)
+   parameter real TCV=1m from (-inf:inf) 
+                  `P(info="Threshold voltage TC [V/K]");
+   parameter real BEX=-1.5 from (-inf:inf)
+                  `P(info="Mobility temperature exponent");
+   parameter real UCEX=0.8 from (-inf:inf) 
+                  `P(info="Longitudinal critical field temperature exponent");
+   parameter real IBBT=9e-4 from (-inf:inf) 
+                  `P(info="Temperature coefficient for IBB [K^-1]");
+   
+   // - intrinsic model (matching, section 4.7)
+   parameter real AVTO=0 from (-inf:inf)
+                  `P(info="Area related VTO mismatch parameter [Vm]");
+   parameter real AKP=0 from (-inf:inf)
+                  `P(info="Area related KP mismatch parameter [m]");
+   parameter real AGAMMA=0 from (-inf:inf) 
+                  `P(info="Area related GAMMA mismatch parameter [V^0.5*m]");
+   
+   // - intrinsic model (flicker noise, section 4.8)
+   parameter real KF=0 from [0:inf)
+                  `P(info="Flicker noise coefficient");
+   parameter real AF=1 from (-inf:inf)
+                  `P(info="Flicker noise exponent");
+   
+   // - intrinsic model (setup, section 4.9)
+   parameter real NQS=0 from [0:1]
+                  `P(info="Non-quasi-static operation switch");
+   parameter real SATLIM=exp(4) from (0:inf) 
+                  `P(info="Saturation limit (if/ir)");
+   parameter real XQC=0.4 from [0:1]
+                  `P(info="Charge/capacitance model selector");
+   
+   // - external parasitic parameters
+   parameter real HDIF=0 from [0:inf) 
+                  `P(info="S/D diffusion length (/2) [m]");
+   parameter real RSH=0 from [0:inf) 
+                  `P(info="S/D sheet resistance [ohm]");
+   parameter real JS=0 from [0:inf) 
+                  `P(info="S/D junction saturation current density [A/m^2]");
+   parameter real JSW=0 from [0:inf) 
+                  `P(info="S/D junction sidewall saturation current density [A/m]");
+   parameter real XTI=0 from [0:inf) 
+                  `P(info="S/D diode saturation current temperature exponent");
+   parameter real N=1 from [0.5:10]
+                  `P(info="S/D diode emission coefficient");
+   parameter real CJ=0 from [0:inf)
+                  `P(info="S/D zero-bias junction capacitance per area [F/m^2]");
+   parameter real CJSW=0 from [0:inf)
+                  `P(info="S/D zero-bias junction capacitance per perimeter [F/m]");
+   parameter real PB=0.8 from (0:inf)
+                  `P(info="S/D bottom junction builtin potential [V]");
+   parameter real PBSW=PB from (0:inf)
+                  `P(info="S/D sidewall junction builtin potential [V]");
+   parameter real MJ=0.5 from (0:inf)
+                  `P(info="S/D bottom junction grading coefficient");
+   parameter real MJSW=0.333 from (0:inf)
+                  `P(info="S/D sidewall junction grading coefficient");
+   parameter real FC=0.5 from (0:inf)
+                  `P(info="S/D bottom junction forward-bias threshold");
+   parameter real FCSW=FC from (0:inf)
+                  `P(info="S/D sidewall junction forward-bias threshold");
+   parameter real CGSO=0 from [0:inf)
+                  `P(info="Gate-source overlap capacitance per width [F/m]");
+   parameter real CGDO=0 from [0:inf)
+                  `P(info="Gate-drain overlap capacitance per width [F/m]");
+   parameter real CGBO=0 from [0:inf)
+                  `P(info="Gate-bulk overlap capacitance per length [F/m]");
+
+
+   // Instance parameters
+
+   // - intrinsic model
+   parameter real L=10u from [0:inf] 
+                  `P(type="instance" info="Drawn length [m]" unit="m");
+   parameter real W=10u from [0:inf] 
+                  `P(type="instance" info="Drawn width [m]" unit="m");
+   parameter real M=1   from [0:inf] 
+                  `P(type="instance" info="Parallel multiplier" unit="m");
+//   parameter real N=1   from [0:inf] 
+//                  `P(type="instance" info="Series multiplier" unit="m");
+
+   // - external parasitics
+   parameter real AD=((HDIF>0) ? (2*HDIF*W) : 0) from [0:inf) 
+                  `P(info="Drain area [m^2]" type="instance");
+   parameter real AS=((HDIF>0) ? (2*HDIF*W) : 0) from [0:inf) 
+                  `P(info="Source area [m^2]" type="instance");
+   parameter real PD=((HDIF>0) ? (4*HDIF+2*W) : 0) from [0:inf) 
+                  `P(info="Drain perimeter [m]" type="instance");
+   parameter real PS=((HDIF>0) ? (4*HDIF+2*W) : 0) from [0:inf) 
+                  `P(info="Source perimeter [m]" type="instance");
+   parameter real NRD=((HDIF>0) ? (HDIF/W) : 0) from [0:inf)
+                  `P(info="Drain no. squares" type="instance");
+   parameter real NRS=((HDIF>0) ? (HDIF/W) : 0) from [0:inf)
+                  `P(info="Source no. squares" type="instance");
+   parameter real RS=((RSH>0) ? (RSH*NRS) : 0) from [0:inf)
+                  `P(info="Source resistance [ohms]" type="instance");
+   parameter real RD=((RSH>0) ? (RSH*NRD) : 0) from [0:inf)
+                  `P(info="Drain resistance [ohms]" type="instance");
+
+
+   // Declaration of variables
+   integer  mode;
+   real     lc,isat_s,vexp_s,gexp_s,isat_d,vexp_d,gexp_d,fact,
+            weff,leff,np,ns,lmin,rd,rs,ceps,ca,xsi,dvrsce,
+            tempk,vt,sqrt_A,vto_a,kp_a,gamma_a,ucrit,phi,ibb,vc,qb0,
+            vg,vd,vs,tmp,vgprime,vp0,vsprime,vdprime,gamma0,gammaprime,vp,n,ifwd,
+            vdss,vdssprime,dv,vds,vip,dl,lprime,leq,irprime,irev,beta0,nau,
+            nq,xf,xr,qd,qs,qi,qb,qg,beta0prime,beta,vpprime,is,ids,vib,
+            idb,ibdj,ibsj,coxt,qdt,qst,qgt,qbt,
+            cbs0,cbs0sw,cbs,cbd0,cbd0sw,cbd,
+            fv,z0,z1,y;
+
+   real     cgso,cgdo,cgbo;
+   
+
+   analog begin
+
+      `INITIAL_MODEL begin      // Model Initialization
+
+         lc = sqrt(`EPSSI/COX*XJ);
+         
+      end // INITIAL_MODEL
+
+      `INSTANCE begin // temperature independent device initialization
+
+         weff = W+DW;
+         leff = L+DL;
+
+         np = M;
+         ns = 1;
+
+         // eq. 54
+         lmin = 0.1*ns*leff;
+         
+         rs = ns/np*RS;
+         rd = ns/np*RD;
+
+         ceps = 4*22e-3*22e-3;
+         ca = 0.028;
+         xsi = ca*(10*leff/LK-1);
+         dvrsce = 2*Q0/COX/`SQR(1+0.5*(xsi+sqrt(xsi*xsi+ceps)));
+
+         coxt = np*ns*COX*weff*leff;
+         
+      end // temperature independent
+      
+      `INSTANCE begin // temperature dependent device initialization
+         tempk = $temperature;
+         vt = `VT(tempk);
+         
+         sqrt_A = sqrt(np*weff*ns*leff);
+         
+         vto_a   = MTYPE*(VTO+TCV*(tempk-(TNOM+273.15)))+AVTO/sqrt_A;
+         kp_a    = KP*pow(tempk/(TNOM+273.15),BEX)*(1+AKP/sqrt_A);
+         gamma_a = GAMMA+AGAMMA/sqrt_A;
+         ucrit   = UCRIT*pow(tempk/(TNOM+273.15),UCEX);
+         phi     = PHI*tempk/(TNOM+273.15)-3*vt*ln(tempk/(TNOM+273.15))-`EG(TNOM+273.15)*tempk/(TNOM+273.15)+`EG(tempk);
+         ibb     = IBB*(1+IBBT*(tempk-(TNOM+273.15)));
+
+         vc = ucrit*ns*leff;
+         
+         // eq. 60
+         qb0 = gamma_a*sqrt(phi);
+
+         fact = (`EG(TNOM+273.15)/`VT(TNOM+273.15)-`EG(tempk)/vt) * pow(tempk/(TNOM+273.15),XTI);
+         `expl(fact,tmp);
+         isat_s = np*ns*(JS*AS+JSW*PS)*tmp;
+         isat_d = np*ns*(JS*AD+JSW*PD)*tmp;
+
+         if (isat_s>0) begin
+            vexp_s = vt*ln(IMAX/isat_s+1);
+            gexp_s = (IMAX+isat_s)/vt;
+         end else begin
+            vexp_s = -1e9;
+            gexp_s = 0;
+         end
+
+         if (isat_d>0) begin
+            vexp_d = vt*ln(IMAX/isat_d+1);
+            gexp_d = (IMAX+isat_d)/vt;
+         end else begin
+            vexp_d = -1e9;
+            gexp_d = 0;
+         end
+         
+         cbs0 = np*ns*CJ*AS;
+         cbd0 = np*ns*CJ*AD;
+         cbs0sw = np*ns*CJSW*PS;
+         cbd0sw = np*ns*CJSW*PD;
+
+         cgso = np*ns*CGSO*weff;
+         cgdo = np*ns*CGDO*weff;
+         cgbo = np*ns*CGBO*leff;
+         
+      end // temperature dependent
+
+      
+      begin     //Bias-dependent model evaluation
+
+         vg = MTYPE*V(g,b);
+         vd = MTYPE*V(di,b);
+         vs = MTYPE*V(si,b);
+         // $strobe("vg=%e vd=%e vs=%e",vg,vd,vs);
+         
+         if (vd>=vs)
+            mode = 1;
+         else begin
+            mode = -1;
+            tmp = vs;
+            vs = vd;
+            vd = tmp;
+         end
+
+         // eq. 33
+         vgprime = vg-vto_a-dvrsce+phi+gamma_a*sqrt(phi);
+         // eq. 35
+         vsprime = 0.5*(vs+phi+sqrt(`SQR(vs+phi)+16*`SQR(vt)));
+         vdprime = 0.5*(vd+phi+sqrt(`SQR(vd+phi)+16*`SQR(vt)));
+         // $strobe("vgprime=%e vdprime=%e vsprime=%e",vgprime,vdprime,vsprime);
+         // eq. 34
+         if (vgprime>=0) begin
+            vp0 = vgprime-phi-gamma_a*(sqrt(vgprime+0.25*`SQR(gamma_a))-0.5*gamma_a);
+            // eq. 36
+            gamma0 = gamma_a-`EPSSI/COX*(LETA/leff*(sqrt(vsprime)+sqrt(vdprime))-3*WETA/weff*sqrt(vp0+phi));
+         end else begin
+            vp0 = -phi;
+            // eq. 36 - skipped sqrt(vp0+phi) here, it produces inf on derivative
+            gamma0 = gamma_a-`EPSSI/COX*(LETA/leff*(sqrt(vsprime)+sqrt(vdprime))  );
+         end
+         // eq. 37
+         gammaprime = 0.5*(gamma0+sqrt(`SQR(gamma0)+0.1*vt));
+         // eq. 38
+         if (vgprime>=0)
+           vp = vgprime-phi-gammaprime*(sqrt(vgprime+0.25*`SQR(gammaprime))-0.5*gammaprime);
+         else
+           vp = -phi;
+         // $strobe("vp0=%e vp=%e gamma0=%e gammaprime=%e",vp0,vp,gamma0,gammaprime);
+         // eq. 39
+         n = 1+gamma_a*0.5/sqrt(vp+phi+4*vt);
+
+	 // Forward  current (43-44)
+   	 fv=(vp-vs)/vt;
+	 
+     	 if (fv > -0.35) begin
+           z0 = 2.0/(1.3 + fv - ln(fv+1.6));
+    	   z1 = (2.0 + z0) / (1.0 + fv + ln(z0));
+	   y = (1.0 + fv + ln(z1)) / (2.0 + z1);
+         end
+    	 else if (fv > -15) begin
+	   `expl(-fv,tmp);
+           z0 = 1.55 + tmp;
+    	   z1 = (2.0 + z0) / (1.0 + fv + ln(z0));
+	   y = (1.0 + fv + ln(z1)) / (2.0 + z1);
+         end 
+         else if (fv > -23.0) begin
+	   `expl(-fv,tmp);
+	   y = 1.0 / (2.0 + tmp);
+         end
+   	 else begin
+ 	   `expl(fv,tmp);
+	   y = tmp + 1.0e-64;
+	 end
+	 
+   	 ifwd = y*(1.0 + y);
+   	 z0  = 1;
+   	 z1  = 1;
+         
+         // eq. 46
+         vdss = vc*(sqrt(0.25+vt/vc*sqrt(ifwd))-0.5);
+         // eq. 47
+         vdssprime = vc*(sqrt(0.25+vt/vc*(sqrt(ifwd)-0.75*ln(ifwd)))-0.5)+vt*(ln(0.5*vc/vt)-0.6);
+         // $strobe("ifwd=%e vdss=%e vdssprime=%e",ifwd,vdss,vdssprime);
+         // eq. 48
+         dv = 4*vt*sqrt(LAMBDA*(sqrt(ifwd)-vdss/vt)+1.0/64);
+         // eq. 49
+         vds = 0.5*(vd-vs);
+         // eq. 50
+         vip = sqrt(`SQR(vdss)+`SQR(dv))-sqrt(`SQR(vds-vdss)+`SQR(dv));
+         // eq. 52
+         dl = LAMBDA*lc*ln(1+(vds-vip)/(lc*ucrit));
+
+         // eq. 53
+         lprime = ns*leff-dl+(vds+vip)/ucrit;
+         // eq. 55
+         leq = 0.5*(lprime+sqrt(`SQR(lprime)+`SQR(lmin)));
+
+         // eq. 56
+   	 fv=(vp-vds-vs-sqrt(`SQR(vdssprime)+`SQR(dv))+sqrt(`SQR(vds-vdssprime)+`SQR(dv)))/vt;
+	 
+     	 if (fv > -0.35) begin
+           z0 = 2.0/(1.3 + fv - ln(fv+1.6));
+    	   z1 = (2.0 + z0) / (1.0 + fv + ln(z0));
+	   y = (1.0 + fv + ln(z1)) / (2.0 + z1);
+         end
+    	 else if (fv > -15) begin
+	   `expl(-fv,tmp);
+           z0 = 1.55 + tmp;
+    	   z1 = (2.0 + z0) / (1.0 + fv + ln(z0));
+	   y = (1.0 + fv + ln(z1)) / (2.0 + z1);
+         end 
+         else if (fv > -23.0) begin
+	   `expl(-fv,tmp);
+	   y = 1.0 / (2.0 + tmp);
+         end
+   	 else begin
+ 	   `expl(fv,tmp);
+	   y = tmp + 1.0e-64;
+	 end
+	 
+   	 irprime = y*(1.0 + y);
+   	 z0  = 1;
+   	 z1  = 1;
+
+         // eq. 57
+   	 fv=(vp-vd)/vt;
+	 
+     	 if (fv > -0.35) begin
+           z0 = 2.0/(1.3 + fv - ln(fv+1.6));
+    	   z1 = (2.0 + z0) / (1.0 + fv + ln(z0));
+	   y = (1.0 + fv + ln(z1)) / (2.0 + z1);
+         end
+    	 else if (fv > -15) begin
+	   `expl(-fv,tmp);
+           z0 = 1.55 + tmp;
+    	   z1 = (2.0 + z0) / (1.0 + fv + ln(z0));
+	   y = (1.0 + fv + ln(z1)) / (2.0 + z1);
+         end 
+         else if (fv > -23.0) begin
+	   `expl(-fv,tmp);
+	   y = 1.0 / (2.0 + tmp);
+         end
+   	 else begin
+ 	   `expl(fv,tmp);
+	   y = tmp + 1.0e-64;
+	 end
+	 
+   	 irev = y*(1.0 + y);
+
+         // eq. 58
+         beta0 = kp_a*np*weff/leq;
+         // eq. 59
+         nau = (5+MTYPE)/12.0;
+
+         // eq. 69
+         nq = 1+0.5*gamma_a/sqrt(vp+phi+1e-6);
+         
+         // eq. 70
+         xf = sqrt(0.25+ifwd);
+         // eq. 71
+         xr = sqrt(0.25+irev);
+         // eq. 72
+         qd = -nq*(4.0/15*(3*`SQR(xr)*(xr+2*xf)+2*`SQR(xf)*(xf+2*xr))/`SQR(xf+xr)-0.5);
+         // eq. 73
+         qs = -nq*(4.0/15*(3*`SQR(xf)*(xf+2*xr)+2*`SQR(xr)*(xr+2*xf))/`SQR(xf+xr)-0.5);
+         // eq. 74
+         qi = qs+qd;
+         // eq. 75
+         if (vgprime>=0)
+           qb = (-gamma_a*sqrt(vp+phi+1e-6))/vt-(nq-1)/nq*qi;
+         else
+           qb = -vgprime/vt;
+         // eq. 76 (qox removed since it is assumed to be zero)
+         qg = -qi-qb;
+
+         if (E0!=0) begin 
+           // eq. 61
+           beta0prime = beta0*(1+COX/(E0*`EPSSI)*qb0);
+           // eq. 62
+           beta = beta0prime/(1+COX/(E0*`EPSSI)*vt*abs(qb+nau*qi));
+         end else begin
+            // eq. 63
+            vpprime = 0.5*(vp+sqrt(`SQR(vp)+2*`SQR(vt)));
+            // eq. 64
+            beta = beta0/(1+THETA*vpprime);
+         end // else: !if(e0!=0)
+         // eq. 65
+         is = 2*n*beta*`SQR(vt);
+         // $strobe("beta0=%e beta0prime=%e beta=%e E0=%e qb0=%e qb=%e qi=%e",beta0,beta0prime,beta,E0,qb0,qb,qi);
+         // eq. 66
+         ids = is*(ifwd-irprime);
+         // eq. 67
+         vib = vd-vs-IBN*2*vdss;
+         // eq. 68
+         if (vib>0) begin
+           `expl((-ibb*lc)/vib,tmp)
+           idb = ids*IBA/ibb*vib*tmp;
+         end else
+           idb = 0;
+         // $strobe("ids=%e idb=%e",ids,idb);
+
+         if (mode>1) begin
+            if (isat_s>0) begin
+               if (-vs>vexp_s)
+                 ibsj = IMAX+gexp_s*(-vs-vexp_s);
+               else begin
+                 `expl(-vs/(N*vt),tmp);
+                 ibsj = isat_s*(tmp-1);
+               end
+            end else
+              ibsj = 0;
+            
+            if (isat_d>0) begin
+               if (-vd>vexp_d)
+                 ibdj = IMAX+gexp_d*(-vd-vexp_d);
+               else begin
+                 `expl(-vd/(N*vt),tmp);
+                 ibdj = isat_d*(tmp-1);
+               end
+            end else
+              ibdj = 0;
+            
+         end else begin // if (mode>1)
+            if (isat_s>0) begin
+               if (-vd>vexp_s)
+                 ibsj = IMAX+gexp_s*(-vd-vexp_s);
+               else begin
+                 `expl(-vd/(N*vt),tmp);
+                 ibsj = isat_s*(tmp-1);
+               end
+            end else
+              ibsj = 0;
+            
+            if (isat_d>0) begin
+               if (-vs>vexp_d)
+                 ibdj = IMAX+gexp_d*(-vs-vexp_d);
+               else begin
+                 `expl(-vs/(N*vt),tmp);
+                 ibdj = isat_d*(tmp-1);
+               end
+            end else
+              ibdj = 0;
+            
+         end // else: !if(mode>1)
+
+         qdt = coxt*vt*qd;
+         qst = coxt*vt*qs;
+         qgt = coxt*vt*qg;
+         qbt = coxt*vt*qb;
+
+         cbs = 0;
+         cbd = 0;
+         
+         if (cbs0>0) begin
+            if (MTYPE*V(b,si)>FC*PB)
+              cbs = cbs+cbs0/pow(1-FC,MJ)*(1+MJ*(MTYPE*V(b,si)-PB*FC))/(PB*(1-FC));
+            else
+              cbs = cbs+cbs0/pow(1-MTYPE*V(b,si),MJ);
+         end
+         if (cbd0>0) begin
+            if (MTYPE*V(b,di)>FC*PB)
+              cbd = cbd+cbd0/pow(1-FC,MJ)*(1+MJ*(MTYPE*V(b,di)-PB*FC))/(PB*(1-FC));
+            else
+              cbd = cbd+cbd0/pow(1-MTYPE*V(b,di),MJ);
+         end
+         if (cbs0sw>0) begin
+            if (MTYPE*V(b,si)>FCSW*PBSW)
+              cbs = cbs+cbs0sw/pow(1-FCSW,MJSW)*(1+MJSW*(MTYPE*V(b,si)-PBSW*FCSW))/(PBSW*(1-FCSW));
+            else
+              cbs = cbs+cbs0sw/pow(1-MTYPE*V(b,si),MJSW);
+         end
+         if (cbd0sw>0) begin
+            if (MTYPE*V(b,di)>FCSW*PBSW)
+              cbd = cbd+cbd0sw/pow(1-FCSW,MJSW)*(1+MJSW*(MTYPE*V(b,di)-PBSW*FCSW))/(PBSW*(1-FCSW));
+            else
+              cbd = cbd+cbd0sw/pow(1-MTYPE*V(b,di),MJSW);
+         end
+         
+      end       //Bias-dependent model evaluation
+
+      begin     //Define branch sources
+
+         I(di,si) <+ MTYPE*mode*ids;
+         if (mode>0) begin
+            I(di,b) <+ MTYPE*idb;
+
+            I(di,g) <+ MTYPE*ddt(qdt);
+            I(si,g) <+ MTYPE*ddt(qst);
+            
+         end else begin
+            I(si,b) <+ MTYPE*idb;
+
+            I(si,g) <+ MTYPE*ddt(qdt);
+            I(di,g) <+ MTYPE*ddt(qst);
+            
+         end // else: !if(mode>0)
+
+         I(b,si) <+ MTYPE*ibsj;
+         I(b,di) <+ MTYPE*ibdj;
+         
+         I(b,g)  <+ MTYPE*ddt(qbt);
+         
+         I(g,si) <+ cgso*ddt(V(g,si));
+         I(g,di) <+ cgdo*ddt(V(g,di));
+         I(g,b)  <+ cgbo*ddt(V(g,b));
+         
+         if (RD>0)
+           I(d,di) <+ V(d,di)/rd;
+         else   
+           V(d,di) <+ 0.0;
+         if (RS>0)
+           I(s,si) <+ V(s,si)/rs;
+         else
+           V(s,si) <+ 0.0;
+
+         I(b,si) <+ cbs*ddt(V(b,si));
+         I(b,di) <+ cbd*ddt(V(b,di));
+         
+      end // begin
+
+//      `NOISE begin    //Define noise sources
+//       
+//      end // noise
+      
+   end //analog
 
-end // analog 
-endmodule 
+endmodule
--- ng-spice-rework/src/spicelib/devices/adms/hicum0/admsva/hicum0.va:1.1	Wed Feb 22 19:07:12 2006
+++ ng-spice-rework/src/spicelib/devices/adms/hicum0/admsva/hicum0.va	Sun Dec 28 17:30:10 2008
@@ -1,8 +1,38 @@
-//  HICUM Level_0: A Verilog-A description
+//  HICUM Level_0 Version_1.12: A Verilog-A description
 //  (A simplified version of HICUM Level2 model for BJT) 
 //  ## It is modified after the first version of HICUM/L0 code    ##
 
-//  Changed VT0 in Vt0 to prevent conflict in compiled C version. DW
+//  12/08: Modifications for ngspice and adms2.2.7 DW 
+//  Changed VT0 in Vt0 to prevent conflict in compiled C version.
+//  Made a temporary variable cjei_i for cjei output purpose only.
+
+// Minor code related changes
+// 12/06: Upper limit of FGEO is changed to infinity
+//  06/06:  Thermal node "tnode" set as external
+//  Flag FLSH introduced for controlling Self-heating calculation
+//  all if-else blocks marked with begin-end
+//  all series resistors and RTH are allowed to have a minimum value MIN_R
+//  07/06: QCJMOD deleted, QJMODF introduced along with with HICJQ
+//  ddx() operator used with QJMOD and QJMODF wherever needed
+//  aj is kept at 2.4 except BE depletion charge
+//  Substrate transistor transfer current added.
+//  Gmin added to (bi,ei) and (bi,ci) branches.
+//  hyperbolic smoothing used in rbi computation to avoid devide-by-zero.
+
+// *********************************************************************************
+// 06/06: Comment on NODE COLLAPSING:
+// Presently this verilog code permits a minimum of 1 milli-Ohm resistance for any
+// series resistance as well as for thermal resistance RTH. If any of the resistance
+// values drops below this minimum value, the corresponding nodes are shorted with
+// zero voltage contribution. We want the model compilers/simulators deal this 
+// situation in such a manner that the corresponding node is COLLAPSED.
+// We expect that the simulators should permit current contribution statement
+// for any branch with resistance value more than (or equal to) 1 milli-Ohm without
+// any convergence problem. In fact, we wish NOT to have to use a voltage contribution
+// statement in our Verilog code, except as an indication for the model compiler/simulator
+// to interprete a zero branch voltage as NODE-COLLAPSING action.
+// **********************************************************************************
+
 
 //Default simulator: Spectre
 
@@ -30,63 +60,43 @@
 `define	NPN	+1
 `define	PNP	-1
 
-
+`define VPT_thresh   	1.0e2
 `define EXPLIM		80.0
 `define INF		1.0e6
 `define TMAX		326.85
 `define TMIN		-100.0
+`define MIN_R		0.001
+`define Gmin 		1.0e-12
 
-// Depletion Charge and capacitance
-// Use of ddx() operator would help omit this macro
-`define QCJMOD(vj,cj0,vd,z,vpt,aj,qjf,cjf)\
+`define QCMODF(vj,cj0,vd,z,aj,cjf)\
   if(cj0 > 0.0) begin\
-	zr	= z/4.0;\
-	vp	= vpt-vd;\
-	vf	= vd*(1.0-exp(-ln(aj)/z));\
-	cmax	= aj*cj0;\
-	cr	= cj0*exp((z-zr)*ln(vd/vpt));\
-	a	= VT;\
-	ve	= (vf-vj)/a;\
-	if (ve <= `EXPLIM) begin\
-		ex1	= exp(ve);\
-		ee1	= 1.0+ex1;\
-		e1	= ex1/ee1;\
-		vj1	= vf-a*ln(ee1);\
-	end else begin\
-		e1	= 1.0;\
-		vj1	= vj;\
-	end\
-	a	= 0.1*vp+4.0*VT;\
-	vr	= (vp+vj1)/a;\
-	if (vr <= `EXPLIM) begin\
-		ex1	= exp(vr);\
-		ee1	= 1.0+ex1;\
-		e2	= ex1/ee1;\
-		vj2	= -vp+a*ln(ee1);\
-	end else begin\
-		e2	= 1.0;\
-		vj2	= vj1;\
-	end\
-	vj4	= vj-vj1;\
-	ez	= 1.0-z;\
-	ezr	= 1.0-zr;\
-	vdj1	= ln(1.0-vj1/vd);\
-	vdj2	= ln(1.0-vj2/vd);\
-	qj1	= cj0*(1.0-exp(vdj2*ez))/ez;\
-	qj2	= cr*(1.0-exp(vdj1*ezr))/ezr;\
-	qj3	= cr*(1.0-exp(vdj2*ezr))/ezr;\
-	qjf	= (qj1+qj2-qj3)*vd+cmax*vj4;\
-	cj1	= cj0*exp(vdj2*(-z))*e1*e2;\
-	cj2	= cr*exp(vdj1*(-zr))*(1.0-e2);\
-	cj3	= cmax*(1.0-e1);\
-	cjf	= cj1+cj2+cj3;\
+      vf	= vd*(1.0-exp(-ln(aj)/z));\
+      xvf	= (vf-vj)/VT;\
+      xvf2	= sqrt(xvf*xvf+1.921812);\
+      v_j	= vf-VT*(xvf+xvf2)*0.5;\
+      dvj	= 0.5*(xvf+xvf2)/xvf2;\
+      cjf	= cj0*exp(-z*ln(1-v_j/vd))*dvj+aj*cj0*(1-dvj);\
   end else begin\
-  	qjf	= 0.0;\
-  	cjf	= 0.0;\
+      cjf	= 0.0;\
   end
-  
 
-// Depletion Charge
+// DEPLETION CHARGE CALCULATION
+// Hyperbolic smoothing used; no punch-through
+`define QJMODF(vj,cj0,vd,z,aj,qjf)\
+  if(cj0 > 0.0) begin\
+      vf	= vd*(1.0-exp(-ln(aj)/z));\
+      xvf	= (vf-vj)/VT;\
+      xvf2	= sqrt(xvf*xvf+1.921812);\
+      v_j	= vf-VT*(xvf+xvf2)*0.5;\
+      x		= 1.0-z;\
+      y		= 1.0-exp(x*ln(1.0-v_j/vd));\
+      qjf	= cj0*vd*y/x+aj*cj0*(vj-v_j);\
+  end else begin\
+      qjf	= 0.0;\
+  end
+
+
+// Depletion Charge : with punch through
 `define QJMOD(vj,cj0,vd,z,vpt,aj,qjf)\
   if(cj0 > 0.0) begin\
 	zr	= z/4.0;\
@@ -99,10 +109,8 @@
 	if (ve <= `EXPLIM) begin\
 		ex1	= exp(ve);\
 		ee1	= 1.0+ex1;\
-		e1	= ex1/(ee1);\
 		vj1	= vf-a*ln(ee1);\
 	end else begin\
-		e1	= 1.0;\
 		vj1	= vj;\
 	end\
 	a	= 0.1*vp+4.0*VT;\
@@ -110,10 +118,8 @@
 	if (vr <= `EXPLIM) begin\
 		ex1	= exp(vr);\
 		ee1	= 1.0+ex1;\
-		e2	= ex1/(ee1);\
 		vj2	= -vp+a*ln(ee1);\
 	end else begin\
-		e2	= 1.0;\
 		vj2	= vj1;\
 	end\
 	vj4	= vj-vj1;\
@@ -128,15 +134,26 @@
   end else begin\
   	qjf	= 0.0;\
   end
-	
+
+
+// DEPLETION CHARGE CALCULATION SELECTOR:
+// Dependent on junction punch-through voltage
+// Important for collector related junctions
+`define HICJQ(vj,cj0,vd,z,vpt,qjf)\
+    if(vpt < `VPT_thresh) begin\
+        `QJMOD(vj,cj0,vd,z,vpt,2.4,qjf)\
+    end else begin\
+        `QJMODF(vj,cj0,vd,z,2.4,qjf)\
+    end
+    
 //Temperature dependence of depletion capacitance parameters
-`define TMPHICJ(cj0,vd,z,aj,vg,cj0_t,vd_t,aj_t)\
+`define TMPHICJ(cj0,vd,z,vg,cj0_t,vd_t)\
 	arg	= 0.5*vd/Vt0;\
 	vdj0	= 2*Vt0*ln(exp(arg)-exp(-arg));\
 	vdjt	= vdj0*qtt0+vg*(1-qtt0)-mg*VT*ln_qtt0;\
 	vd_t	= vdjt+2*VT*ln(0.5*(1+sqrt(1+4*exp(-vdjt/VT))));\
-	cj0_t	= cj0*exp(z*ln(vd/vd_t));\
-	aj_t	= aj*vd_t/vd;
+	cj0_t	= cj0*exp(z*ln(vd/vd_t));
+
 
 //Limiting exponential
 `define LIN_EXP(le, arg)\
@@ -177,12 +194,12 @@
         end
         
 
-module hic0_full (c,b,e,s);                    
+module hic0_full (c,b,e,s,tnode);                    
                                                
                                             
 //Node definitions 
                       
-	inout		c,b,e,s;                                                  
+	inout		c,b,e,s,tnode;                                                  
 	electrical 	c     `P(info="external collector node");
 	electrical 	b     `P(info="external base node");
 	electrical 	e     `P(info="external emitter node");
@@ -190,14 +207,25 @@
 	electrical 	ci    `P(info="internal collector node");
 	electrical 	bi    `P(info="internal base node");
 	electrical 	ei    `P(info="internal emitter node");
-	electrical 	tnode `P(info="local temperature rise node");                            
-
-	branch 		(ci,c) 	irescx;
-	branch 		(ci,c) 	vrescx;
-	branch 		(ei,e) 	iresex;
-	branch 		(ei,e) 	vresex;
-	branch 		(b,bi)  irescb;  
-	branch 		(b,bi)  vrescb;                                         
+	electrical 	tnode `P(info="local temperature rise node");
+	
+	
+	//Branch definitions
+	branch 		(ci,c) 		br_cic_i;
+	branch 		(ci,c) 		br_cic_v;
+	branch 		(ei,e) 		br_eie_i;
+	branch 		(ei,e) 		br_eie_v;
+	branch		(bi,ei)		br_biei;
+	branch		(bi,ci)		br_bici;
+	branch		(ci,ei)		br_ciei;
+	branch 		(b,bi)  	br_bbi_i;  
+	branch 		(b,bi)  	br_bbi_v; 	
+	branch		(b,e)		br_be;
+	branch		(b,ci)		br_bci;
+	branch		(b,s)		br_bs;
+	branch		(s,ci)		br_sci;
+	branch		(tnode )	br_sht;                          
+                                        
 //                                             
 // Parameter initialization with default values            
                                                
@@ -258,14 +286,16 @@
 	parameter real rbi0   		= 0.0		from [0:`INF)	`P(spice:name="rbi0"  info="Internal base resistance at zero-bias" test:value="100" unit="Ohm" m:inverse_factor="yes");   
 	parameter real vr0e   		= 2.5		from (0:`INF]	`P(spice:name="vr0e"  info="forward Early voltage (normalization volt.)" unit="V");                 
 	parameter real vr0c   		= `INF		from (0:`INF]	`P(spice:name="vr0c" info="forward Early voltage (normalization volt.)" unit="V" default="infinity" test:value="25.0");                  
-	parameter real fgeo   		= 0.656		from [0:1]	`P(spice:name="fgeo"  info="Geometry factor" test:value="0.73"); 
+	parameter real fgeo   		= 0.656		from [0:`INF]	`P(spice:name="fgeo"  info="Geometry factor" test:value="0.73"); 
                                                
 // Series resistances                        
 	parameter real rbx    		= 0.0		from [0:`INF)	`P(spice:name="rbx"   info="External base series resistance" test:value="8.8" unit="Ohm" m:inverse_factor="yes"); 
 	parameter real rcx    		= 0.0		from [0:`INF)	`P(spice:name="rcx"   info="Emitter series resistance" test:value="12.5" unit="Ohm" m:inverse_factor="yes");        
 	parameter real re     		= 0.0		from [0:`INF)	`P(spice:name="re"    info="External collector series resistance" test:value="9.16" unit="Ohm" m:inverse_factor="yes");      
                                                
-// Substrate diode current and cap                   
+// Substrate transfer current, diode current and cap                   
+	parameter real itss   		= 0.0		from [0:1.0]	`P(spice:name="itss" info="Substrate transistor transfer saturation current" unit="A" test:value="1e-17" m:factor="yes");    
+	parameter real msf    		= 1.0		from (0:10]	`P(spice:name="msf"  info="Substrate transistor transfer current non-ideality factor");   
 	parameter real iscs   		= 0.0		from [0:1.0]	`P(spice:name="iscs" info="SC saturation current" unit="A" test:value="1e-17" m:factor="yes");    
 	parameter real msc    		= 1.0		from (0:10]	`P(spice:name="msc"  info="SC non-ideality factor");   
 	parameter real cjs0   		= 1.0e-20	from [0:`INF)	`P(spice:name="cjs0" info="Zero-bias SC depletion capacitance" unit="F" test:value="1e-15" m:factor="yes");    
@@ -307,6 +337,7 @@
 	parameter real aleav		= 0.0				`P(spice:name="aleav" info="TC of avalanche exponential factor" unit="1/K");
 	
 // Self-heating                              
+ 	parameter integer flsh		= 0		from [0:2]	`P(spice:name="flsh"  info="Flag for self-heating calculation" test:value="2");            
  	parameter real rth		= 0.0		from [0:`INF)	`P(spice:name="rth"  info="Thermal resistance" test:value="200.0" unit="K/W" m:inverse_factor="yes");            
 	parameter real cth		= 0.0		from [0:`INF)	`P(spice:name="cth"  info="Thermal capacitance" test:value="0.1" unit="Ws/K" m:factor="yes");
 	
@@ -344,21 +375,21 @@
 	real VT,Tamb,Tdev,Tnom,dT,qtt0,ln_qtt0;
 	real vde_t,vdci_t,vdcx_t,vds_t;
 	real is_t,ires_t,ibes_t,ibcs_t;
-	real iscs_t,cje0_t,cjci0_t,cjcx0_t;
+	real itss_t,iscs_t,cje0_t,cjci0_t,cjcx0_t;
 	real cjs0_t,rci0_t,vlim_t;
 	real vces_t,thcs_t,tef0_t,rbi0_t;
 	real rbx_t,rcx_t,re_t,t0_t,eavl_t,kavl_t;
-	real aje_t,ajci_t,ajcx_t,ajs_t;
+	real aje_t;
 
 	// bc charge and cap
 	real qjci `P(ask="yes" info="B-C internal junction charge" unit="C");
 	real qjcx,qjcii,cjcii,qjcxi,qjciii; //cjcx
-	real cjci0_t_ii,cjcx0_t_ii,cjcx0_t_i;
+	real cjci0_t_ii,cjcx0_t_ii,cjcx0_t_i,v_j;
 
 	// be junction
 	real qjei `P(ask="yes" info="B-E internal junction charge" unit="C");
-	real cjei `P(ask="yes" info="B-E internal junction capacitance" unit="F");
-	real vf,vj,x,y,e1,e2;  
+	real cjei_i `P(ask="yes" info="B-E internal junction capacitance" unit="F"); // dw: adms2.2.7 problem
+	real cjei,vf,vj,x,y,e1,e2;  
 	 
 	// transfer and internal base current
 	real cc,qj_2,facl;
@@ -380,10 +411,10 @@
 	real v_bord,a_iavl,lncc;
 	
 	// base resistance
-	real rb,ri,eta,fac_ri,rbi,qje; 
+	real rb,eta,rbi,qje,Qz_nom,fQz; 
 
-	// substrate diode and cap
-	real qjs;
+	// substrate transistor, diode and cap
+	real qjs,HSa,HSb,HSI_Tsu,HSUM;
 
 	// self heating
 	real pterm;
@@ -403,7 +434,7 @@
   	real	IS,IST,UM1,U,Iz,DIOY;
   	
   	// branch voltages
-  	real   Vbci,Vbici,Vbiei,Vciei,Vsci,Veie,Vbbi,Vcic,Vbe,Vrth, Vrth_ext;
+  	real   Vbci,Vbici,Vbiei,Vciei,Vsci,Veie,Vbbi,Vcic,Vbe,Vrth;
 	
 	//Output to be seen
 	real	ijbc `P(ask="yes" info="Base-collector diode current" unit="A");
@@ -437,16 +468,16 @@
 	     HICUMtype	=  `NPN;
          end
 
-	Vbci  = HICUMtype*V(b,ci);
-	Vbici = HICUMtype*V(bi,ci);
-	Vbiei = HICUMtype*V(bi,ei);
-	Vciei = HICUMtype*V(ci,ei);
-	Vsci  = HICUMtype*V(s,ci);
-	Veie  = V(vresex);
-	Vcic  = V(vrescx);
-	Vbbi  = V(vrescb);
-	Vbe   = HICUMtype*V(b,e);
-	Vrth  = V(tnode);
+	Vbci  = HICUMtype*V(br_bci);
+	Vbici = HICUMtype*V(br_bici);
+	Vbiei = HICUMtype*V(br_biei);
+	Vciei = HICUMtype*V(br_ciei);
+	Vsci  = HICUMtype*V(br_sci);
+	Veie  = V(br_eie_v);
+	Vcic  = V(br_cic_v);
+	Vbbi  = V(br_bbi_v);
+	Vbe   = HICUMtype*V(br_be);
+	Vrth  = V(br_sht);
 
 
 
@@ -456,14 +487,16 @@
 
 	Tnom	= tnom+273.15;
 	Tamb	= $temperature;
-	Tdev	= Tamb+dt+Vrth;   // selfheating instead dT later possible
+	Tdev	= Tamb+dt+Vrth;
 	
 // Limit temperature to avoid FPE's in equations
-	if(Tdev < `TMIN + 273.15)
+	if(Tdev < `TMIN + 273.15) begin
 	   Tdev = `TMIN + 273.15;
-	else
- 	if (Tdev > `TMAX + 273.15)
+	end else begin
+ 	if (Tdev > `TMAX + 273.15) begin
 	   Tdev = `TMAX + 273.15;
+	end
+	end
 
 	Vt0     = `P_K*Tnom /`P_Q;
 	VT      = `P_K*Tdev /`P_Q;
@@ -483,11 +516,13 @@
 	ibes_t  = ibes*exp(zetabet*ln_qtt0+vge/VT*(qtt0-1));
 	ires_t  = ires*exp(0.5*mg*ln_qtt0+0.5*vgbe/VT*(qtt0-1));
 	ibcs_t  = ibcs*exp(zetabci*ln_qtt0+vgc/VT*(qtt0-1));
+	itss_t	= itss*exp(zetasct*ln_qtt0+vgc/VT*(qtt0-1));
 	iscs_t  = iscs*exp(zetasct*ln_qtt0+vgs/VT*(qtt0-1));
-	`TMPHICJ(cje0,vde,ze,aje,vgbe,cje0_t,vde_t,aje_t)
-	`TMPHICJ(cjci0,vdci,zci,2.4,vgbc,cjci0_t,vdci_t,ajci_t)
-	`TMPHICJ(cjcx0,vdcx,zcx,2.4,vgbc,cjcx0_t,vdcx_t,ajcx_t)
-	`TMPHICJ(cjs0,vds,zs,2.4,vgsc,cjs0_t,vds_t,ajs_t)
+	`TMPHICJ(cje0,vde,ze,vgbe,cje0_t,vde_t)
+	aje_t	= aje*vde_t/vde;
+	`TMPHICJ(cjci0,vdci,zci,vgbc,cjci0_t,vdci_t)
+	`TMPHICJ(cjcx0,vdcx,zcx,vgbc,cjcx0_t,vdcx_t)
+	`TMPHICJ(cjs0,vds,zs,vgsc,cjs0_t,vds_t)
 	rci0_t  = rci0*exp(zetaci*ln_qtt0);
 	vlim_t  = vlim*exp((zetaci-avs)*ln_qtt0);
 	vces_t  = vces*(1+alces*dT);
@@ -501,7 +536,8 @@
 	rbi0_t  = rbi0*exp(zetarbi*ln_qtt0);
 	re_t    = re*exp(zetare*ln_qtt0);
 	eavl_t  = eavl*exp(aleav*dT);
-	kavl_t  = kavl*exp(alkav*dT);	
+	kavl_t  = kavl*exp(alkav*dT);
+
 
 //
 // Calculation of intrinsic transistor elements
@@ -517,42 +553,28 @@
 		cjci0_t_ii	= cjci0_t*fbc;             // zero bias internal portion
 		qjcxi		= 0;
 		cjcx0_t_i	= cjci0_t*(1-fbc);         // zero bias external portion
-		`QJMOD(Vbci,cjcx0_t_i,vdci_t,zci,vptci,ajci_t,qjcx)
+		`HICJQ(Vbci,cjcx0_t_i,vdci_t,zci,vptci,qjcx)
 	end else begin  
 		cjci0_t_ii	= cjci0_t;                 // zero bias internal portion
 		cjcx0_t_ii	= cjcx0_t*fbc;
-		`QJMOD(Vbici,cjcx0_t_ii,vdcx_t,zcx,vptcx,ajcx_t,qjcxi);
+		`HICJQ(Vbici,cjcx0_t_ii,vdcx_t,zcx,vptcx,qjcxi)
 		cjcx0_t_i	= cjcx0_t*(1-fbc);         // zero bias external portion
-		`QJMOD(Vbci,cjcx0_t_i,vdcx_t,zcx,vptcx,ajcx_t,qjcx)
+		`HICJQ(Vbci,cjcx0_t_i,vdcx_t,zcx,vptcx,qjcx)
 	end
-	`QJMOD(Vbici,cjci0_t_ii,vdci_t,zci,vptci,ajci_t,qjci)
+	`HICJQ(Vbici,cjci0_t_ii,vdci_t,zci,vptci,qjci)
 	qjcii	= qjci+qjcxi;
 		
 //Internal bc cap without punch through for cc
  
-	`QCJMOD(Vbici,cjci0_t_ii,vdci_t,zci,100,ajci_t,qjciii,cjcii)
-//	cjcii	= ddx(qjciii,Vbici);	//cap needful only here: ddx() not supported
+	//`HICJQ(Vbici,cjci0_t_ii,vdci_t,zci,100,qjciii)
+	`QCMODF(Vbici,cjci0_t_ii,vdci_t,zci,2.4,cjcii)
+	//cjcii	= ddx(qjciii,V(bi));
 
 //Internal be cap and charge
 
-// Preprocessing
-	vf	= vde_t*(1-exp(-ln(aje_t)/ze));
-
-// Smoothing terms
-	xvf	= (vf-Vbiei)/VT;
-	xvf2	= sqrt(xvf*xvf+1.921812);
-	vj	= vf-VT*0.5*(xvf+xvf2);
-	dvj	= 0.5*(xvf+xvf2)/xvf2;
-
-// BE cap
-	cjei	= cje0_t*exp(-ze*ln(1-vj/vde_t))*dvj+aje_t*cje0_t*(1-dvj);
-
-// Preprocessing
-	x	= 1-ze;
-	y	= 1-exp(x*ln(1-vj/vde_t));
-
-// BE charge
-	qjei	= cje0_t*vde_t/x*y+aje_t*cje0_t*(Vbiei-vj);
+	`QJMODF(Vbiei,cje0_t,vde_t,ze,aje_t,qjei)
+	cjei	= ddx(qjei,V(bi));
+	cjei_i	= cjei; // dw: adms2.2.7 problem
 
 // Critical current: ick
 	vc	= Vciei-vces_t;
@@ -590,8 +612,9 @@
 
 // Normalized total hole charge
 	qpt	= qj_2+sqrt((qj_2)*(qj_2)+qm);
-	if (qpt<=1e-20)
-		qpt=1e-20;	
+	if (qpt<=1e-20) begin
+		qpt=1e-20;
+	end	
 
 // Low transfer current
 	itfl	= itfi/qpt; 
@@ -599,8 +622,9 @@
 
 // Normalized injection width with low transfer current
 // and normalized charge component
-	if (itfl<=1e-20)
+	if (itfl<=1e-20) begin
 		itfl	= 1e-20;
+	end
 	al	= 1-ick/itfl;
 	s3l	= sqrt(al*al+ahc);
 	wl	= (al+s3l)/(1+sqrt(1+ahc));
@@ -610,8 +634,9 @@
 	facl	= 1/(1+d_qfh/qpt);
 	itf	= itfl*facl;
 	itr	= itrl*facl;
-	if (itf<=1e-20)
+	if (itf<=1e-20) begin
 		itf	= 1e-20;
+	end
 	it	= itf-itr;
 
 // BE diffusion charge
@@ -653,8 +678,8 @@
 
 // Avalanche current	
 
-	v_bord	= eavl_t*vdci_t;
-	if (Vbici < 0) begin
+	if (Vbici < 0) begin : HICAVL
+		v_bord	= eavl_t*vdci_t;
 		if (vdci_t-Vbici>v_bord) begin
 			a_iavl	= kavl_t/vdci_t*exp(-cc);
 			iavl	= itf*a_iavl*(v_bord+(1+cc)*(vdci_t-Vbici-v_bord));
@@ -671,32 +696,58 @@
 //
 
 // Base resistance
-
-	qje	= qjei/cje0_t;
-	ri	= rbi0_t/(1+qje/vr0e+itf/ickf+itr/ickr+qjci/vr0c);
-	if (ibi > 0.0) begin
-		eta	= fgeo*ri*ibi/VT;
-		if (eta < 1e-6) begin
-			fac_ri=1-eta/2;
-		end else begin
-			fac_ri=ln(eta+1)/eta;
+	if(rbi0_t > 0.0) begin : HICRBI
+		// Conductivity modulation with hyperbolic smoothing
+		qje	= qjei/cje0_t;
+		Qz_nom	= 1+qje/vr0e+qjci/vr0c+itf/ickf+itr/ickr;
+		fQz	= 0.5*(Qz_nom+sqrt(Qz_nom*Qz_nom+0.01));;
+		rbi	= rbi0_t/fQz;
+		// Emitter current crowding
+		if (ibi > 0.0) begin
+			eta	= fgeo*rbi*ibi/VT;
+			if (eta < 1e-6) begin
+				rbi	= rbi*(1-0.5*eta);
+			end else begin
+				rbi	= rbi*ln(eta+1)/eta;
+			end
 		end
 	end else begin
-		fac_ri	= 1.0;
+		rbi	= 0.0;
 	end
-	rbi	= ri*fac_ri;  
-	rb	= rbi+rbx_t; 
+	// Total base resistance 
+	rb	= rbi+rbx_t;
+
+// Parasitic substrate transistor transfer current
+ 	if(itss > 0.0) begin : Sub_Transfer
+ 		HSUM	= msf*VT;
+        	HSa	= limexp(Vbci/HSUM);
+        	HSb	= limexp(Vsci/HSUM);
+        	HSI_Tsu	= itss_t*(HSa-HSb);
+      	end else begin
+        	HSI_Tsu	= 0.0;
+      	end
 
 // Substrate diode and cap and charge
 
 	`HICDIO(iscs,iscs_t,msc,Vsci,ijsc)
 
-	`QJMOD(Vsci,cjs0_t,vds_t,zs,vpts,ajs_t,qjs);    // aj=2.4 assumed
+	`HICJQ(Vsci,cjs0_t,vds_t,zs,vpts,qjs)
 
 // Self heating
 
-	if (rth > 0.0) begin
+	if (flsh == 1 && rth >= `MIN_R) begin
 		pterm	= it*Vciei+iavl*(vdci_t-Vbici); 
+	end else if (flsh == 2 && rth >= `MIN_R) begin
+		pterm	=  Vciei*it + (vdci_t-Vbici)*iavl + ijbe*Vbiei + ijbc*Vbici + ijsc*Vsci;
+		if (rb >= `MIN_R) begin
+		pterm	= pterm + Vbbi*Vbbi/rb;
+		end
+		if (re_t >= `MIN_R) begin
+		pterm	= pterm + Veie*Veie/re_t;
+		end
+		if (rcx_t >= `MIN_R) begin
+		pterm	= pterm + Vcic*Vcic/rcx_t;
+		end
 	end
 
 //
@@ -724,59 +775,79 @@
 	
 //
 // Define branch sources
-//	
-
-	I(s,ci)		<+ ijsc					`P(spectre:gmin="add" spectre:pwl_passive="1e10");
-	I(s,ci)		<+ ddt(qjs);
-	I(b,ci)		<+ ddt(qjcx);
-	I(b,ci)  	<+ ddt(Qbci);
-	I(b,e)		<+ ddt(Qbe);
-	if (re > 0.0) begin
-	I(iresex)  	<+ Veie/re_t					`P(spectre:gmin="add");
+//
+	I(br_biei)	<+ `Gmin*V(br_biei);
+	I(br_bici)	<+ `Gmin*V(br_bici);
+		
+	I(br_bs) 		<+ HSI_Tsu;
+	I(br_sci)		<+ ijsc					`P(spectre:gmin="add" spectre:pwl_passive="1e10");
+	I(br_sci)		<+ ddt(qjs);
+	I(br_bci)		<+ ddt(qjcx);
+	I(br_bci)	  	<+ ddt(Qbci);
+	I(br_be)		<+ ddt(Qbe);
+	if (re >= `MIN_R) begin
+	I(br_eie_i)	  	<+ Veie/re_t					`P(spectre:gmin="add");
 	end else begin
-	V(vresex)	<+ 0.0;
+	V(br_eie_v)		<+ 0.0;
 	end
-	if (rcx > 0.0) begin
-	I(irescx)  	<+ Vcic/rcx_t					`P(spectre:gmin="add");
+	if (rcx >= `MIN_R) begin
+	I(br_cic_i)	  	<+ Vcic/rcx_t					`P(spectre:gmin="add");
 	end else begin
-	V(vrescx)	<+ 0.0;
+	V(br_cic_v)		<+ 0.0;
 	end
-	if (rbi0 > 0.0 || rbx > 0.0) begin
-	I(irescb)  	<+ Vbbi/rb				`P(spectre:gmin="add");
+	if (rbi0 >= `MIN_R || rbx >= `MIN_R) begin
+	I(br_bbi_i)	  	<+ Vbbi/rb				`P(spectre:gmin="add");
 	end else begin
-	V(vrescb)	<+ 0.0;
+	V(br_bbi_v)		<+ 0.0;
 	end
-	I(bi,ci)	<+ Ibici				`P(spectre:gmin="add" spectre:pwl_sat_current="IMAX" spectre:pwl_sat_cond="imax/0.025" spectre:pwl_rev_current="imax" spectre:pwl_rev_cond="IMAX/0.025");
-	I(bi,ci)	<+ ddt(Qbici);
-	I(bi,ei)	<+ ijbe					`P(spectre:gmin="add" spectre:pwl_fwd_current="IBEIS*exp(25.0)" spectre:pwl_fwd_node="bi" spectre:pwl_fwd_cond="IBEIS*exp(25.0)/0.025" spectre:pwl_sat_current="IMAX" spectre:pwl_sat_cond="IMAX/0.025" spectre:pwl_passive="1e10");
-	I(bi,ei)	<+ ddt(Qbiei);
-	I(ci,ei)	<+ it					`P(spectre:pwl_fwd_current="IS*exp(25.0)" spectre:pwl_fwd_node="bi" spectre:pwl_fwd_cond="IS*exp(25.0)/0.025"   spectre:pwl_rev_current="IMAX" spectre:pwl_rev_cond="IMAX/0.025" spectre:pwl_passive="1e10");
-	
-	if(rth == 0) begin
-		V(tnode)	<+ 0.0;
+	I(br_bici)	<+ Ibici				`P(spectre:gmin="add" spectre:pwl_sat_current="IMAX" spectre:pwl_sat_cond="imax/0.025" spectre:pwl_rev_current="imax" spectre:pwl_rev_cond="IMAX/0.025");
+	I(br_bici)	<+ ddt(Qbici);
+	I(br_biei)	<+ ijbe					`P(spectre:gmin="add" spectre:pwl_fwd_current="IBEIS*exp(25.0)" spectre:pwl_fwd_node="bi" spectre:pwl_fwd_cond="IBEIS*exp(25.0)/0.025" spectre:pwl_sat_current="IMAX" spectre:pwl_sat_cond="IMAX/0.025" spectre:pwl_passive="1e10");
+	I(br_biei)	<+ ddt(Qbiei);
+	I(br_ciei)	<+ it					`P(spectre:pwl_fwd_current="IS*exp(25.0)" spectre:pwl_fwd_node="bi" spectre:pwl_fwd_cond="IS*exp(25.0)/0.025"   spectre:pwl_rev_current="IMAX" spectre:pwl_rev_cond="IMAX/0.025" spectre:pwl_passive="1e10");
+	
+	// Following code is an intermediate solution:
+	// ******************************************
+	//if(flsh == 0 || rth < `MIN_R) begin
+	//	I(br_sht) 	<+ Vrth/`MIN_R;
+	//end else begin
+	//	I(br_sht) 	<+ Vrth/rth-pterm			`P(spectre:gmin="add");
+	//	I(br_sht) 	<+ ddt(cth*Vrth);
+	//end
+	// ******************************************
+	// For simulators having no problem with V(br_sht) <+ 0.0 
+	// with external thermal node, follwing code may be used.
+	// This external thermal node should remain accessible.
+	// ********************************************
+	if(flsh == 0 || rth < `MIN_R) begin
+		V(br_sht)	<+ 0.0;
 	end else begin
-		I(tnode) 	<+ Vrth/rth-pterm		`P(spectre:gmin="add");
-		I(tnode) 	<+ ddt(cth*Vrth);
+		I(br_sht) 	<+ Vrth/rth-pterm		`P(spectre:gmin="add");
+		I(br_sht) 	<+ ddt(cth*Vrth);
 	end
-
+	// ********************************************
+	
 // Noise sources
 // Thermal noise
 	fourkt 	= 4.0 * `P_K * Tdev;
-	if(rbx > 0.0 || rbi0 > 0.0)
-		I(irescb)		<+ white_noise(fourkt/rb);
-	if(rcx > 0.0)
-		I(irescx)		<+ white_noise(fourkt/rcx_t);
-	if(re > 0.0)
-		I(iresex)		<+ white_noise(fourkt/re_t);
+	if(rbx >= `MIN_R || rbi0 >= `MIN_R) begin
+		I(br_bbi_i)		<+ white_noise(fourkt/rb);
+	end
+	if(rcx >= `MIN_R) begin
+		I(br_cic_i)		<+ white_noise(fourkt/rcx_t);
+	end
+	if(re >= `MIN_R) begin
+		I(br_eie_i)		<+ white_noise(fourkt/re_t);
+	end
 
 // Shot noise
 	twoq	= 2.0 * `P_Q;
-	I(bi,ei)	<+ white_noise(twoq*ijbe);
-	I(ci,ei)	<+ white_noise(twoq*it);
+	I(br_biei)	<+ white_noise(twoq*ijbe);
+	I(br_ciei)	<+ white_noise(twoq*it);
    
 // Flicker noise   
 	flicker_Pwr	= kf*pow(ijbe,af);
-	I(bi,ei)	<+ flicker_noise(flicker_Pwr,1.0);
+	I(br_biei)	<+ flicker_noise(flicker_Pwr,1.0);
 
 end  // analog
 endmodule
--- ng-spice-rework/src/spicelib/devices/adms/hicum2/admsva/hicum2.va:1.3	Tue Jul 24 10:12:15 2007
+++ ng-spice-rework/src/spicelib/devices/adms/hicum2/admsva/hicum2.va	Mon Jan  5 21:33:19 2009
@@ -1,26 +1,75 @@
 //HICUM Level_2 Version_2.22: A Verilog-A Description
 
+//dw 12/08: Modifications for ngspice and adms suggested by Laurent Lemaitre:
+// replaced `define MODEL @(initial_model) by `define MODEL because we have usage of a 
+// dependent variable for HICTUN_T.
+// all V(...) <+ 0.0; are replaced by I(...) < V(...)/`MIN_R;
+// variable definition only on start of the module and removing named blocks HICTUN_T
+// because handling not correct - wrong scope!
+
 // 01/06: Bug fix and optimization
 // FCdf1_dw assigned expression (missing in v2.21)
 // FCa and FCa1 are found to have same expression: FCa is omitted in those cases
-// Fca1 written instead of Fca in the expression for FCf_ci
-// Thermal node "tnode" is set as external
+// FCa1 written instead of FCa in the expression for FCf_ci
+// Thermal node "tnode" set as external
 // zetasct = mg+1-2.5 changed to zetasct = mg-1.5;
-// Code optimization: code rearranged to exclude the temperature dependent 
-// calculation from @(initial_model) within insideADMS (with self-heating ON).
-// Temperature update parts are moduled in a separate block.
+// Code optimization: Temperature dependent parts are moduled in two separate blocks: 
+// within @(initial_model) when self-heating is OFF
+// outside @(initial_model) when self-heating is ON
+// 03/06 : Further fix
+// vlim_t,ibcis_t,ibcxs_t,itss_t,iscs_t considered in compatibility block
+// ddt() operators are separated in contribution expressions.
+// FLCOMP parameter is given different values
+// 05/06:
+// all if-else blocks marked with begin-end
+// unused variables deleted
+// all series resistors and RTH are allowed to have a minimum value MIN_R
+// only tunelling current source contribution within if-then-else
+// 06/06: HICRBI deleted and instead the code changed (hyperbolic smoothing in 
+// conductivity modulation part) and put in relevant portion of the code.
+// 07/06: ddx() operator used to find out capacitances from charges: 
+// QJMODF,QJMOD,HICJQ changed accordingly
+// Lateral NQS effect modified with ddx() operator.
+// HICFCT included for downward compatibility reason.
+// Few macros are taken inside the code: HICICK, HICAVL, HICTUN (more optimized), 
+// internal base resistance (Qjci included under conductivity modulation, hyperbolic smoothing used)
+// Gmin added at (bi,ei) and (bi,ci) branches.
+// 08/06: Units added in the parameter descriptions.
+
+// *********************************************************************************
+// 06/06: Comment on NODE COLLAPSING:
+// Presently this verilog code permits a minimum of 1 milli-Ohm resistance for any
+// series resistance as well as for thermal resistance RTH. If any of the resistance
+// values drops below this minimum value, the corresponding nodes are shorted with
+// zero voltage contribution. We want the model compilers/simulators deal this 
+// situation in such a manner that the corresponding node is COLLAPSED.
+// We expect that the simulators should permit current contribution statement
+// for any branch with resistance value more than (or equal to) 1 milli-Ohm without
+// any convergence problem. In fact, we wish NOT to have to use a voltage contribution
+// statement in our Verilog code, except as an indication for the model compiler/simulator
+// to interprete a zero branch voltage as NODE-COLLAPSING action.
+// **********************************************************************************
+// **********************************************************************************
+// 06/06: Comment on Implementation of Non-Quasi-Static Effect:
+// This code does not have NQS effect implemented yet. Up to now we recommend Weil's 
+// approach, which is implemented in DEVICE FTN code and built-in v2.1 HICUM model
+// inside most of the circuit simulators. Using Verilog, it is not presently possible 
+// to implement Weil's approach, since there remains hardly any possibility to access
+// previous time-step of simulation. Providing C-code will not even serve the purpose,
+// since we are not aware of the specific time-steps for various simulators. Instead,
+// we recommend the EDA vendors to use their previous implementation (piece of code 
+// for NQS effect) for this model code in appropriate position, once it is converted 
+// into C-code by the model compilers. At present only this solution seems feasible.
+// **********************************************************************************
 
-// ddt() terms splitted DW
 
 //Default simulator: Spectre
 
 `ifdef insideADMS
-  `define P(p) (*p*)
-  `define MODEL @(initial_model)
+  `define MODEL
   `define NOISE @(noise)
   `define ATTR(txt) (*txt*)
 `else
-  `define P(p)
   `define MODEL
   `define NOISE
   `define ATTR(txt)
@@ -35,7 +84,9 @@
 `define l_itmax		100
 `define TMAX		326.85
 `define TMIN		-100.0
-
+`define LN_EXP_LIMIT 	11.0
+`define MIN_R 		0.001
+`define Gmin 		1.0e-12
 
 //ADS
 //`include "constants.vams"
@@ -47,7 +98,7 @@
 `include "discipline.h"
 
 
-// DEPLETION CAPACITANCE AND CHARGE CALCULATION
+// DEPLETION CHARGE CALCULATION
 // Hyperbolic smoothing used; no punch-through
 // INPUT:
 //  c_0		: zero-bias capacitance
@@ -59,29 +110,22 @@
 //  VT		: thermal voltage
 // OUTPUT:
 //  Qz		: depletion Charge 
-//  C		: depletion capacitance (Until ddx() is operative)
-`define QCJMODF(c_0,u_d,z,a_j,U_cap,C,Qz)\
+`define QJMODF(c_0,u_d,z,a_j,U_cap,Qz)\
   if(c_0 > 0.0) begin\
       DFV_f	= u_d*(1.0-exp(-ln(a_j)/z));\
-      DFC_max	= a_j*c_0;\
-      DFa	= VT;\
-      DFv_e	= (DFV_f-U_cap)/DFa;\
+      DFv_e	= (DFV_f-U_cap)/VT;\
       DFs_q	= sqrt(DFv_e*DFv_e+`DFa_fj);\
       DFs_q2	= (DFv_e+DFs_q)*0.5;\
-      DFv_j	= DFV_f-DFa*DFs_q2;\
-      DFdvj_dv	= DFs_q2/DFs_q;\
+      DFv_j	= DFV_f-VT*DFs_q2;\
       DFb	= ln(1.0-DFv_j/u_d);\
-      DFC_j1	= c_0*exp(-z*DFb)*DFdvj_dv;\
-      C		= DFC_j1+DFC_max*(1.0-DFdvj_dv);\
       DFQ_j	= c_0*u_d*(1.0-exp(DFb*(1.0-z)))/(1.0-z);\
-      Qz	= DFQ_j+DFC_max*(U_cap-DFv_j);\
+      Qz	= DFQ_j+a_j*c_0*(U_cap-DFv_j);\
   end else begin\
-      C		= 0.0;\
       Qz	= 0.0;\
   end
 
 
-// DEPLETION CAPACITANCE AND CHARGE CALCULATION
+// DEPLETION CHARGE CALCULATION CONSIDERING PUNCH THROUGH
 // smoothing of reverse bias region (punch-through) 
 // and limiting to a_j=Cj,max/Cj0 for forward bias.
 // Important for base-collector and collector-substrate junction
@@ -96,8 +140,7 @@
 //  VT		: thermal voltage
 // OUTPUT:
 //  Qz		: depletion charge
-//  C		: depletion capacitance (Until ddx() is operative)
-`define QCJMOD(c_0,u_d,z,a_j,v_pt,U_cap,C,Qz)\
+`define QJMOD(c_0,u_d,z,a_j,v_pt,U_cap,Qz)\
   if(c_0 > 0.0) begin\
       Dz_r	= z/4.0;\
       Dv_p	= v_pt-u_d;\
@@ -107,21 +150,16 @@
       Dv_e	= (DV_f-U_cap)/VT;\
       if(Dv_e < `Cexp_lim) begin\
         De	= exp(Dv_e);\
-        De_1	= De/(1.0+De);\
         Dv_j1	= DV_f-VT*ln(1.0+De);\
       end else begin\
-        De_1	= 1.0;\
         Dv_j1	= U_cap;\
       end\
       Da	= 0.1*Dv_p+4.0*VT;\
       Dv_r	= (Dv_p+Dv_j1)/Da;\
       if(Dv_r < `Cexp_lim) begin\
        	De	= exp(Dv_r);\
-       	De_2	= De/(1.0+De);\
        	Dv_j2	= -Dv_p+Da*ln(1.0+De);\
-      end\
-      else begin\
-       	De_2	= 1.0;\
+      end else begin\
        	Dv_j2	= Dv_j1;\
       end\
       Dv_j4	= U_cap-Dv_j1;\
@@ -129,30 +167,25 @@
       DCln2	= ln(1.0-Dv_j2/u_d);\
       Dz1	= 1.0-z;\
       Dzr1	= 1.0-Dz_r;\
-      DC_j1	= c_0*exp(DCln2*(-z))*De_1*De_2;\
-      DC_j2	= DC_c*exp(DCln1*(-Dz_r))*(1.0-De_2);\
-      DC_j3	= DC_max*(1.0-De_1);\
-      C		= DC_j1+DC_j2+DC_j3;\
       DQ_j1	= c_0*(1.0-exp(DCln2*Dz1))/Dz1;\
       DQ_j2	= DC_c*(1.0-exp(DCln1*Dzr1))/Dzr1;\
       DQ_j3	= DC_c*(1.0-exp(DCln2*Dzr1))/Dzr1;\
       Qz	= (DQ_j1+DQ_j2-DQ_j3)*u_d+DC_max*Dv_j4;\
   end else begin\
-      C		= 0.0;\
       Qz	= 0.0;\
   end
 
 
 
 
-// DEPLETION CAPACITANCE AND CHARGE CALCULATION SELECTOR:
+// DEPLETION CHARGE CALCULATION SELECTOR
 // Dependent on junction punch-through voltage
 // Important for collector related junctions
-`define HICJCAP(c_0,u_d,z,v_pt,U_cap,C,Qz)\
+`define HICJQ(c_0,u_d,z,v_pt,U_cap,Qz)\
     if(v_pt < `VPT_thresh) begin\
-        `QCJMOD(c_0,u_d,z,2.4,v_pt,U_cap,C,Qz)\
+        `QJMOD(c_0,u_d,z,2.4,v_pt,U_cap,Qz)\
     end else begin\
-        `QCJMODF(c_0,u_d,z,2.4,U_cap,C,Qz)\
+        `QJMODF(c_0,u_d,z,2.4,U_cap,Qz)\
     end
 
 
@@ -182,6 +215,23 @@
       	end
 
 
+// NEEDED TO CALCULATE WEIGHTED ICCR COLLECTOR MINORITY CHARGE
+// INPUT:
+//  z : zeta_b or zeta_l
+//  w : normalized injection width
+// OUTPUT:
+//  hicfcto   	: output
+//  dhicfcto_dw : derivative of output wrt w
+`define HICFCT(z,lnz,w,hicfcto,dhicfcto_dw)\
+    a = z*w;\
+    if (a > 1.0e-6) begin\
+        hicfcto   	= (a - lnz)/z;\
+        dhicfcto_dw 	= a / (1.0 + a);\
+    end else begin\
+        hicfcto   	= 0.5 * a * w;\
+        dhicfcto_dw 	= a;\
+    end
+
 
 // COLLECTOR CURRENT SPREADING CALCULATION
 // collector minority charge incl. 2D/3D current spreading (TED 10/96)
@@ -221,7 +271,7 @@
         		FCd_a		= 1.0/(1.0-FCf1*latb);\
 			FCw		= FCf1*FCd_a;\
         		FCdw_daick	= -1.0*FCd_a*FCd_a;\
-        		FClnb     	= latb*FCw;\
+            		FClnb     	= latb*FCw;\
             		FClnl     	= latl*FCw;\
            		FCa1      	= FCz*FCw;\
             		FCda1_dw  	= FCz;\
@@ -236,9 +286,17 @@
         	FCdfc_dw	= FCf_CT*(FCa1*FCdf1_dw+FCda1_dw*FCf1-FCdf2_dw+FCdf3_dw);\
 		FCdw_ditf	= FCdw_daick*FCdaick_ditf;\
 		FCdfc_ditf	= FCdfc_dw*FCdw_ditf;\
-		FCf_CT		= FCf_ci;\
-      		FCdfCT_ditf	= FCdfc_ditf;\
-      	end else begin\
+		if(flcomp == 0.0 || flcomp == 2.1) begin\
+			`HICFCT(latb,FClnb,FCw,FCf2,FCdf2_dw)\
+        		`HICFCT(latl,FClnl,FCw,FCf3,FCdf3_dw)\
+			FCf_CT		= FCf_CT*(FCf2-FCf3);\
+			FCdfCT_dw 	= FCf_CT*(FCdf2_dw-FCdf3_dw);\
+			FCdfCT_ditf	= FCdfCT_dw*FCdw_ditf;\
+		end else begin\
+			FCf_CT		= FCf_ci;\
+			FCdfCT_ditf	= FCdfc_ditf;\
+		end\
+	end else begin\
         	if(latb > 0.01) begin\
         		FCd_a		= 1.0/(1.0+FCa_ck*latb);\
         		FCw		= (1.0-FCa_ck)*FCd_a;\
@@ -255,15 +313,25 @@
         	FCdfc_dw	= 2.0*FCw*(FCz_1+FCz*FCz/3.0)*FCd_f*FCd_f;\
 		FCdw_ditf	= FCdw_daick*FCdaick_ditf;\
 		FCdfc_ditf	= FCdfc_dw*FCdw_ditf;\
-		FCf_CT		= FCf_ci;\
-      		FCdfCT_ditf	= FCdfc_ditf;\
+		if(flcomp == 0.0 || flcomp == 2.1) begin\
+			if (FCz > 0.001) begin\
+            			FCf_CT    	= 2.0*(FCz_1*ln(FCz_1)-FCz)/(latb*latb*FCz_1);\
+            			FCdfCT_dw 	= 2.0*FCw*FCd_f*FCd_f;\
+       			end else begin\
+            			FCf_CT    	= FCw2*(1.0-FCz/3.0)*FCd_f;\
+            			FCdfCT_dw 	= 2.0*FCw*(1.0-FCz*FCz/3.0)*FCd_f*FCd_f;\
+        		end\
+			FCdfCT_ditf	= FCdfCT_dw*FCdw_ditf;\
+		end else begin\
+			FCf_CT		= FCf_ci;\
+			FCdfCT_ditf	= FCdfc_ditf;\
+		end\
      	end\
+     	Q_CT	= Q_fC*FCf_CT;\
       	Q_fC	= Q_fC*FCf_ci;\
-      	Q_CT	= Q_fC*FCf_CT;\
 	T_fC	= FFT_pcS*(FCf_ci+Ix*FCdfc_ditf);\
 	T_cT	= FFT_pcS*(FCf_CT+Ix*FCdfCT_ditf);
 
-
 // TRANSIT-TIME AND STORED MINORITY CHARGE
 // INPUT:
 //  itf		: forward transport current
@@ -315,7 +383,6 @@
 
 
 
-
 // IDEAL DIODE (WITHOUT CAPACITANCE): 
 // conductance calculation not required
 // INPUT:
@@ -345,86 +412,6 @@
         end
 
 
-// CRITICAL CURRENT INDICATING ONSET OF HIGH CURRENT EFFECTS
-// INPUT:
-//  v_c		: unsmoothed effective collector voltage
-//  Orci0_t	: reciprocal of low-field epi resistance
-//  vlim_t 	: limitation voltage
-//  Ovpt 	: reciprocal of punch-through voltage
-// IMPLICIT INPUT:
-//  VT		: thermal voltage
-// OUTPUT:
-//  I_CK  	: critical current
-//  v_ceff	: smoothed effective collector voltage
-`define HICICK(v_c,Orci0_t,vlim_t,Ovpt,I_CK,v_ceff)\
-      ICKv	= v_c/VT;\
-      d1	= ICKv-1;\
-      v_ceff	= (1.0+((d1+sqrt(d1*d1+1.921812))/2))*VT;\
-      ICKv	= v_ceff/vlim_t;\
-      I_CK	= v_ceff*Orci0_t/sqrt(1.0+ICKv*ICKv);\
-      ICKa	= (v_ceff-vlim_t)*Ovpt;\
-      I_CK	= I_CK*(1.0+(ICKa+sqrt(ICKa*ICKa+1.0e-3))/2.0);
-
-
-// SIMPLE AVALANCHE GENERATION CURRENT
-// INPUT:
-//  itf		: forward component of the transfer current
-//  Ucap	: junction voltage
-//  Cjci	: junction capacitance
-// IMPLICIT INPUT:
-//  cjci0_t,vdci_t,qavl_t,favl_t	: related to model parameters
-// OUTPUT:
-//  iavl	: current generated by avalanche effect
-`define HICAVL(itf,Ucap,Cjci,iavl)\
-      if(Ucap < 0.0 && favl_t > 0.0 && cjci0_t > 0.0) begin\
-            AVLv_bord	= vdci_t-Ucap;\
-            AVLv_q	= qavl_t/Cjci;\
-            AVLU0	= qavl_t/cjci0_t;\
-            if(AVLv_bord > AVLU0) begin\
-              AVLa	= favl_t*exp(-AVLv_q/AVLU0);\
-              AVLS_avl	= AVLa*(AVLU0+(1.0+AVLv_q/AVLU0)*(AVLv_bord-AVLU0));\
-            end else begin\
-              AVLS_avl	= favl_t*AVLv_bord*exp(-AVLv_q/AVLv_bord);\
-            end\
-            iavl	= itf*AVLS_avl;\
-      end else begin\
-      	    iavl	= 0.0;\
-      end
-
-
-// TUNNELING CURRENT FOR EMITTER-BASE BREAKDOWN
-// INPUT:
-//  mostly related to model parameters at different temperature
-//  vgx, vgy		: bandgap voltages
-//  Cp_t, Ci_t		: peripheral and intrinsic c-b junction cap at zero bias
-//  Vp_t, Vi_t		: peripheral and intrinsic c-b built-in potential
-//  Upp, Uii		: peripheral and intrinsic c-b junction voltages 
-//  Cpp, Cii		: peripheral and intrinsic c-b capacitances
-// IMPLICIT INPUT:
-//  tunode,cjep0,vdep,zep,cjei0,vdei,zei	: model parameters
-// OUTPUT:
-//  Itun	: current generated by tunneling effect
-`define HICTUN(vgx,vgy,Cp_t,Ci_t,Vp_t,Vi_t,Upp,Uii,Cpp,Cii,Itun) a_eg=vgx/vgy;\
-	if(tunode==1.0 && cjep0 > 0.0 && vdep >0.0) begin\
-		ab	= (Cp_t/cjep0)*sqrt(a_eg)*Vp_t*Vp_t/(vdep*vdep);\
-		aa	= (vdep/Vp_t)*(cjep0/Cp_t)*pow(a_eg,-1.5);\
-		vve	= -Upp/Vp_t;\
-		cce	= Cpp/Cp_t;\
-		zex	= zep;\
-	end else begin\
-		ab	= (Ci_t/cjei0)*sqrt(a_eg)*Vi_t*Vi_t/(vdei*vdei);\
-		aa	= (vdei/Vi_t)*(cjei0/Ci_t)*pow(a_eg,-1.5);\
-		vve	= -Uii/Vi_t;\
-		cce	= Cii/Ci_t;\
-		zex	= zei;\
-	end\
-	ibets_t	= ibets*ab;\
-	abet_t	= abet*aa;\
-	pocce	= limexp((1-1/zex)*ln(cce));\
-	czz	= ibets_t*vve*pocce;\
-	Itun	= czz*limexp(-abet_t/pocce);
-	
-
 
 // TEMPERATURE UPDATE OF JUNCTION CAPACITANCE RELATED PARAMETERS
 // INPUT:
@@ -442,7 +429,6 @@
 //  c_j_t		: temperature update of "c_j"
 //  vd_t		: temperature update of "vd0"
 //  w_t			: temperature update of "w"
-
 `define TMPHICJ(c_j,vd0,z,w,is_al,vgeff,c_j_t,vd_t,w_t)\
    if (c_j > 0.0) begin\
 		vdj0	= 2*vt0*ln(exp(vd0*0.5/vt0)-exp(-0.5*vd0/vt0));\
@@ -450,10 +436,11 @@
 		vdt	= vdjt+2*VT*ln(0.5*(1+sqrt(1+4*exp(-vdjt/VT))));\
 		vd_t	= vdt;\
 		c_j_t	= c_j*exp(z*ln(vd0/vd_t));\
-		if (is_al == 1)\
+		if (is_al == 1) begin\
 			w_t	= w*vd_t/vd0;\
-		else\
+		end else begin\
 			w_t	= w;\
+		end\
     end else begin\
     		c_j_t	= c_j;\
     		vd_t	= vd0;\
@@ -461,59 +448,14 @@
     end
 
 
-//INTERNAL BASE RESISTANCE DEPENDENT ON QP AND INTERNAL BASE CURRENT
-// INPUT:
-//  R_BI0, f_dqr0, F_GEO, f_qi	: model parameters at device temperature 
-//  Q_p0,  Q_jei, Q_jci, Q_f	: different charge components (section 2.1.6)
-//  ibei			: diode current for internal b-e junction
-// IMPLICIT INPUT:
-//  VT		: thermal voltage
-// OUTPUT:
-//  R_BI	: charge and bias dependent internal base resistance
-`define HICRBI(R_BI0,f_dqr0,F_GEO,f_qi,Q_p0,Q_jei,Q_f,ibei,R_BI)\
-      if(R_BI0 > 0.0) begin\
-      	f_QR	= (1+f_dqr0)*Q_p0;\
-        Qz	= Q_jei+Q_f;\
-	if(Q_f > 0.0) begin\
-        	Q_fi	= Q_f*f_qi;\
-        	f_p	= (Q_jei+Q_fi)/Qz;\
-        end else begin\
-        	f_p	= 1.0;\
-        end\
-        R_BI	= R_BI0*f_QR/(f_QR+Qz);\
-	if( ibei > 0.0) begin\
-      		ETA	= R_BI*ibei*F_GEO/VT;\
-      		if(ETA < 1.0e-6) begin\
-       			R_BI	= R_BI*(1.0-0.5*ETA);\
-      		end else begin\
-        		R_BI	= R_BI*ln(1.0+ETA)/ETA;\
-      		end\
-      	end\
-      	R_BI	= R_BI*f_p;\
-      end else begin\
-        R_BI	= 0.0;\
-      end
-
-
-
-
-
 
 module hic2_full (c,b,e,s,tnode);
 
 //Node definitions
 
 inout 		c,b,e,s,tnode;
-electrical 	c     `P(info="external collector node");
-electrical 	b     `P(info="external base node");
-electrical 	e     `P(info="external emitter node");
-electrical 	s     `P(info="external substrate node");
-electrical 	tnode `P(info="external temperature node");                            
-electrical 	ci    `P(info="internal collector node");
-electrical 	ei    `P(info="internal emitter node");
-electrical 	bp    `P(info="internal base node p");
-electrical 	bi    `P(info="internal base node i");
-electrical 	si    `P(info="internal substrate node");
+electrical 	c,b,e,s,ci,ei,bp,bi,si;
+electrical 	tnode;
 
 //Branch definitions
 branch 		(b,bp) 		br_bbp_i;
@@ -545,108 +487,108 @@
 
 
 //Transfer current
-parameter real c10  	= 2.0E-30	from [0:1]	`ATTR(info="GICCR constant"); 
-parameter real qp0  	= 2.0E-14	from (0:1] 	`ATTR(info="Zero-bias hole charge");
-parameter real ich  	= 0.0		from [0:inf)	`ATTR(info="High-current correction for 2D and 3D effects"); //`0' signifies infinity 
+parameter real c10  	= 2.0E-30	from [0:1]	`ATTR(info="GICCR constant" unit="A^2s"); 
+parameter real qp0  	= 2.0E-14	from (0:1] 	`ATTR(info="Zero-bias hole charge" unit="Coul");
+parameter real ich  	= 0.0		from [0:inf)	`ATTR(info="High-current correction for 2D and 3D effects" unit="A"); //`0' signifies infinity 
 parameter real hfe  	= 1.0		from [0:inf]	`ATTR(info="Emitter minority charge weighting factor in HBTs");
 parameter real hfc  	= 1.0		from [0:inf]	`ATTR(info="Collector minority charge weighting factor in HBTs");
 parameter real hjei 	= 1.0		from [0:100]	`ATTR(info="B-E depletion charge weighting factor in HBTs");
 parameter real hjci 	= 1.0		from [0:100]	`ATTR(info="B-C depletion charge weighting factor in HBTs"); 
 
 //Base-Emitter diode currents
-parameter real ibeis 	= 1.0E-18	from [0:1]	`ATTR(info="Internal B-E saturation current"); 
+parameter real ibeis 	= 1.0E-18	from [0:1]	`ATTR(info="Internal B-E saturation current" unit="A"); 
 parameter real mbei  	= 1.0		from (0:10]	`ATTR(info="Internal B-E current ideality factor"); 
-parameter real ireis 	= 0.0		from [0:1]	`ATTR(info="Internal B-E recombination saturation current"); 
+parameter real ireis 	= 0.0		from [0:1]	`ATTR(info="Internal B-E recombination saturation current" unit="A"); 
 parameter real mrei  	= 2.0		from (0:10]	`ATTR(info="Internal B-E recombination current ideality factor"); 
-parameter real ibeps 	= 0.0		from [0:1]	`ATTR(info="Peripheral B-E saturation current"); 
+parameter real ibeps 	= 0.0		from [0:1]	`ATTR(info="Peripheral B-E saturation current" unit="A"); 
 parameter real mbep  	= 1.0		from (0:10]	`ATTR(info="Peripheral B-E current ideality factor"); 
-parameter real ireps 	= 0.0		from [0:1]	`ATTR(info="Peripheral B-E recombination saturation current"); 
+parameter real ireps 	= 0.0		from [0:1]	`ATTR(info="Peripheral B-E recombination saturation current" unit="A"); 
 parameter real mrep  	= 2.0		from (0:10]	`ATTR(info="Peripheral B-E recombination current ideality factor"); 
 parameter real mcf  	= 1.0		from (0:10]	`ATTR(info="Non-ideality factor for III-V HBTs");
 
 //Transit time for excess recombination current at b-c barrier
-parameter real tbhrec	= 0.0		from [0:inf)	`ATTR(info="Base current recombination time constant at B-C barrier for high forward injection"); 
+parameter real tbhrec	= 0.0		from [0:inf)	`ATTR(info="Base current recombination time constant at B-C barrier for high forward injection" unit="s"); 
 
 //Base-Collector diode currents
-parameter real ibcis 	= 1.0E-16	from [0:1.0]	`ATTR(info="Internal B-C saturation current"); 
+parameter real ibcis 	= 1.0E-16	from [0:1.0]	`ATTR(info="Internal B-C saturation current" unit="A"); 
 parameter real mbci  	= 1.0		from (0:10]	`ATTR(info="Internal B-C current ideality factor"); 
-parameter real ibcxs 	= 0.0		from [0:1.0]	`ATTR(info="External B-C saturation current"); 
+parameter real ibcxs 	= 0.0		from [0:1.0]	`ATTR(info="External B-C saturation current" unit="A"); 
 parameter real mbcx  	= 1.0		from (0:10]	`ATTR(info="External B-C current ideality factor"); 
 
 //Base-Emitter tunneling current
-parameter real ibets 	= 0.0		from [0:1]	`ATTR(info="B-E tunneling saturation current"); 
+parameter real ibets 	= 0.0		from [0:1]	`ATTR(info="B-E tunneling saturation current" unit="A"); 
 parameter real abet  	= 40		from [0:inf)	`ATTR(info="Exponent factor for tunneling current"); 
 parameter integer tunode= 1		from [0:1]	`ATTR(info="Specifies the base node connection for the tunneling current"); // =1 signifies perimeter node
 
 //Base-Collector avalanche current
-parameter real favl  	= 0.0		from [0:inf)	`ATTR(info="Avalanche current factor"); 
-parameter real qavl  	= 0.0		from [0:inf)	`ATTR(info="Exponent factor for avalanche current"); 
-parameter real alfav 	= 0.0				`ATTR(info="Relative TC for FAVL"); 
-parameter real alqav 	= 0.0				`ATTR(info="Relative TC for QAVL"); 
+parameter real favl  	= 0.0		from [0:inf)	`ATTR(info="Avalanche current factor" unit="1/V"); 
+parameter real qavl  	= 0.0		from [0:inf)	`ATTR(info="Exponent factor for avalanche current" unit="Coul"); 
+parameter real alfav 	= 0.0				`ATTR(info="Relative TC for FAVL" unit="1/K"); 
+parameter real alqav 	= 0.0				`ATTR(info="Relative TC for QAVL" unit="1/K"); 
 
 //Series resistances
-parameter real rbi0  	= 0.0		from [0:inf)	`ATTR(info="Zero bias internal base resistance"); 	
-parameter real rbx   	= 0.0		from [0:inf)	`ATTR(info="External base series resistance"); 
+parameter real rbi0  	= 0.0		from [0:inf)	`ATTR(info="Zero bias internal base resistance" unit="Ohm"); 	
+parameter real rbx   	= 0.0		from [0:inf)	`ATTR(info="External base series resistance" unit="Ohm"); 
 parameter real fgeo  	= 0.6557	from [0:1]	`ATTR(info="Factor for geometry dependence of emitter current crowding"); 
 parameter real fdqr0 	= 0.0		from [0:1]	`ATTR(info="Correction factor for modulation by B-E and B-C space charge layer"); 	
 parameter real fcrbi 	= 0.0		from [0:1]	`ATTR(info="Ratio of HF shunt to total internal capacitance (lateral NQS effect)");
 parameter real fqi   	= 1.0		from [0:1]	`ATTR(info="Ration of internal to total minority charge"); 
-parameter real re    	= 0.0		from [0:inf)	`ATTR(info="Emitter series resistance"); 
-parameter real rcx   	= 0.0		from [0:inf)	`ATTR(info="External collector series resistance"); 
+parameter real re    	= 0.0		from [0:inf)	`ATTR(info="Emitter series resistance" unit="Ohm"); 
+parameter real rcx   	= 0.0		from [0:inf)	`ATTR(info="External collector series resistance" unit="Ohm"); 
 
 //Substrate transistor
-parameter real itss 	= 0.0		from [0:1.0]	`ATTR(info="Substrate transistor transfer saturation current"); 
+parameter real itss 	= 0.0		from [0:1.0]	`ATTR(info="Substrate transistor transfer saturation current" unit="A"); 
 parameter real msf 	= 1.0		from (0:10]	`ATTR(info="Forward ideality factor of substrate transfer current"); 
-parameter real iscs	= 0.0		from [0:1.0]	`ATTR(info="C-S diode saturation current"); 
+parameter real iscs	= 0.0		from [0:1.0]	`ATTR(info="C-S diode saturation current" unit="A"); 
 parameter real msc  	= 1.0		from (0:10]	`ATTR(info="Ideality factor of C-S diode current"); 
-parameter real tsf  	= 0.0		from [0:inf)	`ATTR(info="Transit time for forward operation of substrate transistor"); 
+parameter real tsf  	= 0.0		from [0:inf)	`ATTR(info="Transit time for forward operation of substrate transistor" unit="s"); 
 
 //Intra-device substrate coupling
-parameter real rsu 	= 0.0		from [0:inf)	`ATTR(info="Substrate series resistance"); 
-parameter real csu 	= 0.0		from [0:inf)	`ATTR(info="Substrate shunt capacitance");
+parameter real rsu 	= 0.0		from [0:inf)	`ATTR(info="Substrate series resistance" unit="Ohm"); 
+parameter real csu 	= 0.0		from [0:inf)	`ATTR(info="Substrate shunt capacitance" unit="F");
 
 //Depletion Capacitances
-parameter real cjei0 	= 1.0E-20	from [0:inf)	`ATTR(info="Internal B-E zero-bias depletion capacitance"); 
-parameter real vdei  	= 0.9		from (0:10]	`ATTR(info="Internal B-E built-in potential"); 
+parameter real cjei0 	= 1.0E-20	from [0:inf)	`ATTR(info="Internal B-E zero-bias depletion capacitance" unit="F"); 
+parameter real vdei  	= 0.9		from (0:10]	`ATTR(info="Internal B-E built-in potential" unit="V"); 
 parameter real zei   	= 0.5		from (0:1]	`ATTR(info="Internal B-E grading coefficient"); 
 parameter real ajei 	= 2.5		from [1:inf)	`ATTR(info="Ratio of maximum to zero-bias value of internal B-E capacitance"); 
-parameter real cjep0 	= 1.0E-20	from [0:inf)	`ATTR(info="Peripheral B-E zero-bias depletion capacitance"); 
-parameter real vdep  	= 0.9		from (0:10]	`ATTR(info="Peripheral B-E built-in potential"); 
+parameter real cjep0 	= 1.0E-20	from [0:inf)	`ATTR(info="Peripheral B-E zero-bias depletion capacitance" unit="F"); 
+parameter real vdep  	= 0.9		from (0:10]	`ATTR(info="Peripheral B-E built-in potential" unit="V"); 
 parameter real zep   	= 0.5		from (0:1]	`ATTR(info="Peripheral B-E grading coefficient"); 
 parameter real ajep 	= 2.5		from [1:inf)	`ATTR(info="Ratio of maximum to zero-bias value of peripheral B-E capacitance"); 
-parameter real cjci0 	= 1.0E-20	from [0:inf)	`ATTR(info="Internal B-C zero-bias depletion capacitance"); 
-parameter real vdci  	= 0.7		from (0:10]	`ATTR(info="Internal B-C built-in potential"); 
+parameter real cjci0 	= 1.0E-20	from [0:inf)	`ATTR(info="Internal B-C zero-bias depletion capacitance" unit="F"); 
+parameter real vdci  	= 0.7		from (0:10]	`ATTR(info="Internal B-C built-in potential" unit="V"); 
 parameter real zci   	= 0.4		from (0:1]	`ATTR(info="Internal B-C grading coefficient"); 
-parameter real vptci 	= 100		from (0:100]	`ATTR(info="Internal B-C punch-through voltage"); 
-parameter real cjcx0 	= 1.0E-20	from [0:inf)	`ATTR(info="External B-C zero-bias depletion capacitance"); 
-parameter real vdcx  	= 0.7		from (0:10]	`ATTR(info="External B-C built-in potential"); 
+parameter real vptci 	= 100		from (0:100]	`ATTR(info="Internal B-C punch-through voltage" unit="V"); 
+parameter real cjcx0 	= 1.0E-20	from [0:inf)	`ATTR(info="External B-C zero-bias depletion capacitance" unit="F"); 
+parameter real vdcx  	= 0.7		from (0:10]	`ATTR(info="External B-C built-in potential" unit="V"); 
 parameter real zcx   	= 0.4		from (0:1]	`ATTR(info="External B-C grading coefficient"); 
-parameter real vptcx 	= 100		from (0:100]	`ATTR(info="External B-C punch-through voltage"); 
+parameter real vptcx 	= 100		from (0:100]	`ATTR(info="External B-C punch-through voltage" unit="V"); 
 parameter real fbcpar   = 0.0		from [0:1]	`ATTR(info="Partitioning factor of parasitic B-C cap"); 
 parameter real fbepar   = 1.0		from [0:1]	`ATTR(info="Partitioning factor of parasitic B-E cap"); 
-parameter real cjs0  	= 0.0		from [0:inf)	`ATTR(info="C-S zero-bias depletion capacitance"); 
-parameter real vds   	= 0.6		from (0:10]	`ATTR(info="C-S built-in potential"); 
+parameter real cjs0  	= 0.0		from [0:inf)	`ATTR(info="C-S zero-bias depletion capacitance" unit="F"); 
+parameter real vds   	= 0.6		from (0:10]	`ATTR(info="C-S built-in potential" unit="V"); 
 parameter real zs    	= 0.5		from (0:1]	`ATTR(info="C-S grading coefficient"); 
-parameter real vpts  	= 100		from (0:100]	`ATTR(info="C-S punch-through voltage");
+parameter real vpts  	= 100		from (0:100]	`ATTR(info="C-S punch-through voltage" unit="V");
 
 //Diffusion Capacitances
-parameter real t0    	= 0.0		from [0:inf)	`ATTR(info="Low current forward transit time at VBC=0V"); 
-parameter real dt0h 	= 0.0				`ATTR(info="Time constant for base and B-C space charge layer width modulation");
-parameter real tbvl  	= 0.0		from [0:inf)	`ATTR(info="Time constant for modelling carrier jam at low VCE"); 
-parameter real tef0  	= 0.0		from [0:inf)	`ATTR(info="Neutral emitter storage time"); 	
+parameter real t0    	= 0.0		from [0:inf)	`ATTR(info="Low current forward transit time at VBC=0V" unit="s"); 
+parameter real dt0h 	= 0.0				`ATTR(info="Time constant for base and B-C space charge layer width modulation" unit="s");
+parameter real tbvl  	= 0.0		from [0:inf)	`ATTR(info="Time constant for modelling carrier jam at low VCE" unit="s"); 
+parameter real tef0  	= 0.0		from [0:inf)	`ATTR(info="Neutral emitter storage time" unit="s"); 	
 parameter real gtfe  	= 1.0		from (0:10]	`ATTR(info="Exponent factor for current dependence of neutral emitter storage time");
-parameter real thcs  	= 0.0		from [0:inf)	`ATTR(info="Saturation time constant at high current densities"); 
+parameter real thcs  	= 0.0		from [0:inf)	`ATTR(info="Saturation time constant at high current densities" unit="s"); 
 parameter real ahc  	= 0.1		from (0:10]	`ATTR(info="Smoothing factor for current dependence of base and collector transit time"); 
 parameter real fthc  	= 0.0		from [0:1]	`ATTR(info="Partitioning factor for base and collector portion"); 
-parameter real rci0  	= 150		from (0:inf)	`ATTR(info="Internal collector resistance at low electric field");
-parameter real vlim  	= 0.5		from (0:10]	`ATTR(info="Voltage separating ohmic and saturation velocity regime"); 
-parameter real vces  	= 0.1		from [0:1]	`ATTR(info="Internal C-E saturation voltage"); 
-parameter real vpt   	= 0.0		from [0:inf]	`ATTR(info="Collector punch-through voltage"); // `0' signifies infinity
-parameter real tr	= 0.0		from [0:inf)	`ATTR(info="Storage time for inverse operation"); 
+parameter real rci0  	= 150		from (0:inf)	`ATTR(info="Internal collector resistance at low electric field" unit="Ohm");
+parameter real vlim  	= 0.5		from (0:10]	`ATTR(info="Voltage separating ohmic and saturation velocity regime" unit="V"); 
+parameter real vces  	= 0.1		from [0:1]	`ATTR(info="Internal C-E saturation voltage" unit="V"); 
+parameter real vpt   	= 0.0		from [0:inf]	`ATTR(info="Collector punch-through voltage" unit="V"); // `0' signifies infinity
+parameter real tr	= 0.0		from [0:inf)	`ATTR(info="Storage time for inverse operation" unit="s"); 
 
 //Isolation Capacitances
-parameter real cbepar 	= 0.0		from [0:inf)	`ATTR(info="Total parasitic B-E capacitance"); 
-parameter real cbcpar 	= 0.0		from [0:inf)	`ATTR(info="Total parasitic B-C capacitance");
+parameter real cbepar 	= 0.0		from [0:inf)	`ATTR(info="Total parasitic B-E capacitance" unit="F"); 
+parameter real cbcpar 	= 0.0		from [0:inf)	`ATTR(info="Total parasitic B-C capacitance" unit="F");
 
 //Non-quasi-static Effect 
 parameter real alqf 	= 0.0		from [0:1]	`ATTR(info="Factor for additional delay time of minority charge"); 
@@ -663,130 +605,106 @@
 parameter real latl    	= 0.0		from [0:inf)	`ATTR(info="Scaling factor for collector minority charge in direction of emitter length");
 
 //Temperature dependence	
-parameter real vgb     	= 1.17		from (0:10]	`ATTR(info="Bandgap voltage extrapolated to 0 K"); 
-parameter real alt0    	= 0.0				`ATTR(info="First order relative TC of parameter T0");
+parameter real vgb     	= 1.17		from (0:10]	`ATTR(info="Bandgap voltage extrapolated to 0 K" unit="V"); 
+parameter real alt0    	= 0.0				`ATTR(info="First order relative TC of parameter T0" unit="1/K");
 parameter real kt0     	= 0.0				`ATTR(info="Second order relative TC of parameter T0");
 parameter real zetaci  	= 0.0				`ATTR(info="Temperature exponent for RCI0");		
-parameter real alvs    	= 0.0				`ATTR(info="Relative TC of saturation drift velocity"); 
-parameter real alces   	= 0.0				`ATTR(info="Relative TC of VCES"); 
+parameter real alvs    	= 0.0				`ATTR(info="Relative TC of saturation drift velocity" unit="1/K"); 
+parameter real alces   	= 0.0				`ATTR(info="Relative TC of VCES" unit="1/K"); 
 parameter real zetarbi 	= 0.0				`ATTR(info="Temperature exponent of internal base resistance");		
 parameter real zetarbx 	= 0.0				`ATTR(info="Temperature exponent of external base resistance");		
 parameter real zetarcx 	= 0.0				`ATTR(info="Temperature exponent of external collector resistance");		
 parameter real zetare  	= 0.0				`ATTR(info="Temperature exponent of emitter resistance");		
 parameter real zetacx  	= 1.0				`ATTR(info="Temperature exponent of mobility in substrate transistor transit time");		               
-parameter real vge    	= 1.17		from (0:10]	`ATTR(info="Effective emitter bandgap voltage");            
-parameter real vgc    	= 1.17		from (0:10]	`ATTR(info="Effective collector bandgap voltage");        
-parameter real vgs    	= 1.17		from (0:10]	`ATTR(info="Effective substrate bandgap voltage"); 
+parameter real vge    	= 1.17		from (0:10]	`ATTR(info="Effective emitter bandgap voltage" unit="V");            
+parameter real vgc    	= 1.17		from (0:10]	`ATTR(info="Effective collector bandgap voltage" unit="V");        
+parameter real vgs    	= 1.17		from (0:10]	`ATTR(info="Effective substrate bandgap voltage" unit="V"); 
 parameter real f1vg   	=-1.02377e-4			`ATTR(info="Coefficient K1 in T-dependent band-gap equation");
 parameter real f2vg   	= 4.3215e-4			`ATTR(info="Coefficient K2 in T-dependent band-gap equation");                
 parameter real zetact 	= 3.0				`ATTR(info="Exponent coefficient in transfer current temperature dependence");
 parameter real zetabet	= 3.5				`ATTR(info="Exponent coefficient in B-E junction current temperature dependence");		             
-parameter real alb	= 0.0				`ATTR(info="Relative TC of forward current gain for V2.1 model");
+parameter real alb	= 0.0				`ATTR(info="Relative TC of forward current gain for V2.1 model" unit="1/K");
 
 //Self-Heating
 parameter integer flsh 	= 0		from [0:2]	`ATTR(info="Flag for turning on and off self-heating effect");
-parameter real rth 	= 0.0		from [0:inf)	`ATTR(info="Thermal resistance"); 
-parameter real cth 	= 0.0		from [0:inf)	`ATTR(info="Thermal capacitance"); 
+parameter real rth 	= 0.0		from [0:inf)	`ATTR(info="Thermal resistance" unit="K/W"); 
+parameter real cth 	= 0.0		from [0:inf)	`ATTR(info="Thermal capacitance" unit="J/W"); 
 
 //Compatibility with V2.1
-parameter integer flcomp = 0		from [0:1]	`ATTR(info="Flag for compatibility with v2.1 model (0=v2.1)");
+parameter real flcomp = 0.0		from [0:inf)	`ATTR(info="Flag for compatibility with v2.1 model (0=v2.1)");
 
 //Circuit simulator specific parameters
-parameter real tnom  	= 27.0				`ATTR(info="Temperature at which parameters are specified");
-parameter real dt    	= 0.0				`ATTR(info="Temperature change w.r.t. chip temperature for particular transistor");
-
-	//Declaration of variables: begin
-	
-	
-        //Temperature and drift
-        real VT,Tamb,Tdev,Tnom,qtt0,ln_qtt0,r_VgVT,V_gT,dT,k;
-	real ireis_t,ibeis_t,ibcxs_t,ibcis_t;
-	real iscs_t,cje0_t,cjci0_t,cjcx0_t;
-	real cjs0_t,rci0_t,vlim_t;
-	real vces_t,thcs_t,tef0_t,rbi_t,rbi0_t;
-	real rbx_t,rcx_t,re_t,rsu_t,t0_t;
-	real vdei_t,vdci_t;
-	real c10_t,cjei0_t,qp0_t;
-      	real vdcx_t,vptcx_t,cjcx01_t,cjcx02_t,vpts_t,itss_t,tsf_t;
-      	real ibeps_t,ireps_t,cjep0_t,ibets_t,abet_t;
-      	real ajei_t,qavl_t,favl_t,vptci_t,vdep_t,ajep_t;
-      	
-      	//Band-gap related
-      	real mg,zetabci,zetabcxt,zetasct,zetatef,avs;
-      	real k1,k2,k10,k20,vgbe0,vgbc0,vgsc0,dvg0;	
-      	real vgb0,vge0,vgc0,vgs0,vge_t0,vge_t,vgb_t,vgb_t0,vgbe_t,vgbe_t0,vt0;      	
-      	
-        //Charge and capacitance for b-c junction
-        real Qjci,Cjci,Qjcx,Qjcxi,Qjcii,qjcx0_t_i,cbcpar1,cbcpar2,C_1;
-	real cjcx0_t_ii,cjcx0_t_i,qjcx0_t_ii,cratio_t,Cjcit,cc;
-
-        //Charge and capacitance for b-e junction
-        real Qjei,Cjei; 
-        real Qjep,Cjep;
- 
-        //Transfer and base current, related charges and capacitances
-        real itf,itr,it,ibei,irei,ibci,ibep,irep,ibh_rec;
-	real Oich,Orci0_t,Ovpt,Otbhrec,Tf,Tr,VT_f,i_0f,i_0r,a_bpt,Q_0,Q_p,Q_bpt;
-	real T_f0,Q_fT,Q_bf,T_fT,b_q,Q_fC,T_fC,T_cT,I_Tf1,A,a_h,vds_t;
-      	real Q_pT,l_it,d_Q,d_Q0;
-      	real cbepar1,cbepar2,qrbi;
-        
-        //Diffusion charge and critical current
-        real Qf,Qdei,tf0;
-        real Qr,Qdci;       
-        real ick;
-        real vc,vceff;
-	
-	//Tunneling current
-	real ibet;
-
-        //Avalanche current
-	real iavl;
-	
-	//Base resistance
-        real rbi; 
+parameter real tnom  	= 27.0				`ATTR(info="Temperature at which parameters are specified" unit="C");
+parameter real dt    	= 0.0				`ATTR(info="Temperature change w.r.t. chip temperature for particular transistor" unit="K");
 
-        //External b-c diode and cap
-        real ijbcx,cjcx01,cjcx02;
 
-        //Substrate diode and cap
-        real ijsc,Cjs,Qjs;
-        
-        //Substrate Transistor
-        real  HSUM,HSI_Tsu,HSa,HSb,Qdsu;
+//
+//======================== Transistor model formulation =================== 
+//
 
-	//Self heating
-	real pterm,itnode,qtnode;	
+	//Declaration of variables
+	
+	//Temperature and drift
+        real VT,Tdev,qtt0,ln_qtt0,r_VgVT,V_gT,dT,k;
+	real ireis_t,ibeis_t,ibcxs_t,ibcis_t,iscs_t,cjci0_t;
+	real cjs0_t,rci0_t,vlim_t,vces_t,thcs_t,tef0_t,rbi0_t;
+	real rbx_t,rcx_t,re_t,t0_t,vdei_t,vdci_t,vpts_t,itss_t,tsf_t;
+	real c10_t,cjei0_t,qp0_t,vdcx_t,vptcx_t,cjcx01_t,cjcx02_t;
+	real qjcx0_t_i,qjcx0_t_ii,cratio_t;
+      	real ibeps_t,ireps_t,cjep0_t;
+      	real ajei_t,qavl_t,favl_t,ibets_t,abet_t,vptci_t,vdep_t,ajep_t,zetatef;
+      	real k1,k2,dvg0,vge_t,vgb_t,vgbe_t,vds_t,vt0,Tnom,Tamb,a,avs;
+      	real zetabci,zetabcxt,zetasct,vgbe0,mg,vgb_t0,vge_t0,vgbe_t0,vgbc0,vgsc0;	
+      	real cbcpar1,cbcpar2,cbepar2,cbepar1,Oich,Ovpt,Otbhrec;
+      	
+        //Charges, capacitances and currents
+        real Qjci,Qjei,Qjep;
+        real it,ibei,irei,ibci,ibep,irep,ibh_rec;
+        real Qdei,Qdci,qrbi;       
+	real ibet,iavl;
+        real ijbcx,ijsc,Qjs,HSUM,HSI_Tsu,Qdsu;
+	
+	//Base resistance and self-heating power
+	real rbi,pterm;
+	
+	//Variables for macro TMPHICJ
+	real  vdj0,vdjt,vdt;
+	
+	//Model initialization
+	real k10,k20,C_1;
+	
+	//Model evaluation
+	real Cjci,Cjcit,cc,Cjei,Cjep;
+        real itf,itr,Tf,Tr,VT_f,i_0f,i_0r,a_bpt,Q_0,Q_p,Q_bpt;
+	real Orci0_t,b_q,Q_fC,T_fC,T_cT,I_Tf1,T_f0,Q_fT,T_fT,Q_bf;
+	real ICKa,d1;
+	real A,a_h,Q_pT,d_Q,d_Q0;
+	real Qf,Cdei,Qr,Cdci,Crbi;
+        real ick,vc,vceff,cjcx01,cjcx02,HSa,HSb;
+	integer l_it;
 	
-	//Macro test
-	real  ICKv,ICKa;	//HICICK
-	real  AVLS_avl,AVLv_bord,AVLv_q,AVLU0,AVLa;//HICAVL
-        real  vdj0,vdjt,vdt,d1; //TMPHICJ 
+	//Variables for macros
 	real  DIOY,le;//HICDIO
 	real  FFT_fbS,FFa,FFx,FFs,FFw,FFw_2,FFd_QfB,FFd_TfB,FFT_pcS,FFQ_fC,FFT_fC,FFQ_cT,FFT_cT,FFd_TfE,FFd_QfE,FFa_w;//HICQFF
-	real  FCz,FCw2,FCf1,FCf2,FCf3,FCf_ci,FCz_1;//HICQFC
-	real  FCd_a,FCdaick_ditf,FCa,FCw,FCdw_daick,FCdfc_dw,FCdw_ditf,FCdfc_ditf,FCf_CT,FCdfCT_ditf,FCrt,FCln,FClnl,FClnb,FCda1_dw,FCdf1_dw,FCdf2_dw,FCdf3_dw,FCd_f;//HICQFC
-	real  FCa1,FCa_ck,FCxl,FCxb;//HICQFC
-	real  Dz_r,Dv_p,DV_f,DC_max,DC_c,Da,Dv_e,De,De_1,Dv_j1,Dv_r,De_2,Dv_j2,Dv_j4,DC_j1,DC_j2,DC_j3,DQ_j1,DQ_j2,DQ_j3,DCln1,DCln2,Dz1,Dzr1;//QCJMOD
-	real  DFV_f,DFC_max,DFa,DFv_e,DFv_j,DFb,DFC_j1,DFQ_j,DFdvj_dv,DFs_q,DFs_q2;//QCJMODF
-	real  z,a,a2,a3,r,x;//HICFCI
-	real  f_QR,Qz,f_p,ETA,Q_fi; //HICRBI
-	real  a_eg,aa,ab,vve,cce,pocce,zex,czz; //HICTUN
+	real  FCz,FCw2,FCf1,FCf2,FCf3,FCf_ci,FCz_1,FCa1,FCa_ck,FCxl,FCxb;//HICQFC
+	real  FCd_a,FCdaick_ditf,FCa,FCw,FCdw_daick,FCdfc_dw,FCdw_ditf,FCdfc_ditf,FCf_CT,FCdfCT_ditf,FCrt,FCln,FClnl,FClnb,FCda1_dw,FCdf1_dw,FCdf2_dw,FCdf3_dw,FCd_f,FCdfCT_dw;//HICQFC
+	real  Dz_r,Dv_p,DV_f,DC_max,DC_c,Da,Dv_e,De,De_1,Dv_j1,Dv_r,De_2,Dv_j2,Dv_j4,DQ_j1,DQ_j2,DQ_j3,DCln1,DCln2,Dz1,Dzr1;//QJMOD
+	real  DFV_f,DFv_e,DFv_j,DFb,DFQ_j,DFs_q,DFs_q2;//QJMODF
+	real  z,a2,a3,r,x;//HICFCI
+	real zb,zl,lnzb,w,hicfcio,dhicfcio_dw; //HICFCT
 	
 	//Noise
-  	real fourkt,twoq,flicker_Pwr;
-
-
-	//Declaration of variables: end
-
-//
-//======================== Transistor model formulation =================== 
-//
+	real fourkt,twoq,flicker_Pwr;
 
+// don't like it inside named blocks
+	real a_eg,ab,aa;
+	
+	//end of variables
+	
 analog begin
 
-`MODEL begin	// Model Initialization
-
+`MODEL begin : Model_initialization
+	
 	Tnom    = tnom+`P_CELSIUS0;
 	Tamb    = $temperature;
 	vt0     = `P_K*Tnom /`P_Q;
@@ -822,142 +740,371 @@
 	//Parasitic b-e capacitance partitioning: No temperature dependence
 	cbepar2	= fbepar*cbepar;
 	cbepar1	= cbepar-cbepar2;
-        
-end	// Model initialization:end
-        
-begin	// Temperature-dependent model evaluation with provision for self-heating
-        
-        // Temperature and resulting parameter drift
-        Tdev    = Tamb+dt+V(br_sht);
 	
-	// Limit temperature to avoid FPEs in equations
-	if(Tdev < `TMIN + 273.15)
-	   Tdev = `TMIN + 273.15;
-	else
- 	if (Tdev > `TMAX + 273.15)
-	   Tdev = `TMAX + 273.15;
-        
-        VT      = `P_K*Tdev /`P_Q;
-	dT      = Tdev-Tnom;  
-	qtt0    = Tdev/Tnom;
-	ln_qtt0 = ln(qtt0);
-	k1      = f1vg*Tdev*ln(Tdev);
-	k2      = f2vg*Tdev;
-        vgb_t   = vgb+k1+k2;
-        vge_t   = vge+k1+k2;
-        vgbe_t  = (vgb_t+vge_t)/2;
+	//Avoid devide-by-zero and define infinity other way
+	//High current correction for 2D and 3D effects
+    	if (ich != 0.0) begin
+       		Oich 	= 1.0/ich;
+      	end else begin
+       		Oich	= 0.0;
+       	end
+       
+       	//Base current recombination time constant at b-c barrier
+      	if (tbhrec != 0.0) begin
+       		Otbhrec = 1.0/tbhrec;
+      	end else begin
+       		Otbhrec	= 0.0;
+       	end
+     	
+	//Collector punch-through voltage
+	if(vpt != 0.0) begin
+       		Ovpt	= 1.0/vpt;
+     	end else begin
+       		Ovpt	= 0.0;
+       	end
+	    
+        // Temperature and resulting parameter drift
+        if (flsh==0 || rth < `MIN_R) begin : Thermal_updat_without_self_heating
+        	Tdev    = Tamb+dt;
+        	if(Tdev < `TMIN + 273.15) begin
+	   		Tdev = `TMIN + 273.15;
+		end else begin
+ 		if (Tdev > `TMAX + 273.15) begin
+	   		Tdev = `TMAX + 273.15;
+		end  
+        	end
+       		VT      = `P_K*Tdev /`P_Q;
+		dT      = Tdev-Tnom;  
+		qtt0    = Tdev/Tnom;
+		ln_qtt0 = ln(qtt0);
+		k1      = f1vg*Tdev*ln(Tdev);
+		k2      = f2vg*Tdev;
+        	vgb_t   = vgb+k1+k2;
+        	vge_t   = vge+k1+k2;
+        	vgbe_t  = (vgb_t+vge_t)/2;
         
-        //Internal b-e junction capacitance
-	`TMPHICJ(cjei0,vdei,zei,ajei,1,vgbe0,cjei0_t,vdei_t,ajei_t)
+        	//Internal b-e junction capacitance
+		`TMPHICJ(cjei0,vdei,zei,ajei,1,vgbe0,cjei0_t,vdei_t,ajei_t)
 	
-        if (flcomp ==0) begin
-        V_gT     = 3.0*VT*ln_qtt0 + vgb*(qtt0-1.0);
-        r_VgVT   = V_gT/VT;
-        //Internal b-e diode saturation currents
-        a	 = mcf*r_VgVT/mbei - alb*dT; 
-	ibeis_t  = ibeis*exp(a);
-	a        = mcf*r_VgVT/mrei - alb*dT;
-        ireis_t  = ireis*exp(a);
-	a        = mcf*r_VgVT/mbep - alb*dT;
-	//Peripheral b-e diode saturation currents
-        ibeps_t  = ibeps*exp(a);
-        a        = mcf*r_VgVT/mrep - alb*dT;
-        ireps_t  = ireps*exp(a);
-        //Zero bias hole charge
-        a	 = vdei_t/vdei;
-	qp0_t	 = qp0*(1.0+0.5*zei*(1.0-a));
-	//Neutral emitter storage time
-	a        = 1.0+alb*dT;
-        k        = 0.5*(a+sqrt(a*a+0.01));
-        tef0_t   = tef0*qtt0/k;
-        end else begin
-        //Internal b-e diode saturation currents
-        ibeis_t  = ibeis*exp(zetabet*ln_qtt0+vge/VT*(qtt0-1));
-        ireis_t  = ireis*exp(0.5*mg*ln_qtt0+0.5*vgbe0/VT*(qtt0-1));
-        //Peripheral b-e diode saturation currents
-	ibeps_t	 = ibeps*exp(zetabet*ln_qtt0+vge/VT*(qtt0-1));
-	ireps_t	 = ireps*exp(0.5*mg*ln_qtt0+0.5*vgbe0/VT*(qtt0-1));
-	//Zero bias hole charge
-	a	= exp(zei*ln(vdei_t/vdei));
-	qp0_t	= qp0*(2.0-a);
-        //Neutral emitter storage time
-        zetatef = zetabet-zetact-0.5;
-        dvg0    = vgb-vge;
-        tef0_t  = tef0*exp(zetatef*ln_qtt0-dvg0/VT*(qtt0-1));
-        end        
-	
-	//GICCR prefactor
-	c10_t	= c10*exp(zetact*ln_qtt0+vgb/VT*(qtt0-1));
-
-        // Low-field internal collector resistance
-	rci0_t	= rci0/exp(-zetaci*ln_qtt0);
-
-	//Voltage separating ohmic and saturation velocity regime
-	vlim_t  = vlim*exp((zetaci-avs)*ln_qtt0);
-
-        //Internal c-e saturation voltage
-	vces_t  = vces*(1+alces*dT);
+        	if (flcomp == 0.0 || flcomp == 2.1) begin
+        	V_gT     = 3.0*VT*ln_qtt0 + vgb*(qtt0-1.0);
+        	r_VgVT   = V_gT/VT;
+        	//Internal b-e diode saturation currents
+        	a	 = mcf*r_VgVT/mbei - alb*dT; 
+		ibeis_t  = ibeis*exp(a);
+		a        = mcf*r_VgVT/mrei - alb*dT;
+        	ireis_t  = ireis*exp(a);
+		a        = mcf*r_VgVT/mbep - alb*dT;
+		//Peripheral b-e diode saturation currents
+        	ibeps_t  = ibeps*exp(a);
+        	a        = mcf*r_VgVT/mrep - alb*dT;
+        	ireps_t  = ireps*exp(a);
+        	//Internal b-c diode saturation current
+        	a       = r_VgVT/mbci;
+        	ibcis_t = ibcis*exp(a);
+        	//External b-c diode saturation currents
+		a       = r_VgVT/mbcx;
+        	ibcxs_t = ibcxs*exp(a);
+        	//Saturation transfer current for substrate transistor
+        	a       = r_VgVT/msf;
+        	itss_t  = itss*exp(a);
+        	//Saturation current for c-s diode  
+        	a       = r_VgVT/msc;
+        	iscs_t  = iscs*exp(a);
+        	//Zero bias hole charge
+        	a	 = vdei_t/vdei;
+		qp0_t	 = qp0*(1.0+0.5*zei*(1.0-a));
+		//Voltage separating ohmic and saturation velocity regime
+		a = vlim*(1.0-alvs*dT)*exp(zetaci*ln_qtt0);
+        	k = (a-VT)/VT;
+        	if (k < `LN_EXP_LIMIT) begin
+            		vlim_t = VT + VT*ln(1.0+exp(k));
+        	end else begin
+            		vlim_t = a;
+        	end
+		//Neutral emitter storage time
+		a        = 1.0+alb*dT;
+       		k        = 0.5*(a+sqrt(a*a+0.01));
+        	tef0_t   = tef0*qtt0/k;
+        	end else begin
+        	//Internal b-e diode saturation currents
+        	ibeis_t  = ibeis*exp(zetabet*ln_qtt0+vge/VT*(qtt0-1));
+        	ireis_t  = ireis*exp(0.5*mg*ln_qtt0+0.5*vgbe0/VT*(qtt0-1));
+        	//Peripheral b-e diode saturation currents
+		ibeps_t	 = ibeps*exp(zetabet*ln_qtt0+vge/VT*(qtt0-1));
+		ireps_t	 = ireps*exp(0.5*mg*ln_qtt0+0.5*vgbe0/VT*(qtt0-1));
+		//Internal b-c diode saturation currents
+		ibcis_t = ibcis*exp(zetabci*ln_qtt0+vgc/VT*(qtt0-1));
+		//External b-c diode saturation currents
+		ibcxs_t	= ibcxs*exp(zetabcxt*ln_qtt0+vgc/VT*(qtt0-1));
+		//Saturation transfer current for substrate transistor
+		itss_t	= itss*exp(zetasct*ln_qtt0+vgc/VT*(qtt0-1));
+		//Saturation current for c-s diode   
+		iscs_t  = iscs*exp(zetasct*ln_qtt0+vgs/VT*(qtt0-1));
+		//Zero bias hole charge
+		a	= exp(zei*ln(vdei_t/vdei));
+		qp0_t	= qp0*(2.0-a);
+		//Voltage separating ohmic and saturation velocity regime
+		vlim_t  = vlim*exp((zetaci-avs)*ln_qtt0);
+        	//Neutral emitter storage time
+        	zetatef = zetabet-zetact-0.5;
+        	dvg0    = vgb-vge;
+        	tef0_t  = tef0*exp(zetatef*ln_qtt0-dvg0/VT*(qtt0-1));
+        	end        
+	
+		//GICCR prefactor
+		c10_t	= c10*exp(zetact*ln_qtt0+vgb/VT*(qtt0-1));
+
+        	// Low-field internal collector resistance
+		rci0_t	= rci0*exp(zetaci*ln_qtt0);
+
+		//Voltage separating ohmic and saturation velocity regime
+		//vlim_t  = vlim*exp((zetaci-avs)*ln_qtt0);
+
+        	//Internal c-e saturation voltage
+		vces_t  = vces*(1+alces*dT);
 
 
-        //Internal b-c diode saturation current
-	ibcis_t = ibcis*exp(zetabci*ln_qtt0+vgc/VT*(qtt0-1));
+        	//Internal b-c diode saturation current
+		//ibcis_t = ibcis*exp(zetabci*ln_qtt0+vgc/VT*(qtt0-1));
 
-        //Internal b-c junction capacitance
-        `TMPHICJ(cjci0,vdci,zci,vptci,0,vgbc0,cjci0_t,vdci_t,vptci_t)
+        	//Internal b-c junction capacitance
+        	`TMPHICJ(cjci0,vdci,zci,vptci,0,vgbc0,cjci0_t,vdci_t,vptci_t)
 
-        //Low-current forward transit time
-	t0_t    = t0*(1+alt0*dT+kt0*dT*dT);
+        	//Low-current forward transit time
+		t0_t    = t0*(1+alt0*dT+kt0*dT*dT);
         
-        //Saturation time constant at high current densities
-	thcs_t  = thcs*exp((zetaci-1)*ln_qtt0);
+        	//Saturation time constant at high current densities
+		thcs_t  = thcs*exp((zetaci-1)*ln_qtt0);
 
 
-	//Avalanche caurrent factors
-	favl_t  = favl*exp(alfav*dT);
-	qavl_t  = qavl*exp(alqav*dT);	
+		//Avalanche caurrent factors
+		favl_t  = favl*exp(alfav*dT);
+		qavl_t  = qavl*exp(alqav*dT);	
 
-
-        //Zero bias internal base resistance
-	rbi0_t  = rbi0*exp(zetarbi*ln_qtt0);
+		//Zero bias internal base resistance
+		rbi0_t  = rbi0*exp(zetarbi*ln_qtt0);
 	
 	
-	//Peripheral b-e junction capacitance
-	`TMPHICJ(cjep0,vdep,zep,ajep,1,vgbe0,cjep0_t,vdep_t,ajep_t)
+		//Peripheral b-e junction capacitance
+		`TMPHICJ(cjep0,vdep,zep,ajep,1,vgbe0,cjep0_t,vdep_t,ajep_t)
+		
+		//Tunneling current factors
+		if (V(br_bpei) < 0.0 || V(br_biei) < 0.0) begin // : HICTUN_T
+//			real a_eg,ab,aa;
+			ab	= 1.0;
+			aa	= 1.0;
+			a_eg=vgbe_t0/vgbe_t;
+			if(tunode==1 && cjep0 > 0.0 && vdep >0.0) begin
+				ab	= (cjep0_t/cjep0)*sqrt(a_eg)*vdep_t*vdep_t/(vdep*vdep);
+				aa	= (vdep/vdep_t)*(cjep0/cjep0_t)*pow(a_eg,-1.5);
+			end else if (tunode==0 && cjei0 > 0.0 && vdei >0.0) begin
+				ab	= (cjei0_t/cjei0)*sqrt(a_eg)*vdei_t*vdei_t/(vdei*vdei);
+				aa	= (vdei/vdei_t)*(cjei0/cjei0_t)*pow(a_eg,-1.5);
+			end
+			ibets_t	= ibets*ab;
+			abet_t	= abet*aa;
+		end
 
 
-	//Temperature mapping for tunneling current is done inside HICTUN
+		//Temperature mapping for tunneling current is done inside HICTUN
 
-	`TMPHICJ(1.0,vdcx,zcx,vptcx,0,vgbc0,cratio_t,vdcx_t,vptcx_t)
-	 cjcx01_t=cratio_t*cjcx01;
-	 cjcx02_t=cratio_t*cjcx02;
+		`TMPHICJ(1.0,vdcx,zcx,vptcx,0,vgbc0,cratio_t,vdcx_t,vptcx_t)
+		 cjcx01_t=cratio_t*cjcx01;
+	 	 cjcx02_t=cratio_t*cjcx02;
 
 		
-	//External b-c diode saturation currents   
-	ibcxs_t	= ibcxs*exp(zetabcxt*ln_qtt0+vgc/VT*(qtt0-1));
+		//External b-c diode saturation currents   
+		//ibcxs_t	= ibcxs*exp(zetabcxt*ln_qtt0+vgc/VT*(qtt0-1));
 	
 	
-	//Constant external series resistances
-	rcx_t	= rcx*exp(zetarcx*ln_qtt0);
-	rbx_t	= rbx*exp(zetarbx*ln_qtt0);
-	re_t	= re*exp(zetare*ln_qtt0);
+		//Constant external series resistances
+		rcx_t	= rcx*exp(zetarcx*ln_qtt0);
+		rbx_t	= rbx*exp(zetarbx*ln_qtt0);
+		re_t	= re*exp(zetare*ln_qtt0);
+	
+		//Forward transit time in substrate transistor
+		tsf_t	= tsf*exp((zetacx-1.0)*ln_qtt0);
+
+		//Capacitance for c-s junction
+        	`TMPHICJ(cjs0,vds,zs,vpts,0,vgsc0,cjs0_t,vds_t,vpts_t)
+        	
+        end // of Thermal_update_without_self_heating
+        	
+end	//of Model_initialization
+
+       	if (flsh!=0 && rth >= `MIN_R) begin : Thermal_update_with_self_heating
+       		Tdev    = Tamb+dt+V(br_sht);
+        	// Limit temperature to avoid FPEs in equations
+		if(Tdev < `TMIN + 273.15) begin
+	   		Tdev = `TMIN + 273.15;
+		end else begin
+ 		if (Tdev > `TMAX + 273.15) begin
+	   		Tdev = `TMAX + 273.15;
+		end  
+        	end
+        	VT      = `P_K*Tdev /`P_Q;
+		dT      = Tdev-Tnom;  
+		qtt0    = Tdev/Tnom;
+		ln_qtt0 = ln(qtt0);
+		k1      = f1vg*Tdev*ln(Tdev);
+		k2      = f2vg*Tdev;
+        	vgb_t   = vgb+k1+k2;
+        	vge_t   = vge+k1+k2;
+        	vgbe_t  = (vgb_t+vge_t)/2;
+        
+        	//Internal b-e junction capacitance
+		`TMPHICJ(cjei0,vdei,zei,ajei,1,vgbe0,cjei0_t,vdei_t,ajei_t)
 	
-	//Forward transit time in substrate transistor
-	tsf_t	= tsf*exp((zetacx-1.0)*ln_qtt0);
+        	if (flcomp == 0.0 || flcomp == 2.1) begin
+        	V_gT     = 3.0*VT*ln_qtt0 + vgb*(qtt0-1.0);
+        	r_VgVT   = V_gT/VT;
+        	//Internal b-e diode saturation currents
+       		a	 = mcf*r_VgVT/mbei - alb*dT; 
+		ibeis_t  = ibeis*exp(a);
+		a        = mcf*r_VgVT/mrei - alb*dT;
+        	ireis_t  = ireis*exp(a);
+		a        = mcf*r_VgVT/mbep - alb*dT;
+		//Peripheral b-e diode saturation currents
+        	ibeps_t  = ibeps*exp(a);
+        	a        = mcf*r_VgVT/mrep - alb*dT;
+        	ireps_t  = ireps*exp(a);
+        	//Internal b-c diode saturation current
+        	a       = r_VgVT/mbci;
+        	ibcis_t = ibcis*exp(a);
+        	//External b-c diode saturation currents
+		a       = r_VgVT/mbcx;
+        	ibcxs_t = ibcxs*exp(a);
+        	//Saturation transfer current for substrate transistor
+        	a       = r_VgVT/msf;
+        	itss_t  = itss*exp(a);
+        	//Saturation current for c-s diode  
+        	a       = r_VgVT/msc;
+        	iscs_t  = iscs*exp(a);
+        	//Zero bias hole charge
+        	a	 = vdei_t/vdei;
+		qp0_t	 = qp0*(1.0+0.5*zei*(1.0-a));
+		//Voltage separating ohmic and saturation velocity regime
+		a = vlim*(1.0-alvs*dT)*exp(zetaci*ln_qtt0);
+        	k = (a-VT)/VT;
+        	if (k < `LN_EXP_LIMIT) begin
+            		vlim_t = VT + VT*ln(1.0+exp(k));
+        	end else begin
+            		vlim_t = a;
+        	end
+		//Neutral emitter storage time
+		a        = 1.0+alb*dT;
+        	k        = 0.5*(a+sqrt(a*a+0.01));
+        	tef0_t   = tef0*qtt0/k;
+        	end else begin
+        	//Internal b-e diode saturation currents
+        	ibeis_t  = ibeis*exp(zetabet*ln_qtt0+vge/VT*(qtt0-1));
+        	ireis_t  = ireis*exp(0.5*mg*ln_qtt0+0.5*vgbe0/VT*(qtt0-1));
+        	//Peripheral b-e diode saturation currents
+		ibeps_t	 = ibeps*exp(zetabet*ln_qtt0+vge/VT*(qtt0-1));
+		ireps_t	 = ireps*exp(0.5*mg*ln_qtt0+0.5*vgbe0/VT*(qtt0-1));
+		//Internal b-c diode saturation currents
+		ibcis_t = ibcis*exp(zetabci*ln_qtt0+vgc/VT*(qtt0-1));
+		//External b-c diode saturation currents
+		ibcxs_t	= ibcxs*exp(zetabcxt*ln_qtt0+vgc/VT*(qtt0-1));
+		//Saturation transfer current for substrate transistor
+		itss_t	= itss*exp(zetasct*ln_qtt0+vgc/VT*(qtt0-1));
+		//Saturation current for c-s diode   
+		iscs_t  = iscs*exp(zetasct*ln_qtt0+vgs/VT*(qtt0-1));
+		//Zero bias hole charge
+		a	= exp(zei*ln(vdei_t/vdei));
+		qp0_t	= qp0*(2.0-a);
+		//Voltage separating ohmic and saturation velocity regime
+		vlim_t  = vlim*exp((zetaci-avs)*ln_qtt0);
+        	//Neutral emitter storage time
+        	zetatef = zetabet-zetact-0.5;
+        	dvg0    = vgb-vge;
+        	tef0_t  = tef0*exp(zetatef*ln_qtt0-dvg0/VT*(qtt0-1));
+        	end        
+	
+		//GICCR prefactor
+		c10_t	= c10*exp(zetact*ln_qtt0+vgb/VT*(qtt0-1));
+
+        	// Low-field internal collector resistance
+		rci0_t	= rci0*exp(zetaci*ln_qtt0);
+
+		//Voltage separating ohmic and saturation velocity regime
+		//vlim_t  = vlim*exp((zetaci-avs)*ln_qtt0);
+
+        	//Internal c-e saturation voltage
+		vces_t  = vces*(1+alces*dT);
+
 
-	//Saturation transfer current for substrate transistor
-	itss_t	= itss*exp(zetasct*ln_qtt0+vgc/VT*(qtt0-1));
+        	//Internal b-c diode saturation current
+		//ibcis_t = ibcis*exp(zetabci*ln_qtt0+vgc/VT*(qtt0-1));
 
-	//Saturation current for c-s diode   
-	iscs_t  = iscs*exp(zetasct*ln_qtt0+vgs/VT*(qtt0-1));
+        	//Internal b-c junction capacitance
+        	`TMPHICJ(cjci0,vdci,zci,vptci,0,vgbc0,cjci0_t,vdci_t,vptci_t)
 
-	//Capacitance for c-s junction
-        `TMPHICJ(cjs0,vds,zs,vpts,0,vgsc0,cjs0_t,vds_t,vpts_t)
+        	//Low-current forward transit time
+		t0_t    = t0*(1+alt0*dT+kt0*dT*dT);
         
-end	// Temperature update:end
+        	//Saturation time constant at high current densities
+		thcs_t  = thcs*exp((zetaci-1)*ln_qtt0);
 
- 
-begin	//Bias-dependent model evaluation
 
+		//Avalanche caurrent factors
+		favl_t  = favl*exp(alfav*dT);
+		qavl_t  = qavl*exp(alqav*dT);	
+
+		//Zero bias internal base resistance
+		rbi0_t  = rbi0*exp(zetarbi*ln_qtt0);
+	
+	
+		//Peripheral b-e junction capacitance
+		`TMPHICJ(cjep0,vdep,zep,ajep,1,vgbe0,cjep0_t,vdep_t,ajep_t)
+		
+		//Tunneling current factors
+		if (V(br_bpei) < 0.0 || V(br_biei) < 0.0) begin // : HICTUN_T
+//			real a_eg,ab,aa;
+			ab	= 1.0;
+			aa	= 1.0;
+			a_eg=vgbe_t0/vgbe_t;
+			if(tunode==1 && cjep0 > 0.0 && vdep >0.0) begin
+				ab	= (cjep0_t/cjep0)*sqrt(a_eg)*vdep_t*vdep_t/(vdep*vdep);
+				aa	= (vdep/vdep_t)*(cjep0/cjep0_t)*pow(a_eg,-1.5);
+			end else if (tunode==0 && cjei0 > 0.0 && vdei >0.0) begin
+				ab	= (cjei0_t/cjei0)*sqrt(a_eg)*vdei_t*vdei_t/(vdei*vdei);
+				aa	= (vdei/vdei_t)*(cjei0/cjei0_t)*pow(a_eg,-1.5);
+			end
+			ibets_t	= ibets*ab;
+			abet_t	= abet*aa;
+		end
+
+
+		//Temperature mapping for tunneling current is done inside HICTUN
+
+		`TMPHICJ(1.0,vdcx,zcx,vptcx,0,vgbc0,cratio_t,vdcx_t,vptcx_t)
+	 	cjcx01_t=cratio_t*cjcx01;
+	 	cjcx02_t=cratio_t*cjcx02;
+
+		
+		//External b-c diode saturation currents   
+		//ibcxs_t	= ibcxs*exp(zetabcxt*ln_qtt0+vgc/VT*(qtt0-1));
+	
+	
+		//Constant external series resistances
+		rcx_t	= rcx*exp(zetarcx*ln_qtt0);
+		rbx_t	= rbx*exp(zetarbx*ln_qtt0);
+		re_t	= re*exp(zetare*ln_qtt0);
+	
+		//Forward transit time in substrate transistor
+		tsf_t	= tsf*exp((zetacx-1.0)*ln_qtt0);
+
+		//Capacitance for c-s junction
+        	`TMPHICJ(cjs0,vds,zs,vpts,0,vgsc0,cjs0_t,vds_t,vpts_t)
+        	
+
+        end	//of Thermal_update_with_self_heating
+
+ 
+begin : Model_evaluation
+		
 	//Intrinsic transistor
 	//Internal base currents across b-e junction
 	`HICDIO(ibeis,ibeis_t,mbei,V(br_biei),ibei)
@@ -968,25 +1115,6 @@
 	//Inverse of low-field internal collector resistance: needed in HICICK
 	Orci0_t	= 1.0/rci0_t;
 
-	//Avoid devide-by-zer and define infinity other way
-	//High current correction for 2D and 3D effects
-    	if (ich != 0.0)
-       		Oich 	= 1.0/ich;
-      	else
-       		Oich	= 0.0;
-       
-       	//Base current recombination time constant at b-c barrier
-      	if (tbhrec != 0.0)
-       		Otbhrec = 1.0/tbhrec;
-      	else
-       		Otbhrec	= 0.0;
-     	
-	//Collector punch-through voltage
-	if(vpt != 0.0)
-       		Ovpt	= 1.0/vpt;
-     	else
-       		Ovpt	= 0.0;
-
 	//Initialization
 	//Transfer current, minority charges and transit times
      
@@ -996,8 +1124,10 @@
       	i_0r	= c10_t * limexp(V(br_bici)/VT);	
 	
 	//Internal b-e and b-c junction capacitances and charges
-	`QCJMODF(cjei0_t,vdei_t,zei,ajei_t,V(br_biei),Cjei,Qjei)
-	`HICJCAP(cjci0_t,vdci_t,zci,vptci_t,V(br_bici),Cjci,Qjci)
+	`QJMODF(cjei0_t,vdei_t,zei,ajei_t,V(br_biei),Qjei)
+	Cjei	= ddx(Qjei,V(bi));
+	`HICJQ(cjci0_t,vdci_t,zci,vptci_t,V(br_bici),Qjci)
+	Cjci	= ddx(Qjci,V(bi));
 
 	//Hole charge at low bias
       	a_bpt	= 0.05;
@@ -1007,18 +1137,38 @@
 	Q_0	= Q_bpt*(1+(b_q +sqrt(b_q*b_q+1.921812))/2);
 
 	//Transit time calculation at low current density
-	`QCJMODF(cjci0_t,vdci_t,zci,2.4,V(br_bici),Cjcit,d1)
-	if(Cjcit > 0.0) 
+  	if(cjci0_t > 0.0) begin : CJMODF
+  		real cV_f,cv_e,cs_q,cs_q2,cv_j,cdvj_dv;
+      		cV_f	= vdci_t*(1.0-exp(-ln(2.4)/zci));
+      		cv_e	= (cV_f-V(br_bici))/VT;
+      		cs_q	= sqrt(cv_e*cv_e+1.921812);
+      		cs_q2	= (cv_e+cs_q)*0.5;
+      		cv_j	= cV_f-VT*cs_q2;
+      		cdvj_dv	= cs_q2/cs_q;
+      		Cjcit	= cjci0_t*exp(-zci*ln(1.0-cv_j/vdci_t))*cdvj_dv+2.4*cjci0_t*(1.0-cdvj_dv);
+  	end else begin
+      		Cjcit	= 0.0;
+  	end
+	if(Cjcit > 0.0) begin 
     		cc	= cjci0_t/Cjcit;
-    	else
+    	end else begin
      		cc	= 1.0;
+     	end
 	T_f0	= t0_t+dt0h*(cc-1.0)+tbvl*(1/cc-1.0);
       
 	//Effective collector voltage
       	vc	= V(br_ciei)-vces_t;     
 
 	//Critical current for onset of high-current effects      
-	`HICICK(vc,Orci0_t,vlim_t,Ovpt,ick,vceff)
+	begin : HICICK
+      		a	= vc/VT;
+      		d1	= a-1;
+      		vceff	= (1.0+((d1+sqrt(d1*d1+1.921812))/2))*VT;
+      		a	= vceff/vlim_t;
+      		ick	= vceff*Orci0_t/sqrt(1.0+a*a);
+      		ICKa	= (vceff-vlim_t)*Ovpt;
+      		ick	= ick*(1.0+0.5*(ICKa+sqrt(ICKa*ICKa+1.0e-3)));
+      	end
 
 	//Initial formulation of forward and reverse component of transfer current
 	Q_p	= Q_0;
@@ -1030,7 +1180,7 @@
       	a_h	= Oich*I_Tf1;
       	itf	= I_Tf1*(1.0+a_h);
       	itr	= i_0r/Q_p;
-
+      	
       	//Initial formulation of forward transit time, diffusion, GICCR and excess b-c charge
       	Q_bf	= 0.0;
       	Tf	= T_f0;
@@ -1057,18 +1207,20 @@
         		Qf	= T_f0*itf;
 			`HICQFF(itf,ick,Tf,Qf,T_fT,Q_fT,Q_bf)
   			Qr	= Tr*itr;
-        		if(Oich == 0.0) 
+        		if(Oich == 0.0) begin
         			a	= 1.0+(T_fT*itf+Qr)/Q_pT;
-        		else
+        		end else begin
        				a	= 1.0+(T_fT*I_Tf1*(1.0+2.0*a_h)+Qr)/Q_pT;
+       			end
         		d_Q	= -(Q_pT-(Q_0+Q_fT+Qr))/a;
 			//Limit maximum change of Q_pT
         		a	= abs(0.3*Q_pT);
         		if(abs(d_Q) > a) begin
-        			if (d_Q>=0)
+        			if (d_Q>=0) begin
         				d_Q	= a;
-        			else 
+        			end else begin
         				d_Q	= -a;
+        			end
         		end
         		Q_pT	= Q_pT+d_Q;
         		l_it	= l_it+1;
@@ -1092,20 +1244,20 @@
      	it	= itf-itr;
      	
      	/*
-      	//NQS Effect
-      	
-      	
+      	// NQS Effect:Please incert here the hand-coded Weil's approach after getting
+      	// C-code from the model compilers.
       	*/
 
-
 	//Diffusion charges for further use
       	Qdei	= Qf;
       	Qdci	= Qr;
       	
       	
 	//High-frequency emitter current crowding (lateral NQS)
-	//Currently not accurate: using ddx() operator may provide right formulation
- 	qrbi	= fcrbi*(Qjei+Qdei+Qjci+Qdci);
+ 	Cdei	= ddx(Qdei,V(bi));
+ 	Cdci	= ddx(Qdci,V(bi));
+ 	Crbi	= fcrbi*(Cjei+Cjci+Cdei+Cdci);
+ 	qrbi	= Crbi*V(br_bpbi_v);
  	
 	//HICCR: end
 	
@@ -1113,39 +1265,110 @@
 	`HICDIO(ibcis,ibcis_t,mbci,V(br_bici),ibci)
 
 	//Avalanche current
-	`HICAVL(itf,V(br_bici),Cjci,iavl)
+	if((V(br_bici) < 0.0) && (favl_t > 0.0) && (cjci0_t > 0.0)) begin : HICAVL
+		real v_bord,v_q,U0,av,avl,S_avl;
+            	v_bord	= vdci_t-V(br_bici);
+            	v_q	= qavl_t/Cjci;
+            	U0	= qavl_t/cjci0_t;
+            	if(v_bord > U0) begin
+              		av	= favl_t*exp(-v_q/U0);
+              		avl	= av*(U0+(1.0+v_q/U0)*(v_bord-U0));
+            	end else begin
+              		avl	= favl_t*v_bord*exp(-v_q/v_bord);
+            	end
+            		iavl	= itf*avl;
+      	end else begin
+      	    	iavl	= 0.0;
+      	end
 
 	//Excess base current from recombination at the b-c barrier
 	ibh_rec	= Q_bf*Otbhrec;
 
 	//Internal base resistance
-	`HICRBI(rbi0_t,fdqr0,fgeo,fqi,qp0_t,Qjei,Qf,ibei,rbi)
+      	if(rbi0_t > 0.0) begin : HICRBI
+      		real Qz_nom,f_QR,f_p,ETA,Qz0,fQz;
+      		// Consideration of conductivity modulation
+      		// To avoid convergence problem hyperbolic smoothing used
+      		f_QR	= (1+fdqr0)*qp0_t;
+      		Qz0	= Qjei+Qjci+Qf;
+      		Qz_nom	= 1+Qz0/f_QR;
+      		fQz	= 0.5*(Qz_nom+sqrt(Qz_nom*Qz_nom+0.01));
+        	rbi	= rbi0_t/fQz;
+        	// Consideration of emitter current crowding
+        	if( ibei > 0.0) begin
+      			ETA	= rbi*ibei*fgeo/VT;
+      			if(ETA < 1.0e-6) begin
+       				rbi	= rbi*(1.0-0.5*ETA);
+      			end else begin
+        			rbi	= rbi*ln(1.0+ETA)/ETA;
+      			end
+      		end
+      		// Consideration of peripheral charge
+		if(Qf > 0.0) begin
+        		rbi	= rbi*(Qjei+Qf*fqi)/(Qjei+Qf);
+        	end
+      	end else begin
+        	rbi	= 0.0;
+      	end
 
 	//Base currents across peripheral b-e junction
 	`HICDIO(ibeps,ibeps_t,mbep,V(br_bpei),ibep)
 	`HICDIO(ireps,ireps_t,mrep,V(br_bpei),irep)
 
 	//Peripheral b-e junction capacitance and charge
-	`QCJMODF(cjep0_t,vdep_t,zep,ajep_t,V(br_bpei),Cjep,Qjep)
+	//Following module may be replaced by calling QJMODF
+	//if ddx() produces correct results for Cjep using that macro.
+  	    if (cjep0_t >0.0) begin : QJEP
+  	    	real V_f,v_e,s_q,s_q2,v_j,Q_j;
+      		V_f	= vdep_t*(1.0-exp(-ln(ajep_t)/zep));
+      		v_e	= (V_f-V(br_bpei))/VT;
+      		s_q	= sqrt(v_e*v_e+1.921812);
+      		s_q2	= (v_e+s_q)*0.5;
+      		v_j	= V_f-VT*s_q2;
+      		Q_j	= cjep0_t*vdep_t*(1.0-exp(ln(1.0-v_j/vdep_t)*(1.0-zep)))/(1.0-zep);
+      		Qjep	= Q_j+ajep_t*cjep0_t*(V(br_bpei)-v_j);
+      	     end else begin
+      	     	Qjep	= 0.0;
+      	     end
+      	     
+      	//`QJMODF(cjep0_t,vdep_t,zep,ajep_t,V(br_bpei),Qjep)
+      	     Cjep	= ddx(Qjep,V(bp));
+
+
+	//Tunelling current
+	if (V(br_bpei) <0.0 || V(br_biei) < 0.0) begin : HICTUN
+		real pocce,czz;
+		if(tunode==1 && cjep0_t > 0.0 && vdep_t >0.0) begin
+			pocce	= exp((1-1/zep)*ln(Cjep/cjep0_t));
+			czz	= -(V(br_bpei)/vdep_t)*ibets_t*pocce;
+			ibet	= czz*exp(-abet_t/pocce);
+		end else if (tunode==0 && cjei0_t > 0.0 && vdei_t >0.0) begin
+			pocce	= exp((1-1/zei)*ln(Cjei/cjei0_t));
+			czz	= -(V(br_biei)/vdei_t)*ibets_t*pocce;
+			ibet	= czz*exp(-abet_t/pocce);
+		end else begin
+			ibet	= 0.0;
+		end		
+	end else begin
+		ibet	= 0.0;
+	end
 
-	//Tunneling current
-	`HICTUN(vgbe_t0,vgbe_t,cjep0_t,cjei0_t,vdep_t,vdei_t,V(br_bpei),V(br_biei),Cjep,Cjei,ibet)
 
 	//Depletion capacitance and charge at peripheral b-c junction (bp,ci)
-	`HICJCAP(cjcx02_t,vdcx_t,zcx,vptcx_t,V(br_bpci),cjcx0_t_ii,qjcx0_t_ii)
+	`HICJQ(cjcx02_t,vdcx_t,zcx,vptcx_t,V(br_bpci),qjcx0_t_ii)
 
 	//Base currents across peripheral b-c junction (bp,ci)
 	`HICDIO(ibcxs,ibcxs_t,mbcx,V(br_bpci),ijbcx)
 
 	//Depletion capacitance and charge at external b-c junction (b,ci)
-	`HICJCAP(cjcx01_t,vdcx_t,zcx,vptcx_t,V(br_bci),cjcx0_t_i,qjcx0_t_i)
+	`HICJQ(cjcx01_t,vdcx_t,zcx,vptcx_t,V(br_bci),qjcx0_t_i)
 
 	//Depletion substrate capacitance and charge at s-c junction (si,ci)
-	`HICJCAP(cjs0_t,vds_t,zs,vpts_t,V(br_sici),Cjs,Qjs)
+	`HICJQ(cjs0_t,vds_t,zs,vpts_t,V(br_sici),Qjs)
 
 	//Parasitic substrate transistor transfer current and diffusion charge
- 	HSUM	= msf*VT;
- 	if(itss > 0.0) begin
+ 	if(itss > 0.0) begin : Sub_Transfer
+ 		HSUM	= msf*VT;
         	HSa	= limexp(V(br_bpci)/HSUM);
         	HSb	= limexp(V(br_sici)/HSUM);
         	HSI_Tsu	= itss_t*(HSa-HSb);
@@ -1163,53 +1386,59 @@
 	`HICDIO(iscs,iscs_t,msc,V(br_sici),ijsc)
 	
 	//Self-heating calculation
-	if (flsh == 1 && rth > 0.0) begin
+	if (flsh == 1 && rth >= `MIN_R) begin
 		pterm	=  V(br_ciei)*it + (vdci_t-V(br_bici))*iavl;
-	end else if (flsh == 2 && rth > 0.0) begin
+	end else if (flsh == 2 && rth >= `MIN_R) begin
 		pterm	=  V(br_ciei)*it + (vdci_t-V(br_bici))*iavl + ibei*V(br_biei) + ibci*V(br_bici) + ibep*V(br_bpei) + ijbcx*V(br_bpci) + ijsc*V(br_sici);
-		if (rbi > 0.0) begin
+		if (rbi >= `MIN_R) begin
 		pterm	= pterm + V(br_bpbi_i)*V(br_bpbi_i)/rbi;
 		end
-		if (re_t > 0.0) begin
+		if (re_t >= `MIN_R) begin
 		pterm	= pterm + V(br_eie_i)*V(br_eie_i)/re_t;
 		end
-		if (rcx_t > 0.0) begin
+		if (rcx_t >= `MIN_R) begin
 		pterm	= pterm + V(br_cic_i)*V(br_cic_i)/rcx_t;
 		end
-		if (rbx_t > 0.0) begin
+		if (rbx_t >= `MIN_R) begin
 		pterm	= pterm + V(br_bbp_i)*V(br_bbp_i)/rbx_t;
 		end
 	end
 
-end	//Bias-dependent model evaluation
-
-begin	//Define branch sources
+end	//of Model_evaluation
 
+begin : Load_sources
+	
+	I(br_biei)	<+ `Gmin*V(br_biei);
+	I(br_bici)	<+ `Gmin*V(br_bici);
+	
 	I(br_bci)	<+ ddt(qjcx0_t_i);
    	I(br_bci)      	<+ ddt(cbcpar1*V(br_bci));
 	I(br_bpci)      <+ ddt(cbcpar2*V(br_bpci));
-	if (rbx > 0.0) begin
+	if (rbx >= `MIN_R) begin
 		I(br_bbp_i)	<+ V(br_bbp_i)/rbx_t;
 	end else begin
-		V(br_bbp_v) 	<+ 0.0;
+//dw		V(br_bbp_v) 	<+ 0.0;
+		I(br_bbp_i)	<+ V(br_bbp_i)/`MIN_R;
 	end
-	if(rbi0 > 0.0) begin
+	if(rbi0 >= `MIN_R) begin
 		I(br_bpbi_i)	<+ V(br_bpbi_i)/rbi;
 		I(br_bpbi_i) 	<+ ddt(qrbi);
 	end else begin
-		V(br_bpbi_v) 	<+ 0.0;
+//dw		V(br_bpbi_v) 	<+ 0.0;
+		I(br_bpbi_i)	<+ V(br_bpbi_i)/`MIN_R;
 	end
 	if (tunode==1.0) begin
-		I(br_bpei) 	<+ -ibet+ibep+irep;
-		I(br_bpei) 	<+ ddt(Qjep);
-		I(br_biei) 	<+ ibei+irei+ibh_rec;	
-		I(br_biei) 	<+ ddt(Qdei+Qjei);	
+		I(br_bpei) 	<+ -ibet;			
 	end else begin	            
-		I(br_bpei) 	<+ ibep+irep;
-		I(br_bpei) 	<+ ddt(Qjep);
-		I(br_biei) 	<+ -ibet+ibei+irei+ibh_rec;
-		I(br_biei) 	<+ ddt(Qdei+Qjei);
+		I(br_biei) 	<+ -ibet;
 	end
+	I(br_bpei) 	<+ ibep;
+	I(br_bpei) 	<+ irep;
+	I(br_bpei) 	<+ ddt(Qjep);
+	I(br_biei) 	<+ ibei;
+	I(br_biei) 	<+ irei;
+	I(br_biei) 	<+ ibh_rec;
+	I(br_biei) 	<+ ddt(Qdei+Qjei);	
 	I(br_bpsi) 	<+ HSI_Tsu;
 	I(br_bpci) 	<+ ijbcx;
 	I(br_bpci) 	<+ ddt(qjcx0_t_ii+Qdsu);
@@ -1220,45 +1449,72 @@
 	I(br_sici) 	<+ ijsc;
 	I(br_sici) 	<+ ddt(Qjs);
 	I(br_ciei) 	<+ it;
-	if (rcx > 0.0) begin
+	if (rcx >= `MIN_R) begin
 		I(br_cic_i)	<+ V(br_cic_i)/rcx_t;
 	end else begin
-		V(br_cic_v)  	<+ 0.0;
+//dw		V(br_cic_v)  	<+ 0.0;
+		I(br_cic_i)	<+ V(br_cic_i)/`MIN_R;
 	end
-	if (re > 0.0) begin
+	if (re >= `MIN_R) begin
 		I(br_eie_i)	<+ V(br_eie_i)/re_t;
 	end else begin
-		V(br_eie_v)  	<+ 0.0;
+//dw		V(br_eie_v)  	<+ 0.0;
+		I(br_eie_i)	<+ V(br_eie_i)/`MIN_R;
 	end	
-	if(rsu > 0.0) begin
+	if(rsu >= `MIN_R) begin
 		I(br_sis_i)  	<+ V(br_sis_i)/rsu;
 		I(br_sis_i)  	<+ ddt(csu*V(br_sis_i));
 	end else begin
-		V(br_sis_v) 	<+ 0.0;
+//dw		V(br_sis_v) 	<+ 0.0;
+		I(br_sis_i)  	<+ V(br_sis_i)/`MIN_R;
 	end
-	if(flsh == 0 || rth == 0.0) begin
-		V(br_sht)	<+ 0.0;
+	
+	// Following code is an intermediate solution (if branch contribution is not supported):
+	// ******************************************
+	if(flsh == 0 || rth < `MIN_R) begin
+		I(br_sht) 	<+ V(br_sht)/`MIN_R;
 	end else begin
 		I(br_sht) 	<+ V(br_sht)/rth-pterm;
 		I(br_sht) 	<+ ddt(cth*V(br_sht));
 	end
 
-end //Define branch source
+	// ******************************************
+	
+	// For simulators having no problem with V(br_sht) <+ 0.0 
+	// with external thermal node, follwing code may be used.
+	// Note that external thermal node should remain accessible 
+	// even without self-heating.
+	// ********************************************
+	// if(flsh == 0 || rth < `MIN_R) begin
+	// 	V(br_sht)	<+ 0.0;
+	// end else begin
+	// 	I(br_sht) 	<+ V(br_sht)/rth-pterm;
+	// 	I(br_sht) 	<+ ddt(cth*V(br_sht));
+	// end
+	// ********************************************
+	
+end //of Load_sources
+
 
-`NOISE begin	//Define noise sources
+`NOISE begin : Noise_sources
 	
 	//Thermal noise
 	fourkt 	= 4.0 * `P_K * Tdev;
-	if(rbx > 0.0)
+	if(rbx >= `MIN_R) begin
 		I(br_bbp_i)	<+ white_noise(fourkt/rbx_t,	"thermal");
-	if(rbi0 > 0.0)
+	end
+	if(rbi0 >= `MIN_R) begin
 		I(br_bpbi_i) 	<+ white_noise(fourkt/rbi,	"thermal");
-	if(rcx > 0.0)
+	end
+	if(rcx >= `MIN_R) begin
 		I(br_cic_i)	<+ white_noise(fourkt/rcx_t,	"thermal");
-	if(re > 0.0)
+	end
+	if(re >= `MIN_R) begin
 		I(br_eie_i)	<+ white_noise(fourkt/re_t,	"thermal");
-	if(rsu > 0.0)
+	end
+	if(rsu >= `MIN_R) begin
 		I(br_sis_i)	<+ white_noise(fourkt/rsu,	"thermal");
+	end
 	
 	//Flicker noise : Fully correlated between the perimeter and internal base-node
    	flicker_Pwr  	= kf*pow((ibei+ibep),af);
@@ -1269,25 +1525,18 @@
    	end
    	   	
    	//Shot noise
-
-  	twoq	= 2.0 * `P_Q;  
+   	twoq	= 2.0 * `P_Q;  
    	I(br_ciei) 	<+ white_noise(twoq*it,		"shot");
    	I(br_cibi) 	<+ white_noise(twoq*iavl,	"shot");
-
-  	I(br_biei) 	<+ white_noise(twoq*ibei,	"shot");
-
-  	I(br_bici) 	<+ white_noise(twoq*abs(ibci),	"shot");
-
-  	I(br_bpei) 	<+ white_noise(twoq*ibep,	"shot");
-
-  	I(br_bpci) 	<+ white_noise(twoq*abs(ijbcx),	"shot");
-
-  	I(br_sici) 	<+ white_noise(twoq*abs(ijsc),	"shot");
-
-  	   
+   	I(br_biei) 	<+ white_noise(twoq*ibei,	"shot");
+   	I(br_bici) 	<+ white_noise(twoq*abs(ibci),	"shot");
+   	I(br_bpei) 	<+ white_noise(twoq*ibep,	"shot");
+   	I(br_bpci) 	<+ white_noise(twoq*abs(ijbcx),	"shot");
+   	I(br_sici) 	<+ white_noise(twoq*abs(ijsc),	"shot");
+   	   
 	//Correlated noise not yet implemented
 
-end	//Define noise sources
+end	//of Noise_sources
 	
 end //analog
 endmodule
--- ng-spice-rework/src/spicelib/devices/bsim3soi/b4soild.c:1.3	Sun Sep 21 22:18:17 2008
+++ ng-spice-rework/src/spicelib/devices/bsim3soi/b4soild.c	Sun Jan 11 21:31:23 2009
@@ -18,10 +18,6 @@
 #include "devdefs.h"
 #include "suffix.h"
 
-#ifdef _MSC_VER
-extern int _isnan(double);
-#endif
-
 #define EPSOX 3.453133e-11
 #define EPSSI 1.03594e-10
 #define Charge_q 1.60219e-19
--- ng-spice-rework/src/spicelib/devices/bsim3soi_dd/b3soiddld.c:1.5	Wed Nov 26 20:33:20 2008
+++ ng-spice-rework/src/spicelib/devices/bsim3soi_dd/b3soiddld.c	Sun Jan 11 21:31:23 2009
@@ -21,10 +21,6 @@
 #include "devdefs.h"
 #include "suffix.h"
 
-#ifdef _MSC_VER
-extern int _isnan(double);
-#endif
-
 #define MAX_EXP 5.834617425e14
 #define MIN_EXP 1.713908431e-15
 #define EXP_THRESHOLD 34.0
--- ng-spice-rework/src/spicelib/devices/bsim3soi_fd/b3soifdld.c:1.5	Wed Nov 26 20:33:20 2008
+++ ng-spice-rework/src/spicelib/devices/bsim3soi_fd/b3soifdld.c	Sun Jan 11 21:31:23 2009
@@ -21,10 +21,6 @@
 #include "devdefs.h"
 #include "suffix.h"
 
-#ifdef _MSC_VER
-extern int _isnan(double);
-#endif
-
 #define MAX_EXP 5.834617425e14
 #define MIN_EXP 1.713908431e-15
 #define EXP_THRESHOLD 34.0
--- ng-spice-rework/src/spicelib/devices/bsim3soi_pd/b3soipdld.c:1.6	Wed Nov 26 20:33:20 2008
+++ ng-spice-rework/src/spicelib/devices/bsim3soi_pd/b3soipdld.c	Sun Jan 11 21:31:23 2009
@@ -26,10 +26,6 @@
 #include "devdefs.h"
 #include "suffix.h"
 
-#ifdef _MSC_VER
-extern int _isnan(double);
-#endif
-
 #define EPSOX 3.453133e-11
 #define EPSSI 1.03594e-10
 #define Charge_q 1.60219e-19
--- ng-spice-rework/src/spicelib/devices/hisim/hsm1eval102.c:1.4	Sun Sep 21 22:18:17 2008
+++ ng-spice-rework/src/spicelib/devices/hisim/hsm1eval102.c	Sun Jan 11 20:43:27 2009
@@ -63,17 +63,8 @@
 /*---------------------------------------------------*
 * Header files.
 *-----------------*/
-#include <stdlib.h>
-#include <stdio.h>
-#include <math.h>
-#include <float.h>
-#include "config.h"
-#ifdef HAVE_IEEEFP_H
-# include <ieeefp.h>
-#endif
-#ifdef _MSC_VER
-#define finite _finite
-#endif
+#include "ngspice.h"
+
 /*-----------------------------------*
 * HiSIM macros and structures.
 * - All inputs and outputs are defined here.
--- ng-spice-rework/src/spicelib/devices/hisim/hsm1eval112.c:1.4	Sun Sep 21 22:18:18 2008
+++ ng-spice-rework/src/spicelib/devices/hisim/hsm1eval112.c	Sun Jan 11 20:43:27 2009
@@ -63,17 +63,7 @@
 /*---------------------------------------------------*
 * Header files.
 *-----------------*/
-#include <stdlib.h>
-#include <stdio.h>
-#include <math.h>
-#include <float.h>
-#include "config.h"
-#ifdef HAVE_IEEEFP_H
-# include <ieeefp.h>
-#endif
-#ifdef _MSC_VER
-#define finite _finite
-#endif
+#include "ngspice.h"
 
 /*-----------------------------------*
 * HiSIM macros and structures.
--- ng-spice-rework/src/spicelib/devices/hisim/hsm1eval120.c:1.5	Sun Sep 21 22:18:19 2008
+++ ng-spice-rework/src/spicelib/devices/hisim/hsm1eval120.c	Sun Jan 11 20:43:27 2009
@@ -63,17 +63,7 @@
 /*---------------------------------------------------*
 * Header files.
 *-----------------*/
-#include <stdlib.h>
-#include <stdio.h>
-#include <math.h>
-#include <float.h>
-#include "config.h"
-#ifdef HAVE_IEEEFP_H
-# include <ieeefp.h>
-#endif
-#ifdef _MSC_VER
-#define finite _finite
-#endif
+#include "ngspice.h"
 
 /*-----------------------------------*
 * HiSIM macros and structures.
--- ng-spice-rework/src/spicelib/devices/isrc/isrc.c:1.3	Tue May 10 06:59:05 2005
+++ ng-spice-rework/src/spicelib/devices/isrc/isrc.c	Thu Jan 15 22:16:32 2009
@@ -13,13 +13,14 @@
  IOPP( "dc",      ISRC_DC,        IF_REAL   ,"DC value of source"),
  IOPPA( "acmag",   ISRC_AC_MAG,    IF_REAL   ,"AC magnitude"),
  IOPAAU( "acphase", ISRC_AC_PHASE,  IF_REAL   ,"AC phase"),
- IP ( "pulse",   ISRC_PULSE,     IF_REALVEC,"Pulse description"),
- IP ( "sine",    ISRC_SINE,      IF_REALVEC,"Sinusoidal source description"),
- IP ( "sin",     ISRC_SINE,      IF_REALVEC,"Sinusoidal source description"),
- IP ( "exp",     ISRC_EXP,       IF_REALVEC,"Exponential source description"),
- IP ( "pwl",     ISRC_PWL,       IF_REALVEC,"Piecewise linear description"),
- IP ( "sffm",    ISRC_SFFM,      IF_REALVEC,"Single freq. FM description"),
- IP ( "am",      ISRC_AM,        IF_REALVEC,"Amplitude modulation description"),
+ /* Modified to allow print @Iin[sin] A.Roldan */ 
+ IOP ( "pulse",   ISRC_PULSE,     IF_REALVEC,"Pulse description"),
+ IOP ( "sine",    ISRC_SINE,      IF_REALVEC,"Sinusoidal source description"),
+ IOP ( "sin",     ISRC_SINE,      IF_REALVEC,"Sinusoidal source description"),
+ IOP ( "exp",     ISRC_EXP,       IF_REALVEC,"Exponential source description"),
+ IOP ( "pwl",     ISRC_PWL,       IF_REALVEC,"Piecewise linear description"),
+ IOP ( "sffm",    ISRC_SFFM,      IF_REALVEC,"Single freq. FM description"),
+ IOP ( "am",      ISRC_AM,        IF_REALVEC,"Amplitude modulation description"),
  OPU ( "neg_node",ISRC_NEG_NODE,  IF_INTEGER,"Negative node of source"),
  OPU ( "pos_node",ISRC_POS_NODE,  IF_INTEGER,"Positive node of source"),
  OPU ( "acreal",  ISRC_AC_REAL,   IF_REAL   ,"AC real part"),
--- ng-spice-rework/src/spicelib/devices/vsrc/vsrc.c:1.4	Tue Oct  9 08:44:51 2007
+++ ng-spice-rework/src/spicelib/devices/vsrc/vsrc.c	Thu Jan 15 22:16:32 2009
@@ -13,14 +13,16 @@
  IOPP("dc",      VSRC_DC,        IF_REAL   ,"D.C. source value"),
  IOPPA("acmag",   VSRC_AC_MAG,    IF_REAL   ,"A.C. Magnitude"),
  IOPAAU("acphase", VSRC_AC_PHASE,  IF_REAL   ,"A.C. Phase"),
- IP ("pulse",   VSRC_PULSE,     IF_REALVEC,"Pulse description"),
- IP ("sine",    VSRC_SINE,      IF_REALVEC,"Sinusoidal source description"),
- IP ("sin",     VSRC_SINE,      IF_REALVEC,"Sinusoidal source description"),
- IP ("exp",     VSRC_EXP,       IF_REALVEC,"Exponential source description"),
- IP ("pwl",     VSRC_PWL,       IF_REALVEC,"Piecewise linear description"),
- IP ("sffm",    VSRC_SFFM,      IF_REALVEC,"Single freq. FM descripton"),
- IP ("am",      VSRC_AM,        IF_REALVEC,"Amplitude modulation descripton"),
- OPU ("pos_node",VSRC_POS_NODE,  IF_INTEGER,"Positive node of source"),
+ /* Modified to allow print @vin[sin] A.Roldan */ 
+ IOP ("pulse",   VSRC_PULSE,     IF_REALVEC,"Pulse description"),
+ IOP ("sine",    VSRC_SINE,      IF_REALVEC,"Sinusoidal source description"),
+ IOP ("sin",     VSRC_SINE,      IF_REALVEC,"Sinusoidal source description"),
+ IOP ("exp",     VSRC_EXP,       IF_REALVEC,"Exponential source description"),
+ IOP ("pwl",     VSRC_PWL,       IF_REALVEC,"Piecewise linear description"),
+ IOP ("sffm",    VSRC_SFFM,      IF_REALVEC,"Single freq. FM descripton"),
+ IOP ("am",      VSRC_AM,        IF_REALVEC,"Amplitude modulation descripton"),
+ 
+OPU ("pos_node",VSRC_POS_NODE,  IF_INTEGER,"Positive node of source"),
  OPU ("neg_node",VSRC_NEG_NODE,  IF_INTEGER,"Negative node of source"),
  OPU ("function",VSRC_FCN_TYPE,  IF_INTEGER,"Function of the source"),
  OPU ("order",   VSRC_FCN_ORDER, IF_INTEGER,"Order of the source function"),
--- ng-spice-rework/src/spicelib/parser/inp2n.c:1.1	Tue May  1 03:38:13 2007
+++ ng-spice-rework/src/spicelib/parser/inp2n.c	Thu Dec  4 20:40:57 2008
@@ -124,5 +124,8 @@
     
     return;
 }
+#else
+
+int Dummy1;
 
 #endif
--- ng-spice-rework/src/spicelib/parser/inpdomod.c:1.29	Sun Nov  9 22:44:15 2008
+++ ng-spice-rework/src/spicelib/parser/inpdomod.c	Mon Dec 22 12:42:08 2008
@@ -287,17 +287,16 @@
 	    if ( strcmp(ver, "3.1a") == 0 ) {
 	      type = INPtypelook("BSIM3v1A");
 	    }
-	    if ( (strstr(ver, "3.2.2")) || (strstr(ver, "3.22")) ||
-	         (strstr(ver, "3.2.3")) || (strstr(ver, "3.23")) ||
-	         (strstr(ver, "3.2.4")) || (strstr(ver, "3.24")) ) {
+	    if ( prefix("3.2", ver)) { /* version string ver has to start with 3.2 */
 	      type = INPtypelook("BSIM3v32");
 	    }
 	    if ( (strstr(ver, "default")) 
-	        || (strstr(ver, "3.3")) || (strstr(ver, "3.3.0")) || (strstr(ver, "3.30")) ) {
+	        || (prefix("3.3", ver)) ) {
 	      type = INPtypelook("BSIM3");
 	    }
 	    if (type < 0) {
-	      err = INPmkTemp("Device type BSIM3 not available in this binary\n");
+	       err = (char *) tmalloc(sizeof(char) * (60 + strlen(ver)));
+	       sprintf(err,"Device type BSIM3 version %s not available in this binary\n",ver);
 	    }
 	    break;
 	case  9:
@@ -308,31 +307,26 @@
 	    }
 	    break;
 	case 14: case 54:
-	    err = INPfindVer(line, ver); /* mapping of minor versions are only placeholder */
-	    if ( (strstr(ver, "4.2")) || (strstr(ver, "4.2.0")) || (strstr(ver, "4.20")) 
-	                              || (strstr(ver, "4.2.1")) || (strstr(ver, "4.21")) ) {
+	    err = INPfindVer(line, ver); /* mapping of minor versions are included */
+	    if (prefix("4.2", ver)) {
 	      type = INPtypelook("BSIM4v2");
 	    }
-	    if ( (strstr(ver, "4.3")) || (strstr(ver, "4.3.0")) || (strstr(ver, "4.30")) ) {
+	    if (prefix("4.3", ver)) {
 	      type = INPtypelook("BSIM4v3");
 	    }
-	    if ( (strstr(ver, "4.4")) || (strstr(ver, "4.4.0")) || (strstr(ver, "4.40")) ) {
+	    if (prefix("4.4", ver)) {
 	      type = INPtypelook("BSIM4v4");
 	    }
-	    if ( (strstr(ver, "4.5")) || (strstr(ver, "4.5.0")) || (strstr(ver, "4.50")) ) {
+	    if (prefix("4.5", ver)) {
 	      type = INPtypelook("BSIM4v5");
 	    }
 	    if ( (strstr(ver, "default")) 
-	        || (strstr(ver, "4.6")) || (strstr(ver, "4.6.0")) || (strstr(ver, "4.60")) 
-	                                || (strstr(ver, "4.6.1")) || (strstr(ver, "4.61"))
-	                                || (strstr(ver, "4.6.2")) || (strstr(ver, "4.62"))
-	                                || (strstr(ver, "4.6.3")) || (strstr(ver, "4.63")) ) {
+	        || (prefix("4.6", ver)) ) {
 	      type = INPtypelook("BSIM4");
 	    }
 	    if (type < 0) {
-		err =
-		    INPmkTemp
-		    ("Device type BSIM4 not available in this binary\n");
+	       err = (char *) tmalloc(sizeof(char) * (60 + strlen(ver)));
+	       sprintf(err,"Device type BSIM4 version %s not available in this binary\n",ver);
 	    }
 	    break;
 	case 15:
--- ng-spice-rework/src/spicelib/parser/inpfindl.c:1.3	Wed Aug  6 18:38:05 2003
+++ ng-spice-rework/src/spicelib/parser/inpfindl.c	Wed Dec 31 14:42:49 2008
@@ -39,16 +39,16 @@
 	sscanf(where, "%2d", level);	/* We get the level number */
 	if (*level < 0) {
 	    *level = 1;
-	    printf("Illegal value for level.\n");
-	    printf("Level must be >0 (Setting level to 1)\n");
+	    fprintf(stderr,"Illegal value for level.\n");
+	    fprintf(stderr,"Level must be >0 (Setting level to 1)\n");
 	    return (INPmkTemp
 		    (" illegal (negative) argument to level parameter - level=1 assumed"));
 	}
 
 	if (*level > 99) {	/* Limit to change in the future */
 	    *level = 1;
-	    printf("Illegal value for level.\n");
-	    printf("Level must be <99 (Setting Level to 1)\n");
+	    fprintf(stderr,"Illegal value for level.\n");
+	    fprintf(stderr,"Level must be <99 (Setting Level to 1)\n");
 	    return (INPmkTemp
 		    (" illegal (too high) argument to level parameter - level=1 assumed"));
 	}
@@ -60,7 +60,7 @@
 
     else {			/* no level on the line => default */
 	*level = 1;
-	printf("Warning -- Level not specified on line \"%s\"\nUsing level 1.\n", line);
+	fprintf(stderr,"Warning -- Level not specified on line \"%s\"\nUsing level 1.\n", line);
 	return ((char *) NULL);
     }
 
--- ng-spice-rework/src/xspice/icm/Makefile:1.7	Sat May 24 17:53:49 2008
+++ ng-spice-rework/src/xspice/icm/Makefile	Sun Dec 14 18:00:55 2008
@@ -1,4 +1,4 @@
-# The master makefile to make spiceopuse (TM) like codemodels
+# The master makefile to make spiceopus (TM) like codemodels
 # Under the GPLV2 or later license 
 # 2003 - Stefan Jones <stefan.jones@multigig.com>
 
@@ -106,8 +106,8 @@
 	-rm -rf .deps
 
 %.o: %.c
-	@echo '$(COMPILE) -c $<'; \
-	$(COMPILE) -Wp,-MD,.deps/$(*F).pp -c $<
+	@echo '$(COMPILE) $(DEPFLAGS) .deps/$(*F).pp -c $<'; \
+	$(COMPILE) $(DEPFLAGS) .deps/$(*F).pp -c $<
 	@-cp .deps/$(*F).pp .deps/$(*F).P; \
 	tr ' ' '\012' < .deps/$(*F).pp \
 	| sed -e 's/^\\$$//' -e '/^$$/ d' -e '/:$$/ d' -e 's/$$/ :/' \
--- ng-spice-rework/src/xspice/icm/Makefile.am:1.7	Sun Aug 24 17:13:28 2008
+++ ng-spice-rework/src/xspice/icm/Makefile.am	Sat Jan 31 22:22:29 2009
@@ -1,196 +0,0 @@
-## Process this file with automake to produce Makefile.in
-#
-# Hacked on 5.23.2003 by SDB
-
-
-SUBDIRS = icm_spice2poly
-
-AM_CPPFLAGS = -I$(top_srcdir)/src/include
-
-MAINTAINERCLEANFILES = Makefile.in
-
-EXTRA_DIST = README modpath.lst udnpath.lst spice2poly.cm dlmain.c
-
-
-# Edit these to point to your Opus installation
-CMPPDIR = $(top_srcdir)/src/xspice/cmpp
-OPUS_INCLUDE_DIR = $(top_srcdir)/src/include
-
-
-##------ automake definitions below. ------
-##
-
-## Yes, listing all this stuff is ugly, but I wasn't clever enough to
-## find a better way to make it work.
-
-SYSTEM_LIBS = -lm -lncurses -L/usr/X11R6/lib -lX11 -lXt -lXext -lXmu -lXaw  -lSM -lICE
-
-LOCAL_LIBS = -lcmxsp,-levtxsp,-lidnxsp,-lipcxsp,-lenhxsp,-lmifxsp,-ldev,-lckt,-linp,-lparser,-lhlp,-linp,-lderiv,-lcmaths,-lpoly,-lni,-lsparse,-lmisc,-lfte,-lplotting
-
-DEVICE_LIBS = -lasrc,-lbjt,-lbsim1,-lbsim2,-lbsim3,-lbsim3v1,-lbsim3v2,-lbsim4,-lcap,-lbsim3soipd,-lbsim3soifd,-lbsim3soidd,-lcccs,-lccvs,-lcpl,-lcsw,-ldio,-lind,-lisrc,-lhfet,-lhfet2,-ljfet,-ljfet2,-lltra,-lmes,-lmesa,-lmos1,-lmos2,-lmos3,-lmos6,-lmos9,-lres,-lsoi3,-lsw,-ltxl,-ltra,-lurc,-lvccs,-lvcvs,-lvsrc
-
-
-
-LOCAL_LIB_DIRS = \
-	-L$(top_srcdir)/src/xspice/cm/ 			\
-	-L$(top_srcdir)/src/xspice/enh/ 		\
-	-L$(top_srcdir)/src/xspice/evt/ 		\
-	-L$(top_srcdir)/src/xspice/idn/ 		\
-	-L$(top_srcdir)/src/xspice/ipc/ 		\
-	-L$(top_srcdir)/src/xspice/mif/ 		\
-	-L$(top_srcdir)/src/spicelib/devices/ 		\
-	-L$(top_srcdir)/src/spicelib/analysis/ 		\
-	-L$(top_srcdir)/src/spicelib/parser/ 		\
-					   		\
-	-L$(top_srcdir)/src/frontend/parser/ 		\
-	-L$(top_srcdir)/src/frontend/help/ 		\
-	-L$(top_srcdir)/src/maths/deriv/ 		\
-	-L$(top_srcdir)/src/maths/cmaths/ 		\
-	-L$(top_srcdir)/src/maths/poly/ 		\
-	-L$(top_srcdir)/src/maths/ni/ 			\
-	-L$(top_srcdir)/src/maths/sparse/ 		\
-	-L$(top_srcdir)/src/misc/ 			\
-							\
-	-L$(top_srcdir)/src/frontend/ 			\
-	-L$(top_srcdir)/src/frontend/plotting/	 	\
-							\
-	-L$(top_srcdir)/src/spicelib/devices/asrc/	\
-	-L$(top_srcdir)/src/spicelib/devices/bjt/	 \
-	-L$(top_srcdir)/src/spicelib/devices/bsim1/      	\
-	-L$(top_srcdir)/src/spicelib/devices/bsim2/      	\
-	-L$(top_srcdir)/src/spicelib/devices/bsim3/      	\
-	-L$(top_srcdir)/src/spicelib/devices/bsim3v1/  	\
-	-L$(top_srcdir)/src/spicelib/devices/bsim3v2/ 	\
-	-L$(top_srcdir)/src/spicelib/devices/bsim4/      	\
-	-L$(top_srcdir)/src/spicelib/devices/cap/		 \
-	-L$(top_srcdir)/src/spicelib/devices/bsim3soi_pd/   \
-	-L$(top_srcdir)/src/spicelib/devices/bsim3soi_fd/   \
-	-L$(top_srcdir)/src/spicelib/devices/bsim3soi_dd/   \
-	-L$(top_srcdir)/src/spicelib/devices/cccs/		\
-	-L$(top_srcdir)/src/spicelib/devices/ccvs/		\
-	-L$(top_srcdir)/src/spicelib/devices/cpl/		  \
-	-L$(top_srcdir)/src/spicelib/devices/csw/		  \
-	-L$(top_srcdir)/src/spicelib/devices/dio/		  \
-									\
-	-L$(top_srcdir)/src/spicelib/devices/ind/		  \
-	-L$(top_srcdir)/src/spicelib/devices/isrc/		\
-	-L$(top_srcdir)/src/spicelib/devices/hfet1/	       \
-	-L$(top_srcdir)/src/spicelib/devices/hfet2/	      \
-	-L$(top_srcdir)/src/spicelib/devices/jfet/		\
-	-L$(top_srcdir)/src/spicelib/devices/jfet2/	      \
-	-L$(top_srcdir)/src/spicelib/devices/ltra/		\
-	-L$(top_srcdir)/src/spicelib/devices/mes/		  \
-	-L$(top_srcdir)/src/spicelib/devices/mesa/	  	\
-	-L$(top_srcdir)/src/spicelib/devices/mos1/		\
-	-L$(top_srcdir)/src/spicelib/devices/mos2/		\
-	-L$(top_srcdir)/src/spicelib/devices/mos3/		\
-	-L$(top_srcdir)/src/spicelib/devices/mos6/		\
-	-L$(top_srcdir)/src/spicelib/devices/mos9/		\
-	-L$(top_srcdir)/src/spicelib/devices/res/		  \
-	-L$(top_srcdir)/src/spicelib/devices/soi3/		\
-	-L$(top_srcdir)/src/spicelib/devices/sw/		    \
-	-L$(top_srcdir)/src/spicelib/devices/txl/	   	\
-	-L$(top_srcdir)/src/spicelib/devices/tra/		  \
-	-L$(top_srcdir)/src/spicelib/devices/urc/		  \
-	-L$(top_srcdir)/src/spicelib/devices/vccs/		\
-	-L$(top_srcdir)/src/spicelib/devices/vcvs/		\
-	-L$(top_srcdir)/src/spicelib/devices/vsrc/		
-
-
-EXTRA_LIB_DIRS = \
-	-L$(top_srcdir)/src/xspice/cm/.libs/ 			\
-	-L$(top_srcdir)/src/xspice/enh/.libs/ 		\
-	-L$(top_srcdir)/src/xspice/evt/.libs/ 		\
-	-L$(top_srcdir)/src/xspice/idn/.libs/ 		\
-	-L$(top_srcdir)/src/xspice/ipc/.libs/ 		\
-	-L$(top_srcdir)/src/xspice/mif/.libs/ 		\
-	-L$(top_srcdir)/src/spicelib/devices/.libs/ 		\
-	-L$(top_srcdir)/src/spicelib/analysis/.libs/	\
-	-L$(top_srcdir)/src/spicelib/parser/.libs/	\
-					   		\
-	-L$(top_srcdir)/src/frontend/parser/.libs/	\
-	-L$(top_srcdir)/src/frontend/help/.libs/		\
-	-L$(top_srcdir)/src/maths/deriv/.libs/		\
-	-L$(top_srcdir)/src/maths/cmaths/.libs/		\
-	-L$(top_srcdir)/src/maths/poly/.libs/		\
-	-L$(top_srcdir)/src/maths/ni/.libs/		\
-	-L$(top_srcdir)/src/maths/sparse/.libs		\
-	-L$(top_srcdir)/src/misc/.libs/		\
-							\
-	-L$(top_srcdir)/src/frontend/.libs/			\
-	-L$(top_srcdir)/src/frontend/plotting/.libs/	 	\
-							\
-	-L$(top_srcdir)/src/spicelib/devices/asrc/.libs/	\
-	-L$(top_srcdir)/src/spicelib/devices/bjt/.libs/    \
-	-L$(top_srcdir)/src/spicelib/devices/bsim1/.libs/  	\
-	-L$(top_srcdir)/src/spicelib/devices/bsim2/.libs/ 	\
-	-L$(top_srcdir)/src/spicelib/devices/bsim3/.libs/ 	\
-	-L$(top_srcdir)/src/spicelib/devices/bsim3v1/.libs/  	\
-	-L$(top_srcdir)/src/spicelib/devices/bsim3v2/.libs/ 	\
-	-L$(top_srcdir)/src/spicelib/devices/bsim4/.libs/   	\
-	-L$(top_srcdir)/src/spicelib/devices/cap/.libs/ 	 \
-	-L$(top_srcdir)/src/spicelib/devices/bsim3soi_pd/.libs/   \
-	-L$(top_srcdir)/src/spicelib/devices/bsim3soi_fd/.libs/   \
-	-L$(top_srcdir)/src/spicelib/devices/bsim3soi_dd/.libs/   \
-	-L$(top_srcdir)/src/spicelib/devices/cccs/.libs/	       \
-	-L$(top_srcdir)/src/spicelib/devices/ccvs/.libs/	   \
-	-L$(top_srcdir)/src/spicelib/devices/cpl/.libs/	   \
-	-L$(top_srcdir)/src/spicelib/devices/csw/.libs/	    \
-	-L$(top_srcdir)/src/spicelib/devices/dio/.libs/	    \
-									\
-	-L$(top_srcdir)/src/spicelib/devices/ind/.libs/	    \
-	-L$(top_srcdir)/src/spicelib/devices/isrc/.libs/	   \
-	-L$(top_srcdir)/src/spicelib/devices/hfet1/.libs/	  \
-	-L$(top_srcdir)/src/spicelib/devices/hfet2/.libs/	\
-	-L$(top_srcdir)/src/spicelib/devices/jfet/.libs/	 \
-	-L$(top_srcdir)/src/spicelib/devices/jfet2/.libs/	 \
-	-L$(top_srcdir)/src/spicelib/devices/ltra/.libs/	 \
-	-L$(top_srcdir)/src/spicelib/devices/mes/.libs/	   \
-	-L$(top_srcdir)/src/spicelib/devices/mesa/.libs/     	\
-	-L$(top_srcdir)/src/spicelib/devices/mos1/.libs/	  \
-	-L$(top_srcdir)/src/spicelib/devices/mos2/.libs/	  \
-	-L$(top_srcdir)/src/spicelib/devices/mos3/.libs/	  \
-	-L$(top_srcdir)/src/spicelib/devices/mos6/.libs/	  \
-	-L$(top_srcdir)/src/spicelib/devices/mos9/.libs/	  \
-	-L$(top_srcdir)/src/spicelib/devices/res/.libs/	   \
-	-L$(top_srcdir)/src/spicelib/devices/soi3/.libs/	   \
-	-L$(top_srcdir)/src/spicelib/devices/sw/.libs/	    \
-	-L$(top_srcdir)/src/spicelib/devices/txl/.libs/      	\
-	-L$(top_srcdir)/src/spicelib/devices/tra/.libs/	    \
-	-L$(top_srcdir)/src/spicelib/devices/urc/.libs/	    \
-	-L$(top_srcdir)/src/spicelib/devices/vccs/.libs/	   \
-	-L$(top_srcdir)/src/spicelib/devices/vcvs/.libs/	  \
-	-L$(top_srcdir)/src/spicelib/devices/vsrc/.libs/	
-
-clean: clean-recursive
-	rm -f cmextrn.h cminfo.h udnextrn.h udninfo.h *.o
-
-
-cmextrn.h: modpath.lst $(SUBDIRS)/cfunc.c $(SUBDIRS)/ifspec.c
-	$(CMPPDIR)/cmpp -lst
-
-cminfo.h: modpath.lst $(SUBDIRS)/cfunc.c $(SUBDIRS)/ifspec.c
-	$(CMPPDIR)/cmpp -lst
-
-udnextrn.h: udnpath.lst $(SUBDIRS)/cfunc.c $(SUBDIRS)/ifspec.c
-	$(CMPPDIR)/cmpp -lst
-
-udninfo.h: udnpath.lst  $(SUBDIRS)/cfunc.c $(SUBDIRS)/ifspec.c
-	$(CMPPDIR)/cmpp -lst
-
-all: spice2poly.cm
-
-spice2poly.cm: $(SUBDIRS)/cfunc.o $(SUBDIRS)/ifspec.o dlmain.o
-	$(top_srcdir)/libtool --mode=link $(CC) -module -shared -fPIC -o spice2poly.cm \
-		$(SUBDIRS)/cfunc.o $(SUBDIRS)/ifspec.o dlmain.o \
-		$(SYSTEM_LIBS) $(LOCAL_LIB_DIRS) \
-		-Wl,--start-group -Wl,$(LOCAL_LIBS) -Wl,--end-group -ldl \
-		-Wl,--rpath,/usr/local/geda/lib/ng-spice-rework
-
-dlmain.o: dlmain.c cmextrn.h udnextrn.h cminfo.h udninfo.h
-	$(CC) -fPIC -I$(OPUS_INCLUDE_DIR) $(INCLUDES) $(CFLAGS) -DCM_LINUX -c dlmain.c
-
-
-distclean: clean
-
-check:
--- ng-spice-rework/src/xspice/icm/makedefs.in:1.8	Sat May 24 17:53:49 2008
+++ ng-spice-rework/src/xspice/icm/makedefs.in	Sun Dec 14 18:00:55 2008
@@ -18,6 +18,7 @@
 
 # CFLAGS to use here
 CFLAGS = @CFLAGS@ -fPIC -DCM_LINUX
+DEPFLAGS = -MD -MF
 ISMINGW = $(shell uname | grep -c "MINGW32")
 ifeq ($(ISMINGW), 1)
   CFLAGS = @CFLAGS@ -DCM_WINDOWS
@@ -26,10 +27,11 @@
 ifeq ($(ISCYGWIN), 1)
   CFLAGS = @CFLAGS@ -DCM_WINDOWS
 endif
-ISSUNCC = $(shell uname | grep -c "SunOS")
-ifeq ($(ISSUNCC), 1)
+ISSUNOS = $(shell uname | grep -c "SunOS")
+ifeq ($(ISSUNOS), 1)
   ifneq "$(CC)" "gcc"
     CFLAGS = @CFLAGS@ -KPIC -DCM_LINUX
+    DEPFLAGS = -xMD -xMF
   endif
 endif
 
--- ng-spice-rework/src/xspice/ipc/ipcaegis.c:1.4	Sat Jan 12 16:24:23 2008
+++ ng-spice-rework/src/xspice/ipc/ipcaegis.c	Sun Dec 14 17:57:21 2008
@@ -303,4 +303,8 @@
    return IPC_STATUS_OK;
 }
 
+#else
+
+int intDummy1;
+
 #endif  /* IPC_AEGIS_MAILBOXES */
--- ng-spice-rework/src/xspice/ipc/ipctiein.c:1.5	Sat Jan 12 16:24:23 2008
+++ ng-spice-rework/src/xspice/ipc/ipctiein.c	Sun Dec 14 17:57:21 2008
@@ -363,7 +363,6 @@
         return(IPC_TRUE);
     }
 
-    return(IPC_TRUE);
 }
 
 
--- ng-spice-rework/tests/adms/hicum0/hic0_gum.sp:1.2	Tue Jul 24 09:11:02 2007
+++ ng-spice-rework/tests/adms/hicum0/hic0_gum.sp	Sun Dec 28 17:30:10 2008
@@ -12,256 +12,6 @@
 plot abs(i(vc))/abs(i(vb)) vs abs(-i(vc)) xlog xlimit 1e-09 10e-3 ylimit 0 300
 .endc
 
-********************************************************************************
-********************************************************************************
-* HICUM Level0 Version 1.1 model cards for testing
-********************************************************************************
-********************************************************************************
-* 1D transistor: Isothermal Simulation and Temperature dependence
-********************************************************************************
-.subckt hicumL0V1p1_1D c b e s
-qhcm0 c b e s hic0_full
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=0.0 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_1D
-********************************************************************************
-* 1D transistor: Electrothermal Simulation to test self-heating
-********************************************************************************
-.subckt hicumL0V1p1_1D_slh c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=0.0 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=1000.0 cth=1.0e-10 
-+ tnom=27.0 dt=0.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_1D_slh
-********************************************************************************
-* 1D transistor: Isothermal Simulation with NQS Effect: future
-********************************************************************************
-.subckt hicumL0V1p1_1D_nqs c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=0.0 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_1D_nqs
-********************************************************************************
-* 1D transistor: Isothermal Simulation to test collector current spreading
-********************************************************************************
-.subckt hicumL0V1p1_1D_ccs c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=0.0 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_1D_ccs
-********************************************************************************
-* Internal transistor: Isothermal Simulation and Temperature dependence (Tunneling current at peripheral node:future)
-********************************************************************************
-.subckt hicumL0V1p1_i_tnp c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_i_tnp
-********************************************************************************
-* Internal transistor: Isothermal Simulation and Temperature dependence (Tunneling current at internal node:future)
-********************************************************************************
-.subckt hicumL0V1p1_i_tni c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_i_tni
-********************************************************************************
-* Complete transistor: Isothermal Simulation and Temperature dependence
-********************************************************************************
-.subckt hicumL0V1p1_c c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_c
-********************************************************************************
-* Complete transistor: Electrothermal Simulation to test self-heating
-********************************************************************************
-.subckt hicumL0V1p1_c_slh c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=1000.0 cth=1.0e-10 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_c_slh
-********************************************************************************
-* Complete transistor: Isothermal Simulation with NQS Effect: future
-********************************************************************************
-.subckt hicumL0V1p1_c_nqs c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_c_nqs
-********************************************************************************
-* Complete transistor: Isothermal Simulation to test collector current spreading
-********************************************************************************
-.subckt hicumL0V1p1_c_ccs c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_c_ccs
-********************************************************************************
-* Complete transistor: Isothermal Simulation with substrate diode
-********************************************************************************
-.subckt hicumL0V1p1_c_sbt c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=1.0e-17 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=3.64e-14 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_c_sbt
-********************************************************************************
-* Complete transistor: Isothermal Simulation with substrate network: future
-********************************************************************************
-.subckt hicumL0V1p1_c_sbn c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=1.0e-17 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=3.64e-14 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_c_sbn
-********************************************************************************
-* Complete test transistor: default
-********************************************************************************
-.subckt hicumL0V11_default c b e s
-qhcm0 c b e s hic0_full
-.ends hicumL0V11_default
-********************************************************************************
+.include model-card-hicumL0V1p11.lib
 
 .end
--- ng-spice-rework/tests/adms/hicum0/hic0_out.sp:1.2	Tue Jul 24 09:11:02 2007
+++ ng-spice-rework/tests/adms/hicum0/hic0_out.sp	Sun Dec 28 17:30:10 2008
@@ -11,256 +11,6 @@
 plot abs(i(vc))
 .endc
 
-********************************************************************************
-********************************************************************************
-* HICUM Level0 Version 1.1 model cards for testing
-********************************************************************************
-********************************************************************************
-* 1D transistor: Isothermal Simulation and Temperature dependence
-********************************************************************************
-.subckt hicumL0V1p1_1D c b e s
-qhcm0 c b e s hic0_full
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=0.0 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_1D
-********************************************************************************
-* 1D transistor: Electrothermal Simulation to test self-heating
-********************************************************************************
-.subckt hicumL0V1p1_1D_slh c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=0.0 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=1000.0 cth=1.0e-10 
-+ tnom=27.0 dt=0.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_1D_slh
-********************************************************************************
-* 1D transistor: Isothermal Simulation with NQS Effect: future
-********************************************************************************
-.subckt hicumL0V1p1_1D_nqs c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=0.0 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_1D_nqs
-********************************************************************************
-* 1D transistor: Isothermal Simulation to test collector current spreading
-********************************************************************************
-.subckt hicumL0V1p1_1D_ccs c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=0.0 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_1D_ccs
-********************************************************************************
-* Internal transistor: Isothermal Simulation and Temperature dependence (Tunneling current at peripheral node:future)
-********************************************************************************
-.subckt hicumL0V1p1_i_tnp c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_i_tnp
-********************************************************************************
-* Internal transistor: Isothermal Simulation and Temperature dependence (Tunneling current at internal node:future)
-********************************************************************************
-.subckt hicumL0V1p1_i_tni c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_i_tni
-********************************************************************************
-* Complete transistor: Isothermal Simulation and Temperature dependence
-********************************************************************************
-.subckt hicumL0V1p1_c c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_c
-********************************************************************************
-* Complete transistor: Electrothermal Simulation to test self-heating
-********************************************************************************
-.subckt hicumL0V1p1_c_slh c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=1000.0 cth=1.0e-10 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_c_slh
-********************************************************************************
-* Complete transistor: Isothermal Simulation with NQS Effect: future
-********************************************************************************
-.subckt hicumL0V1p1_c_nqs c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_c_nqs
-********************************************************************************
-* Complete transistor: Isothermal Simulation to test collector current spreading
-********************************************************************************
-.subckt hicumL0V1p1_c_ccs c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=0.0 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_c_ccs
-********************************************************************************
-* Complete transistor: Isothermal Simulation with substrate diode
-********************************************************************************
-.subckt hicumL0V1p1_c_sbt c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=1.0e-17 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=3.64e-14 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_c_sbt
-********************************************************************************
-* Complete transistor: Isothermal Simulation with substrate network: future
-********************************************************************************
-.subckt hicumL0V1p1_c_sbn c b e s
-qhcm0 c b e s hic0_full 
-.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
-+ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
-+ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
-+ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=1.0e-17 msc=1.0
-+ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
-+ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
-+ cjs0=3.64e-14 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
-+ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
-+ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
-+ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
-+ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
-+ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0
-+ tnom=27.0 npn=1 pnp=0
-*+ dt=0.0
-.ends hicumL0V1p1_c_sbn
-********************************************************************************
-* Complete test transistor: default
-********************************************************************************
-.subckt hicumL0V11_default c b e s
-qhcm0 c b e s hic0_full
-.ends hicumL0V11_default
-********************************************************************************
+.include model-card-hicumL0V1p11.lib 
 
 .end
--- /dev/null	Sat Jan 31 22:22:29 2009
+++ ng-spice-rework/tests/adms/hicum0/model-card-hicumL0V1p11.lib	Sun Dec 28 17:32:16 2008
@@ -0,0 +1,251 @@
+********************************************************************************
+********************************************************************************
+* HICUM Level0 Version 1.1 model cards for testing
+********************************************************************************
+********************************************************************************
+* 1D transistor: Isothermal Simulation and Temperature dependence
+********************************************************************************
+.subckt hicumL0V1p1_1D c b e s
+qhcm0 c b e s hic0_full
+.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
++ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
++ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
++ aleav=0.196e-3 rbi0=0.0 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
++ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
++ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
++ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
++ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
++ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
++ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
++ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
++ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
++ tnom=27.0 npn=1 pnp=0
+*+ dt=0.0
+.ends hicumL0V1p1_1D
+********************************************************************************
+* 1D transistor: Electrothermal Simulation to test self-heating
+********************************************************************************
+.subckt hicumL0V1p1_1D_slh c b e s
+qhcm0 c b e s hic0_full 
+.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
++ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
++ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
++ aleav=0.196e-3 rbi0=0.0 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
++ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
++ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
++ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
++ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
++ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
++ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
++ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
++ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=1000.0 cth=1.0e-10 
++ tnom=27.0 dt=0.0 npn=1 pnp=0
+*+ dt=0.0
+.ends hicumL0V1p1_1D_slh
+********************************************************************************
+* 1D transistor: Isothermal Simulation with NQS Effect: future
+********************************************************************************
+.subckt hicumL0V1p1_1D_nqs c b e s
+qhcm0 c b e s hic0_full 
+.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
++ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
++ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
++ aleav=0.196e-3 rbi0=0.0 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
++ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
++ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
++ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
++ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
++ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
++ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
++ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
++ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
++ tnom=27.0 npn=1 pnp=0
+*+ dt=0.0
+.ends hicumL0V1p1_1D_nqs
+********************************************************************************
+* 1D transistor: Isothermal Simulation to test collector current spreading
+********************************************************************************
+.subckt hicumL0V1p1_1D_ccs c b e s
+qhcm0 c b e s hic0_full 
+.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
++ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
++ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
++ aleav=0.196e-3 rbi0=0.0 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
++ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
++ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
++ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
++ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
++ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
++ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
++ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
++ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
++ tnom=27.0 npn=1 pnp=0
+*+ dt=0.0
+.ends hicumL0V1p1_1D_ccs
+********************************************************************************
+* Internal transistor: Isothermal Simulation and Temperature dependence (Tunneling current at peripheral node:future)
+********************************************************************************
+.subckt hicumL0V1p1_i_tnp c b e s
+qhcm0 c b e s hic0_full 
+.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
++ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
++ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
++ aleav=0.196e-3 rbi0=71.76 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
++ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
++ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
++ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
++ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
++ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
++ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
++ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
++ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
++ tnom=27.0 npn=1 pnp=0
+*+ dt=0.0
+.ends hicumL0V1p1_i_tnp
+********************************************************************************
+* Internal transistor: Isothermal Simulation and Temperature dependence (Tunneling current at internal node:future)
+********************************************************************************
+.subckt hicumL0V1p1_i_tni c b e s
+qhcm0 c b e s hic0_full 
+.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
++ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
++ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
++ aleav=0.196e-3 rbi0=71.76 rbx=0.0 fgeo=0.73 re=0.0 rcx=0.0 iscs=0.0 msc=1.0
++ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
++ vptci=46 cjcx0=1.0e-20 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
++ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
++ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
++ vces=0.1 vpt=5 cbepar=0.0 cbcpar=0.0 kf=1.43e-8 af=2.0 vgb=1.17
++ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
++ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
++ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
++ tnom=27.0 npn=1 pnp=0
+*+ dt=0.0
+.ends hicumL0V1p1_i_tni
+********************************************************************************
+* Complete transistor: Isothermal Simulation and Temperature dependence
+********************************************************************************
+.subckt hicumL0V1p1_c c b e s
+qhcm0 c b e s hic0_full 
+.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
++ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
++ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
++ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=0.0 msc=1.0
++ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
++ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
++ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
++ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
++ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
++ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
++ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
++ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
++ tnom=27.0 npn=1 pnp=0
+*+ dt=0.0
+.ends hicumL0V1p1_c
+********************************************************************************
+* Complete transistor: Electrothermal Simulation to test self-heating
+********************************************************************************
+.subckt hicumL0V1p1_c_slh c b e s
+qhcm0 c b e s hic0_full 
+.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
++ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
++ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
++ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=0.0 msc=1.0
++ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
++ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
++ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
++ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
++ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
++ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
++ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
++ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=1000.0 cth=1.0e-10 
++ tnom=27.0 npn=1 pnp=0
+*+ dt=0.0
+.ends hicumL0V1p1_c_slh
+********************************************************************************
+* Complete transistor: Isothermal Simulation with NQS Effect: future
+********************************************************************************
+.subckt hicumL0V1p1_c_nqs c b e s
+qhcm0 c b e s hic0_full 
+.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
++ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
++ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
++ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=0.0 msc=1.0
++ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
++ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
++ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
++ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
++ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
++ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
++ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
++ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
++ tnom=27.0 npn=1 pnp=0
+*+ dt=0.0
+.ends hicumL0V1p1_c_nqs
+********************************************************************************
+* Complete transistor: Isothermal Simulation to test collector current spreading
+********************************************************************************
+.subckt hicumL0V1p1_c_ccs c b e s
+qhcm0 c b e s hic0_full 
+.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
++ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
++ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
++ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=0.0 msc=1.0
++ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
++ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
++ cjs0=0.0 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
++ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
++ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
++ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
++ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
++ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0 
++ tnom=27.0 npn=1 pnp=0
+*+ dt=0.0
+.ends hicumL0V1p1_c_ccs
+********************************************************************************
+* Complete transistor: Isothermal Simulation with substrate diode
+********************************************************************************
+.subckt hicumL0V1p1_c_sbt c b e s
+qhcm0 c b e s hic0_full 
+.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
++ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
++ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
++ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=1.0e-17 msc=1.0
++ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
++ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
++ cjs0=3.64e-14 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
++ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
++ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
++ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
++ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
++ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0
++ tnom=27.0 npn=1 pnp=0
+*+ dt=0.0
+.ends hicumL0V1p1_c_sbt
+********************************************************************************
+* Complete transistor: Isothermal Simulation with substrate network: future
+********************************************************************************
+.subckt hicumL0V1p1_c_sbn c b e s
+qhcm0 c b e s hic0_full 
+.model hic0_full npn level=7 is=1.3525E-18 vef=8.0 iqf=3.0e-2 iqr=1e6
++ iqfh=1e6 tfh=1e-8 ibes=1.16E-20 mbe=1.015 ires=1.16e-16 mre=2.0 ibcs=1.16e-20
++ mbc=1.015 mcf=1.0 mcr=1 kavl=0.9488 eavl=11.96e10 alkav=0.825e-4
++ aleav=0.196e-3 rbi0=71.76 rbx=8.83 fgeo=0.73 re=12.534 rcx=9.165 iscs=1.0e-17 msc=1.0
++ cje0=8.11e-15 vde=0.95 ze=0.5 aje=1.8 cjci0=1.16e-15 vdci=0.8 zci=0.333 
++ vptci=46 cjcx0=5.4e-15 vdcx=0.7 zcx=0.333 vptcx=100 fbc=0.1526 vr0e=1.6 vr0c=8.0
++ cjs0=3.64e-14 vds=0.6 zs=0.447 vpts=100 t0=4.75e-12 dt0h=2.1e-12 tbvl=4.0e-12
++ tef0=1.8e-12 gte=1.4 thcs=30.0e-12 ahc=0.75 tr=0.0 rci0=127.8 vlim=0.7 
++ vces=0.1 vpt=5 cbepar=1.13e-15 cbcpar=2.97e-15 kf=1.43e-8 af=2.0 vgb=1.17
++ alt0=0.0 kt0=0.0 zetaci=1.6 alvs=1.0e-3 alces=0.4e-3 zetarbi=0.588 
++ zetarbx=0.206 zetarcx=0.223 zetare=0.0 vge=1.1386 vgc=1.1143 vgs=1.15 f1vg=-1.02377e-4
++ f2vg=4.3215e-4 zetact=3.5 zetabet=4.0 rth=0.0 cth=0.0
++ tnom=27.0 npn=1 pnp=0
+*+ dt=0.0
+.ends hicumL0V1p1_c_sbn
+********************************************************************************
+* Complete test transistor: default
+********************************************************************************
+.subckt hicumL0V11_default c b e s
+qhcm0 c b e s hic0_full
+.ends hicumL0V11_default
+********************************************************************************
--- ng-spice-rework/visualc/vngspice.vcproj:1.2	Sat Nov 29 20:21:56 2008
+++ ng-spice-rework/visualc/vngspice.vcproj	Sat Jan 31 15:21:22 2009
@@ -47,7 +47,7 @@
 				RuntimeLibrary="1"
 				RuntimeTypeInfo="false"
 				UsePrecompiledHeader="0"
-				WarningLevel="3"
+				WarningLevel="4"
 				Detect64BitPortabilityProblems="false"
 				DebugInformationFormat="4"
 				CompileAs="1"
@@ -65,7 +65,7 @@
 				Name="VCLinkerTool"
 				AdditionalDependencies="psapi.lib"
 				OutputFile="$(OutDir)\bin\vngspice_d.exe"
-				LinkIncremental="2"
+				LinkIncremental="1"
 				GenerateManifest="false"
 				GenerateDebugInformation="true"
 				SubSystem="2"
@@ -135,8 +135,8 @@
 				RuntimeLibrary="0"
 				RuntimeTypeInfo="true"
 				UsePrecompiledHeader="0"
-				WarningLevel="4"
-				Detect64BitPortabilityProblems="true"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
 				DebugInformationFormat="3"
 				CompileAs="1"
 			/>
@@ -1100,11 +1100,11 @@
 				>
 			</File>
 			<File
-				RelativePath="..\src\include\grid.h"
+				RelativePath="..\src\frontend\plotting\grid.h"
 				>
 			</File>
 			<File
-				RelativePath="..\src\frontend\plotting\grid.h"
+				RelativePath="..\src\include\grid.h"
 				>
 			</File>
 			<File
