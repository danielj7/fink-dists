diff -uNbr arts-1.1.0/Makefile.am.in arts-1.1.0-new/Makefile.am.in
--- arts-1.1.0/Makefile.am.in	Wed May 22 18:02:07 2002
+++ arts-1.1.0-new/Makefile.am.in	Sat Dec 14 17:46:11 2002
@@ -27,7 +27,7 @@
 	cd $(top_srcdir) && $(MAKE) -f admin/Makefile.common subdirs 
 
 AUTOMAKE_OPTIONS = foreign 1.4
-COMPILE_FIRST = libltdl mcop mcopidl flow mcop_mt soundserver artsc examples tests doc 
+COMPILE_FIRST = libltdl mcop mcopidl flow mcop_mt x11 soundserver artsc examples tests doc 
 EXTRA_DIST = admin
 
 dist-hook:
diff -uNbr arts-1.1.0/artsc/Makefile.am arts-1.1.0-new/artsc/Makefile.am
--- arts-1.1.0/artsc/Makefile.am	Mon Aug  5 13:58:30 2002
+++ arts-1.1.0-new/artsc/Makefile.am	Sat Dec 14 17:46:11 2002
@@ -9,21 +9,26 @@
 bin_SCRIPTS = artsc-config artsdsp
 
 libartsdsp_la_SOURCES = artsdsp.c
-libartsdsp_la_LDFLAGS = -no-undefined -module
+libartsdsp_la_LDFLAGS = -no-undefined -version-info 1:7 -module
 libartsdsp_la_LIBADD = libartsc.la
 
 libartsdsp_st_la_SOURCES = artsc.c artsdsp.c
-libartsdsp_st_la_LDFLAGS = -no-undefined -module
+libartsdsp_st_la_LDFLAGS = -no-undefined -version-info 1:7 -module
 libartsdsp_st_la_LIBADD = $(top_builddir)/libltdl/libltdlc.la
 
 libartsc_la_SOURCES = artsc.c
-libartsc_la_LDFLAGS = -no-undefined
+libartsc_la_LDFLAGS = -no-undefined -version-info 1:7
 libartsc_la_LIBADD = $(top_builddir)/libltdl/libltdlc.la $(LIBPTHREAD) $(USE_THREADS)
 
 libartscbackend_la_SOURCES = artscbackend.cc
-libartscbackend_la_LDFLAGS = -no-undefined -module $(KDE_RPATH)
-libartscbackend_la_LIBADD = $(FLOWLIBS) \
-    $(top_builddir)/soundserver/libsoundserver_idl.la
+libartscbackend_la_LDFLAGS = -no-undefined -version-info 1:7 -module $(KDE_RPATH)
+libartscbackend_la_LIBADD = \
+    $(top_builddir)/mcop/libmcop.la \
+    $(top_builddir)/flow/libartsflow.la \
+    $(top_builddir)/flow/libartsflow_idl.la \
+    $(top_builddir)/soundserver/libsoundserver_idl.la \
+    $(top_builddir)/soundserver/libkmedia2.la \
+    $(top_builddir)/soundserver/libkmedia2_idl.la
 
 artscincludedir = $(includedir)/artsc
 artscinclude_HEADERS = artsc.h
diff -uNbr arts-1.1.0/configure.in.in arts-1.1.0-new/configure.in.in
--- arts-1.1.0/configure.in.in	Mon Aug  5 13:58:29 2002
+++ arts-1.1.0-new/configure.in.in	Sat Dec 14 17:46:11 2002
@@ -586,6 +586,26 @@
 AC_SUBST(GLIB_LIBADD)
 AC_SUBST(GLIB_LDFLAGS)
  
+dnl Check for esd
+AC_MSG_CHECKING(for esound)
+if test "x$PKG_CONFIG" != "xno"; then
+if $PKG_CONFIG --exists esound >/dev/null 2>&1 ; then
+    ESD_CFLAGS="`$PKG_CONFIG --cflags esound`"
+    ESD_LIBS="`$PKG_CONFIG --libs esound`"
+    ESD_DEPLIBS="$ESD_LIBS"
+    AC_DEFINE(HAVE_ESD,1,[Define if you have ESound installed (required on Mac OS X)])
+    AC_MSG_RESULT(yes)
+fi
+fi
+
+if test -z "$ESD_LIBS"; then
+	AC_MSG_RESULT([not installed])
+fi
+
+AC_SUBST(ESD_CFLAGS)
+AC_SUBST(ESD_LIBS)
+AC_SUBST(ESD_DEPLIBS)
+
 dnl OpenBSD requires an -lossaudio and soundcard.h to provide OSS audio I/O
 AC_CHECK_HEADERS(soundcard.h)
 AC_CHECK_LIB(ossaudio, _oss_ioctl, [LIBOSSAUDIO="-lossaudio"])
diff -uNbr arts-1.1.0/flow/Makefile.am arts-1.1.0-new/flow/Makefile.am
--- arts-1.1.0/flow/Makefile.am	Mon Aug  5 13:58:31 2002
+++ arts-1.1.0-new/flow/Makefile.am	Sat Dec 14 17:49:37 2002
@@ -1,3 +1,5 @@
+AM_CFLAGS = -DGSL_WANT_GLIB_WRAPPER -DGSL_WANT_ARTS_THREADS
+AM_CXXFLAGS = -DGSL_WANT_GLIB_WRAPPER -DGSL_WANT_ARTS_THREADS
 
 SUBDIRS = mcopclass gsl gslpp
 INCLUDES = -I$(top_srcdir)/mcop $(all_includes)
@@ -7,12 +9,12 @@
 lib_LTLIBRARIES = libartsflow_idl.la libartsflow.la
 
 libartsflow_idl_la_SOURCES = artsflow.cc
-libartsflow_idl_la_LDFLAGS = -no-undefined -version-info 1:0
+libartsflow_idl_la_LDFLAGS = -no-undefined -version-info 1:7
 libartsflow_idl_la_LIBADD = $(top_builddir)/mcop/libmcop.la $(LIBPOSIX4)
 
 libartsflow_la_LIBADD = $(top_builddir)/mcop/libmcop.la libartsflow_idl.la $(top_builddir)/flow/gslpp/libgslpp.la $(LIBAUDIOFILE) $(LIBASOUND) $(LIBAUDIOIO) $(LIBOSSAUDIO) $(LIBAUDIONAS) $(SGILIBAUDIO) -lm \
-  $(top_builddir)/flow/gsl/libgsl.la
-libartsflow_la_LDFLAGS = -no-undefined -version-info 1:0
+ $(top_builddir)/flow/gsl/libgsl.la $(LIB_POLL)
+libartsflow_la_LDFLAGS = -no-undefined -version-info 1:7 $(FRAMEWORK_COREAUDIO)
 libartsflow_la_COMPILE_FIRST = artsflow.h
 libartsflow_la_SOURCES =  synth_play_impl.cc \
   synthschedule.cc gslschedule.cc audiosubsys.cc \
@@ -26,7 +28,7 @@
   audioionull.cc audioiolibaudioio.cc \
   audioiosun.cc audioioaix.cc audioionas.cc cpuinfo.cc \
   audioioossthreaded.cc audiotobytestream_impl.cc audioiosgi.cc \
-  datahandle_impl.cc
+  audioiocoreaudio.cc datahandle_impl.cc
 
 artsincludedir = $(includedir)/arts
 artsinclude_HEADERS = artsflow.h audiosubsys.h cache.h \
diff -uNbr arts-1.1.0/flow/audioiocoreaudio.cc arts-1.1.0-new/flow/audioiocoreaudio.cc
--- arts-1.1.0/flow/audioiocoreaudio.cc	Wed Dec 31 19:00:00 1969
+++ arts-1.1.0-new/flow/audioiocoreaudio.cc	Sat Dec 14 17:46:31 2002
@@ -0,0 +1,619 @@
+    /*
+    
+    Copyright (C) 2001 Stefan Westerfeld
+                        stefan@space.twc.de
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+    
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+    Boston, MA 02111-1307, USA.
+    
+    */
+    /*
+        Modifications for ARTS -    
+        Ben Hines <bhines@alumni.ucsd.edu>
+        Ben Reed  <ranger@befunk.com>
+        
+        Some CoreAudio code borrowed from ESD -
+        Shawn Hsiao <phsiao@mac.com>
+        Masanori Sekino <m-sekino@mb.kcom.ne.jp>
+    */
+
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define DEBUG 1
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <sys/socket.h>
+#include <sys/file.h>
+
+/* for useful debugging macros */
+#include <mach/error.h>
+
+#include <CoreAudio/CoreAudio.h>
+
+#include "debug.h"
+#include "audioio.h"
+#include "audiosubsys.h"
+
+#define NAME_LEN 256		/* max length of a device name */
+#define BUF_SIZE (4 * 1024)  /* from ESD */
+
+#define driverVersion "0.01 alpha"
+
+#ifdef BIG_ENDIAN
+#define defaultFormat 17
+#else
+#define defaultFormat 16
+#endif
+    
+bool NotifyOnError (OSStatus inRetVal, const char * inStringDesc);
+
+struct audio_queue {
+    float dataBuf[BUF_SIZE];
+    pthread_mutex_t mutex;
+    pthread_cond_t condition;
+    int numSamples;
+};
+
+static OSStatus PlaybackIOProc(AudioDeviceID inDevice,
+			const AudioTimeStamp *inNow,
+			const AudioBufferList *inInputData,
+			const AudioTimeStamp *inInputTime,
+			AudioBufferList *outOutputData,
+			const AudioTimeStamp *inOutputTime,
+			audio_queue *inClientData);
+
+static OSStatus RecordIOProc(AudioDeviceID inDevice,
+		      const AudioTimeStamp *inNow,
+		      const AudioBufferList *inInputData,
+		      const AudioTimeStamp *inInputTime,
+		      AudioBufferList *outOutputData,
+		      const AudioTimeStamp *inOutputTime,
+		      audio_queue *inClientData);
+                                              
+namespace Arts {
+
+class AudioIOCoreAudio : public AudioIO {
+
+protected:
+     /* From ESD */
+     AudioDeviceID gOutputDeviceID, gInputDeviceID;
+    
+     audio_queue input;
+     audio_queue output;    
+    
+     int audioPlaybackStarted, audioRecordStarted;
+     int coreaudio_has_output_device;
+     int coreaudio_has_input_device;
+     int coreaudio_init;
+     
+     /* Arts Specific */
+     int audio_fd;
+     int bytesPerSec;
+     timeval start;
+        
+public:
+	AudioIOCoreAudio();
+	bool supportsFormat(AudioDeviceID device, AudioStreamBasicDescription *format);
+	void setParam(AudioParam param, int& value);
+	int getParam(AudioParam param);
+
+	bool open();
+	void close();
+	int read(void *buffer, int size);
+	int write(void *buffer, int size);
+
+};
+
+REGISTER_AUDIO_IO(AudioIOCoreAudio, "coreaudio", "Apple CoreAudio");
+}; // end namespace Arts
+
+using namespace std;
+using namespace Arts;
+
+AudioIOCoreAudio::AudioIOCoreAudio() {
+        artsdebug("CoreAudio driver version %s", driverVersion);
+        /*
+         * default parameters
+         */
+        param(samplingRate) = 44100;
+        paramStr(deviceName) = "default";
+        param(fragmentSize) = 1024;
+        param(fragmentCount) = 7;
+        param(channels) = 2;
+        param(direction) = 2;
+        param(format) = defaultFormat;
+        
+        input.numSamples = output.numSamples = 0;
+    
+        audioPlaybackStarted = 0, audioRecordStarted = 0;
+        coreaudio_has_output_device = 0;
+        coreaudio_has_input_device = 0;
+        coreaudio_init = 0;
+}
+
+void
+AudioIOCoreAudio::close()
+{
+    artsdebug("CoreAudio driver close()");
+    
+    /* deactivate both of them */
+    if (coreaudio_has_output_device && audioPlaybackStarted) {
+        NotifyOnError(AudioDeviceStop(gOutputDeviceID, (AudioDeviceIOProc) PlaybackIOProc),
+                        "AudioDeviceStop (PlaybackIOProc)");
+        NotifyOnError(AudioDeviceRemoveIOProc(gOutputDeviceID,(AudioDeviceIOProc) PlaybackIOProc),
+                        "AudioDeviceRemoveIOProc (PlaybackIOProc)");
+        audioPlaybackStarted = 0;
+        coreaudio_has_output_device = 0;
+    }
+    
+    if (coreaudio_has_input_device && audioRecordStarted) {        
+        NotifyOnError(AudioDeviceStop(gInputDeviceID, (AudioDeviceIOProc) RecordIOProc),
+                        "AudioDeviceStop (RecordIOProc)");
+        NotifyOnError(AudioDeviceRemoveIOProc(gInputDeviceID,(AudioDeviceIOProc) RecordIOProc),
+                        "AudioDeviceRemoveIOProc (RecordIOProc)");
+        audioRecordStarted = 0;
+        coreaudio_has_input_device = 0;
+    }
+}
+
+ 
+int 
+AudioIOCoreAudio::write(void *buffer, int buf_size) {
+
+  float scale = 1.0 / SHRT_MAX;
+  int remain_to_write = buf_size;
+
+  if (!coreaudio_has_output_device)
+  {
+    arts_warning("AudioIOCoreAudio::write with no output device!");
+    return -1;
+  }
+  if (!audioPlaybackStarted) {
+    NotifyOnError(AudioDeviceStart(gOutputDeviceID,(AudioDeviceIOProc)  PlaybackIOProc),
+                    "AudioDeviceStart (PlaybackIOProc)");
+    audioPlaybackStarted = 1;
+  }
+
+  while (remain_to_write)
+  {
+    pthread_mutex_lock(&output.mutex);
+
+    while(output.numSamples == BUF_SIZE)
+      pthread_cond_wait(&output.condition, &output.mutex);
+
+    {
+      short *src_data = (short *)buffer + (buf_size - remain_to_write) / sizeof(short);
+      float *dst_data = output.dataBuf + output.numSamples;
+      int src_samples = remain_to_write / sizeof(short);
+      int dst_samples = BUF_SIZE - output.numSamples;
+      int n = (dst_samples < src_samples) ? dst_samples : src_samples;
+      int i;
+
+      for (i = 0; i < n; i++)
+        dst_data[i] = scale * src_data[i];
+
+      output.numSamples += n;
+      remain_to_write -= n * sizeof(short);
+    }
+
+    pthread_mutex_unlock(&output.mutex);
+  }
+
+  return (buf_size);
+
+}
+
+int AudioIOCoreAudio::read(void *buffer, int buf_size) {
+  float scale = SHRT_MAX;
+  int remain_to_read = buf_size;
+
+  if (!coreaudio_has_input_device)
+  {
+    arts_warning("AudioIOCoreAudio::read with no input device!");
+    return -1;
+  }
+
+  if (!audioRecordStarted) {
+    NotifyOnError(AudioDeviceStart(gInputDeviceID,(AudioDeviceIOProc)  RecordIOProc),
+                    "AudioDeviceStart (RecordIOProc)");
+    audioRecordStarted = 1;
+  }
+
+  while (remain_to_read)
+  {
+    pthread_mutex_lock(&input.mutex);
+
+    while(input.numSamples == BUF_SIZE)
+      pthread_cond_wait(&input.condition, &input.mutex);
+
+    {
+      float *src_data = input.dataBuf + input.numSamples;
+      short *dst_data = (short *)buffer + (buf_size - remain_to_read) / sizeof(short);
+      int src_samples = BUF_SIZE - input.numSamples;
+      int dst_samples = remain_to_read / sizeof(short);
+      int n = (dst_samples < src_samples) ? dst_samples : src_samples;
+      int i;
+
+      for (i = 0; i < n; i++)
+        dst_data[i] = (short)(scale * src_data[i]);
+
+      input.numSamples += n;
+      remain_to_read -= n * sizeof(short);
+    }
+
+    pthread_mutex_unlock(&input.mutex);
+  }
+
+  return (buf_size);
+
+}
+
+
+bool
+AudioIOCoreAudio::open()
+{
+        #define LEN_DEVICE_NAME 128
+        UInt32 propertySize, bufferByteCount;
+        char deviceName[LEN_DEVICE_NAME];
+        char fdName[LEN_DEVICE_NAME + 50];
+        struct AudioStreamBasicDescription streamDesc;
+
+        /***** Arts Specific ***/
+	artsdebug("info: requesting %s, %d channel sound at %d hz\n",
+            (param(direction) & directionWrite) ? "write" : "read", param(channels), param(samplingRate));
+
+        bytesPerSec = param(channels) * 2 * param(samplingRate);
+        gettimeofday(&start,0);
+	if (param(direction) & directionWrite) {
+            if(coreaudio_has_output_device)
+            {
+                arts_warning("AudioIOCoreAudio::open() called twice for writing!");
+                return true;
+            }
+                
+            /* HACK - create the file descriptor?  */
+            sprintf(fdName, "/tmp/audioiocoreaudio");
+            fopen(fdName, "w+");
+            audio_fd = ::open(fdName,  O_RDWR | O_NDELAY, 0);
+            /* Obtain a file descriptor for our "listening" socket */
+            if(audio_fd == -1)
+            {
+                arts_warning("file descriptor can't be created, %s\n", strerror(errno));
+                return false;
+            }
+            /***** End Arts Specific ***/
+            /*  Stuff from ESD... */
+            /********************** playback section ***************************/
+            /* get default output device */
+            propertySize = sizeof(gOutputDeviceID);
+            NotifyOnError(AudioHardwareGetProperty(kAudioHardwarePropertyDefaultOutputDevice,
+                                                &propertySize,
+                                                &gOutputDeviceID),
+                        "AudioHardwareGetProperty (Default Output Device)");
+            
+            arts_assert(gOutputDeviceID != kAudioDeviceUnknown);
+            
+            /* got default output device */
+            coreaudio_has_output_device = 1;
+        
+            /* get output device name */
+            propertySize = sizeof(char)*LEN_DEVICE_NAME;
+            NotifyOnError(AudioDeviceGetProperty(gOutputDeviceID,
+                                            1,
+                                            0,
+                                            kAudioDevicePropertyDeviceName,
+                                            &propertySize,
+                                            deviceName),
+                            "AudioDeviceGetProperty (Output Device Name)");
+        
+            /* get output format */
+            propertySize = sizeof(struct AudioStreamBasicDescription);
+            NotifyOnError(AudioDeviceGetProperty(gOutputDeviceID,
+                                            1,
+                                            0,
+                                            kAudioDevicePropertyStreamFormat,
+                                            &propertySize,
+                                            &streamDesc),
+                        "AudioDeviceGetProperty (Output StreamFormat)");
+                        
+            if ((streamDesc.mSampleRate != 44100.0) ||
+                (streamDesc.mFormatID != kAudioFormatLinearPCM) ||
+               !(streamDesc.mFormatFlags & kLinearPCMFormatFlagIsFloat) ||
+                (streamDesc.mChannelsPerFrame != 2))
+            {
+            	arts_warning("Unsupported output device format!\n");
+                return (-2);
+            }
+        
+            /* set buffer size */
+            bufferByteCount = BUF_SIZE * sizeof(float);
+            propertySize = sizeof(bufferByteCount);
+            NotifyOnError(AudioDeviceSetProperty(gOutputDeviceID,
+                                            0,
+                                            0,
+                                            0,
+                                            kAudioDevicePropertyBufferSize,
+                                            propertySize,
+                                            &bufferByteCount),
+                        "AudioDeviceSetProperty (Output BufferSize)");
+    
+            artsdebug("using device %s for output:\n", deviceName);
+            artsdebug("\twith sample rate %f, %ld channels and %ld-bit sample\n",
+                    streamDesc.mSampleRate,
+                    streamDesc.mChannelsPerFrame,
+                    streamDesc.mBitsPerChannel);
+        
+            arts_return_val_if_fail(pthread_mutex_init(&output.mutex, NULL) == 0, -1);
+            arts_return_val_if_fail(pthread_cond_init(&output.condition, NULL) == 0, -1);
+            
+            /* Registers PlaybackIOProc with the device without activating it. */
+            NotifyOnError(AudioDeviceAddIOProc(gOutputDeviceID, 
+                            (AudioDeviceIOProc) PlaybackIOProc, 
+                                                (void *)&output),
+                            "AudioDeviceAddIOProc (PlaybackIOProc)");
+	} else if (param(direction) & directionRead) {
+            /********************** record section ***************************/
+            if(coreaudio_has_input_device)
+            {
+                arts_warning("AudioIOCoreAudio::open() called twice for reading!");
+                return true;
+            }
+                
+            /* get default input device */
+            propertySize = sizeof(gInputDeviceID);
+            NotifyOnError(AudioHardwareGetProperty(kAudioHardwarePropertyDefaultInputDevice,
+                                                &propertySize,
+                                                &gInputDeviceID),
+                          "AudioHardwareGetProperty (Default Input Device)");
+
+            arts_assert(gInputDeviceID != kAudioDeviceUnknown);         
+            
+            /* got default input device */
+            coreaudio_has_input_device = 1;
+        
+            /* get input device name */
+            propertySize = sizeof(char)*64;
+            NotifyOnError(AudioDeviceGetProperty(gInputDeviceID,
+                                            1,
+                                            1,
+                                            kAudioDevicePropertyDeviceName,
+                                            &propertySize,
+                                            deviceName),
+                        "AudioDeviceGetProperty (Input Device Name)");
+
+            /* get input format */
+            propertySize = sizeof(struct AudioStreamBasicDescription);
+            NotifyOnError(AudioDeviceGetProperty(gInputDeviceID,
+                                            1,
+                                            1,
+                                            kAudioDevicePropertyStreamFormat,
+                                            &propertySize,
+                                            &streamDesc),
+                        "AudioDeviceGetProperty (Input Stream Size)");
+        
+            if ((streamDesc.mSampleRate != 44100.0) ||
+                (streamDesc.mFormatID != kAudioFormatLinearPCM) ||
+                !(streamDesc.mFormatFlags & kLinearPCMFormatFlagIsFloat) ||
+                (streamDesc.mChannelsPerFrame != 2))
+            {
+                artsdebug("Unsupported Input Device format.\n");
+                return (-2);
+            }
+        
+            /* set buffer size */
+            bufferByteCount = BUF_SIZE * sizeof(float);
+            propertySize = sizeof(bufferByteCount);
+            NotifyOnError(AudioDeviceSetProperty(gInputDeviceID,
+                                            0,
+                                            0,
+                                            1,
+                                            kAudioDevicePropertyBufferSize,
+                                            propertySize,
+                                            &bufferByteCount),
+                        "AudioDeviceSetProperty (input buffersize)");
+
+            artsdebug("using device %s for input:\n", deviceName);
+            artsdebug("\twith sample rate %f, %ld channels and %ld-bit sample\n",
+                    streamDesc.mSampleRate,
+                    streamDesc.mChannelsPerFrame,
+                    streamDesc.mBitsPerChannel);
+
+            arts_return_val_if_fail(pthread_mutex_init(&input.mutex, NULL) == 0, -1);
+            arts_return_val_if_fail(pthread_cond_init(&input.condition, NULL) == 0, -1);
+        
+            /* Registers PlaybackIOProc with the device without activating it. */
+            NotifyOnError(AudioDeviceAddIOProc(gInputDeviceID, 
+                                (AudioDeviceIOProc) RecordIOProc, 
+                                                (void *)&output),
+                            "AudioDeviceAddIOProc (RecordIOProc)");
+	} else {
+		arts_warning("something went horribly wrong, we're not reading or writing!!!!");
+		return false;
+	}                
+        
+	return true;
+}
+
+void AudioIOCoreAudio::setParam(AudioParam p, int& value) {
+	switch(p)
+	{
+		default:
+			param(p) = value;
+			break;
+	}
+}
+
+int AudioIOCoreAudio::getParam(AudioParam p) {
+	timeval now;
+	double delta;
+	int bytes;
+
+	switch(p)
+	{
+		case canRead:
+		case canWrite:
+			gettimeofday(&now,0);
+			delta = (double)now.tv_sec + (double)now.tv_usec/1000000.0;
+			delta -= (double)start.tv_sec + (double)start.tv_usec/1000000.0;
+			bytes = (int)( (delta * bytesPerSec) -  ((p == canRead)?input.numSamples:output.numSamples));
+               //         printf("%s %d bytes\n", ((p == canRead)?"canRead":"canWrite"), bytes);
+			return bytes;
+			break;
+
+		case autoDetect:
+			return 12; // so we're higher than liboss
+			break;
+                        
+		case selectReadFD:
+			return (param(direction) & directionRead)?audio_fd:-1;
+			break;
+
+		case selectWriteFD:
+			return (param(direction) & directionWrite)?audio_fd:-1;
+			break;
+                        
+		default:
+			return param(p);
+			break;
+	}
+}
+
+bool AudioIOCoreAudio::supportsFormat(AudioDeviceID device, AudioStreamBasicDescription *format) {
+
+	UInt32 formatSize;
+	OSStatus err;
+
+	formatSize = sizeof(*format);
+	err = AudioDeviceGetProperty(device, 0, false,
+		kAudioDevicePropertyStreamFormatSupported, &formatSize, format);
+	NotifyOnError(err, "supportsFormat");
+
+	if (err == noErr) {
+		return true;
+	} else {
+		return false;
+	}
+
+}
+
+/* Add __attribute__((unused)) to unused parameters when that gcc bug is fixed for OS X (3.4?)*/
+static OSStatus PlaybackIOProc(AudioDeviceID inDevice,
+			const AudioTimeStamp *inNow,
+			const AudioBufferList *inInputData,
+			const AudioTimeStamp *inInputTime,
+			AudioBufferList *outOutputData,
+			const AudioTimeStamp *inOutputTime,
+			audio_queue *inClientData)
+{
+  float *bufPtr = (float *) outOutputData->mBuffers[0].mData;
+  int i;
+
+  pthread_mutex_lock(&inClientData->mutex);
+
+  for (i = 0; i < inClientData->numSamples; i++)
+    bufPtr[i] = inClientData->dataBuf[i];
+  for ( ; i < BUF_SIZE; i++)
+    bufPtr[i] = 0;
+  inClientData->numSamples = 0;
+
+  pthread_mutex_unlock(&inClientData->mutex);
+  pthread_cond_signal(&inClientData->condition);
+
+  return (kAudioHardwareNoError);
+}
+
+/* Add __attribute__((unused)) to unused parameters when that gcc bug is fixed for OS X (3.4?)*/
+static OSStatus RecordIOProc(AudioDeviceID inDevice,
+		      const AudioTimeStamp *inNow,
+		      const AudioBufferList *inInputData,
+		      const AudioTimeStamp *inInputTime,
+		      AudioBufferList *outOutputData,
+		      const AudioTimeStamp *inOutputTime,
+		      audio_queue *inClientData)
+{
+  float *bufPtr = inInputData->mBuffers[0].mData;
+  int i;
+
+  pthread_mutex_lock(&inClientData->mutex);
+
+  for (i = 0; i < BUF_SIZE; i++)
+    inClientData->dataBuf[i] = bufPtr[i];
+  inClientData->numSamples = 0;
+
+  pthread_mutex_unlock(&inClientData->mutex);
+  pthread_cond_signal(&inClientData->condition);
+
+  return (kAudioHardwareNoError);
+}
+
+/* Utility */
+
+bool NotifyOnError (OSStatus inRetVal, const char * inStringDesc) {
+	if (inRetVal == noErr) {
+		return true;
+	} else {
+		switch(inRetVal) {
+			case kAudioHardwareNoError:
+				break;
+			case kAudioHardwareNotRunningError:
+				arts_warning("error: hardware not running in %s", inStringDesc);
+				break;
+			case kAudioHardwareUnspecifiedError:
+				arts_warning("error: unspecified error in %s", inStringDesc);
+				break;
+			case kAudioHardwareUnknownPropertyError:
+				arts_warning("error: unknown property in %s", inStringDesc);
+				break;
+			case kAudioHardwareBadPropertySizeError:
+				arts_warning("error: bad property size in %s", inStringDesc);
+				break;
+			case kAudioHardwareIllegalOperationError:
+				arts_warning("error: illegal operation in %s", inStringDesc);
+				break;
+			case kAudioHardwareBadDeviceError:
+				arts_warning("error: bad device in %s", inStringDesc);
+				break;
+			case kAudioHardwareBadStreamError:
+				arts_warning("error: bad stream in %s", inStringDesc);
+				break;
+			case kAudioDeviceUnsupportedFormatError:
+				arts_warning("error: unsupported format in %s", inStringDesc);
+				break;
+			case kAudioDevicePermissionsError:
+				arts_warning("error: bad device permissions in %s", inStringDesc);
+				break;
+			default:
+				arts_warning("error: unknown CoreAudio error in %s", inStringDesc);
+				break;
+		}
+			
+		arts_warning("  system: 0x%d", err_get_system(inRetVal));
+		arts_warning("  sub:    0x%d", err_get_sub(inRetVal));
+		arts_warning("  code:   0x%d", err_get_code(inRetVal));
+		return false;
+	}
+}
+
+void ExitOnError (OSStatus inRetVal, const char * inStringDesc) {
+	if ( NotifyOnError (inRetVal, inStringDesc) ) {
+		exit(1);
+	}
+}
diff -uNbr arts-1.1.0/flow/gsl/Makefile.am arts-1.1.0-new/flow/gsl/Makefile.am
--- arts-1.1.0/flow/gsl/Makefile.am	Mon Aug  5 13:58:31 2002
+++ arts-1.1.0-new/flow/gsl/Makefile.am	Sat Dec 14 17:46:11 2002
@@ -1,4 +1,3 @@
-
 EXTRA_DIST =
 CLEANFILES =
 MAINTAINERCLEANFILES =
@@ -15,11 +14,11 @@
 
 libgsl_la_SOURCES = $(GSL_C_SRC) gslglib.c gslglibhash.cc gslartsthreads.cc gslfilehash.c
 libgsl_la_LIBADD = $(top_builddir)/mcop/libmcop.la -lm $(LIBPOSIX4) $(GSL_LIBS) $(LIB_POLL)
-libgsl_la_LDFLAGS = -no-undefined
+libgsl_la_LDFLAGS = -no-undefined -version-info 1:7
 
 noinst_PROGRAMS = $(GSL_NOINST_PROGS)
 
-GSL_progs_ldadd = libgsl.la
+GSL_progs_ldadd = libgsl.la $(LIB_POLL)
 GSL_cc_dummy = dummy.cc
 $(srcdir)/dummy.cc: gslconfig.h
 
diff -uNbr arts-1.1.0/flow/gsl/gsldatahandle-mad.c arts-1.1.0-new/flow/gsl/gsldatahandle-mad.c
--- arts-1.1.0/flow/gsl/gsldatahandle-mad.c	Tue Jul 30 16:05:52 2002
+++ arts-1.1.0-new/flow/gsl/gsldatahandle-mad.c	Sat Dec 14 17:46:11 2002
@@ -31,6 +31,10 @@
 #include <string.h>
 #include <errno.h>
 
+#ifndef EBADFD
+#define EBADFD 77
+#endif
+
 #if	GSL_HAVE_LIBMAD
 #include <mad.h>
 
diff -uNbr arts-1.1.0/libltdl/ltdl.c arts-1.1.0-new/libltdl/ltdl.c
--- arts-1.1.0/libltdl/ltdl.c	Mon Aug  5 13:58:39 2002
+++ arts-1.1.0-new/libltdl/ltdl.c	Sat Dec 14 17:46:11 2002
@@ -1544,11 +1544,14 @@
   /* try to open the old library first; if it was dlpreopened,
      we want the preopened version of it, even if a dlopenable
      module is available */
+/*	HACKALERT: Why? Mac OS/Darwin can't open static libs, it is
+	a waste to even try. Disabled for kde.	*/
+#if 0
   if (old_name && tryall_dlopen(handle, old_name) == 0)
     {
       return 0;
     }
-
+#endif
   /* try to open the dynamic library */
   if (dlname)
     {
@@ -1567,6 +1570,28 @@
 	    }
 
 	  sprintf (filename, "%s/%s", libdir, dlname);
+	  error = (tryall_dlopen (handle, filename) != 0);
+	  LT_DLFREE (filename);
+
+	  if (!error)
+	    {
+	      return 0;
+	    }
+	}
+
+      /* then look for the same module, but with "lib" prepended */
+      if (installed && libdir)
+	{
+	  len	    = strlen (libdir) + 4 + strlen (dlname);
+	  filename  = LT_DLMALLOC (char, 1+ len);
+
+	  if (!filename)
+	    {
+	      MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
+	      return 1;
+	    }
+
+	  sprintf (filename, "%s/%s%s", libdir, "lib", dlname);
 	  error = (tryall_dlopen (handle, filename) != 0);
 	  LT_DLFREE (filename);
 
diff -uNbr arts-1.1.0/libltdl/ltdl.m4 arts-1.1.0-new/libltdl/ltdl.m4
--- arts-1.1.0/libltdl/ltdl.m4	Mon Aug  5 13:58:39 2002
+++ arts-1.1.0-new/libltdl/ltdl.m4	Sat Dec 14 17:46:11 2002
@@ -103,6 +103,9 @@
 	osf*)
 	  libltdl_cv_sys_dlopen_deplibs=yes
 	  ;;
+	darwin*)
+	  libltdl_cv_sys_dlopen_deplibs=yes
+	  ;;
 	esac
 ])
 if test "$libltdl_cv_sys_dlopen_deplibs" != yes; then
diff -uNbr arts-1.1.0/mcop/Makefile.am arts-1.1.0-new/mcop/Makefile.am
--- arts-1.1.0/mcop/Makefile.am	Mon Aug  5 13:58:39 2002
+++ arts-1.1.0-new/mcop/Makefile.am	Sat Dec 14 17:46:11 2002
@@ -17,7 +17,7 @@
 	 delayedreturn.cc thread.cc dynamicskeleton.cc
 
 libmcop_la_LIBADD = $(LIBSOCKET) $(top_builddir)/libltdl/libltdlc.la
-libmcop_la_LDFLAGS = -no-undefined -version-info 1:0
+libmcop_la_LDFLAGS = -no-undefined -version-info 1:7
 
 artsincludedir = $(includedir)/arts
 artsinclude_HEADERS = buffer.h common.h connection.h core.h dispatcher.h \
diff -uNbr arts-1.1.0/mcop_mt/Makefile.am arts-1.1.0-new/mcop_mt/Makefile.am
--- arts-1.1.0/mcop_mt/Makefile.am	Mon Aug  5 13:58:39 2002
+++ arts-1.1.0-new/mcop_mt/Makefile.am	Sat Dec 14 17:46:11 2002
@@ -4,4 +4,4 @@
 
 libmcop_mt_la_SOURCES = threads_posix.cc
 libmcop_mt_la_LIBADD = $(top_builddir)/mcop/libmcop.la $(LIBPTHREAD) $(LIBPOSIX4)
-libmcop_mt_la_LDFLAGS = -no-undefined -version-info 1:0 $(USE_THREADS) 
+libmcop_mt_la_LDFLAGS = -no-undefined -version-info 1:7 $(USE_THREADS) 
diff -uNbr arts-1.1.0/mcopidl/Makefile.am arts-1.1.0-new/mcopidl/Makefile.am
--- arts-1.1.0/mcopidl/Makefile.am	Mon Aug  5 13:58:39 2002
+++ arts-1.1.0-new/mcopidl/Makefile.am	Sat Dec 14 17:46:11 2002
@@ -1,4 +1,3 @@
-KDE_CXXFLAGS = $(NOOPT_CXXFLAGS) 
 INCLUDES = -I$(top_srcdir)/mcop $(all_includes)
 ####### Files
 
diff -uNbr arts-1.1.0/qtmcop/Makefile.am arts-1.1.0-new/qtmcop/Makefile.am
--- arts-1.1.0/qtmcop/Makefile.am	Wed Feb 13 15:54:53 2002
+++ arts-1.1.0-new/qtmcop/Makefile.am	Sat Dec 14 17:46:11 2002
@@ -5,7 +5,7 @@
 
 libqtmcop_la_SOURCES = qiomanager.cc
 libqtmcop_la_LIBADD = $(top_builddir)/mcop/libmcop.la $(LIB_QT)
-libqtmcop_la_LDFLAGS = -no-undefined -version-info 1:0 $(KDE_RPATH) $(KDE_MT_LDFLAGS) $(QT_LDFLAGS) \
+libqtmcop_la_LDFLAGS = -no-undefined -version-info 1:7 $(KDE_RPATH) $(KDE_MT_LDFLAGS) $(QT_LDFLAGS) \
   $(X_LDFLAGS) $(USER_LDFLAGS)
 
 METASOURCES = qiomanager_p.moc
diff -uNbr arts-1.1.0/soundserver/Makefile.am arts-1.1.0-new/soundserver/Makefile.am
--- arts-1.1.0/soundserver/Makefile.am	Mon Aug  5 13:58:39 2002
+++ arts-1.1.0-new/soundserver/Makefile.am	Sat Dec 14 17:46:11 2002
@@ -19,26 +19,29 @@
 lib_LTLIBRARIES = libkmedia2_idl.la libsoundserver_idl.la \
 	libartsgslplayobject.la libartswavplayobject.la libkmedia2.la
 
-libsoundserver_idl_la_LIBADD = libkmedia2_idl.la \
-                          $(top_builddir)/flow/libartsflow_idl.la
-libsoundserver_idl_la_LDFLAGS = -no-undefined -version-info 1:0
+libsoundserver_idl_la_LIBADD = libkmedia2_idl.la $(top_builddir)/x11/libx11globalcomm.la \
+                          $(top_builddir)/flow/libartsflow_idl.la $(top_builddir)/mcop/libmcop.la
+libsoundserver_idl_la_LDFLAGS = -no-undefined -version-info 1:7
 libsoundserver_idl_la_SOURCES = soundserver.cc
 libsoundserver_idl_la_COMPILE_FIRST = soundserver.h
 
 libkmedia2_idl_la_SOURCES = kmedia2.cc
 libkmedia2_idl_la_COMPILE_FIRST = kmedia2.h
-libkmedia2_idl_la_LIBADD  = $(top_builddir)/flow/libartsflow.la
-libkmedia2_idl_la_LDFLAGS = -no-undefined -version-info 1:0
+libkmedia2_idl_la_LIBADD  = $(top_builddir)/flow/libartsflow.la $(top_builddir)/mcop/libmcop.la \
+	$(top_builddir)/x11/libx11globalcomm.la $(top_builddir)/flow/libartsflow_idl.la
+libkmedia2_idl_la_LDFLAGS = -no-undefined -version-info 1:7
 
 libkmedia2_la_SOURCES = fileinputstream_impl.cc stdoutwriter_impl.cc
-libkmedia2_la_LIBADD  = libkmedia2_idl.la $(FLOWLIBS)
-libkmedia2_la_LDFLAGS = -no-undefined -version-info 1:0
+libkmedia2_la_LIBADD  = libkmedia2_idl.la $(FLOWLIBS) $(top_builddir)/flow/libartsflow_idl.la \
+	$(top_builddir)/mcop/libmcop.la $(top_builddir)/x11/libx11globalcomm.la
+libkmedia2_la_LDFLAGS = -no-undefined -version-info 1:7
 libkmedia2_la_COMPILE_FIRST = kmedia2.h ../flow/artsflow.h
 
 libartswavplayobject_la_SOURCES = wavplayobject_impl.cc
-libartswavplayobject_la_LIBADD  = $(top_builddir)/mcop/libmcop.la \
-                                  libsoundserver_idl.la $(FLOWLIBS)
-libartswavplayobject_la_LDFLAGS = -no-undefined -module
+libartswavplayobject_la_LIBADD  = $(top_builddir)/mcop/libmcop.la $(top_builddir)/x11/libx11globalcomm.la \
+                                  libsoundserver_idl.la $(FLOWLIBS) $(top_builddir)/flow/libartsflow_idl.la \
+				  libkmedia2_idl.la
+libartswavplayobject_la_LDFLAGS = -no-undefined -version-info 1:7 -module
 libartswavplayobject_la_COMPILE_FIRST = soundserver.h ../flow/artsflow.h
 
 libartsgslplayobject_la_SOURCES = gslplayobject_impl.cc
diff -uNbr arts-1.1.0/soundserver/artsd.cc arts-1.1.0-new/soundserver/artsd.cc
--- arts-1.1.0/soundserver/artsd.cc	Mon Aug  5 13:58:39 2002
+++ arts-1.1.0-new/soundserver/artsd.cc	Sat Dec 14 17:46:11 2002
@@ -35,6 +35,13 @@
 #include "debug.h"
 #include "artsversion.h"
 
+#ifdef MACOSX
+  #include <mach/mach.h>
+  #include <mach/thread_policy.h>
+  #include <sys/param.h>
+  #include <sys/sysctl.h>
+#endif
+
 using namespace std;
 using namespace Arts;
 
@@ -232,6 +239,29 @@
 	cerr << endl;
 }
 
+#ifdef MACOSX
+static void macosx_get_realtime_priority()
+{
+	struct thread_time_constraint_policy ttcpolicy;
+	int bus_speed, mib [2] = { CTL_HW, HW_BUS_FREQ };
+	size_t len;   
+
+	len = sizeof (bus_speed);
+	sysctl (mib, 2, &bus_speed, &len, NULL, 0);
+
+	/* Is it enough? */
+	ttcpolicy.period = bus_speed / 120;
+	ttcpolicy.computation = bus_speed / 2400;
+	ttcpolicy.constraint = bus_speed / 1200;
+	ttcpolicy.preemptible = 1;
+
+	thread_policy_set (mach_thread_self (),
+			   THREAD_TIME_CONSTRAINT_POLICY,
+			   (int*)&ttcpolicy,
+			   THREAD_TIME_CONSTRAINT_POLICY_COUNT);
+}
+#endif
+
 int main(int argc, char **argv)
 {
 	handleArgs(argc, argv);
@@ -244,7 +274,9 @@
 
 	if(cfgPort)			 TCPServer::setPort(cfgPort);
 
+#ifndef ARTS_NO_ALARM
 	CPUUsage	cpuUsage;
+#endif
 	Dispatcher	dispatcher(0,cfgServers);
 
 	initSignals();
@@ -298,6 +330,10 @@
 		cleanUnusedReferences();
 		if(!publishReferences(server,audioManager,false)) return 1;
 	}
+
+#ifdef MACOSX
+	macosx_get_realtime_priority();
+#endif
 
 	/* warn if there was a problem with artswrapper */
 	char *wrapper = getenv("STARTED_THROUGH_ARTSWRAPPER");
diff -uNbr arts-1.1.0/soundserver/soundserverv2_impl.cc arts-1.1.0-new/soundserver/soundserverv2_impl.cc
--- arts-1.1.0/soundserver/soundserverv2_impl.cc	Sat Mar  9 08:56:13 2002
+++ arts-1.1.0-new/soundserver/soundserverv2_impl.cc	Sat Dec 14 17:46:11 2002
@@ -374,9 +374,12 @@
 
 float SoundServerV2_impl::cpuUsage()
 {
+#ifndef ARTS_NO_ALARM
 	return CPUUsage::the()->usage() * 100.0;
+#else
+	return 5.0;
+#endif
 }
-
 
 #ifndef __SUNPRO_CC
 /* See bottom of simplesoundserver_impl.cc for the reason this is here.  */
diff -uNbr arts-1.1.0/x11/Makefile.am arts-1.1.0-new/x11/Makefile.am
--- arts-1.1.0/x11/Makefile.am	Mon Aug  5 13:58:40 2002
+++ arts-1.1.0-new/x11/Makefile.am	Sat Dec 14 17:46:11 2002
@@ -4,7 +4,7 @@
 
 libx11globalcomm_la_SOURCES = x11globalcomm.cc x11globalcomm_impl.cc
 libx11globalcomm_la_LIBADD = $(top_builddir)/mcop/libmcop.la $(LIB_X11)
-libx11globalcomm_la_LDFLAGS = -no-undefined -module -version-info 1:0 $(X_LDFLAGS)
+libx11globalcomm_la_LDFLAGS = -no-undefined -module -version-info 1:7 $(X_LDFLAGS)
 
 DISTCLEANFILES = x11globalcomm.cc x11globalcomm.h \
                  x11globalcomm.mcoptype x11globalcomm.mcopclass
