Index: src/bin/mksh/Build.sh
diff -u src/bin/mksh/Build.sh:1.443 src/bin/mksh/Build.sh:1.477
--- src/bin/mksh/Build.sh:1.443	Tue Feb 23 22:02:35 2010
+++ src/bin/mksh/Build.sh	Sat Apr  9 21:00:58 2011
@@ -1,7 +1,7 @@
 #!/bin/sh
-srcversion='$MirOS: src/bin/mksh/Build.sh,v 1.443 2010/02/23 22:02:35 tg Exp $'
+srcversion='$MirOS: src/bin/mksh/Build.sh,v 1.477 2011/04/09 21:00:58 tg Exp $'
 #-
-# Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+# Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
 #	Thorsten Glaser <tg@mirbsd.org>
 #
 # Provided that these terms and disclaimer and all copyright notices
@@ -28,7 +28,10 @@
 # CPPFLAGS recognised:	MKSH_ASSUME_UTF8 MKSH_BINSHREDUCED MKSH_CLS_STRING
 #			MKSH_CONSERVATIVE_FDS MKSH_MIDNIGHTBSD01ASH_COMPAT
 #			MKSH_NOPWNAM MKSH_NO_LIMITS MKSH_SMALL MKSH_S_NOVI
-#			MKSH_UNEMPLOYED
+#			MKSH_UNEMPLOYED MKSH_DEFAULT_EXECSHELL MKSHRC_PATH
+#			MKSH_DEFAULT_TMPDIR MKSH_CLRTOEOL_STRING MKSH_A4PB
+#			MKSH_NO_DEPRECATED_WARNING MKSH_DONT_EMIT_IDSTRING
+#			MKSH_NOPROSPECTOFWORK
 
 LC_ALL=C
 export LC_ALL
@@ -176,9 +179,9 @@
 		test $ct = gcc && vscan='unrecogni[sz]ed'
 		test $ct = hpcc && vscan='unsupported'
 		test $ct = pcc && vscan='unsupported'
-		test $ct = sunpro && vscan='ignored'
+		test $ct = sunpro && vscan='-e ignored -e turned.off'
 	fi
-	test -n "$vscan" && grep "$vscan" vv.out >/dev/null 2>&1 && fv=$fr
+	test -n "$vscan" && grep $vscan vv.out >/dev/null 2>&1 && fv=$fr
 	rmf conftest.c conftest.o ${tcfn}* vv.out
 	ac_testdone
 }
@@ -282,54 +285,95 @@
 	echo "$me: Error: ./mksh is a directory!" >&2
 	exit 1
 fi
-rmf a.exe* a.out* conftest.c *core lft mksh* no *.o \
-    signames.inc stdint.h test.sh x vv.out
+rmf a.exe* a.out* conftest.c *core lft mksh* no *.bc *.ll *.o \
+    Rebuild.sh signames.inc test.sh x vv.out
 
 curdir=`pwd` srcdir=`dirname "$0"` check_categories=
+test -n "$dirname" || dirname=.
+dstversion=`sed -n '/define MKSH_VERSION/s/^.*"\(.*\)".*$/\1/p' $srcdir/sh.h`
 
 e=echo
 r=0
 eq=0
 pm=0
 cm=normal
-llvm=
+optflags=-std-compile-opts
+last=
 
 for i
 do
-	case $i in
-	-j)
-		pm=1
+	case $last:$i in
+	c:combine|c:dragonegg|c:llvm)
+		cm=$i
+		last=
+		;;
+	c:*)
+		echo "$me: Unknown option -c '$i'!" >&2
+		exit 1
 		;;
-	-combine)
+	o:*)
+		optflags=$i
+		last=
+		;;
+	:-c)
+		last=c
+		;;
+	:-combine)
 		cm=combine
+		echo "$me: Warning: '$i' is deprecated, use '-c combine' instead!" >&2
 		;;
-	-llvm)
+	:-g)
+		# checker, debug, valgrind build
+		CPPFLAGS="$CPPFLAGS -DDEBUG"
+		CFLAGS="$CFLAGS -g3 -fno-builtin"
+		;;
+	:-j)
+		pm=1
+		;;
+	:-llvm)
 		cm=llvm
-		llvm=-std-compile-opts
+		optflags=-std-compile-opts
+		echo "$me: Warning: '$i' is deprecated, use '-c llvm -O' instead!" >&2
 		;;
-	-llvm=*)
+	:-llvm=*)
 		cm=llvm
-		llvm=`echo "x$i" | sed 's/^x-llvm=//'`
+		optflags=`echo "x$i" | sed 's/^x-llvm=//'`
+		echo "$me: Warning: '$i' is deprecated, use '-c llvm -o $llvm' instead!" >&2
 		;;
-	-M)
+	:-M)
 		cm=makefile
 		;;
-	-Q)
+	:-O)
+		optflags=-std-compile-opts
+		;;
+	:-o)
+		last=o
+		;;
+	:-Q)
 		eq=1
 		;;
-	-r)
+	:-r)
 		r=1
 		;;
-	-valgrind)
-		CPPFLAGS="$CPPFLAGS -DDEBUG"
-		CFLAGS="$CFLAGS -g3 -fno-builtin"
+	:-v)
+		echo "Build.sh $srcversion"
+		echo "for mksh $dstversion"
+		exit 0
 		;;
-	*)
+	:*)
 		echo "$me: Unknown option '$i'!" >&2
 		exit 1
 		;;
+	*)
+		echo "$me: Unknown option -'$last' '$i'!" >&2
+		exit 1
+		;;
 	esac
 done
+if test -n "$last"; then
+	echo "$me: Option -'$last' not followed by argument!" >&2
+	exit 1
+fi
 
 SRCS="lalloc.c edit.c eval.c exec.c expr.c funcs.c histrap.c"
 SRCS="$SRCS jobs.c lex.c main.c misc.c shf.c syn.c tree.c var.c"
@@ -347,6 +391,12 @@
 tsts=
 ccpr='|| for _f in ${tcfn}*; do test x"${_f}" = x"mksh.1" || rm -f "${_f}"; done'
 
+# Evil hack
+if test x"$TARGET_OS" = x"Android"; then
+	check_categories="$check_categories android"
+	TARGET_OS=Linux
+fi
+
 # Configuration depending on OS revision, on OSes that need them
 case $TARGET_OS in
 QNX)
@@ -360,7 +410,7 @@
 	CPPFLAGS="$CPPFLAGS -D_ALL_SOURCE"
 	: ${HAVE_SETLOCALE_CTYPE=0}
 	;;
-BeOS|Haiku)
+BeOS)
 	oswarn=' and will currently not work'
 	;;
 BSD/OS)
@@ -375,6 +425,11 @@
 	;;
 FreeBSD)
 	;;
+FreeMiNT)
+	oswarn="; it has minor issues"
+	CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE"
+	: ${HAVE_SETLOCALE_CTYPE=0}
+	;;
 GNU)
 	# define NO_PATH_MAX to use Hurd-only functions
 	CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE -DNO_PATH_MAX"
@@ -382,6 +437,9 @@
 GNU/kFreeBSD)
 	CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE"
 	;;
+Haiku)
+	CPPFLAGS="$CPPFLAGS -DMKSH_ASSUME_UTF8"
+	;;
 HP-UX)
 	;;
 Interix)
@@ -395,7 +453,7 @@
 	: ${HAVE_SETLOCALE_CTYPE=0}
 	;;
 Linux)
-	CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE"
+	CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE -DSETUID_CAN_FAIL_WITH_EAGAIN"
 	: ${HAVE_REVOKE=0}
 	;;
 MidnightBSD)
@@ -408,6 +466,10 @@
 	;;
 MirBSD)
 	;;
+MSYS_*)
+	# probably same as CYGWIN* – need to test; from RT|Chatzilla
+	oswarn='but will probably work'
+	;;
 NetBSD)
 	;;
 OpenBSD)
@@ -464,12 +526,13 @@
 	;;
 esac
 
+: ${HAVE_MKNOD=0}
+
 : ${CC=cc} ${NROFF=nroff}
 test 0 = $r && echo | $NROFF -v 2>&1 | grep GNU >/dev/null 2>&1 && \
     NROFF="$NROFF -c"
 
 # this aids me in tracing FTBFSen without access to the buildd
-dstversion=`sed -n '/define MKSH_VERSION/s/^.*"\(.*\)".*$/\1/p' $srcdir/sh.h`
 $e "Hi from$ao $bi$srcversion$ao on:"
 case $TARGET_OS in
 Darwin)
@@ -698,7 +761,11 @@
 	ct=unknown
 	;;
 esac
-test $cm = llvm && vv '|' "llc -version"
+case $cm in
+dragonegg|llvm)
+	vv '|' "llc -version"
+	;;
+esac
 $e "$bi==> which compiler seems to be used...$ao $ui$ct$ao"
 rmf conftest.c conftest.o conftest a.out* a.exe* vv.out
 
@@ -894,7 +961,7 @@
 #
 # Compiler: check for stuff that only generates warnings
 #
-ac_test attribute_bounded '' 'for __attribute__((bounded))' <<-'EOF'
+ac_test attribute_bounded '' 'for __attribute__((__bounded__))' <<-'EOF'
 	#if defined(__GNUC__) && (__GNUC__ < 2)
 	/* force a failure: gcc 1.42 has a false positive here */
 	int main(void) { return (thiswillneverbedefinedIhope()); }
@@ -902,68 +969,69 @@
 	#include <string.h>
 	#undef __attribute__
 	int xcopy(const void *, void *, size_t)
-	    __attribute__((bounded (buffer, 1, 3)))
-	    __attribute__((bounded (buffer, 2, 3)));
+	    __attribute__((__bounded__ (__buffer__, 1, 3)))
+	    __attribute__((__bounded__ (__buffer__, 2, 3)));
 	int main(int ac, char *av[]) { return (xcopy(av[0], av[--ac], 1)); }
 	int xcopy(const void *s, void *d, size_t n) {
 		memmove(d, s, n); return ((int)n);
 	}
 	#endif
 EOF
-ac_test attribute_format '' 'for __attribute__((format))' <<-'EOF'
+ac_test attribute_format '' 'for __attribute__((__format__))' <<-'EOF'
 	#if defined(__GNUC__) && (__GNUC__ < 2)
 	/* force a failure: gcc 1.42 has a false positive here */
 	int main(void) { return (thiswillneverbedefinedIhope()); }
 	#else
+	#define fprintf printfoo
 	#include <stdio.h>
 	#undef __attribute__
-	#undef printf
-	extern int printf(const char *format, ...)
-	    __attribute__((format (printf, 1, 2)));
-	int main(int ac, char **av) { return (printf("%s%d", *av, ac)); }
+	#undef fprintf
+	extern int fprintf(FILE *, const char *format, ...)
+	    __attribute__((__format__ (__printf__, 2, 3)));
+	int main(int ac, char **av) { return (fprintf(stderr, "%s%d", *av, ac)); }
 	#endif
 EOF
-ac_test attribute_nonnull '' 'for __attribute__((nonnull))' <<-'EOF'
+ac_test attribute_nonnull '' 'for __attribute__((__nonnull__))' <<-'EOF'
 	#if defined(__GNUC__) && (__GNUC__ < 2)
 	/* force a failure: gcc 1.42 has a false positive here */
 	int main(void) { return (thiswillneverbedefinedIhope()); }
 	#else
-	int foo(char *s1, char *s2) __attribute__((nonnull));
-	int bar(char *s1, char *s2) __attribute__((nonnull (1, 2)));
-	int baz(char *s) __attribute__((nonnull (1)));
+	int foo(char *s1, char *s2) __attribute__((__nonnull__));
+	int bar(char *s1, char *s2) __attribute__((__nonnull__ (1, 2)));
+	int baz(char *s) __attribute__((__nonnull__ (1)));
 	int foo(char *s1, char *s2) { return (bar(s2, s1)); }
 	int bar(char *s1, char *s2) { return (baz(s1) - baz(s2)); }
 	int baz(char *s) { return (*s); }
 	int main(int ac, char **av) { return (ac == foo(av[0], av[ac-1])); }
 	#endif
 EOF
-ac_test attribute_noreturn '' 'for __attribute__((noreturn))' <<-'EOF'
+ac_test attribute_noreturn '' 'for __attribute__((__noreturn__))' <<-'EOF'
 	#if defined(__GNUC__) && (__GNUC__ < 2)
 	/* force a failure: gcc 1.42 has a false positive here */
 	int main(void) { return (thiswillneverbedefinedIhope()); }
 	#else
 	#include <stdlib.h>
 	#undef __attribute__
-	void fnord(void) __attribute__((noreturn));
+	void fnord(void) __attribute__((__noreturn__));
 	int main(void) { fnord(); }
 	void fnord(void) { exit(0); }
 	#endif
 EOF
-ac_test attribute_unused '' 'for __attribute__((unused))' <<-'EOF'
+ac_test attribute_unused '' 'for __attribute__((__unused__))' <<-'EOF'
 	#if defined(__GNUC__) && (__GNUC__ < 2)
 	/* force a failure: gcc 1.42 has a false positive here */
 	int main(void) { return (thiswillneverbedefinedIhope()); }
 	#else
-	int main(int ac __attribute__((unused)), char **av
-	    __attribute__((unused))) { return (0); }
+	int main(int ac __attribute__((__unused__)), char **av
+	    __attribute__((__unused__))) { return (0); }
 	#endif
 EOF
-ac_test attribute_used '' 'for __attribute__((used))' <<-'EOF'
+ac_test attribute_used '' 'for __attribute__((__used__))' <<-'EOF'
 	#if defined(__GNUC__) && (__GNUC__ < 2)
 	/* force a failure: gcc 1.42 has a false positive here */
 	int main(void) { return (thiswillneverbedefinedIhope()); }
 	#else
-	static const char fnord[] __attribute__((used)) = "42";
+	static const char fnord[] __attribute__((__used__)) = "42";
 	int main(void) { return (0); }
 	#endif
 EOF
@@ -995,58 +1063,47 @@
 		;;
 	esac
 
-	: ${HAVE_MKNOD=0}
-	: ${HAVE_REVOKE=0}
+	: ${HAVE_NICE=0}
 	: ${HAVE_PERSISTENT_HISTORY=0}
-	check_categories=$check_categories,smksh
+	check_categories="$check_categories smksh"
 	HAVE_ISSET_MKSH_CONSERVATIVE_FDS=1	# from sh.h
 fi
 ac_ifcpp 'ifdef MKSH_BINSHREDUCED' isset_MKSH_BINSHREDUCED '' \
     "if a reduced-feature sh is requested" && \
-    check_categories=$check_categories,binsh
+    check_categories="$check_categories binsh"
 ac_ifcpp 'ifdef MKSH_UNEMPLOYED' isset_MKSH_UNEMPLOYED '' \
     "if mksh will be built without job control" && \
-    check_categories=$check_categories,arge
+    check_categories="$check_categories arge"
+ac_ifcpp 'ifdef MKSH_NOPROSPECTOFWORK' isset_MKSH_NOPROSPECTOFWORK '' \
+    "if mksh will be built without job signals" && \
+    check_categories="$check_categories arge nojsig"
 ac_ifcpp 'ifdef MKSH_ASSUME_UTF8' isset_MKSH_ASSUME_UTF8 '' \
     'if the default UTF-8 mode is specified' && : ${HAVE_SETLOCALE_CTYPE=0}
 ac_ifcpp 'ifdef MKSH_CONSERVATIVE_FDS' isset_MKSH_CONSERVATIVE_FDS '' \
     'if traditional/conservative fd use is requested' && \
-    check_categories=$check_categories,convfds
+    check_categories="$check_categories convfds"
 
 #
 # Environment: headers
 #
-ac_header sys/param.h
+ac_header sys/bsdtypes.h
+ac_header sys/file.h sys/types.h
 ac_header sys/mkdev.h sys/types.h
 ac_header sys/mman.h sys/types.h
+ac_header sys/param.h
+ac_header sys/select.h sys/types.h
 ac_header sys/sysmacros.h
+ac_header bstring.h
+ac_header grp.h sys/types.h
 ac_header libgen.h
 ac_header libutil.h sys/types.h
 ac_header paths.h
-ac_header stdbool.h
-ac_header strings.h sys/types.h
-ac_header grp.h sys/types.h
+ac_header stdint.h stdarg.h
+# include strings.h only if compatible with string.h
+ac_header strings.h sys/types.h string.h
 ac_header ulimit.h sys/types.h
 ac_header values.h
 
-ac_header '!' stdint.h stdarg.h
-ac_testn can_inttypes '!' stdint_h 1 "for standard 32-bit integer types" <<-'EOF'
-	#include <sys/types.h>
-	int main(int ac, char **av) { return ((uint32_t)*av + (int32_t)ac); }
-EOF
-ac_testn can_ucbints '!' can_inttypes 1 "for UCB 32-bit integer types" <<-'EOF'
-	#include <sys/types.h>
-	int main(int ac, char **av) { return ((u_int32_t)*av + (int32_t)ac); }
-EOF
-case $HAVE_CAN_INTTYPES$HAVE_CAN_UCBINTS in
-01)	HAVE_U_INT32_T=1
-	echo 'typedef u_int32_t uint32_t;' >>stdint.h ;;
-00)	echo 'typedef signed int int32_t;' >>stdint.h
-	echo 'typedef unsigned int uint32_t;' >>stdint.h ;;
-esac
-test -f stdint.h && HAVE_STDINT_H=1
-ac_cppflags STDINT_H
-
 #
 # Environment: definitions
 #
@@ -1070,6 +1127,27 @@
 #
 # Environment: types
 #
+ac_test can_inttypes '!' stdint_h 1 "for standard 32-bit integer types" <<-'EOF'
+	#include <sys/types.h>
+	#include <stddef.h>
+	int main(int ac, char **av) { return ((uint32_t)(ptrdiff_t)*av + (int32_t)ac); }
+EOF
+ac_test can_ucbints '!' can_inttypes 1 "for UCB 32-bit integer types" <<-'EOF'
+	#include <sys/types.h>
+	#include <stddef.h>
+	int main(int ac, char **av) { return ((u_int32_t)(ptrdiff_t)*av + (int32_t)ac); }
+EOF
+ac_test can_int8type '!' stdint_h 1 "for standard 8-bit integer type" <<-'EOF'
+	#include <sys/types.h>
+	#include <stddef.h>
+	int main(int ac, char **av) { return ((uint8_t)(ptrdiff_t)av[ac]); }
+EOF
+ac_test can_ucbint8 '!' can_int8type 1 "for UCB 8-bit integer type" <<-'EOF'
+	#include <sys/types.h>
+	#include <stddef.h>
+	int main(int ac, char **av) { return ((u_int8_t)(ptrdiff_t)av[ac]); }
+EOF
+
 ac_test rlim_t <<-'EOF'
 	#include <sys/types.h>
 	#include <sys/time.h>
@@ -1083,14 +1161,14 @@
 	#include <sys/types.h>
 	#include <signal.h>
 	#include <stddef.h>
-	int main(void) { return ((int)(ptrdiff_t)(sig_t)kill(0,0)); }
+	int main(void) { return ((int)(ptrdiff_t)(sig_t)(ptrdiff_t)kill(0,0)); }
 EOF
 
 ac_testn sighandler_t '!' sig_t 0 <<-'EOF'
 	#include <sys/types.h>
 	#include <signal.h>
 	#include <stddef.h>
-	int main(void) { return ((int)(ptrdiff_t)(sighandler_t)kill(0,0)); }
+	int main(void) { return ((int)(ptrdiff_t)(sighandler_t)(ptrdiff_t)kill(0,0)); }
 EOF
 if test 1 = $HAVE_SIGHANDLER_T; then
 	CPPFLAGS="$CPPFLAGS -Dsig_t=sighandler_t"
@@ -1101,7 +1179,7 @@
 	#include <sys/types.h>
 	#include <signal.h>
 	#include <stddef.h>
-	int main(void) { return ((int)(ptrdiff_t)(__sighandler_t)kill(0,0)); }
+	int main(void) { return ((int)(ptrdiff_t)(__sighandler_t)(ptrdiff_t)kill(0,0)); }
 EOF
 if test 1 = $HAVE___SIGHANDLER_T; then
 	CPPFLAGS="$CPPFLAGS -Dsig_t=__sighandler_t"
@@ -1111,15 +1189,6 @@
 test 1 = $HAVE_SIG_T || CPPFLAGS="$CPPFLAGS -Dsig_t=nosig_t"
 ac_cppflags SIG_T
 
-ac_testn u_int32_t <<-'EOF'
-	#include <sys/types.h>
-	#if HAVE_STDINT_H
-	#include <stdint.h>
-	#endif
-	int main(void) { return ((int)(u_int32_t)0); }
-EOF
-test 1 = $HAVE_U_INT32_T || CPPFLAGS="$CPPFLAGS -Du_int32_t=uint32_t"
-
 #
 # Environment: signals
 #
@@ -1151,55 +1220,14 @@
 #
 # Environment: library functions
 #
-ac_testn arc4random <<-'EOF'
-	#include <sys/types.h>
-	#if HAVE_STDINT_H
-	#include <stdint.h>
-	#endif
-	extern u_int32_t arc4random(void);
-	int main(void) { return ((int)(arc4random() & 0xFF)); }
-EOF
-
-save_LIBS=$LIBS
-if test 0 = $HAVE_ARC4RANDOM; then
-	test -f arc4random.c || if test -f "$srcdir/arc4random.c"; then
-		# ensure isolation of source directory from build directory
-		cp "$srcdir/arc4random.c" .
-	fi
-	if test -f arc4random.c; then
-		ac_testn can_uint8t '' "for uint8_t" <<-'EOF'
-			#include <sys/types.h>
-			#if HAVE_STDINT_H
-			#include <stdint.h>
-			#endif
-			int main(void) { return (1 - (uint8_t)1); }
-		EOF
-		test $HAVE_CAN_UINT8T = 1 || \
-		    CPPFLAGS="$CPPFLAGS -D\"uint8_t=unsigned char\""
-
-		ac_header sys/sysctl.h
-		addsrcs '!' HAVE_ARC4RANDOM arc4random.c
-		HAVE_ARC4RANDOM=1
-		LIBS="$LIBS arc4random.c"
-	fi
-fi
-ac_cppflags ARC4RANDOM
-
-ac_test arc4random_pushb arc4random 0 <<-'EOF'
-	#include <sys/types.h>
-	#if HAVE_STDINT_H
-	#include <stdint.h>
-	#endif
-	extern uint32_t arc4random_pushb(void *, size_t);
-	int main(int ac, char *av[]) { return ((int)(arc4random_pushb(*av,
-	    (size_t)ac)) & 0xFF); }
-EOF
-LIBS=$save_LIBS
-
 ac_testn flock_ex '' 'flock and mmap' <<-'EOF'
 	#include <sys/types.h>
+	#if HAVE_SYS_FILE_H
 	#include <sys/file.h>
+	#endif
+	#if HAVE_SYS_MMAN_H
 	#include <sys/mman.h>
+	#endif
 	#include <fcntl.h>
 	#include <stdlib.h>
 	int main(void) { return ((void *)mmap(NULL, (size_t)flock(0, LOCK_EX),
@@ -1265,18 +1293,30 @@
 	int main(void) { return ((int)(ptrdiff_t)(void *)nl_langinfo(CODESET)); }
 EOF
 
-ac_test setmode mknod 1 <<-'EOF'
-	/* XXX imake style */
-	/* XXX conditions correct? */
-	#if defined(__MSVCRT__) || defined(__CYGWIN__)
-	/* force a failure: Win32 setmode() is not what we want... */
-	int main(void) { return (thiswillneverbedefinedIhope()); }
-	#else
+ac_test select <<-'EOF'
 	#include <sys/types.h>
-	#include <unistd.h>
-	int main(int ac, char *av[]) { return (getmode(setmode(av[0]),
-	    (mode_t)ac)); }
+	#include <sys/time.h>
+	#if HAVE_SYS_BSDTYPES_H
+	#include <sys/bsdtypes.h>
+	#endif
+	#if HAVE_SYS_SELECT_H
+	#include <sys/select.h>
+	#endif
+	#if HAVE_BSTRING_H
+	#include <bstring.h>
+	#endif
+	#include <stddef.h>
+	#include <stdlib.h>
+	#include <string.h>
+	#if HAVE_STRINGS_H
+	#include <strings.h>
 	#endif
+	#include <unistd.h>
+	int main(void) {
+		struct timeval tv = { 1, 200000 };
+		fd_set fds; FD_ZERO(&fds); FD_SET(0, &fds);
+		return (select(FD_SETSIZE, &fds, NULL, NULL, &tv));
+	}
 EOF
 
 ac_test setresugid <<-'EOF'
@@ -1317,18 +1357,6 @@
 #
 save_CC=$CC; save_LDFLAGS=$LDFLAGS; save_LIBS=$LIBS
 CC="$CC -c -o $tcfn"; LDFLAGS=; LIBS=
-ac_test '!' arc4random_decl arc4random 1 'if arc4random() does not need to be declared' <<-'EOF'
-	#define MKSH_INCLUDES_ONLY
-	#include "sh.h"
-	long arc4random(void);		/* this clashes if defined before */
-	int main(void) { return ((int)arc4random()); }
-EOF
-ac_test '!' arc4random_pushb_decl arc4random_pushb 1 'if arc4random_pushb() does not need to be declared' <<-'EOF'
-	#define MKSH_INCLUDES_ONLY
-	#include "sh.h"
-	int arc4random_pushb(char, int); /* this clashes if defined before */
-	int main(int ac, char *av[]) { return ((int)arc4random_pushb(**av, ac)); }
-EOF
 ac_test '!' flock_decl flock_ex 1 'if flock() does not need to be declared' <<-'EOF'
 	#define MKSH_INCLUDES_ONLY
 	#include "sh.h"
@@ -1353,7 +1381,7 @@
 #
 fd='if to use persistent history'
 ac_cache PERSISTENT_HISTORY || test 0 = $HAVE_FLOCK_EX || fv=1
-test 1 = $fv || check_categories=$check_categories,no-histfile
+test 1 = $fv || check_categories="$check_categories no-histfile"
 ac_testdone
 ac_cppflags
 
@@ -1363,7 +1391,7 @@
 test 0 = $HAVE_SYS_SIGNAME && if ac_testinit cpp_dd '' \
     'checking if the C Preprocessor supports -dD'; then
 	echo '#define foo bar' >conftest.c
-	vv ']' "$CPP $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -dD conftest.c $LIBS >x"
+	vv ']' "$CPP $CFLAGS $CPPFLAGS $NOWARN -dD conftest.c >x"
 	grep '#define foo bar' x >/dev/null 2>&1 && fv=1
 	rmf conftest.c x vv.out
 	ac_testdone
@@ -1378,7 +1406,7 @@
 # the character count to standard output; cope for that
 echo wq >x
 ed x <x 2>/dev/null | grep 3 >/dev/null 2>&1 && \
-    check_categories=$check_categories,$oldish_ed
+    check_categories="$check_categories $oldish_ed"
 rmf x vv.out
 
 if test 0 = $HAVE_SYS_SIGNAME; then
@@ -1397,7 +1425,7 @@
 #endif
 #endif
 mksh_cfg: NSIG' >conftest.c
-	NSIG=`vq "$CPP $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN conftest.c $LIBS" | \
+	NSIG=`vq "$CPP $CFLAGS $CPPFLAGS $NOWARN conftest.c" | \
 	    grep mksh_cfg: | sed 's/^mksh_cfg:[	 ]*\([0-9x ()+-]*\).*$/\1/'`
 	case $NSIG in
 	*[\ \(\)+-]*) NSIG=`awk "BEGIN { print $NSIG }"` ;;
@@ -1410,14 +1438,14 @@
 	sigs="$sigs KILL LOST PIPE PROF PWR QUIT RESV SAK SEGV STOP SYS TERM"
 	sigs="$sigs TRAP TSTP TTIN TTOU URG USR1 USR2 VTALRM WINCH XCPU XFSZ"
 	test 1 = $HAVE_CPP_DD && test $NSIG -gt 1 && sigs="$sigs "`vq \
-	    "$CPP $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -dD conftest.c $LIBS" | \
+	    "$CPP $CFLAGS $CPPFLAGS $NOWARN -dD conftest.c" | \
 	    grep '[	 ]SIG[A-Z0-9]*[	 ]' | \
 	    sed 's/^\(.*[	 ]SIG\)\([A-Z0-9]*\)\([	 ].*\)$/\2/' | sort`
 	test $NSIG -gt 1 || sigs=
 	for name in $sigs; do
 		echo '#include <signal.h>' >conftest.c
 		echo mksh_cfg: SIG$name >>conftest.c
-		vq "$CPP $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN conftest.c $LIBS" | \
+		vq "$CPP $CFLAGS $CPPFLAGS $NOWARN conftest.c" | \
 		    grep mksh_cfg: | \
 		    sed 's/^mksh_cfg:[	 ]*\([0-9x]*\).*$/\1:'$name/
 	done | grep -v '^:' | while IFS=: read nr name; do
@@ -1435,11 +1463,9 @@
 	$e done.
 fi
 
-addsrcs '!' HAVE_SETMODE setmode.c
 addsrcs '!' HAVE_STRLCPY strlcpy.c
 addsrcs USE_PRINTF_BUILTIN printf.c
 test 1 = "$USE_PRINTF_BUILTIN" && CPPFLAGS="$CPPFLAGS -DMKSH_PRINTF_BUILTIN"
-test 0 = "$HAVE_SETMODE" && CPPFLAGS="$CPPFLAGS -DHAVE_CONFIG_H -DCONFIG_H_FILENAME=\\\"sh.h\\\""
 test 1 = "$HAVE_CAN_VERB" && CFLAGS="$CFLAGS -verbose"
 
 $e $bi$me: Finished configuration testing, now producing output.$ao
@@ -1454,7 +1480,42 @@
 cat >>test.sh <<-EOF
 	LC_ALL=C PATH='$PATH'; export LC_ALL PATH
 	test -n "\$KSH_VERSION" || exit 1
-	check_categories=$check_categories
+	set -A check_categories -- $check_categories
+	pflag='$curdir/mksh'
+	sflag='$srcdir/check.t'
+	usee=0 Pflag=0 uset=0 vflag=0 xflag=0
+	while getopts "C:e:Pp:s:t:v" ch; do case \$ch {
+	(C)	check_categories[\${#check_categories[*]}]=\$OPTARG ;;
+	(e)	usee=1; eflag=\$OPTARG ;;
+	(P)	Pflag=1 ;;
+	(p)	pflag=\$OPTARG ;;
+	(s)	sflag=\$OPTARG ;;
+	(t)	uset=1; tflag=\$OPTARG ;;
+	(v)	vflag=1 ;;
+	(*)	xflag=1 ;;
+	}
+	done
+	shift \$((OPTIND - 1))
+	set -A args -- '$srcdir/check.pl' -p "\$pflag" -s "\$sflag"
+	x=
+	for y in "\${check_categories[@]}"; do
+		x=\$x,\$y
+	done
+	if [[ -n \$x ]]; then
+		args[\${#args[*]}]=-C
+		args[\${#args[*]}]=\${x#,}
+	fi
+	if (( usee )); then
+		args[\${#args[*]}]=-e
+		args[\${#args[*]}]=\$eflag
+	fi
+	(( Pflag )) && args[\${#args[*]}]=-P
+	if (( uset )); then
+		args[\${#args[*]}]=-t
+		args[\${#args[*]}]=\$tflag
+	fi
+	(( vflag )) && args[\${#args[*]}]=-v
+	(( xflag )) && args[\${#args[*]}]=-x	# force usage by synerr
 	print Testing mksh for conformance:
 	fgrep MirOS: '$srcdir/check.t'
 	fgrep MIRBSD '$srcdir/check.t'
@@ -1464,35 +1525,46 @@
 	cstr="\$cstr"'print \$os . ", Perl version " . \$];'
 	for perli in \$PERL perl5 perl no; do
 		[[ \$perli = no ]] && exit 1
-		perlos=\$(\$perli -e "\$cstr") 2>&- || continue
+		perlos=\$(\$perli -e "\$cstr") 2>/dev/null || continue
 		print "Perl interpreter '\$perli' running on '\$perlos'"
 		[[ -n \$perlos ]] && break
 	done
-	exec \$perli '$srcdir/check.pl' -s '$srcdir/check.t' -p '$curdir/mksh' \${check_categories:+-C} \${check_categories#,} \$*$tsts
+	exec \$perli "\${args[@]}" "\$@"$tsts
 EOF
 chmod 755 test.sh
 test $HAVE_CAN_COMBINE$cm = 0combine && cm=normal
 if test $cm = llvm; then
 	emitbc="-emit-llvm -c"
+elif test $cm = dragonegg; then
+	emitbc="-S -flto"
 else
 	emitbc=-c
 fi
 echo set -x >Rebuild.sh
 for file in $SRCS; do
-	of=`echo x"$file" | sed 's/^x\(.*\)\.c$/\1.o/'`
-	objs="$objs$sp$of"
+	op=`echo x"$file" | sed 's/^x\(.*\)\.c$/\1./'`
 	test -f $file || file=$srcdir/$file
 	files="$files$sp$file"
 	sp=' '
 	echo "$CC $CFLAGS $CPPFLAGS $emitbc $file || exit 1" >>Rebuild.sh
+	if test $cm = dragonegg; then
+		echo "mv ${op}s ${op}ll" >>Rebuild.sh
+		echo "llvm-as ${op}ll || exit 1" >>Rebuild.sh
+		objs="$objs$sp${op}bc"
+	else
+		objs="$objs$sp${op}o"
+	fi
 done
-if test $cm = llvm; then
+case $cm in
+dragonegg|llvm)
 	echo "rm -f mksh.s" >>Rebuild.sh
-	echo "llvm-link -o - $objs | opt $llvm | llc -o mksh.s" >>Rebuild.sh
+	echo "llvm-link -o - $objs | opt $optflags | llc -o mksh.s" >>Rebuild.sh
 	lobjs=mksh.s
-else
+	;;
+*)
 	lobjs=$objs
-fi
+	;;
+esac
 case $tcfn in
 a.exe)	mkshexe=mksh.exe ;;
 *)	mkshexe=mksh ;;
@@ -1558,14 +1630,22 @@
 	wait
 else
 	for file in $SRCS; do
+		test $cm = dragonegg && \
+		    op=`echo x"$file" | sed 's/^x\(.*\)\.c$/\1./'`
 		test -f $file || file=$srcdir/$file
 		v "$CC $CFLAGS $CPPFLAGS $emitbc $file" || exit 1
+		if test $cm = dragonegg; then
+			v "mv ${op}s ${op}ll"
+			v "llvm-as ${op}ll" || exit 1
+		fi
 	done
 fi
-if test $cm = llvm; then
+case $cm in
+dragonegg|llvm)
 	rmf mksh.s
-	v "llvm-link -o - $objs | opt $llvm | llc -o mksh.s"
-fi
+	v "llvm-link -o - $objs | opt $optflags | llc -o mksh.s"
+	;;
+esac
 tcfn=$mkshexe
 test $cm = combine || v "$CC $CFLAGS $LDFLAGS -o $tcfn $lobjs $LIBS $ccpr"
 test -f $tcfn || exit 1
Index: src/bin/mksh/check.pl
diff -u src/bin/mksh/check.pl:1.23 src/bin/mksh/check.pl:1.26
--- src/bin/mksh/check.pl:1.23	Wed Jun 10 18:12:43 2009
+++ src/bin/mksh/check.pl	Mon Mar 28 21:58:05 2011
@@ -1,7 +1,7 @@
-# $MirOS: src/bin/mksh/check.pl,v 1.23 2009/06/10 18:12:43 tg Rel $
+# $MirOS: src/bin/mksh/check.pl,v 1.26 2011/03/28 21:58:05 tg Exp $
 # $OpenBSD: th,v 1.13 2006/05/18 21:27:23 miod Exp $
 #-
-# Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
+# Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
 #	Thorsten Glaser <tg@mirbsd.org>
 #
 # Provided that these terms and disclaimer and all copyright notices
@@ -71,7 +71,8 @@
 #					environment. Programs are run with
 #					the following minimal environment:
 #					    HOME, LD_LIBRARY_PATH, LOCPATH,
-#					    LOGNAME, PATH, SHELL, USER
+#					    LOGNAME, PATH, SHELL, UNIXMODE,
+#					    USER
 #					(values taken from the environment of
 #					the test harness).
 #					ENV is set to /nonexistant.
@@ -135,6 +136,8 @@
 #					One category os:XXX is predefined
 #					(XXX is the operating system name,
 #					eg, linux, dec_osf).
+#	need-ctty			'yes' if the test needs a ctty, run
+#					with -C regress:no-ctty to disable.
 # Flag meanings:
 #	r	tag is required (eg, a test must have a name tag).
 #	m	value can be multiple lines. Lines must be prefixed with
@@ -156,19 +159,19 @@
 ($prog = $0) =~ s#.*/##;
 
 $Usage = <<EOF ;
-Usage: $prog [-s test-set] [-C category] [-p prog] [-v] [-e e=v] name ...
-	-p p	Use p as the program to test
+Usage: $prog [-Pv] [-C cat] [-e e=v] [-p prog] [-s fn] [-t tmo] name ...
 	-C c	Specify the comma separated list of categories the program
 		belongs to (see category field).
+	-e e=v	Set the environment variable e to v for all tests
+		(if no =v is given, the current value is used)
+		Only one -e option can be given at the moment, sadly.
+	-P	program (-p) string has multiple words, and the program is in
+		the path (kludge option)
+	-p p	Use p as the program to test
 	-s s	Read tests from file s; if s is a directory, it is recursively
 		scaned for test files (which end in .t).
 	-t t	Use t as default time limit for tests (default is unlimited)
-	-P	program (-p) string has multiple words, and the program is in
-		the path (kludge option)
 	-v	Verbose mode: print reason test failed.
-	-e e=v	Set the environment variable e to v for all tests
-		(if no =v is given, the current value is used)
-		Only one -e option can be given at the moment, sadly.
 	name	specifies the name of the test(s) to run; if none are
 		specified, all tests are run.
 EOF
@@ -193,6 +196,7 @@
 	'expected-stderr',		'm',
 	'expected-stderr-pattern',	'm',
 	'category',			'm',
+	'need-ctty',			'',
 	);
 # Filled in by read_test()
 %internal_test_fields = (
@@ -219,7 +223,7 @@
 
 %known_tests = ();
 
-if (!getopts('C:p:Ps:t:ve:')) {
+if (!getopts('C:e:Pp:s:t:v')) {
     print STDERR $Usage;
     exit 1;
 }
@@ -253,7 +257,7 @@
 # Set up a very minimal environment
 %new_env = ();
 foreach $env (('HOME', 'LD_LIBRARY_PATH', 'LOCPATH', 'LOGNAME',
-  'PATH', 'SHELL', 'USER')) {
+  'PATH', 'SHELL', 'UNIXMODE', 'USER')) {
     $new_env{$env} = $ENV{$env} if defined $ENV{$env};
 }
 $new_env{'ENV'} = '/nonexistant';
@@ -642,6 +646,7 @@
     local(*test) = @_;
     local($c);
 
+    return 0 if ($test{'need-ctty'} && defined $categories{'regress:no-ctty'});
     return 1 if (!defined $test{'category'});
     local($ok) = 0;
     foreach $c (split(',', $test{'category'})) {
@@ -1064,6 +1069,16 @@
     } else {
 	$test{'expected-fail'} = 0;
     }
+    if (defined $test{'need-ctty'}) {
+	if ($test{'need-ctty'} !~ /^(yes|no)$/) {
+	    print STDERR
+	      "$prog:$test{':long-name'}: bad value for need-ctty field\n";
+	    return undef;
+	}
+	$test{'need-ctty'} = $1 eq 'yes';
+    } else {
+	$test{'need-ctty'} = 0;
+    }
     if (defined $test{'arguments'}) {
 	local($firstc) = substr($test{'arguments'}, 0, 1);
 
Index: src/bin/mksh/check.t
diff -u src/bin/mksh/check.t:1.365 src/bin/mksh/check.t:1.454
--- src/bin/mksh/check.t:1.365	Thu Feb 25 20:18:14 2010
+++ src/bin/mksh/check.t	Sat May  7 02:02:45 2011
@@ -1,9 +1,9 @@
-# $MirOS: src/bin/mksh/check.t,v 1.365 2010/02/25 20:18:14 tg Exp $
+# $MirOS: src/bin/mksh/check.t,v 1.454 2011/05/07 02:02:45 tg Exp $
 # $OpenBSD: bksl-nl.t,v 1.2 2001/01/28 23:04:56 niklas Exp $
 # $OpenBSD: history.t,v 1.5 2001/01/28 23:04:56 niklas Exp $
 # $OpenBSD: read.t,v 1.3 2003/03/10 03:48:16 david Exp $
 #-
-# Copyright © 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+# Copyright © 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
 #	Thorsten Glaser <tg@mirbsd.org>
 #
 # Provided that these terms and disclaimer and all copyright notices
@@ -25,7 +25,7 @@
 # http://www.research.att.com/~gsf/public/ifs.sh
 
 expected-stdout:
-	@(#)MIRBSD KSH R39 2010/02/25
+	@(#)MIRBSD KSH R39 2011/05/06
 description:
 	Check version of shell.
 stdin:
@@ -65,6 +65,16 @@
 stdin:
 	set
 ---
+name: selftest-direct-builtin-call
+description:
+	Check that direct builtin calls work
+stdin:
+	ln -s "$__progname" cat
+	ln -s "$__progname" echo
+	./echo -c 'echo  foo' | ./cat -u
+expected-stdout:
+	-c echo  foo
+---
 name: alias-1
 description:
 	Check that recursion is detected/avoided in aliases.
@@ -185,6 +195,17 @@
 	tf
 	tf
 ---
+name: alias-10
+description:
+	Check that recursion is detected/avoided in aliases.
+	Regression, introduced during an old bugfix.
+stdin:
+	alias foo='print hello '
+	alias bar='foo world'
+	echo $(bar)
+expected-stdout:
+	hello world
+---
 name: arith-lazy-1
 description:
 	Check that only one side of ternary operator is evaluated
@@ -335,7 +356,7 @@
 ---
 name: bksl-nl-ign-1
 description:
-	Check that \newline is not collasped after #
+	Check that \newline is not collapsed after #
 stdin:
 	echo hi #there \
 	echo folks
@@ -345,7 +366,7 @@
 ---
 name: bksl-nl-ign-2
 description:
-	Check that \newline is not collasped inside single quotes
+	Check that \newline is not collapsed inside single quotes
 stdin:
 	echo 'hi \
 	there'
@@ -357,7 +378,7 @@
 ---
 name: bksl-nl-ign-3
 description:
-	Check that \newline is not collasped inside single quotes
+	Check that \newline is not collapsed inside single quotes
 stdin:
 	cat << \EOF
 	hi \
@@ -407,7 +428,7 @@
 #
 name: bksl-nl-1
 description:
-	Check that \newline is collasped before, in the middle of, and
+	Check that \newline is collapsed before, in the middle of, and
 	after words
 stdin:
 	 	 	\
@@ -419,7 +440,7 @@
 ---
 name: bksl-nl-2
 description:
-	Check that \newline is collasped in $ sequences
+	Check that \newline is collapsed in $ sequences
 	(ksh93 fails this)
 stdin:
 	a=12
@@ -443,7 +464,7 @@
 ---
 name: bksl-nl-3
 description:
-	Check that \newline is collasped in $(..) and `...` sequences
+	Check that \newline is collapsed in $(..) and `...` sequences
 	(ksh93 fails this)
 stdin:
 	echo $\
@@ -468,7 +489,7 @@
 ---
 name: bksl-nl-4
 description:
-	Check that \newline is collasped in $((..)) sequences
+	Check that \newline is collapsed in $((..)) sequences
 	(ksh93 fails this)
 stdin:
 	echo $\
@@ -490,7 +511,7 @@
 ---
 name: bksl-nl-5
 description:
-	Check that \newline is collasped in double quoted strings
+	Check that \newline is collapsed in double quoted strings
 stdin:
 	echo "\
 	hi"
@@ -505,7 +526,7 @@
 ---
 name: bksl-nl-6
 description:
-	Check that \newline is collasped in here document delimiters
+	Check that \newline is collapsed in here document delimiters
 	(ksh93 fails second part of this)
 stdin:
 	a=12
@@ -528,7 +549,7 @@
 ---
 name: bksl-nl-7
 description:
-	Check that \newline is collasped in double-quoted here-document
+	Check that \newline is collapsed in double-quoted here-document
 	delimiter.
 stdin:
 	a=12
@@ -547,7 +568,7 @@
 ---
 name: bksl-nl-8
 description:
-	Check that \newline is collasped in various 2+ character tokens
+	Check that \newline is collapsed in various 2+ character tokens
 	delimiter.
 	(ksh93 fails this)
 stdin:
@@ -992,6 +1013,7 @@
 	XXX=_
 	PS1=X
 	false && echo hmmm
+need-ctty: yes
 arguments: !-i!
 stdin:
 	echo hi${XXX}there
@@ -1036,11 +1058,17 @@
 	(echo -n '30 '; printf '<%s> ' ${IFS+foo 'b\
 	ar' baz}; echo .) 2>&- || (echo failed in 30; echo failed in 31)
 	(echo -n '32 '; printf '<%s> ' ${IFS+foo "b\
-	ar" baz}; echo .) 2>&- || (echo failed in 32; echo failed in 33)
-	(echo -n '34 '; printf '<%s> ' "${IFS+foo 'b\
-	ar' baz}"; echo .) 2>&- || (echo failed in 34; echo failed in 35)
-	(echo -n '36 '; printf '<%s> ' "${IFS+foo "b\
-	ar" baz}"; echo .) 2>&- || (echo failed in 36; echo failed in 37)
+	ar" baz}; echo .) 2>&- || echo failed in 32
+	(echo -n '33 '; printf '<%s> ' "${IFS+foo 'b\
+	ar' baz}"; echo .) 2>&- || echo failed in 33
+	(echo -n '34 '; printf '<%s> ' "${IFS+foo "b\
+	ar" baz}"; echo .) 2>&- || echo failed in 34
+	(echo -n '35 '; printf '<%s> ' ${v=a\ b} x ${v=c\ d}; echo .) 2>&- || echo failed in 35
+	(echo -n '36 '; printf '<%s> ' "${v=a\ b}" x "${v=c\ d}"; echo .) 2>&- || echo failed in 36
+	(echo -n '37 '; printf '<%s> ' ${v-a\ b} x ${v-c\ d}; echo .) 2>&- || echo failed in 37
+	(echo 38 ${IFS+x'a'y} / "${IFS+x'a'y}" .) 2>&- || echo failed in 38
+	foo="x'a'y"; (echo 39 ${foo%*'a'*} / "${foo%*'a'*}" .) 2>&- || echo failed in 39
+	foo="a b c"; (echo -n '40 '; printf '<%s> ' "${foo#a}"; echo .) 2>&- || echo failed in 40
 expected-stdout:
 	1 }z
 	2 ''z}
@@ -1074,8 +1102,14 @@
 	30 <foo> <b\
 	ar> <baz> .
 	32 <foo> <bar> <baz> .
-	34 <foo 'bar' baz> .
-	36 <foo bar baz> .
+	33 <foo 'bar' baz> .
+	34 <foo bar baz> .
+	35 <a> <b> <x> <a> <b> .
+	36 <a\ b> <x> <a\ b> .
+	37 <a b> <x> <c d> .
+	38 xay / x'a'y .
+	39 x' / x' .
+	40 < b c> .
 ---
 name: expand-unglob-dblq
 description:
@@ -1337,6 +1371,56 @@
 	9 EQAL brac foo x c x} baz
 	9 QSTN brac foo x c x} baz
 ---
+name: expand-threecolons-dblq
+description:
+	Check for a particular thing that used to segfault
+stdin:
+	TEST=1234
+	echo "${TEST:1:2:3}"
+	echo $? but still living
+expected-stderr-pattern:
+	/bad substitution/
+expected-exit: 1
+---
+name: expand-threecolons-unq
+description:
+	Check for a particular thing that used to not error out
+stdin:
+	TEST=1234
+	echo ${TEST:1:2:3}
+	echo $? but still living
+expected-stderr-pattern:
+	/bad substitution/
+expected-exit: 1
+---
+name: expand-weird-1
+description:
+	Check corner case of trim expansion vs. $# vs. ${#var}
+stdin:
+	set 1 2 3 4 5 6 7 8 9 10 11
+	echo ${#}	# value of $#
+	echo ${##}	# length of $#
+	echo ${##1}	# $# trimmed 1
+	set 1 2 3 4 5 6 7 8 9 10 11 12
+	echo ${##1}
+expected-stdout:
+	11
+	2
+	1
+	2
+---
+name: expand-weird-2
+description:
+	Check corner case of ${var?} vs. ${#var}
+stdin:
+	(exit 0)
+	echo $? = ${#?} .
+	(exit 111)
+	echo $? = ${#?} .
+expected-stdout:
+	0 = 1 .
+	111 = 3 .
+---
 name: eglob-bad-1
 description:
 	Check that globbing isn't done when glob has syntax error
@@ -1472,6 +1556,26 @@
 	3: abcdef
 	4: cdef
 ---
+name: eglob-trim-3
+description:
+	Check eglobbing works in trims, for Korn Shell
+	Ensure eglobbing does not work for reduced-feature /bin/sh
+stdin:
+	set +o sh
+	x=foobar
+	y=foobaz
+	echo "<${x%bar|baz},${y%bar|baz}>"
+	echo "<${x%ba(r|z)},${y%ba(r|z)}>"
+	set -o sh
+	echo "<${x%bar|baz},${y%bar|baz}>"
+	z='foo(bar'
+	echo "<${z%(*}>"
+expected-stdout:
+	<foo,foo>
+	<foo,foo>
+	<foobar,foobaz>
+	<foo>
+---
 name: eglob-substrpl-1
 description:
 	Check eglobbing works in substs... and they work at all
@@ -1719,6 +1823,8 @@
 name: glob-bad-2
 description:
 	Check that symbolic links aren't stat()'d
+# breaks on FreeMiNT (cannot unlink dangling symlinks)
+category: !os:mint
 file-setup: dir 755 "dir"
 file-setup: symlink 644 "dir/abc"
 	non-existent-file
@@ -1984,6 +2090,242 @@
 expected-stdout:
 	one
 ---
+name: heredoc-9e
+description:
+	Check here string related regression with multiple iops
+stdin:
+	echo $(tr r z <<<'bar' 2>&-)
+expected-stdout:
+	baz
+---
+name: heredoc-10
+description:
+	Check direct here document assignment
+stdin:
+	x=u
+	va=<<EOF
+	=a $x \x40=
+	EOF
+	vb=<<'EOF'
+	=b $x \x40=
+	EOF
+	function foo {
+		vc=<<-EOF
+			=c $x \x40=
+		EOF
+	}
+	typeset -f foo
+	foo
+	# rather nonsensical, but…
+	vd=<<<"=d $x \x40="
+	ve=<<<'=e $x \x40='
+	vf=<<<$'=f $x \x40='
+	# now check
+	print -r -- "| va={$va} vb={$vb} vc={$vc} vd={$vd} ve={$ve} vf={$vf} |"
+expected-stdout:
+	function foo {
+		vc= <<-EOF 
+	=c $x \x40=
+	EOF
+	
+	} 
+	| va={=a u \x40=
+	} vb={=b $x \x40=
+	} vc={=c u \x40=
+	} vd={=d u \x40=
+	} ve={=e $x \x40=
+	} vf={=f $x @=
+	} |
+---
+name: heredoc-11
+description:
+	Check here documents with no or empty delimiter
+stdin:
+	x=u
+	va=<<
+	=a $x \x40=
+	<<
+	vb=<<''
+	=b $x \x40=
+	
+	function foo {
+		vc=<<-
+			=c $x \x40=
+		<<
+		vd=<<-''
+			=d $x \x40=
+	
+	}
+	typeset -f foo
+	foo
+	print -r -- "| va={$va} vb={$vb} vc={$vc} vd={$vd} |"
+expected-stdout:
+	function foo {
+		vc= <<- 
+	=c $x \x40=
+	<<
+	
+		vd= <<-"" 
+	=d $x \x40=
+	
+	
+	} 
+	| va={=a u \x40=
+	} vb={=b $x \x40=
+	} vc={=c u \x40=
+	} vd={=d $x \x40=
+	} |
+---
+name: heredoc-comsub-1
+description:
+	Tests for here documents in COMSUB, taken from Austin ML
+stdin:
+	text=$(cat <<EOF
+	here is the text
+	EOF)
+	echo = $text =
+expected-stdout:
+	= here is the text =
+---
+name: heredoc-comsub-2
+description:
+	Tests for here documents in COMSUB, taken from Austin ML
+stdin:
+	unbalanced=$(cat <<EOF
+	this paren ) is a problem
+	EOF)
+	echo = $unbalanced =
+expected-stdout:
+	= this paren ) is a problem =
+---
+name: heredoc-comsub-3
+description:
+	Tests for here documents in COMSUB, taken from Austin ML
+stdin:
+	balanced=$(cat <<EOF
+	these parens ( ) are not a problem
+	EOF)
+	echo = $balanced =
+expected-stdout:
+	= these parens ( ) are not a problem =
+---
+name: heredoc-comsub-4
+description:
+	Tests for here documents in COMSUB, taken from Austin ML
+stdin:
+	balanced=$(cat <<EOF
+	these parens \( ) are a problem
+	EOF)
+	echo = $balanced =
+expected-stdout:
+	= these parens \( ) are a problem =
+---
+name: heredoc-subshell-1
+description:
+	Tests for here documents in subshells, taken from Austin ML
+stdin:
+	(cat <<EOF
+	some text
+	EOF)
+	echo end
+expected-stdout:
+	some text
+	end
+---
+name: heredoc-subshell-2
+description:
+	Tests for here documents in subshells, taken from Austin ML
+stdin:
+	(cat <<EOF
+	some text
+	EOF
+	)
+	echo end
+expected-stdout:
+	some text
+	end
+---
+name: heredoc-subshell-3
+description:
+	Tests for here documents in subshells, taken from Austin ML
+stdin:
+	(cat <<EOF; )
+	some text
+	EOF
+	echo end
+expected-stdout:
+	some text
+	end
+---
+name: heredoc-weird-1
+description:
+	Tests for here documents, taken from Austin ML
+	Documents current state in mksh, *NOT* necessarily correct!
+stdin:
+	cat <<END
+	hello
+	END\
+	END
+	END
+	echo end
+expected-stdout:
+	hello
+	ENDEND
+	end
+---
+name: heredoc-weird-2
+description:
+	Tests for here documents, taken from Austin ML
+stdin:
+	cat <<'    END    '
+	hello
+	    END    
+	echo end
+expected-stdout:
+	hello
+	end
+---
+name: heredoc-weird-3
+description:
+	Tests for here documents, taken from Austin ML
+stdin:
+	cat <<x*x & touch 'x*x'
+	hello
+	x*x
+	echo end
+expected-stdout:
+	hello
+	end
+---
+name: heredoc-weird-4
+description:
+	Tests for here documents, taken from Austin ML
+	Documents current state in mksh, *NOT* necessarily correct!
+stdin:
+	cat <<END
+	hello\
+	END
+	END
+	echo end
+expected-stdout:
+	helloEND
+	end
+---
+name: heredoc-weird-5
+description:
+	Tests for here documents, taken from Austin ML
+	Documents current state in mksh, *NOT* necessarily correct!
+stdin:
+	cat <<END
+	hello
+	\END
+	END
+	echo end
+expected-stdout:
+	hello
+	\END
+	end
+---
 name: heredoc-quoting-unsubst
 description:
 	Check for correct handling of quoted characters in
@@ -2192,6 +2534,7 @@
 name: history-basic
 description:
 	See if we can test history at all
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2208,6 +2551,7 @@
 name: history-dups
 description:
 	Verify duplicates and spaces are not entered
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2228,6 +2572,7 @@
 name: history-unlink
 description:
 	Check if broken HISTFILEs do not cause trouble
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=foo/hist.file!
 file-setup: file 644 "Env"
@@ -2245,11 +2590,12 @@
 	hi
 	1	echo hi
 expected-stderr-pattern:
-	/(.*cannot unlink HISTFILE.*\n)?X*$/
+	/(.*can't unlink HISTFILE.*\n)?X*$/
 ---
 name: history-e-minus-1
 description:
 	Check if more recent command is executed
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2269,6 +2615,7 @@
 description:
 	Check that repeated command is printed before command
 	is re-executed.
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2288,6 +2635,7 @@
 	fc -e - fails when there is no history
 	(ksh93 has a bug that causes this to fail)
 	(ksh88 loops on this)
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2303,6 +2651,7 @@
 name: history-e-minus-4
 description:
 	Check if "fc -e -" command output goes to stdout.
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2321,6 +2670,7 @@
 name: history-e-minus-5
 description:
 	fc is replaced in history by new command.
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2346,6 +2696,7 @@
 description:
 	List lists correct range
 	(ksh88 fails 'cause it lists the fc command)
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2369,6 +2720,7 @@
 	Lists oldest history if given pre-historic number
 	(ksh93 has a bug that causes this to fail)
 	(ksh88 fails 'cause it lists the fc command)
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2391,6 +2743,7 @@
 name: history-list-3
 description:
 	Can give number 'options' to fc
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2414,6 +2767,7 @@
 name: history-list-4
 description:
 	-1 refers to previous command
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2436,6 +2790,7 @@
 name: history-list-5
 description:
 	List command stays in history
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2462,6 +2817,7 @@
 description:
 	HISTSIZE limits about of history kept.
 	(ksh88 fails 'cause it lists the fc command)
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!HISTSIZE=3!
 file-setup: file 644 "Env"
@@ -2487,6 +2843,7 @@
 name: history-list-7
 description:
 	fc allows too old/new errors in range specification
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!HISTSIZE=3!
 file-setup: file 644 "Env"
@@ -2513,6 +2870,7 @@
 name: history-list-r-1
 description:
 	test -r flag in history
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2539,6 +2897,7 @@
 name: history-list-r-2
 description:
 	If first is newer than last, -r is implied.
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2565,6 +2924,7 @@
 name: history-list-r-3
 description:
 	If first is newer than last, -r is cancelled.
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2591,6 +2951,7 @@
 name: history-subst-1
 description:
 	Basic substitution
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2609,6 +2970,7 @@
 name: history-subst-2
 description:
 	Does subst find previous command?
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2627,6 +2989,7 @@
 name: history-subst-3
 description:
 	Does subst find previous command when no arguments given
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2646,6 +3009,7 @@
 description:
 	Global substitutions work
 	(ksh88 and ksh93 do not have -g option)
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2663,6 +3027,7 @@
 description:
 	Make sure searches don't find current (fc) command
 	(ksh88/ksh93 don't have the ? prefix thing so they fail this test)
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2684,6 +3049,7 @@
 	that prints no prompts). This is for oldish ed(1) which write
 	the character count to stdout.
 category: stdout-ed
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2706,6 +3072,7 @@
 description:
 	Correct command is edited when number given
 category: stdout-ed
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2737,6 +3104,7 @@
 	(NOTE: adjusted for COMPLEX HISTORY compile time option)
 	(ksh88 fails 'cause it lists the fc command)
 category: stdout-ed
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2768,6 +3136,7 @@
 	Basic (ed) editing works (assumes you have generic ed editor
 	that prints no prompts). This is for newish ed(1) and stderr.
 category: !no-stderr-ed
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2788,6 +3157,7 @@
 description:
 	Correct command is edited when number given
 category: !no-stderr-ed
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2815,6 +3185,7 @@
 	Newly created multi line commands show up as single command
 	in history.
 category: !no-stderr-ed
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -2920,23 +3291,6 @@
 expected-stdout:
 	 <:>
 ---
-name: IFS-space-colon-3
-description:
-	Simple test, IFS=<white-space>:
-	pdksh fails both of these tests
-	not sure whether #2 is correct
-stdin:
-	showargs() { for i; do echo -n " <$i>"; done; echo; }
-	IFS="$IFS:"
-	x=
-	set --
-	showargs "$x$@" 1
-	showargs "$@$x" 2
-expected-fail: yes
-expected-stdout:
-	 <> <1>
-	 <> <2>
----
 name: IFS-space-colon-4
 description:
 	Simple test, IFS=<white-space>:
@@ -3028,6 +3382,7 @@
 	Syntax errors in expressions and effects on bases
 	(interactive so errors don't cause exits)
 	(ksh88 fails this test - shell exits, even with -i)
+need-ctty: yes
 arguments: !-i!
 stdin:
 	PS1= # minimise prompt hassles
@@ -3309,6 +3664,40 @@
 	dot B 3
 	C 3
 ---
+name: lineno-trap
+description:
+	Check if LINENO is tracked in traps
+stdin:
+	fail() {
+		echo "line <$1>"
+		exit 1
+	}
+	trap 'fail $LINENO' INT ERR
+	false
+expected-stdout:
+	line <6>
+expected-exit: 1
+---
+name: unknown-trap
+description:
+	Ensure unknown traps are not a syntax error
+stdin:
+	(
+	trap "echo trap 1 executed" UNKNOWNSIGNAL || echo "foo"
+	echo =1
+	trap "echo trap 2 executed" UNKNOWNSIGNAL EXIT 999999 FNORD
+	echo = $?
+	) 2>&1 | sed "s^${__progname}: <stdin>\[[0-9]*]PROG"
+expected-stdout:
+	PROG: trap: bad signal 'UNKNOWNSIGNAL'
+	foo
+	=1
+	PROG: trap: bad signal 'UNKNOWNSIGNAL'
+	PROG: trap: bad signal '999999'
+	PROG: trap: bad signal 'FNORD'
+	= 3
+	trap 2 executed
+---
 name: read-IFS-1
 description:
 	Simple test, default IFS
@@ -3335,6 +3724,46 @@
 expected-stdout:
 	[abc]
 ---
+name: read-regress-1
+description:
+	Check a regression of read
+file-setup: file 644 "foo"
+	foo bar
+	baz
+	blah
+stdin:
+	while read a b c; do
+		read d
+		break
+	done <foo
+	echo "<$a|$b|$c><$d>"
+expected-stdout:
+	<foo|bar|><baz>
+---
+name: read-delim-1
+description:
+	Check read with delimiters
+stdin:
+	emit() {
+		printf 'foo bar\tbaz\nblah \0blub\tblech\nmyok meck \0'
+	}
+	emit | while IFS= read -d "" foo; do print -r -- "<$foo>"; done
+	emit | while read -d "" foo; do print -r -- "<$foo>"; done
+	emit | while read -d "eh?" foo; do print -r -- "<$foo>"; done
+expected-stdout:
+	<foo bar	baz
+	blah >
+	<blub	blech
+	myok meck >
+	<foo bar	baz
+	blah>
+	<blub	blech
+	myok meck>
+	<foo bar	baz
+	blah blub	bl>
+	<ch
+	myok m>
+---
 name: regression-1
 description:
 	Lex array code had problems with this.
@@ -3745,6 +4174,9 @@
 description:
 	Does umask print a leading 0 when umask is 3 digits?
 stdin:
+	# on MiNT, the first umask call seems to fail
+	umask 022
+	# now, the test proper
 	umask 222
 	umask
 expected-stdout:
@@ -3969,6 +4401,7 @@
 	PS1=Y
 	PS2=X
 env-setup: !ENV=./env!
+need-ctty: yes
 arguments: !-i!
 stdin:
 	alias foo='echo hi ; '
@@ -3999,6 +4432,7 @@
 file-setup: file 644 "abc"
 	stuff
 env-setup: !ENV=./env!
+need-ctty: yes
 arguments: !-i!
 stdin:
 	sed 's/^/X /' < ab*
@@ -4332,6 +4766,78 @@
 		time
 	}
 ---
+name: regression-65
+description:
+	check for a regression with sleep builtin and signal mask
+category: !nojsig
+time-limit: 3
+stdin:
+	sleep 1
+	echo blub |&
+	while read -p line; do :; done
+	echo ok
+expected-stdout:
+	ok
+---
+name: readonly-0
+description:
+	Ensure readonly is honoured for assignments and unset
+stdin:
+	"$__progname" -c 'u=x; echo $? $u .' || echo aborted, $?
+	echo =
+	"$__progname" -c 'readonly u; u=x; echo $? $u .' || echo aborted, $?
+	echo =
+	"$__progname" -c 'u=x; readonly u; unset u; echo $? $u .' || echo aborted, $?
+expected-stdout:
+	0 x .
+	=
+	aborted, 2
+	=
+	1 x .
+expected-stderr-pattern:
+	/read *only/
+---
+name: readonly-1
+description:
+	http://austingroupbugs.net/view.php?id=367 for export
+stdin:
+	"$__progname" -c 'readonly foo; export foo=a; echo $?' || echo aborted, $?
+expected-stdout:
+	aborted, 2
+expected-stderr-pattern:
+	/read *only/
+---
+name: readonly-2a
+description:
+	Check that getopts works as intended, for readonly-2b to be valid
+stdin:
+	"$__progname" -c 'set -- -a b; getopts a c; echo $? $c .; getopts a c; echo $? $c .' || echo aborted, $?
+expected-stdout:
+	0 a .
+	1 ? .
+---
+name: readonly-2b
+description:
+	http://austingroupbugs.net/view.php?id=367 for getopts
+stdin:
+	"$__progname" -c 'readonly c; set -- -a b; getopts a c; echo $? $c .' || echo aborted, $?
+expected-stdout:
+	2 .
+expected-stderr-pattern:
+	/read *only/
+---
+name: readonly-3
+description:
+	http://austingroupbugs.net/view.php?id=367 for read
+stdin:
+	echo x | "$__progname" -c 'read s; echo $? $s .' || echo aborted, $?
+	echo y | "$__progname" -c 'readonly s; read s; echo $? $s .' || echo aborted, $?
+expected-stdout:
+	0 x .
+	2 .
+expected-stderr-pattern:
+	/read *only/
+---
 name: syntax-1
 description:
 	Check that lone ampersand is a syntax error
@@ -4384,6 +4890,53 @@
 expected-stdout:
 	123
 ---
+name: xxx-multi-assignment-posix-cmd
+description:
+	Check that the behaviour for multiple assignments with a
+	command name matches POSIX. See:
+	http://thread.gmane.org/gmane.comp.standards.posix.austin.general/1925
+stdin:
+	X=a Y=b; X=$Y Y=$X "$__progname" -c 'echo 1 $X $Y .'; echo 2 $X $Y .
+	unset X Y Z
+	X=a Y=${X=b} Z=$X "$__progname" -c 'echo 3 $Z .'
+	unset X Y Z
+	X=a Y=${X=b} Z=$X; echo 4 $Z .
+expected-stdout:
+	1 b a .
+	2 a b .
+	3 b .
+	4 a .
+---
+name: xxx-multi-assignment-posix-nocmd
+description:
+	Check that the behaviour for multiple assignments with no
+	command name matches POSIX (Debian #334182). See:
+	http://thread.gmane.org/gmane.comp.standards.posix.austin.general/1925
+stdin:
+	X=a Y=b; X=$Y Y=$X; echo 1 $X $Y .
+expected-stdout:
+	1 b b .
+---
+name: xxx-multi-assignment-posix-subassign
+description:
+	Check that the behaviour for multiple assignments matches POSIX:
+	- The assignment words shall be expanded in the current execution
+	  environment.
+	- The assignments happen in the temporary execution environment.
+stdin:
+	unset X Y Z
+	Z=a Y=${X:=b} sh -c 'echo +$X+ +$Y+ +$Z+'
+	echo /$X/
+	# Now for the special case:
+	unset X Y Z
+	X= Y=${X:=b} sh -c 'echo +$X+ +$Y+'
+	echo /$X/
+expected-stdout:
+	++ +b+ +a+
+	/b/
+	++ +b+
+	/b/
+---
 name: xxx-exec-environment-1
 description:
 	Check to see if exec sets it's environment correctly
@@ -4441,6 +4994,22 @@
 	/bad substitution/
 expected-exit: 1
 ---
+name: xxx-variable-syntax-2
+stdin:
+	set 0
+	echo ${*:0}
+expected-stderr-pattern:
+	/bad substitution/
+expected-exit: 1
+---
+name: xxx-variable-syntax-3
+stdin:
+	set -A foo 0
+	echo ${foo[*]:0}
+expected-stderr-pattern:
+	/bad substitution/
+expected-exit: 1
+---
 name: xxx-substitution-eval-order
 description:
 	Check order of evaluation of expressions
@@ -4467,6 +5036,7 @@
 name: xxx-exec-1
 description:
 	Check that exec exits for built-ins
+need-ctty: yes
 arguments: !-i!
 stdin:
 	exec echo hi
@@ -4514,6 +5084,7 @@
 name: xxx-status-1
 description:
 	Check that blank lines don't clear $?
+need-ctty: yes
 arguments: !-i!
 stdin:
 	(exit 1)
@@ -4602,12 +5173,12 @@
 	Check some "exit on error" conditions
 stdin:
 	set -ex
-	/usr/bin/env false && echo something
+	env false && echo something
 	echo END
 expected-stdout:
 	END
 expected-stderr:
-	+ /usr/bin/env false
+	+ env false
 	+ echo END
 ---
 name: exit-err-2
@@ -4615,15 +5186,15 @@
 	Check some "exit on error" edge conditions (POSIXly)
 stdin:
 	set -ex
-	if /usr/bin/env true; then
-		/usr/bin/env false && echo something
+	if env true; then
+		env false && echo something
 	fi
 	echo END
 expected-stdout:
 	END
 expected-stderr:
-	+ /usr/bin/env true
-	+ /usr/bin/env false
+	+ env true
+	+ env false
 	+ echo END
 ---
 name: exit-err-3
@@ -4745,6 +5316,16 @@
 	E 0
 	F 0
 ---
+name: exit-trap-1
+description:
+	Check that "exit" with no arguments behaves SUSv4 conformant.
+stdin:
+	trap 'echo hi; exit' EXIT
+	exit 9
+expected-stdout:
+	hi
+expected-exit: 9
+---
 name: test-stlt-1
 description:
 	Check that test also can handle string1 < string2 etc.
@@ -4881,6 +5462,7 @@
 	Part 2: verify mkshrc can be read (interactive shells)
 file-setup: file 644 ".mkshrc"
 	FNORD=42
+need-ctty: yes
 arguments: !-i!
 env-setup: !HOME=.!ENV=!PS1=!
 stdin:
@@ -5004,6 +5586,7 @@
 name: pipeline-2
 description:
 	check that co-processes work with TCOMs, TPIPEs and TPARENs
+category: !nojsig
 stdin:
 	"$__progname" -c 'i=100; echo hi |& while read -p line; do echo "$((i++)) $line"; done'
 	"$__progname" -c 'i=200; echo hi | cat |& while read -p line; do echo "$((i++)) $line"; done'
@@ -5013,10 +5596,33 @@
 	200 hi
 	300 hi
 ---
+name: pipeline-3
+description:
+	Check that PIPESTATUS does what it's supposed to
+stdin:
+	echo 1 $PIPESTATUS .
+	echo 2 ${PIPESTATUS[0]} .
+	echo 3 ${PIPESTATUS[1]} .
+	(echo x; exit 12) | (cat; exit 23) | (cat; exit 42)
+	echo 5 $? , $PIPESTATUS , ${PIPESTATUS[0]} , ${PIPESTATUS[1]} , ${PIPESTATUS[2]} , ${PIPESTATUS[3]} .
+	echo 6 ${PIPESTATUS[0]} .
+	set | fgrep PIPESTATUS
+	echo 8 $(set | fgrep PIPESTATUS) .
+expected-stdout:
+	1 0 .
+	2 0 .
+	3 .
+	x
+	5 42 , 12 , 12 , 23 , 42 , .
+	6 0 .
+	PIPESTATUS[0]=0
+	8 PIPESTATUS[0]=0 PIPESTATUS[1]=0 .
+---
 name: persist-history-1
 description:
 	Check if persistent history saving works
 category: !no-histfile
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
@@ -5108,7 +5714,7 @@
 	mit
 	ohne
 	=
-	﻿: mit
+	﻿: ohne
 ---
 name: utf8bom-2
 description:
@@ -5139,12 +5745,17 @@
 name: utf8bom-3
 description:
 	Reading the UTF-8 BOM should enable the utf8-mode flag
+	(temporarily for COMSUBs)
 stdin:
 	"$__progname" -c ':; if [[ $- = *U* ]]; then echo 1 on; else echo 1 off; fi'
 	"$__progname" -c '﻿:; if [[ $- = *U* ]]; then echo 2 on; else echo 2 off; fi'
+	"$__progname" -c 'if [[ $- = *U* ]]; then echo 3 on; else echo 3 off; fi; x=$(﻿:; if [[ $- = *U* ]]; then echo 4 on; else echo 4 off; fi); echo $x; if [[ $- = *U* ]]; then echo 5 on; else echo 5 off; fi'
 expected-stdout:
 	1 off
 	2 on
+	3 off
+	4 on
+	5 off
 ---
 name: utf8opt-1a
 description:
@@ -5182,6 +5793,7 @@
 	-UMKSH_ASSUME_UTF8 => not expected, but if your OS is old,
 	 try passing HAVE_SETLOCALE_CTYPE=0 to Build.sh
 category: !os:hpux
+need-ctty: yes
 arguments: !-i!
 env-setup: !PS1=!PS2=!LC_CTYPE=en_US.UTF-8!
 stdin:
@@ -5200,6 +5812,7 @@
 	Check that the utf8-mode flag is set at interactive startup
 	Expected failure if -DMKSH_ASSUME_UTF8=0
 category: os:hpux
+need-ctty: yes
 arguments: !-i!
 env-setup: !PS1=!PS2=!LC_CTYPE=en_US.utf8!
 stdin:
@@ -5235,7 +5848,7 @@
 name: aliases-1
 description:
 	Check if built-in shell aliases are okay
-category: !arge
+category: !android,!arge
 stdin:
 	alias
 	typeset -f
@@ -5258,7 +5871,7 @@
 name: aliases-1-hartz4
 description:
 	Check if built-in shell aliases are okay
-category: arge
+category: android,arge
 stdin:
 	alias
 	typeset -f
@@ -5292,7 +5905,6 @@
 description:
 	Check if running as sh disables built-in aliases (except a few)
 category: disabled
-arguments: !-o!sh!
 stdin:
 	cp "$__progname" sh
 	./sh -c 'alias; typeset -f'
@@ -5304,7 +5916,7 @@
 name: aliases-2b
 description:
 	Check if “set -o sh” does not influence built-in aliases
-category: !arge
+category: !android,!arge
 arguments: !-o!sh!
 stdin:
 	alias
@@ -5328,8 +5940,7 @@
 name: aliases-3b
 description:
 	Check if running as sh does not influence built-in aliases
-category: !arge
-arguments: !-o!sh!
+category: !android,!arge
 stdin:
 	cp "$__progname" sh
 	./sh -c 'alias; typeset -f'
@@ -5353,7 +5964,7 @@
 name: aliases-2b-hartz4
 description:
 	Check if “set -o sh” does not influence built-in aliases
-category: arge
+category: android,arge
 arguments: !-o!sh!
 stdin:
 	alias
@@ -5375,8 +5986,7 @@
 name: aliases-3b-hartz4
 description:
 	Check if running as sh does not influence built-in aliases
-category: arge
-arguments: !-o!sh!
+category: android,arge
 stdin:
 	cp "$__progname" sh
 	./sh -c 'alias; typeset -f'
@@ -5431,6 +6041,17 @@
 expected-stdout:
 	makro
 ---
+name: aliases-funcdef-4
+description:
+	Functions should only take over if actually being defined
+stdin:
+	alias local
+	:|| local() { :; }
+	alias local
+expected-stdout:
+	local=typeset
+	local=typeset
+---
 name: arrays-1
 description:
 	Check if Korn Shell arrays work as expected
@@ -5646,6 +6267,29 @@
 	2g 009 .
 	2h 00001 00002 .
 ---
+name: arrays-9a
+description:
+	Check that we can concatenate arrays
+category: !smksh
+stdin:
+	unset foo; foo=(bar); foo+=(baz); echo 1 ${!foo[*]} : ${foo[*]} .
+	unset foo; foo=(foo bar); foo+=(baz); echo 2 ${!foo[*]} : ${foo[*]} .
+	unset foo; foo=([2]=foo [0]=bar); foo+=(baz [5]=quux); echo 3 ${!foo[*]} : ${foo[*]} .
+expected-stdout:
+	1 0 1 : bar baz .
+	2 0 1 2 : foo bar baz .
+	3 0 2 3 5 : bar foo baz quux .
+---
+name: arrays-9b
+description:
+	Check that we can concatenate parameters too
+stdin:
+	unset foo; foo=bar; foo+=baz; echo 1 $foo .
+	unset foo; typeset -i16 foo=10; foo+=20; echo 2 $foo .
+expected-stdout:
+	1 barbaz .
+	2 16#a20 .
+---
 name: varexpand-substr-1
 description:
 	Check if bash-style substring expansion works
@@ -5768,6 +6412,16 @@
 	c we
 	d we
 ---
+name: varexpand-special-hash
+description:
+	Check special ${var@x} expansion for x=hash
+stdin:
+	typeset -i8 foo=10
+	bar=baz
+	print ${bar@#} ${baz@#} .
+expected-stdout:
+	57F1BA9A 04808901 .
+---
 name: varexpand-null-1
 description:
 	Ensure empty strings expand emptily
@@ -5780,6 +6434,15 @@
 	z w
 	v u
 ---
+name: varexpand-null-2
+description:
+	Ensure empty strings, when quoted, are expanded as empty strings
+stdin:
+	printf '<%s> ' 1 "${a}" 2 "${a#?}" + "${b%?}" 3 "${a=}" + "${b/c/d}"
+	echo .
+expected-stdout:
+	<1> <> <2> <> <+> <> <3> <> <+> <> .
+---
 name: print-funny-chars
 description:
 	Check print builtin's capability to output designated characters
@@ -5865,6 +6528,22 @@
 	000000B0  E2 82 AC 64 20 EF BF BD - 20 12 33 20 78 20 53 20  |...d ... .3 x S |
 	000000C0  53 34 0A                -                          |S4.|
 ---
+name: dollar-doublequoted-strings
+description:
+	Check that a $ preceding "…" is ignored
+stdin:
+	echo $"Localise me!"
+	cat <<<$"Me too!"
+	V=X
+	aol=aol
+	cat <<-$"aol"
+		I do not take a $V for a V!
+	aol
+expected-stdout:
+	Localise me!
+	Me too!
+	I do not take a $V for a V!
+---
 name: dollar-quoted-strings
 description:
 	Check backslash expansion by $'…' strings
@@ -6338,8 +7017,9 @@
 description:
 	Check if we can use a specific syntax idiom for ulimit
 stdin:
-	if ! x=$(ulimit -d); then
-		echo expected to fail on this OS
+	if ! x=$(ulimit -d) || [[ $x = unknown ]]; then
+		#echo expected to fail on this OS
+		echo okay
 	else
 		ulimit -dS $x && echo okay
 	fi
@@ -6448,7 +7128,7 @@
 expected-stdout:
 	===
 	mir
-expected-stderr-pattern: /.*: cannot (create|overwrite) .*/
+expected-stderr-pattern: /.*: can't (create|overwrite) .*/
 ---
 name: bashiop-3b
 description:
@@ -6613,21 +7293,22 @@
 name: fd-cloexec-1
 description:
 	Verify that file descriptors > 2 are private for Korn shells
+	AT&T ksh93 does this still, which means we must keep it as well
 file-setup: file 644 "test.sh"
-	print -u3 Fowl
+	echo >&3 Fowl
 stdin:
 	exec 3>&1
 	"$__progname" test.sh
 expected-exit: e != 0
-expected-stderr:
-	test.sh[1]: print: -u: 3: bad file descriptor
+expected-stderr-pattern:
+	/bad file descriptor/
 ---
 name: fd-cloexec-2
 description:
 	Verify that file descriptors > 2 are not private for POSIX shells
 	See Debian Bug #154540, Closes: #499139
 file-setup: file 644 "test.sh"
-	print -u3 Fowl
+	echo >&3 Fowl
 stdin:
 	test -n "$POSH_VERSION" || set -o sh
 	exec 3>&1
@@ -6635,28 +7316,61 @@
 expected-stdout:
 	Fowl
 ---
-name: comsub-1
+name: comsub-1a
 description:
-	COMSUB are currently parsed by hacking lex.c instead of
-	recursively (see regression-6): matching parenthesēs bug
-	Fails on: pdksh mksh bash2 bash3 zsh
-	Passes on: bash4 ksh93
-expected-fail: yes
+	COMSUB are now parsed recursively, so this works
+	see also regression-6: matching parenthesēs bug
+	Fails on: pdksh bash2 bash3 zsh
+	Passes on: bash4 ksh93 mksh(20110313+)
 stdin:
 	echo $(case 1 in (1) echo yes;; (2) echo no;; esac)
 	echo $(case 1 in 1) echo yes;; 2) echo no;; esac)
+	TEST=1234; echo ${TEST: $(case 1 in (1) echo 1;; (*) echo 2;; esac)}
+	TEST=5678; echo ${TEST: $(case 1 in 1) echo 1;; *) echo 2;; esac)}
 expected-stdout:
 	yes
 	yes
+	234
+	678
+---
+name: comsub-1b
+description:
+	COMSUB are now parsed recursively, so this works
+	Fails on GNU bash even, ksh93 passes
+stdin:
+	echo $(($(case 1 in (1) echo 1;; (*) echo 2;; esac)+10))
+	echo $(($(case 1 in 1) echo 1;; *) echo 2;; esac)+20))
+	(( a = $(case 1 in (1) echo 1;; (*) echo 2;; esac) )); echo $a.
+	(( a = $(case 1 in 1) echo 1;; *) echo 2;; esac) )); echo $a.
+expected-stdout:
+	11
+	21
+	1.
+	1.
+---
+name: comsub-1c
+description:
+	COMSUB are now parsed recursively, so this works (ksh93, mksh)
+	First test passes on bash4, second fails there
+category: !smksh
+stdin:
+	a=($(case 1 in (1) echo 1;; (*) echo 2;; esac)); echo ${a[0]}.
+	a=($(case 1 in 1) echo 1;; *) echo 2;; esac)); echo ${a[0]}.
+	a=($(($(case 1 in (1) echo 1;; (*) echo 2;; esac)+10))); echo ${a[0]}.
+	a=($(($(case 1 in 1) echo 1;; *) echo 2;; esac)+20))); echo ${a[0]}.
+expected-stdout:
+	1.
+	1.
+	11.
+	21.
 ---
 name: comsub-2
 description:
 	RedHat BZ#496791 – another case of missing recursion
 	in parsing COMSUB expressions
-	Fails on: pdksh mksh bash2 bash3¹ bash4¹ zsh
-	Passes on: ksh93
+	Fails on: pdksh bash2 bash3¹ bash4¹ zsh
+	Passes on: ksh93 mksh(20110305+)
 	① bash[34] seem to choke on comment ending with backslash-newline
-expected-fail: yes
 stdin:
 	# a comment with " ' \
 	x=$(
@@ -6667,6 +7381,688 @@
 expected-stdout:
 	yes
 ---
+name: comsub-3
+description:
+	Extended test for COMSUB explaining why a recursive parser
+	is a must (a non-recursive parser cannot pass all three of
+	these test cases, especially the ‘#’ is difficult)
+stdin:
+	echo $(typeset -i10 x=16#20; echo $x)
+	echo $(typeset -Uui16 x=16#$(id -u)
+	) .
+	echo $(c=1; d=1
+	typeset -Uui16 a=36#foo; c=2
+	typeset -Uui16 b=36 #foo; d=2
+	echo $a $b $c $d)
+expected-stdout:
+	32
+	.
+	16#4F68 16#24 2 1
+---
+name: comsub-torture
+description:
+	Check the tree dump functions work correctly
+stdin:
+	if [[ -z $__progname ]]; then echo >&2 call me with __progname; exit 1; fi
+	while IFS= read -r line; do
+		if [[ $line = '#1' ]]; then
+			lastf=0
+			continue
+		elif [[ $line = EOFN* ]]; then
+			fbody=$fbody$'\n'$line
+			continue
+		elif [[ $line != '#'* ]]; then
+			fbody=$fbody$'\n\t'$line
+			continue
+		fi
+		if (( lastf )); then
+			x="inline_${nextf}() {"$fbody$'\n}\n'
+			print -nr -- "$x"
+			print -r -- "${x}typeset -f inline_$nextf" | "$__progname"
+			x="function comsub_$nextf { x=\$("$fbody$'\n); }\n'
+			print -nr -- "$x"
+			print -r -- "${x}typeset -f comsub_$nextf" | "$__progname"
+			x="function reread_$nextf { x=\$(("$fbody$'\n)|tr u x); }\n'
+			print -nr -- "$x"
+			print -r -- "${x}typeset -f reread_$nextf" | "$__progname"
+		fi
+		lastf=1
+		fbody=
+		nextf=${line#?}
+	done <<'EOD'
+	#1
+	#TCOM
+	vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4"
+	#TPAREN_TPIPE_TLIST
+	(echo $foo  |  tr -dc 0-9; echo)
+	#TAND_TOR
+	cmd  &&  echo ja  ||  echo nein
+	#TSELECT
+	select  file  in  *;  do  echo  "<$file>" ;  break ;  done
+	#TFOR_TTIME
+	for  i  in  {1,2,3}  ;  do  time  echo  $i ;  done
+	#TCASE
+	case  $foo  in  1)  echo eins;; 2) echo zwei  ;; *) echo kann net bis drei zählen;;  esac
+	#TIF_TBANG_TDBRACKET_TELIF
+	if  !  [[  1  =  1  ]]  ;  then  echo eins;  elif [[ 1 = 2 ]]; then echo zwei  ;else echo drei; fi
+	#TWHILE
+	i=1; while (( i < 10 )); do echo $i; let ++i; done
+	#TUNTIL
+	i=10; until  (( !--i )) ; do echo $i; done
+	#TCOPROC
+	cat  *  |&  ls
+	#TFUNCT_TBRACE_TASYNC
+	function  korn  {  echo eins; echo zwei ;  }
+	bourne  ()  {  logger *  &  }
+	#IOREAD_IOCAT
+	tr  x  u  0<foo  >>bar
+	#IOWRITE_IOCLOB_IOHERE_noIOSKIP
+	cat  >|bar  <<'EOFN'
+	foo
+	EOFN
+	#IOWRITE_noIOCLOB_IOHERE_IOSKIP
+	cat  1>bar  <<-EOFI
+	foo
+	EOFI
+	#IORDWR_IODUP
+	sh  1<>/dev/console  0<&1  2>&1
+	#COMSUB_EXPRSUB
+	echo $(true) $((1+ 2))
+	#QCHAR_OQUOTE_CQUOTE
+	echo fo\ob\"a\`r\'b\$az
+	echo "fo\ob\"a\`r\'b\$az"
+	echo 'fo\ob\"a\`r'\''b\$az'
+	#OSUBST_CSUBST_OPAT_SPAT_CPAT
+	[[ ${foo#bl\(u\)b} = @(bar|baz) ]]
+	#heredoc_closed
+	x=$(cat <<EOFN
+	note there must be no space between EOFN and )
+	EOFN); echo $x
+	#heredoc_space
+	x=$(cat <<EOFN\ 
+	note the space between EOFN and ) is actually part of the here document marker
+	EOFN ); echo $x
+	#patch_motd
+	x=$(sysctl -n kern.version | sed 1q)
+	[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd)" != $x ]] && \
+	    ed -s /etc/motd 2>&1 <<-EOF
+		1,/^\$/d
+		0a
+			$x
+	
+		.
+		wq
+	EOF)" = @(?) ]] && rm -f /etc/motd
+	if [[ ! -s /etc/motd ]]; then
+		install -c -o root -g wheel -m 664 /dev/null /etc/motd
+		print -- "$x\n" >/etc/motd
+	fi
+	#0
+	EOD
+expected-stdout:
+	inline_TCOM() {
+		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4"
+	}
+	inline_TCOM() {
+		vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" 
+	} 
+	function comsub_TCOM { x=$(
+		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4"
+	); }
+	function comsub_TCOM {
+		x=$(vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" ) 
+	} 
+	function reread_TCOM { x=$((
+		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4"
+	)|tr u x); }
+	function reread_TCOM {
+		x=$(( vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" ) | tr u x ) 
+	} 
+	inline_TPAREN_TPIPE_TLIST() {
+		(echo $foo  |  tr -dc 0-9; echo)
+	}
+	inline_TPAREN_TPIPE_TLIST() {
+		( echo $foo | tr -dc 0-9 
+		  echo ) 
+	} 
+	function comsub_TPAREN_TPIPE_TLIST { x=$(
+		(echo $foo  |  tr -dc 0-9; echo)
+	); }
+	function comsub_TPAREN_TPIPE_TLIST {
+		x=$(( echo $foo | tr -dc 0-9 ; echo ) ) 
+	} 
+	function reread_TPAREN_TPIPE_TLIST { x=$((
+		(echo $foo  |  tr -dc 0-9; echo)
+	)|tr u x); }
+	function reread_TPAREN_TPIPE_TLIST {
+		x=$(( ( echo $foo | tr -dc 0-9 ; echo ) ) | tr u x ) 
+	} 
+	inline_TAND_TOR() {
+		cmd  &&  echo ja  ||  echo nein
+	}
+	inline_TAND_TOR() {
+		cmd && echo ja || echo nein 
+	} 
+	function comsub_TAND_TOR { x=$(
+		cmd  &&  echo ja  ||  echo nein
+	); }
+	function comsub_TAND_TOR {
+		x=$(cmd && echo ja || echo nein ) 
+	} 
+	function reread_TAND_TOR { x=$((
+		cmd  &&  echo ja  ||  echo nein
+	)|tr u x); }
+	function reread_TAND_TOR {
+		x=$(( cmd && echo ja || echo nein ) | tr u x ) 
+	} 
+	inline_TSELECT() {
+		select  file  in  *;  do  echo  "<$file>" ;  break ;  done
+	}
+	inline_TSELECT() {
+		select file in * 
+		do
+			echo "<$file>" 
+			break 
+		done 
+	} 
+	function comsub_TSELECT { x=$(
+		select  file  in  *;  do  echo  "<$file>" ;  break ;  done
+	); }
+	function comsub_TSELECT {
+		x=$(select file in * ; do echo "<$file>" ; break ; done ) 
+	} 
+	function reread_TSELECT { x=$((
+		select  file  in  *;  do  echo  "<$file>" ;  break ;  done
+	)|tr u x); }
+	function reread_TSELECT {
+		x=$(( select file in * ; do echo "<$file>" ; break ; done ) | tr u x ) 
+	} 
+	inline_TFOR_TTIME() {
+		for  i  in  {1,2,3}  ;  do  time  echo  $i ;  done
+	}
+	inline_TFOR_TTIME() {
+		for i in {1,2,3} 
+		do
+			time echo $i 
+		done 
+	} 
+	function comsub_TFOR_TTIME { x=$(
+		for  i  in  {1,2,3}  ;  do  time  echo  $i ;  done
+	); }
+	function comsub_TFOR_TTIME {
+		x=$(for i in {1,2,3} ; do time echo $i ; done ) 
+	} 
+	function reread_TFOR_TTIME { x=$((
+		for  i  in  {1,2,3}  ;  do  time  echo  $i ;  done
+	)|tr u x); }
+	function reread_TFOR_TTIME {
+		x=$(( for i in {1,2,3} ; do time echo $i ; done ) | tr u x ) 
+	} 
+	inline_TCASE() {
+		case  $foo  in  1)  echo eins;; 2) echo zwei  ;; *) echo kann net bis drei zählen;;  esac
+	}
+	inline_TCASE() {
+		case $foo in
+		(1)
+			echo eins 
+			;;
+		(2)
+			echo zwei 
+			;;
+		(*)
+			echo kann net bis drei zählen 
+			;;
+		esac 
+	} 
+	function comsub_TCASE { x=$(
+		case  $foo  in  1)  echo eins;; 2) echo zwei  ;; *) echo kann net bis drei zählen;;  esac
+	); }
+	function comsub_TCASE {
+		x=$(case $foo in (1) echo eins  ;; (2) echo zwei  ;; (*) echo kann net bis drei zählen  ;; esac ) 
+	} 
+	function reread_TCASE { x=$((
+		case  $foo  in  1)  echo eins;; 2) echo zwei  ;; *) echo kann net bis drei zählen;;  esac
+	)|tr u x); }
+	function reread_TCASE {
+		x=$(( case $foo in (1) echo eins  ;; (2) echo zwei  ;; (*) echo kann net bis drei zählen  ;; esac ) | tr u x ) 
+	} 
+	inline_TIF_TBANG_TDBRACKET_TELIF() {
+		if  !  [[  1  =  1  ]]  ;  then  echo eins;  elif [[ 1 = 2 ]]; then echo zwei  ;else echo drei; fi
+	}
+	inline_TIF_TBANG_TDBRACKET_TELIF() {
+		if ! [[ 1 = 1 ]] 
+		then
+			echo eins 
+		elif [[ 1 = 2 ]] 
+		then
+			echo zwei 
+		else
+			echo drei 
+		fi 
+	} 
+	function comsub_TIF_TBANG_TDBRACKET_TELIF { x=$(
+		if  !  [[  1  =  1  ]]  ;  then  echo eins;  elif [[ 1 = 2 ]]; then echo zwei  ;else echo drei; fi
+	); }
+	function comsub_TIF_TBANG_TDBRACKET_TELIF {
+		x=$(if ! [[ 1 = 1 ]] ; then echo eins ; elif [[ 1 = 2 ]] ; then echo zwei ; else echo drei ; fi ) 
+	} 
+	function reread_TIF_TBANG_TDBRACKET_TELIF { x=$((
+		if  !  [[  1  =  1  ]]  ;  then  echo eins;  elif [[ 1 = 2 ]]; then echo zwei  ;else echo drei; fi
+	)|tr u x); }
+	function reread_TIF_TBANG_TDBRACKET_TELIF {
+		x=$(( if ! [[ 1 = 1 ]] ; then echo eins ; elif [[ 1 = 2 ]] ; then echo zwei ; else echo drei ; fi ) | tr u x ) 
+	} 
+	inline_TWHILE() {
+		i=1; while (( i < 10 )); do echo $i; let ++i; done
+	}
+	inline_TWHILE() {
+		i=1 
+		while let " i < 10 " 
+		do
+			echo $i 
+			let ++i 
+		done 
+	} 
+	function comsub_TWHILE { x=$(
+		i=1; while (( i < 10 )); do echo $i; let ++i; done
+	); }
+	function comsub_TWHILE {
+		x=$(i=1 ; while let " i < 10 " ; do echo $i ; let ++i ; done ) 
+	} 
+	function reread_TWHILE { x=$((
+		i=1; while (( i < 10 )); do echo $i; let ++i; done
+	)|tr u x); }
+	function reread_TWHILE {
+		x=$(( i=1 ; while let " i < 10 " ; do echo $i ; let ++i ; done ) | tr u x ) 
+	} 
+	inline_TUNTIL() {
+		i=10; until  (( !--i )) ; do echo $i; done
+	}
+	inline_TUNTIL() {
+		i=10 
+		until let " !--i " 
+		do
+			echo $i 
+		done 
+	} 
+	function comsub_TUNTIL { x=$(
+		i=10; until  (( !--i )) ; do echo $i; done
+	); }
+	function comsub_TUNTIL {
+		x=$(i=10 ; until let " !--i " ; do echo $i ; done ) 
+	} 
+	function reread_TUNTIL { x=$((
+		i=10; until  (( !--i )) ; do echo $i; done
+	)|tr u x); }
+	function reread_TUNTIL {
+		x=$(( i=10 ; until let " !--i " ; do echo $i ; done ) | tr u x ) 
+	} 
+	inline_TCOPROC() {
+		cat  *  |&  ls
+	}
+	inline_TCOPROC() {
+		cat * |& 
+		ls 
+	} 
+	function comsub_TCOPROC { x=$(
+		cat  *  |&  ls
+	); }
+	function comsub_TCOPROC {
+		x=$(cat * |&  ls ) 
+	} 
+	function reread_TCOPROC { x=$((
+		cat  *  |&  ls
+	)|tr u x); }
+	function reread_TCOPROC {
+		x=$(( cat * |&  ls ) | tr u x ) 
+	} 
+	inline_TFUNCT_TBRACE_TASYNC() {
+		function  korn  {  echo eins; echo zwei ;  }
+		bourne  ()  {  logger *  &  }
+	}
+	inline_TFUNCT_TBRACE_TASYNC() {
+		function korn {
+			echo eins 
+			echo zwei 
+		} 
+		bourne() {
+			logger * & 
+		} 
+	} 
+	function comsub_TFUNCT_TBRACE_TASYNC { x=$(
+		function  korn  {  echo eins; echo zwei ;  }
+		bourne  ()  {  logger *  &  }
+	); }
+	function comsub_TFUNCT_TBRACE_TASYNC {
+		x=$(function korn { echo eins ; echo zwei ; } ; bourne() { logger * &  } ) 
+	} 
+	function reread_TFUNCT_TBRACE_TASYNC { x=$((
+		function  korn  {  echo eins; echo zwei ;  }
+		bourne  ()  {  logger *  &  }
+	)|tr u x); }
+	function reread_TFUNCT_TBRACE_TASYNC {
+		x=$(( function korn { echo eins ; echo zwei ; } ; bourne() { logger * &  } ) | tr u x ) 
+	} 
+	inline_IOREAD_IOCAT() {
+		tr  x  u  0<foo  >>bar
+	}
+	inline_IOREAD_IOCAT() {
+		tr x u <foo >>bar 
+	} 
+	function comsub_IOREAD_IOCAT { x=$(
+		tr  x  u  0<foo  >>bar
+	); }
+	function comsub_IOREAD_IOCAT {
+		x=$(tr x u <foo >>bar ) 
+	} 
+	function reread_IOREAD_IOCAT { x=$((
+		tr  x  u  0<foo  >>bar
+	)|tr u x); }
+	function reread_IOREAD_IOCAT {
+		x=$(( tr x u <foo >>bar ) | tr u x ) 
+	} 
+	inline_IOWRITE_IOCLOB_IOHERE_noIOSKIP() {
+		cat  >|bar  <<'EOFN'
+		foo
+	EOFN
+	}
+	inline_IOWRITE_IOCLOB_IOHERE_noIOSKIP() {
+		cat >|bar <<"EOFN" 
+		foo
+	EOFN
+	
+	} 
+	function comsub_IOWRITE_IOCLOB_IOHERE_noIOSKIP { x=$(
+		cat  >|bar  <<'EOFN'
+		foo
+	EOFN
+	); }
+	function comsub_IOWRITE_IOCLOB_IOHERE_noIOSKIP {
+		x=$(cat >|bar <<"EOFN" 
+		foo
+	EOFN
+	) 
+	} 
+	function reread_IOWRITE_IOCLOB_IOHERE_noIOSKIP { x=$((
+		cat  >|bar  <<'EOFN'
+		foo
+	EOFN
+	)|tr u x); }
+	function reread_IOWRITE_IOCLOB_IOHERE_noIOSKIP {
+		x=$(( cat >|bar <<"EOFN" 
+		foo
+	EOFN
+	) | tr u x ) 
+	} 
+	inline_IOWRITE_noIOCLOB_IOHERE_IOSKIP() {
+		cat  1>bar  <<-EOFI
+		foo
+		EOFI
+	}
+	inline_IOWRITE_noIOCLOB_IOHERE_IOSKIP() {
+		cat >bar <<-EOFI 
+	foo
+	EOFI
+	
+	} 
+	function comsub_IOWRITE_noIOCLOB_IOHERE_IOSKIP { x=$(
+		cat  1>bar  <<-EOFI
+		foo
+		EOFI
+	); }
+	function comsub_IOWRITE_noIOCLOB_IOHERE_IOSKIP {
+		x=$(cat >bar <<-EOFI 
+	foo
+	EOFI
+	) 
+	} 
+	function reread_IOWRITE_noIOCLOB_IOHERE_IOSKIP { x=$((
+		cat  1>bar  <<-EOFI
+		foo
+		EOFI
+	)|tr u x); }
+	function reread_IOWRITE_noIOCLOB_IOHERE_IOSKIP {
+		x=$(( cat >bar <<-EOFI 
+	foo
+	EOFI
+	) | tr u x ) 
+	} 
+	inline_IORDWR_IODUP() {
+		sh  1<>/dev/console  0<&1  2>&1
+	}
+	inline_IORDWR_IODUP() {
+		sh 1<>/dev/console <&1 2>&1 
+	} 
+	function comsub_IORDWR_IODUP { x=$(
+		sh  1<>/dev/console  0<&1  2>&1
+	); }
+	function comsub_IORDWR_IODUP {
+		x=$(sh 1<>/dev/console <&1 2>&1 ) 
+	} 
+	function reread_IORDWR_IODUP { x=$((
+		sh  1<>/dev/console  0<&1  2>&1
+	)|tr u x); }
+	function reread_IORDWR_IODUP {
+		x=$(( sh 1<>/dev/console <&1 2>&1 ) | tr u x ) 
+	} 
+	inline_COMSUB_EXPRSUB() {
+		echo $(true) $((1+ 2))
+	}
+	inline_COMSUB_EXPRSUB() {
+		echo $(true ) $((1+ 2)) 
+	} 
+	function comsub_COMSUB_EXPRSUB { x=$(
+		echo $(true) $((1+ 2))
+	); }
+	function comsub_COMSUB_EXPRSUB {
+		x=$(echo $(true ) $((1+ 2)) ) 
+	} 
+	function reread_COMSUB_EXPRSUB { x=$((
+		echo $(true) $((1+ 2))
+	)|tr u x); }
+	function reread_COMSUB_EXPRSUB {
+		x=$(( echo $(true ) $((1+ 2)) ) | tr u x ) 
+	} 
+	inline_QCHAR_OQUOTE_CQUOTE() {
+		echo fo\ob\"a\`r\'b\$az
+		echo "fo\ob\"a\`r\'b\$az"
+		echo 'fo\ob\"a\`r'\''b\$az'
+	}
+	inline_QCHAR_OQUOTE_CQUOTE() {
+		echo fo\ob\"a\`r\'b\$az 
+		echo "fo\ob\"a\`r\'b\$az" 
+		echo "fo\\ob\\\"a\\\`r"\'"b\\\$az" 
+	} 
+	function comsub_QCHAR_OQUOTE_CQUOTE { x=$(
+		echo fo\ob\"a\`r\'b\$az
+		echo "fo\ob\"a\`r\'b\$az"
+		echo 'fo\ob\"a\`r'\''b\$az'
+	); }
+	function comsub_QCHAR_OQUOTE_CQUOTE {
+		x=$(echo fo\ob\"a\`r\'b\$az ; echo "fo\ob\"a\`r\'b\$az" ; echo "fo\\ob\\\"a\\\`r"\'"b\\\$az" ) 
+	} 
+	function reread_QCHAR_OQUOTE_CQUOTE { x=$((
+		echo fo\ob\"a\`r\'b\$az
+		echo "fo\ob\"a\`r\'b\$az"
+		echo 'fo\ob\"a\`r'\''b\$az'
+	)|tr u x); }
+	function reread_QCHAR_OQUOTE_CQUOTE {
+		x=$(( echo fo\ob\"a\`r\'b\$az ; echo "fo\ob\"a\`r\'b\$az" ; echo "fo\\ob\\\"a\\\`r"\'"b\\\$az" ) | tr u x ) 
+	} 
+	inline_OSUBST_CSUBST_OPAT_SPAT_CPAT() {
+		[[ ${foo#bl\(u\)b} = @(bar|baz) ]]
+	}
+	inline_OSUBST_CSUBST_OPAT_SPAT_CPAT() {
+		[[ ${foo#bl\(u\)b} = @(bar|baz) ]] 
+	} 
+	function comsub_OSUBST_CSUBST_OPAT_SPAT_CPAT { x=$(
+		[[ ${foo#bl\(u\)b} = @(bar|baz) ]]
+	); }
+	function comsub_OSUBST_CSUBST_OPAT_SPAT_CPAT {
+		x=$([[ ${foo#bl\(u\)b} = @(bar|baz) ]] ) 
+	} 
+	function reread_OSUBST_CSUBST_OPAT_SPAT_CPAT { x=$((
+		[[ ${foo#bl\(u\)b} = @(bar|baz) ]]
+	)|tr u x); }
+	function reread_OSUBST_CSUBST_OPAT_SPAT_CPAT {
+		x=$(( [[ ${foo#bl\(u\)b} = @(bar|baz) ]] ) | tr u x ) 
+	} 
+	inline_heredoc_closed() {
+		x=$(cat <<EOFN
+		note there must be no space between EOFN and )
+	EOFN); echo $x
+	}
+	inline_heredoc_closed() {
+		x=$(cat <<EOFN 
+		note there must be no space between EOFN and )
+	EOFN
+	) 
+		echo $x 
+	} 
+	function comsub_heredoc_closed { x=$(
+		x=$(cat <<EOFN
+		note there must be no space between EOFN and )
+	EOFN); echo $x
+	); }
+	function comsub_heredoc_closed {
+		x=$(x=$(cat <<EOFN 
+		note there must be no space between EOFN and )
+	EOFN
+	) ; echo $x ) 
+	} 
+	function reread_heredoc_closed { x=$((
+		x=$(cat <<EOFN
+		note there must be no space between EOFN and )
+	EOFN); echo $x
+	)|tr u x); }
+	function reread_heredoc_closed {
+		x=$(( x=$(cat <<EOFN 
+		note there must be no space between EOFN and )
+	EOFN
+	) ; echo $x ) | tr u x ) 
+	} 
+	inline_heredoc_space() {
+		x=$(cat <<EOFN\ 
+		note the space between EOFN and ) is actually part of the here document marker
+	EOFN ); echo $x
+	}
+	inline_heredoc_space() {
+		x=$(cat <<EOFN\  
+		note the space between EOFN and ) is actually part of the here document marker
+	EOFN 
+	) 
+		echo $x 
+	} 
+	function comsub_heredoc_space { x=$(
+		x=$(cat <<EOFN\ 
+		note the space between EOFN and ) is actually part of the here document marker
+	EOFN ); echo $x
+	); }
+	function comsub_heredoc_space {
+		x=$(x=$(cat <<EOFN\  
+		note the space between EOFN and ) is actually part of the here document marker
+	EOFN 
+	) ; echo $x ) 
+	} 
+	function reread_heredoc_space { x=$((
+		x=$(cat <<EOFN\ 
+		note the space between EOFN and ) is actually part of the here document marker
+	EOFN ); echo $x
+	)|tr u x); }
+	function reread_heredoc_space {
+		x=$(( x=$(cat <<EOFN\  
+		note the space between EOFN and ) is actually part of the here document marker
+	EOFN 
+	) ; echo $x ) | tr u x ) 
+	} 
+	inline_patch_motd() {
+		x=$(sysctl -n kern.version | sed 1q)
+		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd)" != $x ]] && \
+		    ed -s /etc/motd 2>&1 <<-EOF
+			1,/^\$/d
+			0a
+				$x
+		
+			.
+			wq
+		EOF)" = @(?) ]] && rm -f /etc/motd
+		if [[ ! -s /etc/motd ]]; then
+			install -c -o root -g wheel -m 664 /dev/null /etc/motd
+			print -- "$x\n" >/etc/motd
+		fi
+	}
+	inline_patch_motd() {
+		x=$(sysctl -n kern.version | sed 1q ) 
+		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF 
+	1,/^\$/d
+	0a
+	$x
+	
+	.
+	wq
+	EOF
+	)" = @(?) ]] && rm -f /etc/motd 
+		if [[ ! -s /etc/motd ]] 
+		then
+			install -c -o root -g wheel -m 664 /dev/null /etc/motd 
+			print -- "$x\n" >/etc/motd 
+		fi 
+	} 
+	function comsub_patch_motd { x=$(
+		x=$(sysctl -n kern.version | sed 1q)
+		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd)" != $x ]] && \
+		    ed -s /etc/motd 2>&1 <<-EOF
+			1,/^\$/d
+			0a
+				$x
+		
+			.
+			wq
+		EOF)" = @(?) ]] && rm -f /etc/motd
+		if [[ ! -s /etc/motd ]]; then
+			install -c -o root -g wheel -m 664 /dev/null /etc/motd
+			print -- "$x\n" >/etc/motd
+		fi
+	); }
+	function comsub_patch_motd {
+		x=$(x=$(sysctl -n kern.version | sed 1q ) ; [[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF 
+	1,/^\$/d
+	0a
+	$x
+	
+	.
+	wq
+	EOF
+	)" = @(?) ]] && rm -f /etc/motd ; if [[ ! -s /etc/motd ]] ; then install -c -o root -g wheel -m 664 /dev/null /etc/motd ; print -- "$x\n" >/etc/motd ; fi ) 
+	} 
+	function reread_patch_motd { x=$((
+		x=$(sysctl -n kern.version | sed 1q)
+		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd)" != $x ]] && \
+		    ed -s /etc/motd 2>&1 <<-EOF
+			1,/^\$/d
+			0a
+				$x
+		
+			.
+			wq
+		EOF)" = @(?) ]] && rm -f /etc/motd
+		if [[ ! -s /etc/motd ]]; then
+			install -c -o root -g wheel -m 664 /dev/null /etc/motd
+			print -- "$x\n" >/etc/motd
+		fi
+	)|tr u x); }
+	function reread_patch_motd {
+		x=$(( x=$(sysctl -n kern.version | sed 1q ) ; [[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF 
+	1,/^\$/d
+	0a
+	$x
+	
+	.
+	wq
+	EOF
+	)" = @(?) ]] && rm -f /etc/motd ; if [[ ! -s /etc/motd ]] ; then install -c -o root -g wheel -m 664 /dev/null /etc/motd ; print -- "$x\n" >/etc/motd ; fi ) | tr u x ) 
+	} 
+---
 name: test-stnze-1
 description:
 	Check that the short form [ $x ] works
@@ -6768,6 +8164,7 @@
 file-setup: file 755 "!false"
 	#! /bin/sh
 	echo si
+need-ctty: yes
 arguments: !-i!
 stdin:
 	export PATH=.:$PATH
@@ -6796,6 +8193,7 @@
 file-setup: file 755 "!"
 	#! /bin/sh
 	echo si
+need-ctty: yes
 arguments: !-i!
 stdin:
 	export PATH=.:$PATH
@@ -6822,6 +8220,7 @@
 file-setup: file 755 "!"
 	#! /bin/sh
 	echo si
+need-ctty: yes
 arguments: !-i!
 env-setup: !ENV=./Env!
 file-setup: file 644 "Env"
@@ -7049,7 +8448,7 @@
 description:
 	Check support for ((…)) and $((…)) vs (…) and $(…)
 stdin:
-	if ( (echo fubar) | tr u x); then
+	if ( (echo fubar)|tr u x); then
 		echo ja
 	else
 		echo nein
@@ -7062,7 +8461,15 @@
 description:
 	Check support for ((…)) and $((…)) vs (…) and $(…)
 stdin:
-	echo $( (echo fubar) | tr u x) $?
+	echo $( (echo fubar)|tr u x) $?
+expected-stdout:
+	fxbar 0
+---
+name: better-parens-1c
+description:
+	Check support for ((…)) and $((…)) vs (…) and $(…)
+stdin:
+	x=$( (echo fubar)|tr u x); echo $x $?
 expected-stdout:
 	fxbar 0
 ---
@@ -7070,7 +8477,7 @@
 description:
 	Check support for ((…)) and $((…)) vs (…) and $(…)
 stdin:
-	if ((echo fubar) | tr u x); then
+	if ((echo fubar)|tr u x); then
 		echo ja
 	else
 		echo nein
@@ -7083,7 +8490,15 @@
 description:
 	Check support for ((…)) and $((…)) vs (…) and $(…)
 stdin:
-	echo $((echo fubar) | tr u x) $?
+	echo $((echo fubar)|tr u x) $?
+expected-stdout:
+	fxbar 0
+---
+name: better-parens-2c
+description:
+	Check support for ((…)) and $((…)) vs (…) and $(…)
+stdin:
+	x=$((echo fubar)|tr u x); echo $x $?
 expected-stdout:
 	fxbar 0
 ---
@@ -7091,7 +8506,7 @@
 description:
 	Check support for ((…)) and $((…)) vs (…) and $(…)
 stdin:
-	if ( (echo fubar) | (tr u x)); then
+	if ( (echo fubar)|(tr u x)); then
 		echo ja
 	else
 		echo nein
@@ -7104,7 +8519,15 @@
 description:
 	Check support for ((…)) and $((…)) vs (…) and $(…)
 stdin:
-	echo $( (echo fubar) | (tr u x)) $?
+	echo $( (echo fubar)|(tr u x)) $?
+expected-stdout:
+	fxbar 0
+---
+name: better-parens-3c
+description:
+	Check support for ((…)) and $((…)) vs (…) and $(…)
+stdin:
+	x=$( (echo fubar)|(tr u x)); echo $x $?
 expected-stdout:
 	fxbar 0
 ---
@@ -7112,7 +8535,7 @@
 description:
 	Check support for ((…)) and $((…)) vs (…) and $(…)
 stdin:
-	if ((echo fubar) | (tr u x)); then
+	if ((echo fubar)|(tr u x)); then
 		echo ja
 	else
 		echo nein
@@ -7125,7 +8548,15 @@
 description:
 	Check support for ((…)) and $((…)) vs (…) and $(…)
 stdin:
-	echo $((echo fubar) | (tr u x)) $?
+	echo $((echo fubar)|(tr u x)) $?
+expected-stdout:
+	fxbar 0
+---
+name: better-parens-4c
+description:
+	Check support for ((…)) and $((…)) vs (…) and $(…)
+stdin:
+	x=$((echo fubar)|(tr u x)); echo $x $?
 expected-stdout:
 	fxbar 0
 ---
@@ -7262,3 +8693,155 @@
 expected-stdout:
 	1 .
 ---
+name: realpath-1
+description:
+	Check proper return values for realpath
+category: os:mirbsd
+stdin:
+	wd=$(realpath .)
+	mkdir dir
+	:>file
+	:>dir/file
+	ln -s dir lndir
+	ln -s file lnfile
+	ln -s nix lnnix
+	ln -s . lnself
+	i=0
+	chk() {
+		typeset x y
+		x=$(realpath "$wd/$1" 2>&1); y=$?
+		print $((++i)) "?$1" =${x##*$wd/} !$y
+	}
+	chk dir
+	chk dir/
+	chk dir/file
+	chk dir/nix
+	chk file
+	chk file/
+	chk file/file
+	chk file/nix
+	chk nix
+	chk nix/
+	chk nix/file
+	chk nix/nix
+	chk lndir
+	chk lndir/
+	chk lndir/file
+	chk lndir/nix
+	chk lnfile
+	chk lnfile/
+	chk lnfile/file
+	chk lnfile/nix
+	chk lnnix
+	chk lnnix/
+	chk lnnix/file
+	chk lnnix/nix
+	chk lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself
+	rm lnself
+expected-stdout:
+	1 ?dir =dir !0
+	2 ?dir/ =dir !0
+	3 ?dir/file =dir/file !0
+	4 ?dir/nix =dir/nix !0
+	5 ?file =file !0
+	6 ?file/ =file/: Not a directory !20
+	7 ?file/file =file/file: Not a directory !20
+	8 ?file/nix =file/nix: Not a directory !20
+	9 ?nix =nix !0
+	10 ?nix/ =nix !0
+	11 ?nix/file =nix/file: No such file or directory !2
+	12 ?nix/nix =nix/nix: No such file or directory !2
+	13 ?lndir =dir !0
+	14 ?lndir/ =dir !0
+	15 ?lndir/file =dir/file !0
+	16 ?lndir/nix =dir/nix !0
+	17 ?lnfile =file !0
+	18 ?lnfile/ =lnfile/: Not a directory !20
+	19 ?lnfile/file =lnfile/file: Not a directory !20
+	20 ?lnfile/nix =lnfile/nix: Not a directory !20
+	21 ?lnnix =nix !0
+	22 ?lnnix/ =nix !0
+	23 ?lnnix/file =lnnix/file: No such file or directory !2
+	24 ?lnnix/nix =lnnix/nix: No such file or directory !2
+	25 ?lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself =lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself: Too many levels of symbolic links !62
+---
+name: realpath-2
+description:
+	Ensure that exactly two leading slashes are not collapsed
+	POSIX guarantees this exception, e.g. for UNC paths on Cygwin
+category: os:mirbsd
+stdin:
+	ln -s /bin t1
+	ln -s //bin t2
+	ln -s ///bin t3
+	realpath /bin
+	realpath //bin
+	realpath ///bin
+	realpath /usr/bin
+	realpath /usr//bin
+	realpath /usr///bin
+	realpath t1
+	realpath t2
+	realpath t3
+	rm -f t1 t2 t3
+	cd //usr/bin
+	pwd
+	cd ../lib
+	pwd
+	realpath //usr/include/../bin
+expected-stdout:
+	/bin
+	//bin
+	/bin
+	/usr/bin
+	/usr/bin
+	/usr/bin
+	/bin
+	//bin
+	/bin
+	//usr/bin
+	//usr/lib
+	//usr/bin
+---
+name: crash-1
+description:
+	Crashed during March 2011, fixed on vernal equinōx ☺
+category: os:mirbsd,os:openbsd
+stdin:
+	export MALLOC_OPTIONS=FGJPRSX
+	"$__progname" -c 'x=$(tr z r <<<baz); echo $x'
+expected-stdout:
+	bar
+---
+name: debian-117-1
+description:
+	Check test - bug#465250
+stdin:
+	test \( ! -e \) ; echo $?
+expected-stdout:
+	1
+---
+name: debian-117-2
+description:
+	Check test - bug#465250
+stdin:
+	test \(  -e \) ; echo $?
+expected-stdout:
+	0
+---
+name: debian-117-3
+description:
+	Check test - bug#465250
+stdin:
+	test ! -e  ; echo $?
+expected-stdout:
+	1
+---
+name: debian-117-4
+description:
+	Check test - bug#465250
+stdin:
+	test  -e  ; echo $?
+expected-stdout:
+	0
+---
Index: src/bin/mksh/dot.mkshrc
diff -u src/bin/mksh/dot.mkshrc:1.54 src/bin/mksh/dot.mkshrc:1.59
--- src/bin/mksh/dot.mkshrc:1.54	Thu Feb 25 20:48:10 2010
+++ src/bin/mksh/dot.mkshrc	Wed Feb  9 19:32:35 2011
@@ -1,7 +1,7 @@
 # $Id$
-# $MirOS: src/bin/mksh/dot.mkshrc,v 1.54 2010/02/25 20:48:10 tg Exp $
+# $MirOS: src/bin/mksh/dot.mkshrc,v 1.59 2011/02/09 19:32:35 tg Exp $
 #-
-# Copyright (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2010
+# Copyright (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2010, 2011
 #	Thorsten Glaser <tg@mirbsd.org>
 #
 # Provided that these terms and disclaimer and all copyright notices
@@ -31,9 +31,9 @@
 }
 PS1='$(precmd)${USER:=$(ulimit -c 0;id -un 2>&-||print \?)}@${HOSTNAME%%.*}:$(
 	typeset d=${PWD:-?} n p=~; [[ $p = ?(*/) ]] || d=${d/#$p/~}
-	(( ${#d} > (n = (COLUMNS/3 < 7 ? 7 : COLUMNS/3)) )) && {
+	(( (${%d}>0 ? ${%d}: ${#d}) > (n = (COLUMNS/3<7 ? 7: COLUMNS/3)) )) && {
 	d=${d:(-n)}; p=...; } || p=; print -nr -- "$p$d") '"$PS1 "
-: ${MKSH:=$(whence -p mksh)}; export EDITOR HOSTNAME MKSH PS1 TERM USER
+: ${MKSH:=$(whence -p mksh)}; export EDITOR HOSTNAME MKSH TERM USER
 alias ls=ls
 unalias ls
 alias l='ls -F'
@@ -73,7 +73,7 @@
 	cd "$t"
 }
 function dirs {
-	typeset d
+	typeset d dwidth
 	typeset -i isnoglob=0 fl=0 fv=0 fn=0 cpos=0
 
 	[[ $(set +o) == *@(-o noglob)@(| *) ]] && isnoglob=1
@@ -105,9 +105,11 @@
 		while (( fv < ${#DIRSTACK[*]} )); do
 			d=${DIRSTACK[fv]}
 			(( fl )) && d=${d/#~/$DIRSTACKBASE}
-			if (( fn && (cpos+=${#d}+1) >= 79 && ${#d} < 80 )); then
+			(( dwidth = (${%d} > 0 ? ${%d} : ${#d}) ))
+			if (( fn && (cpos += dwidth + 1) >= 79 && \
+			    dwidth < 80 )); then
 				print
-				(( cpos = ${#d} + 1 ))
+				(( cpos = dwidth + 1 ))
 			fi
 			print -nr -- "$d "
 			let fv++
@@ -202,6 +204,24 @@
 	dirs $fa
 }
 
+# pager (not control character safe)
+function smores {
+	typeset dummy line llen curlin=0
+
+	cat "$@" | while IFS= read -r line; do
+		llen=${%line}
+		(( llen == -1 )) && llen=${#line}
+		(( llen = llen ? (llen + COLUMNS - 1) / COLUMNS : 1 ))
+		if (( (curlin += llen) >= LINES )); then
+			print -n -- '\033[7m--more--\033[0m'
+			read -u1 dummy
+			[[ $dummy = [Qq]* ]] && return 0
+			curlin=$llen
+		fi
+		print -r -- "$line"
+	done
+}
+
 # base64 encoder (not NUL safe) and decoder (NUL safe), RFC compliant
 function Lb64decode {
 	[[ -o utf8-mode ]]; typeset u=$?
@@ -335,7 +355,7 @@
 	done; }
 }
 
-: place customsations below this line
+: place customisations below this line
 
 for p in ~/.etc/bin ~/bin; do
 	[[ -d $p/. ]] || continue
@@ -348,8 +368,9 @@
 #unset LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_IDENTIFICATION LC_MONETARY \
 #    LC_NAME LC_NUMERIC LC_TELEPHONE LC_TIME
 #p=en_GB.UTF-8
+#set -U
 #export LANG=C LC_CTYPE=$p LC_MEASUREMENT=$p LC_MESSAGES=$p LC_PAPER=$p
 
 unset p
 
-: place customsations above this line
+: place customisations above this line
Index: src/bin/mksh/edit.c
diff -u src/bin/mksh/edit.c:1.190 src/bin/mksh/edit.c:1.211
--- src/bin/mksh/edit.c:1.190	Tue Feb 23 18:13:02 2010
+++ src/bin/mksh/edit.c	Fri Apr 22 12:16:38 2011
@@ -1,10 +1,10 @@
-/*	$OpenBSD: edit.c,v 1.33 2007/08/02 10:50:25 fgsch Exp $	*/
+/*	$OpenBSD: edit.c,v 1.34 2010/05/20 01:13:07 fgsch Exp $	*/
 /*	$OpenBSD: edit.h,v 1.8 2005/03/28 21:28:22 deraadt Exp $	*/
-/*	$OpenBSD: emacs.c,v 1.42 2009/06/02 06:47:47 halex Exp $	*/
+/*	$OpenBSD: emacs.c,v 1.43 2011/03/14 21:20:01 okan Exp $	*/
 /*	$OpenBSD: vi.c,v 1.26 2009/06/29 22:50:19 martynas Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -25,7 +25,20 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.190 2010/02/23 18:13:02 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.211 2011/04/22 12:16:38 tg Exp $");
+
+/*
+ * in later versions we might use libtermcap for this, but since external
+ * dependencies are problematic, this has not yet been decided on; another
+ * good string is "\033c" except on hardware terminals like the DEC VT420
+ * which do a full power cycle then...
+ */
+#ifndef MKSH_CLS_STRING
+#define MKSH_CLS_STRING		"\033[;H\033[J"
+#endif
+#ifndef MKSH_CLRTOEOL_STRING
+#define MKSH_CLRTOEOL_STRING	"\033[K"
+#endif
 
 /* tty driver characters we are interested in */
 typedef struct {
@@ -44,7 +57,12 @@
 #define XCF_FILE	BIT(1)	/* Do file completion */
 #define XCF_FULLPATH	BIT(2)	/* command completion: store full path */
 #define XCF_COMMAND_FILE (XCF_COMMAND|XCF_FILE)
+#define XCF_IS_COMMAND	BIT(3)	/* return flag: is command */
+#define XCF_IS_VARSUB	BIT(4)	/* return flag: is $FOO substitution */
+#define XCF_IS_EXTGLOB	BIT(5)	/* return flag: is foo* expansion */
 
+static char editmode;
+static int xx_cols;			/* for Emacs mode */
 static int modified;			/* buffer has been "modified" */
 static char holdbuf[LINE];		/* place to hold last edit buffer */
 
@@ -53,8 +71,7 @@
 static bool x_mode(bool);
 static int x_do_comment(char *, int, int *);
 static void x_print_expansions(int, char *const *, bool);
-static int x_cf_glob(int, const char *, int, int, int *, int *, char ***,
-    bool *);
+static int x_cf_glob(int *, const char *, int, int, int *, int *, char ***);
 static int x_longest_prefix(int, char *const *);
 static int x_basename(const char *, const char *);
 static void x_free_words(int, char **);
@@ -67,23 +84,21 @@
 #endif
 
 #define x_flush()	shf_flush(shl_out)
+#ifdef MKSH_SMALL
+#define x_putc(c)	x_putcf(c)
+#else
 #define x_putc(c)	shf_putc((c), shl_out)
+#endif
 
 static int path_order_cmp(const void *aa, const void *bb);
-static char *add_glob(const char *, int)
-    MKSH_A_NONNULL((nonnull (1)))
-    MKSH_A_BOUNDED(string, 1, 2);
 static void glob_table(const char *, XPtrV *, struct table *);
 static void glob_path(int flags, const char *, XPtrV *, const char *);
-static int x_file_glob(int, const char *, int, char ***)
-    MKSH_A_NONNULL((nonnull (2)))
-    MKSH_A_BOUNDED(string, 2, 3);
-static int x_command_glob(int, const char *, int, char ***)
-    MKSH_A_NONNULL((nonnull (2)))
-    MKSH_A_BOUNDED(string, 2, 3);
+static int x_file_glob(int, char *, char ***);
+static int x_command_glob(int, char *, char ***);
 static int x_locate_word(const char *, int, int, int *, bool *);
 
 static int x_e_getmbc(char *);
+static int x_e_rebuildline(const char *);
 
 /* +++ generic editing functions +++ */
 
@@ -91,12 +106,14 @@
 void
 x_init(void)
 {
-	/* set to -2 to force initial binding */
+	/*
+	 * Set edchars to -2 to force initial binding, except
+	 * we need default values for some deficient systems…
+	 */
 	edchars.erase = edchars.kill = edchars.intr = edchars.quit =
 	    edchars.eof = -2;
-	/* default value for deficient systems */
-	edchars.werase = 027;	/* ^W */
-	change_winsz();
+	/* ^W */
+	edchars.werase = 027;
 	x_init_emacs();
 }
 
@@ -117,9 +134,10 @@
 		i = x_vi(buf, len);
 #endif
 	else
-		i = -1;		/* internal error */
+		/* internal error */
+		i = -1;
+	editmode = 0;
 	x_mode(false);
-	change_winsz();
 	return (i);
 }
 
@@ -129,12 +147,22 @@
 x_getc(void)
 {
 	char c;
-	int n;
+	ssize_t n;
 
 	while ((n = blocking_read(STDIN_FILENO, &c, 1)) < 0 && errno == EINTR)
 		if (trap) {
 			x_mode(false);
 			runtraps(0);
+#ifdef SIGWINCH
+			if (got_winch) {
+				change_winsz();
+				if (x_cols != xx_cols && editmode == 1) {
+					/* redraw line in Emacs mode */
+					xx_cols = x_cols;
+					x_e_rebuildline(MKSH_CLRTOEOL_STRING);
+				}
+			}
+#endif
 			x_mode(true);
 		}
 	return ((n == 1) ? (int)(unsigned char)c : -1);
@@ -150,7 +178,8 @@
  * Misc common code for vi/emacs *
  *********************************/
 
-/* Handle the commenting/uncommenting of a line.
+/*-
+ * Handle the commenting/uncommenting of a line.
  * Returns:
  *	1 if a carriage return is indicated (comment added)
  *	0 if no return (comment removed)
@@ -164,7 +193,8 @@
 	int i, j, len = *lenp;
 
 	if (len == 0)
-		return (1); /* somewhat arbitrary - it's what AT&T ksh does */
+		/* somewhat arbitrary - it's what AT&T ksh does */
+		return (1);
 
 	/* Already commented? */
 	if (buf[0] == '#') {
@@ -209,7 +239,8 @@
 	int prefix_len;
 	XPtrV l = { NULL, NULL, NULL };
 
-	/* Check if all matches are in the same directory (in this
+	/*
+	 * Check if all matches are in the same directory (in this
 	 * case, we want to omit the directory name)
 	 */
 	if (!is_command &&
@@ -243,7 +274,8 @@
 	pr_list(use_copy ? (char **)XPptrv(l) : words);
 
 	if (use_copy)
-		XPfree(l); /* not x_free_words() */
+		/* not x_free_words() */
+		XPfree(l);
 }
 
 /**
@@ -254,19 +286,14 @@
  *	- returns number of matching strings
  */
 static int
-x_file_glob(int flags MKSH_A_UNUSED, const char *str, int slen, char ***wordsp)
+x_file_glob(int flags MKSH_A_UNUSED, char *toglob, char ***wordsp)
 {
-	char *toglob, **words;
+	char **words;
 	int nwords, i, idx;
 	bool escaping;
 	XPtrV w;
 	struct source *s, *sold;
 
-	if (slen < 0)
-		return (0);
-
-	toglob = add_glob(str, slen);
-
 	/* remove all escaping backward slashes */
 	escaping = false;
 	for (i = 0, idx = 0; toglob[i]; i++) {
@@ -295,7 +322,7 @@
 	source = s;
 	if (yylex(ONEWORD | LQCHAR) != LWORD) {
 		source = sold;
-		internal_warningf("fileglob: substitute error");
+		internal_warningf("%s: %s", "fileglob", "bad substitution");
 		return (0);
 	}
 	source = sold;
@@ -309,8 +336,9 @@
 	if (nwords == 1) {
 		struct stat statb;
 
-		/* Check if globbing failed (returned glob pattern),
-		 * but be careful (E.g. toglob == "ab*" when the file
+		/*
+		 * Check if globbing failed (returned glob pattern),
+		 * but be careful (e.g. toglob == "ab*" when the file
 		 * "ab*" exists is not an error).
 		 * Also, check for empty result - happens if we tried
 		 * to glob something which evaluated to an empty
@@ -324,7 +352,6 @@
 			nwords = 0;
 		}
 	}
-	afree(toglob, ATEMP);
 
 	if ((*wordsp = nwords ? words : NULL) == NULL && words != NULL)
 		x_free_words(nwords, words);
@@ -352,21 +379,15 @@
 }
 
 static int
-x_command_glob(int flags, const char *str, int slen, char ***wordsp)
+x_command_glob(int flags, char *toglob, char ***wordsp)
 {
-	char *toglob, *pat, *fpath;
+	char *pat, *fpath;
 	int nwords;
 	XPtrV w;
 	struct block *l;
 
-	if (slen < 0)
-		return (0);
-
-	toglob = add_glob(str, slen);
-
 	/* Convert "foo*" (toglob) to a pattern for future use */
 	pat = evalstr(toglob, DOPAT | DOTILDE);
-	afree(toglob, ATEMP);
 
 	XPinit(w, 32);
 
@@ -395,7 +416,7 @@
 		int i, path_order = 0;
 
 		info = (struct path_order_info *)
-		    alloc(nwords * sizeof(struct path_order_info), ATEMP);
+		    alloc2(nwords, sizeof(struct path_order_info), ATEMP);
 		for (i = 0; i < nwords; i++) {
 			info[i].word = words[i];
 			info[i].base = x_basename(words[i], NULL);
@@ -452,7 +473,8 @@
 	/* The case where pos == buflen happens to take care of itself... */
 
 	start = pos;
-	/* Keep going backwards to start of word (has effect of allowing
+	/*
+	 * Keep going backwards to start of word (has effect of allowing
 	 * one blank after the end of a word)
 	 */
 	for (; (start > 0 && IS_WORDC(buf[start - 1])) ||
@@ -473,7 +495,8 @@
 			p--;
 		iscmd = p < 0 || vstrchr(";|&()`", buf[p]);
 		if (iscmd) {
-			/* If command has a /, path, etc. is not searched;
+			/*
+			 * If command has a /, path, etc. is not searched;
 			 * only current directory is searched which is just
 			 * like file globbing.
 			 */
@@ -490,78 +513,96 @@
 }
 
 static int
-x_cf_glob(int flags, const char *buf, int buflen, int pos, int *startp,
-    int *endp, char ***wordsp, bool *is_commandp)
+x_cf_glob(int *flagsp, const char *buf, int buflen, int pos, int *startp,
+    int *endp, char ***wordsp)
 {
-	int len, nwords;
+	int len, nwords = 0;
 	char **words = NULL;
 	bool is_command;
 
 	len = x_locate_word(buf, buflen, pos, startp, &is_command);
-	if (!(flags & XCF_COMMAND))
+	if (!(*flagsp & XCF_COMMAND))
 		is_command = false;
-	/* Don't do command globing on zero length strings - it takes too
+	/*
+	 * Don't do command globing on zero length strings - it takes too
 	 * long and isn't very useful. File globs are more likely to be
 	 * useful, so allow these.
 	 */
 	if (len == 0 && is_command)
 		return (0);
 
-	nwords = is_command ?
-	    x_command_glob(flags, buf + *startp, len, &words) :
-	    x_file_glob(flags, buf + *startp, len, &words);
+	if (len >= 0) {
+		char *toglob, *s;
+		bool saw_slash = false, saw_dollar = false, saw_glob = false;
+
+		/*
+		 * Given a string, copy it and possibly add a '*' to the end.
+		 */
+
+		strndupx(toglob, buf + *startp, len + /* the '*' */ 1, ATEMP);
+		toglob[len] = '\0';
+
+		/*
+		 * If the pathname contains a wildcard (an unquoted '*',
+		 * '?', or '[') or parameter expansion ('$'), or a ~username
+		 * with no trailing slash, then it is globbed based on that
+		 * value (i.e., without the appended '*').
+		 */
+		for (s = toglob; *s; s++) {
+			if (*s == '\\' && s[1])
+				s++;
+			else if (*s == '$') {
+				/*
+				 * Do not append a space after the value
+				 * if expanding a parameter substitution
+				 * as in: “cat $HOME/.ss↹” (LP: #710539)
+				 */
+				saw_dollar = true;
+			} else if (*s == '?' || *s == '*' || *s == '[' ||
+			    /* ?() *() +() @() !() but two already checked */
+			    (s[1] == '(' /*)*/ &&
+			    (*s == '+' || *s == '@' || *s == '!'))) {
+				/* just expand based on the extglob */
+				saw_glob = true;
+			} else if (*s == '/')
+				saw_slash = true;
+		}
+		if (saw_glob) {
+			/*
+			 * do not append a glob, we already have a
+			 * glob or extglob; it works even if this is
+			 * a parameter expansion as we have a glob
+			 */
+			*flagsp |= XCF_IS_EXTGLOB;
+		} else if (saw_dollar) {
+			/* do not append a glob, nor later a space */
+			*flagsp |= XCF_IS_VARSUB;
+		} else if (*toglob != '~' || saw_slash) {
+			/* append a glob, this is not just a tilde */
+			toglob[len] = '*';
+			toglob[len + 1] = '\0';
+		}
+
+		/*
+		 * Expand (glob) it now.
+		 */
+
+		nwords = is_command ?
+		    x_command_glob(*flagsp, toglob, &words) :
+		    x_file_glob(*flagsp, toglob, &words);
+		afree(toglob, ATEMP);
+	}
 	if (nwords == 0) {
 		*wordsp = NULL;
 		return (0);
 	}
-	if (is_commandp)
-		*is_commandp = is_command;
+	*flagsp |= XCF_IS_COMMAND;
 	*wordsp = words;
 	*endp = *startp + len;
 
 	return (nwords);
 }
 
-/* Given a string, copy it and possibly add a '*' to the end.
- * The new string is returned.
- */
-static char *
-add_glob(const char *str, int slen)
-{
-	char *toglob, *s;
-	bool saw_slash = false;
-
-	if (slen < 0)
-		return (NULL);
-
-	/* for clang's static analyser, the nonnull attribute isn't enough */
-	mkssert(str != NULL);
-
-	strndupx(toglob, str, slen + 1, ATEMP); /* + 1 for "*" */
-	toglob[slen] = '\0';
-
-	/*
-	 * If the pathname contains a wildcard (an unquoted '*',
-	 * '?', or '[') or parameter expansion ('$'), or a ~username
-	 * with no trailing slash, then it is globbed based on that
-	 * value (i.e., without the appended '*').
-	 */
-	for (s = toglob; *s; s++) {
-		if (*s == '\\' && s[1])
-			s++;
-		else if (*s == '*' || *s == '[' || *s == '?' || *s == '$' ||
-		    (s[1] == '(' && vstrchr("*+?@!", *s)))
-			break;
-		else if (*s == '/')
-			saw_slash = true;
-	}
-	if (!*s && (*toglob != '~' || saw_slash)) {
-		toglob[slen] = '*';
-		toglob[slen + 1] = '\0';
-	}
-	return (toglob);
-}
-
 /*
  * Find longest common prefix
  */
@@ -592,7 +633,8 @@
 	afree(words, ATEMP);
 }
 
-/* Return the offset of the basename of string s (which ends at se - need not
+/*-
+ * Return the offset of the basename of string s (which ends at se - need not
  * be null terminated). Trailing slashes are ignored. If s is just a slash,
  * then the offset is 0 (actually, length - 1).
  *	s		Return
@@ -648,13 +690,15 @@
 static void
 glob_path(int flags, const char *pat, XPtrV *wp, const char *lpath)
 {
-	const char *sp, *p;
+	const char *sp = lpath, *p;
 	char *xp, **words;
-	int staterr, pathlen, patlen, oldsize, newsize, i, j;
+	size_t pathlen, patlen, oldsize, newsize, i, j;
+	int staterr;
 	XString xs;
 
-	patlen = strlen(pat) + 1;
-	sp = lpath;
+	patlen = strlen(pat);
+	checkoktoadd(patlen, 129 + X_EXTRA);
+	++patlen;
 	Xinit(xs, xp, patlen + 128, ATEMP);
 	while (sp) {
 		xp = Xstring(xs, xp);
@@ -662,7 +706,8 @@
 			p = sp + strlen(sp);
 		pathlen = p - sp;
 		if (pathlen) {
-			/* Copy sp into xp, stuffing any MAGIC characters
+			/*
+			 * Copy sp into xp, stuffing any MAGIC characters
 			 * on the way
 			 */
 			const char *s = sp;
@@ -681,7 +726,8 @@
 		memcpy(xp, pat, patlen);
 
 		oldsize = XPsize(*wp);
-		glob_str(Xstring(xs, xp), wp, 1); /* mark dirs */
+		/* mark dirs */
+		glob_str(Xstring(xs, xp), wp, 1);
 		newsize = XPsize(*wp);
 
 		/* Check that each match is executable... */
@@ -771,13 +817,14 @@
 
 /* Separator for completion */
 #define	is_cfs(c)	((c) == ' ' || (c) == '\t' || (c) == '"' || (c) == '\'')
-			/* Separator for motion */
-#define	is_mfs(c)	(!(ksh_isalnux(c) || (c) == '$'))
+/* Separator for motion */
+#define	is_mfs(c)	(!(ksh_isalnux(c) || (c) == '$' || ((c) & 0x80)))
 
 #define X_NTABS		3			/* normal, meta1, meta2 */
 #define X_TABSZ		256			/* size of keydef tables etc */
 
-/* Arguments for do_complete()
+/*-
+ * Arguments for do_complete()
  * 0 = enumerate	M-=	complete as much as possible and then list
  * 1 = complete		M-Esc
  * 2 = list		M-?
@@ -804,11 +851,10 @@
  */
 static int x_adj_done;
 
-static int xx_cols;
 static int x_col;
 static int x_displen;
 static int x_arg;		/* general purpose arg */
-static int x_arg_defaulted;	/* x_arg not explicitly set; defaulted to 1 */
+static bool x_arg_defaulted;	/* x_arg not explicitly set; defaulted to 1 */
 
 static int xlp_valid;
 
@@ -826,7 +872,7 @@
 static int killsp, killtp;
 static int x_curprefix;
 #ifndef MKSH_SMALL
-static char *macroptr = NULL;	/* bind key macro active? */
+static char *macroptr;		/* bind key macro active? */
 #endif
 #if !MKSH_S_NOVI
 static int cur_col;		/* current column on line */
@@ -862,7 +908,7 @@
 static void x_redraw(int);
 static void x_push(int);
 static char *x_mapin(const char *, Area *)
-    MKSH_A_NONNULL((nonnull (1)));
+    MKSH_A_NONNULL((__nonnull__ (1)));
 static char *x_mapout(int);
 static void x_mapout2(int, char **);
 static void x_print(int, int);
@@ -969,7 +1015,8 @@
 	{ XFUNC_fold_capitalise,	1,	'C'	},
 	{ XFUNC_fold_capitalise,	1,	'c'	},
 #endif
-	/* These for ansi arrow keys: arguablely shouldn't be here by
+	/*
+	 * These for ANSI arrow keys: arguablely shouldn't be here by
 	 * default, but its simpler/faster/smaller than using termcap
 	 * entries.
 	 */
@@ -1090,7 +1137,8 @@
 			x_load_hist(histptr - off);
 		x_nextcmd = -1;
 	}
-	while (1) {
+	editmode = 1;
+	while (/* CONSTCOND */ 1) {
 		x_flush();
 		if ((c = x_e_getc()) < 0)
 			return (0);
@@ -1112,7 +1160,7 @@
 		if (!(x_ftab[f].xf_flags & XF_PREFIX) &&
 		    x_last_command != XFUNC_set_arg) {
 			x_arg = 1;
-			x_arg_defaulted = 1;
+			x_arg_defaulted = true;
 		}
 		i = c | (x_curprefix << 8);
 		x_curprefix = 0;
@@ -1124,7 +1172,8 @@
 		case KEOL:
 			i = xep - xbuf;
 			return (i);
-		case KINTR:	/* special case for interrupt */
+		case KINTR:
+			/* special case for interrupt */
 			trapsig(SIGINT);
 			x_mode(false);
 			unwind(LSHELL);
@@ -1137,7 +1186,7 @@
 static int
 x_insert(int c)
 {
-	static int left = 0, pos, save_arg;
+	static int left, pos, save_arg;
 	static char str[4];
 
 	/*
@@ -1235,7 +1284,8 @@
 	x_lastcp();
 	x_adj_ok = (xcp >= xlp);
 	x_zots(cp);
-	if (adj == x_adj_done) {	/* has x_adjust() been called? */
+	/* has x_adjust() been called? */
+	if (adj == x_adj_done) {
 		/* no */
 		cp = xlp;
 		while (cp > xcp)
@@ -1324,13 +1374,15 @@
 		x_push(nb);
 
 	xep -= nb;
-	memmove(xcp, xcp + nb, xep - xcp + 1);	/* Copies the NUL */
-	x_adj_ok = 0;			/* don't redraw */
+	/* Copies the NUL */
+	memmove(xcp, xcp + nb, xep - xcp + 1);
+	/* don't redraw */
+	x_adj_ok = 0;
 	xlp_valid = false;
 	x_zots(xcp);
 	/*
 	 * if we are already filling the line,
-	 * there is no need to ' ','\b'.
+	 * there is no need to ' ', '\b'.
 	 * But if we must, make sure we do the minimum.
 	 */
 	if ((i = xx_cols - 2 - x_col) > 0 || xep - xlp == 0) {
@@ -1442,10 +1494,12 @@
 		/* we are heading off screen */
 		xcp = cp;
 		x_adjust();
-	} else if (cp < xcp) {		/* move back */
+	} else if (cp < xcp) {
+		/* move back */
 		while (cp < xcp)
 			x_bs3(&xcp);
-	} else if (cp > xcp) {		/* move forward */
+	} else if (cp > xcp) {
+		/* move forward */
 		while (cp > xcp)
 			x_zotc3(&xcp);
 	}
@@ -1485,9 +1539,11 @@
 	if (dcp)
 		*dcp = cp + 1;
 	if (c == '\t')
-		return (4);	/* Kludge, tabs are always four spaces. */
+		/* Kludge, tabs are always four spaces. */
+		return (4);
 	if (c < ' ' || c == 0x7f)
-		return (2);	/* control unsigned char */
+		/* control unsigned char */
+		return (2);
 	return (1);
 }
 
@@ -1670,7 +1726,8 @@
 	return (KSTD);
 }
 
-/* Goto a particular history number obtained from argument.
+/*
+ * Goto a particular history number obtained from argument.
  * If no argument is given history 1 is probably not what you
  * want so we'll simply go to the oldest one.
  */
@@ -1740,7 +1797,7 @@
 	unsigned char f;
 
 	*p = '\0';
-	while (1) {
+	while (/* CONSTCOND */ 1) {
 		if (offset < 0) {
 			x_e_puts("\nI-search: ");
 			x_e_puts(pat);
@@ -1803,7 +1860,8 @@
 			if (offset >= 0)
 				x_load_hist(histptr + 1);
 			break;
-		} else { /* other command */
+		} else {
+			/* other command */
 			x_e_ungetc(c);
 			break;
 		}
@@ -1922,25 +1980,21 @@
 }
 
 static int
-x_cls(int c MKSH_A_UNUSED)
+x_e_rebuildline(const char *clrstr)
 {
-/*
- * in later versions we might use libtermcap for this, but since external
- * dependencies are problematic, this has not yet been decided on; another
- * good string is "\033c" except on hardware terminals like the DEC VT420
- * which do a full power cycle then...
- */
-#ifndef MKSH_CLS_STRING
-#define MKSH_CLS_STRING	"\033[;H\033[J"
-#endif
-	shf_fprintf(shl_out, MKSH_CLS_STRING);
-	x_putc('\r');
-	x_init_prompt();
-	x_redraw(0);
+	shf_puts(clrstr, shl_out);
+	x_adjust();
 	return (KSTD);
 }
 
-/* Redraw (part of) the line. If limit is < 0, the everything is redrawn
+static int
+x_cls(int c MKSH_A_UNUSED)
+{
+	return (x_e_rebuildline(MKSH_CLS_STRING));
+}
+
+/*
+ * Redraw (part of) the line. If limit is < 0, the everything is redrawn
  * on a NEW line, otherwise limit is the screen column up to which needs
  * redrawing.
  */
@@ -1977,7 +2031,8 @@
 		limit = xx_cols;
 	if (limit >= 0) {
 		if (xep > xlp)
-			i = 0;			/* we fill the line */
+			/* we fill the line */
+			i = 0;
 		else {
 			char *cpl = xbp;
 
@@ -1994,7 +2049,8 @@
 			j++;
 		}
 		i = ' ';
-		if (xep > xlp) {		/* more off screen */
+		if (xep > xlp) {
+			/* more off screen */
 			if (xbp > xbuf)
 				i = '*';
 			else
@@ -2018,7 +2074,8 @@
 {
 	unsigned int tmpa, tmpb;
 
-	/* What transpose is meant to do seems to be up for debate. This
+	/*-
+	 * What transpose is meant to do seems to be up for debate. This
 	 * is a general summary of the options; the text is abcd with the
 	 * upper case character or underscore indicating the cursor position:
 	 *	Who			Before	After	Before	After
@@ -2039,8 +2096,9 @@
 			x_e_putc2(7);
 			return (KSTD);
 		}
-		/* Gosling/Unipress emacs style: Swap two characters before the
-		 * cursor, do not change cursor position
+		/*
+		 * Gosling/Unipress emacs style: Swap two characters before
+		 * the cursor, do not change cursor position
 		 */
 		x_bs3(&xcp);
 		if (utf_mbtowc(&tmpa, xcp) == (size_t)-1) {
@@ -2057,7 +2115,8 @@
 		utf_wctomb(xcp, tmpb);
 		x_zotc3(&xcp);
 	} else {
-		/* GNU emacs style: Swap the characters before and under the
+		/*
+		 * GNU emacs style: Swap the characters before and under the
 		 * cursor, move cursor position along one.
 		 */
 		if (utf_mbtowc(&tmpa, xcp) == (size_t)-1) {
@@ -2205,7 +2264,7 @@
 	switch ((c = x_e_getc())) {
 	case '~':
 		x_arg = 1;
-		x_arg_defaulted = 1;
+		x_arg_defaulted = true;
 		return (x_mv_begin(0));
 	case ';':
 		/* "interesting" sequence detected */
@@ -2220,7 +2279,7 @@
 
 	/*-
 	 * At this point, we have read the following octets so far:
-	 * - ESC+[ or ESC+O or Ctrl-X (Præfix 2)
+	 * - ESC+[ or ESC+O or Ctrl-X (Prefix 2)
 	 * - 1 (vt_hack)
 	 * - ;
 	 * - 5 (Ctrl key combiner) or 3 (Alt key combiner)
@@ -2243,18 +2302,19 @@
 static char *
 x_mapin(const char *cp, Area *ap)
 {
-	char *new, *op;
+	char *news, *op;
 
 	/* for clang's static analyser, the nonnull attribute isn't enough */
 	mkssert(cp != NULL);
 
-	strdupx(new, cp, ap);
-	op = new;
+	strdupx(news, cp, ap);
+	op = news;
 	while (*cp) {
 		/* XXX -- should handle \^ escape? */
 		if (*cp == '^') {
 			cp++;
-			if (*cp >= '?')	/* includes '?'; ASCII */
+			if (*cp >= '?')
+				/* includes '?'; ASCII */
 				*op++ = CTRL(*cp);
 			else {
 				*op++ = '^';
@@ -2266,7 +2326,7 @@
 	}
 	*op = '\0';
 
-	return (new);
+	return (news);
 }
 
 static void
@@ -2318,9 +2378,11 @@
 int
 x_bind(const char *a1, const char *a2,
 #ifndef MKSH_SMALL
-    bool macro,			/* bind -m */
+    /* bind -m */
+    bool macro,
 #endif
-    bool list)			/* bind -l */
+    /* bind -l */
+    bool list)
 {
 	unsigned char f;
 	int prefix, key;
@@ -2331,7 +2393,7 @@
 #endif
 
 	if (x_tab == NULL) {
-		bi_errorf("cannot bind, not a tty");
+		bi_errorf("can't bind, not a tty");
 		return (1);
 	}
 	/* List function names */
@@ -2373,16 +2435,16 @@
 	    && ((*m1 != '~') || *(m1 + 1))
 #endif
 	    ) {
-		char msg[256] = "key sequence '";
+		char msg[256];
 		const char *c = a1;
-		m1 = msg + strlen(msg);
+		m1 = msg;
 		while (*c && m1 < (msg + sizeof(msg) - 3))
 			x_mapout2(*c++, &m1);
-		bi_errorf("%s' too long", msg);
+		bi_errorf("%s: %s", "too long key sequence", msg);
 		return (1);
 	}
 #ifndef MKSH_SMALL
-	hastilde = *m1;
+	hastilde = tobool(*m1);
 #endif
 	afree(m2, ATEMP);
 
@@ -2403,7 +2465,7 @@
 			    strcmp(x_ftab[f].xf_name, a2) == 0)
 				break;
 		if (f == NELEM(x_ftab) || x_ftab[f].xf_flags & XF_NOBIND) {
-			bi_errorf("%s: no such function", a2);
+			bi_errorf("%s: %s %s", a2, "no such", T_function);
 			return (1);
 		}
 	}
@@ -2441,7 +2503,7 @@
 	ainit(AEDIT);
 	x_nextcmd = -1;
 
-	x_tab = alloc(X_NTABS * sizeof(*x_tab), AEDIT);
+	x_tab = alloc2(X_NTABS, sizeof(*x_tab), AEDIT);
 	for (j = 0; j < X_TABSZ; j++)
 		x_tab[0][j] = XFUNC_insert;
 	for (i = 1; i < X_NTABS; i++)
@@ -2452,7 +2514,7 @@
 		    = x_defbindings[i].xdb_func;
 
 #ifndef MKSH_SMALL
-	x_atab = alloc(X_NTABS * sizeof(*x_atab), AEDIT);
+	x_atab = alloc2(X_NTABS, sizeof(*x_atab), AEDIT);
 	for (i = 1; i < X_NTABS; i++)
 		for (j = 0; j < X_TABSZ; j++)
 			x_atab[i][j] = NULL;
@@ -2578,10 +2640,10 @@
 {
 	char **words;
 	int start, end, nwords, i;
-	bool is_command;
 
-	nwords = x_cf_glob(XCF_FILE, xbuf, xep - xbuf, xcp - xbuf,
-	    &start, &end, &words, &is_command);
+	i = XCF_FILE;
+	nwords = x_cf_glob(&i, xbuf, xep - xbuf, xcp - xbuf,
+	    &start, &end, &words);
 
 	if (nwords == 0) {
 		x_e_putc2(7);
@@ -2589,7 +2651,9 @@
 	}
 	x_goto(xbuf + start);
 	x_delete(end - start, false);
-	for (i = 0; i < nwords;) {
+
+	i = 0;
+	while (i < nwords) {
 		if (x_escape(words[i], strlen(words[i]), x_do_ins) < 0 ||
 		    (++i < nwords && x_ins(" ") < 0)) {
 			x_e_putc2(7);
@@ -2601,24 +2665,26 @@
 	return (KSTD);
 }
 
-/* type == 0 for list, 1 for complete and 2 for complete-list */
 static void
-do_complete(int flags,	/* XCF_{COMMAND,FILE,COMMAND_FILE} */
+do_complete(
+    /* XCF_{COMMAND,FILE,COMMAND_FILE} */
+    int flags,
+    /* 0 for list, 1 for complete and 2 for complete-list */
     Comp_type type)
 {
 	char **words;
 	int start, end, nlen, olen, nwords;
-	bool is_command, completed = false;
+	bool completed = false;
 
-	nwords = x_cf_glob(flags, xbuf, xep - xbuf, xcp - xbuf,
-	    &start, &end, &words, &is_command);
+	nwords = x_cf_glob(&flags, xbuf, xep - xbuf, xcp - xbuf,
+	    &start, &end, &words);
 	/* no match */
 	if (nwords == 0) {
 		x_e_putc2(7);
 		return;
 	}
 	if (type == CT_LIST) {
-		x_print_expansions(nwords, words, is_command);
+		x_print_expansions(nwords, words, flags & XCF_IS_COMMAND);
 		x_redraw(0);
 		x_free_words(nwords, words);
 		return;
@@ -2633,13 +2699,14 @@
 		x_adjust();
 		completed = true;
 	}
-	/* add space if single non-dir match */
-	if (nwords == 1 && words[0][nlen - 1] != '/') {
+	/* add space if single non-dir match and not parameter substitution */
+	if (nwords == 1 && words[0][nlen - 1] != '/' &&
+	    !(flags & XCF_IS_VARSUB)) {
 		x_ins(" ");
 		completed = true;
 	}
 	if (type == CT_COMPLIST && !completed) {
-		x_print_expansions(nwords, words, is_command);
+		x_print_expansions(nwords, words, flags & XCF_IS_COMMAND);
 		completed = true;
 	}
 	if (completed)
@@ -2648,7 +2715,8 @@
 	x_free_words(nwords, words);
 }
 
-/* NAME:
+/*-
+ * NAME:
  *	x_adjust - redraw the line adjusting starting point etc.
  *
  * DESCRIPTION:
@@ -2664,7 +2732,8 @@
 static void
 x_adjust(void)
 {
-	x_adj_done++;			/* flag the fact that we were called. */
+	/* flag the fact that we were called. */
+	x_adj_done++;
 	/*
 	 * we had a problem if the prompt length > xx_cols / 2
 	 */
@@ -2792,7 +2861,8 @@
 		x_e_putc3(&s);
 }
 
-/* NAME:
+/*-
+ * NAME:
  *	x_set_arg - set an arg value for next function
  *
  * DESCRIPTION:
@@ -2804,19 +2874,24 @@
 static int
 x_set_arg(int c)
 {
-	int n = 0, first = 1;
+	int n = 0;
+	bool first = true;
 
-	c &= 255;	/* strip command prefix */
-	for (; c >= 0 && ksh_isdigit(c); c = x_e_getc(), first = 0)
+	/* strip command prefix */
+	c &= 255;
+	while (c >= 0 && ksh_isdigit(c)) {
 		n = n * 10 + (c - '0');
+		c = x_e_getc();
+		first = false;
+	}
 	if (c < 0 || first) {
 		x_e_putc2(7);
 		x_arg = 1;
-		x_arg_defaulted = 1;
+		x_arg_defaulted = true;
 	} else {
 		x_e_ungetc(c);
 		x_arg = n;
-		x_arg_defaulted = 0;
+		x_arg_defaulted = false;
 	}
 	return (KSTD);
 }
@@ -2902,7 +2977,8 @@
 }
 #endif
 
-/* NAME:
+/*-
+ * NAME:
  *	x_prev_histword - recover word from prev command
  *
  * DESCRIPTION:
@@ -2923,11 +2999,17 @@
 {
 	char *rcp, *cp;
 	char **xhp;
-	int m;
-
-	if (xmp && modified > 1)
-		x_kill_region(0);
-	m = modified ? modified : 1;
+	int m = 1;
+	/* -1 = defaulted; 0+ = argument */
+	static int last_arg = -1;
+
+	if (x_last_command == XFUNC_prev_histword) {
+		if (xmp && modified > 1)
+			x_kill_region(0);
+		if (modified)
+			m = modified;
+	} else
+		last_arg = x_arg_defaulted ? -1 : x_arg;
 	xhp = histptr - (m - 1);
 	if ((xhp < history) || !(cp = *xhp)) {
 		x_e_putc2(7);
@@ -2935,7 +3017,9 @@
 		return (KSTD);
 	}
 	x_set_mark(0);
-	if (x_arg_defaulted) {
+	if ((x_arg = last_arg) == -1) {
+		/* x_arg_defaulted */
+
 		rcp = &cp[strlen(cp) - 1];
 		/*
 		 * ignore white-space after the last word
@@ -2948,6 +3032,7 @@
 			rcp++;
 		x_ins(rcp);
 	} else {
+		/* not x_arg_defaulted */
 		char ch;
 
 		rcp = cp;
@@ -2956,7 +3041,7 @@
 		 */
 		while (*rcp && is_cfs(*rcp))
 			rcp++;
-		while (x_arg-- > 1) {
+		while (x_arg-- > 0) {
 			while (*rcp && !is_cfs(*rcp))
 				rcp++;
 			while (*rcp && is_cfs(*rcp))
@@ -2996,7 +3081,8 @@
 	return (x_fold_case('C'));
 }
 
-/* NAME:
+/*-
+ * NAME:
  *	x_fold_case - convert word to UPPER/lower/Capital case
  *
  * DESCRIPTION:
@@ -3026,9 +3112,11 @@
 		 * a different action than for the rest.
 		 */
 		if (cp != xep) {
-			if (c == 'L')		/* lowercase */
+			if (c == 'L')
+				/* lowercase */
 				*cp = ksh_tolower(*cp);
-			else			/* uppercase, capitalise */
+			else
+				/* uppercase, capitalise */
 				*cp = ksh_toupper(*cp);
 			cp++;
 		}
@@ -3036,9 +3124,11 @@
 		 * now for the rest of the word
 		 */
 		while (cp != xep && !is_mfs(*cp)) {
-			if (c == 'U')		/* uppercase */
+			if (c == 'U')
+				/* uppercase */
 				*cp = ksh_toupper(*cp);
-			else			/* lowercase, capitalise */
+			else
+				/* lowercase, capitalise */
 				*cp = ksh_tolower(*cp);
 			cp++;
 		}
@@ -3049,7 +3139,8 @@
 }
 #endif
 
-/* NAME:
+/*-
+ * NAME:
  *	x_lastcp - last visible char
  *
  * SYNOPSIS:
@@ -3116,10 +3207,10 @@
 		cb.c_iflag &= ~(INLCR | ICRNL);
 		cb.c_lflag &= ~(ISIG | ICANON | ECHO);
 #if defined(VLNEXT) && defined(_POSIX_VDISABLE)
-		/* osf/1 processes lnext when ~icanon */
+		/* OSF/1 processes lnext when ~icanon */
 		cb.c_cc[VLNEXT] = _POSIX_VDISABLE;
 #endif
-		/* sunos 4.1.x & osf/1 processes discard(flush) when ~icanon */
+		/* SunOS 4.1.x & OSF/1 processes discard(flush) when ~icanon */
 #if defined(VDISCARD) && defined(_POSIX_VDISABLE)
 		cb.c_cc[VDISCARD] = _POSIX_VDISABLE;
 #endif
@@ -3287,7 +3378,7 @@
 static char		undocbuf[LINE];
 
 static struct edstate	*save_edstate(struct edstate *old);
-static void		restore_edstate(struct edstate *old, struct edstate *new);
+static void		restore_edstate(struct edstate *old, struct edstate *news);
 static void		free_edstate(struct edstate *old);
 
 static struct edstate	ebuf;
@@ -3315,7 +3406,8 @@
 static int hlast;			/* 1 past last position in history */
 static int state;
 
-/* Information for keeping track of macros that are being expanded.
+/*
+ * Information for keeping track of macros that are being expanded.
  * The format of buf is the alias contents followed by a NUL byte followed
  * by the name (letter) of the alias. The end of the buffer is marked by
  * a double NUL. The name of the alias is stored so recursive macros can
@@ -3328,10 +3420,10 @@
 };
 static struct macro_state macro;
 
-enum expand_mode {
-	NONE, EXPAND, COMPLETE, PRINT
-};
-static enum expand_mode expanded = NONE;	/* last input was expanded */
+/* last input was expanded */
+static enum expand_mode {
+	NONE = 0, EXPAND, COMPLETE, PRINT
+} expanded;
 
 static int
 x_vi(char *buf, size_t len)
@@ -3380,8 +3472,9 @@
 	lastref = 1;
 	holdlen = 0;
 
+	editmode = 2;
 	x_flush();
-	while (1) {
+	while (/* CONSTCOND */ 1) {
 		if (macro.p) {
 			c = *macro.p++;
 			/* end of current macro? */
@@ -3778,7 +3871,8 @@
 		expanded = NONE;
 		return (0);
 	}
-	/* If any chars are entered before escape, trash the saved insert
+	/*
+	 * If any chars are entered before escape, trash the saved insert
 	 * buffer (if user inserts & deletes char, ibuf gets trashed and
 	 * we don't want to use it)
 	 */
@@ -3886,7 +3980,7 @@
 			{
 				static char alias[] = "_\0";
 				struct tbl *ap;
-				int olen, nlen;
+				size_t olen, nlen;
 				char *p, *nbuf;
 
 				/* lookup letter in alias list... */
@@ -3903,6 +3997,10 @@
 				nlen = strlen(ap->val.s) + 1;
 				olen = !macro.p ? 2 :
 				    macro.len - (macro.p - macro.buf);
+				/*
+				 * at this point, it's fairly reasonable that
+				 * nlen + olen + 2 doesn't overflow
+				 */
 				nbuf = alloc(nlen + 1 + olen, APERM);
 				memcpy(nbuf, ap->val.s, nlen);
 				nbuf[nlen++] = cmd[1];
@@ -4297,29 +4395,37 @@
 				return (ret);
 			}
 
-		case '=':			/* AT&T ksh */
-		case Ctrl('e'):			/* Nonstandard vi/ksh */
+		/* AT&T ksh */
+		case '=':
+		/* Nonstandard vi/ksh */
+		case Ctrl('e'):
 			print_expansions(es, 1);
 			break;
 
 
-		case Ctrl('i'):			/* Nonstandard vi/ksh */
+		/* Nonstandard vi/ksh */
+		case Ctrl('i'):
 			if (!Flag(FVITABCOMPLETE))
 				return (-1);
 			complete_word(1, argcnt);
 			break;
 
-		case Ctrl('['):			/* some annoying AT&T kshs */
+		/* some annoying AT&T kshs */
+		case Ctrl('['):
 			if (!Flag(FVIESCCOMPLETE))
 				return (-1);
-		case '\\':			/* AT&T ksh */
-		case Ctrl('f'):			/* Nonstandard vi/ksh */
+		/* AT&T ksh */
+		case '\\':
+		/* Nonstandard vi/ksh */
+		case Ctrl('f'):
 			complete_word(1, argcnt);
 			break;
 
 
-		case '*':			/* AT&T ksh */
-		case Ctrl('x'):			/* Nonstandard vi/ksh */
+		/* AT&T ksh */
+		case '*':
+		/* Nonstandard vi/ksh */
+		case Ctrl('x'):
 			expand_word(1);
 			break;
 		}
@@ -4548,25 +4654,25 @@
 static struct edstate *
 save_edstate(struct edstate *old)
 {
-	struct edstate *new;
+	struct edstate *news;
 
-	new = alloc(sizeof(struct edstate), APERM);
-	new->cbuf = alloc(old->cbufsize, APERM);
-	memcpy(new->cbuf, old->cbuf, old->linelen);
-	new->cbufsize = old->cbufsize;
-	new->linelen = old->linelen;
-	new->cursor = old->cursor;
-	new->winleft = old->winleft;
-	return (new);
+	news = alloc(sizeof(struct edstate), APERM);
+	news->cbuf = alloc(old->cbufsize, APERM);
+	memcpy(news->cbuf, old->cbuf, old->linelen);
+	news->cbufsize = old->cbufsize;
+	news->linelen = old->linelen;
+	news->cursor = old->cursor;
+	news->winleft = old->winleft;
+	return (news);
 }
 
 static void
-restore_edstate(struct edstate *new, struct edstate *old)
+restore_edstate(struct edstate *news, struct edstate *old)
 {
-	memcpy(new->cbuf, old->cbuf, old->linelen);
-	new->linelen = old->linelen;
-	new->cursor = old->cursor;
-	new->winleft = old->winleft;
+	memcpy(news->cbuf, old->cbuf, old->linelen);
+	news->linelen = old->linelen;
+	news->cursor = old->cursor;
+	news->winleft = old->winleft;
 	free_edstate(old);
 }
 
@@ -4785,7 +4891,7 @@
 	}
 	(void)histnum(n);
 	if ((hptr = *histpos()) == NULL) {
-		internal_warningf("grabhist: bad history array");
+		internal_warningf("%s: %s", "grabhist", "bad history array");
 		return (-1);
 	}
 	if (save)
@@ -4970,7 +5076,8 @@
 		col++;
 	}
 	if (es->winleft > 0 && moreright)
-		/* POSIX says to use * for this but that is a globbing
+		/*
+		 * POSIX says to use * for this but that is a globbing
 		 * character and may confuse people; + is more innocuous
 		 */
 		mc = '+';
@@ -5019,11 +5126,8 @@
 expand_word(int cmd)
 {
 	static struct edstate *buf;
-	int rval = 0;
-	int nwords;
-	int start, end;
+	int rval = 0, nwords, start, end, i;
 	char **words;
-	int i;
 
 	/* Undo previous expansion */
 	if (cmd == 0 && expanded == EXPAND && buf) {
@@ -5037,9 +5141,9 @@
 		buf = 0;
 	}
 
-	nwords = x_cf_glob(XCF_COMMAND_FILE|XCF_FULLPATH,
-	    es->cbuf, es->linelen, es->cursor,
-	    &start, &end, &words, NULL);
+	i = XCF_COMMAND_FILE | XCF_FULLPATH;
+	nwords = x_cf_glob(&i, es->cbuf, es->linelen, es->cursor,
+	    &start, &end, &words);
 	if (nwords == 0) {
 		vi_error();
 		return (-1);
@@ -5049,7 +5153,8 @@
 	expanded = EXPAND;
 	del_range(start, end);
 	es->cursor = start;
-	for (i = 0; i < nwords; ) {
+	i = 0;
+	while (i < nwords) {
 		if (x_escape(words[i], strlen(words[i]), x_vi_putbuf) != 0) {
 			rval = -1;
 			break;
@@ -5074,10 +5179,10 @@
 complete_word(int cmd, int count)
 {
 	static struct edstate *buf;
-	int rval, nwords, start, end, match_len;
+	int rval, nwords, start, end, match_len, flags;
 	char **words;
 	char *match;
-	bool is_command, is_unique;
+	bool is_unique;
 
 	/* Undo previous completion */
 	if (cmd == 0 && expanded == COMPLETE && buf) {
@@ -5096,12 +5201,15 @@
 		buf = 0;
 	}
 
-	/* XCF_FULLPATH for count 'cause the menu printed by print_expansions()
-	 * was done this way.
+	/*
+	 * XCF_FULLPATH for count 'cause the menu printed by
+	 * print_expansions() was done this way.
 	 */
-	nwords = x_cf_glob(XCF_COMMAND_FILE | (count ? XCF_FULLPATH : 0),
-	    es->cbuf, es->linelen, es->cursor,
-	    &start, &end, &words, &is_command);
+	flags = XCF_COMMAND_FILE;
+	if (count)
+		flags |= XCF_FULLPATH;
+	nwords = x_cf_glob(&flags, es->cbuf, es->linelen, es->cursor,
+	    &start, &end, &words);
 	if (nwords == 0) {
 		vi_error();
 		return (-1);
@@ -5112,7 +5220,8 @@
 		count--;
 		if (count >= nwords) {
 			vi_error();
-			x_print_expansions(nwords, words, is_command);
+			x_print_expansions(nwords, words,
+			    flags & XCF_IS_COMMAND);
 			x_free_words(nwords, words);
 			redraw_line(0);
 			return (-1);
@@ -5120,7 +5229,7 @@
 		/*
 		 * Expand the count'th word to its basename
 		 */
-		if (is_command) {
+		if (flags & XCF_IS_COMMAND) {
 			match = words[count] +
 			    x_basename(words[count], NULL);
 			/* If more than one possible match, use full path */
@@ -5139,7 +5248,8 @@
 	} else {
 		match = words[0];
 		match_len = x_longest_prefix(nwords, words);
-		expanded = COMPLETE;	/* next call will list completions */
+		/* next call will list completions */
+		expanded = COMPLETE;
 		is_unique = nwords == 1;
 	}
 
@@ -5147,18 +5257,25 @@
 	del_range(start, end);
 	es->cursor = start;
 
-	/* escape all shell-sensitive characters and put the result into
-	 * command buffer */
+	/*
+	 * escape all shell-sensitive characters and put the result into
+	 * command buffer
+	 */
 	rval = x_escape(match, match_len, x_vi_putbuf);
 
 	if (rval == 0 && is_unique) {
-		/* If exact match, don't undo. Allows directory completions
+		/*
+		 * If exact match, don't undo. Allows directory completions
 		 * to be used (ie, complete the next portion of the path).
 		 */
 		expanded = NONE;
 
-		/* If not a directory, add a space to the end... */
-		if (match_len > 0 && match[match_len - 1] != '/')
+		/*
+		 * append a space if this is not a directory or the
+		 * result of a parameter substitution
+		 */
+		if (match_len > 0 && match[match_len - 1] != '/' &&
+		    !(flags & XCF_IS_VARSUB))
 			rval = putbuf(" ", 1, 0);
 	}
 	x_free_words(nwords, words);
@@ -5166,7 +5283,8 @@
 	modified = 1;
 	hnum = hlast;
 	insert = INSERT;
-	lastac = 0;	 /* prevent this from being redone... */
+	/* prevent this from being redone... */
+	lastac = 0;
 	refresh(0);
 
 	return (rval);
@@ -5175,18 +5293,17 @@
 static int
 print_expansions(struct edstate *est, int cmd MKSH_A_UNUSED)
 {
-	int start, end, nwords;
+	int start, end, nwords, i;
 	char **words;
-	bool is_command;
 
-	nwords = x_cf_glob(XCF_COMMAND_FILE | XCF_FULLPATH,
-	    est->cbuf, est->linelen, est->cursor,
-	    &start, &end, &words, &is_command);
+	i = XCF_COMMAND_FILE | XCF_FULLPATH;
+	nwords = x_cf_glob(&i, est->cbuf, est->linelen, est->cursor,
+	    &start, &end, &words);
 	if (nwords == 0) {
 		vi_error();
 		return (-1);
 	}
-	x_print_expansions(nwords, words, is_command);
+	x_print_expansions(nwords, words, i & XCF_IS_COMMAND);
 	x_free_words(nwords, words);
 	redraw_line(0);
 	return (0);
Index: src/bin/mksh/emacsfn.h
diff -u src/bin/mksh/emacsfn.h:1.4 src/bin/mksh/emacsfn.h:1.5
--- src/bin/mksh/emacsfn.h:1.4	Wed Sep 23 18:04:55 2009
+++ src/bin/mksh/emacsfn.h	Sat Jul 17 22:09:33 2010
@@ -1,86 +1,86 @@
 #if defined(EMACSFN_DEFNS)
-__RCSID("$MirOS: src/bin/mksh/emacsfn.h,v 1.4 2009/09/23 18:04:55 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/emacsfn.h,v 1.5 2010/07/17 22:09:33 tg Exp $");
 #define FN(cname,sname,flags)	static int x_##cname(int);
 #elif defined(EMACSFN_ENUMS)
 #define FN(cname,sname,flags)	XFUNC_##cname,
 #define F0(cname,sname,flags)	XFUNC_##cname = 0,
 #elif defined(EMACSFN_ITEMS)
-#define FN(cname,sname,flags)	{ x_##cname, #sname, flags },
+#define FN(cname,sname,flags)	{ x_##cname, sname, flags },
 #endif
 
 #ifndef F0
 #define F0 FN
 #endif
 
-F0(abort, abort, 0)
-FN(beg_hist, beginning-of-history, 0)
-FN(cls, clear-screen, 0)
-FN(comment, comment, 0)
-FN(comp_comm, complete-command, 0)
-FN(comp_file, complete-file, 0)
-FN(comp_list, complete-list, 0)
-FN(complete, complete, 0)
-FN(del_back, delete-char-backward, XF_ARG)
-FN(del_bword, delete-word-backward, XF_ARG)
-FN(del_char, delete-char-forward, XF_ARG)
-FN(del_fword, delete-word-forward, XF_ARG)
-FN(del_line, kill-line, 0)
-FN(draw_line, redraw, 0)
+F0(abort, "abort", 0)
+FN(beg_hist, "beginning-of-history", 0)
+FN(cls, "clear-screen", 0)
+FN(comment, "comment", 0)
+FN(comp_comm, "complete-command", 0)
+FN(comp_file, "complete-file", 0)
+FN(comp_list, "complete-list", 0)
+FN(complete, "complete", 0)
+FN(del_back, "delete-char-backward", XF_ARG)
+FN(del_bword, "delete-word-backward", XF_ARG)
+FN(del_char, "delete-char-forward", XF_ARG)
+FN(del_fword, "delete-word-forward", XF_ARG)
+FN(del_line, "kill-line", 0)
+FN(draw_line, "redraw", 0)
 #ifndef MKSH_SMALL
-FN(edit_line, edit-line, XF_ARG)
+FN(edit_line, "edit-line", XF_ARG)
 #endif
-FN(end_hist, end-of-history, 0)
-FN(end_of_text, eot, 0)
-FN(enumerate, list, 0)
-FN(eot_del, eot-or-delete, XF_ARG)
-FN(error, error, 0)
-FN(expand, expand-file, 0)
+FN(end_hist, "end-of-history", 0)
+FN(end_of_text, "eot", 0)
+FN(enumerate, "list", 0)
+FN(eot_del, "eot-or-delete", XF_ARG)
+FN(error, "error", 0)
+FN(expand, "expand-file", 0)
 #ifndef MKSH_SMALL
-FN(fold_capitalise, capitalize-word, XF_ARG)
-FN(fold_lower, downcase-word, XF_ARG)
-FN(fold_upper, upcase-word, XF_ARG)
+FN(fold_capitalise, "capitalize-word", XF_ARG)
+FN(fold_lower, "downcase-word", XF_ARG)
+FN(fold_upper, "upcase-word", XF_ARG)
 #endif
-FN(goto_hist, goto-history, XF_ARG)
+FN(goto_hist, "goto-history", XF_ARG)
 #ifndef MKSH_SMALL
-FN(ins_string, macro-string, XF_NOBIND)
+FN(ins_string, "macro-string", XF_NOBIND)
 #endif
-FN(insert, auto-insert, XF_ARG)
-FN(kill, kill-to-eol, XF_ARG)
-FN(kill_region, kill-region, 0)
-FN(list_comm, list-command, 0)
-FN(list_file, list-file, 0)
-FN(literal, quote, 0)
-FN(meta1, prefix-1, XF_PREFIX)
-FN(meta2, prefix-2, XF_PREFIX)
-FN(meta_yank, yank-pop, 0)
-FN(mv_back, backward-char, XF_ARG)
-FN(mv_begin, beginning-of-line, 0)
-FN(mv_bword, backward-word, XF_ARG)
-FN(mv_end, end-of-line, 0)
-FN(mv_forw, forward-char, XF_ARG)
-FN(mv_fword, forward-word, XF_ARG)
-FN(newline, newline, 0)
-FN(next_com, down-history, XF_ARG)
-FN(nl_next_com, newline-and-next, 0)
-FN(noop, no-op, 0)
-FN(prev_com, up-history, XF_ARG)
-FN(prev_histword, prev-hist-word, XF_ARG)
-FN(search_char_back, search-character-backward, XF_ARG)
-FN(search_char_forw, search-character-forward, XF_ARG)
-FN(search_hist, search-history, 0)
+FN(insert, "auto-insert", XF_ARG)
+FN(kill, "kill-to-eol", XF_ARG)
+FN(kill_region, "kill-region", 0)
+FN(list_comm, "list-command", 0)
+FN(list_file, "list-file", 0)
+FN(literal, "quote", 0)
+FN(meta1, "prefix-1", XF_PREFIX)
+FN(meta2, "prefix-2", XF_PREFIX)
+FN(meta_yank, "yank-pop", 0)
+FN(mv_back, "backward-char", XF_ARG)
+FN(mv_begin, "beginning-of-line", 0)
+FN(mv_bword, "backward-word", XF_ARG)
+FN(mv_end, "end-of-line", 0)
+FN(mv_forw, "forward-char", XF_ARG)
+FN(mv_fword, "forward-word", XF_ARG)
+FN(newline, "newline", 0)
+FN(next_com, "down-history", XF_ARG)
+FN(nl_next_com, "newline-and-next", 0)
+FN(noop, "no-op", 0)
+FN(prev_com, "up-history", XF_ARG)
+FN(prev_histword, "prev-hist-word", XF_ARG)
+FN(search_char_back, "search-character-backward", XF_ARG)
+FN(search_char_forw, "search-character-forward", XF_ARG)
+FN(search_hist, "search-history", 0)
 #ifndef MKSH_SMALL
-FN(search_hist_dn, search-history-down, 0)
-FN(search_hist_up, search-history-up, 0)
+FN(search_hist_dn, "search-history-down", 0)
+FN(search_hist_up, "search-history-up", 0)
 #endif
-FN(set_arg, set-arg, XF_NOBIND)
-FN(set_mark, set-mark-command, 0)
-FN(transpose, transpose-chars, 0)
-FN(version, version, 0)
+FN(set_arg, "set-arg", XF_NOBIND)
+FN(set_mark, "set-mark-command", 0)
+FN(transpose, "transpose-chars", 0)
+FN(version, "version", 0)
 #ifndef MKSH_SMALL
-FN(vt_hack, vt100-hack, XF_ARG)
+FN(vt_hack, "vt100-hack", XF_ARG)
 #endif
-FN(xchg_point_mark, exchange-point-and-mark, 0)
-FN(yank, yank, 0)
+FN(xchg_point_mark, "exchange-point-and-mark", 0)
+FN(yank, "yank", 0)
 
 #undef FN
 #undef F0
Index: src/bin/mksh/eval.c
diff -u src/bin/mksh/eval.c:1.83 src/bin/mksh/eval.c:1.104
--- src/bin/mksh/eval.c:1.83	Thu Feb 25 20:18:15 2010
+++ src/bin/mksh/eval.c	Mon May  2 22:52:51 2011
@@ -1,7 +1,7 @@
-/*	$OpenBSD: eval.c,v 1.34 2009/01/29 23:27:26 jaredy Exp $	*/
+/*	$OpenBSD: eval.c,v 1.36 2011/03/15 08:39:54 okan Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -22,7 +22,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.83 2010/02/25 20:18:15 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.104 2011/05/02 22:52:51 tg Exp $");
 
 /*
  * string expansion
@@ -108,7 +108,7 @@
 	s->start = s->str = cp;
 	source = s;
 	if (yylex(ONEWORD) != LWORD)
-		internal_errorf("substitute");
+		internal_errorf("bad substitution");
 	source = sold;
 	afree(s, ATEMP);
 	return (evalstr(yylval.cp, f));
@@ -129,7 +129,8 @@
 		return (vap.rw);
 	}
 	XPinit(w, 32);
-	XPput(w, NULL);		/* space for shell name */
+	/* space for shell name */
+	XPput(w, NULL);
 	while (*ap != NULL)
 		expand(*ap++, &w, f);
 	XPput(w, NULL);
@@ -188,7 +189,8 @@
 	short	stype;		/* [=+-?%#] action after expanded word */
 	short	base;		/* begin position of expanded word */
 	short	f;		/* saved value of f (DOPAT, etc) */
-	short	quote;		/* saved value of quote (for ${..[%#]..}) */
+	uint8_t	quotep;		/* saved value of quote (for ${..[%#]..}) */
+	uint8_t	quotew;		/* saved value of quote (for ${..[+-=]..}) */
 } SubType;
 
 void
@@ -204,11 +206,13 @@
 	const char *sp;		/* source */
 	int fdo, word;		/* second pass flags; have word */
 	int doblank;		/* field splitting of parameter/command subst */
-	Expand x = {		/* expansion variables */
+	Expand x = {
+		/* expansion variables */
 		NULL, { NULL }, NULL, 0
 	};
 	SubType st_head, *st;
-	int newlines = 0; /* For trailing newlines in COMSUB */
+	/* For trailing newlines in COMSUB */
+	int newlines = 0;
 	int saw_eq, tilde_ok;
 	int make_magic;
 	size_t len;
@@ -227,12 +231,14 @@
 	if (Flag(FBRACEEXPAND) && (f & DOGLOB))
 		f |= DOBRACE_;
 
-	Xinit(ds, dp, 128, ATEMP);	/* init dest. string */
+	/* init destination string */
+	Xinit(ds, dp, 128, ATEMP);
 	type = XBASE;
 	sp = cp;
 	fdo = 0;
 	saw_eq = 0;
-	tilde_ok = (f & (DOTILDE|DOASNTILDE)) ? 1 : 0; /* must be 1/0 */
+	/* must be 1/0 */
+	tilde_ok = (f & (DOTILDE|DOASNTILDE)) ? 1 : 0;
 	doblank = 0;
 	make_magic = 0;
 	word = (f&DOBLANK) ? IFS_WS : IFS_WORD;
@@ -240,11 +246,12 @@
 	memset(&st_head, 0, sizeof(st_head));
 	st = &st_head;
 
-	while (1) {
+	while (/* CONSTCOND */ 1) {
 		Xcheck(ds, dp);
 
 		switch (type) {
-		case XBASE:	/* original prefixed string */
+		case XBASE:
+			/* original prefixed string */
 			c = *sp++;
 			switch (c) {
 			case EOS:
@@ -254,7 +261,8 @@
 				c = *sp++;
 				break;
 			case QCHAR:
-				quote |= 2; /* temporary quote */
+				/* temporary quote */
+				quote |= 2;
 				c = *sp++;
 				break;
 			case OQUOTE:
@@ -263,7 +271,7 @@
 				quote = 1;
 				continue;
 			case CQUOTE:
-				quote = st->quote;	/* XXX correct? */
+				quote = st->quotew;
 				continue;
 			case COMSUB:
 				tilde_ok = 0;
@@ -298,7 +306,8 @@
 					char *p;
 
 					v.flag = DEFINED|ISSET|INTEGER;
-					v.type = 10; /* not default */
+					/* not default */
+					v.type = 10;
 					v.name[0] = '\0';
 					v_evaluate(&v, substitute(sp, 0),
 					    KSH_UNWIND_ERROR, true);
@@ -309,23 +318,27 @@
 					}
 				}
 				continue;
-			case OSUBST: {	/* ${{#}var{:}[=+-?#%]word} */
-			/* format is:
+			case OSUBST: {
+				/* ${{#}var{:}[=+-?#%]word} */
+			/*-
+			 * format is:
 			 *	OSUBST [{x] plain-variable-part \0
 			 *	    compiled-word-part CSUBST [}x]
 			 * This is where all syntax checking gets done...
 			 */
-				const char *varname = ++sp; /* skip the { or x (}) */
+				/* skip the { or x (}) */
+				const char *varname = ++sp;
 				int stype;
 				int slen = 0;
 
-				sp = cstrchr(sp, '\0') + 1; /* skip variable */
+				/* skip variable */
+				sp = cstrchr(sp, '\0') + 1;
 				type = varsub(&x, varname, sp, &stype, &slen);
 				if (type < 0) {
 					char *beg, *end, *str;
-
  unwind_substsyn:
-					sp = varname - 2; /* restore sp */
+					/* restore sp */
+					sp = varname - 2;
 					end = (beg = wdcopy(sp, ATEMP)) +
 					    (wdscan(sp, CSUBST) - sp);
 					/* ({) the } or x is already skipped */
@@ -333,12 +346,13 @@
 						*end = EOS;
 					str = snptreef(NULL, 64, "%S", beg);
 					afree(beg, ATEMP);
-					errorf("%s: bad substitution", str);
+					errorf("%s: %s", str, "bad substitution");
 				}
 				if (f & DOBLANK)
 					doblank++;
 				tilde_ok = 0;
-				if (type == XBASE) {	/* expand? */
+				if (type == XBASE) {
+					/* expand? */
 					if (!st->next) {
 						SubType *newst;
 
@@ -352,11 +366,15 @@
 					st->base = Xsavepos(ds, dp);
 					st->f = f;
 					st->var = x.var;
-					st->quote = quote;
+					st->quotew = st->quotep = quote;
 					/* skip qualifier(s) */
 					if (stype)
 						sp += slen;
-					switch (stype & 0x7f) {
+					switch (stype & 0x17F) {
+					case 0x100 | '#':
+						x.str = shf_smprintf("%08X",
+						    hash(str_val(st->var)));
+						break;
 					case '0': {
 						char *beg, *mid, *end, *stg;
 						mksh_ari_t from = 0, num = -1, flen, finc = 0;
@@ -373,16 +391,18 @@
 						} else {
 							end = mid +
 							    (wdscan(mid, ADELIM) - mid);
-							if (end >= stg)
+							if (end >= stg ||
+							    /* more than max delimiters */
+							    end[-1] != /*{*/ '}')
 								goto unwind_substsyn;
 							end[-2] = EOS;
 							sp += end - beg - 1;
 						}
-						evaluate(substitute(stg = wdstrip(beg, false, false), 0),
+						evaluate(substitute(stg = wdstrip(beg, 0), 0),
 						    &from, KSH_UNWIND_ERROR, true);
 						afree(stg, ATEMP);
 						if (end) {
-							evaluate(substitute(stg = wdstrip(mid, false, false), 0),
+							evaluate(substitute(stg = wdstrip(mid, 0), 0),
 							    &num, KSH_UNWIND_ERROR, true);
 							afree(stg, ATEMP);
 						}
@@ -421,10 +441,11 @@
 						else
 							d[-2] = EOS;
 						sp += (d ? d : p) - s - 1;
-						tpat0 = wdstrip(s, true, true);
+						tpat0 = wdstrip(s,
+						    WDS_KEEPQ | WDS_MAGIC);
 						pat = substitute(tpat0, 0);
 						if (d) {
-							d = wdstrip(p, true, false);
+							d = wdstrip(p, WDS_KEEPQ);
 							rrep = substitute(d, 0);
 							afree(d, ATEMP);
 						} else
@@ -444,12 +465,44 @@
 						*d = '\0';
 						afree(tpat0, ATEMP);
 
-						/* reject empty pattern */
-						if (!*pat || gmatchx("", pat, false))
+						/* check for special cases */
+						d = str_val(st->var);
+						switch (*pat) {
+						case '#':
+							/* anchor at begin */
+							tpat0 = pat + 1;
+							tpat1 = rrep;
+							tpat2 = d;
+							break;
+						case '%':
+							/* anchor at end */
+							tpat0 = pat + 1;
+							tpat1 = d;
+							tpat2 = rrep;
+							break;
+						case '\0':
+							/* empty pattern */
 							goto no_repl;
+						default:
+							tpat0 = pat;
+							/* silence gcc */
+							tpat1 = tpat2 = NULL;
+						}
+						if (gmatchx(null, tpat0, false)) {
+							/*
+							 * pattern matches
+							 * the empty string
+							 */
+							if (tpat0 == pat)
+								goto no_repl;
+							/* but is anchored */
+							s = shf_smprintf("%s%s",
+							    tpat1, tpat2);
+							goto do_repl;
+						}
 
 						/* prepare string on which to work */
-						strdupx(s, str_val(st->var), ATEMP);
+						strdupx(s, d, ATEMP);
 						sbeg = s;
 
 						/* first see if we have any match at all */
@@ -468,7 +521,8 @@
 							tpat2 = tpat1 + 2;
 						}
  again_repl:
-						/* this would not be necessary if gmatchx would return
+						/*
+						 * this would not be necessary if gmatchx would return
 						 * the start and end values of a match found, like re*
 						 */
 						if (!gmatchx(sbeg, tpat1, false))
@@ -488,8 +542,9 @@
 							while (p >= sbeg) {
 								bool gotmatch;
 
-								c = *p; *p = '\0';
-								gotmatch = gmatchx(sbeg, tpat0, false);
+								c = *p;
+								*p = '\0';
+								gotmatch = tobool(gmatchx(sbeg, tpat0, false));
 								*p = c;
 								if (gotmatch)
 									break;
@@ -505,6 +560,7 @@
 							goto again_repl;
  end_repl:
 						afree(tpat1, ATEMP);
+ do_repl:
 						x.str = s;
  no_repl:
 						afree(pat, ATEMP);
@@ -517,16 +573,21 @@
 						/* ! DOBLANK,DOBRACE_,DOTILDE */
 						f = DOPAT | (f&DONTRUNCOMMAND) |
 						    DOTEMP_;
-						quote = 0;
-						/* Prepend open pattern (so |
+						st->quotew = quote = 0;
+						/*
+						 * Prepend open pattern (so |
 						 * in a trim will work as
 						 * expected)
 						 */
-						*dp++ = MAGIC;
-						*dp++ = (char)('@' | 0x80);
+						if (!Flag(FSH)) {
+							*dp++ = MAGIC;
+							*dp++ = (char)('@' |
+							    0x80);
+						}
 						break;
 					case '=':
-						/* Enabling tilde expansion
+						/*
+						 * Enabling tilde expansion
 						 * after :s here is
 						 * non-standard ksh, but is
 						 * consistent with rules for
@@ -542,7 +603,8 @@
 						if (!(x.var->flag & INTEGER))
 							f |= DOASNTILDE|DOTILDE;
 						f |= DOTEMP_;
-						/* These will be done after the
+						/*
+						 * These will be done after the
 						 * value has been assigned.
 						 */
 						f &= ~(DOBLANK|DOGLOB|DOBRACE_);
@@ -562,47 +624,62 @@
 					sp += wdscan(sp, CSUBST) - sp;
 				continue;
 			}
-			case CSUBST: /* only get here if expanding word */
+			case CSUBST:
+				/* only get here if expanding word */
  do_CSUBST:
-				sp++; /* ({) skip the } or x */
-				tilde_ok = 0;	/* in case of ${unset:-} */
+				/* ({) skip the } or x */
+				sp++;
+				/* in case of ${unset:-} */
+				tilde_ok = 0;
 				*dp = '\0';
-				quote = st->quote;
+				quote = st->quotep;
 				f = st->f;
 				if (f&DOBLANK)
 					doblank--;
-				switch (st->stype&0x7f) {
+				switch (st->stype & 0x17F) {
 				case '#':
 				case '%':
-					/* Append end-pattern */
-					*dp++ = MAGIC; *dp++ = ')'; *dp = '\0';
+					if (!Flag(FSH)) {
+						/* Append end-pattern */
+						*dp++ = MAGIC;
+						*dp++ = ')';
+					}
+					*dp = '\0';
 					dp = Xrestpos(ds, dp, st->base);
-					/* Must use st->var since calling
+					/*
+					 * Must use st->var since calling
 					 * global would break things
 					 * like x[i+=1].
 					 */
 					x.str = trimsub(str_val(st->var),
 						dp, st->stype);
-					type = strlen(x.str) ? XSUB : XNULLSUB;
+					if (x.str[0] != '\0' || st->quotep)
+						type = XSUB;
+					else
+						type = XNULLSUB;
 					if (f&DOBLANK)
 						doblank++;
 					st = st->prev;
 					continue;
 				case '=':
-					/* Restore our position and substitute
+					/*
+					 * Restore our position and substitute
 					 * the value of st->var (may not be
 					 * the assigned value in the presence
 					 * of integer/right-adj/etc attributes).
 					 */
 					dp = Xrestpos(ds, dp, st->base);
-					/* Must use st->var since calling
+					/*
+					 * Must use st->var since calling
 					 * global would cause with things
 					 * like x[i+=1] to be evaluated twice.
 					 */
-					/* Note: not exported by FEXPORT
+					/*
+					 * Note: not exported by FEXPORT
 					 * in AT&T ksh.
 					 */
-					/* XXX POSIX says readonly is only
+					/*
+					 * XXX POSIX says readonly is only
 					 * fatal for special builtins (setstr
 					 * does readonly check).
 					 */
@@ -626,6 +703,7 @@
 				}
 				case '0':
 				case '/':
+				case 0x100 | '#':
 					dp = Xrestpos(ds, dp, st->base);
 					type = XSUB;
 					if (f&DOBLANK)
@@ -637,18 +715,21 @@
 				type = XBASE;
 				continue;
 
-			case OPAT: /* open pattern: *(foo|bar) */
+			case OPAT:
+				/* open pattern: *(foo|bar) */
 				/* Next char is the type of pattern */
 				make_magic = 1;
 				c = *sp++ + 0x80;
 				break;
 
-			case SPAT: /* pattern separator (|) */
+			case SPAT:
+				/* pattern separator (|) */
 				make_magic = 1;
 				c = '|';
 				break;
 
-			case CPAT: /* close pattern */
+			case CPAT:
+				/* close pattern */
 				make_magic = 1;
 				c = /*(*/ ')';
 				break;
@@ -656,14 +737,16 @@
 			break;
 
 		case XNULLSUB:
-			/* Special case for "$@" (and "${foo[@]}") - no
+			/*
+			 * Special case for "$@" (and "${foo[@]}") - no
 			 * word is generated if $# is 0 (unless there is
 			 * other stuff inside the quotes).
 			 */
 			type = XBASE;
 			if (f&DOBLANK) {
 				doblank--;
-				/* not really correct: x=; "$x$@" should
+				/*
+				 * not really correct: x=; "$x$@" should
 				 * generate a null argument and
 				 * set A; "${@:+}" shouldn't.
 				 */
@@ -687,7 +770,8 @@
 			quote = 1;
 		case XARG:
 			if ((c = *x.str++) == '\0') {
-				/* force null words to be created so
+				/*
+				 * force null words to be created so
 				 * set -- '' 2 ''; foo "$@" will do
 				 * the right thing
 				 */
@@ -714,7 +798,8 @@
 			break;
 
 		case XCOM:
-			if (newlines) {		/* Spit out saved NLs */
+			if (newlines) {
+				/* Spit out saved NLs */
 				c = '\n';
 				--newlines;
 			} else {
@@ -744,7 +829,8 @@
 		/* check for end of word or IFS separation */
 		if (c == 0 || (!quote && (f & DOBLANK) && doblank &&
 		    !make_magic && ctype(c, C_IFS))) {
-			/* How words are broken up:
+			/*-
+			 * How words are broken up:
 			 *			|	value of c
 			 *	word		|	ws	nws	0
 			 *	-----------------------------------
@@ -803,7 +889,8 @@
 				case NOT:
 				case '-':
 				case ']':
-					/* For character classes - doesn't hurt
+					/*
+					 * For character classes - doesn't hurt
 					 * to have magic !,-,]s outside of
 					 * [...] expressions.
 					 */
@@ -839,13 +926,15 @@
 						tilde_ok = 1;
 					}
 					break;
-				case ':': /* : */
+				case ':':
+					/* : */
 					/* Note unquoted : for ~ */
 					if (!(f & DOTEMP_) && (f & DOASNTILDE))
 						tilde_ok = 1;
 					break;
 				case '~':
-					/* tilde_ok is reset whenever
+					/*
+					 * tilde_ok is reset whenever
 					 * any of ' " $( $(( ${ } are seen.
 					 * Note that tilde_ok must be preserved
 					 * through the sequence ${A=a=}~
@@ -871,7 +960,8 @@
 					break;
 				}
 			else
-				quote &= ~2; /* undo temporary */
+				/* undo temporary */
+				quote &= ~2;
 
 			if (make_magic) {
 				make_magic = 0;
@@ -881,7 +971,8 @@
 				fdo |= DOMAGIC_;
 				*dp++ = MAGIC;
 			}
-			*dp++ = c; /* save output char */
+			/* save output char */
+			*dp++ = c;
 			word = IFS_WORD;
 		}
 	}
@@ -903,7 +994,8 @@
 	struct tbl *vp;
 	bool zero_ok = false;
 
-	if ((stype = sp[0]) == '\0')	/* Bad variable name */
+	if ((stype = sp[0]) == '\0')
+		/* Bad variable name */
 		return (-1);
 
 	xp->var = NULL;
@@ -970,8 +1062,9 @@
 			}
 		}
 		if (Flag(FNOUNSET) && c == 0 && !zero_ok)
-			errorf("%s: parameter not set", sp);
-		*stypep = 0; /* unqualified variable/string substitution */
+			errorf("%s: %s", sp, "parameter not set");
+		/* unqualified variable/string substitution */
+		*stypep = 0;
 		xp->str = shf_smprintf("%d", c);
 		return (XSUB);
 	}
@@ -996,14 +1089,24 @@
 	} else if (ctype(c, C_SUBOP1)) {
 		slen += 2;
 		stype |= c;
-	} else if (ctype(c, C_SUBOP2)) { /* Note: ksh88 allows :%, :%%, etc */
+	} else if (ctype(c, C_SUBOP2)) {
+		/* Note: ksh88 allows :%, :%%, etc */
 		slen += 2;
 		stype = c;
 		if (word[slen + 0] == CHAR && c == word[slen + 1]) {
 			stype |= 0x80;
 			slen += 2;
 		}
-	} else if (stype)	/* : is not ok */
+	} else if (c == '@') {
+		/* @x where x is command char */
+		slen += 2;
+		stype |= 0x100;
+		if (word[slen] == CHAR) {
+			stype |= word[slen + 1];
+			slen += 2;
+		}
+	} else if (stype)
+		/* : is not ok */
 		return (-1);
 	if (!stype && *word != CSUBST)
 		return (-1);
@@ -1012,10 +1115,13 @@
 
 	c = sp[0];
 	if (c == '*' || c == '@') {
-		switch (stype & 0x7f) {
+		switch (stype & 0x17F) {
 		case '=':	/* can't assign to a vector */
 		case '%':	/* can't trim a vector (yet) */
 		case '#':
+		case '0':
+		case '/':
+		case 0x100 | '#':
 			return (-1);
 		}
 		if (e->loc->argc == 0) {
@@ -1028,17 +1134,21 @@
 			xp->split = c == '@'; /* $@ */
 			state = XARG;
 		}
-		zero_ok = true;	/* POSIX 2009? */
+		/* POSIX 2009? */
+		zero_ok = true;
 	} else {
 		if ((p = cstrchr(sp, '[')) && (p[1] == '*' || p[1] == '@') &&
 		    p[2] == ']') {
 			XPtrV wv;
 
-			switch (stype & 0x7f) {
+			switch (stype & 0x17F) {
 			case '=':	/* can't assign to a vector */
 			case '%':	/* can't trim a vector (yet) */
 			case '#':
 			case '?':
+			case '0':
+			case '/':
+			case 0x100 | '#':
 				return (-1);
 			}
 			XPinit(wv, 32);
@@ -1065,7 +1175,7 @@
 			}
 		} else {
 			/* Can't assign things like $! or $1 */
-			if ((stype & 0x7f) == '=' &&
+			if ((stype & 0x17F) == '=' &&
 			    ctype(*sp, C_VAR1 | C_DIGIT))
 				return (-1);
 			if (*sp == '!' && sp[1]) {
@@ -1080,7 +1190,8 @@
 				} else if (xp->var->flag & ISSET)
 					xp->str = xp->var->name;
 				else
-					xp->str = "0";	/* ksh93 compat */
+					/* ksh93 compat */
+					xp->str = "0";
 			} else {
 				xp->var = global(sp);
 				xp->str = str_val(xp->var);
@@ -1089,15 +1200,17 @@
 		}
 	}
 
-	c = stype&0x7f;
+	c = stype & 0x7F;
 	/* test the compiler's code generator */
-	if (ctype(c, C_SUBOP2) || stype == (0x80 | '0') || c == '/' ||
+	if (((stype < 0x100) && (ctype(c, C_SUBOP2) || c == '/' ||
 	    (((stype&0x80) ? *xp->str=='\0' : xp->str==null) ? /* undef? */
-	    c == '=' || c == '-' || c == '?' : c == '+'))
-		state = XBASE;	/* expand word instead of variable value */
+	    c == '=' || c == '-' || c == '?' : c == '+'))) ||
+	    stype == (0x80 | '0') || stype == (0x100 | '#'))
+		/* expand word instead of variable value */
+		state = XBASE;
 	if (Flag(FNOUNSET) && xp->str == null && !zero_ok &&
 	    (ctype(c, C_SUBOP2) || (state != XBASE && c != '+')))
-		errorf("%s: parameter not set", sp);
+		errorf("%s: %s", sp, "parameter not set");
 	return (state);
 }
 
@@ -1110,30 +1223,33 @@
 	Source *s, *sold;
 	struct op *t;
 	struct shf *shf;
+	uint8_t old_utfmode = UTFMODE;
 
 	s = pushs(SSTRING, ATEMP);
 	s->start = s->str = cp;
 	sold = source;
-	t = compile(s);
+	t = compile(s, true);
 	afree(s, ATEMP);
 	source = sold;
 
 	if (t == NULL)
 		return (XBASE);
 
-	if (t != NULL && t->type == TCOM && /* $(<file) */
+	if (t != NULL && t->type == TCOM &&
 	    *t->args == NULL && *t->vars == NULL && t->ioact != NULL) {
+		/* $(<file) */
 		struct ioword *io = *t->ioact;
 		char *name;
 
-		if ((io->flag&IOTYPE) != IOREAD)
-			errorf("funny $() command: %s",
+		if ((io->flag & IOTYPE) != IOREAD)
+			errorf("%s: %s", "funny $() command",
 			    snptreef(NULL, 32, "%R", io));
 		shf = shf_open(name = evalstr(io->name, DOTILDE), O_RDONLY, 0,
 			SHF_MAPHI|SHF_CLEXEC);
 		if (shf == NULL)
-			errorf("%s: cannot open $() input", name);
-		xp->split = 0;	/* no waitlast() */
+			errorf("%s: %s %s", name, "can't open", "$() input");
+		/* no waitlast() */
+		xp->split = 0;
 	} else {
 		int ofd1, pv[2];
 		openpipe(pv);
@@ -1146,9 +1262,11 @@
 		execute(t, XFORK|XXCOM|XPIPEO, NULL);
 		restfd(1, ofd1);
 		startlast();
-		xp->split = 1;	/* waitlast() */
+		/* waitlast() */
+		xp->split = 1;
 	}
 
+	UTFMODE = old_utfmode;
 	xp->u.shf = shf;
 	return (XCOM);
 }
@@ -1164,7 +1282,8 @@
 	char *p, c;
 
 	switch (how & 0xFF) {
-	case '#':		/* shortest at beginning */
+	case '#':
+		/* shortest match at beginning */
 		for (p = str; p <= end; p += utf_ptradj(p)) {
 			c = *p; *p = '\0';
 			if (gmatchx(str, pat, false)) {
@@ -1174,7 +1293,8 @@
 			*p = c;
 		}
 		break;
-	case '#'|0x80:		/* longest match at beginning */
+	case '#'|0x80:
+		/* longest match at beginning */
 		for (p = end; p >= str; p--) {
 			c = *p; *p = '\0';
 			if (gmatchx(str, pat, false)) {
@@ -1184,7 +1304,8 @@
 			*p = c;
 		}
 		break;
-	case '%':		/* shortest match at end */
+	case '%':
+		/* shortest match at end */
 		p = end;
 		while (p >= str) {
 			if (gmatchx(p, pat, false))
@@ -1199,7 +1320,8 @@
 				--p;
 		}
 		break;
-	case '%'|0x80:		/* longest match at end */
+	case '%'|0x80:
+		/* longest match at end */
 		for (p = str; p <= end; p++)
 			if (gmatchx(p, pat, false)) {
  trimsub_match:
@@ -1209,7 +1331,8 @@
 		break;
 	}
 
-	return (str);		/* no match, return string */
+	/* no match, return string */
+	return (str);
 }
 
 /*
@@ -1235,7 +1358,8 @@
 #define GF_GLOBBED	BIT(1)		/* some globbing has been done */
 #define GF_MARKDIR	BIT(2)		/* add trailing / to directories */
 
-/* Apply file globbing to cp and store the matching files in wp. Returns
+/*
+ * Apply file globbing to cp and store the matching files in wp. Returns
  * the number of matches found.
  */
 int
@@ -1267,8 +1391,10 @@
 	/* This to allow long expansions to be interrupted */
 	intrcheck();
 
-	if (sp == NULL) {	/* end of source path */
-		/* We only need to check if the file exists if a pattern
+	if (sp == NULL) {
+		/* end of source path */
+		/*
+		 * We only need to check if the file exists if a pattern
 		 * is followed by a non-pattern (eg, foo*x/bar; no check
 		 * is needed for foo* since the match must exist) or if
 		 * any patterns were expanded and the markdirs option is set.
@@ -1284,7 +1410,8 @@
 
 			if (lstat(Xstring(*xs, xp), &lstatb) < 0)
 				return;
-			/* special case for systems which strip trailing
+			/*
+			 * special case for systems which strip trailing
 			 * slashes from regular files (eg, /etc/passwd/).
 			 * SunOS 4.1.3 does this...
 			 */
@@ -1293,7 +1420,8 @@
 			    (!S_ISLNK(lstatb.st_mode) ||
 			    stat_check() < 0 || !S_ISDIR(statb.st_mode)))
 				return;
-			/* Possibly tack on a trailing / if there isn't already
+			/*
+			 * Possibly tack on a trailing / if there isn't already
 			 * one and if the file is a directory or a symlink to a
 			 * directory
 			 */
@@ -1320,7 +1448,8 @@
 	np = strchr(sp, '/');
 	if (np != NULL) {
 		se = np;
-		odirsep = *np;	/* don't assume '/', can be multiple kinds */
+		/* don't assume '/', can be multiple kinds */
+		odirsep = *np;
 		*np++ = '\0';
 	} else {
 		odirsep = '\0'; /* keep gcc quiet */
@@ -1328,7 +1457,8 @@
 	}
 
 
-	/* Check if sp needs globbing - done to avoid pattern checks for strings
+	/*
+	 * Check if sp needs globbing - done to avoid pattern checks for strings
 	 * containing MAGIC characters, open [s without the matching close ],
 	 * etc. (otherwise opendir() will be called which may fail because the
 	 * directory isn't readable - if no globbing is needed, only execute
@@ -1357,7 +1487,8 @@
 			name = d->d_name;
 			if (name[0] == '.' &&
 			    (name[1] == 0 || (name[1] == '.' && name[2] == 0)))
-				continue; /* always ignore . and .. */
+				/* always ignore . and .. */
+				continue;
 			if ((*name == '.' && *sp != '.') ||
 			    !gmatchx(name, sp, true))
 				continue;
@@ -1408,7 +1539,8 @@
 	return (dp);
 }
 
-/* Check if p is an unquoted name, possibly followed by a / or :. If so
+/*
+ * Check if p is an unquoted name, possibly followed by a / or :. If so
  * puts the expanded version in *dcp,dp and returns a pointer in p just
  * past the name, otherwise returns 0.
  */
@@ -1526,7 +1658,8 @@
 	}
 	/* no valid expansions... */
 	if (!p || count != 0) {
-		/* Note that given a{{b,c} we do not expand anything (this is
+		/*
+		 * Note that given a{{b,c} we do not expand anything (this is
 		 * what AT&T ksh does. This may be changed to do the {b,c}
 		 * expansion. }
 		 */
@@ -1551,19 +1684,23 @@
 				count++;
 			else if ((*p == CBRACE && --count == 0) ||
 			    (*p == ',' && count == 1)) {
-				char *new;
+				char *news;
 				int l1, l2, l3;
 
+				/*
+				 * addition safe since these operate on
+				 * one string (separate substrings)
+				 */
 				l1 = brace_start - start;
 				l2 = (p - 1) - field_start;
 				l3 = end - brace_end;
-				new = alloc(l1 + l2 + l3 + 1, ATEMP);
-				memcpy(new, start, l1);
-				memcpy(new + l1, field_start, l2);
-				memcpy(new + l1 + l2, brace_end, l3);
-				new[l1 + l2 + l3] = '\0';
-				alt_expand(wp, new, new + l1,
-				    new + l1 + l2 + l3, fdo);
+				news = alloc(l1 + l2 + l3 + 1, ATEMP);
+				memcpy(news, start, l1);
+				memcpy(news + l1, field_start, l2);
+				memcpy(news + l1 + l2, brace_end, l3);
+				news[l1 + l2 + l3] = '\0';
+				alt_expand(wp, news, news + l1,
+				    news + l1 + l2 + l3, fdo);
 				field_start = p + 1;
 			}
 		}
Index: src/bin/mksh/exec.c
diff -u src/bin/mksh/exec.c:1.72 src/bin/mksh/exec.c:1.91
--- src/bin/mksh/exec.c:1.72	Sat Dec 12 22:27:06 2009
+++ src/bin/mksh/exec.c	Sat May  7 00:51:11 2011
@@ -1,7 +1,7 @@
 /*	$OpenBSD: exec.c,v 1.49 2009/01/29 23:27:26 jaredy Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -22,16 +22,20 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.72 2009/12/12 22:27:06 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.91 2011/05/07 00:51:11 tg Exp $");
 
-static int comexec(struct op *, struct tbl *volatile, const char **,
+#ifndef MKSH_DEFAULT_EXECSHELL
+#define MKSH_DEFAULT_EXECSHELL	"/bin/sh"
+#endif
+
+static int comexec(struct op *, struct tbl * volatile, const char **,
     int volatile, volatile int *);
 static void scriptexec(struct op *, const char **) MKSH_A_NORETURN;
 static int call_builtin(struct tbl *, const char **);
 static int iosetup(struct ioword *, struct tbl *);
-static int herein(const char *, int);
+static int herein(const char *, int, char **);
 static const char *do_selectargs(const char **, bool);
-static int dbteste_isa(Test_env *, Test_meta);
+static Test_op dbteste_isa(Test_env *, Test_meta);
 static const char *dbteste_getopnd(Test_env *, Test_op, bool);
 static void dbteste_error(Test_env *, int, const char *);
 
@@ -39,8 +43,9 @@
  * execute command tree
  */
 int
-execute(struct op *volatile t,
-    volatile int flags,		/* if XEXEC don't fork */
+execute(struct op * volatile t,
+    /* if XEXEC don't fork */
+    volatile int flags,
     volatile int * volatile xerrok)
 {
 	int i;
@@ -48,9 +53,10 @@
 	int pv[2];
 	const char ** volatile ap;
 	char ** volatile up;
-	const char *s, *cp;
+	const char *s, *ccp;
 	struct ioword **iowp;
 	struct tbl *tp = NULL;
+	char *cp;
 
 	if (t == NULL)
 		return (0);
@@ -67,15 +73,60 @@
 	if (trap)
 		runtraps(0);
 
+	/* we want to run an executable, do some variance checks */
 	if (t->type == TCOM) {
-		/* Clear subst_exstat before argument expansion. Used by
+		/* check if this is 'var=<<EOF' */
+		if (
+		    /* we have zero arguments, i.e. no programme to run */
+		    t->args[0] == NULL &&
+		    /* we have exactly one variable assignment */
+		    t->vars[0] != NULL && t->vars[1] == NULL &&
+		    /* we have exactly one I/O redirection */
+		    t->ioact != NULL && t->ioact[0] != NULL &&
+		    t->ioact[1] == NULL &&
+		    /* of type "here document" (or "here string") */
+		    (t->ioact[0]->flag & IOTYPE) == IOHERE &&
+		    /* the variable assignment begins with a valid varname */
+		    (ccp = skip_wdvarname(t->vars[0], true)) != t->vars[0] &&
+		    /* and has no right-hand side (i.e. "varname=") */
+		    ccp[0] == CHAR && ccp[1] == '=' && ccp[2] == EOS &&
+		    /* plus we can have a here document content */
+		    herein(t->ioact[0]->heredoc, t->ioact[0]->flag & IOEVAL,
+		    &cp) == 0 && cp && *cp) {
+			char *sp = cp, *dp;
+			size_t n = ccp - t->vars[0] + 2, z;
+
+			/* drop redirection (will be garbage collected) */
+			t->ioact = NULL;
+
+			/* set variable to its expanded value */
+			z = strlen(cp) + 1;
+			if (notoktomul(z, 2) || notoktoadd(z * 2, n))
+				internal_errorf(T_oomem, (unsigned long)-1);
+			dp = alloc(z * 2 + n, ATEMP);
+			memcpy(dp, t->vars[0], n);
+			t->vars[0] = dp;
+			dp += n;
+			while (*sp) {
+				*dp++ = QCHAR;
+				*dp++ = *sp++;
+			}
+			*dp = EOS;
+			/* free the expanded value */
+			afree(cp, APERM);
+		}
+
+		/*
+		 * Clear subst_exstat before argument expansion. Used by
 		 * null commands (see comexec() and c_eval()) and by c_set().
 		 */
 		subst_exstat = 0;
 
-		current_lineno = t->lineno;	/* for $LINENO */
+		/* for $LINENO */
+		current_lineno = t->lineno;
 
-		/* POSIX says expand command words first, then redirections,
+		/*
+		 * POSIX says expand command words first, then redirections,
 		 * and assignments last..
 		 */
 		up = eval(t->args, t->u.evalflags | DOBLANK | DOGLOB | DOTILDE);
@@ -84,8 +135,8 @@
 			timex_hook(t, &up);
 		ap = (const char **)up;
 		if (Flag(FXTRACE) && ap[0]) {
-			shf_fprintf(shl_out, "%s",
-				substitute(str_val(global("PS4")), 0));
+			shf_puts(substitute(str_val(global("PS4")), 0),
+			    shl_out);
 			for (i = 0; ap[i]; i++)
 				shf_fprintf(shl_out, "%s%c", ap[i],
 				    ap[i + 1] ? ' ' : '\n');
@@ -97,17 +148,21 @@
 	flags &= ~XTIME;
 
 	if (t->ioact != NULL || t->type == TPIPE || t->type == TCOPROC) {
-		e->savefd = alloc(NUFILE * sizeof(short), ATEMP);
+		e->savefd = alloc2(NUFILE, sizeof(short), ATEMP);
 		/* initialise to not redirected */
 		memset(e->savefd, 0, NUFILE * sizeof(short));
 	}
 
+	/* mark for replacement later (unless TPIPE) */
+	vp_pipest->flag |= INT_L;
+
 	/* do redirection, to be restored in quitenv() */
 	if (t->ioact != NULL)
 		for (iowp = t->ioact; *iowp != NULL; iowp++) {
 			if (iosetup(*iowp, tp) < 0) {
 				exstat = rv = 1;
-				/* Redirection failures for special commands
+				/*
+				 * Redirection failures for special commands
 				 * cause (non-interactive) shell to exit.
 				 */
 				if (tp && tp->type == CSHELL &&
@@ -134,7 +189,8 @@
 		e->savefd[1] = savefd(1);
 		while (t->type == TPIPE) {
 			openpipe(pv);
-			ksh_dup2(pv[1], 1, false); /* stdout of curr */
+			/* stdout of curr */
+			ksh_dup2(pv[1], 1, false);
 			/**
 			 * Let exchild() close pv[0] in child
 			 * (if this isn't done, commands like
@@ -143,15 +199,18 @@
 			 */
 			exchild(t->left, flags | XPIPEO | XCCLOSE,
 			    NULL, pv[0]);
-			ksh_dup2(pv[0], 0, false); /* stdin of next */
+			/* stdin of next */
+			ksh_dup2(pv[0], 0, false);
 			closepipe(pv);
 			flags |= XPIPEI;
 			t = t->right;
 		}
-		restfd(1, e->savefd[1]); /* stdout of last */
-		e->savefd[1] = 0; /* no need to re-restore this */
+		/* stdout of last */
+		restfd(1, e->savefd[1]);
+		/* no need to re-restore this */
+		e->savefd[1] = 0;
 		/* Let exchild() close 0 in parent, after fork, before wait */
-		i = exchild(t, flags | XPCLOSE, xerrok, 0);
+		i = exchild(t, flags | XPCLOSE | XPIPEST, xerrok, 0);
 		if (!(flags&XBGND) && !(flags&XXCOM))
 			rv = i;
 		break;
@@ -165,9 +224,11 @@
 		break;
 
 	case TCOPROC: {
+#ifndef MKSH_NOPROSPECTOFWORK
 		sigset_t omask;
 
-		/* Block sigchild as we are using things changed in the
+		/*
+		 * Block sigchild as we are using things changed in the
 		 * signal handler
 		 */
 		sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
@@ -179,6 +240,7 @@
 			unwind(i);
 			/* NOTREACHED */
 		}
+#endif
 		/* Already have a (live) co-process? */
 		if (coproc.job && coproc.write >= 0)
 			errorf("coprocess already exists");
@@ -204,15 +266,20 @@
 			openpipe(pv);
 			coproc.read = pv[0];
 			ksh_dup2(pv[1], 1, false);
-			coproc.readw = pv[1];	 /* closed before first read */
+			/* closed before first read */
+			coproc.readw = pv[1];
 			coproc.njobs = 0;
 			/* create new coprocess id */
 			++coproc.id;
 		}
+#ifndef MKSH_NOPROSPECTOFWORK
 		sigprocmask(SIG_SETMASK, &omask, NULL);
-		e->type = E_EXEC; /* no more need for error handler */
+		/* no more need for error handler */
+		e->type = E_EXEC;
+#endif
 
-		/* exchild() closes coproc.* in child after fork,
+		/*
+		 * exchild() closes coproc.* in child after fork,
 		 * will also increment coproc.njobs when the
 		 * job is actually created.
 		 */
@@ -223,7 +290,8 @@
 	}
 
 	case TASYNC:
-		/* XXX non-optimal, I think - "(foo &)", forks for (),
+		/*
+		 * XXX non-optimal, I think - "(foo &)", forks for (),
 		 * forks again for async... parent should optimise
 		 * this to "foo &"...
 		 */
@@ -268,7 +336,7 @@
 		    (const char **)eval((const char **)t->vars,
 		    DOBLANK | DOGLOB | DOTILDE);
 		e->type = E_LOOP;
-		while (1) {
+		while (/* CONSTCOND */ 1) {
 			i = sigsetjmp(e->jbuf, 0);
 			if (!i)
 				break;
@@ -281,20 +349,22 @@
 				goto Break;
 			}
 		}
-		rv = 0; /* in case of a continue */
+		/* in case of a continue */
+		rv = 0;
 		if (t->type == TFOR) {
 			while (*ap != NULL) {
 				setstr(global(t->str), *ap++, KSH_UNWIND_ERROR);
 				rv = execute(t->left, flags & XERROK, xerrok);
 			}
-		} else { /* TSELECT */
+		} else {
+			/* TSELECT */
 			for (;;) {
-				if (!(cp = do_selectargs(ap, is_first))) {
+				if (!(ccp = do_selectargs(ap, is_first))) {
 					rv = 1;
 					break;
 				}
 				is_first = false;
-				setstr(global(t->str), cp, KSH_UNWIND_ERROR);
+				setstr(global(t->str), ccp, KSH_UNWIND_ERROR);
 				execute(t->left, flags & XERROK, xerrok);
 			}
 		}
@@ -304,7 +374,7 @@
 	case TWHILE:
 	case TUNTIL:
 		e->type = E_LOOP;
-		while (1) {
+		while (/* CONSTCOND */ 1) {
 			i = sigsetjmp(e->jbuf, 0);
 			if (!i)
 				break;
@@ -317,7 +387,8 @@
 				goto Break;
 			}
 		}
-		rv = 0; /* in case of a continue */
+		/* in case of a continue */
+		rv = 0;
 		while ((execute(t->left, XERROK, NULL) == 0) ==
 		    (t->type == TWHILE))
 			rv = execute(t->right, flags & XERROK, xerrok);
@@ -326,18 +397,19 @@
 	case TIF:
 	case TELIF:
 		if (t->right == NULL)
-			break;	/* should be error */
+			/* should be error */
+			break;
 		rv = execute(t->left, XERROK, NULL) == 0 ?
 		    execute(t->right->left, flags & XERROK, xerrok) :
 		    execute(t->right->right, flags & XERROK, xerrok);
 		break;
 
 	case TCASE:
-		cp = evalstr(t->str, DOTILDE);
+		ccp = evalstr(t->str, DOTILDE);
 		for (t = t->left; t != NULL && t->type == TPAT; t = t->right)
 		    for (ap = (const char **)t->vars; *ap; ap++)
 			if ((s = evalstr(*ap, DOTILDE|DOPAT)) &&
-			    gmatchx(cp, s, false))
+			    gmatchx(ccp, s, false))
 				goto Found;
 		break;
  Found:
@@ -353,13 +425,15 @@
 		break;
 
 	case TTIME:
-		/* Clear XEXEC so nested execute() call doesn't exit
+		/*
+		 * Clear XEXEC so nested execute() call doesn't exit
 		 * (allows "ls -l | time grep foo").
 		 */
 		rv = timex(t, flags & ~XEXEC, xerrok);
 		break;
 
-	case TEXEC:		/* an eval'd TCOM */
+	case TEXEC:
+		/* an eval'd TCOM */
 		s = t->args[0];
 		up = makenv();
 		restoresigs();
@@ -378,10 +452,18 @@
 	}
  Break:
 	exstat = rv;
+	if (vp_pipest->flag & INT_L) {
+		unset(vp_pipest, 1);
+		vp_pipest->flag = DEFINED | ISSET | INTEGER | RDONLY |
+		    ARRAY | INT_U;
+		vp_pipest->val.i = rv;
+	}
 
-	quitenv(NULL);		/* restores IO */
+	/* restores IO */
+	quitenv(NULL);
 	if ((flags&XEXEC))
-		unwind(LEXIT);	/* exit child */
+		/* exit child */
+		unwind(LEXIT);
 	if (rv != 0 && !(flags & XERROK) &&
 	    (xerrok == NULL || !*xerrok)) {
 		trapsig(SIGERR_);
@@ -396,20 +478,23 @@
  */
 
 static int
-comexec(struct op *t, struct tbl *volatile tp, const char **ap,
+comexec(struct op *t, struct tbl * volatile tp, const char **ap,
     volatile int flags, volatile int *xerrok)
 {
 	int i;
 	volatile int rv = 0;
 	const char *cp;
 	const char **lastp;
-	static struct op texec; /* Must be static (XXX but why?) */
+	/* Must be static (XXX but why?) */
+	static struct op texec;
 	int type_flags;
 	int keepasn_ok;
 	int fcflags = FC_BI|FC_FUNC|FC_PATH;
 	bool bourne_function_call = false;
+	struct block *l_expand, *l_assign;
 
-	/* snag the last argument for $_ XXX not the same as AT&T ksh,
+	/*
+	 * snag the last argument for $_ XXX not the same as AT&T ksh,
 	 * which only seems to set $_ after a newline (but not in
 	 * functions/dot scripts, but in interactive and script) -
 	 * perhaps save last arg here and set it in shell()?.
@@ -422,7 +507,8 @@
 		    KSH_RETURN_ERROR);
 	}
 
-	/* Deal with the shell builtins builtin, exec and command since
+	/**
+	 * Deal with the shell builtins builtin, exec and command since
 	 * they can be followed by other commands. This must be done before
 	 * we know if we should create a local block which must be done
 	 * before we can do a path search (in case the assignments change
@@ -436,15 +522,16 @@
 	 */
 	keepasn_ok = 1;
 	while (tp && tp->type == CSHELL) {
-		fcflags = FC_BI|FC_FUNC|FC_PATH;/* undo effects of command */
+		/* undo effects of command */
+		fcflags = FC_BI|FC_FUNC|FC_PATH;
 		if (tp->val.f == c_builtin) {
-			if ((cp = *++ap) == NULL) {
+			if ((cp = *++ap) == NULL ||
+			    (!strcmp(cp, "--") && (cp = *++ap) == NULL)) {
 				tp = NULL;
 				break;
 			}
-			tp = findcom(cp, FC_BI);
-			if (tp == NULL)
-				errorf("builtin: %s: not a builtin", cp);
+			if ((tp = findcom(cp, FC_BI)) == NULL)
+				errorf("%s: %s: %s", T_builtin, cp, "not a builtin");
 			continue;
 		} else if (tp->val.f == c_exec) {
 			if (ap[1] == NULL)
@@ -454,27 +541,30 @@
 		} else if (tp->val.f == c_command) {
 			int optc, saw_p = 0;
 
-			/* Ugly dealing with options in two places (here and
-			 * in c_command(), but such is life)
+			/*
+			 * Ugly dealing with options in two places (here
+			 * and in c_command(), but such is life)
 			 */
 			ksh_getopt_reset(&builtin_opt, 0);
 			while ((optc = ksh_getopt(ap, &builtin_opt, ":p")) == 'p')
 				saw_p = 1;
 			if (optc != EOF)
-				break;	/* command -vV or something */
+				/* command -vV or something */
+				break;
 			/* don't look for functions */
 			fcflags = FC_BI|FC_PATH;
 			if (saw_p) {
 				if (Flag(FRESTRICTED)) {
-					warningf(true,
-					    "command -p: restricted");
+					warningf(true, "%s: %s",
+					    "command -p", "restricted");
 					rv = 1;
 					goto Leave;
 				}
 				fcflags |= FC_DEFPATH;
 			}
 			ap += builtin_opt.optind;
-			/* POSIX says special builtins lose their status
+			/*
+			 * POSIX says special builtins lose their status
 			 * if accessed using command.
 			 */
 			keepasn_ok = 0;
@@ -483,10 +573,28 @@
 				subst_exstat = 0;
 				break;
 			}
+		} else if (tp->val.f == c_cat) {
+			/*
+			 * if we have any flags, do not use the builtin
+			 * in theory, we could allow -u, but that would
+			 * mean to use ksh_getopt here and possibly ad-
+			 * ded complexity and more code and isn't worth
+			 * additional hassle (and the builtin must call
+			 * ksh_getopt already but can't come back here)
+			 */
+			if (ap[1] && ap[1][0] == '-' && ap[1][1] != '\0' &&
+			    /* argument, begins with -, is not - or -- */
+			    (ap[1][1] != '-' || ap[1][2] != '\0'))
+				/* don't look for builtins or functions */
+				fcflags = FC_PATH;
+			else
+				/* go on, use the builtin */
+				break;
 		} else
 			break;
 		tp = findcom(ap[0], fcflags & (FC_BI|FC_FUNC));
 	}
+	l_expand = e->loc;
 	if (keepasn_ok && (!ap[0] || (tp && (tp->flag & KEEPASN))))
 		type_flags = 0;
 	else {
@@ -500,14 +608,20 @@
 		} else
 			type_flags = LOCAL|LOCAL_COPY|EXPORT;
 	}
+	l_assign = e->loc;
 	if (Flag(FEXPORT))
 		type_flags |= EXPORT;
 	for (i = 0; t->vars[i]; i++) {
+		/* do NOT lookup in the new var/fn block just created */
+		e->loc = l_expand;
 		cp = evalstr(t->vars[i], DOASNTILDE);
+		e->loc = l_assign;
+		/* but assign in there as usual */
+
 		if (Flag(FXTRACE)) {
 			if (i == 0)
-				shf_fprintf(shl_out, "%s",
-					substitute(str_val(global("PS4")), 0));
+				shf_puts(substitute(str_val(global("PS4")), 0),
+				    shl_out);
 			shf_fprintf(shl_out, "%s%c", cp,
 			    t->vars[i + 1] ? ' ' : '\n');
 			if (!t->vars[i + 1])
@@ -523,7 +637,7 @@
 		goto Leave;
 	} else if (!tp) {
 		if (Flag(FRESTRICTED) && vstrchr(cp, '/')) {
-			warningf(true, "%s: restricted", cp);
+			warningf(true, "%s: %s", cp, "restricted");
 			rv = 1;
 			goto Leave;
 		}
@@ -531,54 +645,57 @@
 	}
 
 	switch (tp->type) {
-	case CSHELL:			/* shell built-in */
+
+	/* shell built-in */
+	case CSHELL:
 		rv = call_builtin(tp, (const char **)ap);
 		break;
 
-	case CFUNC: {			/* function call */
+	/* function call */
+	case CFUNC: {
 		volatile unsigned char old_xflag;
 		volatile Tflag old_inuse;
-		const char *volatile old_kshname;
+		const char * volatile old_kshname;
 
 		if (!(tp->flag & ISSET)) {
 			struct tbl *ftp;
 
 			if (!tp->u.fpath) {
 				if (tp->u2.errno_) {
-					warningf(true,
-					    "%s: can't find function "
-					    "definition file - %s",
-					    cp, strerror(tp->u2.errno_));
+					warningf(true, "%s: %s %s: %s", cp,
+					    "can't find",
+					    "function definition file",
+					    strerror(tp->u2.errno_));
 					rv = 126;
 				} else {
-					warningf(true,
-					    "%s: can't find function "
-					    "definition file", cp);
+					warningf(true, "%s: %s %s", cp,
+					    "can't find",
+					    "function definition file");
 					rv = 127;
 				}
 				break;
 			}
 			if (include(tp->u.fpath, 0, NULL, 0) < 0) {
 				rv = errno;
-				warningf(true,
-				    "%s: can't open function definition file %s - %s",
-				    cp, tp->u.fpath, strerror(rv));
+				warningf(true, "%s: %s %s %s: %s", cp,
+				    "can't open", "function definition file",
+				    tp->u.fpath, strerror(rv));
 				rv = 127;
 				break;
 			}
 			if (!(ftp = findfunc(cp, hash(cp), false)) ||
 			    !(ftp->flag & ISSET)) {
-				warningf(true,
-				    "%s: function not defined by %s",
-				    cp, tp->u.fpath);
+				warningf(true, "%s: %s %s", cp,
+				    "function not defined by", tp->u.fpath);
 				rv = 127;
 				break;
 			}
 			tp = ftp;
 		}
 
-		/* ksh functions set $0 to function name, POSIX functions leave
-		 * $0 unchanged.
+		/*
+		 * ksh functions set $0 to function name, POSIX
+		 * functions leave $0 unchanged.
 		 */
 		old_kshname = kshname;
 		if (tp->flag & FKSH)
@@ -589,7 +706,8 @@
 		for (i = 0; *ap++ != NULL; i++)
 			;
 		e->loc->argc = i - 1;
-		/* ksh-style functions handle getopts sanely,
+		/*
+		 * ksh-style functions handle getopts sanely,
 		 * Bourne/POSIX functions are insane...
 		 */
 		if (tp->flag & FKSH) {
@@ -599,7 +717,7 @@
 		}
 
 		old_xflag = Flag(FXTRACE);
-		Flag(FXTRACE) = tp->flag & TRACE ? 1 : 0;
+		Flag(FXTRACE) |= tp->flag & TRACE ? 1 : 0;
 
 		old_inuse = tp->flag & FINUSE;
 		tp->flag |= FINUSE;
@@ -614,9 +732,10 @@
 		kshname = old_kshname;
 		Flag(FXTRACE) = old_xflag;
 		tp->flag = (tp->flag & ~FINUSE) | old_inuse;
-		/* Were we deleted while executing? If so, free the execution
-		 * tree. todo: Unfortunately, the table entry is never re-used
-		 * until the lookup table is expanded.
+		/*
+		 * Were we deleted while executing? If so, free the
+		 * execution tree. TODO: Unfortunately, the table entry
+		 * is never re-used until the lookup table is expanded.
 		 */
 		if ((tp->flag & (FDELETE|FINUSE)) == FDELETE) {
 			if (tp->flag & ALLOC) {
@@ -639,25 +758,29 @@
 			/* NOTREACHED */
 		default:
 			quitenv(NULL);
-			internal_errorf("CFUNC %d", i);
+			internal_errorf("%s %d", "CFUNC", i);
 		}
 		break;
 	}
 
-	case CEXEC:		/* executable command */
-	case CTALIAS:		/* tracked alias */
+	/* executable command */
+	case CEXEC:
+	/* tracked alias */
+	case CTALIAS:
 		if (!(tp->flag&ISSET)) {
-			/* errno_ will be set if the named command was found
+			/*
+			 * errno_ will be set if the named command was found
 			 * but could not be executed (permissions, no execute
 			 * bit, directory, etc). Print out a (hopefully)
 			 * useful error message and set the exit status to 126.
 			 */
 			if (tp->u2.errno_) {
-				warningf(true, "%s: cannot execute - %s", cp,
-				    strerror(tp->u2.errno_));
-				rv = 126;	/* POSIX */
+				warningf(true, "%s: %s: %s", cp,
+				    "can't execute", strerror(tp->u2.errno_));
+				/* POSIX */
+				rv = 126;
 			} else {
-				warningf(true, "%s: not found", cp);
+				warningf(true, "%s: %s", cp, "not found");
 				rv = 127;
 			}
 			break;
@@ -682,7 +805,8 @@
 
 		/* to fork we set up a TEXEC node and call execute */
 		texec.type = TEXEC;
-		texec.left = t;	/* for tprint */
+		/* for tprint */
+		texec.left = t;
 		texec.str = tp->val.s;
 		texec.args = ap;
 		rv = exchild(&texec, flags, xerrok, -1);
@@ -702,7 +826,8 @@
 	const char *sh;
 #ifndef MKSH_SMALL
 	unsigned char *cp;
-	char buf[64];		/* 64 == MAXINTERP in MirBSD <sys/param.h> */
+	/* 64 == MAXINTERP in MirBSD <sys/param.h> */
+	char buf[64];
 	int fd;
 #endif
 	union mksh_ccphack args, cap;
@@ -711,7 +836,7 @@
 	if (sh && *sh)
 		sh = search(sh, path, X_OK, NULL);
 	if (!sh || !*sh)
-		sh = "/bin/sh";
+		sh = MKSH_DEFAULT_EXECSHELL;
 
 	*tp->args-- = tp->str;
 
@@ -722,8 +847,15 @@
 			/* read error -> no good */
 			buf[0] = '\0';
 		close(fd);
-		/* scan for newline (or CR) or NUL _before_ end of buffer */
+
+		/* skip UTF-8 Byte Order Mark, if present */
 		cp = (unsigned char *)buf;
+		if ((cp[0] == 0xEF) && (cp[1] == 0xBB) && (cp[2] == 0xBF))
+			cp += 3;
+		/* save begin of shebang for later */
+		fd = (char *)cp - buf;		/* either 0 or (if BOM) 3 */
+
+		/* scan for newline (or CR) or NUL _before_ end of buffer */
 		while ((char *)cp < (buf + sizeof(buf)))
 			if (*cp == '\0' || *cp == '\n' || *cp == '\r') {
 				*cp = '\0';
@@ -733,13 +865,13 @@
 		/* if the shebang line is longer than MAXINTERP, bail out */
 		if ((char *)cp >= (buf + sizeof(buf)))
 			goto noshebang;
-		/* skip UTF-8 Byte Order Mark, if present */
-		cp = (unsigned char *)buf;
-		if ((cp[0] == 0xEF) && (cp[1] == 0xBB) && (cp[2] == 0xBF))
-			cp += 3;
+
+		/* restore begin of shebang position (buf+0 or buf+3) */
+		cp = (unsigned char *)(buf + fd);
 		/* bail out if read error (above) or no shebang */
 		if ((cp[0] != '#') || (cp[1] != '!'))
 			goto noshebang;
+
 		cp += 2;
 		/* skip whitespace before shell name */
 		while (*cp == ' ' || *cp == '\t')
@@ -794,7 +926,7 @@
 
 	tp = ktsearch(&builtins, *wp, hash(*wp));
 	if (tp == NULL)
-		internal_errorf("shcomexec: %s", *wp);
+		internal_errorf("%s: %s", "shcomexec", *wp);
 	return (call_builtin(tp, wp));
 }
 
@@ -830,20 +962,31 @@
 int
 define(const char *name, struct op *t)
 {
+	uint32_t nhash;
 	struct tbl *tp;
 	bool was_set = false;
 
-	while (1) {
-		tp = findfunc(name, hash(name), true);
+	nhash = hash(name);
+
+	if (t != NULL && !tobool(t->u.ksh_func)) {
+		/* drop same-name aliases for POSIX functions */
+		if ((tp = ktsearch(&aliases, name, nhash)))
+			ktdelete(tp);
+	}
+
+	while (/* CONSTCOND */ 1) {
+		tp = findfunc(name, nhash, true);
 
 		if (tp->flag & ISSET)
 			was_set = true;
-		/* If this function is currently being executed, we zap this
-		 * table entry so findfunc() won't see it
+		/*
+		 * If this function is currently being executed, we zap
+		 * this table entry so findfunc() won't see it
 		 */
 		if (tp->flag & FINUSE) {
 			tp->name[0] = '\0';
-			tp->flag &= ~DEFINED; /* ensure it won't be found */
+			/* ensure it won't be found */
+			tp->flag &= ~DEFINED;
 			tp->flag |= FDELETE;
 		} else
 			break;
@@ -854,7 +997,8 @@
 		tfree(tp->val.t, tp->areap);
 	}
 
-	if (t == NULL) {		/* undefine */
+	if (t == NULL) {
+		/* undefine */
 		ktdelete(tp);
 		return (was_set ? 0 : 1);
 	}
@@ -870,7 +1014,7 @@
 /*
  * add builtin
  */
-void
+const char *
 builtin(const char *name, int (*func) (const char **))
 {
 	struct tbl *tp;
@@ -878,11 +1022,14 @@
 
 	/* see if any flags should be set for this builtin */
 	for (flag = 0; ; name++) {
-		if (*name == '=')	/* command does variable assignment */
+		if (*name == '=')
+			/* command does variable assignment */
 			flag |= KEEPASN;
-		else if (*name == '*')	/* POSIX special builtin */
+		else if (*name == '*')
+			/* POSIX special builtin */
 			flag |= SPEC_BI;
-		else if (*name == '+')	/* POSIX regular builtin */
+		else if (*name == '+')
+			/* POSIX regular builtin */
 			flag |= REG_BI;
 		else
 			break;
@@ -892,6 +1039,8 @@
 	tp->flag = DEFINED | flag;
 	tp->type = CSHELL;
 	tp->val.f = func;
+
+	return (name);
 }
 
 /*
@@ -904,8 +1053,10 @@
 	static struct tbl temp;
 	uint32_t h = hash(name);
 	struct tbl *tp = NULL, *tbi;
-	unsigned char insert = Flag(FTRACKALL);	/* insert if not found */
-	char *fpath;			/* for function autoloading */
+	/* insert if not found */
+	unsigned char insert = Flag(FTRACKALL);
+	/* for function autoloading */
+	char *fpath;
 	union mksh_cchack npath;
 
 	if (vstrchr(name, '/')) {
@@ -915,7 +1066,8 @@
 		goto Search;
 	}
 	tbi = (flags & FC_BI) ? ktsearch(&builtins, name, h) : NULL;
-	/* POSIX says special builtins first, then functions, then
+	/*
+	 * POSIX says special builtins first, then functions, then
 	 * POSIX regular builtins, then search path...
 	 */
 	if ((flags & FC_SPECBI) && tbi && (tbi->flag & SPEC_BI))
@@ -957,7 +1109,8 @@
 				tp = &temp;
 				tp->type = CEXEC;
 			}
-			tp->flag = DEFINED;	/* make ~ISSET */
+			/* make ~ISSET */
+			tp->flag = DEFINED;
 		}
 		npath.ro = search(name, flags & FC_DEFPATH ? def_path : path,
 		    X_OK, &tp->u2.errno_);
@@ -970,14 +1123,16 @@
 		    (fpath = str_val(global("FPATH"))) != null &&
 		    (npath.ro = search(name, fpath, R_OK,
 		    &tp->u2.errno_)) != NULL) {
-			/* An undocumented feature of AT&T ksh is that it
-			 * searches FPATH if a command is not found, even
-			 * if the command hasn't been set up as an autoloaded
-			 * function (ie, no typeset -uf).
+			/*
+			 * An undocumented feature of AT&T ksh is that
+			 * it searches FPATH if a command is not found,
+			 * even if the command hasn't been set up as an
+			 * autoloaded function (ie, no typeset -uf).
 			 */
 			tp = &temp;
 			tp->type = CFUNC;
-			tp->flag = DEFINED; /* make ~ISSET */
+			/* make ~ISSET */
+			tp->flag = DEFINED;
 			tp->u.fpath = npath.ro;
 		}
 	}
@@ -986,9 +1141,10 @@
 
 /*
  * flush executable commands with relative paths
+ * (just relative or all?)
  */
 void
-flushcom(int all)	/* just relative or all */
+flushcom(bool all)
 {
 	struct tbl *tp;
 	struct tstate ts;
@@ -1006,7 +1162,8 @@
 /* Check if path is something we want to find. Returns -1 for failure. */
 int
 search_access(const char *lpath, int mode,
-    int *errnop)	/* set if candidate found, but not suitable */
+    /* set if candidate found, but not suitable */
+    int *errnop)
 {
 	int ret, err = 0;
 	struct stat statb;
@@ -1015,7 +1172,8 @@
 		return (-1);
 	ret = access(lpath, mode);
 	if (ret < 0)
-		err = errno; /* File exists, but we can't access it */
+		/* File exists, but we can't access it */
+		err = errno;
 	else if (mode == X_OK && (!S_ISREG(statb.st_mode) ||
 	    !(statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)))) {
 		/* This 'cause access() says root can execute everything */
@@ -1032,8 +1190,10 @@
  */
 const char *
 search(const char *name, const char *lpath,
-    int mode,		/* R_OK or X_OK */
-    int *errnop)	/* set if candidate found, but not suitable */
+    /* R_OK or X_OK */
+    int mode,
+    /* set if candidate found, but not suitable */
+    int *errnop)
 {
 	const char *sp, *p;
 	char *xp;
@@ -1082,11 +1242,11 @@
 	builtin_argv0 = wp[0];
 	builtin_flag = tp->flag;
 	shf_reopen(1, SHF_WR, shl_stdout);
-	shl_stdout_ok = 1;
+	shl_stdout_ok = true;
 	ksh_getopt_reset(&builtin_opt, GF_ERROR);
 	rv = (*tp->val.f)(wp);
 	shf_flush(shl_stdout);
-	shl_stdout_ok = 0;
+	shl_stdout_ok = false;
 	builtin_flag = 0;
 	builtin_argv0 = NULL;
 	return (rv);
@@ -1129,7 +1289,8 @@
 
 	case IOWRITE:
 		flags = O_WRONLY | O_CREAT | O_TRUNC;
-		/* The stat() is here to allow redirections to
+		/*
+		 * The stat() is here to allow redirections to
 		 * things like /dev/null without error.
 		 */
 		if (Flag(FNOCLOBBER) && !(iop->flag & IOCLOB) &&
@@ -1144,7 +1305,7 @@
 	case IOHERE:
 		do_open = 0;
 		/* herein() returns -2 if error has been printed */
-		u = herein(iop->heredoc, iop->flag & IOEVAL);
+		u = herein(iop->heredoc, iop->flag & IOEVAL, NULL);
 		/* cp may have wrong name */
 		break;
 
@@ -1153,7 +1314,8 @@
 
 		do_open = 0;
 		if (*cp == '-' && !cp[1]) {
-			u = 1009;	 /* prevent error return below */
+			/* prevent error return below */
+			u = 1009;
 			do_close = 1;
 		} else if ((u = check_fd(cp,
 		    X_OK | ((iop->flag & IORDUP) ? R_OK : W_OK),
@@ -1163,14 +1325,15 @@
 			return (-1);
 		}
 		if (u == iop->unit)
-			return (0);		/* "dup from" == "dup to" */
+			/* "dup from" == "dup to" */
+			return (0);
 		break;
 	}
 	}
 
 	if (do_open) {
 		if (Flag(FRESTRICTED) && (flags & O_CREAT)) {
-			warningf(true, "%s: restricted", cp);
+			warningf(true, "%s: %s", cp, "restricted");
 			return (-1);
 		}
 		u = open(cp, flags, 0666);
@@ -1179,7 +1342,7 @@
 		/* herein() may already have printed message */
 		if (u == -1) {
 			u = errno;
-			warningf(true, "cannot %s %s: %s",
+			warningf(true, "can't %s %s: %s",
 			    iotype == IODUP ? "dup" :
 			    (iotype == IOREAD || iotype == IOHERE) ?
 			    "open" : "create", cp, strerror(u));
@@ -1192,7 +1355,8 @@
 		if (u == iop->unit)
 			e->savefd[iop->unit] = -1;
 		else
-			/* c_exec() assumes e->savefd[fd] set for any
+			/*
+			 * c_exec() assumes e->savefd[fd] set for any
 			 * redirections. Ask savefd() not to close iop->unit;
 			 * this allows error messages to be seen if iop->unit
 			 * is 2; also means we can't lose the fd (eg, both
@@ -1208,8 +1372,8 @@
 			int ev;
 
 			ev = errno;
-			warningf(true,
-			    "could not finish (dup) redirection %s: %s",
+			warningf(true, "%s %s %s",
+			    "can't finish (dup) redirection",
 			    snptreef(NULL, 32, "%R", &iotmp),
 			    strerror(ev));
 			if (iotype != IODUP)
@@ -1218,84 +1382,111 @@
 		}
 		if (iotype != IODUP)
 			close(u);
-		/* Touching any co-process fd in an empty exec
+		/*
+		 * Touching any co-process fd in an empty exec
 		 * causes the shell to close its copies
 		 */
 		else if (tp && tp->type == CSHELL && tp->val.f == c_exec) {
-			if (iop->flag & IORDUP)	/* possible exec <&p */
+			if (iop->flag & IORDUP)
+				/* possible exec <&p */
 				coproc_read_close(u);
-			else			/* possible exec >&p */
+			else
+				/* possible exec >&p */
 				coproc_write_close(u);
 		}
 	}
-	if (u == 2) /* Clear any write errors */
+	if (u == 2)
+		/* Clear any write errors */
 		shf_reopen(2, SHF_WR, shl_out);
 	return (0);
 }
 
 /*
- * open here document temp file.
- * if unquoted here, expand here temp file into second temp file.
+ * Process here documents by providing the content, either as
+ * result (globally allocated) string or in a temp file; if
+ * unquoted, the string is expanded first.
  */
 static int
-herein(const char *content, int sub)
+hereinval(const char *content, int sub, char **resbuf, struct shf *shf)
 {
-	volatile int fd = -1;
-	struct source *s, *volatile osource;
-	struct shf *volatile shf;
+	const char *ccp;
+	struct source *s, *osource;
+
+	osource = source;
+	newenv(E_ERRH);
+	if (sigsetjmp(e->jbuf, 0)) {
+		source = osource;
+		quitenv(shf);
+		/* special to iosetup(): don't print error */
+		return (-2);
+	}
+	if (sub) {
+		/* do substitutions on the content of heredoc */
+		s = pushs(SSTRING, ATEMP);
+		s->start = s->str = content;
+		source = s;
+		if (yylex(ONEWORD|HEREDOC) != LWORD)
+			internal_errorf("%s: %s", "herein", "yylex");
+		source = osource;
+		ccp = evalstr(yylval.cp, 0);
+	} else
+		ccp = content;
+
+	if (resbuf == NULL)
+		shf_puts(ccp, shf);
+	else
+		strdupx(*resbuf, ccp, APERM);
+
+	quitenv(NULL);
+	return (0);
+}
+
+static int
+herein(const char *content, int sub, char **resbuf)
+{
+	int fd = -1;
+	struct shf *shf;
 	struct temp *h;
 	int i;
 
 	/* ksh -c 'cat << EOF' can cause this... */
 	if (content == NULL) {
-		warningf(true, "here document missing");
-		return (-2); /* special to iosetup(): don't print error */
+		warningf(true, "%s missing", "here document");
+		/* special to iosetup(): don't print error */
+		return (-2);
 	}
 
-	/* Create temp file to hold content (done before newenv so temp
-	 * doesn't get removed too soon).
+	/* skip all the fd setup if we just want the value */
+	if (resbuf != NULL)
+		return (hereinval(content, sub, resbuf, NULL));
+
+	/*
+	 * Create temp file to hold content (done before newenv
+	 * so temp doesn't get removed too soon).
 	 */
 	h = maketemp(ATEMP, TT_HEREDOC_EXP, &e->temps);
 	if (!(shf = h->shf) || (fd = open(h->name, O_RDONLY, 0)) < 0) {
-		fd = errno;
+		i = errno;
 		warningf(true, "can't %s temporary file %s: %s",
-		    !shf ? "create" : "open",
-		    h->name, strerror(fd));
+		    !shf ? "create" : "open", h->name, strerror(i));
 		if (shf)
 			shf_close(shf);
-		return (-2 /* special to iosetup(): don't print error */);
+		/* special to iosetup(): don't print error */
+		return (-2);
 	}
 
-	osource = source;
-	newenv(E_ERRH);
-	i = sigsetjmp(e->jbuf, 0);
-	if (i) {
-		source = osource;
-		quitenv(shf);
+	if (hereinval(content, sub, NULL, shf) == -2) {
 		close(fd);
-		return (-2); /* special to iosetup(): don't print error */
+		/* special to iosetup(): don't print error */
+		return (-2);
 	}
-	if (sub) {
-		/* Do substitutions on the content of heredoc */
-		s = pushs(SSTRING, ATEMP);
-		s->start = s->str = content;
-		source = s;
-		if (yylex(ONEWORD|HEREDOC) != LWORD)
-			internal_errorf("herein: yylex");
-		source = osource;
-		shf_puts(evalstr(yylval.cp, 0), shf);
-	} else
-		shf_puts(content, shf);
-
-	quitenv(NULL);
 
 	if (shf_close(shf) == EOF) {
 		i = errno;
 		close(fd);
-		fd = errno;
-		warningf(true, "error writing %s: %s, %s", h->name,
-		    strerror(i), strerror(fd));
-		return (-2);	/* special to iosetup(): don't print error */
+		warningf(true, "%s: %s: %s", "write", h->name, strerror(i));
+		/* special to iosetup(): don't print error */
+		return (-2);
 	}
 
 	return (fd);
@@ -1316,8 +1507,9 @@
 
 	for (argct = 0; ap[argct]; argct++)
 		;
-	while (1) {
-		/* Menu is printed if
+	while (/* CONSTCOND */ 1) {
+		/*-
+		 * Menu is printed if
 		 *	- this is the first time around the select loop
 		 *	- the user enters a blank line
 		 *	- the REPLY parameter is empty
@@ -1405,7 +1597,7 @@
 static char *
 plain_fmt_entry(char *buf, int buflen, int i, const void *arg)
 {
-	shf_snprintf(buf, buflen, "%s", ((const char * const *)arg)[i]);
+	strlcpy(buf, ((const char * const *)arg)[i], buflen);
 	return (buf);
 }
 
@@ -1434,19 +1626,20 @@
  *	[[ ... ]] evaluation routines
  */
 
-/* Test if the current token is a whatever. Accepts the current token if
+/*
+ * Test if the current token is a whatever. Accepts the current token if
  * it is. Returns 0 if it is not, non-zero if it is (in the case of
  * TM_UNOP and TM_BINOP, the returned value is a Test_op).
  */
-static int
+static Test_op
 dbteste_isa(Test_env *te, Test_meta meta)
 {
-	int ret = 0;
+	Test_op ret = TO_NONOP;
 	int uqword;
 	const char *p;
 
 	if (!*te->pos.wp)
-		return (meta == TM_END);
+		return (meta == TM_END ? TO_NONNULL : TO_NONOP);
 
 	/* unquoted word? */
 	for (p = *te->pos.wp; *p == CHAR; p += 2)
@@ -1455,8 +1648,10 @@
 
 	if (meta == TM_UNOP || meta == TM_BINOP) {
 		if (uqword) {
-			char buf[8];	/* longer than the longest operator */
+			/* longer than the longest operator */
+			char buf[8];
 			char *q = buf;
+
 			for (p = *te->pos.wp;
 			    *p == CHAR && q < &buf[sizeof(buf) - 1]; p += 2)
 				*q++ = p[1];
@@ -1464,13 +1659,13 @@
 			ret = test_isop(meta, buf);
 		}
 	} else if (meta == TM_END)
-		ret = 0;
+		ret = TO_NONOP;
 	else
-		ret = uqword &&
-		    strcmp(*te->pos.wp, dbtest_tokens[(int) meta]) == 0;
+		ret = (uqword && !strcmp(*te->pos.wp,
+		    dbtest_tokens[(int)meta])) ? TO_NONNULL : TO_NONOP;
 
 	/* Accept the token? */
-	if (ret)
+	if (ret != TO_NONOP)
 		te->pos.wp++;
 
 	return (ret);
Index: src/bin/mksh/expr.c
diff -u src/bin/mksh/expr.c:1.43 src/bin/mksh/expr.c:1.47
--- src/bin/mksh/expr.c:1.43	Mon Jan 25 14:38:00 2010
+++ src/bin/mksh/expr.c	Sat Dec 11 16:05:03 2010
@@ -22,7 +22,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.43 2010/01/25 14:38:00 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.47 2010/12/11 16:05:03 tg Exp $");
 
 /* The order of these enums is constrained by the order of opinfo[] */
 enum token {
@@ -269,26 +269,28 @@
 		default:
 			s = opinfo[(int)es->tok].name;
 		}
-		warningf(true, "%s: unexpected '%s'", es->expression, s);
+		warningf(true, "%s: %s '%s'", es->expression,
+		    "unexpected", s);
 		break;
 
 	case ET_BADLIT:
-		warningf(true, "%s: bad number '%s'", es->expression, str);
+		warningf(true, "%s: %s '%s'", es->expression,
+		    "bad number", str);
 		break;
 
 	case ET_RECURSIVE:
-		warningf(true, "%s: expression recurses on parameter '%s'",
-		    es->expression, str);
+		warningf(true, "%s: %s '%s'", es->expression,
+		    "expression recurses on parameter", str);
 		break;
 
 	case ET_LVALUE:
-		warningf(true, "%s: %s requires lvalue",
-		    es->expression, str);
+		warningf(true, "%s: %s %s",
+		    es->expression, str, "requires lvalue");
 		break;
 
 	case ET_RDONLY:
-		warningf(true, "%s: %s applied to read only variable",
-		    es->expression, str);
+		warningf(true, "%s: %s %s",
+		    es->expression, str, "applied to read only variable");
 		break;
 
 	default: /* keep gcc happy */
@@ -798,6 +800,7 @@
 }
 
 
+#ifndef MKSH_mirbsd_wcwidth
 /* --- begin of wcwidth.c excerpt --- */
 /*-
  * Markus Kuhn -- 2007-05-26 (Unicode 5.0)
@@ -807,7 +810,7 @@
  * disclaims all warranties with regard to this software.
  */
 
-__RCSID("$miros: src/lib/libc/i18n/wcwidth.c,v 1.8 2008/09/20 12:01:18 tg Exp $");
+__RCSID("$miros: src/lib/libc/i18n/wcwidth.c,v 1.10 2010/12/11 16:05:03 tg Exp $");
 
 int
 utf_wcwidth(unsigned int c)
@@ -816,54 +819,77 @@
 		unsigned short first;
 		unsigned short last;
 	} comb[] = {
-		{ 0x0300, 0x036F }, { 0x0483, 0x0486 }, { 0x0488, 0x0489 },
-		{ 0x0591, 0x05BD }, { 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 },
-		{ 0x05C4, 0x05C5 }, { 0x05C7, 0x05C7 }, { 0x0600, 0x0603 },
-		{ 0x0610, 0x0615 }, { 0x064B, 0x065E }, { 0x0670, 0x0670 },
-		{ 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },
+		/* Unicode 6.0.0 BMP */
+		{ 0x0300, 0x036F }, { 0x0483, 0x0489 }, { 0x0591, 0x05BD },
+		{ 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 }, { 0x05C4, 0x05C5 },
+		{ 0x05C7, 0x05C7 }, { 0x0600, 0x0603 }, { 0x0610, 0x061A },
+		{ 0x064B, 0x065F }, { 0x0670, 0x0670 }, { 0x06D6, 0x06DD },
+		{ 0x06DF, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },
 		{ 0x070F, 0x070F }, { 0x0711, 0x0711 }, { 0x0730, 0x074A },
-		{ 0x07A6, 0x07B0 }, { 0x07EB, 0x07F3 }, { 0x0901, 0x0902 },
+		{ 0x07A6, 0x07B0 }, { 0x07EB, 0x07F3 }, { 0x0816, 0x0819 },
+		{ 0x081B, 0x0823 }, { 0x0825, 0x0827 }, { 0x0829, 0x082D },
+		{ 0x0859, 0x085B }, { 0x0900, 0x0902 }, { 0x093A, 0x093A },
 		{ 0x093C, 0x093C }, { 0x0941, 0x0948 }, { 0x094D, 0x094D },
-		{ 0x0951, 0x0954 }, { 0x0962, 0x0963 }, { 0x0981, 0x0981 },
+		{ 0x0951, 0x0957 }, { 0x0962, 0x0963 }, { 0x0981, 0x0981 },
 		{ 0x09BC, 0x09BC }, { 0x09C1, 0x09C4 }, { 0x09CD, 0x09CD },
 		{ 0x09E2, 0x09E3 }, { 0x0A01, 0x0A02 }, { 0x0A3C, 0x0A3C },
 		{ 0x0A41, 0x0A42 }, { 0x0A47, 0x0A48 }, { 0x0A4B, 0x0A4D },
-		{ 0x0A70, 0x0A71 }, { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC },
-		{ 0x0AC1, 0x0AC5 }, { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD },
-		{ 0x0AE2, 0x0AE3 }, { 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C },
-		{ 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B43 }, { 0x0B4D, 0x0B4D },
-		{ 0x0B56, 0x0B56 }, { 0x0B82, 0x0B82 }, { 0x0BC0, 0x0BC0 },
+		{ 0x0A51, 0x0A51 }, { 0x0A70, 0x0A71 }, { 0x0A75, 0x0A75 },
+		{ 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC }, { 0x0AC1, 0x0AC5 },
+		{ 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD }, { 0x0AE2, 0x0AE3 },
+		{ 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C }, { 0x0B3F, 0x0B3F },
+		{ 0x0B41, 0x0B44 }, { 0x0B4D, 0x0B4D }, { 0x0B56, 0x0B56 },
+		{ 0x0B62, 0x0B63 }, { 0x0B82, 0x0B82 }, { 0x0BC0, 0x0BC0 },
 		{ 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 }, { 0x0C46, 0x0C48 },
-		{ 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 }, { 0x0CBC, 0x0CBC },
-		{ 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD },
-		{ 0x0CE2, 0x0CE3 }, { 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D },
-		{ 0x0DCA, 0x0DCA }, { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 },
-		{ 0x0E31, 0x0E31 }, { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E },
-		{ 0x0EB1, 0x0EB1 }, { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC },
-		{ 0x0EC8, 0x0ECD }, { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 },
-		{ 0x0F37, 0x0F37 }, { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E },
-		{ 0x0F80, 0x0F84 }, { 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 },
-		{ 0x0F99, 0x0FBC }, { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 },
-		{ 0x1032, 0x1032 }, { 0x1036, 0x1037 }, { 0x1039, 0x1039 },
-		{ 0x1058, 0x1059 }, { 0x1160, 0x11FF }, { 0x135F, 0x135F },
-		{ 0x1712, 0x1714 }, { 0x1732, 0x1734 }, { 0x1752, 0x1753 },
-		{ 0x1772, 0x1773 }, { 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD },
-		{ 0x17C6, 0x17C6 }, { 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD },
-		{ 0x180B, 0x180D }, { 0x18A9, 0x18A9 }, { 0x1920, 0x1922 },
-		{ 0x1927, 0x1928 }, { 0x1932, 0x1932 }, { 0x1939, 0x193B },
-		{ 0x1A17, 0x1A18 }, { 0x1B00, 0x1B03 }, { 0x1B34, 0x1B34 },
+		{ 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 }, { 0x0C62, 0x0C63 },
+		{ 0x0CBC, 0x0CBC }, { 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 },
+		{ 0x0CCC, 0x0CCD }, { 0x0CE2, 0x0CE3 }, { 0x0D41, 0x0D44 },
+		{ 0x0D4D, 0x0D4D }, { 0x0D62, 0x0D63 }, { 0x0DCA, 0x0DCA },
+		{ 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 }, { 0x0E31, 0x0E31 },
+		{ 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E }, { 0x0EB1, 0x0EB1 },
+		{ 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC }, { 0x0EC8, 0x0ECD },
+		{ 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 }, { 0x0F37, 0x0F37 },
+		{ 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E }, { 0x0F80, 0x0F84 },
+		{ 0x0F86, 0x0F87 }, { 0x0F8D, 0x0F97 }, { 0x0F99, 0x0FBC },
+		{ 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 }, { 0x1032, 0x1037 },
+		{ 0x1039, 0x103A }, { 0x103D, 0x103E }, { 0x1058, 0x1059 },
+		{ 0x105E, 0x1060 }, { 0x1071, 0x1074 }, { 0x1082, 0x1082 },
+		{ 0x1085, 0x1086 }, { 0x108D, 0x108D }, { 0x109D, 0x109D },
+		{ 0x1160, 0x11FF }, { 0x135D, 0x135F }, { 0x1712, 0x1714 },
+		{ 0x1732, 0x1734 }, { 0x1752, 0x1753 }, { 0x1772, 0x1773 },
+		{ 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD }, { 0x17C6, 0x17C6 },
+		{ 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD }, { 0x180B, 0x180D },
+		{ 0x18A9, 0x18A9 }, { 0x1920, 0x1922 }, { 0x1927, 0x1928 },
+		{ 0x1932, 0x1932 }, { 0x1939, 0x193B }, { 0x1A17, 0x1A18 },
+		{ 0x1A56, 0x1A56 }, { 0x1A58, 0x1A5E }, { 0x1A60, 0x1A60 },
+		{ 0x1A62, 0x1A62 }, { 0x1A65, 0x1A6C }, { 0x1A73, 0x1A7C },
+		{ 0x1A7F, 0x1A7F }, { 0x1B00, 0x1B03 }, { 0x1B34, 0x1B34 },
 		{ 0x1B36, 0x1B3A }, { 0x1B3C, 0x1B3C }, { 0x1B42, 0x1B42 },
-		{ 0x1B6B, 0x1B73 }, { 0x1DC0, 0x1DCA }, { 0x1DFE, 0x1DFF },
-		{ 0x200B, 0x200F }, { 0x202A, 0x202E }, { 0x2060, 0x2063 },
-		{ 0x206A, 0x206F }, { 0x20D0, 0x20EF }, { 0x302A, 0x302F },
-		{ 0x3099, 0x309A }, { 0xA806, 0xA806 }, { 0xA80B, 0xA80B },
-		{ 0xA825, 0xA826 }, { 0xFB1E, 0xFB1E }, { 0xFE00, 0xFE0F },
-		{ 0xFE20, 0xFE23 }, { 0xFEFF, 0xFEFF }, { 0xFFF9, 0xFFFB }
+		{ 0x1B6B, 0x1B73 }, { 0x1B80, 0x1B81 }, { 0x1BA2, 0x1BA5 },
+		{ 0x1BA8, 0x1BA9 }, { 0x1BE6, 0x1BE6 }, { 0x1BE8, 0x1BE9 },
+		{ 0x1BED, 0x1BED }, { 0x1BEF, 0x1BF1 }, { 0x1C2C, 0x1C33 },
+		{ 0x1C36, 0x1C37 }, { 0x1CD0, 0x1CD2 }, { 0x1CD4, 0x1CE0 },
+		{ 0x1CE2, 0x1CE8 }, { 0x1CED, 0x1CED }, { 0x1DC0, 0x1DE6 },
+		{ 0x1DFC, 0x1DFF }, { 0x200B, 0x200F }, { 0x202A, 0x202E },
+		{ 0x2060, 0x2064 }, { 0x206A, 0x206F }, { 0x20D0, 0x20F0 },
+		{ 0x2CEF, 0x2CF1 }, { 0x2D7F, 0x2D7F }, { 0x2DE0, 0x2DFF },
+		{ 0x302A, 0x302F }, { 0x3099, 0x309A }, { 0xA66F, 0xA672 },
+		{ 0xA67C, 0xA67D }, { 0xA6F0, 0xA6F1 }, { 0xA802, 0xA802 },
+		{ 0xA806, 0xA806 }, { 0xA80B, 0xA80B }, { 0xA825, 0xA826 },
+		{ 0xA8C4, 0xA8C4 }, { 0xA8E0, 0xA8F1 }, { 0xA926, 0xA92D },
+		{ 0xA947, 0xA951 }, { 0xA980, 0xA982 }, { 0xA9B3, 0xA9B3 },
+		{ 0xA9B6, 0xA9B9 }, { 0xA9BC, 0xA9BC }, { 0xAA29, 0xAA2E },
+		{ 0xAA31, 0xAA32 }, { 0xAA35, 0xAA36 }, { 0xAA43, 0xAA43 },
+		{ 0xAA4C, 0xAA4C }, { 0xAAB0, 0xAAB0 }, { 0xAAB2, 0xAAB4 },
+		{ 0xAAB7, 0xAAB8 }, { 0xAABE, 0xAABF }, { 0xAAC1, 0xAAC1 },
+		{ 0xABE5, 0xABE5 }, { 0xABE8, 0xABE8 }, { 0xABED, 0xABED },
+		{ 0xFB1E, 0xFB1E }, { 0xFE00, 0xFE0F }, { 0xFE20, 0xFE26 },
+		{ 0xFEFF, 0xFEFF }, { 0xFFF9, 0xFFFB }
 	};
 	size_t min = 0, mid, max = NELEM(comb) - 1;
 
 	/* test for 8-bit control characters */
-	if (c < 32 || (c >= 0x7f && c < 0xa0))
+	if (c < 32 || (c >= 0x7F && c < 0xA0))
 		return (c ? -1 : 0);
 
 	/* binary search in table of non-spacing characters */
@@ -879,15 +905,17 @@
 		}
 
 	/* if we arrive here, c is not a combining or C0/C1 control char */
+
 	return ((c >= 0x1100 && (
-	    c <= 0x115f || /* Hangul Jamo init. consonants */
-	    c == 0x2329 || c == 0x232a ||
-	    (c >= 0x2e80 && c <= 0xa4cf && c != 0x303f) || /* CJK ... Yi */
-	    (c >= 0xac00 && c <= 0xd7a3) || /* Hangul Syllables */
-	    (c >= 0xf900 && c <= 0xfaff) || /* CJK Compatibility Ideographs */
-	    (c >= 0xfe10 && c <= 0xfe19) || /* Vertical forms */
-	    (c >= 0xfe30 && c <= 0xfe6f) || /* CJK Compatibility Forms */
-	    (c >= 0xff00 && c <= 0xff60) || /* Fullwidth Forms */
-	    (c >= 0xffe0 && c <= 0xffe6))) ? 2 : 1);
+	    c <= 0x115F || /* Hangul Jamo init. consonants */
+	    c == 0x2329 || c == 0x232A ||
+	    (c >= 0x2E80 && c <= 0xA4CF && c != 0x303F) || /* CJK ... Yi */
+	    (c >= 0xAC00 && c <= 0xD7A3) || /* Hangul Syllables */
+	    (c >= 0xF900 && c <= 0xFAFF) || /* CJK Compatibility Ideographs */
+	    (c >= 0xFE10 && c <= 0xFE19) || /* Vertical forms */
+	    (c >= 0xFE30 && c <= 0xFE6F) || /* CJK Compatibility Forms */
+	    (c >= 0xFF00 && c <= 0xFF60) || /* Fullwidth Forms */
+	    (c >= 0xFFE0 && c <= 0xFFE6))) ? 2 : 1);
 }
 /* --- end of wcwidth.c excerpt --- */
+#endif
Index: src/bin/mksh/funcs.c
diff -u src/bin/mksh/funcs.c:1.151 src/bin/mksh/funcs.c:1.186
--- src/bin/mksh/funcs.c:1.151	Tue Feb 23 18:13:03 2010
+++ src/bin/mksh/funcs.c	Fri May  6 15:41:23 2011
@@ -1,10 +1,11 @@
 /*	$OpenBSD: c_ksh.c,v 1.33 2009/02/07 14:03:24 kili Exp $	*/
-/*	$OpenBSD: c_sh.c,v 1.40 2009/05/05 17:59:55 millert Exp $	*/
+/*	$OpenBSD: c_sh.c,v 1.41 2010/03/27 09:10:01 jmc Exp $	*/
 /*	$OpenBSD: c_test.c,v 1.18 2009/03/01 20:11:06 otto Exp $	*/
 /*	$OpenBSD: c_ulimit.c,v 1.17 2008/03/21 12:51:19 millert Exp $	*/
 
 /*-
- * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+ *		 2010, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -25,7 +26,19 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.151 2010/02/23 18:13:03 tg Exp $");
+#if HAVE_SELECT
+#if HAVE_SYS_BSDTYPES_H
+#include <sys/bsdtypes.h>
+#endif
+#if HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
+#if HAVE_BSTRING_H
+#include <bstring.h>
+#endif
+#endif
+
+__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.186 2011/05/06 15:41:23 tg Exp $");
 
 #if HAVE_KILLPG
 /*
@@ -47,9 +60,14 @@
 #define c_ulimit c_label
 #endif
 
+#if defined(ANDROID)
+static int c_android_lsmod(const char **);
+#endif
+
 extern uint8_t set_refflag;
 
-/* A leading = means assignments before command are kept;
+/*
+ * A leading = means assignments before command are kept;
  * a leading * means a POSIX special builtin;
  * a leading + means a POSIX regular builtin
  * (* and + should not be combined).
@@ -59,14 +77,14 @@
 	{"*=:", c_label},
 	{"[", c_test},
 	{"*=break", c_brkcont},
-	{"=builtin", c_builtin},
+	{T_gbuiltin, c_builtin},
 	{"*=continue", c_brkcont},
 	{"*=eval", c_eval},
 	{"*=exec", c_exec},
 	{"*=exit", c_exitreturn},
 	{"+false", c_label},
 	{"*=return", c_exitreturn},
-	{"*=set", c_set},
+	{T_sgset, c_set},
 	{"*=shift", c_shift},
 	{"=times", c_times},
 	{"*=trap", c_trap},
@@ -77,9 +95,11 @@
 	{"ulimit", c_ulimit},
 	{"+umask", c_umask},
 	{"*=unset", c_unset},
-	{"+alias", c_alias},	/* no =: AT&T manual wrong */
+	/* no =: AT&T manual wrong */
+	{T_palias, c_alias},
 	{"+cd", c_cd},
-	{"chdir", c_cd},	/* dash compatibility hack */
+	/* dash compatibility hack */
+	{"chdir", c_cd},
 	{"+command", c_command},
 	{"echo", c_print},
 	{"*=export", c_typeset},
@@ -95,18 +115,29 @@
 	{"pwd", c_pwd},
 	{"*=readonly", c_typeset},
 	{T__typeset, c_typeset},
-	{"+unalias", c_unalias},
+	{T_punalias, c_unalias},
 	{"whence", c_whence},
 #ifndef MKSH_UNEMPLOYED
 	{"+bg", c_fgbg},
 	{"+fg", c_fgbg},
 #endif
 	{"bind", c_bind},
+	{"cat", c_cat},
 #if HAVE_MKNOD
 	{"mknod", c_mknod},
 #endif
 	{"realpath", c_realpath},
 	{"rename", c_rename},
+#if HAVE_SELECT
+	{"sleep", c_sleep},
+#endif
+#ifdef __MirBSD__
+	/* alias to "true" for historical reasons */
+	{"domainname", c_label},
+#endif
+#if defined(ANDROID)
+	{"lsmod", c_android_lsmod},
+#endif
 	{NULL, (int (*)(const char **))NULL}
 };
 
@@ -168,324 +199,19 @@
 static int test_aexpr(Test_env *, bool);
 static int test_nexpr(Test_env *, bool);
 static int test_primary(Test_env *, bool);
-static int ptest_isa(Test_env *, Test_meta);
+static Test_op ptest_isa(Test_env *, Test_meta);
 static const char *ptest_getopnd(Test_env *, Test_op, bool);
 static void ptest_error(Test_env *, int, const char *);
 static char *kill_fmt_entry(char *, int, int, const void *);
 static void p_time(struct shf *, bool, long, int, int,
     const char *, const char *)
-    MKSH_A_NONNULL((nonnull (6, 7)));
-static char *do_realpath(const char *);
-
-static char *
-do_realpath(const char *upath)
-{
-	char *xp, *ip, *tp, *ipath, *ldest = NULL;
-	XString xs;
-	ptrdiff_t pos;
-	size_t len;
-	int symlinks = 32;	/* max. recursion depth */
-	int llen;
-	struct stat sb;
-
-	if (upath[0] == '/') {
-		/* upath is an absolute pathname */
-		strdupx(ipath, upath, ATEMP);
-	} else {
-		/* upath is a relative pathname, prepend cwd */
-		if ((tp = ksh_get_wd(NULL)) == NULL || tp[0] != '/')
-			return (NULL);
-		ipath = shf_smprintf("%s/%s", tp, upath);
-		afree(tp, ATEMP);
-	}
-
-	Xinit(xs, xp, strlen(ip = ipath) + 1, ATEMP);
-
-	while (*ip) {
-		/* skip slashes in input */
-		while (*ip == '/')
-			++ip;
-		if (!*ip)
-			break;
-
-		/* get next pathname component from input */
-		tp = ip;
-		while (*ip && *ip != '/')
-			++ip;
-		len = ip - tp;
-
-		/* check input for "." and ".." */
-		if (tp[0] == '.') {
-			if (len == 1)
-				/* just continue with the next one */
-				continue;
-			else if (len == 2 && tp[1] == '.') {
-				/* strip off last pathname component */
-				while (xp > Xstring(xs, xp))
-					if (*--xp == '/')
-						break;
-				/* then continue with the next one */
-				continue;
-			}
-		}
-
-		/* store output position away, then append slash to output */
-		pos = Xsavepos(xs, xp);
-		Xcheck(xs, xp);
-		Xput(xs, xp, '/');
-
-		/* append next pathname component to output */
-		XcheckN(xs, xp, len + 1);
-		memcpy(xp, tp, len);
-		xp += len;
-		*xp = '\0';
-
-		/* lstat the current output, see if it's a symlink */
-		if (lstat(Xstring(xs, xp), &sb)) {
-			/* lstat failed */
-			if (errno == ENOENT) {
-				/* because the pathname does not exist */
-				while (*ip == '/')
-					/* skip any trailing slashes */
-					++ip;
-				/* no more components left? */
-				if (!*ip)
-					/* we can still return successfully */
-					break;
-				/* more components left? fall through */
-			}
-			/* not ENOENT or not at the end of ipath */
-			goto notfound;
-		}
-
-		/* check if we encountered a symlink? */
-		if (S_ISLNK(sb.st_mode)) {
-			/* reached maximum recursion depth? */
-			if (!symlinks--) {
-				/* yep, prevent infinite loops */
-				errno = ELOOP;
-				goto notfound;
-			}
-
-			/* get symlink(7) target */
-#ifdef NO_PATH_MAX
-			if (ldest) {
-				afree(ldest, ATEMP);
-				ldest = NULL;
-			}
-			{
-				struct stat hurd_sb;
-
-				if (lstat(Xstring(xs, xp), &hurd_sb))
-					goto notfound;
-				ldest = alloc(hurd_sb.st_size + 1, ATEMP);
-				if ((llen = readlink(Xstring(xs, xp), ldest,
-				    hurd_sb.st_size)) < 0)
-					goto notfound;
-			}
-#else
-			if (!ldest)
-				ldest = alloc(PATH_MAX + 1, ATEMP);
-			if ((llen = readlink(Xstring(xs, xp), ldest,
-			    PATH_MAX)) < 0)
-				/* oops... */
-				goto notfound;
-#endif
-			ldest[llen] = '\0';
-
-			/*
-			 * restart if symlink target is an absolute path,
-			 * otherwise continue with currently resolved prefix
-			 */
-			xp = (ldest[0] == '/') ? Xstring(xs, xp) :
-			    Xrestpos(xs, xp, pos);
-			tp = shf_smprintf("%s/%s", ldest, ip);
-			afree(ipath, ATEMP);
-			ip = ipath = tp;
-		}
-		/* otherwise (no symlink) merely go on */
-	}
-
-	/*
-	 * either found the target and successfully resolved it,
-	 * or found its parent directory and may create it
-	 */
-	if (Xlength(xs, xp) == 0)
-		/*
-		 * if the resolved pathname is "", make it "/",
-		 * otherwise do not add a trailing slash
-		 */
-		Xput(xs, xp, '/');
-	Xput(xs, xp, '\0');
-
-	if (ldest != NULL)
-		afree(ldest, ATEMP);
-	afree(ipath, ATEMP);
-	return (Xclose(xs, xp));
-
- notfound:
-	llen = errno;	/* save; free(3) might trash it */
-	if (ldest != NULL)
-		afree(ldest, ATEMP);
-	afree(ipath, ATEMP);
-	Xfree(xs, xp);
-	errno = llen;
-	return (NULL);
-}
-
-int
-c_cd(const char **wp)
-{
-	int optc, rv, phys_path;
-	bool physical = Flag(FPHYSICAL) ? true : false;
-	int cdnode;			/* was a node from cdpath added in? */
-	bool printpath = false;		/* print where we cd'd? */
-	struct tbl *pwd_s, *oldpwd_s;
-	XString xs;
-	char *dir, *allocd = NULL, *try, *pwd, *cdpath;
-
-	while ((optc = ksh_getopt(wp, &builtin_opt, "LP")) != -1)
-		switch (optc) {
-		case 'L':
-			physical = false;
-			break;
-		case 'P':
-			physical = true;
-			break;
-		case '?':
-			return (1);
-		}
-	wp += builtin_opt.optind;
-
-	if (Flag(FRESTRICTED)) {
-		bi_errorf("restricted shell - can't cd");
-		return (1);
-	}
-
-	pwd_s = global("PWD");
-	oldpwd_s = global("OLDPWD");
-
-	if (!wp[0]) {
-		/* No arguments - go home */
-		if ((dir = str_val(global("HOME"))) == null) {
-			bi_errorf("no home directory (HOME not set)");
-			return (1);
-		}
-	} else if (!wp[1]) {
-		/* One argument: - or dir */
-		strdupx(allocd, wp[0], ATEMP);
-		if (ksh_isdash((dir = allocd))) {
-			afree(allocd, ATEMP);
-			allocd = NULL;
-			dir = str_val(oldpwd_s);
-			if (dir == null) {
-				bi_errorf("no OLDPWD");
-				return (1);
-			}
-			printpath = true;
-		}
-	} else if (!wp[2]) {
-		/* Two arguments - substitute arg1 in PWD for arg2 */
-		int ilen, olen, nlen, elen;
-		char *cp;
-
-		if (!current_wd[0]) {
-			bi_errorf("don't know current directory");
-			return (1);
-		}
-		/* substitute arg1 for arg2 in current path.
-		 * if the first substitution fails because the cd fails
-		 * we could try to find another substitution. For now
-		 * we don't
-		 */
-		if ((cp = strstr(current_wd, wp[0])) == NULL) {
-			bi_errorf("bad substitution");
-			return (1);
-		}
-		ilen = cp - current_wd;
-		olen = strlen(wp[0]);
-		nlen = strlen(wp[1]);
-		elen = strlen(current_wd + ilen + olen) + 1;
-		dir = allocd = alloc(ilen + nlen + elen, ATEMP);
-		memcpy(dir, current_wd, ilen);
-		memcpy(dir + ilen, wp[1], nlen);
-		memcpy(dir + ilen + nlen, current_wd + ilen + olen, elen);
-		printpath = true;
-	} else {
-		bi_errorf("too many arguments");
-		return (1);
-	}
-
-#ifdef NO_PATH_MAX
-	/* only a first guess; make_path will enlarge xs if necessary */
-	XinitN(xs, 1024, ATEMP);
-#else
-	XinitN(xs, PATH_MAX, ATEMP);
-#endif
-
-	cdpath = str_val(global("CDPATH"));
-	do {
-		cdnode = make_path(current_wd, dir, &cdpath, &xs, &phys_path);
-		if (physical)
-			rv = chdir(try = Xstring(xs, xp) + phys_path);
-		else {
-			simplify_path(Xstring(xs, xp));
-			rv = chdir(try = Xstring(xs, xp));
-		}
-	} while (rv < 0 && cdpath != NULL);
-
-	if (rv < 0) {
-		if (cdnode)
-			bi_errorf("%s: bad directory", dir);
-		else
-			bi_errorf("%s - %s", try, strerror(errno));
-		afree(allocd, ATEMP);
-		return (1);
-	}
-
-	/* allocd (above) => dir, which is no longer used */
-	afree(allocd, ATEMP);
-	allocd = NULL;
-
-	/* Clear out tracked aliases with relative paths */
-	flushcom(0);
-
-	/* Set OLDPWD (note: unsetting OLDPWD does not disable this
-	 * setting in AT&T ksh)
-	 */
-	if (current_wd[0])
-		/* Ignore failure (happens if readonly or integer) */
-		setstr(oldpwd_s, current_wd, KSH_RETURN_ERROR);
-
-	if (Xstring(xs, xp)[0] != '/') {
-		pwd = NULL;
-	} else if (!physical || !(pwd = allocd = do_realpath(Xstring(xs, xp))))
-		pwd = Xstring(xs, xp);
-
-	/* Set PWD */
-	if (pwd) {
-		char *ptmp = pwd;
-
-		set_current_wd(ptmp);
-		/* Ignore failure (happens if readonly or integer) */
-		setstr(pwd_s, ptmp, KSH_RETURN_ERROR);
-	} else {
-		set_current_wd(null);
-		pwd = Xstring(xs, xp);
-		/* XXX unset $PWD? */
-	}
-	if (printpath || cdnode)
-		shprintf("%s\n", pwd);
-
-	afree(allocd, ATEMP);
-	return (0);
-}
+    MKSH_A_NONNULL((__nonnull__ (6, 7)));
 
 int
 c_pwd(const char **wp)
 {
 	int optc;
-	bool physical = Flag(FPHYSICAL) ? true : false;
+	bool physical = tobool(Flag(FPHYSICAL));
 	char *p, *allocd = NULL;
 
 	while ((optc = ksh_getopt(wp, &builtin_opt, "LP")) != -1)
@@ -509,8 +235,9 @@
 	    current_wd) : NULL;
 	if (p && access(p, R_OK) < 0)
 		p = NULL;
-	if (!p && !(p = allocd = ksh_get_wd(NULL))) {
-		bi_errorf("can't get current directory - %s", strerror(errno));
+	if (!p && !(p = allocd = ksh_get_wd())) {
+		bi_errorf("%s: %s", "can't determine current directory",
+		    strerror(errno));
 		return (1);
 	}
 	shprintf("%s\n", p);
@@ -539,7 +266,7 @@
 	if (wp[0][0] == 'e') {
 		/* echo builtin */
 		wp++;
-		if (Flag(FPOSIX) || Flag(FSH)) {
+		if (Flag(FPOSIX) || Flag(FSH) || Flag(FAS_BUILTIN)) {
 			/* Debian Policy 10.4 compliant "echo" builtin */
 			if (*wp && !strcmp(*wp, "-n")) {
 				/* we recognise "-n" only as the first arg */
@@ -589,7 +316,8 @@
 
 		while ((optc = ksh_getopt(wp, &builtin_opt, opts)) != -1)
 			switch (optc) {
-			case 'R': /* fake BSD echo command */
+			case 'R':
+				/* fake BSD echo command */
 				flags |= PO_PMINUSMINUS;
 				flags &= ~PO_EXPAND;
 				opts = "ne";
@@ -602,7 +330,7 @@
 				break;
 			case 'p':
 				if ((fd = coproc_getfd(W_OK, &emsg)) < 0) {
-					bi_errorf("-p: %s", emsg);
+					bi_errorf("%s: %s", "-p", emsg);
 					return (1);
 				}
 				break;
@@ -616,7 +344,7 @@
 				if (!*(s = builtin_opt.optarg))
 					fd = 0;
 				else if ((fd = check_fd(s, W_OK, &emsg)) < 0) {
-					bi_errorf("-u: %s: %s", s, emsg);
+					bi_errorf("%s: %s: %s", "-u", s, emsg);
 					return (1);
 				}
 				break;
@@ -685,7 +413,8 @@
 		int len = Xlength(xs, xp);
 		int opipe = 0;
 
-		/* Ensure we aren't killed by a SIGPIPE while writing to
+		/*
+		 * Ensure we aren't killed by a SIGPIPE while writing to
 		 * a coprocess. AT&T ksh doesn't seem to do this (seems
 		 * to just check that the co-process is alive which is
 		 * not enough).
@@ -760,7 +489,8 @@
 		/* Note that -p on its own is deal with in comexec() */
 		if (pflag)
 			fcflags |= FC_DEFPATH;
-		/* Convert command options to whence options - note that
+		/*
+		 * Convert command options to whence options - note that
 		 * command -pV uses a different path search than whence -v
 		 * or whence -pv. This should be considered a feature.
 		 */
@@ -785,22 +515,32 @@
 		if (vflag || (tp->type != CALIAS && tp->type != CEXEC &&
 		    tp->type != CTALIAS))
 			shf_puts(id, shl_stdout);
+		if (vflag)
+			switch (tp->type) {
+			case CKEYWD:
+			case CALIAS:
+			case CFUNC:
+			case CSHELL:
+				shf_puts(" is a", shl_stdout);
+				break;
+			}
+
 		switch (tp->type) {
 		case CKEYWD:
 			if (vflag)
-				shf_puts(" is a reserved word", shl_stdout);
+				shf_puts(" reserved word", shl_stdout);
 			break;
 		case CALIAS:
 			if (vflag)
-				shprintf(" is an %salias for ",
-				    (tp->flag & EXPORT) ? "exported " : null);
+				shprintf("n %s%s for ",
+				    (tp->flag & EXPORT) ? "exported " : null,
+				    T_alias);
 			if (!iam_whence && !vflag)
-				shprintf("alias %s=", id);
+				shprintf("%s %s=", T_alias, id);
 			print_value_quoted(tp->val.s);
 			break;
 		case CFUNC:
 			if (vflag) {
-				shf_puts(" is a", shl_stdout);
 				if (tp->flag & EXPORT)
 					shf_puts("n exported", shl_stdout);
 				if (tp->flag & TRACE)
@@ -811,13 +551,14 @@
 						shprintf(" (autoload from %s)",
 						    tp->u.fpath);
 				}
-				shf_puts(" function", shl_stdout);
+				shf_puts(T__function, shl_stdout);
 			}
 			break;
 		case CSHELL:
 			if (vflag)
-				shprintf(" is a%s shell builtin",
-				    (tp->flag & SPEC_BI) ? " special" : null);
+				shprintf("%s %s %s",
+				    (tp->flag & SPEC_BI) ? " special" : null,
+				    "shell", T_builtin);
 			break;
 		case CTALIAS:
 		case CEXEC:
@@ -825,14 +566,15 @@
 				if (vflag) {
 					shf_puts(" is ", shl_stdout);
 					if (tp->type == CTALIAS)
-						shprintf("a tracked %salias for ",
+						shprintf("a tracked %s%s for ",
 						    (tp->flag & EXPORT) ?
-						    "exported " : null);
+						    "exported " : null,
+						    T_alias);
 				}
 				shf_puts(tp->val.s, shl_stdout);
 			} else {
 				if (vflag)
-					shf_puts(" not found", shl_stdout);
+					shprintf(" %s\n", "not found");
 				rv = 1;
 			}
 			break;
@@ -850,7 +592,8 @@
 int
 c_command(const char **wp)
 {
-	/* Let c_whence do the work. Note that c_command() must be
+	/*
+	 * Let c_whence do the work. Note that c_command() must be
 	 * a distinct function from c_whence() (tested in comexec()).
 	 */
 	return (c_whence(wp));
@@ -869,18 +612,26 @@
 	bool localv = false, func = false, pflag = false, istset = true;
 
 	switch (**wp) {
-	case 'e':		/* export */
+
+	/* export */
+	case 'e':
 		fset |= EXPORT;
 		istset = false;
 		break;
-	case 'r':		/* readonly */
+
+	/* readonly */
+	case 'r':
 		fset |= RDONLY;
 		istset = false;
 		break;
-	case 's':		/* set */
+
+	/* set */
+	case 's':
 		/* called with 'typeset -' */
 		break;
-	case 't':		/* typeset */
+
+	/* typeset */
+	case 't':
 		localv = true;
 		break;
 	}
@@ -890,7 +641,8 @@
 
 	fieldstr = basestr = NULL;
 	builtin_opt.flags |= GF_PLUSOPT;
-	/* AT&T ksh seems to have 0-9 as options which are multiplied
+	/*
+	 * AT&T ksh seems to have 0-9 as options which are multiplied
 	 * to get a number that is used with -L, -R, -Z or -i (eg, -1R2
 	 * sets right justify in a field of 12). This allows options
 	 * to be grouped in an order (eg, -Lu12), but disallows -i8 -L3 and
@@ -910,7 +662,8 @@
 			fieldstr = builtin_opt.optarg;
 			break;
 		case 'U':
-			/* AT&T ksh uses u, but this conflicts with
+			/*
+			 * AT&T ksh uses u, but this conflicts with
 			 * upper/lower case. If this option is changed,
 			 * need to change the -U below as well
 			 */
@@ -940,8 +693,8 @@
 		case 'n':
 			set_refflag = (builtin_opt.info & GI_PLUS) ? 2 : 1;
 			break;
+		/* export, readonly: POSIX -p flag */
 		case 'p':
-			/* export, readonly: POSIX -p flag */
 			/* typeset: show values as well */
 			pflag = true;
 			if (istset)
@@ -954,7 +707,8 @@
 			flag = TRACE;
 			break;
 		case 'u':
-			flag = UCASEV_AL;	/* upper case / autoload */
+			/* upper case / autoload */
+			flag = UCASEV_AL;
 			break;
 		case 'x':
 			flag = EXPORT;
@@ -994,19 +748,24 @@
 		return (1);
 	}
 	if (wp[builtin_opt.optind]) {
-		/* Take care of exclusions.
+		/*
+		 * Take care of exclusions.
 		 * At this point, flags in fset are cleared in fclr and vice
 		 * versa. This property should be preserved.
 		 */
-		if (fset & LCASEV)	/* LCASEV has priority over UCASEV_AL */
+		if (fset & LCASEV)
+			/* LCASEV has priority over UCASEV_AL */
 			fset &= ~UCASEV_AL;
-		if (fset & LJUST)	/* LJUST has priority over RJUST */
+		if (fset & LJUST)
+			/* LJUST has priority over RJUST */
 			fset &= ~RJUST;
-		if ((fset & (ZEROFIL|LJUST)) == ZEROFIL) { /* -Z implies -ZR */
+		if ((fset & (ZEROFIL|LJUST)) == ZEROFIL) {
+			/* -Z implies -ZR */
 			fset |= RJUST;
 			fclr &= ~RJUST;
 		}
-		/* Setting these attributes clears the others, unless they
+		/*
+		 * Setting these attributes clears the others, unless they
 		 * are also set in this command
 		 */
 		if ((fset & (LJUST | RJUST | ZEROFIL | UCASEV_AL | LCASEV |
@@ -1025,7 +784,7 @@
 		for (i = builtin_opt.optind; wp[i]; i++) {
 			if (func) {
 				f = findfunc(wp[i], hash(wp[i]),
-				    (fset&UCASEV_AL) ? true : false);
+				    tobool(fset & UCASEV_AL));
 				if (!f) {
 					/* AT&T ksh does ++rv: bogus */
 					rv = 1;
@@ -1034,13 +793,14 @@
 				if (fset | fclr) {
 					f->flag |= fset;
 					f->flag &= ~fclr;
-				} else
-					fptreef(shl_stdout, 0,
-					    f->flag & FKSH ?
-					    "function %s %T\n" :
-					    "%s() %T\n", wp[i], f->val.t);
+				} else {
+					fpFUNCTf(shl_stdout, 0,
+					    tobool(f->flag & FKSH),
+					    wp[i], f->val.t);
+					shf_putc('\n', shl_stdout);
+				}
 			} else if (!typeset(wp[i], fset, fclr, field, base)) {
-				bi_errorf("%s: not identifier", wp[i]);
+				bi_errorf("%s: %s", wp[i], "not identifier");
 				set_refflag = 0;
 				return (1);
 			}
@@ -1050,18 +810,21 @@
 	}
 
 	/* list variables and attributes */
-	flag = fset | fclr; /* no difference at this point.. */
+
+	/* no difference at this point.. */
+	flag = fset | fclr;
 	if (func) {
 		for (l = e->loc; l; l = l->next) {
 			for (p = ktsort(&l->funs); (vp = *p++); ) {
 				if (flag && (vp->flag & flag) == 0)
 					continue;
 				if (thing == '-')
-					fptreef(shl_stdout, 0, vp->flag & FKSH ?
-					    "function %s %T\n" : "%s() %T\n",
+					fpFUNCTf(shl_stdout, 0,
+					    tobool(vp->flag & FKSH),
 					    vp->name, vp->val.t);
 				else
-					shprintf("%s\n", vp->name);
+					shf_puts(vp->name, shl_stdout);
+				shf_putc('\n', shl_stdout);
 			}
 		}
 	} else {
@@ -1093,15 +856,18 @@
 				if (flag && (vp->flag & flag) == 0)
 					continue;
 				for (; vp; vp = vp->u.array) {
-					/* Ignore array elements that aren't
+					/*
+					 * Ignore array elements that aren't
 					 * set unless there are no set elements,
-					 * in which case the first is reported on */
+					 * in which case the first is reported on
+					 */
 					if ((vp->flag&ARRAY) && any_set &&
 					    !(vp->flag & ISSET))
 						continue;
 					/* no arguments */
 					if (thing == 0 && flag == 0) {
-						/* AT&T ksh prints things
+						/*
+						 * AT&T ksh prints things
 						 * like export, integer,
 						 * leftadj, zerofill, etc.,
 						 * but POSIX says must
@@ -1109,34 +875,36 @@
 						 */
 						shf_puts("typeset ", shl_stdout);
 						if (((vp->flag&(ARRAY|ASSOC))==ASSOC))
-							shf_puts("-n ", shl_stdout);
+							shprintf("%s ", "-n");
 						if ((vp->flag&INTEGER))
-							shf_puts("-i ", shl_stdout);
+							shprintf("%s ", "-i");
 						if ((vp->flag&EXPORT))
-							shf_puts("-x ", shl_stdout);
+							shprintf("%s ", "-x");
 						if ((vp->flag&RDONLY))
-							shf_puts("-r ", shl_stdout);
+							shprintf("%s ", "-r");
 						if ((vp->flag&TRACE))
-							shf_puts("-t ", shl_stdout);
+							shprintf("%s ", "-t");
 						if ((vp->flag&LJUST))
 							shprintf("-L%d ", vp->u2.field);
 						if ((vp->flag&RJUST))
 							shprintf("-R%d ", vp->u2.field);
 						if ((vp->flag&ZEROFIL))
-							shf_puts("-Z ", shl_stdout);
+							shprintf("%s ", "-Z");
 						if ((vp->flag&LCASEV))
-							shf_puts("-l ", shl_stdout);
+							shprintf("%s ", "-l");
 						if ((vp->flag&UCASEV_AL))
-							shf_puts("-u ", shl_stdout);
+							shprintf("%s ", "-u");
 						if ((vp->flag&INT_U))
-							shf_puts("-U ", shl_stdout);
+							shprintf("%s ", "-U");
 						shf_puts(vp->name, shl_stdout);
 						if (pflag) {
 							char *s = str_val(vp);
 
 							shf_putc('=', shl_stdout);
-							/* AT&T ksh can't have
-							 * justified integers.. */
+							/*
+							 * AT&T ksh can't have
+							 * justified integers...
+							 */
 							if ((vp->flag &
 							    (INTEGER|LJUST|RJUST)) ==
 							    INTEGER)
@@ -1165,8 +933,10 @@
 							char *s = str_val(vp);
 
 							shf_putc('=', shl_stdout);
-							/* AT&T ksh can't have
-							 * justified integers.. */
+							/*
+							 * AT&T ksh can't have
+							 * justified integers...
+							 */
 							if ((vp->flag &
 							    (INTEGER|LJUST|RJUST)) ==
 							    INTEGER)
@@ -1176,7 +946,8 @@
 						}
 						shf_putc('\n', shl_stdout);
 					}
-					/* Only report first 'element' of an array with
+					/*
+					 * Only report first 'element' of an array with
 					 * no set elements.
 					 */
 					if (!any_set)
@@ -1248,12 +1019,12 @@
 	/* "hash -r" means reset all the tracked aliases.. */
 	if (rflag) {
 		static const char *args[] = {
-			"unalias", "-ta", NULL
+			T_unalias, "-ta", NULL
 		};
 
 		if (!tflag || *wp) {
-			shf_puts("alias: -r flag can only be used with -t"
-			    " and without arguments\n", shl_stdout);
+			shprintf("%s: -r flag can only be used with -t"
+			    " and without arguments\n", T_alias);
 			return (1);
 		}
 		ksh_getopt_reset(&builtin_opt, GF_ERROR);
@@ -1266,7 +1037,7 @@
 		for (p = ktsort(t); (ap = *p++) != NULL; )
 			if ((ap->flag & (ISSET|xflag)) == (ISSET|xflag)) {
 				if (pflag)
-					shf_puts("alias ", shl_stdout);
+					shprintf("%s ", T_alias);
 				shf_puts(ap->name, shl_stdout);
 				if (prefix != '+') {
 					shf_putc('=', shl_stdout);
@@ -1291,7 +1062,7 @@
 			ap = ktsearch(t, alias, h);
 			if (ap != NULL && (ap->flag&ISSET)) {
 				if (pflag)
-					shf_puts("alias ", shl_stdout);
+					shprintf("%s ", T_alias);
 				shf_puts(ap->name, shl_stdout);
 				if (prefix != '+') {
 					shf_putc('=', shl_stdout);
@@ -1299,7 +1070,8 @@
 				}
 				shf_putc('\n', shl_stdout);
 			} else {
-				shprintf("%s alias not found\n", alias);
+				shprintf("%s %s %s\n", alias, T_alias,
+				    "not found");
 				rv = 1;
 			}
 			continue;
@@ -1346,7 +1118,8 @@
 			break;
 		case 'd':
 #ifdef MKSH_NOPWNAM
-			t = NULL;	/* fix "unalias -dt" */
+			/* fix "unalias -dt" */
+			t = NULL;
 #else
 			t = &homedirs;
 #endif
@@ -1366,7 +1139,8 @@
 	for (; *wp != NULL; wp++) {
 		ap = ktsearch(t, *wp, hash(*wp));
 		if (ap == NULL) {
-			rv = 1;	/* POSIX */
+			/* POSIX */
+			rv = 1;
 			continue;
 		}
 		if (ap->flag&ALLOC) {
@@ -1397,12 +1171,14 @@
 	int rv = 1;
 	mksh_ari_t val;
 
-	if (wp[1] == NULL) /* AT&T ksh does this */
+	if (wp[1] == NULL)
+		/* AT&T ksh does this */
 		bi_errorf("no arguments");
 	else
 		for (wp++; *wp; wp++)
 			if (!evaluate(*wp, &val, KSH_RETURN_ERROR, true)) {
-				rv = 2;	/* distinguish error from zero result */
+				/* distinguish error from zero result */
+				rv = 2;
 				break;
 			} else
 				rv = val == 0;
@@ -1425,7 +1201,8 @@
 		case 'n':
 			nflag = 1;
 			break;
-		case 'z':	/* debugging: print zombies */
+		case 'z':
+			/* debugging: print zombies */
 			nflag = -1;
 			break;
 		case '?':
@@ -1572,8 +1349,8 @@
 			if (j_kill(p, sig))
 				rv = 1;
 		} else if (!getn(p, &n)) {
-			bi_errorf("%s: arguments must be jobs or process IDs",
-			    p);
+			bi_errorf("%s: %s", p,
+			    "arguments must be jobs or process IDs");
 			rv = 1;
 		} else {
 			if (mksh_kill(n, sig) < 0) {
@@ -1608,22 +1385,22 @@
 
 	opts = *wp++;
 	if (!opts) {
-		bi_errorf("missing options argument");
+		bi_errorf("missing %s argument", "options");
 		return (1);
 	}
 
 	var = *wp++;
 	if (!var) {
-		bi_errorf("missing name argument");
+		bi_errorf("missing %s argument", "name");
 		return (1);
 	}
 	if (!*var || *skip_varname(var, true)) {
-		bi_errorf("%s: is not an identifier", var);
+		bi_errorf("%s: %s", var, "is not an identifier");
 		return (1);
 	}
 
 	if (e->loc->next == NULL) {
-		internal_warningf("c_getopts: no argv");
+		internal_warningf("%s: %s", "c_getopts", "no argv");
 		return (1);
 	}
 	/* Which arguments are we parsing... */
@@ -1650,7 +1427,8 @@
 		buf[1] = optc;
 		buf[2] = '\0';
 	} else {
-		/* POSIX says var is set to ? at end-of-options, AT&T ksh
+		/*
+		 * POSIX says var is set to ? at end-of-options, AT&T ksh
 		 * sets it to null - we go with POSIX...
 		 */
 		buf[0] = optc < 0 ? '?' : optc;
@@ -1661,7 +1439,8 @@
 	user_opt.uoptind = user_opt.optind;
 
 	voptarg = global("OPTARG");
-	voptarg->flag &= ~RDONLY;	/* AT&T ksh clears ro and int */
+	/* AT&T ksh clears ro and int */
+	voptarg->flag &= ~RDONLY;
 	/* Paranoia: ensure no bizarre results. */
 	if (voptarg->flag & INTEGER)
 	    typeset("OPTARG", 0, INTEGER, 0, 0);
@@ -1676,7 +1455,7 @@
 	vq = global(var);
 	/* Error message already printed (integer, readonly) */
 	if (!setstr(vq, buf, KSH_RETURN_ERROR))
-		rv = 1;
+		rv = 2;
 	if (Flag(FEXPORT))
 		typeset(var, EXPORT, 0, 0, 0);
 
@@ -1715,7 +1494,8 @@
 		}
 	wp += builtin_opt.optind;
 
-	if (*wp == NULL)	/* list all */
+	if (*wp == NULL)
+		/* list all */
 		rv = x_bind(NULL, NULL,
 #ifndef MKSH_SMALL
 		    false,
@@ -1741,7 +1521,11 @@
 	return (rv);
 }
 
-/* :, false and true (and ulimit if MKSH_NO_LIMITS) */
+/**
+ * :, false and true
+ * ulimit if MKSH_NO_LIMITS
+ * domainname on MirBSD (hysterical raisins, just don't ask)
+ */
 int
 c_label(const char **wp)
 {
@@ -1766,7 +1550,7 @@
 	} else
 		n = 1;
 	if (n < 0) {
-		bi_errorf("%s: bad number", arg);
+		bi_errorf("%s: %s", arg, "bad number");
 		return (1);
 	}
 	if (l->argc < n) {
@@ -1833,7 +1617,8 @@
 			char op;
 
 			old_umask = umask((mode_t)0);
-			umask(old_umask); /* in case of error */
+			/* in case of error */
+			umask(old_umask);
 			old_umask = ~old_umask;
 			new_umask = old_umask;
 			positions = 0;
@@ -1854,7 +1639,8 @@
 						break;
 					}
 				if (!positions)
-					positions = 0111; /* default is a */
+					/* default is a */
+					positions = 0111;
 				if (!vstrchr("=+-", op = *cp))
 					break;
 				cp++;
@@ -1932,7 +1718,8 @@
 	/* Set positional parameters? */
 	if (wp[builtin_opt.optind + 1]) {
 		argv = wp + builtin_opt.optind;
-		argv[0] = e->loc->argv[0]; /* preserve $0 */
+		/* preserve $0 */
+		argv[0] = e->loc->argv[0];
 		for (argc = 0; argv[argc + 1]; argc++)
 			;
 	} else {
@@ -1963,7 +1750,8 @@
 		for (; *wp; wp++)
 			rv = waitfor(*wp, &sig);
 		if (rv < 0)
-			rv = sig ? sig : 127; /* magic exit code: bad job-id */
+			/* magic exit code: bad job-id */
+			rv = sig ? sig : 127;
 	}
 	return (rv);
 }
@@ -1971,20 +1759,23 @@
 int
 c_read(const char **wp)
 {
-	int c = 0, ecode = 0, fd = 0, optc;
+	int c, ecode = 0, fd = 0, optc;
 	bool expande = true, historyr = false, expanding;
 	const char *cp, *emsg;
 	struct shf *shf;
 	XString cs, xs = { NULL, NULL, 0, NULL};
 	struct tbl *vp;
-	char *ccp, *xp = NULL, *wpalloc = NULL;
+	char *ccp, *xp = NULL, *wpalloc = NULL, delim = '\n';
 	static char REPLY[] = "REPLY";
 
-	while ((optc = ksh_getopt(wp, &builtin_opt, "prsu,")) != -1)
+	while ((optc = ksh_getopt(wp, &builtin_opt, "d:prsu,")) != -1)
 		switch (optc) {
+		case 'd':
+			delim = builtin_opt.optarg[0];
+			break;
 		case 'p':
 			if ((fd = coproc_getfd(R_OK, &emsg)) < 0) {
-				bi_errorf("-p: %s", emsg);
+				bi_errorf("%s: %s", "-p", emsg);
 				return (1);
 			}
 			break;
@@ -1998,7 +1789,7 @@
 			if (!*(cp = builtin_opt.optarg))
 				fd = 0;
 			else if ((fd = check_fd(cp, R_OK, &emsg)) < 0) {
-				bi_errorf("-u: %s: %s", cp, emsg);
+				bi_errorf("%s: %s: %s", "-u", cp, emsg);
 				return (1);
 			}
 			break;
@@ -2010,7 +1801,8 @@
 	if (*wp == NULL)
 		*--wp = REPLY;
 
-	/* Since we can't necessarily seek backwards on non-regular files,
+	/*
+	 * Since we can't necessarily seek backwards on non-regular files,
 	 * don't buffer them so we can't read too much.
 	 */
 	shf = shf_reopen(fd, SHF_RD | SHF_INTERRUPT | can_seek(fd), shl_spare);
@@ -2020,16 +1812,18 @@
 		wpalloc[cp - *wp] = '\0';
 		*wp = wpalloc;
 		if (isatty(fd)) {
-			/* AT&T ksh says it prints prompt on fd if it's open
+			/*
+			 * AT&T ksh says it prints prompt on fd if it's open
 			 * for writing and is a tty, but it doesn't do it
 			 * (it also doesn't check the interactive flag,
-			 * as is indicated in the Kornshell book).
+			 * as is indicated in the Korn Shell book).
 			 */
-			shellf("%s", cp+1);
+			shellf("%s", cp + 1);
 		}
 	}
 
-	/* If we are reading from the co-process for the first time,
+	/*
+	 * If we are reading from the co-process for the first time,
 	 * make sure the other side of the pipe is closed first. This allows
 	 * the detection of eof.
 	 *
@@ -2044,17 +1838,26 @@
 		Xinit(xs, xp, 128, ATEMP);
 	expanding = false;
 	Xinit(cs, ccp, 128, ATEMP);
+	/* initialise to something not EOF or delim or any character */
+	c = 0x100;
 	for (; *wp != NULL; wp++) {
 		for (ccp = Xstring(cs, ccp); ; ) {
-			if (c == '\n' || c == EOF)
+			if (c == delim || c == EOF)
 				break;
-			while (1) {
+			/* loop to read one character */
+			while (/* CONSTCOND */ 1) {
 				c = shf_getc(shf);
+				/* we break unless NUL or EOF, so... */
+				if (c == delim)
+					/* in case delim == NUL */
+					break;
 				if (c == '\0')
+					/* skip any read NUL byte */
 					continue;
 				if (c == EOF && shf_error(shf) &&
 				    shf_errno(shf) == EINTR) {
-					/* Was the offending signal one that
+					/*
+					 * Was the offending signal one that
 					 * would normally kill a process?
 					 * If so, pretend the read was killed.
 					 */
@@ -2075,10 +1878,11 @@
 			Xcheck(cs, ccp);
 			if (expanding) {
 				expanding = false;
-				if (c == '\n') {
+				if (c == delim) {
 					c = 0;
 					if (Flag(FTALKING_I) && isatty(fd)) {
-						/* set prompt in case this is
+						/*
+						 * set prompt in case this is
 						 * called from .profile or $ENV
 						 */
 						set_prompt(PS2, NULL);
@@ -2092,7 +1896,7 @@
 				expanding = true;
 				continue;
 			}
-			if (c == '\n' || c == EOF)
+			if (c == delim || c == EOF)
 				break;
 			if (ctype(c, C_IFS)) {
 				if (Xlength(cs, ccp) == 0 && ctype(c, C_IFSWS))
@@ -2112,9 +1916,9 @@
 		/* Must be done before setting export. */
 		if (vp->flag & RDONLY) {
 			shf_flush(shf);
-			bi_errorf("%s is read only", *wp);
+			bi_errorf("%s: %s", *wp, "is read only");
 			afree(wpalloc, ATEMP);
-			return (1);
+			return (2);
 		}
 		if (Flag(FEXPORT))
 			typeset(*wp, EXPORT, 0, 0, 0);
@@ -2131,9 +1935,10 @@
 		histsave(&source->line, Xstring(xs, xp), true, false);
 		Xfree(xs, xp);
 	}
-	/* if this is the co-process fd, close the file descriptor
-	 * (can get eof if and only if all processes are have died, ie,
-	 * coproc.njobs is 0 and the pipe is closed).
+	/*
+	 * if this is the co-process fd, close the file descriptor
+	 * (can get eof if and only if all processes are have died,
+	 * i.e. coproc.njobs is 0 and the pipe is closed).
 	 */
 	if (c == EOF && !ecode)
 		coproc_read_close(fd);
@@ -2221,20 +2026,21 @@
 	 * command 'exit' isn't confused with the pseudo-signal
 	 * 'EXIT'.
 	 */
-	s = (gettrap(*wp, false) == NULL) ? *wp++ : NULL; /* get command */
+	/* get command */
+	s = (gettrap(*wp, false) == NULL) ? *wp++ : NULL;
 	if (s != NULL && s[0] == '-' && s[1] == '\0')
 		s = NULL;
 
 	/* set/clear traps */
-	while (*wp != NULL) {
-		p = gettrap(*wp++, true);
-		if (p == NULL) {
-			bi_errorf("bad signal %s", wp[-1]);
-			return (1);
-		}
-		settrap(p, s);
-	}
-	return (0);
+	i = 0;
+	while (*wp != NULL)
+		if ((p = gettrap(*wp++, true)) == NULL) {
+			warningf(true, "%s: %s '%s'", builtin_argv0,
+			    "bad signal", wp[-1]);
+			++i;
+		} else
+			settrap(p, s);
+	return (i);
 }
 
 int
@@ -2250,14 +2056,17 @@
 	if (arg) {
 		if (!getn(arg, &n)) {
 			exstat = 1;
-			warningf(true, "%s: bad number", arg);
+			warningf(true, "%s: %s", arg, "bad number");
 		} else
 			exstat = n;
-	}
-	if (wp[0][0] == 'r') { /* return */
+	} else if (trap_exstat != -1)
+		exstat = trap_exstat;
+	if (wp[0][0] == 'r') {
+		/* return */
 		struct env *ep;
 
-		/* need to tell if this is exit or return so trap exit will
+		/*
+		 * need to tell if this is exit or return so trap exit will
 		 * work right (POSIX)
 		 */
 		for (ep = e; ep; ep = ep->oenv)
@@ -2272,7 +2081,8 @@
 		how = LSHELL;
 	}
 
-	quitenv(NULL);	/* get rid of any i/o redirections */
+	/* get rid of any i/o redirections */
+	quitenv(NULL);
 	unwind(how);
 	/* NOTREACHED */
 }
@@ -2295,7 +2105,7 @@
 	quit = n;
 	if (quit <= 0) {
 		/* AT&T ksh does this for non-interactive shells only - weird */
-		bi_errorf("%s: bad value", arg);
+		bi_errorf("%s: %s", arg, "bad value");
 		return (1);
 	}
 
@@ -2309,15 +2119,17 @@
 		}
 
 	if (quit) {
-		/* AT&T ksh doesn't print a message - just does what it
+		/*
+		 * AT&T ksh doesn't print a message - just does what it
 		 * can. We print a message 'cause it helps in debugging
 		 * scripts, but don't generate an error (ie, keep going).
 		 */
 		if (n == quit) {
-			warningf(true, "%s: cannot %s", wp[0], wp[0]);
+			warningf(true, "%s: %s %s", wp[0], "can't", wp[0]);
 			return (0);
 		}
-		/* POSIX says if n is too big, the last enclosing loop
+		/*
+		 * POSIX says if n is too big, the last enclosing loop
 		 * shall be used. Doesn't say to print an error but we
 		 * do anyway 'cause the user messed up.
 		 */
@@ -2340,7 +2152,7 @@
 	const char **owp;
 
 	if (wp[1] == NULL) {
-		static const char *args[] = { "set", "-", NULL };
+		static const char *args[] = { T_set, "-", NULL };
 		return (c_typeset(args));
 	}
 
@@ -2351,11 +2163,12 @@
 	if (setargs) {
 		wp += argi - 1;
 		owp = wp;
-		wp[0] = l->argv[0]; /* save $0 */
+		/* save $0 */
+		wp[0] = l->argv[0];
 		while (*++wp != NULL)
 			strdupx(*wp, *wp, &l->area);
 		l->argc = wp - owp - 1;
-		l->argv = alloc((l->argc + 2) * sizeof(char *), &l->area);
+		l->argv = alloc2(l->argc + 2, sizeof(char *), &l->area);
 		for (wp = l->argv; (*wp++ = *owp++) != NULL; )
 			;
 	}
@@ -2375,7 +2188,7 @@
 c_unset(const char **wp)
 {
 	const char *id;
-	int optc;
+	int optc, rv = 0;
 	bool unset_var = true;
 
 	while ((optc = ksh_getopt(wp, &builtin_opt, "fv")) != -1)
@@ -2387,11 +2200,13 @@
 			unset_var = true;
 			break;
 		case '?':
-			return (1);
+			/*XXX not reached due to GF_ERROR */
+			return (2);
 		}
 	wp += builtin_opt.optind;
 	for (; (id = *wp) != NULL; wp++)
-		if (unset_var) {	/* unset variable */
+		if (unset_var) {
+			/* unset variable */
 			struct tbl *vp;
 			char *cp = NULL;
 			size_t n;
@@ -2409,13 +2224,15 @@
 			afree(cp, ATEMP);
 
 			if ((vp->flag&RDONLY)) {
-				bi_errorf("%s is read only", vp->name);
-				return (1);
-			}
-			unset(vp, optc);
-		} else			/* unset function */
+				warningf(true, "%s: %s", vp->name,
+				    "is read only");
+				rv = 1;
+			} else
+				unset(vp, optc);
+		} else
+			/* unset function */
 			define(id, NULL);
-	return (0);
+	return (rv);
 }
 
 static void
@@ -2487,7 +2304,8 @@
 	} else
 		tf = TF_NOARGS;
 
-	if (tf & TF_NOARGS) { /* ksh93 - report shell times (shell+kids) */
+	if (tf & TF_NOARGS) {
+		/* ksh93 - report shell times (shell+kids) */
 		tf |= TF_NOREAL;
 		timeradd(&ru0.ru_utime, &cru0.ru_utime, &usrtime);
 		timeradd(&ru0.ru_stime, &cru0.ru_stime, &systime);
@@ -2532,17 +2350,19 @@
 	Getopt opt;
 
 	ksh_getopt_reset(&opt, 0);
-	opt.optind = 0;	/* start at the start */
+	/* start at the start */
+	opt.optind = 0;
 	while ((optc = ksh_getopt((const char **)wp, &opt, ":p")) != -1)
 		switch (optc) {
 		case 'p':
 			t->str[0] |= TF_POSIX;
 			break;
 		case '?':
-			errorf("time: -%s unknown option", opt.optarg);
+			errorf("time: -%s %s", opt.optarg,
+			    "unknown option");
 		case ':':
-			errorf("time: -%s requires an argument",
-			    opt.optarg);
+			errorf("time: -%s %s", opt.optarg,
+			    "requires an argument");
 		}
 	/* Copy command words down over options. */
 	if (opt.optind != 0) {
@@ -2599,7 +2419,7 @@
 				return (1);
 			}
 			mode = getmode(set, (mode_t)(DEFFILEMODE));
-			free(set);
+			free_ossetmode(set);
 			break;
 		default:
 			goto c_mknod_usage;
@@ -2630,28 +2450,28 @@
 
 		majnum = strtoul(argv[2], &c, 0);
 		if ((c == argv[2]) || (*c != '\0')) {
-			bi_errorf("non-numeric device major '%s'", argv[2]);
+			bi_errorf("non-numeric %s %s '%s'", "device", "major", argv[2]);
 			goto c_mknod_err;
 		}
 		minnum = strtoul(argv[3], &c, 0);
 		if ((c == argv[3]) || (*c != '\0')) {
-			bi_errorf("non-numeric device minor '%s'", argv[3]);
+			bi_errorf("non-numeric %s %s '%s'", "device", "minor", argv[3]);
 			goto c_mknod_err;
 		}
 		dv = makedev(majnum, minnum);
-		if ((unsigned long)major(dv) != majnum) {
-			bi_errorf("device major too large: %lu", majnum);
+		if ((unsigned long)(major(dv)) != majnum) {
+			bi_errorf("%s %s too large: %lu", "device", "major", majnum);
 			goto c_mknod_err;
 		}
-		if ((unsigned long)minor(dv) != minnum) {
-			bi_errorf("device minor too large: %lu", minnum);
+		if ((unsigned long)(minor(dv)) != minnum) {
+			bi_errorf("%s %s too large: %lu", "device", "minor", minnum);
 			goto c_mknod_err;
 		}
 		if (mknod(argv[0], mode, dv))
 			goto c_mknod_failed;
 	} else if (mkfifo(argv[0], mode)) {
  c_mknod_failed:
-		bi_errorf("%s: %s", *wp, strerror(errno));
+		bi_errorf("%s: %s", argv[0], strerror(errno));
  c_mknod_err:
 		rv = 1;
 	}
@@ -2660,20 +2480,14 @@
 		umask(oldmode);
 	return (rv);
  c_mknod_usage:
-	bi_errorf("usage: mknod [-m mode] name [b | c] major minor");
-	bi_errorf("usage: mknod [-m mode] name p");
+	bi_errorf("%s: %s", "usage", "mknod [-m mode] name b|c major minor");
+	bi_errorf("%s: %s", "usage", "mknod [-m mode] name p");
 	return (1);
 }
 #endif
 
-/* dummy function, special case in comexec() */
-int
-c_builtin(const char **wp MKSH_A_UNUSED)
-{
-	return (0);
-}
-
-/* test(1) accepts the following grammar:
+/*-
+   test(1) accepts the following grammar:
 	oexpr	::= aexpr | aexpr "-o" oexpr ;
 	aexpr	::= nexpr | nexpr "-a" aexpr ;
 	nexpr	::= primary | "!" nexpr ;
@@ -2694,7 +2508,8 @@
 	operand ::= <any thing>
 */
 
-#define T_ERR_EXIT	2	/* POSIX says > 1 for errors */
+/* POSIX says > 1 for errors */
+#define T_ERR_EXIT	2
 
 int
 c_test(const char **wp)
@@ -2727,11 +2542,23 @@
 	 * our parser does the right thing for the omitted steps.
 	 */
 	if (argc <= 5) {
-		const char **owp = wp;
+		const char **owp = wp, **owpend = te.wp_end;
 		int invert = 0;
 		Test_op op;
 		const char *opnd1, *opnd2;
 
+		if (argc >= 2 && ((*te.isa)(&te, TM_OPAREN))) {
+			te.pos.wp = te.wp_end - 1;
+			if ((*te.isa)(&te, TM_CPAREN)) {
+				argc -= 2;
+				te.wp_end--;
+				te.pos.wp = owp + 2;
+			} else {
+				te.pos.wp = owp + 1;
+				te.wp_end = owpend;
+			}
+		}
+
 		while (--argc >= 0) {
 			if ((*te.isa)(&te, TM_END))
 				return (!0);
@@ -2752,8 +2579,6 @@
 			}
 			if (argc == 1) {
 				opnd1 = (*te.getopnd)(&te, TO_NONOP, 1);
-				if (strcmp(opnd1, "-t") == 0)
-				    break;
 				res = (*te.eval)(&te, TO_STNZE, opnd1,
 				    NULL, 1);
 				if (invert & 1)
@@ -2766,6 +2591,7 @@
 				break;
 		}
 		te.pos.wp = owp + 1;
+		te.wp_end = owpend;
 	}
 
 	return (test_parse(&te));
@@ -2803,99 +2629,182 @@
 	if (!do_eval)
 		return (0);
 
-	switch ((int)op) {
+	switch (op) {
+
 	/*
 	 * Unary Operators
 	 */
-	case TO_STNZE: /* -n */
+
+	/* -n */
+	case TO_STNZE:
 		return (*opnd1 != '\0');
-	case TO_STZER: /* -z */
+
+	/* -z */
+	case TO_STZER:
 		return (*opnd1 == '\0');
-	case TO_OPTION: /* -o */
+
+	/* -o */
+	case TO_OPTION:
 		if ((i = *opnd1) == '!' || i == '?')
 			opnd1++;
 		if ((k = option(opnd1)) == (size_t)-1)
 			return (0);
 		return (i == '?' ? 1 : i == '!' ? !Flag(k) : Flag(k));
-	case TO_FILRD: /* -r */
+
+	/* -r */
+	case TO_FILRD:
 		return (test_eaccess(opnd1, R_OK) == 0);
-	case TO_FILWR: /* -w */
+
+	/* -w */
+	case TO_FILWR:
 		return (test_eaccess(opnd1, W_OK) == 0);
-	case TO_FILEX: /* -x */
+
+	/* -x */
+	case TO_FILEX:
 		return (test_eaccess(opnd1, X_OK) == 0);
-	case TO_FILAXST: /* -a */
-	case TO_FILEXST: /* -e */
+
+	/* -a */
+	case TO_FILAXST:
+	/* -e */
+	case TO_FILEXST:
 		return (stat(opnd1, &b1) == 0);
-	case TO_FILREG: /* -r */
+
+	/* -r */
+	case TO_FILREG:
 		return (stat(opnd1, &b1) == 0 && S_ISREG(b1.st_mode));
-	case TO_FILID: /* -d */
+
+	/* -d */
+	case TO_FILID:
 		return (stat(opnd1, &b1) == 0 && S_ISDIR(b1.st_mode));
-	case TO_FILCDEV: /* -c */
+
+	/* -c */
+	case TO_FILCDEV:
 		return (stat(opnd1, &b1) == 0 && S_ISCHR(b1.st_mode));
-	case TO_FILBDEV: /* -b */
+
+	/* -b */
+	case TO_FILBDEV:
 		return (stat(opnd1, &b1) == 0 && S_ISBLK(b1.st_mode));
-	case TO_FILFIFO: /* -p */
+
+	/* -p */
+	case TO_FILFIFO:
 		return (stat(opnd1, &b1) == 0 && S_ISFIFO(b1.st_mode));
-	case TO_FILSYM: /* -h -L */
+
+	/* -h or -L */
+	case TO_FILSYM:
 		return (lstat(opnd1, &b1) == 0 && S_ISLNK(b1.st_mode));
-	case TO_FILSOCK: /* -S */
+
+	/* -S */
+	case TO_FILSOCK:
 		return (stat(opnd1, &b1) == 0 && S_ISSOCK(b1.st_mode));
-	case TO_FILCDF:/* -H HP context dependent files (directories) */
+
+	/* -H => HP context dependent files (directories) */
+	case TO_FILCDF:
+#ifdef S_ISCDF
+	{
+		char *nv;
+
+		/*
+		 * Append a + to filename and check to see if result is
+		 * a setuid directory. CDF stuff in general is hookey,
+		 * since it breaks for, e.g., the following sequence:
+		 * echo hi >foo+; mkdir foo; echo bye >foo/default;
+		 * chmod u+s foo (foo+ refers to the file with hi in it,
+		 * there is no way to get at the file with bye in it;
+		 * please correct me if I'm wrong about this).
+		 */
+
+		nv = shf_smprintf("%s+", opnd1);
+		i = (stat(nv, &b1) == 0 && S_ISCDF(b1.st_mode));
+		afree(nv, ATEMP);
+		return (i);
+	}
+#else
 		return (0);
-	case TO_FILSETU: /* -u */
+#endif
+
+	/* -u */
+	case TO_FILSETU:
 		return (stat(opnd1, &b1) == 0 &&
 		    (b1.st_mode & S_ISUID) == S_ISUID);
-	case TO_FILSETG: /* -g */
+
+	/* -g */
+	case TO_FILSETG:
 		return (stat(opnd1, &b1) == 0 &&
 		    (b1.st_mode & S_ISGID) == S_ISGID);
-	case TO_FILSTCK: /* -k */
+
+	/* -k */
+	case TO_FILSTCK:
 #ifdef S_ISVTX
 		return (stat(opnd1, &b1) == 0 &&
 		    (b1.st_mode & S_ISVTX) == S_ISVTX);
 #else
 		return (0);
 #endif
-	case TO_FILGZ: /* -s */
+
+	/* -s */
+	case TO_FILGZ:
 		return (stat(opnd1, &b1) == 0 && b1.st_size > 0L);
-	case TO_FILTT: /* -t */
+
+	/* -t */
+	case TO_FILTT:
 		if (opnd1 && !bi_getn(opnd1, &i)) {
 			te->flags |= TEF_ERROR;
 			i = 0;
 		} else
 			i = isatty(opnd1 ? i : 0);
 		return (i);
-	case TO_FILUID: /* -O */
+
+	/* -O */
+	case TO_FILUID:
 		return (stat(opnd1, &b1) == 0 && b1.st_uid == ksheuid);
-	case TO_FILGID: /* -G */
+
+	/* -G */
+	case TO_FILGID:
 		return (stat(opnd1, &b1) == 0 && b1.st_gid == getegid());
+
 	/*
 	 * Binary Operators
 	 */
-	case TO_STEQL: /* = */
+
+	/* = */
+	case TO_STEQL:
 		if (te->flags & TEF_DBRACKET)
 			return (gmatchx(opnd1, opnd2, false));
 		return (strcmp(opnd1, opnd2) == 0);
-	case TO_STNEQ: /* != */
+
+	/* != */
+	case TO_STNEQ:
 		if (te->flags & TEF_DBRACKET)
 			return (!gmatchx(opnd1, opnd2, false));
 		return (strcmp(opnd1, opnd2) != 0);
-	case TO_STLT: /* < */
+
+	/* < */
+	case TO_STLT:
 		return (strcmp(opnd1, opnd2) < 0);
-	case TO_STGT: /* > */
+
+	/* > */
+	case TO_STGT:
 		return (strcmp(opnd1, opnd2) > 0);
-	case TO_INTEQ: /* -eq */
-	case TO_INTNE: /* -ne */
-	case TO_INTGE: /* -ge */
-	case TO_INTGT: /* -gt */
-	case TO_INTLE: /* -le */
-	case TO_INTLT: /* -lt */
+
+	/* -eq */
+	case TO_INTEQ:
+	/* -ne */
+	case TO_INTNE:
+	/* -ge */
+	case TO_INTGE:
+	/* -gt */
+	case TO_INTGT:
+	/* -le */
+	case TO_INTLE:
+	/* -lt */
+	case TO_INTLT:
 		if (!evaluate(opnd1, &v1, KSH_RETURN_ERROR, false) ||
 		    !evaluate(opnd2, &v2, KSH_RETURN_ERROR, false)) {
 			/* error already printed.. */
 			te->flags |= TEF_ERROR;
 			return (1);
 		}
-		switch ((int)op) {
+		switch (op) {
 		case TO_INTEQ:
 			return (v1 == v2);
 		case TO_INTNE:
@@ -2908,24 +2817,42 @@
 			return (v1 <= v2);
 		case TO_INTLT:
 			return (v1 < v2);
+		default:
+			/* NOTREACHED */
+			break;
 		}
-	case TO_FILNT: /* -nt */
-		/* ksh88/ksh93 succeed if file2 can't be stated
+		/* NOTREACHED */
+
+	/* -nt */
+	case TO_FILNT:
+		/*
+		 * ksh88/ksh93 succeed if file2 can't be stated
 		 * (subtly different from 'does not exist').
 		 */
 		return (stat(opnd1, &b1) == 0 &&
 		    (((s = stat(opnd2, &b2)) == 0 &&
 		    b1.st_mtime > b2.st_mtime) || s < 0));
-	case TO_FILOT: /* -ot */
-		/* ksh88/ksh93 succeed if file1 can't be stated
+
+	/* -ot */
+	case TO_FILOT:
+		/*
+		 * ksh88/ksh93 succeed if file1 can't be stated
 		 * (subtly different from 'does not exist').
 		 */
 		return (stat(opnd2, &b2) == 0 &&
 		    (((s = stat(opnd1, &b1)) == 0 &&
 		    b1.st_mtime < b2.st_mtime) || s < 0));
-	case TO_FILEQ: /* -ef */
+
+	/* -ef */
+	case TO_FILEQ:
 		return (stat (opnd1, &b1) == 0 && stat (opnd2, &b2) == 0 &&
 		    b1.st_dev == b2.st_dev && b1.st_ino == b2.st_ino);
+
+	/* all other cases */
+	case TO_NONOP:
+	case TO_NONNULL:
+		/* throw the error */
+		break;
 	}
 	(*te->error)(te, 0, "internal error: unknown op");
 	return (1);
@@ -3010,7 +2937,7 @@
 		if (te->flags & TEF_ERROR)
 			return (0);
 		if (!(*te->isa)(te, TM_CPAREN)) {
-			(*te->error)(te, 0, "missing closing paren");
+			(*te->error)(te, 0, "missing )");
 			return (0);
 		}
 		return (rv);
@@ -3054,31 +2981,33 @@
  * Plain test (test and [ .. ]) specific routines.
  */
 
-/* Test if the current token is a whatever. Accepts the current token if
+/*
+ * Test if the current token is a whatever. Accepts the current token if
  * it is. Returns 0 if it is not, non-zero if it is (in the case of
  * TM_UNOP and TM_BINOP, the returned value is a Test_op).
  */
-static int
+static Test_op
 ptest_isa(Test_env *te, Test_meta meta)
 {
 	/* Order important - indexed by Test_meta values */
 	static const char *const tokens[] = {
 		"-o", "-a", "!", "(", ")"
 	};
-	int rv;
+	Test_op rv;
 
 	if (te->pos.wp >= te->wp_end)
-		return (meta == TM_END);
+		return (meta == TM_END ? TO_NONNULL : TO_NONOP);
 
 	if (meta == TM_UNOP || meta == TM_BINOP)
 		rv = test_isop(meta, *te->pos.wp);
 	else if (meta == TM_END)
-		rv = 0;
+		rv = TO_NONOP;
 	else
-		rv = strcmp(*te->pos.wp, tokens[(int) meta]) == 0;
+		rv = !strcmp(*te->pos.wp, tokens[(int)meta]) ?
+		    TO_NONNULL : TO_NONOP;
 
 	/* Accept the token? */
-	if (rv)
+	if (rv != TO_NONOP)
 		te->pos.wp++;
 
 	return (rv);
@@ -3118,6 +3047,49 @@
 static void print_ulimit(const struct limits *, int);
 static int set_ulimit(const struct limits *, const char *, int);
 
+/* Magic to divine the 'm' and 'v' limits */
+
+#ifdef RLIMIT_AS
+#if !defined(RLIMIT_VMEM) || (RLIMIT_VMEM == RLIMIT_AS) || \
+    !defined(RLIMIT_RSS) || (RLIMIT_VMEM == RLIMIT_RSS)
+#define ULIMIT_V_IS_AS
+#elif defined(RLIMIT_VMEM)
+#if !defined(RLIMIT_RSS) || (RLIMIT_RSS == RLIMIT_AS)
+#define ULIMIT_V_IS_AS
+#else
+#define ULIMIT_V_IS_VMEM
+#endif
+#endif
+#endif
+
+#ifdef RLIMIT_RSS
+#ifdef ULIMIT_V_IS_VMEM
+#define ULIMIT_M_IS_RSS
+#elif defined(RLIMIT_VMEM) && (RLIMIT_VMEM == RLIMIT_RSS)
+#define ULIMIT_M_IS_VMEM
+#else
+#define ULIMIT_M_IS_RSS
+#endif
+#if defined(ULIMIT_M_IS_RSS) && defined(RLIMIT_AS) && (RLIMIT_RSS == RLIMIT_AS)
+#undef ULIMIT_M_IS_RSS
+#endif
+#endif
+
+#if !defined(RLIMIT_AS) && !defined(ULIMIT_M_IS_VMEM) && defined(RLIMIT_VMEM)
+#define ULIMIT_V_IS_VMEM
+#endif
+
+#if !defined(ULIMIT_V_IS_VMEM) && defined(RLIMIT_VMEM) && \
+    (!defined(RLIMIT_RSS) || (defined(RLIMIT_AS) && (RLIMIT_RSS == RLIMIT_AS)))
+#define ULIMIT_M_IS_VMEM
+#endif
+
+#if defined(ULIMIT_M_IS_VMEM) && defined(RLIMIT_AS) && \
+    (RLIMIT_VMEM == RLIMIT_AS)
+#undef ULIMIT_M_IS_VMEM
+#endif
+
+
 int
 c_ulimit(const char **wp)
 {
@@ -3141,18 +3113,12 @@
 #ifdef RLIMIT_MEMLOCK
 		{ "lockedmem(KiB)", RLIMIT_MEMLOCK, 1024, 'l' },
 #endif
-#ifdef RLIMIT_RSS
-		{ "memory(KiB)", RLIMIT_RSS, 1024, 'm' },
-#endif
 #ifdef RLIMIT_NOFILE
 		{ "nofiles(descriptors)", RLIMIT_NOFILE, 1, 'n' },
 #endif
 #ifdef RLIMIT_NPROC
 		{ "processes", RLIMIT_NPROC, 1, 'p' },
 #endif
-#ifdef RLIMIT_VMEM
-		{ "vmemory(KiB)", RLIMIT_VMEM, 1024, 'v' },
-#endif
 #ifdef RLIMIT_SWAP
 		{ "swap(KiB)", RLIMIT_SWAP, 1024, 'w' },
 #endif
@@ -3162,6 +3128,46 @@
 #ifdef RLIMIT_TIME
 		{ "humantime(seconds)", RLIMIT_TIME, 1, 'T' },
 #endif
+#ifdef RLIMIT_NOVMON
+		{ "vnodemonitors", RLIMIT_NOVMON, 1, 'V' },
+#endif
+#ifdef RLIMIT_SIGPENDING
+		{ "sigpending", RLIMIT_SIGPENDING, 1, 'i' },
+#endif
+#ifdef RLIMIT_MSGQUEUE
+		{ "msgqueue(bytes)", RLIMIT_MSGQUEUE, 1, 'q' },
+#endif
+#ifdef RLIMIT_AIO_MEM
+		{ "AIOlockedmem(KiB)", RLIMIT_AIO_MEM, 1024, 'M' },
+#endif
+#ifdef RLIMIT_AIO_OPS
+		{ "AIOoperations", RLIMIT_AIO_OPS, 1, 'O' },
+#endif
+#ifdef RLIMIT_TCACHE
+		{ "cachedthreads", RLIMIT_TCACHE, 1, 'C' },
+#endif
+#ifdef RLIMIT_SBSIZE
+		{ "sockbufsiz(KiB)", RLIMIT_SBSIZE, 1024, 'B' },
+#endif
+#ifdef RLIMIT_PTHREAD
+		{ "threadsperprocess", RLIMIT_PTHREAD, 1, 'P' },
+#endif
+#ifdef RLIMIT_NICE
+		{ "maxnice", RLIMIT_NICE, 1, 'e' },
+#endif
+#ifdef RLIMIT_RTPRIO
+		{ "maxrtprio", RLIMIT_RTPRIO, 1, 'r' },
+#endif
+#if defined(ULIMIT_M_IS_RSS)
+		{ "resident-set(KiB)", RLIMIT_RSS, 1024, 'm' },
+#elif defined(ULIMIT_M_IS_VMEM)
+		{ "memory(KiB)", RLIMIT_VMEM, 1024, 'm' },
+#endif
+#if defined(ULIMIT_V_IS_VMEM)
+		{ "virtual-memory(KiB)", RLIMIT_VMEM, 1024, 'v' },
+#elif defined(ULIMIT_V_IS_AS)
+		{ "address-space(KiB)", RLIMIT_AS, 1024, 'v' },
+#endif
 		{ NULL, 0, 0, 0 }
 	};
 	static char opts[3 + NELEM(limits)];
@@ -3191,7 +3197,8 @@
 			all = true;
 			break;
 		case '?':
-			bi_errorf("usage: ulimit [-acdfHLlmnpSsTtvw] [value]");
+			bi_errorf("%s: %s", "usage",
+			    "ulimit [-acdfHLlmnpSsTtvw] [value]");
 			return (1);
 		default:
 			what = optc;
@@ -3247,7 +3254,7 @@
 	}
 
 	if (getrlimit(l->resource, &limit) < 0) {
-		/* some cannot be read, e.g. Linux RLIMIT_LOCKS */
+		/* some can't be read, e.g. Linux RLIMIT_LOCKS */
 		limit.rlim_cur = RLIM_INFINITY;
 		limit.rlim_max = RLIM_INFINITY;
 	}
@@ -3290,15 +3297,20 @@
 {
 	int rv = 1;
 
-	if (wp == NULL		/* argv */ ||
-	    wp[0] == NULL	/* name of builtin */ ||
-	    wp[1] == NULL	/* first argument */ ||
-	    wp[2] == NULL	/* second argument */ ||
-	    wp[3] != NULL	/* no further args please */)
+	/* skip argv[0] */
+	++wp;
+	if (wp[0] && !strcmp(wp[0], "--"))
+		/* skip "--" (options separator) */
+		++wp;
+
+	/* check for exactly two arguments */
+	if (wp[0] == NULL	/* first argument */ ||
+	    wp[1] == NULL	/* second argument */ ||
+	    wp[2] != NULL	/* no further args please */)
 		bi_errorf(T_synerr);
-	else if ((rv = rename(wp[1], wp[2])) != 0) {
+	else if ((rv = rename(wp[0], wp[1])) != 0) {
 		rv = errno;
-		bi_errorf("failed: %s", strerror(rv));
+		bi_errorf("%s: %s", "failed", strerror(rv));
 	}
 
 	return (rv);
@@ -3310,31 +3322,158 @@
 	int rv = 1;
 	char *buf;
 
-	if (wp != NULL && wp[0] != NULL && wp[1] != NULL) {
-		if (strcmp(wp[1], "--")) {
-			if (wp[2] == NULL) {
-				wp += 1;
-				rv = 0;
-			}
-		} else {
-			if (wp[2] != NULL && wp[3] == NULL) {
-				wp += 2;
-				rv = 0;
-			}
-		}
-	}
+	/* skip argv[0] */
+	++wp;
+	if (wp[0] && !strcmp(wp[0], "--"))
+		/* skip "--" (options separator) */
+		++wp;
 
-	if (rv)
+	/* check for exactly one argument */
+	if (wp[0] == NULL || wp[1] != NULL)
 		bi_errorf(T_synerr);
-	else if ((buf = do_realpath(*wp)) == NULL) {
+	else if ((buf = do_realpath(wp[0])) == NULL) {
 		rv = errno;
-		bi_errorf("%s: %s", *wp, strerror(rv));
+		bi_errorf("%s: %s", wp[0], strerror(rv));
 		if ((unsigned int)rv > 255)
 			rv = 255;
 	} else {
 		shprintf("%s\n", buf);
 		afree(buf, ATEMP);
+		rv = 0;
 	}
 
 	return (rv);
 }
+
+int
+c_cat(const char **wp)
+{
+	int fd = STDIN_FILENO, rv;
+	ssize_t n, w;
+	const char *fn = "<stdin>";
+	char *buf, *cp;
+#define MKSH_CAT_BUFSIZ 4096
+
+	if ((buf = malloc_osfunc(MKSH_CAT_BUFSIZ)) == NULL) {
+		bi_errorf(T_oomem, (unsigned long)MKSH_CAT_BUFSIZ);
+		return (1);
+	}
+
+	/* parse options: POSIX demands we support "-u" as no-op */
+	while ((rv = ksh_getopt(wp, &builtin_opt, "u")) != -1) {
+		switch (rv) {
+		case 'u':
+			/* we already operate unbuffered */
+			break;
+		default:
+			bi_errorf(T_synerr);
+			return (1);
+		}
+	}
+	wp += builtin_opt.optind;
+	rv = 0;
+
+	do {
+		if (*wp) {
+			fn = *wp++;
+			if (fn[0] == '-' && fn[1] == '\0')
+				fd = STDIN_FILENO;
+			else if ((fd = open(fn, O_RDONLY)) < 0) {
+				rv = errno;
+				bi_errorf("%s: %s", fn, strerror(rv));
+				rv = 1;
+				continue;
+			}
+		}
+		while (/* CONSTCOND */ 1) {
+			n = blocking_read(fd, (cp = buf), MKSH_CAT_BUFSIZ);
+			if (n == -1) {
+				if (errno == EINTR)
+					/* interrupted, try again */
+					continue;
+				/* an error occured during reading */
+				rv = errno;
+				bi_errorf("%s: %s", fn, strerror(rv));
+				rv = 1;
+				break;
+			} else if (n == 0)
+				/* end of file reached */
+				break;
+			while (n) {
+				w = write(STDOUT_FILENO, cp, n);
+				if (w == -1) {
+					if (errno == EINTR)
+						/* interrupted, try again */
+						continue;
+					/* an error occured during writing */
+					rv = errno;
+					bi_errorf("%s: %s", "<stdout>",
+					    strerror(rv));
+					rv = 1;
+					if (fd != STDIN_FILENO)
+						close(fd);
+					goto out;
+				}
+				n -= w;
+				cp += w;
+			}
+		}
+		if (fd != STDIN_FILENO)
+			close(fd);
+	} while (*wp);
+
+ out:
+	free_osfunc(buf);
+	return (rv);
+}
+
+#if HAVE_SELECT
+int
+c_sleep(const char **wp)
+{
+	struct timeval tv;
+	int rv = 1;
+
+	/* skip argv[0] */
+	++wp;
+	if (wp[0] && !strcmp(wp[0], "--"))
+		/* skip "--" (options separator) */
+		++wp;
+
+	if (!wp[0] || wp[1])
+		bi_errorf(T_synerr);
+	else if (parse_usec(wp[0], &tv))
+		bi_errorf("%s: %s '%s'", T_synerr, strerror(errno), wp[0]);
+	else {
+#ifndef MKSH_NOPROSPECTOFWORK
+		sigset_t omask;
+
+		/* block SIGCHLD from interrupting us, though */
+		sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
+#endif
+		if (select(0, NULL, NULL, NULL, &tv) == 0 || errno == EINTR)
+			/*
+			 * strictly speaking only for SIGALRM, but the
+			 * execution may be interrupted by other signals
+			 */
+			rv = 0;
+		else
+			bi_errorf("%s: %s", T_select, strerror(errno));
+#ifndef MKSH_NOPROSPECTOFWORK
+		sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
+	}
+	return (rv);
+}
+#endif
+
+#if defined(ANDROID)
+static int
+c_android_lsmod(const char **wp MKSH_A_UNUSED)
+{
+	const char *cwp[3] = { "cat", "/proc/modules", NULL };
+
+	builtin_argv0 = cwp[0];
+	return (c_cat(cwp));
+}
+#endif
Index: src/bin/mksh/histrap.c
diff -u src/bin/mksh/histrap.c:1.92 src/bin/mksh/histrap.c:1.109
--- src/bin/mksh/histrap.c:1.92	Fri Jan 29 09:34:28 2010
+++ src/bin/mksh/histrap.c	Fri Apr 22 12:21:53 2011
@@ -1,8 +1,8 @@
-/*	$OpenBSD: history.c,v 1.37 2009/07/02 16:29:15 martynas Exp $	*/
-/*	$OpenBSD: trap.c,v 1.22 2005/03/30 17:16:37 deraadt Exp $	*/
+/*	$OpenBSD: history.c,v 1.39 2010/05/19 17:36:08 jasper Exp $	*/
+/*	$OpenBSD: trap.c,v 1.23 2010/05/19 17:36:08 jasper Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -22,11 +22,11 @@
  */
 
 #include "sh.h"
-#if HAVE_PERSISTENT_HISTORY
+#if HAVE_SYS_FILE_H
 #include <sys/file.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.92 2010/01/29 09:34:28 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.109 2011/04/22 12:21:53 tg Exp $");
 
 /*-
  * MirOS: This is the default mapping type, and need not be specified.
@@ -50,7 +50,7 @@
 #endif
 
 static int hist_execute(char *);
-static int hist_replace(char **, const char *, const char *, int);
+static int hist_replace(char **, const char *, const char *, bool);
 static char **hist_get(const char *, bool, bool);
 static char **hist_get_oldest(void);
 static void histbackup(void);
@@ -60,11 +60,15 @@
 static Source *hist_source;
 
 #if HAVE_PERSISTENT_HISTORY
-static char *hname;		/* current name of history file */
+/* current history file: name, fd, size */
+static char *hname;
 static int histfd;
 static int hsize;
 #endif
 
+static const char T_not_in_history[] = "not in history";
+#define T_history (T_not_in_history + 7)
+
 int
 c_fc(const char **wp)
 {
@@ -72,45 +76,57 @@
 	struct temp *tf;
 	const char *p;
 	char *editor = NULL;
-	int gflag = 0, lflag = 0, nflag = 0, sflag = 0, rflag = 0;
+	bool gflag = false, lflag = false, nflag = false, rflag = false,
+	    sflag = false;
 	int optc;
 	const char *first = NULL, *last = NULL;
 	char **hfirst, **hlast, **hp;
 
 	if (!Flag(FTALKING_I)) {
-		bi_errorf("history functions not available");
+		bi_errorf("history %ss not available", T_function);
 		return (1);
 	}
 
 	while ((optc = ksh_getopt(wp, &builtin_opt,
 	    "e:glnrs0,1,2,3,4,5,6,7,8,9,")) != -1)
 		switch (optc) {
+
 		case 'e':
 			p = builtin_opt.optarg;
 			if (ksh_isdash(p))
-				sflag++;
+				sflag = true;
 			else {
 				size_t len = strlen(p);
+
+				/* almost certainly not overflowing */
 				editor = alloc(len + 4, ATEMP);
 				memcpy(editor, p, len);
 				memcpy(editor + len, " $_", 4);
 			}
 			break;
-		case 'g': /* non-AT&T ksh */
-			gflag++;
+
+		/* non-AT&T ksh */
+		case 'g':
+			gflag = true;
 			break;
+
 		case 'l':
-			lflag++;
+			lflag = true;
 			break;
+
 		case 'n':
-			nflag++;
+			nflag = true;
 			break;
+
 		case 'r':
-			rflag++;
+			rflag = true;
 			break;
-		case 's':	/* POSIX version of -e - */
-			sflag++;
+
+		/* POSIX version of -e - */
+		case 's':
+			sflag = true;
 			break;
+
 		/* kludge city - accept -num as -- -num (kind of) */
 		case '0': case '1': case '2': case '3': case '4':
 		case '5': case '6': case '7': case '8': case '9':
@@ -125,6 +141,7 @@
 				return (1);
 			}
 			break;
+
 		case '?':
 			return (1);
 		}
@@ -182,15 +199,15 @@
 		/* can't fail if hfirst didn't fail */
 		hlast = hist_get_newest(false);
 	} else {
-		/* POSIX says not an error if first/last out of bounds
-		 * when range is specified; AT&T ksh and pdksh allow out of
-		 * bounds for -l as well.
+		/*
+		 * POSIX says not an error if first/last out of bounds
+		 * when range is specified; AT&T ksh and pdksh allow out
+		 * of bounds for -l as well.
 		 */
-		hfirst = hist_get(first, (lflag || last) ? true : false,
-		    lflag ? true : false);
+		hfirst = hist_get(first, tobool(lflag || last), lflag);
 		if (!hfirst)
 			return (1);
-		hlast = last ? hist_get(last, true, lflag ? true : false) :
+		hlast = last ? hist_get(last, true, lflag) :
 		    (lflag ? hist_get_newest(false) : hfirst);
 		if (!hlast)
 			return (1);
@@ -199,7 +216,8 @@
 		char **temp;
 
 		temp = hfirst; hfirst = hlast; hlast = temp;
-		rflag = !rflag; /* POSIX */
+		/* POSIX */
+		rflag = !rflag;
 	}
 
 	/* List history */
@@ -230,15 +248,16 @@
 
 	tf = maketemp(ATEMP, TT_HIST_EDIT, &e->temps);
 	if (!(shf = tf->shf)) {
-		bi_errorf("cannot create temp file %s - %s",
-		    tf->name, strerror(errno));
+		bi_errorf("can't %s temporary file %s: %s",
+		    "create", tf->name, strerror(errno));
 		return (1);
 	}
 	for (hp = rflag ? hlast : hfirst;
 	    hp >= hfirst && hp <= hlast; hp += rflag ? -1 : 1)
 		shf_fprintf(shf, "%s\n", *hp);
 	if (shf_close(shf) == EOF) {
-		bi_errorf("error writing temporary file - %s", strerror(errno));
+		bi_errorf("can't %s temporary file %s: %s",
+		    "write", tf->name, strerror(errno));
 		return (1);
 	}
 
@@ -250,7 +269,7 @@
 		Source *sold = source;
 		int ret;
 
-		ret = command(editor ? editor : "${FCEDIT:-/bin/ed} $_");
+		ret = command(editor ? editor : "${FCEDIT:-/bin/ed} $_", 0);
 		source = sold;
 		if (ret)
 			return (ret);
@@ -263,11 +282,19 @@
 		int n;
 
 		if (!(shf = shf_open(tf->name, O_RDONLY, 0, 0))) {
-			bi_errorf("cannot open temp file %s", tf->name);
+			bi_errorf("can't %s temporary file %s: %s",
+			    "open", tf->name, strerror(errno));
 			return (1);
 		}
 
-		n = stat(tf->name, &statb) < 0 ? 128 : statb.st_size + 1;
+		if (stat(tf->name, &statb) < 0)
+			n = 128;
+		else if (statb.st_size > (1024 * 1048576)) {
+			bi_errorf("%s %s too large: %lu", T_history,
+			    "file", (unsigned long)statb.st_size);
+			goto errout;
+		} else
+			n = statb.st_size + 1;
 		Xinit(xs, xp, n, hist_source->areap);
 		while ((n = shf_read(xp, Xnleft(xs, xp), shf)) > 0) {
 			xp += n;
@@ -275,8 +302,9 @@
 				XcheckN(xs, xp, Xlength(xs, xp));
 		}
 		if (n < 0) {
-			bi_errorf("error reading temp file %s - %s",
-			    tf->name, strerror(shf_errno(shf)));
+			bi_errorf("can't %s temporary file %s: %s",
+			    "read", tf->name, strerror(shf_errno(shf)));
+ errout:
 			shf_close(shf);
 			return (1);
 		}
@@ -299,18 +327,23 @@
 
 	for (p = cmd; p; p = q) {
 		if ((q = strchr(p, '\n'))) {
-			*q++ = '\0'; /* kill the newline */
-			if (!*q) /* ignore trailing newline */
+			/* kill the newline */
+			*q++ = '\0';
+			if (!*q)
+				/* ignore trailing newline */
 				q = NULL;
 		}
 		histsave(&hist_source->line, p, true, true);
 
-		shellf("%s\n", p); /* POSIX doesn't say this is done... */
-		if (q)		/* restore \n (trailing \n not restored) */
+		/* POSIX doesn't say this is done... */
+		shellf("%s\n", p);
+		if (q)
+			/* restore \n (trailing \n not restored) */
 			q[-1] = '\n';
 	}
 
-	/* Commands are executed here instead of pushing them onto the
+	/*-
+	 * Commands are executed here instead of pushing them onto the
 	 * input 'cause POSIX says the redirection and variable assignments
 	 * in
 	 *	X=y fc -e - 42 2> /dev/null
@@ -318,13 +351,13 @@
 	 */
 	/* XXX: source should not get trashed by this.. */
 	sold = source;
-	ret = command(cmd);
+	ret = command(cmd, 0);
 	source = sold;
 	return (ret);
 }
 
 static int
-hist_replace(char **hp, const char *pat, const char *rep, int globr)
+hist_replace(char **hp, const char *pat, const char *rep, bool globr)
 {
 	char *line;
 
@@ -337,21 +370,23 @@
 		int len;
 		XString xs;
 		char *xp;
-		int any_subst = 0;
+		bool any_subst = false;
 
 		Xinit(xs, xp, 128, ATEMP);
 		for (s = *hp; (s1 = strstr(s, pat)) && (!any_subst || globr);
 		    s = s1 + pat_len) {
-			any_subst = 1;
+			any_subst = true;
 			len = s1 - s;
 			XcheckN(xs, xp, len + rep_len);
-			memcpy(xp, s, len);		/* first part */
+			/*; first part */
+			memcpy(xp, s, len);
 			xp += len;
-			memcpy(xp, rep, rep_len);	/* replacement */
+			/* replacement */
+			memcpy(xp, rep, rep_len);
 			xp += rep_len;
 		}
 		if (!any_subst) {
-			bi_errorf("substitution failed");
+			bi_errorf("bad substitution");
 			return (1);
 		}
 		len = strlen(s) + 1;
@@ -379,18 +414,18 @@
 			if (approx)
 				hp = hist_get_oldest();
 			else {
-				bi_errorf("%s: not in history", str);
+				bi_errorf("%s: %s", str, T_not_in_history);
 				hp = NULL;
 			}
 		} else if ((ptrdiff_t)hp > (ptrdiff_t)histptr) {
 			if (approx)
 				hp = hist_get_newest(allow_cur);
 			else {
-				bi_errorf("%s: not in history", str);
+				bi_errorf("%s: %s", str, T_not_in_history);
 				hp = NULL;
 			}
 		} else if (!allow_cur && hp == histptr) {
-			bi_errorf("%s: invalid range", str);
+			bi_errorf("%s: %s", str, "invalid range");
 			hp = NULL;
 		}
 	} else {
@@ -398,7 +433,7 @@
 
 		/* the -1 is to avoid the current fc command */
 		if ((n = findhist(histptr - history - 1, 0, str, anchored)) < 0)
-			bi_errorf("%s: not in history", str);
+			bi_errorf("%s: %s", str, T_not_in_history);
 		else
 			hp = &history[n];
 	}
@@ -416,7 +451,7 @@
 	return (allow_cur ? histptr : histptr - 1);
 }
 
-/* Return a pointer to the newest command in the history */
+/* Return a pointer to the oldest command in the history */
 static char **
 hist_get_oldest(void)
 {
@@ -427,9 +462,9 @@
 	return (history);
 }
 
-/******************************/
-/* Back up over last histsave */
-/******************************/
+/*
+ * Back up over last histsave
+ */
 static void
 histbackup(void)
 {
@@ -491,26 +526,6 @@
 	return (-1);
 }
 
-int
-findhistrel(const char *str)
-{
-	int	maxhist = histptr - history;
-	int	start = maxhist - 1;
-	int	rec;
-
-	getn(str, &rec);
-	if (rec == 0)
-		return (-1);
-	if (rec > 0) {
-		if (rec > maxhist)
-			return (-1);
-		return (rec - 1);
-	}
-	if (rec > maxhist)
-		return (-1);
-	return (start + rec + 1);
-}
-
 /*
  *	set history
  *	this means reallocating the dataspace
@@ -527,7 +542,7 @@
 			cursize = n;
 		}
 
-		history = aresize(history, n * sizeof(char *), APERM);
+		history = aresize2(history, n, sizeof(char *), APERM);
 
 		histsize = n;
 		histptr = history + cursize;
@@ -578,7 +593,7 @@
 {
 	if (history == (char **)NULL) {
 		histsize = HISTORYSIZE;
-		history = alloc(histsize * sizeof(char *), APERM);
+		history = alloc2(histsize, sizeof(char *), APERM);
 		histptr = history - 1;
 	}
 }
@@ -644,7 +659,8 @@
 
 	hp = histptr;
 
-	if (++hp >= history + histsize) { /* remove oldest command */
+	if (++hp >= history + histsize) {
+		/* remove oldest command */
 		afree(*history, APERM);
 		for (hp = history; hp < history + histsize - 1; hp++)
 			hp[0] = hp[1];
@@ -664,7 +680,7 @@
  *	if your system ain't got it - then you'll have to undef HISTORYFILE
  */
 
-/*
+/*-
  *	Open a history file
  *	Format is:
  *	Bytes 1, 2:
@@ -745,8 +761,9 @@
 				hist_finish();
 				if (rv) {
  hiniterr:
-					bi_errorf("cannot unlink HISTFILE %s"
-					    " - %s", hname, strerror(errno));
+					bi_errorf("can't %s %s: %s",
+					    "unlink HISTFILE", hname,
+					    strerror(errno));
 					hsize = 0;
 					return;
 				}
@@ -860,9 +877,10 @@
 	unsigned char *ep;
 
 	for (ep = base + *bytes; --ep > base; ) {
-		/* this doesn't really work: the 4 byte line number that is
-		 * encoded after the COMMAND byte can itself contain the
-		 * COMMAND byte....
+		/*
+		 * this doesn't really work: the 4 byte line number that
+		 * is encoded after the COMMAND byte can itself contain
+		 * the COMMAND byte....
 		 */
 		for (; ep > base && *ep != COMMAND; ep--)
 			;
@@ -954,7 +972,7 @@
 {
 	int	sizenow;
 	unsigned char	*base;
-	unsigned char	*new;
+	unsigned char	*news;
 	int	bytes;
 	unsigned char	hdr[5];
 
@@ -971,13 +989,13 @@
 			    MAP_FILE | MAP_PRIVATE, histfd, (off_t)0);
 			if (base == (unsigned char *)MAP_FAILED)
 				goto bad;
-			new = base + hsize;
-			if (*new != COMMAND) {
+			news = base + hsize;
+			if (*news != COMMAND) {
 				munmap((caddr_t)base, sizenow);
 				goto bad;
 			}
 			hist_source->line--;
-			histload(hist_source, new, bytes);
+			histload(hist_source, news, bytes);
 			hist_source->line++;
 			lno = hist_source->line;
 			munmap((caddr_t)base, sizenow);
@@ -1046,6 +1064,8 @@
 	int i;
 	const char *cs;
 
+	trap_exstat = -1;
+
 	/* Populate sigtraps based on sys_signame and sys_siglist. */
 	for (i = 0; i <= NSIG; i++) {
 		sigtraps[i].signal = i;
@@ -1083,10 +1103,12 @@
 #endif
 			if ((sigtraps[i].mess == NULL) ||
 			    (sigtraps[i].mess[0] == '\0'))
-				sigtraps[i].mess = shf_smprintf("Signal %d", i);
+				sigtraps[i].mess = shf_smprintf("%s %d",
+				    "Signal", i);
 		}
 	}
-	sigtraps[SIGEXIT_].name = "EXIT";	/* our name for signal 0 */
+	/* our name for signal 0 */
+	sigtraps[SIGEXIT_].name = "EXIT";
 
 	(void)sigemptyset(&Sigact_ign.sa_mask);
 	Sigact_ign.sa_flags = 0; /* interruptible */
@@ -1094,7 +1116,8 @@
 
 	sigtraps[SIGINT].flags |= TF_DFL_INTR | TF_TTY_INTR;
 	sigtraps[SIGQUIT].flags |= TF_DFL_INTR | TF_TTY_INTR;
-	sigtraps[SIGTERM].flags |= TF_DFL_INTR;/* not fatal for interactive */
+	/* SIGTERM is not fatal for interactive */
+	sigtraps[SIGTERM].flags |= TF_DFL_INTR;
 	sigtraps[SIGHUP].flags |= TF_FATAL;
 	sigtraps[SIGCHLD].flags |= TF_SHELL_USES;
 
@@ -1119,7 +1142,7 @@
 static void
 alarm_catcher(int sig MKSH_A_UNUSED)
 {
-	int errno_ = errno;
+	/* this runs inside interrupt context, with errno saved */
 
 	if (ksh_tmout_state == TMOUT_READING) {
 		int left = alarm(0);
@@ -1130,7 +1153,6 @@
 		} else
 			alarm(left);
 	}
-	errno = errno_;
 }
 
 Trap *
@@ -1178,7 +1200,8 @@
 	errno = errno_;
 }
 
-/* called when we want to allow the user to ^C out of something - won't
+/*
+ * called when we want to allow the user to ^C out of something - won't
  * work if user has trapped SIGINT.
  */
 void
@@ -1188,7 +1211,8 @@
 		runtraps(TF_DFL_INTR|TF_FATAL);
 }
 
-/* called after EINTR to check if a signal with normally causes process
+/*
+ * called after EINTR to check if a signal with normally causes process
  * termination has been received.
  */
 int
@@ -1205,7 +1229,8 @@
 	return (0);
 }
 
-/* Returns the signal number of any pending traps: ie, a signal which has
+/*
+ * Returns the signal number of any pending traps: ie, a signal which has
  * occurred for which a trap has been set or for which the TF_DFL_INTR flag
  * is set.
  */
@@ -1237,7 +1262,8 @@
 		warningf(false, "timed out waiting for input");
 		unwind(LEXIT);
 	} else
-		/* XXX: this means the alarm will have no effect if a trap
+		/*
+		 * XXX: this means the alarm will have no effect if a trap
 		 * is caught after the alarm() was started...not good.
 		 */
 		ksh_tmout_state = TMOUT_EXECUTING;
@@ -1247,22 +1273,29 @@
 		intrsig = 0;
 	if (flag & TF_FATAL)
 		fatal_trap = 0;
+	++trap_nested;
 	for (p = sigtraps, i = NSIG+1; --i >= 0; p++)
 		if (p->set && (!flag ||
 		    ((p->flags & flag) && p->trap == NULL)))
-			runtrap(p);
+			runtrap(p, false);
+	if (!--trap_nested)
+		runtrap(NULL, true);
 }
 
 void
-runtrap(Trap *p)
+runtrap(Trap *p, bool is_last)
 {
-	int	i = p->signal;
-	char	*trapstr = p->trap;
-	int	oexstat;
-	int	old_changed = 0;
+	int old_changed = 0, i;
+	char *trapstr;
 
+	if (p == NULL)
+		/* just clean up, see runtraps() above */
+		goto donetrap;
+	i = p->signal;
+	trapstr = p->trap;
 	p->set = 0;
-	if (trapstr == NULL) { /* SIG_DFL */
+	if (trapstr == NULL) {
+		/* SIG_DFL */
 		if (p->flags & TF_FATAL) {
 			/* eg, SIGHUP */
 			exstat = 128 + i;
@@ -1273,21 +1306,24 @@
 			exstat = 128 + i;
 			unwind(LINTR);
 		}
-		return;
+		goto donetrap;
 	}
-	if (trapstr[0] == '\0') /* SIG_IGN */
-		return;
-	if (i == SIGEXIT_ || i == SIGERR_) {	/* avoid recursion on these */
+	if (trapstr[0] == '\0')
+		/* SIG_IGN */
+		goto donetrap;
+	if (i == SIGEXIT_ || i == SIGERR_) {
+		/* avoid recursion on these */
 		old_changed = p->flags & TF_CHANGED;
 		p->flags &= ~TF_CHANGED;
 		p->trap = NULL;
 	}
-	oexstat = exstat;
-	/* Note: trapstr is fully parsed before anything is executed, thus
+	if (trap_exstat == -1)
+		trap_exstat = exstat;
+	/*
+	 * Note: trapstr is fully parsed before anything is executed, thus
 	 * no problem with afree(p->trap) in settrap() while still in use.
 	 */
-	command(trapstr);
-	exstat = oexstat;
+	command(trapstr, current_lineno);
 	if (i == SIGEXIT_ || i == SIGERR_) {
 		if (p->flags & TF_CHANGED)
 			/* don't clear TF_CHANGED */
@@ -1296,6 +1332,13 @@
 			p->trap = trapstr;
 		p->flags |= old_changed;
 	}
+
+ donetrap:
+	/* we're the last trap of a sequence executed */
+	if (is_last && trap_exstat != -1) {
+		exstat = trap_exstat;
+		trap_exstat = -1;
+	}
 }
 
 /* clear pending traps and reset user's trap handlers; used after fork(2) */
@@ -1335,7 +1378,8 @@
 
 	if (p->trap)
 		afree(p->trap, APERM);
-	strdupx(p->trap, s, APERM); /* handles s == 0 */
+	/* handles s == NULL */
+	strdupx(p->trap, s, APERM);
 	p->flags |= TF_CHANGED;
 	f = !s ? SIG_DFL : s[0] ? trapsig : SIG_IGN;
 
@@ -1352,7 +1396,8 @@
 				p->flags |= TF_EXEC_DFL;
 		}
 
-		/* assumes handler already set to what shell wants it
+		/*
+		 * assumes handler already set to what shell wants it
 		 * (normally trapsig, but could be j_sigchld() or SIG_IGN)
 		 */
 		return;
@@ -1362,7 +1407,8 @@
 	setsig(p, f, SS_RESTORE_CURR|SS_USER);
 }
 
-/* Called by c_print() when writing to a co-process to ensure SIGPIPE won't
+/*
+ * Called by c_print() when writing to a co-process to ensure SIGPIPE won't
  * kill shell (unless user catches it and exits)
  */
 int
@@ -1377,7 +1423,8 @@
 			restore_dfl = 1;
 	} else if (p->cursig == SIG_DFL) {
 		setsig(p, SIG_IGN, SS_RESTORE_CURR);
-		restore_dfl = 1; /* restore to SIG_DFL */
+		/* restore to SIG_DFL */
+		restore_dfl = 1;
 	}
 	return (restore_dfl);
 }
@@ -1390,7 +1437,8 @@
 		setsig(&sigtraps[SIGPIPE], SIG_DFL, SS_RESTORE_CURR);
 }
 
-/* Set action for a signal. Action may not be set if original
+/*
+ * Set action for a signal. Action may not be set if original
  * action was SIG_IGN, depending on the value of flags and FTALKING.
  */
 int
@@ -1401,7 +1449,8 @@
 	if (p->signal == SIGEXIT_ || p->signal == SIGERR_)
 		return (1);
 
-	/* First time setting this signal? If so, get and note the current
+	/*
+	 * First time setting this signal? If so, get and note the current
 	 * setting.
 	 */
 	if (!(p->flags & (TF_ORIG_IGN|TF_ORIG_DFL))) {
@@ -1411,7 +1460,8 @@
 		p->cursig = SIG_IGN;
 	}
 
-	/* Generally, an ignored signal stays ignored, except if
+	/*-
+	 * Generally, an ignored signal stays ignored, except if
 	 *	- the user of an interactive shell wants to change it
 	 *	- the shell wants for force a change
 	 */
@@ -1421,9 +1471,11 @@
 
 	setexecsig(p, flags & SS_RESTORE_MASK);
 
-	/* This is here 'cause there should be a way of clearing shtraps, but
-	 * don't know if this is a sane way of doing it. At the moment,
-	 * all users of shtrap are lifetime users (SIGCHLD, SIGALRM, SIGWINCH).
+	/*
+	 * This is here 'cause there should be a way of clearing
+	 * shtraps, but don't know if this is a sane way of doing
+	 * it. At the moment, all users of shtrap are lifetime
+	 * users (SIGALRM, SIGCHLD, SIGWINCH).
 	 */
 	if (!(flags & SS_USER))
 		p->shtrap = (sig_t)NULL;
@@ -1435,7 +1487,8 @@
 	if (p->cursig != f) {
 		p->cursig = f;
 		(void)sigemptyset(&sigact.sa_mask);
-		sigact.sa_flags = 0 /* interruptible */;
+		/* interruptible */
+		sigact.sa_flags = 0;
 		sigact.sa_handler = f;
 		sigaction(p->signal, &sigact, NULL);
 	}
@@ -1455,7 +1508,8 @@
 	/* restore original value for exec'd kids */
 	p->flags &= ~(TF_EXEC_IGN|TF_EXEC_DFL);
 	switch (restore & SS_RESTORE_MASK) {
-	case SS_RESTORE_CURR: /* leave things as they currently are */
+	case SS_RESTORE_CURR:
+		/* leave things as they currently are */
 		break;
 	case SS_RESTORE_ORIG:
 		p->flags |= p->flags & TF_ORIG_IGN ? TF_EXEC_IGN : TF_EXEC_DFL;
Index: src/bin/mksh/jobs.c
diff -u src/bin/mksh/jobs.c:1.67 src/bin/mksh/jobs.c:1.78
--- src/bin/mksh/jobs.c:1.67	Thu Dec 31 14:05:43 2009
+++ src/bin/mksh/jobs.c	Fri Apr 22 12:21:54 2011
@@ -1,7 +1,7 @@
 /*	$OpenBSD: jobs.c,v 1.38 2009/12/12 04:28:44 deraadt Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -22,7 +22,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.67 2009/12/31 14:05:43 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.78 2011/04/22 12:21:54 tg Exp $");
 
 #if HAVE_KILLPG
 #define mksh_killpg		killpg
@@ -63,7 +63,7 @@
 #define JF_W_ASYNCNOTIFY 0x004	/* set if waiting and async notification ok */
 #define JF_XXCOM	0x008	/* set for $(command) jobs */
 #define JF_FG		0x010	/* running in foreground (also has tty pgrp) */
-#define JF_SAVEDTTY	0x020	/* j->ttystate is valid */
+#define JF_SAVEDTTY	0x020	/* j->ttystat is valid */
 #define JF_CHANGED	0x040	/* process has changed state */
 #define JF_KNOWN	0x080	/* $! referenced */
 #define JF_ZOMBIE	0x100	/* known, unwaited process */
@@ -87,7 +87,7 @@
 	int32_t	age;		/* number of jobs started */
 	Coproc_id coproc_id;	/* 0 or id of coprocess output pipe */
 #ifndef MKSH_UNEMPLOYED
-	struct termios ttystate;/* saved tty state for stopped jobs */
+	struct termios ttystat;	/* saved tty state for stopped jobs */
 	pid_t saved_ttypgrp;	/* saved tty process group for stopped jobs */
 #endif
 };
@@ -97,6 +97,7 @@
 #define JW_INTERRUPT	0x01	/* ^C will stop the wait */
 #define JW_ASYNCNOTIFY	0x02	/* asynchronous notification during wait ok */
 #define JW_STOPPEDWAIT	0x04	/* wait even if job stopped */
+#define JW_PIPEST	0x08	/* want PIPESTATUS */
 
 /* Error codes for j_lookup() */
 #define JL_OK		0
@@ -124,8 +125,10 @@
 #define CHILD_MAX	25
 #endif
 
+#ifndef MKSH_NOPROSPECTOFWORK
 /* held_sigchld is set if sigchld occurs before a job is completely started */
 static volatile sig_atomic_t held_sigchld;
+#endif
 
 #ifndef MKSH_UNEMPLOYED
 static struct shf	*shl_j;
@@ -157,6 +160,7 @@
 	Flag(FMONITOR) = 0;
 #endif
 
+#ifndef MKSH_NOPROSPECTOFWORK
 	(void)sigemptyset(&sm_default);
 	sigprocmask(SIG_SETMASK, &sm_default, NULL);
 
@@ -165,12 +169,17 @@
 
 	setsig(&sigtraps[SIGCHLD], j_sigchld,
 	    SS_RESTORE_ORIG|SS_FORCE|SS_SHTRAP);
+#else
+	/* Make sure SIGCHLD isn't ignored - can do odd things under SYSV */
+	setsig(&sigtraps[SIGCHLD], SIG_DFL, SS_RESTORE_ORIG|SS_FORCE);
+#endif
 
 #ifndef MKSH_UNEMPLOYED
 	if (!mflagset && Flag(FTALKING))
 		Flag(FMONITOR) = 1;
 
-	/* shl_j is used to do asynchronous notification (used in
+	/*
+	 * shl_j is used to do asynchronous notification (used in
 	 * an interrupt handler, so need a distinct shf)
 	 */
 	shl_j = shf_fdopen(2, SHF_WR, NULL);
@@ -178,7 +187,8 @@
 	if (Flag(FMONITOR) || Flag(FTALKING)) {
 		int i;
 
-		/* the TF_SHELL_USES test is a kludge that lets us know if
+		/*
+		 * the TF_SHELL_USES test is a kludge that lets us know if
 		 * if the signals have been changed by the shell.
 		 */
 		for (i = NELEM(tt_sigs); --i >= 0; ) {
@@ -198,13 +208,26 @@
 		tty_init(true, true);
 }
 
+static int
+proc_errorlevel(Proc *p)
+{
+	switch (p->state) {
+	case PEXITED:
+		return (WEXITSTATUS(p->status));
+	case PSIGNALLED:
+		return (128 + WTERMSIG(p->status));
+	default:
+		return (0);
+	}
+}
+
 /* job cleanup before shell exit */
 void
 j_exit(void)
 {
 	/* kill stopped, and possibly running, jobs */
-	Job	*j;
-	int	killed = 0;
+	Job *j;
+	bool killed = false;
 
 	for (j = job_list; j != NULL; j = j->next) {
 		if (j->ppid == procpid &&
@@ -212,7 +235,7 @@
 		    (j->state == PRUNNING &&
 		    ((j->flags & JF_FG) ||
 		    (Flag(FLOGIN) && !Flag(FNOHUP) && procpid == kshpid))))) {
-			killed = 1;
+			killed = true;
 			if (j->pgrp == 0)
 				kill_job(j, SIGHUP);
 			else
@@ -233,7 +256,8 @@
 
 #ifndef MKSH_UNEMPLOYED
 	if (kshpid == procpid && restore_ttypgrp >= 0) {
-		/* Need to restore the tty pgrp to what it was when the
+		/*
+		 * Need to restore the tty pgrp to what it was when the
 		 * shell started up, so that the process that started us
 		 * will be able to access the tty when we are done.
 		 * Also need to restore our process group in case we are
@@ -269,12 +293,12 @@
 			setsig(&sigtraps[SIGTTIN], SIG_DFL,
 			    SS_RESTORE_ORIG|SS_FORCE);
 			/* wait to be given tty (POSIX.1, B.2, job control) */
-			while (1) {
+			while (/* CONSTCOND */ 1) {
 				pid_t ttypgrp;
 
 				if ((ttypgrp = tcgetpgrp(tty_fd)) < 0) {
-					warningf(false,
-					    "j_init: tcgetpgrp() failed: %s",
+					warningf(false, "%s: %s %s: %s",
+					    "j_init", "tcgetpgrp", "failed",
 					    strerror(errno));
 					ttypgrp_ok = false;
 					break;
@@ -289,14 +313,13 @@
 			    SS_RESTORE_DFL|SS_FORCE);
 		if (ttypgrp_ok && kshpgrp != kshpid) {
 			if (setpgid(0, kshpid) < 0) {
-				warningf(false,
-				    "j_init: setpgid() failed: %s",
-				    strerror(errno));
+				warningf(false, "%s: %s %s: %s", "j_init",
+				    "setpgid", "failed", strerror(errno));
 				ttypgrp_ok = false;
 			} else {
 				if (tcsetpgrp(tty_fd, kshpid) < 0) {
-					warningf(false,
-					    "j_init: tcsetpgrp() failed: %s",
+					warningf(false, "%s: %s %s: %s",
+					    "j_init", "tcsetpgrp", "failed",
 					    strerror(errno));
 					ttypgrp_ok = false;
 				} else
@@ -305,7 +328,8 @@
 			}
 		}
 		if (use_tty && !ttypgrp_ok)
-			warningf(false, "warning: won't have full job control");
+			warningf(false, "%s: %s", "warning",
+			    "won't have full job control");
 		if (tty_fd >= 0)
 			tcgetattr(tty_fd, &tty_state);
 	} else {
@@ -333,29 +357,36 @@
 int
 exchild(struct op *t, int flags,
     volatile int *xerrok,
-    /* used if XPCLOSE or XCCLOSE */ int close_fd)
+    /* used if XPCLOSE or XCCLOSE */
+    int close_fd)
 {
-	static Proc *last_proc;		/* for pipelines */
+	/* for pipelines */
+	static Proc *last_proc;
 
-	int i, rv = 0, forksleep;
+	int rv = 0, forksleep, jwflags = JW_NONE;
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigset_t omask;
+#endif
 	Proc *p;
 	Job *j;
-	struct {
-#if !HAVE_ARC4RANDOM
-		pid_t thepid;
-#endif
-		unsigned char ischild;
-	} pi;
+	pid_t cldpid;
+
+	if (flags & XPIPEST) {
+		flags &= ~XPIPEST;
+		jwflags |= JW_PIPEST;
+	}
 
 	if (flags & XEXEC)
-		/* Clear XFORK|XPCLOSE|XCCLOSE|XCOPROC|XPIPEO|XPIPEI|XXCOM|XBGND
+		/*
+		 * Clear XFORK|XPCLOSE|XCCLOSE|XCOPROC|XPIPEO|XPIPEI|XXCOM|XBGND
 		 * (also done in another execute() below)
 		 */
 		return (execute(t, flags & (XEXEC | XERROK), xerrok));
 
+#ifndef MKSH_NOPROSPECTOFWORK
 	/* no SIGCHLDs while messing with job and process lists */
 	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
+#endif
 
 	p = new_proc();
 	p->next = NULL;
@@ -364,18 +395,21 @@
 	p->pid = 0;
 
 	/* link process into jobs list */
-	if (flags & XPIPEI) {	/* continuing with a pipe */
+	if (flags & XPIPEI) {
+		/* continuing with a pipe */
 		if (!last_job)
-			internal_errorf(
-			    "exchild: XPIPEI and no last_job - pid %d",
+			internal_errorf("%s %d",
+			    "exchild: XPIPEI and no last_job - pid",
 			    (int)procpid);
 		j = last_job;
 		if (last_proc)
 			last_proc->next = p;
 		last_proc = p;
 	} else {
-		j = new_job(); /* fills in j->job */
-		/* we don't consider XXCOMs foreground since they don't get
+		/* fills in j->job */
+		j = new_job();
+		/*
+		 * we don't consider XXCOMs foreground since they don't get
 		 * tty process group and we don't save or restore tty modes.
 		 */
 		j->flags = (flags & XXCOM) ? JF_XXCOM :
@@ -393,49 +427,42 @@
 		put_job(j, PJ_PAST_STOPPED);
 	}
 
-	snptreef(p->command, sizeof(p->command), "%T", t);
+	vistree(p->command, sizeof(p->command), t);
 
 	/* create child process */
 	forksleep = 1;
-	while ((i = fork()) < 0 && errno == EAGAIN && forksleep < 32) {
-		if (intrsig)	 /* allow user to ^C out... */
+	while ((cldpid = fork()) < 0 && errno == EAGAIN && forksleep < 32) {
+		if (intrsig)
+			/* allow user to ^C out... */
 			break;
 		sleep(forksleep);
 		forksleep <<= 1;
 	}
-	if (i < 0) {
+	/* ensure $RANDOM changes between parent and child */
+	rndset((long)cldpid);
+	/* fork failed? */
+	if (cldpid < 0) {
 		kill_job(j, SIGKILL);
 		remove_job(j, "fork failed");
+#ifndef MKSH_NOPROSPECTOFWORK
 		sigprocmask(SIG_SETMASK, &omask, NULL);
-		errorf("cannot fork - try again");
-	}
-#if !HAVE_ARC4RANDOM
-#ifdef DEBUG
-	/* reduce extra 3 bytes of entropy, for Valgrind */
-	memset(&pi, 0, sizeof(pi));
-#endif
-	pi.thepid =
-#endif
-	    p->pid = (pi.ischild = i == 0) ? (procpid = getpid()) : i;
-
-#if !HAVE_ARC4RANDOM
-	/*
-	 * ensure next child gets a (slightly) different $RANDOM sequence
-	 * from its parent process and other child processes
-	 */
-	change_random(&pi, sizeof(pi));
 #endif
+		errorf("can't fork - try again");
+	}
+	p->pid = cldpid ? cldpid : (procpid = getpid());
 
 #ifndef MKSH_UNEMPLOYED
 	/* job control set up */
 	if (Flag(FMONITOR) && !(flags&XXCOM)) {
-		int	dotty = 0;
-		if (j->pgrp == 0) {	/* First process */
+		bool dotty = false;
+		if (j->pgrp == 0) {
+			/* First process */
 			j->pgrp = p->pid;
-			dotty = 1;
+			dotty = true;
 		}
 
-		/* set pgrp in both parent and child to deal with race
+		/*
+		 * set pgrp in both parent and child to deal with race
 		 * condition
 		 */
 		setpgid(p->pid, j->pgrp);
@@ -445,23 +472,28 @@
 #endif
 
 	/* used to close pipe input fd */
-	if (close_fd >= 0 && (((flags & XPCLOSE) && !pi.ischild) ||
-	    ((flags & XCCLOSE) && pi.ischild)))
+	if (close_fd >= 0 && (((flags & XPCLOSE) && cldpid) ||
+	    ((flags & XCCLOSE) && !cldpid)))
 		close(close_fd);
-	if (pi.ischild) {		/* child */
+	if (!cldpid) {
+		/* child */
+
 		/* Do this before restoring signal */
 		if (flags & XCOPROC)
 			coproc_cleanup(false);
+#ifndef MKSH_NOPROSPECTOFWORK
 		sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 		cleanup_parents_env();
 #ifndef MKSH_UNEMPLOYED
-		/* If FMONITOR or FTALKING is set, these signals are ignored,
+		/*
+		 * If FMONITOR or FTALKING is set, these signals are ignored,
 		 * if neither FMONITOR nor FTALKING are set, the signals have
 		 * their inherited values.
 		 */
 		if (Flag(FMONITOR) && !(flags & XXCOM)) {
-			for (i = NELEM(tt_sigs); --i >= 0; )
-				setsig(&sigtraps[tt_sigs[i]], SIG_DFL,
+			for (forksleep = NELEM(tt_sigs); --forksleep >= 0; )
+				setsig(&sigtraps[tt_sigs[forksleep]], SIG_DFL,
 				    SS_RESTORE_DFL|SS_FORCE);
 		}
 #endif
@@ -479,12 +511,13 @@
 			setsig(&sigtraps[SIGQUIT], SIG_IGN,
 			    SS_RESTORE_IGN|SS_FORCE);
 			if ((!(flags & (XPIPEI | XCOPROC))) &&
-			    ((i = open("/dev/null", 0)) > 0)) {
-				(void)ksh_dup2(i, 0, true);
-				close(i);
+			    ((forksleep = open("/dev/null", 0)) > 0)) {
+				(void)ksh_dup2(forksleep, 0, true);
+				close(forksleep);
 			}
 		}
-		remove_job(j, "child");	/* in case of $(jobs) command */
+		/* in case of $(jobs) command */
+		remove_job(j, "child");
 		nzombie = 0;
 #ifndef MKSH_UNEMPLOYED
 		ttypgrp_ok = false;
@@ -498,8 +531,9 @@
 #ifndef MKSH_SMALL
 		if (t->type == TPIPE)
 			unwind(LLEAVE);
-		internal_warningf("exchild: execute() returned");
-		fptreef(shl_out, 2, "exchild: tried to execute {\n%T\n}\n", t);
+		internal_warningf("%s: %s", "exchild", "execute() returned");
+		fptreef(shl_out, 8, "%s: tried to execute {\n\t%T\n}\n",
+		    "exchild", t);
 		shf_flush(shl_out);
 #endif
 		unwind(LLEAVE);
@@ -507,12 +541,15 @@
 	}
 
 	/* shell (parent) stuff */
-	if (!(flags & XPIPEO)) {	/* last process in a job */
+	if (!(flags & XPIPEO)) {
+		/* last process in a job */
 		j_startjob(j);
 		if (flags & XCOPROC) {
 			j->coproc_id = coproc.id;
-			coproc.njobs++; /* n jobs using co-process output */
-			coproc.job = (void *) j; /* j using co-process input */
+			/* n jobs using co-process output */
+			coproc.njobs++;
+			/* j using co-process input */
+			coproc.job = (void *)j;
 		}
 		if (flags & XBGND) {
 			j_set_async(j);
@@ -525,10 +562,12 @@
 				shf_flush(shl_out);
 			}
 		} else
-			rv = j_waitj(j, JW_NONE, "jw:last proc");
+			rv = j_waitj(j, jwflags, "jw:last proc");
 	}
 
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 
 	return (rv);
 }
@@ -537,41 +576,53 @@
 void
 startlast(void)
 {
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigset_t omask;
 
 	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
+#endif
 
-	if (last_job) { /* no need to report error - waitlast() will do it */
+	/* no need to report error - waitlast() will do it */
+	if (last_job) {
 		/* ensure it isn't removed by check_job() */
 		last_job->flags |= JF_WAITING;
 		j_startjob(last_job);
 	}
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 }
 
 /* wait for last job: only used for $(command) jobs */
 int
 waitlast(void)
 {
-	int	rv;
-	Job	*j;
+	int rv;
+	Job *j;
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigset_t omask;
 
 	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
+#endif
 
 	j = last_job;
 	if (!j || !(j->flags & JF_STARTED)) {
 		if (!j)
-			warningf(true, "waitlast: no last job");
+			warningf(true, "%s: %s", "waitlast", "no last job");
 		else
-			internal_warningf("waitlast: not started");
+			internal_warningf("%s: %s", "waitlast", "not started");
+#ifndef MKSH_NOPROSPECTOFWORK
 		sigprocmask(SIG_SETMASK, &omask, NULL);
-		return (125); /* not so arbitrary, non-zero value */
+#endif
+		/* not so arbitrary, non-zero value */
+		return (125);
 	}
 
-	rv = j_waitj(j, JW_NONE, "jw:waitlast");
+	rv = j_waitj(j, JW_NONE, "waitlast");
 
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 
 	return (rv);
 }
@@ -580,18 +631,19 @@
 int
 waitfor(const char *cp, int *sigp)
 {
-	int	rv;
-	Job	*j;
-	int	ecode;
-	int	flags = JW_INTERRUPT|JW_ASYNCNOTIFY;
+	int rv, ecode, flags = JW_INTERRUPT|JW_ASYNCNOTIFY;
+	Job *j;
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigset_t omask;
 
 	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
+#endif
 
 	*sigp = 0;
 
 	if (cp == NULL) {
-		/* wait for an unspecified job - always returns 0, so
+		/*
+		 * wait for an unspecified job - always returns 0, so
 		 * don't have to worry about exited/signaled jobs
 		 */
 		for (j = job_list; j; j = j->next)
@@ -599,18 +651,24 @@
 			if (j->ppid == procpid && j->state == PRUNNING)
 				break;
 		if (!j) {
+#ifndef MKSH_NOPROSPECTOFWORK
 			sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 			return (-1);
 		}
 	} else if ((j = j_lookup(cp, &ecode))) {
 		/* don't report normal job completion */
 		flags &= ~JW_ASYNCNOTIFY;
 		if (j->ppid != procpid) {
+#ifndef MKSH_NOPROSPECTOFWORK
 			sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 			return (-1);
 		}
 	} else {
+#ifndef MKSH_NOPROSPECTOFWORK
 		sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 		if (ecode != JL_NOSUCH)
 			bi_errorf("%s: %s", cp, lookup_msgs[ecode]);
 		return (-1);
@@ -619,9 +677,12 @@
 	/* AT&T ksh will wait for stopped jobs - we don't */
 	rv = j_waitj(j, flags, "jw:waitfor");
 
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 
-	if (rv < 0) /* we were interrupted */
+	if (rv < 0)
+		/* we were interrupted */
 		*sigp = 128 + -rv;
 
 	return (rv);
@@ -631,20 +692,24 @@
 int
 j_kill(const char *cp, int sig)
 {
-	Job	*j;
-	int	rv = 0;
-	int	ecode;
+	Job *j;
+	int rv = 0, ecode;
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigset_t omask;
 
 	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
+#endif
 
 	if ((j = j_lookup(cp, &ecode)) == NULL) {
+#ifndef MKSH_NOPROSPECTOFWORK
 		sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 		bi_errorf("%s: %s", cp, lookup_msgs[ecode]);
 		return (1);
 	}
 
-	if (j->pgrp == 0) {	/* started when !Flag(FMONITOR) */
+	if (j->pgrp == 0) {
+		/* started when !Flag(FMONITOR) */
 		if (kill_job(j, sig) < 0) {
 			bi_errorf("%s: %s", cp, strerror(errno));
 			rv = 1;
@@ -660,7 +725,9 @@
 		}
 	}
 
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 
 	return (rv);
 }
@@ -670,11 +737,10 @@
 int
 j_resume(const char *cp, int bg)
 {
-	Job	*j;
-	Proc	*p;
-	int	ecode;
-	int	running;
-	int	rv = 0;
+	Job *j;
+	Proc *p;
+	int ecode, rv = 0;
+	bool running;
 	sigset_t omask;
 
 	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
@@ -694,12 +760,12 @@
 	if (bg)
 		shprintf("[%d] ", j->job);
 
-	running = 0;
+	running = false;
 	for (p = j->proc_list; p != NULL; p = p->next) {
 		if (p->state == PSTOPPED) {
 			p->state = PRUNNING;
 			p->status = 0;
-			running = 1;
+			running = true;
 		}
 		shf_puts(p->command, shl_stdout);
 		if (p->next)
@@ -717,7 +783,7 @@
 		/* attach tty to job */
 		if (j->state == PRUNNING) {
 			if (ttypgrp_ok && (j->flags & JF_SAVEDTTY))
-				tcsetattr(tty_fd, TCSADRAIN, &j->ttystate);
+				tcsetattr(tty_fd, TCSADRAIN, &j->ttystat);
 			/* See comment in j_waitj regarding saved_ttypgrp. */
 			if (ttypgrp_ok &&
 			    tcsetpgrp(tty_fd, (j->flags & JF_SAVEDTTYPGRP) ?
@@ -725,12 +791,11 @@
 				rv = errno;
 				if (j->flags & JF_SAVEDTTY)
 					tcsetattr(tty_fd, TCSADRAIN, &tty_state);
-				sigprocmask(SIG_SETMASK, &omask,
-				    NULL);
-				bi_errorf("1st tcsetpgrp(%d, %d) failed: %s",
-				    tty_fd,
-				    (int)((j->flags & JF_SAVEDTTYPGRP) ?
-				    j->saved_ttypgrp : j->pgrp),
+				sigprocmask(SIG_SETMASK, &omask, NULL);
+				bi_errorf("%s %s(%d, %ld) %s: %s",
+				    "1st", "tcsetpgrp", tty_fd,
+				    (long)((j->flags & JF_SAVEDTTYPGRP) ?
+				    j->saved_ttypgrp : j->pgrp), "failed",
 				    strerror(rv));
 				return (1);
 			}
@@ -749,12 +814,12 @@
 			if (ttypgrp_ok && (j->flags & JF_SAVEDTTY))
 				tcsetattr(tty_fd, TCSADRAIN, &tty_state);
 			if (ttypgrp_ok && tcsetpgrp(tty_fd, kshpgrp) < 0)
-				warningf(true,
-				    "fg: 2nd tcsetpgrp(%d, %ld) failed: %s",
-				    tty_fd, (long)kshpgrp, strerror(errno));
+				warningf(true, "%s %s(%d, %ld) %s: %s",
+				    "fg: 2nd", "tcsetpgrp", tty_fd,
+				    (long)kshpgrp, "failed", strerror(errno));
 		}
 		sigprocmask(SIG_SETMASK, &omask, NULL);
-		bi_errorf("cannot continue job %s: %s",
+		bi_errorf("%s %s %s", "can't continue job",
 		    cp, strerror(err));
 		return (1);
 	}
@@ -773,8 +838,8 @@
 int
 j_stopped_running(void)
 {
-	Job	*j;
-	int	which = 0;
+	Job *j;
+	int which = 0;
 
 	for (j = job_list; j != NULL; j = j->next) {
 #ifndef MKSH_UNEMPLOYED
@@ -796,35 +861,23 @@
 	return (0);
 }
 
-int
-j_njobs(void)
-{
-	Job *j;
-	int nj = 0;
-	sigset_t omask;
-
-	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
-	for (j = job_list; j; j = j->next)
-		nj++;
-
-	sigprocmask(SIG_SETMASK, &omask, NULL);
-	return (nj);
-}
-
 
 /* list jobs for jobs built-in */
 int
 j_jobs(const char *cp, int slp,
-    int nflag)		/* 0: short, 1: long, 2: pgrp */
+    /* 0: short, 1: long, 2: pgrp */
+    int nflag)
 {
-	Job	*j, *tmp;
-	int	how;
-	int	zflag = 0;
+	Job *j, *tmp;
+	int how, zflag = 0;
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigset_t omask;
 
 	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
+#endif
 
-	if (nflag < 0) { /* kludge: print zombies */
+	if (nflag < 0) {
+		/* kludge: print zombies */
 		nflag = 0;
 		zflag = 1;
 	}
@@ -832,7 +885,9 @@
 		int	ecode;
 
 		if ((j = j_lookup(cp, &ecode)) == NULL) {
+#ifndef MKSH_NOPROSPECTOFWORK
 			sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 			bi_errorf("%s: %s", cp, lookup_msgs[ecode]);
 			return (1);
 		}
@@ -855,7 +910,9 @@
 		if (j->flags & JF_REMOVE)
 			remove_job(j, "jobs");
 	}
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 	return (0);
 }
 
@@ -863,16 +920,19 @@
 void
 j_notify(void)
 {
-	Job	*j, *tmp;
+	Job *j, *tmp;
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigset_t omask;
 
 	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
+#endif
 	for (j = job_list; j; j = j->next) {
 #ifndef MKSH_UNEMPLOYED
 		if (Flag(FMONITOR) && (j->flags & JF_CHANGED))
 			j_print(j, JP_MEDIUM, shl_out);
 #endif
-		/* Remove job after doing reports so there aren't
+		/*
+		 * Remove job after doing reports so there aren't
 		 * multiple +/- jobs.
 		 */
 		if (j->state == PEXITED || j->state == PSIGNALLED)
@@ -884,26 +944,33 @@
 			remove_job(j, "notify");
 	}
 	shf_flush(shl_out);
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 }
 
 /* Return pid of last process in last asynchronous job */
 pid_t
 j_async(void)
 {
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigset_t omask;
 
 	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
+#endif
 
 	if (async_job)
 		async_job->flags |= JF_KNOWN;
 
+#ifndef MKSH_NOPROSPECTOFWORK
 	sigprocmask(SIG_SETMASK, &omask, NULL);
+#endif
 
 	return (async_pid);
 }
 
-/* Make j the last async process
+/*
+ * Make j the last async process
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
@@ -915,7 +982,7 @@
 	if (async_job && (async_job->flags & (JF_KNOWN|JF_ZOMBIE)) == JF_ZOMBIE)
 		remove_job(async_job, "async");
 	if (!(j->flags & JF_STARTED)) {
-		internal_warningf("j_async: job not started");
+		internal_warningf("%s: %s", "j_async", "job not started");
 		return;
 	}
 	async_job = j;
@@ -929,8 +996,8 @@
 		if (!oldest) {
 			/* XXX debugging */
 			if (!(async_job->flags & JF_ZOMBIE) || nzombie != 1) {
-				internal_warningf("j_async: bad nzombie (%d)",
-				    nzombie);
+				internal_warningf("%s: bad nzombie (%d)",
+				    "j_async", nzombie);
 				nzombie = 0;
 			}
 			break;
@@ -939,7 +1006,8 @@
 	}
 }
 
-/* Start a job: set STARTED, check for held signals and set j->last_proc
+/*
+ * Start a job: set STARTED, check for held signals and set j->last_proc
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
@@ -953,11 +1021,13 @@
 		;
 	j->last_proc = p;
 
+#ifndef MKSH_NOPROSPECTOFWORK
 	if (held_sigchld) {
 		held_sigchld = 0;
 		/* Don't call j_sigchld() as it may remove job... */
 		kill(procpid, SIGCHLD);
 	}
+#endif
 }
 
 /*
@@ -967,7 +1037,8 @@
  */
 static int
 j_waitj(Job *j,
-    int flags,			/* see JW_* */
+    /* see JW_* */
+    int flags,
     const char *where)
 {
 	int	rv;
@@ -986,12 +1057,17 @@
 
 	while (j->state == PRUNNING ||
 	    ((flags & JW_STOPPEDWAIT) && j->state == PSTOPPED)) {
+#ifndef MKSH_NOPROSPECTOFWORK
 		sigsuspend(&sm_default);
+#else
+		j_sigchld(SIGCHLD);
+#endif
 		if (fatal_trap) {
 			int oldf = j->flags & (JF_WAITING|JF_W_ASYNCNOTIFY);
 			j->flags &= ~(JF_WAITING|JF_W_ASYNCNOTIFY);
 			runtraps(TF_FATAL);
-			j->flags |= oldf; /* not reached... */
+			/* not reached... */
+			j->flags |= oldf;
 		}
 		if ((flags & JW_INTERRUPT) && (rv = trap_pending())) {
 			j->flags &= ~(JF_WAITING|JF_W_ASYNCNOTIFY);
@@ -1019,17 +1095,18 @@
 			    (j->saved_ttypgrp = tcgetpgrp(tty_fd)) >= 0)
 				j->flags |= JF_SAVEDTTYPGRP;
 			if (tcsetpgrp(tty_fd, kshpgrp) < 0)
-				warningf(true,
-				    "j_waitj: tcsetpgrp(%d, %ld) failed: %s",
-				    tty_fd, (long)kshpgrp, strerror(errno));
+				warningf(true, "%s %s(%d, %ld) %s: %s",
+				    "j_waitj:", "tcsetpgrp", tty_fd,
+				    (long)kshpgrp, "failed", strerror(errno));
 			if (j->state == PSTOPPED) {
 				j->flags |= JF_SAVEDTTY;
-				tcgetattr(tty_fd, &j->ttystate);
+				tcgetattr(tty_fd, &j->ttystat);
 			}
 		}
 #endif
 		if (tty_fd >= 0) {
-			/* Only restore tty settings if job was originally
+			/*
+			 * Only restore tty settings if job was originally
 			 * started in the foreground. Problems can be
 			 * caused by things like 'more foobar &' which will
 			 * typically get and save the shell's vi/emacs tty
@@ -1042,7 +1119,8 @@
 				tcgetattr(tty_fd, &tty_state);
 			} else {
 				tcsetattr(tty_fd, TCSADRAIN, &tty_state);
-				/* Don't use tty mode if job is stopped and
+				/*-
+				 * Don't use tty mode if job is stopped and
 				 * later restarted and exits. Consider
 				 * the sequence:
 				 *	vi foo (stopped)
@@ -1058,7 +1136,8 @@
 			}
 		}
 #ifndef MKSH_UNEMPLOYED
-		/* If it looks like user hit ^C to kill a job, pretend we got
+		/*
+		 * If it looks like user hit ^C to kill a job, pretend we got
 		 * one too to break out of for loops, etc. (AT&T ksh does this
 		 * even when not monitoring, but this doesn't make sense since
 		 * a tty generated ^C goes to the whole process group)
@@ -1079,6 +1158,38 @@
 	j_systime = j->systime;
 	rv = j->status;
 
+	if ((flags & JW_PIPEST) && (j->proc_list != NULL)) {
+		size_t num = 0;
+		Proc *p = j->proc_list;
+		struct tbl *vp;
+
+		unset(vp_pipest, 1);
+		vp = vp_pipest;
+		vp->flag = DEFINED | ISSET | INTEGER | RDONLY | ARRAY | INT_U;
+		goto got_array;
+
+		while (p != NULL) {
+			{
+				struct tbl *vq;
+
+				/* strlen(vp_pipest->name) == 10 */
+				vq = alloc(offsetof(struct tbl, name[0]) + 11,
+				    vp_pipest->areap);
+				memset(vq, 0, offsetof(struct tbl, name[0]));
+				memcpy(vq->name, vp_pipest->name, 11);
+				vp->u.array = vq;
+				vp = vq;
+			}
+			vp->areap = vp_pipest->areap;
+			vp->ua.index = ++num;
+			vp->flag = DEFINED | ISSET | INTEGER | RDONLY |
+			    ARRAY | INT_U | AINDEX;
+ got_array:
+			vp->val.i = proc_errorlevel(p);
+			p = p->next;
+		}
+	}
+
 	if (!(flags & JW_ASYNCNOTIFY)
 #ifndef MKSH_UNEMPLOYED
 	    && (!Flag(FMONITOR) || j->state != PSTOPPED)
@@ -1097,7 +1208,8 @@
 	return (rv);
 }
 
-/* SIGCHLD handler to reap children and update job states
+/*
+ * SIGCHLD handler to reap children and update job states
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
@@ -1105,14 +1217,17 @@
 static void
 j_sigchld(int sig MKSH_A_UNUSED)
 {
-	int		errno_ = errno;
-	Job		*j;
-	Proc		*p = NULL;
-	int		pid;
-	int		status;
-	struct rusage	ru0, ru1;
+	/* this runs inside interrupt context, with errno saved */
+
+	Job *j;
+	Proc *p = NULL;
+	pid_t pid;
+	int status;
+	struct rusage ru0, ru1;
 
-	/* Don't wait for any processes if a job is partially started.
+#ifndef MKSH_NOPROSPECTOFWORK
+	/*
+	 * Don't wait for any processes if a job is partially started.
 	 * This is so we don't do away with the process group leader
 	 * before all the processes in a pipe line are started (so the
 	 * setpgid() won't fail)
@@ -1120,15 +1235,24 @@
 	for (j = job_list; j; j = j->next)
 		if (j->ppid == procpid && !(j->flags & JF_STARTED)) {
 			held_sigchld = 1;
-			goto finished;
+			return;
 		}
+#endif
 
 	getrusage(RUSAGE_CHILDREN, &ru0);
 	do {
+#ifndef MKSH_NOPROSPECTOFWORK
 		pid = waitpid(-1, &status, (WNOHANG|WUNTRACED));
+#else
+		pid = wait(&status);
+#endif
 
-		if (pid <= 0)	/* return if would block (0) ... */
-			break;	/* ... or no children or interrupted (-1) */
+		/*
+		 * return if this would block (0) or no children
+		 * or interrupted (-1)
+		 */
+		if (pid <= 0)
+			return;
 
 		getrusage(RUSAGE_CHILDREN, &ru1);
 
@@ -1163,11 +1287,14 @@
 		else
 			p->state = PEXITED;
 
-		check_job(j);	/* check to see if entire job is done */
-	} while (1);
-
- finished:
-	errno = errno_;
+		/* check to see if entire job is done */
+		check_job(j);
+	}
+#ifndef MKSH_NOPROSPECTOFWORK
+	    while (/* CONSTCOND */ 1);
+#else
+	    while (/* CONSTCOND */ 0);
+#endif
 }
 
 /*
@@ -1194,35 +1321,28 @@
 	jstate = PRUNNING;
 	for (p=j->proc_list; p != NULL; p = p->next) {
 		if (p->state == PRUNNING)
-			return;	/* some processes still running */
+			/* some processes still running */
+			return;
 		if (p->state > jstate)
 			jstate = p->state;
 	}
 	j->state = jstate;
+	j->status = proc_errorlevel(j->last_proc);
 
-	switch (j->last_proc->state) {
-	case PEXITED:
-		j->status = WEXITSTATUS(j->last_proc->status);
-		break;
-	case PSIGNALLED:
-		j->status = 128 + WTERMSIG(j->last_proc->status);
-		break;
-	default:
-		j->status = 0;
-		break;
-	}
-
-	/* Note when co-process dies: can't be done in j_wait() nor
+	/*
+	 * Note when co-process dies: can't be done in j_wait() nor
 	 * remove_job() since neither may be called for non-interactive
 	 * shells.
 	 */
 	if (j->state == PEXITED || j->state == PSIGNALLED) {
-		/* No need to keep co-process input any more
+		/*
+		 * No need to keep co-process input any more
 		 * (at least, this is what ksh93d thinks)
 		 */
 		if (coproc.job == j) {
 			coproc.job = NULL;
-			/* XXX would be nice to get the closes out of here
+			/*
+			 * XXX would be nice to get the closes out of here
 			 * so they aren't done in the signal handler.
 			 * Would mean a check in coproc_getfd() to
 			 * do "if job == 0 && write >= 0, close write".
@@ -1238,7 +1358,8 @@
 	j->flags |= JF_CHANGED;
 #ifndef MKSH_UNEMPLOYED
 	if (Flag(FMONITOR) && !(j->flags & JF_XXCOM)) {
-		/* Only put stopped jobs at the front to avoid confusing
+		/*
+		 * Only put stopped jobs at the front to avoid confusing
 		 * the user (don't want finished jobs effecting %+ or %-)
 		 */
 		if (j->state == PSTOPPED)
@@ -1255,7 +1376,8 @@
 						fd = ep->savefd[2];
 				shf_reopen(fd, SHF_WR, shl_j);
 			}
-			/* Can't call j_notify() as it removes jobs. The job
+			/*
+			 * Can't call j_notify() as it removes jobs. The job
 			 * must stay in the job list as j_waitj() may be
 			 * running with this job.
 			 */
@@ -1299,7 +1421,8 @@
 	int	output = 0;
 
 	if (how == JP_PGRP) {
-		/* POSIX doesn't say what to do it there is no process
+		/*
+		 * POSIX doesn't say what to do it there is no process
 		 * group leader (ie, !FMONITOR). We arbitrarily return
 		 * last pid (which is what $! returns).
 		 */
@@ -1338,8 +1461,9 @@
 			if (WCOREDUMP(p->status))
 				coredumped = 1;
 #endif
-			/* kludge for not reporting 'normal termination signals'
-			 * (ie, SIGINT, SIGPIPE)
+			/*
+			 * kludge for not reporting 'normal termination
+			 * signals' (i.e. SIGINT, SIGPIPE)
 			 */
 			if (how == JP_SHORT && !coredumped &&
 			    (WTERMSIG(p->status) == SIGINT ||
@@ -1355,7 +1479,7 @@
 			if (p == j->proc_list)
 				shf_fprintf(shf, "[%d] %c ", j->job, jobchar);
 			else
-				shf_fprintf(shf, "%s", filler);
+				shf_puts(filler, shf);
 		}
 
 		if (how == JP_LONG)
@@ -1392,7 +1516,8 @@
 		shf_putc('\n', shf);
 }
 
-/* Convert % sequence to job
+/*
+ * Convert % sequence to job
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
@@ -1409,8 +1534,10 @@
 		for (j = job_list; j != NULL; j = j->next)
 			if (j->last_proc && j->last_proc->pid == job)
 				return (j);
-		/* ...then look for process group (this is non-POSIX,
-		 * but should not break anything */
+		/*
+		 * ...then look for process group (this is non-POSIX,
+		 * but should not break anything
+		 */
 		for (j = job_list; j != NULL; j = j->next)
 			if (j->pgrp && j->pgrp == job)
 				return (j);
@@ -1444,7 +1571,8 @@
 				return (j);
 		break;
 
-	case '?':		/* %?string */
+	/* %?string */
+	case '?':
 		last_match = NULL;
 		for (j = job_list; j != NULL; j = j->next)
 			for (p = j->proc_list; p != NULL; p = p->next)
@@ -1460,7 +1588,8 @@
 			return (last_match);
 		break;
 
-	default:		/* %string */
+	/* %string */
+	default:
 		len = strlen(cp);
 		last_match = NULL;
 		for (j = job_list; j != NULL; j = j->next)
@@ -1484,7 +1613,8 @@
 static Job	*free_jobs;
 static Proc	*free_procs;
 
-/* allocate a new job and fill in the job number.
+/*
+ * allocate a new job and fill in the job number.
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
@@ -1512,7 +1642,8 @@
 	return (newj);
 }
 
-/* Allocate new process struct
+/*
+ * Allocate new process struct
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
@@ -1530,7 +1661,8 @@
 	return (p);
 }
 
-/* Take job out of job_list and put old structures into free list.
+/*
+ * Take job out of job_list and put old structures into free list.
  * Keeps nzombies, last_job and async_job up to date.
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
@@ -1546,7 +1678,7 @@
 	for (; curr != NULL && curr != j; prev = &curr->next, curr = *prev)
 		;
 	if (curr != j) {
-		internal_warningf("remove_job: job not found (%s)", where);
+		internal_warningf("remove_job: job %s (%s)", "not found", where);
 		return;
 	}
 	*prev = curr->next;
@@ -1570,7 +1702,8 @@
 		async_job = NULL;
 }
 
-/* put j in a particular location (taking it out job_list if it is there
+/*
+ * put j in a particular location (taking it out job_list if it is there
  * already)
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
@@ -1606,7 +1739,8 @@
 	}
 }
 
-/* nuke a job (called when unable to start full job).
+/*
+ * nuke a job (called when unable to start full job).
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
Index: src/bin/mksh/lalloc.c
diff -u src/bin/mksh/lalloc.c:1.11 src/bin/mksh/lalloc.c:1.17
--- src/bin/mksh/lalloc.c:1.11	Sat Aug  8 13:08:51 2009
+++ src/bin/mksh/lalloc.c	Sun Mar 13 10:50:44 2011
@@ -1,32 +1,32 @@
 /*-
- * Copyright © 2009
+ * Copyright (c) 2009, 2010, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
  * are retained or reproduced in an accompanying document, permission
- * is granted to deal in this work without restriction, including un‐
+ * is granted to deal in this work without restriction, including un-
  * limited rights to use, publicly perform, distribute, sell, modify,
  * merge, give away, or sublicence.
  *
- * This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
+ * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
  * the utmost extent permitted by applicable law, neither express nor
  * implied; without malicious intent or gross negligence. In no event
  * may a licensor, author or contributor be held liable for indirect,
  * direct, other damage, loss, or other issues arising in any way out
  * of dealing in the work, even if advised of the possibility of such
  * damage or existence of a defect, except proven that it results out
- * of said person’s immediate fault when using the work as intended.
+ * of said person's immediate fault when using the work as intended.
  */
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.11 2009/08/08 13:08:51 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.17 2011/03/13 10:50:44 tg Exp $");
 
 /* build with CPPFLAGS+= -DUSE_REALLOC_MALLOC=0 on ancient systems */
 #if defined(USE_REALLOC_MALLOC) && (USE_REALLOC_MALLOC == 0)
-#define remalloc(p,n)	((p) == NULL ? malloc(n) : realloc((p), (n)))
+#define remalloc(p,n)	((p) == NULL ? malloc_osi(n) : realloc_osi((p), (n)))
 #else
-#define remalloc(p,n)	realloc((p), (n))
+#define remalloc(p,n)	realloc_osi((p), (n))
 #endif
 
 #define ALLOC_ISUNALIGNED(p) (((ptrdiff_t)(p)) % ALLOC_SIZE)
@@ -61,12 +61,29 @@
 #ifndef MKSH_SMALL
  fail:
 #endif
-			internal_errorf("rogue pointer %p", ptr);
+#ifdef DEBUG
+			internal_warningf("rogue pointer %lX in ap %lX",
+			    (long)(ptrdiff_t)ptr, (long)(ptrdiff_t)ap);
+			/* try to get a coredump */
+			abort();
+#else
+			internal_errorf("rogue pointer %lX",
+			    (long)(ptrdiff_t)ptr);
+#endif
 		}
 	return (ap);
 }
 
 void *
+aresize2(void *ptr, size_t fac1, size_t fac2, Area *ap)
+{
+	if (notoktomul(fac1, fac2))
+		internal_errorf(T_intovfl, (unsigned long)fac1, '*',
+		    (unsigned long)fac2);
+	return (aresize(ptr, fac1 * fac2, ap));
+}
+
+void *
 aresize(void *ptr, size_t numb, Area *ap)
 {
 	ALLOC_ITEM *lp = NULL;
@@ -79,14 +96,13 @@
 		pp->next = lp->next;
 	}
 
-	if ((numb >= SIZE_MAX - ALLOC_SIZE) ||
+	if (notoktoadd(numb, ALLOC_SIZE) ||
 	    (lp = remalloc(lp, numb + ALLOC_SIZE)) == NULL
 #ifndef MKSH_SMALL
 	    || ALLOC_ISUNALIGNED(lp)
 #endif
 	    )
-		internal_errorf("cannot allocate %lu data bytes",
-		    (unsigned long)numb);
+		internal_errorf(T_oomem, (unsigned long)numb);
 	/* this only works because Area is an ALLOC_ITEM */
 	lp->next = ap->next;
 	ap->next = lp;
@@ -104,7 +120,7 @@
 		/* unhook */
 		pp->next = lp->next;
 		/* now free ALLOC_ITEM */
-		free(lp);
+		free_osimalloc(lp);
 	}
 }
 
@@ -118,6 +134,6 @@
 		/* make next ALLOC_ITEM head of list */
 		ap->next = lp->next;
 		/* free old head */
-		free(lp);
+		free_osimalloc(lp);
 	}
 }
Index: src/bin/mksh/lex.c
diff -u src/bin/mksh/lex.c:1.110 src/bin/mksh/lex.c:1.150
--- src/bin/mksh/lex.c:1.110	Thu Feb 25 20:18:16 2010
+++ src/bin/mksh/lex.c	Sat May  7 00:51:12 2011
@@ -1,7 +1,7 @@
-/*	$OpenBSD: lex.c,v 1.44 2008/07/03 17:52:08 otto Exp $	*/
+/*	$OpenBSD: lex.c,v 1.45 2011/03/09 09:30:39 okan Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -22,7 +22,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.110 2010/02/25 20:18:16 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.150 2011/05/07 00:51:12 tg Exp $");
 
 /*
  * states while lexing word
@@ -35,78 +35,53 @@
 #define SEQUOTE		5	/* inside $'' */
 #define SBRACE		6	/* inside ${} */
 #define SQBRACE		7	/* inside "${}" */
-#define SCSPAREN	8	/* inside $() */
-#define SBQUOTE		9	/* inside `` */
-#define SASPAREN	10	/* inside $(( )) */
-#define SHEREDELIM	11	/* parsing <<,<<- delimiter */
-#define SHEREDQUOTE	12	/* parsing " in <<,<<- delimiter */
-#define SPATTERN	13	/* parsing *(...|...) pattern (*+?@!) */
-#define STBRACE		14	/* parsing ${...[#%]...} */
-#define SLETARRAY	15	/* inside =( ), just copy */
-#define SADELIM		16	/* like SBASE, looking for delimiter */
-#define SHERESTRING	17	/* parsing <<< string */
-
-/* Structure to keep track of the lexing state and the various pieces of info
- * needed for each particular state. */
-typedef struct lex_state Lex_state;
-struct lex_state {
-	int ls_state;
-	union {
-		/* $(...) */
-		struct scsparen_info {
-			int nparen;	/* count open parenthesis */
-			int csstate;	/* XXX remove */
-#define ls_scsparen ls_info.u_scsparen
-		} u_scsparen;
-
-		/* $((...)) */
-		struct sasparen_info {
-			int nparen;	/* count open parenthesis */
-			int start;	/* marks start of $(( in output str */
-#define ls_sasparen ls_info.u_sasparen
-		} u_sasparen;
-
-		/* ((...)) */
-		struct sletparen_info {
-			int nparen;	/* count open parenthesis */
-#define ls_sletparen ls_info.u_sletparen
-		} u_sletparen;
-
-		/* `...` */
-		struct sbquote_info {
-			int indquotes;	/* true if in double quotes: "`...`" */
-#define ls_sbquote ls_info.u_sbquote
-		} u_sbquote;
+#define SBQUOTE		8	/* inside `` */
+#define SASPAREN	9	/* inside $(( )) */
+#define SHEREDELIM	10	/* parsing <<,<<- delimiter */
+#define SHEREDQUOTE	11	/* parsing " in <<,<<- delimiter */
+#define SPATTERN	12	/* parsing *(...|...) pattern (*+?@!) */
+#define STBRACE		13	/* parsing ${...[#%]...} */
+#define SLETARRAY	14	/* inside =( ), just copy */
+#define SADELIM		15	/* like SBASE, looking for delimiter */
+#define SHERESTRING	16	/* parsing <<< string */
+#define SINVALID	255	/* invalid state */
 
-#ifndef MKSH_SMALL
-		/* =(...) */
-		struct sletarray_info {
-			int nparen;	/* count open parentheses */
-#define ls_sletarray ls_info.u_sletarray
-		} u_sletarray;
-#endif
+struct sretrace_info {
+	struct sretrace_info *next;
+	XString xs;
+	char *xp;
+};
 
-		/* ADELIM */
-		struct sadelim_info {
-			unsigned char nparen;	/* count open parentheses */
-#define SADELIM_BASH	0
-#define SADELIM_MAKE	1
-			unsigned char style;
+/*
+ * Structure to keep track of the lexing state and the various pieces of info
+ * needed for each particular state.
+ */
+typedef struct lex_state {
+	union {
+		/* point to the next state block */
+		struct lex_state *base;
+		/* marks start of state output in output string */
+		int start;
+		/* SBQUOTE: true if in double quotes: "`...`" */
+		/* SEQUOTE: got NUL, ignore rest of string */
+		bool abool;
+		/* SADELIM information */
+		struct {
+			/* character to search for */
 			unsigned char delimiter;
+			/* max. number of delimiters */
 			unsigned char num;
-			unsigned char flags;	/* ofs. into sadelim_flags[] */
-#define ls_sadelim ls_info.u_sadelim
-		} u_sadelim;
-
-		/* $'...' */
-		struct sequote_info {
-			bool got_NUL;	/* ignore rest of string */
-#define ls_sequote ls_info.u_sequote
-		} u_sequote;
-
-		Lex_state *base;	/* used to point to next state block */
-	} ls_info;
-};
+		} adelim;
+	} u;
+	/* count open parentheses */
+	short nparen;
+	/* type of this state */
+	uint8_t type;
+} Lex_state;
+#define ls_base		u.base
+#define ls_start	u.start
+#define ls_bool		u.abool
+#define ls_adelim	u.adelim
 
 typedef struct {
 	Lex_state *base;
@@ -114,72 +89,106 @@
 } State_info;
 
 static void readhere(struct ioword *);
+static void ungetsc(int);
+static void ungetsc_(int);
 static int getsc__(void);
 static void getsc_line(Source *);
 static int getsc_bn(void);
 static int s_get(void);
 static void s_put(int);
 static char *get_brace_var(XString *, char *);
-static int arraysub(char **);
-static const char *ungetsc(int);
+static bool arraysub(char **);
 static void gethere(bool);
 static Lex_state *push_state_(State_info *, Lex_state *);
 static Lex_state *pop_state_(State_info *, Lex_state *);
 
 static int dopprompt(const char *, int, bool);
+void yyskiputf8bom(void);
 
 static int backslash_skip;
 static int ignore_backslash_newline;
+static struct sretrace_info *retrace_info;
+short subshell_nesting_level = 0;
 
 /* optimised getsc_bn() */
-#define _getsc()	(*source->str != '\0' && *source->str != '\\' \
-			 && !backslash_skip && !(source->flags & SF_FIRST) \
-			 ? *source->str++ : getsc_bn())
+#define _getsc()	(*source->str != '\0' && *source->str != '\\' && \
+			    !backslash_skip ? *source->str++ : getsc_bn())
 /* optimised getsc__() */
-#define	_getsc_()	((*source->str != '\0') && !(source->flags & SF_FIRST) \
-			 ? *source->str++ : getsc__())
+#define	_getsc_()	((*source->str != '\0') ? *source->str++ : getsc__())
+
+/* retrace helper */
+#define _getsc_r(carg)	{				\
+	int cev = (carg);				\
+	struct sretrace_info *rp = retrace_info;	\
+							\
+	while (rp) {					\
+		Xcheck(rp->xs, rp->xp);			\
+		*rp->xp++ = cev;			\
+		rp = rp->next;				\
+	}						\
+							\
+	return (cev);					\
+}
 
 #ifdef MKSH_SMALL
 static int getsc(void);
-static int getsc_(void);
 
 static int
 getsc(void)
 {
-	return (_getsc());
+	_getsc_r(_getsc());
 }
+#else
+static int getsc_r(int);
 
 static int
-getsc_(void)
+getsc_r(int c)
 {
-	return (_getsc_());
+	_getsc_r(c);
 }
-#else
-/* !MKSH_SMALL: use them inline */
-#define getsc()		_getsc()
-#define getsc_()	_getsc_()
+
+#define getsc()		getsc_r(_getsc())
 #endif
 
-#define STATE_BSIZE	32
+#define STATE_BSIZE	8
 
 #define PUSH_STATE(s)	do {					\
 	if (++statep == state_info.end)				\
 		statep = push_state_(&state_info, statep);	\
-	state = statep->ls_state = (s);				\
-} while (0)
+	state = statep->type = (s);				\
+} while (/* CONSTCOND */ 0)
 
 #define POP_STATE()	do {					\
 	if (--statep == state_info.base)			\
 		statep = pop_state_(&state_info, statep);	\
-	state = statep->ls_state;				\
-} while (0)
+	state = statep->type;					\
+} while (/* CONSTCOND */ 0)
+
+#define PUSH_SRETRACE()	do {					\
+	struct sretrace_info *ri;				\
+								\
+	statep->ls_start = Xsavepos(ws, wp);			\
+	ri = alloc(sizeof(struct sretrace_info), ATEMP);	\
+	Xinit(ri->xs, ri->xp, 64, ATEMP);			\
+	ri->next = retrace_info;				\
+	retrace_info = ri;					\
+} while (/* CONSTCOND */ 0)
+
+#define POP_SRETRACE()	do {					\
+	wp = Xrestpos(ws, wp, statep->ls_start);		\
+	*retrace_info->xp = '\0';				\
+	sp = Xstring(retrace_info->xs, retrace_info->xp);	\
+	dp = (void *)retrace_info;				\
+	retrace_info = retrace_info->next;			\
+	afree(dp, ATEMP);					\
+} while (/* CONSTCOND */ 0)
 
 /**
  * Lexical analyser
  *
  * tokens are not regular expressions, they are LL(1).
  * for example, "${var:-${PWD}}", and "$(size $(whence ksh))".
- * hence the state stack.
+ * hence the state stack. Note "$(...)" are now parsed recursively.
  */
 
 int
@@ -193,8 +202,8 @@
 	char *sp, *dp;
 
  Again:
-	states[0].ls_state = -1;
-	states[0].ls_info.base = NULL;
+	states[0].type = SINVALID;
+	states[0].ls_base = NULL;
 	statep = &states[1];
 	state_info.base = states;
 	state_info.end = &state_info.base[STATE_BSIZE];
@@ -204,19 +213,21 @@
 	backslash_skip = 0;
 	ignore_backslash_newline = 0;
 
-	if (cf&ONEWORD)
+	if (cf & ONEWORD)
 		state = SWORD;
-	else if (cf&LETEXPR) {
+	else if (cf & LETEXPR) {
 		/* enclose arguments in (double) quotes */
 		*wp++ = OQUOTE;
 		state = SLETPAREN;
-		statep->ls_sletparen.nparen = 0;
+		statep->nparen = 0;
 #ifndef MKSH_SMALL
-	} else if (cf&LETARRAY) {
+	} else if (cf & LETARRAY) {
 		state = SLETARRAY;
-		statep->ls_sletarray.nparen = 0;
+		statep->nparen = 0;
+		PUSH_SRETRACE();
 #endif
-	} else {		/* normal lexing */
+	} else {
+		/* normal lexing */
 		state = (cf & HEREDELIM) ? SHEREDELIM : SBASE;
 		while ((c = getsc()) == ' ' || c == '\t')
 			;
@@ -228,13 +239,14 @@
 		}
 		ungetsc(c);
 	}
-	if (source->flags & SF_ALIAS) {	/* trailing ' ' in alias definition */
+	if (source->flags & SF_ALIAS) {
+		/* trailing ' ' in alias definition */
 		source->flags &= ~SF_ALIAS;
 		cf |= ALIAS;
 	}
 
-	/* Initial state: one of SBASE SHEREDELIM SWORD SASPAREN */
-	statep->ls_state = state;
+	/* Initial state: one of SWORD SLETPAREN SLETARRAY SHEREDELIM SBASE */
+	statep->type = state;
 
 	/* check for here string */
 	if (state == SHEREDELIM) {
@@ -259,14 +271,14 @@
 		switch (state) {
 		case SADELIM:
 			if (c == '(')
-				statep->ls_sadelim.nparen++;
+				statep->nparen++;
 			else if (c == ')')
-				statep->ls_sadelim.nparen--;
-			else if (statep->ls_sadelim.nparen == 0 &&
-			    (c == /*{*/ '}' || c == statep->ls_sadelim.delimiter)) {
+				statep->nparen--;
+			else if (statep->nparen == 0 &&
+			    (c == /*{*/ '}' || c == statep->ls_adelim.delimiter)) {
 				*wp++ = ADELIM;
 				*wp++ = c;
-				if (c == /*{*/ '}' || --statep->ls_sadelim.num == 0)
+				if (c == /*{*/ '}' || --statep->ls_adelim.num == 0)
 					POP_STATE();
 				if (c == /*{*/ '}')
 					POP_STATE();
@@ -275,7 +287,8 @@
 			/* FALLTHROUGH */
 		case SBASE:
 			if (c == '[' && (cf & (VARASN|ARRAYVAR))) {
-				*wp = EOS;	/* temporary */
+				/* temporary */
+				*wp = EOS;
 				if (is_wdvarname(Xstring(ws, wp), false)) {
 					char *p, *tmp;
 
@@ -355,6 +368,7 @@
 					/* FALLTHROUGH */
 				case '\\':
 				case '$': case '`':
+ store_qchar:
 					*wp++ = QCHAR;
 					*wp++ = c;
 					break;
@@ -377,17 +391,20 @@
 				if (c == '(') /*)*/ {
 					c = getsc();
 					if (c == '(') /*)*/ {
-						PUSH_STATE(SASPAREN);
-						statep->ls_sasparen.nparen = 2;
-						statep->ls_sasparen.start =
-						    Xsavepos(ws, wp);
 						*wp++ = EXPRSUB;
+						PUSH_STATE(SASPAREN);
+						statep->nparen = 2;
+						PUSH_SRETRACE();
+						*retrace_info->xp++ = '(';
 					} else {
 						ungetsc(c);
-						PUSH_STATE(SCSPAREN);
-						statep->ls_scsparen.nparen = 1;
-						statep->ls_scsparen.csstate = 0;
+ subst_command:
+						sp = yyrecursive();
+						c2 = strlen(sp) + 1;
+						XcheckN(ws, wp, c2);
 						*wp++ = COMSUB;
+						memcpy(wp, sp, c2);
+						wp += c2;
 					}
 				} else if (c == '{') /*}*/ {
 					*wp++ = OSUBST;
@@ -406,14 +423,14 @@
 							*wp++ = ':';
 							PUSH_STATE(SBRACE);
 							PUSH_STATE(SADELIM);
-							statep->ls_sadelim.style = SADELIM_BASH;
-							statep->ls_sadelim.delimiter = ':';
-							statep->ls_sadelim.num = 1;
-							statep->ls_sadelim.nparen = 0;
+							statep->ls_adelim.delimiter = ':';
+							statep->ls_adelim.num = 1;
+							statep->nparen = 0;
 							break;
 						} else if (ksh_isdigit(c) ||
 						    c == '('/*)*/ || c == ' ' ||
-						    c == '$' /* XXX what else? */) {
+						    /*XXX what else? */
+						    c == '$') {
 							/* substring subst. */
 							if (c != ' ') {
 								*wp++ = CHAR;
@@ -422,10 +439,9 @@
 							ungetsc(c);
 							PUSH_STATE(SBRACE);
 							PUSH_STATE(SADELIM);
-							statep->ls_sadelim.style = SADELIM_BASH;
-							statep->ls_sadelim.delimiter = ':';
-							statep->ls_sadelim.num = 2;
-							statep->ls_sadelim.nparen = 0;
+							statep->ls_adelim.delimiter = ':';
+							statep->ls_adelim.num = 2;
+							statep->nparen = 0;
 							break;
 						}
 					} else if (c == '/') {
@@ -438,16 +454,16 @@
 							ungetsc(c);
 						PUSH_STATE(SBRACE);
 						PUSH_STATE(SADELIM);
-						statep->ls_sadelim.style = SADELIM_BASH;
-						statep->ls_sadelim.delimiter = '/';
-						statep->ls_sadelim.num = 1;
-						statep->ls_sadelim.nparen = 0;
+						statep->ls_adelim.delimiter = '/';
+						statep->ls_adelim.num = 1;
+						statep->nparen = 0;
 						break;
 					}
-					/* If this is a trim operation,
+					/*
+					 * If this is a trim operation,
 					 * treat (,|,) specially in STBRACE.
 					 */
-					if (ctype(c, C_SUBOP2)) {
+					if (!Flag(FSH) && ctype(c, C_SUBOP2)) {
 						ungetsc(c);
 						PUSH_STATE(STBRACE);
 					} else {
@@ -482,11 +498,15 @@
 					*wp++ = OQUOTE;
 					ignore_backslash_newline++;
 					PUSH_STATE(SEQUOTE);
-					statep->ls_sequote.got_NUL = false;
+					statep->ls_bool = false;
 					break;
+				} else if (c == '"' && (state == SBASE)) {
+					/* XXX which other states are valid? */
+					goto DEQUOTE;
 				} else {
 					*wp++ = CHAR;
 					*wp++ = '$';
+ DEQUOTE:
 					ungetsc(c);
 				}
 				break;
@@ -494,7 +514,8 @@
  subst_gravis:
 				PUSH_STATE(SBQUOTE);
 				*wp++ = COMSUB;
-				/* Need to know if we are inside double quotes
+				/*
+				 * Need to know if we are inside double quotes
 				 * since sh/AT&T-ksh translate the \" to " in
 				 * "`...\"...`".
 				 * This is not done in POSIX mode (section
@@ -514,19 +535,19 @@
 				 * literal meaning, except when followed by
 				 * $ ` \.").
 				 */
-				statep->ls_sbquote.indquotes = 0;
+				statep->ls_bool = false;
 				s2 = statep;
 				base = state_info.base;
-				while (1) {
+				while (/* CONSTCOND */ 1) {
 					for (; s2 != base; s2--) {
-						if (s2->ls_state == SDQUOTE) {
-							statep->ls_sbquote.indquotes = 1;
+						if (s2->type == SDQUOTE) {
+							statep->ls_bool = true;
 							break;
 						}
 					}
 					if (s2 != base)
 						break;
-					if (!(s2 = s2->ls_info.base))
+					if (!(s2 = s2->ls_base))
 						break;
 					base = s2-- - STATE_BSIZE;
 				}
@@ -554,8 +575,8 @@
 				if ((c2 = unbksl(true, s_get, s_put)) == -1)
 					c2 = s_get();
 				if (c2 == 0)
-					statep->ls_sequote.got_NUL = true;
-				if (!statep->ls_sequote.got_NUL) {
+					statep->ls_bool = true;
+				if (!statep->ls_bool) {
 					char ts[4];
 
 					if ((unsigned int)c2 < 0x100) {
@@ -570,7 +591,7 @@
 						}
 					}
 				}
-			} else if (!statep->ls_sequote.got_NUL) {
+			} else if (!statep->ls_bool) {
 				*wp++ = QCHAR;
 				*wp++ = c;
 			}
@@ -595,107 +616,73 @@
 				goto Subst;
 			break;
 
-		case SCSPAREN:	/* $( ... ) */
-			/* todo: deal with $(...) quoting properly
-			 * kludge to partly fake quoting inside $(...): doesn't
-			 * really work because nested $(...) or ${...} inside
-			 * double quotes aren't dealt with.
-			 */
-			switch (statep->ls_scsparen.csstate) {
-			case 0:	/* normal */
-				switch (c) {
-				case '(':
-					statep->ls_scsparen.nparen++;
-					break;
-				case ')':
-					statep->ls_scsparen.nparen--;
-					break;
-				case '\\':
-					statep->ls_scsparen.csstate = 1;
-					break;
-				case '"':
-					statep->ls_scsparen.csstate = 2;
-					break;
-				case '\'':
-					statep->ls_scsparen.csstate = 4;
-					ignore_backslash_newline++;
-					break;
-				}
-				break;
-
-			case 1:	/* backslash in normal mode */
-			case 3:	/* backslash in double quotes */
-				--statep->ls_scsparen.csstate;
-				break;
-
-			case 2:	/* double quotes */
-				if (c == '"')
-					statep->ls_scsparen.csstate = 0;
-				else if (c == '\\')
-					statep->ls_scsparen.csstate = 3;
-				break;
-
-			case 4:	/* single quotes */
-				if (c == '\'') {
-					statep->ls_scsparen.csstate = 0;
-					ignore_backslash_newline--;
-				}
-				break;
-			}
-			if (statep->ls_scsparen.nparen == 0) {
-				POP_STATE();
-				*wp++ = 0;	/* end of COMSUB */
-			} else
-				*wp++ = c;
-			break;
-
-		case SASPAREN:	/* $(( ... )) */
-			/* XXX should nest using existing state machine
-			 * (embed "...", $(...), etc.) */
+		/* $(( ... )) */
+		case SASPAREN:
 			if (c == '(')
-				statep->ls_sasparen.nparen++;
+				statep->nparen++;
 			else if (c == ')') {
-				statep->ls_sasparen.nparen--;
-				if (statep->ls_sasparen.nparen == 1) {
-					/*(*/
-					if ((c2 = getsc()) == ')') {
-						POP_STATE();
-						/* end of EXPRSUB */
-						*wp++ = 0;
+				statep->nparen--;
+				if (statep->nparen == 1) {
+					/* end of EXPRSUB */
+					POP_SRETRACE();
+					POP_STATE();
+
+					if ((c2 = getsc()) == /*(*/ ')') {
+						c = strlen(sp) - 2;
+						XcheckN(ws, wp, c);
+						memcpy(wp, sp + 1, c);
+						wp += c;
+						afree(sp, ATEMP);
+						*wp++ = '\0';
 						break;
 					} else {
-						char *s;
+						Source *s;
 
 						ungetsc(c2);
-						/* mismatched parenthesis -
+						/*
+						 * mismatched parenthesis -
 						 * assume we were really
 						 * parsing a $(...) expression
 						 */
-						s = Xrestpos(ws, wp,
-						    statep->ls_sasparen.start);
-						memmove(s + 1, s, wp - s);
-						*s++ = COMSUB;
-						*s = '('; /*)*/
-						wp++;
-						statep->ls_scsparen.nparen = 1;
-						statep->ls_scsparen.csstate = 0;
-						state = statep->ls_state =
-						    SCSPAREN;
+						--wp;
+						s = pushs(SREREAD,
+						    source->areap);
+						s->start = s->str =
+						    s->u.freeme = sp;
+						s->next = source;
+						source = s;
+						goto subst_command;
 					}
 				}
 			}
-			*wp++ = c;
-			break;
+			/* reuse existing state machine */
+			goto Sbase2;
+
+		case SQBRACE:
+			if (c == '\\') {
+				/*
+				 * perform POSIX "quote removal" if the back-
+				 * slash is "special", i.e. same cases as the
+				 * {case '\\':} in Subst: plus closing brace;
+				 * in mksh code "quote removal" on '\c' means
+				 * write QCHAR+c, otherwise CHAR+\+CHAR+c are
+				 * emitted (in heredocquote:)
+				 */
+				if ((c = getsc()) == '"' || c == '\\' ||
+				    c == '$' || c == '`' || c == /*{*/'}')
+					goto store_qchar;
+				goto heredocquote;
+			}
+			goto common_SQBRACE;
 
 		case SBRACE:
 			if (c == '\'')
 				goto open_ssquote;
-			/* FALLTHROUGH */
-		case SQBRACE:
-			if (c == '"')
-				goto open_sdquote;
 			else if (c == '\\')
 				goto getsc_qchar;
+ common_SQBRACE:
+			if (c == '"')
+				goto open_sdquote;
 			else if (c == '$')
 				goto subst_dollar;
 			else if (c == '`')
@@ -708,9 +695,8 @@
 			break;
 
 		case STBRACE:
-			/* Same as SBRACE, except (,|,) treated specially */
-			/*{*/
-			if (c == '}') {
+			/* Same as SBASE, except (,|,) treated specially */
+			if (c == /*{*/ '}') {
 				POP_STATE();
 				*wp++ = CSUBST;
 				*wp++ = /*{*/ '}';
@@ -718,7 +704,8 @@
 				*wp++ = SPAT;
 			} else if (c == '(') {
 				*wp++ = OPAT;
-				*wp++ = ' ';	/* simile for @ */
+				/* simile for @ */
+				*wp++ = ' ';
 				PUSH_STATE(SPATTERN);
 			} else
 				goto Sbase1;
@@ -730,36 +717,37 @@
 				POP_STATE();
 			} else if (c == '\\') {
 				switch (c = getsc()) {
+				case 0:
+					/* trailing \ is lost */
+					break;
 				case '\\':
 				case '$': case '`':
 					*wp++ = c;
 					break;
 				case '"':
-					if (statep->ls_sbquote.indquotes) {
+					if (statep->ls_bool) {
 						*wp++ = c;
 						break;
 					}
 					/* FALLTHROUGH */
 				default:
-					if (c) {
-						/* trailing \ is lost */
-						*wp++ = '\\';
-						*wp++ = c;
-					}
+					*wp++ = '\\';
+					*wp++ = c;
 					break;
 				}
 			} else
 				*wp++ = c;
 			break;
 
-		case SWORD:	/* ONEWORD */
+		/* ONEWORD */
+		case SWORD:
 			goto Subst;
 
-		case SLETPAREN:	/* LETEXPR: (( ... )) */
-			/*(*/
-			if (c == ')') {
-				if (statep->ls_sletparen.nparen > 0)
-					--statep->ls_sletparen.nparen;
+		/* LETEXPR: (( ... )) */
+		case SLETPAREN:
+			if (c == /*(*/ ')') {
+				if (statep->nparen > 0)
+					--statep->nparen;
 				else if ((c2 = getsc()) == /*(*/ ')') {
 					c = 0;
 					*wp++ = CQUOTE;
@@ -768,13 +756,14 @@
 					Source *s;
 
 					ungetsc(c2);
-					/* mismatched parenthesis -
+					/*
+					 * mismatched parenthesis -
 					 * assume we were really
-					 * parsing a $(...) expression
+					 * parsing a (...) expression
 					 */
 					*wp = EOS;
 					sp = Xstring(ws, wp);
-					dp = wdstrip(sp, true, false);
+					dp = wdstrip(sp, WDS_KEEPQ);
 					s = pushs(SREREAD, source->areap);
 					s->start = s->str = s->u.freeme = dp;
 					s->next = source;
@@ -782,28 +771,40 @@
 					return ('('/*)*/);
 				}
 			} else if (c == '(')
-				/* parenthesis inside quotes and backslashes
-				 * are lost, but AT&T ksh doesn't count them
-				 * either
+				/*
+				 * parentheses inside quotes and
+				 * backslashes are lost, but AT&T ksh
+				 * doesn't count them either
 				 */
-				++statep->ls_sletparen.nparen;
+				++statep->nparen;
 			goto Sbase2;
 
 #ifndef MKSH_SMALL
-		case SLETARRAY:	/* LETARRAY: =( ... ) */
+		/* LETARRAY: =( ... ) */
+		case SLETARRAY:
 			if (c == '('/*)*/)
-				++statep->ls_sletarray.nparen;
-			else if (c == /*(*/')')
-				if (statep->ls_sletarray.nparen-- == 0) {
-					c = 0;
+				++statep->nparen;
+			else if (c == /*(*/')') {
+				if (statep->nparen-- == 0) {
+					POP_SRETRACE();
+					/* drop trailing paren */
+					c = strlen(dp = sp) - 1;
+					XcheckN(ws, wp, c * 2);
+					while (c--) {
+						*wp++ = CHAR;
+						*wp++ = *dp++;
+					}
+					afree(sp, ATEMP);
+					/* assert: c == 0 */
 					goto Done;
 				}
-			*wp++ = CHAR;
-			*wp++ = c;
-			break;
+			}
+			/* reuse existing state machine */
+			goto Sbase2;
 #endif
 
-		case SHERESTRING:	/* <<< delimiter */
+		/* <<< delimiter */
+		case SHERESTRING:
 			if (c == '\\') {
 				c = getsc();
 				if (c) {
@@ -811,14 +812,13 @@
 					*wp++ = QCHAR;
 					*wp++ = c;
 				}
-				/* invoke quoting mode */
-				Xstring(ws, wp)[0] = QCHAR;
 			} else if (c == '$') {
 				if ((c2 = getsc()) == '\'') {
 					PUSH_STATE(SEQUOTE);
-					statep->ls_sequote.got_NUL = false;
+					statep->ls_bool = false;
 					goto sherestring_quoted;
-				}
+				} else if (c2 == '"')
+					goto sherestring_dquoted;
 				ungetsc(c2);
 				goto sherestring_regular;
 			} else if (c == '\'') {
@@ -826,10 +826,9 @@
  sherestring_quoted:
 				*wp++ = OQUOTE;
 				ignore_backslash_newline++;
-				/* invoke quoting mode */
-				Xstring(ws, wp)[0] = QCHAR;
 			} else if (c == '"') {
-				state = statep->ls_state = SHEREDQUOTE;
+ sherestring_dquoted:
+				state = statep->type = SHEREDQUOTE;
 				*wp++ = OQUOTE;
 				/* just don't IFS split; no quoting mode */
 			} else {
@@ -839,13 +838,16 @@
 			}
 			break;
 
-		case SHEREDELIM:	/* <<,<<- delimiter */
-			/* XXX chuck this state (and the next) - use
+		/* <<,<<- delimiter */
+		case SHEREDELIM:
+			/*
+			 * XXX chuck this state (and the next) - use
 			 * the existing states ($ and \`...` should be
 			 * stripped of their specialness after the
 			 * fact).
 			 */
-			/* here delimiters need a special case since
+			/*
+			 * here delimiters need a special case since
 			 * $ and `...` are not to be treated specially
 			 */
 			if (c == '\\') {
@@ -858,9 +860,10 @@
 			} else if (c == '$') {
 				if ((c2 = getsc()) == '\'') {
 					PUSH_STATE(SEQUOTE);
-					statep->ls_sequote.got_NUL = false;
+					statep->ls_bool = false;
 					goto sheredelim_quoted;
-				}
+				} else if (c2 == '"')
+					goto sheredelim_dquoted;
 				ungetsc(c2);
 				goto sheredelim_regular;
 			} else if (c == '\'') {
@@ -869,7 +872,8 @@
 				*wp++ = OQUOTE;
 				ignore_backslash_newline++;
 			} else if (c == '"') {
-				state = statep->ls_state = SHEREDQUOTE;
+ sheredelim_dquoted:
+				state = statep->type = SHEREDQUOTE;
 				*wp++ = OQUOTE;
 			} else {
  sheredelim_regular:
@@ -878,25 +882,27 @@
 			}
 			break;
 
-		case SHEREDQUOTE:	/* " in <<,<<- delimiter */
+		/* " in <<,<<- delimiter */
+		case SHEREDQUOTE:
 			if (c == '"') {
 				*wp++ = CQUOTE;
-				state = statep->ls_state =
+				state = statep->type =
 				    /* dp[1] == '<' means here string */
 				    Xstring(ws, wp)[1] == '<' ?
 				    SHERESTRING : SHEREDELIM;
 			} else {
 				if (c == '\\') {
 					switch (c = getsc()) {
-					case '\\': case '"':
-					case '$': case '`':
+					case 0:
+						/* trailing \ is lost */
+					case '\\':
+					case '"':
+					case '$':
+					case '`':
 						break;
 					default:
-						if (c) {
-							/* trailing \ lost */
-							*wp++ = CHAR;
-							*wp++ = '\\';
-						}
+						*wp++ = CHAR;
+						*wp++ = '\\';
 						break;
 					}
 				}
@@ -905,15 +911,17 @@
 			}
 			break;
 
-		case SPATTERN:	/* in *(...|...) pattern (*+?@!) */
-			if ( /*(*/ c == ')') {
+		/* in *(...|...) pattern (*+?@!) */
+		case SPATTERN:
+			if (c == /*(*/ ')') {
 				*wp++ = CPAT;
 				POP_STATE();
 			} else if (c == '|') {
 				*wp++ = SPAT;
 			} else if (c == '(') {
 				*wp++ = OPAT;
-				*wp++ = ' ';	/* simile for @ */
+				/* simile for @ */
+				*wp++ = ' ';
 				PUSH_STATE(SPATTERN);
 			} else
 				goto Sbase1;
@@ -927,8 +935,8 @@
 		yyerror("no closing quote\n");
 
 #ifndef MKSH_SMALL
-	if (state == SLETARRAY && statep->ls_sletarray.nparen != -1)
-		yyerror("%s: ')' missing\n", T_synerr);
+	if (state == SLETARRAY && statep->nparen != -1)
+		yyerror("%s: %s\n", T_synerr, "missing )");
 #endif
 
 	/* This done to avoid tests for SHEREDELIM wherever SBASE tested */
@@ -968,10 +976,14 @@
 			iop->flag |= c == c2 ?
 			    (c == '>' ? IOCAT : IOHERE) : IORDWR;
 			if (iop->flag == IOHERE) {
-				if ((c2 = getsc()) == '-')
+				if ((c2 = getsc()) == '-') {
 					iop->flag |= IOSKIP;
-				else
-					ungetsc(c2);
+					c2 = getsc();
+				} else if (c2 == '<')
+					iop->flag |= IOHERESTR;
+				ungetsc(c2);
+				if (c2 == '\n')
+					iop->flag |= IONDELIM;
 			}
 		} else if (c2 == '&')
 			iop->flag |= IODUP | (c == '<' ? IORDUP : 0);
@@ -986,15 +998,17 @@
 		iop->name = NULL;
 		iop->delim = NULL;
 		iop->heredoc = NULL;
-		Xfree(ws, wp);	/* free word */
+		/* free word */
+		Xfree(ws, wp);
 		yylval.iop = iop;
 		return (REDIR);
  no_iop:
-		;
+		afree(iop, ATEMP);
 	}
 
 	if (wp == dp && state == SBASE) {
-		Xfree(ws, wp);	/* free word */
+		/* free word */
+		Xfree(ws, wp);
 		/* no word, process LEX1 character */
 		if ((c == '|') || (c == '&') || (c == ';') || (c == '('/*)*/)) {
 			if ((c2 = getsc()) == c)
@@ -1016,7 +1030,8 @@
 		return (c);
 	}
 
-	*wp++ = EOS;		/* terminate word */
+	/* terminate word */
+	*wp++ = EOS;
 	yylval.cp = Xclose(ws, wp);
 	if (state == SWORD || state == SLETPAREN
 	    /* XXX ONEWORD? */
@@ -1051,15 +1066,16 @@
 	/* Make sure the ident array stays '\0' padded */
 	memset(dp, 0, (ident+IDENT) - dp + 1);
 	if (c != EOS)
-		*ident = '\0';	/* word is not unquoted */
+		/* word is not unquoted */
+		*ident = '\0';
 
-	if (*ident != '\0' && (cf&(KEYWORD|ALIAS))) {
+	if (*ident != '\0' && (cf & (KEYWORD | ALIAS))) {
 		struct tbl *p;
 		uint32_t h = hash(ident);
 
-		/* { */
 		if ((cf & KEYWORD) && (p = ktsearch(&keywords, ident, h)) &&
-		    (!(cf & ESACONLY) || p->val.i == ESAC || p->val.i == '}')) {
+		    (!(cf & ESACONLY) || p->val.i == ESAC ||
+		    p->val.i == /*{*/ '}')) {
 			afree(yylval.cp, ATEMP);
 			return (p->val.i);
 		}
@@ -1085,16 +1101,10 @@
 				 */
 				++cp;
 			/* prefer functions over aliases */
-			if (*cp == '(' /*)*/)
-				/*
-				 * delete alias upon encountering function
-				 * definition
-				 */
-				ktdelete(p);
-			else {
+			if (cp[0] != '(' || cp[1] != ')') {
 				Source *s = source;
 
-				while (s->flags & SF_HASALIAS)
+				while (s && (s->flags & SF_HASALIAS))
 					if (s->u.tblp == p)
 						return (LWORD);
 					else
@@ -1126,7 +1136,7 @@
 	struct ioword **p;
 
 	for (p = heres; p < herep; p++)
-		if (iseof && (*p)->delim[1] != '<')
+		if (iseof && !((*p)->flag & IOHERESTR))
 			/* only here strings at EOF */
 			return;
 		else
@@ -1142,62 +1152,90 @@
 readhere(struct ioword *iop)
 {
 	int c;
-	char *volatile eof;
-	char *eofp;
-	int skiptabs;
+	const char *eof, *eofp;
 	XString xs;
 	char *xp;
 	int xpos;
 
-	if (iop->delim[1] == '<') {
+	if (iop->flag & IOHERESTR) {
 		/* process the here string */
-		xp = iop->heredoc = evalstr(iop->delim, DOBLANK);
+		iop->heredoc = xp = evalstr(iop->delim, DOBLANK);
 		c = strlen(xp) - 1;
 		memmove(xp, xp + 1, c);
 		xp[c] = '\n';
 		return;
 	}
 
-	eof = evalstr(iop->delim, 0);
+	eof = iop->flag & IONDELIM ? "<<" : evalstr(iop->delim, 0);
 
 	if (!(iop->flag & IOEVAL))
 		ignore_backslash_newline++;
 
 	Xinit(xs, xp, 256, ATEMP);
 
-	for (;;) {
-		eofp = eof;
-		skiptabs = iop->flag & IOSKIP;
-		xpos = Xsavepos(xs, xp);
-		while ((c = getsc()) != 0) {
-			if (skiptabs) {
-				if (c == '\t')
-					continue;
-				skiptabs = 0;
-			}
-			if (c != *eofp)
+ heredoc_read_line:
+	/* beginning of line */
+	eofp = eof;
+	xpos = Xsavepos(xs, xp);
+	if (iop->flag & IOSKIP) {
+		/* skip over leading tabs */
+		while ((c = getsc()) == '\t')
+			/* nothing */;
+		goto heredoc_parse_char;
+	}
+ heredoc_read_char:
+	c = getsc();
+ heredoc_parse_char:
+	/* compare with here document marker */
+	if (!*eofp) {
+		/* end of here document marker, what to do? */
+		switch (c) {
+		case /*(*/ ')':
+			if (!subshell_nesting_level)
+				/*-
+				 * not allowed outside $(...) or (...)
+				 * => mismatch
+				 */
 				break;
-			Xcheck(xs, xp);
-			Xput(xs, xp, c);
-			eofp++;
-		}
-		/* Allow EOF here so commands with out trailing newlines
-		 * will work (eg, ksh -c '...', $(...), etc).
-		 */
-		if (*eofp == '\0' && (c == 0 || c == '\n')) {
-			xp = Xrestpos(xs, xp, xpos);
-			break;
-		}
-		ungetsc(c);
-		while ((c = getsc()) != '\n') {
-			if (c == 0)
-				yyerror("here document '%s' unclosed\n", eof);
-			Xcheck(xs, xp);
-			Xput(xs, xp, c);
+			/* allow $(...) or (...) to close here */
+			ungetsc(/*(*/ ')');
+			/* FALLTHROUGH */
+		case 0:
+			/*
+			 * Allow EOF here to commands without trailing
+			 * newlines (mksh -c '...') will work as well.
+			 */
+		case '\n':
+			/* Newline terminates here document marker */
+			goto heredoc_found_terminator;
 		}
+	} else if (c == *eofp++)
+		/* store; then read and compare next character */
+		goto heredoc_store_and_loop;
+	/* nope, mismatch; read until end of line */
+	while (c != '\n') {
+		if (!c)
+			/* oops, reached EOF */
+			yyerror("%s '%s' unclosed\n", "here document", eof);
+		/* store character */
 		Xcheck(xs, xp);
 		Xput(xs, xp, c);
+		/* read next character */
+		c = getsc();
 	}
+	/* we read a newline as last character */
+ heredoc_store_and_loop:
+	/* store character */
+	Xcheck(xs, xp);
+	Xput(xs, xp, c);
+	if (c == '\n')
+		goto heredoc_read_line;
+	goto heredoc_read_char;
+
+ heredoc_found_terminator:
+	/* jump back to saved beginning of line */
+	xp = Xrestpos(xs, xp, xpos);
+	/* terminate, close and store */
 	Xput(xs, xp, '\0');
 	iop->heredoc = Xclose(xs, xp);
 
@@ -1213,7 +1251,8 @@
 	/* pop aliases and re-reads */
 	while (source->type == SALIAS || source->type == SREREAD)
 		source = source->next;
-	source->str = null;	/* zap pending input */
+	/* zap pending input */
+	source->str = null;
 
 	error_prefix(true);
 	va_start(va, fmt);
@@ -1232,19 +1271,12 @@
 	Source *s;
 
 	s = alloc(sizeof(Source), areap);
+	memset(s, 0, sizeof(Source));
 	s->type = type;
 	s->str = null;
-	s->start = NULL;
-	s->line = 0;
-	s->errline = 0;
-	s->file = NULL;
-	s->flags = 0;
-	s->next = NULL;
 	s->areap = areap;
 	if (type == SFILE || type == SSTDIN)
 		XinitN(s->xs, 256, s->areap);
-	else
-		memset(&s->xs, 0, sizeof(s->xs));
 	return (s);
 }
 
@@ -1254,9 +1286,9 @@
 	Source *s = source;
 	int c;
 
- getsc_again:
 	while ((c = *s->str++) == 0) {
-		s->str = NULL;		/* return 0 for EOF by default */
+		/* return 0 for EOF by default */
+		s->str = NULL;
 		switch (s->type) {
 		case SEOF:
 			s->str = null;
@@ -1296,23 +1328,26 @@
 				s = source;
 			} else if (*s->u.tblp->val.s &&
 			    (c = strnul(s->u.tblp->val.s)[-1], ksh_isspace(c))) {
-				source = s = s->next;	/* pop source stack */
-				/* Note that this alias ended with a space,
-				 * enabling alias expansion on the following
-				 * word.
+				/* pop source stack */
+				source = s = s->next;
+				/*
+				 * Note that this alias ended with a
+				 * space, enabling alias expansion on
+				 * the following word.
 				 */
 				s->flags |= SF_ALIAS;
 			} else {
-				/* At this point, we need to keep the current
+				/*
+				 * At this point, we need to keep the current
 				 * alias in the source list so recursive
-				 * aliases can be detected and we also need
-				 * to return the next character. Do this
-				 * by temporarily popping the alias to get
-				 * the next character and then put it back
-				 * in the source list with the SF_ALIASEND
-				 * flag set.
+				 * aliases can be detected and we also need to
+				 * return the next character. Do this by
+				 * temporarily popping the alias to get the
+				 * next character and then put it back in the
+				 * source list with the SF_ALIASEND flag set.
 				 */
-				source = s->next;	/* pop source stack */
+				/* pop source stack */
+				source = s->next;
 				source->flags |= s->flags & SF_ALIAS;
 				c = getsc__();
 				if (c) {
@@ -1323,7 +1358,7 @@
 					source = s;
 				} else {
 					s = source;
-					/* avoid reading eof twice */
+					/* avoid reading EOF twice */
 					s->str = NULL;
 					break;
 				}
@@ -1331,7 +1366,8 @@
 			continue;
 
 		case SREREAD:
-			if (s->start != s->ugbuf)	/* yuck */
+			if (s->start != s->ugbuf)
+				/* yuck */
 				afree(s->u.freeme, ATEMP);
 			source = s = s->next;
 			continue;
@@ -1346,17 +1382,6 @@
 			shf_flush(shl_out);
 		}
 	}
-	/* check for UTF-8 byte order mark */
-	if (s->flags & SF_FIRST) {
-		s->flags &= ~SF_FIRST;
-		if (((unsigned char)c == 0xEF) &&
-		    (((const unsigned char *)(s->str))[0] == 0xBB) &&
-		    (((const unsigned char *)(s->str))[1] == 0xBF)) {
-			s->str += 2;
-			UTFMODE = 1;
-			goto getsc_again;
-		}
-	}
 	return (c);
 }
 
@@ -1376,6 +1401,8 @@
 		ksh_tmout_state = TMOUT_READING;
 		alarm(ksh_tmout);
 	}
+	if (interactive)
+		change_winsz();
 	if (have_tty && (
 #if !MKSH_S_NOVI
 	    Flag(FVI) ||
@@ -1384,17 +1411,18 @@
 		int nread;
 
 		nread = x_read(xp, LINE);
-		if (nread < 0)	/* read error */
+		if (nread < 0)
+			/* read error */
 			nread = 0;
 		xp[nread] = '\0';
 		xp += nread;
 	} else {
-		if (interactive) {
+		if (interactive)
 			pprompt(prompt, 0);
-		} else
+		else
 			s->line++;
 
-		while (1) {
+		while (/* CONSTCOND */ 1) {
 			char *p = shf_getse(xp, Xnleft(s->xs, xp), s->u.shf);
 
 			if (!p && shf_error(s->u.shf) &&
@@ -1407,20 +1435,24 @@
 			if (!p || (xp = p, xp[-1] == '\n'))
 				break;
 			/* double buffer size */
-			xp++;	/* move past NUL so doubling works... */
+			/* move past NUL so doubling works... */
+			xp++;
 			XcheckN(s->xs, xp, Xlength(s->xs, xp));
-			xp--;	/* ...and move back again */
+			/* ...and move back again */
+			xp--;
 		}
-		/* flush any unwanted input so other programs/builtins
+		/*
+		 * flush any unwanted input so other programs/builtins
 		 * can read it. Not very optimal, but less error prone
 		 * than flushing else where, dealing with redirections,
 		 * etc.
-		 * todo: reduce size of shf buffer (~128?) if SSTDIN
+		 * TODO: reduce size of shf buffer (~128?) if SSTDIN
 		 */
 		if (s->type == SSTDIN)
 			shf_flush(s->u.shf);
 	}
-	/* XXX: temporary kludge to restore source after a
+	/*
+	 * XXX: temporary kludge to restore source after a
 	 * trap may have been executed.
 	 */
 	source = s;
@@ -1434,7 +1466,7 @@
 		int linelen;
 
 		linelen = Xlength(s->xs, xp);
-		XcheckN(s->xs, xp, fc_e_n + /* NUL */ 1);
+		XcheckN(s->xs, xp, Tn_fc_e_ + /* NUL */ 1);
 		/* reload after potential realloc */
 		cp = Xstring(s->xs, xp);
 		/* change initial '!' into space */
@@ -1442,10 +1474,10 @@
 		/* NUL terminate the current string */
 		*xp = '\0';
 		/* move the actual string forward */
-		memmove(cp + fc_e_n, cp, linelen + /* NUL */ 1);
-		xp += fc_e_n;
+		memmove(cp + Tn_fc_e_, cp, linelen + /* NUL */ 1);
+		xp += Tn_fc_e_;
 		/* prepend it with "fc -e -" */
-		memcpy(cp, fc_e_, fc_e_n);
+		memcpy(cp, T_fc_e_, Tn_fc_e_);
 	}
 #endif
 	s->start = s->str = cp;
@@ -1478,8 +1510,10 @@
 	cur_prompt = to;
 
 	switch (to) {
-	case PS1:	/* command */
-		/* Substitute ! and !! here, before substitutions are done
+	/* command */
+	case PS1:
+		/*
+		 * Substitute ! and !! here, before substitutions are done
 		 * so ! in expanded variables are not expanded.
 		 * NOTE: this is not what AT&T ksh does (it does it after
 		 * substitutions, POSIX doesn't say which is to be done.
@@ -1503,7 +1537,8 @@
 			newenv(E_ERRH);
 			if (sigsetjmp(e->jbuf, 0)) {
 				prompt = safe_prompt;
-				/* Don't print an error - assume it has already
+				/*
+				 * Don't print an error - assume it has already
 				 * been printed. Reason is we may have forked
 				 * to run a command and the child may be
 				 * unwinding its stack through this code as it
@@ -1516,7 +1551,8 @@
 			quitenv(NULL);
 		}
 		break;
-	case PS2:	/* command continuation */
+	/* command continuation */
+	case PS2:
 		prompt = str_val(global("PS2"));
 		break;
 	}
@@ -1528,11 +1564,12 @@
 	int columns = 0, lines = 0, indelimit = 0;
 	char delimiter = 0;
 
-	/* Undocumented AT&T ksh feature:
-	 * If the second char in the prompt string is \r then the first char
-	 * is taken to be a non-printing delimiter and any chars between two
-	 * instances of the delimiter are not considered to be part of the
-	 * prompt length
+	/*
+	 * Undocumented AT&T ksh feature:
+	 * If the second char in the prompt string is \r then the first
+	 * char is taken to be a non-printing delimiter and any chars
+	 * between two instances of the delimiter are not considered to
+	 * be part of the prompt length
 	 */
 	if (*cp && cp[1] == '\r') {
 		delimiter = *cp;
@@ -1583,20 +1620,20 @@
 	return (dopprompt(cp, 0, false));
 }
 
-/* Read the variable part of a ${...} expression (ie, up to but not including
- * the :[-+?=#%] or close-brace.
+/*
+ * Read the variable part of a ${...} expression (i.e. up to but not
+ * including the :[-+?=#%] or close-brace).
  */
 static char *
 get_brace_var(XString *wsp, char *wp)
 {
+	char c;
 	enum parse_state {
 		PS_INITIAL, PS_SAW_HASH, PS_IDENT,
 		PS_NUMBER, PS_VAR1
-	} state;
-	char c;
+	} state = PS_INITIAL;
 
-	state = PS_INITIAL;
-	while (1) {
+	while (/* CONSTCOND */ 1) {
 		c = getsc();
 		/* State machine to figure out where the variable part ends. */
 		switch (state) {
@@ -1611,7 +1648,19 @@
 				state = PS_IDENT;
 			else if (ksh_isdigit(c))
 				state = PS_NUMBER;
-			else if (ctype(c, C_VAR1))
+			else if (c == '#') {
+				if (state == PS_SAW_HASH) {
+					char c2;
+
+					c2 = getsc();
+					ungetsc(c2);
+					if (c2 != '}') {
+						ungetsc(c);
+						goto out;
+					}
+				}
+				state = PS_VAR1;
+			} else if (ctype(c, C_VAR1))
 				state = PS_VAR1;
 			else
 				goto out;
@@ -1629,7 +1678,8 @@
 						*wp++ = *p++;
 					}
 					afree(tmp, ATEMP);
-					c = getsc();	/* the ] */
+					/* the ] */
+					c = getsc();
 				}
 				goto out;
 			}
@@ -1645,7 +1695,8 @@
 		*wp++ = c;
 	}
  out:
-	*wp++ = '\0';	/* end of variable part */
+	/* end of variable part */
+	*wp++ = '\0';
 	ungetsc(c);
 	return (wp);
 }
@@ -1655,13 +1706,13 @@
  * if eof or newline was found.
  * (Returned string double null terminated)
  */
-static int
+static bool
 arraysub(char **strp)
 {
 	XString ws;
-	char	*wp;
-	char	c;
-	int	depth = 1;	/* we are just past the initial [ */
+	char *wp, c;
+	/* we are just past the initial [ */
+	int depth = 1;
 
 	Xinit(ws, wp, 32, ATEMP);
 
@@ -1678,18 +1729,30 @@
 	*wp++ = '\0';
 	*strp = Xclose(ws, wp);
 
-	return (depth == 0 ? 1 : 0);
+	return (tobool(depth == 0));
 }
 
 /* Unget a char: handles case when we are already at the start of the buffer */
-static const char *
+static void
 ungetsc(int c)
 {
+	struct sretrace_info *rp = retrace_info;
+
 	if (backslash_skip)
 		backslash_skip--;
-	/* Don't unget eof... */
+	/* Don't unget EOF... */
 	if (source->str == null && c == '\0')
-		return (source->str);
+		return;
+	while (rp) {
+		if (Xlength(rp->xs, rp->xp))
+			rp->xp--;
+		rp = rp->next;
+	}
+	ungetsc_(c);
+}
+static void
+ungetsc_(int c)
+{
 	if (source->str > source->start)
 		source->str--;
 	else {
@@ -1701,7 +1764,6 @@
 		s->next = source;
 		source = s;
 	}
-	return (source->str);
 }
 
 
@@ -1712,37 +1774,60 @@
 	int c, c2;
 
 	if (ignore_backslash_newline)
-		return (getsc_());
+		return (_getsc_());
 
 	if (backslash_skip == 1) {
 		backslash_skip = 2;
-		return (getsc_());
+		return (_getsc_());
 	}
 
 	backslash_skip = 0;
 
-	while (1) {
-		c = getsc_();
+	while (/* CONSTCOND */ 1) {
+		c = _getsc_();
 		if (c == '\\') {
-			if ((c2 = getsc_()) == '\n')
+			if ((c2 = _getsc_()) == '\n')
 				/* ignore the \newline; get the next char... */
 				continue;
-			ungetsc(c2);
+			ungetsc_(c2);
 			backslash_skip = 1;
 		}
 		return (c);
 	}
 }
 
+void
+yyskiputf8bom(void)
+{
+	int c;
+
+	if ((unsigned char)(c = _getsc_()) != 0xEF) {
+		ungetsc_(c);
+		return;
+	}
+	if ((unsigned char)(c = _getsc_()) != 0xBB) {
+		ungetsc_(c);
+		ungetsc_(0xEF);
+		return;
+	}
+	if ((unsigned char)(c = _getsc_()) != 0xBF) {
+		ungetsc_(c);
+		ungetsc_(0xBB);
+		ungetsc_(0xEF);
+		return;
+	}
+	UTFMODE |= 8;
+}
+
 static Lex_state *
 push_state_(State_info *si, Lex_state *old_end)
 {
-	Lex_state *new = alloc(STATE_BSIZE * sizeof(Lex_state), ATEMP);
+	Lex_state *news = alloc2(STATE_BSIZE, sizeof(Lex_state), ATEMP);
 
-	new[0].ls_info.base = old_end;
-	si->base = &new[0];
-	si->end = &new[STATE_BSIZE];
-	return (&new[1]);
+	news[0].ls_base = old_end;
+	si->base = &news[0];
+	si->end = &news[STATE_BSIZE];
+	return (&news[1]);
 }
 
 static Lex_state *
@@ -1750,8 +1835,8 @@
 {
 	Lex_state *old_base = si->base;
 
-	si->base = old_end->ls_info.base - STATE_BSIZE;
-	si->end = old_end->ls_info.base;
+	si->base = old_end->ls_base - STATE_BSIZE;
+	si->end = old_end->ls_base;
 
 	afree(old_base, ATEMP);
 
Index: src/bin/mksh/main.c
diff -u src/bin/mksh/main.c:1.162 src/bin/mksh/main.c:1.190
--- src/bin/mksh/main.c:1.162	Fri Jan 29 09:34:29 2010
+++ src/bin/mksh/main.c	Sun Apr 17 12:24:43 2011
@@ -1,10 +1,10 @@
-/*	$OpenBSD: main.c,v 1.45 2009/01/29 23:27:26 jaredy Exp $	*/
+/*	$OpenBSD: main.c,v 1.46 2010/05/19 17:36:08 jasper Exp $	*/
 /*	$OpenBSD: tty.c,v 1.9 2006/03/14 22:08:01 deraadt Exp $	*/
 /*	$OpenBSD: io.c,v 1.22 2006/03/17 16:30:13 millert Exp $	*/
 /*	$OpenBSD: table.c,v 1.13 2009/01/17 22:06:44 millert Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -33,19 +33,25 @@
 #include <locale.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/main.c,v 1.162 2010/01/29 09:34:29 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/main.c,v 1.190 2011/04/17 12:24:43 tg Exp $");
 
 extern char **environ;
 
-#if !HAVE_SETRESUGID
-extern uid_t kshuid;
-extern gid_t kshgid, kshegid;
+#ifndef MKSHRC_PATH
+#define MKSHRC_PATH	"~/.mkshrc"
 #endif
 
+#ifndef MKSH_DEFAULT_TMPDIR
+#define MKSH_DEFAULT_TMPDIR	"/tmp"
+#endif
+
+void chvt_reinit(void);
 static void reclaim(void);
 static void remove_temps(struct temp *);
-void chvt_reinit(void);
-Source *mksh_init(int, const char *[]);
+static mksh_uari_t rndsetup(void);
+#ifdef SIGWINCH
+static void x_sigwinch(int);
+#endif
 
 static const char initifs[] = "IFS= \t\n";
 
@@ -55,14 +61,18 @@
 static const char *initcoms[] = {
 	T_typeset, "-r", initvsn, NULL,
 	T_typeset, "-x", "HOME", "PATH", "RANDOM", "SHELL", NULL,
-	T_typeset, "-i10", "COLUMNS", "LINES", "OPTIND", "PGRP", "PPID",
-	    "RANDOM", "SECONDS", "TMOUT", "USER_ID", NULL,
-	"alias",
+	T_typeset, "-i10", "COLUMNS", "KSHEGID", "KSHGID", "KSHUID", "LINES",
+	    "OPTIND", "PGRP", "PPID", "RANDOM", "SECONDS", "TMOUT", "USER_ID",
+	    NULL,
+	T_alias,
 	"integer=typeset -i",
 	T_local_typeset,
-	"hash=alias -t",	/* not "alias -t --": hash -r needs to work */
+	/* not "alias -t --": hash -r needs to work */
+	"hash=alias -t",
 	"type=whence -v",
-#ifndef MKSH_UNEMPLOYED
+#if !defined(ANDROID) && !defined(MKSH_UNEMPLOYED)
+	/* not in Android for political reasons */
+	/* not in ARGE mksh due to no job control */
 	"stop=kill -STOP",
 	"suspend=kill -STOP $$",
 #endif
@@ -71,12 +81,12 @@
 	"history=fc -l",
 	"nameref=typeset -n",
 	"nohup=nohup ",
-	r_fc_e_,
+	T_r_fc_e_,
 	"source=PATH=$PATH:. command .",
 	"login=exec login",
 	NULL,
 	 /* this is what AT&T ksh seems to track, with the addition of emacs */
-	"alias", "-tU",
+	T_alias, "-tU",
 	"cat", "cc", "chmod", "cp", "date", "ed", "emacs", "grep", "ls",
 	"make", "mv", "pr", "rm", "sed", "sh", "vi", "who", NULL,
 	NULL
@@ -84,9 +94,52 @@
 
 static int initio_done;
 
+/* top-level parsing and execution environment */
 static struct env env;
 struct env *e = &env;
 
+static mksh_uari_t
+rndsetup(void)
+{
+	register uint32_t h;
+	struct {
+		ALLOC_ITEM __alloc_i;
+		void *dataptr, *stkptr, *mallocptr;
+		sigjmp_buf jbuf;
+		struct timeval tv;
+		struct timezone tz;
+	} *bufptr;
+	char *cp;
+
+	cp = alloc(sizeof(*bufptr) - ALLOC_SIZE, APERM);
+#ifdef DEBUG
+	/* clear the allocated space, for valgrind */
+	memset(cp, 0, sizeof(*bufptr) - ALLOC_SIZE);
+#endif
+	/* undo what alloc() did to the malloc result address */
+	bufptr = (void *)(cp - ALLOC_SIZE);
+	/* PIE or something similar provides us with deltas here */
+	bufptr->dataptr = &rndsetupstate;
+	/* ASLR in at least Windows, Linux, some BSDs */
+	bufptr->stkptr = &bufptr;
+	/* randomised malloc in BSD (and possibly others) */
+	bufptr->mallocptr = bufptr;
+	/* glibc pointer guard */
+	sigsetjmp(bufptr->jbuf, 1);
+	/* introduce variation */
+	gettimeofday(&bufptr->tv, &bufptr->tz);
+
+	oaat1_init_impl(h);
+	/* variation through pid, ppid, and the works */
+	oaat1_addmem_impl(h, &rndsetupstate, sizeof(rndsetupstate));
+	/* some variation, some possibly entropy, depending on OE */
+	oaat1_addmem_impl(h, bufptr, sizeof(*bufptr));
+	oaat1_fini_impl(h);
+
+	afree(cp, APERM);
+	return ((mksh_uari_t)h);
+}
+
 void
 chvt_reinit(void)
 {
@@ -94,25 +147,25 @@
 	ksheuid = geteuid();
 	kshpgrp = getpgrp();
 	kshppid = getppid();
-
-#if !HAVE_ARC4RANDOM
-	change_random(&kshstate_, sizeof(kshstate_));
-#endif
 }
 
-Source *
-mksh_init(int argc, const char *argv[])
+static const char *empty_argv[] = {
+	"mksh", NULL
+};
+
+int
+main(int argc, const char *argv[])
 {
 	int argi, i;
-	Source *s;
+	Source *s = NULL;
 	struct block *l;
 	unsigned char restricted, errexit, utf_flag;
-	const char **wp;
+	char *cp;
+	const char *ccp, **wp;
 	struct tbl *vp;
 	struct stat s_stdin;
 #if !defined(_PATH_DEFPATH) && defined(_CS_PATH)
-	size_t k;
-	char *cp;
+	ssize_t k;
 #endif
 
 	/* do things like getpgrp() et al. */
@@ -120,28 +173,58 @@
 
 	/* make sure argv[] is sane */
 	if (!*argv) {
-		static const char *empty_argv[] = {
-			"mksh", NULL
-		};
-
 		argv = empty_argv;
 		argc = 1;
 	}
-	kshname = *argv;
+	kshname = argv[0];
 
-	ainit(&aperm);		/* initialise permanent Area */
+	/* initialise permanent Area */
+	ainit(&aperm);
 
 	/* set up base environment */
 	env.type = E_NONE;
 	ainit(&env.area);
-	newblock();		/* set up global l->vars and l->funs */
+	/* set up global l->vars and l->funs */
+	newblock();
 
 	/* Do this first so output routines (eg, errorf, shellf) can work */
 	initio();
 
-	argi = parse_args(argv, OF_FIRSTTIME, NULL);
-	if (argi < 0)
-		return (NULL);
+	/* determine the basename (without '-' or path) of the executable */
+	ccp = kshname;
+	goto begin_parse_kshname;
+	while ((i = ccp[argi++])) {
+		if (i == '/') {
+			ccp += argi;
+ begin_parse_kshname:
+			argi = 0;
+			if (*ccp == '-')
+				++ccp;
+		}
+	}
+	if (!*ccp)
+		ccp = empty_argv[0];
+
+	/* define built-in commands and see if we were called as one */
+	ktinit(&builtins, APERM,
+	    /* must be 80% of 2^n (currently 44 builtins) */ 64);
+	for (i = 0; mkshbuiltins[i].name != NULL; i++)
+		if (!strcmp(ccp, builtin(mkshbuiltins[i].name,
+		    mkshbuiltins[i].func)))
+			Flag(FAS_BUILTIN) = 1;
+
+	if (!Flag(FAS_BUILTIN)) {
+		/* check for -T option early */
+		argi = parse_args(argv, OF_FIRSTTIME, NULL);
+		if (argi < 0)
+			return (1);
+
+#ifdef MKSH_BINSHREDUCED
+		/* set FSH if we're called as -sh or /bin/sh or so */
+		if (!strcmp(ccp, "sh"))
+			change_flag(FSH, OF_FIRSTTIME, 1);
+#endif
+	}
 
 	initvar();
 
@@ -161,19 +244,13 @@
 	/* define shell keywords */
 	initkeywords();
 
-	/* define built-in commands */
-	ktinit(&builtins, APERM,
-	    /* must be 80% of 2^n (currently 44 builtins) */ 64);
-	for (i = 0; mkshbuiltins[i].name != NULL; i++)
-		builtin(mkshbuiltins[i].name, mkshbuiltins[i].func);
-
 	init_histvec();
 
 #ifdef _PATH_DEFPATH
 	def_path = _PATH_DEFPATH;
 #else
 #ifdef _CS_PATH
-	if ((k = confstr(_CS_PATH, NULL, 0)) != (size_t)-1 && k > 0 &&
+	if ((k = confstr(_CS_PATH, NULL, 0)) > 0 &&
 	    confstr(_CS_PATH, cp = alloc(k + 1, APERM), k + 1) == k + 1)
 		def_path = cp;
 	else
@@ -189,82 +266,61 @@
 		def_path = "/bin:/usr/bin:/sbin:/usr/sbin";
 #endif
 
-	/* Set PATH to def_path (will set the path global variable).
+	/*
+	 * Set PATH to def_path (will set the path global variable).
 	 * (import of environment below will probably change this setting).
 	 */
 	vp = global("PATH");
 	/* setstr can't fail here */
 	setstr(vp, def_path, KSH_RETURN_ERROR);
 
-	/* Turn on nohup by default for now - will change to off
+	/*
+	 * Turn on nohup by default for now - will change to off
 	 * by default once people are aware of its existence
 	 * (AT&T ksh does not have a nohup option - it always sends
 	 * the hup).
 	 */
 	Flag(FNOHUP) = 1;
 
-	/* Turn on brace expansion by default. AT&T kshs that have
+	/*
+	 * Turn on brace expansion by default. AT&T kshs that have
 	 * alternation always have it on.
 	 */
 	Flag(FBRACEEXPAND) = 1;
 
-	/* Set edit mode to emacs by default, may be overridden
+	/*
+	 * Set edit mode to emacs by default, may be overridden
 	 * by the environment or the user. Also, we want tab completion
-	 * on in vi by default. */
+	 * on in vi by default.
+	 */
 	change_flag(FEMACS, OF_SPECIAL, 1);
 #if !MKSH_S_NOVI
 	Flag(FVITABCOMPLETE) = 1;
 #endif
 
-#ifdef MKSH_BINSHREDUCED
-	/* set FSH if we're called as -sh or /bin/sh or so */
-	{
-		const char *cc;
-
-		cc = kshname;
-		i = 0; argi = 0;
-		while (cc[i] != '\0')
-			/* the following line matches '-' and '/' ;-) */
-			if ((cc[i++] | 2) == '/')
-				argi = i;
-		if (((cc[argi] | 0x20) == 's') && ((cc[argi + 1] | 0x20) == 'h'))
-			change_flag(FSH, OF_FIRSTTIME, 1);
-	}
-#endif
-
 	/* import environment */
 	if (environ != NULL)
 		for (wp = (const char **)environ; *wp != NULL; wp++)
 			typeset(*wp, IMPORT | EXPORT, 0, 0, 0);
 
-	typeset(initifs, 0, 0, 0, 0);	/* for security */
+	/* for security */
+	typeset(initifs, 0, 0, 0, 0);
 
 	/* assign default shell variable values */
 	substitute(initsubs, 0);
 
 	/* Figure out the current working directory and set $PWD */
-	{
-		struct stat s_pwd, s_dot;
-		struct tbl *pwd_v = global("PWD");
-		char *pwd = str_val(pwd_v);
-		char *pwdx = pwd;
-
-		/* Try to use existing $PWD if it is valid */
-		if (pwd[0] != '/' ||
-		    stat(pwd, &s_pwd) < 0 || stat(".", &s_dot) < 0 ||
-		    s_pwd.st_dev != s_dot.st_dev ||
-		    s_pwd.st_ino != s_dot.st_ino)
-			pwdx = NULL;
-		set_current_wd(pwdx);
-		if (current_wd[0])
-			simplify_path(current_wd);
-		/* Only set pwd if we know where we are or if it had a
-		 * bogus value
-		 */
-		if (current_wd[0] || pwd != null)
-			/* setstr can't fail here */
-			setstr(pwd_v, current_wd, KSH_RETURN_ERROR);
-	}
+	vp = global("PWD");
+	cp = str_val(vp);
+	/* Try to use existing $PWD if it is valid */
+	set_current_wd((cp[0] == '/' && test_eval(NULL, TO_FILEQ, cp, ".",
+	    true)) ? cp : NULL);
+	if (current_wd[0])
+		simplify_path(current_wd);
+	/* Only set pwd if we know where we are or if it had a bogus value */
+	if (current_wd[0] || *cp)
+		/* setstr can't fail here */
+		setstr(vp, current_wd, KSH_RETURN_ERROR);
 
 	for (wp = initcoms; *wp != NULL; wp++) {
 		shcomexec(wp);
@@ -275,6 +331,10 @@
 	setint(global("LINES"), 0);
 	setint(global("OPTIND"), 1);
 
+	kshuid = getuid();
+	kshgid = getgid();
+	kshegid = getegid();
+
 	safe_prompt = ksheuid ? "$ " : "# ";
 	vp = global("PS1");
 	/* Set PS1 if unset or we are root and prompt doesn't contain a # */
@@ -286,21 +346,20 @@
 	vp->flag |= INT_U;
 	setint((vp = global("PPID")), (mksh_uari_t)kshppid);
 	vp->flag |= INT_U;
-	setint((vp = global("RANDOM")), (mksh_uari_t)hash(kshname));
-	vp->flag |= INT_U;
 	setint((vp = global("USER_ID")), (mksh_uari_t)ksheuid);
 	vp->flag |= INT_U;
-#if HAVE_ARC4RANDOM
-	Flag(FARC4RANDOM) = 1;		/* initialised */
-#endif
+	setint((vp = global("KSHUID")), (mksh_uari_t)kshuid);
+	vp->flag |= INT_U;
+	setint((vp = global("KSHEGID")), (mksh_uari_t)kshegid);
+	vp->flag |= INT_U;
+	setint((vp = global("KSHGID")), (mksh_uari_t)kshgid);
+	vp->flag |= INT_U;
+	setint((vp = global("RANDOM")), rndsetup());
+	vp->flag |= INT_U;
+	setint((vp_pipest = global("PIPESTATUS")), 0);
 
 	/* Set this before parsing arguments */
-#if HAVE_SETRESUGID
-	Flag(FPRIVILEGED) = getuid() != ksheuid || getgid() != getegid();
-#else
-	Flag(FPRIVILEGED) = (kshuid = getuid()) != ksheuid ||
-	    (kshgid = getgid()) != (kshegid = getegid());
-#endif
+	Flag(FPRIVILEGED) = kshuid != ksheuid || kshgid != kshegid;
 
 	/* this to note if monitor is set on command line (see below) */
 #ifndef MKSH_UNEMPLOYED
@@ -309,18 +368,23 @@
 	/* this to note if utf-8 mode is set on command line (see below) */
 	UTFMODE = 2;
 
-	argi = parse_args(argv, OF_CMDLINE, NULL);
-	if (argi < 0)
-		return (NULL);
+	if (!Flag(FAS_BUILTIN)) {
+		argi = parse_args(argv, OF_CMDLINE, NULL);
+		if (argi < 0)
+			return (1);
+	}
 
 	/* process this later only, default to off (hysterical raisins) */
 	utf_flag = UTFMODE;
 	UTFMODE = 0;
 
-	if (Flag(FCOMMAND)) {
+	if (Flag(FAS_BUILTIN)) {
+		/* auto-detect from environment variables, always */
+		utf_flag = 3;
+	} else if (Flag(FCOMMAND)) {
 		s = pushs(SSTRING, ATEMP);
 		if (!(s->start = s->str = argv[argi++]))
-			errorf("-c requires an argument");
+			errorf("%s %s", "-c", "requires an argument");
 #ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT
 		/* compatibility to MidnightBSD 0.1 /bin/sh (kludge) */
 		if (Flag(FSH) && argv[argi] && !strcmp(argv[argi], "--"))
@@ -334,7 +398,7 @@
 		s->u.shf = shf_open(s->file, O_RDONLY, 0,
 		    SHF_MAPHI | SHF_CLEXEC);
 		if (s->u.shf == NULL) {
-			shl_stdout_ok = 0;
+			shl_stdout_ok = false;
 			warningf(true, "%s: %s", s->file, strerror(errno));
 			/* mandated by SUSv4 */
 			exstat = 127;
@@ -363,47 +427,85 @@
 
 	/* initialise job control */
 	j_init();
-	/* set: 0/1; unset: 2->0 */
-	UTFMODE = utf_flag & 1;
 	/* Do this after j_init(), as tty_fd is not initialised until then */
 	if (Flag(FTALKING)) {
 		if (utf_flag == 2) {
 #ifndef MKSH_ASSUME_UTF8
-#define isuc(x)	(((x) != NULL) && \
-		    (stristr((x), "UTF-8") || stristr((x), "utf8")))
-		/* Check if we're in a UTF-8 locale */
-			const char *ccp;
-
-#if HAVE_SETLOCALE_CTYPE
-			ccp = setlocale(LC_CTYPE, "");
-#if HAVE_LANGINFO_CODESET
-			if (!isuc(ccp))
-				ccp = nl_langinfo(CODESET);
-#endif
-#else
-			/* these were imported from environ earlier */
-			ccp = str_val(global("LC_ALL"));
-			if (ccp == null)
-				ccp = str_val(global("LC_CTYPE"));
-			if (ccp == null)
-				ccp = str_val(global("LANG"));
-#endif
-			UTFMODE = isuc(ccp);
-#undef isuc
+			/* auto-detect from locale or environment */
+			utf_flag = 4;
 #elif MKSH_ASSUME_UTF8
-			UTFMODE = 1;
+			utf_flag = 1;
 #else
-			UTFMODE = 0;
+			/* always disable UTF-8 (for interactive) */
+			utf_flag = 0;
 #endif
 		}
 		x_init();
 	}
 
+#ifdef SIGWINCH
+	sigtraps[SIGWINCH].flags |= TF_SHELL_USES;
+	setsig(&sigtraps[SIGWINCH], x_sigwinch,
+	    SS_RESTORE_ORIG|SS_FORCE|SS_SHTRAP);
+#endif
+
 	l = e->loc;
-	l->argv = &argv[argi - 1];
-	l->argc = argc - argi;
-	l->argv[0] = kshname;
-	getopts_reset(1);
+	if (Flag(FAS_BUILTIN)) {
+		l->argc = argc;
+		l->argv = argv;
+		l->argv[0] = ccp;
+	} else {
+		l->argc = argc - argi;
+		l->argv = &argv[argi - 1];
+		l->argv[0] = kshname;
+		getopts_reset(1);
+	}
+
+	/* divine the initial state of the utf8-mode Flag */
+#define isuc(x)	(((x) != NULL) && \
+	    (stristr((x), "UTF-8") || stristr((x), "utf8")))
+	ccp = null;
+	switch (utf_flag) {
+
+	/* auto-detect from locale or environment */
+	case 4:
+#if HAVE_SETLOCALE_CTYPE
+		ccp = setlocale(LC_CTYPE, "");
+#if HAVE_LANGINFO_CODESET
+		if (!isuc(ccp))
+			ccp = nl_langinfo(CODESET);
+#endif
+		if (!isuc(ccp))
+			ccp = null;
+		/* FALLTHROUGH */
+#endif
+
+	/* auto-detect from environment */
+	case 3:
+		/* these were imported from environ earlier */
+		if (ccp == null)
+			ccp = str_val(global("LC_ALL"));
+		if (ccp == null)
+			ccp = str_val(global("LC_CTYPE"));
+		if (ccp == null)
+			ccp = str_val(global("LANG"));
+		UTFMODE = isuc(ccp);
+		break;
+
+	/* not set on command line, not FTALKING */
+	case 2:
+	/* unknown values */
+	default:
+		utf_flag = 0;
+		/* FALLTHROUGH */
+
+	/* known values */
+	case 1:
+	case 0:
+		UTFMODE = utf_flag;
+		break;
+	}
+#undef isuc
 
 	/* Disable during .profile/ENV reading */
 	restricted = Flag(FRESTRICTED);
@@ -411,11 +513,12 @@
 	errexit = Flag(FERREXIT);
 	Flag(FERREXIT) = 0;
 
-	/* Do this before profile/$ENV so that if it causes problems in them,
+	/*
+	 * Do this before profile/$ENV so that if it causes problems in them,
 	 * user will know why things broke.
 	 */
 	if (!current_wd[0] && Flag(FTALKING))
-		warningf(false, "Cannot determine current working directory");
+		warningf(false, "can't determine current directory");
 
 	if (Flag(FLOGIN)) {
 		include(KSH_SYSTEM_PROFILE, 0, NULL, 1);
@@ -429,7 +532,7 @@
 		char *env_file;
 
 		/* include $ENV */
-		env_file = substitute(substitute("${ENV:-~/.mkshrc}", 0),
+		env_file = substitute(substitute("${ENV:-" MKSHRC_PATH "}", 0),
 		    DOTILDE);
 		if (*env_file != '\0')
 			include(env_file, 0, NULL, 1);
@@ -447,24 +550,20 @@
 	}
 	Flag(FERREXIT) = errexit;
 
-	if (Flag(FTALKING)) {
+	if (Flag(FTALKING))
 		hist_init(s);
-		alarm_init();
-	} else
-		Flag(FTRACKALL) = 1;	/* set after ENV */
+	else
+		/* set after ENV */
+		Flag(FTRACKALL) = 1;
 
-	return (s);
-}
+	alarm_init();
 
-int
-main(int argc, const char *argv[])
-{
-	Source *s;
+	if (Flag(FAS_BUILTIN))
+		return (shcomexec(l->argv));
 
-	if ((s = mksh_init(argc, argv)))
-		/* doesn’t return */
-		shell(s, true);
-	return (1);
+	/* doesn't return */
+	shell(s, true);
+	return (0);
 }
 
 int
@@ -498,9 +597,11 @@
 		switch (i) {
 		case LRETURN:
 		case LERROR:
-			return (exstat & 0xff); /* see below */
+			/* see below */
+			return (exstat & 0xFF);
 		case LINTR:
-			/* intr_ok is set if we are including .profile or $ENV.
+			/*
+			 * intr_ok is set if we are including .profile or $ENV.
 			 * If user ^Cs out, we don't want to kill the shell...
 			 */
 			if (intr_ok && (exstat - 128) != SIGTERM)
@@ -512,7 +613,7 @@
 			unwind(i);
 			/* NOTREACHED */
 		default:
-			internal_errorf("include: %d", i);
+			internal_errorf("%s %d", "include", i);
 			/* NOTREACHED */
 		}
 	}
@@ -529,16 +630,19 @@
 		e->loc->argv = old_argv;
 		e->loc->argc = old_argc;
 	}
-	return (i & 0xff);	/* & 0xff to ensure value not -1 */
+	/* & 0xff to ensure value not -1 */
+	return (i & 0xFF);
 }
 
+/* spawn a command into a shell optionally keeping track of the line number */
 int
-command(const char *comm)
+command(const char *comm, int line)
 {
 	Source *s;
 
 	s = pushs(SSTRING, ATEMP);
 	s->start = s->str = comm;
+	s->line = line;
 	return (shell(s, false));
 }
 
@@ -552,30 +656,32 @@
 	volatile int wastty = s->flags & SF_TTY;
 	volatile int attempts = 13;
 	volatile int interactive = Flag(FTALKING) && toplevel;
+	volatile bool sfirst = true;
 	Source *volatile old_source = source;
 	int i;
 
-	s->flags |= SF_FIRST;	/* enable UTF-8 BOM check */
-
 	newenv(E_PARSE);
 	if (interactive)
 		really_exit = 0;
 	i = sigsetjmp(e->jbuf, 0);
 	if (i) {
 		switch (i) {
-		case LINTR: /* we get here if SIGINT not caught or ignored */
+		case LINTR:
+			/* we get here if SIGINT not caught or ignored */
 		case LERROR:
 		case LSHELL:
 			if (interactive) {
 				if (i == LINTR)
 					shellf("\n");
-				/* Reset any eof that was read as part of a
+				/*
+				 * Reset any eof that was read as part of a
 				 * multiline command.
 				 */
 				if (Flag(FIGNOREEOF) && s->type == SEOF &&
 				    wastty)
 					s->type = SSTDIN;
-				/* Used by exit command to get back to
+				/*
+				 * Used by exit command to get back to
 				 * top level shell. Kind of strange since
 				 * interactive is set if we are reading from
 				 * a tty, but to have stopped jobs, one only
@@ -591,16 +697,17 @@
 		case LRETURN:
 			source = old_source;
 			quitenv(NULL);
-			unwind(i);	/* keep on going */
+			/* keep on going */
+			unwind(i);
 			/* NOTREACHED */
 		default:
 			source = old_source;
 			quitenv(NULL);
-			internal_errorf("shell: %d", i);
+			internal_errorf("%s %d", "shell", i);
 			/* NOTREACHED */
 		}
 	}
-	while (1) {
+	while (/* CONSTCOND */ 1) {
 		if (trap)
 			runtraps(0);
 
@@ -614,17 +721,19 @@
 			j_notify();
 			set_prompt(PS1, s);
 		}
-		t = compile(s);
+		t = compile(s, sfirst);
+		sfirst = false;
 		if (t != NULL && t->type == TEOF) {
 			if (wastty && Flag(FIGNOREEOF) && --attempts > 0) {
-				shellf("Use 'exit' to leave ksh\n");
+				shellf("Use 'exit' to leave mksh\n");
 				s->type = SSTDIN;
 			} else if (wastty && !really_exit &&
 			    j_stopped_running()) {
 				really_exit = 1;
 				s->type = SSTDIN;
 			} else {
-				/* this for POSIX which says EXIT traps
+				/*
+				 * this for POSIX which says EXIT traps
 				 * shall be taken in the environment
 				 * immediately after the last command
 				 * executed.
@@ -654,13 +763,17 @@
 	/* ordering for EXIT vs ERR is a bit odd (this is what AT&T ksh does) */
 	if (i == LEXIT || (Flag(FERREXIT) && (i == LERROR || i == LINTR) &&
 	    sigtraps[SIGEXIT_].trap)) {
-		runtrap(&sigtraps[SIGEXIT_]);
+		++trap_nested;
+		runtrap(&sigtraps[SIGEXIT_], trap_nested == 1);
+		--trap_nested;
 		i = LLEAVE;
 	} else if (Flag(FERREXIT) && (i == LERROR || i == LINTR)) {
-		runtrap(&sigtraps[SIGERR_]);
+		++trap_nested;
+		runtrap(&sigtraps[SIGERR_], trap_nested == 1);
+		--trap_nested;
 		i = LLEAVE;
 	}
-	while (1) {
+	while (/* CONSTCOND */ 1) {
 		switch (e->type) {
 		case E_PARSE:
 		case E_FUNC:
@@ -690,7 +803,8 @@
 	 * so first get the actually used memory, then assign it
 	 */
 	cp = alloc(sizeof(struct env) - ALLOC_SIZE, ATEMP);
-	ep = (void *)(cp - ALLOC_SIZE);	/* undo what alloc() did */
+	/* undo what alloc() did to the malloc result address */
+	ep = (void *)(cp - ALLOC_SIZE);
 	/* initialise public members of struct env (not the ALLOC_ITEM) */
 	ainit(&ep->area);
 	ep->oenv = e;
@@ -717,14 +831,17 @@
 			/* if ep->savefd[fd] < 0, means fd was closed */
 			if (ep->savefd[fd])
 				restfd(fd, ep->savefd[fd]);
-		if (ep->savefd[2])	/* Clear any write errors */
+		if (ep->savefd[2])
+			/* Clear any write errors */
 			shf_reopen(2, SHF_WR, shl_out);
 	}
-	/* Bottom of the stack.
+	/*
+	 * Bottom of the stack.
 	 * Either main shell is exiting or cleanup_parents_env() was called.
 	 */
 	if (ep->oenv == NULL) {
-		if (ep->type == E_NONE) {	/* Main shell exiting? */
+		if (ep->type == E_NONE) {
+			/* Main shell exiting? */
 #if HAVE_PERSISTENT_HISTORY
 			if (Flag(FTALKING))
 				hist_finish();
@@ -733,7 +850,8 @@
 			if (ep->flags & EF_FAKE_SIGDIE) {
 				int sig = exstat - 128;
 
-				/* ham up our death a bit (AT&T ksh
+				/*
+				 * ham up our death a bit (AT&T ksh
 				 * only seems to do this for SIGTERM)
 				 * Don't do it for SIGQUIT, since we'd
 				 * dump a core..
@@ -817,7 +935,8 @@
 			unlink(tp->name);
 }
 
-/* Initialise tty_fd. Used for saving/reseting tty modes upon
+/*
+ * Initialise tty_fd. Used for saving/reseting tty modes upon
  * foreground job completion and for setting up tty process group.
  */
 void
@@ -830,19 +949,21 @@
 		close(tty_fd);
 		tty_fd = -1;
 	}
-	tty_devtty = 1;
+	tty_devtty = true;
 
 #ifdef _UWIN
-	/* XXX imake style */
-	if (isatty(3))
+	/*XXX imake style */
+	if (isatty(3)) {
+		/* fd 3 on UWIN _is_ /dev/tty (or our controlling tty) */
 		tfd = 3;
-	else
+		do_close = false;
+	} else
 #endif
-	if ((tfd = open("/dev/tty", O_RDWR, 0)) < 0) {
-		tty_devtty = 0;
+	  if ((tfd = open("/dev/tty", O_RDWR, 0)) < 0) {
+		tty_devtty = false;
 		if (need_tty)
-			warningf(false,
-			    "No controlling tty (open /dev/tty: %s)",
+			warningf(false, "%s: %s %s: %s",
+			    "No controlling tty", "open", "/dev/tty",
 			    strerror(errno));
 	}
 	if (tfd < 0) {
@@ -853,20 +974,18 @@
 			tfd = 2;
 		else {
 			if (need_tty)
-				warningf(false,
-				    "Can't find tty file descriptor");
+				warningf(false, "can't find tty fd");
 			return;
 		}
 	}
 	if ((tty_fd = fcntl(tfd, F_DUPFD, FDBASE)) < 0) {
 		if (need_tty)
-			warningf(false, "j_ttyinit: dup of tty fd failed: %s",
-			    strerror(errno));
+			warningf(false, "%s: %s %s: %s", "j_ttyinit",
+			    "dup of tty fd", "failed", strerror(errno));
 	} else if (fcntl(tty_fd, F_SETFD, FD_CLOEXEC) < 0) {
 		if (need_tty)
-			warningf(false,
-			    "j_ttyinit: can't set close-on-exec flag: %s",
-			    strerror(errno));
+			warningf(false, "%s: %s: %s", "j_ttyinit",
+			    "can't set close-on-exec flag", strerror(errno));
 		close(tty_fd);
 		tty_fd = -1;
 	} else if (init_ttystate)
@@ -885,21 +1004,59 @@
 }
 
 /* A shell error occurred (eg, syntax error, etc.) */
+
+#define VWARNINGF_ERRORPREFIX	1
+#define VWARNINGF_FILELINE	2
+#define VWARNINGF_BUILTIN	4
+#define VWARNINGF_INTERNAL	8
+
+static void MKSH_A_FORMAT(__printf__, 2, 0)
+vwarningf(unsigned int flags, const char *fmt, va_list ap)
+{
+	if (*fmt != 1) {
+		if (flags & VWARNINGF_INTERNAL)
+			shf_fprintf(shl_out, "internal error: ");
+		if (flags & VWARNINGF_ERRORPREFIX)
+			error_prefix(tobool(flags & VWARNINGF_FILELINE));
+		if ((flags & VWARNINGF_BUILTIN) &&
+		    /* not set when main() calls parse_args() */
+		    builtin_argv0 && builtin_argv0 != kshname)
+			shf_fprintf(shl_out, "%s: ", builtin_argv0);
+		shf_vfprintf(shl_out, fmt, ap);
+		shf_putchar('\n', shl_out);
+	}
+	shf_flush(shl_out);
+}
+
+void
+errorfx(int rc, const char *fmt, ...)
+{
+	va_list va;
+
+	exstat = rc;
+
+	/* debugging: note that stdout not valid */
+	shl_stdout_ok = false;
+
+	va_start(va, fmt);
+	vwarningf(VWARNINGF_ERRORPREFIX | VWARNINGF_FILELINE, fmt, va);
+	va_end(va);
+	unwind(LERROR);
+}
+
 void
 errorf(const char *fmt, ...)
 {
 	va_list va;
 
-	shl_stdout_ok = 0;	/* debugging: note that stdout not valid */
 	exstat = 1;
-	if (*fmt != 1) {
-		error_prefix(true);
-		va_start(va, fmt);
-		shf_vfprintf(shl_out, fmt, va);
-		va_end(va);
-		shf_putchar('\n', shl_out);
-	}
-	shf_flush(shl_out);
+
+	/* debugging: note that stdout not valid */
+	shl_stdout_ok = false;
+
+	va_start(va, fmt);
+	vwarningf(VWARNINGF_ERRORPREFIX | VWARNINGF_FILELINE, fmt, va);
+	va_end(va);
 	unwind(LERROR);
 }
 
@@ -909,15 +1066,14 @@
 {
 	va_list va;
 
-	error_prefix(fileline);
 	va_start(va, fmt);
-	shf_vfprintf(shl_out, fmt, va);
+	vwarningf(VWARNINGF_ERRORPREFIX | (fileline ? VWARNINGF_FILELINE : 0),
+	    fmt, va);
 	va_end(va);
-	shf_putchar('\n', shl_out);
-	shf_flush(shl_out);
 }
 
-/* Used by built-in utilities to prefix shell and utility name to message
+/*
+ * Used by built-in utilities to prefix shell and utility name to message
  * (also unwinds environments for special builtins).
  */
 void
@@ -925,20 +1081,18 @@
 {
 	va_list va;
 
-	shl_stdout_ok = 0;	/* debugging: note that stdout not valid */
+	/* debugging: note that stdout not valid */
+	shl_stdout_ok = false;
+
 	exstat = 1;
-	if (*fmt != 1) {
-		error_prefix(true);
-		/* not set when main() calls parse_args() */
-		if (builtin_argv0)
-			shf_fprintf(shl_out, "%s: ", builtin_argv0);
-		va_start(va, fmt);
-		shf_vfprintf(shl_out, fmt, va);
-		va_end(va);
-		shf_putchar('\n', shl_out);
-	}
-	shf_flush(shl_out);
-	/* POSIX special builtins and ksh special builtins cause
+
+	va_start(va, fmt);
+	vwarningf(VWARNINGF_ERRORPREFIX | VWARNINGF_FILELINE |
+	    VWARNINGF_BUILTIN, fmt, va);
+	va_end(va);
+
+	/*
+	 * POSIX special builtins and ksh special builtins cause
 	 * non-interactive shells to exit.
 	 * XXX odd use of KEEPASN; also may not want LERROR here
 	 */
@@ -950,21 +1104,12 @@
 
 /* Called when something that shouldn't happen does */
 void
-internal_verrorf(const char *fmt, va_list ap)
-{
-	shf_fprintf(shl_out, "internal error: ");
-	shf_vfprintf(shl_out, fmt, ap);
-	shf_putchar('\n', shl_out);
-	shf_flush(shl_out);
-}
-
-void
 internal_errorf(const char *fmt, ...)
 {
 	va_list va;
 
 	va_start(va, fmt);
-	internal_verrorf(fmt, va);
+	vwarningf(VWARNINGF_INTERNAL, fmt, va);
 	va_end(va);
 	unwind(LERROR);
 }
@@ -975,7 +1120,7 @@
 	va_list va;
 
 	va_start(va, fmt);
-	internal_verrorf(fmt, va);
+	vwarningf(VWARNINGF_INTERNAL, fmt, va);
 	va_end(va);
 }
 
@@ -1000,7 +1145,8 @@
 {
 	va_list va;
 
-	if (!initio_done) /* shl_out may not be set up yet... */
+	if (!initio_done)
+		/* shl_out may not be set up yet... */
 		return;
 	va_start(va, fmt);
 	shf_vfprintf(shl_out, fmt, va);
@@ -1036,9 +1182,11 @@
 void
 initio(void)
 {
-	shf_fdopen(1, SHF_WR, shl_stdout);	/* force buffer allocation */
+	/* force buffer allocation */
+	shf_fdopen(1, SHF_WR, shl_stdout);
 	shf_fdopen(2, SHF_WR, shl_out);
-	shf_fdopen(2, SHF_WR, shl_spare);	/* force buffer allocation */
+	/* force buffer allocation */
+	shf_fdopen(2, SHF_WR, shl_spare);
 	initio_done = 1;
 }
 
@@ -1052,7 +1200,7 @@
 		errorf("too many files open in shell");
 
 #ifdef __ultrix
-	/* XXX imake style */
+	/*XXX imake style */
 	if (rv >= 0)
 		fcntl(nfd, F_SETFD, 0);
 #endif
@@ -1061,8 +1209,8 @@
 }
 
 /*
- * move fd from user space (0<=fd<10) to shell space (fd>=10),
- * set close-on-exec flag.
+ * Move fd from user space (0 <= fd < 10) to shell space (fd >= 10),
+ * set close-on-exec flag. See FDBASE in sh.h, maybe 24 not 10 here.
  */
 short
 savefd(int fd)
@@ -1083,10 +1231,12 @@
 {
 	if (fd == 2)
 		shf_flush(&shf_iob[fd]);
-	if (ofd < 0)		/* original fd closed */
+	if (ofd < 0)
+		/* original fd closed */
 		close(fd);
 	else if (fd != ofd) {
-		ksh_dup2(ofd, fd, true); /* XXX: what to do if this fails? */
+		/*XXX: what to do if this dup fails? */
+		ksh_dup2(ofd, fd, true);
 		close(ofd);
 	}
 }
@@ -1113,7 +1263,8 @@
 	close(pv[1]);
 }
 
-/* Called by iosetup() (deals with 2>&4, etc.), c_read, c_print to turn
+/*
+ * Called by iosetup() (deals with 2>&4, etc.), c_read, c_print to turn
  * a string (the X in 2>&X, read -uX, print -uX) into a file descriptor.
  */
 int
@@ -1136,7 +1287,8 @@
 		return (-1);
 	}
 	fl &= O_ACCMODE;
-	/* X_OK is a kludge to disable this check for dups (x<&1):
+	/*
+	 * X_OK is a kludge to disable this check for dups (x<&1):
 	 * historical shells never did this check (XXX don't know what
 	 * POSIX has to say).
 	 */
@@ -1172,7 +1324,8 @@
 	}
 }
 
-/* Called by c_read() and by iosetup() to close the other side of the
+/*
+ * Called by c_read() and by iosetup() to close the other side of the
  * read pipe, so reads will actually terminate.
  */
 void
@@ -1184,7 +1337,8 @@
 	}
 }
 
-/* Called by c_print when a write to a fd fails with EPIPE and by iosetup
+/*
+ * Called by c_print when a write to a fd fails with EPIPE and by iosetup
  * when co-process input is dup'd
  */
 void
@@ -1196,7 +1350,8 @@
 	}
 }
 
-/* Called to check for existence of/value of the co-process file descriptor.
+/*
+ * Called to check for existence of/value of the co-process file descriptor.
  * (Used by check_fd() and by c_read/c_print to deal with -p option).
  */
 int
@@ -1211,7 +1366,8 @@
 	return (-1);
 }
 
-/* called to close file descriptors related to the coprocess (if any)
+/*
+ * called to close file descriptors related to the coprocess (if any)
  * Should be called with SIGCHLD blocked.
  */
 void
@@ -1243,13 +1399,14 @@
 	char *pathname;
 	const char *dir;
 
-	dir = tmpdir ? tmpdir : "/tmp";
+	dir = tmpdir ? tmpdir : MKSH_DEFAULT_TMPDIR;
 #if HAVE_MKSTEMP
 	len = strlen(dir) + 6 + 10 + 1;
 #else
 	pathname = tempnam(dir, "mksh.");
 	len = ((pathname == NULL) ? 0 : strlen(pathname)) + 1;
 #endif
+	/* reasonably sure that this will not overflow */
 	tp = alloc(sizeof(struct temp) + len, ap);
 	tp->name = (char *)&tp[1];
 #if !HAVE_MKSTEMP
@@ -1257,14 +1414,14 @@
 		tp->name[0] = '\0';
 	else {
 		memcpy(tp->name, pathname, len);
-		free(pathname);
+		free_ostempnam(pathname);
 	}
 #endif
 	pathname = tp->name;
 	tp->shf = NULL;
 	tp->type = type;
 #if HAVE_MKSTEMP
-	shf_snprintf(pathname, len, "%s/mksh.XXXXXXXXXX", dir);
+	shf_snprintf(pathname, len, "%s%s", dir, "/mksh.XXXXXXXXXX");
 	if ((fd = mkstemp(pathname)) >= 0)
 #else
 	if (tp->name[0] && (fd = open(tp->name, O_CREAT | O_RDWR, 0600)) >= 0)
@@ -1290,26 +1447,6 @@
 static struct tbl *ktscan(struct table *, const char *, uint32_t,
     struct tbl ***);
 
-/* Bob Jenkins' one-at-a-time hash */
-uint32_t
-oaathash_full(register const uint8_t *bp)
-{
-	register uint32_t h = 0;
-	register uint8_t c;
-
-	while ((c = *bp++)) {
-		h += c;
-		h += h << 10;
-		h ^= h >> 6;
-	}
-
-	h += h << 3;
-	h ^= h >> 11;
-	h += h << 15;
-
-	return (h);
-}
-
 static void
 texpand(struct table *tp, size_t nsize)
 {
@@ -1317,15 +1454,18 @@
 	struct tbl *tblp, **pp;
 	struct tbl **ntblp, **otblp = tp->tbls;
 
-	ntblp = alloc(nsize * sizeof(struct tbl *), tp->areap);
+	ntblp = alloc2(nsize, sizeof(struct tbl *), tp->areap);
 	for (i = 0; i < nsize; i++)
 		ntblp[i] = NULL;
 	tp->size = nsize;
-	tp->nfree = (nsize * 4) / 5;	/* table can get 80% full */
+	/* table can get 80% full */
+	tp->nfree = (nsize * 4) / 5;
 	tp->tbls = ntblp;
 	if (otblp == NULL)
 		return;
-	nsize--;			/* from here on nsize := mask */
+
+	/* from here on nsize := mask */
+	nsize--;
 	for (i = 0; i < osize; i++)
 		if ((tblp = otblp[i]) != NULL) {
 			if ((tblp->flag & DEFINED)) {
@@ -1396,7 +1536,7 @@
 ktenter(struct table *tp, const char *n, uint32_t h)
 {
 	struct tbl **pp, *p;
-	int len;
+	size_t len;
 
 	if (tp->size == 0)
 		texpand(tp, INIT_TBLS);
@@ -1411,8 +1551,9 @@
 	}
 
 	/* create new tbl entry */
-	len = strlen(n) + 1;
-	p = alloc(offsetof(struct tbl, name[0]) + len, tp->areap);
+	len = strlen(n);
+	checkoktoadd(len, offsetof(struct tbl, name[0]) + 1);
+	p = alloc(offsetof(struct tbl, name[0]) + ++len, tp->areap);
 	p->flag = 0;
 	p->type = 0;
 	p->areap = tp->areap;
@@ -1460,7 +1601,8 @@
 	size_t i;
 	struct tbl **p, **sp, **dp;
 
-	p = alloc((tp->size + 1) * sizeof(struct tbl *), ATEMP);
+	/* tp->size + 1 will not overflow */
+	p = alloc2(tp->size + 1, sizeof(struct tbl *), ATEMP);
 	sp = tp->tbls;		/* source */
 	dp = p;			/* dest */
 	i = (size_t)tp->size;
@@ -1472,3 +1614,13 @@
 	p[i] = NULL;
 	return (p);
 }
+
+#ifdef SIGWINCH
+static void
+x_sigwinch(int sig MKSH_A_UNUSED)
+{
+	/* this runs inside interrupt context, with errno saved */
+
+	got_winch = 1;
+}
+#endif
Index: src/bin/mksh/misc.c
diff -u src/bin/mksh/misc.c:1.138 src/bin/mksh/misc.c:1.165
--- src/bin/mksh/misc.c:1.138	Fri Jan 29 09:34:29 2010
+++ src/bin/mksh/misc.c	Wed May  4 23:16:02 2011
@@ -2,7 +2,7 @@
 /*	$OpenBSD: path.c,v 1.12 2005/03/30 17:16:37 deraadt Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -29,15 +29,13 @@
 #include <grp.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.138 2010/01/29 09:34:29 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.165 2011/05/04 23:16:02 tg Exp $");
 
-unsigned char chtypes[UCHAR_MAX + 1];	/* type bits for unsigned char */
-
-#if !HAVE_SETRESUGID
-uid_t kshuid;
-gid_t kshgid, kshegid;
-#endif
+/* type bits for unsigned char */
+unsigned char chtypes[UCHAR_MAX + 1];
 
+static const unsigned char *pat_scan(const unsigned char *,
+    const unsigned char *, bool);
 static int do_gmatch(const unsigned char *, const unsigned char *,
     const unsigned char *, const unsigned char *);
 static const unsigned char *cclass(const unsigned char *, int);
@@ -45,6 +43,20 @@
 static void chvt(const char *);
 #endif
 
+/*XXX this should go away */
+static int make_path(const char *, const char *, char **, XString *, int *);
+
+#ifdef SETUID_CAN_FAIL_WITH_EAGAIN
+/* we don't need to check for other codes, EPERM won't happen */
+#define DO_SETUID(func, argvec) do {					\
+	if ((func argvec) && errno == EAGAIN)				\
+		errorf("%s failed with EAGAIN, probably due to a"	\
+		    " too low process limit; aborting", #func);		\
+} while (/* CONSTCOND */ 0)
+#else
+#define DO_SETUID(func, argvec) func argvec
+#endif
+
 /*
  * Fast character classes
  */
@@ -56,7 +68,8 @@
 	if (t & C_IFS) {
 		for (i = 0; i < UCHAR_MAX + 1; i++)
 			chtypes[i] &= ~C_IFS;
-		chtypes[0] |= C_IFS; /* include \0 in C_IFS */
+		/* include \0 in C_IFS */
+		chtypes[0] |= C_IFS;
 	}
 	while (*s != 0)
 		chtypes[(unsigned char)*s++] |= t;
@@ -73,7 +86,8 @@
 		chtypes[c] |= C_ALPHA;
 	chtypes['_'] |= C_ALPHA;
 	setctypes("0123456789", C_DIGIT);
-	setctypes(" \t\n|&;<>()", C_LEX1); /* \0 added automatically */
+	/* \0 added automatically */
+	setctypes(" \t\n|&;<>()", C_LEX1);
 	setctypes("*@#!$-?", C_VAR1);
 	setctypes(" \t\n", C_IFSWS);
 	setctypes("=-+?", C_SUBOP1);
@@ -82,12 +96,15 @@
 
 /* called from XcheckN() to grow buffer */
 char *
-Xcheck_grow_(XString *xsp, const char *xp, unsigned int more)
+Xcheck_grow_(XString *xsp, const char *xp, size_t more)
 {
 	const char *old_beg = xsp->beg;
 
-	xsp->len += more > xsp->len ? more : xsp->len;
-	xsp->beg = aresize(xsp->beg, xsp->len + 8, xsp->areap);
+	if (more < xsp->len)
+		more = xsp->len;
+	/* (xsp->len + X_EXTRA) never overflows */
+	checkoktoadd(more, xsp->len + X_EXTRA);
+	xsp->beg = aresize(xsp->beg, (xsp->len += more) + X_EXTRA, xsp->areap);
 	xsp->end = xsp->beg + xsp->len;
 	return (xsp->beg + (xp - old_beg));
 }
@@ -167,11 +184,12 @@
 		print_columns(shl_stdout, n, options_fmt_entry, &oi,
 		    octs + 4, oi.opt_width + 4, true);
 	} else {
-		/* short version á la AT&T ksh93 */
-		shf_puts("set", shl_stdout);
+		/* short version like AT&T ksh93 */
+		shf_puts(T_set, shl_stdout);
 		while (i < (int)NELEM(options)) {
 			if (Flag(i) && options[i].name)
-				shprintf(" -o %s", options[i].name);
+				shprintf("%s %s %s", null, "-o",
+				    options[i].name);
 			++i;
 		}
 		shf_putc('\n', shl_stdout);
@@ -182,7 +200,7 @@
 getoptions(void)
 {
 	unsigned int i;
-	char m[(int) FNFLAGS + 1];
+	char m[(int)FNFLAGS + 1];
 	char *cp = m;
 
 	for (i = 0; i < NELEM(options); i++)
@@ -199,7 +217,8 @@
 	unsigned char oldval;
 
 	oldval = Flag(f);
-	Flag(f) = newval ? 1 : 0;	/* needed for tristates */
+	/* needed for tristates */
+	Flag(f) = newval ? 1 : 0;
 #ifndef MKSH_UNEMPLOYED
 	if (f == FMONITOR) {
 		if (what != OF_CMDLINE && newval != oldval)
@@ -218,18 +237,21 @@
 		Flag(f) = (unsigned char)newval;
 	} else if (f == FPRIVILEGED && oldval && !newval) {
 		/* Turning off -p? */
-#if HAVE_SETRESUGID
-		gid_t kshegid = getgid();
 
-		setresgid(kshegid, kshegid, kshegid);
+		/*XXX this can probably be optimised */
+		kshegid = kshgid = getgid();
+#if HAVE_SETRESUGID
+		DO_SETUID(setresgid, (kshegid, kshegid, kshegid));
 #if HAVE_SETGROUPS
+		/* setgroups doesn't EAGAIN on Linux */
 		setgroups(1, &kshegid);
 #endif
-		setresuid(ksheuid, ksheuid, ksheuid);
+		DO_SETUID(setresuid, (ksheuid, ksheuid, ksheuid));
 #else
+		/* seteuid, setegid, setgid don't EAGAIN on Linux */
 		seteuid(ksheuid = kshuid = getuid());
-		setuid(ksheuid);
-		setegid(kshegid = kshgid = getgid());
+		DO_SETUID(setuid, (ksheuid));
+		setegid(kshegid);
 		setgid(kshegid);
 #endif
 	} else if ((f == FPOSIX || f == FSH) && newval) {
@@ -243,12 +265,14 @@
 	}
 }
 
-/* Parse command line & set command arguments. Returns the index of
+/*
+ * Parse command line and set command arguments. Returns the index of
  * non-option arguments, -1 if there is an error.
  */
 int
 parse_args(const char **argv,
-    int what,			/* OF_CMDLINE or OF_SET */
+    /* OF_CMDLINE or OF_SET */
+    int what,
     bool *setargsp)
 {
 	static char cmd_opts[NELEM(options) + 5]; /* o:T:\0 */
@@ -257,7 +281,8 @@
 	const char *array = NULL;
 	Getopt go;
 	size_t i;
-	int optc, sortargs = 0, arrayset = 0;
+	int optc, arrayset = 0;
+	bool sortargs = false;
 
 	/* First call? Build option strings... */
 	if (cmd_opts[0] == '\0') {
@@ -291,7 +316,8 @@
 
 	if (what == OF_CMDLINE) {
 		const char *p = argv[0], *q;
-		/* Set FLOGIN before parsing options so user can clear
+		/*
+		 * Set FLOGIN before parsing options so user can clear
 		 * flag using +l.
 		 */
 		if (*p != '-')
@@ -319,7 +345,8 @@
 			if (what == OF_FIRSTTIME)
 				break;
 			if (go.optarg == NULL) {
-				/* lone -o: print options
+				/*
+				 * lone -o: print options
 				 *
 				 * Note that on the command line, -o requires
 				 * an option (ie, can't get here if what is
@@ -329,8 +356,17 @@
 				break;
 			}
 			i = option(go.optarg);
+#ifndef MKSH_NO_DEPRECATED_WARNING
+			if ((enum sh_flag)i == FARC4RANDOM) {
+				warningf(true, "Do not use set ±o arc4random,"
+				    " it will be removed in the next version"
+				    " of mksh!");
+				return (0);
+			}
+#endif
 			if ((i != (size_t)-1) && set == Flag(i))
-				/* Don't check the context if the flag
+				/*
+				 * Don't check the context if the flag
 				 * isn't changing - makes "set -o interactive"
 				 * work if you're already interactive. Needed
 				 * if the output of "set +o" is to be used.
@@ -339,7 +375,7 @@
 			else if ((i != (size_t)-1) && (options[i].flags & what))
 				change_flag((enum sh_flag)i, what, set);
 			else {
-				bi_errorf("%s: bad option", go.optarg);
+				bi_errorf("%s: %s", go.optarg, "bad option");
 				return (-1);
 			}
 			break;
@@ -365,7 +401,7 @@
 				break;
 			/* -s: sort positional params (AT&T ksh stupidity) */
 			if (what == OF_SET && optc == 's') {
-				sortargs = 1;
+				sortargs = true;
 				break;
 			}
 			for (i = 0; i < NELEM(options); i++)
@@ -392,9 +428,15 @@
 		*setargsp = !arrayset && ((go.info & GI_MINUSMINUS) ||
 		    argv[go.optind]);
 
-	if (arrayset && (!*array || *skip_varname(array, false))) {
-		bi_errorf("%s: is not an identifier", array);
-		return (-1);
+	if (arrayset) {
+		const char *ccp = NULL;
+
+		if (*array)
+			ccp = skip_varname(array, false);
+		if (!ccp || !(!ccp[0] || (ccp[0] == '+' && !ccp[1]))) {
+			bi_errorf("%s: %s", array, "is not an identifier");
+			return (-1);
+		}
 	}
 	if (sortargs) {
 		for (i = go.optind; argv[i]; i++)
@@ -403,7 +445,7 @@
 		    xstrcmp);
 	}
 	if (arrayset)
-		go.optind += set_array(array, arrayset > 0 ? true : false,
+		go.optind += set_array(array, tobool(arrayset > 0),
 		    argv + go.optind);
 
 	return (go.optind);
@@ -450,10 +492,83 @@
 	int rv;
 
 	if (!(rv = getn(as, ai)))
-		bi_errorf("%s: bad number", as);
+		bi_errorf("%s: %s", as, "bad number");
 	return (rv);
 }
 
+/**
+ * pattern simplifications:
+ * - @(x) -> x (not @(x|y) though)
+ * - ** -> *
+ */
+static void *
+simplify_gmatch_pattern(const unsigned char *sp)
+{
+	uint8_t c;
+	unsigned char *cp, *dp;
+	const unsigned char *ps, *se;
+
+	cp = alloc(strlen((const void *)sp) + 1, ATEMP);
+	goto simplify_gmatch_pat1a;
+
+	/* foo@(b@(a)r)b@(a|a)z -> foobarb@(a|a)z */
+ simplify_gmatch_pat1:
+	sp = cp;
+ simplify_gmatch_pat1a:
+	dp = cp;
+	se = sp + strlen((const void *)sp);
+	while ((c = *sp++)) {
+		if (!ISMAGIC(c)) {
+			*dp++ = c;
+			continue;
+		}
+		switch ((c = *sp++)) {
+		case 0x80|'@':
+		/* simile for @ */
+		case 0x80|' ':
+			/* check whether it has only one clause */
+			ps = pat_scan(sp, se, true);
+			if (!ps || ps[-1] != /*(*/ ')')
+				/* nope */
+				break;
+			/* copy inner clause until matching close */
+			ps -= 2;
+			while ((const unsigned char *)sp < ps)
+				*dp++ = *sp++;
+			/* skip MAGIC and closing parenthesis */
+			sp += 2;
+			/* copy the rest of the pattern */
+			memmove(dp, sp, strlen((const void *)sp) + 1);
+			/* redo from start */
+			goto simplify_gmatch_pat1;
+		}
+		*dp++ = MAGIC;
+		*dp++ = c;
+	}
+	*dp = '\0';
+
+	/* collapse adjacent asterisk wildcards */
+	sp = dp = cp;
+	while ((c = *sp++)) {
+		if (!ISMAGIC(c)) {
+			*dp++ = c;
+			continue;
+		}
+		switch ((c = *sp++)) {
+		case '*':
+			while (ISMAGIC(sp[0]) && sp[1] == c)
+				sp += 2;
+			break;
+		}
+		*dp++ = MAGIC;
+		*dp++ = c;
+	}
+	*dp = '\0';
+
+	/* return the result, allocated from ATEMP */
+	return (cp);
+}
+
 /* -------- gmatch.c -------- */
 
 /*
@@ -463,18 +578,20 @@
  * Match a pattern as in sh(1).
  * pattern character are prefixed with MAGIC by expand.
  */
-
 int
 gmatchx(const char *s, const char *p, bool isfile)
 {
 	const char *se, *pe;
+	char *pnew;
+	int rv;
 
 	if (s == NULL || p == NULL)
 		return (0);
 
 	se = s + strlen(s);
 	pe = p + strlen(p);
-	/* isfile is false iff no syntax check has been done on
+	/*
+	 * isfile is false iff no syntax check has been done on
 	 * the pattern. If check fails, just to a strcmp().
 	 */
 	if (!isfile && !has_globbing(p, pe)) {
@@ -484,11 +601,22 @@
 		debunk(t, p, len);
 		return (!strcmp(t, s));
 	}
-	return (do_gmatch((const unsigned char *) s, (const unsigned char *) se,
-	    (const unsigned char *) p, (const unsigned char *) pe));
+
+	/*
+	 * since the do_gmatch() engine sucks so much, we must do some
+	 * pattern simplifications
+	 */
+	pnew = simplify_gmatch_pattern((const unsigned char *)p);
+	pe = pnew + strlen(pnew);
+
+	rv = do_gmatch((const unsigned char *)s, (const unsigned char *)se,
+	    (const unsigned char *)pnew, (const unsigned char *)pe);
+	afree(pnew, ATEMP);
+	return (rv);
 }
 
-/* Returns if p is a syntacticly correct globbing pattern, false
+/**
+ * Returns if p is a syntacticly correct globbing pattern, false
  * if it contains no pattern characters or if there is a syntax error.
  * Syntax errors are:
  *	- [ with no closing ]
@@ -496,14 +624,14 @@
  *	- [...] and *(...) not nested (eg, [a$(b|]c), *(a[b|c]d))
  */
 /*XXX
-- if no magic,
-	if dest given, copy to dst
-	return ?
-- if magic && (no globbing || syntax error)
-	debunk to dst
-	return ?
-- return ?
-*/
+ * - if no magic,
+ *	if dest given, copy to dst
+ *	return ?
+ * - if magic && (no globbing || syntax error)
+ *	debunk to dst
+ *	return ?
+ * - return ?
+ */
 int
 has_globbing(const char *xp, const char *xpe)
 {
@@ -511,42 +639,46 @@
 	const unsigned char *pe = (const unsigned char *) xpe;
 	int c;
 	int nest = 0, bnest = 0;
-	int saw_glob = 0;
-	int in_bracket = 0; /* inside [...] */
+	bool saw_glob = false;
+	/* inside [...] */
+	bool in_bracket = false;
 
 	for (; p < pe; p++) {
 		if (!ISMAGIC(*p))
 			continue;
 		if ((c = *++p) == '*' || c == '?')
-			saw_glob = 1;
+			saw_glob = true;
 		else if (c == '[') {
 			if (!in_bracket) {
-				saw_glob = 1;
-				in_bracket = 1;
+				saw_glob = true;
+				in_bracket = true;
 				if (ISMAGIC(p[1]) && p[2] == NOT)
 					p += 2;
 				if (ISMAGIC(p[1]) && p[2] == ']')
 					p += 2;
 			}
-			/* XXX Do we need to check ranges here? POSIX Q */
+			/*XXX Do we need to check ranges here? POSIX Q */
 		} else if (c == ']') {
 			if (in_bracket) {
-				if (bnest)		/* [a*(b]) */
+				if (bnest)
+					/* [a*(b]) */
 					return (0);
-				in_bracket = 0;
+				in_bracket = false;
 			}
 		} else if ((c & 0x80) && vstrchr("*+?@! ", c & 0x7f)) {
-			saw_glob = 1;
+			saw_glob = true;
 			if (in_bracket)
 				bnest++;
 			else
 				nest++;
 		} else if (c == '|') {
-			if (in_bracket && !bnest)	/* *(a[foo|bar]) */
+			if (in_bracket && !bnest)
+				/* *(a[foo|bar]) */
 				return (0);
 		} else if (c == /*(*/ ')') {
 			if (in_bracket) {
-				if (!bnest--)		/* *(a[b)c] */
+				if (!bnest--)
+					/* *(a[b)c] */
 					return (0);
 			} else if (nest)
 				nest--;
@@ -608,9 +740,12 @@
 		 * [*+?@!](pattern|pattern|..)
 		 * This is also needed for ${..%..}, etc.
 		 */
-		case 0x80|'+': /* matches one or more times */
-		case 0x80|'*': /* matches zero or more times */
-			if (!(prest = pat_scan(p, pe, 0)))
+
+		/* matches one or more times */
+		case 0x80|'+':
+		/* matches zero or more times */
+		case 0x80|'*':
+			if (!(prest = pat_scan(p, pe, false)))
 				return (0);
 			s--;
 			/* take care of zero matches */
@@ -618,7 +753,7 @@
 			    do_gmatch(s, se, prest, pe))
 				return (1);
 			for (psub = p; ; psub = pnext) {
-				pnext = pat_scan(psub, pe, 1);
+				pnext = pat_scan(psub, pe, true);
 				for (srest = s; srest <= se; srest++) {
 					if (do_gmatch(s, srest, psub, pnext - 2) &&
 					    (do_gmatch(srest, se, prest, pe) ||
@@ -631,10 +766,13 @@
 			}
 			return (0);
 
-		case 0x80|'?': /* matches zero or once */
-		case 0x80|'@': /* matches one of the patterns */
-		case 0x80|' ': /* simile for @ */
-			if (!(prest = pat_scan(p, pe, 0)))
+		/* matches zero or once */
+		case 0x80|'?':
+		/* matches one of the patterns */
+		case 0x80|'@':
+		/* simile for @ */
+		case 0x80|' ':
+			if (!(prest = pat_scan(p, pe, false)))
 				return (0);
 			s--;
 			/* Take care of zero matches */
@@ -642,7 +780,7 @@
 			    do_gmatch(s, se, prest, pe))
 				return (1);
 			for (psub = p; ; psub = pnext) {
-				pnext = pat_scan(psub, pe, 1);
+				pnext = pat_scan(psub, pe, true);
 				srest = prest == pe ? se : s;
 				for (; srest <= se; srest++) {
 					if (do_gmatch(s, srest, psub, pnext - 2) &&
@@ -654,15 +792,16 @@
 			}
 			return (0);
 
-		case 0x80|'!': /* matches none of the patterns */
-			if (!(prest = pat_scan(p, pe, 0)))
+		/* matches none of the patterns */
+		case 0x80|'!':
+			if (!(prest = pat_scan(p, pe, false)))
 				return (0);
 			s--;
 			for (srest = s; srest <= se; srest++) {
 				int matched = 0;
 
 				for (psub = p; ; psub = pnext) {
-					pnext = pat_scan(psub, pe, 1);
+					pnext = pat_scan(psub, pe, true);
 					if (do_gmatch(s, srest, psub,
 					    pnext - 2)) {
 						matched = 1;
@@ -689,19 +828,21 @@
 static const unsigned char *
 cclass(const unsigned char *p, int sub)
 {
-	int c, d, not, found = 0;
+	int c, d, notp, found = 0;
 	const unsigned char *orig_p = p;
 
-	if ((not = (ISMAGIC(*p) && *++p == NOT)))
+	if ((notp = (ISMAGIC(*p) && *++p == NOT)))
 		p++;
 	do {
 		c = *p++;
 		if (ISMAGIC(c)) {
 			c = *p++;
 			if ((c & 0x80) && !ISMAGIC(c)) {
-				c &= 0x7f;/* extended pattern matching: *+?@! */
+				/* extended pattern matching: *+?@! */
+				c &= 0x7F;
 				/* XXX the ( char isn't handled as part of [] */
-				if (c == ' ') /* simile for @: plain (..) */
+				if (c == ' ')
+					/* simile for @: plain (..) */
 					c = '(' /*)*/;
 			}
 		}
@@ -710,7 +851,8 @@
 			return (sub == '[' ? orig_p : NULL);
 		if (ISMAGIC(p[0]) && p[1] == '-' &&
 		    (!ISMAGIC(p[2]) || p[3] != ']')) {
-			p += 2; /* MAGIC- */
+			/* MAGIC- */
+			p += 2;
 			d = *p++;
 			if (ISMAGIC(d)) {
 				d = *p++;
@@ -726,12 +868,12 @@
 			found = 1;
 	} while (!(ISMAGIC(p[0]) && p[1] == ']'));
 
-	return ((found != not) ? p+2 : NULL);
+	return ((found != notp) ? p+2 : NULL);
 }
 
 /* Look for next ) or | (if match_sep) in *(foo|bar) pattern */
 const unsigned char *
-pat_scan(const unsigned char *p, const unsigned char *pe, int match_sep)
+pat_scan(const unsigned char *p, const unsigned char *pe, bool match_sep)
 {
 	int nest = 0;
 
@@ -766,7 +908,8 @@
 }
 
 
-/* getopt() used for shell built-in commands, the getopts command, and
+/**
+ * getopt() used for shell built-in commands, the getopts command, and
  * command line options.
  * A leading ':' in options means don't print errors, instead return '?'
  * or ':' and set go->optarg to the offending option character.
@@ -807,7 +950,8 @@
 			return (-1);
 		}
 		if (arg == NULL ||
-		    ((flag != '-' ) && /* neither a - nor a + (if + allowed) */
+		    ((flag != '-' ) &&
+		    /* neither a - nor a + (if + allowed) */
 		    (!(go->flags & GF_PLUSOPT) || flag != '+')) ||
 		    (c = arg[1]) == '\0') {
 			go->p = 0;
@@ -824,15 +968,17 @@
 			go->buf[0] = c;
 			go->optarg = go->buf;
 		} else {
-			warningf(true, "%s%s-%c: unknown option",
+			warningf(true, "%s%s-%c: %s",
 			    (go->flags & GF_NONAME) ? "" : argv[0],
-			    (go->flags & GF_NONAME) ? "" : ": ", c);
+			    (go->flags & GF_NONAME) ? "" : ": ", c,
+			    "unknown option");
 			if (go->flags & GF_ERROR)
 				bi_errorfz();
 		}
 		return ('?');
 	}
-	/* : means argument must be present, may be part of option argument
+	/**
+	 * : means argument must be present, may be part of option argument
 	 *   or the next argument
 	 * ; same as : but argument may be missing
 	 * , means argument is part of option argument, and may be null.
@@ -850,9 +996,10 @@
 				go->optarg = go->buf;
 				return (':');
 			}
-			warningf(true, "%s%s-'%c' requires argument",
+			warningf(true, "%s%s-%c: %s",
 			    (go->flags & GF_NONAME) ? "" : argv[0],
-			    (go->flags & GF_NONAME) ? "" : ": ", c);
+			    (go->flags & GF_NONAME) ? "" : ": ", c,
+			    "requires an argument");
 			if (go->flags & GF_ERROR)
 				bi_errorfz();
 			return ('?');
@@ -863,7 +1010,8 @@
 		go->optarg = argv[go->optind - 1] + go->p;
 		go->p = 0;
 	} else if (*o == '#') {
-		/* argument is optional and may be attached or unattached
+		/*
+		 * argument is optional and may be attached or unattached
 		 * but must start with a digit. optarg is set to 0 if the
 		 * argument is missing.
 		 */
@@ -884,7 +1032,8 @@
 	return (c);
 }
 
-/* print variable/alias value using necessary quotes
+/*
+ * print variable/alias value using necessary quotes
  * (POSIX says they should be suitable for re-entry...)
  * No trailing newline is printed.
  */
@@ -892,25 +1041,33 @@
 print_value_quoted(const char *s)
 {
 	const char *p;
-	int inquote = 0;
+	bool inquote = false;
 
-	/* Test if any quotes are needed */
+	/* first, check whether any quotes are needed */
 	for (p = s; *p; p++)
 		if (ctype(*p, C_QUOTE))
 			break;
 	if (!*p) {
+		/* nope, use the shortcut */
 		shf_puts(s, shl_stdout);
 		return;
 	}
+
+	/* quote via state machine */
 	for (p = s; *p; p++) {
 		if (*p == '\'') {
-			if (inquote)
+			/*
+			 * multiple '''s or any ' at beginning of string
+			 * look nicer this way than when simply substituting
+			 */
+			if (inquote) {
 				shf_putc('\'', shl_stdout);
+				inquote = false;
+			}
 			shf_putc('\\', shl_stdout);
-			inquote = 0;
 		} else if (!inquote) {
 			shf_putc('\'', shl_stdout);
-			inquote = 1;
+			inquote = true;
 		}
 		shf_putc(*p, shl_stdout);
 	}
@@ -992,8 +1149,9 @@
 {
 	char *dst;
 
-	/* nbytes check because some systems (older FreeBSDs) have a buggy
-	 * memchr()
+	/*
+	 * nbytes check because some systems (older FreeBSDs) have a
+	 * buggy memchr()
 	 */
 	if (nbytes && (dst = memchr(buf, '\0', nbytes))) {
 		char *end = buf + nbytes;
@@ -1013,19 +1171,20 @@
 	}
 }
 
-/* Like read(2), but if read fails due to non-blocking flag, resets flag
- * and restarts read.
+/*
+ * Like read(2), but if read fails due to non-blocking flag,
+ * resets flag and restarts read.
  */
-int
-blocking_read(int fd, char *buf, int nbytes)
+ssize_t
+blocking_read(int fd, char *buf, size_t nbytes)
 {
-	int ret;
-	int tried_reset = 0;
+	ssize_t ret;
+	bool tried_reset = false;
 
 	while ((ret = read(fd, buf, nbytes)) < 0) {
 		if (!tried_reset && errno == EAGAIN) {
 			if (reset_nonblock(fd) > 0) {
-				tried_reset = 1;
+				tried_reset = true;
 				continue;
 			}
 			errno = EAGAIN;
@@ -1035,7 +1194,8 @@
 	return (ret);
 }
 
-/* Reset the non-blocking flag on the specified file descriptor.
+/*
+ * Reset the non-blocking flag on the specified file descriptor.
  * Returns -1 if there was an error, 0 if non-blocking wasn't set,
  * 1 if it was.
  */
@@ -1054,34 +1214,225 @@
 	return (1);
 }
 
-
-/* Like getcwd(), except bsize is ignored if buf is 0 (PATH_MAX is used) */
+/* getcwd(3) equivalent, allocates from ATEMP but doesn't resize */
 char *
-ksh_get_wd(size_t *dlen)
+ksh_get_wd(void)
 {
-	char *ret, *b;
-	size_t len = 1;
-
 #ifdef NO_PATH_MAX
-	if ((b = get_current_dir_name())) {
-		len = strlen(b) + 1;
-		strndupx(ret, b, len - 1, ATEMP);
-		free(b);
+	char *rv, *cp;
+
+	if ((cp = get_current_dir_name())) {
+		strdupx(rv, cp, ATEMP);
+		free_gnu_gcdn(cp);
 	} else
-		ret = NULL;
+		rv = NULL;
 #else
-	if ((ret = getcwd((b = alloc(PATH_MAX + 1, ATEMP)), PATH_MAX)))
-		ret = aresize(b, len = (strlen(b) + 1), ATEMP);
-	else
-		afree(b, ATEMP);
+	char *rv;
+
+	if (!getcwd((rv = alloc(PATH_MAX + 1, ATEMP)), PATH_MAX)) {
+		afree(rv, ATEMP);
+		rv = NULL;
+	}
 #endif
 
-	if (dlen)
-		*dlen = len;
-	return (ret);
+	return (rv);
 }
 
-/*
+char *
+do_realpath(const char *upath)
+{
+	char *xp, *ip, *tp, *ipath, *ldest = NULL;
+	XString xs;
+	ptrdiff_t pos;
+	size_t len;
+	int llen;
+	struct stat sb;
+#ifdef NO_PATH_MAX
+	size_t ldestlen = 0;
+#define pathlen sb.st_size
+#define pathcnd (ldestlen < (pathlen + 1))
+#else
+#define pathlen PATH_MAX
+#define pathcnd (!ldest)
+#endif
+	/* max. recursion depth */
+	int symlinks = 32;
+
+	if (upath[0] == '/') {
+		/* upath is an absolute pathname */
+		strdupx(ipath, upath, ATEMP);
+	} else {
+		/* upath is a relative pathname, prepend cwd */
+		if ((tp = ksh_get_wd()) == NULL || tp[0] != '/')
+			return (NULL);
+		ipath = shf_smprintf("%s%s%s", tp, "/", upath);
+		afree(tp, ATEMP);
+	}
+
+	/* ipath and upath are in memory at the same time -> unchecked */
+	Xinit(xs, xp, strlen(ip = ipath) + 1, ATEMP);
+
+	/* now jump into the deep of the loop */
+	goto beginning_of_a_pathname;
+
+	while (*ip) {
+		/* skip slashes in input */
+		while (*ip == '/')
+			++ip;
+		if (!*ip)
+			break;
+
+		/* get next pathname component from input */
+		tp = ip;
+		while (*ip && *ip != '/')
+			++ip;
+		len = ip - tp;
+
+		/* check input for "." and ".." */
+		if (tp[0] == '.') {
+			if (len == 1)
+				/* just continue with the next one */
+				continue;
+			else if (len == 2 && tp[1] == '.') {
+				/* strip off last pathname component */
+				while (xp > Xstring(xs, xp))
+					if (*--xp == '/')
+						break;
+				/* then continue with the next one */
+				continue;
+			}
+		}
+
+		/* store output position away, then append slash to output */
+		pos = Xsavepos(xs, xp);
+		/* 1 for the '/' and len + 1 for tp and the NUL from below */
+		XcheckN(xs, xp, 1 + len + 1);
+		Xput(xs, xp, '/');
+
+		/* append next pathname component to output */
+		memcpy(xp, tp, len);
+		xp += len;
+		*xp = '\0';
+
+		/* lstat the current output, see if it's a symlink */
+		if (lstat(Xstring(xs, xp), &sb)) {
+			/* lstat failed */
+			if (errno == ENOENT) {
+				/* because the pathname does not exist */
+				while (*ip == '/')
+					/* skip any trailing slashes */
+					++ip;
+				/* no more components left? */
+				if (!*ip)
+					/* we can still return successfully */
+					break;
+				/* more components left? fall through */
+			}
+			/* not ENOENT or not at the end of ipath */
+			goto notfound;
+		}
+
+		/* check if we encountered a symlink? */
+		if (S_ISLNK(sb.st_mode)) {
+			/* reached maximum recursion depth? */
+			if (!symlinks--) {
+				/* yep, prevent infinite loops */
+				errno = ELOOP;
+				goto notfound;
+			}
+
+			/* get symlink(7) target */
+			if (pathcnd) {
+#ifdef NO_PATH_MAX
+				if (notoktoadd(pathlen, 1)) {
+					errno = ENAMETOOLONG;
+					goto notfound;
+				}
+#endif
+				ldest = aresize(ldest, pathlen + 1, ATEMP);
+			}
+			llen = readlink(Xstring(xs, xp), ldest, pathlen);
+			if (llen < 0)
+				/* oops... */
+				goto notfound;
+			ldest[llen] = '\0';
+
+			/*
+			 * restart if symlink target is an absolute path,
+			 * otherwise continue with currently resolved prefix
+			 */
+			/* append rest of current input path to link target */
+			tp = shf_smprintf("%s%s%s", ldest, *ip ? "/" : "", ip);
+			afree(ipath, ATEMP);
+			ip = ipath = tp;
+			if (ldest[0] != '/') {
+				/* symlink target is a relative path */
+				xp = Xrestpos(xs, xp, pos);
+			} else {
+				/* symlink target is an absolute path */
+				xp = Xstring(xs, xp);
+ beginning_of_a_pathname:
+				/* assert: (ip == ipath)[0] == '/' */
+				/* assert: xp == xs.beg => start of path */
+
+				/* exactly two leading slashes? (SUSv4 3.266) */
+				if (ip[1] == '/' && ip[2] != '/') {
+					/* keep them, e.g. for UNC pathnames */
+					Xput(xs, xp, '/');
+				}
+			}
+		}
+		/* otherwise (no symlink) merely go on */
+	}
+
+	/*
+	 * either found the target and successfully resolved it,
+	 * or found its parent directory and may create it
+	 */
+	if (Xlength(xs, xp) == 0)
+		/*
+		 * if the resolved pathname is "", make it "/",
+		 * otherwise do not add a trailing slash
+		 */
+		Xput(xs, xp, '/');
+	Xput(xs, xp, '\0');
+
+	/*
+	 * if source path had a trailing slash, check if target path
+	 * is not a non-directory existing file
+	 */
+	if (ip > ipath && ip[-1] == '/') {
+		if (stat(Xstring(xs, xp), &sb)) {
+			if (errno != ENOENT)
+				goto notfound;
+		} else if (!S_ISDIR(sb.st_mode)) {
+			errno = ENOTDIR;
+			goto notfound;
+		}
+		/* target now either does not exist or is a directory */
+	}
+
+	/* return target path */
+	if (ldest != NULL)
+		afree(ldest, ATEMP);
+	afree(ipath, ATEMP);
+	return (Xclose(xs, xp));
+
+ notfound:
+	/* save; freeing memory might trash it */
+	llen = errno;
+	if (ldest != NULL)
+		afree(ldest, ATEMP);
+	afree(ipath, ATEMP);
+	Xfree(xs, xp);
+	errno = llen;
+	return (NULL);
+
+#undef pathlen
+#undef pathcnd
+}
+
+/**
  *	Makes a filename into result using the following algorithm.
  *	- make result NULL
  *	- if file starts with '/', append file to result & set cdpathp to NULL
@@ -1096,9 +1447,10 @@
  *	The return value indicates whether a non-null element from cdpathp
  *	was appended to result.
  */
-int
+static int
 make_path(const char *cwd, const char *file,
-    char **cdpathp,		/* & of : separated list */
+    /* pointer to colon-separated list */
+    char **cdpathp,
     XString *xsp,
     int *phys_pathp)
 {
@@ -1166,96 +1518,281 @@
 	return (rval);
 }
 
-/*
+/*-
  * Simplify pathnames containing "." and ".." entries.
- * ie, simplify_path("/a/b/c/./../d/..") returns "/a/b"
+ *
+ * simplify_path(this)			= that
+ * /a/b/c/./../d/..			/a/b
+ * //./C/foo/bar/../baz			//C/foo/baz
+ * /foo/				/foo
+ * /foo/../../bar			/bar
+ * /foo/./blah/..			/foo
+ * .					.
+ * ..					..
+ * ./foo				foo
+ * foo/../../../bar			../../bar
  */
 void
-simplify_path(char *pathl)
+simplify_path(char *p)
 {
-	char *cur, *t;
-	bool isrooted;
-	char *very_start = pathl, *start;
+	char *dp, *ip, *sp, *tp;
+	size_t len;
+	bool needslash;
 
-	if (!*pathl)
+	switch (*p) {
+	case 0:
 		return;
+	case '/':
+		/* exactly two leading slashes? (SUSv4 3.266) */
+		if (p[1] == '/' && p[2] != '/')
+			/* keep them, e.g. for UNC pathnames */
+			++p;
+		needslash = true;
+		break;
+	default:
+		needslash = false;
+	}
+	dp = ip = sp = p;
 
-	if ((isrooted = pathl[0] == '/'))
-		very_start++;
-
-	/* Before			After
-	 * /foo/			/foo
-	 * /foo/../../bar		/bar
-	 * /foo/./blah/..		/foo
-	 * .				.
-	 * ..				..
-	 * ./foo			foo
-	 * foo/../../../bar		../../bar
-	 */
-
-	for (cur = t = start = very_start; ; ) {
-		/* treat multiple '/'s as one '/' */
-		while (*t == '/')
-			t++;
-
-		if (*t == '\0') {
-			if (cur == pathl)
-				/* convert empty path to dot */
-				*cur++ = '.';
-			*cur = '\0';
+	while (*ip) {
+		/* skip slashes in input */
+		while (*ip == '/')
+			++ip;
+		if (!*ip)
 			break;
-		}
 
-		if (t[0] == '.') {
-			if (!t[1] || t[1] == '/') {
-				t += 1;
+		/* get next pathname component from input */
+		tp = ip;
+		while (*ip && *ip != '/')
+			++ip;
+		len = ip - tp;
+
+		/* check input for "." and ".." */
+		if (tp[0] == '.') {
+			if (len == 1)
+				/* just continue with the next one */
 				continue;
-			} else if (t[1] == '.' && (!t[2] || t[2] == '/')) {
-				if (!isrooted && cur == start) {
-					if (cur != very_start)
-						*cur++ = '/';
-					*cur++ = '.';
-					*cur++ = '.';
-					start = cur;
-				} else if (cur != start)
-					while (--cur > start && *cur != '/')
-						;
-				t += 2;
+			else if (len == 2 && tp[1] == '.') {
+				/* parent level, but how? */
+				if (*p == '/')
+					/* absolute path, only one way */
+					goto strip_last_component;
+				else if (dp > sp) {
+					/* relative path, with subpaths */
+					needslash = false;
+ strip_last_component:
+					/* strip off last pathname component */
+					while (dp > sp)
+						if (*--dp == '/')
+							break;
+				} else {
+					/* relative path, at its beginning */
+					if (needslash)
+						/* or already dotdot-slash'd */
+						*dp++ = '/';
+					/* keep dotdot-slash if not absolute */
+					*dp++ = '.';
+					*dp++ = '.';
+					needslash = true;
+					sp = dp;
+				}
+				/* then continue with the next one */
 				continue;
 			}
 		}
 
-		if (cur != very_start)
-			*cur++ = '/';
+		if (needslash)
+			*dp++ = '/';
 
-		/* find/copy next component of pathname */
-		while (*t && *t != '/')
-			*cur++ = *t++;
-	}
+		/* append next pathname component to output */
+		memmove(dp, tp, len);
+		dp += len;
+
+		/* append slash if we continue */
+		needslash = true;
+		/* try next component */
+	}
+	if (dp == p)
+		/* empty path -> dot */
+		*dp++ = needslash ? '/' : '.';
+	*dp = '\0';
 }
 
-
 void
-set_current_wd(char *pathl)
+set_current_wd(const char *nwd)
 {
-	size_t len = 1;
-	char *p = pathl;
+	char *allocd = NULL;
 
-	if (p == NULL) {
-		if ((p = ksh_get_wd(&len)) == NULL)
-			p = null;
-	} else
-		len = strlen(p) + 1;
+	if (nwd == NULL) {
+		allocd = ksh_get_wd();
+		nwd = allocd ? allocd : null;
+	}
 
-	if (len > current_wd_size) {
-		afree(current_wd, APERM);
-		current_wd = alloc(current_wd_size = len, APERM);
-	}
-	memcpy(current_wd, p, len);
-	if (p != pathl && p != null)
-		afree(p, ATEMP);
+	afree(current_wd, APERM);
+	strdupx(current_wd, nwd, APERM);
+
+	afree(allocd, ATEMP);
 }
 
+int
+c_cd(const char **wp)
+{
+	int optc, rv, phys_path;
+	bool physical = tobool(Flag(FPHYSICAL));
+	/* was a node from cdpath added in? */
+	int cdnode;
+	/* print where we cd'd? */
+	bool printpath = false;
+	struct tbl *pwd_s, *oldpwd_s;
+	XString xs;
+	char *dir, *allocd = NULL, *tryp, *pwd, *cdpath;
+
+	while ((optc = ksh_getopt(wp, &builtin_opt, "LP")) != -1)
+		switch (optc) {
+		case 'L':
+			physical = false;
+			break;
+		case 'P':
+			physical = true;
+			break;
+		case '?':
+			return (1);
+		}
+	wp += builtin_opt.optind;
+
+	if (Flag(FRESTRICTED)) {
+		bi_errorf("restricted shell - can't cd");
+		return (1);
+	}
+
+	pwd_s = global("PWD");
+	oldpwd_s = global("OLDPWD");
+
+	if (!wp[0]) {
+		/* No arguments - go home */
+		if ((dir = str_val(global("HOME"))) == null) {
+			bi_errorf("no home directory (HOME not set)");
+			return (1);
+		}
+	} else if (!wp[1]) {
+		/* One argument: - or dir */
+		strdupx(allocd, wp[0], ATEMP);
+		if (ksh_isdash((dir = allocd))) {
+			afree(allocd, ATEMP);
+			allocd = NULL;
+			dir = str_val(oldpwd_s);
+			if (dir == null) {
+				bi_errorf("no OLDPWD");
+				return (1);
+			}
+			printpath = true;
+		}
+	} else if (!wp[2]) {
+		/* Two arguments - substitute arg1 in PWD for arg2 */
+		size_t ilen, olen, nlen, elen;
+		char *cp;
+
+		if (!current_wd[0]) {
+			bi_errorf("can't determine current directory");
+			return (1);
+		}
+		/*
+		 * substitute arg1 for arg2 in current path.
+		 * if the first substitution fails because the cd fails
+		 * we could try to find another substitution. For now
+		 * we don't
+		 */
+		if ((cp = strstr(current_wd, wp[0])) == NULL) {
+			bi_errorf("bad substitution");
+			return (1);
+		}
+		/*-
+		 * ilen = part of current_wd before wp[0]
+		 * elen = part of current_wd after wp[0]
+		 * because current_wd and wp[1] need to be in memory at the
+		 * same time beforehand the addition can stay unchecked
+		 */
+		ilen = cp - current_wd;
+		olen = strlen(wp[0]);
+		nlen = strlen(wp[1]);
+		elen = strlen(current_wd + ilen + olen) + 1;
+		dir = allocd = alloc(ilen + nlen + elen, ATEMP);
+		memcpy(dir, current_wd, ilen);
+		memcpy(dir + ilen, wp[1], nlen);
+		memcpy(dir + ilen + nlen, current_wd + ilen + olen, elen);
+		printpath = true;
+	} else {
+		bi_errorf("too many arguments");
+		return (1);
+	}
+
+#ifdef NO_PATH_MAX
+	/* only a first guess; make_path will enlarge xs if necessary */
+	XinitN(xs, 1024, ATEMP);
+#else
+	XinitN(xs, PATH_MAX, ATEMP);
+#endif
+
+	cdpath = str_val(global("CDPATH"));
+	do {
+		cdnode = make_path(current_wd, dir, &cdpath, &xs, &phys_path);
+		if (physical)
+			rv = chdir(tryp = Xstring(xs, xp) + phys_path);
+		else {
+			simplify_path(Xstring(xs, xp));
+			rv = chdir(tryp = Xstring(xs, xp));
+		}
+	} while (rv < 0 && cdpath != NULL);
+
+	if (rv < 0) {
+		if (cdnode)
+			bi_errorf("%s: %s", dir, "bad directory");
+		else
+			bi_errorf("%s: %s", tryp, strerror(errno));
+		afree(allocd, ATEMP);
+		return (1);
+	}
+
+	/* allocd (above) => dir, which is no longer used */
+	afree(allocd, ATEMP);
+	allocd = NULL;
+
+	/* Clear out tracked aliases with relative paths */
+	flushcom(false);
+
+	/*
+	 * Set OLDPWD (note: unsetting OLDPWD does not disable this
+	 * setting in AT&T ksh)
+	 */
+	if (current_wd[0])
+		/* Ignore failure (happens if readonly or integer) */
+		setstr(oldpwd_s, current_wd, KSH_RETURN_ERROR);
+
+	if (Xstring(xs, xp)[0] != '/') {
+		pwd = NULL;
+	} else if (!physical || !(pwd = allocd = do_realpath(Xstring(xs, xp))))
+		pwd = Xstring(xs, xp);
+
+	/* Set PWD */
+	if (pwd) {
+		char *ptmp = pwd;
+
+		set_current_wd(ptmp);
+		/* Ignore failure (happens if readonly or integer) */
+		setstr(pwd_s, ptmp, KSH_RETURN_ERROR);
+	} else {
+		set_current_wd(null);
+		pwd = Xstring(xs, xp);
+		/* XXX unset $PWD? */
+	}
+	if (printpath || cdnode)
+		shprintf("%s\n", pwd);
+
+	afree(allocd, ATEMP);
+	return (0);
+}
+
+
 #ifdef TIOCSCTTY
 extern void chvt_reinit(void);
 
@@ -1276,48 +1813,58 @@
 			if (stat(dv, &sb)) {
 				strlcpy(dv + 8, fn, sizeof(dv) - 8);
 				if (stat(dv, &sb))
-					errorf("chvt: can't find tty %s", fn);
+					errorf("%s: %s %s", "chvt",
+					    "can't find tty", fn);
 			}
 			fn = dv;
 		}
 		if (!(sb.st_mode & S_IFCHR))
-			errorf("chvt: not a char device: %s", fn);
+			errorf("%s %s %s", "chvt: not a char", "device", fn);
 		if ((sb.st_uid != 0) && chown(fn, 0, 0))
-			warningf(false, "chvt: cannot chown root %s", fn);
+			warningf(false, "%s: %s %s", "chvt", "can't chown root", fn);
 		if (((sb.st_mode & 07777) != 0600) && chmod(fn, (mode_t)0600))
-			warningf(false, "chvt: cannot chmod 0600 %s", fn);
+			warningf(false, "%s: %s %s", "chvt", "can't chmod 0600", fn);
 #if HAVE_REVOKE
 		if (revoke(fn))
 #endif
-			warningf(false, "chvt: cannot revoke %s, new shell is"
-			    " potentially insecure", fn);
+			warningf(false, "%s: %s %s", "chvt",
+			    "new shell is potentially insecure, can't revoke",
+			    fn);
 	}
 	if ((fd = open(fn, O_RDWR)) == -1) {
 		sleep(1);
 		if ((fd = open(fn, O_RDWR)) == -1)
-			errorf("chvt: cannot open %s", fn);
+			errorf("%s: %s %s", "chvt", "can't open", fn);
 	}
 	switch (fork()) {
 	case -1:
-		errorf("chvt: %s failed", "fork");
+		errorf("%s: %s %s", "chvt", "fork", "failed");
 	case 0:
 		break;
 	default:
 		exit(0);
 	}
 	if (setsid() == -1)
-		errorf("chvt: %s failed", "setsid");
+		errorf("%s: %s %s", "chvt", "setsid", "failed");
 	if (fn != dv + 1) {
 		if (ioctl(fd, TIOCSCTTY, NULL) == -1)
-			errorf("chvt: %s failed", "TIOCSCTTY");
+			errorf("%s: %s %s", "chvt", "TIOCSCTTY", "failed");
 		if (tcflush(fd, TCIOFLUSH))
-			errorf("chvt: %s failed", "TCIOFLUSH");
+			errorf("%s: %s %s", "chvt", "TCIOFLUSH", "failed");
 	}
 	ksh_dup2(fd, 0, false);
 	ksh_dup2(fd, 1, false);
 	ksh_dup2(fd, 2, false);
 	if (fd > 2)
 		close(fd);
+	{
+		register uint32_t h;
+
+		oaat1_init_impl(h);
+		oaat1_addmem_impl(h, &rndsetupstate, sizeof(rndsetupstate));
+		oaat1_fini_impl(h);
+		rndset((long)h);
+	}
 	chvt_reinit();
 }
 #endif
@@ -1518,15 +2065,15 @@
 		break;
 	case 'U':
 		i = 8;
-		if (0)
+		if (/* CONSTCOND */ 0)
 		/* FALLTHROUGH */
 	case 'u':
 		i = 4;
-		if (0)
+		if (/* CONSTCOND */ 0)
 		/* FALLTHROUGH */
 	case 'x':
 		i = cstyle ? -1 : 2;
-		/*
+		/**
 		 * x:	look for a hexadecimal number with up to
 		 *	two (C style: arbitrary) digits; convert
 		 *	to raw octet (C style: Unicode if >0xFF)
Index: src/bin/mksh/mksh.1
diff -u src/bin/mksh/mksh.1:1.217 src/bin/mksh/mksh.1:1.260
--- src/bin/mksh/mksh.1:1.217	Thu Feb 25 21:05:00 2010
+++ src/bin/mksh/mksh.1	Fri May  6 15:41:24 2011
@@ -1,7 +1,8 @@
-.\" $MirOS: src/bin/mksh/mksh.1,v 1.217 2010/02/25 21:05:00 tg Exp $
-.\" $OpenBSD: ksh.1,v 1.130 2010/02/25 13:45:54 schwarze Exp $
+.\" $MirOS: src/bin/mksh/mksh.1,v 1.260 2011/05/06 15:41:24 tg Exp $
+.\" $OpenBSD: ksh.1,v 1.140 2011/04/23 10:14:59 sobrado Exp $
 .\"-
-.\" Copyright © 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+.\" Copyright © 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+.\"		2010, 2011
 .\"	Thorsten Glaser <tg@mirbsd.org>
 .\"
 .\" Provided that these terms and disclaimer and all copyright notices
@@ -71,7 +72,7 @@
 .\" with -mandoc, it might implement .Mx itself, but we want to
 .\" use our own definition. And .Dd must come *first*, always.
 .\"
-.Dd $Mdocdate: February 25 2010 $
+.Dd $Mdocdate: May 6 2011 $
 .\"
 .\" Check which macro package we use
 .\"
@@ -154,10 +155,15 @@
 .Op Fl +abCefhiklmnprUuvXx
 .Op Fl T Ar /dev/ttyCn | \-
 .Op Fl +o Ar option
-.Oo Fl c Ar string \*(Ba Fl s \*(Ba
-.Ar \ file\ \&
-.Op Ar argument ... Oc
+.Oo
+.Fl c Ar string \*(Ba
+.Fl s \*(Ba
+.Ar file
+.Op Ar argument ...
+.Oc
 .Ek
+.Nm builtin-name
+.Op Ar argument ...
 .Sh DESCRIPTION
 .Nm
 is a command interpreter intended for both interactive and shell
@@ -166,6 +172,9 @@
 .Xr sh C
 shell language and largely compatible to the original Korn shell.
 .Pp
+Most builtins can be called directly, for example if a link points from its
+name to the shell; not all make sense, have been tested or work at all though.
+.Pp
 The options are as follows:
 .Bl -tag -width Ds
 .It Fl c Ar string
@@ -386,7 +395,7 @@
 is used in
 .Ic case
 statements;
-.Ql (( .. ))
+.Ql \&(( .. ))
 is used in arithmetic expressions;
 and lastly,
 .Ql \&( .. )\&
@@ -595,21 +604,12 @@
 word of a command (i.e. they can't be preceded by parameter assignments or
 redirections):
 .Bd -literal -offset indent
-case     else     function     then      !
-do       esac     if           time      [[
+case     else     function     then      !       (
+do       esac     if           time      [[      ((
 done     fi       in           until     {
 elif     for      select       while     }
 .Ed
 .Pp
-.Sy Note :
-Some shells (but not this one) execute control structure commands in a
-subshell when one or more of their file descriptors are redirected, so any
-environment changes inside them may fail.
-To be portable, the
-.Ic exec
-statement should be used instead to redirect file descriptors before the
-control structure.
-.Pp
 In the following compound command descriptions, command lists (denoted as
 .Em list )
 that are followed by reserved words must end with a semicolon, a newline, or
@@ -641,7 +641,7 @@
 .Ql }
 are reserved words, not meta-characters.
 .It Xo case Ar word No in
-.Oo Op (
+.Oo Op \&(
 .Ar \ pattern
 .Op \*(Ba Ar pattern
 .No ... No )
@@ -833,7 +833,7 @@
 Note that redirections specified after a function definition are
 performed whenever the function is executed, not when the function definition
 is executed.
-.It Ar name Ns () Ar command
+.It Ar name Ns \&() Ar command
 Mostly the same as
 .Ic function
 (see
@@ -842,11 +842,11 @@
 Whitespace (space or tab) after
 .Ar name
 will be ignored most of the time.
-.It Xo function Ar name Ns ()
+.It Xo function Ar name Ns \&()
 .No { Ar list ; No }
 .Xc
 The same as
-.Ar name Ns ()
+.Ar name Ns \&()
 .Pq Nm bash Ns ism .
 The
 .Ic function
@@ -859,7 +859,7 @@
 reserved word is described in the
 .Sx Command execution
 section.
-.It (( Ar expression No ))
+.It \&(( Ar expression No ))
 The arithmetic expression
 .Ar expression
 is evaluated; equivalent to
@@ -897,22 +897,6 @@
 .Sq \&! )
 must be unquoted.
 .It
-The second operand of the
-.Sq !=
-and
-.Sq =
-expressions are patterns (e.g. the comparison
-.Ic [[ foobar = f*r ]]
-succeeds).
-.It
-The single argument form of
-.Ic test ,
-which tests if the argument has a non-zero length, is not portable,
-e.g. instead of
-.No \&[ Ar str No \&]
-use
-.No \&[[ \-n Ar str No \&]] .
-.It
 Parameter, command, and arithmetic substitutions are performed as expressions
 are evaluated and lazy expression evaluation is used for the
 .Ql &&
@@ -927,6 +911,23 @@
 .Bd -literal -offset indent
 $ [[ \-r foo && $(\*(Ltfoo) = b*r ]]
 .Ed
+.It
+The second operand of the
+.Sq !=
+and
+.Sq =
+expressions are patterns (e.g. the comparison
+.Ic \&[[ foobar = f*r ]]
+succeeds).
+This even works indirectly:
+.Bd -literal -offset indent
+$ bar=foobar; baz=\*(aqf*r\*(aq
+$ [[ $bar = $baz ]]; echo $?
+$ [[ $bar = "$baz" ]]; echo $?
+.Ed
+.Pp
+Perhaps surprisingly, the first comparision succeeds,
+whereas the second doesn't.
 .El
 .El
 .Ss Quoting
@@ -976,6 +977,9 @@
 C style backslash expansion (see below) is applied (even single quote
 characters inside can be escaped and do not terminate the string then);
 the expanded result is treated as any other single-quoted string.
+If a double-quoted string is preceded by an unquoted
+.Ql $ ,
+the latter is ignored.
 .Ss Backslash expansion
 In places where backslashes are expanded, certain C and
 .At
@@ -1042,7 +1046,7 @@
 where
 .Dq #
 is any octet, translates to Ctrl-# (which basically means,
-.Ql \ec\*(TI
+.Ql \ec?
 becomes DEL, everything else is bitwise ANDed with 0x1F).
 Finally,
 .Ql \e# ,
@@ -1232,15 +1236,25 @@
 Note that
 .Ic $(\*(Ltfoo)
 has the same effect as
-.Ic $(cat foo) ,
-but it is carried out more efficiently because no process is started.
+.Ic $(cat foo) .
 .Pp
-.Sy Note :
-.Pf $( Ns Ar command Ns \&)
-expressions are currently parsed by finding matching parentheses,
-regardless of quoting; comments containing quote characters are
-not handled correctly.
-This should be fixed soon.
+Note that some shells do not use a recursive parser for command substitutions,
+leading to failure for certain constructs; to be portable, use as workaround
+.Ql x=$(cat) \*(Lt\*(Lt"EOF"
+(or the newline-keeping
+.Ql x=\*(Lt\*(Lt"EOF"
+extension) instead to merely slurp the string.
+.St -p1003.1
+recommends to use case statements of the form
+.Ql "x=$(case $foo in (bar) echo $bar ;; (*) echo $baz ;; esac)"
+instead, which would work but not serve as example for this portability issue.
+.Bd -literal -offset indent
+x=$(case $foo in bar) echo $bar ;; *) echo $baz ;; esac)
+# above fails to parse on old shells; below is the workaround
+x=$(eval $(cat)) \*(Lt\*(Lt"EOF"
+case $foo in bar) echo $bar ;; *) echo $baz ;; esac
+EOF
+.Ed
 .Pp
 Arithmetic substitutions are replaced by the value of the specified expression.
 For example, the command
@@ -1265,10 +1279,11 @@
 where
 .Ar expr
 is an arithmetic expression.
-Array indices are currently limited to the range 0 through 4294967295, (for
+Array indices in
 .Nm
-only; portable maximum is 1023), inclusive.
+are limited to the range 0 through 4294967295, inclusive.
 That is, they are a 32-bit unsigned integer.
+.Pp
 Parameter substitutions take the form
 .Pf $ Ns Ar name ,
 .Pf ${ Ns Ar name Ns } ,
@@ -1279,6 +1294,11 @@
 where
 .Ar name
 is a parameter name.
+Substitution of all array elements with
+.Pf ${ Ns Ar name Ns \&[*]}
+and
+.Pf ${ Ns Ar name Ns \&[@]}
+works equivalent to $* and $@ for positional parameters.
 If substitution is performed on a parameter
 (or an array parameter element)
 that is not set, a null string is substituted unless the
@@ -1312,6 +1332,9 @@
 Note that both the parameter name and the
 .Ql =
 must be unquoted for the shell to recognise a parameter assignment.
+The construct
+.Ic FOO+=baz
+is also recognised; the old and new values are immediately concatenated.
 The fourth way of setting a parameter is with the
 .Ic export ,
 .Ic readonly ,
@@ -1419,9 +1442,11 @@
 Note that, for all of the above,
 .Ar word
 is actually considered quoted, and special parsing rules apply.
-The parsing rules also differ on whether the expression is
-double-quoted with respect to the single quote
-.Pq Dq \*(aq .
+The parsing rules also differ on whether the expression is double-quoted:
+.Ar word
+then uses double-quoting rules, except for the double quote itself
+.Pq Sq \&"
+and the closing brace, which, if backslash escaped, gets quote removal applied.
 .Pp
 In the above modifiers, the
 .Ql \&:
@@ -1436,7 +1461,9 @@
 .Ar word
 is not needed, it is not evaluated.
 .Pp
-The following forms of parameter substitution can also be used:
+The following forms of parameter substitution can also be used (if
+.Ar name
+is an array, its element #0 will be substituted in a scalar context):
 .Pp
 .Bl -tag -width Ds -compact
 .It Pf ${# Ns Ar name Ns \&}
@@ -1450,8 +1477,8 @@
 of the string value of parameter
 .Ar name .
 .Pp
-.It Pf ${# Ns Ar name Ns [*]}
-.It Pf ${# Ns Ar name Ns [@]}
+.It Pf ${# Ns Ar name Ns \&[*]}
+.It Pf ${# Ns Ar name Ns \&[@]}
 The number of elements in the array
 .Ar name .
 .Pp
@@ -1460,7 +1487,7 @@
 .Pq in screen columns
 of the string value of parameter
 .Ar name ,
-or -1 if
+or \-1 if
 .Pf ${ Ns Ar name Ns }
 contains a control character.
 .Pp
@@ -1476,8 +1503,8 @@
 command (which is an alias for
 .Ic typeset Fl n ) .
 .Pp
-.It Pf ${! Ns Ar name Ns [*]}
-.It Pf ${! Ns Ar name Ns [@]}
+.It Pf ${! Ns Ar name Ns \&[*]}
+.It Pf ${! Ns Ar name Ns \&[@]}
 The names of indices (keys) in the array
 .Ar name .
 .Pp
@@ -1500,6 +1527,8 @@
 .Ql #
 results in the shortest match, and two
 of them result in the longest match.
+Cannot be applied to a vector
+.Pq ${*} or ${@} or ${array[*]} or ${array[@]} .
 .Pp
 .Sm off
 .It Xo
@@ -1512,6 +1541,7 @@
 .Xc
 .Sm on
 Like ${..#..} substitution, but it deletes from the end of the value.
+Cannot be applied to a vector.
 .Pp
 .Sm off
 .It Xo
@@ -1544,6 +1574,8 @@
 is omitted, the
 .Ar pattern
 is replaced by the empty string, i.e. deleted.
+Cannot be applied to a vector.
+Inefficiently implemented.
 .Pp
 .Sm off
 .It Xo
@@ -1579,16 +1611,27 @@
 Currently,
 .Ar pos
 must start with a space, opening parenthesis or digit to be recognised.
+Cannot be applied to a vector.
+.Pp
+.It Pf ${ Ns Ar name Ns @#}
+The internal hash of the expansion of
+.Ar name .
+At the moment, this is OAAT1 (Bob Jenkins' one-at-a-time hash with
+an initialisation value of 0x00000100), but this is not set.
+This is the hash the shell uses internally for its associative arrays.
 .El
 .Pp
 Note that
 .Ar pattern
-may need to be escaped as an extended globbing pattern
+may need extended globbing pattern
 .Pq @(...) ,
-with single quotes
+single
 .Pq \&\*(aq...\&\*(aq
-or double quotes
-.Pq \&"...\&" .
+or double
+.Pq \&"...\&"
+quote escaping unless
+.Fl o Ic sh
+is set.
 .Pp
 The following special parameters are implicitly set by the shell and cannot be
 set directly using assignments:
@@ -1661,8 +1704,9 @@
 .El
 .Pp
 The following parameters are set and/or used by the shell:
-.Bl -tag -width "EXECSHELL"
-.It Ev _ No (underscore)
+.Bl -tag -width "KSH_VERSION"
+.It Ev _
+.Pq underscore
 When an external command is executed by the shell, this parameter is set in the
 environment of the new process to the path of the executed command.
 In interactive use, this parameter is also set in the parent shell to the last
@@ -1768,6 +1812,12 @@
 .Sy Note :
 This parameter is not imported from the environment when the shell is
 started.
+.It Ev KSHEGID
+The effective group id of the shell.
+.It Ev KSHGID
+The real group id of the shell.
+.It Ev KSHUID
+The real user id of the shell.
 .It Ev KSH_VERSION
 The name and version of the shell (read-only).
 See also the version commands in
@@ -1808,6 +1858,9 @@
 (the current directory).
 .It Ev PGRP
 The process ID of the shell's process group leader.
+.It Ev PIPESTATUS
+An array containing the errorlevel (exit status) codes,
+one by one, of the last pipeline run in the foreground.
 .It Ev PPID
 The process ID of the shell's parent.
 .It Ev PS1
@@ -1887,6 +1940,13 @@
 x=$(print \e\e001)
 PS1="$x$(print \e\er)$x$(tput smso)$x\e$PWD$x$(tput rmso)$x\*(Gt "
 .Ed
+.Pp
+Due to pressure from David G. Korn,
+.Nm
+now also supports the following form:
+.Bd -literal -offset indent
+PS1=$'\e1\er\e1\ee[7m\e1$PWD\e1\ee[0m\e1\*(Gt '
+.Ed
 .It Ev PS2
 Secondary prompt string, by default
 .Sq \*(Gt\ \& ,
@@ -1911,14 +1971,10 @@
 .Dv NULL
 if the shell doesn't know where it is.
 .It Ev RANDOM
-Every time
+Each time
 .Ev RANDOM
-is referenced, it is assigned a 15-bit pseudo-random number, i.e. between
-0 and 32767, first, which is taken from
-.Xr arc4random 3
-if available,
-a Linear Congruential PRNG
-otherwise.
+is referenced, it is assigned a number between 0 and 32767 from
+a Linear Congruential PRNG first.
 .It Ev REPLY
 Default parameter for the
 .Ic read
@@ -2034,7 +2090,7 @@
 or
 .Ql \&!
 characters or
-.Dq [..]
+.Dq \&[..]
 sequences.
 Once brace expansion has been performed, the shell replaces file
 name patterns with the sorted names of all the files that match the pattern
@@ -2045,12 +2101,12 @@
 Matches any single character.
 .It \&*
 Matches any sequence of octets.
-.It [..]
+.It \&[..]
 Matches any of the octets inside the brackets.
 Ranges of octets can be specified by separating two octets by a
 .Ql \-
 (e.g.\&
-.Dq [a0\-9]
+.Dq \&[a0\-9]
 matches the letter
 .Sq a
 or any digit).
@@ -2065,7 +2121,7 @@
 .Ql \&!
 appearing at the start of the list has special meaning (see below), so to
 represent itself it must be quoted or appear later in the list.
-.It [!..]
+.It \&[!..]
 Like [..],
 except it matches any octet not inside the brackets.
 .Sm off
@@ -2164,10 +2220,6 @@
 option is set, any directories that result from file name generation are marked
 with a trailing
 .Ql / .
-.Pp
-The POSIX character classes (i.e.\&
-.Pf [: Ns Ar class-name Ns :]
-inside a [..] expression) are not implemented.
 .Ss Input/output redirection
 When a command is executed, its standard input, standard output, and standard
 error (file descriptors 0, 1, and 2, respectively) are normally inherited from
@@ -2178,7 +2230,7 @@
 input is initially set to be from
 .Pa /dev/null ,
 and commands for which any of the following redirections have been specified:
-.Bl -tag -width Ds
+.Bl -tag -width XXxxmarker
 .It \*(Gt Ar file
 Standard output is redirected to
 .Ar file .
@@ -2244,6 +2296,20 @@
 .Ql \&" .
 If multiple here documents are used on the same command line, they are saved in
 order.
+.Pp
+If no
+.Ar marker
+is given, the here document ends at the next
+.Ic \*(Lt\*(Lt
+and substitution will be performed.
+If
+.Ar marker
+is only a set of either single
+.Dq \*(aq\*(aq
+or double
+.Sq \&""
+quotes with nothing in between, the here document ends at the next empty line
+and substitution will not be performed.
 .It \*(Lt\*(Lt\- Ar marker
 Same as
 .Ic \*(Lt\*(Lt ,
@@ -2336,7 +2402,7 @@
 pipelines are created and in the order they are given, so the following
 will print an error with a line number prepended to it:
 .Pp
-.D1 $ cat /foo/bar 2\*(Gt&1 \*(Gt/dev/null \*(Ba cat \-n
+.D1 $ cat /foo/bar 2\*(Gt&1 \*(Gt/dev/null \*(Ba pr \-n \-t
 .Pp
 File descriptors created by input/output redirections are private to the
 Korn shell, but passed to sub-processes if
@@ -2610,7 +2676,7 @@
 Functions are defined using either Korn shell
 .Ic function Ar function-name
 syntax or the Bourne/POSIX shell
-.Ar function-name Ns ()
+.Ar function-name Ns \&()
 syntax (see below for the difference between the two forms).
 Functions are like
 .Li .\(hyscripts
@@ -2664,9 +2730,7 @@
 respectively.
 When a traced function is executed, the shell's
 .Ic xtrace
-option is turned on for the function's duration; otherwise, the
-.Ic xtrace
-option is turned off.
+option is turned on for the function's duration.
 The
 .Dq export
 attribute of functions is currently not used.
@@ -2698,7 +2762,7 @@
 .Ic function
 reserved word are treated differently in the following ways from functions
 defined with the
-.Ic ()
+.Ic \&()
 notation:
 .Bl -bullet
 .It
@@ -2787,10 +2851,10 @@
 .Nm
 regular commands
 .Pp
-.Ic \&[ , chdir , bind , echo ,
-.Ic let , mknod , print , printf ,
-.Ic pwd , realpath , rename , test ,
-.Ic ulimit , whence
+.Ic \&[ , chdir , bind , cat ,
+.Ic echo , let , mknod , print ,
+.Ic printf , pwd , realpath , rename ,
+.Ic sleep , test , ulimit , whence
 .Pp
 In the future, the additional
 .Nm
@@ -2965,11 +3029,35 @@
 .Ar level
 defaults to 1.
 .Pp
-.It Ic builtin Ar command Op Ar arg ...
+.It Xo
+.Ic builtin
+.Op Fl \-
+.Ar command Op Ar arg ...
+.Xc
 Execute the built-in command
 .Ar command .
 .Pp
 .It Xo
+.Ic cat
+.Op Fl u
+.Op Ar
+.Xc
+Read files sequentially, in command line order, and write them to
+standard output.
+If a
+.Ar file
+is a single dash
+.Pq Sq -
+or absent, read from standard input.
+If any options are given, an external
+.Xr cat 1
+utility is invoked instead if called from the shell.
+For direct builtin calls, the
+.Tn POSIX
+.Fl u
+option is supported as a no-op.
+.Pp
+.It Xo
 .Ic cd
 .Op Fl LP
 .Op Ar dir
@@ -3141,8 +3229,8 @@
 .Ic posix
 or
 .Ic sh
-option is set, only the first argument is treated as an option, and only
-if it is exactly
+option is set or this is a direct builtin call, only the first argument
+is treated as an option, and only if it is exactly
 .Dq Fl n .
 Backslash interpretation is disabled.
 .Pp
@@ -3412,7 +3500,7 @@
 If an error occurs during
 the parsing or evaluation of an expression, the exit status is greater than 1.
 Since expressions may need to be quoted,
-.No (( Ar expr No ))
+.No \&(( Ar expr No ))
 is syntactic sugar for
 .No let \&" Ns Ar expr Ns \&" .
 .Pp
@@ -3420,7 +3508,7 @@
 .Ic mknod
 .Op Fl m Ar mode
 .Ar name
-.Op Cm b \*(Ba Cm c
+.Cm b\*(Bac
 .Ar major minor
 .Xc
 .It Xo
@@ -3508,14 +3596,14 @@
 .Pp
 .It Ic printf Ar format Op Ar arguments ...
 Formatted output.
-The same as the utility
+Approximately the same as the utility
 .Xr printf 1 ,
-except that it may use the same
+except that it uses the same
 .Sx Backslash expansion
-code as the rest of
+and I/O code as the rest of
 .Nm mksh .
 This is not normally part of
-.Nm mksh ,
+.Nm mksh ;
 however, distributors may have added this as builtin as a speed hack.
 .Pp
 .It Ic pwd Op Fl LP
@@ -3539,6 +3627,7 @@
 .Pp
 .It Xo
 .Ic read
+.Op Fl d Ar delimiter
 .Op Fl prsu Ns Op Ar n
 .Op Ar parameter ...
 .Xc
@@ -3548,6 +3637,12 @@
 parameter (see
 .Sx Substitution
 above), and assigns each field to the specified parameters.
+Lines are delimited by the first character of
+.Ar delimiter ,
+.Dv NUL
+if empty, if
+.Fl d
+was used, a newline otherwise.
 If there are more parameters than fields, the extra parameters are set to
 .Dv NULL ,
 or alternatively, if there are more fields than parameters, the last parameter
@@ -3636,8 +3731,20 @@
 .Xc
 Prints the resolved absolute pathname corresponding to
 .Ar name .
+If
+.Ar name
+ends with a slash
+.Pq Sq / ,
+it's also checked for existence and whether it is a directory; otherwise,
+.Ic realpath
+returns 0 if the pathname either exists or can be created immediately,
+i.e. all but the last component exist and are directories.
 .Pp
-.It Ic rename Ar from to
+.It Xo
+.Ic rename
+.Op Fl \-
+.Ar from to
+.Xc
 Renames the file
 .Ar from
 to
@@ -3717,7 +3824,7 @@
 .At
 .Nm ksh93
 is:
-.Ic foo=(a b c)
+.Ic foo=(a b c); foo+=(d e)
 .Pp
 Another
 .At
@@ -3811,7 +3918,9 @@
 Enable UTF-8 support in the
 .Sx Emacs editing mode
 and internal string handling functions.
-This is enabled automatically for interactive shells if your system supports
+This flag is disabled by default, but can be enabled by setting it on the
+shell command line; is enabled automatically for interactive shells if
+requested at compile time, your system supports
 .Fn setlocale LC_CTYPE \&""
 and optionally
 .Fn nl_langinfo CODESET ,
@@ -3824,8 +3933,10 @@
 and at least one of these returns something that matches
 .Dq UTF\-8
 or
-.Dq utf8 ,
-or if the input begins with a UTF-8 Byte Order Mark.
+.Dq utf8
+case-insensitively; for direct builtin calls depending on the
+aforementioned environment variables; or for stdin or scripts,
+if the input begins with a UTF-8 Byte Order Mark.
 .It Fl u \*(Ba Ic nounset
 Referencing of an unset parameter, other than
 .Dq $@
@@ -3848,10 +3959,10 @@
 the value of
 .Ev PS4 .
 .It Ic arc4random
-If this shell option, which cannot be unset, exists,
-.Xr arc4random 3
-is used for the value of
-.Ev RANDOM .
+Deprecated, will be removed in
+.Nm
+R41.
+Do not use, emits a warning to stderr.
 .It Ic bgnice
 Background jobs are run with lower priority.
 .It Ic braceexpand
@@ -3993,6 +4104,12 @@
 .Ar number
 defaults to 1.
 .Pp
+.It Ic sleep Ar seconds
+Suspends execution for a minimum of the
+.Ar seconds
+specified as positive decimal value with an optional fractional part.
+Signal delivery may continue execution earlier.
+.Pp
 .It Ic source Ar file Op Ar arg ...
 Like
 .Ic \&. Po Do dot Dc Pc ,
@@ -4053,6 +4170,9 @@
 .It Fl g Ar file
 .Ar file Ns 's
 mode has the setgid bit set.
+.It Fl H Ar file
+.Ar file
+is a context dependent directory (only useful on HP-UX).
 .It Fl h Ar file
 .Ar file
 is a symbolic link.
@@ -4109,14 +4229,12 @@
 .It Fl s Ar file
 .Ar file
 is not empty.
-.It Fl t Op Ar fd
+.It Fl t Ar fd
 File descriptor
 .Ar fd
 is a
 .Xr tty 4
 device.
-.Ar fd
-may be left out, in which case it is taken to be 1.
 .It Fl u Ar file
 .Ar file Ns 's
 mode has the setuid bit set.
@@ -4229,8 +4347,12 @@
 .Sq Fl n .
 Use tests like
 .Dq if \&[ x\&"$foo\&" = x"bar" \&]
-instead, or the double-bracket operator:
+instead, or the double-bracket operator
 .Dq if \&[[ $foo = bar \&]]
+or, to avoid pattern matching (see
+.Ic \&[[
+above):
+.Dq if \&[[ $foo = "$bar" \&]]
 .Pp
 .It Xo
 .Ic time
@@ -4382,7 +4504,7 @@
 .Pq Ic + .
 Values for parameters may optionally be specified.
 For
-.Ar name Ns [*] ,
+.Ar name Ns \&[*] ,
 the change affects the entire array, and no value may be specified.
 If
 .Ic typeset
@@ -4541,7 +4663,7 @@
 .Pp
 .It Xo
 .Ic ulimit
-.Op Fl acdfHLlmnpSsTtvw
+.Op Fl aBCcdefHiLlMmnOPpqrSsTtVvw
 .Op Ar value
 .Xc
 Display or set process limits.
@@ -4564,6 +4686,13 @@
 Display all limits; unless
 .Fl H
 is used, soft limits are displayed.
+.It Fl B Ar n
+Set the socket buffer size to
+.Ar n
+kibibytes.
+.It Fl C Ar n
+Set the number of cached threads to
+.Ar n .
 .It Fl c Ar n
 Impose a size limit of
 .Ar n
@@ -4572,6 +4701,9 @@
 Impose a size limit of
 .Ar n
 kibibytes on the size of the data area.
+.It Fl e Ar n
+Set the maximum niceness to
+.Ar n .
 .It Fl f Ar n
 Impose a size limit of
 .Ar n
@@ -4579,12 +4711,19 @@
 size may be read).
 .It Fl H
 Set the hard limit only (the default is to set both hard and soft limits).
+.It Fl i Ar n
+Set the number of pending signals to
+.Ar n .
 .It Fl L Ar n
 Control flocks; documentation is missing.
 .It Fl l Ar n
 Impose a limit of
 .Ar n
 kibibytes on the amount of locked (wired) physical memory.
+.It Fl M Ar n
+Set the AIO locked memory to
+.Ar n
+kibibytes.
 .It Fl m Ar n
 Impose a limit of
 .Ar n
@@ -4593,10 +4732,25 @@
 Impose a limit of
 .Ar n
 file descriptors that can be open at once.
+.It Fl O Ar n
+Set the number of AIO operations to
+.Ar n .
+.It Fl P Ar n
+Limit the number of threads per process to
+.Ar n .
 .It Fl p Ar n
 Impose a limit of
 .Ar n
 processes that can be run by the user at any one time.
+.It Fl q Ar n
+Limit the size of
+.Tn POSIX
+message queues to
+.Ar n
+bytes.
+.It Fl r Ar n
+Set the maximum real-time priority to
+.Ar n .
 .It Fl S
 Set the soft limit only (the default is to set both hard and soft limits).
 .It Fl s Ar n
@@ -4611,6 +4765,9 @@
 Impose a time limit of
 .Ar n
 CPU seconds spent in user mode to be used by each process.
+.It Fl V Ar n
+Set the number of vnode monitors on Haiku to
+.Ar n .
 .It Fl v Ar n
 Impose a limit of
 .Ar n
@@ -4677,9 +4834,12 @@
 or functions
 .Pq Fl f .
 With
-.Ar parameter Ns [*] ,
+.Ar parameter Ns \&[*] ,
 attributes are kept, only values are unset.
 .Pp
+The exit status is non-zero if any of the parameters have the read-only
+attribute set, zero otherwise.
+.Pp
 .It Ic wait Op Ar job ...
 Wait for the specified job(s) to finish.
 The exit status of
@@ -4779,7 +4939,7 @@
 .Pp
 When a job is created, it is assigned a job number.
 For interactive shells, this number is printed inside
-.Dq [..] ,
+.Dq \&[..] ,
 followed by the process IDs of the processes in the job when an asynchronous
 command is run.
 A job may be referred to in the
@@ -5198,10 +5358,10 @@
 .Op Ar n
 .No \*(ha[. , \*(ha[_
 .Xc
-The last
-.Pq Ar n Ns th
-word of the previous (on repeated execution, second-last, third-last, etc.)
-command is inserted at the cursor.
+The last word, or, if given, the
+.Ar n Ns th
+word (zero-based) of the previous (on repeated execution, second-last,
+third-last, etc.) command is inserted at the cursor.
 Use of this editing command trashes the mark.
 .It quote: \*(ha\*(ha , \*(haV
 The following character is taken literally rather than as an editing command.
@@ -5855,6 +6015,7 @@
 Used only if
 .Ev ENV
 is unset or empty.
+The location can be changed at compile time (for embedded systems).
 .It Pa \*(TI/.profile
 User's login profile.
 .It Pa /etc/profile
@@ -5866,6 +6027,7 @@
 .El
 .Sh SEE ALSO
 .Xr awk 1 ,
+.Xr cat 1 ,
 .Xr ed 1 ,
 .Xr getopt 1 ,
 .Xr sed 1 ,
@@ -5881,7 +6043,6 @@
 .Xr pipe 2 ,
 .Xr rename 2 ,
 .Xr wait 2 ,
-.Xr arc4random 3 ,
 .Xr getopt 3 ,
 .Xr nl_langinfo 3 ,
 .Xr setlocale 3 ,
@@ -5969,37 +6130,30 @@
 .Sh CAVEATS
 .Nm
 only supports the Unicode BMP (Basic Multilingual Plane).
-Pipelines are executed in subshells.
 It has a different scope model from
 .At
 .Nm ksh ,
 which leads to subtile differences in semantics for identical builtins.
+.Pp
+The parts of a pipeline, like below, are executed in subshells.
+Thus, variable assignments inside them fail.
+Use co-processes instead.
+.Bd -literal -offset indent
+foo \*(Ba bar \*(Ba read baz            # will not change $baz
+foo \*(Ba bar \*(Ba& read \-p baz        # will, however, do so
+.Ed
 .Sh BUGS
 Suspending (using \*(haZ) pipelines like the one below will only suspend
 the currently running part of the pipeline; in this example,
 .Dq fubar
-is immediately printed on suspension (but not later).
-.Bd -literal -offset indent
-$ sleep 666 && echo fubar
-.Ed
-.Pp
-Some parts of the parser are not recursive; things like the following
-example will fail because of the parenthesis asymmetry:
-.Bd -literal -offset indent
-x=$(case $foo in bar) echo $bar ;; *) echo $baz ;; esac)
-.Ed
-.Pp
-Patches welcome.
-.Pp
-The parts of a pipeline, like below, are executed in subshells.
-Thus, variable assignments inside them fail.
-This is actually a feature; use co-processes instead.
+is immediately printed on suspension (but not later after an
+.Ic fg ) .
 .Bd -literal -offset indent
-foo \*(Ba bar \*(Ba read baz    # will not change $baz
+$ /bin/sleep 666 && echo fubar
 .Ed
 .Pp
 This document attempts to describe
-.Nm mksh\ R39c
+.Nm mksh\ R39c+CVS
 and up,
 compiled without any options impacting functionality, such as
 .Dv MKSH_SMALL ,
Index: src/bin/mksh/sh.h
diff -u src/bin/mksh/sh.h:1.383 src/bin/mksh/sh.h:1.469
--- src/bin/mksh/sh.h:1.383	Thu Feb 25 20:18:17 2010
+++ src/bin/mksh/sh.h	Fri May  6 15:41:25 2011
@@ -4,12 +4,12 @@
 /*	$OpenBSD: tree.h,v 1.10 2005/03/28 21:28:22 deraadt Exp $	*/
 /*	$OpenBSD: expand.h,v 1.6 2005/03/30 17:16:37 deraadt Exp $	*/
 /*	$OpenBSD: lex.h,v 1.11 2006/05/29 18:22:24 otto Exp $	*/
-/*	$OpenBSD: proto.h,v 1.32 2009/01/29 23:27:26 jaredy Exp $	*/
+/*	$OpenBSD: proto.h,v 1.33 2010/05/19 17:36:08 jasper Exp $	*/
 /*	$OpenBSD: c_test.h,v 1.4 2004/12/20 11:34:26 otto Exp $	*/
 /*	$OpenBSD: tty.h,v 1.5 2004/12/20 11:34:26 otto Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -68,9 +68,6 @@
 #include <setjmp.h>
 #include <signal.h>
 #include <stdarg.h>
-#if HAVE_STDBOOL_H
-#include <stdbool.h>
-#endif
 #include <stddef.h>
 #if HAVE_STDINT_H
 #include <stdint.h>
@@ -93,12 +90,12 @@
 
 #undef __attribute__
 #if HAVE_ATTRIBUTE_BOUNDED
-#define MKSH_A_BOUNDED(x,y,z)	__attribute__((bounded (x, y, z)))
+#define MKSH_A_BOUNDED(x,y,z)	__attribute__((__bounded__ (x, y, z)))
 #else
 #define MKSH_A_BOUNDED(x,y,z)	/* nothing */
 #endif
 #if HAVE_ATTRIBUTE_FORMAT
-#define MKSH_A_FORMAT(x,y,z)	__attribute__((format (x, y, z)))
+#define MKSH_A_FORMAT(x,y,z)	__attribute__((__format__ (x, y, z)))
 #else
 #define MKSH_A_FORMAT(x,y,z)	/* nothing */
 #endif
@@ -108,17 +105,17 @@
 #define MKSH_A_NONNULL(a)	/* nothing */
 #endif
 #if HAVE_ATTRIBUTE_NORETURN
-#define MKSH_A_NORETURN		__attribute__((noreturn))
+#define MKSH_A_NORETURN		__attribute__((__noreturn__))
 #else
 #define MKSH_A_NORETURN		/* nothing */
 #endif
 #if HAVE_ATTRIBUTE_UNUSED
-#define MKSH_A_UNUSED		__attribute__((unused))
+#define MKSH_A_UNUSED		__attribute__((__unused__))
 #else
 #define MKSH_A_UNUSED		/* nothing */
 #endif
 #if HAVE_ATTRIBUTE_USED
-#define MKSH_A_USED		__attribute__((used))
+#define MKSH_A_USED		__attribute__((__used__))
 #else
 #define MKSH_A_USED		/* nothing */
 #endif
@@ -141,18 +138,22 @@
 #undef __SCCSID
 #define __IDSTRING_CONCAT(l,p)		__LINTED__ ## l ## _ ## p
 #define __IDSTRING_EXPAND(l,p)		__IDSTRING_CONCAT(l,p)
+#ifdef MKSH_DONT_EMIT_IDSTRING
+#define __IDSTRING(prefix, string)	/* nothing */
+#else
 #define __IDSTRING(prefix, string)				\
 	static const char __IDSTRING_EXPAND(__LINE__,prefix) []	\
 	    MKSH_A_USED = "@(""#)" #prefix ": " string
+#endif
 #define __COPYRIGHT(x)		__IDSTRING(copyright,x)
 #define __RCSID(x)		__IDSTRING(rcsid,x)
 #define __SCCSID(x)		__IDSTRING(sccsid,x)
 #endif
 
 #ifdef EXTERN
-__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.383 2010/02/25 20:18:17 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.469 2011/05/06 15:41:25 tg Exp $");
 #endif
-#define MKSH_VERSION "R39 2010/02/25"
+#define MKSH_VERSION "R39 2011/05/06"
 
 #ifndef MKSH_INCLUDES_ONLY
 
@@ -181,11 +182,21 @@
 typedef void (*sig_t)(int);
 #endif
 
-#if !HAVE_STDBOOL_H
-/* kludge, but enough for mksh */
-typedef int bool;
-#define false 0
-#define true 1
+#if !HAVE_CAN_INTTYPES
+#if !HAVE_CAN_UCBINTS
+typedef signed int int32_t;
+typedef unsigned int uint32_t;
+#else
+typedef u_int32_t uint32_t;
+#endif
+#endif
+
+#if !HAVE_CAN_INT8TYPE
+#if !HAVE_CAN_UCBINT8
+typedef unsigned char uint8_t;
+#else
+typedef u_int8_t uint8_t;
+#endif
 #endif
 
 /* extra macros */
@@ -247,14 +258,13 @@
 #ifndef S_ISSOCK
 #define S_ISSOCK(m)	((m & 0170000) == 0140000)
 #endif
+#if !defined(S_ISCDF) && defined(S_CDF)
+#define S_ISCDF(m)	(S_ISDIR(m) && ((m) & S_CDF))
+#endif
 #ifndef DEFFILEMODE
 #define DEFFILEMODE	(S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
 #endif
 
-#if !defined(RLIMIT_VMEM) && defined(RLIMIT_AS)
-#define RLIMIT_VMEM	RLIMIT_AS
-#endif
-
 #if !defined(MAP_FAILED)
 /* XXX imake style */
 #  if defined(__linux)
@@ -276,16 +286,6 @@
 
 /* OS-dependent additions (functions, variables, by OS) */
 
-#if !HAVE_ARC4RANDOM_DECL
-extern u_int32_t arc4random(void);
-extern void arc4random_addrandom(unsigned char *, int)
-    MKSH_A_BOUNDED(string, 1, 2);
-#endif
-
-#if !HAVE_ARC4RANDOM_PUSHB_DECL
-extern uint32_t arc4random_pushb(const void *, size_t);
-#endif
-
 #if !HAVE_FLOCK_DECL
 extern int flock(int, int);
 #endif
@@ -298,11 +298,6 @@
 extern int revoke(const char *);
 #endif
 
-#if !HAVE_SETMODE
-mode_t getmode(const void *, mode_t);
-void *setmode(const char *);
-#endif
-
 #ifdef __ultrix
 /* XXX imake style */
 int strcasecmp(const char *, const char *);
@@ -327,6 +322,15 @@
 extern int __cdecl setegid(gid_t);
 #endif
 
+/* remove redundances */
+
+#if defined(MirBSD) && (MirBSD >= 0x08A8)
+#define MKSH_mirbsd_wcwidth
+#define utf_wcwidth(i) wcwidth((__WCHAR_TYPE__)i)
+extern int wcwidth(__WCHAR_TYPE__);
+#endif
+
+
 /* some useful #defines */
 #ifdef EXTERN
 # define I__(i) = i
@@ -346,6 +350,20 @@
 typedef int32_t mksh_ari_t;
 typedef uint32_t mksh_uari_t;
 
+/* boolean type (no <stdbool.h> deliberately) */
+typedef unsigned char mksh_bool;
+#undef bool
+/* false MUST equal 0 */
+#undef false
+#undef true
+/* access macros for boolean type */
+#define bool		mksh_bool
+/* values must have identity mapping between mksh_bool and short */
+#define false		0
+#define true		1
+/* make any-type into bool or short */
+#define tobool(cond)	((cond) ? true : false)
+
 /* these shall be smaller than 100 */
 #ifdef MKSH_CONSERVATIVE_FDS
 #define NUFILE		32	/* Number of user-accessible files */
@@ -365,25 +383,6 @@
 
 #define LINE		4096	/* input line size */
 
-EXTERN struct {
-	const char *kshname_;	/* $0 */
-	pid_t kshpid_;		/* $$, shell PID */
-	pid_t procpid_;		/* PID of executing process */
-	pid_t kshpgrp_;		/* process group of shell */
-	uid_t ksheuid_;		/* effective UID of shell */
-	pid_t kshppid_;		/* PID of parent of shell */
-	int exstat_;		/* exit status */
-	int subst_exstat_;	/* exit status of last $(..)/`..` */
-} kshstate_;
-#define kshname		kshstate_.kshname_
-#define kshpid		kshstate_.kshpid_
-#define procpid		kshstate_.procpid_
-#define kshpgrp		kshstate_.kshpgrp_
-#define ksheuid		kshstate_.ksheuid_
-#define kshppid		kshstate_.kshppid_
-#define exstat		kshstate_.exstat_
-#define subst_exstat	kshstate_.subst_exstat_
-
 EXTERN const char *safe_prompt; /* safe prompt if PS1 substitution fails */
 EXTERN const char initvsn[] I__("KSH_VERSION=@(#)MIRBSD KSH " MKSH_VERSION);
 #define KSH_VERSION	(initvsn + /* "KSH_VERSION=@(#)" */ 16)
@@ -497,10 +496,43 @@
 #define MKSH_S_NOVI		0
 #endif
 
+#if defined(MKSH_NOPROSPECTOFWORK) && !defined(MKSH_UNEMPLOYED)
+#define MKSH_UNEMPLOYED
+#endif
+
 /*
  * simple grouping allocator
  */
 
+
+/* 0. OS API: where to get memory from and how to free it (grouped) */
+
+/* malloc(3)/realloc(3) -> free(3) for use by the memory allocator */
+#define malloc_osi(sz)		malloc(sz)
+#define realloc_osi(p,sz)	realloc((p), (sz))
+#define free_osimalloc(p)	free(p)
+
+/* malloc(3)/realloc(3) -> free(3) for use by mksh code */
+#define malloc_osfunc(sz)	malloc(sz)
+#define realloc_osfunc(p,sz)	realloc((p), (sz))
+#define free_osfunc(p)		free(p)
+
+#if HAVE_MKNOD
+/* setmode(3) -> free(3) */
+#define free_ossetmode(p)	free(p)
+#endif
+
+#if !HAVE_MKSTEMP
+/* tempnam(3) -> free(3) */
+#define free_ostempnam(p)	free(p)
+#endif
+
+#ifdef NO_PATH_MAX
+/* GNU libc: get_current_dir_name(3) -> free(3) */
+#define free_gnu_gcdn(p)	free(p)
+#endif
+
+
 /* 1. internal structure */
 struct lalloc {
 	struct lalloc *next;
@@ -519,6 +551,18 @@
 #define ATEMP	&e->area
 
 /*
+ * flags (the order of these enums MUST match the order in misc.c(options[]))
+ */
+enum sh_flag {
+#define SHFLAGS_ENUMS
+#include "sh_flags.h"
+	FNFLAGS		/* (place holder: how many flags are there) */
+};
+
+#define Flag(f)	(shell_flags[(int)(f)])
+#define UTFMODE	Flag(FUNICODE)
+
+/*
  * parsing & execution environment
  */
 extern struct env {
@@ -565,6 +609,34 @@
 #define LSHELL	8	/* return to interactive shell() */
 #define LAEXPR	9	/* error in arithmetic expression */
 
+/* sort of shell global state */
+EXTERN pid_t procpid;		/* PID of executing process */
+EXTERN int exstat;		/* exit status */
+EXTERN int subst_exstat;	/* exit status of last $(..)/`..` */
+EXTERN struct tbl *vp_pipest;	/* global PIPESTATUS array */
+EXTERN short trap_exstat;	/* exit status before running a trap */
+EXTERN uint8_t trap_nested;	/* running nested traps */
+EXTERN uint8_t shell_flags[FNFLAGS];
+EXTERN const char *kshname;	/* $0 */
+EXTERN struct {
+	uid_t kshuid_;		/* real UID of shell */
+	uid_t ksheuid_;		/* effective UID of shell */
+	gid_t kshgid_;		/* real GID of shell */
+	gid_t kshegid_;		/* effective GID of shell */
+	pid_t kshpgrp_;		/* process group of shell */
+	pid_t kshppid_;		/* PID of parent of shell */
+	pid_t kshpid_;		/* $$, shell PID */
+} rndsetupstate;
+
+#define kshpid		rndsetupstate.kshpid_
+#define kshpgrp		rndsetupstate.kshpgrp_
+#define kshuid		rndsetupstate.kshuid_
+#define ksheuid		rndsetupstate.ksheuid_
+#define kshgid		rndsetupstate.kshgid_
+#define kshegid		rndsetupstate.kshegid_
+#define kshppid		rndsetupstate.kshppid_
+
+
 /* option processing */
 #define OF_CMDLINE	0x01	/* command line */
 #define OF_SET		0x02	/* set builtin */
@@ -580,30 +652,34 @@
 };
 extern const struct shoption options[];
 
-/*
- * flags (the order of these enums MUST match the order in misc.c(options[]))
- */
-enum sh_flag {
-#define SHFLAGS_ENUMS
-#include "sh_flags.h"
-	FNFLAGS		/* (place holder: how many flags are there) */
-};
-
-#define Flag(f)	(shell_flags[(int)(f)])
-#define UTFMODE	Flag(FUNICODE)
-
-EXTERN unsigned char shell_flags[FNFLAGS];
-
 /* null value for variable; comparision pointer for unset */
 EXTERN char null[] I__("");
 /* helpers for string pooling */
-#define T_synerr "syntax error"
-EXTERN const char r_fc_e_[] I__("r=fc -e -");
-#define fc_e_		(r_fc_e_ + 2)		/* "fc -e -" */
-#define fc_e_n		7			/* strlen(fc_e_) */
+EXTERN const char T_intovfl[] I__("integer overflow %lu %c %lu prevented");
+EXTERN const char T_oomem[] I__("can't allocate %lu data bytes");
+#if defined(__GNUC__)
+/* trust this to have string pooling; -Wformat bitches otherwise */
+#define T_synerr	"syntax error"
+#else
+EXTERN const char T_synerr[] I__("syntax error");
+#endif
+EXTERN const char T_select[] I__("select");
+EXTERN const char T_r_fc_e_[] I__("r=fc -e -");
+#define T_fc_e_		(T_r_fc_e_ + 2)		/* "fc -e -" */
+#define Tn_fc_e_	7			/* strlen(T_fc_e_) */
 EXTERN const char T_local_typeset[] I__("local=typeset");
 #define T__typeset	(T_local_typeset + 5)	/* "=typeset" */
 #define T_typeset	(T_local_typeset + 6)	/* "typeset" */
+EXTERN const char T_palias[] I__("+alias");
+#define T_alias		(T_palias + 1)		/* "alias" */
+EXTERN const char T_punalias[] I__("+unalias");
+#define T_unalias	(T_punalias + 1)	/* "unalias" */
+EXTERN const char T_sgset[] I__("*=set");
+#define T_set		(T_sgset + 2)		/* "set" */
+EXTERN const char T_gbuiltin[] I__("=builtin");
+#define T_builtin	(T_gbuiltin + 1)	/* "builtin" */
+EXTERN const char T__function[] I__(" function");
+#define T_function	(T__function + 1)	/* "function" */
 
 enum temp_type {
 	TT_HEREDOC_EXP,	/* expanded heredoc */
@@ -626,7 +702,7 @@
 #define shl_spare	(&shf_iob[0])	/* for c_read()/c_print() */
 #define shl_stdout	(&shf_iob[1])
 #define shl_out		(&shf_iob[2])
-EXTERN int shl_stdout_ok;
+EXTERN bool shl_stdout_ok;
 
 /*
  * trap handlers
@@ -662,16 +738,23 @@
 #define SS_RESTORE_IGN	3	/* restore to SIG_IGN */
 #define SS_FORCE	BIT(3)	/* set signal even if original signal ignored */
 #define SS_USER		BIT(4)	/* user is doing the set (ie, trap command) */
-#define SS_SHTRAP	BIT(5)	/* trap for internal use (CHLD,ALRM,WINCH) */
+#define SS_SHTRAP	BIT(5)	/* trap for internal use (ALRM, CHLD, WINCH) */
 
 #define SIGEXIT_	0	/* for trap EXIT */
 #define SIGERR_		NSIG	/* for trap ERR */
 
 EXTERN volatile sig_atomic_t trap;	/* traps pending? */
 EXTERN volatile sig_atomic_t intrsig;	/* pending trap interrupts command */
-EXTERN volatile sig_atomic_t fatal_trap;/* received a fatal signal */
+EXTERN volatile sig_atomic_t fatal_trap; /* received a fatal signal */
 extern	Trap	sigtraps[NSIG+1];
 
+/* got_winch = 1 when we need to re-adjust the window size */
+#ifdef SIGWINCH
+EXTERN volatile sig_atomic_t got_winch I__(1);
+#else
+#define got_winch	true
+#endif
+
 /*
  * TMOUT support
  */
@@ -702,9 +785,9 @@
 
 extern unsigned char chtypes[];
 
-#define ctype(c, t)	!!( ((t) == C_SUBOP2) ?				\
+#define ctype(c, t)	tobool( ((t) == C_SUBOP2) ?			\
 			    (((c) == '#' || (c) == '%') ? 1 : 0) :	\
-			    (chtypes[(unsigned char)(c)]&(t)) )
+			    (chtypes[(unsigned char)(c)] & (t)) )
 #define ksh_isalphx(c)	ctype((c), C_ALPHA)
 #define ksh_isalnux(c)	ctype((c), C_ALPHA | C_DIGIT)
 
@@ -723,13 +806,13 @@
 #define GI_MINUSMINUS	BIT(2)	/* arguments were ended with -- */
 
 typedef struct {
-	const char	*optarg;
-	int		optind;
-	int		uoptind;/* what user sees in $OPTIND */
-	int		flags;	/* see GF_* */
-	int		info;	/* see GI_* */
-	unsigned int	p;	/* 0 or index into argv[optind - 1] */
-	char		buf[2];	/* for bad option OPTARG value */
+	const char *optarg;
+	int optind;
+	int uoptind;		/* what user sees in $OPTIND */
+	int flags;		/* see GF_* */
+	int info;		/* see GI_* */
+	unsigned int p;		/* 0 or index into argv[optind - 1] */
+	char buf[2];		/* for bad option OPTARG value */
 } Getopt;
 
 EXTERN Getopt builtin_opt;	/* for shell builtin commands */
@@ -748,16 +831,17 @@
 };
 EXTERN struct coproc coproc;
 
-/* Used in jobs.c and by coprocess stuff in exec.c */
+#ifndef MKSH_NOPROSPECTOFWORK
+/* used in jobs.c and by coprocess stuff in exec.c and select() calls */
 EXTERN sigset_t		sm_default, sm_sigchld;
+#endif
 
 /* name of called builtin function (used by error functions) */
 EXTERN const char *builtin_argv0;
 EXTERN Tflag builtin_flag;	/* flags of called builtin (SPEC_BI, etc.) */
 
-/* current working directory, and size of memory allocated for same */
+/* current working directory */
 EXTERN char	*current_wd;
-EXTERN size_t	current_wd_size;
 
 /* Minimum required space to work with on a line - if the prompt leaves less
  * space than this on a line, the prompt is truncated.
@@ -860,7 +944,7 @@
 		char *s;		/* string */
 		mksh_ari_t i;		/* integer */
 		mksh_uari_t u;		/* unsigned integer */
-		int (*f)(const char **);/* int function */
+		int (*f)(const char **); /* int function */
 		struct op *t;		/* "function" tree */
 	} val;			/* value */
 	union {
@@ -900,7 +984,7 @@
 #define LCASEV		BIT(17)	/* convert to lower case */
 #define UCASEV_AL	BIT(18) /* convert to upper case / autoload function */
 #define INT_U		BIT(19)	/* unsigned integer */
-#define INT_L		BIT(20)	/* long integer (no-op) */
+#define INT_L		BIT(20)	/* long integer (no-op but used as magic) */
 #define IMPORT		BIT(21)	/* flag to typeset(): no arrays, must have = */
 #define LOCAL_COPY	BIT(22)	/* with LOCAL - copy attrs from existing var */
 #define EXPRINEVAL	BIT(23)	/* contents currently being evaluated */
@@ -1027,7 +1111,8 @@
 					 */
 	int lineno;			/* TCOM/TFUNC: LINENO for this */
 	short type;			/* operation type, see below */
-	union { /* WARNING: newtp(), tcopy() use evalflags = 0 to clear union */
+	union {
+		/* WARNING: newtp(), tcopy() use evalflags = 0 to clear union */
 		short evalflags;	/* TCOM: arg expansion eval() flags */
 		short ksh_func;		/* TFUNC: function x (vs x()) */
 	} u;
@@ -1079,27 +1164,29 @@
  * IO redirection
  */
 struct ioword {
-	int	unit;	/* unit affected */
-	int	flag;	/* action (below) */
-	char	*name;	/* file name (unused if heredoc) */
-	char	*delim;	/* delimiter for <<,<<- */
-	char	*heredoc;/* content of heredoc */
+	int	unit;		/* unit affected */
+	int	flag;		/* action (below) */
+	char	*name;		/* file name (unused if heredoc) */
+	char	*delim;		/* delimiter for <<,<<- */
+	char	*heredoc;	/* content of heredoc */
 };
 
 /* ioword.flag - type of redirection */
-#define IOTYPE	0xF	/* type: bits 0:3 */
-#define IOREAD	0x1	/* < */
-#define IOWRITE	0x2	/* > */
-#define IORDWR	0x3	/* <>: todo */
-#define IOHERE	0x4	/* << (here file) */
-#define IOCAT	0x5	/* >> */
-#define IODUP	0x6	/* <&/>& */
-#define IOEVAL	BIT(4)	/* expand in << */
-#define IOSKIP	BIT(5)	/* <<-, skip ^\t* */
-#define IOCLOB	BIT(6)	/* >|, override -o noclobber */
-#define IORDUP	BIT(7)	/* x<&y (as opposed to x>&y) */
-#define IONAMEXP BIT(8)	/* name has been expanded */
-#define IOBASH	BIT(9)	/* &> etc. */
+#define IOTYPE		0xF	/* type: bits 0:3 */
+#define IOREAD		0x1	/* < */
+#define IOWRITE		0x2	/* > */
+#define IORDWR		0x3	/* <>: todo */
+#define IOHERE		0x4	/* << (here file) */
+#define IOCAT		0x5	/* >> */
+#define IODUP		0x6	/* <&/>& */
+#define IOEVAL		BIT(4)	/* expand in << */
+#define IOSKIP		BIT(5)	/* <<-, skip ^\t* */
+#define IOCLOB		BIT(6)	/* >|, override -o noclobber */
+#define IORDUP		BIT(7)	/* x<&y (as opposed to x>&y) */
+#define IONAMEXP	BIT(8)	/* name has been expanded */
+#define IOBASH		BIT(9)	/* &> etc. */
+#define IOHERESTR	BIT(10)	/* <<< (here string) */
+#define IONDELIM	BIT(11)	/* null delimiter (<<) */
 
 /* execute/exchild flags */
 #define XEXEC	BIT(0)		/* execute without forking */
@@ -1114,6 +1201,7 @@
 #define XERROK	BIT(8)		/* non-zero exit ok (for set -e) */
 #define XCOPROC BIT(9)		/* starting a co-process */
 #define XTIME	BIT(10)		/* timing TCOM command */
+#define XPIPEST	BIT(11)		/* want PIPESTATUS */
 
 /*
  * flags to control expansion of words (assumed by t->evalflags to fit
@@ -1144,7 +1232,7 @@
 #define DB_BE	4	/* an inserted -BE */
 #define DB_PAT	5	/* a pattern argument */
 
-#define X_EXTRA	8	/* this many extra bytes in X string */
+#define X_EXTRA	20	/* this many extra bytes in X string */
 
 typedef struct XString {
 	char *end, *beg;	/* end, begin of string */
@@ -1173,7 +1261,7 @@
 #define XcheckN(xs, xp, n) do {					\
 	int more = ((xp) + (n)) - (xs).end;			\
 	if (more > 0)						\
-		(xp) = Xcheck_grow_(&(xs), (xp), more);		\
+		(xp) = Xcheck_grow_(&(xs), (xp), (size_t)more);	\
 } while (/* CONSTCOND */ 0)
 
 /* check for overflow, expand string */
@@ -1194,7 +1282,7 @@
 #define Xsavepos(xs, xp)	((xp) - (xs).beg)
 #define Xrestpos(xs, xp, n)	((xs).beg + (n))
 
-char *Xcheck_grow_(XString *, const char *, unsigned int);
+char *Xcheck_grow_(XString *, const char *, size_t);
 
 /*
  * expandable vector of generic pointers
@@ -1207,7 +1295,7 @@
 
 #define XPinit(x, n) do {					\
 	void **vp__;						\
-	vp__ = alloc((n) * sizeof(void *), ATEMP);		\
+	vp__ = alloc2((n), sizeof(void *), ATEMP);		\
 	(x).cur = (x).beg = vp__;				\
 	(x).end = vp__ + (n);					\
 } while (/* CONSTCOND */ 0)
@@ -1215,8 +1303,8 @@
 #define XPput(x, p) do {					\
 	if ((x).cur >= (x).end) {				\
 		size_t n = XPsize(x);				\
-		(x).beg = aresize((x).beg,			\
-		    n * 2 * sizeof(void *), ATEMP);		\
+		(x).beg = aresize2((x).beg,			\
+		    n, 2 * sizeof(void *), ATEMP);		\
 		(x).cur = (x).beg + n;				\
 		(x).end = (x).cur + n;				\
 	}							\
@@ -1225,7 +1313,7 @@
 
 #define XPptrv(x)	((x).beg)
 #define XPsize(x)	((x).cur - (x).beg)
-#define XPclose(x)	aresize((x).beg, XPsize(x) * sizeof(void *), ATEMP)
+#define XPclose(x)	aresize2((x).beg, XPsize(x), sizeof(void *), ATEMP)
 #define XPfree(x)	afree((x).beg, ATEMP)
 
 #define IDENT	64
@@ -1268,8 +1356,7 @@
 #define SF_ALIAS	BIT(1)	/* faking space at end of alias */
 #define SF_ALIASEND	BIT(2)	/* faking space at end of alias */
 #define SF_TTY		BIT(3)	/* type == SSTDIN & it is a tty */
-#define SF_FIRST	BIT(4)	/* initial state (to ignore UTF-8 BOM) */
-#define SF_HASALIAS	BIT(5)	/* u.tblp valid (SALIAS, SEOF) */
+#define SF_HASALIAS	BIT(4)	/* u.tblp valid (SALIAS, SEOF) */
 
 typedef union {
 	int i;
@@ -1342,12 +1429,53 @@
 /* user and system time of last j_waitjed job */
 EXTERN struct timeval j_usrtime, j_systime;
 
+#define notoktomul(fac1, fac2)	((fac1) && (fac2) && \
+				    (SIZE_MAX / (fac1) < (fac2)))
+#define notoktoadd(val, cnst)	((val) > (SIZE_MAX - (cnst)))
+#define checkoktoadd(val, cnst) do {					\
+	if (notoktoadd((val), (cnst)))					\
+		internal_errorf(T_intovfl, (unsigned long)(val),	\
+		    '+', (unsigned long)(cnst));			\
+} while (/* CONSTCOND */ 0)
+
+/* Bob Jenkins' one-at-a-time hash, with better start value */
+#define oaat1_init_impl(h) do {						\
+	(h) = 0x100;							\
+} while (/* CONSTCOND */ 0)
+#define oaat1_addmem_impl(h, buf, len) do {				\
+	register const uint8_t *oaat1_addmem_p = (const void *)(buf);	\
+	register size_t oaat1_addmem_n = (len);				\
+									\
+	while (oaat1_addmem_n--) {					\
+		(h) += *oaat1_addmem_p++;				\
+		(h) += (h) << 10;					\
+		(h) ^= (h) >> 6;					\
+	}								\
+} while (/* CONSTCOND */ 0)
+#define oaat1_addstr_impl(h, s) do {					\
+	register const uint8_t *oaat1_addstr_p = (const void *)(s);	\
+	register uint8_t oaat1_addstr_c;				\
+									\
+	while ((oaat1_addstr_c = *oaat1_addstr_p++)) {			\
+		h += oaat1_addstr_c;					\
+		(h) += (h) << 10;					\
+		(h) ^= (h) >> 6;					\
+	}								\
+} while (/* CONSTCOND */ 0)
+#define oaat1_fini_impl(h) do {						\
+	(h) += (h) << 3;						\
+	(h) ^= (h) >> 11;						\
+	(h) += (h) << 15;						\
+} while (/* CONSTCOND */ 0)
+
 /* lalloc.c */
 void ainit(Area *);
 void afreeall(Area *);
 /* these cannot fail and can take NULL (not for ap) */
-#define alloc(n, ap)	aresize(NULL, (n), (ap))
+#define alloc(n, ap)		aresize(NULL, (n), (ap))
+#define alloc2(m, n, ap)	aresize2(NULL, (m), (n), (ap))
 void *aresize(void *, size_t, Area *);
+void *aresize2(void *, size_t, size_t, Area *);
 void afree(void *, Area *);	/* can take NULL */
 /* edit.c */
 #ifndef MKSH_SMALL
@@ -1370,9 +1498,9 @@
 int shcomexec(const char **);
 struct tbl *findfunc(const char *, uint32_t, bool);
 int define(const char *, struct op *);
-void builtin(const char *, int (*)(const char **));
+const char *builtin(const char *, int (*)(const char **));
 struct tbl *findcom(const char *, int);
-void flushcom(int);
+void flushcom(bool);
 const char *search(const char *, const char *, int, int *);
 int search_access(const char *, int, int *);
 int pr_menu(const char * const *);
@@ -1387,10 +1515,11 @@
 int utf_mbswidth(const char *);
 const char *utf_skipcols(const char *, int);
 size_t utf_ptradj(const char *);
+#ifndef MKSH_mirbsd_wcwidth
 int utf_wcwidth(unsigned int);
+#endif
 /* funcs.c */
 int c_hash(const char **);
-int c_cd(const char **);
 int c_pwd(const char **);
 int c_print(const char **);
 #ifdef MKSH_PRINTF_BUILTIN
@@ -1427,13 +1556,16 @@
 int timex(struct op *, int, volatile int *);
 void timex_hook(struct op *, char ** volatile *);
 int c_exec(const char **);
-int c_builtin(const char **);
+/* dummy function (just need pointer value), special case in comexec() */
+#define c_builtin shcomexec
 int c_test(const char **);
 #if HAVE_MKNOD
 int c_mknod(const char **);
 #endif
 int c_realpath(const char **);
 int c_rename(const char **);
+int c_cat(const char **);
+int c_sleep(const char **);
 /* histrap.c */
 void init_histvec(void);
 void hist_init(Source *);
@@ -1452,7 +1584,6 @@
 char **histpos(void);
 int histnum(int);
 int findhist(int, int, const char *, int);
-int findhistrel(const char *);
 char **hist_get_newest(bool);
 void inittraps(void);
 void alarm_init(void);
@@ -1462,7 +1593,7 @@
 int fatal_trap_check(void);
 int trap_pending(void);
 void runtraps(int intr);
-void runtrap(Trap *);
+void runtrap(Trap *, bool);
 void cleartraps(void);
 void restoresigs(void);
 void settrap(Trap *, const char *);
@@ -1485,7 +1616,6 @@
 int j_resume(const char *, int);
 #endif
 int j_jobs(const char *, int, int);
-int j_njobs(void);
 void j_notify(void);
 pid_t j_async(void);
 int j_stopped_running(void);
@@ -1493,14 +1623,14 @@
 int yylex(int);
 void yyerror(const char *, ...)
     MKSH_A_NORETURN
-    MKSH_A_FORMAT(printf, 1, 2);
+    MKSH_A_FORMAT(__printf__, 1, 2);
 Source *pushs(int, Area *);
 void set_prompt(int, Source *);
 void pprompt(const char *, int);
 int promptlen(const char *);
 /* main.c */
 int include(const char *, int, const char **, int);
-int command(const char *);
+int command(const char *, int);
 int shell(Source *volatile, int volatile);
 void unwind(int) MKSH_A_NORETURN;
 void newenv(int);
@@ -1509,25 +1639,27 @@
 void cleanup_proc_env(void);
 void errorf(const char *, ...)
     MKSH_A_NORETURN
-    MKSH_A_FORMAT(printf, 1, 2);
+    MKSH_A_FORMAT(__printf__, 1, 2);
+void errorfx(int, const char *, ...)
+    MKSH_A_NORETURN
+    MKSH_A_FORMAT(__printf__, 2, 3);
 void warningf(bool, const char *, ...)
-    MKSH_A_FORMAT(printf, 2, 3);
+    MKSH_A_FORMAT(__printf__, 2, 3);
 void bi_errorf(const char *, ...)
-    MKSH_A_FORMAT(printf, 1, 2);
+    MKSH_A_FORMAT(__printf__, 1, 2);
 #define errorfz()	errorf("\1")
+#define errorfxz(rc)	errorfx((rc), "\1")
 #define bi_errorfz()	bi_errorf("\1")
-void internal_verrorf(const char *, va_list)
-    MKSH_A_FORMAT(printf, 1, 0);
 void internal_errorf(const char *, ...)
     MKSH_A_NORETURN
-    MKSH_A_FORMAT(printf, 1, 2);
+    MKSH_A_FORMAT(__printf__, 1, 2);
 void internal_warningf(const char *, ...)
-    MKSH_A_FORMAT(printf, 1, 2);
+    MKSH_A_FORMAT(__printf__, 1, 2);
 void error_prefix(bool);
 void shellf(const char *, ...)
-    MKSH_A_FORMAT(printf, 1, 2);
+    MKSH_A_FORMAT(__printf__, 1, 2);
 void shprintf(const char *, ...)
-    MKSH_A_FORMAT(printf, 1, 2);
+    MKSH_A_FORMAT(__printf__, 1, 2);
 int can_seek(int);
 void initio(void);
 int ksh_dup2(int, int, bool);
@@ -1543,9 +1675,6 @@
 int coproc_getfd(int, const char **);
 void coproc_cleanup(int);
 struct temp *maketemp(Area *, Temp_type, struct temp **);
-#define hash(s) oaathash_full((const uint8_t *)(s))
-uint32_t oaathash_full(register const uint8_t *);
-uint32_t hashmem(const void *, size_t);
 void ktinit(struct table *, Area *, size_t);
 struct tbl *ktsearch(struct table *, const char *, uint32_t);
 struct tbl *ktenter(struct table *, const char *, uint32_t);
@@ -1564,22 +1693,23 @@
 int bi_getn(const char *, int *);
 int gmatchx(const char *, const char *, bool);
 int has_globbing(const char *, const char *);
-const unsigned char *pat_scan(const unsigned char *, const unsigned char *, int);
 int xstrcmp(const void *, const void *);
 void ksh_getopt_reset(Getopt *, int);
 int ksh_getopt(const char **, Getopt *, const char *);
 void print_value_quoted(const char *);
+char *quote_value(const char *);
 void print_columns(struct shf *, int,
     char *(*)(char *, int, int, const void *),
     const void *, int, int, bool);
 void strip_nuls(char *, int);
-int blocking_read(int, char *, int)
-    MKSH_A_BOUNDED(buffer, 2, 3);
+ssize_t blocking_read(int, char *, size_t)
+    MKSH_A_BOUNDED(__buffer__, 2, 3);
 int reset_nonblock(int);
-char *ksh_get_wd(size_t *);
-int make_path(const char *, const char *, char **, XString *, int *);
+char *ksh_get_wd(void);
+char *do_realpath(const char *);
 void simplify_path(char *);
-void set_current_wd(char *);
+void set_current_wd(const char *);
+int c_cd(const char **);
 #ifdef MKSH_SMALL
 char *strdup_(const char *, Area *);
 char *strndup_(const char *, size_t, Area *);
@@ -1602,25 +1732,36 @@
 int shf_puts(const char *, struct shf *);
 int shf_write(const char *, int, struct shf *);
 int shf_fprintf(struct shf *, const char *, ...)
-    MKSH_A_FORMAT(printf, 2, 3);
+    MKSH_A_FORMAT(__printf__, 2, 3);
 int shf_snprintf(char *, int, const char *, ...)
-    MKSH_A_FORMAT(printf, 3, 4)
-    MKSH_A_BOUNDED(string, 1, 2);
+    MKSH_A_FORMAT(__printf__, 3, 4)
+    MKSH_A_BOUNDED(__string__, 1, 2);
 char *shf_smprintf(const char *, ...)
-    MKSH_A_FORMAT(printf, 1, 2);
+    MKSH_A_FORMAT(__printf__, 1, 2);
 int shf_vfprintf(struct shf *, const char *, va_list)
-    MKSH_A_FORMAT(printf, 2, 0);
+    MKSH_A_FORMAT(__printf__, 2, 0);
 /* syn.c */
 void initkeywords(void);
-struct op *compile(Source *);
+struct op *compile(Source *, bool);
+bool parse_usec(const char *, struct timeval *);
+char *yyrecursive(void);
 /* tree.c */
-int fptreef(struct shf *, int, const char *, ...);
+void fptreef(struct shf *, int, const char *, ...);
 char *snptreef(char *, int, const char *, ...);
 struct op *tcopy(struct op *, Area *);
 char *wdcopy(const char *, Area *);
 const char *wdscan(const char *, int);
-char *wdstrip(const char *, bool, bool);
+#define WDS_TPUTS	BIT(0)		/* tputS (dumpwdvar) mode */
+#define WDS_KEEPQ	BIT(1)		/* keep quote characters */
+#define WDS_MAGIC	BIT(2)		/* make MAGIC */
+char *wdstrip(const char *, int);
 void tfree(struct op *, Area *);
+void dumpchar(struct shf *, int);
+void dumptree(struct shf *, struct op *);
+void dumpwdvar(struct shf *, const char *);
+void vistree(char *, size_t, struct op *)
+    MKSH_A_BOUNDED(__string__, 1, 2);
+void fpFUNCTf(struct shf *, int, bool, const char *, struct op *);
 /* var.c */
 void newblock(void);
 void popblock(void);
@@ -1632,20 +1773,19 @@
 struct tbl *setint_v(struct tbl *, struct tbl *, bool);
 void setint(struct tbl *, mksh_ari_t);
 struct tbl *typeset(const char *, Tflag, Tflag, int, int)
-    MKSH_A_NONNULL((nonnull (1)));
+    MKSH_A_NONNULL((__nonnull__ (1)));
 void unset(struct tbl *, int);
 const char *skip_varname(const char *, int);
 const char *skip_wdvarname(const char *, int);
 int is_wdvarname(const char *, int);
 int is_wdvarassign(const char *);
 char **makenv(void);
-#if !HAVE_ARC4RANDOM
-void change_random(const void *, size_t);
-#endif
 void change_winsz(void);
 int array_ref_len(const char *);
 char *arrayname(const char *);
 mksh_uari_t set_array(const char *, bool, const char **);
+uint32_t hash(const void *);
+void rndset(long);
 
 enum Test_op {
 	TO_NONOP = 0,	/* non-operator */
@@ -1658,7 +1798,9 @@
 	TO_FILRD, TO_FILGZ, TO_FILTT, TO_FILSETU, TO_FILWR, TO_FILEX,
 	/* binary operators */
 	TO_STEQL, TO_STNEQ, TO_STLT, TO_STGT, TO_INTEQ, TO_INTNE, TO_INTGT,
-	TO_INTGE, TO_INTLT, TO_INTLE, TO_FILEQ, TO_FILNT, TO_FILOT
+	TO_INTGE, TO_INTLT, TO_INTLE, TO_FILEQ, TO_FILNT, TO_FILOT,
+	/* not an operator */
+	TO_NONNULL	/* !TO_NONOP */
 };
 typedef enum Test_op Test_op;
 
@@ -1678,19 +1820,18 @@
 #define TEF_ERROR	BIT(0)		/* set if we've hit an error */
 #define TEF_DBRACKET	BIT(1)		/* set if [[ .. ]] test */
 
-typedef struct test_env Test_env;
-struct test_env {
+typedef struct test_env {
 	union {
-		const char **wp;/* used by ptest_* */
-		XPtrV *av;	/* used by dbtestp_* */
+		const char **wp;	/* used by ptest_* */
+		XPtrV *av;		/* used by dbtestp_* */
 	} pos;
-	const char **wp_end;	/* used by ptest_* */
-	int (*isa)(Test_env *, Test_meta);
-	const char *(*getopnd) (Test_env *, Test_op, bool);
-	int (*eval)(Test_env *, Test_op, const char *, const char *, bool);
-	void (*error)(Test_env *, int, const char *);
-	int flags;		/* TEF_* */
-};
+	const char **wp_end;		/* used by ptest_* */
+	Test_op (*isa)(struct test_env *, Test_meta);
+	const char *(*getopnd) (struct test_env *, Test_op, bool);
+	int (*eval)(struct test_env *, Test_op, const char *, const char *, bool);
+	void (*error)(struct test_env *, int, const char *);
+	int flags;			/* TEF_* */
+} Test_env;
 
 extern const char *const dbtest_tokens[];
 
@@ -1699,7 +1840,7 @@
 int test_parse(Test_env *);
 
 EXTERN int tty_fd I__(-1);	/* dup'd tty file descriptor */
-EXTERN int tty_devtty;		/* true if tty_fd is from /dev/tty */
+EXTERN bool tty_devtty;		/* true if tty_fd is from /dev/tty */
 EXTERN struct termios tty_state;	/* saved tty state */
 
 extern void tty_init(bool, bool);
Index: src/bin/mksh/sh_flags.h
diff -u src/bin/mksh/sh_flags.h:1.5 src/bin/mksh/sh_flags.h:1.8
--- src/bin/mksh/sh_flags.h:1.5	Thu Jan 28 15:18:51 2010
+++ src/bin/mksh/sh_flags.h	Fri Feb 11 01:18:23 2011
@@ -1,5 +1,5 @@
 #if defined(SHFLAGS_DEFNS)
-__RCSID("$MirOS: src/bin/mksh/sh_flags.h,v 1.5 2010/01/28 15:18:51 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/sh_flags.h,v 1.8 2011/02/11 01:18:23 tg Exp $");
 #define FN(sname,cname,ochar,flags)	/* nothing */
 #elif defined(SHFLAGS_ENUMS)
 #define FN(sname,cname,ochar,flags)	cname,
@@ -21,10 +21,8 @@
 /* -a	all new parameters are created with the export attribute */
 F0("allexport", FEXPORT, 'a', OF_ANY)
 
-#if HAVE_ARC4RANDOM
-/* ./.	backwards compat: available if arc4random(3) is used for $RANDOM */
-FN("arc4random", FARC4RANDOM, 0, OF_INTERNAL)
-#endif
+/* ./.	backwards compat: dummy, emits a warning */
+FN("arc4random", FARC4RANDOM, 0, OF_ANY)
 
 #if HAVE_NICE
 /* ./.	bgnice */
@@ -137,6 +135,9 @@
  * anonymous flags: used internally by shell only (not visible to user)
  */
 
+/* ./.	direct builtin call (divined from argv[0] multi-call binary) */
+FN(NULL, FAS_BUILTIN, 0, OF_INTERNAL)
+
 /* ./.	(internal) initial shell was interactive */
 FN(NULL, FTALKING_I, 0, OF_INTERNAL)
 
Index: src/bin/mksh/shf.c
diff -u src/bin/mksh/shf.c:1.35 src/bin/mksh/shf.c:1.41
--- src/bin/mksh/shf.c:1.35	Sat Nov 28 14:28:03 2009
+++ src/bin/mksh/shf.c	Sun Mar 13 01:20:23 2011
@@ -18,11 +18,13 @@
  * of dealing in the work, even if advised of the possibility of such
  * damage or existence of a defect, except proven that it results out
  * of said person's immediate fault when using the work as intended.
+ *-
+ * Use %lX instead of %p and floating point isn't supported at all.
  */
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.35 2009/11/28 14:28:03 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.41 2011/03/13 01:20:23 tg Exp $");
 
 /* flags to shf_emptybuf() */
 #define EB_READSW	0x01	/* about to switch to reading */
@@ -45,7 +47,8 @@
 shf_open(const char *name, int oflags, int mode, int sflags)
 {
 	struct shf *shf;
-	int bsize = sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
+	int bsize = /* at most 512 */
+	    sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
 	int fd;
 
 	/* Done before open so if alloca fails, fd won't be lost. */
@@ -83,7 +86,8 @@
 struct shf *
 shf_fdopen(int fd, int sflags, struct shf *shf)
 {
-	int bsize = sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
+	int bsize = /* at most 512 */
+	    sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
 
 	/* use fcntl() to figure out correct read/write flags */
 	if (sflags & SHF_GETFL) {
@@ -108,7 +112,7 @@
 	}
 
 	if (!(sflags & (SHF_RD | SHF_WR)))
-		internal_errorf("shf_fdopen: missing read/write");
+		internal_errorf("%s: %s", "shf_fdopen", "missing read/write");
 
 	if (shf) {
 		if (bsize) {
@@ -140,7 +144,8 @@
 struct shf *
 shf_reopen(int fd, int sflags, struct shf *shf)
 {
-	int bsize = sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
+	int bsize = /* at most 512 */
+	    sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
 
 	/* use fcntl() to figure out correct read/write flags */
 	if (sflags & SHF_GETFL) {
@@ -165,9 +170,9 @@
 	}
 
 	if (!(sflags & (SHF_RD | SHF_WR)))
-		internal_errorf("shf_reopen: missing read/write");
+		internal_errorf("%s: %s", "shf_reopen", "missing read/write");
 	if (!shf || !shf->buf || shf->bsize < bsize)
-		internal_errorf("shf_reopen: bad shf/buf/bsize");
+		internal_errorf("%s: %s", "shf_reopen", "bad shf/buf/bsize");
 
 	/* assumes shf->buf and shf->bsize already set up */
 	shf->fd = fd;
@@ -196,7 +201,7 @@
 {
 	/* can't have a read+write string */
 	if (!(!(sflags & SHF_RD) ^ !(sflags & SHF_WR)))
-		internal_errorf("shf_sopen: flags 0x%x", sflags);
+		internal_errorf("%s: flags 0x%X", "shf_sopen", sflags);
 
 	if (!shf) {
 		shf = alloc(sizeof(struct shf), ATEMP);
@@ -289,7 +294,7 @@
 		return ((shf->flags & SHF_WR) ? EOF : 0);
 
 	if (shf->fd < 0)
-		internal_errorf("shf_flush: no fd");
+		internal_errorf("%s: %s", "shf_flush", "no fd");
 
 	if (shf->flags & SHF_ERROR) {
 		errno = shf->errno_;
@@ -319,7 +324,7 @@
 	int ret = 0;
 
 	if (!(shf->flags & SHF_STRING) && shf->fd < 0)
-		internal_errorf("shf_emptybuf: no fd");
+		internal_errorf("%s: %s", "shf_emptybuf", "no fd");
 
 	if (shf->flags & SHF_ERROR) {
 		errno = shf->errno_;
@@ -342,7 +347,7 @@
 		    !(shf->flags & SHF_ALLOCB))
 			return (EOF);
 		/* allocate more space for buffer */
-		nbuf = aresize(shf->buf, 2 * shf->wbsize, shf->areap);
+		nbuf = aresize2(shf->buf, 2, shf->wbsize, shf->areap);
 		shf->rp = nbuf + (shf->rp - shf->buf);
 		shf->wp = nbuf + (shf->wp - shf->buf);
 		shf->rbsize += shf->wbsize;
@@ -395,11 +400,13 @@
 static int
 shf_fillbuf(struct shf *shf)
 {
+	ssize_t n;
+
 	if (shf->flags & SHF_STRING)
 		return (0);
 
 	if (shf->fd < 0)
-		internal_errorf("shf_fillbuf: no fd");
+		internal_errorf("%s: %s", "shf_fillbuf", "no fd");
 
 	if (shf->flags & (SHF_EOF | SHF_ERROR)) {
 		if (shf->flags & SHF_ERROR)
@@ -413,24 +420,21 @@
 	shf->flags |= SHF_READING;
 
 	shf->rp = shf->buf;
-	while (1) {
-		shf->rnleft = blocking_read(shf->fd, (char *) shf->buf,
-		    shf->rbsize);
-		if (shf->rnleft < 0 && errno == EINTR &&
-		    !(shf->flags & SHF_INTERRUPT))
+	while (/* CONSTCOND */ 1) {
+		n = blocking_read(shf->fd, (char *)shf->buf, shf->rbsize);
+		if (n < 0 && errno == EINTR && !(shf->flags & SHF_INTERRUPT))
 			continue;
 		break;
 	}
-	if (shf->rnleft <= 0) {
-		if (shf->rnleft < 0) {
-			shf->flags |= SHF_ERROR;
-			shf->errno_ = errno;
-			shf->rnleft = 0;
-			shf->rp = shf->buf;
-			return (EOF);
-		}
-		shf->flags |= SHF_EOF;
+	if (n < 0) {
+		shf->flags |= SHF_ERROR;
+		shf->errno_ = errno;
+		shf->rnleft = 0;
+		shf->rp = shf->buf;
+		return (EOF);
 	}
+	if ((shf->rnleft = n) == 0)
+		shf->flags |= SHF_EOF;
 	return (0);
 }
 
@@ -445,10 +449,10 @@
 	int ncopy;
 
 	if (!(shf->flags & SHF_RD))
-		internal_errorf("shf_read: flags %x", shf->flags);
+		internal_errorf("%s: flags 0x%X", "shf_read", shf->flags);
 
 	if (bsize <= 0)
-		internal_errorf("shf_read: bsize %d", bsize);
+		internal_errorf("%s: %s %d", "shf_write", "bsize", bsize);
 
 	while (bsize > 0) {
 		if (shf->rnleft == 0 &&
@@ -480,7 +484,7 @@
 	char *orig_buf = buf;
 
 	if (!(shf->flags & SHF_RD))
-		internal_errorf("shf_getse: flags %x", shf->flags);
+		internal_errorf("%s: flags 0x%X", "shf_getse", shf->flags);
 
 	if (bsize <= 0)
 		return (NULL);
@@ -515,7 +519,7 @@
 shf_getchar(struct shf *shf)
 {
 	if (!(shf->flags & SHF_RD))
-		internal_errorf("shf_getchar: flags %x", shf->flags);
+		internal_errorf("%s: flags 0x%X", "shf_getchar", shf->flags);
 
 	if (shf->rnleft == 0 && (shf_fillbuf(shf) == EOF || shf->rnleft == 0))
 		return (EOF);
@@ -530,7 +534,7 @@
 shf_ungetc(int c, struct shf *shf)
 {
 	if (!(shf->flags & SHF_RD))
-		internal_errorf("shf_ungetc: flags %x", shf->flags);
+		internal_errorf("%s: flags 0x%X", "shf_ungetc", shf->flags);
 
 	if ((shf->flags & SHF_ERROR) || c == EOF ||
 	    (shf->rp == shf->buf && shf->rnleft))
@@ -565,7 +569,7 @@
 shf_putchar(int c, struct shf *shf)
 {
 	if (!(shf->flags & SHF_WR))
-		internal_errorf("shf_putchar: flags %x", shf->flags);
+		internal_errorf("%s: flags 0x%X", "shf_putchar", shf->flags);
 
 	if (c == EOF)
 		return (EOF);
@@ -575,7 +579,7 @@
 		int n;
 
 		if (shf->fd < 0)
-			internal_errorf("shf_putchar: no fd");
+			internal_errorf("%s: %s", "shf_putchar", "no fd");
 		if (shf->flags & SHF_ERROR) {
 			errno = shf->errno_;
 			return (EOF);
@@ -619,10 +623,10 @@
 	int n, ncopy, orig_nbytes = nbytes;
 
 	if (!(shf->flags & SHF_WR))
-		internal_errorf("shf_write: flags %x", shf->flags);
+		internal_errorf("%s: flags 0x%X", "shf_write", shf->flags);
 
 	if (nbytes < 0)
-		internal_errorf("shf_write: nbytes %d", nbytes);
+		internal_errorf("%s: %s %d", "shf_write", "nbytes", nbytes);
 
 	/* Don't buffer if buffer is empty and we're writting a large amount. */
 	if ((ncopy = shf->wnleft) &&
@@ -636,32 +640,45 @@
 		shf->wnleft -= ncopy;
 	}
 	if (nbytes > 0) {
-		/* Flush deals with strings and sticky errors */
-		if (shf_emptybuf(shf, EB_GROW) == EOF)
-			return (EOF);
-		if (nbytes > shf->wbsize) {
-			ncopy = nbytes;
-			if (shf->wbsize)
-				ncopy -= nbytes % shf->wbsize;
-			nbytes -= ncopy;
-			while (ncopy > 0) {
-				n = write(shf->fd, buf, ncopy);
-				if (n < 0) {
-					if (errno == EINTR &&
-					    !(shf->flags & SHF_INTERRUPT))
-						continue;
-					shf->flags |= SHF_ERROR;
-					shf->errno_ = errno;
-					shf->wnleft = 0;
-					/* Note: fwrite(3S) returns 0 for
-					 * errors - this doesn't */
+		if (shf->flags & SHF_STRING) {
+			/* resize buffer until there's enough space left */
+			while (nbytes > shf->wnleft)
+				if (shf_emptybuf(shf, EB_GROW) == EOF)
 					return (EOF);
+			/* then write everything into the buffer */
+		} else {
+			/* flush deals with sticky errors */
+			if (shf_emptybuf(shf, EB_GROW) == EOF)
+				return (EOF);
+			/* write chunks larger than window size directly */
+			if (nbytes > shf->wbsize) {
+				ncopy = nbytes;
+				if (shf->wbsize)
+					ncopy -= nbytes % shf->wbsize;
+				nbytes -= ncopy;
+				while (ncopy > 0) {
+					n = write(shf->fd, buf, ncopy);
+					if (n < 0) {
+						if (errno == EINTR &&
+						    !(shf->flags & SHF_INTERRUPT))
+							continue;
+						shf->flags |= SHF_ERROR;
+						shf->errno_ = errno;
+						shf->wnleft = 0;
+						/*
+						 * Note: fwrite(3) returns 0
+						 * for errors - this doesn't
+						 */
+						return (EOF);
+					}
+					buf += n;
+					ncopy -= n;
 				}
-				buf += n;
-				ncopy -= n;
 			}
+			/* ... and buffer the rest */
 		}
 		if (nbytes > 0) {
+			/* write remaining bytes to buffer */
 			memcpy(shf->wp, buf, nbytes);
 			shf->wp += nbytes;
 			shf->wnleft -= nbytes;
@@ -692,7 +709,8 @@
 	int n;
 
 	if (!buf || bsize <= 0)
-		internal_errorf("shf_snprintf: buf %p, bsize %d", buf, bsize);
+		internal_errorf("shf_snprintf: buf %lX, bsize %d",
+		    (long)(ptrdiff_t)buf, bsize);
 
 	shf_sopen(buf, bsize, SHF_WR, &shf);
 	va_start(args, fmt);
@@ -842,11 +860,6 @@
 		}
 
 		switch (c) {
-		case 'p': /* pointer */
-			flags &= ~(FL_LONG | FL_SHORT);
-			flags |= (sizeof(char *) > sizeof(int)) ?
-			    /* hope it fits.. */ FL_LONG : 0;
-			/* aaahhh... */
 		case 'd':
 		case 'i':
 		case 'o':
@@ -904,7 +917,6 @@
 					*--cp = '0';
 				break;
 
-			case 'p':
 			case 'x': {
 				const char *digits = (flags & FL_UPPER) ?
 				    digits_uc : digits_lc;
Index: src/bin/mksh/syn.c
diff -u src/bin/mksh/syn.c:1.48 src/bin/mksh/syn.c:1.64
--- src/bin/mksh/syn.c:1.48	Sat Dec 12 22:27:10 2009
+++ src/bin/mksh/syn.c	Sat May  7 00:51:12 2011
@@ -1,7 +1,7 @@
 /*	$OpenBSD: syn.c,v 1.28 2008/07/23 16:34:38 jaredy Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -22,7 +22,9 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.48 2009/12/12 22:27:10 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.64 2011/05/07 00:51:12 tg Exp $");
+
+extern short subshell_nesting_level;
 
 struct nesting_state {
 	int start_token;	/* token than began nesting (eg, FOR) */
@@ -32,7 +34,7 @@
 static void yyparse(void);
 static struct op *pipeline(int);
 static struct op *andor(void);
-static struct op *c_list(int);
+static struct op *c_list(bool);
 static struct ioword *synio(int);
 static struct op *nested(int, int, int);
 static struct op *get_command(int);
@@ -50,7 +52,7 @@
 static void nesting_pop(struct nesting_state *);
 static int assign_command(char *);
 static int inalias(struct source *);
-static int dbtestp_isa(Test_env *, Test_meta);
+static Test_op dbtestp_isa(Test_env *, Test_meta);
 static const char *dbtestp_getopnd(Test_env *, Test_op, bool);
 static int dbtestp_eval(Test_env *, Test_op, const char *,
     const char *, bool);
@@ -59,14 +61,14 @@
 static struct op *outtree;		/* yyparse output */
 static struct nesting_state nesting;	/* \n changed to ; */
 
-static int reject;		/* token(cf) gets symbol again */
-static int symbol;		/* yylex value */
+static bool reject;			/* token(cf) gets symbol again */
+static int symbol;			/* yylex value */
 
-#define REJECT		(reject = 1)
-#define ACCEPT		(reject = 0)
+#define REJECT		(reject = true)
+#define ACCEPT		(reject = false)
 #define token(cf)	((reject) ? (ACCEPT, symbol) : (symbol = yylex(cf)))
 #define tpeek(cf)	((reject) ? (symbol) : (REJECT, symbol = yylex(cf)))
-#define musthave(c,cf)	do { if (token(cf) != (c)) syntaxerr(NULL); } while (0)
+#define musthave(c,cf)	do { if (token(cf) != (c)) syntaxerr(NULL); } while (/* CONSTCOND */ 0)
 
 static void
 yyparse(void)
@@ -122,20 +124,23 @@
 }
 
 static struct op *
-c_list(int multi)
+c_list(bool multi)
 {
 	struct op *t = NULL, *p, *tl = NULL;
-	int c, have_sep;
+	int c;
+	bool have_sep;
 
-	while (1) {
+	while (/* CONSTCOND */ 1) {
 		p = andor();
-		/* Token has always been read/rejected at this point, so
+		/*
+		 * Token has always been read/rejected at this point, so
 		 * we don't worry about what flags to pass token()
 		 */
 		c = token(0);
-		have_sep = 1;
+		have_sep = true;
 		if (c == '\n' && (multi || inalias(source))) {
-			if (!p) /* ignore blank lines */
+			if (!p)
+				/* ignore blank lines */
 				continue;
 		} else if (!p)
 			break;
@@ -143,7 +148,7 @@
 			p = block(c == '&' ? TASYNC : TCOPROC,
 			    p, NOBLOCK, NOWORDS);
 		else if (c != ';')
-			have_sep = 0;
+			have_sep = false;
 		if (!t)
 			t = p;
 		else if (!tl)
@@ -161,7 +166,7 @@
 synio(int cf)
 {
 	struct ioword *iop;
-	static struct ioword *nextiop = NULL;
+	static struct ioword *nextiop;
 	bool ishere;
 
 	if (nextiop != NULL) {
@@ -174,14 +179,18 @@
 		return (NULL);
 	ACCEPT;
 	iop = yylval.iop;
-	ishere = (iop->flag&IOTYPE) == IOHERE;
+	if (iop->flag & IONDELIM)
+		goto gotnulldelim;
+	ishere = (iop->flag & IOTYPE) == IOHERE;
 	musthave(LWORD, ishere ? HEREDELIM : 0);
 	if (ishere) {
 		iop->delim = yylval.cp;
-		if (*ident != 0) /* unquoted */
+		if (*ident != 0)
+			/* unquoted */
+ gotnulldelim:
 			iop->flag |= IOEVAL;
 		if (herep > &heres[HERES - 1])
-			yyerror("too many <<s\n");
+			yyerror("too many %ss\n", "<<");
 		*herep++ = iop;
 	} else
 		iop->name = yylval.cp;
@@ -231,7 +240,8 @@
 	XPtrV args, vars;
 	struct nesting_state old_nesting;
 
-	iops = alloc((NUFILE + 1) * sizeof(struct ioword *), ATEMP);
+	/* NUFILE is small enough to leave this addition unchecked */
+	iops = alloc2((NUFILE + 1), sizeof(struct ioword *), ATEMP);
 	XPinit(args, 16);
 	XPinit(vars, 16);
 
@@ -242,7 +252,8 @@
 		afree(iops, ATEMP);
 		XPfree(args);
 		XPfree(vars);
-		return (NULL); /* empty line */
+		/* empty line */
+		return (NULL);
 
 	case LWORD:
 	case REDIR:
@@ -250,21 +261,23 @@
 		syniocf &= ~(KEYWORD|ALIAS);
 		t = newtp(TCOM);
 		t->lineno = source->line;
-		while (1) {
+		while (/* CONSTCOND */ 1) {
 			cf = (t->u.evalflags ? ARRAYVAR : 0) |
 			    (XPsize(args) == 0 ? ALIAS|VARASN : CMDWORD);
 			switch (tpeek(cf)) {
 			case REDIR:
 				while ((iop = synio(cf)) != NULL) {
 					if (iopn >= NUFILE)
-						yyerror("too many redirections\n");
+						yyerror("too many %ss\n",
+						    "redirection");
 					iops[iopn++] = iop;
 				}
 				break;
 
 			case LWORD:
 				ACCEPT;
-				/* the iopn == 0 and XPsize(vars) == 0 are
+				/*
+				 * the iopn == 0 and XPsize(vars) == 0 are
 				 * dubious but AT&T ksh acts this way
 				 */
 				if (iopn == 0 && XPsize(vars) == 0 &&
@@ -279,7 +292,8 @@
 				break;
 
 			case '(':
-				/* Check for "> foo (echo hi)" which AT&T ksh
+				/*
+				 * Check for "> foo (echo hi)" which AT&T ksh
 				 * allows (not POSIX, but not disallowed)
 				 */
 				afree(t, ATEMP);
@@ -292,13 +306,12 @@
 				    XPsize(vars) == 1 && is_wdvarassign(yylval.cp))
 					goto is_wdarrassign;
 #endif
-				/* Must be a function */
+				/* must be a function */
 				if (iopn != 0 || XPsize(args) != 1 ||
 				    XPsize(vars) != 0)
 					syntaxerr(NULL);
 				ACCEPT;
-				/*(*/
-				musthave(')', 0);
+				musthave(/*(*/')', 0);
 				t = function_body(XPptrv(args)[0], false);
 				goto Leave;
 #ifndef MKSH_SMALL
@@ -348,7 +361,9 @@
 
 	case '(':
  Subshell:
+		++subshell_nesting_level;
 		t = nested(TPAREN, '(', ')');
+		--subshell_nesting_level;
 		break;
 
 	case '{': /*}*/
@@ -362,13 +377,13 @@
 			CHAR, 't', EOS
 		};
 
-		/* Leave KEYWORD in syniocf (allow if (( 1 )) then ...) */
+		/* leave KEYWORD in syniocf (allow if (( 1 )) then ...) */
 		lno = source->line;
 		ACCEPT;
 		switch (token(LETEXPR)) {
 		case LWORD:
 			break;
-		case '(':	/* ) */
+		case '(': /*)*/
 			goto Subshell;
 		default:
 			syntaxerr(NULL);
@@ -381,7 +396,7 @@
 	}
 
 	case DBRACKET: /* [[ .. ]] */
-		/* Leave KEYWORD in syniocf (allow if [[ -n 1 ]] then ...) */
+		/* leave KEYWORD in syniocf (allow if [[ -n 1 ]] then ...) */
 		t = newtp(TDBRACKET);
 		ACCEPT;
 		{
@@ -403,8 +418,8 @@
 		t = newtp((c == FOR) ? TFOR : TSELECT);
 		musthave(LWORD, ARRAYVAR);
 		if (!is_wdvarname(yylval.cp, true))
-			yyerror("%s: bad identifier\n",
-			    c == FOR ? "for" : "select");
+			yyerror("%s: %s\n", c == FOR ? "for" : T_select,
+			    "bad identifier");
 		strdupx(t->str, ident, ATEMP);
 		nesting_push(&old_nesting, c);
 		t->vars = wordlist();
@@ -452,7 +467,8 @@
 		t = pipeline(0);
 		if (t) {
 			t->str = alloc(2, ATEMP);
-			t->str[0] = '\0';	/* TF_* flags */
+			/* TF_* flags */
+			t->str[0] = '\0';
 			t->str[1] = '\0';
 		}
 		t = block(TTIME, t, NOBLOCK, NOWORDS);
@@ -466,7 +482,7 @@
 
 	while ((iop = synio(syniocf)) != NULL) {
 		if (iopn >= NUFILE)
-			yyerror("too many redirections\n");
+			yyerror("too many %ss\n", "redirection");
 		iops[iopn++] = iop;
 	}
 
@@ -475,7 +491,7 @@
 		t->ioact = NULL;
 	} else {
 		iops[iopn++] = NULL;
-		iops = aresize(iops, iopn * sizeof(struct ioword *), ATEMP);
+		iops = aresize2(iops, iopn, sizeof(struct ioword *), ATEMP);
 		t->ioact = iops;
 	}
 
@@ -499,7 +515,8 @@
 	struct op *list;
 
 	c = token(CONTIN|KEYWORD|ALIAS);
-	/* A {...} can be used instead of do...done for for/select loops
+	/*
+	 * A {...} can be used instead of do...done for for/select loops
 	 * but not for while/until loops - we don't need to check if it
 	 * is a while loop because it would have been parsed as part of
 	 * the conditional command list...
@@ -567,7 +584,8 @@
 	else
 		syntaxerr(NULL);
 	t = tl = NULL;
-	while ((tpeek(CONTIN|KEYWORD|ESACONLY)) != c) { /* no ALIAS here */
+	/* no ALIAS here */
+	while ((tpeek(CONTIN|KEYWORD|ESACONLY)) != c) {
 		struct op *tc = casepart(c);
 		if (tl == NULL)
 			t = tl = tc, tl->right = NULL;
@@ -607,47 +625,46 @@
 
 static struct op *
 function_body(char *name,
-    bool ksh_func)		/* function foo { ... } vs foo() { .. } */
+    /* function foo { ... } vs foo() { .. } */
+    bool ksh_func)
 {
 	char *sname, *p;
 	struct op *t;
 	bool old_func_parse;
 
-	sname = wdstrip(name, false, false);
-	/* Check for valid characters in name. POSIX and AT&T ksh93 say only
-	 * allow [a-zA-Z_0-9] but this allows more as old pdkshs have
-	 * allowed more (the following were never allowed:
+	sname = wdstrip(name, 0);
+	/*-
+	 * Check for valid characters in name. POSIX and AT&T ksh93 say
+	 * only allow [a-zA-Z_0-9] but this allows more as old pdkshs
+	 * have allowed more; the following were never allowed:
 	 *	NUL TAB NL SP " $ & ' ( ) ; < = > \ ` |
 	 * C_QUOTE covers all but adds # * ? [ ]
 	 */
 	for (p = sname; *p; p++)
 		if (ctype(*p, C_QUOTE))
-			yyerror("%s: invalid function name\n", sname);
+			yyerror("%s: %s\n", sname, "invalid function name");
 
-	/* Note that POSIX allows only compound statements after foo(), sh and
-	 * AT&T ksh allow any command, go with the later since it shouldn't
-	 * break anything. However, for function foo, AT&T ksh only accepts
-	 * an open-brace.
+	/*
+	 * Note that POSIX allows only compound statements after foo(),
+	 * sh and AT&T ksh allow any command, go with the later since it
+	 * shouldn't break anything. However, for function foo, AT&T ksh
+	 * only accepts an open-brace.
 	 */
 	if (ksh_func) {
-		if (tpeek(CONTIN|KEYWORD|ALIAS) == '(' /* ) */) {
-			struct tbl *tp;
-
+		if (tpeek(CONTIN|KEYWORD|ALIAS) == '(' /*)*/) {
 			/* function foo () { */
 			ACCEPT;
 			musthave(')', 0);
 			/* degrade to POSIX function */
 			ksh_func = false;
-			if ((tp = ktsearch(&aliases, sname, hash(sname))))
-				ktdelete(tp);
 		}
-		musthave('{', CONTIN|KEYWORD|ALIAS); /* } */
+		musthave('{' /*}*/, CONTIN|KEYWORD|ALIAS);
 		REJECT;
 	}
 
 	t = newtp(TFUNCT);
 	t->str = sname;
-	t->u.ksh_func = ksh_func;
+	t->u.ksh_func = tobool(ksh_func);
 	t->lineno = source->line;
 
 	old_func_parse = e->flags & EF_FUNC_PARSE;
@@ -655,12 +672,13 @@
 	if ((t->left = get_command(CONTIN)) == NULL) {
 		char *tv;
 		/*
-		 * Probably something like foo() followed by eof or ;.
+		 * Probably something like foo() followed by EOF or ';'.
 		 * This is accepted by sh and ksh88.
 		 * To make "typeset -f foo" work reliably (so its output can
 		 * be used as input), we pretend there is a colon here.
 		 */
 		t->left = newtp(TCOM);
+		/* (2 * sizeof(char *)) is small enough */
 		t->left->args = alloc(2 * sizeof(char *), ATEMP);
 		t->left->args[0] = tv = alloc(3, ATEMP);
 		tv[0] = CHAR;
@@ -686,7 +704,8 @@
 	XPinit(args, 16);
 	/* POSIX does not do alias expansion here... */
 	if ((c = token(CONTIN|KEYWORD|ALIAS)) != IN) {
-		if (c != ';') /* non-POSIX, but AT&T ksh accepts a ; here */
+		if (c != ';')
+			/* non-POSIX, but AT&T ksh accepts a ; here */
 			REJECT;
 		return (NULL);
 	}
@@ -733,13 +752,13 @@
 	{ "case",	CASE,	true },
 	{ "esac",	ESAC,	true },
 	{ "for",	FOR,	true },
-	{ "select",	SELECT,	true },
+	{ T_select,	SELECT,	true },
 	{ "while",	WHILE,	true },
 	{ "until",	UNTIL,	true },
 	{ "do",		DO,	true },
 	{ "done",	DONE,	true },
 	{ "in",		IN,	true },
-	{ "function",	FUNCTION, true },
+	{ T_function,	FUNCTION, true },
 	{ "time",	TIME,	true },
 	{ "{",		'{',	true },
 	{ "}",		'}',	true },
@@ -763,7 +782,8 @@
 	struct tbl *p;
 
 	ktinit(&keywords, APERM,
-	    /* must be 80% of 2^n (currently 20 keywords) */ 32);
+	    /* must be 80% of 2^n (currently 20 keywords) */
+	    32);
 	for (tt = tokentab; tt->name; tt++) {
 		if (tt->reserved) {
 			p = ktenter(&keywords, tt->name, hash(tt->name));
@@ -777,7 +797,8 @@
 static void
 syntaxerr(const char *what)
 {
-	char redir[6];	/* 2<<- is the longest redirection, I think */
+	/* 2<<- is the longest redirection, I think */
+	char redir[6];
 	const char *s;
 	struct tokeninfo const *tt;
 	int c;
@@ -796,7 +817,7 @@
 			goto Again;
 		}
 		/* don't quote the EOF */
-		yyerror("%s: unexpected EOF\n", T_synerr);
+		yyerror("%s: %s %s\n", T_synerr, "unexpected", "EOF");
 		/* NOTREACHED */
 
 	case LWORD:
@@ -857,17 +878,22 @@
 }
 
 struct op *
-compile(Source *s)
+compile(Source *s, bool skiputf8bom)
 {
+	extern void yyskiputf8bom(void);
+
 	nesting.start_token = 0;
 	nesting.start_line = 0;
 	herep = heres;
 	source = s;
+	if (skiputf8bom)
+		yyskiputf8bom();
 	yyparse();
 	return (outtree);
 }
 
-/* This kludge exists to take care of sh/AT&T ksh oddity in which
+/*-
+ * This kludge exists to take care of sh/AT&T ksh oddity in which
  * the arguments of alias/export/readonly/typeset have no field
  * splitting, file globbing, or (normal) tilde expansion done.
  * AT&T ksh seems to do something similar to this since
@@ -882,7 +908,7 @@
 {
 	if (!*s)
 		return (0);
-	return ((strcmp(s, "alias") == 0) ||
+	return ((strcmp(s, T_alias) == 0) ||
 	    (strcmp(s, "export") == 0) ||
 	    (strcmp(s, "readonly") == 0) ||
 	    (strcmp(s, T_typeset) == 0));
@@ -899,7 +925,8 @@
 }
 
 
-/* Order important - indexed by Test_meta values
+/*
+ * Order important - indexed by Test_meta values
  * Note that ||, &&, ( and ) can't appear in as unquoted strings
  * in normal shell input, so these can be interpreted unambiguously
  * in the evaluation pass.
@@ -917,42 +944,46 @@
 const char db_lthan[] = { CHAR, '<', EOS };
 const char db_gthan[] = { CHAR, '>', EOS };
 
-/* Test if the current token is a whatever. Accepts the current token if
+/*
+ * Test if the current token is a whatever. Accepts the current token if
  * it is. Returns 0 if it is not, non-zero if it is (in the case of
  * TM_UNOP and TM_BINOP, the returned value is a Test_op).
  */
-static int
+static Test_op
 dbtestp_isa(Test_env *te, Test_meta meta)
 {
 	int c = tpeek(ARRAYVAR | (meta == TM_BINOP ? 0 : CONTIN));
 	int uqword;
 	char *save = NULL;
-	int ret = 0;
+	Test_op ret = TO_NONOP;
 
 	/* unquoted word? */
 	uqword = c == LWORD && *ident;
 
 	if (meta == TM_OR)
-		ret = c == LOGOR;
+		ret = c == LOGOR ? TO_NONNULL : TO_NONOP;
 	else if (meta == TM_AND)
-		ret = c == LOGAND;
+		ret = c == LOGAND ? TO_NONNULL : TO_NONOP;
 	else if (meta == TM_NOT)
-		ret = uqword && strcmp(yylval.cp, dbtest_tokens[(int) TM_NOT]) == 0;
+		ret = (uqword && !strcmp(yylval.cp,
+		    dbtest_tokens[(int)TM_NOT])) ? TO_NONNULL : TO_NONOP;
 	else if (meta == TM_OPAREN)
-		ret = c == '(' /*)*/;
+		ret = c == '(' /*)*/ ? TO_NONNULL : TO_NONOP;
 	else if (meta == TM_CPAREN)
-		ret = c == /*(*/ ')';
+		ret = c == /*(*/ ')' ? TO_NONNULL : TO_NONOP;
 	else if (meta == TM_UNOP || meta == TM_BINOP) {
 		if (meta == TM_BINOP && c == REDIR &&
 		    (yylval.iop->flag == IOREAD || yylval.iop->flag == IOWRITE)) {
-			ret = 1;
+			ret = TO_NONNULL;
 			save = wdcopy(yylval.iop->flag == IOREAD ?
 			    db_lthan : db_gthan, ATEMP);
 		} else if (uqword && (ret = test_isop(meta, ident)))
 			save = yylval.cp;
-	} else /* meta == TM_END */
-		ret = uqword && strcmp(yylval.cp, db_close) == 0;
-	if (ret) {
+	} else
+		/* meta == TM_END */
+		ret = (uqword && !strcmp(yylval.cp,
+		    db_close)) ? TO_NONNULL : TO_NONOP;
+	if (ret != TO_NONOP) {
 		ACCEPT;
 		if (meta < NELEM(dbtest_tokens))
 			save = wdcopy(dbtest_tokens[(int)meta], ATEMP);
@@ -999,3 +1030,96 @@
 	}
 	syntaxerr(msg);
 }
+
+#if HAVE_SELECT
+
+#ifndef EOVERFLOW
+#ifdef ERANGE
+#define EOVERFLOW	ERANGE
+#else
+#define EOVERFLOW	EINVAL
+#endif
+#endif
+
+bool
+parse_usec(const char *s, struct timeval *tv)
+{
+	struct timeval tt;
+	int i;
+
+	tv->tv_sec = 0;
+	/* parse integral part */
+	while (ksh_isdigit(*s)) {
+		tt.tv_sec = tv->tv_sec * 10 + (*s++ - '0');
+		if (tt.tv_sec / 10 != tv->tv_sec) {
+			errno = EOVERFLOW;
+			return (true);
+		}
+		tv->tv_sec = tt.tv_sec;
+	}
+
+	tv->tv_usec = 0;
+	if (!*s)
+		/* no decimal fraction */
+		return (false);
+	else if (*s++ != '.') {
+		/* junk after integral part */
+		errno = EINVAL;
+		return (true);
+	}
+
+	/* parse decimal fraction */
+	i = 100000;
+	while (ksh_isdigit(*s)) {
+		tv->tv_usec += i * (*s++ - '0');
+		if (i == 1)
+			break;
+		i /= 10;
+	}
+	/* check for junk after fractional part */
+	while (ksh_isdigit(*s))
+		++s;
+	if (*s) {
+		errno = EINVAL;
+		return (true);
+	}
+
+	/* end of input string reached, no errors */
+	return (false);
+}
+#endif
+
+/*
+ * Helper function called from within lex.c:yylex() to parse
+ * a COMSUB recursively using the main shell parser and lexer
+ */
+char *
+yyrecursive(void)
+{
+	struct op *t;
+	char *cp;
+	bool old_reject;
+	int old_symbol;
+	struct ioword **old_herep;
+
+	/* tell the lexer to accept a closing parenthesis as EOD */
+	++subshell_nesting_level;
+
+	/* push reject state, parse recursively, pop reject state */
+	old_reject = reject;
+	old_symbol = symbol;
+	ACCEPT;
+	old_herep = herep;
+	/* we use TPAREN as a helper container here */
+	t = nested(TPAREN, '(', ')');
+	herep = old_herep;
+	reject = old_reject;
+	symbol = old_symbol;
+
+	/* t->left because nested(TPAREN, ...) hides our goodies there */
+	cp = snptreef(NULL, 0, "%T", t->left);
+	tfree(t, ATEMP);
+
+	--subshell_nesting_level;
+	return (cp);
+}
Index: src/bin/mksh/tree.c
diff -u src/bin/mksh/tree.c:1.30 src/bin/mksh/tree.c:1.48
--- src/bin/mksh/tree.c:1.30	Thu Feb 25 20:18:19 2010
+++ src/bin/mksh/tree.c	Sat May  7 00:24:35 2011
@@ -1,7 +1,7 @@
 /*	$OpenBSD: tree.c,v 1.19 2008/08/11 21:50:35 jaredy Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -22,19 +22,20 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.30 2010/02/25 20:18:19 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.48 2011/05/07 00:24:35 tg Exp $");
 
-#define INDENT	4
+#define INDENT	8
 
-#define tputc(c, shf) shf_putchar(c, shf);
 static void ptree(struct op *, int, struct shf *);
 static void pioact(struct shf *, int, struct ioword *);
-static void tputC(int, struct shf *);
-static void tputS(char *, struct shf *);
+static const char *wdvarput(struct shf *, const char *, int, int);
 static void vfptreef(struct shf *, int, const char *, va_list);
 static struct ioword **iocopy(struct ioword **, Area *);
 static void iofree(struct ioword **, Area *);
 
+/* "foo& ; bar" and "foo |& ; bar" are invalid */
+static bool prevent_semicolon;
+
 /*
  * print a command tree
  */
@@ -44,22 +45,26 @@
 	const char **w;
 	struct ioword **ioact;
 	struct op *t1;
+	int i;
 
  Chain:
 	if (t == NULL)
 		return;
 	switch (t->type) {
 	case TCOM:
-		if (t->vars)
-			for (w = (const char **)t->vars; *w != NULL; )
+		if (t->vars) {
+			w = (const char **)t->vars;
+			while (*w)
 				fptreef(shf, indent, "%S ", *w++);
-		else
+		} else
 			shf_puts("#no-vars# ", shf);
-		if (t->args)
-			for (w = t->args; *w != NULL; )
+		if (t->args) {
+			w = t->args;
+			while (*w)
 				fptreef(shf, indent, "%S ", *w++);
-		else
+		} else
 			shf_puts("#no-args# ", shf);
+		prevent_semicolon = false;
 		break;
 	case TEXEC:
 		t = t->left;
@@ -78,30 +83,28 @@
 	case TOR:
 	case TAND:
 		fptreef(shf, indent, "%T%s %T",
-		    t->left, (t->type==TOR) ? "||" : "&&", t->right);
+		    t->left, (t->type == TOR) ? "||" : "&&", t->right);
 		break;
 	case TBANG:
 		shf_puts("! ", shf);
+		prevent_semicolon = false;
 		t = t->right;
 		goto Chain;
-	case TDBRACKET: {
-		int i;
-
+	case TDBRACKET:
+		w = t->args;
 		shf_puts("[[", shf);
-		for (i = 0; t->args[i]; i++)
-			fptreef(shf, indent, " %S", t->args[i]);
+		while (*w)
+			fptreef(shf, indent, " %S", *w++);
 		shf_puts(" ]] ", shf);
 		break;
-	}
 	case TSELECT:
-		fptreef(shf, indent, "select %s ", t->str);
-		/* FALLTHROUGH */
 	case TFOR:
-		if (t->type == TFOR)
-			fptreef(shf, indent, "for %s ", t->str);
+		fptreef(shf, indent, "%s %s ",
+		    (t->type == TFOR) ? "for" : "select", t->str);
 		if (t->vars != NULL) {
 			shf_puts("in ", shf);
-			for (w = (const char **)t->vars; *w; )
+			w = (const char **)t->vars;
+			while (*w)
 				fptreef(shf, indent, "%S ", *w++);
 			fptreef(shf, indent, "%;");
 		}
@@ -112,34 +115,42 @@
 		fptreef(shf, indent, "case %S in", t->str);
 		for (t1 = t->left; t1 != NULL; t1 = t1->right) {
 			fptreef(shf, indent, "%N(");
-			for (w = (const char **)t1->vars; *w != NULL; w++)
+			w = (const char **)t1->vars;
+			while (*w) {
 				fptreef(shf, indent, "%S%c", *w,
 				    (w[1] != NULL) ? '|' : ')');
-			fptreef(shf, indent + INDENT, "%;%T%N;;", t1->left);
+				++w;
+			}
+			fptreef(shf, indent + INDENT, "%N%T%N;;", t1->left);
 		}
 		fptreef(shf, indent, "%Nesac ");
 		break;
-	case TIF:
+#ifndef MKSH_NO_DEPRECATED_WARNING
 	case TELIF:
-		/* 3 == strlen("if ") */
-		fptreef(shf, indent + 3, "if %T", t->left);
-		for (;;) {
+		internal_errorf("TELIF in tree.c:ptree() unexpected");
+		/* FALLTHROUGH */
+#endif
+	case TIF:
+		i = 2;
+		goto process_TIF;
+		do {
+			t = t->right;
+			i = 0;
+			fptreef(shf, indent, "%;");
+ process_TIF:
+			/* 5 == strlen("elif ") */
+			fptreef(shf, indent + 5 - i, "elif %T" + i, t->left);
 			t = t->right;
 			if (t->left != NULL) {
 				fptreef(shf, indent, "%;");
-				fptreef(shf, indent + INDENT, "then%N%T",
-				    t->left);
+				fptreef(shf, indent + INDENT, "%s%N%T",
+				    "then", t->left);
 			}
-			if (t->right == NULL || t->right->type != TELIF)
-				break;
-			t = t->right;
-			fptreef(shf, indent, "%;");
-			/* 5 == strlen("elif ") */
-			fptreef(shf, indent + 5, "elif %T", t->left);
-		}
+		} while (t->right && t->right->type == TELIF);
 		if (t->right != NULL) {
 			fptreef(shf, indent, "%;");
-			fptreef(shf, indent + INDENT, "else%;%T", t->right);
+			fptreef(shf, indent + INDENT, "%s%N%T",
+			    "else", t->right);
 		}
 		fptreef(shf, indent, "%;fi ");
 		break;
@@ -147,60 +158,63 @@
 	case TUNTIL:
 		/* 6 == strlen("while"/"until") */
 		fptreef(shf, indent + 6, "%s %T",
-		    (t->type==TWHILE) ? "while" : "until",
+		    (t->type == TWHILE) ? "while" : "until",
 		    t->left);
-		fptreef(shf, indent, "%;do");
-		fptreef(shf, indent + INDENT, "%;%T", t->right);
+		fptreef(shf, indent, "%;");
+		fptreef(shf, indent + INDENT, "do%N%T", t->right);
 		fptreef(shf, indent, "%;done ");
 		break;
 	case TBRACE:
-		fptreef(shf, indent + INDENT, "{%;%T", t->left);
+		fptreef(shf, indent + INDENT, "{%N%T", t->left);
 		fptreef(shf, indent, "%;} ");
 		break;
 	case TCOPROC:
 		fptreef(shf, indent, "%T|& ", t->left);
+		prevent_semicolon = true;
 		break;
 	case TASYNC:
 		fptreef(shf, indent, "%T& ", t->left);
+		prevent_semicolon = true;
 		break;
 	case TFUNCT:
-		fptreef(shf, indent,
-		    t->u.ksh_func ? "function %s %T" : "%s() %T",
-		    t->str, t->left);
+		fpFUNCTf(shf, indent, tobool(t->u.ksh_func), t->str, t->left);
 		break;
 	case TTIME:
-		fptreef(shf, indent, "time %T", t->left);
+		fptreef(shf, indent, "%s %T", "time", t->left);
 		break;
 	default:
 		shf_puts("<botch>", shf);
+		prevent_semicolon = false;
 		break;
 	}
 	if ((ioact = t->ioact) != NULL) {
-		int	need_nl = 0;
+		bool need_nl = false;
 
 		while (*ioact != NULL)
 			pioact(shf, indent, *ioact++);
 		/* Print here documents after everything else... */
-		for (ioact = t->ioact; *ioact != NULL; ) {
+		ioact = t->ioact;
+		while (*ioact != NULL) {
 			struct ioword *iop = *ioact++;
 
-			/* heredoc is 0 when tracing (set -x) */
-			if ((iop->flag & IOTYPE) == IOHERE && iop->heredoc &&
-			    /* iop->delim[1] == '<' means here string */
-			    (!iop->delim || iop->delim[1] != '<')) {
-				tputc('\n', shf);
+			/* heredoc is NULL when tracing (set -x) */
+			if ((iop->flag & (IOTYPE | IOHERESTR)) == IOHERE &&
+			    iop->heredoc) {
+				shf_putc('\n', shf);
 				shf_puts(iop->heredoc, shf);
 				fptreef(shf, indent, "%s",
+				    iop->flag & IONDELIM ? "<<" :
 				    evalstr(iop->delim, 0));
-				need_nl = 1;
+				need_nl = true;
 			}
 		}
-		/* Last delimiter must be followed by a newline (this often
-		 * leads to an extra blank line, but its not worth worrying
-		 * about)
+		/*
+		 * Last delimiter must be followed by a newline (this
+		 * often leads to an extra blank line, but it's not
+		 * worth worrying about)
 		 */
 		if (need_nl)
-			tputc('\n', shf);
+			shf_putc('\n', shf);
 	}
 }
 
@@ -220,123 +234,136 @@
 
 	switch (type) {
 	case IOREAD:
-		shf_puts("< ", shf);
+		shf_puts("<", shf);
 		break;
 	case IOHERE:
 		shf_puts(flag & IOSKIP ? "<<-" : "<<", shf);
 		break;
 	case IOCAT:
-		shf_puts(">> ", shf);
+		shf_puts(">>", shf);
 		break;
 	case IOWRITE:
-		shf_puts(flag & IOCLOB ? ">| " : "> ", shf);
+		shf_puts(flag & IOCLOB ? ">|" : ">", shf);
 		break;
 	case IORDWR:
-		shf_puts("<> ", shf);
+		shf_puts("<>", shf);
 		break;
 	case IODUP:
 		shf_puts(flag & IORDUP ? "<&" : ">&", shf);
 		break;
 	}
-	/* name/delim are 0 when printing syntax errors */
+	/* name/delim are NULL when printing syntax errors */
 	if (type == IOHERE) {
 		if (iop->delim)
-			fptreef(shf, indent, "%s%S ",
-			    /* here string */ iop->delim[1] == '<' ? "" : " ",
-			    iop->delim);
+			fptreef(shf, indent, "%S ", iop->delim);
 		else
-			tputc(' ', shf);
+			shf_putc(' ', shf);
 	} else if (iop->name)
 		fptreef(shf, indent, (iop->flag & IONAMEXP) ? "%s " : "%S ",
 		    iop->name);
+	prevent_semicolon = false;
 }
 
-
-/*
- * variants of fputc, fputs for ptreef and snptreef
- */
-static void
-tputC(int c, struct shf *shf)
-{
-	if ((c&0x60) == 0) {		/* C0|C1 */
-		tputc((c&0x80) ? '$' : '^', shf);
-		tputc(((c&0x7F)|0x40), shf);
-	} else if ((c&0x7F) == 0x7F) {	/* DEL */
-		tputc((c&0x80) ? '$' : '^', shf);
-		tputc('?', shf);
-	} else
-		tputc(c, shf);
-}
-
-static void
-tputS(char *wp, struct shf *shf)
+/* variant of fputs for ptreef and wdstrip */
+static const char *
+wdvarput(struct shf *shf, const char *wp, int quotelevel, int opmode)
 {
-	int c, quotelevel = 0;
+	int c;
 
-	/* problems:
+	/*-
+	 * problems:
 	 *	`...` -> $(...)
 	 *	'foo' -> "foo"
+	 *	x${foo:-"hi"} -> x${foo:-hi} unless WDS_TPUTS
+	 *	x${foo:-'hi'} -> x${foo:-hi} unless WDS_KEEPQ
 	 * could change encoding to:
 	 *	OQUOTE ["'] ... CQUOTE ["']
 	 *	COMSUB [(`] ...\0	(handle $ ` \ and maybe " in `...` case)
 	 */
-	while (1)
+	while (/* CONSTCOND */ 1)
 		switch (*wp++) {
 		case EOS:
-			return;
+			return (--wp);
 		case ADELIM:
 		case CHAR:
-			tputC(*wp++, shf);
+			c = *wp++;
+			if ((opmode & WDS_MAGIC) &&
+			    (ISMAGIC(c) || c == '[' || c == NOT ||
+			    c == '-' || c == ']' || c == '*' || c == '?'))
+				shf_putc(MAGIC, shf);
+			shf_putc(c, shf);
 			break;
-		case QCHAR:
+		case QCHAR: {
+			bool doq;
+
 			c = *wp++;
-			if (!quotelevel || (c == '"' || c == '`' || c == '$'))
-				tputc('\\', shf);
-			tputC(c, shf);
+			doq = (c == '"' || c == '`' || c == '$' || c == '\\');
+			if (opmode & WDS_TPUTS) {
+				if (quotelevel == 0)
+					doq = true;
+			} else {
+				if (!(opmode & WDS_KEEPQ))
+					doq = false;
+			}
+			if (doq)
+				shf_putc('\\', shf);
+			shf_putc(c, shf);
 			break;
+		}
 		case COMSUB:
 			shf_puts("$(", shf);
-			while (*wp != 0)
-				tputC(*wp++, shf);
-			tputc(')', shf);
-			wp++;
+			while ((c = *wp++) != 0)
+				shf_putc(c, shf);
+			shf_putc(')', shf);
 			break;
 		case EXPRSUB:
 			shf_puts("$((", shf);
-			while (*wp != 0)
-				tputC(*wp++, shf);
+			while ((c = *wp++) != 0)
+				shf_putc(c, shf);
 			shf_puts("))", shf);
-			wp++;
 			break;
 		case OQUOTE:
-			quotelevel++;
-			tputc('"', shf);
+			if (opmode & WDS_TPUTS) {
+				quotelevel++;
+				shf_putc('"', shf);
+			}
 			break;
 		case CQUOTE:
-			if (quotelevel)
-				quotelevel--;
-			tputc('"', shf);
+			if (opmode & WDS_TPUTS) {
+				if (quotelevel)
+					quotelevel--;
+				shf_putc('"', shf);
+			}
 			break;
 		case OSUBST:
-			tputc('$', shf);
+			shf_putc('$', shf);
 			if (*wp++ == '{')
-				tputc('{', shf);
+				shf_putc('{', shf);
 			while ((c = *wp++) != 0)
-				tputC(c, shf);
+				shf_putc(c, shf);
+			wp = wdvarput(shf, wp, 0, opmode);
 			break;
 		case CSUBST:
 			if (*wp++ == '}')
-				tputc('}', shf);
-			break;
+				shf_putc('}', shf);
+			return (wp);
 		case OPAT:
-			tputc(*wp++, shf);
-			tputc('(', shf);
+			if (opmode & WDS_MAGIC) {
+				shf_putc(MAGIC, shf);
+				shf_putchar(*wp++ | 0x80, shf);
+			} else {
+				shf_putchar(*wp++, shf);
+				shf_putc('(', shf);
+			}
 			break;
 		case SPAT:
-			tputc('|', shf);
-			break;
+			c = '|';
+			if (0)
 		case CPAT:
-			tputc(')', shf);
+				c = /*(*/ ')';
+			if (opmode & WDS_MAGIC)
+				shf_putc(MAGIC, shf);
+			shf_putc(c, shf);
 			break;
 		}
 }
@@ -346,16 +373,14 @@
  * variable args with an ANSI compiler
  */
 /* VARARGS */
-int
+void
 fptreef(struct shf *shf, int indent, const char *fmt, ...)
 {
 	va_list va;
 
 	va_start(va, fmt);
-
 	vfptreef(shf, indent, fmt, va);
 	va_end(va);
-	return (0);
 }
 
 /* VARARGS */
@@ -371,7 +396,8 @@
 	vfptreef(&shf, 0, fmt, va);
 	va_end(va);
 
-	return (shf_sclose(&shf)); /* null terminates */
+	/* shf_sclose NUL terminates */
+	return (shf_sclose(&shf));
 }
 
 static void
@@ -383,48 +409,63 @@
 		if (c == '%') {
 			switch ((c = *fmt++)) {
 			case 'c':
-				tputc(va_arg(va, int), shf);
+				/* character (octet, probably) */
+				shf_putchar(va_arg(va, int), shf);
 				break;
 			case 's':
+				/* string */
 				shf_puts(va_arg(va, char *), shf);
 				break;
-			case 'S':	/* word */
-				tputS(va_arg(va, char *), shf);
+			case 'S':
+				/* word */
+				wdvarput(shf, va_arg(va, char *), 0, WDS_TPUTS);
 				break;
-			case 'd':	/* decimal */
+			case 'd':
+				/* signed decimal */
 				shf_fprintf(shf, "%d", va_arg(va, int));
 				break;
-			case 'u':	/* decimal */
+			case 'u':
+				/* unsigned decimal */
 				shf_fprintf(shf, "%u", va_arg(va, unsigned int));
 				break;
-			case 'T':	/* format tree */
+			case 'T':
+				/* format tree */
 				ptree(va_arg(va, struct op *), indent, shf);
-				break;
-			case ';':	/* newline or ; */
-			case 'N':	/* newline or space */
+				goto dont_trash_prevent_semicolon;
+			case ';':
+				/* newline or ; */
+			case 'N':
+				/* newline or space */
 				if (shf->flags & SHF_STRING) {
-					if (c == ';')
-						tputc(';', shf);
-					tputc(' ', shf);
+					if (c == ';' && !prevent_semicolon)
+						shf_putc(';', shf);
+					shf_putc(' ', shf);
 				} else {
 					int i;
 
-					tputc('\n', shf);
-					for (i = indent; i >= 8; i -= 8)
-						tputc('\t', shf);
-					for (; i > 0; --i)
-						tputc(' ', shf);
+					shf_putc('\n', shf);
+					i = indent;
+					while (i >= 8) {
+						shf_putc('\t', shf);
+						i -= 8;
+					}
+					while (i--)
+						shf_putc(' ', shf);
 				}
 				break;
 			case 'R':
+				/* I/O redirection */
 				pioact(shf, indent, va_arg(va, struct ioword *));
 				break;
 			default:
-				tputc(c, shf);
+				shf_putc(c, shf);
 				break;
 			}
 		} else
-			tputc(c, shf);
+			shf_putc(c, shf);
+		prevent_semicolon = false;
+ dont_trash_prevent_semicolon:
+		;
 	}
 }
 
@@ -454,11 +495,13 @@
 	if (t->vars == NULL)
 		r->vars = NULL;
 	else {
-		for (tw = (const char **)t->vars; *tw++ != NULL; )
-			;
-		rw = r->vars = alloc((tw - (const char **)t->vars + 1) *
+		tw = (const char **)t->vars;
+		while (*tw)
+			++tw;
+		rw = r->vars = alloc2(tw - (const char **)t->vars + 1,
 		    sizeof(*tw), ap);
-		for (tw = (const char **)t->vars; *tw != NULL; )
+		tw = (const char **)t->vars;
+		while (*tw)
 			*rw++ = wdcopy(*tw++, ap);
 		*rw = NULL;
 	}
@@ -466,11 +509,13 @@
 	if (t->args == NULL)
 		r->args = NULL;
 	else {
-		for (tw = t->args; *tw++ != NULL; )
-			;
-		r->args = (const char **)(rw = alloc((tw - t->args + 1) *
+		tw = t->args;
+		while (*tw)
+			++tw;
+		r->args = (const char **)(rw = alloc2(tw - t->args + 1,
 		    sizeof(*tw), ap));
-		for (tw = t->args; *tw != NULL; )
+		tw = t->args;
+		while (*tw)
 			*rw++ = wdcopy(*tw++, ap);
 		*rw = NULL;
 	}
@@ -487,7 +532,9 @@
 char *
 wdcopy(const char *wp, Area *ap)
 {
-	size_t len = wdscan(wp, EOS) - wp;
+	size_t len;
+
+	len = wdscan(wp, EOS) - wp;
 	return (memcpy(alloc(len, ap), wp, len));
 }
 
@@ -497,7 +544,7 @@
 {
 	int nest = 0;
 
-	while (1)
+	while (/* CONSTCOND */ 1)
 		switch (*wp++) {
 		case EOS:
 			return (wp);
@@ -546,88 +593,19 @@
 		}
 }
 
-/* return a copy of wp without any of the mark up characters and
- * with quote characters (" ' \) stripped.
- * (string is allocated from ATEMP)
+/*
+ * return a copy of wp without any of the mark up characters and with
+ * quote characters (" ' \) stripped. (string is allocated from ATEMP)
  */
 char *
-wdstrip(const char *wp, bool keepq, bool make_magic)
+wdstrip(const char *wp, int opmode)
 {
 	struct shf shf;
-	int c;
 
 	shf_sopen(NULL, 32, SHF_WR | SHF_DYNAMIC, &shf);
-
-	/* problems:
-	 *	`...` -> $(...)
-	 *	x${foo:-"hi"} -> x${foo:-hi}
-	 *	x${foo:-'hi'} -> x${foo:-hi} unless keepq
-	 */
-	while (1)
-		switch (*wp++) {
-		case EOS:
-			return (shf_sclose(&shf)); /* null terminates */
-		case ADELIM:
-		case CHAR:
-			c = *wp++;
-			if (make_magic && (ISMAGIC(c) || c == '[' || c == NOT ||
-			    c == '-' || c == ']' || c == '*' || c == '?'))
-				shf_putchar(MAGIC, &shf);
-			shf_putchar(c, &shf);
-			break;
-		case QCHAR:
-			c = *wp++;
-			if (keepq && (c == '"' || c == '`' || c == '$' || c == '\\'))
-				shf_putchar('\\', &shf);
-			shf_putchar(c, &shf);
-			break;
-		case COMSUB:
-			shf_puts("$(", &shf);
-			while (*wp != 0)
-				shf_putchar(*wp++, &shf);
-			shf_putchar(')', &shf);
-			break;
-		case EXPRSUB:
-			shf_puts("$((", &shf);
-			while (*wp != 0)
-				shf_putchar(*wp++, &shf);
-			shf_puts("))", &shf);
-			break;
-		case OQUOTE:
-			break;
-		case CQUOTE:
-			break;
-		case OSUBST:
-			shf_putchar('$', &shf);
-			if (*wp++ == '{')
-			    shf_putchar('{', &shf);
-			while ((c = *wp++) != 0)
-				shf_putchar(c, &shf);
-			break;
-		case CSUBST:
-			if (*wp++ == '}')
-				shf_putchar('}', &shf);
-			break;
-		case OPAT:
-			if (make_magic) {
-				shf_putchar(MAGIC, &shf);
-				shf_putchar(*wp++ | 0x80, &shf);
-			} else {
-				shf_putchar(*wp++, &shf);
-				shf_putchar('(', &shf);
-			}
-			break;
-		case SPAT:
-			if (make_magic)
-				shf_putchar(MAGIC, &shf);
-			shf_putchar('|', &shf);
-			break;
-		case CPAT:
-			if (make_magic)
-				shf_putchar(MAGIC, &shf);
-			shf_putchar(')', &shf);
-			break;
-		}
+	wdvarput(&shf, wp, 0, opmode);
+	/* shf_sclose NUL terminates */
+	return (shf_sclose(&shf));
 }
 
 static struct ioword **
@@ -636,9 +614,10 @@
 	struct ioword **ior;
 	int i;
 
-	for (ior = iow; *ior++ != NULL; )
-		;
-	ior = alloc((ior - iow + 1) * sizeof(struct ioword *), ap);
+	ior = iow;
+	while (*ior)
+		++ior;
+	ior = alloc2(ior - iow + 1, sizeof(struct ioword *), ap);
 
 	for (i = 0; iow[i] != NULL; i++) {
 		struct ioword *p, *q;
@@ -680,8 +659,9 @@
 	}
 
 	if (t->args != NULL) {
+		/*XXX we assume the caller is right */
 		union mksh_ccphack cw;
-		/* XXX we assume the caller is right */
+
 		cw.ro = t->args;
 		for (w = cw.rw; *w != NULL; w++)
 			afree(*w, ap);
@@ -703,7 +683,8 @@
 	struct ioword **iop;
 	struct ioword *p;
 
-	for (iop = iow; (p = *iop++) != NULL; ) {
+	iop = iow;
+	while ((p = *iop++) != NULL) {
 		if (p->name != NULL)
 			afree(p->name, ap);
 		if (p->delim != NULL)
@@ -714,3 +695,315 @@
 	}
 	afree(iow, ap);
 }
+
+void
+fpFUNCTf(struct shf *shf, int i, bool isksh, const char *k, struct op *v)
+{
+	if (isksh)
+		fptreef(shf, i, "%s %s %T", T_function, k, v);
+	else
+		fptreef(shf, i, "%s() %T", k, v);
+}
+
+
+/* for jobs.c */
+void
+vistree(char *dst, size_t sz, struct op *t)
+{
+	int c;
+	char *cp, *buf;
+
+	buf = alloc(sz, ATEMP);
+	snptreef(buf, sz, "%T", t);
+	cp = buf;
+	while ((c = *cp++)) {
+		if (((c & 0x60) == 0) || ((c & 0x7F) == 0x7F)) {
+			/* C0 or C1 control character or DEL */
+			if (!--sz)
+				break;
+			*dst++ = (c & 0x80) ? '$' : '^';
+			c = (c & 0x7F) ^ 0x40;
+		}
+		if (!--sz)
+			break;
+		*dst++ = c;
+	}
+	*dst = '\0';
+	afree(buf, ATEMP);
+}
+
+#ifdef DEBUG
+void
+dumpchar(struct shf *shf, int c)
+{
+	if (((c & 0x60) == 0) || ((c & 0x7F) == 0x7F)) {
+		/* C0 or C1 control character or DEL */
+		shf_putc((c & 0x80) ? '$' : '^', shf);
+		c = (c & 0x7F) ^ 0x40;
+	}
+	shf_putc(c, shf);
+}
+
+/* see: wdvarput */
+static const char *
+dumpwdvar_(struct shf *shf, const char *wp, int quotelevel)
+{
+	int c;
+
+	while (/* CONSTCOND */ 1) {
+		switch(*wp++) {
+		case EOS:
+			shf_puts("EOS", shf);
+			return (--wp);
+		case ADELIM:
+			shf_puts("ADELIM=", shf);
+			if (0)
+		case CHAR:
+				shf_puts("CHAR=", shf);
+			dumpchar(shf, *wp++);
+			break;
+		case QCHAR:
+			shf_puts("QCHAR<", shf);
+			c = *wp++;
+			if (quotelevel == 0 ||
+			    (c == '"' || c == '`' || c == '$' || c == '\\'))
+				shf_putc('\\', shf);
+			dumpchar(shf, c);
+			goto closeandout;
+		case COMSUB:
+			shf_puts("COMSUB<", shf);
+ dumpsub:
+			while ((c = *wp++) != 0)
+				dumpchar(shf, c);
+ closeandout:
+			shf_putc('>', shf);
+			break;
+		case EXPRSUB:
+			shf_puts("EXPRSUB<", shf);
+			goto dumpsub;
+		case OQUOTE:
+			shf_fprintf(shf, "OQUOTE{%d", ++quotelevel);
+			break;
+		case CQUOTE:
+			shf_fprintf(shf, "%d}CQUOTE", quotelevel);
+			if (quotelevel)
+				quotelevel--;
+			else
+				shf_puts("(err)", shf);
+			break;
+		case OSUBST:
+			shf_puts("OSUBST(", shf);
+			dumpchar(shf, *wp++);
+			shf_puts(")[", shf);
+			while ((c = *wp++) != 0)
+				dumpchar(shf, c);
+			shf_putc('|', shf);
+			wp = dumpwdvar_(shf, wp, 0);
+			break;
+		case CSUBST:
+			shf_puts("]CSUBST(", shf);
+			dumpchar(shf, *wp++);
+			shf_putc(')', shf);
+			return (wp);
+		case OPAT:
+			shf_puts("OPAT=", shf);
+			dumpchar(shf, *wp++);
+			break;
+		case SPAT:
+			shf_puts("SPAT", shf);
+			break;
+		case CPAT:
+			shf_puts("CPAT", shf);
+			break;
+		default:
+			shf_fprintf(shf, "INVAL<%u>", (uint8_t)wp[-1]);
+			break;
+		}
+		shf_putc(' ', shf);
+	}
+}
+void
+dumpwdvar(struct shf *shf, const char *wp)
+{
+	dumpwdvar_(shf, wp, 0);
+}
+
+void
+dumptree(struct shf *shf, struct op *t)
+{
+	int i;
+	const char **w, *name;
+	struct op *t1;
+	static int nesting = 0;
+
+	for (i = 0; i < nesting; ++i)
+		shf_putc('\t', shf);
+	++nesting;
+	shf_puts("{tree:" /*}*/, shf);
+	if (t == NULL) {
+		name = "(null)";
+		goto out;
+	}
+	switch (t->type) {
+#define OPEN(x) case x: name = #x; shf_puts(" {" #x ":", shf); /*}*/
+
+	OPEN(TCOM)
+		if (t->vars) {
+			i = 0;
+			w = (const char **)t->vars;
+			while (*w) {
+				shf_putc('\n', shf);
+				for (int j = 0; j < nesting; ++j)
+					shf_putc('\t', shf);
+				shf_fprintf(shf, " var%d<", i++);
+				dumpwdvar(shf, *w++);
+				shf_putc('>', shf);
+			}
+		} else
+			shf_puts(" #no-vars#", shf);
+		if (t->args) {
+			i = 0;
+			w = t->args;
+			while (*w) {
+				shf_putc('\n', shf);
+				for (int j = 0; j < nesting; ++j)
+					shf_putc('\t', shf);
+				shf_fprintf(shf, " arg%d<", i++);
+				dumpwdvar(shf, *w++);
+				shf_putc('>', shf);
+			}
+		} else
+			shf_puts(" #no-args#", shf);
+		break;
+	OPEN(TEXEC)
+ dumpleftandout:
+		t = t->left;
+ dumpandout:
+		shf_putc('\n', shf);
+		dumptree(shf, t);
+		break;
+	OPEN(TPAREN)
+		goto dumpleftandout;
+	OPEN(TPIPE)
+ dumpleftmidrightandout:
+		shf_putc('\n', shf);
+		dumptree(shf, t->left);
+/* middumprightandout: (unused) */
+		shf_fprintf(shf, "/%s:", name);
+ dumprightandout:
+		t = t->right;
+		goto dumpandout;
+	OPEN(TLIST)
+		goto dumpleftmidrightandout;
+	OPEN(TOR)
+		goto dumpleftmidrightandout;
+	OPEN(TAND)
+		goto dumpleftmidrightandout;
+	OPEN(TBANG)
+		goto dumprightandout;
+	OPEN(TDBRACKET)
+		i = 0;
+		w = t->args;
+		while (*w) {
+			shf_putc('\n', shf);
+			for (int j = 0; j < nesting; ++j)
+				shf_putc('\t', shf);
+			shf_fprintf(shf, " arg%d<", i++);
+			dumpwdvar(shf, *w++);
+			shf_putc('>', shf);
+		}
+		break;
+	OPEN(TFOR)
+ dumpfor:
+		shf_fprintf(shf, " str<%s>", t->str);
+		if (t->vars != NULL) {
+			i = 0;
+			w = (const char **)t->vars;
+			while (*w) {
+				shf_putc('\n', shf);
+				for (int j = 0; j < nesting; ++j)
+					shf_putc('\t', shf);
+				shf_fprintf(shf, " var%d<", i++);
+				dumpwdvar(shf, *w++);
+				shf_putc('>', shf);
+			}
+		}
+		goto dumpleftandout;
+	OPEN(TSELECT)
+		goto dumpfor;
+	OPEN(TCASE)
+		shf_fprintf(shf, " str<%s>", t->str);
+		i = 0;
+		for (t1 = t->left; t1 != NULL; t1 = t1->right) {
+			shf_putc('\n', shf);
+			for (int j = 0; j < nesting; ++j)
+				shf_putc('\t', shf);
+			shf_fprintf(shf, " sub%d[(", i);
+			w = (const char **)t1->vars;
+			while (*w) {
+				dumpwdvar(shf, *w);
+				if (w[1] != NULL)
+					shf_putc('|', shf);
+				++w;
+			}
+			shf_putc(')', shf);
+			shf_putc('\n', shf);
+			dumptree(shf, t1->left);
+			shf_fprintf(shf, " /%d]", i++);
+		}
+		break;
+	OPEN(TWHILE)
+		goto dumpleftmidrightandout;
+	OPEN(TUNTIL)
+		goto dumpleftmidrightandout;
+	OPEN(TBRACE)
+		goto dumpleftandout;
+	OPEN(TCOPROC)
+		goto dumpleftandout;
+	OPEN(TASYNC)
+		goto dumpleftandout;
+	OPEN(TFUNCT)
+		shf_fprintf(shf, " str<%s> ksh<%s>", t->str,
+		    t->u.ksh_func ? "yes" : "no");
+		goto dumpleftandout;
+	OPEN(TTIME)
+		goto dumpleftandout;
+	OPEN(TIF)
+ dumpif:
+		shf_putc('\n', shf);
+		dumptree(shf, t->left);
+		t = t->right;
+		if (t->left != NULL) {
+			shf_puts(" /TTHEN:\n", shf);
+			dumptree(shf, t->left);
+		}
+		if (t->right && t->right->type == TELIF) {
+			shf_puts(" /TELIF:", shf);
+			t = t->right;
+			goto dumpif;
+		}
+		if (t->right != NULL) {
+			shf_puts(" /TELSE:\n", shf);
+			dumptree(shf, t->right);
+		}
+		break;
+	OPEN(TEOF)
+ dumpunexpected:
+		shf_puts("unexpected", shf);
+		break;
+	OPEN(TELIF)
+		goto dumpunexpected;
+	OPEN(TPAT)
+		goto dumpunexpected;
+	default:
+		name = "TINVALID";
+		shf_fprintf(shf, "{T<%d>:" /*}*/, t->type);
+		goto dumpunexpected;
+
+#undef OPEN
+	}
+ out:
+	shf_fprintf(shf, /*{*/ " /%s}\n", name);
+	--nesting;
+}
+#endif
Index: src/bin/mksh/var.c
diff -u src/bin/mksh/var.c:1.104 src/bin/mksh/var.c:1.121
--- src/bin/mksh/var.c:1.104	Thu Jan 28 20:26:52 2010
+++ src/bin/mksh/var.c	Sat May  7 02:02:47 2011
@@ -1,7 +1,7 @@
 /*	$OpenBSD: var.c,v 1.34 2007/10/15 02:16:35 deraadt Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -22,7 +22,11 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/var.c,v 1.104 2010/01/28 20:26:52 tg Exp $");
+#if defined(__OpenBSD__)
+#include <sys/sysctl.h>
+#endif
+
+__RCSID("$MirOS: src/bin/mksh/var.c,v 1.121 2011/05/07 02:02:47 tg Exp $");
 
 /*
  * Variables
@@ -35,8 +39,10 @@
  */
 static struct tbl vtemp;
 static struct table specials;
+static uint32_t lcg_state = 5381;
+
 static char *formatstr(struct tbl *, const char *);
-static void export(struct tbl *, const char *);
+static void exportprep(struct tbl *, const char *);
 static int special(const char *);
 static void unspecial(const char *);
 static void getspec(struct tbl *);
@@ -46,12 +52,6 @@
 static mksh_ari_t intval(struct tbl *);
 static struct tbl *arraysearch(struct tbl *, uint32_t);
 static const char *array_index_calc(const char *, bool *, uint32_t *);
-#if !HAVE_ARC4RANDOM
-static uint32_t oaathash_update(register uint32_t, register const uint8_t *,
-    register size_t);
-
-static uint32_t lcg_state = 5381;
-#endif
 
 uint8_t set_refflag = 0;
 
@@ -392,7 +392,7 @@
 	base = getint(vp, &num, false);
 	if (base == -1)
 		/* XXX check calls - is error here ok by POSIX? */
-		errorf("%s: bad number", str_val(vp));
+		errorf("%s: %s", str_val(vp), "bad number");
 	return (num);
 }
 
@@ -405,9 +405,9 @@
 
 	error_ok &= ~0x4;
 	if ((vq->flag & RDONLY) && !no_ro_check) {
-		warningf(true, "%s: is read only", vq->name);
+		warningf(true, "%s: %s", vq->name, "is read only");
 		if (!error_ok)
-			errorfz();
+			errorfxz(2);
 		return (0);
 	}
 	if (!(vq->flag&INTEGER)) { /* string dest */
@@ -425,7 +425,7 @@
 		if (s && (vq->flag & (UCASEV_AL|LCASEV|LJUST|RJUST)))
 			s = salloc = formatstr(vq, s);
 		if ((vq->flag&EXPORT))
-			export(vq, s);
+			exportprep(vq, s);
 		else {
 			strdupx(vq->val.s, s, vq->areap);
 			vq->flag |= ALLOC;
@@ -644,14 +644,17 @@
  * make vp->val.s be "name=value" for quick exporting.
  */
 static void
-export(struct tbl *vp, const char *val)
+exportprep(struct tbl *vp, const char *val)
 {
 	char *xp;
 	char *op = (vp->flag&ALLOC) ? vp->val.s : NULL;
-	int namelen = strlen(vp->name);
-	int vallen = strlen(val) + 1;
+	size_t namelen, vallen;
+
+	namelen = strlen(vp->name);
+	vallen = strlen(val) + 1;
 
 	vp->flag |= ALLOC;
+	/* since name+val are both in memory this can go unchecked */
 	xp = alloc(namelen + 1 + vallen, vp->areap);
 	memcpy(vp->val.s = xp, vp->name, namelen);
 	xp += namelen;
@@ -675,6 +678,7 @@
 	char *tvar;
 	const char *val;
 	int len;
+	bool vappend = false;
 
 	/* check for valid variable name, search for value */
 	val = skip_varname(var, false);
@@ -684,8 +688,8 @@
 	mkssert(*var != 0);
 	if (*val == '[') {
 		if (set_refflag)
-			errorf("%s: reference variable cannot be an array",
-			    var);
+			errorf("%s: %s", var,
+			    "reference variable can't be an array");
 		len = array_ref_len(val);
 		if (len == 0)
 			return (NULL);
@@ -703,15 +707,19 @@
 		}
 		val += len;
 	}
-	if (*val == '=')
-		strndupx(tvar, var, val++ - var, ATEMP);
-	else {
+	if (val[0] == '=' || (val[0] == '+' && val[1] == '=')) {
+		strndupx(tvar, var, val - var, ATEMP);
+		if (*val++ == '+') {
+			++val;
+			vappend = true;
+		}
+	} else {
 		/* Importing from original environment: must have an = */
 		if (set & IMPORT)
 			return (NULL);
 		strdupx(tvar, var, ATEMP);
 		val = NULL;
-		/* handle foo[*] ⇒ foo (whole array) mapping for R39b */
+		/* handle foo[*] => foo (whole array) mapping for R39b */
 		len = strlen(tvar);
 		if (len > 3 && tvar[len-3] == '[' && tvar[len-2] == '*' &&
 		    tvar[len-1] == ']')
@@ -721,9 +729,9 @@
 	/* Prevent typeset from creating a local PATH/ENV/SHELL */
 	if (Flag(FRESTRICTED) && (strcmp(tvar, "PATH") == 0 ||
 	    strcmp(tvar, "ENV") == 0 || strcmp(tvar, "SHELL") == 0))
-		errorf("%s: restricted", tvar);
+		errorf("%s: %s", tvar, "restricted");
 
-	vp = (set&LOCAL) ? local(tvar, (set & LOCAL_COPY) ? true : false) :
+	vp = (set&LOCAL) ? local(tvar, tobool(set & LOCAL_COPY)) :
 	    global(tvar);
 	if (set_refflag == 2 && (vp->flag & (ARRAY|ASSOC)) == ASSOC)
 		vp->flag &= ~ASSOC;
@@ -749,13 +757,15 @@
 
 	vpbase = (vp->flag & ARRAY) ? global(arrayname(var)) : vp;
 
-	/* only allow export flag to be set. AT&T ksh allows any attribute to
-	 * be changed which means it can be truncated or modified (-L/-R/-Z/-i)
+	/*
+	 * only allow export flag to be set; AT&T ksh allows any
+	 * attribute to be changed which means it can be truncated or
+	 * modified (-L/-R/-Z/-i)
 	 */
 	if ((vpbase->flag&RDONLY) &&
 	    (val || clr || (set & ~EXPORT)))
 		/* XXX check calls - is error here ok by POSIX? */
-		errorf("%s: is read only", tvar);
+		errorfx(2, "%s: %s", tvar, "is read only");
 	afree(tvar, ATEMP);
 
 	/* most calls are with set/clr == 0 */
@@ -790,8 +800,9 @@
 				t->flag &= ~ALLOC;
 			}
 			t->flag = (t->flag | set) & ~clr;
-			/* Don't change base if assignment is to be done,
-			 * in case assignment fails.
+			/*
+			 * Don't change base if assignment is to be
+			 * done, in case assignment fails.
 			 */
 			if ((set & INTEGER) && base > 0 && (!val || t != vp))
 				t->type = base;
@@ -799,9 +810,11 @@
 				t->u2.field = field;
 			if (fake_assign) {
 				if (!setstr(t, s, KSH_RETURN_ERROR)) {
-					/* Somewhat arbitrary action here:
-					 * zap contents of variable, but keep
-					 * the flag settings.
+					/*
+					 * Somewhat arbitrary action
+					 * here: zap contents of
+					 * variable, but keep the flag
+					 * settings.
 					 */
 					ok = false;
 					if (t->flag & INTEGER)
@@ -822,6 +835,14 @@
 	}
 
 	if (val != NULL) {
+		char *tval;
+
+		if (vappend) {
+			tval = shf_smprintf("%s%s", str_val(vp), val);
+			val = tval;
+		} else
+			tval = NULL;
+
 		if (vp->flag&INTEGER) {
 			/* do not zero base before assignment */
 			setstr(vp, val, KSH_UNWIND_ERROR | 0x4);
@@ -831,12 +852,15 @@
 		} else
 			/* setstr can't fail (readonly check already done) */
 			setstr(vp, val, KSH_RETURN_ERROR | 0x4);
+
+		if (tval != NULL)
+			afree(tval, ATEMP);
 	}
 
 	/* only x[0] is ever exported, so use vpbase */
 	if ((vpbase->flag&EXPORT) && !(vpbase->flag&INTEGER) &&
 	    vpbase->type == 0)
-		export(vpbase, (vpbase->flag&ISSET) ? vpbase->val.s : null);
+		exportprep(vpbase, (vpbase->flag&ISSET) ? vpbase->val.s : null);
 
 	return (vp);
 }
@@ -907,7 +931,7 @@
 			char c;
 			int depth = 0;
 
-			while (1) {
+			while (/* CONSTCOND */ 1) {
 				if (p[0] != CHAR)
 					break;
 				c = p[1];
@@ -939,7 +963,8 @@
 {
 	const char *p = skip_wdvarname(s, true);
 
-	return (p != s && p[0] == CHAR && p[1] == '=');
+	return (p != s && p[0] == CHAR &&
+	    (p[1] == '=' || (p[1] == '+' && p[2] == CHAR && p[3] == '=')));
 }
 
 /*
@@ -982,48 +1007,6 @@
 	return ((char **)XPclose(denv));
 }
 
-#if !HAVE_ARC4RANDOM
-static uint32_t
-oaathash_update(register uint32_t h, register const uint8_t *cp,
-    register size_t n)
-{
-	while (n--) {
-		h += *cp++;
-		h += h << 10;
-		h ^= h >> 6;
-	}
-
-	return (h);
-}
-
-void
-change_random(const void *vp, size_t n)
-{
-	register uint32_t h = 0x100;
-	struct {
-		const void *sp, *bp, *dp;
-		size_t dsz;
-		struct timeval tv;
-		uint32_t s;
-	} i;
-
-	i.dp = vp;
-	i.dsz = n;
-	i.s = lcg_state;
-	i.bp = &lcg_state;
-	i.sp = &i;
-	gettimeofday(&i.tv, NULL);
-	h = oaathash_update(oaathash_update(h, (void *)&i, sizeof(i)), vp, n);
-
-	/* oaathash_finalise */
-	h += h << 3;
-	h ^= h >> 11;
-	h += h << 15;
-
-	lcg_state = h;
-}
-#endif
-
 /*
  * handle special variables with side effects - PATH, SECONDS.
  */
@@ -1074,15 +1057,11 @@
 			return;
 		break;
 	case V_RANDOM:
-#if HAVE_ARC4RANDOM
-		i = arc4random() & 0x7FFF;
-#else
 		/*
 		 * this is the same Linear Congruential PRNG as Borland
 		 * C/C++ allegedly uses in its built-in rand() function
 		 */
 		i = ((lcg_state = 22695477 * lcg_state + 1) >> 16) & 0x7FFF;
-#endif
 		break;
 	case V_HISTSIZE:
 		i = histsize;
@@ -1127,7 +1106,8 @@
 			afree(path, APERM);
 		s = str_val(vp);
 		strdupx(path, s, APERM);
-		flushcom(1);	/* clear tracked aliases */
+		/* clear tracked aliases */
+		flushcom(true);
 		return;
 	case V_IFS:
 		setctypes(s = str_val(vp), C_IFS);
@@ -1149,17 +1129,17 @@
 			    stat(s, &statb) == 0 && S_ISDIR(statb.st_mode))
 				strdupx(tmpdir, s, APERM);
 		}
-		break;
+		return;
 #if HAVE_PERSISTENT_HISTORY
 	case V_HISTFILE:
 		sethistfile(str_val(vp));
-		break;
+		return;
 #endif
 	case V_TMOUT:
 		/* AT&T ksh seems to do this (only listen if integer) */
 		if (vp->flag & INTEGER)
 			ksh_tmout = vp->val.i >= 0 ? vp->val.i : 0;
-		break;
+		return;
 
 	/* common sub-cases */
 	case V_OPTIND:
@@ -1196,25 +1176,11 @@
 			x_lins = i;
 		break;
 	case V_RANDOM:
-#if HAVE_ARC4RANDOM
-#if HAVE_ARC4RANDOM_PUSHB
-		if (Flag(FARC4RANDOM))
-			/*
-			 * things like initialisation, environment import,
-			 * etc. are already done
-			 */
-			arc4random_pushb(&i, sizeof(i));
-		else
-			/* during start-up phase or somesuch */
-#endif	/* HAVE_ARC4RANDOM_PUSHB */
-			arc4random_addrandom((void *)&i, sizeof(i));
-#else	/* !HAVE_ARC4RANDOM */
 		/*
-		 * mksh R40+ no longer has the traditional repeatability
+		 * mksh R39d+ no longer has the traditional repeatability
 		 * of $RANDOM sequences, but always retains state
 		 */
-		change_random(&i, sizeof(i));
-#endif	/* !HAVE_ARC4RANDOM */
+		rndset((long)i);
 		break;
 	case V_SECONDS:
 		{
@@ -1239,7 +1205,8 @@
 		if (path)
 			afree(path, APERM);
 		strdupx(path, def_path, APERM);
-		flushcom(1);	/* clear tracked aliases */
+		/* clear tracked aliases */
+		flushcom(true);
 		break;
 	case V_IFS:
 		setctypes(" \t\n", C_IFS);
@@ -1259,13 +1226,12 @@
 		unspecial(vp->name);
 		break;
 
-	/* AT&T ksh man page says OPTIND, OPTARG and _ lose special meaning,
-	 * but OPTARG does not (still set by getopts) and _ is also still
-	 * set in various places.
-	 * Don't know what AT&T does for:
-	 *		HISTSIZE, HISTFILE,
-	 * Unsetting these in AT&T ksh does not loose the 'specialness':
-	 * no effect: IFS, COLUMNS, PATH, TMPDIR
+	/*
+	 * AT&T ksh man page says OPTIND, OPTARG and _ lose special
+	 * meaning, but OPTARG does not (still set by getopts) and _ is
+	 * also still set in various places. Don't know what AT&T does
+	 * for HISTSIZE, HISTFILE. Unsetting these in AT&T ksh does not
+	 * loose the 'specialness': IFS, COLUMNS, PATH, TMPDIR
 	 */
 	}
 }
@@ -1277,7 +1243,7 @@
 static struct tbl *
 arraysearch(struct tbl *vp, uint32_t val)
 {
-	struct tbl *prev, *curr, *new;
+	struct tbl *prev, *curr, *news;
 	size_t len;
 
 	vp->flag = (vp->flag | (ARRAY|DEFINED)) & ~ASSOC;
@@ -1293,25 +1259,26 @@
 	if (curr && curr->ua.index == val) {
 		if (curr->flag&ISSET)
 			return (curr);
-		new = curr;
+		news = curr;
 	} else
-		new = NULL;
-	len = strlen(vp->name) + 1;
-	if (!new) {
-		new = alloc(offsetof(struct tbl, name[0]) + len, vp->areap);
-		memcpy(new->name, vp->name, len);
-	}
-	new->flag = (vp->flag & ~(ALLOC|DEFINED|ISSET|SPECIAL)) | AINDEX;
-	new->type = vp->type;
-	new->areap = vp->areap;
-	new->u2.field = vp->u2.field;
-	new->ua.index = val;
-
-	if (curr != new) {		/* not reusing old array entry */
-		prev->u.array = new;
-		new->u.array = curr;
+		news = NULL;
+	if (!news) {
+		len = strlen(vp->name);
+		checkoktoadd(len, 1 + offsetof(struct tbl, name[0]));
+		news = alloc(offsetof(struct tbl, name[0]) + ++len, vp->areap);
+		memcpy(news->name, vp->name, len);
+	}
+	news->flag = (vp->flag & ~(ALLOC|DEFINED|ISSET|SPECIAL)) | AINDEX;
+	news->type = vp->type;
+	news->areap = vp->areap;
+	news->u2.field = vp->u2.field;
+	news->ua.index = val;
+
+	if (curr != news) {		/* not reusing old array entry */
+		prev->u.array = news;
+		news->u.array = curr;
 	}
-	return (new);
+	return (news);
 }
 
 /* Return the length of an array reference (eg, [1+2]) - cp is assumed
@@ -1356,32 +1323,50 @@
 set_array(const char *var, bool reset, const char **vals)
 {
 	struct tbl *vp, *vq;
-	mksh_uari_t i;
+	mksh_uari_t i, j = 0;
 	const char *ccp;
 #ifndef MKSH_SMALL
-	char *cp;
-	mksh_uari_t j;
+	char *cp = NULL;
 #endif
 
 	/* to get local array, use "typeset foo; set -A foo" */
-	vp = global(var);
+#ifndef MKSH_SMALL
+	i = strlen(var);
+	if (i > 0 && var[i - 1] == '+') {
+		/* append mode */
+		reset = false;
+		strndupx(cp, var, i - 1, ATEMP);
+	}
+#define CPORVAR	(cp ? cp : var)
+#else
+#define CPORVAR	var
+#endif
+	vp = global(CPORVAR);
 
 	/* Note: AT&T ksh allows set -A but not set +A of a read-only var */
 	if ((vp->flag&RDONLY))
-		errorf("%s: is read only", var);
+		errorfx(2, "%s: %s", CPORVAR, "is read only");
 	/* This code is quite non-optimal */
 	if (reset)
 		/* trash existing values and attributes */
 		unset(vp, 1);
-	/* todo: would be nice for assignment to completely succeed or
+	/*
+	 * todo: would be nice for assignment to completely succeed or
 	 * completely fail. Only really effects integer arrays:
 	 * evaluation of some of vals[] may fail...
 	 */
 	i = 0;
 #ifndef MKSH_SMALL
-	j = 0;
-#else
-#define j i
+	if (cp != NULL) {
+		/* find out where to set when appending */
+		for (vq = vp; vq; vq = vq->u.array) {
+			if (!(vq->flag & ISSET))
+				continue;
+			if (arrayindex(vq) >= j)
+				j = arrayindex(vq) + 1;
+		}
+		afree(cp, ATEMP);
+	}
 #endif
 	while ((ccp = vals[i])) {
 #ifndef MKSH_SMALL
@@ -1411,9 +1396,7 @@
 		/* would be nice to deal with errors here... (see above) */
 		setstr(vq, ccp, KSH_RETURN_ERROR);
 		i++;
-#ifndef MKSH_SMALL
 		j++;
-#endif
 	}
 
 	return (i);
@@ -1433,7 +1416,7 @@
 	}
 
 #ifdef TIOCGWINSZ
-	/* check if window size has changed since first time */
+	/* check if window size has changed */
 	if (tty_fd >= 0) {
 		struct winsize ws;
 
@@ -1451,4 +1434,49 @@
 		x_cols = 80;
 	if (x_lins < MIN_LINS)
 		x_lins = 24;
+
+#ifdef SIGWINCH
+	got_winch = 0;
+#endif
+}
+
+uint32_t
+hash(const void *s)
+{
+	register uint32_t h;
+
+	oaat1_init_impl(h);
+	oaat1_addstr_impl(h, s);
+	oaat1_fini_impl(h);
+	return (h);
+}
+
+void
+rndset(long v)
+{
+	register uint32_t h;
+
+	oaat1_init_impl(h);
+	oaat1_addmem_impl(h, &lcg_state, sizeof(lcg_state));
+	oaat1_addmem_impl(h, &v, sizeof(v));
+
+#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)
+	/*
+	 * either we have very chap entropy get and push available,
+	 * with malloc() pulling in this code already anyway, or the
+	 * user requested us to use the old functions
+	 */
+	lcg_state = h;
+	oaat1_fini_impl(lcg_state);
+#if defined(arc4random_pushb_fast)
+	arc4random_pushb_fast(&lcg_state, sizeof(lcg_state));
+	lcg_state = arc4random();
+#else
+	lcg_state = arc4random_pushb(&lcg_state, sizeof(lcg_state));
+#endif
+	oaat1_addmem_impl(h, &lcg_state, sizeof(lcg_state));
+#endif
+
+	oaat1_fini_impl(h);
+	lcg_state = h;
 }
