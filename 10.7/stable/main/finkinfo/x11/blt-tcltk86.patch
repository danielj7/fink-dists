diff -uNr blt2.4z/src/bltArrayObj.c blt2.4z.tcltk86/src/bltArrayObj.c
--- blt2.4z/src/bltArrayObj.c	2002-07-12 14:38:47.000000000 -0400
+++ blt2.4z.tcltk86/src/bltArrayObj.c	2013-08-20 11:23:00.000000000 -0400
@@ -54,7 +54,7 @@
     Blt_HashEntry *hPtr;
     Blt_HashTable *tablePtr;
     Tcl_Obj *elemObjPtr;
-    Tcl_ObjType *oldTypePtr = objPtr->typePtr;
+    const Tcl_ObjType *oldTypePtr = objPtr->typePtr;
     char **elemArr;
     char *string;
     int isNew;
diff -uNr blt2.4z/src/bltInit.c blt2.4z.tcltk86/src/bltInit.c
--- blt2.4z/src/bltInit.c	2013-08-20 12:00:03.000000000 -0400
+++ blt2.4z.tcltk86/src/bltInit.c	2013-08-20 11:23:00.000000000 -0400
@@ -454,7 +454,7 @@
 	    return TCL_ERROR;
 	}
 	Tcl_SetAssocData(interp, BLT_THREAD_KEY, NULL, 
-		(ClientData)(flags | BLT_TCL_CMDS));
+		(ClientData)(intptr_t)(flags | BLT_TCL_CMDS));
     }
 #ifndef TCL_ONLY
     if ((flags & BLT_TK_CMDS) == 0) {
@@ -497,7 +497,7 @@
 	}
 	Blt_InitEpsCanvasItem(interp);
 	Tcl_SetAssocData(interp, BLT_THREAD_KEY, NULL, 
-		(ClientData)(flags | BLT_TK_CMDS));
+		(ClientData)(intptr_t)(flags | BLT_TK_CMDS));
     }
 #endif
     return TCL_OK;
diff -uNr blt2.4z/src/bltPs.c blt2.4z.tcltk86/src/bltPs.c
--- blt2.4z/src/bltPs.c	2002-09-18 18:30:51.000000000 -0400
+++ blt2.4z.tcltk86/src/bltPs.c	2013-08-20 11:23:42.000000000 -0400
@@ -893,7 +893,7 @@
 	return;
     }
     if ((relief == TK_RELIEF_SOLID) ||
-	(borderPtr->lightColor == NULL) || (borderPtr->darkColor == NULL)) {
+	(borderPtr->lightColorPtr == NULL) || (borderPtr->darkColorPtr == NULL)) {
 	if (relief == TK_RELIEF_SOLID) {
 	    darkColor.red = darkColor.blue = darkColor.green = 0x00;
 	    lightColor.red = lightColor.blue = lightColor.green = 0x00;
@@ -901,7 +901,7 @@
 	} else {
 	    Screen *screenPtr;
 
-	    lightColor = *borderPtr->bgColor;
+	    lightColor = *borderPtr->bgColorPtr;
 	    screenPtr = Tk_Screen(tokenPtr->tkwin);
 	    if (lightColor.pixel == WhitePixelOfScreen(screenPtr)) {
 		darkColor.red = darkColor.blue = darkColor.green = 0x00;
@@ -912,8 +912,8 @@
 	lightColorPtr = &lightColor;
 	darkColorPtr = &darkColor;
     } else {
-	lightColorPtr = borderPtr->lightColor;
-	darkColorPtr = borderPtr->darkColor;
+	lightColorPtr = borderPtr->lightColorPtr;
+	darkColorPtr = borderPtr->darkColorPtr;
     }
 
 
@@ -942,7 +942,7 @@
 	topColor = darkColorPtr;
 	bottomColor = lightColorPtr;
     } else {
-	topColor = bottomColor = borderPtr->bgColor;
+	topColor = bottomColor = borderPtr->bgColorPtr;
     }
     Blt_BackgroundToPostScript(tokenPtr, bottomColor);
     Blt_RectangleToPostScript(tokenPtr, x, y + height - borderWidth, width,
@@ -982,7 +982,7 @@
      * Setting the pen color as foreground or background only affects
      * the plot when the colormode option is "monochrome".
      */
-    Blt_BackgroundToPostScript(tokenPtr, borderPtr->bgColor);
+    Blt_BackgroundToPostScript(tokenPtr, borderPtr->bgColorPtr);
     Blt_RectangleToPostScript(tokenPtr, x, y, width, height);
     Blt_Draw3DRectangleToPostScript(tokenPtr, border, x, y, width, height,
 	borderWidth, relief);
diff -uNr blt2.4z/src/bltText.c blt2.4z.tcltk86/src/bltText.c
--- blt2.4z/src/bltText.c	2013-08-20 12:00:03.000000000 -0400
+++ blt2.4z.tcltk86/src/bltText.c	2013-08-20 11:23:42.000000000 -0400
@@ -944,7 +944,7 @@
 	    TkBorder *borderPtr = (TkBorder *) tsPtr->border;
 	    XColor *color1, *color2;
 
-	    color1 = borderPtr->lightColor, color2 = borderPtr->darkColor;
+	    color1 = borderPtr->lightColorPtr, color2 = borderPtr->darkColorPtr;
 	    if (tsPtr->state & STATE_EMPHASIS) {
 		XColor *hold;
 
@@ -1008,7 +1008,7 @@
 	TkBorder *borderPtr = (TkBorder *) tsPtr->border;
 	XColor *color1, *color2;
 
-	color1 = borderPtr->lightColor, color2 = borderPtr->darkColor;
+	color1 = borderPtr->lightColorPtr, color2 = borderPtr->darkColorPtr;
 	if (tsPtr->state & STATE_EMPHASIS) {
 	    XColor *hold;
 
diff -uNr blt2.4z/src/bltTkInt.h blt2.4z.tcltk86/src/bltTkInt.h
--- blt2.4z/src/bltTkInt.h	2001-12-06 00:30:15.000000000 -0500
+++ blt2.4z.tcltk86/src/bltTkInt.h	2013-08-20 11:23:42.000000000 -0400
@@ -27,214 +27,8 @@
 #ifndef _BLT_TKINT_H
 #define _BLT_TKINT_H
 
-typedef struct {
-    Tk_Uid family;		/* Font family. The most important field. */
-    int pointsize;		/* Pointsize of font, 0 for default size, or
-				 * negative number meaning pixel size. */
-    int weight;			/* Weight flag; see below for def'n. */
-    int slant;			/* Slant flag; see below for def'n. */
-    int underline;		/* Non-zero for underline font. */
-    int overstrike;		/* Non-zero for overstrike font. */
-} TkFontAttributes;
-
-typedef struct {
-    int ascent;			/* From baseline to top of font. */
-    int descent;		/* From baseline to bottom of font. */
-    int maxWidth;		/* Width of widest character in font. */
-    int fixed;			/* Non-zero if this is a fixed-width font,
-				 * 0 otherwise. */
-} TkFontMetrics;
-
-
-typedef struct TkFontStruct {
-    /*
-     * Fields used and maintained exclusively by generic code.
-     */
-#if (TK_VERSION_NUMBER >= _VERSION(8,1,0))
-    int resourceRefCount;	/* Number of active uses of this font (each
-				 * active use corresponds to a call to
-				 * Tk_AllocFontFromTable or Tk_GetFont).
-				 * If this count is 0, then this TkFont
-				 * structure is no longer valid and it isn't
-				 * present in a hash table: it is being
-				 * kept around only because there are objects
-				 * referring to it.  The structure is freed
-				 * when resourceRefCount and objRefCount
-				 * are both 0. */
-    int objRefCount;		/* The number of Tcl objects that reference
-				 * this structure. */
-#else
-    int refCount;		/* Number of users of the TkFont. */
-#endif
-    Tcl_HashEntry *cacheHashPtr;/* Entry in font cache for this structure,
-				 * used when deleting it. */
-    Tcl_HashEntry *namedHashPtr;/* Pointer to hash table entry that
-				 * corresponds to the named font that the
-				 * tkfont was based on, or NULL if the tkfont
-				 * was not based on a named font. */
-#if (TK_VERSION_NUMBER >= _VERSION(8,1,0))
-    Screen *screen;		/* The screen where this font is valid. */
-#endif /* TK_VERSION_NUMBER >= 8.1.0 */
-    int tabWidth;		/* Width of tabs in this font (pixels). */
-    int underlinePos;		/* Offset from baseline to origin of
-				 * underline bar (used for drawing underlines
-				 * on a non-underlined font). */
-    int underlineHeight;	/* Height of underline bar (used for drawing
-				 * underlines on a non-underlined font). */
-
-    /*
-     * Fields in the generic font structure that are filled in by
-     * platform-specific code.
-     */
-
-    Font fid;			/* For backwards compatibility with XGCValues
-				 * structures.  Remove when TkGCValues is
-				 * implemented.  */
-    TkFontAttributes fa;	/* Actual font attributes obtained when the
-				 * the font was created, as opposed to the
-				 * desired attributes passed in to
-				 * TkpGetFontFromAttributes().  The desired
-				 * metrics can be determined from the string
-				 * that was used to create this font. */
-    TkFontMetrics fm;		/* Font metrics determined when font was
-				 * created. */
-#if (TK_VERSION_NUMBER >= _VERSION(8,1,0))
-    struct TkFontStruct *nextPtr;	/* Points to the next TkFont structure with
-				 * the same name.  All fonts with the
-				 * same name (but different displays) are
-				 * chained together off a single entry in
-				 * a hash table. */
-#endif /* TK_VERSION_NUMBER >= 8.1.0 */
-} TkFont;
-
-/*
- * This structure is used by the Mac and Window porting layers as
- * the internal representation of a clip_mask in a GC.
- */
-typedef struct TkRegionStruct *TkRegion;
-
-typedef struct {
-    int type;			/* One of TKP_CLIP_PIXMAP or TKP_CLIP_REGION */
-    union {
-	Pixmap pixmap;
-	TkRegion region;
-    } value;
-} TkpClipMask;
-
-#define TKP_CLIP_PIXMAP 0
-#define TKP_CLIP_REGION 1
-
-#ifdef WIN32
-/*
- * The TkWinDrawable is the internal implementation of an X Drawable (either
- * a Window or a Pixmap).  The following constants define the valid Drawable
- * types.
- */
-
-#define TWD_BITMAP	1
-#define TWD_WINDOW	2
-#define TWD_WINDC	3
-
-typedef struct TkWindowStruct TkWindow;
-
-typedef struct {
-    int type;
-    HWND handle;
-    TkWindow *winPtr;
-} TkWinWindow;
-
-typedef struct {
-    int type;
-    HBITMAP handle;
-    Colormap colormap;
-    int depth;
-} TkWinBitmap;
-
-typedef struct {
-    int type;
-    HDC hdc;
-} TkWinDC;
-
-typedef union {
-    int type;
-    TkWinWindow window;
-    TkWinBitmap bitmap;
-    TkWinDC winDC;
-} TkWinDrawable;
-
-/*
- * The TkWinDCState is used to save the state of a device context
- * so that it can be restored later.
- */
-
-typedef struct {
-    HPALETTE palette;
-    int bkmode;			/* This field was added in Tk
-				 * 8.3.1. Be careful that you don't 
-				 * use this structure in a context
-				 * where its size is important.  */
-} TkWinDCState;
-
-extern HDC TkWinGetDrawableDC(Display *display, Drawable drawable,
-    TkWinDCState * state);
-extern HDC TkWinReleaseDrawableDC(Drawable drawable, HDC dc,
-    TkWinDCState * state);
-
-extern HWND Tk_GetHWND _ANSI_ARGS_((Window window));
-
-extern HINSTANCE Tk_GetHINSTANCE _ANSI_ARGS_((void));
-
-extern Window Tk_AttachHWND _ANSI_ARGS_((Tk_Window tkwin, HWND hWnd));
-
-#endif /* WIN32 */
-
-/*
- * The Border structure used internally by the Tk_3D* routines.
- * The following is a copy of it from tk3d.c.
- */
-
-typedef struct TkBorderStruct {
-    Screen *screen;		/* Screen on which the border will be used. */
-    Visual *visual;		/* Visual for all windows and pixmaps using
-				 * the border. */
-    int depth;			/* Number of bits per pixel of drawables where
-				 * the border will be used. */
-    Colormap colormap;		/* Colormap out of which pixels are
-				 * allocated. */
-    int refCount;		/* Number of different users of
-				 * this border.  */
-#if (TK_VERSION_NUMBER >= _VERSION(8,1,0))
-    int objRefCount;		/* The number of Tcl objects that reference
-				 * this structure. */
-#endif /* TK_VERSION_NUMBER >= 8.1.0 */
-    XColor *bgColor;		/* Background color (intensity between 
-				 * lightColorPtr and darkColorPtr). */
-    XColor *darkColor;		/* Color for darker areas (must free when
-				 * deleting structure). NULL means shadows
-				 * haven't been allocated yet.*/
-    XColor *lightColor;		/* Color used for lighter areas of border
-				 * (must free this when deleting structure).
-				 * NULL means shadows haven't been allocated
-				 * yet. */
-    Pixmap shadow;		/* Stipple pattern to use for drawing
-				 * shadows areas.  Used for displays with
-				 * <= 64 colors or where colormap has filled
-				 * up. */
-    GC bgGC;			/* Used (if necessary) to draw areas in
-				 * the background color. */
-    GC darkGC;			/* Used to draw darker parts of the
-				 * border. None means the shadow colors
-				 * haven't been allocated yet.*/
-    GC lightGC;			/* Used to draw lighter parts of
-				 * the border. None means the shadow colors
-				 * haven't been allocated yet. */
-    Tcl_HashEntry *hashPtr;	/* Entry in borderTable (needed in
-				 * order to delete structure). */
-    struct TkBorderStruct *nextPtr; /* Points to the next TkBorder structure with
-				 * the same color name.  Borders with the
-				 * same name but different screens or
-				 * colormaps are chained together off a
-				 * single entry in borderTable. */
-} TkBorder;
+#include <tkInt.h>
+#include <tk3d.h>
+#include <tkFont.h>
 
 #endif /* BLT_TKINT_H */
diff -uNr blt2.4z/src/bltTreeCmd.c blt2.4z.tcltk86/src/bltTreeCmd.c
--- blt2.4z/src/bltTreeCmd.c	2013-08-20 12:00:03.000000000 -0400
+++ blt2.4z.tcltk86/src/bltTreeCmd.c	2013-08-20 11:23:00.000000000 -0400
@@ -4830,7 +4830,7 @@
 	return TCL_ERROR;
     }
     if (valueObjPtr->typePtr != NULL) {
-	Tcl_SetResult(interp, valueObjPtr->typePtr->name, TCL_VOLATILE);
+	Tcl_SetResult(interp, (char *)valueObjPtr->typePtr->name, TCL_VOLATILE);
     } else {
 	Tcl_SetResult(interp, "string", TCL_STATIC);
     }
diff -uNr blt2.4z/src/bltWindow.c blt2.4z.tcltk86/src/bltWindow.c
--- blt2.4z/src/bltWindow.c	2013-08-20 12:00:03.000000000 -0400
+++ blt2.4z.tcltk86/src/bltWindow.c	2013-08-20 11:31:23.000000000 -0400
@@ -33,25 +33,7 @@
 #include <X11/Xproto.h>
 #endif
 
-typedef struct TkIdStackStruct TkIdStack;
-typedef struct TkErrorHandlerStruct TkErrorHandler;
-typedef struct TkSelectionInfoStruct TkSelectionInfo;
-typedef struct TkClipboardTargetStruct TkClipboardTarget;
-
-#ifndef WIN32
-typedef struct TkWindowStruct TkWindow;
-#endif
-typedef struct TkWindowEventStruct TkWindowEvent;
-typedef struct TkMainInfoStruct TkMainInfo;
-typedef struct TkEventHandlerStruct TkEventHandler;
-typedef struct TkSelHandlerStruct TkSelHandler;
-typedef struct TkWinInfoStruct TkWinInfo;
-typedef struct TkClassProcsStruct TkClassProcs;
-typedef struct TkWindowPrivateStruct TkWindowPrivate;
-typedef struct TkGrabEventStruct TkGrabEvent;
-typedef struct TkColormapStruct TkColormap;
-typedef struct TkStressedCmapStruct TkStressedCmap;
-typedef struct TkWmInfoStruct TkWmInfo;
+#include <tkInt.h>
 
 #ifdef XNQueryInputStyle
 #define TK_USE_INPUT_METHODS
@@ -70,727 +52,6 @@
 #define TK_REPARENTED 	0
 #endif
 
-#if (TK_VERSION_NUMBER >= _VERSION(8,1,0))
-
-typedef struct TkCaret {
-    struct TkWindow *winPtr;	/* the window on which we requested caret
-				 * placement */
-    int x;			/* relative x coord of the caret */
-    int y;			/* relative y coord of the caret */
-    int height;			/* specified height of the window */
-} TkCaret;
-
-/*
- * One of the following structures is maintained for each display
- * containing a window managed by Tk.  In part, the structure is
- * used to store thread-specific data, since each thread will have
- * its own TkDisplay structure.
- */
-
-typedef struct TkDisplayStruct {
-    Display *display;		/* Xlib's info about display. */
-    struct TkDisplay *nextPtr;	/* Next in list of all displays. */
-    char *name;			/* Name of display (with any screen identifier
-				 * removed). Malloc-ed. */
-    Time lastEventTime;		/* Time of last event received for this
-				 * display. */
-
-    /*
-     * Information used primarily by tk3d.c:
-     */
-
-    int borderInit;		/* 0 means borderTable needs initializing. */
-    Tcl_HashTable borderTable;	/* Maps from color name to TkBorder
-				 * structure. */
-
-    /*
-     * Information used by tkAtom.c only:
-     */
-
-    int atomInit;		/* 0 means stuff below hasn't been initialized
-				 * yet. */
-    Tcl_HashTable nameTable;	/* Maps from names to Atom's. */
-    Tcl_HashTable atomTable;	/* Maps from Atom's back to names. */
-
-    /*
-     * Information used primarily by tkBind.c:
-     */
-
-    int bindInfoStale;		/* Non-zero means the variables in this part
-				 * of the structure are potentially incorrect
-				 * and should be recomputed. */
-    unsigned int modeModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to "mode shift". If no such
-				 * modifier, than this is zero. */
-    unsigned int metaModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to the "Meta" key. If no such
-				 * modifier, then this is zero. */
-    unsigned int altModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to the "Meta" key. If no such
-				 * modifier, then this is zero. */
-    enum {LU_IGNORE, LU_CAPS, LU_SHIFT} lockUsage;
-				/* Indicates how to interpret lock
-				 * modifier. */
-    int numModKeyCodes;		/* Number of entries in modKeyCodes array
-				 * below. */
-    KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for all
-				 * of the keys that have modifiers associated
-				 * with them. Malloc'ed, but may be NULL. */
-
-    /*
-     * Information used by tkBitmap.c only:
-     */
-
-    int bitmapInit;		/* 0 means tables above need initializing. */
-    int bitmapAutoNumber;	/* Used to number bitmaps. */
-    Tcl_HashTable bitmapNameTable;
-				/* Maps from name of bitmap to the first
-				 * TkBitmap record for that name. */
-    Tcl_HashTable bitmapIdTable;/* Maps from bitmap id to the TkBitmap
-				 * structure for the bitmap. */
-    Tcl_HashTable bitmapDataTable;
-				/* Used by Tk_GetBitmapFromData to map from a
-				 * collection of in-core data about a bitmap
-				 * to a reference giving an automatically-
-				 * generated name for the bitmap. */
-
-    /*
-     * Information used by tkCanvas.c only:
-     */
-
-    int numIdSearches;
-    int numSlowSearches;
-
-    /*
-     * Used by tkColor.c only:
-     */
-
-    int colorInit;		/* 0 means color module needs initializing. */
-    TkStressedCmap *stressPtr;	/* First in list of colormaps that have filled
-				 * up, so we have to pick an approximate
-				 * color. */
-    Tcl_HashTable colorNameTable;
-				/* Maps from color name to TkColor structure
-				 * for that color. */
-    Tcl_HashTable colorValueTable;
-				/* Maps from integer RGB values to TkColor
-				 * structures. */
-
-    /*
-     * Used by tkCursor.c only:
-     */
-
-    int cursorInit;		/* 0 means cursor module need initializing. */
-    Tcl_HashTable cursorNameTable;
-				/* Maps from a string name to a cursor to the
-				 * TkCursor record for the cursor. */
-    Tcl_HashTable cursorDataTable;
-				/* Maps from a collection of in-core data
-				 * about a cursor to a TkCursor structure. */
-    Tcl_HashTable cursorIdTable;
-				/* Maps from a cursor id to the TkCursor
-				 * structure for the cursor. */
-    char cursorString[20];	/* Used to store a cursor id string. */
-    Font cursorFont;		/* Font to use for standard cursors. None
-				 * means font not loaded yet. */
-
-    /*
-     * Information used by tkError.c only:
-     */
-
-    struct TkErrorHandler *errorPtr;
-				/* First in list of error handlers for this
-				 * display. NULL means no handlers exist at
-				 * present. */
-    int deleteCount;		/* Counts # of handlers deleted since last
-				 * time inactive handlers were garbage-
-				 * collected. When this number gets big,
-				 * handlers get cleaned up. */
-
-    /*
-     * Used by tkEvent.c only:
-     */
-
-    struct TkWindowEvent *delayedMotionPtr;
-				/* Points to a malloc-ed motion event whose
-				 * processing has been delayed in the hopes
-				 * that another motion event will come along
-				 * right away and we can merge the two of them
-				 * together. NULL means that there is no
-				 * delayed motion event. */
-
-    /*
-     * Information used by tkFocus.c only:
-     */
-
-    int focusDebug;		/* 1 means collect focus debugging
-				 * statistics. */
-    struct TkWindow *implicitWinPtr;
-				/* If the focus arrived at a toplevel window
-				 * implicitly via an Enter event (rather than
-				 * via a FocusIn event), this points to the
-				 * toplevel window. Otherwise it is NULL. */
-    struct TkWindow *focusPtr;	/* Points to the window on this display that
-				 * should be receiving keyboard events. When
-				 * multiple applications on the display have
-				 * the focus, this will refer to the innermost
-				 * window in the innermost application. This
-				 * information isn't used under Unix or
-				 * Windows, but it's needed on the Mac. */
-
-    /*
-     * Information used by tkGC.c only:
-     */
-
-    Tcl_HashTable gcValueTable; /* Maps from a GC's values to a TkGC structure
-				 * describing a GC with those values. */
-    Tcl_HashTable gcIdTable;    /* Maps from a GC to a TkGC. */
-    int gcInit;			/* 0 means the tables below need
-				 * initializing. */
-
-    /*
-     * Information used by tkGeometry.c only:
-     */
-
-    Tcl_HashTable maintainHashTable;
-				/* Hash table that maps from a master's
-				 * Tk_Window token to a list of slaves managed
-				 * by that master. */
-    int geomInit;
-
-    /*
-     * Information used by tkGet.c only:
-     */
-
-    Tcl_HashTable uidTable;	/* Stores all Tk_Uid used in a thread. */
-    int uidInit;		/* 0 means uidTable needs initializing. */
-
-    /*
-     * Information used by tkGrab.c only:
-     */
-
-    struct TkWindow *grabWinPtr;/* Window in which the pointer is currently
-				 * grabbed, or NULL if none. */
-    struct TkWindow *eventualGrabWinPtr;
-				/* Value that grabWinPtr will have once the
-				 * grab event queue (below) has been
-				 * completely emptied. */
-    struct TkWindow *buttonWinPtr;
-				/* Window in which first mouse button was
-				 * pressed while grab was in effect, or NULL
-				 * if no such press in effect. */
-    struct TkWindow *serverWinPtr;
-				/* If no application contains the pointer then
-				 * this is NULL. Otherwise it contains the
-				 * last window for which we've gotten an Enter
-				 * or Leave event from the server (i.e. the
-				 * last window known to have contained the
-				 * pointer). Doesn't reflect events that were
-				 * synthesized in tkGrab.c. */
-    TkGrabEvent *firstGrabEventPtr;
-				/* First in list of enter/leave events
-				 * synthesized by grab code. These events must
-				 * be processed in order before any other
-				 * events are processed. NULL means no such
-				 * events. */
-    TkGrabEvent *lastGrabEventPtr;
-				/* Last in list of synthesized events, or NULL
-				 * if list is empty. */
-    int grabFlags;		/* Miscellaneous flag values. See definitions
-				 * in tkGrab.c. */
-
-    /*
-     * Information used by tkGrid.c only:
-     */
-
-    int gridInit;		/* 0 means table below needs initializing. */
-    Tcl_HashTable gridHashTable;/* Maps from Tk_Window tokens to corresponding
-				 * Grid structures. */
-
-    /*
-     * Information used by tkImage.c only:
-     */
-
-    int imageId;		/* Value used to number image ids. */
-
-    /*
-     * Information used by tkMacWinMenu.c only:
-     */
-
-    int postCommandGeneration;
-
-    /*
-     * Information used by tkOption.c only.
-     */
-
-    /*
-     * Information used by tkPack.c only.
-     */
-
-    int packInit;		/* 0 means table below needs initializing. */
-    Tcl_HashTable packerHashTable;
-				/* Maps from Tk_Window tokens to corresponding
-				 * Packer structures. */
-
-    /*
-     * Information used by tkPlace.c only.
-     */
-
-    int placeInit;		/* 0 means tables below need initializing. */
-    Tcl_HashTable masterTable;	/* Maps from Tk_Window toke to the Master
-				 * structure for the window, if it exists. */
-    Tcl_HashTable slaveTable;	/* Maps from Tk_Window toke to the Slave
-				 * structure for the window, if it exists. */
-
-    /*
-     * Information used by tkSelect.c and tkClipboard.c only:
-     */
-
-    struct TkSelectionInfo *selectionInfoPtr;
-				/* First in list of selection information
-				 * records. Each entry contains information
-				 * about the current owner of a particular
-				 * selection on this display. */
-    Atom multipleAtom;		/* Atom for MULTIPLE. None means selection
-				 * stuff isn't initialized. */
-    Atom incrAtom;		/* Atom for INCR. */
-    Atom targetsAtom;		/* Atom for TARGETS. */
-    Atom timestampAtom;		/* Atom for TIMESTAMP. */
-    Atom textAtom;		/* Atom for TEXT. */
-    Atom compoundTextAtom;	/* Atom for COMPOUND_TEXT. */
-    Atom applicationAtom;	/* Atom for TK_APPLICATION. */
-    Atom windowAtom;		/* Atom for TK_WINDOW. */
-    Atom clipboardAtom;		/* Atom for CLIPBOARD. */
-    Atom utf8Atom;		/* Atom for UTF8_STRING. */
-
-    Tk_Window clipWindow;	/* Window used for clipboard ownership and to
-				 * retrieve selections between processes. NULL
-				 * means clipboard info hasn't been
-				 * initialized. */
-    int clipboardActive;	/* 1 means we currently own the clipboard
-				 * selection, 0 means we don't. */
-    struct TkMainInfo *clipboardAppPtr;
-				/* Last application that owned clipboard. */
-    struct TkClipboardTarget *clipTargetPtr;
-				/* First in list of clipboard type information
-				 * records. Each entry contains information
-				 * about the buffers for a given selection
-				 * target. */
-
-    /*
-     * Information used by tkSend.c only:
-     */
-
-    Tk_Window commTkwin;	/* Window used for communication between
-				 * interpreters during "send" commands. NULL
-				 * means send info hasn't been initialized
-				 * yet. */
-    Atom commProperty;		/* X's name for comm property. */
-    Atom registryProperty;	/* X's name for property containing registry
-				 * of interpreter names. */
-    Atom appNameProperty;	/* X's name for property used to hold the
-				 * application name on each comm window. */
-
-    /*
-     * Information used by tkXId.c only:
-     */
-
-    struct TkIdStack *idStackPtr;
-				/* First in list of chunks of free resource
-				 * identifiers, or NULL if there are no free
-				 * resources. */
-    XID (*defaultAllocProc) (Display *display);
-				/* Default resource allocator for display. */
-    struct TkIdStack *windowStackPtr;
-				/* First in list of chunks of window ids that
-				 * can't be reused right now. */
-    Tcl_TimerToken idCleanupScheduled;
-				/* If set, it means a call to WindowIdCleanup
-				 * has already been scheduled, 0 means it
-				 * hasn't. */
-
-    /*
-     * Information used by tkUnixWm.c and tkWinWm.c only:
-     */
-
-    struct TkWmInfo *firstWmPtr;/* Points to first top-level window. */
-    struct TkWmInfo *foregroundWmPtr;
-				/* Points to the foreground window. */
-
-    /*
-     * Information maintained by tkWindow.c for use later on by tkXId.c:
-     */
-
-    int destroyCount;		/* Number of Tk_DestroyWindow operations in
-				 * progress. */
-    unsigned long lastDestroyRequest;
-				/* Id of most recent XDestroyWindow request;
-				 * can re-use ids in windowStackPtr when
-				 * server has seen this request and event
-				 * queue is empty. */
-
-    /*
-     * Information used by tkVisual.c only:
-     */
-
-    TkColormap *cmapPtr;	/* First in list of all non-default colormaps
-				 * allocated for this display. */
-
-    /*
-     * Miscellaneous information:
-     */
-
-#ifdef TK_USE_INPUT_METHODS
-    XIM inputMethod;		/* Input method for this display. */
-    XIMStyle inputStyle;	/* Input style selected for this display. */
-    XFontSet inputXfs;		/* XFontSet cached for over-the-spot XIM. */
-#endif /* TK_USE_INPUT_METHODS */
-    Tcl_HashTable winTable;	/* Maps from X window ids to TkWindow ptrs. */
-
-    int refCount;		/* Reference count of how many Tk applications
-				 * are using this display. Used to clean up
-				 * the display when we no longer have any Tk
-				 * applications using it. */
-
-    /*
-     * The following field were all added for Tk8.3
-     */
-
-    int mouseButtonState;	/* Current mouse button state for this
-				 * display. */
-    Window mouseButtonWindow;	/* Window the button state was set in, added
-				 * in Tk 8.4. */
-    Window warpWindow;
-    int warpX;
-    int warpY;
-
-    /*
-     * The following field(s) were all added for Tk8.4
-     */
-
-    unsigned int flags;		/* Various flag values: these are all defined
-				 * in below. */
-    TkCaret caret;		/* Information about the caret for this
-				 * display. This is not a pointer. */
-
-    int iconDataSize;		/* Size of default iconphoto image data. */
-    unsigned char *iconDataPtr;	/* Default iconphoto image data, if set. */
-
-} TkDisplay;
-
-#else
-
-/*
- * One of the following structures is maintained for each display
- * containing a window managed by Tk:
- */
-typedef struct TkDisplayStruct {
-    Display *display;		/* Xlib's info about display. */
-    struct TkDisplayStruct *nextPtr; /* Next in list of all displays. */
-    char *name;			/* Name of display (with any screen
-				 * identifier removed).  Malloc-ed. */
-    Time lastEventTime;		/* Time of last event received for this
-				 * display. */
-
-    /*
-     * Information used primarily by tkBind.c:
-     */
-
-    int bindInfoStale;		/* Non-zero means the variables in this
-				 * part of the structure are potentially
-				 * incorrect and should be recomputed. */
-    unsigned int modeModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to "mode shift".  If no
-				 * such modifier, than this is zero. */
-    unsigned int metaModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to the "Meta" key.  If no
-				 * such modifier, then this is zero. */
-    unsigned int altModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to the "Meta" key.  If no
-				 * such modifier, then this is zero. */
-    enum {
-	LU_IGNORE, LU_CAPS, LU_SHIFT
-    } lockUsage;
-    /* Indicates how to interpret lock modifier. */
-    int numModKeyCodes;		/* Number of entries in modKeyCodes array
-				 * below. */
-    KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for
-				 * all of the keys that have modifiers
-				 * associated with them.  Malloc'ed, but
-				 * may be NULL. */
-
-    /*
-     * Information used by tkError.c only:
-     */
-
-    TkErrorHandler *errorPtr;
-    /* First in list of error handlers
-				 * for this display.  NULL means
-				 * no handlers exist at present. */
-     int deleteCount;		/* Counts # of handlers deleted since
-				 * last time inactive handlers were
-				 * garbage-collected.  When this number
-				 * gets big, handlers get cleaned up. */
-
-    /*
-     * Information used by tkSend.c only:
-     */
-
-    Tk_Window commTkwin;	/* Window used for communication
-				 * between interpreters during "send"
-				 * commands.  NULL means send info hasn't
-				 * been initialized yet. */
-    Atom commProperty;		/* X's name for comm property. */
-    Atom registryProperty;	/* X's name for property containing
-				 * registry of interpreter names. */
-    Atom appNameProperty;	/* X's name for property used to hold the
-				 * application name on each comm window. */
-
-    /*
-     * Information used by tkSelect.c and tkClipboard.c only:
-     */
-
-     TkSelectionInfo *selectionInfoPtr;
-    /* First in list of selection information
-				 * records.  Each entry contains information
-				 * about the current owner of a particular
-				 * selection on this display. */
-    Atom multipleAtom;		/* Atom for MULTIPLE.  None means
-				 * selection stuff isn't initialized. */
-    Atom incrAtom;		/* Atom for INCR. */
-    Atom targetsAtom;		/* Atom for TARGETS. */
-    Atom timestampAtom;		/* Atom for TIMESTAMP. */
-    Atom textAtom;		/* Atom for TEXT. */
-    Atom compoundTextAtom;	/* Atom for COMPOUND_TEXT. */
-    Atom applicationAtom;	/* Atom for TK_APPLICATION. */
-    Atom windowAtom;		/* Atom for TK_WINDOW. */
-    Atom clipboardAtom;		/* Atom for CLIPBOARD. */
-
-    Tk_Window clipWindow;	/* Window used for clipboard ownership and to
-				 * retrieve selections between processes. NULL
-				 * means clipboard info hasn't been
-				 * initialized. */
-    int clipboardActive;	/* 1 means we currently own the clipboard
-				 * selection, 0 means we don't. */
-     TkMainInfo *clipboardAppPtr;
-     /* Last application that owned clipboard. */
-     TkClipboardTarget *clipTargetPtr;
-     /* First in list of clipboard type information
-				 * records.  Each entry contains information
-				 * about the buffers for a given selection
-				 * target. */
-
-    /*
-     * Information used by tkAtom.c only:
-     */
-
-    int atomInit;		/* 0 means stuff below hasn't been
-				 * initialized yet. */
-    Tcl_HashTable nameTable;	/* Maps from names to Atom's. */
-    Tcl_HashTable atomTable;	/* Maps from Atom's back to names. */
-
-    /*
-     * Information used by tkCursor.c only:
-     */
-
-    Font cursorFont;		/* Font to use for standard cursors.
-				 * None means font not loaded yet. */
-
-    /*
-     * Information used by tkGrab.c only:
-     */
-
-     TkWindow *grabWinPtr;
-    /* Window in which the pointer is currently
-				 * grabbed, or NULL if none. */
-     TkWindow *eventualGrabWinPtr;
-    /* Value that grabWinPtr will have once the
-				 * grab event queue (below) has been
-				 * completely emptied. */
-     TkWindow *buttonWinPtr;
-    /* Window in which first mouse button was
-				 * pressed while grab was in effect, or NULL
-				 * if no such press in effect. */
-     TkWindow *serverWinPtr;
-    /* If no application contains the pointer then
-				 * this is NULL.  Otherwise it contains the
-				 * last window for which we've gotten an
-				 * Enter or Leave event from the server (i.e.
-				 * the last window known to have contained
-				 * the pointer).  Doesn't reflect events
-				 * that were synthesized in tkGrab.c. */
-    TkGrabEvent *firstGrabEventPtr;
-    /* First in list of enter/leave events
-				 * synthesized by grab code.  These events
-				 * must be processed in order before any other
-				 * events are processed.  NULL means no such
-				 * events. */
-    TkGrabEvent *lastGrabEventPtr;
-    /* Last in list of synthesized events, or NULL
-				 * if list is empty. */
-    int grabFlags;		/* Miscellaneous flag values.  See definitions
-				 * in tkGrab.c. */
-
-    /*
-     * Information used by tkXId.c only:
-     */
-
-     TkIdStack *idStackPtr;
-    /* First in list of chunks of free resource
-				 * identifiers, or NULL if there are no free
-				 * resources. */
-              XID(*defaultAllocProc) _ANSI_ARGS_((Display *display));
-    /* Default resource allocator for display. */
-     TkIdStack *windowStackPtr;
-    /* First in list of chunks of window
-				 * identifers that can't be reused right
-				 * now. */
-    int idCleanupScheduled;	/* 1 means a call to WindowIdCleanup has
-				 * already been scheduled, 0 means it
-				 * hasn't. */
-
-    /*
-     * Information maintained by tkWindow.c for use later on by tkXId.c:
-     */
-
-
-    int destroyCount;		/* Number of Tk_DestroyWindow operations
-				 * in progress. */
-    unsigned long lastDestroyRequest;
-    /* Id of most recent XDestroyWindow request;
-				 * can re-use ids in windowStackPtr when
-				 * server has seen this request and event
-				 * queue is empty. */
-
-    /*
-     * Information used by tkVisual.c only:
-     */
-
-    TkColormap *cmapPtr;	/* First in list of all non-default colormaps
-				 * allocated for this display. */
-
-    /*
-     * Information used by tkFocus.c only:
-     */
-#if (TK_MAJOR_VERSION == 4)
-
-     TkWindow *focusWinPtr;
-				/* Window that currently has the focus for
-				 * this display, or NULL if none. */
-     TkWindow *implicitWinPtr;
-				/* If the focus arrived at a toplevel window
-				 * implicitly via an Enter event (rather
-				 * than via a FocusIn event), this points
-				 * to the toplevel window.  Otherwise it is
-				 * NULL. */
-     TkWindow *focusOnMapPtr;
-				/* This points to a toplevel window that is
-				 * supposed to receive the X input focus as
-				 * soon as it is mapped (needed to handle the
-				 * fact that X won't allow the focus on an
-				 * unmapped window).  NULL means no delayed
-				 * focus op in progress. */
-    int forceFocus;		/* Associated with focusOnMapPtr:  non-zero
-				 * means claim the focus even if some other
-				 * application currently has it. */
-#else
-     TkWindow *implicitWinPtr;
-				/* If the focus arrived at a toplevel window
-				 * implicitly via an Enter event (rather
-				 * than via a FocusIn event), this points
-				 * to the toplevel window.  Otherwise it is
-				 * NULL. */
-     TkWindow *focusPtr;	/* Points to the window on this display that
-				 * should be receiving keyboard events.  When
-				 * multiple applications on the display have
-				 * the focus, this will refer to the
-				 * innermost window in the innermost
-				 * application.  This information isn't used
-				 * under Unix or Windows, but it's needed on
-				 * the Macintosh. */
-#endif /* TK_MAJOR_VERSION == 4 */
-
-    /*
-     * Used by tkColor.c only:
-     */
-
-    TkStressedCmap *stressPtr;	/* First in list of colormaps that have
-				 * filled up, so we have to pick an
-				 * approximate color. */
-
-    /*
-     * Used by tkEvent.c only:
-     */
-
-     TkWindowEvent *delayedMotionPtr;
-				/* Points to a malloc-ed motion event
-				 * whose processing has been delayed in
-				 * the hopes that another motion event
-				 * will come along right away and we can
-				 * merge the two of them together.  NULL
-				 * means that there is no delayed motion
-				 * event. */
-    /*
-     * Miscellaneous information:
-     */
-
-#ifdef TK_USE_INPUT_METHODS
-    XIM inputMethod;		/* Input method for this display */
-#endif /* TK_USE_INPUT_METHODS */
-    Tcl_HashTable winTable;	/* Maps from X window ids to TkWindow ptrs. */
-#if (TK_MAJOR_VERSION > 4)
-    int refCount;		/* Reference count of how many Tk applications
-                                 * are using this display. Used to clean up
-                                 * the display when we no longer have any
-                                 * Tk applications using it.
-                                 */
-#endif /* TK_MAJOR_VERSION > 4 */
-
-} TkDisplay;
-
-#endif /* TK_VERSION_NUMBER >= _VERSION(8,1,0) */
-
-
-struct TkWindowStruct {
-    Display *display;
-    TkDisplay *dispPtr;
-    int screenNum;
-    Visual *visual;
-    int depth;
-    Window window;
-    TkWindow *childList;
-    TkWindow *lastChildPtr;
-    TkWindow *parentPtr;
-    TkWindow *nextPtr;
-    TkMainInfo *infoPtr;
-    char *pathName;
-    Tk_Uid nameUid;
-    Tk_Uid classUid;
-    XWindowChanges changes;
-    unsigned int dirtyChanges;
-    XSetWindowAttributes atts;
-    unsigned long dirtyAtts;
-    unsigned int flags;
-    TkEventHandler *handlerList;
-#ifdef TK_USE_INPUT_METHODS
-    XIC inputContext;
-#endif /* TK_USE_INPUT_METHODS */
-    ClientData *tagPtr;
-    int nTags;
-    int optionLevel;
-    TkSelHandler *selHandlerList;
-    Tk_GeomMgr *geomMgrPtr;
-    ClientData geomData;
-    int reqWidth, reqHeight;
-    int internalBorderWidth;
-    TkWinInfo *wmInfoPtr;
-#if (TK_MAJOR_VERSION > 4)
-    TkClassProcs *classProcsPtr;
-    ClientData instanceData;
-#endif
-    TkWindowPrivate *privatePtr;
-};
-
 #ifdef WIN32
 /*
  *----------------------------------------------------------------------
diff -uNr blt2.4z/src/bltWindow.c.orig blt2.4z.tcltk86/src/bltWindow.c.orig
--- blt2.4z/src/bltWindow.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ blt2.4z.tcltk86/src/bltWindow.c.orig	2013-08-20 11:22:59.000000000 -0400
@@ -0,0 +1,1782 @@
+/*
+ * bltWindow.c --
+ *
+ *	This module implements additional window functionality for
+ *	the BLT toolkit, such as transparent Tk windows,
+ *	and reparenting Tk windows.
+ *
+ * Copyright 1991-1998 Lucent Technologies, Inc.
+ *
+ * Permission to use, copy, modify, and distribute this software and
+ * its documentation for any purpose and without fee is hereby
+ * granted, provided that the above copyright notice appear in all
+ * copies and that both that the copyright notice and warranty
+ * disclaimer appear in supporting documentation, and that the names
+ * of Lucent Technologies any of their entities not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.
+ *
+ * Lucent Technologies disclaims all warranties with regard to this
+ * software, including all implied warranties of merchantability and
+ * fitness.  In no event shall Lucent Technologies be liable for any
+ * special, indirect or consequential damages or any damages
+ * whatsoever resulting from loss of use, data or profits, whether in
+ * an action of contract, negligence or other tortuous action, arising
+ * out of or in connection with the use or performance of this
+ * software.
+ */
+
+#include "bltInt.h"
+
+#include <X11/Xlib.h>
+#ifndef WIN32
+#include <X11/Xproto.h>
+#endif
+
+typedef struct TkIdStackStruct TkIdStack;
+typedef struct TkErrorHandlerStruct TkErrorHandler;
+typedef struct TkSelectionInfoStruct TkSelectionInfo;
+typedef struct TkClipboardTargetStruct TkClipboardTarget;
+
+#ifndef WIN32
+typedef struct TkWindowStruct TkWindow;
+#endif
+typedef struct TkWindowEventStruct TkWindowEvent;
+typedef struct TkMainInfoStruct TkMainInfo;
+typedef struct TkEventHandlerStruct TkEventHandler;
+typedef struct TkSelHandlerStruct TkSelHandler;
+typedef struct TkWinInfoStruct TkWinInfo;
+typedef struct TkClassProcsStruct TkClassProcs;
+typedef struct TkWindowPrivateStruct TkWindowPrivate;
+typedef struct TkGrabEventStruct TkGrabEvent;
+typedef struct TkColormapStruct TkColormap;
+typedef struct TkStressedCmapStruct TkStressedCmap;
+typedef struct TkWmInfoStruct TkWmInfo;
+
+#ifdef XNQueryInputStyle
+#define TK_USE_INPUT_METHODS
+#endif
+
+/*
+ * This defines whether we should try to use XIM over-the-spot style
+ * input.  Allow users to override it.  It is a much more elegant use
+ * of XIM, but uses a bit more memory.
+ */
+#ifndef TK_XIM_SPOT
+#   define TK_XIM_SPOT	1
+#endif
+
+#ifndef TK_REPARENTED
+#define TK_REPARENTED 	0
+#endif
+
+#if (TK_VERSION_NUMBER >= _VERSION(8,1,0))
+
+typedef struct TkCaret {
+    struct TkWindow *winPtr;	/* the window on which we requested caret
+				 * placement */
+    int x;			/* relative x coord of the caret */
+    int y;			/* relative y coord of the caret */
+    int height;			/* specified height of the window */
+} TkCaret;
+
+/*
+ * One of the following structures is maintained for each display
+ * containing a window managed by Tk.  In part, the structure is
+ * used to store thread-specific data, since each thread will have
+ * its own TkDisplay structure.
+ */
+
+typedef struct TkDisplayStruct {
+    Display *display;		/* Xlib's info about display. */
+    struct TkDisplay *nextPtr;	/* Next in list of all displays. */
+    char *name;			/* Name of display (with any screen identifier
+				 * removed). Malloc-ed. */
+    Time lastEventTime;		/* Time of last event received for this
+				 * display. */
+
+    /*
+     * Information used primarily by tk3d.c:
+     */
+
+    int borderInit;		/* 0 means borderTable needs initializing. */
+    Tcl_HashTable borderTable;	/* Maps from color name to TkBorder
+				 * structure. */
+
+    /*
+     * Information used by tkAtom.c only:
+     */
+
+    int atomInit;		/* 0 means stuff below hasn't been initialized
+				 * yet. */
+    Tcl_HashTable nameTable;	/* Maps from names to Atom's. */
+    Tcl_HashTable atomTable;	/* Maps from Atom's back to names. */
+
+    /*
+     * Information used primarily by tkBind.c:
+     */
+
+    int bindInfoStale;		/* Non-zero means the variables in this part
+				 * of the structure are potentially incorrect
+				 * and should be recomputed. */
+    unsigned int modeModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to "mode shift". If no such
+				 * modifier, than this is zero. */
+    unsigned int metaModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to the "Meta" key. If no such
+				 * modifier, then this is zero. */
+    unsigned int altModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to the "Meta" key. If no such
+				 * modifier, then this is zero. */
+    enum {LU_IGNORE, LU_CAPS, LU_SHIFT} lockUsage;
+				/* Indicates how to interpret lock
+				 * modifier. */
+    int numModKeyCodes;		/* Number of entries in modKeyCodes array
+				 * below. */
+    KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for all
+				 * of the keys that have modifiers associated
+				 * with them. Malloc'ed, but may be NULL. */
+
+    /*
+     * Information used by tkBitmap.c only:
+     */
+
+    int bitmapInit;		/* 0 means tables above need initializing. */
+    int bitmapAutoNumber;	/* Used to number bitmaps. */
+    Tcl_HashTable bitmapNameTable;
+				/* Maps from name of bitmap to the first
+				 * TkBitmap record for that name. */
+    Tcl_HashTable bitmapIdTable;/* Maps from bitmap id to the TkBitmap
+				 * structure for the bitmap. */
+    Tcl_HashTable bitmapDataTable;
+				/* Used by Tk_GetBitmapFromData to map from a
+				 * collection of in-core data about a bitmap
+				 * to a reference giving an automatically-
+				 * generated name for the bitmap. */
+
+    /*
+     * Information used by tkCanvas.c only:
+     */
+
+    int numIdSearches;
+    int numSlowSearches;
+
+    /*
+     * Used by tkColor.c only:
+     */
+
+    int colorInit;		/* 0 means color module needs initializing. */
+    TkStressedCmap *stressPtr;	/* First in list of colormaps that have filled
+				 * up, so we have to pick an approximate
+				 * color. */
+    Tcl_HashTable colorNameTable;
+				/* Maps from color name to TkColor structure
+				 * for that color. */
+    Tcl_HashTable colorValueTable;
+				/* Maps from integer RGB values to TkColor
+				 * structures. */
+
+    /*
+     * Used by tkCursor.c only:
+     */
+
+    int cursorInit;		/* 0 means cursor module need initializing. */
+    Tcl_HashTable cursorNameTable;
+				/* Maps from a string name to a cursor to the
+				 * TkCursor record for the cursor. */
+    Tcl_HashTable cursorDataTable;
+				/* Maps from a collection of in-core data
+				 * about a cursor to a TkCursor structure. */
+    Tcl_HashTable cursorIdTable;
+				/* Maps from a cursor id to the TkCursor
+				 * structure for the cursor. */
+    char cursorString[20];	/* Used to store a cursor id string. */
+    Font cursorFont;		/* Font to use for standard cursors. None
+				 * means font not loaded yet. */
+
+    /*
+     * Information used by tkError.c only:
+     */
+
+    struct TkErrorHandler *errorPtr;
+				/* First in list of error handlers for this
+				 * display. NULL means no handlers exist at
+				 * present. */
+    int deleteCount;		/* Counts # of handlers deleted since last
+				 * time inactive handlers were garbage-
+				 * collected. When this number gets big,
+				 * handlers get cleaned up. */
+
+    /*
+     * Used by tkEvent.c only:
+     */
+
+    struct TkWindowEvent *delayedMotionPtr;
+				/* Points to a malloc-ed motion event whose
+				 * processing has been delayed in the hopes
+				 * that another motion event will come along
+				 * right away and we can merge the two of them
+				 * together. NULL means that there is no
+				 * delayed motion event. */
+
+    /*
+     * Information used by tkFocus.c only:
+     */
+
+    int focusDebug;		/* 1 means collect focus debugging
+				 * statistics. */
+    struct TkWindow *implicitWinPtr;
+				/* If the focus arrived at a toplevel window
+				 * implicitly via an Enter event (rather than
+				 * via a FocusIn event), this points to the
+				 * toplevel window. Otherwise it is NULL. */
+    struct TkWindow *focusPtr;	/* Points to the window on this display that
+				 * should be receiving keyboard events. When
+				 * multiple applications on the display have
+				 * the focus, this will refer to the innermost
+				 * window in the innermost application. This
+				 * information isn't used under Unix or
+				 * Windows, but it's needed on the Mac. */
+
+    /*
+     * Information used by tkGC.c only:
+     */
+
+    Tcl_HashTable gcValueTable; /* Maps from a GC's values to a TkGC structure
+				 * describing a GC with those values. */
+    Tcl_HashTable gcIdTable;    /* Maps from a GC to a TkGC. */
+    int gcInit;			/* 0 means the tables below need
+				 * initializing. */
+
+    /*
+     * Information used by tkGeometry.c only:
+     */
+
+    Tcl_HashTable maintainHashTable;
+				/* Hash table that maps from a master's
+				 * Tk_Window token to a list of slaves managed
+				 * by that master. */
+    int geomInit;
+
+    /*
+     * Information used by tkGet.c only:
+     */
+
+    Tcl_HashTable uidTable;	/* Stores all Tk_Uid used in a thread. */
+    int uidInit;		/* 0 means uidTable needs initializing. */
+
+    /*
+     * Information used by tkGrab.c only:
+     */
+
+    struct TkWindow *grabWinPtr;/* Window in which the pointer is currently
+				 * grabbed, or NULL if none. */
+    struct TkWindow *eventualGrabWinPtr;
+				/* Value that grabWinPtr will have once the
+				 * grab event queue (below) has been
+				 * completely emptied. */
+    struct TkWindow *buttonWinPtr;
+				/* Window in which first mouse button was
+				 * pressed while grab was in effect, or NULL
+				 * if no such press in effect. */
+    struct TkWindow *serverWinPtr;
+				/* If no application contains the pointer then
+				 * this is NULL. Otherwise it contains the
+				 * last window for which we've gotten an Enter
+				 * or Leave event from the server (i.e. the
+				 * last window known to have contained the
+				 * pointer). Doesn't reflect events that were
+				 * synthesized in tkGrab.c. */
+    TkGrabEvent *firstGrabEventPtr;
+				/* First in list of enter/leave events
+				 * synthesized by grab code. These events must
+				 * be processed in order before any other
+				 * events are processed. NULL means no such
+				 * events. */
+    TkGrabEvent *lastGrabEventPtr;
+				/* Last in list of synthesized events, or NULL
+				 * if list is empty. */
+    int grabFlags;		/* Miscellaneous flag values. See definitions
+				 * in tkGrab.c. */
+
+    /*
+     * Information used by tkGrid.c only:
+     */
+
+    int gridInit;		/* 0 means table below needs initializing. */
+    Tcl_HashTable gridHashTable;/* Maps from Tk_Window tokens to corresponding
+				 * Grid structures. */
+
+    /*
+     * Information used by tkImage.c only:
+     */
+
+    int imageId;		/* Value used to number image ids. */
+
+    /*
+     * Information used by tkMacWinMenu.c only:
+     */
+
+    int postCommandGeneration;
+
+    /*
+     * Information used by tkOption.c only.
+     */
+
+    /*
+     * Information used by tkPack.c only.
+     */
+
+    int packInit;		/* 0 means table below needs initializing. */
+    Tcl_HashTable packerHashTable;
+				/* Maps from Tk_Window tokens to corresponding
+				 * Packer structures. */
+
+    /*
+     * Information used by tkPlace.c only.
+     */
+
+    int placeInit;		/* 0 means tables below need initializing. */
+    Tcl_HashTable masterTable;	/* Maps from Tk_Window toke to the Master
+				 * structure for the window, if it exists. */
+    Tcl_HashTable slaveTable;	/* Maps from Tk_Window toke to the Slave
+				 * structure for the window, if it exists. */
+
+    /*
+     * Information used by tkSelect.c and tkClipboard.c only:
+     */
+
+    struct TkSelectionInfo *selectionInfoPtr;
+				/* First in list of selection information
+				 * records. Each entry contains information
+				 * about the current owner of a particular
+				 * selection on this display. */
+    Atom multipleAtom;		/* Atom for MULTIPLE. None means selection
+				 * stuff isn't initialized. */
+    Atom incrAtom;		/* Atom for INCR. */
+    Atom targetsAtom;		/* Atom for TARGETS. */
+    Atom timestampAtom;		/* Atom for TIMESTAMP. */
+    Atom textAtom;		/* Atom for TEXT. */
+    Atom compoundTextAtom;	/* Atom for COMPOUND_TEXT. */
+    Atom applicationAtom;	/* Atom for TK_APPLICATION. */
+    Atom windowAtom;		/* Atom for TK_WINDOW. */
+    Atom clipboardAtom;		/* Atom for CLIPBOARD. */
+    Atom utf8Atom;		/* Atom for UTF8_STRING. */
+
+    Tk_Window clipWindow;	/* Window used for clipboard ownership and to
+				 * retrieve selections between processes. NULL
+				 * means clipboard info hasn't been
+				 * initialized. */
+    int clipboardActive;	/* 1 means we currently own the clipboard
+				 * selection, 0 means we don't. */
+    struct TkMainInfo *clipboardAppPtr;
+				/* Last application that owned clipboard. */
+    struct TkClipboardTarget *clipTargetPtr;
+				/* First in list of clipboard type information
+				 * records. Each entry contains information
+				 * about the buffers for a given selection
+				 * target. */
+
+    /*
+     * Information used by tkSend.c only:
+     */
+
+    Tk_Window commTkwin;	/* Window used for communication between
+				 * interpreters during "send" commands. NULL
+				 * means send info hasn't been initialized
+				 * yet. */
+    Atom commProperty;		/* X's name for comm property. */
+    Atom registryProperty;	/* X's name for property containing registry
+				 * of interpreter names. */
+    Atom appNameProperty;	/* X's name for property used to hold the
+				 * application name on each comm window. */
+
+    /*
+     * Information used by tkXId.c only:
+     */
+
+    struct TkIdStack *idStackPtr;
+				/* First in list of chunks of free resource
+				 * identifiers, or NULL if there are no free
+				 * resources. */
+    XID (*defaultAllocProc) (Display *display);
+				/* Default resource allocator for display. */
+    struct TkIdStack *windowStackPtr;
+				/* First in list of chunks of window ids that
+				 * can't be reused right now. */
+    Tcl_TimerToken idCleanupScheduled;
+				/* If set, it means a call to WindowIdCleanup
+				 * has already been scheduled, 0 means it
+				 * hasn't. */
+
+    /*
+     * Information used by tkUnixWm.c and tkWinWm.c only:
+     */
+
+    struct TkWmInfo *firstWmPtr;/* Points to first top-level window. */
+    struct TkWmInfo *foregroundWmPtr;
+				/* Points to the foreground window. */
+
+    /*
+     * Information maintained by tkWindow.c for use later on by tkXId.c:
+     */
+
+    int destroyCount;		/* Number of Tk_DestroyWindow operations in
+				 * progress. */
+    unsigned long lastDestroyRequest;
+				/* Id of most recent XDestroyWindow request;
+				 * can re-use ids in windowStackPtr when
+				 * server has seen this request and event
+				 * queue is empty. */
+
+    /*
+     * Information used by tkVisual.c only:
+     */
+
+    TkColormap *cmapPtr;	/* First in list of all non-default colormaps
+				 * allocated for this display. */
+
+    /*
+     * Miscellaneous information:
+     */
+
+#ifdef TK_USE_INPUT_METHODS
+    XIM inputMethod;		/* Input method for this display. */
+    XIMStyle inputStyle;	/* Input style selected for this display. */
+    XFontSet inputXfs;		/* XFontSet cached for over-the-spot XIM. */
+#endif /* TK_USE_INPUT_METHODS */
+    Tcl_HashTable winTable;	/* Maps from X window ids to TkWindow ptrs. */
+
+    int refCount;		/* Reference count of how many Tk applications
+				 * are using this display. Used to clean up
+				 * the display when we no longer have any Tk
+				 * applications using it. */
+
+    /*
+     * The following field were all added for Tk8.3
+     */
+
+    int mouseButtonState;	/* Current mouse button state for this
+				 * display. */
+    Window mouseButtonWindow;	/* Window the button state was set in, added
+				 * in Tk 8.4. */
+    Window warpWindow;
+    int warpX;
+    int warpY;
+
+    /*
+     * The following field(s) were all added for Tk8.4
+     */
+
+    unsigned int flags;		/* Various flag values: these are all defined
+				 * in below. */
+    TkCaret caret;		/* Information about the caret for this
+				 * display. This is not a pointer. */
+
+    int iconDataSize;		/* Size of default iconphoto image data. */
+    unsigned char *iconDataPtr;	/* Default iconphoto image data, if set. */
+
+} TkDisplay;
+
+#else
+
+/*
+ * One of the following structures is maintained for each display
+ * containing a window managed by Tk:
+ */
+typedef struct TkDisplayStruct {
+    Display *display;		/* Xlib's info about display. */
+    struct TkDisplayStruct *nextPtr; /* Next in list of all displays. */
+    char *name;			/* Name of display (with any screen
+				 * identifier removed).  Malloc-ed. */
+    Time lastEventTime;		/* Time of last event received for this
+				 * display. */
+
+    /*
+     * Information used primarily by tkBind.c:
+     */
+
+    int bindInfoStale;		/* Non-zero means the variables in this
+				 * part of the structure are potentially
+				 * incorrect and should be recomputed. */
+    unsigned int modeModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to "mode shift".  If no
+				 * such modifier, than this is zero. */
+    unsigned int metaModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to the "Meta" key.  If no
+				 * such modifier, then this is zero. */
+    unsigned int altModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to the "Meta" key.  If no
+				 * such modifier, then this is zero. */
+    enum {
+	LU_IGNORE, LU_CAPS, LU_SHIFT
+    } lockUsage;
+    /* Indicates how to interpret lock modifier. */
+    int numModKeyCodes;		/* Number of entries in modKeyCodes array
+				 * below. */
+    KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for
+				 * all of the keys that have modifiers
+				 * associated with them.  Malloc'ed, but
+				 * may be NULL. */
+
+    /*
+     * Information used by tkError.c only:
+     */
+
+    TkErrorHandler *errorPtr;
+    /* First in list of error handlers
+				 * for this display.  NULL means
+				 * no handlers exist at present. */
+     int deleteCount;		/* Counts # of handlers deleted since
+				 * last time inactive handlers were
+				 * garbage-collected.  When this number
+				 * gets big, handlers get cleaned up. */
+
+    /*
+     * Information used by tkSend.c only:
+     */
+
+    Tk_Window commTkwin;	/* Window used for communication
+				 * between interpreters during "send"
+				 * commands.  NULL means send info hasn't
+				 * been initialized yet. */
+    Atom commProperty;		/* X's name for comm property. */
+    Atom registryProperty;	/* X's name for property containing
+				 * registry of interpreter names. */
+    Atom appNameProperty;	/* X's name for property used to hold the
+				 * application name on each comm window. */
+
+    /*
+     * Information used by tkSelect.c and tkClipboard.c only:
+     */
+
+     TkSelectionInfo *selectionInfoPtr;
+    /* First in list of selection information
+				 * records.  Each entry contains information
+				 * about the current owner of a particular
+				 * selection on this display. */
+    Atom multipleAtom;		/* Atom for MULTIPLE.  None means
+				 * selection stuff isn't initialized. */
+    Atom incrAtom;		/* Atom for INCR. */
+    Atom targetsAtom;		/* Atom for TARGETS. */
+    Atom timestampAtom;		/* Atom for TIMESTAMP. */
+    Atom textAtom;		/* Atom for TEXT. */
+    Atom compoundTextAtom;	/* Atom for COMPOUND_TEXT. */
+    Atom applicationAtom;	/* Atom for TK_APPLICATION. */
+    Atom windowAtom;		/* Atom for TK_WINDOW. */
+    Atom clipboardAtom;		/* Atom for CLIPBOARD. */
+
+    Tk_Window clipWindow;	/* Window used for clipboard ownership and to
+				 * retrieve selections between processes. NULL
+				 * means clipboard info hasn't been
+				 * initialized. */
+    int clipboardActive;	/* 1 means we currently own the clipboard
+				 * selection, 0 means we don't. */
+     TkMainInfo *clipboardAppPtr;
+     /* Last application that owned clipboard. */
+     TkClipboardTarget *clipTargetPtr;
+     /* First in list of clipboard type information
+				 * records.  Each entry contains information
+				 * about the buffers for a given selection
+				 * target. */
+
+    /*
+     * Information used by tkAtom.c only:
+     */
+
+    int atomInit;		/* 0 means stuff below hasn't been
+				 * initialized yet. */
+    Tcl_HashTable nameTable;	/* Maps from names to Atom's. */
+    Tcl_HashTable atomTable;	/* Maps from Atom's back to names. */
+
+    /*
+     * Information used by tkCursor.c only:
+     */
+
+    Font cursorFont;		/* Font to use for standard cursors.
+				 * None means font not loaded yet. */
+
+    /*
+     * Information used by tkGrab.c only:
+     */
+
+     TkWindow *grabWinPtr;
+    /* Window in which the pointer is currently
+				 * grabbed, or NULL if none. */
+     TkWindow *eventualGrabWinPtr;
+    /* Value that grabWinPtr will have once the
+				 * grab event queue (below) has been
+				 * completely emptied. */
+     TkWindow *buttonWinPtr;
+    /* Window in which first mouse button was
+				 * pressed while grab was in effect, or NULL
+				 * if no such press in effect. */
+     TkWindow *serverWinPtr;
+    /* If no application contains the pointer then
+				 * this is NULL.  Otherwise it contains the
+				 * last window for which we've gotten an
+				 * Enter or Leave event from the server (i.e.
+				 * the last window known to have contained
+				 * the pointer).  Doesn't reflect events
+				 * that were synthesized in tkGrab.c. */
+    TkGrabEvent *firstGrabEventPtr;
+    /* First in list of enter/leave events
+				 * synthesized by grab code.  These events
+				 * must be processed in order before any other
+				 * events are processed.  NULL means no such
+				 * events. */
+    TkGrabEvent *lastGrabEventPtr;
+    /* Last in list of synthesized events, or NULL
+				 * if list is empty. */
+    int grabFlags;		/* Miscellaneous flag values.  See definitions
+				 * in tkGrab.c. */
+
+    /*
+     * Information used by tkXId.c only:
+     */
+
+     TkIdStack *idStackPtr;
+    /* First in list of chunks of free resource
+				 * identifiers, or NULL if there are no free
+				 * resources. */
+              XID(*defaultAllocProc) _ANSI_ARGS_((Display *display));
+    /* Default resource allocator for display. */
+     TkIdStack *windowStackPtr;
+    /* First in list of chunks of window
+				 * identifers that can't be reused right
+				 * now. */
+    int idCleanupScheduled;	/* 1 means a call to WindowIdCleanup has
+				 * already been scheduled, 0 means it
+				 * hasn't. */
+
+    /*
+     * Information maintained by tkWindow.c for use later on by tkXId.c:
+     */
+
+
+    int destroyCount;		/* Number of Tk_DestroyWindow operations
+				 * in progress. */
+    unsigned long lastDestroyRequest;
+    /* Id of most recent XDestroyWindow request;
+				 * can re-use ids in windowStackPtr when
+				 * server has seen this request and event
+				 * queue is empty. */
+
+    /*
+     * Information used by tkVisual.c only:
+     */
+
+    TkColormap *cmapPtr;	/* First in list of all non-default colormaps
+				 * allocated for this display. */
+
+    /*
+     * Information used by tkFocus.c only:
+     */
+#if (TK_MAJOR_VERSION == 4)
+
+     TkWindow *focusWinPtr;
+				/* Window that currently has the focus for
+				 * this display, or NULL if none. */
+     TkWindow *implicitWinPtr;
+				/* If the focus arrived at a toplevel window
+				 * implicitly via an Enter event (rather
+				 * than via a FocusIn event), this points
+				 * to the toplevel window.  Otherwise it is
+				 * NULL. */
+     TkWindow *focusOnMapPtr;
+				/* This points to a toplevel window that is
+				 * supposed to receive the X input focus as
+				 * soon as it is mapped (needed to handle the
+				 * fact that X won't allow the focus on an
+				 * unmapped window).  NULL means no delayed
+				 * focus op in progress. */
+    int forceFocus;		/* Associated with focusOnMapPtr:  non-zero
+				 * means claim the focus even if some other
+				 * application currently has it. */
+#else
+     TkWindow *implicitWinPtr;
+				/* If the focus arrived at a toplevel window
+				 * implicitly via an Enter event (rather
+				 * than via a FocusIn event), this points
+				 * to the toplevel window.  Otherwise it is
+				 * NULL. */
+     TkWindow *focusPtr;	/* Points to the window on this display that
+				 * should be receiving keyboard events.  When
+				 * multiple applications on the display have
+				 * the focus, this will refer to the
+				 * innermost window in the innermost
+				 * application.  This information isn't used
+				 * under Unix or Windows, but it's needed on
+				 * the Macintosh. */
+#endif /* TK_MAJOR_VERSION == 4 */
+
+    /*
+     * Used by tkColor.c only:
+     */
+
+    TkStressedCmap *stressPtr;	/* First in list of colormaps that have
+				 * filled up, so we have to pick an
+				 * approximate color. */
+
+    /*
+     * Used by tkEvent.c only:
+     */
+
+     TkWindowEvent *delayedMotionPtr;
+				/* Points to a malloc-ed motion event
+				 * whose processing has been delayed in
+				 * the hopes that another motion event
+				 * will come along right away and we can
+				 * merge the two of them together.  NULL
+				 * means that there is no delayed motion
+				 * event. */
+    /*
+     * Miscellaneous information:
+     */
+
+#ifdef TK_USE_INPUT_METHODS
+    XIM inputMethod;		/* Input method for this display */
+#endif /* TK_USE_INPUT_METHODS */
+    Tcl_HashTable winTable;	/* Maps from X window ids to TkWindow ptrs. */
+#if (TK_MAJOR_VERSION > 4)
+    int refCount;		/* Reference count of how many Tk applications
+                                 * are using this display. Used to clean up
+                                 * the display when we no longer have any
+                                 * Tk applications using it.
+                                 */
+#endif /* TK_MAJOR_VERSION > 4 */
+
+} TkDisplay;
+
+#endif /* TK_VERSION_NUMBER >= _VERSION(8,1,0) */
+
+
+struct TkWindowStruct {
+    Display *display;
+    TkDisplay *dispPtr;
+    int screenNum;
+    Visual *visual;
+    int depth;
+    Window window;
+    TkWindow *childList;
+    TkWindow *lastChildPtr;
+    TkWindow *parentPtr;
+    TkWindow *nextPtr;
+    TkMainInfo *infoPtr;
+    char *pathName;
+    Tk_Uid nameUid;
+    Tk_Uid classUid;
+    XWindowChanges changes;
+    unsigned int dirtyChanges;
+    XSetWindowAttributes atts;
+    unsigned long dirtyAtts;
+    unsigned int flags;
+    TkEventHandler *handlerList;
+#ifdef TK_USE_INPUT_METHODS
+    XIC inputContext;
+#endif /* TK_USE_INPUT_METHODS */
+    ClientData *tagPtr;
+    int nTags;
+    int optionLevel;
+    TkSelHandler *selHandlerList;
+    Tk_GeomMgr *geomMgrPtr;
+    ClientData geomData;
+    int reqWidth, reqHeight;
+    int internalBorderWidth;
+    TkWinInfo *wmInfoPtr;
+#if (TK_MAJOR_VERSION > 4)
+    TkClassProcs *classProcsPtr;
+    ClientData instanceData;
+#endif
+    TkWindowPrivate *privatePtr;
+};
+
+#ifdef WIN32
+/*
+ *----------------------------------------------------------------------
+ *
+ * GetWindowHandle --
+ *
+ *      Returns the XID for the Tk_Window given.  Starting in Tk 8.0,
+ *      the toplevel widgets are wrapped by another window.
+ *      Currently there's no way to get at that window, other than
+ *      what is done here: query the X window hierarchy and grab the
+ *      parent.
+ *
+ * Results:
+ *      Returns the X Window ID of the widget.  If it's a toplevel, then
+ *	the XID of the wrapper is returned.
+ *
+ *----------------------------------------------------------------------
+ */
+static HWND
+GetWindowHandle(Tk_Window tkwin)
+{
+    HWND hWnd;
+    Window window;
+    
+    window = Tk_WindowId(tkwin);
+    if (window == None) {
+	Tk_MakeWindowExist(tkwin);
+    }
+    hWnd = Tk_GetHWND(Tk_WindowId(tkwin));
+#if (TK_MAJOR_VERSION > 4)
+    if (Tk_IsTopLevel(tkwin)) {
+	hWnd = GetParent(hWnd);
+    }
+#endif /* TK_MAJOR_VERSION > 4 */
+    return hWnd;
+}
+
+#else
+
+Window
+Blt_GetParent(display, window)
+    Display *display;
+    Window window;
+{
+    Window root, parent;
+    Window *dummy;
+    unsigned int count;
+
+    if (XQueryTree(display, window, &root, &parent, &dummy, &count) > 0) {
+	XFree(dummy);
+	return parent;
+    }
+    return None;
+}
+
+static Window
+GetWindowId(tkwin)
+    Tk_Window tkwin;
+{
+    Window window;
+
+    Tk_MakeWindowExist(tkwin);
+    window = Tk_WindowId(tkwin);
+#if (TK_MAJOR_VERSION > 4)
+    if (Tk_IsTopLevel(tkwin)) {
+	Window parent;
+
+	parent = Blt_GetParent(Tk_Display(tkwin), window);
+	if (parent != None) {
+	    window = parent;
+	}
+	window = parent;
+    }
+#endif /* TK_MAJOR_VERSION > 4 */
+    return window;
+}
+
+#endif /* WIN32 */
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * DoConfigureNotify --
+ *
+ *	Generate a ConfigureNotify event describing the current
+ *	configuration of a window.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	An event is generated and processed by Tk_HandleEvent.
+ *
+ *----------------------------------------------------------------------
+ */
+static void
+DoConfigureNotify(winPtr)
+    Tk_FakeWin *winPtr;		/* Window whose configuration was just
+				 * changed. */
+{
+    XEvent event;
+
+    event.type = ConfigureNotify;
+    event.xconfigure.serial = LastKnownRequestProcessed(winPtr->display);
+    event.xconfigure.send_event = False;
+    event.xconfigure.display = winPtr->display;
+    event.xconfigure.event = winPtr->window;
+    event.xconfigure.window = winPtr->window;
+    event.xconfigure.x = winPtr->changes.x;
+    event.xconfigure.y = winPtr->changes.y;
+    event.xconfigure.width = winPtr->changes.width;
+    event.xconfigure.height = winPtr->changes.height;
+    event.xconfigure.border_width = winPtr->changes.border_width;
+    if (winPtr->changes.stack_mode == Above) {
+	event.xconfigure.above = winPtr->changes.sibling;
+    } else {
+	event.xconfigure.above = None;
+    }
+    event.xconfigure.override_redirect = winPtr->atts.override_redirect;
+    Tk_HandleEvent(&event);
+}
+
+/*
+ *--------------------------------------------------------------
+ *
+ * Blt_MakeTransparentWindowExist --
+ *
+ *	Similar to Tk_MakeWindowExist but instead creates a
+ *	transparent window to block for user events from sibling
+ *	windows.
+ *
+ *	Differences from Tk_MakeWindowExist.
+ *
+ *	1. This is always a "busy" window. There's never a
+ *	   platform-specific class procedure to execute instead.
+ *	2. The window is transparent and never will contain children,
+ *	   so colormap information is irrelevant.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	When the procedure returns, the internal window associated
+ *	with tkwin is guaranteed to exist.  This may require the
+ *	window's ancestors to be created too.
+ *
+ *--------------------------------------------------------------
+ */
+void
+Blt_MakeTransparentWindowExist(tkwin, parent, isBusy)
+    Tk_Window tkwin;		/* Token for window. */
+    Window parent;		/* Parent window. */
+    int isBusy;			/*  */
+{
+    TkWindow *winPtr = (TkWindow *) tkwin;
+    TkWindow *winPtr2;
+    Tcl_HashEntry *hPtr;
+    int notUsed;
+    TkDisplay *dispPtr;
+#ifdef WIN32
+    HWND hParent;
+    int style;
+    DWORD exStyle;
+    HWND hWnd;
+#else
+    long int mask;
+#endif /* WIN32 */
+
+    if (winPtr->window != None) {
+	return;			/* Window already exists. */
+    }
+#ifdef notdef			
+    if ((winPtr->parentPtr == NULL) || (winPtr->flags & TK_TOP_LEVEL)) {
+	parent = XRootWindow(winPtr->display, winPtr->screenNum);
+	/* TODO: Make the entire screen busy */
+    } else {
+	if (Tk_WindowId(winPtr->parentPtr) == None) {
+	    Tk_MakeWindowExist((Tk_Window)winPtr->parentPtr);
+	}
+    }
+#endif
+
+    /* Create a transparent window and put it on top.  */
+
+#ifdef WIN32
+    hParent = (HWND) parent;
+    style = (WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS);
+    exStyle = (WS_EX_TRANSPARENT | WS_EX_TOPMOST);
+#define TK_WIN_CHILD_CLASS_NAME "TkChild"
+    hWnd = CreateWindowEx(exStyle, TK_WIN_CHILD_CLASS_NAME, NULL, style,
+	Tk_X(tkwin), Tk_Y(tkwin), Tk_Width(tkwin), Tk_Height(tkwin),
+	hParent, NULL, (HINSTANCE) Tk_GetHINSTANCE(), NULL);
+    winPtr->window = Tk_AttachHWND(tkwin, hWnd);
+#else
+    mask = (!isBusy) ? 0 : (CWDontPropagate | CWEventMask);
+    /* Ignore the important events while the window is mapped.  */
+#define USER_EVENTS  (EnterWindowMask | LeaveWindowMask | KeyPressMask | \
+	KeyReleaseMask | ButtonPressMask | ButtonReleaseMask | PointerMotionMask)
+#define PROP_EVENTS  (KeyPressMask | KeyReleaseMask | ButtonPressMask | \
+	ButtonReleaseMask | PointerMotionMask)
+
+    winPtr->atts.do_not_propagate_mask = PROP_EVENTS;
+    winPtr->atts.event_mask = USER_EVENTS;
+    winPtr->changes.border_width = 0;
+    winPtr->depth = 0; 
+
+    winPtr->window = XCreateWindow(winPtr->display, parent,
+	winPtr->changes.x, winPtr->changes.y,
+	(unsigned)winPtr->changes.width,	/* width */
+	(unsigned)winPtr->changes.height,	/* height */
+	(unsigned)winPtr->changes.border_width,	/* border_width */
+	winPtr->depth,		/* depth */
+	InputOnly,		/* class */
+	winPtr->visual,		/* visual */
+        mask,			/* valuemask */
+	&(winPtr->atts)		/* attributes */ );
+#endif /* WIN32 */
+
+    dispPtr = winPtr->dispPtr;
+    hPtr = Tcl_CreateHashEntry(&(dispPtr->winTable), (char *)winPtr->window,
+	&notUsed);
+    Tcl_SetHashValue(hPtr, winPtr);
+    winPtr->dirtyAtts = 0;
+    winPtr->dirtyChanges = 0;
+#ifdef TK_USE_INPUT_METHODS
+    winPtr->inputContext = NULL;
+#endif /* TK_USE_INPUT_METHODS */
+    if (!(winPtr->flags & TK_TOP_LEVEL)) {
+	/*
+	 * If any siblings higher up in the stacking order have already
+	 * been created then move this window to its rightful position
+	 * in the stacking order.
+	 *
+	 * NOTE: this code ignores any changes anyone might have made
+	 * to the sibling and stack_mode field of the window's attributes,
+	 * so it really isn't safe for these to be manipulated except
+	 * by calling Tk_RestackWindow.
+	 */
+	for (winPtr2 = winPtr->nextPtr; winPtr2 != NULL;
+	    winPtr2 = winPtr2->nextPtr) {
+	    if ((winPtr2->window != None) && !(winPtr2->flags & TK_TOP_LEVEL)) {
+		XWindowChanges changes;
+		changes.sibling = winPtr2->window;
+		changes.stack_mode = Below;
+		XConfigureWindow(winPtr->display, winPtr->window,
+		    CWSibling | CWStackMode, &changes);
+		break;
+	    }
+	}
+    }
+
+    /*
+     * Issue a ConfigureNotify event if there were deferred configuration
+     * changes (but skip it if the window is being deleted;  the
+     * ConfigureNotify event could cause problems if we're being called
+     * from Tk_DestroyWindow under some conditions).
+     */
+    if ((winPtr->flags & TK_NEED_CONFIG_NOTIFY)
+	&& !(winPtr->flags & TK_ALREADY_DEAD)) {
+	winPtr->flags &= ~TK_NEED_CONFIG_NOTIFY;
+	DoConfigureNotify((Tk_FakeWin *) tkwin);
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_FindChild --
+ *
+ *      Performs a linear search for the named child window in a given
+ *	parent window.
+ *
+ *	This can be done via Tcl, but not through Tk's C API.  It's 
+ *	simple enough, if you peek into the Tk_Window structure.
+ *
+ * Results:
+ *      The child Tk_Window. If the named child can't be found, NULL
+ *	is returned.
+ *
+ *----------------------------------------------------------------------
+ */
+
+/*LINTLIBRARY*/
+Tk_Window
+Blt_FindChild(parent, name)
+    Tk_Window parent;
+    char *name;
+{
+    register TkWindow *winPtr;
+    TkWindow *parentPtr = (TkWindow *)parent;
+
+    for (winPtr = parentPtr->childList; winPtr != NULL; 
+	winPtr = winPtr->nextPtr) {
+	if (strcmp(name, winPtr->nameUid) == 0) {
+	    return (Tk_Window)winPtr;
+	}
+    }
+    return NULL;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_FirstChildWindow --
+ *
+ *      Performs a linear search for the named child window in a given
+ *	parent window.
+ *
+ *	This can be done via Tcl, but not through Tk's C API.  It's 
+ *	simple enough, if you peek into the Tk_Window structure.
+ *
+ * Results:
+ *      The child Tk_Window. If the named child can't be found, NULL
+ *	is returned.
+ *
+ *----------------------------------------------------------------------
+ */
+/*LINTLIBRARY*/
+Tk_Window
+Blt_FirstChild(parent)
+    Tk_Window parent;
+{
+    TkWindow *parentPtr = (TkWindow *)parent;
+    return (Tk_Window)parentPtr->childList;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_FindChild --
+ *
+ *      Performs a linear search for the named child window in a given
+ *	parent window.
+ *
+ *	This can be done via Tcl, but not through Tk's C API.  It's 
+ *	simple enough, if you peek into the Tk_Window structure.
+ *
+ * Results:
+ *      The child Tk_Window. If the named child can't be found, NULL
+ *	is returned.
+ *
+ *----------------------------------------------------------------------
+ */
+
+/*LINTLIBRARY*/
+Tk_Window
+Blt_NextChild(tkwin)
+    Tk_Window tkwin;
+{
+    TkWindow *winPtr = (TkWindow *)tkwin;
+
+    if (winPtr == NULL) {
+	return NULL;
+    }
+    return (Tk_Window)winPtr->nextPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * UnlinkWindow --
+ *
+ *	This procedure removes a window from the childList of its
+ *	parent.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The window is unlinked from its childList.
+ *
+ *----------------------------------------------------------------------
+ */
+static void
+UnlinkWindow(winPtr)
+    TkWindow *winPtr;	/* Child window to be unlinked. */
+{
+    TkWindow *prevPtr;
+
+    prevPtr = winPtr->parentPtr->childList;
+    if (prevPtr == winPtr) {
+	winPtr->parentPtr->childList = winPtr->nextPtr;
+	if (winPtr->nextPtr == NULL) {
+	    winPtr->parentPtr->lastChildPtr = NULL;
+	}
+    } else {
+	while (prevPtr->nextPtr != winPtr) {
+	    prevPtr = prevPtr->nextPtr;
+	    if (prevPtr == NULL) {
+		panic("UnlinkWindow couldn't find child in parent");
+	    }
+	}
+	prevPtr->nextPtr = winPtr->nextPtr;
+	if (winPtr->nextPtr == NULL) {
+	    winPtr->parentPtr->lastChildPtr = prevPtr;
+	}
+    }
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_RelinkWindow --
+ *
+ *	Relinks a window into a new parent.  The window is unlinked
+ *	from its original parent's child list and added onto the end
+ *	of the new parent's list.
+ *
+ *	FIXME:  If the window has focus, the focus should be moved
+ *		to an ancestor.  Otherwise, Tk becomes confused 
+ *		about which Toplevel turns on focus for the window. 
+ *		Right now this is done at the Tcl layer.  For example,
+ *		see blt::CreateTearoff in tabset.tcl.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The window is unlinked from its childList.
+ *
+ *----------------------------------------------------------------------
+ */
+void
+Blt_RelinkWindow(tkwin, newParent, x, y)
+    Tk_Window tkwin;		/* Child window to be linked. */
+    Tk_Window newParent;
+    int x, y;
+{
+    TkWindow *winPtr, *parentWinPtr;
+
+    if (Blt_ReparentWindow(Tk_Display(tkwin), Tk_WindowId(tkwin),
+	    Tk_WindowId(newParent), x, y) != TCL_OK) {
+	return;
+    }
+    winPtr = (TkWindow *)tkwin;
+    parentWinPtr = (TkWindow *)newParent;
+
+    winPtr->flags &= ~TK_REPARENTED;
+    UnlinkWindow(winPtr);	/* Remove the window from its parent's list */
+
+    /* Append the window onto the end of the parent's list of children */
+    winPtr->parentPtr = parentWinPtr;
+    winPtr->nextPtr = NULL;
+    if (parentWinPtr->childList == NULL) {
+	parentWinPtr->childList = winPtr;
+    } else {
+	parentWinPtr->lastChildPtr->nextPtr = winPtr;
+    }
+    parentWinPtr->lastChildPtr = winPtr;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_RelinkWindow --
+ *
+ *	Relinks a window into a new parent.  The window is unlinked
+ *	from its original parent's child list and added onto the end
+ *	of the new parent's list.
+ *
+ *	FIXME:  If the window has focus, the focus should be moved
+ *		to an ancestor.  Otherwise, Tk becomes confused 
+ *		about which Toplevel turns on focus for the window. 
+ *		Right now this is done at the Tcl layer.  For example,
+ *		see blt::CreateTearoff in tabset.tcl.
+ *
+ * Results:
+ *	None.
+ *
+ * Side effects:
+ *	The window is unlinked from its childList.
+ *
+ *----------------------------------------------------------------------
+ */
+void
+Blt_RelinkWindow2(tkwin, window, newParent, x, y)
+    Tk_Window tkwin;		/* Child window to be linked. */
+    Window window;
+    Tk_Window newParent;
+    int x, y;
+{
+#ifdef notdef
+    TkWindow *winPtr, *parentWinPtr;
+#endif
+    if (Blt_ReparentWindow(Tk_Display(tkwin), window,
+	    Tk_WindowId(newParent), x, y) != TCL_OK) {
+	return;
+    }
+#ifdef notdef
+    winPtr = (TkWindow *)tkwin;
+    parentWinPtr = (TkWindow *)newParent;
+
+    winPtr->flags &= ~TK_REPARENTED;
+    UnlinkWindow(winPtr);	/* Remove the window from its parent's list */
+
+    /* Append the window onto the end of the parent's list of children */
+    winPtr->parentPtr = parentWinPtr;
+    winPtr->nextPtr = NULL;
+    if (parentWinPtr->childList == NULL) {
+	parentWinPtr->childList = winPtr;
+    } else {
+	parentWinPtr->lastChildPtr->nextPtr = winPtr;
+    }
+    parentWinPtr->lastChildPtr = winPtr;
+#endif
+}
+
+void
+Blt_UnlinkWindow(tkwin)
+    Tk_Window tkwin;		/* Child window to be linked. */
+{
+    TkWindow *winPtr;
+    Window root;
+
+    root = XRootWindow(Tk_Display(tkwin), Tk_ScreenNumber(tkwin));
+    if (Blt_ReparentWindow(Tk_Display(tkwin), Tk_WindowId(tkwin),
+	    root, 0, 0) != TCL_OK) {
+	return;
+    }
+    winPtr = (TkWindow *)tkwin;
+    winPtr->flags &= ~TK_REPARENTED;
+#ifdef notdef
+    UnlinkWindow(winPtr);	/* Remove the window from its parent's list */
+#endif
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_Toplevel --
+ *
+ *      Climbs up the widget hierarchy to find the top level window of
+ *      the window given.
+ *
+ * Results:
+ *      Returns the Tk_Window of the toplevel widget.
+ *
+ *----------------------------------------------------------------------
+ */
+Tk_Window
+Blt_Toplevel(tkwin)
+    register Tk_Window tkwin;
+{
+    while (!Tk_IsTopLevel(tkwin)) {
+	tkwin = Tk_Parent(tkwin);
+    }
+    return tkwin;
+}
+
+void
+Blt_RootCoordinates(tkwin, x, y, rootXPtr, rootYPtr)
+    Tk_Window tkwin;
+    int x, y;
+    int *rootXPtr, *rootYPtr;
+{
+    int vx, vy, vw, vh;
+    int rootX, rootY;
+
+    Tk_GetRootCoords(tkwin, &rootX, &rootY);
+    x += rootX;
+    y += rootY;
+    Tk_GetVRootGeometry(tkwin, &vx, &vy, &vw, &vh);
+    x += vx;
+    y += vy;
+    *rootXPtr = x;
+    *rootYPtr = y;
+}
+
+
+/* Find the toplevel then  */
+int
+Blt_RootX(tkwin)
+    Tk_Window tkwin;
+{
+    int x;
+    
+    for (x = 0; tkwin != NULL;  tkwin = Tk_Parent(tkwin)) {
+	x += Tk_X(tkwin) + Tk_Changes(tkwin)->border_width;
+	if (Tk_IsTopLevel(tkwin)) {
+	    break;
+	}
+    }
+    return x;
+}
+
+int
+Blt_RootY(tkwin)
+    Tk_Window tkwin;
+{
+    int y;
+    
+    for (y = 0; tkwin != NULL;  tkwin = Tk_Parent(tkwin)) {
+	y += Tk_Y(tkwin) + Tk_Changes(tkwin)->border_width;
+	if (Tk_IsTopLevel(tkwin)) {
+	    break;
+	}
+    }
+    return y;
+}
+
+#ifdef WIN32
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_GetRealWindowId --
+ *
+ *      Returns the XID for the Tk_Window given.  Starting in Tk 8.0,
+ *      the toplevel widgets are wrapped by another window.
+ *      Currently there's no way to get at that window, other than
+ *      what is done here: query the X window hierarchy and grab the
+ *      parent.
+ *
+ * Results:
+ *      Returns the X Window ID of the widget.  If it's a toplevel, then
+ *	the XID of the wrapper is returned.
+ *
+ *----------------------------------------------------------------------
+ */
+Window
+Blt_GetRealWindowId(Tk_Window tkwin)
+{
+    return (Window) GetWindowHandle(tkwin);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_GetToplevel --
+ *
+ *      Retrieves the toplevel window which is the nearest ancestor of
+ *      of the specified window.
+ *
+ * Results:
+ *      Returns the toplevel window or NULL if the window has no
+ *      ancestor which is a toplevel.
+ *
+ * Side effects:
+ *      None.
+ *
+ *----------------------------------------------------------------------
+ */
+Tk_Window
+Blt_GetToplevel(Tk_Window tkwin) /* Window for which the toplevel
+				  * should be deterined. */
+{
+     while (!Tk_IsTopLevel(tkwin)) {
+         tkwin = Tk_Parent(tkwin);
+	 if (tkwin == NULL) {
+             return NULL;
+         }
+     }
+     return tkwin;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_RaiseToLevelWindow --
+ *
+ * Results:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+void
+Blt_RaiseToplevel(Tk_Window tkwin)
+{
+    SetWindowPos(GetWindowHandle(tkwin), HWND_TOP, 0, 0, 0, 0,
+	SWP_NOMOVE | SWP_NOSIZE);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_MapToplevel --
+ *
+ * Results:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+void
+Blt_MapToplevel(Tk_Window tkwin)
+{
+    ShowWindow(GetWindowHandle(tkwin), SW_SHOWNORMAL);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_UnmapToplevel --
+ *
+ * Results:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+void
+Blt_UnmapToplevel(Tk_Window tkwin)
+{
+    ShowWindow(GetWindowHandle(tkwin), SW_HIDE);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_MoveResizeToplevel --
+ *
+ * Results:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+void
+Blt_MoveResizeToplevel(tkwin, x, y, width, height)
+    Tk_Window tkwin;
+    int x, y, width, height;
+{
+    SetWindowPos(GetWindowHandle(tkwin), HWND_TOP, x, y, width, height, 0);
+}
+
+int
+Blt_ReparentWindow(
+    Display *display,
+    Window window, 
+    Window newParent,
+    int x, int y)
+{
+    XReparentWindow(display, window, newParent, x, y);
+    return TCL_OK;
+}
+
+#else  /* WIN32 */
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_GetRealWindowId --
+ *
+ *      Returns the XID for the Tk_Window given.  Starting in Tk 8.0,
+ *      the toplevel widgets are wrapped by another window.
+ *      Currently there's no way to get at that window, other than
+ *      what is done here: query the X window hierarchy and grab the
+ *      parent.
+ *
+ * Results:
+ *      Returns the X Window ID of the widget.  If it's a toplevel, then
+ *	the XID of the wrapper is returned.
+ *
+ *----------------------------------------------------------------------
+ */
+Window
+Blt_GetRealWindowId(tkwin)
+    Tk_Window tkwin;
+{
+    return GetWindowId(tkwin);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_RaiseToplevel --
+ *
+ * Results:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+void
+Blt_RaiseToplevel(tkwin)
+    Tk_Window tkwin;
+{
+    XRaiseWindow(Tk_Display(tkwin), GetWindowId(tkwin));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_LowerToplevel --
+ *
+ * Results:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+void
+Blt_LowerToplevel(tkwin)
+    Tk_Window tkwin;
+{
+    XLowerWindow(Tk_Display(tkwin), GetWindowId(tkwin));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_ResizeToplevel --
+ *
+ * Results:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+void
+Blt_ResizeToplevel(tkwin, width, height)
+    Tk_Window tkwin;
+    int width, height;
+{
+    XResizeWindow(Tk_Display(tkwin), GetWindowId(tkwin), width, height);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_MoveResizeToplevel --
+ *
+ * Results:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+void
+Blt_MoveResizeToplevel(tkwin, x, y, width, height)
+    Tk_Window tkwin;
+    int x, y, width, height;
+{
+    XMoveResizeWindow(Tk_Display(tkwin), GetWindowId(tkwin), x, y, 
+	      width, height);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_ResizeToplevel --
+ *
+ * Results:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+void
+Blt_MoveToplevel(tkwin, x, y)
+    Tk_Window tkwin;
+    int x, y;
+{
+    XMoveWindow(Tk_Display(tkwin), GetWindowId(tkwin), x, y);
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_MapToplevel --
+ *
+ * Results:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+void
+Blt_MapToplevel(tkwin)
+    Tk_Window tkwin;
+{
+    XMapWindow(Tk_Display(tkwin), GetWindowId(tkwin));
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Blt_UnmapToplevel --
+ *
+ * Results:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+void
+Blt_UnmapToplevel(tkwin)
+    Tk_Window tkwin;
+{
+    XUnmapWindow(Tk_Display(tkwin), GetWindowId(tkwin));
+}
+
+/* ARGSUSED */
+static int
+XReparentWindowErrorProc(clientData, errEventPtr)
+    ClientData clientData;
+    XErrorEvent *errEventPtr;
+{
+    int *errorPtr = clientData;
+
+    *errorPtr = TCL_ERROR;
+    return 0;
+}
+
+int
+Blt_ReparentWindow(display, window, newParent, x, y)
+    Display *display;
+    Window window, newParent;
+    int x, y;
+{
+    Tk_ErrorHandler handler;
+    int result;
+    int any = -1;
+
+    result = TCL_OK;
+    handler = Tk_CreateErrorHandler(display, any, X_ReparentWindow, any,
+	XReparentWindowErrorProc, &result);
+    XReparentWindow(display, window, newParent, x, y);
+    Tk_DeleteErrorHandler(handler);
+    XSync(display, False);
+    return result;
+}
+
+#endif /* WIN32 */
+
+#if (TK_MAJOR_VERSION == 4)
+#include <bltHash.h>
+static int initialized = FALSE;
+static Blt_HashTable windowTable;
+
+void
+Blt_SetWindowInstanceData(tkwin, instanceData)
+    Tk_Window tkwin;
+    ClientData instanceData;
+{
+    Blt_HashEntry *hPtr;
+    int isNew;
+
+    if (!initialized) {
+	Blt_InitHashTable(&windowTable, BLT_ONE_WORD_KEYS);
+	initialized = TRUE;
+    }
+    hPtr = Blt_CreateHashEntry(&windowTable, (char *)tkwin, &isNew);
+    assert(isNew);
+    Blt_SetHashValue(hPtr, instanceData);
+}
+
+ClientData
+Blt_GetWindowInstanceData(tkwin)
+    Tk_Window tkwin;
+{
+    Blt_HashEntry *hPtr;
+
+    hPtr = Blt_FindHashEntry(&windowTable, (char *)tkwin);
+    if (hPtr == NULL) {
+	return NULL;
+    }
+    return Blt_GetHashValue(hPtr);
+}
+
+void
+Blt_DeleteWindowInstanceData(tkwin)
+    Tk_Window tkwin;
+{
+    Blt_HashEntry *hPtr;
+
+    hPtr = Blt_FindHashEntry(&windowTable, (char *)tkwin);
+    assert(hPtr);
+    Blt_DeleteHashEntry(&windowTable, hPtr);
+}
+
+#else
+
+void
+Blt_SetWindowInstanceData(tkwin, instanceData)
+    Tk_Window tkwin;
+    ClientData instanceData;
+{
+    TkWindow *winPtr = (TkWindow *)tkwin;
+
+    winPtr->instanceData = instanceData;
+}
+
+ClientData
+Blt_GetWindowInstanceData(tkwin)
+    Tk_Window tkwin;
+{
+    TkWindow *winPtr = (TkWindow *)tkwin;
+
+    return winPtr->instanceData;
+}
+
+void
+Blt_DeleteWindowInstanceData(tkwin)
+    Tk_Window tkwin;
+{
+}
+
+#endif
+
diff -uNr blt2.4z/src/bltWindow.c.rej blt2.4z.tcltk86/src/bltWindow.c.rej
--- blt2.4z/src/bltWindow.c.rej	1969-12-31 19:00:00.000000000 -0500
+++ blt2.4z.tcltk86/src/bltWindow.c.rej	2013-08-20 11:23:42.000000000 -0400
@@ -0,0 +1,757 @@
+***************
+*** 71,820 ****
+  #endif
+  
+- #if (TK_VERSION_NUMBER >= _VERSION(8,1,0))
+- 
+- typedef struct TkCaret {
+-     struct TkWindow *winPtr;	/* the window on which we requested caret
+- 				 * placement */
+-     int x;			/* relative x coord of the caret */
+-     int y;			/* relative y coord of the caret */
+-     int height;			/* specified height of the window */
+- } TkCaret;
+- 
+- /*
+-  * One of the following structures is maintained for each display
+-  * containing a window managed by Tk.  In part, the structure is
+-  * used to store thread-specific data, since each thread will have
+-  * its own TkDisplay structure.
+-  */
+- 
+- typedef struct TkDisplayStruct {
+-     Display *display;		/* Xlib's info about display. */
+-     struct TkDisplayStruct *nextPtr; /* Next in list of all displays. */
+-     char *name;			/* Name of display (with any screen
+- 				 * identifier removed).  Malloc-ed. */
+-     Time lastEventTime;		/* Time of last event received for this
+- 				 * display. */
+- 
+-     /*
+-      * Information used primarily by tk3d.c:
+-      */
+- 
+-     int borderInit;		/* 0 means borderTable needs initializing. */
+-     Tcl_HashTable borderTable;	/* Maps from color name to TkBorder
+- 				 * structure. */
+- 
+-     /*
+-      * Information used by tkAtom.c only:
+-      */
+- 
+-     int atomInit;		/* 0 means stuff below hasn't been
+- 				 * initialized yet. */
+-     Tcl_HashTable nameTable;	/* Maps from names to Atom's. */
+-     Tcl_HashTable atomTable;	/* Maps from Atom's back to names. */
+- 
+-     /*
+-      * Information used primarily by tkBind.c:
+-      */
+- 
+-     int bindInfoStale;		/* Non-zero means the variables in this
+- 				 * part of the structure are potentially
+- 				 * incorrect and should be recomputed. */
+-     unsigned int modeModMask;	/* Has one bit set to indicate the modifier
+- 				 * corresponding to "mode shift".  If no
+- 				 * such modifier, than this is zero. */
+-     unsigned int metaModMask;	/* Has one bit set to indicate the modifier
+- 				 * corresponding to the "Meta" key.  If no
+- 				 * such modifier, then this is zero. */
+-     unsigned int altModMask;	/* Has one bit set to indicate the modifier
+- 				 * corresponding to the "Meta" key.  If no
+- 				 * such modifier, then this is zero. */
+-     enum {
+- 	LU_IGNORE, LU_CAPS, LU_SHIFT
+-     } lockUsage;		/* Indicates how to interpret lock modifier. */
+-     int numModKeyCodes;		/* Number of entries in modKeyCodes array
+- 				 * below. */
+-     KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for
+- 				 * all of the keys that have modifiers
+- 				 * associated with them.  Malloc'ed, but
+- 				 * may be NULL. */
+- 
+-     /*
+-      * Information used by tkBitmap.c only:
+-      */
+- 
+-     int bitmapInit;		/* 0 means tables above need initializing. */
+-     int bitmapAutoNumber;	/* Used to number bitmaps. */
+-     Tcl_HashTable bitmapNameTable;
+- 				/* Maps from name of bitmap to the first
+- 				 * TkBitmap record for that name. */
+-     Tcl_HashTable bitmapIdTable;/* Maps from bitmap id to the TkBitmap
+- 				 * structure for the bitmap. */
+-     Tcl_HashTable bitmapDataTable;
+- 				/* Used by Tk_GetBitmapFromData to map from
+- 				 * a collection of in-core data about a
+- 				 * bitmap to a reference giving an auto-
+- 				 * matically-generated name for the bitmap. */
+- 
+-     /*
+-      * Information used by tkCanvas.c only:
+-      */
+- 
+-     int numIdSearches;
+-     int numSlowSearches;
+- 
+-     /*
+-      * Used by tkColor.c only:
+-      */
+- 
+-     int colorInit;		/* 0 means color module needs initializing. */
+-     TkStressedCmap *stressPtr;	/* First in list of colormaps that have
+- 				 * filled up, so we have to pick an
+- 				 * approximate color. */
+-     Tcl_HashTable colorNameTable;
+- 				/* Maps from color name to TkColor structure
+- 				 * for that color. */
+-     Tcl_HashTable colorValueTable;
+- 				/* Maps from integer RGB values to TkColor
+- 				 * structures. */
+- 
+-     /*
+-      * Used by tkCursor.c only:
+-      */
+- 
+-     int cursorInit;		/* 0 means cursor module need initializing. */
+-     Tcl_HashTable cursorNameTable;
+- 				/* Maps from a string name to a cursor to the
+- 				 * TkCursor record for the cursor. */
+-     Tcl_HashTable cursorDataTable;
+- 				/* Maps from a collection of in-core data
+- 				 * about a cursor to a TkCursor structure. */
+-     Tcl_HashTable cursorIdTable;
+- 				/* Maps from a cursor id to the TkCursor
+- 				 * structure for the cursor. */
+-     char cursorString[20];	/* Used to store a cursor id string. */
+-     Font cursorFont;		/* Font to use for standard cursors.
+- 				 * None means font not loaded yet. */
+- 
+-     /*
+-      * Information used by tkError.c only:
+-      */
+- 
+-     struct TkErrorHandler *errorPtr;
+- 				/* First in list of error handlers
+- 				 * for this display.  NULL means
+- 				 * no handlers exist at present. */
+-     int deleteCount;		/* Counts # of handlers deleted since
+- 				 * last time inactive handlers were
+- 				 * garbage-collected.  When this number
+- 				 * gets big, handlers get cleaned up. */
+- 
+-     /*
+-      * Used by tkEvent.c only:
+-      */
+- 
+-     struct TkWindowEvent *delayedMotionPtr;
+- 				/* Points to a malloc-ed motion event
+- 				 * whose processing has been delayed in
+- 				 * the hopes that another motion event
+- 				 * will come along right away and we can
+- 				 * merge the two of them together.  NULL
+- 				 * means that there is no delayed motion
+- 				 * event. */
+- 
+-     /*
+-      * Information used by tkFocus.c only:
+-      */
+- 
+-     int focusDebug;		/* 1 means collect focus debugging
+- 				 * statistics. */
+-     struct TkWindow *implicitWinPtr;
+- 				/* If the focus arrived at a toplevel window
+- 				 * implicitly via an Enter event (rather
+- 				 * than via a FocusIn event), this points
+- 				 * to the toplevel window.  Otherwise it is
+- 				 * NULL. */
+-     struct TkWindow *focusPtr;	/* Points to the window on this display that
+- 				 * should be receiving keyboard events.  When
+- 				 * multiple applications on the display have
+- 				 * the focus, this will refer to the
+- 				 * innermost window in the innermost
+- 				 * application.  This information isn't used
+- 				 * under Unix or Windows, but it's needed on
+- 				 * the Macintosh. */
+- 
+-     /*
+-      * Information used by tkGC.c only:
+-      */
+- 
+-     Tcl_HashTable gcValueTable;	/* Maps from a GC's values to a TkGC structure
+- 				 * describing a GC with those values. */
+-     Tcl_HashTable gcIdTable;	/* Maps from a GC to a TkGC. */
+-     int gcInit;			/* 0 means the tables below need
+- 				 * initializing. */
+- 
+-     /*
+-      * Information used by tkGeometry.c only:
+-      */
+- 
+-     Tcl_HashTable maintainHashTable;
+- 				/* Hash table that maps from a master's
+- 				 * Tk_Window token to a list of slaves
+- 				 * managed by that master. */
+-     int geomInit;
+- 
+-     /*
+-      * Information used by tkGet.c only:
+-      */
+- 
+-     Tcl_HashTable uidTable;	/* Stores all Tk_Uids used in a thread. */
+-     int uidInit;		/* 0 means uidTable needs initializing. */
+- 
+-     /*
+-      * Information used by tkGrab.c only:
+-      */
+- 
+-     struct TkWindow *grabWinPtr;
+- 				/* Window in which the pointer is currently
+- 				 * grabbed, or NULL if none. */
+-     struct TkWindow *eventualGrabWinPtr;
+- 				/* Value that grabWinPtr will have once the
+- 				 * grab event queue (below) has been
+- 				 * completely emptied. */
+-     struct TkWindow *buttonWinPtr;
+- 				/* Window in which first mouse button was
+- 				 * pressed while grab was in effect, or NULL
+- 				 * if no such press in effect. */
+-     struct TkWindow *serverWinPtr;
+- 				/* If no application contains the pointer then
+- 				 * this is NULL.  Otherwise it contains the
+- 				 * last window for which we've gotten an
+- 				 * Enter or Leave event from the server (i.e.
+- 				 * the last window known to have contained
+- 				 * the pointer).  Doesn't reflect events
+- 				 * that were synthesized in tkGrab.c. */
+-     TkGrabEvent *firstGrabEventPtr;
+- 				/* First in list of enter/leave events
+- 				 * synthesized by grab code.  These events
+- 				 * must be processed in order before any other
+- 				 * events are processed.  NULL means no such
+- 				 * events. */
+-     TkGrabEvent *lastGrabEventPtr;
+- 				/* Last in list of synthesized events, or NULL
+- 				 * if list is empty. */
+-     int grabFlags;		/* Miscellaneous flag values.  See definitions
+- 				 * in tkGrab.c. */
+- 
+-     /*
+-      * Information used by tkGrid.c only:
+-      */
+- 
+-     int gridInit;		/* 0 means table below needs initializing. */
+-     Tcl_HashTable gridHashTable;/* Maps from Tk_Window tokens to
+- 				 * corresponding Grid structures. */
+- 
+-     /*
+-      * Information used by tkImage.c only:
+-      */
+- 
+-     int imageId;		/* Value used to number image ids. */
+- 
+-     /*
+-      * Information used by tkMacWinMenu.c only:
+-      */
+- 
+-     int postCommandGeneration;
+- 
+-     /*
+-      * Information used by tkOption.c only.
+-      */
+- 
+- 
+- 
+-     /*
+-      * Information used by tkPack.c only.
+-      */
+- 
+-     int packInit;		/* 0 means table below needs initializing. */
+-     Tcl_HashTable packerHashTable;
+- 				/* Maps from Tk_Window tokens to
+- 				 * corresponding Packer structures. */
+- 
+- 
+-     /*
+-      * Information used by tkPlace.c only.
+-      */
+- 
+-     int placeInit;		/* 0 means tables below need initializing. */
+-     Tcl_HashTable masterTable;	/* Maps from Tk_Window toke to the Master
+- 				 * structure for the window, if it exists. */
+-     Tcl_HashTable slaveTable;	/* Maps from Tk_Window toke to the Slave
+- 				 * structure for the window, if it exists. */
+- 
+-     /*
+-      * Information used by tkSelect.c and tkClipboard.c only:
+-      */
+- 
+- 
+-     struct TkSelectionInfo *selectionInfoPtr;
+-     /* First in list of selection information
+- 				 * records.  Each entry contains information
+- 				 * about the current owner of a particular
+- 				 * selection on this display. */
+-     Atom multipleAtom;		/* Atom for MULTIPLE.  None means
+- 				 * selection stuff isn't initialized. */
+-     Atom incrAtom;		/* Atom for INCR. */
+-     Atom targetsAtom;		/* Atom for TARGETS. */
+-     Atom timestampAtom;		/* Atom for TIMESTAMP. */
+-     Atom textAtom;		/* Atom for TEXT. */
+-     Atom compoundTextAtom;	/* Atom for COMPOUND_TEXT. */
+-     Atom applicationAtom;	/* Atom for TK_APPLICATION. */
+-     Atom windowAtom;		/* Atom for TK_WINDOW. */
+-     Atom clipboardAtom;		/* Atom for CLIPBOARD. */
+- #if (TK_VERSION_NUMBER >= _VERSION(8,4,0))
+-     Atom utf8Atom;
+- #endif
+-     Tk_Window clipWindow;	/* Window used for clipboard ownership and to
+- 				 * retrieve selections between processes. NULL
+- 				 * means clipboard info hasn't been
+- 				 * initialized. */
+-     int clipboardActive;	/* 1 means we currently own the clipboard
+- 				 * selection, 0 means we don't. */
+-     struct TkMainInfo *clipboardAppPtr;
+- 				/* Last application that owned clipboard. */
+-     struct TkClipboardTarget *clipTargetPtr;
+- 				/* First in list of clipboard type information
+- 				 * records.  Each entry contains information
+- 				 * about the buffers for a given selection
+- 				 * target. */
+- 
+-     /*
+-      * Information used by tkSend.c only:
+-      */
+- 
+-     Tk_Window commTkwin;	/* Window used for communication
+- 				 * between interpreters during "send"
+- 				 * commands.  NULL means send info hasn't
+- 				 * been initialized yet. */
+-     Atom commProperty;		/* X's name for comm property. */
+-     Atom registryProperty;	/* X's name for property containing
+- 				 * registry of interpreter names. */
+-     Atom appNameProperty;	/* X's name for property used to hold the
+- 				 * application name on each comm window. */
+- 
+-     /*
+-      * Information used by tkXId.c only:
+-      */
+- 
+-     struct TkIdStack *idStackPtr;
+- 				/* First in list of chunks of free resource
+- 				 * identifiers, or NULL if there are no free
+- 				 * resources. */
+-     XID(*defaultAllocProc) _ANSI_ARGS_((Display *display));
+- 				/* Default resource allocator for display. */
+-     struct TkIdStack *windowStackPtr;
+- 				/* First in list of chunks of window
+- 				 * identifers that can't be reused right
+- 				 * now. */
+- #if (TK_VERSION_NUMBER < _VERSION(8,4,0))
+-     int idCleanupScheduled;	/* 1 means a call to WindowIdCleanup has
+- 				 * already been scheduled, 0 means it
+- 				 * hasn't. */
+- #else
+-     Tcl_TimerToken idCleanupScheduled;
+- 				/* If set, it means a call to WindowIdCleanup
+- 				 * has already been scheduled, 0 means it
+- 				 * hasn't. */
+- #endif
+-     /*
+-      * Information used by tkUnixWm.c and tkWinWm.c only:
+-      */
+- 
+- #if (TK_VERSION_NUMBER < _VERSION(8,4,0))
+-     int wmTracing;		/* Used to enable or disable tracing in
+- 				 * this module.  If tracing is enabled,
+- 				 * then information is printed on
+- 				 * standard output about interesting
+- 				 * interactions with the window manager. */
+- #endif
+-     struct TkWmInfo *firstWmPtr; /* Points to first top-level window. */
+-     struct TkWmInfo *foregroundWmPtr;
+- 				/* Points to the foreground window. */
+- 
+-     /*
+-      * Information maintained by tkWindow.c for use later on by tkXId.c:
+-      */
+- 
+- 
+-     int destroyCount;		/* Number of Tk_DestroyWindow operations
+- 				 * in progress. */
+-     unsigned long lastDestroyRequest;
+- 				/* Id of most recent XDestroyWindow request;
+- 				 * can re-use ids in windowStackPtr when
+- 				 * server has seen this request and event
+- 				 * queue is empty. */
+- 
+-     /*
+-      * Information used by tkVisual.c only:
+-      */
+- 
+-     TkColormap *cmapPtr;	/* First in list of all non-default colormaps
+- 				 * allocated for this display. */
+- 
+-     /*
+-      * Miscellaneous information:
+-      */
+- 
+- #ifdef TK_USE_INPUT_METHODS
+-     XIM inputMethod;		/* Input method for this display */
+- #if (TK_VERSION_NUMBER >= _VERSION(8,4,0))
+- #if TK_XIM_SPOT
+-     XFontSet inputXfs;		/* XFontSet cached for over-the-spot XIM. */
+- #endif /* TK_XIM_SPOT */
+- #endif /* TK_VERSION_NUMBER >= 8.4 */
+- #endif /* TK_USE_INPUT_METHODS */
+-     Tcl_HashTable winTable;	/* Maps from X window ids to TkWindow ptrs. */
+-     int refCount;		/* Reference count of how many Tk applications
+-                                  * are using this display. Used to clean up
+-                                  * the display when we no longer have any
+-                                  * Tk applications using it.
+-                                  */
+-     /*
+-      * The following field were all added for Tk8.3
+-      */
+-     int mouseButtonState;       /* current mouse button state for this
+-                                  * display */
+- #if (TK_VERSION_NUMBER < _VERSION(8,4,0))
+-     int warpInProgress;
+- #endif
+-     Window warpWindow;
+-     int warpX;
+-     int warpY;
+- #if (TK_VERSION_NUMBER < _VERSION(8,4,0))
+-     int useInputMethods;        /* Whether to use input methods */
+- #else
+-     /*
+-      * The following field(s) were all added for Tk8.4
+-      */
+-     long deletionEpoch;		/* Incremented by window deletions */
+-     unsigned int flags;		/* Various flag values:  these are all
+- 				 * defined in below. */
+-     TkCaret caret;		/* information about the caret for this
+- 				 * display.  This is not a pointer. */
+- #endif
+- } TkDisplay;
+- 
+- #else
+- 
+- /*
+-  * One of the following structures is maintained for each display
+-  * containing a window managed by Tk:
+-  */
+- typedef struct TkDisplayStruct {
+-     Display *display;		/* Xlib's info about display. */
+-     struct TkDisplayStruct *nextPtr; /* Next in list of all displays. */
+-     char *name;			/* Name of display (with any screen
+- 				 * identifier removed).  Malloc-ed. */
+-     Time lastEventTime;		/* Time of last event received for this
+- 				 * display. */
+- 
+-     /*
+-      * Information used primarily by tkBind.c:
+-      */
+- 
+-     int bindInfoStale;		/* Non-zero means the variables in this
+- 				 * part of the structure are potentially
+- 				 * incorrect and should be recomputed. */
+-     unsigned int modeModMask;	/* Has one bit set to indicate the modifier
+- 				 * corresponding to "mode shift".  If no
+- 				 * such modifier, than this is zero. */
+-     unsigned int metaModMask;	/* Has one bit set to indicate the modifier
+- 				 * corresponding to the "Meta" key.  If no
+- 				 * such modifier, then this is zero. */
+-     unsigned int altModMask;	/* Has one bit set to indicate the modifier
+- 				 * corresponding to the "Meta" key.  If no
+- 				 * such modifier, then this is zero. */
+-     enum {
+- 	LU_IGNORE, LU_CAPS, LU_SHIFT
+-     } lockUsage;
+-     /* Indicates how to interpret lock modifier. */
+-     int numModKeyCodes;		/* Number of entries in modKeyCodes array
+- 				 * below. */
+-     KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for
+- 				 * all of the keys that have modifiers
+- 				 * associated with them.  Malloc'ed, but
+- 				 * may be NULL. */
+- 
+-     /*
+-      * Information used by tkError.c only:
+-      */
+- 
+-     TkErrorHandler *errorPtr;
+-     /* First in list of error handlers
+- 				 * for this display.  NULL means
+- 				 * no handlers exist at present. */
+-      int deleteCount;		/* Counts # of handlers deleted since
+- 				 * last time inactive handlers were
+- 				 * garbage-collected.  When this number
+- 				 * gets big, handlers get cleaned up. */
+- 
+-     /*
+-      * Information used by tkSend.c only:
+-      */
+- 
+-     Tk_Window commTkwin;	/* Window used for communication
+- 				 * between interpreters during "send"
+- 				 * commands.  NULL means send info hasn't
+- 				 * been initialized yet. */
+-     Atom commProperty;		/* X's name for comm property. */
+-     Atom registryProperty;	/* X's name for property containing
+- 				 * registry of interpreter names. */
+-     Atom appNameProperty;	/* X's name for property used to hold the
+- 				 * application name on each comm window. */
+- 
+-     /*
+-      * Information used by tkSelect.c and tkClipboard.c only:
+-      */
+- 
+-      TkSelectionInfo *selectionInfoPtr;
+-     /* First in list of selection information
+- 				 * records.  Each entry contains information
+- 				 * about the current owner of a particular
+- 				 * selection on this display. */
+-     Atom multipleAtom;		/* Atom for MULTIPLE.  None means
+- 				 * selection stuff isn't initialized. */
+-     Atom incrAtom;		/* Atom for INCR. */
+-     Atom targetsAtom;		/* Atom for TARGETS. */
+-     Atom timestampAtom;		/* Atom for TIMESTAMP. */
+-     Atom textAtom;		/* Atom for TEXT. */
+-     Atom compoundTextAtom;	/* Atom for COMPOUND_TEXT. */
+-     Atom applicationAtom;	/* Atom for TK_APPLICATION. */
+-     Atom windowAtom;		/* Atom for TK_WINDOW. */
+-     Atom clipboardAtom;		/* Atom for CLIPBOARD. */
+- 
+-     Tk_Window clipWindow;	/* Window used for clipboard ownership and to
+- 				 * retrieve selections between processes. NULL
+- 				 * means clipboard info hasn't been
+- 				 * initialized. */
+-     int clipboardActive;	/* 1 means we currently own the clipboard
+- 				 * selection, 0 means we don't. */
+-      TkMainInfo *clipboardAppPtr;
+-      /* Last application that owned clipboard. */
+-      TkClipboardTarget *clipTargetPtr;
+-      /* First in list of clipboard type information
+- 				 * records.  Each entry contains information
+- 				 * about the buffers for a given selection
+- 				 * target. */
+- 
+-     /*
+-      * Information used by tkAtom.c only:
+-      */
+- 
+-     int atomInit;		/* 0 means stuff below hasn't been
+- 				 * initialized yet. */
+-     Tcl_HashTable nameTable;	/* Maps from names to Atom's. */
+-     Tcl_HashTable atomTable;	/* Maps from Atom's back to names. */
+- 
+-     /*
+-      * Information used by tkCursor.c only:
+-      */
+- 
+-     Font cursorFont;		/* Font to use for standard cursors.
+- 				 * None means font not loaded yet. */
+- 
+-     /*
+-      * Information used by tkGrab.c only:
+-      */
+- 
+-      TkWindow *grabWinPtr;
+-     /* Window in which the pointer is currently
+- 				 * grabbed, or NULL if none. */
+-      TkWindow *eventualGrabWinPtr;
+-     /* Value that grabWinPtr will have once the
+- 				 * grab event queue (below) has been
+- 				 * completely emptied. */
+-      TkWindow *buttonWinPtr;
+-     /* Window in which first mouse button was
+- 				 * pressed while grab was in effect, or NULL
+- 				 * if no such press in effect. */
+-      TkWindow *serverWinPtr;
+-     /* If no application contains the pointer then
+- 				 * this is NULL.  Otherwise it contains the
+- 				 * last window for which we've gotten an
+- 				 * Enter or Leave event from the server (i.e.
+- 				 * the last window known to have contained
+- 				 * the pointer).  Doesn't reflect events
+- 				 * that were synthesized in tkGrab.c. */
+-     TkGrabEvent *firstGrabEventPtr;
+-     /* First in list of enter/leave events
+- 				 * synthesized by grab code.  These events
+- 				 * must be processed in order before any other
+- 				 * events are processed.  NULL means no such
+- 				 * events. */
+-     TkGrabEvent *lastGrabEventPtr;
+-     /* Last in list of synthesized events, or NULL
+- 				 * if list is empty. */
+-     int grabFlags;		/* Miscellaneous flag values.  See definitions
+- 				 * in tkGrab.c. */
+- 
+-     /*
+-      * Information used by tkXId.c only:
+-      */
+- 
+-      TkIdStack *idStackPtr;
+-     /* First in list of chunks of free resource
+- 				 * identifiers, or NULL if there are no free
+- 				 * resources. */
+-               XID(*defaultAllocProc) _ANSI_ARGS_((Display *display));
+-     /* Default resource allocator for display. */
+-      TkIdStack *windowStackPtr;
+-     /* First in list of chunks of window
+- 				 * identifers that can't be reused right
+- 				 * now. */
+-     int idCleanupScheduled;	/* 1 means a call to WindowIdCleanup has
+- 				 * already been scheduled, 0 means it
+- 				 * hasn't. */
+- 
+-     /*
+-      * Information maintained by tkWindow.c for use later on by tkXId.c:
+-      */
+- 
+- 
+-     int destroyCount;		/* Number of Tk_DestroyWindow operations
+- 				 * in progress. */
+-     unsigned long lastDestroyRequest;
+-     /* Id of most recent XDestroyWindow request;
+- 				 * can re-use ids in windowStackPtr when
+- 				 * server has seen this request and event
+- 				 * queue is empty. */
+- 
+-     /*
+-      * Information used by tkVisual.c only:
+-      */
+- 
+-     TkColormap *cmapPtr;	/* First in list of all non-default colormaps
+- 				 * allocated for this display. */
+- 
+-     /*
+-      * Information used by tkFocus.c only:
+-      */
+- #if (TK_MAJOR_VERSION == 4)
+- 
+-      TkWindow *focusWinPtr;
+- 				/* Window that currently has the focus for
+- 				 * this display, or NULL if none. */
+-      TkWindow *implicitWinPtr;
+- 				/* If the focus arrived at a toplevel window
+- 				 * implicitly via an Enter event (rather
+- 				 * than via a FocusIn event), this points
+- 				 * to the toplevel window.  Otherwise it is
+- 				 * NULL. */
+-      TkWindow *focusOnMapPtr;
+- 				/* This points to a toplevel window that is
+- 				 * supposed to receive the X input focus as
+- 				 * soon as it is mapped (needed to handle the
+- 				 * fact that X won't allow the focus on an
+- 				 * unmapped window).  NULL means no delayed
+- 				 * focus op in progress. */
+-     int forceFocus;		/* Associated with focusOnMapPtr:  non-zero
+- 				 * means claim the focus even if some other
+- 				 * application currently has it. */
+- #else
+-      TkWindow *implicitWinPtr;
+- 				/* If the focus arrived at a toplevel window
+- 				 * implicitly via an Enter event (rather
+- 				 * than via a FocusIn event), this points
+- 				 * to the toplevel window.  Otherwise it is
+- 				 * NULL. */
+-      TkWindow *focusPtr;	/* Points to the window on this display that
+- 				 * should be receiving keyboard events.  When
+- 				 * multiple applications on the display have
+- 				 * the focus, this will refer to the
+- 				 * innermost window in the innermost
+- 				 * application.  This information isn't used
+- 				 * under Unix or Windows, but it's needed on
+- 				 * the Macintosh. */
+- #endif /* TK_MAJOR_VERSION == 4 */
+- 
+-     /*
+-      * Used by tkColor.c only:
+-      */
+- 
+-     TkStressedCmap *stressPtr;	/* First in list of colormaps that have
+- 				 * filled up, so we have to pick an
+- 				 * approximate color. */
+- 
+-     /*
+-      * Used by tkEvent.c only:
+-      */
+- 
+-      TkWindowEvent *delayedMotionPtr;
+- 				/* Points to a malloc-ed motion event
+- 				 * whose processing has been delayed in
+- 				 * the hopes that another motion event
+- 				 * will come along right away and we can
+- 				 * merge the two of them together.  NULL
+- 				 * means that there is no delayed motion
+- 				 * event. */
+-     /*
+-      * Miscellaneous information:
+-      */
+- 
+- #ifdef TK_USE_INPUT_METHODS
+-     XIM inputMethod;		/* Input method for this display */
+- #endif /* TK_USE_INPUT_METHODS */
+-     Tcl_HashTable winTable;	/* Maps from X window ids to TkWindow ptrs. */
+- #if (TK_MAJOR_VERSION > 4)
+-     int refCount;		/* Reference count of how many Tk applications
+-                                  * are using this display. Used to clean up
+-                                  * the display when we no longer have any
+-                                  * Tk applications using it.
+-                                  */
+- #endif /* TK_MAJOR_VERSION > 4 */
+- 
+- } TkDisplay;
+- 
+- #endif /* TK_VERSION_NUMBER >= _VERSION(8,1,0) */
+- 
+- 
+- struct TkWindowStruct {
+-     Display *display;
+-     TkDisplay *dispPtr;
+-     int screenNum;
+-     Visual *visual;
+-     int depth;
+-     Window window;
+-     TkWindow *childList;
+-     TkWindow *lastChildPtr;
+-     TkWindow *parentPtr;
+-     TkWindow *nextPtr;
+-     TkMainInfo *infoPtr;
+-     char *pathName;
+-     Tk_Uid nameUid;
+-     Tk_Uid classUid;
+-     XWindowChanges changes;
+-     unsigned int dirtyChanges;
+-     XSetWindowAttributes atts;
+-     unsigned long dirtyAtts;
+-     unsigned int flags;
+-     TkEventHandler *handlerList;
+- #ifdef TK_USE_INPUT_METHODS
+-     XIC inputContext;
+- #endif /* TK_USE_INPUT_METHODS */
+-     ClientData *tagPtr;
+-     int nTags;
+-     int optionLevel;
+-     TkSelHandler *selHandlerList;
+-     Tk_GeomMgr *geomMgrPtr;
+-     ClientData geomData;
+-     int reqWidth, reqHeight;
+-     int internalBorderWidth;
+-     TkWinInfo *wmInfoPtr;
+- #if (TK_MAJOR_VERSION > 4)
+-     TkClassProcs *classProcsPtr;
+-     ClientData instanceData;
+- #endif
+-     TkWindowPrivate *privatePtr;
+- };
+- 
+  #ifdef WIN32
+  /*
+--- 53,56 ----
+  #endif
+  
+  #ifdef WIN32
+  /*
diff -uNr blt2.4z/src/tclInt.h blt2.4z.tcltk86/src/tclInt.h
--- blt2.4z/src/tclInt.h	1969-12-31 19:00:00.000000000 -0500
+++ blt2.4z.tcltk86/src/tclInt.h	2013-08-20 11:44:17.000000000 -0400
@@ -0,0 +1,4837 @@
+/*
+ * tclInt.h --
+ *
+ *	Declarations of things used internally by the Tcl interpreter.
+ *
+ * Copyright (c) 1987-1993 The Regents of the University of California.
+ * Copyright (c) 1993-1997 Lucent Technologies.
+ * Copyright (c) 1994-1998 Sun Microsystems, Inc.
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ * Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
+ * Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
+ * Copyright (c) 2006-2008 by Joe Mistachkin.  All rights reserved.
+ * Copyright (c) 2008 by Miguel Sofer. All rights reserved.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TCLINT
+#define _TCLINT
+
+/*
+ * Some numerics configuration options.
+ */
+
+#undef NO_WIDE_TYPE
+#undef ACCEPT_NAN
+
+/*
+ * Common include files needed by most of the Tcl source files are included
+ * here, so that system-dependent personalizations for the include files only
+ * have to be made in once place. This results in a few extra includes, but
+ * greater modularity. The order of the three groups of #includes is
+ * important. For example, stdio.h is needed by tcl.h, and the _ANSI_ARGS_
+ * declaration in tcl.h is needed by stdlib.h in some configurations.
+ */
+
+#include "tclPort.h"
+
+#include <stdio.h>
+
+#include <ctype.h>
+#ifdef NO_STDLIB_H
+#   include "../compat/stdlib.h"
+#else
+#   include <stdlib.h>
+#endif
+#ifdef NO_STRING_H
+#include "../compat/string.h"
+#else
+#include <string.h>
+#endif
+#ifdef STDC_HEADERS
+#include <stddef.h>
+#else
+typedef int ptrdiff_t;
+#endif
+
+/*
+ * Ensure WORDS_BIGENDIAN is defined correctly:
+ * Needs to happen here in addition to configure to work with fat compiles on
+ * Darwin (where configure runs only once for multiple architectures).
+ */
+
+#ifdef HAVE_SYS_TYPES_H
+#    include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#    include <sys/param.h>
+#endif
+#ifdef BYTE_ORDER
+#    ifdef BIG_ENDIAN
+#	 if BYTE_ORDER == BIG_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	     define WORDS_BIGENDIAN 1
+#	 endif
+#    endif
+#    ifdef LITTLE_ENDIAN
+#	 if BYTE_ORDER == LITTLE_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	 endif
+#    endif
+#endif
+
+/*
+ * Used to tag functions that are only to be visible within the module being
+ * built and not outside it (where this is supported by the linker).
+ */
+
+#ifndef MODULE_SCOPE
+#   ifdef __cplusplus
+#	define MODULE_SCOPE extern "C"
+#   else
+#	define MODULE_SCOPE extern
+#   endif
+#endif
+
+/*
+ * When Tcl_WideInt and long are the same type, there's no value in
+ * having a tclWideIntType separate from the tclIntType.
+ */
+#ifdef TCL_WIDE_INT_IS_LONG
+#define NO_WIDE_TYPE
+#endif
+
+/*
+ * Macros used to cast between pointers and integers (e.g. when storing an int
+ * in ClientData), on 64-bit architectures they avoid gcc warning about "cast
+ * to/from pointer from/to integer of different size".
+ */
+
+#if !defined(INT2PTR) && !defined(PTR2INT)
+#   if defined(HAVE_INTPTR_T) || defined(intptr_t)
+#	define INT2PTR(p) ((void *)(intptr_t)(p))
+#	define PTR2INT(p) ((int)(intptr_t)(p))
+#   else
+#	define INT2PTR(p) ((void *)(p))
+#	define PTR2INT(p) ((int)(p))
+#   endif
+#endif
+#if !defined(UINT2PTR) && !defined(PTR2UINT)
+#   if defined(HAVE_UINTPTR_T) || defined(uintptr_t)
+#	define UINT2PTR(p) ((void *)(uintptr_t)(p))
+#	define PTR2UINT(p) ((unsigned int)(uintptr_t)(p))
+#   else
+#	define UINT2PTR(p) ((void *)(p))
+#	define PTR2UINT(p) ((unsigned int)(p))
+#   endif
+#endif
+
+/*
+ * The following procedures allow namespaces to be customized to support
+ * special name resolution rules for commands/variables.
+ */
+
+struct Tcl_ResolvedVarInfo;
+
+typedef Tcl_Var (Tcl_ResolveRuntimeVarProc)(Tcl_Interp *interp,
+	struct Tcl_ResolvedVarInfo *vinfoPtr);
+
+typedef void (Tcl_ResolveVarDeleteProc)(struct Tcl_ResolvedVarInfo *vinfoPtr);
+
+/*
+ * The following structure encapsulates the routines needed to resolve a
+ * variable reference at runtime. Any variable specific state will typically
+ * be appended to this structure.
+ */
+
+typedef struct Tcl_ResolvedVarInfo {
+    Tcl_ResolveRuntimeVarProc *fetchProc;
+    Tcl_ResolveVarDeleteProc *deleteProc;
+} Tcl_ResolvedVarInfo;
+
+typedef int (Tcl_ResolveCompiledVarProc)(Tcl_Interp *interp,
+	CONST84 char *name, int length, Tcl_Namespace *context,
+	Tcl_ResolvedVarInfo **rPtr);
+
+typedef int (Tcl_ResolveVarProc)(Tcl_Interp *interp, CONST84 char *name,
+	Tcl_Namespace *context, int flags, Tcl_Var *rPtr);
+
+typedef int (Tcl_ResolveCmdProc)(Tcl_Interp *interp, CONST84 char *name,
+	Tcl_Namespace *context, int flags, Tcl_Command *rPtr);
+
+typedef struct Tcl_ResolverInfo {
+    Tcl_ResolveCmdProc *cmdResProc;
+				/* Procedure handling command name
+				 * resolution. */
+    Tcl_ResolveVarProc *varResProc;
+				/* Procedure handling variable name resolution
+				 * for variables that can only be handled at
+				 * runtime. */
+    Tcl_ResolveCompiledVarProc *compiledVarResProc;
+				/* Procedure handling variable name resolution
+				 * at compile time. */
+} Tcl_ResolverInfo;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to namespaces.
+ *----------------------------------------------------------------
+ */
+
+typedef struct Tcl_Ensemble Tcl_Ensemble;
+typedef struct NamespacePathEntry NamespacePathEntry;
+
+/*
+ * Special hashtable for variables: this is just a Tcl_HashTable with an nsPtr
+ * field added at the end: in this way variables can find their namespace
+ * without having to copy a pointer in their struct: they can access it via
+ * their hPtr->tablePtr.
+ */
+
+typedef struct TclVarHashTable {
+    Tcl_HashTable table;
+    struct Namespace *nsPtr;
+} TclVarHashTable;
+
+/*
+ * This is for itcl - it likes to search our varTables directly :(
+ */
+
+#define TclVarHashFindVar(tablePtr, key) \
+    TclVarHashCreateVar((tablePtr), (key), NULL)
+
+/*
+ * Define this to reduce the amount of space that the average namespace
+ * consumes by only allocating the table of child namespaces when necessary.
+ * Defining it breaks compatibility for Tcl extensions (e.g., itcl) which
+ * reach directly into the Namespace structure.
+ */
+
+#undef BREAK_NAMESPACE_COMPAT
+
+/*
+ * The structure below defines a namespace.
+ * Note: the first five fields must match exactly the fields in a
+ * Tcl_Namespace structure (see tcl.h). If you change one, be sure to change
+ * the other.
+ */
+
+typedef struct Namespace {
+    char *name;			/* The namespace's simple (unqualified) name.
+				 * This contains no ::'s. The name of the
+				 * global namespace is "" although "::" is an
+				 * synonym. */
+    char *fullName;		/* The namespace's fully qualified name. This
+				 * starts with ::. */
+    ClientData clientData;	/* An arbitrary value associated with this
+				 * namespace. */
+    Tcl_NamespaceDeleteProc *deleteProc;
+				/* Procedure invoked when deleting the
+				 * namespace to, e.g., free clientData. */
+    struct Namespace *parentPtr;/* Points to the namespace that contains this
+				 * one. NULL if this is the global
+				 * namespace. */
+#ifndef BREAK_NAMESPACE_COMPAT
+    Tcl_HashTable childTable;	/* Contains any child namespaces. Indexed by
+				 * strings; values have type (Namespace *). */
+#else
+    Tcl_HashTable *childTablePtr;
+				/* Contains any child namespaces. Indexed by
+				 * strings; values have type (Namespace *). If
+				 * NULL, there are no children. */
+#endif
+    long nsId;			/* Unique id for the namespace. */
+    Tcl_Interp *interp;		/* The interpreter containing this
+				 * namespace. */
+    int flags;			/* OR-ed combination of the namespace status
+				 * flags NS_DYING and NS_DEAD listed below. */
+    int activationCount;	/* Number of "activations" or active call
+				 * frames for this namespace that are on the
+				 * Tcl call stack. The namespace won't be
+				 * freed until activationCount becomes zero. */
+    int refCount;		/* Count of references by namespaceName
+				 * objects. The namespace can't be freed until
+				 * refCount becomes zero. */
+    Tcl_HashTable cmdTable;	/* Contains all the commands currently
+				 * registered in the namespace. Indexed by
+				 * strings; values have type (Command *).
+				 * Commands imported by Tcl_Import have
+				 * Command structures that point (via an
+				 * ImportedCmdRef structure) to the Command
+				 * structure in the source namespace's command
+				 * table. */
+    TclVarHashTable varTable;	/* Contains all the (global) variables
+				 * currently in this namespace. Indexed by
+				 * strings; values have type (Var *). */
+    char **exportArrayPtr;	/* Points to an array of string patterns
+				 * specifying which commands are exported. A
+				 * pattern may include "string match" style
+				 * wildcard characters to specify multiple
+				 * commands; however, no namespace qualifiers
+				 * are allowed. NULL if no export patterns are
+				 * registered. */
+    int numExportPatterns;	/* Number of export patterns currently
+				 * registered using "namespace export". */
+    int maxExportPatterns;	/* Mumber of export patterns for which space
+				 * is currently allocated. */
+    int cmdRefEpoch;		/* Incremented if a newly added command
+				 * shadows a command for which this namespace
+				 * has already cached a Command* pointer; this
+				 * causes all its cached Command* pointers to
+				 * be invalidated. */
+    int resolverEpoch;		/* Incremented whenever (a) the name
+				 * resolution rules change for this namespace
+				 * or (b) a newly added command shadows a
+				 * command that is compiled to bytecodes. This
+				 * invalidates all byte codes compiled in the
+				 * namespace, causing the code to be
+				 * recompiled under the new rules.*/
+    Tcl_ResolveCmdProc *cmdResProc;
+				/* If non-null, this procedure overrides the
+				 * usual command resolution mechanism in Tcl.
+				 * This procedure is invoked within
+				 * Tcl_FindCommand to resolve all command
+				 * references within the namespace. */
+    Tcl_ResolveVarProc *varResProc;
+				/* If non-null, this procedure overrides the
+				 * usual variable resolution mechanism in Tcl.
+				 * This procedure is invoked within
+				 * Tcl_FindNamespaceVar to resolve all
+				 * variable references within the namespace at
+				 * runtime. */
+    Tcl_ResolveCompiledVarProc *compiledVarResProc;
+				/* If non-null, this procedure overrides the
+				 * usual variable resolution mechanism in Tcl.
+				 * This procedure is invoked within
+				 * LookupCompiledLocal to resolve variable
+				 * references within the namespace at compile
+				 * time. */
+    int exportLookupEpoch;	/* Incremented whenever a command is added to
+				 * a namespace, removed from a namespace or
+				 * the exports of a namespace are changed.
+				 * Allows TIP#112-driven command lists to be
+				 * validated efficiently. */
+    Tcl_Ensemble *ensembles;	/* List of structures that contain the details
+				 * of the ensembles that are implemented on
+				 * top of this namespace. */
+    Tcl_Obj *unknownHandlerPtr;	/* A script fragment to be used when command
+				 * resolution in this namespace fails. TIP
+				 * 181. */
+    int commandPathLength;	/* The length of the explicit path. */
+    NamespacePathEntry *commandPathArray;
+				/* The explicit path of the namespace as an
+				 * array. */
+    NamespacePathEntry *commandPathSourceList;
+				/* Linked list of path entries that point to
+				 * this namespace. */
+    Tcl_NamespaceDeleteProc *earlyDeleteProc;
+				/* Just like the deleteProc field (and called
+				 * with the same clientData) but called at the
+				 * start of the deletion process, so there is
+				 * a chance for code to do stuff inside the
+				 * namespace before deletion completes. */
+} Namespace;
+
+/*
+ * An entry on a namespace's command resolution path.
+ */
+
+struct NamespacePathEntry {
+    Namespace *nsPtr;		/* What does this path entry point to? If it
+				 * is NULL, this path entry points is
+				 * redundant and should be skipped. */
+    Namespace *creatorNsPtr;	/* Where does this path entry point from? This
+				 * allows for efficient invalidation of
+				 * references when the path entry's target
+				 * updates its current list of defined
+				 * commands. */
+    NamespacePathEntry *prevPtr, *nextPtr;
+				/* Linked list pointers or NULL at either end
+				 * of the list that hangs off Namespace's
+				 * commandPathSourceList field. */
+};
+
+/*
+ * Flags used to represent the status of a namespace:
+ *
+ * NS_DYING -	1 means Tcl_DeleteNamespace has been called to delete the
+ *		namespace but there are still active call frames on the Tcl
+ *		stack that refer to the namespace. When the last call frame
+ *		referring to it has been popped, it's variables and command
+ *		will be destroyed and it will be marked "dead" (NS_DEAD). The
+ *		namespace can no longer be looked up by name.
+ * NS_DEAD -	1 means Tcl_DeleteNamespace has been called to delete the
+ *		namespace and no call frames still refer to it. Its variables
+ *		and command have already been destroyed. This bit allows the
+ *		namespace resolution code to recognize that the namespace is
+ *		"deleted". When the last namespaceName object in any byte code
+ *		unit that refers to the namespace has been freed (i.e., when
+ *		the namespace's refCount is 0), the namespace's storage will
+ *		be freed.
+ * NS_KILLED -	1 means that TclTeardownNamespace has already been called on
+ *		this namespace and it should not be called again [Bug 1355942]
+ * NS_SUPPRESS_COMPILATION -
+ *		Marks the commands in this namespace for not being compiled,
+ *		forcing them to be looked up every time.
+ */
+
+#define NS_DYING	0x01
+#define NS_DEAD		0x02
+#define NS_KILLED	0x04
+#define NS_SUPPRESS_COMPILATION	0x08
+
+/*
+ * Flags passed to TclGetNamespaceForQualName:
+ *
+ * TCL_GLOBAL_ONLY		- (see tcl.h) Look only in the global ns.
+ * TCL_NAMESPACE_ONLY		- (see tcl.h) Look only in the context ns.
+ * TCL_CREATE_NS_IF_UNKNOWN	- Create unknown namespaces.
+ * TCL_FIND_ONLY_NS		- The name sought is a namespace name.
+ */
+
+#define TCL_CREATE_NS_IF_UNKNOWN	0x800
+#define TCL_FIND_ONLY_NS		0x1000
+
+/*
+ * The data cached in an ensemble subcommand's Tcl_Obj rep (reference in
+ * otherValuePtr field). This structure is not shared between Tcl_Objs
+ * referring to the same subcommand, even where one is a duplicate of another.
+ */
+
+typedef struct {
+    Namespace *nsPtr;		/* The namespace backing the ensemble which
+				 * this is a subcommand of. */
+    int epoch;			/* Used to confirm when the data in this
+				 * really structure matches up with the
+				 * ensemble. */
+    Tcl_Command token;		/* Reference to the comamnd for which this
+				 * structure is a cache of the resolution. */
+    char *fullSubcmdName;	/* The full (local) name of the subcommand,
+				 * allocated with ckalloc(). */
+    Tcl_Obj *realPrefixObj;	/* Object containing the prefix words of the
+				 * command that implements this ensemble
+				 * subcommand. */
+} EnsembleCmdRep;
+
+/*
+ * The client data for an ensemble command. This consists of the table of
+ * commands that are actually exported by the namespace, and an epoch counter
+ * that, combined with the exportLookupEpoch field of the namespace structure,
+ * defines whether the table contains valid data or will need to be recomputed
+ * next time the ensemble command is called.
+ */
+
+typedef struct EnsembleConfig {
+    Namespace *nsPtr;		/* The namspace backing this ensemble up. */
+    Tcl_Command token;		/* The token for the command that provides
+				 * ensemble support for the namespace, or NULL
+				 * if the command has been deleted (or never
+				 * existed; the global namespace never has an
+				 * ensemble command.) */
+    int epoch;			/* The epoch at which this ensemble's table of
+				 * exported commands is valid. */
+    char **subcommandArrayPtr;	/* Array of ensemble subcommand names. At all
+				 * consistent points, this will have the same
+				 * number of entries as there are entries in
+				 * the subcommandTable hash. */
+    Tcl_HashTable subcommandTable;
+				/* Hash table of ensemble subcommand names,
+				 * which are its keys so this also provides
+				 * the storage management for those subcommand
+				 * names. The contents of the entry values are
+				 * object version the prefix lists to use when
+				 * substituting for the command/subcommand to
+				 * build the ensemble implementation command.
+				 * Has to be stored here as well as in
+				 * subcommandDict because that field is NULL
+				 * when we are deriving the ensemble from the
+				 * namespace exports list. FUTURE WORK: use
+				 * object hash table here. */
+    struct EnsembleConfig *next;/* The next ensemble in the linked list of
+				 * ensembles associated with a namespace. If
+				 * this field points to this ensemble, the
+				 * structure has already been unlinked from
+				 * all lists, and cannot be found by scanning
+				 * the list from the namespace's ensemble
+				 * field. */
+    int flags;			/* ORed combo of TCL_ENSEMBLE_PREFIX,
+				 * ENSEMBLE_DEAD and ENSEMBLE_COMPILE. */
+
+    /* OBJECT FIELDS FOR ENSEMBLE CONFIGURATION */
+
+    Tcl_Obj *subcommandDict;	/* Dictionary providing mapping from
+				 * subcommands to their implementing command
+				 * prefixes, or NULL if we are to build the
+				 * map automatically from the namespace
+				 * exports. */
+    Tcl_Obj *subcmdList;	/* List of commands that this ensemble
+				 * actually provides, and whose implementation
+				 * will be built using the subcommandDict (if
+				 * present and defined) and by simple mapping
+				 * to the namespace otherwise. If NULL,
+				 * indicates that we are using the (dynamic)
+				 * list of currently exported commands. */
+    Tcl_Obj *unknownHandler;	/* Script prefix used to handle the case when
+				 * no match is found (according to the rule
+				 * defined by flag bit TCL_ENSEMBLE_PREFIX) or
+				 * NULL to use the default error-generating
+				 * behaviour. The script execution gets all
+				 * the arguments to the ensemble command
+				 * (including objv[0]) and will have the
+				 * results passed directly back to the caller
+				 * (including the error code) unless the code
+				 * is TCL_CONTINUE in which case the
+				 * subcommand will be reparsed by the ensemble
+				 * core, presumably because the ensemble
+				 * itself has been updated. */
+    Tcl_Obj *parameterList;	/* List of ensemble parameter names. */
+    int numParameters;		/* Cached number of parameters. This is either
+				 * 0 (if the parameterList field is NULL) or
+				 * the length of the list in the parameterList
+				 * field. */
+} EnsembleConfig;
+
+/*
+ * Various bits for the EnsembleConfig.flags field.
+ */
+
+#define ENSEMBLE_DEAD	0x1	/* Flag value to say that the ensemble is dead
+				 * and on its way out. */
+#define ENSEMBLE_COMPILE 0x4	/* Flag to enable bytecode compilation of an
+				 * ensemble. */
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to variables. These are used primarily in tclVar.c
+ *----------------------------------------------------------------
+ */
+
+/*
+ * The following structure defines a variable trace, which is used to invoke a
+ * specific C procedure whenever certain operations are performed on a
+ * variable.
+ */
+
+typedef struct VarTrace {
+    Tcl_VarTraceProc *traceProc;/* Procedure to call when operations given by
+				 * flags are performed on variable. */
+    ClientData clientData;	/* Argument to pass to proc. */
+    int flags;			/* What events the trace procedure is
+				 * interested in: OR-ed combination of
+				 * TCL_TRACE_READS, TCL_TRACE_WRITES,
+				 * TCL_TRACE_UNSETS and TCL_TRACE_ARRAY. */
+    struct VarTrace *nextPtr;	/* Next in list of traces associated with a
+				 * particular variable. */
+} VarTrace;
+
+/*
+ * The following structure defines a command trace, which is used to invoke a
+ * specific C procedure whenever certain operations are performed on a
+ * command.
+ */
+
+typedef struct CommandTrace {
+    Tcl_CommandTraceProc *traceProc;
+				/* Procedure to call when operations given by
+				 * flags are performed on command. */
+    ClientData clientData;	/* Argument to pass to proc. */
+    int flags;			/* What events the trace procedure is
+				 * interested in: OR-ed combination of
+				 * TCL_TRACE_RENAME, TCL_TRACE_DELETE. */
+    struct CommandTrace *nextPtr;
+				/* Next in list of traces associated with a
+				 * particular command. */
+    int refCount;		/* Used to ensure this structure is not
+				 * deleted too early. Keeps track of how many
+				 * pieces of code have a pointer to this
+				 * structure. */
+} CommandTrace;
+
+/*
+ * When a command trace is active (i.e. its associated procedure is executing)
+ * one of the following structures is linked into a list associated with the
+ * command's interpreter. The information in the structure is needed in order
+ * for Tcl to behave reasonably if traces are deleted while traces are active.
+ */
+
+typedef struct ActiveCommandTrace {
+    struct Command *cmdPtr;	/* Command that's being traced. */
+    struct ActiveCommandTrace *nextPtr;
+				/* Next in list of all active command traces
+				 * for the interpreter, or NULL if no more. */
+    CommandTrace *nextTracePtr;	/* Next trace to check after current trace
+				 * procedure returns; if this trace gets
+				 * deleted, must update pointer to avoid using
+				 * free'd memory. */
+    int reverseScan;		/* Boolean set true when traces are scanning
+				 * in reverse order. */
+} ActiveCommandTrace;
+
+/*
+ * When a variable trace is active (i.e. its associated procedure is
+ * executing) one of the following structures is linked into a list associated
+ * with the variable's interpreter. The information in the structure is needed
+ * in order for Tcl to behave reasonably if traces are deleted while traces
+ * are active.
+ */
+
+typedef struct ActiveVarTrace {
+    struct Var *varPtr;		/* Variable that's being traced. */
+    struct ActiveVarTrace *nextPtr;
+				/* Next in list of all active variable traces
+				 * for the interpreter, or NULL if no more. */
+    VarTrace *nextTracePtr;	/* Next trace to check after current trace
+				 * procedure returns; if this trace gets
+				 * deleted, must update pointer to avoid using
+				 * free'd memory. */
+} ActiveVarTrace;
+
+/*
+ * The following structure describes an enumerative search in progress on an
+ * array variable; this are invoked with options to the "array" command.
+ */
+
+typedef struct ArraySearch {
+    int id;			/* Integer id used to distinguish among
+				 * multiple concurrent searches for the same
+				 * array. */
+    struct Var *varPtr;		/* Pointer to array variable that's being
+				 * searched. */
+    Tcl_HashSearch search;	/* Info kept by the hash module about progress
+				 * through the array. */
+    Tcl_HashEntry *nextEntry;	/* Non-null means this is the next element to
+				 * be enumerated (it's leftover from the
+				 * Tcl_FirstHashEntry call or from an "array
+				 * anymore" command). NULL means must call
+				 * Tcl_NextHashEntry to get value to
+				 * return. */
+    struct ArraySearch *nextPtr;/* Next in list of all active searches for
+				 * this variable, or NULL if this is the last
+				 * one. */
+} ArraySearch;
+
+/*
+ * The structure below defines a variable, which associates a string name with
+ * a Tcl_Obj value. These structures are kept in procedure call frames (for
+ * local variables recognized by the compiler) or in the heap (for global
+ * variables and any variable not known to the compiler). For each Var
+ * structure in the heap, a hash table entry holds the variable name and a
+ * pointer to the Var structure.
+ */
+
+typedef struct Var {
+    int flags;			/* Miscellaneous bits of information about
+				 * variable. See below for definitions. */
+    union {
+	Tcl_Obj *objPtr;	/* The variable's object value. Used for
+				 * scalar variables and array elements. */
+	TclVarHashTable *tablePtr;/* For array variables, this points to
+				 * information about the hash table used to
+				 * implement the associative array. Points to
+				 * ckalloc-ed data. */
+	struct Var *linkPtr;	/* If this is a global variable being referred
+				 * to in a procedure, or a variable created by
+				 * "upvar", this field points to the
+				 * referenced variable's Var struct. */
+    } value;
+} Var;
+
+typedef struct VarInHash {
+    Var var;
+    int refCount;		/* Counts number of active uses of this
+				 * variable: 1 for the entry in the hash
+				 * table, 1 for each additional variable whose
+				 * linkPtr points here, 1 for each nested
+				 * trace active on variable, and 1 if the
+				 * variable is a namespace variable. This
+				 * record can't be deleted until refCount
+				 * becomes 0. */
+    Tcl_HashEntry entry;	/* The hash table entry that refers to this
+				 * variable. This is used to find the name of
+				 * the variable and to delete it from its
+				 * hashtable if it is no longer needed. It
+				 * also holds the variable's name. */
+} VarInHash;
+
+/*
+ * Flag bits for variables. The first two (VAR_ARRAY and VAR_LINK) are
+ * mutually exclusive and give the "type" of the variable. If none is set,
+ * this is a scalar variable.
+ *
+ * VAR_ARRAY -			1 means this is an array variable rather than
+ *				a scalar variable or link. The "tablePtr"
+ *				field points to the array's hashtable for its
+ *				elements.
+ * VAR_LINK -			1 means this Var structure contains a pointer
+ *				to another Var structure that either has the
+ *				real value or is itself another VAR_LINK
+ *				pointer. Variables like this come about
+ *				through "upvar" and "global" commands, or
+ *				through references to variables in enclosing
+ *				namespaces.
+ *
+ * Flags that indicate the type and status of storage; none is set for
+ * compiled local variables (Var structs).
+ *
+ * VAR_IN_HASHTABLE -		1 means this variable is in a hashtable and
+ *				the Var structure is malloced. 0 if it is a
+ *				local variable that was assigned a slot in a
+ *				procedure frame by the compiler so the Var
+ *				storage is part of the call frame.
+ * VAR_DEAD_HASH		1 means that this var's entry in the hashtable
+ *				has already been deleted.
+ * VAR_ARRAY_ELEMENT -		1 means that this variable is an array
+ *				element, so it is not legal for it to be an
+ *				array itself (the VAR_ARRAY flag had better
+ *				not be set).
+ * VAR_NAMESPACE_VAR -		1 means that this variable was declared as a
+ *				namespace variable. This flag ensures it
+ *				persists until its namespace is destroyed or
+ *				until the variable is unset; it will persist
+ *				even if it has not been initialized and is
+ *				marked undefined. The variable's refCount is
+ *				incremented to reflect the "reference" from
+ *				its namespace.
+ *
+ * Flag values relating to the variable's trace and search status.
+ *
+ * VAR_TRACED_READ
+ * VAR_TRACED_WRITE
+ * VAR_TRACED_UNSET
+ * VAR_TRACED_ARRAY
+ * VAR_TRACE_ACTIVE -		1 means that trace processing is currently
+ *				underway for a read or write access, so new
+ *				read or write accesses should not cause trace
+ *				procedures to be called and the variable can't
+ *				be deleted.
+ * VAR_SEARCH_ACTIVE
+ *
+ * The following additional flags are used with the CompiledLocal type defined
+ * below:
+ *
+ * VAR_ARGUMENT -		1 means that this variable holds a procedure
+ *				argument.
+ * VAR_TEMPORARY -		1 if the local variable is an anonymous
+ *				temporary variable. Temporaries have a NULL
+ *				name.
+ * VAR_RESOLVED -		1 if name resolution has been done for this
+ *				variable.
+ * VAR_IS_ARGS			1 if this variable is the last argument and is
+ *				named "args".
+ */
+
+/*
+ * FLAGS RENUMBERED: everything breaks already, make things simpler.
+ *
+ * IMPORTANT: skip the values 0x10, 0x20, 0x40, 0x800 corresponding to
+ * TCL_TRACE_(READS/WRITES/UNSETS/ARRAY): makes code simpler in tclTrace.c
+ *
+ * Keep the flag values for VAR_ARGUMENT and VAR_TEMPORARY so that old values
+ * in precompiled scripts keep working.
+ */
+
+/* Type of value (0 is scalar) */
+#define VAR_ARRAY		0x1
+#define VAR_LINK		0x2
+
+/* Type of storage (0 is compiled local) */
+#define VAR_IN_HASHTABLE	0x4
+#define VAR_DEAD_HASH		0x8
+#define VAR_ARRAY_ELEMENT	0x1000
+#define VAR_NAMESPACE_VAR	0x80	/* KEEP OLD VALUE for Itcl */
+
+#define VAR_ALL_HASH \
+	(VAR_IN_HASHTABLE|VAR_DEAD_HASH|VAR_NAMESPACE_VAR|VAR_ARRAY_ELEMENT)
+
+/* Trace and search state. */
+
+#define VAR_TRACED_READ		0x10	/* TCL_TRACE_READS */
+#define VAR_TRACED_WRITE	0x20	/* TCL_TRACE_WRITES */
+#define VAR_TRACED_UNSET	0x40	/* TCL_TRACE_UNSETS */
+#define VAR_TRACED_ARRAY	0x800	/* TCL_TRACE_ARRAY */
+#define VAR_TRACE_ACTIVE	0x2000
+#define VAR_SEARCH_ACTIVE	0x4000
+#define VAR_ALL_TRACES \
+	(VAR_TRACED_READ|VAR_TRACED_WRITE|VAR_TRACED_ARRAY|VAR_TRACED_UNSET)
+
+/* Special handling on initialisation (only CompiledLocal). */
+#define VAR_ARGUMENT		0x100	/* KEEP OLD VALUE! See tclProc.c */
+#define VAR_TEMPORARY		0x200	/* KEEP OLD VALUE! See tclProc.c */
+#define VAR_IS_ARGS		0x400
+#define VAR_RESOLVED		0x8000
+
+/*
+ * Macros to ensure that various flag bits are set properly for variables.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclSetVarScalar(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarArray(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarLink(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarArrayElement(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarUndefined(Var *varPtr);
+ * MODULE_SCOPE void	TclClearVarUndefined(Var *varPtr);
+ */
+
+#define TclSetVarScalar(varPtr) \
+    (varPtr)->flags &= ~(VAR_ARRAY|VAR_LINK)
+
+#define TclSetVarArray(varPtr) \
+    (varPtr)->flags = ((varPtr)->flags & ~VAR_LINK) | VAR_ARRAY
+
+#define TclSetVarLink(varPtr) \
+    (varPtr)->flags = ((varPtr)->flags & ~VAR_ARRAY) | VAR_LINK
+
+#define TclSetVarArrayElement(varPtr) \
+    (varPtr)->flags = ((varPtr)->flags & ~VAR_ARRAY) | VAR_ARRAY_ELEMENT
+
+#define TclSetVarUndefined(varPtr) \
+    (varPtr)->flags &= ~(VAR_ARRAY|VAR_LINK);\
+    (varPtr)->value.objPtr = NULL
+
+#define TclClearVarUndefined(varPtr)
+
+#define TclSetVarTraceActive(varPtr) \
+    (varPtr)->flags |= VAR_TRACE_ACTIVE
+
+#define TclClearVarTraceActive(varPtr) \
+    (varPtr)->flags &= ~VAR_TRACE_ACTIVE
+
+#define TclSetVarNamespaceVar(varPtr) \
+    if (!TclIsVarNamespaceVar(varPtr)) {\
+	(varPtr)->flags |= VAR_NAMESPACE_VAR;\
+	if (TclIsVarInHash(varPtr)) {\
+	    ((VarInHash *)(varPtr))->refCount++;\
+	}\
+    }
+
+#define TclClearVarNamespaceVar(varPtr) \
+    if (TclIsVarNamespaceVar(varPtr)) {\
+	(varPtr)->flags &= ~VAR_NAMESPACE_VAR;\
+	if (TclIsVarInHash(varPtr)) {\
+	    ((VarInHash *)(varPtr))->refCount--;\
+	}\
+    }
+
+/*
+ * Macros to read various flag bits of variables.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE int	TclIsVarScalar(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarLink(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarArray(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarUndefined(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarArrayElement(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarTemporary(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarArgument(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarResolved(Var *varPtr);
+ */
+
+#define TclIsVarScalar(varPtr) \
+    !((varPtr)->flags & (VAR_ARRAY|VAR_LINK))
+
+#define TclIsVarLink(varPtr) \
+    ((varPtr)->flags & VAR_LINK)
+
+#define TclIsVarArray(varPtr) \
+    ((varPtr)->flags & VAR_ARRAY)
+
+#define TclIsVarUndefined(varPtr) \
+    ((varPtr)->value.objPtr == NULL)
+
+#define TclIsVarArrayElement(varPtr) \
+    ((varPtr)->flags & VAR_ARRAY_ELEMENT)
+
+#define TclIsVarNamespaceVar(varPtr) \
+    ((varPtr)->flags & VAR_NAMESPACE_VAR)
+
+#define TclIsVarTemporary(varPtr) \
+    ((varPtr)->flags & VAR_TEMPORARY)
+
+#define TclIsVarArgument(varPtr) \
+    ((varPtr)->flags & VAR_ARGUMENT)
+
+#define TclIsVarResolved(varPtr) \
+    ((varPtr)->flags & VAR_RESOLVED)
+
+#define TclIsVarTraceActive(varPtr) \
+    ((varPtr)->flags & VAR_TRACE_ACTIVE)
+
+#define TclIsVarTraced(varPtr) \
+    ((varPtr)->flags & VAR_ALL_TRACES)
+
+#define TclIsVarInHash(varPtr) \
+    ((varPtr)->flags & VAR_IN_HASHTABLE)
+
+#define TclIsVarDeadHash(varPtr) \
+    ((varPtr)->flags & VAR_DEAD_HASH)
+
+#define TclGetVarNsPtr(varPtr) \
+    (TclIsVarInHash(varPtr) \
+	? ((TclVarHashTable *) ((((VarInHash *) (varPtr))->entry.tablePtr)))->nsPtr \
+	: NULL)
+
+#define VarHashRefCount(varPtr) \
+    ((VarInHash *) (varPtr))->refCount
+
+/*
+ * Macros for direct variable access by TEBC.
+ */
+
+#define TclIsVarDirectReadable(varPtr) \
+    (   !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_READ)) \
+    &&  (varPtr)->value.objPtr)
+
+#define TclIsVarDirectWritable(varPtr) \
+    !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_WRITE|VAR_DEAD_HASH))
+
+#define TclIsVarDirectUnsettable(varPtr) \
+    !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_READ|VAR_TRACED_WRITE|VAR_TRACED_UNSET|VAR_DEAD_HASH))
+
+#define TclIsVarDirectModifyable(varPtr) \
+    (   !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_READ|VAR_TRACED_WRITE)) \
+    &&  (varPtr)->value.objPtr)
+
+#define TclIsVarDirectReadable2(varPtr, arrayPtr) \
+    (TclIsVarDirectReadable(varPtr) &&\
+	(!(arrayPtr) || !((arrayPtr)->flags & VAR_TRACED_READ)))
+
+#define TclIsVarDirectWritable2(varPtr, arrayPtr) \
+    (TclIsVarDirectWritable(varPtr) &&\
+	(!(arrayPtr) || !((arrayPtr)->flags & VAR_TRACED_WRITE)))
+
+#define TclIsVarDirectModifyable2(varPtr, arrayPtr) \
+    (TclIsVarDirectModifyable(varPtr) &&\
+	(!(arrayPtr) || !((arrayPtr)->flags & (VAR_TRACED_READ|VAR_TRACED_WRITE))))
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to procedures. These are used primarily in
+ * tclProc.c, tclCompile.c, and tclExecute.c.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * Forward declaration to prevent an error when the forward reference to
+ * Command is encountered in the Proc and ImportRef types declared below.
+ */
+
+struct Command;
+
+/*
+ * The variable-length structure below describes a local variable of a
+ * procedure that was recognized by the compiler. These variables have a name,
+ * an element in the array of compiler-assigned local variables in the
+ * procedure's call frame, and various other items of information. If the
+ * local variable is a formal argument, it may also have a default value. The
+ * compiler can't recognize local variables whose names are expressions (these
+ * names are only known at runtime when the expressions are evaluated) or
+ * local variables that are created as a result of an "upvar" or "uplevel"
+ * command. These other local variables are kept separately in a hash table in
+ * the call frame.
+ */
+
+typedef struct CompiledLocal {
+    struct CompiledLocal *nextPtr;
+				/* Next compiler-recognized local variable for
+				 * this procedure, or NULL if this is the last
+				 * local. */
+    int nameLength;		/* The number of characters in local
+				 * variable's name. Used to speed up variable
+				 * lookups. */
+    int frameIndex;		/* Index in the array of compiler-assigned
+				 * variables in the procedure call frame. */
+    int flags;			/* Flag bits for the local variable. Same as
+				 * the flags for the Var structure above,
+				 * although only VAR_ARGUMENT, VAR_TEMPORARY,
+				 * and VAR_RESOLVED make sense. */
+    Tcl_Obj *defValuePtr;	/* Pointer to the default value of an
+				 * argument, if any. NULL if not an argument
+				 * or, if an argument, no default value. */
+    Tcl_ResolvedVarInfo *resolveInfo;
+				/* Customized variable resolution info
+				 * supplied by the Tcl_ResolveCompiledVarProc
+				 * associated with a namespace. Each variable
+				 * is marked by a unique ClientData tag during
+				 * compilation, and that same tag is used to
+				 * find the variable at runtime. */
+    char name[1];		/* Name of the local variable starts here. If
+				 * the name is NULL, this will just be '\0'.
+				 * The actual size of this field will be large
+				 * enough to hold the name. MUST BE THE LAST
+				 * FIELD IN THE STRUCTURE! */
+} CompiledLocal;
+
+/*
+ * The structure below defines a command procedure, which consists of a
+ * collection of Tcl commands plus information about arguments and other local
+ * variables recognized at compile time.
+ */
+
+typedef struct Proc {
+    struct Interp *iPtr;	/* Interpreter for which this command is
+				 * defined. */
+    int refCount;		/* Reference count: 1 if still present in
+				 * command table plus 1 for each call to the
+				 * procedure that is currently active. This
+				 * structure can be freed when refCount
+				 * becomes zero. */
+    struct Command *cmdPtr;	/* Points to the Command structure for this
+				 * procedure. This is used to get the
+				 * namespace in which to execute the
+				 * procedure. */
+    Tcl_Obj *bodyPtr;		/* Points to the ByteCode object for
+				 * procedure's body command. */
+    int numArgs;		/* Number of formal parameters. */
+    int numCompiledLocals;	/* Count of local variables recognized by the
+				 * compiler including arguments and
+				 * temporaries. */
+    CompiledLocal *firstLocalPtr;
+				/* Pointer to first of the procedure's
+				 * compiler-allocated local variables, or NULL
+				 * if none. The first numArgs entries in this
+				 * list describe the procedure's formal
+				 * arguments. */
+    CompiledLocal *lastLocalPtr;/* Pointer to the last allocated local
+				 * variable or NULL if none. This has frame
+				 * index (numCompiledLocals-1). */
+} Proc;
+
+/*
+ * The type of functions called to process errors found during the execution
+ * of a procedure (or lambda term or ...).
+ */
+
+typedef void (ProcErrorProc)(Tcl_Interp *interp, Tcl_Obj *procNameObj);
+
+/*
+ * The structure below defines a command trace. This is used to allow Tcl
+ * clients to find out whenever a command is about to be executed.
+ */
+
+typedef struct Trace {
+    int level;			/* Only trace commands at nesting level less
+				 * than or equal to this. */
+    Tcl_CmdObjTraceProc *proc;	/* Procedure to call to trace command. */
+    ClientData clientData;	/* Arbitrary value to pass to proc. */
+    struct Trace *nextPtr;	/* Next in list of traces for this interp. */
+    int flags;			/* Flags governing the trace - see
+				 * Tcl_CreateObjTrace for details. */
+    Tcl_CmdObjTraceDeleteProc *delProc;
+				/* Procedure to call when trace is deleted. */
+} Trace;
+
+/*
+ * When an interpreter trace is active (i.e. its associated procedure is
+ * executing), one of the following structures is linked into a list
+ * associated with the interpreter. The information in the structure is needed
+ * in order for Tcl to behave reasonably if traces are deleted while traces
+ * are active.
+ */
+
+typedef struct ActiveInterpTrace {
+    struct ActiveInterpTrace *nextPtr;
+				/* Next in list of all active command traces
+				 * for the interpreter, or NULL if no more. */
+    Trace *nextTracePtr;	/* Next trace to check after current trace
+				 * procedure returns; if this trace gets
+				 * deleted, must update pointer to avoid using
+				 * free'd memory. */
+    int reverseScan;		/* Boolean set true when traces are scanning
+				 * in reverse order. */
+} ActiveInterpTrace;
+
+/*
+ * Flag values designating types of execution traces. See tclTrace.c for
+ * related flag values.
+ *
+ * TCL_TRACE_ENTER_EXEC		- triggers enter/enterstep traces.
+ * 				- passed to Tcl_CreateObjTrace to set up
+ *				  "enterstep" traces.
+ * TCL_TRACE_LEAVE_EXEC		- triggers leave/leavestep traces.
+ * 				- passed to Tcl_CreateObjTrace to set up
+ *				  "leavestep" traces.
+ */
+
+#define TCL_TRACE_ENTER_EXEC	1
+#define TCL_TRACE_LEAVE_EXEC	2
+
+/*
+ * The structure below defines an entry in the assocData hash table which is
+ * associated with an interpreter. The entry contains a pointer to a function
+ * to call when the interpreter is deleted, and a pointer to a user-defined
+ * piece of data.
+ */
+
+typedef struct AssocData {
+    Tcl_InterpDeleteProc *proc;	/* Proc to call when deleting. */
+    ClientData clientData;	/* Value to pass to proc. */
+} AssocData;
+
+/*
+ * The structure below defines a call frame. A call frame defines a naming
+ * context for a procedure call: its local naming scope (for local variables)
+ * and its global naming scope (a namespace, perhaps the global :: namespace).
+ * A call frame can also define the naming context for a namespace eval or
+ * namespace inscope command: the namespace in which the command's code should
+ * execute. The Tcl_CallFrame structures exist only while procedures or
+ * namespace eval/inscope's are being executed, and provide a kind of Tcl call
+ * stack.
+ *
+ * WARNING!! The structure definition must be kept consistent with the
+ * Tcl_CallFrame structure in tcl.h. If you change one, change the other.
+ */
+
+/*
+ * Will be grown to contain: pointers to the varnames (allocated at the end),
+ * plus the init values for each variable (suitable to be memcopied on init)
+ */
+
+typedef struct LocalCache {
+    int refCount;
+    int numVars;
+    Tcl_Obj *varName0;
+} LocalCache;
+
+#define localName(framePtr, i) \
+    ((&((framePtr)->localCachePtr->varName0))[(i)])
+
+MODULE_SCOPE void	TclFreeLocalCache(Tcl_Interp *interp,
+			    LocalCache *localCachePtr);
+
+typedef struct CallFrame {
+    Namespace *nsPtr;		/* Points to the namespace used to resolve
+				 * commands and global variables. */
+    int isProcCallFrame;	/* If 0, the frame was pushed to execute a
+				 * namespace command and var references are
+				 * treated as references to namespace vars;
+				 * varTablePtr and compiledLocals are ignored.
+				 * If FRAME_IS_PROC is set, the frame was
+				 * pushed to execute a Tcl procedure and may
+				 * have local vars. */
+    int objc;			/* This and objv below describe the arguments
+				 * for this procedure call. */
+    Tcl_Obj *const *objv;	/* Array of argument objects. */
+    struct CallFrame *callerPtr;
+				/* Value of interp->framePtr when this
+				 * procedure was invoked (i.e. next higher in
+				 * stack of all active procedures). */
+    struct CallFrame *callerVarPtr;
+				/* Value of interp->varFramePtr when this
+				 * procedure was invoked (i.e. determines
+				 * variable scoping within caller). Same as
+				 * callerPtr unless an "uplevel" command or
+				 * something equivalent was active in the
+				 * caller). */
+    int level;			/* Level of this procedure, for "uplevel"
+				 * purposes (i.e. corresponds to nesting of
+				 * callerVarPtr's, not callerPtr's). 1 for
+				 * outermost procedure, 0 for top-level. */
+    Proc *procPtr;		/* Points to the structure defining the called
+				 * procedure. Used to get information such as
+				 * the number of compiled local variables
+				 * (local variables assigned entries ["slots"]
+				 * in the compiledLocals array below). */
+    TclVarHashTable *varTablePtr;
+				/* Hash table containing local variables not
+				 * recognized by the compiler, or created at
+				 * execution time through, e.g., upvar.
+				 * Initially NULL and created if needed. */
+    int numCompiledLocals;	/* Count of local variables recognized by the
+				 * compiler including arguments. */
+    Var *compiledLocals;	/* Points to the array of local variables
+				 * recognized by the compiler. The compiler
+				 * emits code that refers to these variables
+				 * using an index into this array. */
+    ClientData clientData;	/* Pointer to some context that is used by
+				 * object systems. The meaning of the contents
+				 * of this field is defined by the code that
+				 * sets it, and it should only ever be set by
+				 * the code that is pushing the frame. In that
+				 * case, the code that sets it should also
+				 * have some means of discovering what the
+				 * meaning of the value is, which we do not
+				 * specify. */
+    LocalCache *localCachePtr;
+    struct NRE_callback *tailcallPtr;
+				/* NULL if no tailcall is scheduled */
+} CallFrame;
+
+#define FRAME_IS_PROC	0x1
+#define FRAME_IS_LAMBDA 0x2
+#define FRAME_IS_METHOD	0x4	/* The frame is a method body, and the frame's
+				 * clientData field contains a CallContext
+				 * reference. Part of TIP#257. */
+#define FRAME_IS_OO_DEFINE 0x8	/* The frame is part of the inside workings of
+				 * the [oo::define] command; the clientData
+				 * field contains an Object reference that has
+				 * been confirmed to refer to a class. Part of
+				 * TIP#257. */
+
+/*
+ * TIP #280
+ * The structure below defines a command frame. A command frame provides
+ * location information for all commands executing a tcl script (source, eval,
+ * uplevel, procedure bodies, ...). The runtime structure essentially contains
+ * the stack trace as it would be if the currently executing command were to
+ * throw an error.
+ *
+ * For commands where it makes sense it refers to the associated CallFrame as
+ * well.
+ *
+ * The structures are chained in a single list, with the top of the stack
+ * anchored in the Interp structure.
+ *
+ * Instances can be allocated on the C stack, or the heap, the former making
+ * cleanup a bit simpler.
+ */
+
+typedef struct CmdFrame {
+    /*
+     * General data. Always available.
+     */
+
+    int type;			/* Values see below. */
+    int level;			/* Number of frames in stack, prevent O(n)
+				 * scan of list. */
+    int *line;			/* Lines the words of the command start on. */
+    int nline;
+    CallFrame *framePtr;	/* Procedure activation record, may be
+				 * NULL. */
+    struct CmdFrame *nextPtr;	/* Link to calling frame. */
+    /*
+     * Data needed for Eval vs TEBC
+     *
+     * EXECUTION CONTEXTS and usage of CmdFrame
+     *
+     * Field	  TEBC		  EvalEx	  EvalObjEx
+     * =======	  ====		  ======	  =========
+     * level	  yes		  yes		  yes
+     * type	  BC/PREBC	  SRC/EVAL	  EVAL_LIST
+     * line0	  yes		  yes		  yes
+     * framePtr	  yes		  yes		  yes
+     * =======	  ====		  ======	  =========
+     *
+     * =======	  ====		  ======	  ========= union data
+     * line1	  -		  yes		  -
+     * line3	  -		  yes		  -
+     * path	  -		  yes		  -
+     * -------	  ----		  ------	  ---------
+     * codePtr	  yes		  -		  -
+     * pc	  yes		  -		  -
+     * =======	  ====		  ======	  =========
+     *
+     * =======	  ====		  ======	  ========= | union cmd
+     * listPtr	  -		  -		  yes	    |
+     * -------	  ----		  ------	  --------- |
+     * cmd	  yes		  yes		  -	    |
+     * cmdlen	  yes		  yes		  -	    |
+     * -------	  ----		  ------	  --------- |
+     */
+
+    union {
+	struct {
+	    Tcl_Obj *path;	/* Path of the sourced file the command is
+				 * in. */
+	} eval;
+	struct {
+	    const void *codePtr;/* Byte code currently executed... */
+	    const char *pc;	/* ... and instruction pointer. */
+	} tebc;
+    } data;
+    union {
+	struct {
+	    const char *cmd;	/* The executed command, if possible... */
+	    int len;		/* ... and its length. */
+	} str;
+	Tcl_Obj *listPtr;	/* Tcl_EvalObjEx, cmd list. */
+    } cmd;
+    int numLevels;		/* Value of interp's numLevels when the frame
+				 * was pushed. */
+    const struct CFWordBC *litarg;
+				/* Link to set of literal arguments which have
+				 * ben pushed on the lineLABCPtr stack by
+				 * TclArgumentBCEnter(). These will be removed
+				 * by TclArgumentBCRelease. */
+} CmdFrame;
+
+typedef struct CFWord {
+    CmdFrame *framePtr;		/* CmdFrame to access. */
+    int word;			/* Index of the word in the command. */
+    int refCount;		/* Number of times the word is on the
+				 * stack. */
+} CFWord;
+
+typedef struct CFWordBC {
+    CmdFrame *framePtr;		/* CmdFrame to access. */
+    int pc;			/* Instruction pointer of a command in
+				 * ExtCmdLoc.loc[.] */
+    int word;			/* Index of word in
+				 * ExtCmdLoc.loc[cmd]->line[.] */
+    struct CFWordBC *prevPtr;	/* Previous entry in stack for same Tcl_Obj. */
+    struct CFWordBC *nextPtr;	/* Next entry for same command call. See
+				 * CmdFrame litarg field for the list start. */
+    Tcl_Obj *obj;		/* Back reference to hashtable key */
+} CFWordBC;
+
+/*
+ * Structure to record the locations of invisible continuation lines in
+ * literal scripts, as character offset from the beginning of the script. Both
+ * compiler and direct evaluator use this information to adjust their line
+ * counters when tracking through the script, because when it is invoked the
+ * continuation line marker as a whole has been removed already, meaning that
+ * the \n which was part of it is gone as well, breaking regular line
+ * tracking.
+ *
+ * These structures are allocated and filled by both the function
+ * TclSubstTokens() in the file "tclParse.c" and its caller TclEvalEx() in the
+ * file "tclBasic.c", and stored in the thread-global hashtable "lineCLPtr" in
+ * file "tclObj.c". They are used by the functions TclSetByteCodeFromAny() and
+ * TclCompileScript(), both found in the file "tclCompile.c". Their memory is
+ * released by the function TclFreeObj(), in the file "tclObj.c", and also by
+ * the function TclThreadFinalizeObjects(), in the same file.
+ */
+
+#define CLL_END		(-1)
+
+typedef struct ContLineLoc {
+    int num;			/* Number of entries in loc, not counting the
+				 * final -1 marker entry. */
+    int loc[1];			/* Table of locations, as character offsets.
+				 * The table is allocated as part of the
+				 * structure, extending behind the nominal end
+				 * of the structure. An entry containing the
+				 * value -1 is put after the last location, as
+				 * end-marker/sentinel. */
+} ContLineLoc;
+
+/*
+ * The following macros define the allowed values for the type field of the
+ * CmdFrame structure above. Some of the values occur only in the extended
+ * location data referenced via the 'baseLocPtr'.
+ *
+ * TCL_LOCATION_EVAL	  : Frame is for a script evaluated by EvalEx.
+ * TCL_LOCATION_EVAL_LIST : Frame is for a script evaluated by the list
+ *			    optimization path of EvalObjEx.
+ * TCL_LOCATION_BC	  : Frame is for bytecode.
+ * TCL_LOCATION_PREBC	  : Frame is for precompiled bytecode.
+ * TCL_LOCATION_SOURCE	  : Frame is for a script evaluated by EvalEx, from a
+ *			    sourced file.
+ * TCL_LOCATION_PROC	  : Frame is for bytecode of a procedure.
+ *
+ * A TCL_LOCATION_BC type in a frame can be overridden by _SOURCE and _PROC
+ * types, per the context of the byte code in execution.
+ */
+
+#define TCL_LOCATION_EVAL	(0) /* Location in a dynamic eval script. */
+#define TCL_LOCATION_EVAL_LIST	(1) /* Location in a dynamic eval script,
+				     * list-path. */
+#define TCL_LOCATION_BC		(2) /* Location in byte code. */
+#define TCL_LOCATION_PREBC	(3) /* Location in precompiled byte code, no
+				     * location. */
+#define TCL_LOCATION_SOURCE	(4) /* Location in a file. */
+#define TCL_LOCATION_PROC	(5) /* Location in a dynamic proc. */
+#define TCL_LOCATION_LAST	(6) /* Number of values in the enum. */
+
+/*
+ * Structure passed to describe procedure-like "procedures" that are not
+ * procedures (e.g. a lambda) so that their details can be reported correctly
+ * by [info frame]. Contains a sub-structure for each extra field.
+ */
+
+typedef Tcl_Obj * (GetFrameInfoValueProc)(ClientData clientData);
+typedef struct {
+    const char *name;		/* Name of this field. */
+    GetFrameInfoValueProc *proc;	/* Function to generate a Tcl_Obj* from the
+				 * clientData, or just use the clientData
+				 * directly (after casting) if NULL. */
+    ClientData clientData;	/* Context for above function, or Tcl_Obj* if
+				 * proc field is NULL. */
+} ExtraFrameInfoField;
+typedef struct {
+    int length;			/* Length of array. */
+    ExtraFrameInfoField fields[2];
+				/* Really as long as necessary, but this is
+				 * long enough for nearly anything. */
+} ExtraFrameInfo;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures and procedures related to TclHandles, which are a very
+ * lightweight method of preserving enough information to determine if an
+ * arbitrary malloc'd block has been deleted.
+ *----------------------------------------------------------------
+ */
+
+typedef void **TclHandle;
+
+/*
+ *----------------------------------------------------------------
+ * Experimental flag value passed to Tcl_GetRegExpFromObj. Intended for use
+ * only by Expect. It will probably go away in a later release.
+ *----------------------------------------------------------------
+ */
+
+#define TCL_REG_BOSONLY 002000	/* Prepend \A to pattern so it only matches at
+				 * the beginning of the string. */
+
+/*
+ * These are a thin layer over TclpThreadKeyDataGet and TclpThreadKeyDataSet
+ * when threads are used, or an emulation if there are no threads. These are
+ * really internal and Tcl clients should use Tcl_GetThreadData.
+ */
+
+MODULE_SCOPE void *	TclThreadDataKeyGet(Tcl_ThreadDataKey *keyPtr);
+MODULE_SCOPE void	TclThreadDataKeySet(Tcl_ThreadDataKey *keyPtr,
+			    void *data);
+
+/*
+ * This is a convenience macro used to initialize a thread local storage ptr.
+ */
+
+#define TCL_TSD_INIT(keyPtr) \
+  (ThreadSpecificData *)Tcl_GetThreadData((keyPtr), sizeof(ThreadSpecificData))
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to bytecode compilation and execution. These are
+ * used primarily in tclCompile.c, tclExecute.c, and tclBasic.c.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * Forward declaration to prevent errors when the forward references to
+ * Tcl_Parse and CompileEnv are encountered in the procedure type CompileProc
+ * declared below.
+ */
+
+struct CompileEnv;
+
+/*
+ * The type of procedures called by the Tcl bytecode compiler to compile
+ * commands. Pointers to these procedures are kept in the Command structure
+ * describing each command. The integer value returned by a CompileProc must
+ * be one of the following:
+ *
+ * TCL_OK		Compilation completed normally.
+ * TCL_ERROR 		Compilation could not be completed. This can be just a
+ * 			judgment by the CompileProc that the command is too
+ * 			complex to compile effectively, or it can indicate
+ * 			that in the current state of the interp, the command
+ * 			would raise an error. The bytecode compiler will not
+ * 			do any error reporting at compiler time. Error
+ * 			reporting is deferred until the actual runtime,
+ * 			because by then changes in the interp state may allow
+ * 			the command to be successfully evaluated.
+ * TCL_OUT_LINE_COMPILE	A source-compatible alias for TCL_ERROR, kept for the
+ * 			sake of old code only.
+ */
+
+#define TCL_OUT_LINE_COMPILE	TCL_ERROR
+
+typedef int (CompileProc)(Tcl_Interp *interp, Tcl_Parse *parsePtr,
+	struct Command *cmdPtr, struct CompileEnv *compEnvPtr);
+
+/*
+ * The type of procedure called from the compilation hook point in
+ * SetByteCodeFromAny.
+ */
+
+typedef int (CompileHookProc)(Tcl_Interp *interp,
+	struct CompileEnv *compEnvPtr, ClientData clientData);
+
+/*
+ * The data structure for a (linked list of) execution stacks.
+ */
+
+typedef struct ExecStack {
+    struct ExecStack *prevPtr;
+    struct ExecStack *nextPtr;
+    Tcl_Obj **markerPtr;
+    Tcl_Obj **endPtr;
+    Tcl_Obj **tosPtr;
+    Tcl_Obj *stackWords[1];
+} ExecStack;
+
+/*
+ * The data structure defining the execution environment for ByteCode's.
+ * There is one ExecEnv structure per Tcl interpreter. It holds the evaluation
+ * stack that holds command operands and results. The stack grows towards
+ * increasing addresses. The member stackPtr points to the stackItems of the
+ * currently active execution stack.
+ */
+
+typedef struct CorContext {
+    struct CallFrame *framePtr;
+    struct CallFrame *varFramePtr;
+    struct CmdFrame *cmdFramePtr;  /* See Interp.cmdFramePtr */
+    Tcl_HashTable *lineLABCPtr;    /* See Interp.lineLABCPtr */
+} CorContext;
+
+typedef struct CoroutineData {
+    struct Command *cmdPtr;	/* The command handle for the coroutine. */
+    struct ExecEnv *eePtr;	/* The special execution environment (stacks,
+				 * etc.) for the coroutine. */
+    struct ExecEnv *callerEEPtr;/* The execution environment for the caller of
+				 * the coroutine, which might be the
+				 * interpreter global environment or another
+				 * coroutine. */
+    CorContext caller;
+    CorContext running;
+    Tcl_HashTable *lineLABCPtr;    /* See Interp.lineLABCPtr */
+    void *stackLevel;
+    int auxNumLevels;		/* While the coroutine is running the
+				 * numLevels of the create/resume command is
+				 * stored here; for suspended coroutines it
+				 * holds the nesting numLevels at yield. */
+    int nargs;                  /* Number of args required for resuming this
+				 * coroutine; -2 means "0 or 1" (default), -1
+				 * means "any" */
+} CoroutineData;
+
+typedef struct ExecEnv {
+    ExecStack *execStackPtr;	/* Points to the first item in the evaluation
+				 * stack on the heap. */
+    Tcl_Obj *constants[2];	/* Pointers to constant "0" and "1" objs. */
+    struct Tcl_Interp *interp;
+    struct NRE_callback *callbackPtr;
+				/* Top callback in NRE's stack. */
+    struct CoroutineData *corPtr;
+    int rewind;
+} ExecEnv;
+
+#define COR_IS_SUSPENDED(corPtr) \
+    ((corPtr)->stackLevel == NULL)
+
+/*
+ * The definitions for the LiteralTable and LiteralEntry structures. Each
+ * interpreter contains a LiteralTable. It is used to reduce the storage
+ * needed for all the Tcl objects that hold the literals of scripts compiled
+ * by the interpreter. A literal's object is shared by all the ByteCodes that
+ * refer to the literal. Each distinct literal has one LiteralEntry entry in
+ * the LiteralTable. A literal table is a specialized hash table that is
+ * indexed by the literal's string representation, which may contain null
+ * characters.
+ *
+ * Note that we reduce the space needed for literals by sharing literal
+ * objects both within a ByteCode (each ByteCode contains a local
+ * LiteralTable) and across all an interpreter's ByteCodes (with the
+ * interpreter's global LiteralTable).
+ */
+
+typedef struct LiteralEntry {
+    struct LiteralEntry *nextPtr;
+				/* Points to next entry in this hash bucket or
+				 * NULL if end of chain. */
+    Tcl_Obj *objPtr;		/* Points to Tcl object that holds the
+				 * literal's bytes and length. */
+    int refCount;		/* If in an interpreter's global literal
+				 * table, the number of ByteCode structures
+				 * that share the literal object; the literal
+				 * entry can be freed when refCount drops to
+				 * 0. If in a local literal table, -1. */
+    Namespace *nsPtr;		/* Namespace in which this literal is used. We
+				 * try to avoid sharing literal non-FQ command
+				 * names among different namespaces to reduce
+				 * shimmering. */
+} LiteralEntry;
+
+typedef struct LiteralTable {
+    LiteralEntry **buckets;	/* Pointer to bucket array. Each element
+				 * points to first entry in bucket's hash
+				 * chain, or NULL. */
+    LiteralEntry *staticBuckets[TCL_SMALL_HASH_TABLE];
+				/* Bucket array used for small tables to avoid
+				 * mallocs and frees. */
+    int numBuckets;		/* Total number of buckets allocated at
+				 * **buckets. */
+    int numEntries;		/* Total number of entries present in
+				 * table. */
+    int rebuildSize;		/* Enlarge table when numEntries gets to be
+				 * this large. */
+    int mask;			/* Mask value used in hashing function. */
+} LiteralTable;
+
+/*
+ * The following structure defines for each Tcl interpreter various
+ * statistics-related information about the bytecode compiler and
+ * interpreter's operation in that interpreter.
+ */
+
+#ifdef TCL_COMPILE_STATS
+typedef struct ByteCodeStats {
+    long numExecutions;		/* Number of ByteCodes executed. */
+    long numCompilations;	/* Number of ByteCodes created. */
+    long numByteCodesFreed;	/* Number of ByteCodes destroyed. */
+    long instructionCount[256];	/* Number of times each instruction was
+				 * executed. */
+
+    double totalSrcBytes;	/* Total source bytes ever compiled. */
+    double totalByteCodeBytes;	/* Total bytes for all ByteCodes. */
+    double currentSrcBytes;	/* Src bytes for all current ByteCodes. */
+    double currentByteCodeBytes;/* Code bytes in all current ByteCodes. */
+
+    long srcCount[32];		/* Source size distribution: # of srcs of
+				 * size [2**(n-1)..2**n), n in [0..32). */
+    long byteCodeCount[32];	/* ByteCode size distribution. */
+    long lifetimeCount[32];	/* ByteCode lifetime distribution (ms). */
+
+    double currentInstBytes;	/* Instruction bytes-current ByteCodes. */
+    double currentLitBytes;	/* Current literal bytes. */
+    double currentExceptBytes;	/* Current exception table bytes. */
+    double currentAuxBytes;	/* Current auxiliary information bytes. */
+    double currentCmdMapBytes;	/* Current src<->code map bytes. */
+
+    long numLiteralsCreated;	/* Total literal objects ever compiled. */
+    double totalLitStringBytes;	/* Total string bytes in all literals. */
+    double currentLitStringBytes;
+				/* String bytes in current literals. */
+    long literalCount[32];	/* Distribution of literal string sizes. */
+} ByteCodeStats;
+#endif /* TCL_COMPILE_STATS */
+
+/*
+ * Structure used in implementation of those core ensembles which are
+ * partially compiled. Used as an array of these, with a terminating field
+ * whose 'name' is NULL.
+ */
+
+typedef struct {
+    const char *name;		/* The name of the subcommand. */
+    Tcl_ObjCmdProc *proc;	/* The implementation of the subcommand. */
+    CompileProc *compileProc;	/* The compiler for the subcommand. */
+    Tcl_ObjCmdProc *nreProc;	/* NRE implementation of this command. */
+    ClientData clientData;	/* Any clientData to give the command. */
+    int unsafe;			/* Whether this command is to be hidden by
+				 * default in a safe interpreter. */
+} EnsembleImplMap;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to commands.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * An imported command is created in an namespace when it imports a "real"
+ * command from another namespace. An imported command has a Command structure
+ * that points (via its ClientData value) to the "real" Command structure in
+ * the source namespace's command table. The real command records all the
+ * imported commands that refer to it in a list of ImportRef structures so
+ * that they can be deleted when the real command is deleted.
+ */
+
+typedef struct ImportRef {
+    struct Command *importedCmdPtr;
+				/* Points to the imported command created in
+				 * an importing namespace; this command
+				 * redirects its invocations to the "real"
+				 * command. */
+    struct ImportRef *nextPtr;	/* Next element on the linked list of imported
+				 * commands that refer to the "real" command.
+				 * The real command deletes these imported
+				 * commands on this list when it is
+				 * deleted. */
+} ImportRef;
+
+/*
+ * Data structure used as the ClientData of imported commands: commands
+ * created in an namespace when it imports a "real" command from another
+ * namespace.
+ */
+
+typedef struct ImportedCmdData {
+    struct Command *realCmdPtr;	/* "Real" command that this imported command
+				 * refers to. */
+    struct Command *selfPtr;	/* Pointer to this imported command. Needed
+				 * only when deleting it in order to remove it
+				 * from the real command's linked list of
+				 * imported commands that refer to it. */
+} ImportedCmdData;
+
+/*
+ * A Command structure exists for each command in a namespace. The Tcl_Command
+ * opaque type actually refers to these structures.
+ */
+
+typedef struct Command {
+    Tcl_HashEntry *hPtr;	/* Pointer to the hash table entry that refers
+				 * to this command. The hash table is either a
+				 * namespace's command table or an
+				 * interpreter's hidden command table. This
+				 * pointer is used to get a command's name
+				 * from its Tcl_Command handle. NULL means
+				 * that the hash table entry has been removed
+				 * already (this can happen if deleteProc
+				 * causes the command to be deleted or
+				 * recreated). */
+    Namespace *nsPtr;		/* Points to the namespace containing this
+				 * command. */
+    int refCount;		/* 1 if in command hashtable plus 1 for each
+				 * reference from a CmdName Tcl object
+				 * representing a command's name in a ByteCode
+				 * instruction sequence. This structure can be
+				 * freed when refCount becomes zero. */
+    int cmdEpoch;		/* Incremented to invalidate any references
+				 * that point to this command when it is
+				 * renamed, deleted, hidden, or exposed. */
+    CompileProc *compileProc;	/* Procedure called to compile command. NULL
+				 * if no compile proc exists for command. */
+    Tcl_ObjCmdProc *objProc;	/* Object-based command procedure. */
+    ClientData objClientData;	/* Arbitrary value passed to object proc. */
+    Tcl_CmdProc *proc;		/* String-based command procedure. */
+    ClientData clientData;	/* Arbitrary value passed to string proc. */
+    Tcl_CmdDeleteProc *deleteProc;
+				/* Procedure invoked when deleting command to,
+				 * e.g., free all client data. */
+    ClientData deleteData;	/* Arbitrary value passed to deleteProc. */
+    int flags;			/* Miscellaneous bits of information about
+				 * command. See below for definitions. */
+    ImportRef *importRefPtr;	/* List of each imported Command created in
+				 * another namespace when this command is
+				 * imported. These imported commands redirect
+				 * invocations back to this command. The list
+				 * is used to remove all those imported
+				 * commands when deleting this "real"
+				 * command. */
+    CommandTrace *tracePtr;	/* First in list of all traces set for this
+				 * command. */
+    Tcl_ObjCmdProc *nreProc;	/* NRE implementation of this command. */
+} Command;
+
+/*
+ * Flag bits for commands.
+ *
+ * CMD_IS_DELETED -		Means that the command is in the process of
+ *				being deleted (its deleteProc is currently
+ *				executing). Other attempts to delete the
+ *				command should be ignored.
+ * CMD_TRACE_ACTIVE -		1 means that trace processing is currently
+ *				underway for a rename/delete change. See the
+ *				two flags below for which is currently being
+ *				processed.
+ * CMD_HAS_EXEC_TRACES -	1 means that this command has at least one
+ *				execution trace (as opposed to simple
+ *				delete/rename traces) in its tracePtr list.
+ * TCL_TRACE_RENAME -		A rename trace is in progress. Further
+ *				recursive renames will not be traced.
+ * TCL_TRACE_DELETE -		A delete trace is in progress. Further
+ *				recursive deletes will not be traced.
+ * (these last two flags are defined in tcl.h)
+ */
+
+#define CMD_IS_DELETED		    0x1
+#define CMD_TRACE_ACTIVE	    0x2
+#define CMD_HAS_EXEC_TRACES	    0x4
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to name resolution procedures.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * The interpreter keeps a linked list of name resolution schemes. The scheme
+ * for a namespace is consulted first, followed by the list of schemes in an
+ * interpreter, followed by the default name resolution in Tcl. Schemes are
+ * added/removed from the interpreter's list by calling Tcl_AddInterpResolver
+ * and Tcl_RemoveInterpResolver.
+ */
+
+typedef struct ResolverScheme {
+    char *name;			/* Name identifying this scheme. */
+    Tcl_ResolveCmdProc *cmdResProc;
+				/* Procedure handling command name
+				 * resolution. */
+    Tcl_ResolveVarProc *varResProc;
+				/* Procedure handling variable name resolution
+				 * for variables that can only be handled at
+				 * runtime. */
+    Tcl_ResolveCompiledVarProc *compiledVarResProc;
+				/* Procedure handling variable name resolution
+				 * at compile time. */
+
+    struct ResolverScheme *nextPtr;
+				/* Pointer to next record in linked list. */
+} ResolverScheme;
+
+/*
+ * Forward declaration of the TIP#143 limit handler structure.
+ */
+
+typedef struct LimitHandler LimitHandler;
+
+/*
+ * TIP #268.
+ * Values for the selection mode, i.e the package require preferences.
+ */
+
+enum PkgPreferOptions {
+    PKG_PREFER_LATEST, PKG_PREFER_STABLE
+};
+
+/*
+ *----------------------------------------------------------------
+ * This structure shadows the first few fields of the memory cache for the
+ * allocator defined in tclThreadAlloc.c; it has to be kept in sync with the
+ * definition there.
+ * Some macros require knowledge of some fields in the struct in order to
+ * avoid hitting the TSD unnecessarily. In order to facilitate this, a pointer
+ * to the relevant fields is kept in the objCache field in struct Interp.
+ *----------------------------------------------------------------
+ */
+
+typedef struct AllocCache {
+    struct Cache *nextPtr;	/* Linked list of cache entries. */
+    Tcl_ThreadId owner;		/* Which thread's cache is this? */
+    Tcl_Obj *firstObjPtr;	/* List of free objects for thread. */
+    int numObjects;		/* Number of objects for thread. */
+} AllocCache;
+
+/*
+ *----------------------------------------------------------------
+ * This structure defines an interpreter, which is a collection of commands
+ * plus other state information related to interpreting commands, such as
+ * variable storage. Primary responsibility for this data structure is in
+ * tclBasic.c, but almost every Tcl source file uses something in here.
+ *----------------------------------------------------------------
+ */
+
+typedef struct Interp {
+    /*
+     * Note: the first three fields must match exactly the fields in a
+     * Tcl_Interp struct (see tcl.h). If you change one, be sure to change the
+     * other.
+     *
+     * The interpreter's result is held in both the string and the
+     * objResultPtr fields. These fields hold, respectively, the result's
+     * string or object value. The interpreter's result is always in the
+     * result field if that is non-empty, otherwise it is in objResultPtr.
+     * The two fields are kept consistent unless some C code sets
+     * interp->result directly. Programs should not access result and
+     * objResultPtr directly; instead, they should always get and set the
+     * result using procedures such as Tcl_SetObjResult, Tcl_GetObjResult, and
+     * Tcl_GetStringResult. See the SetResult man page for details.
+     */
+
+    char *result;		/* If the last command returned a string
+				 * result, this points to it. Should not be
+				 * accessed directly; see comment above. */
+    Tcl_FreeProc *freeProc;	/* Zero means a string result is statically
+				 * allocated. TCL_DYNAMIC means string result
+				 * was allocated with ckalloc and should be
+				 * freed with ckfree. Other values give
+				 * address of procedure to invoke to free the
+				 * string result. Tcl_Eval must free it before
+				 * executing next command. */
+    int errorLine;		/* When TCL_ERROR is returned, this gives the
+				 * line number in the command where the error
+				 * occurred (1 means first line). */
+    const struct TclStubs *stubTable;
+				/* Pointer to the exported Tcl stub table. On
+				 * previous versions of Tcl this is a pointer
+				 * to the objResultPtr or a pointer to a
+				 * buckets array in a hash table. We therefore
+				 * have to do some careful checking before we
+				 * can use this. */
+
+    TclHandle handle;		/* Handle used to keep track of when this
+				 * interp is deleted. */
+
+    Namespace *globalNsPtr;	/* The interpreter's global namespace. */
+    Tcl_HashTable *hiddenCmdTablePtr;
+				/* Hash table used by tclBasic.c to keep track
+				 * of hidden commands on a per-interp
+				 * basis. */
+    ClientData interpInfo;	/* Information used by tclInterp.c to keep
+				 * track of master/slave interps on a
+				 * per-interp basis. */
+    Tcl_HashTable unused2;	/* No longer used (was mathFuncTable) */
+
+    /*
+     * Information related to procedures and variables. See tclProc.c and
+     * tclVar.c for usage.
+     */
+
+    int numLevels;		/* Keeps track of how many nested calls to
+				 * Tcl_Eval are in progress for this
+				 * interpreter. It's used to delay deletion of
+				 * the table until all Tcl_Eval invocations
+				 * are completed. */
+    int maxNestingDepth;	/* If numLevels exceeds this value then Tcl
+				 * assumes that infinite recursion has
+				 * occurred and it generates an error. */
+    CallFrame *framePtr;	/* Points to top-most in stack of all nested
+				 * procedure invocations. */
+    CallFrame *varFramePtr;	/* Points to the call frame whose variables
+				 * are currently in use (same as framePtr
+				 * unless an "uplevel" command is
+				 * executing). */
+    ActiveVarTrace *activeVarTracePtr;
+				/* First in list of active traces for interp,
+				 * or NULL if no active traces. */
+    int returnCode;		/* [return -code] parameter. */
+    CallFrame *rootFramePtr;	/* Global frame pointer for this
+				 * interpreter. */
+    Namespace *lookupNsPtr;	/* Namespace to use ONLY on the next
+				 * TCL_EVAL_INVOKE call to Tcl_EvalObjv. */
+
+    /*
+     * Information used by Tcl_AppendResult to keep track of partial results.
+     * See Tcl_AppendResult code for details.
+     */
+
+    char *appendResult;		/* Storage space for results generated by
+				 * Tcl_AppendResult. Ckalloc-ed. NULL means
+				 * not yet allocated. */
+    int appendAvl;		/* Total amount of space available at
+				 * partialResult. */
+    int appendUsed;		/* Number of non-null bytes currently stored
+				 * at partialResult. */
+
+    /*
+     * Information about packages. Used only in tclPkg.c.
+     */
+
+    Tcl_HashTable packageTable;	/* Describes all of the packages loaded in or
+				 * available to this interpreter. Keys are
+				 * package names, values are (Package *)
+				 * pointers. */
+    char *packageUnknown;	/* Command to invoke during "package require"
+				 * commands for packages that aren't described
+				 * in packageTable. Ckalloc'ed, may be
+				 * NULL. */
+    /*
+     * Miscellaneous information:
+     */
+
+    int cmdCount;		/* Total number of times a command procedure
+				 * has been called for this interpreter. */
+    int evalFlags;		/* Flags to control next call to Tcl_Eval.
+				 * Normally zero, but may be set before
+				 * calling Tcl_Eval. See below for valid
+				 * values. */
+    int unused1;		/* No longer used (was termOffset) */
+    LiteralTable literalTable;	/* Contains LiteralEntry's describing all Tcl
+				 * objects holding literals of scripts
+				 * compiled by the interpreter. Indexed by the
+				 * string representations of literals. Used to
+				 * avoid creating duplicate objects. */
+    int compileEpoch;		/* Holds the current "compilation epoch" for
+				 * this interpreter. This is incremented to
+				 * invalidate existing ByteCodes when, e.g., a
+				 * command with a compile procedure is
+				 * redefined. */
+    Proc *compiledProcPtr;	/* If a procedure is being compiled, a pointer
+				 * to its Proc structure; otherwise, this is
+				 * NULL. Set by ObjInterpProc in tclProc.c and
+				 * used by tclCompile.c to process local
+				 * variables appropriately. */
+    ResolverScheme *resolverPtr;
+				/* Linked list of name resolution schemes
+				 * added to this interpreter. Schemes are
+				 * added and removed by calling
+				 * Tcl_AddInterpResolvers and
+				 * Tcl_RemoveInterpResolver respectively. */
+    Tcl_Obj *scriptFile;	/* NULL means there is no nested source
+				 * command active; otherwise this points to
+				 * pathPtr of the file being sourced. */
+    int flags;			/* Various flag bits. See below. */
+    long randSeed;		/* Seed used for rand() function. */
+    Trace *tracePtr;		/* List of traces for this interpreter. */
+    Tcl_HashTable *assocData;	/* Hash table for associating data with this
+				 * interpreter. Cleaned up when this
+				 * interpreter is deleted. */
+    struct ExecEnv *execEnvPtr;	/* Execution environment for Tcl bytecode
+				 * execution. Contains a pointer to the Tcl
+				 * evaluation stack. */
+    Tcl_Obj *emptyObjPtr;	/* Points to an object holding an empty
+				 * string. Returned by Tcl_ObjSetVar2 when
+				 * variable traces change a variable in a
+				 * gross way. */
+    char resultSpace[TCL_RESULT_SIZE+1];
+				/* Static space holding small results. */
+    Tcl_Obj *objResultPtr;	/* If the last command returned an object
+				 * result, this points to it. Should not be
+				 * accessed directly; see comment above. */
+    Tcl_ThreadId threadId;	/* ID of thread that owns the interpreter. */
+
+    ActiveCommandTrace *activeCmdTracePtr;
+				/* First in list of active command traces for
+				 * interp, or NULL if no active traces. */
+    ActiveInterpTrace *activeInterpTracePtr;
+				/* First in list of active traces for interp,
+				 * or NULL if no active traces. */
+
+    int tracesForbiddingInline;	/* Count of traces (in the list headed by
+				 * tracePtr) that forbid inline bytecode
+				 * compilation. */
+
+    /*
+     * Fields used to manage extensible return options (TIP 90).
+     */
+
+    Tcl_Obj *returnOpts;	/* A dictionary holding the options to the
+				 * last [return] command. */
+
+    Tcl_Obj *errorInfo;		/* errorInfo value (now as a Tcl_Obj). */
+    Tcl_Obj *eiVar;		/* cached ref to ::errorInfo variable. */
+    Tcl_Obj *errorCode;		/* errorCode value (now as a Tcl_Obj). */
+    Tcl_Obj *ecVar;		/* cached ref to ::errorInfo variable. */
+    int returnLevel;		/* [return -level] parameter. */
+
+    /*
+     * Resource limiting framework support (TIP#143).
+     */
+
+    struct {
+	int active;		/* Flag values defining which limits have been
+				 * set. */
+	int granularityTicker;	/* Counter used to determine how often to
+				 * check the limits. */
+	int exceeded;		/* Which limits have been exceeded, described
+				 * as flag values the same as the 'active'
+				 * field. */
+
+	int cmdCount;		/* Limit for how many commands to execute in
+				 * the interpreter. */
+	LimitHandler *cmdHandlers;
+				/* Handlers to execute when the limit is
+				 * reached. */
+	int cmdGranularity;	/* Mod factor used to determine how often to
+				 * evaluate the limit check. */
+
+	Tcl_Time time;		/* Time limit for execution within the
+				 * interpreter. */
+	LimitHandler *timeHandlers;
+				/* Handlers to execute when the limit is
+				 * reached. */
+	int timeGranularity;	/* Mod factor used to determine how often to
+				 * evaluate the limit check. */
+	Tcl_TimerToken timeEvent;
+				/* Handle for a timer callback that will occur
+				 * when the time-limit is exceeded. */
+
+	Tcl_HashTable callbacks;/* Mapping from (interp,type) pair to data
+				 * used to install a limit handler callback to
+				 * run in _this_ interp when the limit is
+				 * exceeded. */
+    } limit;
+
+    /*
+     * Information for improved default error generation from ensembles
+     * (TIP#112).
+     */
+
+    struct {
+	Tcl_Obj *const *sourceObjs;
+				/* What arguments were actually input into the
+				 * *root* ensemble command? (Nested ensembles
+				 * don't rewrite this.) NULL if we're not
+				 * processing an ensemble. */
+	int numRemovedObjs;	/* How many arguments have been stripped off
+				 * because of ensemble processing. */
+	int numInsertedObjs;	/* How many of the current arguments were
+				 * inserted by an ensemble. */
+    } ensembleRewrite;
+
+    /*
+     * TIP #219: Global info for the I/O system.
+     */
+
+    Tcl_Obj *chanMsg;		/* Error message set by channel drivers, for
+				 * the propagation of arbitrary Tcl errors.
+				 * This information, if present (chanMsg not
+				 * NULL), takes precedence over a POSIX error
+				 * code returned by a channel operation. */
+
+    /*
+     * Source code origin information (TIP #280).
+     */
+
+    CmdFrame *cmdFramePtr;	/* Points to the command frame containing the
+				 * location information for the current
+				 * command. */
+    const CmdFrame *invokeCmdFramePtr;
+				/* Points to the command frame which is the
+				 * invoking context of the bytecode compiler.
+				 * NULL when the byte code compiler is not
+				 * active. */
+    int invokeWord;		/* Index of the word in the command which
+				 * is getting compiled. */
+    Tcl_HashTable *linePBodyPtr;/* This table remembers for each statically
+				 * defined procedure the location information
+				 * for its body. It is keyed by the address of
+				 * the Proc structure for a procedure. The
+				 * values are "struct CmdFrame*". */
+    Tcl_HashTable *lineBCPtr;	/* This table remembers for each ByteCode
+				 * object the location information for its
+				 * body. It is keyed by the address of the
+				 * Proc structure for a procedure. The values
+				 * are "struct ExtCmdLoc*". (See
+				 * tclCompile.h) */
+    Tcl_HashTable *lineLABCPtr;
+    Tcl_HashTable *lineLAPtr;	/* This table remembers for each argument of a
+				 * command on the execution stack the index of
+				 * the argument in the command, and the
+				 * location data of the command. It is keyed
+				 * by the address of the Tcl_Obj containing
+				 * the argument. The values are "struct
+				 * CFWord*" (See tclBasic.c). This allows
+				 * commands like uplevel, eval, etc. to find
+				 * location information for their arguments,
+				 * if they are a proper literal argument to an
+				 * invoking command. Alt view: An index to the
+				 * CmdFrame stack keyed by command argument
+				 * holders. */
+    ContLineLoc *scriptCLLocPtr;/* This table points to the location data for
+				 * invisible continuation lines in the script,
+				 * if any. This pointer is set by the function
+				 * TclEvalObjEx() in file "tclBasic.c", and
+				 * used by function ...() in the same file.
+				 * It does for the eval/direct path of script
+				 * execution what CompileEnv.clLoc does for
+				 * the bytecode compiler.
+				 */
+    /*
+     * TIP #268. The currently active selection mode, i.e. the package require
+     * preferences.
+     */
+
+    int packagePrefer;		/* Current package selection mode. */
+
+    /*
+     * Hashtables for variable traces and searches.
+     */
+
+    Tcl_HashTable varTraces;	/* Hashtable holding the start of a variable's
+				 * active trace list; varPtr is the key. */
+    Tcl_HashTable varSearches;	/* Hashtable holding the start of a variable's
+				 * active searches list; varPtr is the key. */
+    /*
+     * The thread-specific data ekeko: cache pointers or values that
+     *  (a) do not change during the thread's lifetime
+     *  (b) require access to TSD to determine at runtime
+     *  (c) are accessed very often (e.g., at each command call)
+     *
+     * Note that these are the same for all interps in the same thread. They
+     * just have to be initialised for the thread's master interp, slaves
+     * inherit the value.
+     *
+     * They are used by the macros defined below.
+     */
+
+    AllocCache *allocCache;
+    void *pendingObjDataPtr;	/* Pointer to the Cache and PendingObjData
+				 * structs for this interp's thread; see
+				 * tclObj.c and tclThreadAlloc.c */
+    int *asyncReadyPtr;		/* Pointer to the asyncReady indicator for
+				 * this interp's thread; see tclAsync.c */
+    /*
+     * The pointer to the object system root ekeko. c.f. TIP #257.
+     */
+    void *objectFoundation;	/* Pointer to the Foundation structure of the
+				 * object system, which contains things like
+				 * references to key namespaces. See
+				 * tclOOInt.h and tclOO.c for real definition
+				 * and setup. */
+
+    struct NRE_callback *deferredCallbacks;
+				/* Callbacks that are set previous to a call
+				 * to some Eval function but that actually
+				 * belong to the command that is about to be
+				 * called - i.e., they should be run *before*
+				 * any tailcall is invoked. */
+
+    /*
+     * TIP #285, Script cancellation support.
+     */
+
+    Tcl_AsyncHandler asyncCancel;
+				/* Async handler token for Tcl_CancelEval. */
+    Tcl_Obj *asyncCancelMsg;	/* Error message set by async cancel handler
+				 * for the propagation of arbitrary Tcl
+				 * errors. This information, if present
+				 * (asyncCancelMsg not NULL), takes precedence
+				 * over the default error messages returned by
+				 * a script cancellation operation. */
+
+	/*
+	 * TIP #348 IMPLEMENTATION  -  Substituted error stack
+	 */
+    Tcl_Obj *errorStack;	/* [info errorstack] value (as a Tcl_Obj). */
+    Tcl_Obj *upLiteral;		/* "UP" literal for [info errorstack] */
+    Tcl_Obj *callLiteral;	/* "CALL" literal for [info errorstack] */
+    Tcl_Obj *innerLiteral;	/* "INNER" literal for [info errorstack] */
+    Tcl_Obj *innerContext;	/* cached list for fast reallocation */
+    int resetErrorStack;        /* controls cleaning up of ::errorStack */
+
+#ifdef TCL_COMPILE_STATS
+    /*
+     * Statistical information about the bytecode compiler and interpreter's
+     * operation. This should be the last field of Interp.
+     */
+
+    ByteCodeStats stats;	/* Holds compilation and execution statistics
+				 * for this interpreter. */
+#endif /* TCL_COMPILE_STATS */
+} Interp;
+
+/*
+ * Macros that use the TSD-ekeko.
+ */
+
+#define TclAsyncReady(iPtr) \
+    *((iPtr)->asyncReadyPtr)
+
+/*
+ * Macros for script cancellation support (TIP #285).
+ */
+
+#define TclCanceled(iPtr) \
+    (((iPtr)->flags & CANCELED) || ((iPtr)->flags & TCL_CANCEL_UNWIND))
+
+#define TclSetCancelFlags(iPtr, cancelFlags)   \
+    (iPtr)->flags |= CANCELED;                 \
+    if ((cancelFlags) & TCL_CANCEL_UNWIND) {   \
+        (iPtr)->flags |= TCL_CANCEL_UNWIND;    \
+    }
+
+#define TclUnsetCancelFlags(iPtr) \
+    (iPtr)->flags &= (~(CANCELED | TCL_CANCEL_UNWIND))
+
+/*
+ * General list of interpreters. Doubly linked for easier removal of items
+ * deep in the list.
+ */
+
+typedef struct InterpList {
+    Interp *interpPtr;
+    struct InterpList *prevPtr;
+    struct InterpList *nextPtr;
+} InterpList;
+
+/*
+ * Macros for splicing into and out of doubly linked lists. They assume
+ * existence of struct items 'prevPtr' and 'nextPtr'.
+ *
+ * a = element to add or remove.
+ * b = list head.
+ *
+ * TclSpliceIn adds to the head of the list.
+ */
+
+#define TclSpliceIn(a,b)			\
+    (a)->nextPtr = (b);				\
+    if ((b) != NULL) {				\
+	(b)->prevPtr = (a);			\
+    }						\
+    (a)->prevPtr = NULL, (b) = (a);
+
+#define TclSpliceOut(a,b)			\
+    if ((a)->prevPtr != NULL) {			\
+	(a)->prevPtr->nextPtr = (a)->nextPtr;	\
+    } else {					\
+	(b) = (a)->nextPtr;			\
+    }						\
+    if ((a)->nextPtr != NULL) {			\
+	(a)->nextPtr->prevPtr = (a)->prevPtr;	\
+    }
+
+/*
+ * EvalFlag bits for Interp structures:
+ *
+ * TCL_ALLOW_EXCEPTIONS	1 means it's OK for the script to terminate with a
+ *			code other than TCL_OK or TCL_ERROR; 0 means codes
+ *			other than these should be turned into errors.
+ */
+
+#define TCL_ALLOW_EXCEPTIONS	4
+#define TCL_EVAL_FILE		2
+#define TCL_EVAL_CTX		8
+#define TCL_EVAL_REDIRECT	16
+
+/*
+ * Flag bits for Interp structures:
+ *
+ * DELETED:		Non-zero means the interpreter has been deleted:
+ *			don't process any more commands for it, and destroy
+ *			the structure as soon as all nested invocations of
+ *			Tcl_Eval are done.
+ * ERR_ALREADY_LOGGED:	Non-zero means information has already been logged in
+ *			iPtr->errorInfo for the current Tcl_Eval instance, so
+ *			Tcl_Eval needn't log it (used to implement the "error
+ *			message log" command).
+ * DONT_COMPILE_CMDS_INLINE: Non-zero means that the bytecode compiler should
+ *			not compile any commands into an inline sequence of
+ *			instructions. This is set 1, for example, when command
+ *			traces are requested.
+ * RAND_SEED_INITIALIZED: Non-zero means that the randSeed value of the interp
+ *			has not be initialized. This is set 1 when we first
+ *			use the rand() or srand() functions.
+ * SAFE_INTERP:		Non zero means that the current interp is a safe
+ *			interp (i.e. it has only the safe commands installed,
+ *			less priviledge than a regular interp).
+ * INTERP_DEBUG_FRAME:	Used for switching on various extra interpreter
+ *			debug/info mechanisms (e.g. info frame eval/uplevel
+ *			tracing) which are performance intensive.
+ * INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
+ *			active; so no further trace callbacks should be
+ *			invoked.
+ * INTERP_ALTERNATE_WRONG_ARGS: Used for listing second and subsequent forms
+ *			of the wrong-num-args string in Tcl_WrongNumArgs.
+ *			Makes it append instead of replacing and uses
+ *			different intermediate text.
+ * CANCELED:		Non-zero means that the script in progress should be
+ *			canceled as soon as possible. This can be checked by
+ *			extensions (and the core itself) by calling
+ *			Tcl_Canceled and checking if TCL_ERROR is returned.
+ *			This is a one-shot flag that is reset immediately upon
+ *			being detected; however, if the TCL_CANCEL_UNWIND flag
+ *			is set Tcl_Canceled will continue to report that the
+ *			script in progress has been canceled thereby allowing
+ *			the evaluation stack for the interp to be fully
+ *			unwound.
+ *
+ * WARNING: For the sake of some extensions that have made use of former
+ * internal values, do not re-use the flag values 2 (formerly ERR_IN_PROGRESS)
+ * or 8 (formerly ERROR_CODE_SET).
+ */
+
+#define DELETED				     1
+#define ERR_ALREADY_LOGGED		     4
+#define INTERP_DEBUG_FRAME		  0x10
+#define DONT_COMPILE_CMDS_INLINE	  0x20
+#define RAND_SEED_INITIALIZED		  0x40
+#define SAFE_INTERP			  0x80
+#define INTERP_TRACE_IN_PROGRESS	 0x200
+#define INTERP_ALTERNATE_WRONG_ARGS	 0x400
+#define ERR_LEGACY_COPY			 0x800
+#define CANCELED			0x1000
+
+/*
+ * Maximum number of levels of nesting permitted in Tcl commands (used to
+ * catch infinite recursion).
+ */
+
+#define MAX_NESTING_DEPTH	1000
+
+/*
+ * TIP#143 limit handler internal representation.
+ */
+
+struct LimitHandler {
+    int flags;			/* The state of this particular handler. */
+    Tcl_LimitHandlerProc *handlerProc;
+				/* The handler callback. */
+    ClientData clientData;	/* Opaque argument to the handler callback. */
+    Tcl_LimitHandlerDeleteProc *deleteProc;
+				/* How to delete the clientData. */
+    LimitHandler *prevPtr;	/* Previous item in linked list of
+				 * handlers. */
+    LimitHandler *nextPtr;	/* Next item in linked list of handlers. */
+};
+
+/*
+ * Values for the LimitHandler flags field.
+ *	LIMIT_HANDLER_ACTIVE - Whether the handler is currently being
+ *		processed; handlers are never to be entered reentrantly.
+ *	LIMIT_HANDLER_DELETED - Whether the handler has been deleted. This
+ *		should not normally be observed because when a handler is
+ *		deleted it is also spliced out of the list of handlers, but
+ *		even so we will be careful.
+ */
+
+#define LIMIT_HANDLER_ACTIVE	0x01
+#define LIMIT_HANDLER_DELETED	0x02
+
+/*
+ * The macro below is used to modify a "char" value (e.g. by casting it to an
+ * unsigned character) so that it can be used safely with macros such as
+ * isspace.
+ */
+
+#define UCHAR(c) ((unsigned char) (c))
+
+/*
+ * This macro is used to properly align the memory allocated by Tcl, giving
+ * the same alignment as the native malloc.
+ */
+
+#if defined(__APPLE__)
+#define TCL_ALLOCALIGN	16
+#else
+#define TCL_ALLOCALIGN	(2*sizeof(void *))
+#endif
+
+/*
+ * This macro is used to determine the offset needed to safely allocate any
+ * data structure in memory. Given a starting offset or size, it "rounds up"
+ * or "aligns" the offset to the next 8-byte boundary so that any data
+ * structure can be placed at the resulting offset without fear of an
+ * alignment error.
+ *
+ * WARNING!! DO NOT USE THIS MACRO TO ALIGN POINTERS: it will produce the
+ * wrong result on platforms that allocate addresses that are divisible by 4
+ * or 2. Only use it for offsets or sizes.
+ *
+ * This macro is only used by tclCompile.c in the core (Bug 926445). It
+ * however not be made file static, as extensions that touch bytecodes
+ * (notably tbcload) require it.
+ */
+
+#define TCL_ALIGN(x) (((int)(x) + 7) & ~7)
+
+/*
+ * The following enum values are used to specify the runtime platform setting
+ * of the tclPlatform variable.
+ */
+
+typedef enum {
+    TCL_PLATFORM_UNIX = 0,	/* Any Unix-like OS. */
+    TCL_PLATFORM_WINDOWS = 2	/* Any Microsoft Windows OS. */
+} TclPlatformType;
+
+/*
+ * The following enum values are used to indicate the translation of a Tcl
+ * channel. Declared here so that each platform can define
+ * TCL_PLATFORM_TRANSLATION to the native translation on that platform.
+ */
+
+typedef enum TclEolTranslation {
+    TCL_TRANSLATE_AUTO,		/* Eol == \r, \n and \r\n. */
+    TCL_TRANSLATE_CR,		/* Eol == \r. */
+    TCL_TRANSLATE_LF,		/* Eol == \n. */
+    TCL_TRANSLATE_CRLF		/* Eol == \r\n. */
+} TclEolTranslation;
+
+/*
+ * Flags for TclInvoke:
+ *
+ * TCL_INVOKE_HIDDEN		Invoke a hidden command; if not set, invokes
+ *				an exposed command.
+ * TCL_INVOKE_NO_UNKNOWN	If set, "unknown" is not invoked if the
+ *				command to be invoked is not found. Only has
+ *				an effect if invoking an exposed command,
+ *				i.e. if TCL_INVOKE_HIDDEN is not also set.
+ * TCL_INVOKE_NO_TRACEBACK	Does not record traceback information if the
+ *				invoked command returns an error. Used if the
+ *				caller plans on recording its own traceback
+ *				information.
+ */
+
+#define	TCL_INVOKE_HIDDEN	(1<<0)
+#define TCL_INVOKE_NO_UNKNOWN	(1<<1)
+#define TCL_INVOKE_NO_TRACEBACK	(1<<2)
+
+/*
+ * The structure used as the internal representation of Tcl list objects. This
+ * struct is grown (reallocated and copied) as necessary to hold all the
+ * list's element pointers. The struct might contain more slots than currently
+ * used to hold all element pointers. This is done to make append operations
+ * faster.
+ */
+
+typedef struct List {
+    int refCount;
+    int maxElemCount;		/* Total number of element array slots. */
+    int elemCount;		/* Current number of list elements. */
+    int canonicalFlag;		/* Set if the string representation was
+				 * derived from the list representation. May
+				 * be ignored if there is no string rep at
+				 * all.*/
+    Tcl_Obj *elements;		/* First list element; the struct is grown to
+				 * accomodate all elements. */
+} List;
+
+#define LIST_MAX \
+	(1 + (int)(((size_t)UINT_MAX - sizeof(List))/sizeof(Tcl_Obj *)))
+#define LIST_SIZE(numElems) \
+	(unsigned)(sizeof(List) + (((numElems) - 1) * sizeof(Tcl_Obj *)))
+
+/*
+ * Macro used to get the elements of a list object.
+ */
+
+#define ListRepPtr(listPtr) \
+    ((List *) (listPtr)->internalRep.twoPtrValue.ptr1)
+
+#define ListSetIntRep(objPtr, listRepPtr) \
+    (objPtr)->internalRep.twoPtrValue.ptr1 = (void *)(listRepPtr), \
+    (objPtr)->internalRep.twoPtrValue.ptr2 = NULL, \
+    (listRepPtr)->refCount++, \
+    (objPtr)->typePtr = &tclListType
+
+#define ListObjGetElements(listPtr, objc, objv) \
+    ((objv) = &(ListRepPtr(listPtr)->elements), \
+     (objc) = ListRepPtr(listPtr)->elemCount)
+
+#define ListObjLength(listPtr, len) \
+    ((len) = ListRepPtr(listPtr)->elemCount)
+
+#define ListObjIsCanonical(listPtr) \
+    (((listPtr)->bytes == NULL) || ListRepPtr(listPtr)->canonicalFlag)
+
+#define TclListObjGetElements(interp, listPtr, objcPtr, objvPtr) \
+    (((listPtr)->typePtr == &tclListType) \
+	    ? ((ListObjGetElements((listPtr), *(objcPtr), *(objvPtr))), TCL_OK)\
+	    : Tcl_ListObjGetElements((interp), (listPtr), (objcPtr), (objvPtr)))
+
+#define TclListObjLength(interp, listPtr, lenPtr) \
+    (((listPtr)->typePtr == &tclListType) \
+	    ? ((ListObjLength((listPtr), *(lenPtr))), TCL_OK)\
+	    : Tcl_ListObjLength((interp), (listPtr), (lenPtr)))
+
+#define TclListObjIsCanonical(listPtr) \
+    (((listPtr)->typePtr == &tclListType) ? ListObjIsCanonical((listPtr)) : 0)
+
+/*
+ * Modes for collecting (or not) in the implementations of TclNRForeachCmd,
+ * TclNRLmapCmd and their compilations.
+ */
+
+#define TCL_EACH_KEEP_NONE  0	/* Discard iteration result like [foreach] */
+#define TCL_EACH_COLLECT    1	/* Collect iteration result like [lmap] */
+
+/*
+ * Macros providing a faster path to integers: Tcl_GetLongFromObj everywhere,
+ * Tcl_GetIntFromObj and TclGetIntForIndex on platforms where longs are ints.
+ *
+ * WARNING: these macros eval their args more than once.
+ */
+
+#define TclGetLongFromObj(interp, objPtr, longPtr) \
+    (((objPtr)->typePtr == &tclIntType)	\
+	    ? ((*(longPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : Tcl_GetLongFromObj((interp), (objPtr), (longPtr)))
+
+#if (LONG_MAX == INT_MAX)
+#define TclGetIntFromObj(interp, objPtr, intPtr) \
+    (((objPtr)->typePtr == &tclIntType)	\
+	    ? ((*(intPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : Tcl_GetIntFromObj((interp), (objPtr), (intPtr)))
+#define TclGetIntForIndexM(interp, objPtr, endValue, idxPtr) \
+    (((objPtr)->typePtr == &tclIntType)	\
+	    ? ((*(idxPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : TclGetIntForIndex((interp), (objPtr), (endValue), (idxPtr)))
+#else
+#define TclGetIntFromObj(interp, objPtr, intPtr) \
+    Tcl_GetIntFromObj((interp), (objPtr), (intPtr))
+#define TclGetIntForIndexM(interp, objPtr, ignore, idxPtr)	\
+    TclGetIntForIndex(interp, objPtr, ignore, idxPtr)
+#endif
+
+/*
+ * Flag values for TclTraceDictPath().
+ *
+ * DICT_PATH_READ indicates that all entries on the path must exist but no
+ * updates will be needed.
+ *
+ * DICT_PATH_UPDATE indicates that we are going to be doing an update at the
+ * tip of the path, so duplication of shared objects should be done along the
+ * way.
+ *
+ * DICT_PATH_EXISTS indicates that we are performing an existance test and a
+ * lookup failure should therefore not be an error. If (and only if) this flag
+ * is set, TclTraceDictPath() will return the special value
+ * DICT_PATH_NON_EXISTENT if the path is not traceable.
+ *
+ * DICT_PATH_CREATE (which also requires the DICT_PATH_UPDATE bit to be set)
+ * indicates that we are to create non-existant dictionaries on the path.
+ */
+
+#define DICT_PATH_READ		0
+#define DICT_PATH_UPDATE	1
+#define DICT_PATH_EXISTS	2
+#define DICT_PATH_CREATE	5
+
+#define DICT_PATH_NON_EXISTENT	((Tcl_Obj *) (void *) 1)
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to the filesystem internals
+ *----------------------------------------------------------------
+ */
+
+/*
+ * The version_2 filesystem is private to Tcl. As and when these changes have
+ * been thoroughly tested and investigated a new public filesystem interface
+ * will be released. The aim is more versatile virtual filesystem interfaces,
+ * more efficiency in 'path' manipulation and usage, and cleaner filesystem
+ * code internally.
+ */
+
+#define TCL_FILESYSTEM_VERSION_2	((Tcl_FSVersion) 0x2)
+typedef ClientData (TclFSGetCwdProc2)(ClientData clientData);
+typedef int (Tcl_FSLoadFileProc2) (Tcl_Interp *interp, Tcl_Obj *pathPtr,
+	Tcl_LoadHandle *handlePtr, Tcl_FSUnloadFileProc **unloadProcPtr, int flags);
+
+/*
+ * The following types are used for getting and storing platform-specific file
+ * attributes in tclFCmd.c and the various platform-versions of that file.
+ * This is done to have as much common code as possible in the file attributes
+ * code. For more information about the callbacks, see TclFileAttrsCmd in
+ * tclFCmd.c.
+ */
+
+typedef int (TclGetFileAttrProc)(Tcl_Interp *interp, int objIndex,
+	Tcl_Obj *fileName, Tcl_Obj **attrObjPtrPtr);
+typedef int (TclSetFileAttrProc)(Tcl_Interp *interp, int objIndex,
+	Tcl_Obj *fileName, Tcl_Obj *attrObjPtr);
+
+typedef struct TclFileAttrProcs {
+    TclGetFileAttrProc *getProc;/* The procedure for getting attrs. */
+    TclSetFileAttrProc *setProc;/* The procedure for setting attrs. */
+} TclFileAttrProcs;
+
+/*
+ * Opaque handle used in pipeline routines to encapsulate platform-dependent
+ * state.
+ */
+
+typedef struct TclFile_ *TclFile;
+
+/*
+ * The "globParameters" argument of the function TclGlob is an or'ed
+ * combination of the following values:
+ */
+
+#define TCL_GLOBMODE_NO_COMPLAIN	1
+#define TCL_GLOBMODE_JOIN		2
+#define TCL_GLOBMODE_DIR		4
+#define TCL_GLOBMODE_TAILS		8
+
+typedef enum Tcl_PathPart {
+    TCL_PATH_DIRNAME,
+    TCL_PATH_TAIL,
+    TCL_PATH_EXTENSION,
+    TCL_PATH_ROOT
+} Tcl_PathPart;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to obsolete filesystem hooks
+ *----------------------------------------------------------------
+ */
+
+typedef int (TclStatProc_)(const char *path, struct stat *buf);
+typedef int (TclAccessProc_)(const char *path, int mode);
+typedef Tcl_Channel (TclOpenFileChannelProc_)(Tcl_Interp *interp,
+	const char *fileName, const char *modeString, int permissions);
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to procedures
+ *----------------------------------------------------------------
+ */
+
+typedef Tcl_CmdProc *TclCmdProcType;
+typedef Tcl_ObjCmdProc *TclObjCmdProcType;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures for process-global values.
+ *----------------------------------------------------------------
+ */
+
+typedef void (TclInitProcessGlobalValueProc)(char **valuePtr, int *lengthPtr,
+	Tcl_Encoding *encodingPtr);
+
+/*
+ * A ProcessGlobalValue struct exists for each internal value in Tcl that is
+ * to be shared among several threads. Each thread sees a (Tcl_Obj) copy of
+ * the value, and the master is kept as a counted string, with epoch and mutex
+ * control. Each ProcessGlobalValue struct should be a static variable in some
+ * file.
+ */
+
+typedef struct ProcessGlobalValue {
+    int epoch;			/* Epoch counter to detect changes in the
+				 * master value. */
+    int numBytes;		/* Length of the master string. */
+    char *value;		/* The master string value. */
+    Tcl_Encoding encoding;	/* system encoding when master string was
+				 * initialized. */
+    TclInitProcessGlobalValueProc *proc;
+    				/* A procedure to initialize the master string
+				 * copy when a "get" request comes in before
+				 * any "set" request has been received. */
+    Tcl_Mutex mutex;		/* Enforce orderly access from multiple
+				 * threads. */
+    Tcl_ThreadDataKey key;	/* Key for per-thread data holding the
+				 * (Tcl_Obj) copy for each thread. */
+} ProcessGlobalValue;
+
+/*
+ *----------------------------------------------------------------------
+ * Flags for TclParseNumber
+ *----------------------------------------------------------------------
+ */
+
+#define TCL_PARSE_DECIMAL_ONLY		1
+				/* Leading zero doesn't denote octal or
+				 * hex. */
+#define TCL_PARSE_OCTAL_ONLY		2
+				/* Parse octal even without prefix. */
+#define TCL_PARSE_HEXADECIMAL_ONLY	4
+				/* Parse hexadecimal even without prefix. */
+#define TCL_PARSE_INTEGER_ONLY		8
+				/* Disable floating point parsing. */
+#define TCL_PARSE_SCAN_PREFIXES		16
+				/* Use [scan] rules dealing with 0?
+				 * prefixes. */
+#define TCL_PARSE_NO_WHITESPACE		32
+				/* Reject leading/trailing whitespace. */
+#define TCL_PARSE_BINARY_ONLY	64
+				/* Parse binary even without prefix. */
+
+/*
+ *----------------------------------------------------------------------
+ * Type values TclGetNumberFromObj
+ *----------------------------------------------------------------------
+ */
+
+#define TCL_NUMBER_LONG		1
+#define TCL_NUMBER_WIDE		2
+#define TCL_NUMBER_BIG		3
+#define TCL_NUMBER_DOUBLE	4
+#define TCL_NUMBER_NAN		5
+
+/*
+ *----------------------------------------------------------------
+ * Variables shared among Tcl modules but not used by the outside world.
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE char *tclNativeExecutableName;
+MODULE_SCOPE int tclFindExecutableSearchDone;
+MODULE_SCOPE char *tclMemDumpFileName;
+MODULE_SCOPE TclPlatformType tclPlatform;
+MODULE_SCOPE Tcl_NotifierProcs tclNotifierHooks;
+
+/*
+ * TIP #233 (Virtualized Time)
+ * Data for the time hooks, if any.
+ */
+
+MODULE_SCOPE Tcl_GetTimeProc *tclGetTimeProcPtr;
+MODULE_SCOPE Tcl_ScaleTimeProc *tclScaleTimeProcPtr;
+MODULE_SCOPE ClientData tclTimeClientData;
+
+/*
+ * Variables denoting the Tcl object types defined in the core.
+ */
+
+MODULE_SCOPE const Tcl_ObjType tclBignumType;
+MODULE_SCOPE const Tcl_ObjType tclBooleanType;
+MODULE_SCOPE const Tcl_ObjType tclByteArrayType;
+MODULE_SCOPE const Tcl_ObjType tclByteCodeType;
+MODULE_SCOPE const Tcl_ObjType tclDoubleType;
+MODULE_SCOPE const Tcl_ObjType tclEndOffsetType;
+MODULE_SCOPE const Tcl_ObjType tclIntType;
+MODULE_SCOPE const Tcl_ObjType tclListType;
+MODULE_SCOPE const Tcl_ObjType tclDictType;
+MODULE_SCOPE const Tcl_ObjType tclProcBodyType;
+MODULE_SCOPE const Tcl_ObjType tclStringType;
+MODULE_SCOPE const Tcl_ObjType tclArraySearchType;
+MODULE_SCOPE const Tcl_ObjType tclEnsembleCmdType;
+#ifndef NO_WIDE_TYPE
+MODULE_SCOPE const Tcl_ObjType tclWideIntType;
+#endif
+MODULE_SCOPE const Tcl_ObjType tclRegexpType;
+MODULE_SCOPE Tcl_ObjType tclCmdNameType;
+
+/*
+ * Variables denoting the hash key types defined in the core.
+ */
+
+MODULE_SCOPE const Tcl_HashKeyType tclArrayHashKeyType;
+MODULE_SCOPE const Tcl_HashKeyType tclOneWordHashKeyType;
+MODULE_SCOPE const Tcl_HashKeyType tclStringHashKeyType;
+MODULE_SCOPE const Tcl_HashKeyType tclObjHashKeyType;
+
+/*
+ * The head of the list of free Tcl objects, and the total number of Tcl
+ * objects ever allocated and freed.
+ */
+
+MODULE_SCOPE Tcl_Obj *	tclFreeObjList;
+
+#ifdef TCL_COMPILE_STATS
+MODULE_SCOPE long	tclObjsAlloced;
+MODULE_SCOPE long	tclObjsFreed;
+#define TCL_MAX_SHARED_OBJ_STATS 5
+MODULE_SCOPE long	tclObjsShared[TCL_MAX_SHARED_OBJ_STATS];
+#endif /* TCL_COMPILE_STATS */
+
+/*
+ * Pointer to a heap-allocated string of length zero that the Tcl core uses as
+ * the value of an empty string representation for an object. This value is
+ * shared by all new objects allocated by Tcl_NewObj.
+ */
+
+MODULE_SCOPE char *	tclEmptyStringRep;
+MODULE_SCOPE char	tclEmptyString;
+
+/*
+ *----------------------------------------------------------------
+ * Procedures shared among Tcl modules but not used by the outside world,
+ * introduced by/for NRE.
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE Tcl_ObjCmdProc TclNRApplyObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNREvalObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRCatchObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRExprObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRForObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRForeachCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRIfObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRLmapCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRSourceObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRSubstObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRSwitchObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRTryObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRUplevelObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRWhileObjCmd;
+
+MODULE_SCOPE Tcl_NRPostProc TclNRForIterCallback;
+MODULE_SCOPE Tcl_NRPostProc TclNRCoroutineActivateCallback;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRTailcallObjCmd;
+MODULE_SCOPE Tcl_NRPostProc TclNRTailcallEval;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRCoroutineObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRYieldObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRYieldmObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRYieldToObjCmd;
+
+MODULE_SCOPE void  TclSpliceTailcall(Tcl_Interp *interp,
+	               struct NRE_callback *tailcallPtr);
+
+/*
+ * This structure holds the data for the various iteration callbacks used to
+ * NRE the 'for' and 'while' commands. We need a separate structure because we
+ * have more than the 4 client data entries we can provide directly thorugh
+ * the callback API. It is the 'word' information which puts us over the
+ * limit. It is needed because the loop body is argument 4 of 'for' and
+ * argument 2 of 'while'. Not providing the correct index confuses the #280
+ * code. We TclSmallAlloc/Free this.
+ */
+
+typedef struct ForIterData {
+    Tcl_Obj *cond;		/* Loop condition expression. */
+    Tcl_Obj *body;		/* Loop body. */
+    Tcl_Obj *next;		/* Loop step script, NULL for 'while'. */
+    const char *msg;		/* Error message part. */
+    int word;			/* Index of the body script in the command */
+} ForIterData;
+
+/* TIP #357 - Structure doing the bookkeeping of handles for Tcl_LoadFile
+ *            and Tcl_FindSymbol. This structure corresponds to an opaque
+ *            typedef in tcl.h */
+
+typedef void* TclFindSymbolProc(Tcl_Interp* interp, Tcl_LoadHandle loadHandle,
+				const char* symbol);
+struct Tcl_LoadHandle_ {
+    ClientData clientData;	/* Client data is the load handle in the
+				 * native filesystem if a module was loaded
+				 * there, or an opaque pointer to a structure
+				 * for further bookkeeping on load-from-VFS
+				 * and load-from-memory */
+    TclFindSymbolProc* findSymbolProcPtr;
+				/* Procedure that resolves symbols in a
+				 * loaded module */
+    Tcl_FSUnloadFileProc* unloadFileProcPtr;
+				/* Procedure that unloads a loaded module */
+};
+
+/* Flags for conversion of doubles to digit strings */
+
+#define TCL_DD_SHORTEST 		0x4
+				/* Use the shortest possible string */
+#define TCL_DD_STEELE   		0x5
+				/* Use the original Steele&White algorithm */
+#define TCL_DD_E_FORMAT 		0x2
+				/* Use a fixed-length string of digits,
+				 * suitable for E format*/
+#define TCL_DD_F_FORMAT 		0x3
+				/* Use a fixed number of digits after the
+				 * decimal point, suitable for F format */
+
+#define TCL_DD_SHORTEN_FLAG 		0x4
+				/* Allow return of a shorter digit string
+				 * if it converts losslessly */
+#define TCL_DD_NO_QUICK 		0x8
+				/* Debug flag: forbid quick FP conversion */
+
+#define TCL_DD_CONVERSION_TYPE_MASK	0x3
+				/* Mask to isolate the conversion type */
+#define TCL_DD_STEELE0 			0x1
+				/* 'Steele&White' after masking */
+#define TCL_DD_SHORTEST0		0x0
+				/* 'Shortest possible' after masking */
+
+/*
+ *----------------------------------------------------------------
+ * Procedures shared among Tcl modules but not used by the outside world:
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE void	TclAppendBytesToByteArray(Tcl_Obj *objPtr,
+			    const unsigned char *bytes, int len);
+MODULE_SCOPE int	TclNREvalCmd(Tcl_Interp *interp, Tcl_Obj *objPtr,
+			    int flags);
+MODULE_SCOPE void	TclPushTailcallPoint(Tcl_Interp *interp);
+MODULE_SCOPE void	TclAdvanceContinuations(int *line, int **next,
+			    int loc);
+MODULE_SCOPE void	TclAdvanceLines(int *line, const char *start,
+			    const char *end);
+MODULE_SCOPE void	TclArgumentEnter(Tcl_Interp *interp,
+			    Tcl_Obj *objv[], int objc, CmdFrame *cf);
+MODULE_SCOPE void	TclArgumentRelease(Tcl_Interp *interp,
+			    Tcl_Obj *objv[], int objc);
+MODULE_SCOPE void	TclArgumentBCEnter(Tcl_Interp *interp,
+			    Tcl_Obj *objv[], int objc,
+			    void *codePtr, CmdFrame *cfPtr, int pc);
+MODULE_SCOPE void	TclArgumentBCRelease(Tcl_Interp *interp,
+			    CmdFrame *cfPtr);
+MODULE_SCOPE void	TclArgumentGet(Tcl_Interp *interp, Tcl_Obj *obj,
+			    CmdFrame **cfPtrPtr, int *wordPtr);
+MODULE_SCOPE int	TclArraySet(Tcl_Interp *interp,
+			    Tcl_Obj *arrayNameObj, Tcl_Obj *arrayElemObj);
+MODULE_SCOPE double	TclBignumToDouble(const mp_int *bignum);
+MODULE_SCOPE int	TclByteArrayMatch(const unsigned char *string,
+			    int strLen, const unsigned char *pattern,
+			    int ptnLen, int flags);
+MODULE_SCOPE double	TclCeil(const mp_int *a);
+MODULE_SCOPE int	TclCheckBadOctal(Tcl_Interp *interp,
+			    const char *value);
+MODULE_SCOPE int	TclChanCaughtErrorBypass(Tcl_Interp *interp,
+			    Tcl_Channel chan);
+MODULE_SCOPE Tcl_ObjCmdProc TclChannelNamesCmd;
+MODULE_SCOPE int	TclClearRootEnsemble(ClientData data[],
+			    Tcl_Interp *interp, int result);
+MODULE_SCOPE ContLineLoc *TclContinuationsEnter(Tcl_Obj *objPtr, int num,
+			    int *loc);
+MODULE_SCOPE void	TclContinuationsEnterDerived(Tcl_Obj *objPtr,
+			    int start, int *clNext);
+MODULE_SCOPE ContLineLoc *TclContinuationsGet(Tcl_Obj *objPtr);
+MODULE_SCOPE void	TclContinuationsCopy(Tcl_Obj *objPtr,
+			    Tcl_Obj *originObjPtr);
+MODULE_SCOPE int	TclConvertElement(const char *src, int length,
+			    char *dst, int flags);
+MODULE_SCOPE void	TclDeleteNamespaceVars(Namespace *nsPtr);
+/* TIP #280 - Modified token based evulation, with line information. */
+MODULE_SCOPE int	TclEvalEx(Tcl_Interp *interp, const char *script,
+			    int numBytes, int flags, int line,
+			    int *clNextOuter, const char *outerScript);
+MODULE_SCOPE Tcl_ObjCmdProc TclFileAttrsCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileCopyCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileDeleteCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileLinkCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileMakeDirsCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileReadLinkCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileRenameCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileTemporaryCmd;
+MODULE_SCOPE void	TclCreateLateExitHandler(Tcl_ExitProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE void	TclDeleteLateExitHandler(Tcl_ExitProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE char *	TclDStringAppendObj(Tcl_DString *dsPtr,
+			    Tcl_Obj *objPtr);
+MODULE_SCOPE char *	TclDStringAppendDString(Tcl_DString *dsPtr,
+			    Tcl_DString *toAppendPtr);
+MODULE_SCOPE Tcl_Obj *	TclDStringToObj(Tcl_DString *dsPtr);
+MODULE_SCOPE void	TclFinalizeAllocSubsystem(void);
+MODULE_SCOPE void	TclFinalizeAsync(void);
+MODULE_SCOPE void	TclFinalizeDoubleConversion(void);
+MODULE_SCOPE void	TclFinalizeEncodingSubsystem(void);
+MODULE_SCOPE void	TclFinalizeEnvironment(void);
+MODULE_SCOPE void	TclFinalizeEvaluation(void);
+MODULE_SCOPE void	TclFinalizeExecution(void);
+MODULE_SCOPE void	TclFinalizeIOSubsystem(void);
+MODULE_SCOPE void	TclFinalizeFilesystem(void);
+MODULE_SCOPE void	TclResetFilesystem(void);
+MODULE_SCOPE void	TclFinalizeLoad(void);
+MODULE_SCOPE void	TclFinalizeLock(void);
+MODULE_SCOPE void	TclFinalizeMemorySubsystem(void);
+MODULE_SCOPE void	TclFinalizeNotifier(void);
+MODULE_SCOPE void	TclFinalizeObjects(void);
+MODULE_SCOPE void	TclFinalizePreserve(void);
+MODULE_SCOPE void	TclFinalizeSynchronization(void);
+MODULE_SCOPE void	TclFinalizeThreadAlloc(void);
+MODULE_SCOPE void	TclFinalizeThreadData(void);
+MODULE_SCOPE void	TclFinalizeThreadObjects(void);
+MODULE_SCOPE double	TclFloor(const mp_int *a);
+MODULE_SCOPE void	TclFormatNaN(double value, char *buffer);
+MODULE_SCOPE int	TclFSFileAttrIndex(Tcl_Obj *pathPtr,
+			    const char *attributeName, int *indexPtr);
+MODULE_SCOPE int	TclNREvalFile(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+			    const char *encodingName);
+MODULE_SCOPE void	TclFSUnloadTempFile(Tcl_LoadHandle loadHandle);
+MODULE_SCOPE int *	TclGetAsyncReadyPtr(void);
+MODULE_SCOPE Tcl_Obj *	TclGetBgErrorHandler(Tcl_Interp *interp);
+MODULE_SCOPE int	TclGetChannelFromObj(Tcl_Interp *interp,
+			    Tcl_Obj *objPtr, Tcl_Channel *chanPtr,
+			    int *modePtr, int flags);
+MODULE_SCOPE int TclGetCompletionCodeFromObj(Tcl_Interp *interp,
+			    Tcl_Obj *value, int *code);
+MODULE_SCOPE int	TclGetNumberFromObj(Tcl_Interp *interp,
+			    Tcl_Obj *objPtr, ClientData *clientDataPtr,
+			    int *typePtr);
+MODULE_SCOPE int	TclGetOpenModeEx(Tcl_Interp *interp,
+			    const char *modeString, int *seekFlagPtr,
+			    int *binaryPtr);
+MODULE_SCOPE Tcl_Obj *	TclGetProcessGlobalValue(ProcessGlobalValue *pgvPtr);
+MODULE_SCOPE const char *TclGetSrcInfoForCmd(Interp *iPtr, int *lenPtr);
+MODULE_SCOPE int	TclGlob(Tcl_Interp *interp, char *pattern,
+			    Tcl_Obj *unquotedPrefix, int globFlags,
+			    Tcl_GlobTypeData *types);
+MODULE_SCOPE int	TclIncrObj(Tcl_Interp *interp, Tcl_Obj *valuePtr,
+			    Tcl_Obj *incrPtr);
+MODULE_SCOPE Tcl_Obj *	TclIncrObjVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, Tcl_Obj *incrPtr, int flags);
+MODULE_SCOPE int	TclInfoExistsCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclInfoCoroutineCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Obj *	TclInfoFrame(Tcl_Interp *interp, CmdFrame *framePtr);
+MODULE_SCOPE int	TclInfoGlobalsCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclInfoLocalsCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclInfoVarsCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE void	TclInitAlloc(void);
+MODULE_SCOPE void	TclInitDbCkalloc(void);
+MODULE_SCOPE void	TclInitDoubleConversion(void);
+MODULE_SCOPE void	TclInitEmbeddedConfigurationInformation(
+			    Tcl_Interp *interp);
+MODULE_SCOPE void	TclInitEncodingSubsystem(void);
+MODULE_SCOPE void	TclInitIOSubsystem(void);
+MODULE_SCOPE void	TclInitLimitSupport(Tcl_Interp *interp);
+MODULE_SCOPE void	TclInitNamespaceSubsystem(void);
+MODULE_SCOPE void	TclInitNotifier(void);
+MODULE_SCOPE void	TclInitObjSubsystem(void);
+MODULE_SCOPE void	TclInitSubsystems(void);
+MODULE_SCOPE int	TclInterpReady(Tcl_Interp *interp);
+MODULE_SCOPE int	TclIsLocalScalar(const char *src, int len);
+MODULE_SCOPE int	TclIsSpaceProc(char byte);
+MODULE_SCOPE Tcl_Obj *	TclJoinPath(int elements, Tcl_Obj * const objv[]);
+MODULE_SCOPE int	TclJoinThread(Tcl_ThreadId id, int *result);
+MODULE_SCOPE void	TclLimitRemoveAllHandlers(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_Obj *	TclLindexList(Tcl_Interp *interp,
+			    Tcl_Obj *listPtr, Tcl_Obj *argPtr);
+MODULE_SCOPE Tcl_Obj *	TclLindexFlat(Tcl_Interp *interp, Tcl_Obj *listPtr,
+			    int indexCount, Tcl_Obj *const indexArray[]);
+/* TIP #280 */
+MODULE_SCOPE void	TclListLines(Tcl_Obj *listObj, int line, int n,
+			    int *lines, Tcl_Obj *const *elems);
+MODULE_SCOPE Tcl_Obj *	TclListObjCopy(Tcl_Interp *interp, Tcl_Obj *listPtr);
+MODULE_SCOPE Tcl_Obj *	TclLsetList(Tcl_Interp *interp, Tcl_Obj *listPtr,
+			    Tcl_Obj *indexPtr, Tcl_Obj *valuePtr);
+MODULE_SCOPE Tcl_Obj *	TclLsetFlat(Tcl_Interp *interp, Tcl_Obj *listPtr,
+			    int indexCount, Tcl_Obj *const indexArray[],
+			    Tcl_Obj *valuePtr);
+MODULE_SCOPE Tcl_Command TclMakeEnsemble(Tcl_Interp *interp, const char *name,
+			    const EnsembleImplMap map[]);
+MODULE_SCOPE int	TclMaxListLength(const char *bytes, int numBytes,
+			    const char **endPtr);
+MODULE_SCOPE int	TclMergeReturnOptions(Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[], Tcl_Obj **optionsPtrPtr,
+			    int *codePtr, int *levelPtr);
+MODULE_SCOPE Tcl_Obj *  TclNoErrorStack(Tcl_Interp *interp, Tcl_Obj *options);
+MODULE_SCOPE int	TclNokia770Doubles(void);
+MODULE_SCOPE void	TclNsDecrRefCount(Namespace *nsPtr);
+MODULE_SCOPE void	TclObjVarErrMsg(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, const char *operation,
+			    const char *reason, int index);
+MODULE_SCOPE int	TclObjInvokeNamespace(Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[],
+			    Tcl_Namespace *nsPtr, int flags);
+MODULE_SCOPE int	TclObjUnsetVar2(Tcl_Interp *interp,
+			    Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, int flags);
+MODULE_SCOPE int	TclParseBackslash(const char *src,
+			    int numBytes, int *readPtr, char *dst);
+MODULE_SCOPE int	TclParseHex(const char *src, int numBytes,
+			    int *resultPtr);
+MODULE_SCOPE int	TclParseNumber(Tcl_Interp *interp, Tcl_Obj *objPtr,
+			    const char *expected, const char *bytes,
+			    int numBytes, const char **endPtrPtr, int flags);
+MODULE_SCOPE void	TclParseInit(Tcl_Interp *interp, const char *string,
+			    int numBytes, Tcl_Parse *parsePtr);
+MODULE_SCOPE int	TclParseAllWhiteSpace(const char *src, int numBytes);
+MODULE_SCOPE int	TclProcessReturn(Tcl_Interp *interp,
+			    int code, int level, Tcl_Obj *returnOpts);
+MODULE_SCOPE int	TclpObjLstat(Tcl_Obj *pathPtr, Tcl_StatBuf *buf);
+MODULE_SCOPE Tcl_Obj *	TclpTempFileName(void);
+MODULE_SCOPE Tcl_Obj *  TclpTempFileNameForLibrary(Tcl_Interp *interp, Tcl_Obj* pathPtr);
+MODULE_SCOPE Tcl_Obj *	TclNewFSPathObj(Tcl_Obj *dirPtr, const char *addStrRep,
+			    int len);
+MODULE_SCOPE int	TclpDeleteFile(const void *path);
+MODULE_SCOPE void	TclpFinalizeCondition(Tcl_Condition *condPtr);
+MODULE_SCOPE void	TclpFinalizeMutex(Tcl_Mutex *mutexPtr);
+MODULE_SCOPE void	TclpFinalizePipes(void);
+MODULE_SCOPE void	TclpFinalizeSockets(void);
+MODULE_SCOPE int	TclCreateSocketAddress(Tcl_Interp *interp,
+			    struct addrinfo **addrlist,
+			    const char *host, int port, int willBind,
+			    const char **errorMsgPtr);
+MODULE_SCOPE int	TclpThreadCreate(Tcl_ThreadId *idPtr,
+			    Tcl_ThreadCreateProc *proc, ClientData clientData,
+			    int stackSize, int flags);
+MODULE_SCOPE int	TclpFindVariable(const char *name, int *lengthPtr);
+MODULE_SCOPE void	TclpInitLibraryPath(char **valuePtr,
+			    int *lengthPtr, Tcl_Encoding *encodingPtr);
+MODULE_SCOPE void	TclpInitLock(void);
+MODULE_SCOPE void	TclpInitPlatform(void);
+MODULE_SCOPE void	TclpInitUnlock(void);
+MODULE_SCOPE Tcl_Obj *	TclpObjListVolumes(void);
+MODULE_SCOPE void	TclpMasterLock(void);
+MODULE_SCOPE void	TclpMasterUnlock(void);
+MODULE_SCOPE int	TclpMatchFiles(Tcl_Interp *interp, char *separators,
+			    Tcl_DString *dirPtr, char *pattern, char *tail);
+MODULE_SCOPE int	TclpObjNormalizePath(Tcl_Interp *interp,
+			    Tcl_Obj *pathPtr, int nextCheckpoint);
+MODULE_SCOPE void	TclpNativeJoinPath(Tcl_Obj *prefix, const char *joining);
+MODULE_SCOPE Tcl_Obj *	TclpNativeSplitPath(Tcl_Obj *pathPtr, int *lenPtr);
+MODULE_SCOPE Tcl_PathType TclpGetNativePathType(Tcl_Obj *pathPtr,
+			    int *driveNameLengthPtr, Tcl_Obj **driveNameRef);
+MODULE_SCOPE int	TclCrossFilesystemCopy(Tcl_Interp *interp,
+			    Tcl_Obj *source, Tcl_Obj *target);
+MODULE_SCOPE int	TclpMatchInDirectory(Tcl_Interp *interp,
+			    Tcl_Obj *resultPtr, Tcl_Obj *pathPtr,
+			    const char *pattern, Tcl_GlobTypeData *types);
+MODULE_SCOPE ClientData	TclpGetNativeCwd(ClientData clientData);
+MODULE_SCOPE Tcl_FSDupInternalRepProc TclNativeDupInternalRep;
+MODULE_SCOPE Tcl_Obj *	TclpObjLink(Tcl_Obj *pathPtr, Tcl_Obj *toPtr,
+			    int linkType);
+MODULE_SCOPE int	TclpObjChdir(Tcl_Obj *pathPtr);
+MODULE_SCOPE Tcl_Channel TclpOpenTemporaryFile(Tcl_Obj *dirObj,
+			    Tcl_Obj *basenameObj, Tcl_Obj *extensionObj,
+			    Tcl_Obj *resultingNameObj);
+MODULE_SCOPE Tcl_Obj *	TclPathPart(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+			    Tcl_PathPart portion);
+MODULE_SCOPE char *	TclpReadlink(const char *fileName,
+			    Tcl_DString *linkPtr);
+MODULE_SCOPE void	TclpSetInterfaces(void);
+MODULE_SCOPE void	TclpSetVariables(Tcl_Interp *interp);
+MODULE_SCOPE void *	TclThreadStorageKeyGet(Tcl_ThreadDataKey *keyPtr);
+MODULE_SCOPE void	TclThreadStorageKeySet(Tcl_ThreadDataKey *keyPtr,
+			    void *data);
+MODULE_SCOPE void	TclpThreadExit(int status);
+MODULE_SCOPE void	TclRememberCondition(Tcl_Condition *mutex);
+MODULE_SCOPE void	TclRememberJoinableThread(Tcl_ThreadId id);
+MODULE_SCOPE void	TclRememberMutex(Tcl_Mutex *mutex);
+MODULE_SCOPE void	TclRemoveScriptLimitCallbacks(Tcl_Interp *interp);
+MODULE_SCOPE int	TclReToGlob(Tcl_Interp *interp, const char *reStr,
+			    int reStrLen, Tcl_DString *dsPtr, int *flagsPtr);
+MODULE_SCOPE int	TclScanElement(const char *string, int length,
+			    int *flagPtr);
+MODULE_SCOPE void	TclSetBgErrorHandler(Tcl_Interp *interp,
+			    Tcl_Obj *cmdPrefix);
+MODULE_SCOPE void	TclSetBignumIntRep(Tcl_Obj *objPtr,
+			    mp_int *bignumValue);
+MODULE_SCOPE void	TclSetCmdNameObj(Tcl_Interp *interp, Tcl_Obj *objPtr,
+			    Command *cmdPtr);
+MODULE_SCOPE void	TclSetDuplicateObj(Tcl_Obj *dupPtr, Tcl_Obj *objPtr);
+MODULE_SCOPE void	TclSetProcessGlobalValue(ProcessGlobalValue *pgvPtr,
+			    Tcl_Obj *newValue, Tcl_Encoding encoding);
+MODULE_SCOPE void	TclSignalExitThread(Tcl_ThreadId id, int result);
+MODULE_SCOPE void *	TclStackRealloc(Tcl_Interp *interp, void *ptr,
+			    int numBytes);
+MODULE_SCOPE int	TclStringMatch(const char *str, int strLen,
+			    const char *pattern, int ptnLen, int flags);
+MODULE_SCOPE int	TclStringMatchObj(Tcl_Obj *stringObj,
+			    Tcl_Obj *patternObj, int flags);
+MODULE_SCOPE Tcl_Obj *	TclStringObjReverse(Tcl_Obj *objPtr);
+MODULE_SCOPE void	TclSubstCompile(Tcl_Interp *interp, const char *bytes,
+			    int numBytes, int flags, int line,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclSubstOptions(Tcl_Interp *interp, int numOpts,
+			    Tcl_Obj *const opts[], int *flagPtr);
+MODULE_SCOPE void	TclSubstParse(Tcl_Interp *interp, const char *bytes,
+			    int numBytes, int flags, Tcl_Parse *parsePtr,
+			    Tcl_InterpState *statePtr);
+MODULE_SCOPE int	TclSubstTokens(Tcl_Interp *interp, Tcl_Token *tokenPtr,
+			    int count, int *tokensLeftPtr, int line,
+			    int *clNextOuter, const char *outerScript);
+MODULE_SCOPE int	TclTrimLeft(const char *bytes, int numBytes,
+			    const char *trim, int numTrim);
+MODULE_SCOPE int	TclTrimRight(const char *bytes, int numBytes,
+			    const char *trim, int numTrim);
+MODULE_SCOPE Tcl_Obj *	TclpNativeToNormalized(ClientData clientData);
+MODULE_SCOPE Tcl_Obj *	TclpFilesystemPathType(Tcl_Obj *pathPtr);
+MODULE_SCOPE int	TclpDlopen(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+			    Tcl_LoadHandle *loadHandle,
+			    Tcl_FSUnloadFileProc **unloadProcPtr, int flags);
+MODULE_SCOPE int	TclpUtime(Tcl_Obj *pathPtr, struct utimbuf *tval);
+#ifdef TCL_LOAD_FROM_MEMORY
+MODULE_SCOPE void *	TclpLoadMemoryGetBuffer(Tcl_Interp *interp, int size);
+MODULE_SCOPE int	TclpLoadMemory(Tcl_Interp *interp, void *buffer,
+			    int size, int codeSize, Tcl_LoadHandle *loadHandle,
+			    Tcl_FSUnloadFileProc **unloadProcPtr, int flags);
+#endif
+MODULE_SCOPE void	TclInitThreadStorage(void);
+MODULE_SCOPE void	TclFinalizeThreadDataThread(void);
+MODULE_SCOPE void	TclFinalizeThreadStorage(void);
+#ifdef TCL_WIDE_CLICKS
+MODULE_SCOPE Tcl_WideInt TclpGetWideClicks(void);
+MODULE_SCOPE double	TclpWideClicksToNanoseconds(Tcl_WideInt clicks);
+#endif
+MODULE_SCOPE Tcl_Obj *	TclDisassembleByteCodeObj(Tcl_Obj *objPtr);
+MODULE_SCOPE int	TclZlibInit(Tcl_Interp *interp);
+MODULE_SCOPE void *	TclpThreadCreateKey(void);
+MODULE_SCOPE void	TclpThreadDeleteKey(void *keyPtr);
+MODULE_SCOPE void	TclpThreadSetMasterTSD(void *tsdKeyPtr, void *ptr);
+MODULE_SCOPE void *	TclpThreadGetMasterTSD(void *tsdKeyPtr);
+
+MODULE_SCOPE void	TclErrorStackResetIf(Tcl_Interp *interp, const char *msg, int length);
+
+/*
+ *----------------------------------------------------------------
+ * Command procedures in the generic core:
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE int	Tcl_AfterObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_AppendObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ApplyObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitArrayCmd(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_Command TclInitBinaryCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	Tcl_BreakObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_CaseObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_CatchObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_CdObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitChanCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TclChanCreateObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclChanPostEventObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclChanPopObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclChanPushObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE void	TclClockInit(Tcl_Interp *interp);
+MODULE_SCOPE int	TclClockOldscanObjCmd(
+			    ClientData clientData, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+extern int	Tcl_CloseObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ConcatObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ContinueObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_TimerToken TclCreateAbsoluteTimerHandler(
+			    Tcl_Time *timePtr, Tcl_TimerProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE int	TclDefaultBgErrorHandlerObjCmd(
+			    ClientData clientData, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitDictCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TclDictWithFinish(Tcl_Interp *interp, Var *varPtr,
+			    Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, int index, int pathc,
+			    Tcl_Obj *const pathv[], Tcl_Obj *keysPtr);
+MODULE_SCOPE Tcl_Obj *	TclDictWithInit(Tcl_Interp *interp, Tcl_Obj *dictPtr,
+			    int pathc, Tcl_Obj *const pathv[]);
+MODULE_SCOPE int	Tcl_DisassembleObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+			    
+/* Assemble command function */			    
+MODULE_SCOPE int	Tcl_AssembleObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);			    
+MODULE_SCOPE int	TclNRAssembleObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);			    
+			    
+MODULE_SCOPE int	Tcl_EncodingObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_EofObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ErrorObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_EvalObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ExecObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ExitObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ExprObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FblockedObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FconfigureObjCmd(
+			    ClientData clientData, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FcopyObjCmd(ClientData dummy,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitFileCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TclMakeFileCommandSafe(Tcl_Interp *interp);
+MODULE_SCOPE int	Tcl_FileEventObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FlushObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ForObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ForeachObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_FormatObjCmd(ClientData dummy,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_GetsObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_GlobalObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_GlobObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_IfObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_IncrObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitInfoCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	Tcl_InterpObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_JoinObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LappendObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LassignObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LindexObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LinsertObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LlengthObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ListObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LmapObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LoadObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LrangeObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LrepeatObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LreplaceObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LreverseObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LsearchObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LsetObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_LsortObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitNamespaceCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TclNamespaceEnsembleCmd(ClientData dummy,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_OpenObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_PackageObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_PidObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitPrefixCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	Tcl_PutsObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_PwdObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ReadObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_RegexpObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_RegsubObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_RenameObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_RepresentationCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+extern int	Tcl_ReturnObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ScanObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SeekObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SetObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SplitObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SocketObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SourceObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitStringCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	Tcl_SubstObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_SwitchObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_TellObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_ThrowObjCmd(ClientData dummy, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_TimeObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_TraceObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_TryObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UnloadObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UnsetObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UpdateObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UplevelObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_UpvarObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_VariableObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_VwaitObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tcl_WhileObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+
+/*
+ *----------------------------------------------------------------
+ * Compilation procedures for commands in the generic core:
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE int	TclCompileAppendCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileArrayExistsCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileArraySetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileArrayUnsetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileBreakCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileCatchCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileContinueCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictAppendCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictCreateCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictExistsCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictForCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictGetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictIncrCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictLappendCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictMapCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictMergeCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictSetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictUnsetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictUpdateCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileDictWithCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileEnsemble(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileErrorCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileExprCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileForCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileForeachCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileFormatCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileGlobalCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileIfCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoCommandsCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoCoroutineCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoExistsCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoLevelCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoObjectClassCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoObjectIsACmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileInfoObjectNamespaceCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileIncrCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLappendCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLassignCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLindexCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileListCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLlengthCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLmapCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLrangeCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLreplaceCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileLsetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNamespaceCodeCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNamespaceCurrentCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNamespaceQualifiersCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNamespaceTailCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNamespaceUpvarCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNamespaceWhichCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileNoOp(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileObjectSelfCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileRegexpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileRegsubCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileReturnCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileSetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringCmpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringEqualCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringFirstCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringIndexCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringLastCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringLenCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringMapCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringMatchCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileStringRangeCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileSubstCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileSwitchCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileTailcallCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileThrowCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileTryCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileUnsetCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileUpvarCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileVariableCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileWhileCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileYieldCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+
+MODULE_SCOPE int	TclInvertOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileInvertOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclNotOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileNotOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclAddOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileAddOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclMulOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileMulOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclAndOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileAndOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclOrOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileOrOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclXorOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileXorOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclPowOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompilePowOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclLshiftOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileLshiftOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclRshiftOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileRshiftOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclModOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileModOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclNeqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileNeqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclStrneqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileStrneqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclInOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileInOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclNiOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileNiOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclMinusOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileMinusOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclDivOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileDivOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclLessOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileLessOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclLeqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileLeqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclGreaterOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileGreaterOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclGeqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileGeqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclEqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileEqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclStreqOpCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	TclCompileStreqOpCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+			    
+MODULE_SCOPE int	TclCompileAssembleCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
+
+/*
+ * Functions defined in generic/tclVar.c and currenttly exported only for use
+ * by the bytecode compiler and engine. Some of these could later be placed in
+ * the public interface.
+ */
+
+MODULE_SCOPE Var *	TclObjLookupVarEx(Tcl_Interp * interp,
+			    Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, int flags,
+			    const char *msg, const int createPart1,
+			    const int createPart2, Var **arrayPtrPtr);
+MODULE_SCOPE Var *	TclLookupArrayElement(Tcl_Interp *interp,
+			    Tcl_Obj *arrayNamePtr, Tcl_Obj *elNamePtr,
+			    const int flags, const char *msg,
+			    const int createPart1, const int createPart2,
+			    Var *arrayPtr, int index);
+MODULE_SCOPE Tcl_Obj *	TclPtrGetVar(Tcl_Interp *interp,
+			    Var *varPtr, Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, const int flags, int index);
+MODULE_SCOPE Tcl_Obj *	TclPtrSetVar(Tcl_Interp *interp,
+			    Var *varPtr, Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, Tcl_Obj *newValuePtr,
+			    const int flags, int index);
+MODULE_SCOPE Tcl_Obj *	TclPtrIncrObjVar(Tcl_Interp *interp,
+			    Var *varPtr, Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, Tcl_Obj *incrPtr,
+			    const int flags, int index);
+MODULE_SCOPE int	TclPtrObjMakeUpvar(Tcl_Interp *interp, Var *otherPtr,
+			    Tcl_Obj *myNamePtr, int myFlags, int index);
+MODULE_SCOPE int	TclPtrUnsetVar(Tcl_Interp *interp, Var *varPtr,
+			    Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, const int flags,
+			    int index);
+MODULE_SCOPE void	TclInvalidateNsPath(Namespace *nsPtr);
+
+/*
+ * The new extended interface to the variable traces.
+ */
+
+MODULE_SCOPE int	TclObjCallVarTraces(Interp *iPtr, Var *arrayPtr,
+			    Var *varPtr, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr,
+			    int flags, int leaveErrMsg, int index);
+
+/*
+ * So tclObj.c and tclDictObj.c can share these implementations.
+ */
+
+MODULE_SCOPE int	TclCompareObjKeys(void *keyPtr, Tcl_HashEntry *hPtr);
+MODULE_SCOPE void	TclFreeObjEntry(Tcl_HashEntry *hPtr);
+MODULE_SCOPE unsigned	TclHashObjKey(Tcl_HashTable *tablePtr, void *keyPtr);
+
+MODULE_SCOPE int	TclFullFinalizationRequested(void);
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to create and release Tcl objects.
+ * TclNewObj(objPtr) creates a new object denoting an empty string.
+ * TclDecrRefCount(objPtr) decrements the object's reference count, and frees
+ * the object if its reference count is zero. These macros are inline versions
+ * of Tcl_NewObj() and Tcl_DecrRefCount(). Notice that the names differ in not
+ * having a "_" after the "Tcl". Notice also that these macros reference their
+ * argument more than once, so you should avoid calling them with an
+ * expression that is expensive to compute or has side effects. The ANSI C
+ * "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclNewObj(Tcl_Obj *objPtr);
+ * MODULE_SCOPE void	TclDecrRefCount(Tcl_Obj *objPtr);
+ *
+ * These macros are defined in terms of two macros that depend on memory
+ * allocator in use: TclAllocObjStorage, TclFreeObjStorage. They are defined
+ * below.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * DTrace object allocation probe macros.
+ */
+
+#ifdef USE_DTRACE
+#ifndef _TCLDTRACE_H
+typedef const char *TclDTraceStr;
+#include "tclDTrace.h"
+#endif
+#define	TCL_DTRACE_OBJ_CREATE(objPtr)	TCL_OBJ_CREATE(objPtr)
+#define	TCL_DTRACE_OBJ_FREE(objPtr)	TCL_OBJ_FREE(objPtr)
+#else /* USE_DTRACE */
+#define	TCL_DTRACE_OBJ_CREATE(objPtr)	{}
+#define	TCL_DTRACE_OBJ_FREE(objPtr)	{}
+#endif /* USE_DTRACE */
+
+#ifdef TCL_COMPILE_STATS
+#  define TclIncrObjsAllocated() \
+    tclObjsAlloced++
+#  define TclIncrObjsFreed() \
+    tclObjsFreed++
+#else
+#  define TclIncrObjsAllocated()
+#  define TclIncrObjsFreed()
+#endif /* TCL_COMPILE_STATS */
+
+#  define TclAllocObjStorage(objPtr)		\
+	TclAllocObjStorageEx(NULL, (objPtr))
+
+#  define TclFreeObjStorage(objPtr)		\
+	TclFreeObjStorageEx(NULL, (objPtr))
+
+#ifndef TCL_MEM_DEBUG
+# define TclNewObj(objPtr) \
+    TclIncrObjsAllocated(); \
+    TclAllocObjStorage(objPtr); \
+    (objPtr)->refCount = 0; \
+    (objPtr)->bytes    = tclEmptyStringRep; \
+    (objPtr)->length   = 0; \
+    (objPtr)->typePtr  = NULL; \
+    TCL_DTRACE_OBJ_CREATE(objPtr)
+
+/*
+ * Invalidate the string rep first so we can use the bytes value for our
+ * pointer chain, and signal an obj deletion (as opposed to shimmering) with
+ * 'length == -1'.
+ * Use empty 'if ; else' to handle use in unbraced outer if/else conditions.
+ */
+
+# define TclDecrRefCount(objPtr) \
+    if (--(objPtr)->refCount > 0) ; else { \
+	if (!(objPtr)->typePtr || !(objPtr)->typePtr->freeIntRepProc) { \
+	    TCL_DTRACE_OBJ_FREE(objPtr); \
+	    if ((objPtr)->bytes \
+		    && ((objPtr)->bytes != tclEmptyStringRep)) { \
+		ckfree((char *) (objPtr)->bytes); \
+	    } \
+	    (objPtr)->length = -1; \
+	    TclFreeObjStorage(objPtr); \
+	    TclIncrObjsFreed(); \
+	} else { \
+	    TclFreeObj(objPtr); \
+	} \
+    }
+
+#if defined(PURIFY)
+
+/*
+ * The PURIFY mode is like the regular mode, but instead of doing block
+ * Tcl_Obj allocation and keeping a freed list for efficiency, it always
+ * allocates and frees a single Tcl_Obj so that tools like Purify can better
+ * track memory leaks.
+ */
+
+#  define TclAllocObjStorageEx(interp, objPtr) \
+	(objPtr) = (Tcl_Obj *) Tcl_Alloc(sizeof(Tcl_Obj))
+
+#  define TclFreeObjStorageEx(interp, objPtr) \
+	ckfree((char *) (objPtr))
+
+#undef USE_THREAD_ALLOC
+#elif defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)
+
+/*
+ * The TCL_THREADS mode is like the regular mode but allocates Tcl_Obj's from
+ * per-thread caches.
+ */
+
+MODULE_SCOPE Tcl_Obj *	TclThreadAllocObj(void);
+MODULE_SCOPE void	TclThreadFreeObj(Tcl_Obj *);
+MODULE_SCOPE Tcl_Mutex *TclpNewAllocMutex(void);
+MODULE_SCOPE void	TclFreeAllocCache(void *);
+MODULE_SCOPE void *	TclpGetAllocCache(void);
+MODULE_SCOPE void	TclpSetAllocCache(void *);
+MODULE_SCOPE void	TclpFreeAllocMutex(Tcl_Mutex *mutex);
+MODULE_SCOPE void	TclpFreeAllocCache(void *);
+
+/*
+ * These macros need to be kept in sync with the code of TclThreadAllocObj()
+ * and TclThreadFreeObj().
+ *
+ * Note that the optimiser should resolve the case (interp==NULL) at compile
+ * time.
+ */
+
+#  define ALLOC_NOBJHIGH 1200
+
+#  define TclAllocObjStorageEx(interp, objPtr)				\
+    do {								\
+	AllocCache *cachePtr;						\
+	if (((interp) == NULL) ||					\
+		((cachePtr = ((Interp *)(interp))->allocCache),		\
+			(cachePtr->numObjects == 0))) {			\
+	    (objPtr) = TclThreadAllocObj();				\
+	} else {							\
+	    (objPtr) = cachePtr->firstObjPtr;				\
+	    cachePtr->firstObjPtr = (objPtr)->internalRep.otherValuePtr; \
+	    --cachePtr->numObjects;					\
+	}								\
+    } while (0)
+
+#  define TclFreeObjStorageEx(interp, objPtr)				\
+    do {								\
+	AllocCache *cachePtr;						\
+	if (((interp) == NULL) ||					\
+		((cachePtr = ((Interp *)(interp))->allocCache),		\
+			(cachePtr->numObjects >= ALLOC_NOBJHIGH))) {	\
+	    TclThreadFreeObj(objPtr);					\
+	} else {							\
+	    (objPtr)->internalRep.otherValuePtr = cachePtr->firstObjPtr; \
+	    cachePtr->firstObjPtr = objPtr;				\
+	    ++cachePtr->numObjects;					\
+	}								\
+    } while (0)
+
+#else /* not PURIFY or USE_THREAD_ALLOC */
+
+#if defined(USE_TCLALLOC) && USE_TCLALLOC
+    MODULE_SCOPE void TclFinalizeAllocSubsystem();
+    MODULE_SCOPE void TclInitAlloc();
+#else
+#   define USE_TCLALLOC 0
+#endif
+
+#ifdef TCL_THREADS
+/* declared in tclObj.c */
+MODULE_SCOPE Tcl_Mutex	tclObjMutex;
+#endif
+
+#  define TclAllocObjStorageEx(interp, objPtr) \
+    do {								\
+	Tcl_MutexLock(&tclObjMutex);					\
+	if (tclFreeObjList == NULL) {					\
+	    TclAllocateFreeObjects();					\
+	}								\
+	(objPtr) = tclFreeObjList;					\
+	tclFreeObjList = (Tcl_Obj *)					\
+		tclFreeObjList->internalRep.otherValuePtr;		\
+	Tcl_MutexUnlock(&tclObjMutex);					\
+    } while (0)
+
+#  define TclFreeObjStorageEx(interp, objPtr) \
+    do {							       \
+	Tcl_MutexLock(&tclObjMutex);				       \
+	(objPtr)->internalRep.otherValuePtr = (void *) tclFreeObjList; \
+	tclFreeObjList = (objPtr);				       \
+	Tcl_MutexUnlock(&tclObjMutex);				       \
+    } while (0)
+#endif
+
+#else /* TCL_MEM_DEBUG */
+MODULE_SCOPE void	TclDbInitNewObj(Tcl_Obj *objPtr, const char *file,
+			    int line);
+
+# define TclDbNewObj(objPtr, file, line) \
+    do { \
+	TclIncrObjsAllocated();						\
+	(objPtr) = (Tcl_Obj *)						\
+		Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line));		\
+	TclDbInitNewObj((objPtr), (file), (line));			\
+	TCL_DTRACE_OBJ_CREATE(objPtr);					\
+    } while (0)
+
+# define TclNewObj(objPtr) \
+    TclDbNewObj(objPtr, __FILE__, __LINE__);
+
+# define TclDecrRefCount(objPtr) \
+    Tcl_DbDecrRefCount(objPtr, __FILE__, __LINE__)
+
+# define TclNewListObjDirect(objc, objv) \
+    TclDbNewListObjDirect(objc, objv, __FILE__, __LINE__)
+
+#undef USE_THREAD_ALLOC
+#endif /* TCL_MEM_DEBUG */
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to set a Tcl_Obj's string representation to a
+ * copy of the "len" bytes starting at "bytePtr". This code works even if the
+ * byte array contains NULLs as long as the length is correct. Because "len"
+ * is referenced multiple times, it should be as simple an expression as
+ * possible. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void TclInitStringRep(Tcl_Obj *objPtr, char *bytePtr, int len);
+ *
+ * This macro should only be called on an unshared objPtr where
+ *  objPtr->typePtr->freeIntRepProc == NULL
+ *----------------------------------------------------------------
+ */
+
+#define TclInitStringRep(objPtr, bytePtr, len) \
+    if ((len) == 0) { \
+	(objPtr)->bytes	 = tclEmptyStringRep; \
+	(objPtr)->length = 0; \
+    } else { \
+	(objPtr)->bytes = (char *) ckalloc((unsigned) ((len) + 1)); \
+	memcpy((objPtr)->bytes, (bytePtr), (unsigned) (len)); \
+	(objPtr)->bytes[len] = '\0'; \
+	(objPtr)->length = (len); \
+    }
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to get the string representation's byte array
+ * pointer from a Tcl_Obj. This is an inline version of Tcl_GetString(). The
+ * macro's expression result is the string rep's byte pointer which might be
+ * NULL. The bytes referenced by this pointer must not be modified by the
+ * caller. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE char *	TclGetString(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclGetString(objPtr) \
+    ((objPtr)->bytes? (objPtr)->bytes : Tcl_GetString((objPtr)))
+
+#define TclGetStringFromObj(objPtr, lenPtr) \
+    ((objPtr)->bytes \
+	    ? (*(lenPtr) = (objPtr)->length, (objPtr)->bytes)	\
+	    : Tcl_GetStringFromObj((objPtr), (lenPtr)))
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to clean out an object's internal
+ * representation. Does not actually reset the rep's bytes. The ANSI C
+ * "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclFreeIntRep(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclFreeIntRep(objPtr) \
+    if ((objPtr)->typePtr != NULL) { \
+	if ((objPtr)->typePtr->freeIntRepProc != NULL) { \
+	    (objPtr)->typePtr->freeIntRepProc(objPtr); \
+	} \
+	(objPtr)->typePtr = NULL; \
+    }
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to clean out an object's string representation.
+ * The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclInvalidateStringRep(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclInvalidateStringRep(objPtr) \
+    if (objPtr->bytes != NULL) { \
+	if (objPtr->bytes != tclEmptyStringRep) { \
+	    ckfree((char *) objPtr->bytes); \
+	} \
+	objPtr->bytes = NULL; \
+    }
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to grow Tcl_Token arrays. They use the same
+ * growth algorithm as used in tclStringObj.c for growing strings. The ANSI C
+ * "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclGrowTokenArray(Tcl_Token *tokenPtr, int used,
+ *				int available, int append,
+ *				Tcl_Token *staticPtr);
+ * MODULE_SCOPE void	TclGrowParseTokenArray(Tcl_Parse *parsePtr,
+ *				int append);
+ *----------------------------------------------------------------
+ */
+
+/* General tuning for minimum growth in Tcl growth algorithms */
+#ifndef TCL_MIN_GROWTH
+#  ifdef TCL_GROWTH_MIN_ALLOC
+     /* Support for any legacy tuners */
+#    define TCL_MIN_GROWTH TCL_GROWTH_MIN_ALLOC
+#  else
+#    define TCL_MIN_GROWTH 1024
+#  endif
+#endif
+
+/* Token growth tuning, default to the general value. */
+#ifndef TCL_MIN_TOKEN_GROWTH
+#define TCL_MIN_TOKEN_GROWTH TCL_MIN_GROWTH/sizeof(Tcl_Token)
+#endif
+
+#define TCL_MAX_TOKENS (int)(UINT_MAX / sizeof(Tcl_Token))
+#define TclGrowTokenArray(tokenPtr, used, available, append, staticPtr)	\
+    do {								\
+	int needed = (used) + (append);					\
+	if (needed > TCL_MAX_TOKENS) {					\
+	    Tcl_Panic("max # of tokens for a Tcl parse (%d) exceeded",	\
+		    TCL_MAX_TOKENS);					\
+	}								\
+	if (needed > (available)) {					\
+	    int allocated = 2 * needed;					\
+	    Tcl_Token *oldPtr = (tokenPtr);				\
+	    Tcl_Token *newPtr;						\
+	    if (oldPtr == (staticPtr)) {				\
+		oldPtr = NULL;						\
+	    }								\
+	    if (allocated > TCL_MAX_TOKENS) {				\
+		allocated = TCL_MAX_TOKENS;				\
+	    }								\
+	    newPtr = (Tcl_Token *) attemptckrealloc((char *) oldPtr,	\
+		    (unsigned int) (allocated * sizeof(Tcl_Token)));	\
+	    if (newPtr == NULL) {					\
+		allocated = needed + (append) + TCL_MIN_TOKEN_GROWTH;	\
+		if (allocated > TCL_MAX_TOKENS) {			\
+		    allocated = TCL_MAX_TOKENS;				\
+		}							\
+		newPtr = (Tcl_Token *) ckrealloc((char *) oldPtr,	\
+			(unsigned int) (allocated * sizeof(Tcl_Token))); \
+	    }								\
+	    (available) = allocated;					\
+	    if (oldPtr == NULL) {					\
+		memcpy(newPtr, staticPtr,				\
+			(size_t) ((used) * sizeof(Tcl_Token)));		\
+	    }								\
+	    (tokenPtr) = newPtr;					\
+	}								\
+    } while (0)
+
+#define TclGrowParseTokenArray(parsePtr, append)			\
+    TclGrowTokenArray((parsePtr)->tokenPtr, (parsePtr)->numTokens,	\
+	    (parsePtr)->tokensAvailable, (append),			\
+	    (parsePtr)->staticTokens)
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core get a unicode char from a utf string. It checks
+ * to see if we have a one-byte utf char before calling the real
+ * Tcl_UtfToUniChar, as this will save a lot of time for primarily ASCII
+ * string handling. The macro's expression result is 1 for the 1-byte case or
+ * the result of Tcl_UtfToUniChar. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int	TclUtfToUniChar(const char *string, Tcl_UniChar *ch);
+ *----------------------------------------------------------------
+ */
+
+#define TclUtfToUniChar(str, chPtr) \
+	((((unsigned char) *(str)) < 0xC0) ?		\
+	    ((*(chPtr) = (Tcl_UniChar) *(str)), 1)	\
+	    : Tcl_UtfToUniChar(str, chPtr))
+
+/*
+ *----------------------------------------------------------------
+ * Macro counterpart of the Tcl_NumUtfChars() function. To be used in speed-
+ * -sensitive points where it pays to avoid a function call in the common case
+ * of counting along a string of all one-byte characters.  The ANSI C
+ * "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclNumUtfChars(int numChars, const char *bytes,
+ *				int numBytes);
+ *----------------------------------------------------------------
+ */
+
+#define TclNumUtfChars(numChars, bytes, numBytes) \
+    do { \
+	int count, i = (numBytes); \
+	unsigned char *str = (unsigned char *) (bytes); \
+	while (i && (*str < 0xC0)) { i--; str++; } \
+	count = (numBytes) - i; \
+	if (i) { \
+	    count += Tcl_NumUtfChars((bytes) + count, i); \
+	} \
+	(numChars) = count; \
+    } while (0);
+
+/*
+ *----------------------------------------------------------------
+ * Macro that encapsulates the logic that determines when it is safe to
+ * interpret a string as a byte array directly. In summary, the object must be
+ * a byte array and must not have a string representation (as the operations
+ * that it is used in are defined on strings, not byte arrays). Theoretically
+ * it is possible to also be efficient in the case where the object's bytes
+ * field is filled by generation from the byte array (c.f. list canonicality)
+ * but we don't do that at the moment since this is purely about efficiency.
+ * The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int	TclIsPureByteArray(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclIsPureByteArray(objPtr) \
+	(((objPtr)->typePtr==&tclByteArrayType) && ((objPtr)->bytes==NULL))
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to compare Unicode strings. On big-endian
+ * systems we can use the more efficient memcmp, but this would not be
+ * lexically correct on little-endian systems. The ANSI C "prototype" for
+ * this macro is:
+ *
+ * MODULE_SCOPE int	TclUniCharNcmp(const Tcl_UniChar *cs,
+ *			    const Tcl_UniChar *ct, unsigned long n);
+ *----------------------------------------------------------------
+ */
+
+#ifdef WORDS_BIGENDIAN
+#   define TclUniCharNcmp(cs,ct,n) memcmp((cs),(ct),(n)*sizeof(Tcl_UniChar))
+#else /* !WORDS_BIGENDIAN */
+#   define TclUniCharNcmp Tcl_UniCharNcmp
+#endif /* WORDS_BIGENDIAN */
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to increment a namespace's export export epoch
+ * counter. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclInvalidateNsCmdLookup(Namespace *nsPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclInvalidateNsCmdLookup(nsPtr) \
+    if ((nsPtr)->numExportPatterns) {		\
+	(nsPtr)->exportLookupEpoch++;		\
+    }						\
+    if ((nsPtr)->commandPathLength) {		\
+	(nsPtr)->cmdRefEpoch++;			\
+    }
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Core procedures added to libtommath for bignum manipulation.
+ *
+ *----------------------------------------------------------------------
+ */
+
+MODULE_SCOPE Tcl_PackageInitProc TclTommath_Init;
+MODULE_SCOPE void	TclBNInitBignumFromLong(mp_int *bignum, long initVal);
+MODULE_SCOPE void	TclBNInitBignumFromWideInt(mp_int *bignum,
+			    Tcl_WideInt initVal);
+MODULE_SCOPE void	TclBNInitBignumFromWideUInt(mp_int *bignum,
+			    Tcl_WideUInt initVal);
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * External (platform specific) initialization routine, these declarations
+ * explicitly don't use EXTERN since this code does not get compiled into the
+ * library:
+ *
+ *----------------------------------------------------------------------
+ */
+
+MODULE_SCOPE Tcl_PackageInitProc TclplatformtestInit;
+MODULE_SCOPE Tcl_PackageInitProc TclObjTest_Init;
+MODULE_SCOPE Tcl_PackageInitProc TclThread_Init;
+MODULE_SCOPE Tcl_PackageInitProc Procbodytest_Init;
+MODULE_SCOPE Tcl_PackageInitProc Procbodytest_SafeInit;
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to check whether a pattern has any characters
+ * special to [string match]. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int	TclMatchIsTrivial(const char *pattern);
+ *----------------------------------------------------------------
+ */
+
+#define TclMatchIsTrivial(pattern) \
+    (strpbrk((pattern), "*[?\\") == NULL)
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to set a Tcl_Obj's numeric representation
+ * avoiding the corresponding function calls in time critical parts of the
+ * core. They should only be called on unshared objects. The ANSI C
+ * "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclSetIntObj(Tcl_Obj *objPtr, int intValue);
+ * MODULE_SCOPE void	TclSetLongObj(Tcl_Obj *objPtr, long longValue);
+ * MODULE_SCOPE void	TclSetBooleanObj(Tcl_Obj *objPtr, long boolValue);
+ * MODULE_SCOPE void	TclSetWideIntObj(Tcl_Obj *objPtr, Tcl_WideInt w);
+ * MODULE_SCOPE void	TclSetDoubleObj(Tcl_Obj *objPtr, double d);
+ *----------------------------------------------------------------
+ */
+
+#define TclSetIntObj(objPtr, i) \
+    do {						\
+	TclInvalidateStringRep(objPtr);			\
+	TclFreeIntRep(objPtr);				\
+	(objPtr)->internalRep.longValue = (long)(i);	\
+	(objPtr)->typePtr = &tclIntType;		\
+    } while (0)
+
+#define TclSetLongObj(objPtr, l) \
+    TclSetIntObj((objPtr), (l))
+
+/*
+ * NOTE: There is to be no such thing as a "pure" boolean. Boolean values set
+ * programmatically go straight to being "int" Tcl_Obj's, with value 0 or 1.
+ * The only "boolean" Tcl_Obj's shall be those holding the cached boolean
+ * value of strings like: "yes", "no", "true", "false", "on", "off".
+ */
+
+#define TclSetBooleanObj(objPtr, b) \
+    TclSetIntObj((objPtr), ((b)? 1 : 0));
+
+#ifndef NO_WIDE_TYPE
+#define TclSetWideIntObj(objPtr, w) \
+    do {							\
+	TclInvalidateStringRep(objPtr);				\
+	TclFreeIntRep(objPtr);					\
+	(objPtr)->internalRep.wideValue = (Tcl_WideInt)(w);	\
+	(objPtr)->typePtr = &tclWideIntType;			\
+    } while (0)
+#endif
+
+#define TclSetDoubleObj(objPtr, d) \
+    do {							\
+	TclInvalidateStringRep(objPtr);				\
+	TclFreeIntRep(objPtr);					\
+	(objPtr)->internalRep.doubleValue = (double)(d);	\
+	(objPtr)->typePtr = &tclDoubleType;			\
+    } while (0)
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to create and initialise objects of standard
+ * types, avoiding the corresponding function calls in time critical parts of
+ * the core. The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclNewIntObj(Tcl_Obj *objPtr, int i);
+ * MODULE_SCOPE void	TclNewLongObj(Tcl_Obj *objPtr, long l);
+ * MODULE_SCOPE void	TclNewBooleanObj(Tcl_Obj *objPtr, int b);
+ * MODULE_SCOPE void	TclNewWideObj(Tcl_Obj *objPtr, Tcl_WideInt w);
+ * MODULE_SCOPE void	TclNewDoubleObj(Tcl_Obj *objPtr, double d);
+ * MODULE_SCOPE void	TclNewStringObj(Tcl_Obj *objPtr, char *s, int len);
+ * MODULE_SCOPE void	TclNewLiteralStringObj(Tcl_Obj*objPtr, char*sLiteral);
+ *
+ *----------------------------------------------------------------
+ */
+
+#ifndef TCL_MEM_DEBUG
+#define TclNewIntObj(objPtr, i) \
+    do {						\
+	TclIncrObjsAllocated();				\
+	TclAllocObjStorage(objPtr);			\
+	(objPtr)->refCount = 0;				\
+	(objPtr)->bytes = NULL;				\
+	(objPtr)->internalRep.longValue = (long)(i);	\
+	(objPtr)->typePtr = &tclIntType;		\
+	TCL_DTRACE_OBJ_CREATE(objPtr);			\
+    } while (0)
+
+#define TclNewLongObj(objPtr, l) \
+    TclNewIntObj((objPtr), (l))
+
+/*
+ * NOTE: There is to be no such thing as a "pure" boolean.
+ * See comment above TclSetBooleanObj macro above.
+ */
+#define TclNewBooleanObj(objPtr, b) \
+    TclNewIntObj((objPtr), ((b)? 1 : 0))
+
+#define TclNewDoubleObj(objPtr, d) \
+    do {							\
+	TclIncrObjsAllocated();					\
+	TclAllocObjStorage(objPtr);				\
+	(objPtr)->refCount = 0;					\
+	(objPtr)->bytes = NULL;					\
+	(objPtr)->internalRep.doubleValue = (double)(d);	\
+	(objPtr)->typePtr = &tclDoubleType;			\
+	TCL_DTRACE_OBJ_CREATE(objPtr);				\
+    } while (0)
+
+#define TclNewStringObj(objPtr, s, len) \
+    do {							\
+	TclIncrObjsAllocated();					\
+	TclAllocObjStorage(objPtr);				\
+	(objPtr)->refCount = 0;					\
+	TclInitStringRep((objPtr), (s), (len));			\
+	(objPtr)->typePtr = NULL;				\
+	TCL_DTRACE_OBJ_CREATE(objPtr);				\
+    } while (0)
+
+#else /* TCL_MEM_DEBUG */
+#define TclNewIntObj(objPtr, i) \
+    (objPtr) = Tcl_NewIntObj(i)
+
+#define TclNewLongObj(objPtr, l) \
+    (objPtr) = Tcl_NewLongObj(l)
+
+#define TclNewBooleanObj(objPtr, b) \
+    (objPtr) = Tcl_NewBooleanObj(b)
+
+#define TclNewDoubleObj(objPtr, d) \
+    (objPtr) = Tcl_NewDoubleObj(d)
+
+#define TclNewStringObj(objPtr, s, len) \
+    (objPtr) = Tcl_NewStringObj((s), (len))
+#endif /* TCL_MEM_DEBUG */
+
+/*
+ * The sLiteral argument *must* be a string literal; the incantation with
+ * sizeof(sLiteral "") will fail to compile otherwise.
+ */
+#define TclNewLiteralStringObj(objPtr, sLiteral) \
+    TclNewStringObj((objPtr), (sLiteral), (int) (sizeof(sLiteral "") - 1))
+
+/*
+ *----------------------------------------------------------------
+ * Convenience macros for DStrings.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE char * TclDStringAppendLiteral(Tcl_DString *dsPtr,
+ *			const char *sLiteral);
+ * MODULE_SCOPE void   TclDStringClear(Tcl_DString *dsPtr);
+ */
+
+#define TclDStringAppendLiteral(dsPtr, sLiteral) \
+    Tcl_DStringAppend((dsPtr), (sLiteral), (int) (sizeof(sLiteral "") - 1))
+#define TclDStringClear(dsPtr) \
+    Tcl_DStringSetLength((dsPtr), 0)
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to test for some special double values.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE int	TclIsInfinite(double d);
+ * MODULE_SCOPE int	TclIsNaN(double d);
+ */
+
+#ifdef _MSC_VER
+#    define TclIsInfinite(d)	(!(_finite((d))))
+#    define TclIsNaN(d)		(_isnan((d)))
+#else
+#    define TclIsInfinite(d)	((d) > DBL_MAX || (d) < -DBL_MAX)
+#    ifdef NO_ISNAN
+#	 define TclIsNaN(d)	((d) != (d))
+#    else
+#	 define TclIsNaN(d)	(isnan(d))
+#    endif
+#endif
+
+/*
+ * ----------------------------------------------------------------------
+ * Macro to use to find the offset of a field in a structure. Computes number
+ * of bytes from beginning of structure to a given field.
+ */
+
+#ifdef offsetof
+#define TclOffset(type, field) ((int) offsetof(type, field))
+#else
+#define TclOffset(type, field) ((int) ((char *) &((type *) 0)->field))
+#endif
+
+/*
+ *----------------------------------------------------------------
+ * Inline version of Tcl_GetCurrentNamespace and Tcl_GetGlobalNamespace.
+ */
+
+#define TclGetCurrentNamespace(interp) \
+    (Tcl_Namespace *) ((Interp *)(interp))->varFramePtr->nsPtr
+
+#define TclGetGlobalNamespace(interp) \
+    (Tcl_Namespace *) ((Interp *)(interp))->globalNsPtr
+
+/*
+ *----------------------------------------------------------------
+ * Inline version of TclCleanupCommand; still need the function as it is in
+ * the internal stubs, but the core can use the macro instead.
+ */
+
+#define TclCleanupCommandMacro(cmdPtr) \
+    if (--(cmdPtr)->refCount <= 0) { \
+	ckfree((char *) (cmdPtr));\
+    }
+
+/*
+ *----------------------------------------------------------------
+ * Inline versions of Tcl_LimitReady() and Tcl_LimitExceeded to limit number
+ * of calls out of the critical path. Note that this code isn't particularly
+ * readable; the non-inline version (in tclInterp.c) is much easier to
+ * understand. Note also that these macros takes different args (iPtr->limit)
+ * to the non-inline version.
+ */
+
+#define TclLimitExceeded(limit) ((limit).exceeded != 0)
+
+#define TclLimitReady(limit)						\
+    (((limit).active == 0) ? 0 :					\
+    (++(limit).granularityTicker,					\
+    ((((limit).active & TCL_LIMIT_COMMANDS) &&				\
+	    (((limit).cmdGranularity == 1) ||				\
+	    ((limit).granularityTicker % (limit).cmdGranularity == 0)))	\
+	    ? 1 :							\
+    (((limit).active & TCL_LIMIT_TIME) &&				\
+	    (((limit).timeGranularity == 1) ||				\
+	    ((limit).granularityTicker % (limit).timeGranularity == 0)))\
+	    ? 1 : 0)))
+
+/*
+ * Compile-time assertions: these produce a compile time error if the
+ * expression is not known to be true at compile time. If the assertion is
+ * known to be false, the compiler (or optimizer?) will error out with
+ * "division by zero". If the assertion cannot be evaluated at compile time,
+ * the compiler will error out with "non-static initializer".
+ *
+ * Adapted with permission from
+ * http://www.pixelbeat.org/programming/gcc/static_assert.html
+ */
+
+#define TCL_CT_ASSERT(e) \
+    {enum { ct_assert_value = 1/(!!(e)) };}
+
+/*
+ *----------------------------------------------------------------
+ * Allocator for small structs (<=sizeof(Tcl_Obj)) using the Tcl_Obj pool.
+ * Only checked at compile time.
+ *
+ * ONLY USE FOR CONSTANT nBytes.
+ *
+ * DO NOT LET THEM CROSS THREAD BOUNDARIES
+ *----------------------------------------------------------------
+ */
+
+#define TclSmallAlloc(nbytes, memPtr) \
+    TclSmallAllocEx(NULL, (nbytes), (memPtr))
+
+#define TclSmallFree(memPtr) \
+    TclSmallFreeEx(NULL, (memPtr))
+
+#ifndef TCL_MEM_DEBUG
+#define TclSmallAllocEx(interp, nbytes, memPtr) \
+    do {								\
+	Tcl_Obj *objPtr;						\
+	TCL_CT_ASSERT((nbytes)<=sizeof(Tcl_Obj));			\
+	TclIncrObjsAllocated();						\
+	TclAllocObjStorageEx((interp), (objPtr));			\
+	memPtr = (ClientData) (objPtr);					\
+    } while (0)
+
+#define TclSmallFreeEx(interp, memPtr) \
+    do {								\
+	TclFreeObjStorageEx((interp), (Tcl_Obj *) (memPtr));		\
+	TclIncrObjsFreed();						\
+    } while (0)
+
+#else    /* TCL_MEM_DEBUG */
+#define TclSmallAllocEx(interp, nbytes, memPtr) \
+    do {								\
+	Tcl_Obj *objPtr;						\
+	TCL_CT_ASSERT((nbytes)<=sizeof(Tcl_Obj));			\
+	TclNewObj(objPtr);						\
+	memPtr = (ClientData) objPtr;					\
+    } while (0)
+
+#define TclSmallFreeEx(interp, memPtr) \
+    do {								\
+	Tcl_Obj *objPtr = (Tcl_Obj *) memPtr;				\
+	objPtr->bytes = NULL;						\
+	objPtr->typePtr = NULL;						\
+	objPtr->refCount = 1;						\
+	TclDecrRefCount(objPtr);					\
+    } while (0)
+#endif   /* TCL_MEM_DEBUG */
+
+/*
+ * Support for Clang Static Analyzer <http://clang-analyzer.llvm.org>
+ */
+
+#if defined(PURIFY) && defined(__clang__)
+#if __has_feature(attribute_analyzer_noreturn) && \
+	!defined(Tcl_Panic) && defined(Tcl_Panic_TCL_DECLARED)
+void Tcl_Panic(const char *, ...) __attribute__((analyzer_noreturn));
+#endif
+#if !defined(CLANG_ASSERT)
+#include <assert.h>
+#define CLANG_ASSERT(x) assert(x)
+#endif
+#elif !defined(CLANG_ASSERT)
+#define CLANG_ASSERT(x)
+#endif /* PURIFY && __clang__ */
+
+/*
+ *----------------------------------------------------------------
+ * Parameters, structs and macros for the non-recursive engine (NRE)
+ *----------------------------------------------------------------
+ */
+
+#define NRE_USE_SMALL_ALLOC	1  /* Only turn off for debugging purposes. */
+#define NRE_ENABLE_ASSERTS	1
+
+/*
+ * This is the main data struct for representing NR commands. It is designed
+ * to fit in sizeof(Tcl_Obj) in order to exploit the fastest memory allocator
+ * available.
+ */
+
+typedef struct NRE_callback {
+    Tcl_NRPostProc *procPtr;
+    ClientData data[4];
+    struct NRE_callback *nextPtr;
+} NRE_callback;
+
+#define TOP_CB(iPtr) (((Interp *)(iPtr))->execEnvPtr->callbackPtr)
+
+/*
+ * Inline version of Tcl_NRAddCallback.
+ */
+
+#define TclNRAddCallback(interp,postProcPtr,data0,data1,data2,data3) \
+    do {								\
+	NRE_callback *callbackPtr;					\
+	TCLNR_ALLOC((interp), (callbackPtr));				\
+	callbackPtr->procPtr = (postProcPtr);				\
+	callbackPtr->data[0] = (ClientData)(data0);			\
+	callbackPtr->data[1] = (ClientData)(data1);			\
+	callbackPtr->data[2] = (ClientData)(data2);			\
+	callbackPtr->data[3] = (ClientData)(data3);			\
+	callbackPtr->nextPtr = TOP_CB(interp);				\
+	TOP_CB(interp) = callbackPtr;					\
+    } while (0)
+
+#define TclNRDeferCallback(interp,postProcPtr,data0,data1,data2,data3) \
+    do {								\
+	NRE_callback *callbackPtr;					\
+	TCLNR_ALLOC((interp), (callbackPtr));				\
+	callbackPtr->procPtr = (postProcPtr);				\
+	callbackPtr->data[0] = (ClientData)(data0);			\
+	callbackPtr->data[1] = (ClientData)(data1);			\
+	callbackPtr->data[2] = (ClientData)(data2);			\
+	callbackPtr->data[3] = (ClientData)(data3);			\
+	callbackPtr->nextPtr = ((Interp *)interp)->deferredCallbacks;	\
+	((Interp *)interp)->deferredCallbacks = callbackPtr;		\
+    } while (0)
+
+#define TclNRSpliceCallbacks(interp, topPtr) \
+    do {					\
+	NRE_callback *bottomPtr = topPtr;	\
+	while (bottomPtr->nextPtr) {		\
+	    bottomPtr = bottomPtr->nextPtr;	\
+	}					\
+	bottomPtr->nextPtr = TOP_CB(interp);	\
+	TOP_CB(interp) = topPtr;		\
+    } while (0)
+
+#define TclNRSpliceDeferred(interp)					\
+    if (((Interp *)interp)->deferredCallbacks) {			\
+	TclNRSpliceCallbacks(interp, ((Interp *)interp)->deferredCallbacks); \
+	((Interp *)interp)->deferredCallbacks = NULL;			\
+    }
+
+#if NRE_USE_SMALL_ALLOC
+#define TCLNR_ALLOC(interp, ptr) \
+    TclSmallAllocEx(interp, sizeof(NRE_callback), (ptr))
+#define TCLNR_FREE(interp, ptr)  TclSmallFreeEx((interp), (ptr))
+#else
+#define TCLNR_ALLOC(interp, ptr) \
+    (ptr = ((ClientData) ckalloc(sizeof(NRE_callback))))
+#define TCLNR_FREE(interp, ptr)  ckfree((char *) (ptr))
+#endif
+
+#if NRE_ENABLE_ASSERTS
+#define NRE_ASSERT(expr) assert((expr))
+#else
+#define NRE_ASSERT(expr)
+#endif
+
+#include "tclIntDecls.h"
+#include "tclIntPlatDecls.h"
+#include "tclTomMathDecls.h"
+
+#if !defined(USE_TCL_STUBS) && !defined(TCL_MEM_DEBUG)
+#define Tcl_AttemptAlloc(size)        TclpAlloc(size)
+#define Tcl_AttemptRealloc(ptr, size) TclpRealloc((ptr), (size))
+#define Tcl_Free(ptr)                 TclpFree(ptr)
+#endif
+
+#endif /* _TCLINT */
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 78
+ * End:
+ */
diff -uNr blt2.4z/src/tclPort.h blt2.4z.tcltk86/src/tclPort.h
--- blt2.4z/src/tclPort.h	1969-12-31 19:00:00.000000000 -0500
+++ blt2.4z.tcltk86/src/tclPort.h	2013-08-20 11:44:02.000000000 -0400
@@ -0,0 +1,44 @@
+/*
+ * tclPort.h --
+ *
+ *	This header file handles porting issues that occur because
+ *	of differences between systems.  It reads in platform specific
+ *	portability files.
+ *
+ * Copyright (c) 1994-1995 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TCLPORT
+#define _TCLPORT
+
+#ifdef HAVE_TCL_CONFIG_H
+#include "tclConfig.h"
+#endif
+#if defined(_WIN32)
+#   include "tclWinPort.h"
+#endif
+#include "tcl.h"
+#if !defined(_WIN32)
+#   include "../unix/tclUnixPort.h"
+#endif
+
+#if !defined(LLONG_MIN)
+#   ifdef TCL_WIDE_INT_IS_LONG
+#      define LLONG_MIN LONG_MIN
+#   else
+#      ifdef LLONG_BIT
+#         define LLONG_MIN ((Tcl_WideInt)(Tcl_LongAsWide(1)<<(LLONG_BIT-1)))
+#      else
+/* Assume we're on a system with a 64-bit 'long long' type */
+#         define LLONG_MIN ((Tcl_WideInt)(Tcl_LongAsWide(1)<<63))
+#      endif
+#   endif
+/* Assume that if LLONG_MIN is undefined, then so is LLONG_MAX */
+#   define LLONG_MAX (~LLONG_MIN)
+#endif
+
+
+#endif /* _TCLPORT */
diff -uNr blt2.4z/src/tk3d.h blt2.4z.tcltk86/src/tk3d.h
--- blt2.4z/src/tk3d.h	1969-12-31 19:00:00.000000000 -0500
+++ blt2.4z.tcltk86/src/tk3d.h	2013-08-20 11:45:41.000000000 -0400
@@ -0,0 +1,85 @@
+/*
+ * tk3d.h --
+ *
+ *	Declarations of types and functions shared by the 3d border module.
+ *
+ * Copyright (c) 1996-1997 by Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TK3D
+#define _TK3D
+
+#include "tkInt.h"
+
+/*
+ * One of the following data structures is allocated for each 3-D border
+ * currently in use. Structures of this type are indexed by borderTable, so
+ * that a single structure can be shared for several uses.
+ */
+
+typedef struct TkBorder {
+    Screen *screen;		/* Screen on which the border will be used. */
+    Visual *visual;		/* Visual for all windows and pixmaps using
+				 * the border. */
+    int depth;			/* Number of bits per pixel of drawables where
+				 * the border will be used. */
+    Colormap colormap;		/* Colormap out of which pixels are
+				 * allocated. */
+    int resourceRefCount;	/* Number of active uses of this color (each
+				 * active use corresponds to a call to
+				 * Tk_Alloc3DBorderFromObj or Tk_Get3DBorder).
+				 * If this count is 0, then this structure is
+				 * no longer valid and it isn't present in
+				 * borderTable: it is being kept around only
+				 * because there are objects referring to it.
+				 * The structure is freed when objRefCount and
+				 * resourceRefCount are both 0. */
+    int objRefCount;		/* The number of Tcl objects that reference
+				 * this structure. */
+    XColor *bgColorPtr;		/* Background color (intensity between
+				 * lightColorPtr and darkColorPtr). */
+    XColor *darkColorPtr;	/* Color for darker areas (must free when
+				 * deleting structure). NULL means shadows
+				 * haven't been allocated yet.*/
+    XColor *lightColorPtr;	/* Color used for lighter areas of border
+				 * (must free this when deleting structure).
+				 * NULL means shadows haven't been allocated
+				 * yet. */
+    Pixmap shadow;		/* Stipple pattern to use for drawing shadows
+				 * areas. Used for displays with <= 64 colors
+				 * or where colormap has filled up. */
+    GC bgGC;			/* Used (if necessary) to draw areas in the
+				 * background color. */
+    GC darkGC;			/* Used to draw darker parts of the border.
+				 * None means the shadow colors haven't been
+				 * allocated yet.*/
+    GC lightGC;			/* Used to draw lighter parts of the border.
+				 * None means the shadow colors haven't been
+				 * allocated yet. */
+    Tcl_HashEntry *hashPtr;	/* Entry in borderTable (needed in order to
+				 * delete structure). */
+    struct TkBorder *nextPtr;	/* Points to the next TkBorder structure with
+				 * the same color name. Borders with the same
+				 * name but different screens or colormaps are
+				 * chained together off a single entry in
+				 * borderTable. */
+} TkBorder;
+
+/*
+ * Maximum intensity for a color:
+ */
+
+#define MAX_INTENSITY 65535
+
+/*
+ * Declarations for platform specific interfaces used by this module.
+ */
+
+MODULE_SCOPE TkBorder	*TkpGetBorder(void);
+MODULE_SCOPE void	TkpGetShadows(TkBorder *borderPtr, Tk_Window tkwin);
+MODULE_SCOPE void	TkpFreeBorder(TkBorder *borderPtr);
+
+#endif /* _TK3D */
diff -uNr blt2.4z/src/tkButton.c blt2.4z.tcltk86/src/tkButton.c
--- blt2.4z/src/tkButton.c	2013-08-20 12:00:03.000000000 -0400
+++ blt2.4z.tcltk86/src/tkButton.c	2013-08-20 11:22:59.000000000 -0400
@@ -1895,7 +1895,7 @@
 #if TCL_MAJOR_VERSION <=8 && TCL_MINOR_VERSION < 6
 	return TkCopyAndGlobalEval(butPtr->interp, butPtr->command);
 #else
-	return Tcl_EvalObjEx(butPtr->interp, butPtr->command, TCL_EVAL_GLOBAL);
+	return Tcl_EvalObjEx(butPtr->interp, (struct Tcl_Obj *)butPtr->command, TCL_EVAL_GLOBAL);
 #endif
     }
     return TCL_OK;
diff -uNr blt2.4z/src/tkFont.h blt2.4z.tcltk86/src/tkFont.h
--- blt2.4z/src/tkFont.h	1969-12-31 19:00:00.000000000 -0500
+++ blt2.4z.tcltk86/src/tkFont.h	2013-08-20 11:45:52.000000000 -0400
@@ -0,0 +1,224 @@
+/*
+ * tkFont.h --
+ *
+ *	Declarations for interfaces between the generic and platform-specific
+ *	parts of the font package. This information is not visible outside of
+ *	the font package.
+ *
+ * Copyright (c) 1996-1997 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKFONT
+#define _TKFONT
+
+/*
+ * The following structure keeps track of the attributes of a font. It can be
+ * used to keep track of either the desired attributes or the actual
+ * attributes gotten when the font was instantiated.
+ */
+
+struct TkFontAttributes {
+    Tk_Uid family;		/* Font family, or NULL to represent plaform-
+				 * specific default system font. */
+    int size;			/* Pointsize of font, 0 for default size, or
+				 * negative number meaning pixel size. */
+    int weight;			/* Weight flag; see below for def'n. */
+    int slant;			/* Slant flag; see below for def'n. */
+    int underline;		/* Non-zero for underline font. */
+    int overstrike;		/* Non-zero for overstrike font. */
+};
+
+/*
+ * Possible values for the "weight" field in a TkFontAttributes structure.
+ * Weight is a subjective term and depends on what the company that created
+ * the font considers bold.
+ */
+
+#define TK_FW_NORMAL	0
+#define TK_FW_BOLD	1
+
+#define TK_FW_UNKNOWN	-1	/* Unknown weight. This value is used for
+				 * error checking and is never actually stored
+				 * in the weight field. */
+
+/*
+ * Possible values for the "slant" field in a TkFontAttributes structure.
+ */
+
+#define TK_FS_ROMAN	0
+#define TK_FS_ITALIC	1
+#define TK_FS_OBLIQUE	2	/* This value is only used when parsing X font
+				 * names to determine the closest match. It is
+				 * only stored in the XLFDAttributes
+				 * structure, never in the slant field of the
+				 * TkFontAttributes. */
+
+#define TK_FS_UNKNOWN	-1	/* Unknown slant. This value is used for error
+				 * checking and is never actually stored in
+				 * the slant field. */
+
+/*
+ * The following structure keeps track of the metrics for an instantiated
+ * font. The metrics are the physical properties of the font itself.
+ */
+
+typedef struct TkFontMetrics {
+    int	ascent;			/* From baseline to top of font. */
+    int	descent;		/* From baseline to bottom of font. */
+    int maxWidth;		/* Width of widest character in font. */
+    int fixed;			/* Non-zero if this is a fixed-width font,
+				 * 0 otherwise. */
+} TkFontMetrics;
+
+/*
+ * The following structure is used to keep track of the generic information
+ * about a font. Each platform-specific font is represented by a structure
+ * with the following structure at its beginning, plus any platform-specific
+ * stuff after that.
+ */
+
+typedef struct TkFont {
+    /*
+     * Fields used and maintained exclusively by generic code.
+     */
+
+    int resourceRefCount;	/* Number of active uses of this font (each
+				 * active use corresponds to a call to
+				 * Tk_AllocFontFromTable or Tk_GetFont). If
+				 * this count is 0, then this TkFont structure
+				 * is no longer valid and it isn't present in
+				 * a hash table: it is being kept around only
+				 * because there are objects referring to it.
+				 * The structure is freed when
+				 * resourceRefCount and objRefCount are both
+				 * 0. */
+    int objRefCount;		/* The number of Tcl objects that reference
+				 * this structure. */
+    Tcl_HashEntry *cacheHashPtr;/* Entry in font cache for this structure,
+				 * used when deleting it. */
+    Tcl_HashEntry *namedHashPtr;/* Pointer to hash table entry that
+				 * corresponds to the named font that the
+				 * tkfont was based on, or NULL if the tkfont
+				 * was not based on a named font. */
+    Screen *screen;		/* The screen where this font is valid. */
+    int tabWidth;		/* Width of tabs in this font (pixels). */
+    int	underlinePos;		/* Offset from baseline to origin of underline
+				 * bar (used for drawing underlines on a
+				 * non-underlined font). */
+    int underlineHeight;	/* Height of underline bar (used for drawing
+				 * underlines on a non-underlined font). */
+
+    /*
+     * Fields used in the generic code that are filled in by
+     * platform-specific code.
+     */
+
+    Font fid;			/* For backwards compatibility with XGCValues
+				 * structures. Remove when TkGCValues is
+				 * implemented. */
+    TkFontAttributes fa;	/* Actual font attributes obtained when the
+				 * the font was created, as opposed to the
+				 * desired attributes passed in to
+				 * TkpGetFontFromAttributes(). The desired
+				 * metrics can be determined from the string
+				 * that was used to create this font. */
+    TkFontMetrics fm;		/* Font metrics determined when font was
+				 * created. */
+    struct TkFont *nextPtr;	/* Points to the next TkFont structure with
+				 * the same name. All fonts with the same name
+				 * (but different displays) are chained
+				 * together off a single entry in a hash
+				 * table. */
+} TkFont;
+
+/*
+ * The following structure is used to return attributes when parsing an XLFD.
+ * The extra information is of interest to the Unix-specific code when
+ * attempting to find the closest matching font.
+ */
+
+typedef struct TkXLFDAttributes {
+    Tk_Uid foundry;		/* The foundry of the font. */
+    int slant;			/* The tristate value for the slant, which is
+				 * significant under X. */
+    int setwidth;		/* The proportionate width, see below for
+				 * definition. */
+    Tk_Uid charset;		/* The actual charset string. */
+} TkXLFDAttributes;
+
+/*
+ * Possible values for the "setwidth" field in a TkXLFDAttributes structure.
+ * The setwidth is whether characters are considered wider or narrower than
+ * normal.
+ */
+
+#define TK_SW_NORMAL	0
+#define TK_SW_CONDENSE	1
+#define TK_SW_EXPAND	2
+#define TK_SW_UNKNOWN	3	/* Unknown setwidth. This value may be stored
+				 * in the setwidth field. */
+
+/*
+ * The following defines specify the meaning of the fields in a fully
+ * qualified XLFD.
+ */
+
+#define XLFD_FOUNDRY	    0
+#define XLFD_FAMILY	    1
+#define XLFD_WEIGHT	    2
+#define XLFD_SLANT	    3
+#define XLFD_SETWIDTH	    4
+#define XLFD_ADD_STYLE	    5
+#define XLFD_PIXEL_SIZE	    6
+#define XLFD_POINT_SIZE	    7
+#define XLFD_RESOLUTION_X   8
+#define XLFD_RESOLUTION_Y   9
+#define XLFD_SPACING	    10
+#define XLFD_AVERAGE_WIDTH  11
+#define XLFD_CHARSET	    12
+#define XLFD_NUMFIELDS	    13	/* Number of fields in XLFD. */
+
+/*
+ * Helper macro. How to correctly round a double to a short.
+ */
+
+#define ROUND16(x)	((short) floor((x) + 0.5))
+
+/*
+ * Low-level API exported by generic code to platform-specific code.
+ */
+
+#define TkInitFontAttributes(fa)   memset((fa), 0, sizeof(TkFontAttributes));
+#define TkInitXLFDAttributes(xa)   memset((xa), 0, sizeof(TkXLFDAttributes));
+
+MODULE_SCOPE int	TkFontParseXLFD(const char *string,
+			    TkFontAttributes *faPtr, TkXLFDAttributes *xaPtr);
+MODULE_SCOPE const char *const * TkFontGetAliasList(const char *faceName);
+MODULE_SCOPE const char *const *const * TkFontGetFallbacks(void);
+MODULE_SCOPE int	TkFontGetPixels(Tk_Window tkwin, int size);
+MODULE_SCOPE int	TkFontGetPoints(Tk_Window tkwin, int size);
+MODULE_SCOPE const char *const * TkFontGetGlobalClass(void);
+MODULE_SCOPE const char *const * TkFontGetSymbolClass(void);
+MODULE_SCOPE int	TkCreateNamedFont(Tcl_Interp *interp, Tk_Window tkwin,
+			    const char *name, TkFontAttributes *faPtr);
+MODULE_SCOPE int	TkDeleteNamedFont(Tcl_Interp *interp,
+			    Tk_Window tkwin, const char *name);
+MODULE_SCOPE int	TkFontGetFirstTextLayout(Tk_TextLayout layout,
+			    Tk_Font *font, char *dst);
+
+/*
+ * Low-level API exported by platform-specific code to generic code.
+ */
+
+MODULE_SCOPE void	TkpDeleteFont(TkFont *tkFontPtr);
+MODULE_SCOPE void	TkpFontPkgInit(TkMainInfo *mainPtr);
+MODULE_SCOPE TkFont *	TkpGetFontFromAttributes(TkFont *tkFontPtr,
+			    Tk_Window tkwin, const TkFontAttributes *faPtr);
+MODULE_SCOPE void	TkpGetFontFamilies(Tcl_Interp *interp,
+			    Tk_Window tkwin);
+MODULE_SCOPE TkFont *	TkpGetNativeFont(Tk_Window tkwin, const char *name);
+
+#endif	/* _TKFONT */
diff -uNr blt2.4z/src/tkFrame.c blt2.4z.tcltk86/src/tkFrame.c
--- blt2.4z/src/tkFrame.c	2002-10-16 01:33:53.000000000 -0400
+++ blt2.4z.tcltk86/src/tkFrame.c	2013-08-20 11:46:20.000000000 -0400
@@ -116,7 +116,7 @@
     int flags;			/* Various flags;  see below for
 				 * definitions. */
     Blt_Tile tile;
-} Frame;
+} bltFrame;
 
 /*
  * Flag bits for frames:
@@ -143,65 +143,65 @@
 static Tk_ConfigSpec configSpecs[] =
 {
     {TK_CONFIG_BORDER, "-background", "background", "Background",
-	DEF_FRAME_BACKGROUND, Tk_Offset(Frame, border),
+	DEF_FRAME_BACKGROUND, Tk_Offset(bltFrame, border),
 	BOTH | TK_CONFIG_COLOR_ONLY | TK_CONFIG_NULL_OK},
     {TK_CONFIG_BORDER, "-background", "background", "Background",
-	DEF_FRAME_BG_MONO, Tk_Offset(Frame, border),
+	DEF_FRAME_BG_MONO, Tk_Offset(bltFrame, border),
 	BOTH | TK_CONFIG_MONO_ONLY | TK_CONFIG_NULL_OK},
     {TK_CONFIG_SYNONYM, "-bd", "borderWidth", (char *)NULL,
 	(char *)NULL, 0, BOTH},
     {TK_CONFIG_SYNONYM, "-bg", "background", (char *)NULL,
 	(char *)NULL, 0, BOTH},
     {TK_CONFIG_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
-	DEF_FRAME_BORDERWIDTH, Tk_Offset(Frame, borderWidth), BOTH},
+	DEF_FRAME_BORDERWIDTH, Tk_Offset(bltFrame, borderWidth), BOTH},
     {TK_CONFIG_STRING, "-class", "class", "Class",
-	DEF_FRAME_CLASS, Tk_Offset(Frame, className), FRAME},
+	DEF_FRAME_CLASS, Tk_Offset(bltFrame, className), FRAME},
     {TK_CONFIG_STRING, "-class", "class", "Class",
-	DEF_TOPLEVEL_CLASS, Tk_Offset(Frame, className), TOPLEVEL},
+	DEF_TOPLEVEL_CLASS, Tk_Offset(bltFrame, className), TOPLEVEL},
     {TK_CONFIG_STRING, "-colormap", "colormap", "Colormap",
-	DEF_FRAME_COLORMAP, Tk_Offset(Frame, colormapName),
+	DEF_FRAME_COLORMAP, Tk_Offset(bltFrame, colormapName),
 	BOTH | TK_CONFIG_NULL_OK},
 #if (TK_MAJOR_VERSION > 4)
     {TK_CONFIG_BOOLEAN, "-container", "container", "Container",
-	DEF_FRAME_CONTAINER, Tk_Offset(Frame, isContainer), BOTH},
+	DEF_FRAME_CONTAINER, Tk_Offset(bltFrame, isContainer), BOTH},
 #endif /* TK_MAJOR_VERSION > 4 */
     {TK_CONFIG_ACTIVE_CURSOR, "-cursor", "cursor", "Cursor",
-	DEF_FRAME_CURSOR, Tk_Offset(Frame, cursor), BOTH | TK_CONFIG_NULL_OK},
+	DEF_FRAME_CURSOR, Tk_Offset(bltFrame, cursor), BOTH | TK_CONFIG_NULL_OK},
     {TK_CONFIG_PIXELS, "-height", "height", "Height",
-	DEF_FRAME_HEIGHT, Tk_Offset(Frame, height), BOTH},
+	DEF_FRAME_HEIGHT, Tk_Offset(bltFrame, height), BOTH},
     {TK_CONFIG_COLOR, "-highlightbackground", "highlightBackground",
 	"HighlightBackground", DEF_FRAME_HIGHLIGHT_BG,
-	Tk_Offset(Frame, highlightBgColorPtr), BOTH},
+	Tk_Offset(bltFrame, highlightBgColorPtr), BOTH},
     {TK_CONFIG_COLOR, "-highlightcolor", "highlightColor", "HighlightColor",
-	DEF_FRAME_HIGHLIGHT, Tk_Offset(Frame, highlightColorPtr), BOTH},
+	DEF_FRAME_HIGHLIGHT, Tk_Offset(bltFrame, highlightColorPtr), BOTH},
     {TK_CONFIG_PIXELS, "-highlightthickness", "highlightThickness",
 	"HighlightThickness",
-	DEF_FRAME_HIGHLIGHT_WIDTH, Tk_Offset(Frame, highlightWidth), BOTH},
+	DEF_FRAME_HIGHLIGHT_WIDTH, Tk_Offset(bltFrame, highlightWidth), BOTH},
 #if (TK_MAJOR_VERSION > 4)
     {TK_CONFIG_STRING, "-menu", "menu", "Menu",
-	DEF_TOPLEVEL_MENU, Tk_Offset(Frame, menuName),
+	DEF_TOPLEVEL_MENU, Tk_Offset(bltFrame, menuName),
 	TOPLEVEL | TK_CONFIG_NULL_OK},
 #endif /* TK_MAJOR_VERSION > 4 */
     {TK_CONFIG_RELIEF, "-relief", "relief", "Relief",
-	DEF_FRAME_RELIEF, Tk_Offset(Frame, relief), BOTH},
+	DEF_FRAME_RELIEF, Tk_Offset(bltFrame, relief), BOTH},
     {TK_CONFIG_STRING, "-screen", "screen", "Screen",
-	DEF_TOPLEVEL_SCREEN, Tk_Offset(Frame, screenName),
+	DEF_TOPLEVEL_SCREEN, Tk_Offset(bltFrame, screenName),
 	TOPLEVEL | TK_CONFIG_NULL_OK},
     {TK_CONFIG_STRING, "-takefocus", "takeFocus", "TakeFocus",
-	DEF_FRAME_TAKE_FOCUS, Tk_Offset(Frame, takeFocus),
+	DEF_FRAME_TAKE_FOCUS, Tk_Offset(bltFrame, takeFocus),
 	BOTH | TK_CONFIG_NULL_OK},
     {TK_CONFIG_CUSTOM, "-tile", "tile", "Tile",
-	(char *)NULL, Tk_Offset(Frame, tile), BOTH | TK_CONFIG_NULL_OK,
+	(char *)NULL, Tk_Offset(bltFrame, tile), BOTH | TK_CONFIG_NULL_OK,
 	&bltTileOption},
 #if (TK_MAJOR_VERSION > 4)
     {TK_CONFIG_STRING, "-use", "use", "Use",
-	DEF_FRAME_USE, Tk_Offset(Frame, useThis), TOPLEVEL|TK_CONFIG_NULL_OK},
+	DEF_FRAME_USE, Tk_Offset(bltFrame, useThis), TOPLEVEL|TK_CONFIG_NULL_OK},
 #endif
     {TK_CONFIG_STRING, "-visual", "visual", "Visual",
-	DEF_FRAME_VISUAL, Tk_Offset(Frame, visualName),
+	DEF_FRAME_VISUAL, Tk_Offset(bltFrame, visualName),
 	BOTH | TK_CONFIG_NULL_OK},
     {TK_CONFIG_PIXELS, "-width", "width", "Width",
-	DEF_FRAME_WIDTH, Tk_Offset(Frame, width), BOTH},
+	DEF_FRAME_WIDTH, Tk_Offset(bltFrame, width), BOTH},
     {TK_CONFIG_END, (char *)NULL, (char *)NULL, (char *)NULL,
 	(char *)NULL, 0, 0}
 };
@@ -211,7 +211,7 @@
  */
 
 static int ConfigureFrame _ANSI_ARGS_((Tcl_Interp *interp,
-	Frame * framePtr, int argc, char **argv,
+	bltFrame * framePtr, int argc, CONST84 char **argv,
 	int flags));
 static void DestroyFrame _ANSI_ARGS_((DestroyData *memPtr));
 static void DisplayFrame _ANSI_ARGS_((ClientData clientData));
@@ -219,27 +219,16 @@
 	ClientData clientData));
 static void FrameEventProc _ANSI_ARGS_((ClientData clientData,
 	XEvent *eventPtr));
-static int FrameWidgetCmd _ANSI_ARGS_((ClientData clientData,
-	Tcl_Interp *interp, int argc, char **argv));
 static void MapFrame _ANSI_ARGS_((ClientData clientData));
 
 static Blt_TileChangedProc TileChangedProc;
-static Tcl_CmdProc FrameCmd, ToplevelCmd;
+static Tcl_CmdProc FrameCmd, ToplevelCmd, FrameWidgetCmd;
 
-#ifdef TILE_MAINWINDOW
-EXTERN
-#else
 static
-#endif
-int TkCreateFrame _ANSI_ARGS_((ClientData clientData,
-	Tcl_Interp *interp, int argc, char **argv,
+int BltCreateFrame _ANSI_ARGS_((ClientData clientData,
+	Tcl_Interp *interp, int argc, CONST84 char **argv,
 	int toplevel, char *appName));
 
-EXTERN void TkSetWindowMenuBar _ANSI_ARGS_((Tcl_Interp *interp, Tk_Window tkwin,
-        char *oldMenuName, char *menuName));
-
-EXTERN Tk_Window TkCreateMainWindow _ANSI_ARGS_((Tcl_Interp * interp, 
-	char * screenName, char * baseName));
 #if (TK_MAJOR_VERSION == 8) && (TK_MINOR_VERSION > 3)
 #define TkSetClassProcs	Tk_SetClassProcs
 #else 
@@ -247,10 +236,8 @@
 	ClientData instanceData));
 #endif /* TK_MAJOR_VERSION == 8 && TK_MINOR_VERSION > 3 */
 
-EXTERN void TkpSetMainMenubar _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin,
-	char * menuName));
-EXTERN int TkpUseWindow _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, 
-	char * string));
+/* EXTERN void TkpSetMainMenubar _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin,
+	char * menuName)); */
 EXTERN void TkpMakeContainer _ANSI_ARGS_((Tk_Window tkwin));
 
 
@@ -279,9 +266,9 @@
 				 * interpreter. */
     Tcl_Interp *interp;		/* Current interpreter. */
     int argc;			/* Number of arguments. */
-    char **argv;		/* Argument strings. */
+    CONST84 char **argv;		/* Argument strings. */
 {
-    return TkCreateFrame(clientData, interp, argc, argv, 0, (char *)NULL);
+    return BltCreateFrame(clientData, interp, argc, argv, 0, (char *)NULL);
 }
 
 static int
@@ -290,9 +277,9 @@
 				 * interpreter. */
     Tcl_Interp *interp;		/* Current interpreter. */
     int argc;			/* Number of arguments. */
-    char **argv;		/* Argument strings. */
+    CONST84 char **argv;		/* Argument strings. */
 {
-    return TkCreateFrame(clientData, interp, argc, argv, 1, (char *)NULL);
+    return BltCreateFrame(clientData, interp, argc, argv, 1, (char *)NULL);
 }
 
 /*
@@ -319,20 +306,20 @@
 static
 #endif /* TILE_MAINWINDOW */
 int
-TkCreateFrame(clientData, interp, argc, argv, toplevel, appName)
+BltCreateFrame(clientData, interp, argc, argv, toplevel, appName)
     ClientData clientData;	/* Main window associated with interpreter.
 				 * If we're called by Tk_Init to create a
 				 * new application, then this is NULL. */
     Tcl_Interp *interp;		/* Current interpreter. */
     int argc;			/* Number of arguments. */
-    char **argv;		/* Argument strings. */
+    CONST84 char *argv[];	/* Argument strings. */
     int toplevel;		/* Non-zero means create a toplevel window,
 				 * zero means create a frame. */
     char *appName;		/* Should only be non-NULL if clientData is
 				 * NULL:  gives the base name to use for the
 				 * new application. */
 {
-    Frame *framePtr;
+    bltFrame *framePtr;
     Tk_Window new;
     char *className, *screenName, *visualName, *colormapName, *arg, *useOption;
     int i, c, length, depth;
@@ -407,7 +394,7 @@
 	 */
 
 	if (appName == NULL) {
-	    panic("TkCreateFrame didn't get application name");
+	    panic("BltCreateFrame didn't get application name");
 	}
 	new = (Tk_Window)TkCreateMainWindow(interp, screenName, appName);
     }
@@ -467,7 +454,7 @@
      * in the widget record from the special options.
      */
 
-    framePtr = Blt_Malloc(sizeof(Frame));
+    framePtr = Blt_Malloc(sizeof(bltFrame));
     framePtr->tkwin = new;
     framePtr->display = Tk_Display(new);
     framePtr->interp = interp;
@@ -558,9 +545,9 @@
     ClientData clientData;	/* Information about frame widget. */
     Tcl_Interp *interp;		/* Current interpreter. */
     int argc;			/* Number of arguments. */
-    char **argv;		/* Argument strings. */
+    CONST84 char *argv[];		/* Argument strings. */
 {
-    register Frame *framePtr = (Frame *) clientData;
+    register bltFrame *framePtr = (bltFrame *) clientData;
     int result;
     size_t length;
     int c, i;
@@ -660,7 +647,7 @@
 DestroyFrame(memPtr)
     DestroyData *memPtr;	/* Info about frame widget. */
 {
-    register Frame *framePtr = (Frame *) memPtr;
+    register bltFrame *framePtr = (bltFrame *) memPtr;
     
     Tk_FreeOptions(configSpecs, (char *)framePtr, framePtr->display,
 	framePtr->mask);
@@ -689,7 +676,7 @@
     ClientData clientData;
     Blt_Tile tile;
 {
-    Frame *framePtr = (Frame *) clientData;
+    bltFrame *framePtr = (bltFrame *) clientData;
 
     if (framePtr->tkwin != NULL) {
 	if (!(framePtr->flags & REDRAW_PENDING)) {
@@ -723,10 +710,10 @@
 static int
 ConfigureFrame(interp, framePtr, argc, argv, flags)
     Tcl_Interp *interp;		/* Used for error reporting. */
-    register Frame *framePtr;	/* Information about widget;  may or may
+    register bltFrame *framePtr;	/* Information about widget;  may or may
 				 * not already have values for some fields. */
     int argc;			/* Number of valid entries in argv. */
-    char **argv;		/* Arguments. */
+    CONST84 char **argv;		/* Arguments. */
     int flags;			/* Flags to pass to Tk_ConfigureWidget. */
 {
 #if (TK_MAJOR_VERSION > 4)
@@ -810,7 +797,7 @@
 DisplayFrame(clientData)
     ClientData clientData;	/* Information about widget. */
 {
-    register Frame *framePtr = (Frame *) clientData;
+    register bltFrame *framePtr = (bltFrame *) clientData;
     register Tk_Window tkwin = framePtr->tkwin;
     GC gc;
 
@@ -877,7 +864,7 @@
     ClientData clientData;	/* Information about window. */
     register XEvent *eventPtr;	/* Information about event. */
 {
-    register Frame *framePtr = (Frame *) clientData;
+    register bltFrame *framePtr = (bltFrame *) clientData;
 
     if (((eventPtr->type == Expose) && (eventPtr->xexpose.count == 0))
 	|| (eventPtr->type == ConfigureNotify)) {
@@ -964,7 +951,7 @@
 FrameCmdDeletedProc(clientData)
     ClientData clientData;	/* Pointer to widget record for widget. */
 {
-    Frame *framePtr = (Frame *) clientData;
+    bltFrame *framePtr = (bltFrame *) clientData;
     Tk_Window tkwin = framePtr->tkwin;
 
 #if (TK_MAJOR_VERSION > 4)
@@ -1010,7 +997,7 @@
 MapFrame(clientData)
     ClientData clientData;	/* Pointer to frame structure. */
 {
-    Frame *framePtr = (Frame *) clientData;
+    bltFrame *framePtr = (bltFrame *) clientData;
 
     /*
      * Wait for all other background events to be processed before
@@ -1067,9 +1054,9 @@
 #define Tk_InstanceData(tkwin)	(((Tk_FakeWin *)(tkwin))->dummy18)
 #define Tk_MainPtr(tkwin)	(((Tk_FakeWin *)(tkwin))->dummy5)
     if (Tk_MainPtr(tkwin) != NULL) {
-	Frame *framePtr;
+	bltFrame *framePtr;
 
-	framePtr = (Frame *) Tk_InstanceData(tkwin);
+	framePtr = (bltFrame *) Tk_InstanceData(tkwin);
 	TkpMenuNotifyToplevelCreate(framePtr->interp, framePtr->menuName);
     }
 #endif /* TK_MAJOR_VERSION > 4 */
diff -uNr blt2.4z/src/tkInt.h blt2.4z.tcltk86/src/tkInt.h
--- blt2.4z/src/tkInt.h	1969-12-31 19:00:00.000000000 -0500
+++ blt2.4z.tcltk86/src/tkInt.h	2013-08-20 11:44:59.000000000 -0400
@@ -0,0 +1,1256 @@
+/*
+ * tkInt.h --
+ *
+ *	Declarations for things used internally by the Tk functions but not
+ *	exported outside the module.
+ *
+ * Copyright (c) 1990-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ * Copyright (c) 1998 by Scriptics Corporation.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKINT
+#define _TKINT
+
+#ifndef _TKPORT
+#include "tkPort.h"
+#endif
+
+/*
+ * Ensure WORDS_BIGENDIAN is defined correctly:
+ * Needs to happen here in addition to configure to work with fat compiles on
+ * Darwin (where configure runs only once for multiple architectures).
+ */
+
+#include <stdio.h>
+#ifdef HAVE_SYS_TYPES_H
+#    include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#    include <sys/param.h>
+#endif
+#ifdef BYTE_ORDER
+#    ifdef BIG_ENDIAN
+#	 if BYTE_ORDER == BIG_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	     define WORDS_BIGENDIAN 1
+#	 endif
+#    endif
+#    ifdef LITTLE_ENDIAN
+#	 if BYTE_ORDER == LITTLE_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	 endif
+#    endif
+#endif
+
+/*
+ * Used to tag functions that are only to be visible within the module being
+ * built and not outside it (where this is supported by the linker).
+ */
+
+#ifndef MODULE_SCOPE
+#   ifdef __cplusplus
+#	define MODULE_SCOPE extern "C"
+#   else
+#	define MODULE_SCOPE extern
+#   endif
+#endif
+
+/*
+ * Macros used to cast between pointers and integers (e.g. when storing an int
+ * in ClientData), on 64-bit architectures they avoid gcc warning about "cast
+ * to/from pointer from/to integer of different size".
+ */
+
+#if !defined(INT2PTR) && !defined(PTR2INT)
+#   if defined(HAVE_INTPTR_T) || defined(intptr_t)
+#	define INT2PTR(p) ((void*)(intptr_t)(p))
+#	define PTR2INT(p) ((int)(intptr_t)(p))
+#   else
+#	define INT2PTR(p) ((void*)(p))
+#	define PTR2INT(p) ((int)(p))
+#   endif
+#endif
+#if !defined(UINT2PTR) && !defined(PTR2UINT)
+#   if defined(HAVE_UINTPTR_T) || defined(uintptr_t)
+#	define UINT2PTR(p) ((void*)(uintptr_t)(p))
+#	define PTR2UINT(p) ((unsigned int)(uintptr_t)(p))
+#   else
+#	define UINT2PTR(p) ((void*)(p))
+#	define PTR2UINT(p) ((unsigned int)(p))
+#   endif
+#endif
+
+/*
+ * Opaque type declarations:
+ */
+
+typedef struct TkColormap TkColormap;
+typedef struct TkFontAttributes TkFontAttributes;
+typedef struct TkGrabEvent TkGrabEvent;
+typedef struct TkpCursor_ *TkpCursor;
+typedef struct TkRegion_ *TkRegion;
+typedef struct TkStressedCmap TkStressedCmap;
+typedef struct TkBindInfo_ *TkBindInfo;
+typedef struct Busy *TkBusy;
+
+/*
+ * One of the following structures is maintained for each cursor in use in the
+ * system. This structure is used by tkCursor.c and the various system-
+ * specific cursor files.
+ */
+
+typedef struct TkCursor {
+    Tk_Cursor cursor;		/* System specific identifier for cursor. */
+    Display *display;		/* Display containing cursor. Needed for
+				 * disposal and retrieval of cursors. */
+    int resourceRefCount;	/* Number of active uses of this cursor (each
+				 * active use corresponds to a call to
+				 * Tk_AllocPreserveFromObj or Tk_Preserve). If
+				 * this count is 0, then this structure is no
+				 * longer valid and it isn't present in a hash
+				 * table: it is being kept around only because
+				 * there are objects referring to it. The
+				 * structure is freed when resourceRefCount
+				 * and objRefCount are both 0. */
+    int objRefCount;		/* Number of Tcl objects that reference this
+				 * structure.. */
+    Tcl_HashTable *otherTable;	/* Second table (other than idTable) used to
+				 * index this entry. */
+    Tcl_HashEntry *hashPtr;	/* Entry in otherTable for this structure
+				 * (needed when deleting). */
+    Tcl_HashEntry *idHashPtr;	/* Entry in idTable for this structure (needed
+				 * when deleting). */
+    struct TkCursor *nextPtr;	/* Points to the next TkCursor structure with
+				 * the same name. Cursors with the same name
+				 * but different displays are chained together
+				 * off a single hash table entry. */
+} TkCursor;
+
+/*
+ * The following structure is kept one-per-TkDisplay to maintain information
+ * about the caret (cursor location) on this display. This is used to dictate
+ * global focus location (Windows Accessibility guidelines) and to position
+ * the IME or XIM over-the-spot window.
+ */
+
+typedef struct TkCaret {
+    struct TkWindow *winPtr;	/* The window on which we requested caret
+				 * placement. */
+    int x;			/* Relative x coord of the caret. */
+    int y;			/* Relative y coord of the caret. */
+    int height;			/* Specified height of the window. */
+} TkCaret;
+
+/*
+ * One of the following structures is maintained for each display containing a
+ * window managed by Tk. In part, the structure is used to store thread-
+ * specific data, since each thread will have its own TkDisplay structure.
+ */
+
+typedef struct TkDisplay {
+    Display *display;		/* Xlib's info about display. */
+    struct TkDisplay *nextPtr;	/* Next in list of all displays. */
+    char *name;			/* Name of display (with any screen identifier
+				 * removed). Malloc-ed. */
+    Time lastEventTime;		/* Time of last event received for this
+				 * display. */
+
+    /*
+     * Information used primarily by tk3d.c:
+     */
+
+    int borderInit;		/* 0 means borderTable needs initializing. */
+    Tcl_HashTable borderTable;	/* Maps from color name to TkBorder
+				 * structure. */
+
+    /*
+     * Information used by tkAtom.c only:
+     */
+
+    int atomInit;		/* 0 means stuff below hasn't been initialized
+				 * yet. */
+    Tcl_HashTable nameTable;	/* Maps from names to Atom's. */
+    Tcl_HashTable atomTable;	/* Maps from Atom's back to names. */
+
+    /*
+     * Information used primarily by tkBind.c:
+     */
+
+    int bindInfoStale;		/* Non-zero means the variables in this part
+				 * of the structure are potentially incorrect
+				 * and should be recomputed. */
+    unsigned int modeModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to "mode shift". If no such
+				 * modifier, than this is zero. */
+    unsigned int metaModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to the "Meta" key. If no such
+				 * modifier, then this is zero. */
+    unsigned int altModMask;	/* Has one bit set to indicate the modifier
+				 * corresponding to the "Meta" key. If no such
+				 * modifier, then this is zero. */
+    enum {LU_IGNORE, LU_CAPS, LU_SHIFT} lockUsage;
+				/* Indicates how to interpret lock
+				 * modifier. */
+    int numModKeyCodes;		/* Number of entries in modKeyCodes array
+				 * below. */
+    KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for all
+				 * of the keys that have modifiers associated
+				 * with them. Malloc'ed, but may be NULL. */
+
+    /*
+     * Information used by tkBitmap.c only:
+     */
+
+    int bitmapInit;		/* 0 means tables above need initializing. */
+    int bitmapAutoNumber;	/* Used to number bitmaps. */
+    Tcl_HashTable bitmapNameTable;
+				/* Maps from name of bitmap to the first
+				 * TkBitmap record for that name. */
+    Tcl_HashTable bitmapIdTable;/* Maps from bitmap id to the TkBitmap
+				 * structure for the bitmap. */
+    Tcl_HashTable bitmapDataTable;
+				/* Used by Tk_GetBitmapFromData to map from a
+				 * collection of in-core data about a bitmap
+				 * to a reference giving an automatically-
+				 * generated name for the bitmap. */
+
+    /*
+     * Information used by tkCanvas.c only:
+     */
+
+    int numIdSearches;
+    int numSlowSearches;
+
+    /*
+     * Used by tkColor.c only:
+     */
+
+    int colorInit;		/* 0 means color module needs initializing. */
+    TkStressedCmap *stressPtr;	/* First in list of colormaps that have filled
+				 * up, so we have to pick an approximate
+				 * color. */
+    Tcl_HashTable colorNameTable;
+				/* Maps from color name to TkColor structure
+				 * for that color. */
+    Tcl_HashTable colorValueTable;
+				/* Maps from integer RGB values to TkColor
+				 * structures. */
+
+    /*
+     * Used by tkCursor.c only:
+     */
+
+    int cursorInit;		/* 0 means cursor module need initializing. */
+    Tcl_HashTable cursorNameTable;
+				/* Maps from a string name to a cursor to the
+				 * TkCursor record for the cursor. */
+    Tcl_HashTable cursorDataTable;
+				/* Maps from a collection of in-core data
+				 * about a cursor to a TkCursor structure. */
+    Tcl_HashTable cursorIdTable;
+				/* Maps from a cursor id to the TkCursor
+				 * structure for the cursor. */
+    char cursorString[20];	/* Used to store a cursor id string. */
+    Font cursorFont;		/* Font to use for standard cursors. None
+				 * means font not loaded yet. */
+
+    /*
+     * Information used by tkError.c only:
+     */
+
+    struct TkErrorHandler *errorPtr;
+				/* First in list of error handlers for this
+				 * display. NULL means no handlers exist at
+				 * present. */
+    int deleteCount;		/* Counts # of handlers deleted since last
+				 * time inactive handlers were garbage-
+				 * collected. When this number gets big,
+				 * handlers get cleaned up. */
+
+    /*
+     * Used by tkEvent.c only:
+     */
+
+    struct TkWindowEvent *delayedMotionPtr;
+				/* Points to a malloc-ed motion event whose
+				 * processing has been delayed in the hopes
+				 * that another motion event will come along
+				 * right away and we can merge the two of them
+				 * together. NULL means that there is no
+				 * delayed motion event. */
+
+    /*
+     * Information used by tkFocus.c only:
+     */
+
+    int focusDebug;		/* 1 means collect focus debugging
+				 * statistics. */
+    struct TkWindow *implicitWinPtr;
+				/* If the focus arrived at a toplevel window
+				 * implicitly via an Enter event (rather than
+				 * via a FocusIn event), this points to the
+				 * toplevel window. Otherwise it is NULL. */
+    struct TkWindow *focusPtr;	/* Points to the window on this display that
+				 * should be receiving keyboard events. When
+				 * multiple applications on the display have
+				 * the focus, this will refer to the innermost
+				 * window in the innermost application. This
+				 * information isn't used on Windows, but it's
+				 * needed on the Mac, and also on X11 when XIM
+				 * processing is being done. */
+
+    /*
+     * Information used by tkGC.c only:
+     */
+
+    Tcl_HashTable gcValueTable; /* Maps from a GC's values to a TkGC structure
+				 * describing a GC with those values. */
+    Tcl_HashTable gcIdTable;    /* Maps from a GC to a TkGC. */
+    int gcInit;			/* 0 means the tables below need
+				 * initializing. */
+
+    /*
+     * Information used by tkGeometry.c only:
+     */
+
+    Tcl_HashTable maintainHashTable;
+				/* Hash table that maps from a master's
+				 * Tk_Window token to a list of slaves managed
+				 * by that master. */
+    int geomInit;
+
+    /*
+     * Information used by tkGet.c only:
+     */
+
+    Tcl_HashTable uidTable;	/* Stores all Tk_Uid used in a thread. */
+    int uidInit;		/* 0 means uidTable needs initializing. */
+
+    /*
+     * Information used by tkGrab.c only:
+     */
+
+    struct TkWindow *grabWinPtr;/* Window in which the pointer is currently
+				 * grabbed, or NULL if none. */
+    struct TkWindow *eventualGrabWinPtr;
+				/* Value that grabWinPtr will have once the
+				 * grab event queue (below) has been
+				 * completely emptied. */
+    struct TkWindow *buttonWinPtr;
+				/* Window in which first mouse button was
+				 * pressed while grab was in effect, or NULL
+				 * if no such press in effect. */
+    struct TkWindow *serverWinPtr;
+				/* If no application contains the pointer then
+				 * this is NULL. Otherwise it contains the
+				 * last window for which we've gotten an Enter
+				 * or Leave event from the server (i.e. the
+				 * last window known to have contained the
+				 * pointer). Doesn't reflect events that were
+				 * synthesized in tkGrab.c. */
+    TkGrabEvent *firstGrabEventPtr;
+				/* First in list of enter/leave events
+				 * synthesized by grab code. These events must
+				 * be processed in order before any other
+				 * events are processed. NULL means no such
+				 * events. */
+    TkGrabEvent *lastGrabEventPtr;
+				/* Last in list of synthesized events, or NULL
+				 * if list is empty. */
+    int grabFlags;		/* Miscellaneous flag values. See definitions
+				 * in tkGrab.c. */
+
+    /*
+     * Information used by tkGrid.c only:
+     */
+
+    int gridInit;		/* 0 means table below needs initializing. */
+    Tcl_HashTable gridHashTable;/* Maps from Tk_Window tokens to corresponding
+				 * Grid structures. */
+
+    /*
+     * Information used by tkImage.c only:
+     */
+
+    int imageId;		/* Value used to number image ids. */
+
+    /*
+     * Information used by tkMacWinMenu.c only:
+     */
+
+    int postCommandGeneration;
+
+    /*
+     * Information used by tkPack.c only.
+     */
+
+    int packInit;		/* 0 means table below needs initializing. */
+    Tcl_HashTable packerHashTable;
+				/* Maps from Tk_Window tokens to corresponding
+				 * Packer structures. */
+
+    /*
+     * Information used by tkPlace.c only.
+     */
+
+    int placeInit;		/* 0 means tables below need initializing. */
+    Tcl_HashTable masterTable;	/* Maps from Tk_Window toke to the Master
+				 * structure for the window, if it exists. */
+    Tcl_HashTable slaveTable;	/* Maps from Tk_Window toke to the Slave
+				 * structure for the window, if it exists. */
+
+    /*
+     * Information used by tkSelect.c and tkClipboard.c only:
+     */
+
+    struct TkSelectionInfo *selectionInfoPtr;
+				/* First in list of selection information
+				 * records. Each entry contains information
+				 * about the current owner of a particular
+				 * selection on this display. */
+    Atom multipleAtom;		/* Atom for MULTIPLE. None means selection
+				 * stuff isn't initialized. */
+    Atom incrAtom;		/* Atom for INCR. */
+    Atom targetsAtom;		/* Atom for TARGETS. */
+    Atom timestampAtom;		/* Atom for TIMESTAMP. */
+    Atom textAtom;		/* Atom for TEXT. */
+    Atom compoundTextAtom;	/* Atom for COMPOUND_TEXT. */
+    Atom applicationAtom;	/* Atom for TK_APPLICATION. */
+    Atom windowAtom;		/* Atom for TK_WINDOW. */
+    Atom clipboardAtom;		/* Atom for CLIPBOARD. */
+    Atom utf8Atom;		/* Atom for UTF8_STRING. */
+
+    Tk_Window clipWindow;	/* Window used for clipboard ownership and to
+				 * retrieve selections between processes. NULL
+				 * means clipboard info hasn't been
+				 * initialized. */
+    int clipboardActive;	/* 1 means we currently own the clipboard
+				 * selection, 0 means we don't. */
+    struct TkMainInfo *clipboardAppPtr;
+				/* Last application that owned clipboard. */
+    struct TkClipboardTarget *clipTargetPtr;
+				/* First in list of clipboard type information
+				 * records. Each entry contains information
+				 * about the buffers for a given selection
+				 * target. */
+
+    /*
+     * Information used by tkSend.c only:
+     */
+
+    Tk_Window commTkwin;	/* Window used for communication between
+				 * interpreters during "send" commands. NULL
+				 * means send info hasn't been initialized
+				 * yet. */
+    Atom commProperty;		/* X's name for comm property. */
+    Atom registryProperty;	/* X's name for property containing registry
+				 * of interpreter names. */
+    Atom appNameProperty;	/* X's name for property used to hold the
+				 * application name on each comm window. */
+
+    /*
+     * Information used by tkUnixWm.c and tkWinWm.c only:
+     */
+
+    struct TkWmInfo *firstWmPtr;/* Points to first top-level window. */
+    struct TkWmInfo *foregroundWmPtr;
+				/* Points to the foreground window. */
+
+    /*
+     * Information used by tkVisual.c only:
+     */
+
+    TkColormap *cmapPtr;	/* First in list of all non-default colormaps
+				 * allocated for this display. */
+
+    /*
+     * Miscellaneous information:
+     */
+
+#ifdef TK_USE_INPUT_METHODS
+    XIM inputMethod;		/* Input method for this display. */
+    XIMStyle inputStyle;	/* Input style selected for this display. */
+    XFontSet inputXfs;		/* XFontSet cached for over-the-spot XIM. */
+#endif /* TK_USE_INPUT_METHODS */
+    Tcl_HashTable winTable;	/* Maps from X window ids to TkWindow ptrs. */
+
+    int refCount;		/* Reference count of how many Tk applications
+				 * are using this display. Used to clean up
+				 * the display when we no longer have any Tk
+				 * applications using it. */
+
+    /*
+     * The following field were all added for Tk8.3
+     */
+
+    int mouseButtonState;	/* Current mouse button state for this
+				 * display. */
+    Window mouseButtonWindow;	/* Window the button state was set in, added
+				 * in Tk 8.4. */
+    Tk_Window warpWindow;
+    Tk_Window warpMainwin;	/* For finding the root window for warping
+				 * purposes. */
+    int warpX;
+    int warpY;
+
+    /*
+     * The following field(s) were all added for Tk8.4
+     */
+
+    unsigned int flags;		/* Various flag values: these are all defined
+				 * in below. */
+    TkCaret caret;		/* Information about the caret for this
+				 * display. This is not a pointer. */
+
+    int iconDataSize;		/* Size of default iconphoto image data. */
+    unsigned char *iconDataPtr;	/* Default iconphoto image data, if set. */
+} TkDisplay;
+
+/*
+ * Flag values for TkDisplay flags.
+ *  TK_DISPLAY_COLLAPSE_MOTION_EVENTS:	(default on)
+ *	Indicates that we should collapse motion events on this display
+ *  TK_DISPLAY_USE_IM:			(default on, set via tk.tcl)
+ *	Whether to use input methods for this display
+ *  TK_DISPLAY_WM_TRACING:		(default off)
+ *	Whether we should do wm tracing on this display.
+ *  TK_DISPLAY_IN_WARP:			(default off)
+ *	Indicates that we are in a pointer warp
+ */
+
+#define TK_DISPLAY_COLLAPSE_MOTION_EVENTS	(1 << 0)
+#define TK_DISPLAY_USE_IM			(1 << 1)
+#define TK_DISPLAY_WM_TRACING			(1 << 3)
+#define TK_DISPLAY_IN_WARP			(1 << 4)
+
+/*
+ * One of the following structures exists for each error handler created by a
+ * call to Tk_CreateErrorHandler. The structure is managed by tkError.c.
+ */
+
+typedef struct TkErrorHandler {
+    TkDisplay *dispPtr;		/* Display to which handler applies. */
+    unsigned long firstRequest;	/* Only errors with serial numbers >= to this
+				 * are considered. */
+    unsigned long lastRequest;	/* Only errors with serial numbers <= to this
+				 * are considered. This field is filled in
+				 * when XUnhandle is called. -1 means
+				 * XUnhandle hasn't been called yet. */
+    int error;			/* Consider only errors with this error_code
+				 * (-1 means consider all errors). */
+    int request;		/* Consider only errors with this major
+				 * request code (-1 means consider all major
+				 * codes). */
+    int minorCode;		/* Consider only errors with this minor
+				 * request code (-1 means consider all minor
+				 * codes). */
+    Tk_ErrorProc *errorProc;	/* Function to invoke when a matching error
+				 * occurs. NULL means just ignore errors. */
+    ClientData clientData;	/* Arbitrary value to pass to errorProc. */
+    struct TkErrorHandler *nextPtr;
+				/* Pointer to next older handler for this
+				 * display, or NULL for end of list. */
+} TkErrorHandler;
+
+/*
+ * One of the following structures exists for each event handler created by
+ * calling Tk_CreateEventHandler. This information is used by tkEvent.c only.
+ */
+
+typedef struct TkEventHandler {
+    unsigned long mask;		/* Events for which to invoke proc. */
+    Tk_EventProc *proc;		/* Function to invoke when an event in mask
+				 * occurs. */
+    ClientData clientData;	/* Argument to pass to proc. */
+    struct TkEventHandler *nextPtr;
+				/* Next in list of handlers associated with
+				 * window (NULL means end of list). */
+} TkEventHandler;
+
+/*
+ * Tk keeps one of the following data structures for each main window (created
+ * by a call to TkCreateMainWindow). It stores information that is shared by
+ * all of the windows associated with a particular main window.
+ */
+
+typedef struct TkMainInfo {
+    int refCount;		/* Number of windows whose "mainPtr" fields
+				 * point here. When this becomes zero, can
+				 * free up the structure (the reference count
+				 * is zero because windows can get deleted in
+				 * almost any order; the main window isn't
+				 * necessarily the last one deleted). */
+    struct TkWindow *winPtr;	/* Pointer to main window. */
+    Tcl_Interp *interp;		/* Interpreter associated with application. */
+    Tcl_HashTable nameTable;	/* Hash table mapping path names to TkWindow
+				 * structs for all windows related to this
+				 * main window. Managed by tkWindow.c. */
+    long deletionEpoch;		/* Incremented by window deletions. */
+    Tk_BindingTable bindingTable;
+				/* Used in conjunction with "bind" command to
+				 * bind events to Tcl commands. */
+    TkBindInfo bindInfo;	/* Information used by tkBind.c on a per
+				 * application basis. */
+    struct TkFontInfo *fontInfoPtr;
+				/* Information used by tkFont.c on a per
+				 * application basis. */
+
+    /*
+     * Information used only by tkFocus.c and tk*Embed.c:
+     */
+
+    struct TkToplevelFocusInfo *tlFocusPtr;
+				/* First in list of records containing focus
+				 * information for each top-level in the
+				 * application. Used only by tkFocus.c. */
+    struct TkDisplayFocusInfo *displayFocusPtr;
+				/* First in list of records containing focus
+				 * information for each display that this
+				 * application has ever used. Used only by
+				 * tkFocus.c. */
+
+    struct ElArray *optionRootPtr;
+				/* Top level of option hierarchy for this main
+				 * window. NULL means uninitialized. Managed
+				 * by tkOption.c. */
+    Tcl_HashTable imageTable;	/* Maps from image names to Tk_ImageMaster
+				 * structures. Managed by tkImage.c. */
+    int strictMotif;		/* This is linked to the tk_strictMotif global
+				 * variable. */
+    int alwaysShowSelection;	/* This is linked to the
+				 * ::tk::AlwaysShowSelection variable. */
+    struct TkMainInfo *nextPtr;	/* Next in list of all main windows managed by
+				 * this process. */
+    Tcl_HashTable busyTable;	/* Information used by [tk busy] command. */
+} TkMainInfo;
+
+/*
+ * Tk keeps the following data structure for each of it's builtin bitmaps.
+ * This structure is only used by tkBitmap.c and other platform specific
+ * bitmap files.
+ */
+
+typedef struct {
+    const void *source;		/* Bits for bitmap. */
+    int width, height;		/* Dimensions of bitmap. */
+    int native;			/* 0 means generic (X style) bitmap, 1 means
+    				 * native style bitmap. */
+} TkPredefBitmap;
+
+/*
+ * Tk keeps one of the following structures for each window. Some of the
+ * information (like size and location) is a shadow of information managed by
+ * the X server, and some is special information used here, such as event and
+ * geometry management information. This information is (mostly) managed by
+ * tkWindow.c. WARNING: the declaration below must be kept consistent with the
+ * Tk_FakeWin structure in tk.h. If you change one, be sure to change the
+ * other!
+ */
+
+typedef struct TkWindow {
+    /*
+     * Structural information:
+     */
+
+    Display *display;		/* Display containing window. */
+    TkDisplay *dispPtr;		/* Tk's information about display for
+				 * window. */
+    int screenNum;		/* Index of screen for window, among all those
+				 * for dispPtr. */
+    Visual *visual;		/* Visual to use for window. If not default,
+				 * MUST be set before X window is created. */
+    int depth;			/* Number of bits/pixel. */
+    Window window;		/* X's id for window. NULL means window hasn't
+				 * actually been created yet, or it's been
+				 * deleted. */
+    struct TkWindow *childList;	/* First in list of child windows, or NULL if
+				 * no children. List is in stacking order,
+				 * lowest window first.*/
+    struct TkWindow *lastChildPtr;
+				/* Last in list of child windows (highest in
+				 * stacking order), or NULL if no children. */
+    struct TkWindow *parentPtr;	/* Pointer to parent window (logical parent,
+				 * not necessarily X parent). NULL means
+				 * either this is the main window, or the
+				 * window's parent has already been deleted. */
+    struct TkWindow *nextPtr;	/* Next higher sibling (in stacking order) in
+				 * list of children with same parent. NULL
+				 * means end of list. */
+    TkMainInfo *mainPtr;	/* Information shared by all windows
+				 * associated with a particular main window.
+				 * NULL means this window is a rogue that is
+				 * not associated with any application (at
+				 * present, this only happens for the dummy
+				 * windows used for "send" communication). */
+
+    /*
+     * Name and type information for the window:
+     */
+
+    char *pathName;		/* Path name of window (concatenation of all
+				 * names between this window and its top-level
+				 * ancestor). This is a pointer into an entry
+				 * in mainPtr->nameTable. NULL means that the
+				 * window hasn't been completely created
+				 * yet. */
+    Tk_Uid nameUid;		/* Name of the window within its parent
+				 * (unique within the parent). */
+    Tk_Uid classUid;		/* Class of the window. NULL means window
+				 * hasn't been given a class yet. */
+
+    /*
+     * Geometry and other attributes of window. This information may not be
+     * updated on the server immediately; stuff that hasn't been reflected in
+     * the server yet is called "dirty". At present, information can be dirty
+     * only if the window hasn't yet been created.
+     */
+
+    XWindowChanges changes;	/* Geometry and other info about window. */
+    unsigned int dirtyChanges;	/* Bits indicate fields of "changes" that are
+				 * dirty. */
+    XSetWindowAttributes atts;	/* Current attributes of window. */
+    unsigned long dirtyAtts;	/* Bits indicate fields of "atts" that are
+				 * dirty. */
+
+    unsigned int flags;		/* Various flag values: these are all defined
+				 * in tk.h (confusing, but they're needed
+				 * there for some query macros). */
+
+    /*
+     * Information kept by the event manager (tkEvent.c):
+     */
+
+    TkEventHandler *handlerList;/* First in list of event handlers declared
+				 * for this window, or NULL if none. */
+#ifdef TK_USE_INPUT_METHODS
+    XIC inputContext;		/* XIM input context. */
+#endif /* TK_USE_INPUT_METHODS */
+
+    /*
+     * Information used for event bindings (see "bind" and "bindtags" commands
+     * in tkCmds.c):
+     */
+
+    ClientData *tagPtr;		/* Points to array of tags used for bindings
+				 * on this window. Each tag is a Tk_Uid.
+				 * Malloc'ed. NULL means no tags. */
+    int numTags;		/* Number of tags at *tagPtr. */
+
+    /*
+     * Information used by tkOption.c to manage options for the window.
+     */
+
+    int optionLevel;		/* -1 means no option information is currently
+				 * cached for this window. Otherwise this
+				 * gives the level in the option stack at
+				 * which info is cached. */
+    /*
+     * Information used by tkSelect.c to manage the selection.
+     */
+
+    struct TkSelHandler *selHandlerList;
+				/* First in list of handlers for returning the
+				 * selection in various forms. */
+
+    /*
+     * Information used by tkGeometry.c for geometry management.
+     */
+
+    const Tk_GeomMgr *geomMgrPtr;
+				/* Information about geometry manager for this
+				 * window. */
+    ClientData geomData;	/* Argument for geometry manager functions. */
+    int reqWidth, reqHeight;	/* Arguments from last call to
+				 * Tk_GeometryRequest, or 0's if
+				 * Tk_GeometryRequest hasn't been called. */
+    int internalBorderLeft;	/* Width of internal border of window (0 means
+				 * no internal border). Geometry managers
+				 * should not normally place children on top
+				 * of the border. Fields for the other three
+				 * sides are found below. */
+
+    /*
+     * Information maintained by tkWm.c for window manager communication.
+     */
+
+    struct TkWmInfo *wmInfoPtr;	/* For top-level windows (and also for special
+				 * Unix menubar and wrapper windows), points
+				 * to structure with wm-related info (see
+				 * tkWm.c). For other windows, this is
+				 * NULL. */
+
+    /*
+     * Information used by widget classes.
+     */
+
+    const Tk_ClassProcs *classProcsPtr;
+    ClientData instanceData;
+
+    /*
+     * Platform specific information private to each port.
+     */
+
+    struct TkWindowPrivate *privatePtr;
+
+    /*
+     * More information used by tkGeometry.c for geometry management.
+     */
+
+    /* The remaining fields of internal border. */
+    int internalBorderRight;
+    int internalBorderTop;
+    int internalBorderBottom;
+
+    int minReqWidth;		/* Minimum requested width. */
+    int minReqHeight;		/* Minimum requested height. */
+    char *geometryMaster;
+} TkWindow;
+
+/*
+ * Real definition of some events. Note that these events come from outside
+ * but have internally generated pieces added to them.
+ */
+
+typedef struct {
+    XKeyEvent keyEvent;		/* The real event from X11. */
+    char *charValuePtr;		/* A pointer to a string that holds the key's
+				 * %A substitution text (before backslash
+				 * adding), or NULL if that has not been
+				 * computed yet. If non-NULL, this string was
+				 * allocated with ckalloc(). */
+    int charValueLen;		/* Length of string in charValuePtr when that
+				 * is non-NULL. */
+    KeySym keysym;		/* Key symbol computed after input methods
+				 * have been invoked */
+} TkKeyEvent;
+
+/*
+ * Flags passed to TkpMakeMenuWindow's 'transient' argument.
+ */
+
+#define TK_MAKE_MENU_TEAROFF	0	/* Only non-transient case. */
+#define TK_MAKE_MENU_POPUP	1
+#define TK_MAKE_MENU_DROPDOWN	2
+
+/*
+ * The following structure is used with TkMakeEnsemble to create ensemble
+ * commands and optionally to create sub-ensembles.
+ */
+
+typedef struct TkEnsemble {
+    const char *name;
+    Tcl_ObjCmdProc *proc;
+    const struct TkEnsemble *subensemble;
+} TkEnsemble;
+
+/*
+ * The following structure is used as a two way map between integers and
+ * strings, usually to map between an internal C representation and the
+ * strings used in Tcl.
+ */
+
+typedef struct TkStateMap {
+    int numKey;			/* Integer representation of a value. */
+    const char *strKey;		/* String representation of a value. */
+} TkStateMap;
+
+/*
+ * This structure is used by the Mac and Window porting layers as the internal
+ * representation of a clip_mask in a GC.
+ */
+
+typedef struct TkpClipMask {
+    int type;			/* TKP_CLIP_PIXMAP or TKP_CLIP_REGION. */
+    union {
+	Pixmap pixmap;
+	TkRegion region;
+    } value;
+} TkpClipMask;
+
+#define TKP_CLIP_PIXMAP 0
+#define TKP_CLIP_REGION 1
+
+/*
+ * Return values from TkGrabState:
+ */
+
+#define TK_GRAB_NONE		0
+#define TK_GRAB_IN_TREE		1
+#define TK_GRAB_ANCESTOR	2
+#define TK_GRAB_EXCLUDED	3
+
+/*
+ * Additional flag for TkpMeasureCharsInContext. Coordinate with other flags
+ * for this routine, but don't make public until TkpMeasureCharsInContext is
+ * made public, too.
+ */
+
+#define TK_ISOLATE_END		32
+
+/*
+ * The macro below is used to modify a "char" value (e.g. by casting it to an
+ * unsigned character) so that it can be used safely with macros such as
+ * isspace().
+ */
+
+#define UCHAR(c) ((unsigned char) (c))
+
+/*
+ * The following symbol is used in the mode field of FocusIn events generated
+ * by an embedded application to request the input focus from its container.
+ */
+
+#define EMBEDDED_APP_WANTS_FOCUS (NotifyNormal + 20)
+
+/*
+ * The following special modifier mask bits are defined, to indicate logical
+ * modifiers such as Meta and Alt that may float among the actual modifier
+ * bits.
+ */
+
+#define META_MASK	(AnyModifier<<1)
+#define ALT_MASK	(AnyModifier<<2)
+#define EXTENDED_MASK	(AnyModifier<<3)
+
+/*
+ * Object types not declared in tkObj.c need to be mentioned here so they can
+ * be properly registered with Tcl:
+ */
+
+MODULE_SCOPE const Tcl_ObjType tkBorderObjType;
+MODULE_SCOPE const Tcl_ObjType tkBitmapObjType;
+MODULE_SCOPE const Tcl_ObjType tkColorObjType;
+MODULE_SCOPE const Tcl_ObjType tkCursorObjType;
+MODULE_SCOPE const Tcl_ObjType tkFontObjType;
+MODULE_SCOPE const Tcl_ObjType tkStateKeyObjType;
+MODULE_SCOPE const Tcl_ObjType tkTextIndexType;
+
+/*
+ * Miscellaneous variables shared among Tk modules but not exported to the
+ * outside world:
+ */
+
+MODULE_SCOPE const Tk_SmoothMethod tkBezierSmoothMethod;
+MODULE_SCOPE Tk_ImageType	tkBitmapImageType;
+MODULE_SCOPE Tk_PhotoImageFormat tkImgFmtGIF;
+MODULE_SCOPE void		(*tkHandleEventProc) (XEvent* eventPtr);
+MODULE_SCOPE Tk_PhotoImageFormat tkImgFmtPNG;
+MODULE_SCOPE Tk_PhotoImageFormat tkImgFmtPPM;
+MODULE_SCOPE TkMainInfo		*tkMainWindowList;
+MODULE_SCOPE Tk_ImageType	tkPhotoImageType;
+MODULE_SCOPE Tcl_HashTable	tkPredefBitmapTable;
+
+MODULE_SCOPE const char *const tkWebColors[20];
+
+/*
+ * The definition of pi, at least from the perspective of double-precision
+ * floats.
+ */
+
+#ifndef PI
+#ifdef M_PI
+#define PI	M_PI
+#else
+#define PI	3.14159265358979323846
+#endif
+#endif
+
+/*
+ * Support for Clang Static Analyzer <http://clang-analyzer.llvm.org>
+ */
+
+#if defined(PURIFY) && defined(__clang__)
+#if __has_feature(attribute_analyzer_noreturn) && \
+	!defined(Tcl_Panic) && defined(Tcl_Panic_TCL_DECLARED)
+void Tcl_Panic(const char *, ...) __attribute__((analyzer_noreturn));
+#endif
+#if !defined(CLANG_ASSERT)
+#include <assert.h>
+#define CLANG_ASSERT(x) assert(x)
+#endif
+#elif !defined(CLANG_ASSERT)
+#define CLANG_ASSERT(x)
+#endif /* PURIFY && __clang__ */
+
+/*
+ * The following magic value is stored in the "send_event" field of FocusIn
+ * and FocusOut events. This allows us to separate "real" events coming from
+ * the server from those that we generated.
+ */
+
+#define GENERATED_FOCUS_EVENT_MAGIC	((Bool) 0x547321ac)
+
+/*
+ * Exported internals.
+ */
+
+#include "tkIntDecls.h"
+
+/*
+ * Themed widget set init function:
+ */
+
+MODULE_SCOPE int	Ttk_Init(Tcl_Interp *interp);
+
+/*
+ * Internal functions shared among Tk modules but not exported to the outside
+ * world:
+ */
+
+MODULE_SCOPE int	Tk_BellObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_BindObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_BindtagsObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_BusyObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ButtonObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_CanvasObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_CheckbuttonObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ClipboardObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ChooseColorObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ChooseDirectoryObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_DestroyObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_EntryObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_EventObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_FrameObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_FocusObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_FontObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_GetOpenFileObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_GetSaveFileObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_GrabObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_GridObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ImageObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_LabelObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_LabelframeObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ListboxObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_LowerObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_MenubuttonObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_MessageBoxObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_MessageObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_PanedWindowObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_OptionObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_PackObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_PlaceObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_RadiobuttonObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_RaiseObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ScaleObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ScrollbarCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc, const char **argv);
+MODULE_SCOPE int	Tk_SelectionObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_SendCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc, const char **argv);
+MODULE_SCOPE int	Tk_SendObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_SpinboxObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_TextObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_TkwaitObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_ToplevelObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_UpdateObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_WinfoObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE int	Tk_WmObjCmd(ClientData clientData, Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[]);
+
+MODULE_SCOPE int	Tk_GetDoublePixelsFromObj(Tcl_Interp *interp,
+			    Tk_Window tkwin, Tcl_Obj *objPtr,
+			    double *doublePtr);
+MODULE_SCOPE int	TkSetGeometryMaster(Tcl_Interp *interp,
+			    Tk_Window tkwin, const char *master);
+MODULE_SCOPE void	TkFreeGeometryMaster(Tk_Window tkwin,
+			    const char *master);
+
+MODULE_SCOPE void	TkEventInit(void);
+MODULE_SCOPE void	TkRegisterObjTypes(void);
+MODULE_SCOPE int	TkCreateMenuCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TkDeadAppCmd(ClientData clientData,
+			    Tcl_Interp *interp, int argc, const char **argv);
+MODULE_SCOPE int	TkCanvasGetCoordObj(Tcl_Interp *interp,
+			    Tk_Canvas canvas, Tcl_Obj *obj,
+			    double *doublePtr);
+MODULE_SCOPE int	TkGetDoublePixels(Tcl_Interp *interp, Tk_Window tkwin,
+			    const char *string, double *doublePtr);
+MODULE_SCOPE int	TkPostscriptImage(Tcl_Interp *interp, Tk_Window tkwin,
+			    Tk_PostscriptInfo psInfo, XImage *ximage,
+			    int x, int y, int width, int height);
+MODULE_SCOPE void       TkMapTopFrame(Tk_Window tkwin);
+MODULE_SCOPE XEvent *	TkpGetBindingXEvent(Tcl_Interp *interp);
+MODULE_SCOPE void	TkCreateExitHandler(Tcl_ExitProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE void	TkDeleteExitHandler(Tcl_ExitProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE Tcl_ExitProc	TkFinalize;
+MODULE_SCOPE Tcl_ExitProc	TkFinalizeThread;
+MODULE_SCOPE void	TkpBuildRegionFromAlphaData(TkRegion region,
+			    unsigned x, unsigned y, unsigned width,
+			    unsigned height, unsigned char *dataPtr,
+			    unsigned pixelStride, unsigned lineStride);
+MODULE_SCOPE void	TkAppendPadAmount(Tcl_Obj *bufferObj,
+			    const char *buffer, int pad1, int pad2);
+MODULE_SCOPE int	TkParsePadAmount(Tcl_Interp *interp,
+			    Tk_Window tkwin, Tcl_Obj *objPtr,
+			    int *pad1Ptr, int *pad2Ptr);
+MODULE_SCOPE void       TkFocusSplit(TkWindow *winPtr);
+MODULE_SCOPE void       TkFocusJoin(TkWindow *winPtr);
+MODULE_SCOPE int	TkpAlwaysShowSelection(Tk_Window tkwin);
+MODULE_SCOPE void	TkpDrawCharsInContext(Display * display,
+			    Drawable drawable, GC gc, Tk_Font tkfont,
+			    const char *source, int numBytes, int rangeStart,
+			    int rangeLength, int x, int y);
+MODULE_SCOPE int	TkpMeasureCharsInContext(Tk_Font tkfont,
+			    const char *source, int numBytes, int rangeStart,
+			    int rangeLength, int maxLength, int flags,
+			    int *lengthPtr);
+MODULE_SCOPE void	TkUnderlineCharsInContext(Display *display,
+			    Drawable drawable, GC gc, Tk_Font tkfont,
+			    const char *string, int numBytes, int x, int y,
+			    int firstByte, int lastByte);
+MODULE_SCOPE void	TkpGetFontAttrsForChar(Tk_Window tkwin, Tk_Font tkfont,
+			    Tcl_UniChar c, struct TkFontAttributes *faPtr);
+MODULE_SCOPE Tcl_Obj *	TkNewWindowObj(Tk_Window tkwin);
+MODULE_SCOPE void	TkpShowBusyWindow(TkBusy busy);
+MODULE_SCOPE void	TkpHideBusyWindow(TkBusy busy);
+MODULE_SCOPE void	TkpMakeTransparentWindowExist(Tk_Window tkwin,
+			    Window parent);
+MODULE_SCOPE void	TkpCreateBusy(Tk_FakeWin *winPtr, Tk_Window tkRef,
+			    Window *parentPtr, Tk_Window tkParent,
+			    TkBusy busy);
+MODULE_SCOPE int	TkBackgroundEvalObjv(Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const *objv, int flags);
+MODULE_SCOPE void	TkSendVirtualEvent(Tk_Window tgtWin,
+			    const char *eventName);
+MODULE_SCOPE Tcl_Command TkMakeEnsemble(Tcl_Interp *interp,
+			    const char *nsname, const char *name,
+			    ClientData clientData, const TkEnsemble *map);
+MODULE_SCOPE int	TkInitTkCmd(Tcl_Interp *interp,
+			    ClientData clientData);
+MODULE_SCOPE int	TkInitFontchooser(Tcl_Interp *interp,
+			    ClientData clientData);
+MODULE_SCOPE void	TkpWarpPointer(TkDisplay *dispPtr);
+
+#ifdef __WIN32__
+#define TkParseColor XParseColor
+#else
+MODULE_SCOPE Status TkParseColor (Display * display,
+				Colormap map, const char* spec,
+				XColor * colorPtr);
+#endif
+#ifdef HAVE_XFT
+MODULE_SCOPE void	TkUnixSetXftClipRegion(TkRegion clipRegion);
+#endif
+
+/*
+ * Unsupported commands.
+ */
+
+MODULE_SCOPE int	TkUnsupported1ObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[]);
+
+/*
+ * For Tktest.
+ */
+MODULE_SCOPE int SquareObjCmd(ClientData clientData,
+			    Tcl_Interp *interp, int objc,
+			    Tcl_Obj * const objv[]);
+MODULE_SCOPE int	TkOldTestInit(Tcl_Interp *interp);
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK))
+#define TkplatformtestInit(x) TCL_OK
+#else
+MODULE_SCOPE int	TkplatformtestInit(Tcl_Interp *interp);
+#endif
+
+#endif /* _TKINT */
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 78
+ * End:
+ */
diff -uNr blt2.4z/src/tkIntDecls.h blt2.4z.tcltk86/src/tkIntDecls.h
--- blt2.4z/src/tkIntDecls.h	1969-12-31 19:00:00.000000000 -0500
+++ blt2.4z.tcltk86/src/tkIntDecls.h	2013-08-20 11:45:27.000000000 -0400
@@ -0,0 +1,1177 @@
+/*
+ * tkIntDecls.h --
+ *
+ *	This file contains the declarations for all unsupported
+ *	functions that are exported by the Tk library.  These
+ *	interfaces are not guaranteed to remain the same between
+ *	versions.  Use at your own risk.
+ *
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKINTDECLS
+#define _TKINTDECLS
+
+#ifdef BUILD_tk
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLEXPORT
+#endif
+
+struct TkText;
+typedef struct TkTextBTree_ *TkTextBTree;
+struct TkTextDispChunk;
+struct TkTextIndex;
+struct TkTextSegment;
+struct TkSharedText;
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the generic/tkInt.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+/*
+ * Exported function declarations:
+ */
+
+/* 0 */
+EXTERN TkWindow *	TkAllocWindow(TkDisplay *dispPtr, int screenNum,
+				TkWindow *parentPtr);
+/* 1 */
+EXTERN void		TkBezierPoints(double control[], int numSteps,
+				double *coordPtr);
+/* 2 */
+EXTERN void		TkBezierScreenPoints(Tk_Canvas canvas,
+				double control[], int numSteps,
+				XPoint *xPointPtr);
+/* Slot 3 is reserved */
+/* 4 */
+EXTERN void		TkBindEventProc(TkWindow *winPtr, XEvent *eventPtr);
+/* 5 */
+EXTERN void		TkBindFree(TkMainInfo *mainPtr);
+/* 6 */
+EXTERN void		TkBindInit(TkMainInfo *mainPtr);
+/* 7 */
+EXTERN void		TkChangeEventWindow(XEvent *eventPtr,
+				TkWindow *winPtr);
+/* 8 */
+EXTERN int		TkClipInit(Tcl_Interp *interp, TkDisplay *dispPtr);
+/* 9 */
+EXTERN void		TkComputeAnchor(Tk_Anchor anchor, Tk_Window tkwin,
+				int padX, int padY, int innerWidth,
+				int innerHeight, int *xPtr, int *yPtr);
+/* Slot 10 is reserved */
+/* Slot 11 is reserved */
+/* 12 */
+EXTERN TkCursor *	TkCreateCursorFromData(Tk_Window tkwin,
+				const char *source, const char *mask,
+				int width, int height, int xHot, int yHot,
+				XColor fg, XColor bg);
+/* 13 */
+EXTERN int		TkCreateFrame(ClientData clientData,
+				Tcl_Interp *interp, int argc,
+				const char *const *argv, int toplevel,
+				const char *appName);
+/* 14 */
+EXTERN Tk_Window	TkCreateMainWindow(Tcl_Interp *interp,
+				const char *screenName, const char *baseName);
+/* 15 */
+EXTERN Time		TkCurrentTime(TkDisplay *dispPtr);
+/* 16 */
+EXTERN void		TkDeleteAllImages(TkMainInfo *mainPtr);
+/* 17 */
+EXTERN void		TkDoConfigureNotify(TkWindow *winPtr);
+/* 18 */
+EXTERN void		TkDrawInsetFocusHighlight(Tk_Window tkwin, GC gc,
+				int width, Drawable drawable, int padding);
+/* 19 */
+EXTERN void		TkEventDeadWindow(TkWindow *winPtr);
+/* 20 */
+EXTERN void		TkFillPolygon(Tk_Canvas canvas, double *coordPtr,
+				int numPoints, Display *display,
+				Drawable drawable, GC gc, GC outlineGC);
+/* 21 */
+EXTERN int		TkFindStateNum(Tcl_Interp *interp,
+				const char *option, const TkStateMap *mapPtr,
+				const char *strKey);
+/* 22 */
+EXTERN CONST86 char *	TkFindStateString(const TkStateMap *mapPtr,
+				int numKey);
+/* 23 */
+EXTERN void		TkFocusDeadWindow(TkWindow *winPtr);
+/* 24 */
+EXTERN int		TkFocusFilterEvent(TkWindow *winPtr,
+				XEvent *eventPtr);
+/* 25 */
+EXTERN TkWindow *	TkFocusKeyEvent(TkWindow *winPtr, XEvent *eventPtr);
+/* 26 */
+EXTERN void		TkFontPkgInit(TkMainInfo *mainPtr);
+/* 27 */
+EXTERN void		TkFontPkgFree(TkMainInfo *mainPtr);
+/* 28 */
+EXTERN void		TkFreeBindingTags(TkWindow *winPtr);
+/* 29 */
+EXTERN void		TkpFreeCursor(TkCursor *cursorPtr);
+/* 30 */
+EXTERN char *		TkGetBitmapData(Tcl_Interp *interp,
+				const char *string, const char *fileName,
+				int *widthPtr, int *heightPtr, int *hotXPtr,
+				int *hotYPtr);
+/* 31 */
+EXTERN void		TkGetButtPoints(double p1[], double p2[],
+				double width, int project, double m1[],
+				double m2[]);
+/* 32 */
+EXTERN TkCursor *	TkGetCursorByName(Tcl_Interp *interp,
+				Tk_Window tkwin, Tk_Uid string);
+/* 33 */
+EXTERN const char *	TkGetDefaultScreenName(Tcl_Interp *interp,
+				const char *screenName);
+/* 34 */
+EXTERN TkDisplay *	TkGetDisplay(Display *display);
+/* 35 */
+EXTERN int		TkGetDisplayOf(Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[], Tk_Window *tkwinPtr);
+/* 36 */
+EXTERN TkWindow *	TkGetFocusWin(TkWindow *winPtr);
+/* 37 */
+EXTERN int		TkGetInterpNames(Tcl_Interp *interp, Tk_Window tkwin);
+/* 38 */
+EXTERN int		TkGetMiterPoints(double p1[], double p2[],
+				double p3[], double width, double m1[],
+				double m2[]);
+/* 39 */
+EXTERN void		TkGetPointerCoords(Tk_Window tkwin, int *xPtr,
+				int *yPtr);
+/* 40 */
+EXTERN void		TkGetServerInfo(Tcl_Interp *interp, Tk_Window tkwin);
+/* 41 */
+EXTERN void		TkGrabDeadWindow(TkWindow *winPtr);
+/* 42 */
+EXTERN int		TkGrabState(TkWindow *winPtr);
+/* 43 */
+EXTERN void		TkIncludePoint(Tk_Item *itemPtr, double *pointPtr);
+/* 44 */
+EXTERN void		TkInOutEvents(XEvent *eventPtr, TkWindow *sourcePtr,
+				TkWindow *destPtr, int leaveType,
+				int enterType, Tcl_QueuePosition position);
+/* 45 */
+EXTERN void		TkInstallFrameMenu(Tk_Window tkwin);
+/* 46 */
+EXTERN CONST86 char *	TkKeysymToString(KeySym keysym);
+/* 47 */
+EXTERN int		TkLineToArea(double end1Ptr[], double end2Ptr[],
+				double rectPtr[]);
+/* 48 */
+EXTERN double		TkLineToPoint(double end1Ptr[], double end2Ptr[],
+				double pointPtr[]);
+/* 49 */
+EXTERN int		TkMakeBezierCurve(Tk_Canvas canvas, double *pointPtr,
+				int numPoints, int numSteps,
+				XPoint xPoints[], double dblPoints[]);
+/* 50 */
+EXTERN void		TkMakeBezierPostscript(Tcl_Interp *interp,
+				Tk_Canvas canvas, double *pointPtr,
+				int numPoints);
+/* 51 */
+EXTERN void		TkOptionClassChanged(TkWindow *winPtr);
+/* 52 */
+EXTERN void		TkOptionDeadWindow(TkWindow *winPtr);
+/* 53 */
+EXTERN int		TkOvalToArea(double *ovalPtr, double *rectPtr);
+/* 54 */
+EXTERN double		TkOvalToPoint(double ovalPtr[], double width,
+				int filled, double pointPtr[]);
+/* 55 */
+EXTERN int		TkpChangeFocus(TkWindow *winPtr, int force);
+/* 56 */
+EXTERN void		TkpCloseDisplay(TkDisplay *dispPtr);
+/* 57 */
+EXTERN void		TkpClaimFocus(TkWindow *topLevelPtr, int force);
+/* 58 */
+EXTERN void		TkpDisplayWarning(const char *msg, const char *title);
+/* 59 */
+EXTERN void		TkpGetAppName(Tcl_Interp *interp, Tcl_DString *name);
+/* 60 */
+EXTERN TkWindow *	TkpGetOtherWindow(TkWindow *winPtr);
+/* 61 */
+EXTERN TkWindow *	TkpGetWrapperWindow(TkWindow *winPtr);
+/* 62 */
+EXTERN int		TkpInit(Tcl_Interp *interp);
+/* 63 */
+EXTERN void		TkpInitializeMenuBindings(Tcl_Interp *interp,
+				Tk_BindingTable bindingTable);
+/* 64 */
+EXTERN void		TkpMakeContainer(Tk_Window tkwin);
+/* 65 */
+EXTERN void		TkpMakeMenuWindow(Tk_Window tkwin, int transient);
+/* 66 */
+EXTERN Window		TkpMakeWindow(TkWindow *winPtr, Window parent);
+/* 67 */
+EXTERN void		TkpMenuNotifyToplevelCreate(Tcl_Interp *interp,
+				const char *menuName);
+/* 68 */
+EXTERN TkDisplay *	TkpOpenDisplay(const char *display_name);
+/* 69 */
+EXTERN int		TkPointerEvent(XEvent *eventPtr, TkWindow *winPtr);
+/* 70 */
+EXTERN int		TkPolygonToArea(double *polyPtr, int numPoints,
+				double *rectPtr);
+/* 71 */
+EXTERN double		TkPolygonToPoint(double *polyPtr, int numPoints,
+				double *pointPtr);
+/* 72 */
+EXTERN int		TkPositionInTree(TkWindow *winPtr, TkWindow *treePtr);
+/* 73 */
+EXTERN void		TkpRedirectKeyEvent(TkWindow *winPtr,
+				XEvent *eventPtr);
+/* 74 */
+EXTERN void		TkpSetMainMenubar(Tcl_Interp *interp,
+				Tk_Window tkwin, const char *menuName);
+/* 75 */
+EXTERN int		TkpUseWindow(Tcl_Interp *interp, Tk_Window tkwin,
+				const char *string);
+/* Slot 76 is reserved */
+/* 77 */
+EXTERN void		TkQueueEventForAllChildren(TkWindow *winPtr,
+				XEvent *eventPtr);
+/* 78 */
+EXTERN int		TkReadBitmapFile(Display *display, Drawable d,
+				const char *filename,
+				unsigned int *width_return,
+				unsigned int *height_return,
+				Pixmap *bitmap_return, int *x_hot_return,
+				int *y_hot_return);
+/* 79 */
+EXTERN int		TkScrollWindow(Tk_Window tkwin, GC gc, int x, int y,
+				int width, int height, int dx, int dy,
+				TkRegion damageRgn);
+/* 80 */
+EXTERN void		TkSelDeadWindow(TkWindow *winPtr);
+/* 81 */
+EXTERN void		TkSelEventProc(Tk_Window tkwin, XEvent *eventPtr);
+/* 82 */
+EXTERN void		TkSelInit(Tk_Window tkwin);
+/* 83 */
+EXTERN void		TkSelPropProc(XEvent *eventPtr);
+/* Slot 84 is reserved */
+/* 85 */
+EXTERN void		TkSetWindowMenuBar(Tcl_Interp *interp,
+				Tk_Window tkwin, const char *oldMenuName,
+				const char *menuName);
+/* 86 */
+EXTERN KeySym		TkStringToKeysym(const char *name);
+/* 87 */
+EXTERN int		TkThickPolyLineToArea(double *coordPtr,
+				int numPoints, double width, int capStyle,
+				int joinStyle, double *rectPtr);
+/* 88 */
+EXTERN void		TkWmAddToColormapWindows(TkWindow *winPtr);
+/* 89 */
+EXTERN void		TkWmDeadWindow(TkWindow *winPtr);
+/* 90 */
+EXTERN TkWindow *	TkWmFocusToplevel(TkWindow *winPtr);
+/* 91 */
+EXTERN void		TkWmMapWindow(TkWindow *winPtr);
+/* 92 */
+EXTERN void		TkWmNewWindow(TkWindow *winPtr);
+/* 93 */
+EXTERN void		TkWmProtocolEventProc(TkWindow *winPtr,
+				XEvent *evenvPtr);
+/* 94 */
+EXTERN void		TkWmRemoveFromColormapWindows(TkWindow *winPtr);
+/* 95 */
+EXTERN void		TkWmRestackToplevel(TkWindow *winPtr, int aboveBelow,
+				TkWindow *otherPtr);
+/* 96 */
+EXTERN void		TkWmSetClass(TkWindow *winPtr);
+/* 97 */
+EXTERN void		TkWmUnmapWindow(TkWindow *winPtr);
+/* 98 */
+EXTERN Tcl_Obj *	TkDebugBitmap(Tk_Window tkwin, const char *name);
+/* 99 */
+EXTERN Tcl_Obj *	TkDebugBorder(Tk_Window tkwin, const char *name);
+/* 100 */
+EXTERN Tcl_Obj *	TkDebugCursor(Tk_Window tkwin, const char *name);
+/* 101 */
+EXTERN Tcl_Obj *	TkDebugColor(Tk_Window tkwin, const char *name);
+/* 102 */
+EXTERN Tcl_Obj *	TkDebugConfig(Tcl_Interp *interp,
+				Tk_OptionTable table);
+/* 103 */
+EXTERN Tcl_Obj *	TkDebugFont(Tk_Window tkwin, const char *name);
+/* 104 */
+EXTERN int		TkFindStateNumObj(Tcl_Interp *interp,
+				Tcl_Obj *optionPtr, const TkStateMap *mapPtr,
+				Tcl_Obj *keyPtr);
+/* 105 */
+EXTERN Tcl_HashTable *	TkGetBitmapPredefTable(void);
+/* 106 */
+EXTERN TkDisplay *	TkGetDisplayList(void);
+/* 107 */
+EXTERN TkMainInfo *	TkGetMainInfoList(void);
+/* 108 */
+EXTERN int		TkGetWindowFromObj(Tcl_Interp *interp,
+				Tk_Window tkwin, Tcl_Obj *objPtr,
+				Tk_Window *windowPtr);
+/* 109 */
+EXTERN CONST86 char *	TkpGetString(TkWindow *winPtr, XEvent *eventPtr,
+				Tcl_DString *dsPtr);
+/* 110 */
+EXTERN void		TkpGetSubFonts(Tcl_Interp *interp, Tk_Font tkfont);
+/* 111 */
+EXTERN Tcl_Obj *	TkpGetSystemDefault(Tk_Window tkwin,
+				const char *dbName, const char *className);
+/* 112 */
+EXTERN void		TkpMenuThreadInit(void);
+/* 113 */
+EXTERN void		TkClipBox(TkRegion rgn, XRectangle *rect_return);
+/* 114 */
+EXTERN TkRegion		TkCreateRegion(void);
+/* 115 */
+EXTERN void		TkDestroyRegion(TkRegion rgn);
+/* 116 */
+EXTERN void		TkIntersectRegion(TkRegion sra, TkRegion srcb,
+				TkRegion dr_return);
+/* 117 */
+EXTERN int		TkRectInRegion(TkRegion rgn, int x, int y,
+				unsigned int width, unsigned int height);
+/* 118 */
+EXTERN void		TkSetRegion(Display *display, GC gc, TkRegion rgn);
+/* 119 */
+EXTERN void		TkUnionRectWithRegion(XRectangle *rect, TkRegion src,
+				TkRegion dr_return);
+/* Slot 120 is reserved */
+#ifdef MAC_OSX_TK /* AQUA */
+/* 121 */
+EXTERN Pixmap		TkpCreateNativeBitmap(Display *display,
+				const void *source);
+#endif /* AQUA */
+#ifdef MAC_OSX_TK /* AQUA */
+/* 122 */
+EXTERN void		TkpDefineNativeBitmaps(void);
+#endif /* AQUA */
+/* Slot 123 is reserved */
+#ifdef MAC_OSX_TK /* AQUA */
+/* 124 */
+EXTERN Pixmap		TkpGetNativeAppBitmap(Display *display,
+				const char *name, int *width, int *height);
+#endif /* AQUA */
+/* Slot 125 is reserved */
+/* Slot 126 is reserved */
+/* Slot 127 is reserved */
+/* Slot 128 is reserved */
+/* Slot 129 is reserved */
+/* Slot 130 is reserved */
+/* Slot 131 is reserved */
+/* Slot 132 is reserved */
+/* Slot 133 is reserved */
+/* Slot 134 is reserved */
+/* 135 */
+EXTERN void		TkpDrawHighlightBorder(Tk_Window tkwin, GC fgGC,
+				GC bgGC, int highlightWidth,
+				Drawable drawable);
+/* 136 */
+EXTERN void		TkSetFocusWin(TkWindow *winPtr, int force);
+/* 137 */
+EXTERN void		TkpSetKeycodeAndState(Tk_Window tkwin, KeySym keySym,
+				XEvent *eventPtr);
+/* 138 */
+EXTERN KeySym		TkpGetKeySym(TkDisplay *dispPtr, XEvent *eventPtr);
+/* 139 */
+EXTERN void		TkpInitKeymapInfo(TkDisplay *dispPtr);
+/* 140 */
+EXTERN TkRegion		TkPhotoGetValidRegion(Tk_PhotoHandle handle);
+/* 141 */
+EXTERN TkWindow **	TkWmStackorderToplevel(TkWindow *parentPtr);
+/* 142 */
+EXTERN void		TkFocusFree(TkMainInfo *mainPtr);
+/* 143 */
+EXTERN void		TkClipCleanup(TkDisplay *dispPtr);
+/* 144 */
+EXTERN void		TkGCCleanup(TkDisplay *dispPtr);
+/* 145 */
+EXTERN void		TkSubtractRegion(TkRegion sra, TkRegion srcb,
+				TkRegion dr_return);
+/* 146 */
+EXTERN void		TkStylePkgInit(TkMainInfo *mainPtr);
+/* 147 */
+EXTERN void		TkStylePkgFree(TkMainInfo *mainPtr);
+/* 148 */
+EXTERN Tk_Window	TkToplevelWindowForCommand(Tcl_Interp *interp,
+				const char *cmdName);
+/* 149 */
+EXTERN const Tk_OptionSpec * TkGetOptionSpec(const char *name,
+				Tk_OptionTable optionTable);
+/* 150 */
+EXTERN int		TkMakeRawCurve(Tk_Canvas canvas, double *pointPtr,
+				int numPoints, int numSteps,
+				XPoint xPoints[], double dblPoints[]);
+/* 151 */
+EXTERN void		TkMakeRawCurvePostscript(Tcl_Interp *interp,
+				Tk_Canvas canvas, double *pointPtr,
+				int numPoints);
+/* 152 */
+EXTERN void		TkpDrawFrame(Tk_Window tkwin, Tk_3DBorder border,
+				int highlightWidth, int borderWidth,
+				int relief);
+/* 153 */
+EXTERN void		TkCreateThreadExitHandler(Tcl_ExitProc *proc,
+				ClientData clientData);
+/* 154 */
+EXTERN void		TkDeleteThreadExitHandler(Tcl_ExitProc *proc,
+				ClientData clientData);
+/* Slot 155 is reserved */
+/* 156 */
+EXTERN int		TkpTestembedCmd(ClientData clientData,
+				Tcl_Interp *interp, int argc,
+				const char **argv);
+/* 157 */
+EXTERN int		TkpTesttextCmd(ClientData dummy, Tcl_Interp *interp,
+				int argc, const char **argv);
+/* 158 */
+EXTERN int		TkSelGetSelection(Tcl_Interp *interp,
+				Tk_Window tkwin, Atom selection, Atom target,
+				Tk_GetSelProc *proc, ClientData clientData);
+/* 159 */
+EXTERN int		TkTextGetIndex(Tcl_Interp *interp,
+				struct TkText *textPtr, const char *string,
+				struct TkTextIndex *indexPtr);
+/* 160 */
+EXTERN int		TkTextIndexBackBytes(const struct TkText *textPtr,
+				const struct TkTextIndex *srcPtr, int count,
+				struct TkTextIndex *dstPtr);
+/* 161 */
+EXTERN int		TkTextIndexForwBytes(const struct TkText *textPtr,
+				const struct TkTextIndex *srcPtr, int count,
+				struct TkTextIndex *dstPtr);
+/* 162 */
+EXTERN struct TkTextIndex * TkTextMakeByteIndex(TkTextBTree tree,
+				const struct TkText *textPtr, int lineIndex,
+				int byteIndex, struct TkTextIndex *indexPtr);
+/* 163 */
+EXTERN int		TkTextPrintIndex(const struct TkText *textPtr,
+				const struct TkTextIndex *indexPtr,
+				char *string);
+/* 164 */
+EXTERN struct TkTextSegment * TkTextSetMark(struct TkText *textPtr,
+				const char *name,
+				struct TkTextIndex *indexPtr);
+/* 165 */
+EXTERN int		TkTextXviewCmd(struct TkText *textPtr,
+				Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[]);
+/* 166 */
+EXTERN void		TkTextChanged(struct TkSharedText *sharedTextPtr,
+				struct TkText *textPtr,
+				const struct TkTextIndex *index1Ptr,
+				const struct TkTextIndex *index2Ptr);
+/* 167 */
+EXTERN int		TkBTreeNumLines(TkTextBTree tree,
+				const struct TkText *textPtr);
+/* 168 */
+EXTERN void		TkTextInsertDisplayProc(struct TkText *textPtr,
+				struct TkTextDispChunk *chunkPtr, int x,
+				int y, int height, int baseline,
+				Display *display, Drawable dst, int screenY);
+/* 169 */
+EXTERN int		TkStateParseProc(ClientData clientData,
+				Tcl_Interp *interp, Tk_Window tkwin,
+				const char *value, char *widgRec, int offset);
+/* 170 */
+EXTERN CONST86 char *	TkStatePrintProc(ClientData clientData,
+				Tk_Window tkwin, char *widgRec, int offset,
+				Tcl_FreeProc **freeProcPtr);
+/* 171 */
+EXTERN int		TkCanvasDashParseProc(ClientData clientData,
+				Tcl_Interp *interp, Tk_Window tkwin,
+				const char *value, char *widgRec, int offset);
+/* 172 */
+EXTERN CONST86 char *	TkCanvasDashPrintProc(ClientData clientData,
+				Tk_Window tkwin, char *widgRec, int offset,
+				Tcl_FreeProc **freeProcPtr);
+/* 173 */
+EXTERN int		TkOffsetParseProc(ClientData clientData,
+				Tcl_Interp *interp, Tk_Window tkwin,
+				const char *value, char *widgRec, int offset);
+/* 174 */
+EXTERN CONST86 char *	TkOffsetPrintProc(ClientData clientData,
+				Tk_Window tkwin, char *widgRec, int offset,
+				Tcl_FreeProc **freeProcPtr);
+/* 175 */
+EXTERN int		TkPixelParseProc(ClientData clientData,
+				Tcl_Interp *interp, Tk_Window tkwin,
+				const char *value, char *widgRec, int offset);
+/* 176 */
+EXTERN CONST86 char *	TkPixelPrintProc(ClientData clientData,
+				Tk_Window tkwin, char *widgRec, int offset,
+				Tcl_FreeProc **freeProcPtr);
+/* 177 */
+EXTERN int		TkOrientParseProc(ClientData clientData,
+				Tcl_Interp *interp, Tk_Window tkwin,
+				const char *value, char *widgRec, int offset);
+/* 178 */
+EXTERN CONST86 char *	TkOrientPrintProc(ClientData clientData,
+				Tk_Window tkwin, char *widgRec, int offset,
+				Tcl_FreeProc **freeProcPtr);
+/* 179 */
+EXTERN int		TkSmoothParseProc(ClientData clientData,
+				Tcl_Interp *interp, Tk_Window tkwin,
+				const char *value, char *widgRec, int offset);
+/* 180 */
+EXTERN CONST86 char *	TkSmoothPrintProc(ClientData clientData,
+				Tk_Window tkwin, char *widgRec, int offset,
+				Tcl_FreeProc **freeProcPtr);
+/* 181 */
+EXTERN void		TkDrawAngledTextLayout(Display *display,
+				Drawable drawable, GC gc,
+				Tk_TextLayout layout, int x, int y,
+				double angle, int firstChar, int lastChar);
+/* 182 */
+EXTERN void		TkUnderlineAngledTextLayout(Display *display,
+				Drawable drawable, GC gc,
+				Tk_TextLayout layout, int x, int y,
+				double angle, int underline);
+/* 183 */
+EXTERN int		TkIntersectAngledTextLayout(Tk_TextLayout layout,
+				int x, int y, int width, int height,
+				double angle);
+/* 184 */
+EXTERN void		TkDrawAngledChars(Display *display,
+				Drawable drawable, GC gc, Tk_Font tkfont,
+				const char *source, int numBytes, double x,
+				double y, double angle);
+
+typedef struct TkIntStubs {
+    int magic;
+    void *hooks;
+
+    TkWindow * (*tkAllocWindow) (TkDisplay *dispPtr, int screenNum, TkWindow *parentPtr); /* 0 */
+    void (*tkBezierPoints) (double control[], int numSteps, double *coordPtr); /* 1 */
+    void (*tkBezierScreenPoints) (Tk_Canvas canvas, double control[], int numSteps, XPoint *xPointPtr); /* 2 */
+    void (*reserved3)(void);
+    void (*tkBindEventProc) (TkWindow *winPtr, XEvent *eventPtr); /* 4 */
+    void (*tkBindFree) (TkMainInfo *mainPtr); /* 5 */
+    void (*tkBindInit) (TkMainInfo *mainPtr); /* 6 */
+    void (*tkChangeEventWindow) (XEvent *eventPtr, TkWindow *winPtr); /* 7 */
+    int (*tkClipInit) (Tcl_Interp *interp, TkDisplay *dispPtr); /* 8 */
+    void (*tkComputeAnchor) (Tk_Anchor anchor, Tk_Window tkwin, int padX, int padY, int innerWidth, int innerHeight, int *xPtr, int *yPtr); /* 9 */
+    void (*reserved10)(void);
+    void (*reserved11)(void);
+    TkCursor * (*tkCreateCursorFromData) (Tk_Window tkwin, const char *source, const char *mask, int width, int height, int xHot, int yHot, XColor fg, XColor bg); /* 12 */
+    int (*tkCreateFrame) (ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv, int toplevel, const char *appName); /* 13 */
+    Tk_Window (*tkCreateMainWindow) (Tcl_Interp *interp, const char *screenName, const char *baseName); /* 14 */
+    Time (*tkCurrentTime) (TkDisplay *dispPtr); /* 15 */
+    void (*tkDeleteAllImages) (TkMainInfo *mainPtr); /* 16 */
+    void (*tkDoConfigureNotify) (TkWindow *winPtr); /* 17 */
+    void (*tkDrawInsetFocusHighlight) (Tk_Window tkwin, GC gc, int width, Drawable drawable, int padding); /* 18 */
+    void (*tkEventDeadWindow) (TkWindow *winPtr); /* 19 */
+    void (*tkFillPolygon) (Tk_Canvas canvas, double *coordPtr, int numPoints, Display *display, Drawable drawable, GC gc, GC outlineGC); /* 20 */
+    int (*tkFindStateNum) (Tcl_Interp *interp, const char *option, const TkStateMap *mapPtr, const char *strKey); /* 21 */
+    CONST86 char * (*tkFindStateString) (const TkStateMap *mapPtr, int numKey); /* 22 */
+    void (*tkFocusDeadWindow) (TkWindow *winPtr); /* 23 */
+    int (*tkFocusFilterEvent) (TkWindow *winPtr, XEvent *eventPtr); /* 24 */
+    TkWindow * (*tkFocusKeyEvent) (TkWindow *winPtr, XEvent *eventPtr); /* 25 */
+    void (*tkFontPkgInit) (TkMainInfo *mainPtr); /* 26 */
+    void (*tkFontPkgFree) (TkMainInfo *mainPtr); /* 27 */
+    void (*tkFreeBindingTags) (TkWindow *winPtr); /* 28 */
+    void (*tkpFreeCursor) (TkCursor *cursorPtr); /* 29 */
+    char * (*tkGetBitmapData) (Tcl_Interp *interp, const char *string, const char *fileName, int *widthPtr, int *heightPtr, int *hotXPtr, int *hotYPtr); /* 30 */
+    void (*tkGetButtPoints) (double p1[], double p2[], double width, int project, double m1[], double m2[]); /* 31 */
+    TkCursor * (*tkGetCursorByName) (Tcl_Interp *interp, Tk_Window tkwin, Tk_Uid string); /* 32 */
+    const char * (*tkGetDefaultScreenName) (Tcl_Interp *interp, const char *screenName); /* 33 */
+    TkDisplay * (*tkGetDisplay) (Display *display); /* 34 */
+    int (*tkGetDisplayOf) (Tcl_Interp *interp, int objc, Tcl_Obj *const objv[], Tk_Window *tkwinPtr); /* 35 */
+    TkWindow * (*tkGetFocusWin) (TkWindow *winPtr); /* 36 */
+    int (*tkGetInterpNames) (Tcl_Interp *interp, Tk_Window tkwin); /* 37 */
+    int (*tkGetMiterPoints) (double p1[], double p2[], double p3[], double width, double m1[], double m2[]); /* 38 */
+    void (*tkGetPointerCoords) (Tk_Window tkwin, int *xPtr, int *yPtr); /* 39 */
+    void (*tkGetServerInfo) (Tcl_Interp *interp, Tk_Window tkwin); /* 40 */
+    void (*tkGrabDeadWindow) (TkWindow *winPtr); /* 41 */
+    int (*tkGrabState) (TkWindow *winPtr); /* 42 */
+    void (*tkIncludePoint) (Tk_Item *itemPtr, double *pointPtr); /* 43 */
+    void (*tkInOutEvents) (XEvent *eventPtr, TkWindow *sourcePtr, TkWindow *destPtr, int leaveType, int enterType, Tcl_QueuePosition position); /* 44 */
+    void (*tkInstallFrameMenu) (Tk_Window tkwin); /* 45 */
+    CONST86 char * (*tkKeysymToString) (KeySym keysym); /* 46 */
+    int (*tkLineToArea) (double end1Ptr[], double end2Ptr[], double rectPtr[]); /* 47 */
+    double (*tkLineToPoint) (double end1Ptr[], double end2Ptr[], double pointPtr[]); /* 48 */
+    int (*tkMakeBezierCurve) (Tk_Canvas canvas, double *pointPtr, int numPoints, int numSteps, XPoint xPoints[], double dblPoints[]); /* 49 */
+    void (*tkMakeBezierPostscript) (Tcl_Interp *interp, Tk_Canvas canvas, double *pointPtr, int numPoints); /* 50 */
+    void (*tkOptionClassChanged) (TkWindow *winPtr); /* 51 */
+    void (*tkOptionDeadWindow) (TkWindow *winPtr); /* 52 */
+    int (*tkOvalToArea) (double *ovalPtr, double *rectPtr); /* 53 */
+    double (*tkOvalToPoint) (double ovalPtr[], double width, int filled, double pointPtr[]); /* 54 */
+    int (*tkpChangeFocus) (TkWindow *winPtr, int force); /* 55 */
+    void (*tkpCloseDisplay) (TkDisplay *dispPtr); /* 56 */
+    void (*tkpClaimFocus) (TkWindow *topLevelPtr, int force); /* 57 */
+    void (*tkpDisplayWarning) (const char *msg, const char *title); /* 58 */
+    void (*tkpGetAppName) (Tcl_Interp *interp, Tcl_DString *name); /* 59 */
+    TkWindow * (*tkpGetOtherWindow) (TkWindow *winPtr); /* 60 */
+    TkWindow * (*tkpGetWrapperWindow) (TkWindow *winPtr); /* 61 */
+    int (*tkpInit) (Tcl_Interp *interp); /* 62 */
+    void (*tkpInitializeMenuBindings) (Tcl_Interp *interp, Tk_BindingTable bindingTable); /* 63 */
+    void (*tkpMakeContainer) (Tk_Window tkwin); /* 64 */
+    void (*tkpMakeMenuWindow) (Tk_Window tkwin, int transient); /* 65 */
+    Window (*tkpMakeWindow) (TkWindow *winPtr, Window parent); /* 66 */
+    void (*tkpMenuNotifyToplevelCreate) (Tcl_Interp *interp, const char *menuName); /* 67 */
+    TkDisplay * (*tkpOpenDisplay) (const char *display_name); /* 68 */
+    int (*tkPointerEvent) (XEvent *eventPtr, TkWindow *winPtr); /* 69 */
+    int (*tkPolygonToArea) (double *polyPtr, int numPoints, double *rectPtr); /* 70 */
+    double (*tkPolygonToPoint) (double *polyPtr, int numPoints, double *pointPtr); /* 71 */
+    int (*tkPositionInTree) (TkWindow *winPtr, TkWindow *treePtr); /* 72 */
+    void (*tkpRedirectKeyEvent) (TkWindow *winPtr, XEvent *eventPtr); /* 73 */
+    void (*tkpSetMainMenubar) (Tcl_Interp *interp, Tk_Window tkwin, const char *menuName); /* 74 */
+    int (*tkpUseWindow) (Tcl_Interp *interp, Tk_Window tkwin, const char *string); /* 75 */
+    void (*reserved76)(void);
+    void (*tkQueueEventForAllChildren) (TkWindow *winPtr, XEvent *eventPtr); /* 77 */
+    int (*tkReadBitmapFile) (Display *display, Drawable d, const char *filename, unsigned int *width_return, unsigned int *height_return, Pixmap *bitmap_return, int *x_hot_return, int *y_hot_return); /* 78 */
+    int (*tkScrollWindow) (Tk_Window tkwin, GC gc, int x, int y, int width, int height, int dx, int dy, TkRegion damageRgn); /* 79 */
+    void (*tkSelDeadWindow) (TkWindow *winPtr); /* 80 */
+    void (*tkSelEventProc) (Tk_Window tkwin, XEvent *eventPtr); /* 81 */
+    void (*tkSelInit) (Tk_Window tkwin); /* 82 */
+    void (*tkSelPropProc) (XEvent *eventPtr); /* 83 */
+    void (*reserved84)(void);
+    void (*tkSetWindowMenuBar) (Tcl_Interp *interp, Tk_Window tkwin, const char *oldMenuName, const char *menuName); /* 85 */
+    KeySym (*tkStringToKeysym) (const char *name); /* 86 */
+    int (*tkThickPolyLineToArea) (double *coordPtr, int numPoints, double width, int capStyle, int joinStyle, double *rectPtr); /* 87 */
+    void (*tkWmAddToColormapWindows) (TkWindow *winPtr); /* 88 */
+    void (*tkWmDeadWindow) (TkWindow *winPtr); /* 89 */
+    TkWindow * (*tkWmFocusToplevel) (TkWindow *winPtr); /* 90 */
+    void (*tkWmMapWindow) (TkWindow *winPtr); /* 91 */
+    void (*tkWmNewWindow) (TkWindow *winPtr); /* 92 */
+    void (*tkWmProtocolEventProc) (TkWindow *winPtr, XEvent *evenvPtr); /* 93 */
+    void (*tkWmRemoveFromColormapWindows) (TkWindow *winPtr); /* 94 */
+    void (*tkWmRestackToplevel) (TkWindow *winPtr, int aboveBelow, TkWindow *otherPtr); /* 95 */
+    void (*tkWmSetClass) (TkWindow *winPtr); /* 96 */
+    void (*tkWmUnmapWindow) (TkWindow *winPtr); /* 97 */
+    Tcl_Obj * (*tkDebugBitmap) (Tk_Window tkwin, const char *name); /* 98 */
+    Tcl_Obj * (*tkDebugBorder) (Tk_Window tkwin, const char *name); /* 99 */
+    Tcl_Obj * (*tkDebugCursor) (Tk_Window tkwin, const char *name); /* 100 */
+    Tcl_Obj * (*tkDebugColor) (Tk_Window tkwin, const char *name); /* 101 */
+    Tcl_Obj * (*tkDebugConfig) (Tcl_Interp *interp, Tk_OptionTable table); /* 102 */
+    Tcl_Obj * (*tkDebugFont) (Tk_Window tkwin, const char *name); /* 103 */
+    int (*tkFindStateNumObj) (Tcl_Interp *interp, Tcl_Obj *optionPtr, const TkStateMap *mapPtr, Tcl_Obj *keyPtr); /* 104 */
+    Tcl_HashTable * (*tkGetBitmapPredefTable) (void); /* 105 */
+    TkDisplay * (*tkGetDisplayList) (void); /* 106 */
+    TkMainInfo * (*tkGetMainInfoList) (void); /* 107 */
+    int (*tkGetWindowFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr, Tk_Window *windowPtr); /* 108 */
+    CONST86 char * (*tkpGetString) (TkWindow *winPtr, XEvent *eventPtr, Tcl_DString *dsPtr); /* 109 */
+    void (*tkpGetSubFonts) (Tcl_Interp *interp, Tk_Font tkfont); /* 110 */
+    Tcl_Obj * (*tkpGetSystemDefault) (Tk_Window tkwin, const char *dbName, const char *className); /* 111 */
+    void (*tkpMenuThreadInit) (void); /* 112 */
+    void (*tkClipBox) (TkRegion rgn, XRectangle *rect_return); /* 113 */
+    TkRegion (*tkCreateRegion) (void); /* 114 */
+    void (*tkDestroyRegion) (TkRegion rgn); /* 115 */
+    void (*tkIntersectRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 116 */
+    int (*tkRectInRegion) (TkRegion rgn, int x, int y, unsigned int width, unsigned int height); /* 117 */
+    void (*tkSetRegion) (Display *display, GC gc, TkRegion rgn); /* 118 */
+    void (*tkUnionRectWithRegion) (XRectangle *rect, TkRegion src, TkRegion dr_return); /* 119 */
+    void (*reserved120)(void);
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void (*reserved121)(void);
+#endif /* X11 */
+#if defined(__WIN32__) /* WIN */
+    void (*reserved121)(void);
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void (*reserved121)(void); /* Dummy entry for stubs table backwards compatibility */
+    Pixmap (*tkpCreateNativeBitmap) (Display *display, const void *source); /* 121 */
+#endif /* AQUA */
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void (*reserved122)(void);
+#endif /* X11 */
+#if defined(__WIN32__) /* WIN */
+    void (*reserved122)(void);
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void (*reserved122)(void); /* Dummy entry for stubs table backwards compatibility */
+    void (*tkpDefineNativeBitmaps) (void); /* 122 */
+#endif /* AQUA */
+    void (*reserved123)(void);
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+    void (*reserved124)(void);
+#endif /* X11 */
+#if defined(__WIN32__) /* WIN */
+    void (*reserved124)(void);
+#endif /* WIN */
+#ifdef MAC_OSX_TK /* AQUA */
+    void (*reserved124)(void); /* Dummy entry for stubs table backwards compatibility */
+    Pixmap (*tkpGetNativeAppBitmap) (Display *display, const char *name, int *width, int *height); /* 124 */
+#endif /* AQUA */
+    void (*reserved125)(void);
+    void (*reserved126)(void);
+    void (*reserved127)(void);
+    void (*reserved128)(void);
+    void (*reserved129)(void);
+    void (*reserved130)(void);
+    void (*reserved131)(void);
+    void (*reserved132)(void);
+    void (*reserved133)(void);
+    void (*reserved134)(void);
+    void (*tkpDrawHighlightBorder) (Tk_Window tkwin, GC fgGC, GC bgGC, int highlightWidth, Drawable drawable); /* 135 */
+    void (*tkSetFocusWin) (TkWindow *winPtr, int force); /* 136 */
+    void (*tkpSetKeycodeAndState) (Tk_Window tkwin, KeySym keySym, XEvent *eventPtr); /* 137 */
+    KeySym (*tkpGetKeySym) (TkDisplay *dispPtr, XEvent *eventPtr); /* 138 */
+    void (*tkpInitKeymapInfo) (TkDisplay *dispPtr); /* 139 */
+    TkRegion (*tkPhotoGetValidRegion) (Tk_PhotoHandle handle); /* 140 */
+    TkWindow ** (*tkWmStackorderToplevel) (TkWindow *parentPtr); /* 141 */
+    void (*tkFocusFree) (TkMainInfo *mainPtr); /* 142 */
+    void (*tkClipCleanup) (TkDisplay *dispPtr); /* 143 */
+    void (*tkGCCleanup) (TkDisplay *dispPtr); /* 144 */
+    void (*tkSubtractRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 145 */
+    void (*tkStylePkgInit) (TkMainInfo *mainPtr); /* 146 */
+    void (*tkStylePkgFree) (TkMainInfo *mainPtr); /* 147 */
+    Tk_Window (*tkToplevelWindowForCommand) (Tcl_Interp *interp, const char *cmdName); /* 148 */
+    const Tk_OptionSpec * (*tkGetOptionSpec) (const char *name, Tk_OptionTable optionTable); /* 149 */
+    int (*tkMakeRawCurve) (Tk_Canvas canvas, double *pointPtr, int numPoints, int numSteps, XPoint xPoints[], double dblPoints[]); /* 150 */
+    void (*tkMakeRawCurvePostscript) (Tcl_Interp *interp, Tk_Canvas canvas, double *pointPtr, int numPoints); /* 151 */
+    void (*tkpDrawFrame) (Tk_Window tkwin, Tk_3DBorder border, int highlightWidth, int borderWidth, int relief); /* 152 */
+    void (*tkCreateThreadExitHandler) (Tcl_ExitProc *proc, ClientData clientData); /* 153 */
+    void (*tkDeleteThreadExitHandler) (Tcl_ExitProc *proc, ClientData clientData); /* 154 */
+    void (*reserved155)(void);
+    int (*tkpTestembedCmd) (ClientData clientData, Tcl_Interp *interp, int argc, const char **argv); /* 156 */
+    int (*tkpTesttextCmd) (ClientData dummy, Tcl_Interp *interp, int argc, const char **argv); /* 157 */
+    int (*tkSelGetSelection) (Tcl_Interp *interp, Tk_Window tkwin, Atom selection, Atom target, Tk_GetSelProc *proc, ClientData clientData); /* 158 */
+    int (*tkTextGetIndex) (Tcl_Interp *interp, struct TkText *textPtr, const char *string, struct TkTextIndex *indexPtr); /* 159 */
+    int (*tkTextIndexBackBytes) (const struct TkText *textPtr, const struct TkTextIndex *srcPtr, int count, struct TkTextIndex *dstPtr); /* 160 */
+    int (*tkTextIndexForwBytes) (const struct TkText *textPtr, const struct TkTextIndex *srcPtr, int count, struct TkTextIndex *dstPtr); /* 161 */
+    struct TkTextIndex * (*tkTextMakeByteIndex) (TkTextBTree tree, const struct TkText *textPtr, int lineIndex, int byteIndex, struct TkTextIndex *indexPtr); /* 162 */
+    int (*tkTextPrintIndex) (const struct TkText *textPtr, const struct TkTextIndex *indexPtr, char *string); /* 163 */
+    struct TkTextSegment * (*tkTextSetMark) (struct TkText *textPtr, const char *name, struct TkTextIndex *indexPtr); /* 164 */
+    int (*tkTextXviewCmd) (struct TkText *textPtr, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 165 */
+    void (*tkTextChanged) (struct TkSharedText *sharedTextPtr, struct TkText *textPtr, const struct TkTextIndex *index1Ptr, const struct TkTextIndex *index2Ptr); /* 166 */
+    int (*tkBTreeNumLines) (TkTextBTree tree, const struct TkText *textPtr); /* 167 */
+    void (*tkTextInsertDisplayProc) (struct TkText *textPtr, struct TkTextDispChunk *chunkPtr, int x, int y, int height, int baseline, Display *display, Drawable dst, int screenY); /* 168 */
+    int (*tkStateParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 169 */
+    CONST86 char * (*tkStatePrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 170 */
+    int (*tkCanvasDashParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 171 */
+    CONST86 char * (*tkCanvasDashPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 172 */
+    int (*tkOffsetParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 173 */
+    CONST86 char * (*tkOffsetPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 174 */
+    int (*tkPixelParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 175 */
+    CONST86 char * (*tkPixelPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 176 */
+    int (*tkOrientParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 177 */
+    CONST86 char * (*tkOrientPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 178 */
+    int (*tkSmoothParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 179 */
+    CONST86 char * (*tkSmoothPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 180 */
+    void (*tkDrawAngledTextLayout) (Display *display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, double angle, int firstChar, int lastChar); /* 181 */
+    void (*tkUnderlineAngledTextLayout) (Display *display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, double angle, int underline); /* 182 */
+    int (*tkIntersectAngledTextLayout) (Tk_TextLayout layout, int x, int y, int width, int height, double angle); /* 183 */
+    void (*tkDrawAngledChars) (Display *display, Drawable drawable, GC gc, Tk_Font tkfont, const char *source, int numBytes, double x, double y, double angle); /* 184 */
+} TkIntStubs;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern const TkIntStubs *tkIntStubsPtr;
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(USE_TK_STUBS)
+
+/*
+ * Inline function declarations:
+ */
+
+#define TkAllocWindow \
+	(tkIntStubsPtr->tkAllocWindow) /* 0 */
+#define TkBezierPoints \
+	(tkIntStubsPtr->tkBezierPoints) /* 1 */
+#define TkBezierScreenPoints \
+	(tkIntStubsPtr->tkBezierScreenPoints) /* 2 */
+/* Slot 3 is reserved */
+#define TkBindEventProc \
+	(tkIntStubsPtr->tkBindEventProc) /* 4 */
+#define TkBindFree \
+	(tkIntStubsPtr->tkBindFree) /* 5 */
+#define TkBindInit \
+	(tkIntStubsPtr->tkBindInit) /* 6 */
+#define TkChangeEventWindow \
+	(tkIntStubsPtr->tkChangeEventWindow) /* 7 */
+#define TkClipInit \
+	(tkIntStubsPtr->tkClipInit) /* 8 */
+#define TkComputeAnchor \
+	(tkIntStubsPtr->tkComputeAnchor) /* 9 */
+/* Slot 10 is reserved */
+/* Slot 11 is reserved */
+#define TkCreateCursorFromData \
+	(tkIntStubsPtr->tkCreateCursorFromData) /* 12 */
+#define TkCreateFrame \
+	(tkIntStubsPtr->tkCreateFrame) /* 13 */
+#define TkCreateMainWindow \
+	(tkIntStubsPtr->tkCreateMainWindow) /* 14 */
+#define TkCurrentTime \
+	(tkIntStubsPtr->tkCurrentTime) /* 15 */
+#define TkDeleteAllImages \
+	(tkIntStubsPtr->tkDeleteAllImages) /* 16 */
+#define TkDoConfigureNotify \
+	(tkIntStubsPtr->tkDoConfigureNotify) /* 17 */
+#define TkDrawInsetFocusHighlight \
+	(tkIntStubsPtr->tkDrawInsetFocusHighlight) /* 18 */
+#define TkEventDeadWindow \
+	(tkIntStubsPtr->tkEventDeadWindow) /* 19 */
+#define TkFillPolygon \
+	(tkIntStubsPtr->tkFillPolygon) /* 20 */
+#define TkFindStateNum \
+	(tkIntStubsPtr->tkFindStateNum) /* 21 */
+#define TkFindStateString \
+	(tkIntStubsPtr->tkFindStateString) /* 22 */
+#define TkFocusDeadWindow \
+	(tkIntStubsPtr->tkFocusDeadWindow) /* 23 */
+#define TkFocusFilterEvent \
+	(tkIntStubsPtr->tkFocusFilterEvent) /* 24 */
+#define TkFocusKeyEvent \
+	(tkIntStubsPtr->tkFocusKeyEvent) /* 25 */
+#define TkFontPkgInit \
+	(tkIntStubsPtr->tkFontPkgInit) /* 26 */
+#define TkFontPkgFree \
+	(tkIntStubsPtr->tkFontPkgFree) /* 27 */
+#define TkFreeBindingTags \
+	(tkIntStubsPtr->tkFreeBindingTags) /* 28 */
+#define TkpFreeCursor \
+	(tkIntStubsPtr->tkpFreeCursor) /* 29 */
+#define TkGetBitmapData \
+	(tkIntStubsPtr->tkGetBitmapData) /* 30 */
+#define TkGetButtPoints \
+	(tkIntStubsPtr->tkGetButtPoints) /* 31 */
+#define TkGetCursorByName \
+	(tkIntStubsPtr->tkGetCursorByName) /* 32 */
+#define TkGetDefaultScreenName \
+	(tkIntStubsPtr->tkGetDefaultScreenName) /* 33 */
+#define TkGetDisplay \
+	(tkIntStubsPtr->tkGetDisplay) /* 34 */
+#define TkGetDisplayOf \
+	(tkIntStubsPtr->tkGetDisplayOf) /* 35 */
+#define TkGetFocusWin \
+	(tkIntStubsPtr->tkGetFocusWin) /* 36 */
+#define TkGetInterpNames \
+	(tkIntStubsPtr->tkGetInterpNames) /* 37 */
+#define TkGetMiterPoints \
+	(tkIntStubsPtr->tkGetMiterPoints) /* 38 */
+#define TkGetPointerCoords \
+	(tkIntStubsPtr->tkGetPointerCoords) /* 39 */
+#define TkGetServerInfo \
+	(tkIntStubsPtr->tkGetServerInfo) /* 40 */
+#define TkGrabDeadWindow \
+	(tkIntStubsPtr->tkGrabDeadWindow) /* 41 */
+#define TkGrabState \
+	(tkIntStubsPtr->tkGrabState) /* 42 */
+#define TkIncludePoint \
+	(tkIntStubsPtr->tkIncludePoint) /* 43 */
+#define TkInOutEvents \
+	(tkIntStubsPtr->tkInOutEvents) /* 44 */
+#define TkInstallFrameMenu \
+	(tkIntStubsPtr->tkInstallFrameMenu) /* 45 */
+#define TkKeysymToString \
+	(tkIntStubsPtr->tkKeysymToString) /* 46 */
+#define TkLineToArea \
+	(tkIntStubsPtr->tkLineToArea) /* 47 */
+#define TkLineToPoint \
+	(tkIntStubsPtr->tkLineToPoint) /* 48 */
+#define TkMakeBezierCurve \
+	(tkIntStubsPtr->tkMakeBezierCurve) /* 49 */
+#define TkMakeBezierPostscript \
+	(tkIntStubsPtr->tkMakeBezierPostscript) /* 50 */
+#define TkOptionClassChanged \
+	(tkIntStubsPtr->tkOptionClassChanged) /* 51 */
+#define TkOptionDeadWindow \
+	(tkIntStubsPtr->tkOptionDeadWindow) /* 52 */
+#define TkOvalToArea \
+	(tkIntStubsPtr->tkOvalToArea) /* 53 */
+#define TkOvalToPoint \
+	(tkIntStubsPtr->tkOvalToPoint) /* 54 */
+#define TkpChangeFocus \
+	(tkIntStubsPtr->tkpChangeFocus) /* 55 */
+#define TkpCloseDisplay \
+	(tkIntStubsPtr->tkpCloseDisplay) /* 56 */
+#define TkpClaimFocus \
+	(tkIntStubsPtr->tkpClaimFocus) /* 57 */
+#define TkpDisplayWarning \
+	(tkIntStubsPtr->tkpDisplayWarning) /* 58 */
+#define TkpGetAppName \
+	(tkIntStubsPtr->tkpGetAppName) /* 59 */
+#define TkpGetOtherWindow \
+	(tkIntStubsPtr->tkpGetOtherWindow) /* 60 */
+#define TkpGetWrapperWindow \
+	(tkIntStubsPtr->tkpGetWrapperWindow) /* 61 */
+#define TkpInit \
+	(tkIntStubsPtr->tkpInit) /* 62 */
+#define TkpInitializeMenuBindings \
+	(tkIntStubsPtr->tkpInitializeMenuBindings) /* 63 */
+#define TkpMakeContainer \
+	(tkIntStubsPtr->tkpMakeContainer) /* 64 */
+#define TkpMakeMenuWindow \
+	(tkIntStubsPtr->tkpMakeMenuWindow) /* 65 */
+#define TkpMakeWindow \
+	(tkIntStubsPtr->tkpMakeWindow) /* 66 */
+#define TkpMenuNotifyToplevelCreate \
+	(tkIntStubsPtr->tkpMenuNotifyToplevelCreate) /* 67 */
+#define TkpOpenDisplay \
+	(tkIntStubsPtr->tkpOpenDisplay) /* 68 */
+#define TkPointerEvent \
+	(tkIntStubsPtr->tkPointerEvent) /* 69 */
+#define TkPolygonToArea \
+	(tkIntStubsPtr->tkPolygonToArea) /* 70 */
+#define TkPolygonToPoint \
+	(tkIntStubsPtr->tkPolygonToPoint) /* 71 */
+#define TkPositionInTree \
+	(tkIntStubsPtr->tkPositionInTree) /* 72 */
+#define TkpRedirectKeyEvent \
+	(tkIntStubsPtr->tkpRedirectKeyEvent) /* 73 */
+#define TkpSetMainMenubar \
+	(tkIntStubsPtr->tkpSetMainMenubar) /* 74 */
+#define TkpUseWindow \
+	(tkIntStubsPtr->tkpUseWindow) /* 75 */
+/* Slot 76 is reserved */
+#define TkQueueEventForAllChildren \
+	(tkIntStubsPtr->tkQueueEventForAllChildren) /* 77 */
+#define TkReadBitmapFile \
+	(tkIntStubsPtr->tkReadBitmapFile) /* 78 */
+#define TkScrollWindow \
+	(tkIntStubsPtr->tkScrollWindow) /* 79 */
+#define TkSelDeadWindow \
+	(tkIntStubsPtr->tkSelDeadWindow) /* 80 */
+#define TkSelEventProc \
+	(tkIntStubsPtr->tkSelEventProc) /* 81 */
+#define TkSelInit \
+	(tkIntStubsPtr->tkSelInit) /* 82 */
+#define TkSelPropProc \
+	(tkIntStubsPtr->tkSelPropProc) /* 83 */
+/* Slot 84 is reserved */
+#define TkSetWindowMenuBar \
+	(tkIntStubsPtr->tkSetWindowMenuBar) /* 85 */
+#define TkStringToKeysym \
+	(tkIntStubsPtr->tkStringToKeysym) /* 86 */
+#define TkThickPolyLineToArea \
+	(tkIntStubsPtr->tkThickPolyLineToArea) /* 87 */
+#define TkWmAddToColormapWindows \
+	(tkIntStubsPtr->tkWmAddToColormapWindows) /* 88 */
+#define TkWmDeadWindow \
+	(tkIntStubsPtr->tkWmDeadWindow) /* 89 */
+#define TkWmFocusToplevel \
+	(tkIntStubsPtr->tkWmFocusToplevel) /* 90 */
+#define TkWmMapWindow \
+	(tkIntStubsPtr->tkWmMapWindow) /* 91 */
+#define TkWmNewWindow \
+	(tkIntStubsPtr->tkWmNewWindow) /* 92 */
+#define TkWmProtocolEventProc \
+	(tkIntStubsPtr->tkWmProtocolEventProc) /* 93 */
+#define TkWmRemoveFromColormapWindows \
+	(tkIntStubsPtr->tkWmRemoveFromColormapWindows) /* 94 */
+#define TkWmRestackToplevel \
+	(tkIntStubsPtr->tkWmRestackToplevel) /* 95 */
+#define TkWmSetClass \
+	(tkIntStubsPtr->tkWmSetClass) /* 96 */
+#define TkWmUnmapWindow \
+	(tkIntStubsPtr->tkWmUnmapWindow) /* 97 */
+#define TkDebugBitmap \
+	(tkIntStubsPtr->tkDebugBitmap) /* 98 */
+#define TkDebugBorder \
+	(tkIntStubsPtr->tkDebugBorder) /* 99 */
+#define TkDebugCursor \
+	(tkIntStubsPtr->tkDebugCursor) /* 100 */
+#define TkDebugColor \
+	(tkIntStubsPtr->tkDebugColor) /* 101 */
+#define TkDebugConfig \
+	(tkIntStubsPtr->tkDebugConfig) /* 102 */
+#define TkDebugFont \
+	(tkIntStubsPtr->tkDebugFont) /* 103 */
+#define TkFindStateNumObj \
+	(tkIntStubsPtr->tkFindStateNumObj) /* 104 */
+#define TkGetBitmapPredefTable \
+	(tkIntStubsPtr->tkGetBitmapPredefTable) /* 105 */
+#define TkGetDisplayList \
+	(tkIntStubsPtr->tkGetDisplayList) /* 106 */
+#define TkGetMainInfoList \
+	(tkIntStubsPtr->tkGetMainInfoList) /* 107 */
+#define TkGetWindowFromObj \
+	(tkIntStubsPtr->tkGetWindowFromObj) /* 108 */
+#define TkpGetString \
+	(tkIntStubsPtr->tkpGetString) /* 109 */
+#define TkpGetSubFonts \
+	(tkIntStubsPtr->tkpGetSubFonts) /* 110 */
+#define TkpGetSystemDefault \
+	(tkIntStubsPtr->tkpGetSystemDefault) /* 111 */
+#define TkpMenuThreadInit \
+	(tkIntStubsPtr->tkpMenuThreadInit) /* 112 */
+#define TkClipBox \
+	(tkIntStubsPtr->tkClipBox) /* 113 */
+#define TkCreateRegion \
+	(tkIntStubsPtr->tkCreateRegion) /* 114 */
+#define TkDestroyRegion \
+	(tkIntStubsPtr->tkDestroyRegion) /* 115 */
+#define TkIntersectRegion \
+	(tkIntStubsPtr->tkIntersectRegion) /* 116 */
+#define TkRectInRegion \
+	(tkIntStubsPtr->tkRectInRegion) /* 117 */
+#define TkSetRegion \
+	(tkIntStubsPtr->tkSetRegion) /* 118 */
+#define TkUnionRectWithRegion \
+	(tkIntStubsPtr->tkUnionRectWithRegion) /* 119 */
+/* Slot 120 is reserved */
+#ifdef MAC_OSX_TK /* AQUA */
+#define TkpCreateNativeBitmap \
+	(tkIntStubsPtr->tkpCreateNativeBitmap) /* 121 */
+#endif /* AQUA */
+#ifdef MAC_OSX_TK /* AQUA */
+#define TkpDefineNativeBitmaps \
+	(tkIntStubsPtr->tkpDefineNativeBitmaps) /* 122 */
+#endif /* AQUA */
+/* Slot 123 is reserved */
+#ifdef MAC_OSX_TK /* AQUA */
+#define TkpGetNativeAppBitmap \
+	(tkIntStubsPtr->tkpGetNativeAppBitmap) /* 124 */
+#endif /* AQUA */
+/* Slot 125 is reserved */
+/* Slot 126 is reserved */
+/* Slot 127 is reserved */
+/* Slot 128 is reserved */
+/* Slot 129 is reserved */
+/* Slot 130 is reserved */
+/* Slot 131 is reserved */
+/* Slot 132 is reserved */
+/* Slot 133 is reserved */
+/* Slot 134 is reserved */
+#define TkpDrawHighlightBorder \
+	(tkIntStubsPtr->tkpDrawHighlightBorder) /* 135 */
+#define TkSetFocusWin \
+	(tkIntStubsPtr->tkSetFocusWin) /* 136 */
+#define TkpSetKeycodeAndState \
+	(tkIntStubsPtr->tkpSetKeycodeAndState) /* 137 */
+#define TkpGetKeySym \
+	(tkIntStubsPtr->tkpGetKeySym) /* 138 */
+#define TkpInitKeymapInfo \
+	(tkIntStubsPtr->tkpInitKeymapInfo) /* 139 */
+#define TkPhotoGetValidRegion \
+	(tkIntStubsPtr->tkPhotoGetValidRegion) /* 140 */
+#define TkWmStackorderToplevel \
+	(tkIntStubsPtr->tkWmStackorderToplevel) /* 141 */
+#define TkFocusFree \
+	(tkIntStubsPtr->tkFocusFree) /* 142 */
+#define TkClipCleanup \
+	(tkIntStubsPtr->tkClipCleanup) /* 143 */
+#define TkGCCleanup \
+	(tkIntStubsPtr->tkGCCleanup) /* 144 */
+#define TkSubtractRegion \
+	(tkIntStubsPtr->tkSubtractRegion) /* 145 */
+#define TkStylePkgInit \
+	(tkIntStubsPtr->tkStylePkgInit) /* 146 */
+#define TkStylePkgFree \
+	(tkIntStubsPtr->tkStylePkgFree) /* 147 */
+#define TkToplevelWindowForCommand \
+	(tkIntStubsPtr->tkToplevelWindowForCommand) /* 148 */
+#define TkGetOptionSpec \
+	(tkIntStubsPtr->tkGetOptionSpec) /* 149 */
+#define TkMakeRawCurve \
+	(tkIntStubsPtr->tkMakeRawCurve) /* 150 */
+#define TkMakeRawCurvePostscript \
+	(tkIntStubsPtr->tkMakeRawCurvePostscript) /* 151 */
+#define TkpDrawFrame \
+	(tkIntStubsPtr->tkpDrawFrame) /* 152 */
+#define TkCreateThreadExitHandler \
+	(tkIntStubsPtr->tkCreateThreadExitHandler) /* 153 */
+#define TkDeleteThreadExitHandler \
+	(tkIntStubsPtr->tkDeleteThreadExitHandler) /* 154 */
+/* Slot 155 is reserved */
+#define TkpTestembedCmd \
+	(tkIntStubsPtr->tkpTestembedCmd) /* 156 */
+#define TkpTesttextCmd \
+	(tkIntStubsPtr->tkpTesttextCmd) /* 157 */
+#define TkSelGetSelection \
+	(tkIntStubsPtr->tkSelGetSelection) /* 158 */
+#define TkTextGetIndex \
+	(tkIntStubsPtr->tkTextGetIndex) /* 159 */
+#define TkTextIndexBackBytes \
+	(tkIntStubsPtr->tkTextIndexBackBytes) /* 160 */
+#define TkTextIndexForwBytes \
+	(tkIntStubsPtr->tkTextIndexForwBytes) /* 161 */
+#define TkTextMakeByteIndex \
+	(tkIntStubsPtr->tkTextMakeByteIndex) /* 162 */
+#define TkTextPrintIndex \
+	(tkIntStubsPtr->tkTextPrintIndex) /* 163 */
+#define TkTextSetMark \
+	(tkIntStubsPtr->tkTextSetMark) /* 164 */
+#define TkTextXviewCmd \
+	(tkIntStubsPtr->tkTextXviewCmd) /* 165 */
+#define TkTextChanged \
+	(tkIntStubsPtr->tkTextChanged) /* 166 */
+#define TkBTreeNumLines \
+	(tkIntStubsPtr->tkBTreeNumLines) /* 167 */
+#define TkTextInsertDisplayProc \
+	(tkIntStubsPtr->tkTextInsertDisplayProc) /* 168 */
+#define TkStateParseProc \
+	(tkIntStubsPtr->tkStateParseProc) /* 169 */
+#define TkStatePrintProc \
+	(tkIntStubsPtr->tkStatePrintProc) /* 170 */
+#define TkCanvasDashParseProc \
+	(tkIntStubsPtr->tkCanvasDashParseProc) /* 171 */
+#define TkCanvasDashPrintProc \
+	(tkIntStubsPtr->tkCanvasDashPrintProc) /* 172 */
+#define TkOffsetParseProc \
+	(tkIntStubsPtr->tkOffsetParseProc) /* 173 */
+#define TkOffsetPrintProc \
+	(tkIntStubsPtr->tkOffsetPrintProc) /* 174 */
+#define TkPixelParseProc \
+	(tkIntStubsPtr->tkPixelParseProc) /* 175 */
+#define TkPixelPrintProc \
+	(tkIntStubsPtr->tkPixelPrintProc) /* 176 */
+#define TkOrientParseProc \
+	(tkIntStubsPtr->tkOrientParseProc) /* 177 */
+#define TkOrientPrintProc \
+	(tkIntStubsPtr->tkOrientPrintProc) /* 178 */
+#define TkSmoothParseProc \
+	(tkIntStubsPtr->tkSmoothParseProc) /* 179 */
+#define TkSmoothPrintProc \
+	(tkIntStubsPtr->tkSmoothPrintProc) /* 180 */
+#define TkDrawAngledTextLayout \
+	(tkIntStubsPtr->tkDrawAngledTextLayout) /* 181 */
+#define TkUnderlineAngledTextLayout \
+	(tkIntStubsPtr->tkUnderlineAngledTextLayout) /* 182 */
+#define TkIntersectAngledTextLayout \
+	(tkIntStubsPtr->tkIntersectAngledTextLayout) /* 183 */
+#define TkDrawAngledChars \
+	(tkIntStubsPtr->tkDrawAngledChars) /* 184 */
+
+#endif /* defined(USE_TK_STUBS) */
+
+/* !END!: Do not edit above this line. */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+/*
+ * On X11, these macros are just wrappers for the equivalent X Region calls.
+ */
+#if !(defined(__WIN32__) || defined(__CYGWIN__) || defined(MAC_OSX_TK)) /* X11 */
+
+#undef TkClipBox
+#undef TkCreateRegion
+#undef TkDestroyRegion
+#undef TkIntersectRegion
+#undef TkRectInRegion
+#undef TkSetRegion
+#undef TkSubtractRegion
+#undef TkUnionRectWithRegion
+
+#define TkClipBox(rgn, rect) XClipBox((Region) rgn, rect)
+#define TkCreateRegion() (TkRegion) XCreateRegion()
+#define TkDestroyRegion(rgn) XDestroyRegion((Region) rgn)
+#define TkIntersectRegion(a, b, r) XIntersectRegion((Region) a, \
+	(Region) b, (Region) r)
+#define TkRectInRegion(r, x, y, w, h) XRectInRegion((Region) r, x, y, w, h)
+#define TkSetRegion(d, gc, rgn) XSetRegion(d, gc, (Region) rgn)
+#define TkSubtractRegion(a, b, r) XSubtractRegion((Region) a, \
+	(Region) b, (Region) r)
+#define TkUnionRectWithRegion(rect, src, ret) XUnionRectWithRegion(rect, \
+	(Region) src, (Region) ret)
+
+#endif /* UNIX */
+
+#endif /* _TKINTDECLS */
+
diff -uNr blt2.4z/src/tkPort.h blt2.4z.tcltk86/src/tkPort.h
--- blt2.4z/src/tkPort.h	1969-12-31 19:00:00.000000000 -0500
+++ blt2.4z.tcltk86/src/tkPort.h	2013-08-20 11:44:47.000000000 -0400
@@ -0,0 +1,31 @@
+/*
+ * tkPort.h --
+ *
+ *	This header file handles porting issues that occur because of
+ *	differences between systems.  It reads in platform specific
+ *	portability files.
+ *
+ * Copyright (c) 1995 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TKPORT
+#define _TKPORT
+
+#if defined(_WIN32)
+#   include "tkWinPort.h"
+#endif
+#ifndef _TK
+#   include "tk.h"
+#endif
+#if !defined(_WIN32)
+#   if defined(MAC_OSX_TK)
+#	include "tkMacOSXPort.h"
+#   else
+#	include "tkUnixPort.h"
+#   endif
+#endif
+
+#endif /* _TKPORT */
diff -uNr blt2.4z/src/tkUnixPort.h blt2.4z.tcltk86/src/tkUnixPort.h
--- blt2.4z/src/tkUnixPort.h	1969-12-31 19:00:00.000000000 -0500
+++ blt2.4z.tcltk86/src/tkUnixPort.h	2013-08-20 11:45:15.000000000 -0400
@@ -0,0 +1,198 @@
+/*
+ * tkUnixPort.h --
+ *
+ *	This file is included by all of the Tk C files.  It contains
+ *	information that may be configuration-dependent, such as
+ *	#includes for system include files and a few other things.
+ *
+ * Copyright (c) 1991-1993 The Regents of the University of California.
+ * Copyright (c) 1994-1996 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _UNIXPORT
+#define _UNIXPORT
+
+#define __UNIX__ 1
+
+#include <stdio.h>
+#include <ctype.h>
+#include <fcntl.h>
+#ifndef NO_LIMITS_H
+#   include <limits.h>
+#else
+#   include "../compat/limits.h"
+#endif
+#include <math.h>
+#include <pwd.h>
+#ifdef NO_STDLIB_H
+#   include "../compat/stdlib.h"
+#else
+#   include <stdlib.h>
+#endif
+#include <string.h>
+#include <sys/types.h>
+#include <sys/file.h>
+#ifdef HAVE_SYS_SELECT_H
+#   include <sys/select.h>
+#endif
+#include <sys/stat.h>
+#ifndef _TCL
+#   include <tcl.h>
+#endif
+#if TIME_WITH_SYS_TIME
+#   include <sys/time.h>
+#   include <time.h>
+#else
+#   if HAVE_SYS_TIME_H
+#       include <sys/time.h>
+#   else
+#       include <time.h>
+#   endif
+#endif
+#if HAVE_INTTYPES_H
+#    include <inttypes.h>
+#endif
+#ifndef NO_UNISTD_H
+#   include <unistd.h>
+#else
+#   include "../compat/unistd.h"
+#endif
+#include <X11/Xlib.h>
+#include <X11/cursorfont.h>
+#include <X11/keysym.h>
+#include <X11/Xatom.h>
+#include <X11/Xproto.h>
+#include <X11/Xresource.h>
+#include <X11/Xutil.h>
+
+/*
+ * The following macro defines the type of the mask arguments to
+ * select:
+ */
+
+#ifndef NO_FD_SET
+#   define SELECT_MASK fd_set
+#else
+#   ifndef _AIX
+	typedef long fd_mask;
+#   endif
+#   if defined(_IBMR2)
+#	define SELECT_MASK void
+#   else
+#	define SELECT_MASK int
+#   endif
+#endif
+
+/*
+ * The following macro defines the number of fd_masks in an fd_set:
+ */
+
+#ifndef FD_SETSIZE
+#   ifdef OPEN_MAX
+#	define FD_SETSIZE OPEN_MAX
+#   else
+#	define FD_SETSIZE 256
+#   endif
+#endif
+#if !defined(howmany)
+#   define howmany(x, y) (((x)+((y)-1))/(y))
+#endif
+#ifndef NFDBITS
+#   define NFDBITS NBBY*sizeof(fd_mask)
+#endif
+#define MASK_SIZE howmany(FD_SETSIZE, NFDBITS)
+
+/*
+ * Define "NBBY" (number of bits per byte) if it's not already defined.
+ */
+
+#ifndef NBBY
+#   define NBBY 8
+#endif
+
+#ifdef __CYGWIN__
+#   define UINT unsigned int
+#   define HWND void *
+#   define HDC void *
+#   define HINSTANCE void *
+#   define COLORREF void *
+#   define HMENU void *
+#   define TkWinDCState void
+#   define HPALETTE void *
+#   define WNDPROC void *
+#   define WPARAM void *
+#   define LPARAM void *
+#   define LRESULT void *
+
+EXTERN int TkPutImage (unsigned long *, int, Display *, Drawable, GC,
+	XImage *, int, int, int, int, unsigned int, unsigned int);
+
+#else /* !__CYGWIN__ */
+    /*
+     * The TkPutImage macro strips off the color table information, which isn't
+     * needed for X.
+     */
+
+#   define TkPutImage(colors, ncolors, display, pixels, gc, image, srcx, srcy, destx, desty, width, height) \
+		XPutImage(display, pixels, gc, image, srcx, srcy, destx, \
+		desty, width, height);
+
+#endif /* !__CYGWIN__ */
+
+/*
+ * Supply macros for seek offsets, if they're not already provided by
+ * an include file.
+ */
+
+#ifndef SEEK_SET
+#   define SEEK_SET 0
+#endif
+
+#ifndef SEEK_CUR
+#   define SEEK_CUR 1
+#endif
+
+#ifndef SEEK_END
+#   define SEEK_END 2
+#endif
+
+/*
+ * Declarations for various library procedures that may not be declared
+ * in any other header file.
+ */
+
+
+/*
+ * These functions do nothing under Unix, so we just eliminate calls to them.
+ */
+
+#define TkpButtonSetDefaults() {}
+#define TkpDestroyButton(butPtr) {}
+#define TkSelUpdateClipboard(a,b) {}
+#ifndef __CYGWIN__
+#define TkSetPixmapColormap(p,c) {}
+#endif
+
+/*
+ * These calls implement native bitmaps which are not supported under
+ * UNIX.  The macros eliminate the calls.
+ */
+
+#define TkpDefineNativeBitmaps()
+#define TkpCreateNativeBitmap(display, source) None
+#define TkpGetNativeAppBitmap(display, name, w, h) None
+
+/*
+ * This macro stores a representation of the window handle in a string.
+ * This should perhaps use the real size of an XID.
+ */
+
+#ifndef __CYGWIN__
+#define TkpPrintWindowId(buf,w) \
+	sprintf((buf), "%#08lx", (unsigned long) (w))
+#endif
+
+#endif /* _UNIXPORT */
