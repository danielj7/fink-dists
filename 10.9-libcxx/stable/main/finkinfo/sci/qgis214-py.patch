Binary files qgis-2.14.13-orig/.DS_Store and qgis-2.14.13/.DS_Store differ
diff -ruN qgis-2.14.13-orig/CMakeLists.txt qgis-2.14.13/CMakeLists.txt
--- qgis-2.14.13-orig/CMakeLists.txt	2017-04-16 16:54:17.000000000 +0900
+++ qgis-2.14.13/CMakeLists.txt	2017-04-16 16:55:03.000000000 +0900
@@ -575,9 +575,9 @@
     # need to find non-system frameworks
     # cmake bug #0007250 - CMAKE_SHARED_LINKER_FLAGS ignored when creating
     # a framework, so these need to be manually handled with LINK_FLAGS options
-    SET (CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -F/Library/Frameworks")
-    SET (CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -F/Library/Frameworks")
-    SET (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -F/Library/Frameworks")
+    # SET (CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -F/Library/Frameworks")
+    # SET (CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -F/Library/Frameworks")
+    # SET (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -F/Library/Frameworks")
 
   ELSE (APPLE)
     # UNIX
diff -ruN qgis-2.14.13-orig/CMakeLists.txt.orig qgis-2.14.13/CMakeLists.txt.orig
--- qgis-2.14.13-orig/CMakeLists.txt.orig	1970-01-01 09:00:00.000000000 +0900
+++ qgis-2.14.13/CMakeLists.txt.orig	2017-03-24 21:21:50.000000000 +0900
@@ -0,0 +1,877 @@
+SET(CPACK_PACKAGE_VERSION_MAJOR "2")
+SET(CPACK_PACKAGE_VERSION_MINOR "14")
+SET(CPACK_PACKAGE_VERSION_PATCH "13")
+SET(COMPLETE_VERSION ${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH})
+SET(RELEASE_NAME "Essen")
+IF (POLICY CMP0048) # in CMake 3.0.0+
+  CMAKE_POLICY (SET CMP0048 OLD) # keep PROJECT() from clearing VERSION variables
+ENDIF (POLICY CMP0048)
+SET(PROJECT_VERSION ${COMPLETE_VERSION})
+PROJECT(qgis${PROJECT_VERSION})
+IF (APPLE)
+  SET(QGIS_APP_NAME "QGIS")
+ELSE (APPLE)
+  SET(QGIS_APP_NAME "qgis")
+ENDIF (APPLE)
+
+# Note the version no is Mmmpp for Major/minor/patch, 0-padded, thus '10100' for 1.1.0
+MATH(EXPR QGIS_VERSION_INT "${CPACK_PACKAGE_VERSION_MAJOR}*10000+${CPACK_PACKAGE_VERSION_MINOR}*100+${CPACK_PACKAGE_VERSION_PATCH}")
+MESSAGE(STATUS "QGIS version: ${COMPLETE_VERSION} ${RELEASE_NAME} (${QGIS_VERSION_INT})")
+
+#############################################################
+# CMake settings
+
+CMAKE_MINIMUM_REQUIRED(VERSION 2.8.6)
+
+SET(CMAKE_COLOR_MAKEFILE ON)
+
+# set path to additional CMake modules
+SET(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake ${CMAKE_MODULE_PATH})
+
+# in generated makefiles use relative paths so the project dir is moveable
+# Note commented out since it cause problems but it would be nice to resolve these and enable
+#
+# issue is caused by INCLUDE_DIRECTORIES(${CMAKE_BINARY_DIR}) near the end of this file generating incorrect path
+#SET (CMAKE_USE_RELATIVE_PATHS ON)
+
+# try to configure and build GRASS plugin by default
+FOREACH (GRASS_SEARCH_VERSION 6 7)
+  # For GRASS 6 are used cached variables without version suffix so that existing caches don't have to be reconfigured.
+  # Cached variables: WITH_GRASS, WITH_GRASS7, GRASS_PREFIX, GRASS_PREFIX7, GRASS_INCLUDE_DIR, GRASS_INCLUDE_DIR7
+  # Everywhere else each variable has version major appended.
+  # Normal variables: GRASS_FOUND6, GRASS_FOUND7, GRASS_MAJOR_VERSION6, GRASS_MAJOR_VERSION7, etc.
+  # In addition there is also GRASS_FOUND, which is TRUE if at least one version of GRASS was found
+  IF (GRASS_SEARCH_VERSION EQUAL 6)
+    SET (GRASS_CACHE_VERSION "")
+  ELSE (GRASS_SEARCH_VERSION EQUAL 6)
+    SET (GRASS_CACHE_VERSION ${GRASS_SEARCH_VERSION})
+  ENDIF (GRASS_SEARCH_VERSION EQUAL 6)
+
+  SET (WITH_GRASS${GRASS_CACHE_VERSION} TRUE CACHE BOOL "Determines whether GRASS ${GRASS_SEARCH_VERSION} plugin should be built")
+  IF (WITH_GRASS${GRASS_CACHE_VERSION})
+    FIND_PACKAGE(GRASS ${GRASS_SEARCH_VERSION})
+    SET (GRASS_PREFIX${GRASS_CACHE_VERSION} ${GRASS_PREFIX${GRASS_SEARCH_VERSION}} CACHE PATH "Path to GRASS ${GRASS_SEARCH_VERSION} base directory")
+  ENDIF (WITH_GRASS${GRASS_CACHE_VERSION})
+ENDFOREACH (GRASS_SEARCH_VERSION)
+
+SET (WITH_DESKTOP TRUE CACHE BOOL "Determines whether QGIS desktop should be built")
+
+# server disabled default because it needs FastCGI (which is optional dependency)
+SET (WITH_SERVER FALSE CACHE BOOL "Determines whether QGIS server should be built")
+IF(WITH_SERVER)
+  SET (SERVER_SKIP_ECW FALSE CACHE BOOL "Determines whether QGIS server should disable ECW (ECW in server apps requires a special license)")
+
+  SET (WITH_SERVER_PLUGINS TRUE CACHE BOOL "Determines whether QGIS server support for python plugins should be built")
+  IF(WITH_SERVER_PLUGINS)
+    SET(HAVE_SERVER_PYTHON_PLUGINS TRUE)
+  ENDIF(WITH_SERVER_PLUGINS)
+ENDIF(WITH_SERVER)
+
+# Custom widgets
+SET (WITH_CUSTOM_WIDGETS FALSE CACHE BOOL "Determines whether QGIS custom widgets for Qt Designer should be built")
+
+# build our version of astyle
+SET (WITH_ASTYLE FALSE CACHE BOOL "If you plan to contribute you should reindent with scripts/prepare-commit.sh (using 'our' astyle)")
+
+# try to configure and build POSTGRESQL support
+SET (WITH_POSTGRESQL TRUE CACHE BOOL "Determines whether POSTGRESQL support should be built")
+IF (WITH_POSTGRESQL)
+  SET (POSTGRESQL_PREFIX "" CACHE PATH "Path to POSTGRESQL base directory")
+ENDIF (WITH_POSTGRESQL)
+
+SET (WITH_INTERNAL_QEXTSERIALPORT TRUE CACHE BOOL "Use internal build of Qextserialport")
+
+SET (WITH_QSPATIALITE FALSE CACHE BOOL "Determines whether QSPATIALITE sql driver should be built")
+
+SET (WITH_ORACLE FALSE CACHE BOOL "Determines whether Oracle support should be built")
+IF(WITH_ORACLE)
+  SET(HAVE_ORACLE TRUE)
+  SET(ORACLE_INCLUDEDIR "" CACHE STRING "Path to OCI headers")
+  SET(ORACLE_LIBDIR "" CACHE STRING "Path to OCI libraries")
+ENDIF(WITH_ORACLE)
+
+
+# try to configure and build python bindings by default
+SET (WITH_BINDINGS TRUE CACHE BOOL "Determines whether python bindings should be built")
+IF (WITH_BINDINGS)
+  # By default bindings will be installed only to QGIS directory
+  # Someone might want to install it to python site-packages directory
+  # as otherwise user has to use PYTHONPATH environemnt variable to add
+  # QGIS bindings to package search path
+  SET (BINDINGS_GLOBAL_INSTALL FALSE CACHE BOOL "Install bindings to global python directory? (might need root)")
+  SET (WITH_STAGED_PLUGINS TRUE CACHE BOOL "Stage-install core Python plugins to run from build directory? (utilities and console are always staged)")
+  SET (WITH_PY_COMPILE FALSE CACHE BOOL "Determines whether Python modules in staged or installed locations are byte-compiled")
+  # concatenate QScintilla2 API files
+  SET (WITH_QSCIAPI TRUE CACHE BOOL "Whether to generate PyQGIS QScintilla2 API file. (For devs) run 'make qsci-pap-src' in between QGIS build and install to regenerate .pap file in source tree for console auto-completion.")
+  # keep casual users from updating their source tree via WITH_QSCIAPI
+  MARK_AS_ADVANCED (WITH_QSCIAPI)
+  # path to custom Python framework on Mac
+  IF (APPLE)
+    SET (PYTHON_CUSTOM_FRAMEWORK "" CACHE PATH "Path to custom Python.framework on Mac. (should not have to specify other Python options)")
+  ENDIF (APPLE)
+ENDIF (WITH_BINDINGS)
+
+#BUILD WITH QtMobility by default on android only. Other platform can force it
+IF (ANDROID)
+    SET (DEFAULT_WITH_QTMOBILITY TRUE)
+ELSE (ANDROID)
+    SET (DEFAULT_WITH_QTMOBILITY FALSE)
+ENDIF (ANDROID)
+SET (WITH_QTMOBILITY ${DEFAULT_WITH_QTMOBILITY} CACHE BOOL "Determines if QtMobility related code should be build (for example internal GPS)")
+
+SET (WITH_GLOBE FALSE CACHE BOOL "Determines whether Globe plugin should be built")
+IF (WITH_GLOBE)
+  SET(QT_USE_QTOPENGL 1)
+  FIND_PACKAGE(OSGEARTH REQUIRED)
+  IF (OSGEARTHQT_LIBRARY)
+    # following variable is used in qgsconfig.h
+    SET(HAVE_OSGEARTHQT TRUE)
+  ENDIF (OSGEARTHQT_LIBRARY)
+ENDIF (WITH_GLOBE)
+
+# Compile flag. Make it possible to turn it off.
+SET (PEDANTIC TRUE CACHE BOOL "Determines if we should compile in pedantic mode.")
+
+# whether unit tests should be build
+SET (ENABLE_TESTS TRUE CACHE BOOL "Build unit tests?")
+
+# whether coverage tests should be performed
+SET (ENABLE_COVERAGE FALSE CACHE BOOL "Perform coverage tests?")
+
+# whether coverage documentation should be generated
+SET (GENERATE_COVERAGE_DOCS FALSE CACHE BOOL "Generate coverage docs (requires lcov)?")
+
+# hide this variable because building of python bindings might fail
+# if set to other directory than expected
+MARK_AS_ADVANCED(LIBRARY_OUTPUT_PATH)
+
+IF (MSVC AND CMAKE_GENERATOR MATCHES "NMake")
+  # following variable is also used in qgsconfig.h
+  SET (USING_NMAKE TRUE)
+ENDIF (MSVC AND CMAKE_GENERATOR MATCHES "NMake")
+
+IF (CMAKE_GENERATOR MATCHES "Ninja")
+  # following variable is also used in qgsconfig.h
+  SET (USING_NINJA TRUE)
+ENDIF (CMAKE_GENERATOR MATCHES "Ninja")
+
+#############################################################
+# check if lexer and parser are not missing
+# http://www.mail-archive.com/cmake@cmake.org/msg02861.html
+
+INCLUDE(Flex)
+
+FIND_FLEX()
+
+IF (NOT FLEX_EXECUTABLE)
+  MESSAGE(FATAL_ERROR "Couldn't find Flex")
+ENDIF (NOT FLEX_EXECUTABLE)
+
+INCLUDE(Bison)
+
+FIND_BISON()
+
+IF (NOT BISON_EXECUTABLE)
+  MESSAGE(FATAL_ERROR "Couldn't find Bison")
+ENDIF (NOT BISON_EXECUTABLE)
+
+#############################################################
+# search for dependencies
+
+IF(NOT WIN32 AND NOT ANDROID)
+  INCLUDE(CheckFunctionExists)
+  CHECK_FUNCTION_EXISTS(openpty OPENPTY_IN_LIBC)
+  IF(NOT OPENPTY_IN_LIBC)
+    SET(CMAKE_REQUIRED_INCLUDES util.h)
+    SET(CMAKE_REQUIRED_LIBRARIES util)
+    CHECK_FUNCTION_EXISTS(openpty NEED_LIBUTIL)
+    IF(NEED_LIBUTIL)
+      SET(OPENPTY_LIBRARY util)
+    ELSE(NEED_LIBUTIL)
+      MESSAGE (SEND_ERROR "openpty not found!")
+    ENDIF(NEED_LIBUTIL)
+  ENDIF(NOT OPENPTY_IN_LIBC)
+ENDIF(NOT WIN32 AND NOT ANDROID)
+
+# required
+FIND_PACKAGE(Proj)
+FIND_PACKAGE(GEOS)
+FIND_PACKAGE(GDAL)
+FIND_PACKAGE(Expat REQUIRED)
+FIND_PACKAGE(Spatialindex REQUIRED)
+FIND_PACKAGE(Qwt REQUIRED)
+
+IF (WITH_INTERNAL_QEXTSERIALPORT)
+  SET(QEXTSERIALPORT_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/src/core/gps/qextserialport)
+ELSE (WITH_INTERNAL_QEXTSERIALPORT)
+  FIND_PACKAGE(Qextserialport REQUIRED)
+ENDIF(WITH_INTERNAL_QEXTSERIALPORT)
+
+FIND_PACKAGE(Sqlite3)
+IF (NOT SQLITE3_FOUND)
+  MESSAGE (SEND_ERROR "sqlite3 dependency was not found!")
+ENDIF (NOT SQLITE3_FOUND)
+
+# optional
+IF (WITH_POSTGRESQL)
+  FIND_PACKAGE(Postgres) # PostgreSQL provider
+ENDIF (WITH_POSTGRESQL)
+
+FIND_PACKAGE(SPATIALITE REQUIRED)
+
+IF(SPATIALITE_VERSION_GE_4_0_0)
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DSPATIALITE_VERSION_GE_4_0_0")
+ENDIF(SPATIALITE_VERSION_GE_4_0_0)
+IF(SPATIALITE_VERSION_G_4_1_1)
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DSPATIALITE_VERSION_G_4_1_1")
+ENDIF(SPATIALITE_VERSION_G_4_1_1)
+IF(SPATIALITE_HAS_INIT_EX)
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DSPATIALITE_HAS_INIT_EX")
+ENDIF(SPATIALITE_HAS_INIT_EX)
+
+IF (NOT PROJ_FOUND OR NOT GEOS_FOUND OR NOT GDAL_FOUND)
+  MESSAGE (SEND_ERROR "Some dependencies were not found!")
+ENDIF (NOT PROJ_FOUND OR NOT GEOS_FOUND OR NOT GDAL_FOUND)
+
+IF (POSTGRES_FOUND)
+  # following variable is used in qgsconfig.h
+  SET (HAVE_POSTGRESQL TRUE)
+ENDIF (POSTGRES_FOUND)
+
+# following variable is used in qgsconfig.h
+SET (HAVE_SPATIALITE TRUE)
+
+# following variable is used in qgsconfig.h
+SET (HAVE_MSSQL TRUE)
+
+SET (WITH_QTWEBKIT TRUE CACHE INTERNAL "Enable QtWebkit support")
+IF (WITH_QTWEBKIT)
+  ADD_DEFINITIONS(-DWITH_QTWEBKIT)
+ENDIF(WITH_QTWEBKIT)
+#############################################################
+# search for Qt4
+SET(QT_MIN_VERSION 4.8.0)
+SET (ENABLE_QT5 FALSE CACHE BOOL "If enabled will try to find Qt5 before looking for Qt4")
+IF (ENABLE_QT5)
+  FIND_PACKAGE(Qt5Core QUIET)
+  FIND_PACKAGE(Qt5Gui REQUIRED)
+  FIND_PACKAGE(Qt5Widgets REQUIRED)
+  FIND_PACKAGE(Qt5Network REQUIRED)
+  FIND_PACKAGE(Qt5Xml REQUIRED)
+  FIND_PACKAGE(Qt5Svg REQUIRED)
+  FIND_PACKAGE(Qt5Concurrent REQUIRED)
+  FIND_PACKAGE(Qt5PrintSupport REQUIRED)
+  FIND_PACKAGE(Qt5Positioning)
+  IF (WITH_QTWEBKIT)
+    FIND_PACKAGE(Qt5WebKit REQUIRED)
+    FIND_PACKAGE(Qt5WebKitWidgets REQUIRED)
+  ENDIF(WITH_QTWEBKIT)
+  FIND_PACKAGE(Qt5Test REQUIRED)
+  FIND_PACKAGE(Qt5UiTools REQUIRED)
+  FIND_PACKAGE(Qt5Script REQUIRED)
+  FIND_PACKAGE(Qt5Sql REQUIRED)
+  SET(QT5_BUILD TRUE)
+  INCLUDE("cmake/modules/ECMQt4To5Porting.cmake")
+  MESSAGE(STATUS "Found Qt version: ${Qt5Core_VERSION_STRING}")
+ELSE()
+  FIND_PACKAGE(Qt4 ${QT_MIN_VERSION} REQUIRED)
+  SET(QT_USE_QTXML 1)
+  SET(QT_USE_QTNETWORK 1)
+  SET(QT_USE_QTSVG 1)
+  SET(QT_USE_QTSQL 1)
+  SET(QT_USE_QTWEBKIT 1)
+  IF (NOT QT_QTXML_FOUND OR NOT QT_QTNETWORK_FOUND OR NOT QT_QTSVG_FOUND OR NOT QT_QTSQL_FOUND OR NOT QT_QTWEBKIT_FOUND OR (WITH_CUSTOM_WIDGETS AND NOT QT_QTDESIGNER_FOUND))
+    MESSAGE(SEND_ERROR "Some Qt4 modules haven't been found!")
+  ENDIF (NOT QT_QTXML_FOUND OR NOT QT_QTNETWORK_FOUND OR NOT QT_QTSVG_FOUND OR NOT QT_QTSQL_FOUND OR NOT QT_QTWEBKIT_FOUND OR (WITH_CUSTOM_WIDGETS AND NOT QT_QTDESIGNER_FOUND))
+
+  INCLUDE( ${QT_USE_FILE} )
+
+  MESSAGE(STATUS "Found Qt version: ${QTVERSION}")
+ENDIF()
+
+IF (WITH_QTMOBILITY)
+    FIND_PACKAGE(QtMobility 1.1.0)
+ENDIF (WITH_QTMOBILITY)
+
+IF (ANDROID)
+  SET (DEFAULT_WITH_TOUCH TRUE)
+ELSE (ANDROID)
+  SET (DEFAULT_WITH_TOUCH FALSE)
+ENDIF (ANDROID)
+
+#Add a touch mode if Qt has Qt Gestures
+SET (WITH_TOUCH ${DEFAULT_WITH_TOUCH} CACHE BOOL "Determines if touch interface related code should be build")
+
+IF (WITH_TOUCH)
+  # following variable is used in qgsconfig.h
+  SET (HAVE_TOUCH TRUE)
+  MESSAGE (STATUS "Touch support enabled")
+ELSE (WITH_TOUCH)
+  MESSAGE (STATUS "Touch support disabled")
+ENDIF (WITH_TOUCH)
+
+# search for QScintilla2 (C++ lib)
+FIND_PACKAGE(QScintilla REQUIRED)
+
+# Master password hash and authentication encryption
+FIND_PACKAGE(QCA REQUIRED)
+# Check for runtime dependency of qca-ossl plugin
+# REQUIRED if unit tests are to be run from build directory
+IF(NOT MSVC)
+include(QCAMacros)
+FIND_QCAOSSL_PLUGIN_CPP(ENABLE_TESTS)
+ENDIF(NOT MSVC)
+
+# ModelTest
+SET(ENABLE_MODELTEST FALSE CACHE BOOL "Enable QT ModelTest (not for production)")
+
+IF (ENABLE_TESTS)
+  SET( QT_USE_QTTEST  TRUE )
+  ENABLE_TESTING()
+  # Adds some testing specific build targets e.g. make Experimental
+  INCLUDE(Dart)
+  # Define "make check" as alias for "make test" - thanks geos :-)
+  add_custom_target(check COMMAND ctest --output-on-failure)
+  # Additional test configuration options e.g. max upload size of test report
+  CONFIGURE_FILE(
+    "${CMAKE_CURRENT_SOURCE_DIR}/cmake_templates/CTestCustom.cmake.in"
+    "${CMAKE_CURRENT_BINARY_DIR}/CTestCustom.cmake"
+    IMMEDIATE @ONLY)
+  # For server side testing we have no X, we can use xfvb as a fake x
+  # sudo apt-get install xfvb
+  add_custom_target(check-no-x COMMAND xvfb-run --server-args=-screen\ 10\ 1024x768x24 ctest --output-on-failure)
+ENDIF (ENABLE_TESTS)
+
+IF (SUPPRESS_QT_WARNINGS)
+  # Newer versions of UseQt4.cmake include Qt with -isystem automatically
+  # This can be used to force this behavior on older systems
+  # Can be removed as soon as Travis-CI updates from precise
+  INCLUDE_DIRECTORIES(SYSTEM ${QT_INCLUDE_DIR})
+ENDIF (SUPPRESS_QT_WARNINGS)
+
+# Disable automatic conversion from QString to ASCII 8-bit strings (char *)
+# (Keeps code compatible with Qt/Mac/64bit)
+ADD_DEFINITIONS(-DQT_NO_CAST_TO_ASCII)
+
+FIND_PROGRAM(QT_LRELEASE_EXECUTABLE
+    NAMES lrelease
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+#############################################################
+# enable use of c++11 features where available
+# full c++11 support in clang 3.3+: http://clang.llvm.org/cxx_status.html
+# for Mac, this is probably Apple LLVM 4.2 (based on LLVM 3.2svn, in XCode 4.6+)
+#   or definitely Apple LLVM 5.0 (based on LLVM 3.3svn, in Xcode 5+):
+#   https://gist.github.com/yamaya/2924292
+
+IF (CMAKE_CXX_COMPILER_ID MATCHES "GNU")
+  EXECUTE_PROCESS(COMMAND ${CMAKE_CXX_COMPILER} -dumpversion OUTPUT_VARIABLE GCC_VERSION)
+  IF (GCC_VERSION VERSION_GREATER 4.7 OR GCC_VERSION VERSION_EQUAL 4.7)
+    SET(USE_CXX_11 TRUE)
+    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+  ENDIF()
+ELSEIF (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+  IF ((NOT APPLE AND CMAKE_CXX_COMPILER_VERSION VERSION_GREATER "3.2")
+       OR (APPLE AND CMAKE_CXX_COMPILER_VERSION VERSION_GREATER "4.1"))
+    SET(USE_CXX_11 TRUE)
+    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -Wno-error=c++11-narrowing")
+  ENDIF()
+ELSEIF (MSVC AND MSVC_VERSION GREATER 1600)
+  SET(USE_CXX_11 TRUE)
+ELSE()
+  SET(USE_CXX_11 FALSE)
+ENDIF()
+
+#allow override keyword if available
+IF (NOT USE_CXX_11)
+  ADD_DEFINITIONS("-Doverride=")
+  ADD_DEFINITIONS("-Dnullptr=0")
+ENDIF()
+
+
+#############################################################
+# enable warnings
+
+IF (PEDANTIC)
+  MESSAGE (STATUS "Pedantic compiler settings enabled")
+  IF(MSVC)
+    SET(_warnings "")
+    IF (NOT USING_NMAKE AND NOT USING_NINJA)
+      SET(_warnings "${_warnings} /W4" )
+    ENDIF (NOT USING_NMAKE AND NOT USING_NINJA)
+
+    # disable warnings
+    SET(_warnings "${_warnings} /wd4100 ")  # unused formal parameters
+    SET(_warnings "${_warnings} /wd4127 ")  # constant conditional expressions (used in Qt template classes)
+    SET(_warnings "${_warnings} /wd4190 ")  # 'identifier' has C-linkage specified, but returns UDT 'identifier2' which is incompatible with C
+    SET(_warnings "${_warnings} /wd4231 ")  # nonstandard extension used : 'identifier' before template explicit instantiation (used in Qt template classes)
+    SET(_warnings "${_warnings} /wd4244 ")  # conversion from '...' to '...' possible loss of data
+    SET(_warnings "${_warnings} /wd4251 ")  # needs to have dll-interface to be used by clients of class (occurs in Qt template classes)
+    SET(_warnings "${_warnings} /wd4275 ")  # non dll-interface class '...' used as base for dll-interface class '...'
+    SET(_warnings "${_warnings} /wd4505 ")  # unreferenced local function has been removed (QgsRasterDataProvider::extent)
+    SET(_warnings "${_warnings} /wd4510 ")  # default constructor could not be generated (sqlite3_index_info, QMap)
+    SET(_warnings "${_warnings} /wd4512 ")  # assignment operator could not be generated (sqlite3_index_info)
+    SET(_warnings "${_warnings} /wd4610 ")  # user defined constructor required (sqlite3_index_info)
+    SET(_warnings "${_warnings} /wd4706 ")  # assignment within conditional expression (pal)
+    SET(_warnings "${_warnings} /wd4800 ")  # 'int' : forcing value to bool 'true' or 'false' (performance warning)
+    SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${_warnings}")
+    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${_warnings}")
+  ELSE (MSVC)
+    # add warnings via flags (not as definitions as on Mac -Wall can not be overridden per language )
+    SET(_warnings "-Wall -Wextra -Wno-long-long -Wformat-security -Wno-strict-aliasing")
+    SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${_warnings}")
+    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${_warnings}")
+
+    # Qt produces lots of warnings with strict aliasing (as of Qt 4.4.0 & GCC 4.3)
+    # There are redundant declarations in Qt and GDAL
+    # ADD_DEFINITIONS( -fstrict-aliasing -Wstrict-aliasing=1 -Wredundant-decls )
+
+    IF ("${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang")
+      SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-return-type-c-linkage -Wno-overloaded-virtual")
+    ENDIF ("${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang")
+
+    # add any extra CXXFLAGS flags set by user. can be -D CXX_EXTRA_FLAGS or environment variable
+    # command line -D option overrides environment variable
+    # e.g. useful for suppressing transient upstream warnings in dependencies, like Qt
+    SET(CXX_EXTRA_FLAGS "" CACHE STRING "Additional appended CXXFLAGS")
+    IF ("${CXX_EXTRA_FLAGS}" STREQUAL "" AND DEFINED $ENV{CXX_EXTRA_FLAGS})
+      SET(CXX_EXTRA_FLAGS "$ENV{CXX_EXTRA_FLAGS}")
+    ENDIF ("${CXX_EXTRA_FLAGS}" STREQUAL "" AND DEFINED $ENV{CXX_EXTRA_FLAGS})
+    IF (NOT "${CXX_EXTRA_FLAGS}" STREQUAL "")
+      MESSAGE (STATUS "Appending CXX_EXTRA_FLAGS")
+      SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CXX_EXTRA_FLAGS}")
+    ENDIF (NOT "${CXX_EXTRA_FLAGS}" STREQUAL "")
+  ENDIF (MSVC)
+
+ENDIF (PEDANTIC)
+
+IF (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+  SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Qunused-arguments")
+  SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Qunused-arguments")
+  SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Qunused-arguments")
+  SET(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -Qunused-arguments")
+  SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Qunused-arguments")
+ENDIF (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+
+IF(CMAKE_SYSTEM_PROCESSOR MATCHES "^(powerpc|ppc)")
+  # spatialite crashes on ppc - see bugs.debian.org/603986
+  ADD_DEFINITIONS( -fno-strict-aliasing )
+ENDIF(CMAKE_SYSTEM_PROCESSOR MATCHES "^(powerpc|ppc)")
+
+IF (CMAKE_BUILD_TYPE MATCHES Debug OR CMAKE_BUILD_TYPE MATCHES RelWithDebInfo)
+  MESSAGE (STATUS "Debug output enabled")
+  ADD_DEFINITIONS(-DQGISDEBUG=1)
+ENDIF (CMAKE_BUILD_TYPE MATCHES Debug OR CMAKE_BUILD_TYPE MATCHES RelWithDebInfo)
+
+IF(MSVC)
+  SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -DQGISDEBUG=1")
+  SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -DQGISDEBUG=1")
+  # disable macros that offend std::numeric_limits<T>::min()/max()
+  ADD_DEFINITIONS(-DNOMINMAX)
+ENDIF(MSVC)
+
+IF(ENABLE_COVERAGE)
+  INCLUDE("cmake/modules/coverage/CodeCoverage.cmake")
+  SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -O0 -fprofile-arcs -ftest-coverage --coverage")
+  SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g -O0 -fprofile-arcs -ftest-coverage --coverage")
+  SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -g -O0 -fprofile-arcs -ftest-coverage --coverage")
+  SET(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -g -O0 -fprofile-arcs -ftest-coverage --coverage")
+  SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -g -O0 -fprofile-arcs -ftest-coverage --coverage")
+  SETUP_TARGET_FOR_COVERAGE(qgis_coverage ctest coverage)
+ENDIF(ENABLE_COVERAGE)
+
+#############################################################
+# platform specific stuff
+
+IF (WIN32)
+  SET (DEFAULT_LIB_SUBDIR     lib)
+  SET (DEFAULT_LIBEXEC_SUBDIR .)
+  SET (DEFAULT_DATA_SUBDIR    .)
+  SET (DEFAULT_PLUGIN_SUBDIR  plugins)
+  SET (DEFAULT_INCLUDE_SUBDIR include)
+
+  IF (MSVC)
+    SET (DEFAULT_BIN_SUBDIR bin)
+    SET (DEFAULT_CGIBIN_SUBDIR bin)
+    # put all the build products into a single directory
+    # under build (doesnt affect install target) to make for
+    # easier debugging.
+
+    # Turn on defines for non standard maths stuff
+    ADD_DEFINITIONS(-D_USE_MATH_DEFINES)
+
+    # Turn off deprecation warnings
+    ADD_DEFINITIONS(-D_CRT_SECURE_NO_WARNINGS)
+    ADD_DEFINITIONS(-D_CRT_NONSTDC_NO_WARNINGS)
+
+    IF (CMAKE_BUILD_TYPE MATCHES Debug OR CMAKE_BUILD_TYPE MATCHES RelWithDebInfo)
+      IF (NOT USING_NMAKE AND NOT USING_NINJA)
+        MESSAGE (STATUS "Generating browse files")
+        ADD_DEFINITIONS( /FR )
+      ENDIF (NOT USING_NMAKE AND NOT USING_NINJA)
+    ENDIF (CMAKE_BUILD_TYPE MATCHES Debug OR CMAKE_BUILD_TYPE MATCHES RelWithDebInfo)
+
+    IF (INSTALL_DEPS)
+      INSTALL(DIRECTORY ${INSTALL_DEPS} DESTINATION .)
+    ENDIF (INSTALL_DEPS)
+  ELSE(MSVC)
+    SET (DEFAULT_BIN_SUBDIR .)
+    SET (DEFAULT_CGIBIN_SUBDIR .)
+  ENDIF(MSVC)
+ELSE (WIN32)
+
+  IF (APPLE)
+    IF (POLICY CMP0042) # in CMake 3.0.0+
+      SET (CMAKE_MACOSX_RPATH OFF) # otherwise ON by default
+    ENDIF (POLICY CMP0042)
+    # for Mac OS X, everything is put inside an application bundle
+    # save the root install prefix for the app later
+    SET (QGIS_INSTALL_PREFIX ${CMAKE_INSTALL_PREFIX})
+    SET (QGIS_MACAPP_PREFIX ${CMAKE_INSTALL_PREFIX}/${QGIS_APP_NAME}.app/Contents)
+    # common prefix for components, let cmake handle it
+    SET (CMAKE_INSTALL_PREFIX ${QGIS_MACAPP_PREFIX}/MacOS)
+    # 4 bundling levels, each includes previous
+    #   0  nothing
+    #   1  Qt frameworks
+    #   2  non-system libraries, "standard"
+    #   3  non-system frameworks, "standalone"
+    SET (QGIS_MACAPP_BUNDLE 1 CACHE STRING "What to bundle into app package")
+    SET (QGIS_MACAPP_BUNDLE_USER "" CACHE STRING "Path to user bundling script")
+    SET (QGIS_MACAPP_INSTALL_DEV FALSE CACHE BOOL "Install developer frameworks")
+    SET (QGIS_MACAPP_DEV_PREFIX "/Library/Frameworks" CACHE STRING "Path to install developer frameworks")
+    # if we have @loader_path, >=OSX 10.5 (darwin 9+)
+    IF (CMAKE_SYSTEM_VERSION VERSION_GREATER 9.0.0 OR CMAKE_SYSTEM_VERSION VERSION_EQUAL 9.0.0)
+        SET (OSX_HAVE_LOADERPATH 1)
+    ELSE ()
+        SET (OSX_HAVE_LOADERPATH 0)
+    ENDIF ()
+    #this will define ${APP_SERVICES_LIBRARY}
+    FIND_LIBRARY(APP_SERVICES_LIBRARY ApplicationServices )
+
+    SET (DEFAULT_BIN_SUBDIR      bin)
+    SET (QGIS_BIN_SUBDIR_REV     ..)
+    SET (DEFAULT_CGIBIN_SUBDIR   fcgi-bin)
+    SET (QGIS_CGIBIN_SUBDIR_REV  ..)
+    SET (DEFAULT_LIB_SUBDIR      lib)
+    SET (QGIS_LIB_SUBDIR_REV     ..)
+    SET (QGIS_FW_SUBDIR          ../Frameworks)
+    SET (QGIS_FW_SUBDIR_REV      ../MacOS)
+    SET (DEFAULT_DATA_SUBDIR     ../Resources)
+    SET (QGIS_DATA_SUBDIR_REV    ../MacOS)
+    SET (DEFAULT_LIBEXEC_SUBDIR  lib/qgis)
+    SET (QGIS_LIBEXEC_SUBDIR_REV ../..)
+    SET (DEFAULT_PLUGIN_SUBDIR   ../PlugIns/qgis)
+    SET (QGIS_PLUGIN_SUBDIR_REV  ../../MacOS)
+    SET (DEFAULT_INCLUDE_SUBDIR  include/qgis)
+    # path for framework references when running from build directory
+    # changed later to reference in-app resources upon install
+    SET (CMAKE_INSTALL_NAME_DIR ${CMAKE_BINARY_DIR}/output/lib)
+    IF (WITH_GLOBE)
+      SET (OSG_PLUGINS_PATH "" CACHE PATH "Path to OSG plugins for bundling")
+    ENDIF (WITH_GLOBE)
+    # recent cmakes force SDKs, recent SDKs don't have user symlinks
+    # need to find non-system frameworks
+    # cmake bug #0007250 - CMAKE_SHARED_LINKER_FLAGS ignored when creating
+    # a framework, so these need to be manually handled with LINK_FLAGS options
+    SET (CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -F/Library/Frameworks")
+    SET (CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -F/Library/Frameworks")
+    SET (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -F/Library/Frameworks")
+
+  ELSE (APPLE)
+    # UNIX
+    SET (DEFAULT_BIN_SUBDIR     bin)
+    SET (DEFAULT_CGIBIN_SUBDIR  bin)
+    SET (DEFAULT_LIB_SUBDIR     lib${LIB_SUFFIX})
+    SET (DEFAULT_DATA_SUBDIR    share/qgis)
+    SET (DEFAULT_LIBEXEC_SUBDIR lib${LIB_SUFFIX}/qgis)
+    SET (DEFAULT_PLUGIN_SUBDIR  lib${LIB_SUFFIX}/qgis/plugins)
+    SET (DEFAULT_INCLUDE_SUBDIR include/qgis)
+  ENDIF (APPLE)
+
+ENDIF (WIN32)
+
+IF (ANDROID)
+    SET (DEFAULT_PLUGIN_SUBDIR  lib)
+    SET (DEFAULT_DATA_SUBDIR    files/share)
+    string(REPLACE "<CMAKE_SHARED_LIBRARY_SONAME_CXX_FLAG><TARGET_SONAME>" "" CMAKE_CXX_CREATE_SHARED_MODULE "${CMAKE_CXX_CREATE_SHARED_MODULE}")
+ENDIF (ANDROID)
+
+#assume we have escaped compiler directives
+#eventually we want to change this to new
+#since we don't need to jump through so many
+#hoops to escape compiler directives then
+IF(COMMAND cmake_policy)
+  cmake_policy(SET CMP0003 NEW)
+  cmake_policy(SET CMP0005 OLD)
+ENDIF(COMMAND cmake_policy)
+
+IF (WIN32)
+  SET(DLLIMPORT "__declspec(dllimport)")
+  SET(DLLEXPORT "__declspec(dllexport)")
+ELSE (WIN32)
+  IF ("${CMAKE_CXX_COMPILER_ID}" MATCHES "GNU" OR "${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang")
+    SET(DLLEXPORT "__attribute__ ((visibility (\\\"default\\\")))")
+  ELSE()
+    SET(DLLEXPORT "")
+  ENDIF()
+
+  IF(PEDANTIC AND NOT APPLE)
+    SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,--no-undefined")
+    SET(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -Wl,--no-undefined")
+    SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,--no-undefined")
+  ENDIF(PEDANTIC AND NOT APPLE)
+
+ENDIF(WIN32)
+
+ADD_DEFINITIONS("-DCORE_EXPORT=${DLLIMPORT}")
+ADD_DEFINITIONS("-DGUI_EXPORT=${DLLIMPORT}")
+ADD_DEFINITIONS("-DPYTHON_EXPORT=${DLLIMPORT}")
+ADD_DEFINITIONS("-DANALYSIS_EXPORT=${DLLIMPORT}")
+ADD_DEFINITIONS("-DAPP_EXPORT=${DLLIMPORT}")
+ADD_DEFINITIONS("-DCUSTOMWIDGETS_EXPORT=${DLLIMPORT}")
+ADD_DEFINITIONS("-DSERVER_EXPORT=${DLLIMPORT}")
+
+#############################################################
+# user-changeable settings which can be used to customize
+# layout of QGIS installation
+# (default values are platform-specific)
+
+SET (QGIS_BIN_SUBDIR     ${DEFAULT_BIN_SUBDIR}     CACHE STRING "Subdirectory where executables will be installed")
+SET (QGIS_CGIBIN_SUBDIR  ${DEFAULT_CGIBIN_SUBDIR}  CACHE STRING "Subdirectory where CGI executables will be installed")
+SET (QGIS_LIB_SUBDIR     ${DEFAULT_LIB_SUBDIR}     CACHE STRING "Subdirectory where libraries will be installed")
+SET (QGIS_LIBEXEC_SUBDIR ${DEFAULT_LIBEXEC_SUBDIR} CACHE STRING "Subdirectory where private executables will be installed")
+SET (QGIS_DATA_SUBDIR    ${DEFAULT_DATA_SUBDIR}    CACHE STRING "Subdirectory where QGIS data will be installed")
+SET (QGIS_PLUGIN_SUBDIR  ${DEFAULT_PLUGIN_SUBDIR}  CACHE STRING "Subdirectory where plugins will be installed")
+SET (QGIS_INCLUDE_SUBDIR ${DEFAULT_INCLUDE_SUBDIR} CACHE STRING "Subdirectory where header files will be installed")
+
+# mark *_SUBDIR variables as advanced as this is not something
+# that an average user would use
+MARK_AS_ADVANCED (QGIS_BIN_SUBDIR QGIS_CGIBIN_SUBDIR QGIS_LIB_SUBDIR QGIS_LIBEXEC_SUBDIR QGIS_DATA_SUBDIR QGIS_PLUGIN_SUBDIR QGIS_INCLUDE_SUBDIR)
+
+# full paths for the installation
+SET (QGIS_BIN_DIR     ${QGIS_BIN_SUBDIR})
+SET (QGIS_CGIBIN_DIR  ${QGIS_CGIBIN_SUBDIR})
+SET (QGIS_LIB_DIR     ${QGIS_LIB_SUBDIR})
+SET (QGIS_LIBEXEC_DIR ${QGIS_LIBEXEC_SUBDIR})
+SET (QGIS_DATA_DIR    ${QGIS_DATA_SUBDIR})
+SET (QGIS_PLUGIN_DIR  ${QGIS_PLUGIN_SUBDIR})
+SET (QGIS_INCLUDE_DIR ${QGIS_INCLUDE_SUBDIR})
+
+# set the default locations where the targets (executables, libraries) will land when compiled
+# this is to allow running qgis from the source tree without having to actually do a "make install"
+SET (QGIS_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/output)
+SET (CMAKE_RUNTIME_OUTPUT_DIRECTORY ${QGIS_OUTPUT_DIRECTORY}/${QGIS_BIN_SUBDIR})
+SET (CMAKE_LIBRARY_OUTPUT_DIRECTORY ${QGIS_OUTPUT_DIRECTORY}/${QGIS_LIB_SUBDIR})
+
+# write a marker with source directory path into the output's bin directory
+# if run from the build directory QGIS will detect it and alter the paths
+FILE(WRITE ${QGIS_OUTPUT_DIRECTORY}/${QGIS_BIN_SUBDIR}/qgisbuildpath.txt "${CMAKE_SOURCE_DIR}\n${QGIS_OUTPUT_DIRECTORY}")
+
+# manual page - makes sense only on unix systems
+IF (UNIX AND NOT APPLE)
+  SET (DEFAULT_MANUAL_SUBDIR  man)
+  SET (QGIS_MANUAL_SUBDIR  ${DEFAULT_MANUAL_SUBDIR}  CACHE STRING "Subdirectory where manual files will be installed")
+  MARK_AS_ADVANCED (QGIS_MANUAL_SUBDIR)
+  SET (QGIS_MANUAL_DIR  ${CMAKE_INSTALL_PREFIX}/${QGIS_MANUAL_SUBDIR})
+ENDIF (UNIX AND NOT APPLE)
+
+
+#############################################################
+# Python build dependency
+
+IF(ENABLE_QT5)
+  SET(PYTHON_VER 3 CACHE STRING "Python version")
+ELSE(ENABLE_QT5)
+  SET(PYTHON_VER 2.7 CACHE STRING "Python version")
+ENDIF(ENABLE_QT5)
+
+FIND_PACKAGE(PythonInterp ${PYTHON_VER} REQUIRED)
+
+#############################################################
+# Python bindings
+
+IF (WITH_BINDINGS)
+
+  FIND_PACKAGE(PythonLibrary REQUIRED)
+
+  # python support: check for interpreter, sip, pyqt4
+  IF(ENABLE_QT5)
+    FIND_PACKAGE(PyQt5 REQUIRED)
+    SET(PYQT_SIP_FLAGS ${PYQT5_SIP_FLAGS})
+    SET(PYQT_SIP_DIR ${PYQT5_SIP_DIR})
+  ELSE(ENABLE_QT5)
+    FIND_PACKAGE(PyQt4 REQUIRED)
+    # setup SIP variables
+    SET(PYQT_SIP_FLAGS ${PYQT4_SIP_FLAGS})
+    SET(PYQT_SIP_DIR ${PYQT4_SIP_DIR})
+  ENDIF(ENABLE_QT5)
+  SEPARATE_ARGUMENTS(PYQT_SIP_FLAGS) # convert space separated values to a list
+
+  FIND_PACKAGE(SIP REQUIRED)
+  FIND_PACKAGE(Qsci REQUIRED)
+  INCLUDE(PythonMacros)
+  INCLUDE(PyQtMacros)
+  INCLUDE(SIPMacros)
+
+  SET(SIP_INCLUDES ${PYQT_SIP_DIR} ${CMAKE_SOURCE_DIR}/python)
+  SET(SIP_CONCAT_PARTS 4)
+
+  IF (NOT BINDINGS_GLOBAL_INSTALL)
+    SET(PYTHON_SITE_PACKAGES_DIR ${QGIS_DATA_DIR}/python)
+  ENDIF (NOT BINDINGS_GLOBAL_INSTALL)
+
+  IF (WITH_CUSTOM_WIDGETS)
+    SET(PYUIC_WIDGET_PLUGIN_DIRECTORY ${PYQT4_MOD_DIR}/uic/widget-plugins/)
+  ENDIF (WITH_CUSTOM_WIDGETS)
+
+ENDIF (WITH_BINDINGS)
+
+#############################################################
+# create qgsconfig.h
+# installed with app target
+
+CONFIGURE_FILE(${CMAKE_SOURCE_DIR}/cmake_templates/qgsconfig.h.in ${CMAKE_BINARY_DIR}/qgsconfig.h)
+INCLUDE_DIRECTORIES(${CMAKE_BINARY_DIR})
+
+# Added by Jef to prevent python core and gui libs linking to other qgisCore and qgisGui libs
+# that may be in the same install prefix
+LINK_DIRECTORIES(${CMAKE_BINARY_DIR}/src/core ${CMAKE_BINARY_DIR}/src/gui)
+
+#############################################################
+# create qgsversion.h
+IF (EXISTS ${CMAKE_SOURCE_DIR}/.git/index)
+  FIND_PROGRAM(GITCOMMAND git PATHS c:/cygwin/bin)
+  IF(GITCOMMAND)
+    IF(WIN32)
+      IF(USING_NINJA)
+       SET(ARG %a)
+      ELSE(USING_NINJA)
+       SET(ARG %%a)
+      ENDIF(USING_NINJA)
+      ADD_CUSTOM_COMMAND(
+        OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/qgsversion.h ${CMAKE_CURRENT_BINARY_DIR}/qgsversion.inc
+        COMMAND for /f \"usebackq tokens=1\" ${ARG} in "(`\"${GITCOMMAND}\" log -n1 --oneline`)" do echo \#define QGSVERSION \"${ARG}\" >${CMAKE_CURRENT_BINARY_DIR}/qgsversion.h.temp
+        COMMAND for /f \"usebackq tokens=1\" ${ARG} in "(`\"${GITCOMMAND}\" log -n1 --oneline`)" do echo PROJECT_NUMBER = \"${COMPLETE_VERSION}-${RELEASE_NAME} \(${ARG}\)\" >${CMAKE_CURRENT_BINARY_DIR}/qgsversion.inc
+        COMMAND ${CMAKE_COMMAND} -DSRC=${CMAKE_CURRENT_BINARY_DIR}/qgsversion.h.temp -DDST=${CMAKE_CURRENT_BINARY_DIR}/qgsversion.h -P ${CMAKE_SOURCE_DIR}/cmake/CopyIfChanged.cmake
+        MAIN_DEPENDENCY ${CMAKE_SOURCE_DIR}/.git/index
+        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
+      )
+    ELSE(WIN32)
+      ADD_CUSTOM_COMMAND(
+        OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/qgsversion.h
+        COMMAND ${GITCOMMAND} log -n1 --pretty=\#define\\ QGSVERSION\\ \\"%h\\" >${CMAKE_CURRENT_BINARY_DIR}/qgsversion.h.temp
+        COMMAND ${GITCOMMAND} config remote.$$\(${GITCOMMAND} config branch.$$\(${GITCOMMAND} name-rev --name-only HEAD\).remote\).url | sed -e 's/^/\#define QGS_GIT_REMOTE_URL \"/' -e 's/$$/\"/' >>${CMAKE_CURRENT_BINARY_DIR}/qgsversion.h.temp
+        COMMAND ${CMAKE_COMMAND} -DSRC=${CMAKE_CURRENT_BINARY_DIR}/qgsversion.h.temp -DDST=${CMAKE_CURRENT_BINARY_DIR}/qgsversion.h -P ${CMAKE_SOURCE_DIR}/cmake/CopyIfChanged.cmake
+        MAIN_DEPENDENCY ${CMAKE_SOURCE_DIR}/.git/index
+        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
+      )
+    ENDIF(WIN32)
+  ELSE(GITCOMMAND)
+    MESSAGE(STATUS "git marker, but no git found - version will be unknown")
+    SET(REVISION "unknown")
+    FILE(WRITE ${CMAKE_CURRENT_BINARY_DIR}/qgsversion.h "#define QGSVERSION \"unknown\"")
+  ENDIF(GITCOMMAND)
+ELSE (EXISTS ${CMAKE_SOURCE_DIR}/.git/index)
+  SET(REVISION "exported")
+  FILE(WRITE ${CMAKE_CURRENT_BINARY_DIR}/qgsversion.h "#define QGSVERSION \"exported\"")
+ENDIF (EXISTS ${CMAKE_SOURCE_DIR}/.git/index)
+
+ADD_CUSTOM_TARGET(version ALL DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/qgsversion.h)
+
+#############################################################
+# process subdirs
+
+#create a variable to specify where our test data is
+#so that unit tests can use TEST_DATA_DIR to locate
+#the test data. See CMakeLists in test dirs for more info
+#TEST_DATA_DIR is also used by QgsRenderChecker currently in core
+SET (TEST_DATA_DIR "${CMAKE_CURRENT_SOURCE_DIR}/tests/testdata")
+
+ADD_SUBDIRECTORY(src)
+ADD_SUBDIRECTORY(doc)
+ADD_SUBDIRECTORY(images)
+ADD_SUBDIRECTORY(resources)
+ADD_SUBDIRECTORY(i18n)
+
+IF (WITH_BINDINGS)
+  ADD_SUBDIRECTORY(python)
+ENDIF (WITH_BINDINGS)
+
+IF (ENABLE_TESTS)
+  ADD_SUBDIRECTORY(tests)
+  SET (CTEST_BINARY_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/output/bin" )
+  MESSAGE (STATUS "Ctest Binary Directory  set to: ${CTEST_BINARY_DIRECTORY}")
+ENDIF (ENABLE_TESTS)
+
+IF (APPLE)
+  # must be last for install, so install_name_tool can do its work
+  ADD_SUBDIRECTORY(mac)
+
+  # allow QGIS to be run directly from build directory and to run unit tests
+  EXECUTE_PROCESS(COMMAND /bin/mkdir -p "${QGIS_OUTPUT_DIRECTORY}/lib")
+  EXECUTE_PROCESS(
+    COMMAND /bin/ln -fs ../../Plugins/qgis/qgisgrass6.framework lib/
+    WORKING_DIRECTORY "${QGIS_OUTPUT_DIRECTORY}"
+  )
+  EXECUTE_PROCESS(
+    COMMAND /bin/ln -fs ../../Plugins/qgis/qgisgrass7.framework lib/
+    WORKING_DIRECTORY "${QGIS_OUTPUT_DIRECTORY}"
+  )
+ENDIF (APPLE)
+
+# manual page - makes sense only on unix systems
+IF (UNIX AND NOT APPLE)
+  INSTALL (FILES qgis.1 qbrowser.1 DESTINATION ${QGIS_MANUAL_DIR}/man1)
+ENDIF (UNIX AND NOT APPLE)
+
+INSTALL(FILES cmake/FindQGIS.cmake DESTINATION ${QGIS_DATA_DIR})
+
+#############################################################
+# Post-install commands
+ADD_SUBDIRECTORY(postinstall)
+
+#############################################################
+# Uninstall stuff see: http://www.vtk.org/Wiki/CMake_FAQ
+CONFIGURE_FILE(
+  "${CMAKE_CURRENT_SOURCE_DIR}/cmake_templates/cmake_uninstall.cmake.in"
+  "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
+  IMMEDIATE @ONLY)
+
+ADD_CUSTOM_TARGET(uninstall
+  "${CMAKE_COMMAND}" -P "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake")
+
+#############################################################
+# Enable packaging
+
+# Do not warn about runtime libs when building using VS Express
+IF(NOT DEFINED CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_NO_WARNINGS)
+  SET(CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_NO_WARNINGS ON)
+ENDIF()
+INCLUDE(InstallRequiredSystemLibraries)
+
+SET(CPACK_PACKAGE_DESCRIPTION_SUMMARY "QGIS")
+SET(CPACK_PACKAGE_VENDOR "Open Source Geospatial Foundation")
+SET(CPACK_PACKAGE_DESCRIPTION_FILE "${CMAKE_CURRENT_SOURCE_DIR}/README")
+SET(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/COPYING")
+SET(CPACK_PACKAGE_INSTALL_DIRECTORY "QGIS ${COMPLETE_VERSION}")
+IF(WIN32 AND NOT UNIX)
+  # There is a bug in NSI that does not handle full unix paths properly. Make
+  # sure there is at least one set of four (4) backslashes.
+  SET(CPACK_PACKAGE_ICON "${CMAKE_SOURCE_DIR}/win_build\\\\sidebar.bmp")
+  SET(CPACK_NSIS_INSTALLED_ICON_NAME "\\\\qgis.exe")
+  SET(CPACK_NSIS_DISPLAY_NAME "${CPACK_PACKAGE_INSTALL_DIRECTORY} QGIS")
+  SET(CPACK_NSIS_HELP_LINK "http:\\\\\\\\qgis.org")
+  SET(CPACK_NSIS_URL_INFO_ABOUT "http:\\\\\\\\qgis.org")
+  SET(CPACK_NSIS_CONTACT "tim@linfiniti.com")
+  SET(CPACK_NSIS_MODIFY_PATH ON)
+
+#  SET(CPACK_NSIS_EXTRA_INSTALL_COMMANDS "  !include \\\"${CMAKE_SOURCE_DIR}\\\\win_build\\\\extra.nsh\\\"")
+ELSE(WIN32 AND NOT UNIX)
+  #SET(CPACK_STRIP_FILES "QGIS")
+  #SET(CPACK_SOURCE_STRIP_FILES "")
+ENDIF(WIN32 AND NOT UNIX)
+SET(CPACK_PACKAGE_EXECUTABLES "qgis" "QGIS")
+SET(CPACK_PACKAGE_DESCRIPTION_FILE "${CMAKE_SOURCE_DIR}/README.md")
+INCLUDE(CPack)
diff -ruN qgis-2.14.13-orig/cmake/FindOSGEARTH.cmake qgis-2.14.13/cmake/FindOSGEARTH.cmake
--- qgis-2.14.13-orig/cmake/FindOSGEARTH.cmake	2017-04-16 16:54:17.000000000 +0900
+++ qgis-2.14.13/cmake/FindOSGEARTH.cmake	2017-04-16 16:55:03.000000000 +0900
@@ -27,15 +27,7 @@
         $ENV{OSGEARTHDIR}
         $ENV{OSGEARTH_DIR}
         $ENV{OSGEO4W_ROOT}
-        /usr/local/
-        /usr/
         /sw/ # Fink
-        /opt/local/ # DarwinPorts
-        /opt/csw/ # Blastwave
-        /opt/
-        [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session\ Manager\\Environment;OSGEARTH_ROOT]/
-        ~/Library/Frameworks
-        /Library/Frameworks
     PATH_SUFFIXES
         /include/
 )
@@ -108,7 +100,7 @@
     SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${OSGEARTHUTIL_LIBRARY})
     IF(APPLE)
         # no extra LDFLAGS used in link test, may fail in OS X SDK
-        SET(CMAKE_REQUIRED_LIBRARIES "-F/Library/Frameworks" ${CMAKE_REQUIRED_LIBRARIES})
+        # SET(CMAKE_REQUIRED_LIBRARIES "-F/Library/Frameworks" ${CMAKE_REQUIRED_LIBRARIES})
     ENDIF(APPLE)
     CHECK_CXX_SOURCE_COMPILES("
 #include <osgEarthUtil/Controls>
diff -ruN qgis-2.14.13-orig/cmake/FindQScintilla.cmake qgis-2.14.13/cmake/FindQScintilla.cmake
--- qgis-2.14.13-orig/cmake/FindQScintilla.cmake	2017-04-16 16:54:17.000000000 +0900
+++ qgis-2.14.13/cmake/FindQScintilla.cmake	2017-04-16 16:55:03.000000000 +0900
@@ -25,7 +25,7 @@
 ELSE(EXISTS QSCINTILLA_VERSION_STR)
 
   FIND_PATH(QSCINTILLA_INCLUDE_DIR
-    NAMES Qsci/qsciglobal.h
+    NAMES qsciglobal.h
     PATHS
       ${Qt5Core_INCLUDE_DIRS}
       "${QT_INCLUDE_DIR}"
@@ -62,7 +62,7 @@
   IF(QSCINTILLA_INCLUDE_DIR AND NOT EXISTS QSCINTILLA_VERSION_STR)
     # get QScintilla2 version from header, is optinally retrieved via bindings
     # with Qsci PyQt4 module
-    FILE(READ ${QSCINTILLA_INCLUDE_DIR}/Qsci/qsciglobal.h qsci_header)
+    FILE(READ ${QSCINTILLA_INCLUDE_DIR}/qsciglobal.h qsci_header)
     STRING(REGEX REPLACE "^.*QSCINTILLA_VERSION_STR +\"([^\"]+)\".*$" "\\1" QSCINTILLA_VERSION_STR "${qsci_header}")
   ENDIF(QSCINTILLA_INCLUDE_DIR AND NOT EXISTS QSCINTILLA_VERSION_STR)
 
diff -ruN qgis-2.14.13-orig/cmake/FindSPATIALITE.cmake qgis-2.14.13/cmake/FindSPATIALITE.cmake
--- qgis-2.14.13-orig/cmake/FindSPATIALITE.cmake	2017-04-16 16:54:17.000000000 +0900
+++ qgis-2.14.13/cmake/FindSPATIALITE.cmake	2017-04-16 16:55:03.000000000 +0900
@@ -1,4 +1,4 @@
-# Find SpatiaLite
+ # Find SpatiaLite
 # ~~~~~~~~~~~~~~~
 # Copyright (c) 2009, Sandro Furieri <a.furieri at lqt.it>
 # Redistribution and use is allowed according to the terms of the BSD license.
@@ -67,7 +67,7 @@
    # Check for symbol gaiaDropTable
    IF(APPLE)
        # no extra LDFLAGS used in link test, may fail in OS X SDK
-       SET(CMAKE_REQUIRED_LIBRARIES "-F/Library/Frameworks" ${CMAKE_REQUIRED_LIBRARIES})
+       # SET(CMAKE_REQUIRED_LIBRARIES "-F/Library/Frameworks" ${CMAKE_REQUIRED_LIBRARIES})
    ENDIF(APPLE)
    check_library_exists("${SPATIALITE_LIBRARY}" gaiaDropTable "" SPATIALITE_VERSION_GE_4_0_0)
    check_library_exists("${SPATIALITE_LIBRARY}" gaiaStatisticsInvalidate "" SPATIALITE_VERSION_G_4_1_1)
diff -ruN qgis-2.14.13-orig/cmake/FindSPATIALITE.cmake.orig qgis-2.14.13/cmake/FindSPATIALITE.cmake.orig
--- qgis-2.14.13-orig/cmake/FindSPATIALITE.cmake.orig	1970-01-01 09:00:00.000000000 +0900
+++ qgis-2.14.13/cmake/FindSPATIALITE.cmake.orig	2017-03-24 21:21:50.000000000 +0900
@@ -0,0 +1,82 @@
+# Find SpatiaLite
+# ~~~~~~~~~~~~~~~
+# Copyright (c) 2009, Sandro Furieri <a.furieri at lqt.it>
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+#
+# CMake module to search for SpatiaLite library
+#
+# If it's found it sets SPATIALITE_FOUND to TRUE
+# and following variables are set:
+#    SPATIALITE_INCLUDE_DIR
+#    SPATIALITE_LIBRARY
+
+# This macro checks if the symbol exists
+include(CheckLibraryExists)
+
+
+# FIND_PATH and FIND_LIBRARY normally search standard locations
+# before the specified paths. To search non-standard paths first,
+# FIND_* is invoked first with specified paths and NO_DEFAULT_PATH
+# and then again with no specified paths to search the default
+# locations. When an earlier FIND_* succeeds, subsequent FIND_*s
+# searching for the same item do nothing. 
+
+# try to use sqlite framework on mac
+# want clean framework path, not unix compatibility path
+IF (APPLE)
+  IF (CMAKE_FIND_FRAMEWORK MATCHES "FIRST"
+      OR CMAKE_FRAMEWORK_PATH MATCHES "ONLY"
+      OR NOT CMAKE_FIND_FRAMEWORK)
+    SET (CMAKE_FIND_FRAMEWORK_save ${CMAKE_FIND_FRAMEWORK} CACHE STRING "" FORCE)
+    SET (CMAKE_FIND_FRAMEWORK "ONLY" CACHE STRING "" FORCE)
+    FIND_PATH(SPATIALITE_INCLUDE_DIR SQLite3/spatialite.h)
+    # if no spatialite header, we don't want sqlite find below to succeed
+    IF (SPATIALITE_INCLUDE_DIR)
+      FIND_LIBRARY(SPATIALITE_LIBRARY SQLite3)
+      # FIND_PATH doesn't add "Headers" for a framework
+      SET (SPATIALITE_INCLUDE_DIR ${SPATIALITE_LIBRARY}/Headers CACHE PATH "Path to a file." FORCE)
+    ENDIF (SPATIALITE_INCLUDE_DIR)
+    SET (CMAKE_FIND_FRAMEWORK ${CMAKE_FIND_FRAMEWORK_save} CACHE STRING "" FORCE)
+  ENDIF ()
+ENDIF (APPLE)
+
+FIND_PATH(SPATIALITE_INCLUDE_DIR spatialite.h
+  "$ENV{INCLUDE}"
+  "$ENV{LIB_DIR}/include"
+  "$ENV{LIB_DIR}/include/spatialite"
+  )
+
+FIND_LIBRARY(SPATIALITE_LIBRARY NAMES spatialite_i spatialite PATHS
+  /usr/lib
+  $ENV{LIB}
+  $ENV{LIB_DIR}/lib
+  )
+
+IF (SPATIALITE_INCLUDE_DIR AND SPATIALITE_LIBRARY)
+   SET(SPATIALITE_FOUND TRUE)
+ENDIF (SPATIALITE_INCLUDE_DIR AND SPATIALITE_LIBRARY)
+
+
+IF (SPATIALITE_FOUND)
+
+   IF (NOT SPATIALITE_FIND_QUIETLY)
+      MESSAGE(STATUS "Found SpatiaLite: ${SPATIALITE_LIBRARY}")
+   ENDIF (NOT SPATIALITE_FIND_QUIETLY)
+
+   # Check for symbol gaiaDropTable
+   IF(APPLE)
+       # no extra LDFLAGS used in link test, may fail in OS X SDK
+       SET(CMAKE_REQUIRED_LIBRARIES "-F/Library/Frameworks" ${CMAKE_REQUIRED_LIBRARIES})
+   ENDIF(APPLE)
+   check_library_exists("${SPATIALITE_LIBRARY}" gaiaDropTable "" SPATIALITE_VERSION_GE_4_0_0)
+   check_library_exists("${SPATIALITE_LIBRARY}" gaiaStatisticsInvalidate "" SPATIALITE_VERSION_G_4_1_1)
+   check_library_exists("${SPATIALITE_LIBRARY}" spatialite_init_ex "" SPATIALITE_HAS_INIT_EX)
+
+ELSE (SPATIALITE_FOUND)
+
+   IF (SPATIALITE_FIND_REQUIRED)
+      MESSAGE(FATAL_ERROR "Could not find SpatiaLite")
+   ENDIF (SPATIALITE_FIND_REQUIRED)
+
+ENDIF (SPATIALITE_FOUND)
diff -ruN qgis-2.14.13-orig/images/icons/mac/browser/CMakeLists.txt qgis-2.14.13/images/icons/mac/browser/CMakeLists.txt
--- qgis-2.14.13-orig/images/icons/mac/browser/CMakeLists.txt	2017-04-16 16:54:17.000000000 +0900
+++ qgis-2.14.13/images/icons/mac/browser/CMakeLists.txt	2017-04-16 16:55:03.000000000 +0900
@@ -6,4 +6,4 @@
 # create alias now, so alias file gets correct icon, delete first if any exist
 SET (BROWSERNAME "QGIS Browser")
 INSTALL (CODE "EXECUTE_PROCESS(COMMAND /usr/bin/find \"$ENV{DESTDIR}${QGIS_INSTALL_PREFIX}\" -name \"${BROWSERNAME}*\" -maxdepth 1 -type f -delete)")
-INSTALL (CODE "EXECUTE_PROCESS(COMMAND /usr/bin/osascript -e \"tell application \\\"Finder\\\" to make alias file to POSIX file \\\"$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}/${QGIS_BIN_DIR}/${BROWSERNAME}.app\\\" at POSIX file \\\"$ENV{DESTDIR}${QGIS_INSTALL_PREFIX}/\\\"\")")
+# INSTALL (CODE "EXECUTE_PROCESS(COMMAND /usr/bin/osascript -e \"tell application \\\"Finder\\\" to make alias file to POSIX file \\\"$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}/${QGIS_BIN_DIR}/${BROWSERNAME}.app\\\" at POSIX file \\\"$ENV{DESTDIR}${QGIS_INSTALL_PREFIX}/\\\"\")")
Binary files qgis-2.14.13-orig/python/.DS_Store and qgis-2.14.13/python/.DS_Store differ
Binary files qgis-2.14.13-orig/python/plugins/.DS_Store and qgis-2.14.13/python/plugins/.DS_Store differ
Binary files qgis-2.14.13-orig/python/plugins/processing/.DS_Store and qgis-2.14.13/python/plugins/processing/.DS_Store differ
Binary files qgis-2.14.13-orig/python/plugins/processing/algs/.DS_Store and qgis-2.14.13/python/plugins/processing/algs/.DS_Store differ
diff -ruN qgis-2.14.13-orig/python/plugins/processing/algs/grass/GrassUtils.py qgis-2.14.13/python/plugins/processing/algs/grass/GrassUtils.py
--- qgis-2.14.13-orig/python/plugins/processing/algs/grass/GrassUtils.py	2017-04-16 16:54:18.000000000 +0900
+++ qgis-2.14.13/python/plugins/processing/algs/grass/GrassUtils.py	2017-04-16 16:55:03.000000000 +0900
@@ -250,25 +250,17 @@
     def prepareGrassExecution(commands):
         env = os.environ.copy()
 
-        if isWindows():
-            GrassUtils.createGrassScript(commands)
-            command = ['cmd.exe', '/C ', GrassUtils.grassScriptFilename()]
-        else:
-            gisrc = userFolder() + os.sep + 'processing.gisrc'
-            env['GISRC'] = gisrc
-            env['GRASS_MESSAGE_FORMAT'] = 'gui'
-            env['GRASS_BATCH_JOB'] = GrassUtils.grassBatchJobFilename()
-            if 'GISBASE' in env:
-                del env['GISBASE']
-            GrassUtils.createGrassBatchJobFileFromGrassCommands(commands)
-            os.chmod(GrassUtils.grassBatchJobFilename(), stat.S_IEXEC
-                     | stat.S_IREAD | stat.S_IWRITE)
-            if isMac():
-                command = GrassUtils.grassPath() + os.sep + 'grass.sh ' \
-                    + GrassUtils.grassMapsetFolder() + '/PERMANENT'
-            else:
-                command = 'grass64 ' + GrassUtils.grassMapsetFolder() \
-                    + '/PERMANENT'
+        gisrc = userFolder() + os.sep + 'processing.gisrc'
+        env['GISRC'] = gisrc
+        env['GRASS_MESSAGE_FORMAT'] = 'gui'
+        env['GRASS_BATCH_JOB'] = GrassUtils.grassBatchJobFilename()
+        if 'GISBASE' in env:
+            del env['GISBASE']
+        GrassUtils.createGrassBatchJobFileFromGrassCommands(commands)
+        os.chmod(GrassUtils.grassBatchJobFilename(), stat.S_IEXEC
+                 | stat.S_IREAD | stat.S_IWRITE)
+        command = GrassUtils.grassPath() + os.sep + 'grass.sh ' \
+             + GrassUtils.grassMapsetFolder() + '/PERMANENT'
 
         return command, env
 
diff -ruN qgis-2.14.13-orig/python/plugins/processing/algs/grass/GrassUtils.py.orig qgis-2.14.13/python/plugins/processing/algs/grass/GrassUtils.py.orig
--- qgis-2.14.13-orig/python/plugins/processing/algs/grass/GrassUtils.py.orig	1970-01-01 09:00:00.000000000 +0900
+++ qgis-2.14.13/python/plugins/processing/algs/grass/GrassUtils.py.orig	2017-03-24 21:21:50.000000000 +0900
@@ -0,0 +1,437 @@
+# -*- coding: utf-8 -*-
+
+"""
+***************************************************************************
+    GrassUtils.py
+    ---------------------
+    Date                 : August 2012
+    Copyright            : (C) 2012 by Victor Olaya
+    Email                : volayaf at gmail dot com
+***************************************************************************
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+***************************************************************************
+"""
+
+__author__ = 'Victor Olaya'
+__date__ = 'August 2012'
+__copyright__ = '(C) 2012, Victor Olaya'
+
+# This will get replaced with a git SHA1 when you do a git archive
+
+__revision__ = '$Format:%H$'
+
+import stat
+import shutil
+import codecs
+import subprocess
+import os
+import locale
+from qgis.core import QgsApplication
+from PyQt4.QtCore import QCoreApplication
+from processing.core.ProcessingConfig import ProcessingConfig
+from processing.core.ProcessingLog import ProcessingLog
+from processing.tools.system import userFolder, isWindows, isMac, tempFolder, mkdir
+from processing.tests.TestData import points
+
+
+class GrassUtils:
+
+    GRASS_REGION_XMIN = 'GRASS_REGION_XMIN'
+    GRASS_REGION_YMIN = 'GRASS_REGION_YMIN'
+    GRASS_REGION_XMAX = 'GRASS_REGION_XMAX'
+    GRASS_REGION_YMAX = 'GRASS_REGION_YMAX'
+    GRASS_REGION_CELLSIZE = 'GRASS_REGION_CELLSIZE'
+    GRASS_FOLDER = 'GRASS_FOLDER'
+    GRASS_WIN_SHELL = 'GRASS_WIN_SHELL'
+    GRASS_LOG_COMMANDS = 'GRASS_LOG_COMMANDS'
+    GRASS_LOG_CONSOLE = 'GRASS_LOG_CONSOLE'
+    GRASS_HELP_PATH = 'GRASS_HELP_PATH'
+
+    sessionRunning = False
+    sessionLayers = {}
+    projectionSet = False
+
+    isGrassInstalled = False
+
+    @staticmethod
+    def grassBatchJobFilename():
+        '''This is used in Linux. This is the batch job that we assign to
+        GRASS_BATCH_JOB and then call GRASS and let it do the work
+        '''
+        filename = 'grass_batch_job.sh'
+        batchfile = userFolder() + os.sep + filename
+        return batchfile
+
+    @staticmethod
+    def grassScriptFilename():
+        '''This is used in windows. We create a script that initializes
+        GRASS and then uses grass commands
+        '''
+        filename = 'grass_script.bat'
+        filename = userFolder() + os.sep + filename
+        return filename
+
+    @staticmethod
+    def getGrassVersion():
+        # I do not know if this should be removed or let the user enter it
+        # or something like that... This is just a temporary thing
+        return '6.4.0'
+
+    @staticmethod
+    def grassPath():
+        if not isWindows() and not isMac():
+            return ''
+
+        folder = ProcessingConfig.getSetting(GrassUtils.GRASS_FOLDER) or ''
+        if not os.path.exists(folder):
+            folder = None
+        if folder is None:
+            if isWindows():
+                if "OSGEO4W_ROOT" in os.environ:
+                    testfolder = os.path.join(unicode(os.environ['OSGEO4W_ROOT']), "apps")
+                else:
+                    testfolder = unicode(QgsApplication.prefixPath())
+                testfolder = os.path.join(testfolder, 'grass')
+                if os.path.isdir(testfolder):
+                    for subfolder in os.listdir(testfolder):
+                        if subfolder.startswith('grass-6'):
+                            folder = os.path.join(testfolder, subfolder)
+                            break
+            else:
+                folder = os.path.join(QgsApplication.prefixPath(), 'grass')
+                if not os.path.isdir(folder):
+                    folder = '/Applications/GRASS-6.4.app/Contents/MacOS'
+
+        return folder or ''
+
+    @staticmethod
+    def grassWinShell():
+        folder = ProcessingConfig.getSetting(GrassUtils.GRASS_WIN_SHELL) or ''
+        if not os.path.exists(folder):
+            folder = None
+        if folder is None and GrassUtils.grassPath():
+            folder = os.path.dirname(unicode(QgsApplication.prefixPath()))
+            folder = os.path.join(folder, 'msys')
+        return folder or ''
+
+    @staticmethod
+    def grassDescriptionPath():
+        return os.path.join(os.path.dirname(__file__), 'description')
+
+    @staticmethod
+    def createGrassScript(commands):
+        folder = GrassUtils.grassPath()
+        shell = GrassUtils.grassWinShell()
+
+        script = GrassUtils.grassScriptFilename()
+        gisrc = userFolder() + os.sep + 'processing.gisrc'
+
+        encoding = locale.getpreferredencoding()
+        # Temporary gisrc file
+        output = codecs.open(gisrc, 'w', encoding=encoding)
+        location = 'temp_location'
+        gisdbase = GrassUtils.grassDataFolder()
+
+        output.write('GISDBASE: ' + gisdbase + '\n')
+        output.write('LOCATION_NAME: ' + location + '\n')
+        output.write('MAPSET: PERMANENT \n')
+        output.write('GRASS_GUI: text\n')
+        output.close()
+
+        output = codecs.open(script, 'w', encoding=encoding)
+        output.write('set HOME=' + os.path.expanduser('~') + '\n')
+        output.write('set GISRC=' + gisrc + '\n')
+        output.write('set GRASS_SH=' + shell + '\\bin\\sh.exe\n')
+        output.write('set PATH=' + shell + os.sep + 'bin;' + shell + os.sep
+                     + 'lib;' + '%PATH%\n')
+        output.write('set WINGISBASE=' + folder + '\n')
+        output.write('set GISBASE=' + folder + '\n')
+        output.write('set GRASS_PROJSHARE=' + folder + os.sep + 'share'
+                     + os.sep + 'proj' + '\n')
+        output.write('set GRASS_MESSAGE_FORMAT=gui\n')
+
+        # Replacement code for etc/Init.bat
+        output.write('if "%GRASS_ADDON_PATH%"=="" set PATH=%WINGISBASE%\\bin;%WINGISBASE%\\lib;%PATH%\n')
+        output.write('if not "%GRASS_ADDON_PATH%"=="" set PATH=%WINGISBASE%\\bin;%WINGISBASE%\\lib;%GRASS_ADDON_PATH%;%PATH%\n')
+        output.write('\n')
+        output.write('set GRASS_VERSION=' + GrassUtils.getGrassVersion() + '\n')
+        output.write('if not "%LANG%"=="" goto langset\n')
+        output.write('FOR /F "usebackq delims==" %%i IN (`"%WINGISBASE%\\etc\\winlocale"`) DO @set LANG=%%i\n')
+        output.write(':langset\n')
+        output.write('\n')
+        output.write('set PATHEXT=%PATHEXT%;.PY\n')
+        output.write('set PYTHONPATH=%PYTHONPATH%;%WINGISBASE%\\etc\\python;%WINGISBASE%\\etc\\wxpython\\n')
+        output.write('\n')
+        output.write('g.gisenv.exe set="MAPSET=PERMANENT"\n')
+        output.write('g.gisenv.exe set="LOCATION=' + location + '"\n')
+        output.write('g.gisenv.exe set="LOCATION_NAME=' + location + '"\n')
+        output.write('g.gisenv.exe set="GISDBASE=' + gisdbase + '"\n')
+        output.write('g.gisenv.exe set="GRASS_GUI=text"\n')
+        for command in commands:
+            output.write(command + u'\n')
+        output.write('\n')
+        output.write('exit\n')
+        output.close()
+
+    @staticmethod
+    def createGrassBatchJobFileFromGrassCommands(commands):
+        fout = codecs.open(GrassUtils.grassBatchJobFilename(), 'w', encoding='utf-8')
+        for command in commands:
+            fout.write(command + u'\n')
+        fout.write('exit')
+        fout.close()
+
+    @staticmethod
+    def grassMapsetFolder():
+        folder = os.path.join(GrassUtils.grassDataFolder(), 'temp_location')
+        mkdir(folder)
+        return folder
+
+    @staticmethod
+    def grassDataFolder():
+        tempfolder = os.path.join(tempFolder(), 'grassdata')
+        mkdir(tempfolder)
+        return tempfolder
+
+    @staticmethod
+    def createTempMapset():
+        '''Creates a temporary location and mapset(s) for GRASS data
+        processing. A minimal set of folders and files is created in the
+        system's default temporary directory. The settings files are
+        written with sane defaults, so GRASS can do its work. The mapset
+        projection will be set later, based on the projection of the first
+        input image or vector
+        '''
+
+        folder = GrassUtils.grassMapsetFolder()
+        mkdir(os.path.join(folder, 'PERMANENT'))
+        mkdir(os.path.join(folder, 'PERMANENT', '.tmp'))
+        GrassUtils.writeGrassWindow(os.path.join(folder, 'PERMANENT', 'DEFAULT_WIND'))
+        outfile = codecs.open(os.path.join(folder, 'PERMANENT', 'MYNAME'), 'w', encoding='utf-8')
+        outfile.write(
+            'QGIS GRASS interface: temporary data processing location.\n')
+        outfile.close()
+
+        GrassUtils.writeGrassWindow(os.path.join(folder, 'PERMANENT', 'WIND'))
+        mkdir(os.path.join(folder, 'PERMANENT', 'dbf'))
+        outfile = codecs.open(os.path.join(folder, 'PERMANENT', 'VAR'), 'w', encoding='utf-8')
+        outfile.write('DB_DRIVER: dbf\n')
+        outfile.write('DB_DATABASE: $GISDBASE/$LOCATION_NAME/$MAPSET/dbf/\n')
+        outfile.close()
+
+    @staticmethod
+    def writeGrassWindow(filename):
+        with open(filename, 'w') as out:
+            out.write('proj:       0\n')
+            out.write('zone:       0\n')
+            out.write('north:      1\n')
+            out.write('south:      0\n')
+            out.write('east:       1\n')
+            out.write('west:       0\n')
+            out.write('cols:       1\n')
+            out.write('rows:       1\n')
+            out.write('e-w resol:  1\n')
+            out.write('n-s resol:  1\n')
+            out.write('top:        1\n')
+            out.write('bottom:     0\n')
+            out.write('cols3:      1\n')
+            out.write('rows3:      1\n')
+            out.write('depths:     1\n')
+            out.write('e-w resol3: 1\n')
+            out.write('n-s resol3: 1\n')
+            out.write('t-b resol:  1\n')
+
+    @staticmethod
+    def prepareGrassExecution(commands):
+        env = os.environ.copy()
+
+        if isWindows():
+            GrassUtils.createGrassScript(commands)
+            command = ['cmd.exe', '/C ', GrassUtils.grassScriptFilename()]
+        else:
+            gisrc = userFolder() + os.sep + 'processing.gisrc'
+            env['GISRC'] = gisrc
+            env['GRASS_MESSAGE_FORMAT'] = 'gui'
+            env['GRASS_BATCH_JOB'] = GrassUtils.grassBatchJobFilename()
+            if 'GISBASE' in env:
+                del env['GISBASE']
+            GrassUtils.createGrassBatchJobFileFromGrassCommands(commands)
+            os.chmod(GrassUtils.grassBatchJobFilename(), stat.S_IEXEC
+                     | stat.S_IREAD | stat.S_IWRITE)
+            if isMac():
+                command = GrassUtils.grassPath() + os.sep + 'grass.sh ' \
+                    + GrassUtils.grassMapsetFolder() + '/PERMANENT'
+            else:
+                command = 'grass64 ' + GrassUtils.grassMapsetFolder() \
+                    + '/PERMANENT'
+
+        return command, env
+
+    @staticmethod
+    def executeGrass(commands, progress, outputCommands=None):
+        loglines = []
+        loglines.append('GRASS execution console output')
+        grassOutDone = False
+        command, grassenv = GrassUtils.prepareGrassExecution(commands)
+        proc = subprocess.Popen(
+            command,
+            shell=True,
+            stdout=subprocess.PIPE,
+            stdin=open(os.devnull),
+            stderr=subprocess.STDOUT,
+            universal_newlines=True,
+            env=grassenv
+        ).stdout
+        progress.setInfo('GRASS commands output:')
+        for line in iter(proc.readline, ''):
+            if 'GRASS_INFO_PERCENT' in line:
+                try:
+                    progress.setPercentage(int(line[len('GRASS_INFO_PERCENT') + 2:]))
+                except:
+                    pass
+            else:
+                if 'r.out' in line or 'v.out' in line:
+                    grassOutDone = True
+                loglines.append(line)
+                progress.setConsoleInfo(line)
+
+        # Some GRASS scripts, like r.mapcalculator or r.fillnulls, call
+        # other GRASS scripts during execution. This may override any
+        # commands that are still to be executed by the subprocess, which
+        # are usually the output ones. If that is the case runs the output
+        # commands again.
+
+        if not grassOutDone and outputCommands:
+            command, grassenv = GrassUtils.prepareGrassExecution(outputCommands)
+            proc = subprocess.Popen(
+                command,
+                shell=True,
+                stdout=subprocess.PIPE,
+                stdin=open(os.devnull),
+                stderr=subprocess.STDOUT,
+                universal_newlines=True,
+                env=grassenv
+            ).stdout
+            for line in iter(proc.readline, ''):
+                if 'GRASS_INFO_PERCENT' in line:
+                    try:
+                        progress.setPercentage(int(
+                            line[len('GRASS_INFO_PERCENT') + 2:]))
+                    except:
+                        pass
+                else:
+                    loglines.append(line)
+                    progress.setConsoleInfo(line)
+
+        if ProcessingConfig.getSetting(GrassUtils.GRASS_LOG_CONSOLE):
+            ProcessingLog.addToLog(ProcessingLog.LOG_INFO, loglines)
+
+    # GRASS session is used to hold the layers already exported or
+    # produced in GRASS between multiple calls to GRASS algorithms.
+    # This way they don't have to be loaded multiple times and
+    # following algorithms can use the results of the previous ones.
+    # Starting a session just involves creating the temp mapset
+    # structure
+    @staticmethod
+    def startGrassSession():
+        if not GrassUtils.sessionRunning:
+            GrassUtils.createTempMapset()
+            GrassUtils.sessionRunning = True
+
+    # End session by removing the temporary GRASS mapset and all
+    # the layers.
+    @staticmethod
+    def endGrassSession():
+        shutil.rmtree(GrassUtils.grassMapsetFolder(), True)
+        GrassUtils.sessionRunning = False
+        GrassUtils.sessionLayers = {}
+        GrassUtils.projectionSet = False
+
+    @staticmethod
+    def getSessionLayers():
+        return GrassUtils.sessionLayers
+
+    @staticmethod
+    def addSessionLayers(exportedLayers):
+        GrassUtils.sessionLayers = dict(
+            GrassUtils.sessionLayers.items()
+            + exportedLayers.items())
+
+    @staticmethod
+    def checkGrassIsInstalled(ignorePreviousState=False):
+        if isWindows():
+            path = GrassUtils.grassPath()
+            if path == '':
+                return GrassUtils.tr(
+                    'GRASS folder is not configured.\nPlease configure '
+                    'it before running GRASS algorithms.')
+            cmdpath = os.path.join(path, 'bin', 'r.out.gdal.exe')
+            if not os.path.exists(cmdpath):
+                return GrassUtils.tr(
+                    'The specified GRASS folder "{}" does not contain a valid '
+                    'set of GRASS modules. Please, go to the Processing '
+                    'settings dialog, and check that the GRASS folder is '
+                    'correctly configured'.format(os.path.join(path, 'bin')))
+
+        if not ignorePreviousState:
+            if GrassUtils.isGrassInstalled:
+                return
+        try:
+            from processing import runalg
+            result = runalg(
+                'grass:v.voronoi',
+                points(),
+                False,
+                False,
+                '270778.60198,270855.745301,4458921.97814,4458983.8488',
+                -1,
+                0.0001,
+                0,
+                None,
+            )
+            if not os.path.exists(result['output']):
+                return GrassUtils.tr(
+                    'It seems that GRASS is not correctly installed and '
+                    'configured in your system.\nPlease install it before '
+                    'running GRASS algorithms.')
+        except:
+            return GrassUtils.tr(
+                'Error while checking GRASS installation. GRASS might not '
+                'be correctly configured.\n')
+
+        GrassUtils.isGrassInstalled = True
+
+    @staticmethod
+    def tr(string, context=''):
+        if context == '':
+            context = 'GrassUtils'
+        return QCoreApplication.translate(context, string)
+
+    @staticmethod
+    def grassHelpPath():
+        helpPath = ProcessingConfig.getSetting(GrassUtils.GRASS_HELP_PATH)
+
+        if helpPath is None:
+            if isWindows():
+                localPath = os.path.join(GrassUtils.grassPath(), 'docs/html')
+                if os.path.exists(localPath):
+                    helpPath = os.path.abspath(localPath)
+            elif isMac():
+                localPath = '/Applications/GRASS-6.4.app/Contents/MacOS/docs/html'
+                if os.path.exists(localPath):
+                    helpPath = os.path.abspath(localPath)
+            else:
+                searchPaths = ['/usr/share/doc/grass-doc/html',
+                               '/opt/grass/docs/html',
+                               '/usr/share/doc/grass/docs/html']
+                for path in searchPaths:
+                    if os.path.exists(path):
+                        helpPath = os.path.abspath(path)
+                        break
+
+        return helpPath if helpPath is not None else 'http://grass.osgeo.org/grass64/manuals/'
Binary files qgis-2.14.13-orig/python/plugins/processing/algs/grass7/.DS_Store and qgis-2.14.13/python/plugins/processing/algs/grass7/.DS_Store differ
diff -ruN qgis-2.14.13-orig/python/plugins/processing/algs/grass7/Grass7Utils.py qgis-2.14.13/python/plugins/processing/algs/grass7/Grass7Utils.py
--- qgis-2.14.13-orig/python/plugins/processing/algs/grass7/Grass7Utils.py	2017-04-16 16:54:18.000000000 +0900
+++ qgis-2.14.13/python/plugins/processing/algs/grass7/Grass7Utils.py	2017-04-16 16:56:44.000000000 +0900
@@ -81,28 +81,7 @@
 
     @staticmethod
     def grassPath():
-        if not isWindows() and not isMac():
-            return ''
-
-        folder = ProcessingConfig.getSetting(Grass7Utils.GRASS_FOLDER) or ''
-        if not os.path.exists(folder):
-            folder = None
-        if folder is None:
-            if isWindows():
-                if "OSGEO4W_ROOT" in os.environ:
-                    testfolder = os.path.join(unicode(os.environ['OSGEO4W_ROOT']), "apps")
-                else:
-                    testfolder = unicode(QgsApplication.prefixPath())
-                testfolder = os.path.join(testfolder, 'grass')
-                if os.path.isdir(testfolder):
-                    for subfolder in os.listdir(testfolder):
-                        if subfolder.startswith('grass-7'):
-                            folder = os.path.join(testfolder, subfolder)
-                            break
-            else:
-                folder = os.path.join(unicode(QgsApplication.prefixPath()), 'grass7')
-                if not os.path.isdir(folder):
-                    folder = '/Applications/GRASS-7.0.app/Contents/MacOS'
+        folder = '@PREFIX@/Applications/GRASS-7.0.app/Contents/MacOS'
 
         return folder or ''
 
diff -ruN qgis-2.14.13-orig/scripts/pyuic4-wrapper.sh qgis-2.14.13/scripts/pyuic4-wrapper.sh
--- qgis-2.14.13-orig/scripts/pyuic4-wrapper.sh	2017-04-16 16:54:19.000000000 +0900
+++ qgis-2.14.13/scripts/pyuic4-wrapper.sh	2017-04-16 16:55:03.000000000 +0900
@@ -7,4 +7,4 @@
 
 export LD_LIBRARY_PATH PYTHONPATH
 
-exec python $(dirname $0)/pyuic4-wrapper.py $@
+exec @PREFIX@/bin/python2.7 $(dirname $0)/pyuic4-wrapper.py $@
