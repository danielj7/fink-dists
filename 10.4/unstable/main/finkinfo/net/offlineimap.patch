diff --git a/offlineimap/imapserver.py b/offlineimap/imapserver.py
index 7d99e19..441fd0d 100644
--- a/offlineimap/imapserver.py
+++ b/offlineimap/imapserver.py
@@ -23,6 +23,9 @@ from threading import *
 import thread, hmac, os
 import base64
 
+from StringIO import StringIO
+from platform import system
+
 try:
     # do we have a recent pykerberos?
     have_gss = False
@@ -60,10 +63,42 @@ class UsefulIMAP4(UsefulIMAPMixIn, imaplib.IMAP4):
     def open(self, host = '', port = imaplib.IMAP4_PORT):
         imaplibutil.new_open(self, host, port)
 
+    # This is a hack around Darwin's implementation of realloc() (which
+    # Python uses inside the socket code). On Darwin, we split the
+    # message into 100k chunks, which should be small enough - smaller
+    # might start seriously hurting performance ...
+
+    def read(self, size):
+        if (system() == 'Darwin') and (size>0) :
+            read = 0
+            io = StringIO()
+            while read < size:
+                data = imaplib.IMAP4.read (self, min(size-read,8192))
+                read += len(data)
+                io.write(data)
+            return io.getvalue()
+        else:
+            return imaplib.IMAP4.read (self, size)
+
 class UsefulIMAP4_SSL(UsefulIMAPMixIn, imaplibutil.WrappedIMAP4_SSL):
     def open(self, host = '', port = imaplib.IMAP4_SSL_PORT):
         imaplibutil.new_open_ssl(self, host, port)
 
+    # This is the same hack as above, to be used in the case of an SSL
+    # connexion.
+
+    def read(self, size):
+        if (system() == 'Darwin') and (size>0) :
+            read = 0
+            io = StringIO()
+            while read < size:
+                data = imaplibutil.WrappedIMAP4_SSL.read (self, min(size-read,8192))
+                read += len(data)
+                io.write(data)
+            return io.getvalue()
+        else:
+            return imaplibutil.WrappedIMAP4_SSL.read (self,size)
+
 class UsefulIMAP4_Tunnel(UsefulIMAPMixIn, imaplibutil.IMAP4_Tunnel): pass
 
 class IMAPServer:
