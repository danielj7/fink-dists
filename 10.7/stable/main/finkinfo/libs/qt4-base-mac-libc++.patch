diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/src/3rdparty/clucene/src/CLucene/StdHeader.h qt-everywhere-opensource-src-4.8.5/src/3rdparty/clucene/src/CLucene/StdHeader.h
--- qt-everywhere-opensource-src-4.8.5-orig/src/3rdparty/clucene/src/CLucene/StdHeader.h	2013-06-07 01:16:58.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/src/3rdparty/clucene/src/CLucene/StdHeader.h	2013-08-10 16:38:10.000000000 -0400
@@ -458,18 +458,26 @@
 #include "CLucene/config/compiler.h"
 
 #if defined _MSC_VER && (_MSC_VER < 1300)
 # define LUCENE_NO_STDC_NAMESPACE
 #endif
 
 //use std namespace
 #ifndef LUCENE_NO_STDC_NAMESPACE
+#ifdef _LIBCPP_VERSION
+// clang's libc++ pulls in cwchar, clucene pulls in wchar.h and the entire std
+// namespace which causes ambiguity between ::wcschar() and std::wcschar(), but
+// clucene is only using std::min() and std::max()
+using std::min;
+using std::max;
+#else
 using namespace std;
 #endif
+#endif
 
 
 ////////////////////////////////////////////////////////
 //misc shortcut defines
 ////////////////////////////////////////////////////////
 
 //include the headers that we need practically everywhere
 #include "CLucene/debug/error.h" //all delete/creation/mem debugging code
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.cpp qt-everywhere-opensource-src-4.8.5/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.cpp
--- qt-everywhere-opensource-src-4.8.5-orig/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.cpp	2013-06-07 01:16:58.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.cpp	2013-08-10 16:38:10.000000000 -0400
@@ -47,16 +47,18 @@
 
 #if OS(DARWIN)
 
 #include <mach/mach_init.h>
 #include <mach/mach_port.h>
 #include <mach/task.h>
 #include <mach/thread_act.h>
 #include <mach/vm_map.h>
+// clang's libc++ headers does not pull in pthread.h (but libstdc++ does)
+#include <pthread.h>
 
 #elif OS(WINDOWS)
 
 #include <windows.h>
 #include <malloc.h>
 
 #elif OS(HAIKU)
 
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/src/3rdparty/javascriptcore/JavaScriptCore/wtf/HashTable.h qt-everywhere-opensource-src-4.8.5/src/3rdparty/javascriptcore/JavaScriptCore/wtf/HashTable.h
--- qt-everywhere-opensource-src-4.8.5-orig/src/3rdparty/javascriptcore/JavaScriptCore/wtf/HashTable.h	2013-06-07 01:16:58.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/src/3rdparty/javascriptcore/JavaScriptCore/wtf/HashTable.h	2013-08-10 16:38:10.000000000 -0400
@@ -252,18 +252,18 @@
         operator const_iterator() const { return m_iterator; }
 
     private:
         const_iterator m_iterator;
     };
 
     using std::swap;
 
-#if !COMPILER(MSVC) && !OS(QNX)
-    // The Dinkumware C++ library (used by MSVC and QNX) has a swap for pairs defined.
+#if !COMPILER(MSVC) && !OS(QNX) && !defined(_LIBCPP_VERSION)
+    // The Dinkumware C++ library (used by MSVC and QNX) and clang's libc++ have a swap for pairs defined.
 
     // swap pairs by component, in case of pair members that specialize swap
     template<typename T, typename U> inline void swap(pair<T, U>& a, pair<T, U>& b)
     {
         swap(a.first, b.first);
         swap(a.second, b.second);
     }
 #endif
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/src/3rdparty/webkit/Source/JavaScriptCore/wtf/NullPtr.h qt-everywhere-opensource-src-4.8.5/src/3rdparty/webkit/Source/JavaScriptCore/wtf/NullPtr.h
--- qt-everywhere-opensource-src-4.8.5-orig/src/3rdparty/webkit/Source/JavaScriptCore/wtf/NullPtr.h	2013-06-07 01:16:54.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/src/3rdparty/webkit/Source/JavaScriptCore/wtf/NullPtr.h	2014-01-30 12:37:46.000000000 -0500
@@ -30,20 +30,22 @@
 // For compilers and standard libraries that do not yet include it, this adds the
 // nullptr_t type and nullptr object. They are defined in the same namespaces they
 // would be in compiler and library that had the support.
 
 #ifndef __has_feature
     #define __has_feature(feature) 0
 #endif
 
-#if __has_feature(cxx_nullptr) || (GCC_VERSION_AT_LEAST(4, 6, 0) && defined(__GXX_EXPERIMENTAL_CXX0X__)) || (defined(_MSC_VER) && _MSC_VER >= 1600 && !COMPILER(INTEL))
+#if __has_feature(cxx_nullptr) || (GCC_VERSION_AT_LEAST(4, 6, 0) && defined(__GXX_EXPERIMENTAL_CXX0X__)) || (defined(_MSC_VER) && _MSC_VER >= 1600 && !COMPILER(INTEL)) || defined(_LIBCPP_VERSION)
 
 #define HAVE_NULLPTR 1
 
+#include <cstddef>
+
 #else
 
 namespace std {
     class nullptr_t { };
 }
 
 extern std::nullptr_t nullptr;
 
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/Timer.cpp b/src/3rdparty/webkit/Source/WebCore/platform/Timer.cpp
index 3f4e334..acb1220 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/Timer.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/platform/Timer.cpp
@@ -41,6 +41,8 @@ using namespace std;
 
 namespace WebCore {
 
+class TimerHeapReference;
+
 // Timers are stored in a heap data structure, used to implement a priority queue.
 // This allows us to efficiently determine which timer needs to fire the soonest.
 // Then we set a single shared system timer to fire at that time.
@@ -53,110 +55,138 @@ static Vector<TimerBase*>& timerHeap()
     return threadGlobalData().threadTimers().timerHeap();
 }
 
-// Class to represent elements in the heap when calling the standard library heap algorithms.
-// Maintains the m_heapIndex value in the timers themselves, which allows us to do efficient
-// modification of the heap.
-class TimerHeapElement {
-public:
-    explicit TimerHeapElement(int i)
-        : m_index(i)
-        , m_timer(timerHeap()[m_index])
-    { 
-        checkConsistency(); 
-    }
-
-    TimerHeapElement(const TimerHeapElement&);
-    TimerHeapElement& operator=(const TimerHeapElement&);
-
-    TimerBase* timer() const { return m_timer; }
-
-    void checkConsistency() const
-    {
-        ASSERT(m_index >= 0);
-        ASSERT(m_index < static_cast<int>(timerHeap().size()));
-    }
+// ----------------
 
+class TimerHeapPointer {
+public:
+    TimerHeapPointer(TimerBase** pointer) : m_pointer(pointer) { }
+    TimerHeapReference operator*() const;
+    TimerBase* operator->() const { return *m_pointer; }
 private:
-    TimerHeapElement();
+    TimerBase** m_pointer;
+};
 
-    int m_index;
-    TimerBase* m_timer;
+class TimerHeapReference {
+public:
+    TimerHeapReference(TimerBase*& reference) : m_reference(reference) { }
+    operator TimerBase*() const { return m_reference; }
+    TimerHeapPointer operator&() const { return &m_reference; }
+    TimerHeapReference& operator=(TimerBase*);
+    TimerHeapReference& operator=(TimerHeapReference);
+private:
+    TimerBase*& m_reference;
 };
 
-inline TimerHeapElement::TimerHeapElement(const TimerHeapElement& o)
-    : m_index(-1), m_timer(o.timer())
+inline TimerHeapReference TimerHeapPointer::operator*() const
 {
+    return *m_pointer;
 }
 
-inline TimerHeapElement& TimerHeapElement::operator=(const TimerHeapElement& o)
+inline TimerHeapReference& TimerHeapReference::operator=(TimerBase* timer)
 {
-    TimerBase* t = o.timer();
-    m_timer = t;
-    if (m_index != -1) {
-        checkConsistency();
-        timerHeap()[m_index] = t;
-        t->m_heapIndex = m_index;
-    }
+    m_reference = timer;
+    Vector<TimerBase*>& heap = timerHeap();
+    if (&m_reference >= heap.data() && &m_reference < heap.data() + heap.size())
+        timer->m_heapIndex = &m_reference - heap.data();
     return *this;
 }
 
-inline bool operator<(const TimerHeapElement& a, const TimerHeapElement& b)
+inline TimerHeapReference& TimerHeapReference::operator=(TimerHeapReference b)
 {
-    // The comparisons below are "backwards" because the heap puts the largest 
-    // element first and we want the lowest time to be the first one in the heap.
-    double aFireTime = a.timer()->m_nextFireTime;
-    double bFireTime = b.timer()->m_nextFireTime;
-    if (bFireTime != aFireTime)
-        return bFireTime < aFireTime;
-    
-    // We need to look at the difference of the insertion orders instead of comparing the two 
-    // outright in case of overflow. 
-    unsigned difference = a.timer()->m_heapInsertionOrder - b.timer()->m_heapInsertionOrder;
-    return difference < UINT_MAX / 2;
+    TimerBase* timer = b;
+    return *this = timer;
+}
+
+inline void swap(TimerHeapReference a, TimerHeapReference b)
+{
+    TimerBase* timerA = a;
+    TimerBase* timerB = b;
+
+    // Invoke the assignment operator, since that takes care of updating m_heapIndex.
+    a = timerB;
+    b = timerA;
 }
 
 // ----------------
 
 // Class to represent iterators in the heap when calling the standard library heap algorithms.
-// Returns TimerHeapElement for elements in the heap rather than the TimerBase pointers themselves.
-class TimerHeapIterator : public iterator<random_access_iterator_tag, TimerHeapElement, int> {
+// Uses a custom pointer and reference type that update indices for pointers in the heap.
+class TimerHeapIterator : public iterator<random_access_iterator_tag, TimerBase*, ptrdiff_t, TimerHeapPointer, TimerHeapReference> {
 public:
-    TimerHeapIterator() : m_index(-1) { }
-    TimerHeapIterator(int i) : m_index(i) { checkConsistency(); }
-
-    TimerHeapIterator& operator++() { checkConsistency(); ++m_index; checkConsistency(); return *this; }
-    TimerHeapIterator operator++(int) { checkConsistency(); checkConsistency(1); return m_index++; }
+    explicit TimerHeapIterator(TimerBase** pointer) : m_pointer(pointer) { checkConsistency(); }
 
-    TimerHeapIterator& operator--() { checkConsistency(); --m_index; checkConsistency(); return *this; }
-    TimerHeapIterator operator--(int) { checkConsistency(); checkConsistency(-1); return m_index--; }
+    TimerHeapIterator& operator++() { checkConsistency(); ++m_pointer; checkConsistency(); return *this; }
+    TimerHeapIterator operator++(int) { checkConsistency(1); return TimerHeapIterator(m_pointer++); }
 
-    TimerHeapIterator& operator+=(int i) { checkConsistency(); m_index += i; checkConsistency(); return *this; }
-    TimerHeapIterator& operator-=(int i) { checkConsistency(); m_index -= i; checkConsistency(); return *this; }
+    TimerHeapIterator& operator--() { checkConsistency(); --m_pointer; checkConsistency(); return *this; }
+    TimerHeapIterator operator--(int) { checkConsistency(-1); return TimerHeapIterator(m_pointer--); }
 
-    TimerHeapElement operator*() const { return TimerHeapElement(m_index); }
-    TimerHeapElement operator[](int i) const { return TimerHeapElement(m_index + i); }
+    TimerHeapIterator& operator+=(ptrdiff_t i) { checkConsistency(); m_pointer += i; checkConsistency(); return *this; }
+    TimerHeapIterator& operator-=(ptrdiff_t i) { checkConsistency(); m_pointer -= i; checkConsistency(); return *this; }
 
-    int index() const { return m_index; }
+    TimerHeapReference operator*() const { return TimerHeapReference(*m_pointer); }
+    TimerHeapReference operator[](ptrdiff_t i) const { return TimerHeapReference(m_pointer[i]); }
+    TimerBase* operator->() const { return *m_pointer; }
 
-    void checkConsistency(int offset = 0) const
+private:
+    void checkConsistency(ptrdiff_t offset = 0) const
     {
-        ASSERT_UNUSED(offset, m_index + offset >= 0);
-        ASSERT_UNUSED(offset, m_index + offset <= static_cast<int>(timerHeap().size()));
+        ASSERT(m_pointer >= timerHeap().data());
+        ASSERT(m_pointer <= timerHeap().data() + timerHeap().size());
+        ASSERT_UNUSED(offset, m_pointer + offset >= timerHeap().data());
+        ASSERT_UNUSED(offset, m_pointer + offset <= timerHeap().data() + timerHeap().size());
     }
 
-private:
-    int m_index;
+    friend bool operator==(TimerHeapIterator, TimerHeapIterator);
+    friend bool operator!=(TimerHeapIterator, TimerHeapIterator);
+    friend bool operator<(TimerHeapIterator, TimerHeapIterator);
+    friend bool operator>(TimerHeapIterator, TimerHeapIterator);
+    friend bool operator<=(TimerHeapIterator, TimerHeapIterator);
+    friend bool operator>=(TimerHeapIterator, TimerHeapIterator);
+
+    friend TimerHeapIterator operator+(TimerHeapIterator, size_t);
+    friend TimerHeapIterator operator+(size_t, TimerHeapIterator);
+
+    friend TimerHeapIterator operator-(TimerHeapIterator, size_t);
+    friend ptrdiff_t operator-(TimerHeapIterator, TimerHeapIterator);
+
+    TimerBase** m_pointer;
 };
 
-inline bool operator==(TimerHeapIterator a, TimerHeapIterator b) { return a.index() == b.index(); }
-inline bool operator!=(TimerHeapIterator a, TimerHeapIterator b) { return a.index() != b.index(); }
-inline bool operator<(TimerHeapIterator a, TimerHeapIterator b) { return a.index() < b.index(); }
+inline bool operator==(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer == b.m_pointer; }
+inline bool operator!=(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer != b.m_pointer; }
+inline bool operator<(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer < b.m_pointer; }
+inline bool operator>(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer > b.m_pointer; }
+inline bool operator<=(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer <= b.m_pointer; }
+inline bool operator>=(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer >= b.m_pointer; }
 
-inline TimerHeapIterator operator+(TimerHeapIterator a, int b) { return a.index() + b; }
-inline TimerHeapIterator operator+(int a, TimerHeapIterator b) { return a + b.index(); }
+inline TimerHeapIterator operator+(TimerHeapIterator a, size_t b) { return TimerHeapIterator(a.m_pointer + b); }
+inline TimerHeapIterator operator+(size_t a, TimerHeapIterator b) { return TimerHeapIterator(a + b.m_pointer); }
 
-inline TimerHeapIterator operator-(TimerHeapIterator a, int b) { return a.index() - b; }
-inline int operator-(TimerHeapIterator a, TimerHeapIterator b) { return a.index() - b.index(); }
+inline TimerHeapIterator operator-(TimerHeapIterator a, size_t b) { return TimerHeapIterator(a.m_pointer - b); }
+inline ptrdiff_t operator-(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer - b.m_pointer; }
+
+// ----------------
+
+class TimerHeapLessThanFunction {
+public:
+    bool operator()(TimerBase*, TimerBase*) const;
+};
+
+inline bool TimerHeapLessThanFunction::operator()(TimerBase* a, TimerBase* b) const
+{
+    // The comparisons below are "backwards" because the heap puts the largest 
+    // element first and we want the lowest time to be the first one in the heap.
+    double aFireTime = a->m_nextFireTime;
+    double bFireTime = b->m_nextFireTime;
+    if (bFireTime != aFireTime)
+        return bFireTime < aFireTime;
+
+    // We need to look at the difference of the insertion orders instead of comparing the two 
+    // outright in case of overflow. 
+    unsigned difference = a->m_heapInsertionOrder - b->m_heapInsertionOrder;
+    return difference < numeric_limits<unsigned>::max() / 2;
+}
 
 // ----------------
 
@@ -225,7 +255,8 @@ void TimerBase::heapDecreaseKey()
 {
     ASSERT(m_nextFireTime != 0);
     checkHeapIndex();
-    push_heap(TimerHeapIterator(0), TimerHeapIterator(m_heapIndex + 1));
+    TimerBase** heapData = timerHeap().data();
+    push_heap(TimerHeapIterator(heapData), TimerHeapIterator(heapData + m_heapIndex + 1), TimerHeapLessThanFunction());
     checkHeapIndex();
 }
 
@@ -274,7 +305,9 @@ void TimerBase::heapPopMin()
 {
     ASSERT(this == timerHeap().first());
     checkHeapIndex();
-    pop_heap(TimerHeapIterator(0), TimerHeapIterator(timerHeap().size()));
+    Vector<TimerBase*>& heap = timerHeap();
+    TimerBase** heapData = heap.data();
+    pop_heap(TimerHeapIterator(heapData), TimerHeapIterator(heapData + heap.size()), TimerHeapLessThanFunction());
     checkHeapIndex();
     ASSERT(this == timerHeap().last());
 }
@@ -317,4 +350,3 @@ void TimerBase::fireTimersInNestedEventLoop()
 }
 
 } // namespace WebCore
-
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/Timer.h b/src/3rdparty/webkit/Source/WebCore/platform/Timer.h
index 3138345..6ecd995 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/Timer.h
+++ b/src/3rdparty/webkit/Source/WebCore/platform/Timer.h
@@ -84,9 +84,9 @@ private:
     ThreadIdentifier m_thread;
 #endif
 
-    friend class TimerHeapElement;
     friend class ThreadTimers;
-    friend bool operator<(const TimerHeapElement&, const TimerHeapElement&);
+    friend class TimerHeapLessThanFunction;
+    friend class TimerHeapReference;
 };
 
 template <typename TimerFiredClass> class Timer : public TimerBase {
@@ -111,4 +111,4 @@ inline bool TimerBase::isActive() const
 
 }
 
-#endif
+#endif
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/network/qt/QNetworkReplyHandler.cpp b/src/3rdparty/webkit/Source/WebCore/platform/network/qt/QNetworkReplyHandler.cpp
index f40da4d..a630432 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/network/qt/QNetworkReplyHandler.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/platform/network/qt/QNetworkReplyHandler.cpp
@@ -235,7 +235,7 @@ QNetworkReply* QNetworkReplyWrapper::release()
     resetConnections();
     QNetworkReply* reply = m_reply;
     m_reply = 0;
-    m_sniffer = 0;
+    m_sniffer = nullptr;
 
     reply->setParent(0);
     return reply;
@@ -300,7 +300,7 @@ void QNetworkReplyWrapper::receiveSniffedMIMEType()
     Q_ASSERT(m_sniffer);
 
     m_sniffedMIMEType = m_sniffer->mimeType();
-    m_sniffer = 0;
+    m_sniffer = nullptr;
 
     emitMetaDataChanged();
 }
@@ -417,7 +417,7 @@ QNetworkReply* QNetworkReplyHandler::release()
         return 0;
 
     QNetworkReply* reply = m_replyWrapper->release();
-    m_replyWrapper = 0;
+    m_replyWrapper = nullptr;
     return reply;
 }
 
@@ -440,12 +440,12 @@ void QNetworkReplyHandler::finish()
 
     ResourceHandleClient* client = m_resourceHandle->client();
     if (!client) {
-        m_replyWrapper = 0;
+        m_replyWrapper = nullptr;
         return;
     }
 
     if (m_replyWrapper->wasRedirected()) {
-        m_replyWrapper = 0;
+        m_replyWrapper = nullptr;
         m_queue.push(&QNetworkReplyHandler::start);
         return;
     }
@@ -465,7 +465,7 @@ void QNetworkReplyHandler::finish()
         }
     }
 
-    m_replyWrapper = 0;
+    m_replyWrapper = nullptr;
 }
 
 void QNetworkReplyHandler::sendResponseIfNeeded()
@@ -539,7 +539,7 @@ void QNetworkReplyHandler::redirect(ResourceResponse& response, const QUrl& redi
                             newUrl.toString(),
                             QCoreApplication::translate("QWebPage", "Redirection limit reached"));
         client->didFail(m_resourceHandle, error);
-        m_replyWrapper = 0;
+        m_replyWrapper = nullptr;
         return;
     }
 
diff --git a/src/3rdparty/webkit/Source/WebKit/qt/Api/qgraphicswebview.cpp b/src/3rdparty/webkit/Source/WebKit/qt/Api/qgraphicswebview.cpp
index b7b28bc..c4dd6d0 100644
--- a/src/3rdparty/webkit/Source/WebKit/qt/Api/qgraphicswebview.cpp
+++ b/src/3rdparty/webkit/Source/WebKit/qt/Api/qgraphicswebview.cpp
@@ -471,7 +471,7 @@ void QGraphicsWebViewPrivate::detachCurrentPage()
         return;
 
     page->d->view.clear();
-    page->d->client = 0;
+    page->d->client = nullptr;
 
     // if the page was created by us, we own it and need to
     // destroy it as well.
diff --git a/src/3rdparty/webkit/Source/WebKit/qt/WebCoreSupport/NotificationPresenterClientQt.cpp b/src/3rdparty/webkit/Source/WebKit/qt/WebCoreSupport/NotificationPresenterClientQt.cpp
index b2b8132..7ff9278 100644
--- a/src/3rdparty/webkit/Source/WebKit/qt/WebCoreSupport/NotificationPresenterClientQt.cpp
+++ b/src/3rdparty/webkit/Source/WebKit/qt/WebCoreSupport/NotificationPresenterClientQt.cpp
@@ -73,9 +73,9 @@ NotificationWrapper::NotificationWrapper()
 #if ENABLE(NOTIFICATIONS)
 
 #ifndef QT_NO_SYSTEMTRAYICON
-    m_notificationIcon = 0;
+    m_notificationIcon = nullptr;
 #endif
-    m_presenter = 0;
+    m_presenter = nullptr;
 #endif
 }
