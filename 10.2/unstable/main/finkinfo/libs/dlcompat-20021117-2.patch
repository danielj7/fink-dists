--- dlcompat-20021117/dlfcn.c	Mon Nov 11 21:47:23 2002
+++ /Users/peter/od/proj/dlcompat/dlfcn.c	Mon May 12 13:31:16 2003
@@ -29,7 +29,7 @@
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
 
-
+#include <pthread.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -39,6 +39,7 @@
 #include <limits.h>
 #include <mach-o/dyld.h>
 #include <mach-o/nlist.h>
+#include <mach-o/getsect.h>
 #include "dlfcn.h"
 
 /* This is not available on 10.1 */
@@ -70,7 +71,6 @@
 static NSSymbol(*dyld_NSLookupSymbolInImage)
 	(const struct mach_header *, const char *, unsigned long) = 0;
 
-
 /* Define this to make dlcompat reuse data block. This way in theory we save
  * a little bit of overhead. However we then couldn't correctly catch excess
  * calls to dlclose(). Hence we don't use this feature
@@ -78,10 +78,10 @@
 #undef REUSE_STATUS
 
 /* Size of the internal error message buffer (used by dlerror()) */
-#define ERR_STR_LEN			256
+#define ERR_STR_LEN			255
 
 /* Maximum number of search paths supported by getSearchPath */
-#define MAX_SEARCH_PATHS	32
+#define MAX_SEARCH_PATHS	128
 
 
 #define MAGIC_DYLIB_OFI ((NSObjectFileImage) 'DYOF')
@@ -90,6 +90,11 @@
 /* internal flags */
 #define DL_IN_LIST 0x01
 
+/* our mutex */
+static pthread_mutex_t dlcompat_mutex;
+/* Our dlerror thread specific storage */
+static pthread_key_t dlerror_key;
+
 /* This is our central data structure. Whenever a module is loaded via
  * dlopen(), we create such a struct.
  */
@@ -111,9 +116,10 @@
 
 
 /* Storage for the last error message (used by dlerror()) */
-static char err_str[ERR_STR_LEN];
-static int err_filled = 0;
+/* static char err_str[ERR_STR_LEN]; */
+/* static int err_filled = 0; */
 
+static int bind_at_load = 0;
 
 /* Prototypes to internal functions */
 static void debug(const char *fmt, ...);
@@ -135,10 +141,22 @@
 static NSSymbol *search_linked_libs(const struct mach_header *mh, const char *symbol);
 static char *get_lib_name(const struct mach_header *mh);
 static const struct mach_header *get_mach_header_from_NSModule(NSModule * mod);
+static void dlcompat_init_func(void);
+static void dolock(void);
+static void dounlock(void);
+static void dlerrorfree(void* data);
+static void resetdlerror(void);
+
+#if FINK_BUILD
 /* Two Global Functions */
 void *dlsym_prepend_underscore(void *handle, const char *symbol);
 void *dlsym_auto_underscore(void *handle, const char *symbol);
 
+/* And their _intern counterparts */
+static void *dlsym_prepend_underscore_intern(void *handle, const char *symbol);
+static void *dlsym_auto_underscore_intern(void *handle, const char *symbol);
+#endif
+
 /* Functions */
 
 static void debug(const char *fmt, ...)
@@ -157,12 +175,19 @@
 static void error(const char *str, ...)
 {
 	va_list arg;
+	char* err_str;
 	va_start(arg, str);
-	strncpy(err_str, "dlcompat: ", ERR_STR_LEN);
-	vsnprintf(err_str + 10, ERR_STR_LEN - 10, str, arg);
+	err_str = pthread_getspecific(dlerror_key);
+	if (!err_str)
+	{
+		err_str = malloc(ERR_STR_LEN +1);
+		pthread_setspecific(dlerror_key,err_str);
+	}
+	strncpy(err_str +1, "dlcompat: ", ERR_STR_LEN);
+	vsnprintf(err_str + 11, ERR_STR_LEN - 10, str, arg);
 	va_end(arg);
-	debug("ERROR: %s\n", err_str);
-	err_filled = 1;
+	debug("ERROR: %s\n", err_str +1);
+	err_str[0] = 1;
 }
 
 static void warning(const char *str)
@@ -241,7 +266,7 @@
 	char *stdpath = getenv("DYLD_FALLBACK_LIBRARY_PATH");
 	if (!stdpath)
 		stdpath = "/usr/local/lib:/lib:/usr/lib";
-	buf_size = strlen(ldlp) + strlen(dyldlp) + strlen(stdpath) + 1;
+	buf_size = strlen(ldlp) + strlen(dyldlp) + strlen(stdpath) + 3;
 	buf = malloc(buf_size);
 	snprintf(buf, buf_size, "%s%s%s%s%s", dyldlp, (dyldlp[0] ? ":" : ""), ldlp, (ldlp[0] ? ":" : ""),
 			 stdpath);
@@ -254,11 +279,13 @@
 	static const char *list = 0;
 	static const char *path[MAX_SEARCH_PATHS] = { 0 };
 	static int end = 0;
+	if (i >= MAX_SEARCH_PATHS) return 0;
 	if (!list && !end)
 		list = searchList();
 	while (!path[i] && !end)
 	{
 		path[i] = strsep((char **)&list, ":");
+		
 		if (path[i][0] == 0)
 			path[i] = 0;
 		end = list == 0;
@@ -270,8 +297,9 @@
 {
 	static char buf[PATH_MAX];
 	const char *path = getSearchPath(i);
-	if (path)
+	if (path) {
 		snprintf(buf, PATH_MAX, "%s/%s", path, file);
+	}	
 	return path ? buf : 0;
 }
 
@@ -283,14 +311,20 @@
 {
 	int i = 0;
 	static struct stat sbuf;
+	char * fileName; 
 	debug("finding file %s", file);
 	*fullPath = file;
-	do
+	if (0 == stat(file, &sbuf))
+		return &sbuf;
+	if (strchr(file,'/')) return 0; /* If the path had a / we don't look in env var places */	
+	fileName = NULL;
+	if (!fileName) fileName = (char*)file;	
+	while ((*fullPath = getFullPath(i++, fileName)))
 	{
 		if (0 == stat(*fullPath, &sbuf))
-			return &sbuf;
+			return &sbuf;	
 	}
-	while ((*fullPath = getFullPath(i++, file)));
+	;
 	return 0;
 }
 
@@ -426,6 +460,10 @@
 				}
 			}
 		}
+		if ((!nssym) && NSIsSymbolNameDefined(symbol))
+		{
+			debug("Symbol \"%s\" is defined but was not found",symbol);
+		}	
 	}
 	return nssym;
 }
@@ -589,6 +627,15 @@
 			/* Although it is possible with a bit of work to modify this so it works and
 			   functions with RTLD_NOW, I don't deem it necessary at the moment */
 		}
+		if (!(dls->module))
+		{
+			error("Can't open this file type");
+			if ((dls->flags & DL_IN_LIST) == 0)
+			{
+				free(dls);
+			}
+			return NULL;
+		}
 	}
 	else
 	{
@@ -601,26 +648,31 @@
 	if (!dls->module)
 	{
 		NSLinkEditError(&ler, &lerno, &file, &errstr);
-		free(dls);
+		if ((dls->flags & DL_IN_LIST) == 0)
+		{
+			free(dls);
+		}
 		error(errstr);
 		return NULL;
 	}
+
 	insertStatus(dls, sbuf);
+
 	if ((init = dlsymIntern(dls, "__init", 0)))
 	{
 		debug("calling _init()");
-		init();
+		dounlock(); /* allow the lib init func to call dl* functions */
+		init();		/* does this actually work? */
+		dolock();	/* Or will something break? */
 	}
 
 	return dls;
 }
 
-void *dlopen(const char *path, int mode)
+static void dlcompat_init_func(void)
 {
-	const struct stat *sbuf;
-	struct dlstatus *dls;
-	const char *fullPath;
 	static int inited = 0;
+	const struct mach_header *mh = 0;
 	if (!inited)
 	{
 		inited = 1;
@@ -628,40 +680,144 @@
 		_dyld_func_lookup("__dyld_NSIsSymbolNameDefinedInImage",
 						  (unsigned long *)&dyld_NSIsSymbolNameDefinedInImage);
 		_dyld_func_lookup("__dyld_NSLookupSymbolInImage", (unsigned long *)&dyld_NSLookupSymbolInImage);
+		mh = _dyld_get_image_header(0);
+		if (((mh->flags) & MH_BINDATLOAD) || getenv("DYLD_BIND_AT_LAUNCH"))
+		{
+			bind_at_load = 1;
+		}
+		if (pthread_mutex_init(&dlcompat_mutex,NULL)) exit(1);
+		if (pthread_key_create(&dlerror_key,&dlerrorfree)) exit(1);
+
 	}
+}
+#pragma CALL_ON_LOAD dlcompat_init_func
+
+
+static void resetdlerror()
+{
+	char* err_str;
+	err_str = pthread_getspecific(dlerror_key);
+	if (err_str) err_str[0]=0;
+}
+
+static void dlerrorfree(void* data)
+{
+	free(data);
+}
+
+static void dolock(void)
+{
+	int err;
+	err = pthread_mutex_lock(&dlcompat_mutex);
+	if (err)	exit(err);
+}
+
+static void dounlock(void)
+{
+	int err;
+	err = pthread_mutex_unlock(&dlcompat_mutex);
+	if (err)	exit(err);
+}
+
+void *dlopen(const char *path, int mode)
+{
+	const struct stat *sbuf;
+	struct dlstatus *dls;
+	const char *fullPath;
+	dlcompat_init_func(); /* Just in case */
+	dolock();
+	resetdlerror();
 	if (!path)
 	{
-		return &mainStatus;
+		dls = &mainStatus;
+		goto dlopenok;
 	}
 	if (!(sbuf = findFile(path, &fullPath)))
 	{
 		error("file \"%s\" not found", path);
-		return NULL;
+		goto dlopenerror;
 	}
 	/* Now checks that it hasn't been closed already */
 	if ((dls = lookupStatus(sbuf)) && (dls->refs > 0))
 	{
 		/* debug("status found"); */
-		return reference(dls, mode);
+		dls = reference(dls, mode);
+		goto dlopenok;
 	}
 	if (isFlagSet(mode, RTLD_NOLOAD))
 	{
 		error("no existing handle and RTLD_NOLOAD specified");
-		return NULL;
+		goto dlopenerror;
 	}
 	if (isFlagSet(mode, RTLD_LAZY) && isFlagSet(mode, RTLD_NOW))
 	{
 		error("how can I load something both RTLD_LAZY and RTLD_NOW?");
-		return NULL;
+		goto dlopenerror;
 	}
-	return reference(loadModule(fullPath, sbuf, mode), mode);
+	dls = loadModule(fullPath, sbuf, mode);
+	dls = reference(dls,mode);
+dlopenok:	
+	dounlock();
+	return dls;
+dlopenerror:
+	dounlock();
+	return NULL;
 }
 
-#if FINK_BUILD
-void *dlsym_prepend_underscore(void *handle, const char *symbol)
-#else
+#if !FINK_BUILD
 void *dlsym(void *handle, const char *symbol)
+{
+	static char undersym[257];
+	int sym_len = strlen(symbol);
+	void *value = NULL;
+	char *malloc_sym = NULL;
+	struct dlstatus *dls = handle;
+	dolock();
+	resetdlerror();
+	if (!isValidStatus(dls))
+		goto dlsymerror;
+
+	if (sym_len < 256)
+	{
+		snprintf(undersym, 256, "_%s", symbol);
+		value = dlsymIntern(handle, undersym, 1);
+	}
+	else
+	{
+		malloc_sym = malloc(sym_len + 2);
+		if (malloc_sym)
+		{
+			sprintf(malloc_sym, "_%s", symbol);
+			value = dlsymIntern(handle, malloc_sym, 1);
+			free(malloc_sym);
+		}
+		else
+		{
+			error("Unable to allocate memory");
+			goto dlsymerror;
+		}
+	}
+	dounlock();
+	return value;
+dlsymerror:
+	dounlock();
+	return NULL;		
+}
 #endif
+
+#if FINK_BUILD
+
+void *dlsym_prepend_underscore(void *handle, const char *symbol)
+{
+	void* answer;
+	dolock();
+	resetdlerror();
+	answer = dlsym_prepend_underscore_intern(handle,symbol);
+	dounlock();
+	return answer;
+}
+
+static void *dlsym_prepend_underscore_intern(void *handle, const char *symbol)
 {
 /*
  	A quick and easy way for porting packages which call dlsym(handle,"sym")
@@ -677,7 +833,6 @@
 	void *value = NULL;
 	char *malloc_sym = NULL;
 	struct dlstatus *dls = handle;
-
 	if (!isValidStatus(dls))
 		return NULL;
 
@@ -703,16 +858,25 @@
 	return value;
 }
 
-#if FINK_BUILD
 void *dlsym_auto_underscore(void *handle, const char *symbol)
 {
+	void* answer;
+	dolock();
+	resetdlerror();
+	answer = dlsym_auto_underscore_intern(handle,symbol);
+	dounlock();
+	return answer;
+
+}
+static void *dlsym_auto_underscore_intern(void *handle, const char *symbol)
+{
 	struct dlstatus *dls = handle;
 	void *addr = 0;
 	if (!isValidStatus(dls))
 		return NULL;
 	addr = dlsymIntern(dls, symbol, 0);
 	if (!addr)
-		addr = dlsym_prepend_underscore(handle, symbol);
+		addr = dlsym_prepend_underscore_intern(handle, symbol);
 	return addr;
 }
 
@@ -721,10 +885,15 @@
 {
 	struct dlstatus *dls = handle;
 	void *addr = 0;
-
+	dolock();
+	resetdlerror();
 	if (!isValidStatus(dls))
+	{
+		dounlock();
 		return NULL;
+	}
 	addr = dlsymIntern(dls, symbol, 1);
+	dounlock();
 	return addr;
 }
 #endif
@@ -732,18 +901,31 @@
 int dlclose(void *handle)
 {
 	struct dlstatus *dls = handle;
+	dolock();
+	resetdlerror();
 	if (!isValidStatus(dls))
-		return 1;
+	{
+		goto dlcloseerror;
+	}
 	if (dls->module == MAGIC_DYLIB_MOD)
 	{
-		warning("trying to close a .dylib!");
-		error("dynamic libraries cannot be closed");
-		return 1;
+		const char *name;
+		if (!dls->lib)
+		{
+			name = "global context";
+		}
+		else
+		{
+			name = get_lib_name(dls->lib);
+		}				
+ 		warning("trying to close a .dylib!");
+		error("Not closing \"%s\" - dynamic libraries cannot be closed", name);
+		goto dlcloseerror;
 	}
 	if (!dls->module)
 	{
 		error("module already closed");
-		return 1;
+		goto dlcloseerror;
 	}
 	dls->refs--;
 	if (!dls->refs)
@@ -760,7 +942,7 @@
 		if (!NSUnLinkModule(dls->module, options))
 		{
 			error("unable to unlink module");
-			return 1;
+			goto dlcloseerror;
 		}
 		dls->module = 0;
 		/* Note: the dlstatus struct dls is neither removed from the list
@@ -768,16 +950,23 @@
 		 * problem in mostly all cases, though.
 		 */
 	}
+	dounlock();
 	return 0;
+dlcloseerror:
+	dounlock();
+	return 1;	
 }
 
 const char *dlerror(void)
 {
-	const char *e = err_filled ? err_str : 0;
-	err_filled = 0;
-	return e;
+	char* err_str;
+	err_str = pthread_getspecific(dlerror_key);
+	if (!err_str || !err_str[0]) return 0;
+	err_str[0]=0;
+	return (err_str +1);
 }
 
+
 int dladdr(void *p, Dl_info * info)
 {
 	unsigned long i;
@@ -789,6 +978,8 @@
 	int found = 0;
 	if (!info)
 		return 0;
+	dolock();
+	resetdlerror();
 	info->dli_fname = 0;
 	info->dli_fbase = 0;
 	info->dli_sname = 0;
@@ -821,7 +1012,10 @@
 		}
 	}
 	if (!found)
+	{
+		dounlock();
 		return 0;
+	}
 /* 	Okay, we seem to have found a place for the address, so now, we have to search the symbol table
 	for the nearest symbol with an address less than or equal to the passed in address */
 	lc = (struct load_command *)((char *)mh + sizeof(struct mach_header));
@@ -860,5 +1054,6 @@
 			}
 		}
 	}
+	dounlock();
 	return 1;
 }
