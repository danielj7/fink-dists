diff -Nurd config/genStubs.tcl config.new/genStubs.tcl
--- config/genStubs.tcl	1970-01-01 01:00:00.000000000 +0100
+++ config.new/genStubs.tcl	2008-09-18 16:29:45.000000000 +0200
@@ -0,0 +1,894 @@
+# genStubs.tcl --
+#
+#	This script generates a set of stub files for a given
+#	interface.  
+#	
+#
+# Copyright (c) 1998-1999 by Scriptics Corporation.
+# See the file "license.terms" for information on usage and redistribution
+# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+# 
+# RCS: @(#) $Id$
+
+namespace eval genStubs {
+    # libraryName --
+    #
+    #	The name of the entire library.  This value is used to compute
+    #	the USE_*_STUB_PROCS macro and the name of the init file.
+
+    variable libraryName "UNKNOWN"
+
+    # interfaces --
+    #
+    #	An array indexed by interface name that is used to maintain
+    #   the set of valid interfaces.  The value is empty.
+
+    array set interfaces {}
+
+    # curName --
+    #
+    #	The name of the interface currently being defined.
+
+    variable curName "UNKNOWN"
+
+    # hooks --
+    #
+    #	An array indexed by interface name that contains the set of
+    #	subinterfaces that should be defined for a given interface.
+
+    array set hooks {}
+
+    # stubs --
+    #
+    #	This three dimensional array is indexed first by interface name,
+    #	second by platform name, and third by a numeric offset or the
+    #	constant "lastNum".  The lastNum entry contains the largest
+    #	numeric offset used for a given interface/platform combo.  Each
+    #	numeric offset contains the C function specification that
+    #	should be used for the given entry in the stub table.  The spec
+    #	consists of a list in the form returned by parseDecl.
+
+    array set stubs {}
+
+    # outDir --
+    #
+    #	The directory where the generated files should be placed.
+
+    variable outDir .
+}
+
+# genStubs::library --
+#
+#	This function is used in the declarations file to set the name
+#	of the library that the interfaces are associated with (e.g. "tcl").
+#	This value will be used to define the inline conditional macro.
+#
+# Arguments:
+#	name	The library name.
+#
+# Results:
+#	None.
+
+proc genStubs::library {name} {
+    variable libraryName $name
+}
+
+# genStubs::interface --
+#
+#	This function is used in the declarations file to set the name
+#	of the interface currently being defined.
+#
+# Arguments:
+#	name	The name of the interface.
+#
+# Results:
+#	None.
+
+proc genStubs::interface {name} {
+    variable curName $name
+    variable interfaces
+
+    set interfaces($name) {}
+    return
+}
+
+# genStubs::hooks --
+#
+#	This function defines the subinterface hooks for the current
+#	interface.
+#
+# Arguments:
+#	names	The ordered list of interfaces that are reachable through the
+#		hook vector.
+#
+# Results:
+#	None.
+
+proc genStubs::hooks {names} {
+    variable curName
+    variable hooks
+
+    set hooks($curName) $names
+    return
+}
+
+# genStubs::declare --
+#
+#	This function is used in the declarations file to declare a new
+#	interface entry.
+#
+# Arguments:
+#	index		The index number of the interface.
+#	platform	The platform the interface belongs to.  Should be one
+#			of generic, win, unix, or mac.
+#	decl		The C function declaration, or {} for an undefined
+#			entry.
+#
+# Results:
+#	None.
+
+proc genStubs::declare {args} {
+    variable stubs
+    variable curName
+
+    if {[llength $args] != 3} {
+	puts stderr "wrong # args: declare $args"
+    }
+    lassign $args index platformList decl
+
+    # Check for duplicate declarations, then add the declaration and
+    # bump the lastNum counter if necessary.
+
+    foreach platform $platformList {
+	if {[info exists stubs($curName,$platform,$index)]} {
+	    puts stderr "Duplicate entry: declare $args"
+	}
+    }
+    regsub -all "\[ \t\n\]+" [string trim $decl] " " decl
+    set decl [parseDecl $decl]
+
+    foreach platform $platformList {
+	if {$decl != ""} {
+	    set stubs($curName,$platform,$index) $decl
+	    if {![info exists stubs($curName,$platform,lastNum)] \
+		    || ($index > $stubs($curName,$platform,lastNum))} {
+		set stubs($curName,$platform,lastNum) $index
+	    }
+	}
+    }
+    return
+}
+
+# genStubs::rewriteFile --
+#
+#	This function replaces the machine generated portion of the
+#	specified file with new contents.  It looks for the !BEGIN! and
+#	!END! comments to determine where to place the new text.
+#
+# Arguments:
+#	file	The name of the file to modify.
+#	text	The new text to place in the file.
+#
+# Results:
+#	None.
+
+proc genStubs::rewriteFile {file text} {
+    if {![file exist $file]} {
+	puts stderr "Cannot find file: $file"
+	return
+    }
+    set in [open ${file} r]
+    set out [open ${file}.new w]
+
+    # Always write out the file with LF termination
+    fconfigure $out -translation lf
+
+    while {![eof $in]} {
+	set line [gets $in]
+	if {[regexp {!BEGIN!} $line]} {
+	    break
+	}
+	puts $out $line
+    }
+    puts $out "/* !BEGIN!: Do not edit below this line. */"
+    puts $out $text
+    while {![eof $in]} {
+	set line [gets $in]
+	if {[regexp {!END!} $line]} {
+	    break
+	}
+    }
+    puts $out "/* !END!: Do not edit above this line. */"
+    puts -nonewline $out [read $in]
+    close $in
+    close $out
+    file rename -force ${file}.new ${file}
+    return
+}
+
+# genStubs::addPlatformGuard --
+#
+#	Wrap a string inside a platform #ifdef.
+#
+# Arguments:
+#	plat	Platform to test.
+#
+# Results:
+#	Returns the original text inside an appropriate #ifdef.
+
+proc genStubs::addPlatformGuard {plat text} {
+    switch $plat {
+	win {
+	    return "#ifdef __WIN32__\n${text}#endif /* __WIN32__ */\n"
+	}
+	unix {
+	    return "#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */\n${text}#endif /* UNIX */\n"
+	}		    
+	mac {
+	    return "#ifdef MAC_TCL\n${text}#endif /* MAC_TCL */\n"
+	}
+    }
+    return "$text"
+}
+
+# genStubs::emitSlots --
+#
+#	Generate the stub table slots for the given interface.  If there
+#	are no generic slots, then one table is generated for each
+#	platform, otherwise one table is generated for all platforms.
+#
+# Arguments:
+#	name	The name of the interface being emitted.
+#	textVar	The variable to use for output.
+#
+# Results:
+#	None.
+
+proc genStubs::emitSlots {name textVar} {
+    variable stubs
+    upvar $textVar text
+
+    forAllStubs $name makeSlot 1 text {"    void *reserved$i;\n"}
+    return
+}
+
+# genStubs::parseDecl --
+#
+#	Parse a C function declaration into its component parts.
+#
+# Arguments:
+#	decl	The function declaration.
+#
+# Results:
+#	Returns a list of the form {returnType name args}.  The args
+#	element consists of a list of type/name pairs, or a single
+#	element "void".  If the function declaration is malformed
+#	then an error is displayed and the return value is {}.
+
+proc genStubs::parseDecl {decl} {
+    if {![regexp {^(.*)\((.*)\)$} $decl all prefix args]} {
+	puts stderr "Malformed declaration: $decl"
+	return
+    }
+    set prefix [string trim $prefix]
+    if {![regexp {^(.+[ ][*]*)([^ *]+)$} $prefix all rtype fname]} {
+	puts stderr "Bad return type: $decl"
+	return
+    }
+    set rtype [string trim $rtype]
+    foreach arg [split $args ,] {
+	lappend argList [string trim $arg]
+    }
+    if {![string compare [lindex $argList end] "..."]} {
+	if {[llength $argList] != 2} {
+	    puts stderr "Only one argument is allowed in varargs form: $decl"
+	}
+	set arg [parseArg [lindex $argList 0]]
+	if {$arg == "" || ([llength $arg] != 2)} {
+	    puts stderr "Bad argument: '[lindex $argList 0]' in '$decl'"
+	    return
+	}
+	set args [list TCL_VARARGS $arg]
+    } else {
+	set args {}
+	foreach arg $argList {
+	    set argInfo [parseArg $arg]
+	    if {![string compare $argInfo "void"]} {
+		lappend args "void"
+		break
+	    } elseif {[llength $argInfo] == 2 || [llength $argInfo] == 3} {
+		lappend args $argInfo
+	    } else {
+		puts stderr "Bad argument: '$arg' in '$decl'"
+		return
+	    }
+	}
+    }
+    return [list $rtype $fname $args]
+}
+
+# genStubs::parseArg --
+#
+#	This function parses a function argument into a type and name.
+#
+# Arguments:
+#	arg	The argument to parse.
+#
+# Results:
+#	Returns a list of type and name with an optional third array
+#	indicator.  If the argument is malformed, returns "".
+
+proc genStubs::parseArg {arg} {
+    if {![regexp {^(.+[ ][*]*)([^][ *]+)(\[\])?$} $arg all type name array]} {
+	if {$arg == "void"} {
+	    return $arg
+	} else {
+	    return
+	}
+    }
+    set result [list [string trim $type] $name]
+    if {$array != ""} {
+	lappend result $array
+    }
+    return $result
+}
+
+# genStubs::makeDecl --
+#
+#	Generate the prototype for a function.
+#
+# Arguments:
+#	name	The interface name.
+#	decl	The function declaration.
+#	index	The slot index for this function.
+#
+# Results:
+#	Returns the formatted declaration string.
+
+proc genStubs::makeDecl {name decl index} {
+    lassign $decl rtype fname args
+
+    append text "/* $index */\n"
+    set line "EXTERN $rtype"
+    set count [expr {2 - ([string length $line] / 8)}]
+    append line [string range "\t\t\t" 0 $count]
+    set pad [expr {24 - [string length $line]}]
+    if {$pad <= 0} {
+	append line " "
+	set pad 0
+    }
+    append line "$fname _ANSI_ARGS_("
+
+    set arg1 [lindex $args 0]
+    switch -exact $arg1 {
+	void {
+	    append line "(void)"
+	}
+	TCL_VARARGS {
+	    set arg [lindex $args 1]
+	    append line "TCL_VARARGS([lindex $arg 0],[lindex $arg 1])"
+	}
+	default {
+	    set sep "("
+	    foreach arg $args {
+		append line $sep
+		set next {}
+		append next [lindex $arg 0] " " [lindex $arg 1] \
+			[lindex $arg 2]
+		if {[string length $line] + [string length $next] \
+			+ $pad > 76} {
+		    append text $line \n
+		    set line "\t\t\t\t"
+		    set pad 28
+		}
+		append line $next
+		set sep ", "
+	    }
+	    append line ")"
+	}
+    }
+    append text $line
+    
+    append text ");\n"
+    return $text
+}
+
+# genStubs::makeMacro --
+#
+#	Generate the inline macro for a function.
+#
+# Arguments:
+#	name	The interface name.
+#	decl	The function declaration.
+#	index	The slot index for this function.
+#
+# Results:
+#	Returns the formatted macro definition.
+
+proc genStubs::makeMacro {name decl index} {
+    lassign $decl rtype fname args
+
+    set lfname [string tolower [string index $fname 0]]
+    append lfname [string range $fname 1 end]
+
+    set text "#ifndef $fname\n#define $fname"
+    set arg1 [lindex $args 0]
+    set argList ""
+    switch -exact $arg1 {
+	void {
+	    set argList "()"
+	}
+	TCL_VARARGS {
+	}
+	default {
+	    set sep "("
+	    foreach arg $args {
+		append argList $sep [lindex $arg 1]
+		set sep ", "
+	    }
+	    append argList ")"
+	}
+    }
+    append text " \\\n\t(${name}StubsPtr->$lfname)"
+    append text " /* $index */\n#endif\n"
+    return $text
+}
+
+# genStubs::makeStub --
+#
+#	Emits a stub function definition.
+#
+# Arguments:
+#	name	The interface name.
+#	decl	The function declaration.
+#	index	The slot index for this function.
+#
+# Results:
+#	Returns the formatted stub function definition.
+
+proc genStubs::makeStub {name decl index} {
+    lassign $decl rtype fname args
+
+    set lfname [string tolower [string index $fname 0]]
+    append lfname [string range $fname 1 end]
+
+    append text "/* Slot $index */\n" $rtype "\n" $fname
+
+    set arg1 [lindex $args 0]
+
+    if {![string compare $arg1 "TCL_VARARGS"]} {
+	lassign [lindex $args 1] type argName 
+	append text " TCL_VARARGS_DEF($type,$argName)\n\{\n"
+	append text "    " $type " var;\n    va_list argList;\n"
+	if {[string compare $rtype "void"]} {
+	    append text "    " $rtype " resultValue;\n"
+	}
+	append text "\n    var = (" $type ") TCL_VARARGS_START(" \
+		$type "," $argName ",argList);\n\n    "
+	if {[string compare $rtype "void"]} {
+	    append text "resultValue = "
+	}
+	append text "(" $name "StubsPtr->" $lfname "VA)(var, argList);\n"
+	append text "    va_end(argList);\n"
+	if {[string compare $rtype "void"]} {
+	    append text "return resultValue;\n"
+	}
+	append text "\}\n\n"
+	return $text
+    }
+
+    if {![string compare $arg1 "void"]} {
+	set argList "()"
+	set argDecls ""
+    } else {
+	set argList ""
+	set sep "("
+	foreach arg $args {
+	    append argList $sep [lindex $arg 1]
+	    append argDecls "    " [lindex $arg 0] " " \
+		    [lindex $arg 1] [lindex $arg 2] ";\n"
+	    set sep ", "
+	}
+	append argList ")"
+    }
+    append text $argList "\n" $argDecls "{\n    "
+    if {[string compare $rtype "void"]} {
+	append text "return "
+    }
+    append text "(" $name "StubsPtr->" $lfname ")" $argList ";\n}\n\n"
+    return $text
+}
+
+# genStubs::makeSlot --
+#
+#	Generate the stub table entry for a function.
+#
+# Arguments:
+#	name	The interface name.
+#	decl	The function declaration.
+#	index	The slot index for this function.
+#
+# Results:
+#	Returns the formatted table entry.
+
+proc genStubs::makeSlot {name decl index} {
+    lassign $decl rtype fname args
+
+    set lfname [string tolower [string index $fname 0]]
+    append lfname [string range $fname 1 end]
+
+    set text "    "
+    append text $rtype " (*" $lfname ") _ANSI_ARGS_("
+
+    set arg1 [lindex $args 0]
+    switch -exact $arg1 {
+	void {
+	    append text "(void)"
+	}
+	TCL_VARARGS {
+	    set arg [lindex $args 1]
+	    append text "TCL_VARARGS([lindex $arg 0],[lindex $arg 1])"
+	}
+	default {
+	    set sep "("
+	    foreach arg $args {
+		append text $sep [lindex $arg 0] " " [lindex $arg 1] \
+			[lindex $arg 2]
+		set sep ", "
+	    }
+	    append text ")"
+	}
+    }
+    
+    append text "); /* $index */\n"
+    return $text
+}
+
+# genStubs::makeInit --
+#
+#	Generate the prototype for a function.
+#
+# Arguments:
+#	name	The interface name.
+#	decl	The function declaration.
+#	index	The slot index for this function.
+#
+# Results:
+#	Returns the formatted declaration string.
+
+proc genStubs::makeInit {name decl index} {
+    append text "    " [lindex $decl 1] ", /* " $index " */\n"
+    return $text
+}
+
+# genStubs::forAllStubs --
+#
+#	This function iterates over all of the platforms and invokes
+#	a callback for each slot.  The result of the callback is then
+#	placed inside appropriate platform guards.
+#
+# Arguments:
+#	name		The interface name.
+#	slotProc	The proc to invoke to handle the slot.  It will
+#			have the interface name, the declaration,  and
+#			the index appended.
+#	onAll		If 1, emit the skip string even if there are
+#			definitions for one or more platforms.
+#	textVar		The variable to use for output.
+#	skipString	The string to emit if a slot is skipped.  This
+#			string will be subst'ed in the loop so "$i" can
+#			be used to substitute the index value.
+#
+# Results:
+#	None.
+
+proc genStubs::forAllStubs {name slotProc onAll textVar \
+	{skipString {"/* Slot $i is reserved */\n"}}} {
+    variable stubs
+    upvar $textVar text
+
+    set plats [array names stubs $name,*,lastNum]
+    if {[info exists stubs($name,generic,lastNum)]} {
+	# Emit integrated stubs block
+	set lastNum -1
+	foreach plat [array names stubs $name,*,lastNum] {
+	    if {$stubs($plat) > $lastNum} {
+		set lastNum $stubs($plat)
+	    }
+	}
+	for {set i 0} {$i <= $lastNum} {incr i} {
+	    set slots [array names stubs $name,*,$i]
+	    set emit 0
+	    if {[info exists stubs($name,generic,$i)]} {
+		if {[llength $slots] > 1} {
+		    puts stderr "platform entry duplicates generic entry: $i"
+		}
+		append text [$slotProc $name $stubs($name,generic,$i) $i]
+		set emit 1
+	    } elseif {[llength $slots] > 0} {
+		foreach plat {unix win mac} {
+		    if {[info exists stubs($name,$plat,$i)]} {
+			append text [addPlatformGuard $plat \
+				[$slotProc $name $stubs($name,$plat,$i) $i]]
+			set emit 1
+		    } elseif {$onAll} {
+			append text [eval {addPlatformGuard $plat} $skipString]
+			set emit 1
+		    }
+		}
+	    }
+	    if {$emit == 0} {
+		eval {append text} $skipString
+	    }
+	}
+	
+    } else {
+	# Emit separate stubs blocks per platform
+	foreach plat {unix win mac} {
+	    if {[info exists stubs($name,$plat,lastNum)]} {
+		set lastNum $stubs($name,$plat,lastNum)
+		set temp {}
+		for {set i 0} {$i <= $lastNum} {incr i} {
+		    if {![info exists stubs($name,$plat,$i)]} {
+			eval {append temp} $skipString
+		    } else {
+			append temp [$slotProc $name $stubs($name,$plat,$i) $i]
+		    }
+		}
+		append text [addPlatformGuard $plat $temp]
+	    }
+	}
+    }
+
+}
+
+# genStubs::emitDeclarations --
+#
+#	This function emits the function declarations for this interface.
+#
+# Arguments:
+#	name	The interface name.
+#	textVar	The variable to use for output.
+#
+# Results:
+#	None.
+
+proc genStubs::emitDeclarations {name textVar} {
+    variable stubs
+    upvar $textVar text
+
+    append text "\n/*\n * Exported function declarations:\n */\n\n"
+    forAllStubs $name makeDecl 0 text
+    return
+}
+
+# genStubs::emitMacros --
+#
+#	This function emits the inline macros for an interface.
+#
+# Arguments:
+#	name	The name of the interface being emitted.
+#	textVar	The variable to use for output.
+#
+# Results:
+#	None.
+
+proc genStubs::emitMacros {name textVar} {
+    variable stubs
+    variable libraryName
+    upvar $textVar text
+
+    set upName [string toupper $libraryName]
+    append text "\n#if defined(USE_${upName}_STUBS) && !defined(USE_${upName}_STUB_PROCS)\n"
+    append text "\n/*\n * Inline function declarations:\n */\n\n"
+    
+    forAllStubs $name makeMacro 0 text
+
+    append text "\n#endif /* defined(USE_${upName}_STUBS) && !defined(USE_${upName}_STUB_PROCS) */\n"
+    return
+}
+
+# genStubs::emitHeader --
+#
+#	This function emits the body of the <name>Decls.h file for
+#	the specified interface.
+#
+# Arguments:
+#	name	The name of the interface being emitted.
+#
+# Results:
+#	None.
+
+proc genStubs::emitHeader {name} {
+    variable outDir
+    variable hooks
+
+    set capName [string toupper [string index $name 0]]
+    append capName [string range $name 1 end]
+
+    emitDeclarations $name text
+
+    if {[info exists hooks($name)]} {
+	append text "\ntypedef struct ${capName}StubHooks {\n"
+	foreach hook $hooks($name) {
+	    set capHook [string toupper [string index $hook 0]]
+	    append capHook [string range $hook 1 end]
+	    append text "    struct ${capHook}Stubs *${hook}Stubs;\n"
+	}
+	append text "} ${capName}StubHooks;\n"
+    }
+    append text "\ntypedef struct ${capName}Stubs {\n"
+    append text "    int magic;\n"
+    append text "    struct ${capName}StubHooks *hooks;\n\n"
+
+    emitSlots $name text
+
+    append text "} ${capName}Stubs;\n"
+
+    append text "\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n"
+    append text "extern ${capName}Stubs *${name}StubsPtr;\n"
+    append text "#ifdef __cplusplus\n}\n#endif\n"
+
+    emitMacros $name text
+
+    rewriteFile [file join $outDir ${name}Decls.h] $text
+    return
+}
+
+# genStubs::emitStubs --
+#
+#	This function emits the body of the <name>Stubs.c file for
+#	the specified interface.
+#
+# Arguments:
+#	name	The name of the interface being emitted.
+#
+# Results:
+#	None.
+
+proc genStubs::emitStubs {name} {
+    variable outDir
+
+    append text "\n/*\n * Exported stub functions:\n */\n\n"
+    forAllStubs $name makeStub 0 text
+
+    rewriteFile [file join $outDir ${name}Stubs.c] $text
+    return    
+}
+
+# genStubs::emitInit --
+#
+#	Generate the table initializers for an interface.
+#
+# Arguments:
+#	name		The name of the interface to initialize.
+#	textVar		The variable to use for output.
+#
+# Results:
+#	Returns the formatted output.
+
+proc genStubs::emitInit {name textVar} {
+    variable stubs
+    variable hooks
+    upvar $textVar text
+
+    set capName [string toupper [string index $name 0]]
+    append capName [string range $name 1 end]
+
+    if {[info exists hooks($name)]} {
+ 	append text "\nstatic ${capName}StubHooks ${name}StubHooks = \{\n"
+	set sep "    "
+	foreach sub $hooks($name) {
+	    append text $sep "&${sub}Stubs"
+	    set sep ",\n    "
+	}
+	append text "\n\};\n"
+    }
+    append text "\n${capName}Stubs ${name}Stubs = \{\n"
+    append text "    TCL_STUB_MAGIC,\n"
+    if {[info exists hooks($name)]} {
+	append text "    &${name}StubHooks,\n"
+    } else {
+	append text "    NULL,\n"
+    }
+    
+    forAllStubs $name makeInit 1 text {"    NULL, /* $i */\n"}
+
+    append text "\};\n"
+    return
+}
+
+# genStubs::emitInits --
+#
+#	This function emits the body of the <name>StubInit.c file for
+#	the specified interface.
+#
+# Arguments:
+#	name	The name of the interface being emitted.
+#
+# Results:
+#	None.
+
+proc genStubs::emitInits {} {
+    variable hooks
+    variable outDir
+    variable libraryName
+    variable interfaces
+
+    # Assuming that dependencies only go one level deep, we need to emit
+    # all of the leaves first to avoid needing forward declarations.
+
+    set leaves {}
+    set roots {}
+    foreach name [lsort [array names interfaces]] {
+	if {[info exists hooks($name)]} {
+	    lappend roots $name
+	} else {
+	    lappend leaves $name
+	}
+    }
+    foreach name $leaves {
+	emitInit $name text
+    }
+    foreach name $roots {
+	emitInit $name text
+    }
+
+    rewriteFile [file join $outDir ${libraryName}StubInit.c] $text
+}
+
+# genStubs::init --
+#
+#	This is the main entry point.
+#
+# Arguments:
+#	None.
+#
+# Results:
+#	None.
+
+proc genStubs::init {} {
+    global argv argv0
+    variable outDir
+    variable interfaces
+
+    if {[llength $argv] < 2} {
+	puts stderr "usage: $argv0 outDir declFile ?declFile...?"
+	exit 1
+    }
+
+    set outDir [lindex $argv 0]
+
+    foreach file [lrange $argv 1 end] {
+	source $file
+    }
+
+    foreach name [lsort [array names interfaces]] {
+	puts "Emitting $name"
+	emitHeader $name
+    }
+
+    emitInits
+}
+
+# lassign --
+#
+#	This function emulates the TclX lassign command.
+#
+# Arguments:
+#	valueList	A list containing the values to be assigned.
+#	args		The list of variables to be assigned.
+#
+# Results:
+#	Returns any values that were not assigned to variables.
+
+proc lassign {valueList args} {
+  if {[llength $args] == 0} {
+      error "wrong # args: lassign list varname ?varname..?"
+  }
+
+  uplevel [list foreach $args $valueList {break}]
+  return [lrange $valueList [llength $args] end]
+}
+
+genStubs::init
diff -Nurd config/install-sh config.new/install-sh
--- config/install-sh	1970-01-01 01:00:00.000000000 +0100
+++ config.new/install-sh	2008-09-18 16:29:45.000000000 +0200
@@ -0,0 +1,119 @@
+#!/bin/sh
+
+#
+# install - install a program, script, or datafile
+# This comes from X11R5; it is not part of GNU.
+#
+# $XConsortium: install.sh,v 1.2 89/12/18 14:47:22 jim Exp $
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.
+#
+
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit="${DOITPROG-}"
+
+
+# put in absolute paths if you don't have them in your path; or use env. vars.
+
+mvprog="${MVPROG-mv}"
+cpprog="${CPPROG-cp}"
+chmodprog="${CHMODPROG-chmod}"
+chownprog="${CHOWNPROG-chown}"
+chgrpprog="${CHGRPPROG-chgrp}"
+stripprog="${STRIPPROG-strip}"
+rmprog="${RMPROG-rm}"
+
+instcmd="$mvprog"
+chmodcmd=""
+chowncmd=""
+chgrpcmd=""
+stripcmd=""
+rmcmd="$rmprog -f"
+mvcmd="$mvprog"
+src=""
+dst=""
+
+while [ x"$1" != x ]; do
+    case $1 in
+	-c) instcmd="$cpprog"
+	    shift
+	    continue;;
+
+	-m) chmodcmd="$chmodprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-o) chowncmd="$chownprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-g) chgrpcmd="$chgrpprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-s) stripcmd="$stripprog"
+	    shift
+	    continue;;
+
+	*)  if [ x"$src" = x ]
+	    then
+		src=$1
+	    else
+		dst=$1
+	    fi
+	    shift
+	    continue;;
+    esac
+done
+
+if [ x"$src" = x ]
+then
+	echo "install:  no input file specified"
+	exit 1
+fi
+
+if [ x"$dst" = x ]
+then
+	echo "install:  no destination specified"
+	exit 1
+fi
+
+
+# If destination is a directory, append the input filename; if your system
+# does not like double slashes in filenames, you may need to add some logic
+
+if [ -d $dst ]
+then
+	dst="$dst"/`basename $src`
+fi
+
+# Make a temp file name in the proper directory.
+
+dstdir=`dirname $dst`
+dsttmp=$dstdir/#inst.$$#
+
+# Move or copy the file name to the temp name
+
+$doit $instcmd $src $dsttmp
+
+# and set any options; do chmod last to preserve setuid bits
+
+if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; fi
+if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; fi
+if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; fi
+if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; fi
+
+# Now rename the file to the real destination.
+
+$doit $rmcmd $dst
+$doit $mvcmd $dsttmp $dst
+
+
+exit 0
diff -Nurd config/install.tcl config.new/install.tcl
--- config/install.tcl	1970-01-01 01:00:00.000000000 +0100
+++ config.new/install.tcl	2008-09-18 16:29:45.000000000 +0200
@@ -0,0 +1,141 @@
+#!/bin/sh
+# The next line restarts using wish8.0 \
+exec wish8.0 $0 ${1+"$@"}
+#
+# Initialization of some global variables
+
+eval destroy [winfo children .]
+
+switch -glob [info sharedlibextension] {
+    .so* {
+	set libs [list libpng.so.2.1.0 libjpeg.so.62.0.0 libtiff.so.3.4.37 \
+		libz.so.1.1.3 libttf.so.1.2.0 libungif.so.3.1.0]
+    }
+    ..a {
+	set libs [list libpng.a libjpeg.a libtiff.a libz.a libttf.a libungif.a]
+    }
+    .dll {
+	set libs [list png.lib jpeg62.lib tiff.lib zlib.lib ttf.lib ungif.lib]
+	set dll [list png.dll jpeg62.dll tiff.dll zlib.dll ttf.dll ungif.dll]
+    }
+    * {
+	set libs [list libpng[info sharedlibextension] libjpeg[info sharedlibextension] \
+		libtiff[info sharedlibextension] libz[info sharedlibextension] \
+		libttf[info sharedlibextension] libungif[info sharedlibextension]]
+    }
+}
+
+if [info exists env(PATH)] {
+    if [string compare $tcl_platform(platform) windows] {
+	set dirs [split $env(PATH) :]
+    } else {
+	set dirs [split $env(PATH) \;]
+    }
+} else {
+    set dirs "/usr/local/lib /usr/lib /lib"
+}
+
+foreach dir "$dirs C:/WINDOWS/* C:/WINNT/*" {
+   foreach d [list $dir [file join [file dirname $dir] lib]] {
+	set x [glob -nocomplain [file join $d \{lib,\}tcl\[78\]*[info sharedlibextension]*]]
+	if [string compare $x {}] break
+    }
+    if [string compare $x {}] break
+}
+
+
+label .f1 -text "Where should the following files be installed?"
+pack .f1
+proc line {f label default} {
+    frame $f
+    label $f.l -text $label
+    entry $f.e -width 50
+    $f.e insert end $default
+    pack $f.l -side left
+    pack $f.e -side right
+    pack $f -expand y -fill both
+}
+set prefix [file dirname [file dirname $tk_library]]
+
+if [string compare $tcl_platform(platform) windows] {
+    set imglibs [lindex [file split $x] end]
+    if [string match libtcl?.?[info sharedlibextension]* $imglibs] {
+	set imglibs libimg1.2[info sharedlibextension]
+    } else {
+	set imglibs libimg12[info sharedlibextension]
+    }
+} else {
+    set x [lindex $x 0]
+    set systemdll [file dirname $x]
+    set imglibs [list img1280.dll img1281.dll]
+    line .f2 "system dll's" $systemdll
+}
+line .f3 "system libraries"  [file join $prefix lib]
+line .f4 "system headers" [file join $prefix include]
+line .f5 "Img 1.2 files" [file join $prefix lib Img1.2]
+frame .f6
+button .f6.install -text Install -command Install
+button .f6.exit -text Exit -command "destroy ."
+pack .f6.install .f6.exit -side left -fill both -expand y
+pack .f6 -fill both -expand y
+
+proc Copy {src dst} {
+    if [file exists $src] {
+	file delete -force [file join $dst $src]
+	puts_stdout "copying $src to $dst"
+	file copy $src $dst
+	return 1
+    }
+    return 0
+}
+
+proc Install {} {
+    global libs dll tcl_platform imglibs
+    if [winfo exists .t] {
+	raise .t
+    } else {
+	toplevel .t
+	frame .t.f
+	button .t.f.d -text dismiss -command [list destroy .t]
+	pack .t.f.d -side left
+	pack .t.f -side top -fill x
+	text .t.t -yscrollcommand [list .t.s set]
+	scrollbar .t.s -command [list .t.t yview]
+	pack .t.t .t.s -side left -expand y -fill both
+    }
+    .t.t delete 1.0 end
+    proc puts_stdout args {
+	.t.t insert end "[lindex $args 0]\n"
+	.t.t see end
+	update
+    }
+    .t.t see end
+    if ![string compare $tcl_platform(platform) windows] {
+	set dir [.f2.e get]
+	foreach lib $dll {
+	    Copy $lib $dir
+	}
+    }
+    set dir [.f3.e get]
+    foreach lib $libs {
+	if {[Copy $lib $dir] && ![string compare [info sharedlibextension] .so]} {
+	    while {[string compare .so [set ext [file extension $lib]]]} {
+		file delete [set file [file join $dir [file rootname $lib]]]
+		puts_stdout "ln -s $lib $file"
+		exec ln -s $lib $file
+		set lib [file rootname $lib]
+	    }
+	}
+    }
+    set dir [.f4.e get]
+    foreach lib [list zlib.h zconf.h png.h pngconf.h jpeglib.h jconfig.h \
+		jmorecfg.h jerror.h tiff.h tiffio.h tiffconf.h freetype.h gif_lib.h] {
+	Copy $lib $dir
+    }
+    set dir [.f5.e get]
+    catch {file mkdir $dir}
+    foreach lib "$imglibs pkgIndex.tcl" {
+	Copy $lib $dir
+    }
+    puts_stdout "---------- installation complete ----------"
+}
diff -Nurd config/installFile.tcl config.new/installFile.tcl
--- config/installFile.tcl	1970-01-01 01:00:00.000000000 +0100
+++ config.new/installFile.tcl	2008-09-18 16:29:45.000000000 +0200
@@ -0,0 +1,120 @@
+#!/bin/sh
+#
+# installFile.tcl - a Tcl version of install-sh
+#	that copies a file and preserves its permission bits.
+#	This also optimizes out installation of existing files
+#	that have the same size and time stamp as the source.
+#
+# \
+exec tclsh8.3 "$0" ${1+"$@"}
+
+set doCopy 0	;# Rename files instead of copy
+set doStrip 0	;# Strip the symbols from installed copy
+set verbose 0
+set src ""
+set dst ""
+
+# Process command line arguments, compatible with install-sh
+
+for {set i 0} {$i < $argc} {incr i} {
+    set arg [lindex $argv $i]
+    switch -- $arg {
+	-c {
+	    set doCopy 1
+	}
+	-m  {
+	    incr i
+	    # Assume UNIX standard "644", etc, so force Tcl to think octal
+	    set permissions 0[lindex $argv $i]
+	}
+	-o  {
+	    incr i
+	    set owner [lindex $argv $i]
+	}
+	-g  {
+	    incr i
+	    set group [lindex $argv $i]
+	}
+	-s {
+	    set doStrip 1
+	}
+	-v {
+	    set verbose 1
+	}
+	default {
+	    set src $arg
+	    incr i
+	    set dst [lindex $argv $i]
+	    break
+	}
+    }
+}
+if {[string length $src] == 0} {
+    puts stderr "$argv0: no input file specified"
+    exit 1
+}
+if {[string length $dst] == 0} {
+    puts stderr "$argv0: no destination file specified"
+    exit 1
+}
+
+# Compatibility with CYGNUS-style pathnames
+regsub {^/(cygdrive)?/(.)/(.*)} $src {\2:/\3} src
+regsub {^/(cygdrive)?/(.)/(.*)} $dst {\2:/\3} dst
+
+if {$verbose && $doStrip} {
+    puts stderr "Ignoring -s (strip) option for $dst"
+}
+if {[file isdirectory $dst]} {
+    set dst [file join $dst [file tail $src]]
+}
+
+# Temporary file name
+
+set dsttmp [file join [file dirname $dst] #inst.[pid]#]
+
+# Optimize out install if the file already exists
+
+set actions ""
+if {[file exists $dst] &&
+	([file mtime $src] == [file mtime $dst]) &&
+	([file size $src] == [file size $dst])} {
+
+    # Looks like the same file, so don't bother to copy.
+    # Set dsttmp in case we still need to tweak mode, group, etc.
+
+    set dsttmp $dst
+    lappend actions "already installed"
+} else {
+    file copy -force $src $dsttmp
+    lappend actions copied
+}
+
+# At this point "$dsttmp" is installed, but might not have the
+# right permissions and may need to be renamed.
+
+
+foreach attrName {owner group permissions} {
+    upvar 0 $attrName attr
+
+    if {[info exists attr]} {
+	if {![catch {file attributes $dsttmp -$attrName} dstattr]} {
+
+	    # This system supports "$attrName" kind of attributes
+
+	    if {($attr != $dstattr)} {
+		file attributes $dsttmp -$attrName $attr
+		lappend actions "set $attrName to $attr"
+	    }
+	}
+    }
+}
+
+if {[string compare $dst $dsttmp] != 0} {
+    file rename -force $dsttmp $dst
+}
+if {$verbose} {
+    puts stderr "$dst: [join $actions ", "]"
+}
+exit 0
+
diff -Nurd config/ldAout.tcl config.new/ldAout.tcl
--- config/ldAout.tcl	1970-01-01 01:00:00.000000000 +0100
+++ config.new/ldAout.tcl	2008-09-18 16:29:45.000000000 +0200
@@ -0,0 +1,240 @@
+# ldAout.tcl --
+#
+#	This "tclldAout" procedure in this script acts as a replacement
+#	for the "ld" command when linking an object file that will be
+#	loaded dynamically into Tcl or Tk using pseudo-static linking.
+#
+# Parameters:
+#	The arguments to the script are the command line options for
+#	an "ld" command.
+#
+# Results:
+#	The "ld" command is parsed, and the "-o" option determines the
+#	module name.  ".a" and ".o" options are accumulated.
+#	The input archives and object files are examined with the "nm"
+#	command to determine whether the modules initialization
+#	entry and safe initialization entry are present.  A trivial
+#	C function that locates the entries is composed, compiled, and
+#	its .o file placed before all others in the command; then
+#	"ld" is executed to bind the objects together.
+#
+# SCCS: @(#) ldAout.tcl 1.11 96/09/17 09:02:20
+#
+# Copyright (c) 1995, by General Electric Company. All rights reserved.
+#
+# See the file "license.terms" for information on usage and redistribution
+# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+#
+# This work was supported in part by the ARPA Manufacturing Automation
+# and Design Engineering (MADE) Initiative through ARPA contract
+# F33615-94-C-4400.
+#
+
+proc tclLdAout {{cc {}} {shlib_suffix {}} {shlib_cflags none}} {
+  global env
+  global argv
+
+  if {$cc==""} {
+    set cc $env(CC)
+  }
+
+  # if only two parameters are supplied there is assumed that the
+  # only shlib_suffix is missing. This parameter is anyway available
+  # as "info sharedlibextension" too, so there is no need to transfer
+  # 3 parameters to the function tclLdAout. For compatibility, this
+  # function now accepts both 2 and 3 parameters.
+
+  if {$shlib_suffix==""} {
+    set shlib_cflags $env(SHLIB_CFLAGS)
+  } else {
+    if {$shlib_cflags=="none"} {
+      set shlib_cflags $shlib_suffix
+    }
+  }
+
+  # seenDotO is nonzero if a .o or .a file has been seen
+
+  set seenDotO 0
+
+  # minusO is nonzero if the last command line argument was "-o".
+
+  set minusO 0
+
+  # head has command line arguments up to but not including the first
+  # .o or .a file. tail has the rest of the arguments.
+
+  set head {}
+  set tail {}
+
+  # nmCommand is the "nm" command that lists global symbols from the
+  # object files.
+
+  set nmCommand {|nm -g}
+
+  # entryProtos is the table of prototypes found in the
+  # module.
+
+  set entryProtos {}
+
+  # entryPoints is the table of entries found in the
+  # module.
+
+  set entryPoints {}
+
+  # libraries is the list of -L and -l flags to the linker.
+
+  set libraries {}
+  set libdirs {}
+
+  # Process command line arguments
+
+  foreach a $argv {
+    if {!$minusO && [regexp {\.[ao]$} $a]} {
+      set seenDotO 1
+      lappend nmCommand $a
+    }
+    if {$minusO} {
+      set outputFile $a
+      set minusO 0
+    } elseif {![string compare $a -o]} {
+      set minusO 1
+    }
+    if [regexp {^-[lL]} $a] {
+	lappend libraries $a
+	if [regexp {^-L} $a] {
+	    lappend libdirs [string range $a 2 end]
+	}
+    } elseif {$seenDotO} {
+	lappend tail $a
+    } else {
+	lappend head $a
+    }
+  }
+  lappend libdirs /lib /usr/lib
+
+  # MIPS -- If there are corresponding G0 libraries, replace the
+  # ordinary ones with the G0 ones.
+
+  set libs {}
+  foreach lib $libraries {
+      if [regexp {^-l} $lib] {
+	  set lname [string range $lib 2 end]
+	  foreach dir $libdirs {
+	      if [file exists [file join $dir lib${lname}_G0.a]] {
+		  set lname ${lname}_G0
+		  break
+	      }
+	  }
+	  lappend libs -l$lname
+      } else {
+	  lappend libs $lib
+      }
+  }
+  set libraries $libs
+
+  # Extract the module name from the "-o" option
+
+  if {![info exists outputFile]} {
+    error "-o option must be supplied to link a Tcl load module"
+  }
+  set m [file tail $outputFile]
+  if [regexp {\.a$} $outputFile] {
+    set shlib_suffix .a
+  } else {
+    set shlib_suffix ""
+  }
+  if [regexp {\..*$} $outputFile match] {
+    set l [expr [string length $m] - [string length $match]]
+  } else {
+    error "Output file does not appear to have a suffix"
+  }
+  set modName [string tolower [string range $m 0 [expr $l-1]]]
+  if [regexp {^lib} $modName] {
+    set modName [string range $modName 3 end]
+  }
+  if [regexp {[0-9\.]*$} $modName match] {
+    set modName [string range $modName 0 [expr [string length $modName]-[string length $match]-1]]
+  }
+  set modName "[string toupper [string index $modName 0]][string range $modName 1 end]"
+  
+  # Catalog initialization entry points found in the module
+
+  set f [open $nmCommand r]
+  while {[gets $f l] >= 0} {
+    if [regexp {[0-9A-Fa-f]+ T[ 	]*(((Img_)|(g?z)|(adler32)|((un)?compress)|(crc32)|((in)|(de)flate)|(png_)|(jpeg_)|(_?TIFF)|(TT_))[a-zA-Z0-9_]*)} $l trash symbol] {
+      append entryProtos {extern int } $symbol { (); } \n
+      append entryPoints {  } \{ { "} $symbol {", } $symbol { } \} , \n
+    }
+  }
+  close $f
+
+  if {$entryPoints==""} {
+    error "No entry point found in objects"
+  }
+
+  # Compose a C function that resolves the entry points and
+  # embeds the required libraries in the object code.
+
+  set C {#include <string.h>}
+  append C \n
+  append C {char TclLoadLibraries_} $modName { [] =} \n
+  append C {  "@LIBS: } $libraries {";} \n
+  append C $entryProtos
+  append C {static struct } \{ \n
+  append C {  char * name;} \n
+  append C {  int (*value)();} \n
+  append C \} {dictionary [] = } \{ \n
+  append C $entryPoints
+  append C \{  0, 0 \} \n \} \; \n
+  append C {typedef struct Tcl_Interp Tcl_Interp;} \n
+  append C {typedef int Tcl_PackageInitProc (Tcl_Interp *);} \n
+  append C {Tcl_PackageInitProc *} \n
+  append C TclLoadDictionary_ $modName { (symbol)} \n
+  append C {    char * symbol;} \n
+  append C {{
+    int i;
+    for (i = 0; dictionary [i] . name != 0; ++i) {
+      if (!strcmp (symbol, dictionary [i] . name)) {
+	return dictionary [i].value;
+      }
+    }
+    return 0;
+}} \n
+
+  # Write the C module and compile it
+
+  set cFile tcl$modName.c
+  set f [open $cFile w]
+  puts -nonewline $f $C
+  close $f
+  set ccCommand "$cc -c $shlib_cflags $cFile"
+  puts stderr $ccCommand
+  eval exec $ccCommand
+
+  # Now compose and execute the ld command that packages the module
+
+  if {$shlib_suffix == ".a"} {
+    set ldCommand "ar cr $outputFile"
+    regsub { -o} $tail {} tail
+  } else {
+  set ldCommand ld
+  foreach item $head {
+    lappend ldCommand $item
+  }
+  }
+  lappend ldCommand tcl$modName.o
+  foreach item $tail {
+    lappend ldCommand $item
+  }
+  puts stderr $ldCommand
+  if [catch "exec $ldCommand" msg] {
+    puts stderr $msg
+  }
+  if {$shlib_suffix == ".a"} {
+    exec ranlib $outputFile
+  }
+
+  # Clean up working files
+
+  exec /bin/rm $cFile [file rootname $cFile].o
+}
diff -Nurd config/mkinstalldirs config.new/mkinstalldirs
--- config/mkinstalldirs	1970-01-01 01:00:00.000000000 +0100
+++ config.new/mkinstalldirs	2008-09-18 16:29:45.000000000 +0200
@@ -0,0 +1,32 @@
+#!/bin/sh
+# mkinstalldirs --- make directory hierarchy
+# Author: Noah Friedman <friedman@prep.ai.mit.edu>
+# Created: 1993-05-16
+# Last modified: 1994-03-25
+# Public domain
+
+errstatus=0
+
+for file in ${1+"$@"} ; do 
+   set fnord `echo ":$file" | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'`
+   shift
+
+   pathcomp=
+   for d in ${1+"$@"} ; do
+     pathcomp="$pathcomp$d"
+     case "$pathcomp" in
+       -* ) pathcomp=./$pathcomp ;;
+     esac
+
+     if test ! -d "$pathcomp"; then
+        echo "mkdir $pathcomp" 1>&2
+        mkdir "$pathcomp" || errstatus=$?
+     fi
+
+     pathcomp="$pathcomp/"
+   done
+done
+
+exit $errstatus
+
+# mkinstalldirs ends here
