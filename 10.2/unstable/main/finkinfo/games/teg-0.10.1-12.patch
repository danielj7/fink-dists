diff -Naur teg-0.10.1/client/misc.c teg-new/client/misc.c
--- teg-0.10.1/client/misc.c	2002-05-22 00:02:35.000000000 -0400
+++ teg-new/client/misc.c	2002-07-21 22:12:34.000000000 -0400
@@ -193,7 +193,7 @@
 TEG_STATUS launch_server( int port )
 {
 	pid_t pid;
-	char *args[5];
+	char *args[6];
 
 	if ( (pid = fork()) < 0) {
 		perror("tegclient:");
@@ -245,7 +245,7 @@
 TEG_STATUS launch_robot( void )
 {
 	pid_t pid;
-	char *args[6];
+	char *args[7];
 	char port[50];
 
 	/* launch robot in the server */
diff -Naur teg-0.10.1/server/Makefile.in teg-new/server/Makefile.in
--- teg-0.10.1/server/Makefile.in	2002-06-26 17:51:12.000000000 -0400
+++ teg-new/server/Makefile.in	2002-07-21 22:13:26.000000000 -0400
@@ -156,7 +156,7 @@
 INCLUDES = -I$(top_srcdir)/common -I../intl $(GGZINC)		@SERVER_CFLAGS@						@GGZDMOD_INCLUDES@					-DBINDIR=\"$(bindir)\"
 
 
-tegserver_SOURCES =  	main.c main.h			globals.h			server.h			jugador.c jugador.h		sernet.c sernet.h		paises.c paises.h		play.c play.h			turno.c turno.h			console.c console.h		helper.c helper.h		objetivos.c objetivos.h 	tegggz.c tegggz.h		options.c options.h		xmlscores.c xmlscores.h		fow.c fow.h
+tegserver_SOURCES =  	main.c main.h			globals.h			server.h			jugador.c jugador.h		sernet.c sernet.h		paises.c paises.h		play.c play.h			turno.c turno.h			console.c console.h		helper.c helper.h		objetivos.c objetivos.h 	tegggz.c tegggz.h		options.c options.h		xmlscores.c xmlscores.h		fow.c fow.h inet_ntop.c
 
 
 tegserver_DEPENDENCIES = ../common/libtegcommon.a $(INTLDEPS)
@@ -179,7 +179,7 @@
 tegserver_OBJECTS =  main.$(OBJEXT) jugador.$(OBJEXT) sernet.$(OBJEXT) \
 paises.$(OBJEXT) play.$(OBJEXT) turno.$(OBJEXT) console.$(OBJEXT) \
 helper.$(OBJEXT) objetivos.$(OBJEXT) tegggz.$(OBJEXT) options.$(OBJEXT) \
-xmlscores.$(OBJEXT) fow.$(OBJEXT)
+xmlscores.$(OBJEXT) fow.$(OBJEXT) inet_ntop.$(OBJEXT)
 tegserver_LDFLAGS = 
 CFLAGS = @CFLAGS@
 COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
diff -Naur teg-0.10.1/server/helper.c teg-new/server/helper.c
--- teg-0.10.1/server/helper.c	2002-05-12 22:50:56.000000000 -0400
+++ teg-new/server/helper.c	2002-07-21 22:12:34.000000000 -0400
@@ -39,6 +39,10 @@
 
 static char colors[TEG_MAX_PLAYERS];
 
+#ifdef MACOSX
+	#define socklen_t int
+#endif
+
 /**
  * @fn void color_init()
  * Inicializa los colores
diff -Naur teg-0.10.1/server/inet_ntop.c teg-new/server/inet_ntop.c
--- teg-0.10.1/server/inet_ntop.c	1969-12-31 19:00:00.000000000 -0500
+++ teg-new/server/inet_ntop.c	2002-07-21 22:12:34.000000000 -0400
@@ -0,0 +1,205 @@
+/*
+ * Copyright (c) 1996-1999 by Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
+ * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
+ * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+ * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static const char rcsid[] = "$Id: inet_ntop.c,v 1.1 2001/03/29 06:31:39 marka Exp $";
+#endif /* LIBC_SCCS and not lint */
+
+/*#include "port_before.h"*/
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <arpa/nameser.h>
+
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+
+/*#include "port_after.h"*/
+
+#define NS_INT16SZ      2
+#define NS_IN6ADDRSZ   16
+ 
+#ifdef SPRINTF_CHAR
+# define SPRINTF(x) strlen(sprintf/**/x)
+#else
+# define SPRINTF(x) ((size_t)sprintf x)
+#endif
+
+/*
+ * WARNING: Don't even consider trying to compile this on a system where
+ * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
+ */
+
+static const char *inet_ntop4 __P((const u_char *src, char *dst, size_t size));
+static const char *inet_ntop6 __P((const u_char *src, char *dst, size_t size));
+
+/* char *
+ * inet_ntop(af, src, dst, size)
+ *	convert a network format address to presentation format.
+ * return:
+ *	pointer to presentation format address (`dst'), or NULL (see errno).
+ * author:
+ *	Paul Vixie, 1996.
+ */
+const char *
+inet_ntop(af, src, dst, size)
+	int af;
+	const void *src;
+	char *dst;
+	size_t size;
+{
+	switch (af) {
+	case AF_INET:
+		return (inet_ntop4(src, dst, size));
+	case AF_INET6:
+		return (inet_ntop6(src, dst, size));
+	default:
+		errno = EAFNOSUPPORT;
+		return (NULL);
+	}
+	/* NOTREACHED */
+}
+
+/* const char *
+ * inet_ntop4(src, dst, size)
+ *	format an IPv4 address
+ * return:
+ *	`dst' (as a const)
+ * notes:
+ *	(1) uses no statics
+ *	(2) takes a u_char* not an in_addr as input
+ * author:
+ *	Paul Vixie, 1996.
+ */
+static const char *
+inet_ntop4(src, dst, size)
+	const u_char *src;
+	char *dst;
+	size_t size;
+{
+	static const char fmt[] = "%u.%u.%u.%u";
+	char tmp[sizeof "255.255.255.255"];
+
+	if (SPRINTF((tmp, fmt, src[0], src[1], src[2], src[3])) >= size) {
+		errno = ENOSPC;
+		return (NULL);
+	}
+	strcpy(dst, tmp);
+	return (dst);
+}
+
+/* const char *
+ * inet_ntop6(src, dst, size)
+ *	convert IPv6 binary address into presentation (printable) format
+ * author:
+ *	Paul Vixie, 1996.
+ */
+static const char *
+inet_ntop6(src, dst, size)
+	const u_char *src;
+	char *dst;
+	size_t size;
+{
+	/*
+	 * Note that int32_t and int16_t need only be "at least" large enough
+	 * to contain a value of the specified size.  On some systems, like
+	 * Crays, there is no such thing as an integer variable with 16 bits.
+	 * Keep this in mind if you think this function should have been coded
+	 * to use pointer overlays.  All the world's not a VAX.
+	 */
+	char tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"], *tp;
+	struct { int base, len; } best, cur;
+	u_int words[NS_IN6ADDRSZ / NS_INT16SZ];
+	int i;
+
+	/*
+	 * Preprocess:
+	 *	Copy the input (bytewise) array into a wordwise array.
+	 *	Find the longest run of 0x00's in src[] for :: shorthanding.
+	 */
+	memset(words, '\0', sizeof words);
+	for (i = 0; i < NS_IN6ADDRSZ; i++)
+		words[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));
+	best.base = -1;
+	cur.base = -1;
+	for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
+		if (words[i] == 0) {
+			if (cur.base == -1)
+				cur.base = i, cur.len = 1;
+			else
+				cur.len++;
+		} else {
+			if (cur.base != -1) {
+				if (best.base == -1 || cur.len > best.len)
+					best = cur;
+				cur.base = -1;
+			}
+		}
+	}
+	if (cur.base != -1) {
+		if (best.base == -1 || cur.len > best.len)
+			best = cur;
+	}
+	if (best.base != -1 && best.len < 2)
+		best.base = -1;
+
+	/*
+	 * Format the result.
+	 */
+	tp = tmp;
+	for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
+		/* Are we inside the best run of 0x00's? */
+		if (best.base != -1 && i >= best.base &&
+		    i < (best.base + best.len)) {
+			if (i == best.base)
+				*tp++ = ':';
+			continue;
+		}
+		/* Are we following an initial run of 0x00s or any real hex? */
+		if (i != 0)
+			*tp++ = ':';
+		/* Is this address an encapsulated IPv4? */
+		if (i == 6 && best.base == 0 &&
+		    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {
+			if (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))
+				return (NULL);
+			tp += strlen(tp);
+			break;
+		}
+		tp += SPRINTF((tp, "%x", words[i]));
+	}
+	/* Was it a trailing run of 0x00's? */
+	if (best.base != -1 && (best.base + best.len) == 
+	    (NS_IN6ADDRSZ / NS_INT16SZ))
+		*tp++ = ':';
+	*tp++ = '\0';
+
+	/*
+	 * Check for overflow, copy, and we're done.
+	 */
+	if ((size_t)(tp - tmp) > size) {
+		errno = ENOSPC;
+		return (NULL);
+	}
+	strcpy(dst, tmp);
+	return (dst);
+}
