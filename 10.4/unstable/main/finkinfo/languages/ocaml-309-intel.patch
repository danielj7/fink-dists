diff -ur ocaml-3.09.1-orig/.depend ocaml/.depend
--- ocaml-3.09.1-orig/.depend	2005-10-26 08:23:27.000000000 -0500
+++ ocaml/.depend	2006-01-24 07:39:53.000000000 -0600
@@ -747,22 +747,24 @@
     bytecomp/emitcode.cmx bytecomp/dll.cmx typing/ctype.cmx \
     utils/consistbl.cmx utils/config.cmx utils/clflags.cmx \
     toplevel/topdirs.cmi 
-toplevel/toploop.cmo: utils/warnings.cmi typing/types.cmi typing/typemod.cmi \
-    typing/typedtree.cmi typing/typecore.cmi bytecomp/translmod.cmi \
-    bytecomp/symtable.cmi bytecomp/simplif.cmi typing/printtyp.cmi \
-    bytecomp/printlambda.cmi bytecomp/printinstr.cmi parsing/printast.cmi \
-    typing/predef.cmi typing/path.cmi parsing/parsetree.cmi parsing/parse.cmi \
+toplevel/toploop.cmo: utils/warnings.cmi typing/unused_var.cmi \
+    typing/types.cmi typing/typemod.cmi typing/typedtree.cmi \
+    typing/typecore.cmi bytecomp/translmod.cmi bytecomp/symtable.cmi \
+    bytecomp/simplif.cmi typing/printtyp.cmi bytecomp/printlambda.cmi \
+    bytecomp/printinstr.cmi parsing/printast.cmi typing/predef.cmi \
+    typing/path.cmi parsing/parsetree.cmi parsing/parse.cmi \
     typing/outcometree.cmi typing/oprint.cmi utils/misc.cmi bytecomp/meta.cmi \
     parsing/longident.cmi parsing/location.cmi parsing/lexer.cmi \
     typing/ident.cmi toplevel/genprintval.cmi driver/errors.cmi \
     typing/env.cmi bytecomp/emitcode.cmi bytecomp/dll.cmi utils/consistbl.cmi \
     utils/config.cmi driver/compile.cmi utils/clflags.cmi \
     bytecomp/bytegen.cmi typing/btype.cmi toplevel/toploop.cmi 
-toplevel/toploop.cmx: utils/warnings.cmx typing/types.cmx typing/typemod.cmx \
-    typing/typedtree.cmx typing/typecore.cmx bytecomp/translmod.cmx \
-    bytecomp/symtable.cmx bytecomp/simplif.cmx typing/printtyp.cmx \
-    bytecomp/printlambda.cmx bytecomp/printinstr.cmx parsing/printast.cmx \
-    typing/predef.cmx typing/path.cmx parsing/parsetree.cmi parsing/parse.cmx \
+toplevel/toploop.cmx: utils/warnings.cmx typing/unused_var.cmx \
+    typing/types.cmx typing/typemod.cmx typing/typedtree.cmx \
+    typing/typecore.cmx bytecomp/translmod.cmx bytecomp/symtable.cmx \
+    bytecomp/simplif.cmx typing/printtyp.cmx bytecomp/printlambda.cmx \
+    bytecomp/printinstr.cmx parsing/printast.cmx typing/predef.cmx \
+    typing/path.cmx parsing/parsetree.cmi parsing/parse.cmx \
     typing/outcometree.cmi typing/oprint.cmx utils/misc.cmx bytecomp/meta.cmx \
     parsing/longident.cmx parsing/location.cmx parsing/lexer.cmx \
     typing/ident.cmx toplevel/genprintval.cmx driver/errors.cmx \
Only in ocaml: CVS
diff -ur ocaml-3.09.1-orig/Changes ocaml/Changes
--- ocaml-3.09.1-orig/Changes	2006-01-04 07:05:49.000000000 -0600
+++ ocaml/Changes	2006-01-05 09:58:10.000000000 -0600
@@ -6,7 +6,7 @@
 - compilers: assert failure in typeclass.cml PR#3856
 - compilers: assert failure in typing/ctype.ml PR#3909
 - compilers: fatal error exception Ctype.Unify PR#3918
-- compilers: spurious warning Y PR#3868
+- compilers: spurious warning Y in objects PR#3868
 - compilers: spurious warning Z on loop index PR#3907
 - compilers: error message that emacs cannot parse
 - ocamlopt: problems with -for-pack/-pack PR#3825, PR#3826, PR#3919
@@ -2007,4 +2007,4 @@
 
 * First public release.
 
-$Id: Changes,v 1.156.2.3 2006/01/04 13:05:49 doligez Exp $
+$Id: Changes,v 1.156.2.4 2006/01/05 15:58:10 doligez Exp $
diff -ur ocaml-3.09.1-orig/Makefile ocaml/Makefile
--- ocaml-3.09.1-orig/Makefile	2005-09-24 11:20:36.000000000 -0500
+++ ocaml/Makefile	2006-02-09 03:17:23.000000000 -0600
@@ -10,7 +10,7 @@
 #                                                                       #
 #########################################################################
 
-# $Id: Makefile,v 1.199 2005/09/24 16:20:36 xleroy Exp $
+# $Id: Makefile,v 1.199.2.1 2006/02/09 09:17:23 garrigue Exp $
 
 # The main Makefile
 
@@ -226,8 +226,8 @@
 opt: runtimeopt ocamlopt libraryopt otherlibrariesopt camlp4opt
 
 # Native-code versions of the tools
-opt.opt: checkstack core ocaml opt-core ocamlc.opt otherlibraries camlp4out \
-	 $(DEBUGGER) ocamldoc ocamlopt.opt otherlibrariesopt \
+opt.opt: checkstack runtime core ocaml opt-core ocamlc.opt otherlibraries \
+	 camlp4out $(DEBUGGER) ocamldoc ocamlopt.opt otherlibrariesopt \
 	 camlp4opt ocamllex.opt ocamltoolsopt.opt camlp4optopt ocamldoc.opt
 
 # Installation
Only in ocaml/asmcomp: CVS
Only in ocaml/asmcomp/alpha: CVS
Only in ocaml/asmcomp/amd64: CVS
Only in ocaml/asmcomp/arm: CVS
Only in ocaml/asmcomp/hppa: CVS
Only in ocaml/asmcomp/i386: CVS
diff -ur ocaml-3.09.1-orig/asmcomp/i386/arch.ml ocaml/asmcomp/i386/arch.ml
--- ocaml-3.09.1-orig/asmcomp/i386/arch.ml	2003-02-25 09:50:12.000000000 -0600
+++ ocaml/asmcomp/i386/arch.ml	2006-03-01 07:46:56.000000000 -0600
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: arch.ml,v 1.12 2003/02/25 15:50:12 xleroy Exp $ *)
+(* $Id: arch.ml,v 1.12.18.1 2006/03/01 13:46:56 xleroy Exp $ *)
 
 (* Machine-specific command-line options *)
 
@@ -145,3 +145,10 @@
         printreg ppf arg.(i)
       done
       
+(* Stack alignment constraints *)
+
+let stack_alignment =
+  match Config.system with
+  | "macosx" -> 16
+  | _ -> 4
+
diff -ur ocaml-3.09.1-orig/asmcomp/i386/emit.mlp ocaml/asmcomp/i386/emit.mlp
--- ocaml-3.09.1-orig/asmcomp/i386/emit.mlp	2004-11-30 11:07:11.000000000 -0600
+++ ocaml/asmcomp/i386/emit.mlp	2006-03-01 07:46:56.000000000 -0600
@@ -10,10 +10,12 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: emit.mlp,v 1.35 2004/11/30 17:07:11 xleroy Exp $ *)
+(* $Id: emit.mlp,v 1.35.4.1 2006/03/01 13:46:56 xleroy Exp $ *)
 
 (* Emission of Intel 386 assembly code *)
 
+module StringSet = Set.Make(struct type t = string let compare = compare end)
+
 open Location
 open Misc
 open Cmm
@@ -33,7 +35,9 @@
 (* Layout of the stack frame *)
 
 let frame_size () =                     (* includes return address *)
-  !stack_offset + 4 * num_stack_slots.(0) + 8 * num_stack_slots.(1) + 4
+  let sz = 
+    !stack_offset + 4 * num_stack_slots.(0) + 8 * num_stack_slots.(1) + 4
+  in Misc.align sz stack_alignment
 
 let slot_offset loc cl =
   match loc with
@@ -48,6 +52,8 @@
       assert (n >= 0);
       n
 
+let trap_frame_size = Misc.align 8 stack_alignment
+
 (* Prefixing of symbols with "_" *)
 
 let symbol_prefix =
@@ -90,6 +96,14 @@
     "solaris" -> false
   | _ -> true
 
+(* MacOSX has its own way to reference symbols potentially defined in 
+   shared objects *)
+
+let macosx =
+  match Config.system with
+  | "macosx" -> true
+  | _ -> false
+
 (* Output a .align directive.
    The numerical argument to .align is log2 of alignment size, except
    under ELF, where it is the alignment size... *)
@@ -378,6 +392,9 @@
 let range_check_trap = ref 0
 (* Record float literals to be emitted later *)
 let float_constants = ref ([] : (int * string) list)
+(* Record references to external C functions (for MacOSX) *)
+let external_symbols_direct = ref StringSet.empty
+let external_symbols_indirect = ref StringSet.empty
 
 let emit_instr fallthrough i =
     match i.desc with
@@ -439,11 +456,23 @@
         end
     | Lop(Iextcall(s, alloc)) ->
         if alloc then begin
-          `	movl	${emit_symbol s}, %eax\n`;
+          if not macosx then
+            `	movl	${emit_symbol s}, %eax\n`
+          else begin
+            external_symbols_indirect :=
+              StringSet.add s !external_symbols_indirect;
+            `	movl	L{emit_symbol s}$non_lazy_ptr, %eax\n`
+          end;
           `	call	{emit_symbol "caml_c_call"}\n`;
           record_frame i.live
         end else begin
-          `	call	{emit_symbol s}\n`
+          if not macosx then
+            `	call	{emit_symbol s}\n`
+          else begin
+            external_symbols_direct :=
+              StringSet.add s !external_symbols_direct;
+            `	call	L{emit_symbol s}$stub\n`
+          end
         end
     | Lop(Istackoffset n) ->
         if n < 0
@@ -734,16 +763,20 @@
     | Lsetuptrap lbl ->
         `	call	{emit_label lbl}\n`
     | Lpushtrap ->
+        if trap_frame_size > 8 then
+          `	subl	${emit_int (trap_frame_size - 8)}, %esp\n`;
         `	pushl	{emit_symbol "caml_exception_pointer"}\n`;
         `	movl	%esp, {emit_symbol "caml_exception_pointer"}\n`;
-        stack_offset := !stack_offset + 8
+        stack_offset := !stack_offset + trap_frame_size
     | Lpoptrap ->
         `	popl	{emit_symbol "caml_exception_pointer"}\n`;
-        `	addl	$4, %esp\n`;
-        stack_offset := !stack_offset - 8
+        `	addl	${emit_int (trap_frame_size - 4)}, %esp\n`;
+        stack_offset := !stack_offset - trap_frame_size
     | Lraise ->
         `	movl	{emit_symbol "caml_exception_pointer"}, %esp\n`;
         `	popl    {emit_symbol "caml_exception_pointer"}\n`;
+        if trap_frame_size > 8 then
+          `	addl	${emit_int (trap_frame_size - 8)}, %esp\n`;
         `	ret\n`
 
 let rec emit_all fallthrough i =
@@ -762,6 +795,26 @@
   `	.data\n`;
   `{emit_label lbl}:	.double	{emit_string cst}\n`
 
+(* Emission of external symbol references (for MacOSX) *)
+
+let emit_external_symbol_direct s =
+  `L{emit_symbol s}$stub:\n`;
+  `	.indirect_symbol {emit_symbol s}\n`;
+  `	hlt ; hlt ; hlt ; hlt ; hlt\n`
+
+let emit_external_symbol_indirect s =
+  `L{emit_symbol s}$non_lazy_ptr:\n`;
+  `	.indirect_symbol {emit_symbol s}\n`;
+  `	.long	0\n`
+
+let emit_external_symbols () =
+  `	.section __IMPORT,__pointers,non_lazy_symbol_pointers\n`;
+  StringSet.iter emit_external_symbol_indirect !external_symbols_indirect;
+  external_symbols_indirect := StringSet.empty;
+  `	.section __IMPORT,__jump_table,symbol_stubs,self_modifying_code+pure_instructions,5\n`;
+  StringSet.iter emit_external_symbol_direct !external_symbols_direct;
+  external_symbols_direct := StringSet.empty
+
 (* Emission of the profiling prelude *)
 
 let emit_profile () =
@@ -886,4 +939,5 @@
   `{emit_symbol lbl}:\n`;
   `	.long	{emit_int (List.length !frame_descriptors)}\n`;
   List.iter emit_frame !frame_descriptors;
-  frame_descriptors := []
+  frame_descriptors := [];
+  if macosx then emit_external_symbols ()
diff -ur ocaml-3.09.1-orig/asmcomp/i386/selection.ml ocaml/asmcomp/i386/selection.ml
--- ocaml-3.09.1-orig/asmcomp/i386/selection.ml	2003-02-25 09:50:13.000000000 -0600
+++ ocaml/asmcomp/i386/selection.ml	2006-03-01 07:46:56.000000000 -0600
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: selection.ml,v 1.13 2003/02/25 15:50:13 xleroy Exp $ *)
+(* $Id: selection.ml,v 1.13.18.1 2006/03/01 13:46:56 xleroy Exp $ *)
 
 (* Instruction selection for the Intel x86 *)
 
@@ -159,6 +159,15 @@
 
 method is_immediate (n : int) = true
 
+method is_simple_expr e =
+  match e with
+  | Cop(Cextcall(fn, _, alloc), args)
+    when !fast_math && List.mem fn inline_float_ops ->
+      (* inlined float ops are simple if their arguments are *)
+      List.for_all self#is_simple_expr args
+  | _ ->
+      super#is_simple_expr e
+
 method select_addressing exp =
   match select_addr exp with
     (Asymbol s, d) ->
@@ -291,18 +300,23 @@
   | _ -> (Ispecific(Ipush), exp)
 
 method emit_extcall_args env args =
+  let rec size_pushes = function
+  | [] -> 0
+  | e :: el -> Selectgen.size_expr env e + size_pushes el in
+  let sz1 = size_pushes args in
+  let sz2 = Misc.align sz1 stack_alignment in
   let rec emit_pushes = function
-    [] -> 0
+  | [] ->
+      if sz2 > sz1 then 
+        self#insert (Iop (Istackoffset (sz2 - sz1))) [||] [||]
   | e :: el ->
-      let ofs = emit_pushes el in
+      emit_pushes el;
       let (op, arg) = self#select_push e in
-      begin match self#emit_expr env arg with
-        None -> ofs
-      | Some r ->
-          self#insert (Iop op) r [||];
-          ofs + Selectgen.size_expr env e
-      end
-  in ([||], emit_pushes args)
+      match self#emit_expr env arg with
+      | None -> ()
+      | Some r -> self#insert (Iop op) r [||] in
+  emit_pushes args;
+  ([||], sz2)
 
 end
 
Only in ocaml/asmcomp/ia64: CVS
Only in ocaml/asmcomp/m68k: CVS
Only in ocaml/asmcomp/mips: CVS
Only in ocaml/asmcomp/power: CVS
diff -ur ocaml-3.09.1-orig/asmcomp/selectgen.ml ocaml/asmcomp/selectgen.ml
--- ocaml-3.09.1-orig/asmcomp/selectgen.ml	2003-02-25 09:50:12.000000000 -0600
+++ ocaml/asmcomp/selectgen.ml	2006-03-01 07:46:56.000000000 -0600
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: selectgen.ml,v 1.30 2003/02/25 15:50:12 xleroy Exp $ *)
+(* $Id: selectgen.ml,v 1.30.18.1 2006/03/01 13:46:56 xleroy Exp $ *)
 
 (* Selection of pseudo-instructions, assignment of pseudo-registers,
    sequentialization. *)
@@ -76,46 +76,6 @@
         fatal_error "Selection.size_expr"
   in size Tbl.empty exp
 
-(* These are C library functions that are known to be pure
-   (no side effects at all) and worth not pre-computing. *)
-
-let pure_external_functions =
-  ["acos"; "asin"; "atan"; "atan2"; "cos"; "exp"; "log";
-   "log10"; "sin"; "sqrt"; "tan"]
-
-(* Says if an expression is "simple". A "simple" expression has no
-   side-effects and its execution can be delayed until its value
-   is really needed. In the case of e.g. an [alloc] instruction,
-   the non-simple arguments are computed in right-to-left order
-   first, then the block is allocated, then the simple arguments are
-   evaluated and stored. *)
-
-let rec is_simple_expr = function
-    Cconst_int _ -> true
-  | Cconst_natint _ -> true
-  | Cconst_float _ -> true
-  | Cconst_symbol _ -> true
-  | Cconst_pointer _ -> true
-  | Cconst_natpointer _ -> true
-  | Cvar _ -> true
-  | Ctuple el -> List.for_all is_simple_expr el
-  | Clet(id, arg, body) -> is_simple_expr arg && is_simple_expr body
-  | Csequence(e1, e2) -> is_simple_expr e1 && is_simple_expr e2
-  | Cop(op, args) ->
-      begin match op with
-        (* The following may have side effects *)
-      | Capply _ | Calloc | Cstore _ | Craise -> false
-        (* External C functions normally have side effects, unless known *)
-      | Cextcall(fn, _, alloc) ->
-          not alloc &&
-          List.mem fn pure_external_functions &&
-          List.for_all is_simple_expr args
-        (* The remaining operations are simple if their args are *)
-      | _ ->
-          List.for_all is_simple_expr args
-      end
-  | _ -> false
-
 (* Swap the two arguments of an integer comparison *)
 
 let swap_intcomp = function
@@ -201,6 +161,34 @@
 
 class virtual selector_generic = object (self)
 
+(* Says if an expression is "simple". A "simple" expression has no
+   side-effects and its execution can be delayed until its value
+   is really needed. In the case of e.g. an [alloc] instruction,
+   the non-simple arguments are computed in right-to-left order
+   first, then the block is allocated, then the simple arguments are
+   evaluated and stored. *)
+
+method is_simple_expr = function
+    Cconst_int _ -> true
+  | Cconst_natint _ -> true
+  | Cconst_float _ -> true
+  | Cconst_symbol _ -> true
+  | Cconst_pointer _ -> true
+  | Cconst_natpointer _ -> true
+  | Cvar _ -> true
+  | Ctuple el -> List.for_all self#is_simple_expr el
+  | Clet(id, arg, body) -> self#is_simple_expr arg && self#is_simple_expr body
+  | Csequence(e1, e2) -> self#is_simple_expr e1 && self#is_simple_expr e2
+  | Cop(op, args) ->
+      begin match op with
+        (* The following may have side effects *)
+      | Capply _ | Cextcall(_, _, _) | Calloc | Cstore _ | Craise -> false
+        (* The remaining operations are simple if their args are *)
+      | _ ->
+          List.for_all self#is_simple_expr args
+      end
+  | _ -> false
+
 (* Says whether an integer constant is a suitable immediate argument *)
 
 method virtual is_immediate : int -> bool
@@ -591,7 +579,7 @@
   end
 
 method private emit_parts env exp =
-  if is_simple_expr exp then
+  if self#is_simple_expr exp then
     Some (exp, env)
   else begin
     match self#emit_expr env exp with
diff -ur ocaml-3.09.1-orig/asmcomp/selectgen.mli ocaml/asmcomp/selectgen.mli
--- ocaml-3.09.1-orig/asmcomp/selectgen.mli	2002-11-04 10:25:09.000000000 -0600
+++ ocaml/asmcomp/selectgen.mli	2006-03-01 07:46:56.000000000 -0600
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: selectgen.mli,v 1.6 2002/11/04 16:25:09 xleroy Exp $ *)
+(* $Id: selectgen.mli,v 1.6.18.1 2006/03/01 13:46:56 xleroy Exp $ *)
 
 (* Selection of pseudo-instructions, assignment of pseudo-registers,
    sequentialization. *)
@@ -28,6 +28,8 @@
   method virtual select_addressing :
     Cmm.expression -> Arch.addressing_mode * Cmm.expression
     (* Must be defined to select addressing modes *)
+  method is_simple_expr: Cmm.expression -> bool
+    (* Can be overriden to reflect special extcalls known to be pure *)
   method select_operation :
     Cmm.operation ->
     Cmm.expression list -> Mach.operation * Cmm.expression list
Only in ocaml/asmcomp/sparc: CVS
Only in ocaml/asmrun: CVS
diff -ur ocaml-3.09.1-orig/asmrun/i386.S ocaml/asmrun/i386.S
--- ocaml-3.09.1-orig/asmrun/i386.S	2004-08-12 08:37:12.000000000 -0500
+++ ocaml/asmrun/i386.S	2006-03-01 07:46:56.000000000 -0600
@@ -11,7 +11,7 @@
 /*                                                                     */
 /***********************************************************************/
 
-/* $Id: i386.S,v 1.43 2004/08/12 13:37:12 xleroy Exp $ */
+/* $Id: i386.S,v 1.43.4.1 2006/03/01 13:46:56 xleroy Exp $ */
 
 /* Asm part of the runtime system, Intel 386 processor */
 /* Must be preprocessed by cpp */
@@ -208,8 +208,12 @@
         pushl   G(caml_gc_regs)
         pushl   G(caml_last_return_address)
         pushl   G(caml_bottom_of_stack)
+        /* Note: 16-alignment preserved on MacOSX at this point */
     /* Build an exception handler */
         pushl   $ LBL(108)
+#ifdef SYS_macosx
+        subl	$8, %esp     /* 16-alignment */
+#endif
         pushl   G(caml_exception_pointer)
         movl    %esp, G(caml_exception_pointer)
     /* Call the Caml code */
@@ -217,7 +221,11 @@
 LBL(107):
     /* Pop the exception handler */
         popl    G(caml_exception_pointer)
-        popl    %esi    /* dummy register */
+#ifdef SYS_macosx
+        addl	$12, %esp
+#else
+        addl	$4, %esp
+#endif
 LBL(109):
     /* Pop the callback link, restoring the global variables */
         popl    G(caml_bottom_of_stack)
@@ -245,6 +253,9 @@
         movl    4(%esp), %eax
         movl    G(caml_exception_pointer), %esp
         popl    G(caml_exception_pointer)
+#ifdef SYS_macosx
+        addl	$8, %esp
+#endif
         ret
 
 /* Callback from C to Caml */
diff -ur ocaml-3.09.1-orig/asmrun/signals.c ocaml/asmrun/signals.c
--- ocaml-3.09.1-orig/asmrun/signals.c	2005-10-13 02:41:34.000000000 -0500
+++ ocaml/asmrun/signals.c	2006-03-22 07:13:45.000000000 -0600
@@ -11,7 +11,7 @@
 /*                                                                     */
 /***********************************************************************/
 
-/* $Id: signals.c,v 1.93 2005/10/13 07:41:34 xleroy Exp $ */
+/* $Id: signals.c,v 1.93.2.1 2006/03/22 13:13:45 xleroy Exp $ */
 
 #if defined(TARGET_amd64) && defined (SYS_linux)
 #define _GNU_SOURCE
@@ -52,18 +52,23 @@
   ((char *)(pc) >= caml_code_area_start && \
    (char *)(pc) <= caml_code_area_end)
 
+intnat volatile caml_signals_are_pending = 0;
 volatile intnat caml_pending_signals[NSIG];
 volatile int caml_force_major_slice = 0;
 value caml_signal_handlers = 0;
 
 static void caml_process_pending_signals(void)
 {
-  int signal_num;
-  intnat signal_state;
+  int i;
 
-  for (signal_num = 0; signal_num < NSIG; signal_num++) {
-    Read_and_clear(signal_state, caml_pending_signals[signal_num]);
-    if (signal_state) caml_execute_signal(signal_num, 0);
+  if (caml_signals_are_pending) {
+    caml_signals_are_pending = 0;
+    for (i = 0; i < NSIG; i++) {
+      if (caml_pending_signals[i]) {
+        caml_pending_signals[i] = 0;
+        caml_execute_signal(i, 0);
+      }
+    }
   }
 }
 
@@ -132,6 +137,7 @@
 void caml_record_signal(int signal_number)
 {
   caml_pending_signals[signal_number] = 1;
+  caml_signals_are_pending = 1;
   caml_young_limit = caml_young_end;
 }
 
@@ -153,10 +159,7 @@
   if (caml_young_ptr < caml_young_start || caml_force_major_slice) {
     caml_minor_collection();
   }
-  for (signal_number = 0; signal_number < NSIG; signal_number++) {
-    Read_and_clear(signal_state, caml_pending_signals[signal_number]);
-    if (signal_state) caml_execute_signal(signal_number, 0);
-  }
+  caml_process_pending_signals();
 }
 
 /* Trigger a garbage collection as soon as possible */
@@ -173,18 +176,13 @@
 
 void caml_enter_blocking_section(void)
 {
-  int i;
-  intnat pending;
-
   while (1){
     /* Process all pending signals now */
     caml_process_pending_signals();
     caml_enter_blocking_section_hook ();
-    /* Check again for pending signals. */
-    pending = 0;
-    for (i = 0; i < NSIG; i++) pending |= caml_pending_signals[i];
-    /* If none, done; otherwise, try again */
-    if (!pending) break;
+    /* Check again for pending signals.
+       If none, done; otherwise, try again */
+    if (! caml_signals_are_pending) break;
     caml_leave_blocking_section_hook ();
   }
 }
diff -ur ocaml-3.09.1-orig/asmrun/stack.h ocaml/asmrun/stack.h
--- ocaml-3.09.1-orig/asmrun/stack.h	2005-09-22 09:21:47.000000000 -0500
+++ ocaml/asmrun/stack.h	2006-03-01 07:46:56.000000000 -0600
@@ -11,7 +11,7 @@
 /*                                                                     */
 /***********************************************************************/
 
-/* $Id: stack.h,v 1.29 2005/09/22 14:21:47 xleroy Exp $ */
+/* $Id: stack.h,v 1.29.2.1 2006/03/01 13:46:56 xleroy Exp $ */
 
 /* Machine-dependent interface with the asm code */
 
@@ -34,8 +34,12 @@
 
 #ifdef TARGET_i386
 #define Saved_return_address(sp) *((intnat *)((sp) - 4))
+#ifdef SYS_macosx
+#define Callback_link(sp) ((struct caml_context *)((sp) + 16))
+#else
 #define Callback_link(sp) ((struct caml_context *)((sp) + 8))
 #endif
+#endif
 
 #ifdef TARGET_mips
 #define Saved_return_address(sp) *((intnat *)((sp) - 4))
Only in ocaml/boot: CVS
Binary files ocaml-3.09.1-orig/boot/ocamlc and ocaml/boot/ocamlc differ
Binary files ocaml-3.09.1-orig/boot/ocamllex and ocaml/boot/ocamllex differ
Only in ocaml/bytecomp: CVS
diff -ur ocaml-3.09.1-orig/bytecomp/translclass.ml ocaml/bytecomp/translclass.ml
--- ocaml-3.09.1-orig/bytecomp/translclass.ml	2005-08-13 15:59:37.000000000 -0500
+++ ocaml/bytecomp/translclass.ml	2006-03-07 20:05:42.000000000 -0600
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: translclass.ml,v 1.38 2005/08/13 20:59:37 doligez Exp $ *)
+(* $Id: translclass.ml,v 1.38.2.1 2006/03/08 02:05:42 garrigue Exp $ *)
 
 open Misc
 open Asttypes
@@ -633,6 +633,7 @@
         begin try
           (* Doesn't seem to improve size for bytecode *)
           (* if not !Clflags.native_code then raise Not_found; *)
+          if !Clflags.debug then raise Not_found;
           builtin_meths arr [self] env env2 (lfunction args body')
         with Not_found ->
           [lfunction (self :: args)
Only in ocaml/byterun: CVS
diff -ur ocaml-3.09.1-orig/byterun/io.c ocaml/byterun/io.c
--- ocaml-3.09.1-orig/byterun/io.c	2005-10-25 14:15:36.000000000 -0500
+++ ocaml/byterun/io.c	2006-03-22 06:59:58.000000000 -0600
@@ -11,7 +11,7 @@
 /*                                                                     */
 /***********************************************************************/
 
-/* $Id: io.c,v 1.72 2005/10/25 19:15:36 mauny Exp $ */
+/* $Id: io.c,v 1.72.2.1 2006/03/22 12:59:58 doligez Exp $ */
 
 /* Buffered input/output. */
 
@@ -230,7 +230,7 @@
   }
 }
 
-CAMLexport void caml_really_putblock(struct channel *channel, 
+CAMLexport void caml_really_putblock(struct channel *channel,
                                      char *p, intnat len)
 {
   int written;
@@ -450,7 +450,7 @@
   res = Val_emptylist;
   for (channel = caml_all_opened_channels;
        channel != NULL;
-       channel = channel->next) 
+       channel = channel->next)
     /* Testing channel->fd >= 0 looks unnecessary, as
        caml_ml_close_channel changes max when setting fd to -1. */
     if (channel->max == NULL) {
@@ -530,6 +530,7 @@
 
 CAMLprim value caml_ml_flush_partial(value vchannel)
 {
+  CAMLparam1 (vchannel);
   struct channel * channel = Channel(vchannel);
   int res;
 
@@ -537,36 +538,41 @@
   Lock(channel);
   res = caml_flush_partial(channel);
   Unlock(channel);
-  return Val_bool(res);
+  CAMLreturn (Val_bool(res));
 }
 
 CAMLprim value caml_ml_flush(value vchannel)
 {
+  CAMLparam1 (vchannel);
   struct channel * channel = Channel(vchannel);
 
   if (channel->fd == -1) return Val_unit;
   Lock(channel);
   caml_flush(channel);
   Unlock(channel);
-  return Val_unit;
+  CAMLreturn (Val_unit);
 }
 
 CAMLprim value caml_ml_output_char(value vchannel, value ch)
 {
+  CAMLparam2 (vchannel, ch);
   struct channel * channel = Channel(vchannel);
+
   Lock(channel);
   putch(channel, Long_val(ch));
   Unlock(channel);
-  return Val_unit;
+  CAMLreturn (Val_unit);
 }
 
 CAMLprim value caml_ml_output_int(value vchannel, value w)
 {
+  CAMLparam2 (vchannel, w);
   struct channel * channel = Channel(vchannel);
+
   Lock(channel);
   caml_putword(channel, Long_val(w));
   Unlock(channel);
-  return Val_unit;
+  CAMLreturn (Val_unit);
 }
 
 CAMLprim value caml_ml_output_partial(value vchannel, value buff, value start,
@@ -602,20 +608,24 @@
 
 CAMLprim value caml_ml_seek_out(value vchannel, value pos)
 {
+  CAMLparam2 (vchannel, pos);
   struct channel * channel = Channel(vchannel);
+
   Lock(channel);
   caml_seek_out(channel, Long_val(pos));
   Unlock(channel);
-  return Val_unit;
+  CAMLreturn (Val_unit);
 }
 
 CAMLprim value caml_ml_seek_out_64(value vchannel, value pos)
 {
+  CAMLparam2 (vchannel, pos);
   struct channel * channel = Channel(vchannel);
+
   Lock(channel);
   caml_seek_out(channel, File_offset_val(pos));
   Unlock(channel);
-  return Val_unit;
+  CAMLreturn (Val_unit);
 }
 
 CAMLprim value caml_ml_pos_out(value vchannel)
@@ -632,17 +642,19 @@
 
 CAMLprim value caml_ml_input_char(value vchannel)
 {
+  CAMLparam1 (vchannel);
   struct channel * channel = Channel(vchannel);
   unsigned char c;
 
   Lock(channel);
   c = getch(channel);
   Unlock(channel);
-  return Val_long(c);
+  CAMLreturn (Val_long(c));
 }
 
 CAMLprim value caml_ml_input_int(value vchannel)
 {
+  CAMLparam1 (vchannel);
   struct channel * channel = Channel(vchannel);
   intnat i;
 
@@ -652,7 +664,7 @@
 #ifdef ARCH_SIXTYFOUR
   i = (i << 32) >> 32;          /* Force sign extension */
 #endif
-  return Val_long(i);
+  CAMLreturn (Val_long(i));
 }
 
 CAMLprim value caml_ml_input(value vchannel, value buff, value vstart,
@@ -692,20 +704,24 @@
 
 CAMLprim value caml_ml_seek_in(value vchannel, value pos)
 {
+  CAMLparam2 (vchannel, pos);
   struct channel * channel = Channel(vchannel);
+
   Lock(channel);
   caml_seek_in(channel, Long_val(pos));
   Unlock(channel);
-  return Val_unit;
+  CAMLreturn (Val_unit);
 }
 
 CAMLprim value caml_ml_seek_in_64(value vchannel, value pos)
 {
+  CAMLparam2 (vchannel, pos);
   struct channel * channel = Channel(vchannel);
+
   Lock(channel);
   caml_seek_in(channel, File_offset_val(pos));
   Unlock(channel);
-  return Val_unit;
+  CAMLreturn (Val_unit);
 }
 
 CAMLprim value caml_ml_pos_in(value vchannel)
@@ -722,13 +738,14 @@
 
 CAMLprim value caml_ml_input_scan_line(value vchannel)
 {
+  CAMLparam1 (vchannel);
   struct channel * channel = Channel(vchannel);
   intnat res;
 
   Lock(channel);
   res = caml_input_scan_line(channel);
   Unlock(channel);
-  return Val_long(res);
+  CAMLreturn (Val_long(res));
 }
 
 /* Conversion between file_offset and int64 */
diff -ur ocaml-3.09.1-orig/byterun/md5.c ocaml/byterun/md5.c
--- ocaml-3.09.1-orig/byterun/md5.c	2005-09-22 09:21:50.000000000 -0500
+++ ocaml/byterun/md5.c	2006-03-22 06:59:58.000000000 -0600
@@ -11,12 +11,13 @@
 /*                                                                     */
 /***********************************************************************/
 
-/* $Id: md5.c,v 1.19 2005/09/22 14:21:50 xleroy Exp $ */
+/* $Id: md5.c,v 1.19.2.1 2006/03/22 12:59:58 doligez Exp $ */
 
 #include <string.h>
 #include "alloc.h"
 #include "fail.h"
 #include "md5.h"
+#include "memory.h"
 #include "mlvalues.h"
 #include "io.h"
 #include "reverse.h"
@@ -36,6 +37,7 @@
 
 CAMLprim value caml_md5_chan(value vchan, value len)
 {
+  CAMLparam2 (vchan, len);
   struct channel * chan = Channel(vchan);
   struct MD5Context ctx;
   value res;
@@ -63,7 +65,7 @@
   res = caml_alloc_string(16);
   caml_MD5Final(&Byte_u(res, 0), &ctx);
   Unlock(chan);
-  return res;
+  CAMLreturn (res);
 }
 
 /*
@@ -163,7 +165,7 @@
 }
 
 /*
- * Final wrapup - pad to 64-byte boundary with the bit pattern 
+ * Final wrapup - pad to 64-byte boundary with the bit pattern
  * 1 0* (64-bit count of bits processed, MSB-first)
  */
 CAMLexport void caml_MD5Final(unsigned char *digest, struct MD5Context *ctx)
diff -ur ocaml-3.09.1-orig/byterun/signals.c ocaml/byterun/signals.c
--- ocaml-3.09.1-orig/byterun/signals.c	2005-10-12 07:33:47.000000000 -0500
+++ ocaml/byterun/signals.c	2006-03-22 07:13:45.000000000 -0600
@@ -11,7 +11,7 @@
 /*                                                                     */
 /***********************************************************************/
 
-/* $Id: signals.c,v 1.51 2005/10/12 12:33:47 xleroy Exp $ */
+/* $Id: signals.c,v 1.51.2.1 2006/03/22 13:13:45 xleroy Exp $ */
 
 #include <signal.h>
 #include "alloc.h"
@@ -36,6 +36,7 @@
 #define signal(sig,act) caml_win32_signal(sig,act)
 #endif
 
+CAMLexport intnat volatile caml_signals_are_pending = 0;
 CAMLexport intnat volatile caml_pending_signals[NSIG];
 CAMLexport int volatile caml_something_to_do = 0;
 int volatile caml_force_major_slice = 0;
@@ -44,12 +45,16 @@
 
 static void caml_process_pending_signals(void)
 {
-  int signal_num;
-  intnat signal_state;
+  int i;
 
-  for (signal_num = 0; signal_num < NSIG; signal_num++) {
-    Read_and_clear(signal_state, caml_pending_signals[signal_num]);
-    if (signal_state) caml_execute_signal(signal_num, 0);
+  if (caml_signals_are_pending) {
+    caml_signals_are_pending = 0;
+    for (i = 0; i < NSIG; i++) {
+      if (caml_pending_signals[i]) {
+        caml_pending_signals[i] = 0;
+        caml_execute_signal(i, 0);
+      }
+    }
   }
 }
 
@@ -60,8 +65,11 @@
   if (caml_force_major_slice) caml_minor_collection ();
                              /* FIXME should be [caml_check_urgent_gc] */
   caml_process_pending_signals();
-  Read_and_clear(async_action, caml_async_action_hook);
-  if (async_action != NULL) (*async_action)();
+  async_action = caml_async_action_hook;
+  if (async_action != NULL) {
+    caml_async_action_hook = NULL;
+    (*async_action)();
+  }
 }
 
 static intnat volatile caml_async_signal_mode = 0;
@@ -129,6 +137,7 @@
 void caml_record_signal(int signal_number)
 {
   caml_pending_signals[signal_number] = 1;
+  caml_signals_are_pending = 1;
   caml_something_to_do = 1;
 }
 
@@ -154,18 +163,13 @@
 
 CAMLexport void caml_enter_blocking_section(void)
 {
-  int i;
-  intnat pending;
-
   while (1){
     /* Process all pending signals now */
     caml_process_pending_signals();
     caml_enter_blocking_section_hook ();
-    /* Check again for pending signals. */
-    pending = 0;
-    for (i = 0; i < NSIG; i++) pending |= caml_pending_signals[i];
-    /* If none, done; otherwise, try again */
-    if (!pending) break;
+    /* Check again for pending signals.
+       If none, done; otherwise, try again */
+    if (! caml_signals_are_pending) break;
     caml_leave_blocking_section_hook ();
   }
 }
diff -ur ocaml-3.09.1-orig/byterun/signals.h ocaml/byterun/signals.h
--- ocaml-3.09.1-orig/byterun/signals.h	2005-10-12 07:33:47.000000000 -0500
+++ ocaml/byterun/signals.h	2006-03-22 07:13:45.000000000 -0600
@@ -11,7 +11,7 @@
 /*                                                                     */
 /***********************************************************************/
 
-/* $Id: signals.h,v 1.25 2005/10/12 12:33:47 xleroy Exp $ */
+/* $Id: signals.h,v 1.25.2.1 2006/03/22 13:13:45 xleroy Exp $ */
 
 #ifndef CAML_SIGNALS_H
 #define CAML_SIGNALS_H
@@ -24,6 +24,7 @@
 
 /* <private> */
 extern value caml_signal_handlers;
+CAMLextern intnat volatile caml_signals_are_pending;
 CAMLextern intnat volatile caml_pending_signals[];
 CAMLextern int volatile caml_something_to_do;
 extern int volatile caml_force_major_slice;
Only in ocaml/camlp4: CVS
Only in ocaml/camlp4/boot: CVS
Only in ocaml/camlp4/camlp4: CVS
diff -ur ocaml-3.09.1-orig/camlp4/camlp4/argl.ml ocaml/camlp4/camlp4/argl.ml
--- ocaml-3.09.1-orig/camlp4/camlp4/argl.ml	2005-10-21 05:55:32.000000000 -0500
+++ ocaml/camlp4/camlp4/argl.ml	2006-01-11 11:44:58.000000000 -0600
@@ -1,5 +1,5 @@
 (* camlp4r q_MLast.cmo *)
-(* $Id: argl.ml,v 1.18 2005/10/21 10:55:32 mauny Exp $ *)
+(* $Id: argl.ml,v 1.18.2.1 2006/01/11 17:44:58 mauny Exp $ *)
 
 open Printf;
 
@@ -132,6 +132,8 @@
 
 value rec parse_file pa getdir useast =
   let name = Pcaml.input_file.val in
+  let (_,_,fname) = Pcaml.position.val in
+  let () = fname.val := name in
   do {
     Pcaml.warning.val := print_warning;
     let ic = if name = "-" then stdin else open_in_bin name in
Only in ocaml/camlp4/compile: CVS
Only in ocaml/camlp4/config: CVS
Only in ocaml/camlp4/etc: CVS
diff -ur ocaml-3.09.1-orig/camlp4/etc/pr_o.ml ocaml/camlp4/etc/pr_o.ml
--- ocaml-3.09.1-orig/camlp4/etc/pr_o.ml	2006-01-03 12:12:30.000000000 -0600
+++ ocaml/camlp4/etc/pr_o.ml	2006-01-05 04:44:21.000000000 -0600
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: pr_o.ml,v 1.49.2.1 2006/01/03 18:12:30 mauny Exp $ *)
+(* $Id: pr_o.ml,v 1.49.2.2 2006/01/05 10:44:21 mauny Exp $ *)
 
 open Pcaml;
 open Spretty;
@@ -1408,7 +1408,8 @@
         <:expr< while $_$ do { $list:_$ } >> | <:expr< ($list: _$) >> |
         <:expr< let $opt:_$ $list:_$ in $_$ >> |
         <:expr< let module $_$ = $_$ in $_$ >> |
-        <:expr< new $list:_$ >> | 
+	(* Note: `new' is treated differently in pa_o and in pa_r,
+	   and should not occur at this level *)
         <:expr< assert $_$ >> | <:expr< lazy $_$ >> as e ->
           fun curr next dg k ->
             [: `S LO "("; `expr e "" [: `HVbox [: `S RO ")"; k :] :] :]
Only in ocaml/camlp4/lib: CVS
Only in ocaml/camlp4/man: CVS
Only in ocaml/camlp4/meta: CVS
Only in ocaml/camlp4/ocaml_src: CVS
Only in ocaml/camlp4/ocaml_src/camlp4: CVS
diff -ur ocaml-3.09.1-orig/camlp4/ocaml_src/camlp4/argl.ml ocaml/camlp4/ocaml_src/camlp4/argl.ml
--- ocaml-3.09.1-orig/camlp4/ocaml_src/camlp4/argl.ml	2005-10-21 05:55:32.000000000 -0500
+++ ocaml/camlp4/ocaml_src/camlp4/argl.ml	2006-01-11 11:44:58.000000000 -0600
@@ -137,6 +137,8 @@
 
 let rec parse_file pa getdir useast =
   let name = !(Pcaml.input_file) in
+  let (_, _, fname) = !(Pcaml.position) in
+  let () = fname := name in
   Pcaml.warning := print_warning;
   let ic = if name = "-" then stdin else open_in_bin name in
   let cs = Stream.of_channel ic in
Only in ocaml/camlp4/ocaml_src/lib: CVS
Only in ocaml/camlp4/ocaml_src/meta: CVS
Only in ocaml/camlp4/ocaml_src/odyl: CVS
Only in ocaml/camlp4/ocaml_src/tools: CVS
Only in ocaml/camlp4/ocaml_stuff: CVS
Only in ocaml/camlp4/ocaml_stuff/otherlibs: CVS
Only in ocaml/camlp4/ocaml_stuff/otherlibs/dynlink: CVS
Only in ocaml/camlp4/ocaml_stuff/parsing: CVS
Only in ocaml/camlp4/ocaml_stuff/utils: CVS
Only in ocaml/camlp4/ocpp: CVS
Only in ocaml/camlp4/odyl: CVS
Only in ocaml/camlp4/tools: CVS
Only in ocaml/camlp4/top: CVS
Only in ocaml/camlp4/unmaintained: CVS
Only in ocaml/camlp4/unmaintained/format: CVS
Only in ocaml/camlp4/unmaintained/lefteval: CVS
Only in ocaml/camlp4/unmaintained/ocamllex: CVS
Only in ocaml/camlp4/unmaintained/olabl: CVS
Only in ocaml/camlp4/unmaintained/scheme: CVS
Only in ocaml/camlp4/unmaintained/sml: CVS
Only in ocaml/config: CVS
Only in ocaml/config/auto-aux: CVS
Only in ocaml/config/gnu: CVS
diff -ur ocaml-3.09.1-orig/configure ocaml/configure
--- ocaml-3.09.1-orig/configure	2006-01-04 03:26:42.000000000 -0600
+++ ocaml/configure	2006-03-01 07:46:55.000000000 -0600
@@ -13,7 +13,7 @@
 #                                                                       #
 #########################################################################
 
-# $Id: configure,v 1.228.2.3 2006/01/04 09:26:42 xleroy Exp $
+# $Id: configure,v 1.228.2.4 2006/03/01 13:46:55 xleroy Exp $
 
 configure_options="$*"
 prefix=/usr/local
@@ -575,6 +575,7 @@
   i[3456]86-*-solaris*)         arch=i386; system=solaris;;
   i[3456]86-*-beos*)            arch=i386; system=beos;;
   i[3456]86-*-cygwin*)          arch=i386; system=cygwin;;
+  i[3456]86-*-darwin*)          arch=i386; system=macosx;;
   mips-*-irix6*)                arch=mips; system=irix;;
   hppa1.1-*-hpux*)              arch=hppa; system=hpux;;
   hppa2.0*-*-hpux*)             arch=hppa; system=hpux;;
Only in ocaml/debugger: CVS
Only in ocaml/driver: CVS
diff -ur ocaml-3.09.1-orig/driver/opterrors.ml ocaml/driver/opterrors.ml
--- ocaml-3.09.1-orig/driver/opterrors.ml	2003-06-19 10:53:49.000000000 -0500
+++ ocaml/driver/opterrors.ml	2006-02-09 08:12:18.000000000 -0600
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: opterrors.ml,v 1.18 2003/06/19 15:53:49 xleroy Exp $ *)
+(* $Id: opterrors.ml,v 1.18.10.1 2006/02/09 14:12:18 doligez Exp $ *)
 
 (* WARNING: if you change something in this file, you must look at
    errors.ml to see if you need to make the same changes there.
@@ -65,7 +65,7 @@
   | Sys_error msg ->
       fprintf ppf "I/O error: %s" msg
   | Warnings.Errors (n) ->
-      fprintf ppf "@.Error: %d error-enabled warnings occurred." n
+      fprintf ppf "@.Error: error-enabled warnings (%d occurrences)" n
   | x -> fprintf ppf "@]"; raise x in
 
   fprintf ppf "@[%a@]@." report exn
Only in ocaml/emacs: CVS
Only in ocaml/lex: CVS
Only in ocaml/man: CVS
Only in ocaml/ocamldoc: CVS
diff -ur ocaml-3.09.1-orig/ocamldoc/odoc_analyse.ml ocaml/ocamldoc/odoc_analyse.ml
--- ocaml-3.09.1-orig/ocamldoc/odoc_analyse.ml	2005-11-10 08:44:36.000000000 -0600
+++ ocaml/ocamldoc/odoc_analyse.ml	2006-02-09 08:14:05.000000000 -0600
@@ -9,7 +9,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: odoc_analyse.ml,v 1.12.2.2 2005/11/10 14:44:36 guesdon Exp $ *)
+(* $Id: odoc_analyse.ml,v 1.12.2.3 2006/02/09 14:14:05 doligez Exp $ *)
 
 (** Analysis of source files. This module is strongly inspired from
     driver/main.ml :-) *)
@@ -186,7 +186,7 @@
   | Translclass.Error(loc, err) ->
       Location.print ppf loc; Translclass.report_error ppf err
   | Warnings.Errors (n) ->
-      fprintf ppf "@.Error: %d error-enabled warnings occurred." n
+      fprintf ppf "@.Error: error-enabled warnings (%d occurrences)" n
   | x ->
       fprintf ppf "@]";
       fprintf ppf "Compilation error. Use the OCaml compiler to get more details."
@@ -290,7 +290,7 @@
             Odoc_module.m_top_deps = [] ;
             Odoc_module.m_code = None ;
             Odoc_module.m_code_intf = None ;
-	    Odoc_module.m_text_only = true ;
+            Odoc_module.m_text_only = true ;
           }
         in
         Some m
Only in ocaml/otherlibs: CVS
Only in ocaml/otherlibs/bigarray: CVS
Only in ocaml/otherlibs/db: CVS
Only in ocaml/otherlibs/dbm: CVS
Only in ocaml/otherlibs/dynlink: CVS
Only in ocaml/otherlibs/graph: CVS
Only in ocaml/otherlibs/labltk: CVS
Only in ocaml/otherlibs/labltk/browser: CVS
diff -ur ocaml-3.09.1-orig/otherlibs/labltk/browser/main.ml ocaml/otherlibs/labltk/browser/main.ml
--- ocaml-3.09.1-orig/otherlibs/labltk/browser/main.ml	2005-12-09 07:48:07.000000000 -0600
+++ ocaml/otherlibs/labltk/browser/main.ml	2006-01-25 00:28:19.000000000 -0600
@@ -12,7 +12,7 @@
 (*                                                                       *)
 (*************************************************************************)
 
-(* $Id: main.ml,v 1.31.4.2 2005/12/09 13:48:07 garrigue Exp $ *)
+(* $Id: main.ml,v 1.31.4.3 2006/01/25 06:28:19 garrigue Exp $ *)
 
 open StdLabels
 module Unix = UnixLabels
@@ -67,7 +67,7 @@
 
   let path = ref [] in
   let st = ref true in
-  (*let spec =
+  let spec =
     [ "-I", Arg.String (fun s -> path := s :: !path),
       "<dir>  Add <dir> to the list of include directories";
       "-labels", Arg.Clear Clflags.classic, " <obsolete>";
@@ -100,7 +100,7 @@
   if not (check ~spec Sys.argv) then fatal_error (usage ~spec errmsg);
   Arg.parse spec
     (fun name -> raise(Arg.Bad("don't know what to do with " ^ name)))
-    errmsg;*)
+    errmsg;
   Config.load_path :=
     Sys.getcwd ()
     :: List.rev_map ~f:(Misc.expand_directory Config.standard_library) !path
Only in ocaml/otherlibs/labltk/builtin: CVS
Only in ocaml/otherlibs/labltk/camltk: CVS
Only in ocaml/otherlibs/labltk/compiler: CVS
Only in ocaml/otherlibs/labltk/examples_camltk: CVS
Only in ocaml/otherlibs/labltk/examples_camltk/images: CVS
Only in ocaml/otherlibs/labltk/examples_labltk: CVS
Only in ocaml/otherlibs/labltk/frx: CVS
Only in ocaml/otherlibs/labltk/jpf: CVS
Only in ocaml/otherlibs/labltk/labltk: CVS
Only in ocaml/otherlibs/labltk/lib: CVS
Only in ocaml/otherlibs/labltk/support: CVS
Only in ocaml/otherlibs/labltk/tkanim: CVS
Only in ocaml/otherlibs/num: CVS
Only in ocaml/otherlibs/num/bignum: CVS
Only in ocaml/otherlibs/num/test: CVS
Only in ocaml/otherlibs/str: CVS
Only in ocaml/otherlibs/systhreads: CVS
Only in ocaml/otherlibs/systhreads: Tests
diff -ur ocaml-3.09.1-orig/otherlibs/systhreads/posix.c ocaml/otherlibs/systhreads/posix.c
--- ocaml-3.09.1-orig/otherlibs/systhreads/posix.c	2005-09-22 09:21:50.000000000 -0500
+++ ocaml/otherlibs/systhreads/posix.c	2006-03-22 07:13:45.000000000 -0600
@@ -11,7 +11,7 @@
 /*                                                                     */
 /***********************************************************************/
 
-/* $Id: posix.c,v 1.53 2005/09/22 14:21:50 xleroy Exp $ */
+/* $Id: posix.c,v 1.53.2.1 2006/03/22 13:13:45 xleroy Exp $ */
 
 /* Thread interface for POSIX 1003.1c threads */
 
@@ -305,7 +305,8 @@
     select(0, NULL, NULL, NULL, &timeout);
     /* This signal should never cause a callback, so don't go through
        handle_signal(), tweak the global variable directly. */
-    pending_signals[SIGVTALRM] = 1;
+    caml_pending_signals[SIGVTALRM] = 1;
+    caml_signals_are_pending = 1;
 #ifdef NATIVE_CODE
     young_limit = young_end;
 #else
diff -ur ocaml-3.09.1-orig/otherlibs/systhreads/win32.c ocaml/otherlibs/systhreads/win32.c
--- ocaml-3.09.1-orig/otherlibs/systhreads/win32.c	2005-12-07 06:30:59.000000000 -0600
+++ ocaml/otherlibs/systhreads/win32.c	2006-03-22 07:13:45.000000000 -0600
@@ -11,7 +11,7 @@
 /*                                                                     */
 /***********************************************************************/
 
-/* $Id: win32.c,v 1.42.2.1 2005/12/07 12:30:59 xleroy Exp $ */
+/* $Id: win32.c,v 1.42.2.2 2006/03/22 13:13:45 xleroy Exp $ */
 
 /* Thread interface for Win32 threads */
 
@@ -256,7 +256,8 @@
 {
   while(1) {
     Sleep(Thread_timeout);
-    pending_signals[SIGTIMER] = 1;
+    caml_pending_signals[SIGTIMER] = 1;
+    caml_signals_are_pending = 1;
 #ifdef NATIVE_CODE
     young_limit = young_end;
 #else
Only in ocaml/otherlibs/threads: CVS
Only in ocaml/otherlibs/threads: Tests
Only in ocaml/otherlibs/unix: CVS
diff -ur ocaml-3.09.1-orig/otherlibs/unix/times.c ocaml/otherlibs/unix/times.c
--- ocaml-3.09.1-orig/otherlibs/unix/times.c	2005-03-24 11:20:53.000000000 -0600
+++ ocaml/otherlibs/unix/times.c	2006-01-24 07:44:08.000000000 -0600
@@ -11,7 +11,7 @@
 /*                                                                     */
 /***********************************************************************/
 
-/* $Id: times.c,v 1.15 2005/03/24 17:20:53 doligez Exp $ */
+/* $Id: times.c,v 1.15.4.1 2006/01/24 13:44:08 doligez Exp $ */
 
 #include <mlvalues.h>
 #include <alloc.h>
@@ -20,6 +20,10 @@
 #include <time.h>
 #include <sys/types.h>
 #include <sys/times.h>
+#ifdef HAS_GETRUSAGE
+#include <sys/time.h>
+#include <sys/resource.h>
+#endif
 
 #ifndef CLK_TCK
 #ifdef HZ
@@ -31,6 +35,23 @@
 
 CAMLprim value unix_times(value unit)
 {
+#ifdef HAS_GETRUSAGE
+
+  value res;
+  struct rusage ru;
+
+  res = alloc_small(4 * Double_wosize, Double_array_tag);
+
+  getrusage (RUSAGE_SELF, &ru);
+  Store_double_field (res, 0, ru.ru_utime.tv_sec + ru.ru_utime.tv_usec / 1e6);
+  Store_double_field (res, 1, ru.ru_stime.tv_sec + ru.ru_stime.tv_usec / 1e6);
+  getrusage (RUSAGE_CHILDREN, &ru);
+  Store_double_field (res, 2, ru.ru_utime.tv_sec + ru.ru_utime.tv_usec / 1e6);
+  Store_double_field (res, 3, ru.ru_stime.tv_sec + ru.ru_stime.tv_usec / 1e6);
+  return res;
+
+#else
+
   value res;
   struct tms buffer;
 
@@ -41,4 +62,6 @@
   Store_double_field(res, 2, (double) buffer.tms_cutime / CLK_TCK);
   Store_double_field(res, 3, (double) buffer.tms_cstime / CLK_TCK);
   return res;
+
+#endif
 }
diff -ur ocaml-3.09.1-orig/otherlibs/unix/unix.mli ocaml/otherlibs/unix/unix.mli
--- ocaml-3.09.1-orig/otherlibs/unix/unix.mli	2005-11-22 05:58:47.000000000 -0600
+++ ocaml/otherlibs/unix/unix.mli	2006-03-21 09:50:29.000000000 -0600
@@ -11,7 +11,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: unix.mli,v 1.81.4.1 2005/11/22 11:58:47 doligez Exp $ *)
+(* $Id: unix.mli,v 1.81.4.2 2006/03/21 15:50:29 doligez Exp $ *)
 
 (** Interface to the Unix system *)
 
@@ -165,11 +165,11 @@
    environment to the program executed. *)
 
 val execvp : string -> string array -> 'a
-(** Same as {!Unix.execv} respectively, except that
+(** Same as {!Unix.execv}, except that
    the program is searched in the path. *)
 
 val execvpe : string -> string array -> string array -> 'a
-(** Same as {!Unix.execvp} respectively, except that
+(** Same as {!Unix.execve}, except that
    the program is searched in the path. *)
 
 val fork : unit -> int
Only in ocaml/otherlibs/win32graph: CVS
Only in ocaml/otherlibs/win32unix: CVS
diff -ur ocaml-3.09.1-orig/parsing/.cvsignore ocaml/parsing/.cvsignore
--- ocaml-3.09.1-orig/parsing/.cvsignore	2000-06-23 10:08:43.000000000 -0500
+++ ocaml/parsing/.cvsignore	2006-01-24 08:52:17.000000000 -0600
@@ -5,3 +5,5 @@
 lexer_tmp.ml
 linenum.ml
 parser.output
+parser.automaton
+parser.conflicts
Only in ocaml/parsing: CVS
diff -ur ocaml-3.09.1-orig/parsing/parser.mly ocaml/parsing/parser.mly
--- ocaml-3.09.1-orig/parsing/parser.mly	2005-03-22 21:08:37.000000000 -0600
+++ ocaml/parsing/parser.mly	2006-01-24 07:47:51.000000000 -0600
@@ -10,7 +10,7 @@
 /*                                                                     */
 /***********************************************************************/
 
-/* $Id: parser.mly,v 1.123 2005/03/23 03:08:37 garrigue Exp $ */
+/* $Id: parser.mly,v 1.123.4.1 2006/01/24 13:47:51 doligez Exp $ */
 
 /* The parser definition */
 
@@ -1296,6 +1296,10 @@
       { mktyp(Ptyp_class($5, List.rev $2, $6)) }
   | LBRACKET tag_field RBRACKET
       { mktyp(Ptyp_variant([$2], true, None)) }
+/* PR#3835: this is not LR(1), would need lookahead=2
+  | LBRACKET simple_core_type2 RBRACKET
+      { mktyp(Ptyp_variant([$2], true, None)) }
+*/
   | LBRACKET BAR row_field_list RBRACKET
       { mktyp(Ptyp_variant(List.rev $3, true, None)) }
   | LBRACKET row_field BAR row_field_list RBRACKET
Only in ocaml/stdlib: CVS
diff -ur ocaml-3.09.1-orig/stdlib/filename.ml ocaml/stdlib/filename.ml
--- ocaml-3.09.1-orig/stdlib/filename.ml	2005-11-29 06:17:27.000000000 -0600
+++ ocaml/stdlib/filename.ml	2006-01-05 13:19:52.000000000 -0600
@@ -11,7 +11,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: filename.ml,v 1.37.2.1 2005/11/29 12:17:27 doligez Exp $ *)
+(* $Id: filename.ml,v 1.37.2.2 2006/01/05 19:19:52 doligez Exp $ *)
 
 let generic_quote quotequote s =
   let l = String.length s in
@@ -25,6 +25,24 @@
   Buffer.add_char b '\'';
   Buffer.contents b
 
+let generic_basename rindex_dir_sep current_dir_name name =
+  let raw_name =
+    try
+      let p = rindex_dir_sep name + 1 in
+      String.sub name p (String.length name - p)
+    with Not_found ->
+      name
+  in
+  if raw_name = "" then current_dir_name else raw_name
+
+let generic_dirname rindex_dir_sep current_dir_name dir_sep name =
+  try
+    match rindex_dir_sep name with
+      0 -> dir_sep
+    | n -> String.sub name 0 n
+  with Not_found ->
+    current_dir_name
+
 module Unix = struct
   let current_dir_name = "."
   let parent_dir_name = ".."
@@ -43,6 +61,8 @@
   let temp_dir_name =
     try Sys.getenv "TMPDIR" with Not_found -> "/tmp"
   let quote = generic_quote "'\\''"
+  let basename = generic_basename rindex_dir_sep current_dir_name
+  let dirname = generic_dirname rindex_dir_sep current_dir_name dir_sep
 end
 
 module Win32 = struct
@@ -53,7 +73,7 @@
   let rindex_dir_sep s =
     let rec pos i =
       if i < 0 then raise Not_found
-      else if (let c = s.[i] in c = '/' || c = '\\' || c = ':') then i
+      else if is_dir_sep s i then i
       else pos (i - 1)
     in pos (String.length s - 1)
   let is_relative n =
@@ -87,6 +107,23 @@
     done;
     Buffer.add_char b '\"';
     Buffer.contents b
+  let has_drive s =
+    let is_letter = function
+      | 'A' .. 'Z' | 'a' .. 'z' -> true
+      | _ -> false
+    in
+    String.length s >= 2 && is_letter s.[0] && s.[1] = ':'
+  let drive_and_path s =
+    if has_drive s
+    then (String.sub s 0 2, String.sub s 2 (String.length s - 2))
+    else ("", s)
+  let dirname s =
+    let (drive, path) = drive_and_path s in
+    let dir = generic_dirname rindex_dir_sep current_dir_name dir_sep path in
+    drive ^ dir
+  let basename s =
+    let (drive, path) = drive_and_path s in
+    generic_basename rindex_dir_sep current_dir_name path
 end
 
 module Cygwin = struct
@@ -100,26 +137,29 @@
   let check_suffix = Win32.check_suffix
   let temp_dir_name = Unix.temp_dir_name
   let quote = Unix.quote
+  let basename = generic_basename rindex_dir_sep current_dir_name
+  let dirname = generic_dirname rindex_dir_sep current_dir_name dir_sep
 end
 
 let (current_dir_name, parent_dir_name, dir_sep, is_dir_sep, rindex_dir_sep,
-     is_relative, is_implicit, check_suffix, temp_dir_name, quote) =
+     is_relative, is_implicit, check_suffix, temp_dir_name, quote, basename,
+     dirname) =
   match Sys.os_type with
     "Unix" ->
       (Unix.current_dir_name, Unix.parent_dir_name, Unix.dir_sep,
        Unix.is_dir_sep, Unix.rindex_dir_sep,
        Unix.is_relative, Unix.is_implicit, Unix.check_suffix,
-       Unix.temp_dir_name, Unix.quote)
+       Unix.temp_dir_name, Unix.quote, Unix.basename, Unix.dirname)
   | "Win32" ->
       (Win32.current_dir_name, Win32.parent_dir_name, Win32.dir_sep,
        Win32.is_dir_sep, Win32.rindex_dir_sep,
        Win32.is_relative, Win32.is_implicit, Win32.check_suffix,
-       Win32.temp_dir_name, Win32.quote)
+       Win32.temp_dir_name, Win32.quote, Win32.basename, Win32.dirname)
   | "Cygwin" ->
       (Cygwin.current_dir_name, Cygwin.parent_dir_name, Cygwin.dir_sep,
        Cygwin.is_dir_sep, Cygwin.rindex_dir_sep,
        Cygwin.is_relative, Cygwin.is_implicit, Cygwin.check_suffix,
-       Cygwin.temp_dir_name, Cygwin.quote)
+       Cygwin.temp_dir_name, Cygwin.quote, Cygwin.basename, Cygwin.dirname)
   | _ -> assert false
 
 let concat dirname filename =
@@ -128,24 +168,6 @@
   then dirname ^ filename
   else dirname ^ dir_sep ^ filename
 
-let basename name =
-  let raw_name =
-    try
-      let p = rindex_dir_sep name + 1 in
-      String.sub name p (String.length name - p)
-    with Not_found ->
-      name
-  in
-  if raw_name = "" then current_dir_name else raw_name
-
-let dirname name =
-  try
-    match rindex_dir_sep name with
-      0 -> dir_sep
-    | n -> String.sub name 0 n
-  with Not_found ->
-    current_dir_name
-
 let chop_suffix name suff =
   let n = String.length name - String.length suff in
   if n < 0 then invalid_arg "Filename.chop_suffix" else String.sub name 0 n
diff -ur ocaml-3.09.1-orig/stdlib/pervasives.mli ocaml/stdlib/pervasives.mli
--- ocaml-3.09.1-orig/stdlib/pervasives.mli	2005-10-25 13:34:07.000000000 -0500
+++ ocaml/stdlib/pervasives.mli	2006-02-01 08:32:00.000000000 -0600
@@ -11,7 +11,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: pervasives.mli,v 1.104 2005/10/25 18:34:07 doligez Exp $ *)
+(* $Id: pervasives.mli,v 1.104.2.1 2006/02/01 14:32:00 doligez Exp $ *)
 
 (** The initially opened module.
 
@@ -172,10 +172,12 @@
    [x = (x / y) * y + x mod y] and
    [abs(x mod y) <= abs(y)-1].
    If [y = 0], [x mod y] raises [Division_by_zero].
-   Notice that [x mod y] is negative if and only if [x < 0]. *)
+   Notice that [x mod y] is nonpositive if and only if [x < 0].
+   Raise [Division_by_zero] if [y] is zero. *)
 
 val abs : int -> int
-(** Return the absolute value of the argument. *)
+(** Return the absolute value of the argument.  Note that this may be
+  negative if the argument is [min_int]. *)
 
 val max_int : int
 (** The greatest representable integer. *)
diff -ur ocaml-3.09.1-orig/stdlib/printf.ml ocaml/stdlib/printf.ml
--- ocaml-3.09.1-orig/stdlib/printf.ml	2005-10-25 13:34:07.000000000 -0500
+++ ocaml/stdlib/printf.ml	2006-01-23 11:35:13.000000000 -0600
@@ -11,7 +11,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: printf.ml,v 1.40 2005/10/25 18:34:07 doligez Exp $ *)
+(* $Id: printf.ml,v 1.40.2.1 2006/01/23 17:35:13 weis Exp $ *)
 
 external format_int: string -> int -> string = "caml_format_int"
 external format_int32: string -> int32 -> string = "caml_int32_format"
@@ -27,8 +27,9 @@
 external index_of_int : int -> index = "%identity";;
 external int_of_index : index -> int = "%identity";;
 
-let succ_index index = index_of_int (succ (int_of_index index));;
-(* Litteral position are One-based (hence pred p instead of p). *)
+let add_int_index i idx = index_of_int (i + int_of_index idx);;
+let succ_index = add_int_index 1;;
+(* Litteral position are one-based (hence pred p instead of p). *)
 let index_of_litteral_position p = index_of_int (pred p);;
 
 let bad_conversion fmt i c =
@@ -116,7 +117,7 @@
 let sub_format incomplete_format bad_conversion conv fmt i =
   let len = String.length fmt in
   let rec sub_fmt c i =
-    let close = if c = '(' then ')' else '}' in
+    let close = if c = '(' then ')' else (* '{' *) '}' in
     let rec sub j =
        if j >= len then incomplete_format fmt else
        match fmt.[j] with
@@ -127,7 +128,7 @@
        match fmt.[j] with
        | '(' | '{' as c ->
          let j = sub_fmt c (succ j) in sub (succ j)
-       | ')' | '}' as c ->
+       | '}' | ')' as c ->
          if c = close then j else bad_conversion fmt i c
        | _ -> sub (succ j) in
     sub i in
@@ -135,10 +136,11 @@
 
 let sub_format_for_printf = sub_format incomplete_format bad_conversion;;
 
-let iter_format_args fmt add_conv add_char =
-  let len = String.length fmt in
+let iter_on_format_args fmt add_conv add_char =
+  let lim = String.length fmt - 1 in
+
   let rec scan_flags skip i =
-    if i >= len then incomplete_format fmt else
+    if i > lim then incomplete_format fmt else
     match String.unsafe_get fmt i with
     | '*' -> scan_flags skip (add_conv skip i 'i')
     | '$' -> scan_flags skip (succ i)
@@ -148,7 +150,7 @@
     | '.' -> scan_flags skip (succ i)
     | _ -> scan_conv skip i
   and scan_conv skip i =
-    if i >= len then incomplete_format fmt else
+    if i > lim then incomplete_format fmt else
     match String.unsafe_get fmt i with
     | '%' | '!' -> succ i
     | 's' | 'S' | '[' -> add_conv skip i 's'
@@ -159,20 +161,36 @@
     | 'a' | 't' as conv -> add_conv skip i conv
     | 'l' | 'n' | 'L' as conv ->
         let j = succ i in
-        if j >= len then add_conv skip i 'i' else begin
+        if j > lim then add_conv skip i 'i' else begin
           match fmt.[j] with
           | 'd' | 'i' | 'o' | 'x' | 'X' | 'u' ->
-            add_char skip (add_conv skip i conv) 'i'
+            add_char (add_conv skip i conv) 'i'
           | c -> add_conv skip i 'i' end
-    | '{' | '(' as conv -> add_conv skip i conv
+    | '{' as conv ->
+      (* Just get a regular argument, skipping the specification. *)
+      let i = add_conv skip i conv in
+      let j = sub_format_for_printf conv fmt i in
+      (* Add the meta specification anyway. *)
+      let rec loop i =
+        if i < j - 1 then loop (add_char i fmt.[i]) in
+      loop i;
+      scan_conv skip j
+    | '(' as conv ->
+      (* Use the static format argument specification instead of
+         the runtime format argument value: they must have the same type
+         anyway. *)
+      scan_fmt (add_conv skip i conv)
     | '}' | ')' as conv -> add_conv skip i conv
-    | conv -> bad_conversion fmt i conv in
-  let lim = len - 1 in
-  let rec loop i =
+    | conv -> bad_conversion fmt i conv
+
+  and scan_fmt i =
     if i < lim then
-     if fmt.[i] = '%' then loop (scan_flags false (succ i)) else
-     loop (succ i) in
-  loop 0;;
+     if fmt.[i] = '%'
+     then scan_fmt (scan_flags false (succ i))
+     else scan_fmt (succ i)
+    else i in
+
+  ignore (scan_fmt 0);;
 
 (* Returns a string that summarizes the typing information that a given
    format string contains.
@@ -181,13 +199,11 @@
 let summarize_format_type fmt =
   let len = String.length fmt in
   let b = Buffer.create len in
-  let add i c = Buffer.add_char b c; succ i in
-  let add_char skip i c =
-    if skip then succ i else add i c
-  and add_conv skip i c =
+  let add_char i c = Buffer.add_char b c; succ i in
+  let add_conv skip i c =
     if skip then Buffer.add_string b "%_" else Buffer.add_char b '%';
-    add i c in
-  iter_format_args fmt add_conv add_char;
+    add_char i c in
+  iter_on_format_args fmt add_conv add_char;
   Buffer.contents b;;
 
 (* Computes the number of arguments of a format (including flag
@@ -196,11 +212,13 @@
   let num_args = ref 0
   and skip_args = ref 0 in
   let add_conv skip i c =
+    (* Just finishing a meta format: no additional argument to record. *)
+    if c = ')' || c = '}' then succ i else
     let incr_args n = if c = 'a' then n := !n + 2 else n := !n + 1 in
     if skip then incr_args skip_args else incr_args num_args;
     succ i
-  and add_char skip i c = succ i in
-  iter_format_args fmt add_conv add_char;
+  and add_char i c = succ i in
+  iter_on_format_args fmt add_conv add_char;
   !skip_args + !num_args;;
 
 let list_iter_i f l =
@@ -252,32 +270,46 @@
       else Obj.magic (fun x -> loop (succ i) (x :: args)) in
     loop 0 [];;
 
-(* To scan a positional parameter specification. *)
-let scan_positional_spec fmt k n i =
+type param_spec = Spec_none | Spec_index of index;; 
+
+(* To scan an optional positional parameter specification,
+   i.e. an integer followed by a $.
+   We do not support *$ specifications, since this would lead to type checking
+   problems: the type would be dependant of the {\em value} of an integer
+   argument to printf. *)
+let scan_positional_spec fmt got_pos n i =
   match String.unsafe_get fmt i with
   | '0'..'9' as d ->
-    let rec get_int_litteral accu i =
-      match String.unsafe_get fmt i with
+    let rec get_int_litteral accu j =
+      match String.unsafe_get fmt j with
       | '0'..'9' as d ->
-        get_int_litteral (10 * accu + (int_of_char d - 48)) (succ i)
+        get_int_litteral (10 * accu + (int_of_char d - 48)) (succ j)
       | '$' ->
-        k (Some (index_of_litteral_position accu)) None (succ i)
-      | _ -> k None (Some accu) i in
+        if accu = 0
+          then failwith "printf: bad positional specification (0)." else
+        got_pos (Spec_index (index_of_litteral_position accu)) (succ j)
+      (* Not a positional specification. *)
+      | _ -> got_pos Spec_none i in
     get_int_litteral (int_of_char d - 48) (succ i)
-  | _ -> k None None i;;
+  (* No positional specification. *)
+  | _ -> got_pos Spec_none i;;
 
-(* To scan a positional parameter. *)
-let scan_positional fmt scan_flags n i =
-  let got_positional p w i =
-    match p, w with
-    | None, None -> scan_flags n [] i
-    | Some p, None -> scan_flags p [] i
-    | None, Some w -> scan_flags n [w] i
-    | _, _ -> assert false in
-  scan_positional_spec fmt got_positional n i;;
+(* Get the position of the next argument to printf, according to the given
+   positional specification. *)
+let next_index spec n =
+  match spec with
+  | Spec_none -> succ_index n
+  | Spec_index p -> n;;
+
+(* Get the position of the actual argument to printf, according to its
+   optional positional specification. *)
+let get_index spec n =
+  match spec with
+  | Spec_none -> n
+  | Spec_index p -> p;;
 
 (* Decode a %format and act on it.
-   [fmt] is the printf format style, and [pos] points to a [%] character.
+   [fmt] is the printf format string, and [pos] points to a [%] character.
    After consuming the appropriate number of arguments and formatting
    them, one of the five continuations is called:
    [cont_s] for outputting a string (args: string, next pos)
@@ -296,140 +328,147 @@
    Don't do this at home, kids. *)
 let scan_format fmt args n pos cont_s cont_a cont_t cont_f cont_m =
 
-  let get_arg args n = Obj.magic args.(int_of_index n) in
+  let get_arg spec n = Obj.magic args.(int_of_index (get_index spec n)) in
 
-  let rec scan_flags n widths i =
+  let rec scan_positional n widths i =
+    let got_pos spec i = scan_flags spec n widths i in
+    scan_positional_spec fmt got_pos n i
+
+  and scan_flags spec n widths i =
     match String.unsafe_get fmt i with
     | '*' ->
-      let got_positional p w i =
-        match p, w with
-        | None, None ->
-          let (width : int) = get_arg args n in
-          scan_flags (succ_index n) (width :: widths) i
-        | Some p, None ->
-          let (width : int) = get_arg args p in
-          scan_flags n (width :: widths) i
-        | _, _ -> assert false in
-      scan_positional_spec fmt got_positional n (succ i)
+      let got_pos wspec i =
+        let (width : int) = get_arg wspec n in
+        scan_flags spec (next_index wspec n) (width :: widths) i in
+      scan_positional_spec fmt got_pos n (succ i)
     | '0'..'9'
-    | '.' | '#' | '-' | ' ' | '+' -> scan_flags n widths (succ i)
-    | _ -> scan_conv n widths i
+    | '.' | '#' | '-' | ' ' | '+' -> scan_flags spec n widths (succ i)
+    | _ -> scan_conv spec n widths i
 
-  and scan_conv n widths i =
+  and scan_conv spec n widths i =
     match String.unsafe_get fmt i with
     | '%' ->
       cont_s n "%" (succ i)
     | 's' | 'S' as conv ->
-      let (x : string) = get_arg args n in
+      let (x : string) = get_arg spec n in
       let x = if conv = 's' then x else "\"" ^ String.escaped x ^ "\"" in
       let s =
         (* optimize for common case %s *)
         if i = succ pos then x else
         format_string (extract_format fmt pos i widths) x in
-      cont_s (succ_index n) s (succ i)
+      cont_s (next_index spec n) s (succ i)
     | 'c' | 'C' as conv ->
-      let (x : char) = get_arg args n in
+      let (x : char) = get_arg spec n in
       let s =
         if conv = 'c' then String.make 1 x else "'" ^ Char.escaped x ^ "'" in
-      cont_s (succ_index n) s (succ i)
+      cont_s (next_index spec n) s (succ i)
     | 'd' | 'i' | 'o' | 'x' | 'X' | 'u' | 'N' as conv ->
-      let (x : int) = get_arg args n in
+      let (x : int) = get_arg spec n in
       let s = format_int_with_conv conv (extract_format fmt pos i widths) x in
-      cont_s (succ_index n) s (succ i)
+      cont_s (next_index spec n) s (succ i)
     | 'f' | 'e' | 'E' | 'g' | 'G' | 'F' as conv ->
-      let (x : float) = get_arg args n in
+      let (x : float) = get_arg spec n in
       let s =
         if conv = 'F' then string_of_float x else
         format_float (extract_format fmt pos i widths) x in
-      cont_s (succ_index n) s (succ i)
+      cont_s (next_index spec n) s (succ i)
     | 'B' | 'b' ->
-      let (x : bool) = get_arg args n in
-      cont_s (succ_index n) (string_of_bool x) (succ i)
+      let (x : bool) = get_arg spec n in
+      cont_s (next_index spec n) (string_of_bool x) (succ i)
     | 'a' ->
-      let printer = get_arg args n in
-      let n = succ_index n in
-      let arg = get_arg args n in
-      cont_a (succ_index n) printer arg (succ i)
+      let printer = get_arg spec n in
+      (* If the printer spec is Spec_none, go on as usual.
+         If the printer spec is Spec_index p,
+         printer's argument spec is Spec_index (succ_index p). *)
+      let n = succ_index (get_index spec n) in
+      let arg = get_arg Spec_none n in
+      cont_a (next_index spec n) printer arg (succ i)
     | 't' ->
-      let printer = get_arg args n in
-      cont_t (succ_index n) printer (succ i)
+      let printer = get_arg spec n in
+      cont_t (next_index spec n) printer (succ i)
     | 'l' | 'n' | 'L' as conv ->
       begin match String.unsafe_get fmt (succ i) with
       | 'd' | 'i' | 'o' | 'x' | 'X' | 'u' ->
         let s =
           match conv with
           | 'l' ->
-            let (x : int32) = get_arg args n in
+            let (x : int32) = get_arg spec n in
             format_int32 (extract_format fmt pos (succ i) widths) x
           | 'n' ->
-            let (x : nativeint) = get_arg args n in
+            let (x : nativeint) = get_arg spec n in
             format_nativeint (extract_format fmt pos (succ i) widths) x
           | _ ->
-            let (x : int64) = get_arg args n in
+            let (x : int64) = get_arg spec n in
             format_int64 (extract_format fmt pos (succ i) widths) x in
-        cont_s (succ_index n) s (i + 2)
+        cont_s (next_index spec n) s (i + 2)
       | _ ->
-        let (x : int) = get_arg args n in
+        let (x : int) = get_arg spec n in
         cont_s
-          (succ_index n)
+          (next_index spec n)
           (format_int_with_conv 'n' (extract_format fmt pos i widths) x)
           (succ i)
       end
     | '!' -> cont_f n (succ i)
-    | '{' | '(' as conv (* ')' '}' *)->
-      let (xf : ('a, 'b, 'c, 'd) format4) = get_arg args n in
+    | '{' | '(' as conv (* ')' '}' *) ->
+      let (xf : ('a, 'b, 'c, 'd) format4) = get_arg spec n in
       let i = succ i in
       let j = sub_format_for_printf conv fmt i + 1 in
       if conv = '{' (* '}' *) then
         (* Just print the format argument as a specification. *)
         cont_s
-          (succ_index n)
-          (summarize_format_type (format_to_string xf)) j else
+          (next_index spec n)
+          (summarize_format_type (format_to_string xf))
+          j else
         (* Use the format argument instead of the format specification. *)
-        cont_m (succ_index n) xf j
-    | ')' ->
+        cont_m (next_index spec n) xf j
+    | (* '(' *) ')' ->
       cont_s n "" (succ i)
     | conv ->
       bad_conversion fmt i conv in
 
-  scan_positional fmt scan_flags n (succ pos);;
+  scan_positional n [] (succ pos);;
+
+let mkprintf str get_out outc outs flush k fmt =
+
+  let fmt = format_to_string fmt in
+  (* out is global to this invocation of pr, and must be shared by all its
+     recursive calls (fif) any. *)
+  let out = get_out fmt in
+
+  let rec pr k n fmt v =
 
-let mkprintf str get_out outc outs flush =
-  let rec kprintf k fmt =
-    let fmt = format_to_string fmt in
     let len = String.length fmt in
 
-    let kpr fmt v =
-      let out = get_out fmt in
-      let rec doprn n i =
-        if i >= len then Obj.magic (k out) else
-        match String.unsafe_get fmt i with
-        | '%' -> scan_format fmt v n i cont_s cont_a cont_t cont_f cont_m
-        |  c  -> outc out c; doprn n (succ i)
-      and cont_s n s i =
-        outs out s; doprn n i
-      and cont_a n printer arg i =
-        if str then
-          outs out ((Obj.magic printer : unit -> _ -> string) () arg)
-        else
-          printer out arg;
-        doprn n i
-      and cont_t n printer i =
-        if str then
-          outs out ((Obj.magic printer : unit -> string) ())
-        else
-          printer out;
-        doprn n i
-      and cont_f n i =
-        flush out; doprn n i
-      and cont_m n sfmt i =
-        kprintf (Obj.magic (fun _ -> doprn n i)) sfmt in
+    let rec doprn n i =
+       if i >= len then Obj.magic (k out) else
+       match String.unsafe_get fmt i with
+       | '%' -> scan_format fmt v n i cont_s cont_a cont_t cont_f cont_m
+       |  c  -> outc out c; doprn n (succ i)
+     and cont_s n s i =
+       outs out s; doprn n i
+     and cont_a n printer arg i =
+       if str then
+         outs out ((Obj.magic printer : unit -> _ -> string) () arg)
+       else
+         printer out arg;
+       doprn n i
+     and cont_t n printer i =
+       if str then
+         outs out ((Obj.magic printer : unit -> string) ())
+       else
+         printer out;
+       doprn n i
+     and cont_f n i =
+       flush out; doprn n i
+     and cont_m n xf i =
+       let m = add_int_index (nargs_of_format_type (format_to_string xf)) n in
+       pr (Obj.magic (fun _ -> doprn m i)) n (format_to_string xf) v in
 
-      doprn (index_of_int 0) 0 in
+     doprn n 0 in
 
-    kapr kpr fmt in
+  let kpr = pr k (index_of_int 0) in
 
-  kprintf;;
+  kapr kpr fmt;;
 
 let kfprintf k oc =
   mkprintf false (fun _ -> oc) output_char output_string flush k
diff -ur ocaml-3.09.1-orig/stdlib/sys.ml ocaml/stdlib/sys.ml
--- ocaml-3.09.1-orig/stdlib/sys.ml	2006-01-04 07:05:49.000000000 -0600
+++ ocaml/stdlib/sys.ml	2006-03-22 06:59:58.000000000 -0600
@@ -11,7 +11,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: sys.ml,v 1.138.2.8 2006/01/04 13:05:49 doligez Exp $ *)
+(* $Id: sys.ml,v 1.138.2.15 2006/03/22 12:59:58 doligez Exp $ *)
 
 (* System interface *)
 
@@ -78,4 +78,4 @@
 
 (* OCaml version string, must be in the format described in sys.mli. *)
 
-let ocaml_version = "3.09.1";;
+let ocaml_version = "3.09.2+dev6 (2006-03-22)";;
Only in ocaml: test
Only in ocaml: testasmcomp
Only in ocaml: testlabl
Only in ocaml: testobjects
Only in ocaml/tools: CVS
diff -ur ocaml-3.09.1-orig/tools/checkstack.c ocaml/tools/checkstack.c
--- ocaml-3.09.1-orig/tools/checkstack.c	2002-08-09 06:10:34.000000000 -0500
+++ ocaml/tools/checkstack.c	2006-01-23 11:36:47.000000000 -0600
@@ -11,9 +11,10 @@
 /*                                                                     */
 /***********************************************************************/
 
-/* $Id: checkstack.c,v 1.2 2002/08/09 11:10:34 xleroy Exp $ */
+/* $Id: checkstack.c,v 1.2.16.1 2006/01/23 17:36:47 doligez Exp $ */
 
 #include <stdio.h>
+#include <stdlib.h>
 #include <sys/types.h>
 #include <sys/time.h>
 #include <sys/resource.h>
Only in ocaml/toplevel: CVS
Only in ocaml/typing: CVS
diff -ur ocaml-3.09.1-orig/typing/printtyp.ml ocaml/typing/printtyp.ml
--- ocaml-3.09.1-orig/typing/printtyp.ml	2005-12-07 17:37:27.000000000 -0600
+++ ocaml/typing/printtyp.ml	2006-02-08 19:19:26.000000000 -0600
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: printtyp.ml,v 1.139.2.2 2005/12/07 23:37:27 garrigue Exp $ *)
+(* $Id: printtyp.ml,v 1.139.2.3 2006/02/09 01:19:26 garrigue Exp $ *)
 
 (* Printing functions *)
 
@@ -835,7 +835,7 @@
 
 let type_expansion t ppf t' =
   if t == t' then type_expr ppf t else
-  let t' = if proxy t = proxy t' then unalias t' else t' in
+  let t' = if proxy t == proxy t' then unalias t' else t' in
   fprintf ppf "@[<2>%a@ =@ %a@]" type_expr t type_expr t'
 
 let rec trace fst txt ppf = function
diff -ur ocaml-3.09.1-orig/typing/printtyp.mli ocaml/typing/printtyp.mli
--- ocaml-3.09.1-orig/typing/printtyp.mli	2004-06-12 03:55:48.000000000 -0500
+++ ocaml/typing/printtyp.mli	2006-01-05 09:59:35.000000000 -0600
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: printtyp.mli,v 1.26 2004/06/12 08:55:48 xleroy Exp $ *)
+(* $Id: printtyp.mli,v 1.26.10.1 2006/01/05 15:59:35 doligez Exp $ *)
 
 (* Printing functions *)
 
@@ -29,6 +29,7 @@
 val reset_and_mark_loops_list: type_expr list -> unit
 val type_expr: formatter -> type_expr -> unit
 val tree_of_type_scheme: type_expr -> out_type
+val type_sch : formatter -> type_expr -> unit
 val type_scheme: formatter -> type_expr -> unit
 (* Maxence *)
 val reset_names: unit -> unit
diff -ur ocaml-3.09.1-orig/typing/stypes.ml ocaml/typing/stypes.ml
--- ocaml-3.09.1-orig/typing/stypes.ml	2003-07-25 13:00:40.000000000 -0500
+++ ocaml/typing/stypes.ml	2006-01-05 09:59:35.000000000 -0600
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: stypes.ml,v 1.8 2003/07/25 18:00:40 doligez Exp $ *)
+(* $Id: stypes.ml,v 1.8.20.1 2006/01/05 15:59:35 doligez Exp $ *)
 
 (* Recording and dumping (partial) type information *)
 
@@ -107,7 +107,7 @@
       fprintf pp "@.type(@.  ";
       printtyp_reset_maybe loc;
       Printtyp.mark_loops typ;
-      Printtyp.type_expr pp typ;
+      Printtyp.type_sch pp typ;
       fprintf pp "@.)@.";
 ;;
 
diff -ur ocaml-3.09.1-orig/typing/typeclass.ml ocaml/typing/typeclass.ml
--- ocaml-3.09.1-orig/typing/typeclass.ml	2005-07-22 01:42:36.000000000 -0500
+++ ocaml/typing/typeclass.ml	2006-02-20 18:58:10.000000000 -0600
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: typeclass.ml,v 1.85 2005/07/22 06:42:36 garrigue Exp $ *)
+(* $Id: typeclass.ml,v 1.85.2.1 2006/02/21 00:58:10 garrigue Exp $ *)
 
 open Misc
 open Parsetree
@@ -753,9 +753,8 @@
                 pexp_loc = Location.none}))
           pv
       in
-      let rec all_labeled = function
-          Tcty_fun ("", _, _) -> false
-        | Tcty_fun (l, _, ty_fun) -> l.[0] <> '?' && all_labeled ty_fun
+      let rec not_function = function
+          Tcty_fun _ -> false
         | _ -> true
       in
       let partial =
@@ -768,7 +767,7 @@
       Ctype.raise_nongen_level ();
       let cl = class_expr cl_num val_env met_env scl' in
       Ctype.end_def ();
-      if Btype.is_optional l && all_labeled cl.cl_type then
+      if Btype.is_optional l && not_function cl.cl_type then
         Location.prerr_warning pat.pat_loc
           Warnings.Unerasable_optional_argument;
       rc {cl_desc = Tclass_fun (pat, pv, cl, partial);
diff -ur ocaml-3.09.1-orig/typing/typecore.ml ocaml/typing/typecore.ml
--- ocaml-3.09.1-orig/typing/typecore.ml	2005-12-11 03:56:33.000000000 -0600
+++ ocaml/typing/typecore.ml	2006-02-20 18:58:10.000000000 -0600
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: typecore.ml,v 1.176.2.2 2005/12/11 09:56:33 xleroy Exp $ *)
+(* $Id: typecore.ml,v 1.176.2.4 2006/02/21 00:58:10 garrigue Exp $ *)
 
 (* Typechecking for the core language *)
 
@@ -774,8 +774,9 @@
       newty (Ttuple (List.map (approx_type env) args))
   | Ptyp_constr (lid, ctl) ->
       begin try
+        let (path, decl) = Env.lookup_type lid env in
+        if List.length ctl <> decl.type_arity then raise Not_found;
         let tyl = List.map (approx_type env) ctl in
-        let (path, _) = Env.lookup_type lid env in
         newconstr path tyl
       with Not_found -> newvar ()
       end
@@ -1784,11 +1785,11 @@
       let cases, partial =
         type_cases ~in_function:(loc,ty_fun) env ty_arg ty_res
           (Some sexp.pexp_loc) caselist in
-      let all_labeled ty =
+      let not_function ty =
         let ls, tvar = list_labels env ty in
-        not (tvar || List.exists (fun l -> l = "" || l.[0] = '?') ls)
+        ls = [] && not tvar
       in
-      if is_optional l && all_labeled ty_res then
+      if is_optional l && not_function ty_res then
         Location.prerr_warning (fst (List.hd cases)).pat_loc
           Warnings.Unerasable_optional_argument;
       re {
Only in ocaml/utils: CVS
diff -ur ocaml-3.09.1-orig/utils/warnings.ml ocaml/utils/warnings.ml
--- ocaml-3.09.1-orig/utils/warnings.ml	2005-09-14 22:09:26.000000000 -0500
+++ ocaml/utils/warnings.ml	2006-02-17 22:43:27.000000000 -0600
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: warnings.ml,v 1.23 2005/09/15 03:09:26 garrigue Exp $ *)
+(* $Id: warnings.ml,v 1.23.2.1 2006/02/18 04:43:27 garrigue Exp $ *)
 
 (* Please keep them in alphabetical order *)
 
@@ -147,7 +147,8 @@
   | Not_principal s -> s^" is not principal."
   | Without_principality s -> s^" without principality."
   | Unused_argument -> "this argument will not be used by the function."
-  | Nonreturning_statement -> "this statement never returns."
+  | Nonreturning_statement ->
+      "this statement never returns (or has an unsound type.)"
   | Camlp4 s -> s
   | All_clauses_guarded ->
       "bad style, all clauses in this pattern-matching are guarded."
Only in ocaml/win32caml: CVS
diff -ur ocaml-3.09.1-orig/yacc/.cvsignore ocaml/yacc/.cvsignore
--- ocaml-3.09.1-orig/yacc/.cvsignore	2004-11-26 19:04:19.000000000 -0600
+++ ocaml/yacc/.cvsignore	2006-01-24 07:39:07.000000000 -0600
@@ -2,3 +2,4 @@
 *.c.x
 ocamlyacc.xcoff
 version.h
+.gdb_history
Only in ocaml/yacc: CVS
diff -ur ocaml-3.09.1-orig/yacc/main.c ocaml/yacc/main.c
--- ocaml-3.09.1-orig/yacc/main.c	2004-11-26 19:04:19.000000000 -0600
+++ ocaml/yacc/main.c	2006-01-23 11:38:43.000000000 -0600
@@ -12,7 +12,7 @@
 
 /* Based on public-domain code from Berkeley Yacc */
 
-/* $Id: main.c,v 1.19 2004/11/27 01:04:19 doligez Exp $ */
+/* $Id: main.c,v 1.19.4.1 2006/01/23 17:38:43 doligez Exp $ */
 
 #include <signal.h>
 #include <string.h>
@@ -157,6 +157,7 @@
         {
         case '\0':
             input_file = stdin;
+            file_prefix = "stdin";
             if (i + 1 < argc) usage();
             return;
 
