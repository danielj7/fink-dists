diff -Naur SDL_mixer-1.2.6-orig/native_midi/native_midi_mac.c SDL_mixer-1.2.6/native_midi/native_midi_mac.c
--- SDL_mixer-1.2.6-orig/native_midi/native_midi_mac.c	2006-03-10 10:48:19.000000000 -0500
+++ SDL_mixer-1.2.6/native_midi/native_midi_mac.c	2006-03-10 10:48:55.000000000 -0500
@@ -95,13 +95,81 @@
 	int				part_poly_max[32];
 	int				numParts = 0;
 	Uint16			ppqn;
+	SDL_RWops		*rw;
 
 	/* Init the arrays */
 	memset(part_poly_max,0,sizeof(part_poly_max));
 	memset(part_to_inst,-1,sizeof(part_to_inst));
 	
 	/* Attempt to load the midi file */
-	evntlist = CreateMIDIEventList(midifile, &ppqn);
+	rw = SDL_RWFromFile(midifile, "rb");
+	if (rw) {
+		evntlist = CreateMIDIEventList(rw, &ppqn);
+		SDL_RWclose(rw);
+		if (!evntlist)
+			goto bail;
+	}
+
+	/* Allocate memory for the song struct */
+	song = malloc(sizeof(NativeMidiSong));
+	if (!song)
+		goto bail;
+
+	/* Build a tune sequence from the event list */
+	song->tuneSequence = BuildTuneSequence(evntlist, ppqn, part_poly_max, part_to_inst, &numParts);
+	if(!song->tuneSequence)
+		goto bail;
+
+	/* Now build a tune header from the data we collect above, create
+	   all parts as needed and assign them the correct instrument.
+	*/
+	song->tuneHeader = BuildTuneHeader(part_poly_max, part_to_inst, numParts);
+	if(!song->tuneHeader)
+		goto bail;
+	
+	/* Increment the instance count */
+	gInstaceCount++;
+	if (gTunePlayer == NULL)
+		gTunePlayer = OpenDefaultComponent(kTunePlayerComponentType, 0);
+
+	/* Finally, free the event list */
+	FreeMIDIEventList(evntlist);
+	
+	return song;
+	
+bail:
+	if (evntlist)
+		FreeMIDIEventList(evntlist);
+	
+	if (song)
+	{
+		if(song->tuneSequence)
+			free(song->tuneSequence);
+		
+		if(song->tuneHeader)
+			DisposePtr((Ptr)song->tuneHeader);
+
+		free(song);
+	}
+	
+	return NULL;
+}
+
+NativeMidiSong *native_midi_loadsong_RW(SDL_RWops *rw)
+{
+	NativeMidiSong	*song = NULL;
+	MIDIEvent		*evntlist = NULL;
+	int				part_to_inst[32];
+	int				part_poly_max[32];
+	int				numParts = 0;
+	Uint16			ppqn;
+
+	/* Init the arrays */
+	memset(part_poly_max,0,sizeof(part_poly_max));
+	memset(part_to_inst,-1,sizeof(part_to_inst));
+	
+	/* Attempt to load the midi file */
+	evntlist = CreateMIDIEventList(rw, &ppqn);
 	if (!evntlist)
 		goto bail;
 
@@ -591,8 +659,22 @@
 		qtma_StuffGeneralEvent(*myPos1, *myPos2, part, kGeneralEventNoteRequest, kNoteRequestEventLength);
 		myNoteRequest = (NoteRequest *)(myPos1 + 1);
 		myNoteRequest->info.flags = 0;
+		/* I'm told by the Apple people that the Quicktime types were poorly designed and it was 
+		 * too late to change them. On little endian, the BigEndian(Short|Fixed) types are structs
+		 * while on big endian they are primitive types. Furthermore, Quicktime failed to 
+		 * provide setter and getter functions. To get this to work, we need to case the 
+		 * code for the two possible situations.
+		 * My assumption is that the right-side value was always expected to be BigEndian
+		 * as it was written way before the Universal Binary transition. So in the little endian
+		 * case, OSSwap is used.
+		 */
+#if __LITTLE_ENDIAN__
+		myNoteRequest->info.polyphony.bigEndianValue = OSSwapHostToBigInt16(part_poly_max[part]);
+		myNoteRequest->info.typicalPolyphony.bigEndianValue = OSSwapHostToBigInt32(0x00010000);
+#else
 		myNoteRequest->info.polyphony = part_poly_max[part];
 		myNoteRequest->info.typicalPolyphony = 0x00010000;
+#endif
 		myErr = NAStuffToneDescription(myNoteAllocator,part_to_inst[part],&myNoteRequest->tone);
 		if (myErr != noErr)
 			goto bail;
