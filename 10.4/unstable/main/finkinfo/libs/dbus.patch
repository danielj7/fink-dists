diff --git a/README.launchd b/README.launchd
new file mode 100644
index 0000000..701e57d
--- /dev/null
+++ b/README.launchd
@@ -0,0 +1,61 @@
+Launchd[1,2] replaces init, inetd and cron on Mac OS X since 10.4 "Tiger".
+dbus uses this service to provide a common session bus address for each user
+and so deprecates the X11 enabled dbus-launcher.
+
+[1] http://developer.apple.com/MacOsX/launchd.html
+[2] http://launchd.macosforge.org/
+
+
+Setup
+===
+
+Configure with --enable-launchd and --without-x (X11 should not harm but it's
+simply not necessary any more)
+After installation, to prevent a reboot, load the dbus session starter into
+launchd by executing:
+$ launchctl load /Library/LaunchAgents/org.freedesktop.dbus-session.plist
+
+You can change the launch agent dir via configure, but it's not recommended.
+Make sure to execute the above line as the actual user for which you want to
+use a session bus since launchd manages its agents on a per user basis.
+
+
+How it works
+===
+
+Launchd allocates a socket and provides the unix path to it via the variable
+DBUS_LAUNCHD_SESSION_BUS_SOCKET in launchd's environment. Every process
+spawned by launchd (or dbus-daemon, if stared by launchd) can access it through
+its own environment. Other processes can query launchd for it by executing:
+$ launchctl getenv DBUS_LAUNCHD_SESSION_BUS_SOCKET
+However, this is normally done by the dbus client lib for you.
+
+If launchd start dbus-daemon with a config file containing a "launchd:env=FOO"
+address, as the default session config does with env=DBUS_LAUNCHD_SESSION_BUS_SOCKET,
+the daemon will get the file descriptor from launchd and start listening on it.
+The environment variable is used to get the actual socket path which is passed
+to every service spawned by dbus-daemon as a result from autolaunch messages.
+Please note that it's not possible to start dbus-daemon manually when using a
+"launchd:" address. Only child processes of launchd can access the above
+mentioned file descriptor!
+
+To create custom buses just set up an other launch agent. As a quick start copy
+/Library/LaunchAgents/org.freedesktop.dbus-session.plist, change the label
+to i.e. "org.freedesktop.dbus-foo" and change the SecureSocketWithKey value,
+i.e. to "DBUS_LAUNCHD_FOO_BUS_SOCKET". This environment variable has to be set
+in the config file for your new bus in the <listen> element (see session.config).
+Then edit your /Library/LaunchAgents/org.freedesktop.dbus-foo.plist to start
+dbus-daemon with "--config-file=/opt/local/etc/dbus-1/foo.conf" instead of
+"--session". Now load the new plist onto launchd as described in the setup
+section of this document.
+Executing "launchctl export" should now give you two sockets, one in
+DBUS_LAUNCHD_SESSION_BUS_SOCKET and the new DBUS_LAUNCHD_FOO_BUS_SOCKET.
+To connect to this new bus use "launchd:env=DBUS_LAUNCHD_FOO_BUS_SOCKET".
+
+Since Mac OS X 10.5 "Leopard" you can also configure launchd to start
+dbus-daemon on demand as soon as some process connects to the socket. Since
+it's broken on 10.4 this feature is disabled per default. Look at
+/Library/LaunchAgents/org.freedesktop.dbus-session.plist to change it.
+
+On the client side, the envvar DBUS_SESSION_BUS_ADDRESS can be normally used
+but if it's not set, launchd is queried for the session bus socket.
diff --git a/bus/Makefile.am b/bus/Makefile.am
index 3b4f69d..420742b 100644
--- a/bus/Makefile.am
+++ b/bus/Makefile.am
@@ -9,12 +9,18 @@ EFENCE=
 
 CONFIG_IN_FILES=				\
 	session.conf.in				\
-	system.conf.in
+	system.conf.in				\
+	org.freedesktop.dbus-session.plist.in
 
 config_DATA=					\
 	session.conf				\
 	system.conf
 
+if DBUS_ENABLE_LAUNCHD
+agentdir=$(LAUNCHD_AGENT_DIR)
+agent_DATA=org.freedesktop.dbus-session.plist
+endif
+
 if DBUS_USE_LIBXML
 XML_SOURCES=config-loader-libxml.c
 endif
diff --git a/bus/org.freedesktop.dbus-session.plist.in b/bus/org.freedesktop.dbus-session.plist.in
new file mode 100644
index 0000000..ac5a9d4
--- /dev/null
+++ b/bus/org.freedesktop.dbus-session.plist.in
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>Label</key>
+	<string>org.freedesktop.dbus-session</string>
+
+	<key>ServiceIPC</key>
+	<true/>
+
+	<!-- bug in 10.4's launchd - on-demand loading does not work -->
+	<key>OnDemand</key>
+	<false />
+
+	<key>ProgramArguments</key>
+	<array>
+		<string>@DBUS_DAEMONDIR@/dbus-daemon</string>
+		<string>--nofork</string>
+		<string>--session</string>
+	</array>
+
+	<key>Sockets</key>
+	<dict>
+		<key>unix_domain_listener</key>
+		<dict>
+			<key>SecureSocketWithKey</key>
+			<string>DBUS_LAUNCHD_SESSION_BUS_SOCKET</string>
+		</dict>
+	</dict>
+</dict>
+</plist>
diff --git a/bus/session.conf.in b/bus/session.conf.in
index e7229ad..b6caabb 100644
--- a/bus/session.conf.in
+++ b/bus/session.conf.in
@@ -12,7 +12,7 @@
        the behavior of child processes. -->
   <keep_umask/>
 
-  <listen>unix:tmpdir=@DBUS_SESSION_SOCKET_DIR@</listen>
+  <listen>@DBUS_SESSION_BUS_DEFAULT_ADDRESS@</listen>
 
   <standard_session_servicedirs />
 
diff --git a/configure.in b/configure.in
index 5a92efd..8bf097d 100644
--- a/configure.in
+++ b/configure.in
@@ -78,6 +78,7 @@ AC_ARG_ENABLE(inotify, AS_HELP_STRING([--enable-inotify],[build with inotify sup
 AC_ARG_ENABLE(kqueue, AS_HELP_STRING([--enable-kqueue],[build with kqueue support]),enable_kqueue=$enableval,enable_kqueue=auto)
 AC_ARG_ENABLE(console-owner-file, AS_HELP_STRING([--enable-console-owner-file],[enable console owner file]),enable_console_owner_file=$enableval,enable_console_owner_file=auto)
 AC_ARG_ENABLE(userdb-cache, AS_HELP_STRING([--enable-userdb-cache],[build with userdb-cache support]),enable_userdb_cache=$enableval,enable_userdb_cache=yes)
+AC_ARG_ENABLE(launchd, AS_HELP_STRING([--enable-launchd],[build with launchd auto-launch support]),enable_launchd=$enableval,enable_launchd=auto)
 
 AC_ARG_WITH(xml, AS_HELP_STRING([--with-xml=[libxml/expat]],[XML library to use]))
 AC_ARG_WITH(init-scripts, AS_HELP_STRING([--with-init-scripts=[redhat]],[Style of init scripts to install]))
@@ -87,6 +88,7 @@ AC_ARG_WITH(system-pid-file, AS_HELP_STRING([--with-system-pid-file=[pidfile]],[
 AC_ARG_WITH(system-socket, AS_HELP_STRING([--with-system-socket=[filename]],[UNIX domain socket for systemwide daemon]))
 AC_ARG_WITH(console-auth-dir, AS_HELP_STRING([--with-console-auth-dir=[dirname]],[directory to check for console ownerhip]))
 AC_ARG_WITH(console-owner-file, AS_HELP_STRING([--with-console-owner-file=[filename]],[file whose owner determines current console owner]))
+AC_ARG_WITH(launchd-agent-dir, AS_HELP_STRING([--with-launchd-agent-dir=[dirname]],[directory to put the launchd agent (default: /Library/LaunchAgents)]))
 AC_ARG_WITH(dbus_user, AS_HELP_STRING([--with-dbus-user=<user>],[User for running the DBUS daemon (messagebus)]))
 AC_ARG_WITH(dbus_daemondir, AS_HELP_STRING([--with-dbus-daemondir=[dirname]],[Directory for installing the DBUS daemon]))
 
@@ -820,6 +822,38 @@ fi
 
 AM_CONDITIONAL(DBUS_BUS_ENABLE_KQUEUE, test x$have_kqueue = xyes) 
 
+# launchd checks
+if test x$enable_launchd = xno ; then
+    have_launchd=no
+else
+    have_launchd=yes
+    AC_CHECK_HEADER([launch.h], , have_launchd=no)
+    AC_PATH_PROG([LAUNCHCTL], [launchctl])
+    if test "x$LAUNCHCTL" = "x"; then
+        have_launchd=no
+    fi
+
+    if test x$enable_launchd = xyes -a x$have_launchd = xno ; then
+        AC_MSG_ERROR([launchd support explicitly enabled but not available])
+    fi
+fi
+
+dnl check if launchd is enabled
+if test x$have_launchd = xyes; then
+    AC_DEFINE(DBUS_ENABLE_LAUNCHD,1,[Use launchd autolaunch])
+fi
+
+AM_CONDITIONAL(DBUS_ENABLE_LAUNCHD, test x$have_launchd = xyes)
+
+#### Directory to place launchd agent file
+if test "x$with_launchd_agent_dir" = "x"; then
+   LAUNCHD_AGENT_DIR="/Library/LaunchAgents"
+else
+   LAUNCHD_AGENT_DIR="$with_launchd_agent_dir"
+fi
+
+AC_SUBST(LAUNCHD_AGENT_DIR)
+
 dnl console owner file
 if test x$enable_console_owner_file = xno ; then
     have_console_owner_file=no;
@@ -1279,6 +1313,14 @@ DBUS_SYSTEM_BUS_DEFAULT_ADDRESS="unix:path=$DBUS_SYSTEM_SOCKET"
 AC_SUBST(DBUS_SYSTEM_BUS_DEFAULT_ADDRESS)
 AC_DEFINE_UNQUOTED(DBUS_SYSTEM_BUS_DEFAULT_ADDRESS, "$DBUS_SYSTEM_BUS_DEFAULT_ADDRESS",[The default D-Bus address of the system bus])
 
+# set up the session bus address
+if test x$have_launchd = xyes; then
+   DBUS_SESSION_BUS_DEFAULT_ADDRESS="launchd:env=DBUS_LAUNCHD_SESSION_BUS_SOCKET"
+else
+   DBUS_SESSION_BUS_DEFAULT_ADDRESS="unix:tmpdir=$DBUS_SESSION_SOCKET_DIR"
+fi
+AC_SUBST(DBUS_SESSION_BUS_DEFAULT_ADDRESS)
+
 #### Set up the pid file
 if ! test -z "$with_system_pid_file"; then
    DBUS_SYSTEM_PID_FILE=$with_system_pid_file
@@ -1425,6 +1467,7 @@ dbus/dbus-arch-deps.h
 bus/system.conf
 bus/session.conf
 bus/messagebus
+bus/org.freedesktop.dbus-session.plist
 bus/rc.messagebus
 bus/dbus-daemon.1
 Makefile
@@ -1492,6 +1535,7 @@ echo "
         Building Doxygen docs:    ${enable_doxygen_docs}
         Building XML docs:        ${enable_xml_docs}
         Building cache support:   ${enable_userdb_cache}
+        Building launchd support: ${have_launchd}
         Gettext libs (empty OK):  ${INTLLIBS}
         Using XML parser:         ${with_xml}
         Init scripts style:       ${with_init_scripts}
@@ -1505,8 +1549,11 @@ echo "
         Console owner file path:  ${DBUS_CONSOLE_OWNER_FILE}
 	System bus user:          ${DBUS_USER}
 	Session bus services dir: ${EXPANDED_DATADIR}/dbus-1/services
-        'make check' socket dir:  ${TEST_SOCKET_DIR}
-"
+        'make check' socket dir:  ${TEST_SOCKET_DIR}"
+if test x$have_launchd = xyes; then
+        echo "        launchd agent dir:        ${LAUNCHD_AGENT_DIR}"
+fi
+echo
 
 if test x$enable_tests = xyes; then
         echo "NOTE: building with unit tests increases the size of the installed library and renders it insecure."
diff --git a/dbus/Makefile.am b/dbus/Makefile.am
index e966a43..ed0a4ae 100644
--- a/dbus/Makefile.am
+++ b/dbus/Makefile.am
@@ -70,6 +70,8 @@ DBUS_LIB_SOURCES=				\
 	dbus-server.c				\
 	dbus-server-debug-pipe.c		\
 	dbus-server-debug-pipe.h		\
+	dbus-server-launchd.c			\
+	dbus-server-launchd.h			\
 	dbus-server-protected.h			\
 	dbus-server-socket.c			\
 	dbus-server-socket.h			\
diff --git a/dbus/dbus-server-launchd.c b/dbus/dbus-server-launchd.c
new file mode 100644
index 0000000..3dc9992
--- /dev/null
+++ b/dbus/dbus-server-launchd.c
@@ -0,0 +1,207 @@
+/* dbus-server-launchd.c Server methods for interacting with launchd.
+ * Copyright (C) 2007, Tanner Lovelace <lovelace@wayfarer.org>
+ * Copyright (C) 2008, Benjamin Reed <rangerrick@befunk.com>
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <config.h>
+#include "dbus-server-launchd.h"
+
+/**
+ * @defgroup DBusServerLaunchd DBusServer implementations for Launchd
+ * @ingroup  DBusInternals
+ * @brief Implementation details of DBusServer with Launchd support
+ *
+ * @{
+ */
+
+#ifdef DBUS_ENABLE_LAUNCHD
+#include <launch.h>
+#include <errno.h>
+
+#include "dbus-server-socket.h"
+
+/* put other private launchd functions here */
+
+#endif /* DBUS_ENABLE_LAUNCHD */
+
+/**
+ * @brief Creates a new server from launchd.
+ *
+ * launchd has allocaed a socket for us. We now query launchd for the
+ * file descriptor of this socket and create a server on it.
+ * In addition we inherit launchd's environment which holds a variable
+ * containing the path to the socket. This is used to init the server's
+ * address which is passed to autolaunched services.
+ *
+ * @param launchd_env_var the environment variable which holds the unix path to the socket
+ * @param error location to store reason for failure.
+ * @returns the new server, or #NULL on failure.
+ */
+
+DBusServer *
+_dbus_server_new_for_launchd (const char *launchd_env_var, DBusError * error)
+{
+#ifdef DBUS_ENABLE_LAUNCHD
+  DBusServer *server;
+  DBusString address;
+  int launchd_fd;
+  launch_data_t sockets_dict, checkin_response;
+  launch_data_t checkin_request;
+  launch_data_t listening_fd_array, listening_fd;
+  launch_data_t environment_dict, environment_param;
+  const char *launchd_socket_path, *display;
+
+  launchd_socket_path = _dbus_getenv (launchd_env_var);
+  display = _dbus_getenv ("DISPLAY");
+
+  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+
+  if (launchd_socket_path == NULL || *launchd_socket_path == '\0')
+    {
+      dbus_set_error (error, DBUS_ERROR_BAD_ADDRESS,
+		      "launchd's environment variable %s is empty, but should contain a socket path.\n", launchd_env_var);
+      return NULL;
+    }
+
+  if (!_dbus_string_init (&address))
+    {
+      dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
+      return NULL;
+    }
+  if (!_dbus_string_append (&address, "unix:path="))
+    {
+      dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
+      goto l_failed_0;
+    }
+  if (!_dbus_string_append (&address, launchd_socket_path))
+    {
+      dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
+      goto l_failed_0;
+    }
+
+  if ((checkin_request = launch_data_new_string (LAUNCH_KEY_CHECKIN)) == NULL)
+    {
+      dbus_set_error (error, DBUS_ERROR_NO_MEMORY,
+		      "launch_data_new_string(\"%s\") Unable to create string.\n",
+		      LAUNCH_KEY_CHECKIN);
+      goto l_failed_0;
+    }
+
+  if ((checkin_response = launch_msg (checkin_request)) == NULL)
+    {
+      dbus_set_error (error, DBUS_ERROR_IO_ERROR,
+		      "launch_msg(\"%s\") IPC failure: %s\n",
+		      LAUNCH_KEY_CHECKIN, strerror (errno));
+      goto l_failed_0;
+    }
+
+  if (LAUNCH_DATA_ERRNO == launch_data_get_type (checkin_response))
+    {
+      dbus_set_error (error, DBUS_ERROR_FAILED, "Check-in failed: %s\n",
+		      strerror (launch_data_get_errno (checkin_response)));
+      goto l_failed_0;
+    }
+
+  sockets_dict =
+    launch_data_dict_lookup (checkin_response, LAUNCH_JOBKEY_SOCKETS);
+  if (NULL == sockets_dict)
+    {
+      dbus_set_error (error, DBUS_ERROR_IO_ERROR,
+		      "No sockets found to answer requests on!\n");
+      goto l_failed_0;
+    }
+
+  listening_fd_array =
+    launch_data_dict_lookup (sockets_dict, "unix_domain_listener");
+  if (NULL == listening_fd_array)
+    {
+      dbus_set_error (error, DBUS_ERROR_IO_ERROR,
+		      "No known sockets found to answer requests on!\n");
+      goto l_failed_0;
+    }
+
+  if (launch_data_array_get_count (listening_fd_array) != 1)
+    {
+      dbus_set_error (error, DBUS_ERROR_LIMITS_EXCEEDED,
+		      "Expected 1 socket from launchd, got %d.\n",
+		      launch_data_array_get_count (listening_fd_array));
+      goto l_failed_0;
+    }
+
+  listening_fd = launch_data_array_get_index (listening_fd_array, 0);
+  launchd_fd = launch_data_get_fd (listening_fd);
+
+  _dbus_fd_set_close_on_exec (launchd_fd);
+
+  if (launchd_fd < 0)
+    {
+      _DBUS_ASSERT_ERROR_IS_SET (error);
+      goto l_failed_0;
+    }
+
+  if (display == NULL || *display == '\0')
+    {
+      environment_dict = launch_data_dict_lookup (checkin_response, LAUNCH_JOBKEY_USERENVIRONMENTVARIABLES);
+      if (NULL == environment_dict)
+        {
+          _dbus_warn ("Unable to retrieve user environment from launchd.");
+        }
+      else
+        {
+          environment_param = launch_data_dict_lookup (environment_dict, "DISPLAY");
+          if (NULL == environment_dict)
+            {
+              _dbus_warn ("Unable to retrieve DISPLAY from launchd.");
+            }
+          else
+            {
+              display = launch_data_get_string(environment_param);
+              _dbus_setenv ("DISPLAY", display);
+            }
+        }
+    }
+
+  server = _dbus_server_new_for_socket (&launchd_fd, 1, &address);
+  if (server == NULL)
+    {
+      dbus_set_error (error, DBUS_ERROR_NO_SERVER,
+		      "Unable to listen on launchd fd %d.", launchd_fd);
+      goto l_failed_0;
+    }
+
+  _dbus_string_free (&address);
+
+  return server;
+
+l_failed_0:
+  _dbus_string_free (&address);
+
+  return NULL;
+#else /* DBUS_ENABLE_LAUNCHD */
+  dbus_set_error (error, DBUS_ERROR_BAD_ADDRESS,
+		  "address type 'launchd' requested, but launchd support not compiled in");
+  return NULL;
+#endif
+}
+
+/** @} */
diff --git a/dbus/dbus-server-launchd.h b/dbus/dbus-server-launchd.h
new file mode 100644
index 0000000..3a7f6d4
--- /dev/null
+++ b/dbus/dbus-server-launchd.h
@@ -0,0 +1,36 @@
+/* dbus-server-launchd.h Server methods for interacting with launchd.
+* Copyright (C) 2008, Benjamin Reed <rangerrick@befunk.com>
+*
+* Permission is hereby granted, free of charge, to any person
+* obtaining a copy of this software and associated documentation
+* files (the "Software"), to deal in the Software without
+* restriction, including without limitation the rights to use, copy,
+* modify, merge, publish, distribute, sublicense, and/or sell copies
+* of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be
+* included in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+* DEALINGS IN THE SOFTWARE.
+*/
+
+#ifndef DBUS_SERVER_LAUNCHD_H
+#define DBUS_SERVER_LAUNCHD_H
+
+#include <dbus/dbus-internals.h>
+#include <dbus/dbus-server-protected.h>
+
+DBUS_BEGIN_DECLS
+  DBusServer * _dbus_server_new_for_launchd (const char *launchd_env_var,
+					     DBusError * error);
+
+DBUS_END_DECLS
+#endif /* DBUS_SERVER_LAUNCHD_H */
diff --git a/dbus/dbus-server-unix.c b/dbus/dbus-server-unix.c
index fba9e9d..eb7882d 100644
--- a/dbus/dbus-server-unix.c
+++ b/dbus/dbus-server-unix.c
@@ -21,9 +21,11 @@
  *
  */
 
+#include <config.h>
 #include "dbus-internals.h"
 #include "dbus-server-unix.h"
 #include "dbus-server-socket.h"
+#include "dbus-server-launchd.h"
 #include "dbus-transport-unix.h"
 #include "dbus-connection-internal.h"
 #include "dbus-sysdeps-unix.h"
@@ -145,6 +147,27 @@ _dbus_server_listen_platform_specific (DBusAddressEntry *entry,
           return DBUS_SERVER_LISTEN_DID_NOT_CONNECT;
         }
     }
+  else if (strcmp (method, "launchd") == 0)
+    {
+      const char *launchd_env_var = dbus_address_entry_get_value (entry, "env");
+      if (launchd_env_var == NULL)
+        {
+          _dbus_set_bad_address (error, "launchd", "env", NULL);
+          return DBUS_SERVER_LISTEN_DID_NOT_CONNECT;
+        }
+      *server_p = _dbus_server_new_for_launchd (launchd_env_var, error);
+
+      if (*server_p != NULL)
+        {
+          _DBUS_ASSERT_ERROR_IS_CLEAR(error);
+          return DBUS_SERVER_LISTEN_OK;
+        }
+      else
+        {
+          _DBUS_ASSERT_ERROR_IS_SET(error);
+          return DBUS_SERVER_LISTEN_DID_NOT_CONNECT;
+        }
+    }
   else
     {
       /* If we don't handle the method, we return NULL with the
diff --git a/dbus/dbus-sysdeps-unix.c b/dbus/dbus-sysdeps-unix.c
index 1268768..f241884 100644
--- a/dbus/dbus-sysdeps-unix.c
+++ b/dbus/dbus-sysdeps-unix.c
@@ -3168,6 +3168,91 @@ _dbus_read_local_machine_uuid (DBusGUID   *machine_id,
 #define DBUS_UNIX_STANDARD_SYSTEM_SERVICEDIR "/dbus-1/system-services"
 
 /**
+ * quries launchd for a specific env var which holds the socket path.
+ * @param launchd_env_var the env var to look up
+ * @param error a DBusError to store the error in case of failure
+ * @return the value of the env var
+ */
+const char *
+_dbus_lookup_launchd_socket (const char *launchd_env_var,
+                             DBusError  *error)
+{
+#ifdef DBUS_ENABLE_LAUNCHD
+  char *argv[4];
+  int i;
+  DBusString socket_path;
+  
+  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+
+  if (!_dbus_string_init (&socket_path))
+    {
+      _DBUS_SET_OOM (error);
+      return FALSE;
+    }
+  
+  i = 0;
+  argv[i] = "launchctl";
+  ++i;
+  argv[i] = "getenv";
+  ++i;
+  argv[i] = (char*)launchd_env_var;
+  ++i;
+  argv[i] = NULL;
+  ++i;
+
+  _dbus_assert (i == _DBUS_N_ELEMENTS (argv));
+
+  if (!_read_subprocess_line_argv(argv[0], TRUE, argv, &socket_path, error))
+    {
+      _dbus_string_free(&socket_path);
+      return NULL;
+    }
+
+  /* no error, but no result either */
+  if (_dbus_string_get_length(&socket_path) == 0)
+    {
+      _dbus_string_free(&socket_path);
+      return NULL;
+    }
+
+  /* strip the carriage-return */
+  _dbus_string_shorten(&socket_path, 1);
+  return _dbus_string_get_const_data(&socket_path);
+#else /* DBUS_ENABLE_LAUNCHD */
+  dbus_set_error(error, DBUS_ERROR_NOT_SUPPORTED,
+                "can't lookup socket from launchd; launchd support not compiled in");
+  return NULL;
+#endif
+}
+
+static dbus_bool_t
+_dbus_lookup_session_address_launchd (DBusString *address, DBusError  *error)
+{
+  const char *launchd_socket = _dbus_lookup_launchd_socket ("DBUS_LAUNCHD_SESSION_BUS_SOCKET", error);
+  if (dbus_error_is_set(error))
+    return FALSE;
+  if (launchd_socket == NULL)
+    {
+      dbus_set_error(error, "no socket path",
+                "launchd did not provide a socket path, "
+                "verify that org.freedesktop.dbus-session.plist is loaded!");
+      return FALSE;
+    }
+  if (!_dbus_string_append (address, "unix:path="))
+    {
+      _DBUS_SET_OOM (error);
+      return FALSE;
+    }
+  if (!_dbus_string_append (address, launchd_socket))
+    {
+      _DBUS_SET_OOM (error);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/**
  * Determines the address of the session bus by querying a
  * platform-specific method.  
  *
@@ -3191,12 +3276,17 @@ _dbus_lookup_session_address (dbus_bool_t *supported,
                               DBusString  *address,
                               DBusError   *error)
 {
+#ifdef DBUS_ENABLE_LAUNCHD
+  *supported = TRUE;
+  return _dbus_lookup_session_address_launchd (address, error);
+#else
   /* On non-Mac Unix platforms, if the session address isn't already
    * set in DBUS_SESSION_BUS_ADDRESS environment variable, we punt and
    * fall back to the autolaunch: global default; see 
    * init_session_address in dbus/dbus-bus.c. */
   *supported = FALSE;
   return TRUE;
+#endif
 }
 
 /**
diff --git a/dbus/dbus-sysdeps-unix.h b/dbus/dbus-sysdeps-unix.h
index ecd20f6..051aeba 100644
--- a/dbus/dbus-sysdeps-unix.h
+++ b/dbus/dbus-sysdeps-unix.h
@@ -77,6 +77,9 @@ dbus_bool_t _dbus_read_credentials (int               client_fd,
 dbus_bool_t _dbus_send_credentials (int              server_fd,
                                     DBusError       *error);
 
+const char *_dbus_lookup_launchd_socket (const char *launchd_env_var,
+                                         DBusError  *error);
+
 /** Information about a UNIX user */
 typedef struct DBusUserInfo  DBusUserInfo;
 /** Information about a UNIX group */
diff --git a/dbus/dbus-transport-unix.c b/dbus/dbus-transport-unix.c
index a4452aa..180cc19 100644
--- a/dbus/dbus-transport-unix.c
+++ b/dbus/dbus-transport-unix.c
@@ -171,6 +171,41 @@ _dbus_transport_open_platform_specific (DBusAddressEntry  *entry,
           return DBUS_TRANSPORT_OPEN_OK;
         }      
     }
+  else if (strcmp (method, "launchd") == 0)
+    {
+      const char *launchd_env_var = dbus_address_entry_get_value (entry, "env");
+      DBusError tmp_error = DBUS_ERROR_INIT;
+      if (launchd_env_var == NULL)
+        {
+          _dbus_set_bad_address (error, "launchd", "env", NULL);
+          return DBUS_TRANSPORT_OPEN_BAD_ADDRESS;
+        }
+
+      const char *launchd_socket = _dbus_lookup_launchd_socket (launchd_env_var, error);
+      if (launchd_socket)
+        {
+          *transport_p = _dbus_transport_new_for_domain_socket (launchd_socket, FALSE,
+                                                                error);
+        }
+        else
+        {
+          dbus_set_error(&tmp_error, DBUS_ERROR_BAD_ADDRESS,
+                         "launchd's env var %s does not exist", launchd_env_var);
+          dbus_error_free(error);
+          dbus_move_error(&tmp_error, error);
+        }
+
+      if (*transport_p == NULL)
+        {
+          _DBUS_ASSERT_ERROR_IS_SET (error);
+          return DBUS_TRANSPORT_OPEN_DID_NOT_CONNECT;
+        }
+      else
+        {
+          _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+          return DBUS_TRANSPORT_OPEN_OK;
+        }
+    }
   else
     {
       _DBUS_ASSERT_ERROR_IS_CLEAR (error);
diff -Nurd dbus-1.2.16/dbus-glib-0.82/tools/Makefile.in dbus-1.2.16-new/dbus-glib-0.82/tools/Makefile.in
--- dbus-1.2.16/dbus-glib-0.82/tools/Makefile.in	2009-07-16 13:45:34.000000000 -0400
+++ dbus-1.2.16-new/dbus-glib-0.82/tools/Makefile.in	2009-07-21 10:42:25.000000000 -0400
@@ -522,7 +522,7 @@
 @USE_INTROSPECT_XML_TRUE@dbus-bus-introspect.xml: $(INTROSPECT_XML_PATH)
 @USE_INTROSPECT_XML_TRUE@	cp $(INTROSPECT_XML_PATH) dbus-bus-introspect.xml
 @USE_INTROSPECT_XML_FALSE@dbus-bus-introspect.xml:
-@USE_INTROSPECT_XML_FALSE@	DBUS_TOP_BUILDDIR=$(top_builddir) @DBUS_DAEMONDIR@dbus-daemon --introspect > dbus-bus-introspect.xml.tmp && mv dbus-bus-introspect.xml.tmp dbus-bus-introspect.xml
+@USE_INTROSPECT_XML_FALSE@	DBUS_TOP_BUILDDIR=$(top_builddir) ../../bus/dbus-daemon --introspect > dbus-bus-introspect.xml.tmp && mv dbus-bus-introspect.xml.tmp dbus-bus-introspect.xml
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Nurd dbus-1.2.16/dbus-xinitrc.sh dbus-1.2.16-new/dbus-xinitrc.sh
--- dbus-1.2.16/dbus-xinitrc.sh	1969-12-31 19:00:00.000000000 -0500
+++ dbus-1.2.16-new/dbus-xinitrc.sh	2009-07-21 10:43:56.000000000 -0400
@@ -0,0 +1,8 @@
+#!/bin/sh
+
+if [ -n "$DISPLAY" ]; then
+	LDISPLAY=`launchctl getenv DISPLAY`
+	if [ -z "$LDISPLAY" ]; then
+		launchctl setenv DISPLAY "$DISPLAY"
+	fi
+fi
diff -Nurd dbus-1.2.16/start-session-bus.sh dbus-1.2.16-new/start-session-bus.sh
--- dbus-1.2.16/start-session-bus.sh	1969-12-31 19:00:00.000000000 -0500
+++ dbus-1.2.16-new/start-session-bus.sh	2009-07-21 10:41:53.000000000 -0400
@@ -0,0 +1,7 @@
+#!/bin/sh -e
+
+if [ `launchctl list 2>/dev/null | grep -c org.finkproject.dbus-session` -eq 0 ]; then
+      launchctl load "@FINKPREFIX@/share/dbus/launchd/org.finkproject.dbus-session.plist"
+fi
+
+exit 0
diff -Nurd dbus-1.2.16/start-system-bus.sh dbus-1.2.16-new/start-system-bus.sh
--- dbus-1.2.16/start-system-bus.sh	1969-12-31 19:00:00.000000000 -0500
+++ dbus-1.2.16-new/start-system-bus.sh	2009-07-21 10:41:53.000000000 -0400
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+if [ -f "@FINKPREFIX@/etc/dbus-1/disable-dbus" ]; then
+      exit 0
+fi
+
+if [ -f "@FINKPREFIX@/var/run/dbus/pid" ]; then
+      PID=`cat "@FINKPREFIX@/var/run/dbus/pid"`
+      if [ `/bin/ps -p "${PID}" 2>/dev/null | grep -c "^ *${PID} "` -eq 0 ]; then
+              rm -f "@FINKPREFIX@/var/run/dbus/pid"
+              exec "@FINKPREFIX@/bin/dbus-daemon" --system
+      fi
+else
+      exec "@FINKPREFIX@/bin/dbus-daemon" --system
+fi
+
+exit 0
