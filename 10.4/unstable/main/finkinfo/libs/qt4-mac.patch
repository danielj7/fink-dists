diff --git a/README.kde-qt b/README.kde-qt
new file mode 100644
index 0000000..cbbd970
--- /dev/null
+++ b/README.kde-qt
@@ -0,0 +1,269 @@
+This is a patched version of Qt.  It may include changes made by KDE
+and Qt developers that have either not been accepted for inclusion
+into Qt, or have been accepted for a later version of Qt than this
+one.
+
+1. Configuring Qt
+=================
+
+The recommended compile line is:
+
+--default-config-begin--
+
+  ./configure -qt-gif -debug -fast -no-separate-debug-info \
+     -system-libpng -system-libjpeg -system-zlib \
+     -dbus -webkit -plugin-sql-mysql \
+     -nomake examples -nomake demos -prefix <installdir>
+
+--default-config-end--
+
+It contains "-debug", which greatly improves the use for backtraces (but
+also needs a lot more disk space and makes things slower). To build in
+release mode, replace it with "-release".
+
+It also contains "-no-separate-debug-info", which disables separate .debug
+files. Instead, the debug information will be built into the libraries.
+This option is needed when you install Qt.
+
+If you don't install Qt, it can be useful to disable this option,
+thus having separate debug symbol files. With separate debug files, you can
+just move those debug files to another directory to remove Qt debug symbols.
+Moving the files back will enable Qt debug symbols again.
+This is useful if you rarely need to step into Qt functions during debugging,
+because GDB loads much faster and uses less memory without Qt debug symbols.
+In the rare case you need to step into Qt code, you can temporarily enable
+debug symbols again by moving the debug files back. You can even load the Qt
+debug symbols from within GDB on demand, using the "symbol-file" command.
+
+If you are planning to compile Qt using an Icecream cluster you have to
+pass the option -no-pch (no precompiled headers) to configure to make
+distributed compilation work.
+
+2. Compiling Qt
+===============
+
+To compile Qt on a Unix platform, run:
+
+   export MAKEFLAGS=-j2
+   make
+   make install
+
+If your computer has more than one core or processor, you may consider
+increasing the "2" above. If you've got a compile farm available, you
+should adjust the -j argument to match the number of slots in that
+farm.
+
+3. Modifying & rebuilding Qt
+============================
+
+If you make modifications to the Qt source code, you don't need to
+build everything again. Simply go to the directory containing the
+Makefile closest to the files you changed and run "make" again.
+
+For example, if you've modified src/corelib/io/qiodevice.cpp, do:
+
+   cd src/corelib
+   make
+
+If you make a change that is not temporary, you should create a Git
+commit out of it. However, you shouldn't push those changes to
+kde-qt.git. If you have a fix that benefit others, see the "Creating
+kde-qt.git modifications" section below.
+
+4. Building Qt examples and demos
+=================================
+
+The "-nomake examples -nomake demos" arguments to the configure script
+mean that those two sections will not be configured for building,
+which is unneeded for usage of the library.  If you want to compile
+the examples or demos later, just enter either directory and type:
+
+   qmake
+   make
+
+5. Build Qt tests
+=================
+
+(Official information: http://qt.gitorious.org/qt/pages/QtAutotestsEnvironment)
+
+In order to run Qt tests, you must have a "developer build" of Qt. For
+that, you need to reconfigure Qt and add the "-developer-build"
+option. That option is technically equivalent to the options:
+
+   -debug -prefix $PWD -DQT_BUILD_INTERNAL
+
+To run a test, go to its source dir in tests/auto/testname. Type
+"make" to build it, then run it (either ./tst_testname, or "make install").
+
+6. Building Qt documentation
+============================
+
+To build and install the documentation, run:
+
+   make docs
+   ./config.status
+   make install
+
+It is necessary to do this once only, even if you rebuild Qt later.
+
+7. Using Qt uninstalled
+=======================
+
+To use without having to install it, configure it as follows:
+
+   ./configure <other configure options>  -prefix $PWD
+   make sub-src
+   make sub-tools
+
+Attention: DO NOT run
+
+   make install
+
+If you do, Qt will overwrite your include/ directory with its
+installation.
+
+8. Creating kde-qt.git modifications
+====================================
+
+If you have fixed a bug in Qt or modified it in any way that may
+benefit others, please share your change in the form of a patch. Do
+not commit your changes directly to the main branch because they
+may be lost in a future update if they have not been added to the
+official Qt release.
+
+The exception to the above rule is that if the fix has been accepted
+by the Qt developers (and so will appear in the very next release of
+Qt), then it should be simply cherry-picked from the Qt development
+branch. Note that you shouldn't do this for changes that have been
+accepted into a release which is not the very next.  In this case, you
+should use the following command:
+
+   git cherry-pick -x SHA1_OF_THE_FIX
+where SHA1_OF_THE_FIX is the SHA-1 of the commit that you want to
+introduce. Then push the change to the server.
+
+In all other cases, before creating a patch, it is recommended to
+contact the Qt developers via a new task in
+http://bugreports.qt.nokia.com and explain the situation. There may be
+a solution for the problem already or a new direction that should be
+accounted for.
+
+To create a patch, do the following:
+  a) look at the listing of branches in
+  http://qt.gitorious.org/+kde-developers/qt/kde-qt/commits/HEAD and
+  select the next number.
+
+  b) create a new branch out of a clean, released version of Qt, (for
+  example, 4.5.1), using the number above and a brief description of
+  your fix. For example:
+      git checkout -b patches/0180-window-role v4.5.1
+  You can see the available released versions of Qt with:
+      git tag
+
+  c) make your changes to the Qt source code and verify that it
+  compiles, links and works (please run the respective unit tests from
+  tests/auto in the source tree).
+
+  c) commit your changes to Git, using the "git commit" command. Please
+  see http://qt.gitorious.org/qt/pages/GitIntroductionWithQt and
+  http://qt.gitorious.org/qt/pages/QtCodingStyle for information on
+  how to create commits
+
+  Note that you are allowed to create as many commits as necessary to
+  accomplish a working change that can be easily reviewed.
+
+  e) merge the change to the patch branch, for example, 4.5.1-patched:
+      git checkout 4.5.1-patched
+      git merge patches/0180-window-role
+
+  f) merge the patch branch to master:
+      git checkout master
+      git merge 4.5.1-patched
+
+  g) push the changes you made to your branch and to the main server:
+      git push git@gitorious.org:qt/kde-qt.git master 4.5.1-patched patches/0180-window-role
+  (Don't forget to list all 3 branch names)
+
+Don't forget to submit your patch to using the Qt Contribution Model,
+along with the long description of the issue found. See
+http://qt.gitorious.org/qt/pages/QtContributionGuidelines for
+information how. You can submit the branch you've just sent to the
+server.
+
+9. Troubleshooting: Re-configuring and re-compiling
+===================================================
+
+For those updating the source in a directory where Qt has already
+been compiled, you may need to run the following commands from the
+top directory of your Qt sources:
+
+	find . -name '*.moc' | xargs rm
+
+Sometimes ./configure will refuse to run.  You may need to:
+	rm .qmake.cache
+
+If you think you may have run "make install" on an install-less Qt
+(srcdir == $QTDIR), run:
+
+	rm -rf include
+	bin/syncqt
+
+10. Maintenance: updating kde-qt to a newer Qt version
+======================================================
+
+When a new version of Qt is released, do the following to update the
+repository (assuming Qt 4.6.1 is the release you're updating to):
+
+ a) rebase each of the individual patches against this new version.
+      for branch in patches/*; do
+        git checkout -b $branch origin/$branch
+        git rebase v4.6.1
+        resolve conflicts
+      done   # Note: pseudo-shell, don't try to run this
+
+    If a given branch is no longer valid (it's been applied to this Qt
+    version), then delete it on the server:
+      git push origin :$branch
+
+ b) create a new "patched" branch locally, starting on the release tag:
+      git checkout -b 4.6.1-patched v4.6.1
+
+ c) merge the patch branches and the README branch, one by one. There
+    should be no conflicts at this stage; if there are, it indicates
+    one patch conflicts with another.
+      git merge patches/0997-patch1
+      git merge patches/0998-patch2
+      git merge patches/0999-patch3
+      # etc.
+      git merge README
+
+ d) overwrite the master branch's contents with the new branch. If the
+    Git merge strategy "theirs" exist (it doesn't as of Git 1.6), use
+    it:
+      git checkout master
+      git merge -s theirs 4.6.1-patched
+
+    If it doesn't exist, do the equivalent by inverting the point of
+    view:
+      git checkout -b tmp 4.6.1-patched
+      git merge -s ours master
+      git checkout master
+      git merge tmp
+      git branch -d tmp
+
+    Also possible using Git plumbing:
+      git checkout master
+      git merge -s ours --no-commit 4.6.1-patched
+      rm .git/index
+      git read-tree 4.6.1-patched
+      git commit
+
+  e) push everything to kde-qt.git, including the new Qt. Note that
+     the individiual patch branches will require force, because they
+     have been rebased (that is, the new branch tip is no longer a
+     direct descendant of the previous tip).
+
+      # Push the individual patch branches with force
+      git push -f origin patches/0997-patch1 patches/0998-patch2 patches/0999-patch3 etc
+      # Push the tag, the new patched branch and master
+      git push v4.6.1 4.6.1-patched master
diff --git a/bin/syncqt b/bin/syncqt
index 620256e..e2998fd 100755
--- a/bin/syncqt
+++ b/bin/syncqt
@@ -366,9 +366,13 @@ sub fixPaths {
         $match_dir = $tmp;
         $i = $slash;
     }
+    my $cnt_ofs = 0;
+    if($match_dir =~ /^[a-zA-Z]:$/) {
+      $cnt_ofs = 1;
+    }
     if($match_dir) {
         my $after = substr($dir, length($match_dir));
-        my $count = ($after =~ tr,/,,);
+        my $count = ($after =~ tr,/,,) - $cnt_ofs;
         my $dots = "";
         for(my $i = 0; $i < $count; $i++) {
             $dots .= "../";
diff --git a/config.tests/unix/3dnow/3dnow.pro b/config.tests/unix/3dnow/3dnow.pro
index 90a8a19..791c5a3 100644
--- a/config.tests/unix/3dnow/3dnow.pro
+++ b/config.tests/unix/3dnow/3dnow.pro
@@ -1,3 +1,2 @@
 SOURCES = 3dnow.cpp
-CONFIG -= x11 qt
-mac:CONFIG -= app_bundle
+CONFIG -= x11 qt app_bundle
diff --git a/config.tests/unix/clock-gettime/clock-gettime.pro b/config.tests/unix/clock-gettime/clock-gettime.pro
index c527535..50ba344 100644
--- a/config.tests/unix/clock-gettime/clock-gettime.pro
+++ b/config.tests/unix/clock-gettime/clock-gettime.pro
@@ -1,4 +1,3 @@
 SOURCES = clock-gettime.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 include(clock-gettime.pri)
diff --git a/config.tests/unix/clock-monotonic/clock-monotonic.pro b/config.tests/unix/clock-monotonic/clock-monotonic.pro
index 961e3a8..9e8c35f 100644
--- a/config.tests/unix/clock-monotonic/clock-monotonic.pro
+++ b/config.tests/unix/clock-monotonic/clock-monotonic.pro
@@ -1,4 +1,3 @@
 SOURCES = clock-monotonic.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 include(../clock-gettime/clock-gettime.pri)
diff --git a/config.tests/unix/cups/cups.pro b/config.tests/unix/cups/cups.pro
index d7b78c8..7d8447a 100644
--- a/config.tests/unix/cups/cups.pro
+++ b/config.tests/unix/cups/cups.pro
@@ -1,4 +1,3 @@
 SOURCES = cups.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lcups
diff --git a/config.tests/unix/db2/db2.pro b/config.tests/unix/db2/db2.pro
index 0fa39a8..8ee9365 100644
--- a/config.tests/unix/db2/db2.pro
+++ b/config.tests/unix/db2/db2.pro
@@ -1,4 +1,3 @@
 SOURCES = db2.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -ldb2
diff --git a/config.tests/unix/dbus/dbus.pro b/config.tests/unix/dbus/dbus.pro
index 1e4aea7..d307629 100644
--- a/config.tests/unix/dbus/dbus.pro
+++ b/config.tests/unix/dbus/dbus.pro
@@ -1,3 +1,2 @@
 SOURCES = dbus.cpp
-CONFIG -= qt
-mac:CONFIG -= app_bundle
+CONFIG -= qt app_bundle
diff --git a/config.tests/unix/doubleformat/doubleformattest.pro b/config.tests/unix/doubleformat/doubleformattest.pro
index 7e51dea..08284ee 100644
--- a/config.tests/unix/doubleformat/doubleformattest.pro
+++ b/config.tests/unix/doubleformat/doubleformattest.pro
@@ -1,3 +1,2 @@
 SOURCES = doubleformattest.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/endian/endiantest.pro b/config.tests/unix/endian/endiantest.pro
index 7b739eb..bab6273 100644
--- a/config.tests/unix/endian/endiantest.pro
+++ b/config.tests/unix/endian/endiantest.pro
@@ -1,3 +1,2 @@
 SOURCES = endiantest.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/floatmath/floatmath.pro b/config.tests/unix/floatmath/floatmath.pro
index 4c78563..7478b4d 100644
--- a/config.tests/unix/floatmath/floatmath.pro
+++ b/config.tests/unix/floatmath/floatmath.pro
@@ -1,3 +1,2 @@
 SOURCES = floatmath.cpp
-CONFIG -= x11 qt
-
+CONFIG -= x11 qt app_bundle
diff --git a/config.tests/unix/freetype/freetype.pro b/config.tests/unix/freetype/freetype.pro
index e84158e..afd7b6f 100644
--- a/config.tests/unix/freetype/freetype.pro
+++ b/config.tests/unix/freetype/freetype.pro
@@ -1,5 +1,5 @@
 SOURCES = freetype.cpp
 CONFIG += x11
-CONFIG -= qt
+CONFIG -= qt app_bundle
 LIBS += -lfreetype
 include(freetype.pri)
diff --git a/config.tests/unix/getaddrinfo/getaddrinfo.pro b/config.tests/unix/getaddrinfo/getaddrinfo.pro
index c9121db..af63815 100644
--- a/config.tests/unix/getaddrinfo/getaddrinfo.pro
+++ b/config.tests/unix/getaddrinfo/getaddrinfo.pro
@@ -1,4 +1,3 @@
 SOURCES = getaddrinfotest.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += $$QMAKE_LIBS_NETWORK
diff --git a/config.tests/unix/getifaddrs/getifaddrs.pro b/config.tests/unix/getifaddrs/getifaddrs.pro
index c3fead6..aa44091 100644
--- a/config.tests/unix/getifaddrs/getifaddrs.pro
+++ b/config.tests/unix/getifaddrs/getifaddrs.pro
@@ -1,5 +1,4 @@
 SOURCES = getifaddrs.cpp
-CONFIG -= qt
-mac:CONFIG -= app_bundle
+CONFIG -= qt app_bundle
 QT =
 LIBS += $$QMAKE_LIBS_NETWORK
diff --git a/config.tests/unix/glib/glib.pro b/config.tests/unix/glib/glib.pro
index 15d059d..c7cd53d 100644
--- a/config.tests/unix/glib/glib.pro
+++ b/config.tests/unix/glib/glib.pro
@@ -1,2 +1,2 @@
 SOURCES = glib.cpp
-CONFIG -= qt
+CONFIG -= qt app_bundle
diff --git a/config.tests/unix/gnu-libiconv/gnu-libiconv.pro b/config.tests/unix/gnu-libiconv/gnu-libiconv.pro
index d879b20..02ad928 100644
--- a/config.tests/unix/gnu-libiconv/gnu-libiconv.pro
+++ b/config.tests/unix/gnu-libiconv/gnu-libiconv.pro
@@ -1,4 +1,3 @@
 SOURCES = gnu-libiconv.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -liconv
diff --git a/config.tests/unix/gstreamer/gstreamer.pro b/config.tests/unix/gstreamer/gstreamer.pro
index 7d4aa8e..29fc886 100644
--- a/config.tests/unix/gstreamer/gstreamer.pro
+++ b/config.tests/unix/gstreamer/gstreamer.pro
@@ -1,3 +1,3 @@
 SOURCES = gstreamer.cpp
-CONFIG -= qt
+CONFIG -= qt app_bundle
 LIBS += -lgstinterfaces-0.10 -lgstvideo-0.10 -lgstbase-0.10
diff --git a/config.tests/unix/ibase/ibase.pro b/config.tests/unix/ibase/ibase.pro
index 01e7429..f54130f 100644
--- a/config.tests/unix/ibase/ibase.pro
+++ b/config.tests/unix/ibase/ibase.pro
@@ -1,4 +1,3 @@
 SOURCES = ibase.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lgds
diff --git a/config.tests/unix/iconv/iconv.pro b/config.tests/unix/iconv/iconv.pro
index 8cdc776..336069b 100644
--- a/config.tests/unix/iconv/iconv.pro
+++ b/config.tests/unix/iconv/iconv.pro
@@ -1,3 +1,4 @@
 SOURCES = iconv.cpp
 CONFIG -= qt dylib app_bundle
 mac:LIBS += -liconv
+darwin-*:LIBS += -liconv
diff --git a/config.tests/unix/inotify/inotify.pro b/config.tests/unix/inotify/inotify.pro
index e2e1560..eea124e 100644
--- a/config.tests/unix/inotify/inotify.pro
+++ b/config.tests/unix/inotify/inotify.pro
@@ -1,3 +1,2 @@
 SOURCES = inotifytest.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/ipv6/ipv6.pro b/config.tests/unix/ipv6/ipv6.pro
index c51e61b..e0090f9 100644
--- a/config.tests/unix/ipv6/ipv6.pro
+++ b/config.tests/unix/ipv6/ipv6.pro
@@ -1,3 +1,2 @@
 SOURCES = ipv6test.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/ipv6ifname/ipv6ifname.pro b/config.tests/unix/ipv6ifname/ipv6ifname.pro
index ed62869..c15966a 100644
--- a/config.tests/unix/ipv6ifname/ipv6ifname.pro
+++ b/config.tests/unix/ipv6ifname/ipv6ifname.pro
@@ -1,5 +1,4 @@
 SOURCES = ipv6ifname.cpp
-CONFIG -= qt
-mac:CONFIG -= app_bundle
+CONFIG -= qt app_bundle
 QT =
 LIBS += $$QMAKE_LIBS_NETWORK
diff --git a/config.tests/unix/largefile/largefile.pro b/config.tests/unix/largefile/largefile.pro
index d7affc6..a466935 100644
--- a/config.tests/unix/largefile/largefile.pro
+++ b/config.tests/unix/largefile/largefile.pro
@@ -1,3 +1,2 @@
 SOURCES=largefiletest.cpp
-CONFIG-=qt dylib
-mac:CONFIG -= app_bundle
+CONFIG-=qt dylib app_bundle
diff --git a/config.tests/unix/libjpeg/libjpeg.pro b/config.tests/unix/libjpeg/libjpeg.pro
index d06888c..ad91bb8 100644
--- a/config.tests/unix/libjpeg/libjpeg.pro
+++ b/config.tests/unix/libjpeg/libjpeg.pro
@@ -1,4 +1,3 @@
 SOURCES = libjpeg.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -ljpeg
diff --git a/config.tests/unix/libmng/libmng.pro b/config.tests/unix/libmng/libmng.pro
index ee57ecd..147e916 100644
--- a/config.tests/unix/libmng/libmng.pro
+++ b/config.tests/unix/libmng/libmng.pro
@@ -1,4 +1,3 @@
 SOURCES = libmng.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lmng
diff --git a/config.tests/unix/libpng/libpng.pro b/config.tests/unix/libpng/libpng.pro
index f038386..74e53e0 100644
--- a/config.tests/unix/libpng/libpng.pro
+++ b/config.tests/unix/libpng/libpng.pro
@@ -1,4 +1,3 @@
 SOURCES = libpng.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lpng
diff --git a/config.tests/unix/libtiff/libtiff.pro b/config.tests/unix/libtiff/libtiff.pro
index 60ba7d1..122bb83 100644
--- a/config.tests/unix/libtiff/libtiff.pro
+++ b/config.tests/unix/libtiff/libtiff.pro
@@ -1,4 +1,3 @@
 SOURCES = libtiff.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -ltiff
diff --git a/config.tests/unix/mmx/mmx.pro b/config.tests/unix/mmx/mmx.pro
index d2fea7f..66352ae 100644
--- a/config.tests/unix/mmx/mmx.pro
+++ b/config.tests/unix/mmx/mmx.pro
@@ -1,3 +1,2 @@
 SOURCES = mmx.cpp
-CONFIG -= x11 qt
-mac:CONFIG -= app_bundle
+CONFIG -= x11 qt app_bundle
diff --git a/config.tests/unix/mremap/mremap.pro b/config.tests/unix/mremap/mremap.pro
index a36d756..7516e3b 100644
--- a/config.tests/unix/mremap/mremap.pro
+++ b/config.tests/unix/mremap/mremap.pro
@@ -1,3 +1,2 @@
 SOURCES = mremap.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/mysql/mysql.pro b/config.tests/unix/mysql/mysql.pro
index a22579e..ad7b9c9 100644
--- a/config.tests/unix/mysql/mysql.pro
+++ b/config.tests/unix/mysql/mysql.pro
@@ -1,4 +1,3 @@
 SOURCES = mysql.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lmysqlclient
diff --git a/config.tests/unix/mysql_r/mysql_r.pro b/config.tests/unix/mysql_r/mysql_r.pro
index 8c06067..1838533 100644
--- a/config.tests/unix/mysql_r/mysql_r.pro
+++ b/config.tests/unix/mysql_r/mysql_r.pro
@@ -1,4 +1,3 @@
 SOURCES = ../mysql/mysql.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lmysqlclient_r
diff --git a/config.tests/unix/nis/nis.pro b/config.tests/unix/nis/nis.pro
index 1f985b2..5d4fd2a 100644
--- a/config.tests/unix/nis/nis.pro
+++ b/config.tests/unix/nis/nis.pro
@@ -1,5 +1,4 @@
 SOURCES = nis.cpp
-CONFIG -= qt dylib
-mac: CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 solaris-*:LIBS += -lnsl
 else:LIBS += $$QMAKE_LIBS_NIS
diff --git a/config.tests/unix/oci/oci.pro b/config.tests/unix/oci/oci.pro
index 4add225..eeccbea 100644
--- a/config.tests/unix/oci/oci.pro
+++ b/config.tests/unix/oci/oci.pro
@@ -1,4 +1,3 @@
 SOURCES = oci.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lclntsh
diff --git a/config.tests/unix/odbc/odbc.pro b/config.tests/unix/odbc/odbc.pro
index c588ede..f7a8766 100644
--- a/config.tests/unix/odbc/odbc.pro
+++ b/config.tests/unix/odbc/odbc.pro
@@ -1,4 +1,3 @@
 SOURCES = odbc.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lodbc
diff --git a/config.tests/unix/openssl/openssl.pro b/config.tests/unix/openssl/openssl.pro
index 6891e78..275af07 100644
--- a/config.tests/unix/openssl/openssl.pro
+++ b/config.tests/unix/openssl/openssl.pro
@@ -1,4 +1,3 @@
 SOURCES = openssl.cpp
-CONFIG -= x11 qt
-mac:CONFIG -= app_bundle
+CONFIG -= x11 qt app_bundle
 include(openssl.pri)
diff --git a/config.tests/unix/psql/psql.pro b/config.tests/unix/psql/psql.pro
index 64bb3d6..2227104 100644
--- a/config.tests/unix/psql/psql.pro
+++ b/config.tests/unix/psql/psql.pro
@@ -1,4 +1,3 @@
 SOURCES = psql.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lpq
diff --git a/config.tests/unix/ptrsize/ptrsizetest.pro b/config.tests/unix/ptrsize/ptrsizetest.pro
index 41aba86..e480bf4 100644
--- a/config.tests/unix/ptrsize/ptrsizetest.pro
+++ b/config.tests/unix/ptrsize/ptrsizetest.pro
@@ -1,3 +1,2 @@
 SOURCES = ptrsizetest.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/sqlite/sqlite.pro b/config.tests/unix/sqlite/sqlite.pro
index ba2cac1..62380f1 100644
--- a/config.tests/unix/sqlite/sqlite.pro
+++ b/config.tests/unix/sqlite/sqlite.pro
@@ -1,3 +1,2 @@
 SOURCES = sqlite.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/sqlite2/sqlite2.pro b/config.tests/unix/sqlite2/sqlite2.pro
index 14a64d5..e7bac94 100644
--- a/config.tests/unix/sqlite2/sqlite2.pro
+++ b/config.tests/unix/sqlite2/sqlite2.pro
@@ -1,4 +1,3 @@
 SOURCES = sqlite2.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lsqlite
diff --git a/config.tests/unix/sse/sse.pro b/config.tests/unix/sse/sse.pro
index 4cc34a7..7e09bc2 100644
--- a/config.tests/unix/sse/sse.pro
+++ b/config.tests/unix/sse/sse.pro
@@ -1,3 +1,2 @@
 SOURCES = sse.cpp
-CONFIG -= x11 qt
-mac:CONFIG -= app_bundle
+CONFIG -= x11 qt app_bundle
diff --git a/config.tests/unix/sse2/sse2.pro b/config.tests/unix/sse2/sse2.pro
index d4a21aa..8350c6b 100644
--- a/config.tests/unix/sse2/sse2.pro
+++ b/config.tests/unix/sse2/sse2.pro
@@ -1,3 +1,2 @@
 SOURCES = sse2.cpp
-CONFIG -= x11 qt
-mac:CONFIG -= app_bundle
+CONFIG -= x11 qt app_bundle
diff --git a/config.tests/unix/stl/stl.pro b/config.tests/unix/stl/stl.pro
index a2feab4..6b75323 100644
--- a/config.tests/unix/stl/stl.pro
+++ b/config.tests/unix/stl/stl.pro
@@ -1,3 +1,2 @@
 SOURCES = stltest.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/tds/tds.pro b/config.tests/unix/tds/tds.pro
index 5516a14..9e5ce70 100644
--- a/config.tests/unix/tds/tds.pro
+++ b/config.tests/unix/tds/tds.pro
@@ -1,4 +1,3 @@
 SOURCES = tds.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lsybdb
diff --git a/config.tests/unix/tslib/tslib.pro b/config.tests/unix/tslib/tslib.pro
index 1191120..825fe31 100644
--- a/config.tests/unix/tslib/tslib.pro
+++ b/config.tests/unix/tslib/tslib.pro
@@ -1,3 +1,3 @@
 SOURCES = tslib.cpp
-CONFIG -= qt 
+CONFIG -= qt app_bundle 
 LIBS += -lts
diff --git a/config.tests/unix/zlib/zlib.pro b/config.tests/unix/zlib/zlib.pro
index 67cc870..8460548 100644
--- a/config.tests/unix/zlib/zlib.pro
+++ b/config.tests/unix/zlib/zlib.pro
@@ -1,4 +1,3 @@
 SOURCES = zlib.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lz
diff --git a/config.tests/x11/opengl/opengl.pro b/config.tests/x11/opengl/opengl.pro
index 432bd8d..d2841f7 100644
--- a/config.tests/x11/opengl/opengl.pro
+++ b/config.tests/x11/opengl/opengl.pro
@@ -7,4 +7,4 @@ for(p, QMAKE_LIBDIR_OPENGL) {
 }
 
 CONFIG -= qt
-LIBS += -lGL -lGLU
+LIBS += -lGL -lGLU -Wl,-dylib_file,/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib
diff --git a/configure b/configure
index 033f415..fd75809 100755
--- a/configure
+++ b/configure
@@ -179,6 +179,7 @@ UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 #-------------------------------------------------------------------------------
 
 PLATFORM_X11=no
+PLATFORM_DARWIN=no
 PLATFORM_MAC=no
 PLATFORM_QWS=no
 
@@ -236,7 +237,7 @@ fi
 #-------------------------------------------------------------------------------
 # check the license
 #-------------------------------------------------------------------------------
-COMMERCIAL_USER=ask
+COMMERCIAL_USER=no
 CFG_DEV=no
 CFG_NOKIA=no
 CFG_EMBEDDED=no
@@ -1029,6 +1030,11 @@ while [ "$#" -gt 0 ]; do
             VAL=`echo $1 | sed 's,-D,,'`
         fi
         ;;
+    -isystem)
+        VAR="add_isystempath"
+        shift
+        VAL="$1"
+        ;;
     -I?*|-I)
         VAR="add_ipath"
         if [ "$1" = "-I" ]; then
@@ -1281,6 +1287,7 @@ while [ "$#" -gt 0 ]; do
     x11)
         if [ "$PLATFORM_MAC" = "yes" ]; then
             PLATFORM_MAC=no
+            PLATFORM_DARWIN=yes
         elif [ "$PLATFORM_QWS" = "yes" ]; then
             PLATFORM_QWS=no
         fi
@@ -2047,6 +2054,9 @@ while [ "$#" -gt 0 ]; do
     add_ipath)
         I_FLAGS="$I_FLAGS -I\"${VAL}\""
         ;;
+    add_isystempath)
+        I_FLAGS="$I_FLAGS -isystem \"${VAL}\""
+        ;;
     add_lpath)
         L_FLAGS="$L_FLAGS -L\"${VAL}\""
         ;;
@@ -2946,7 +2956,7 @@ else
 fi
 
 QMAKE_CONF_COMPILER=`getQMakeConf "$XQMAKESPEC" | grep "^QMAKE_CXX[^_A-Z0-9]" | sed "s,.* *= *\(.*\)$,\1," | tail -1`
-TEST_COMPILER="$CC"
+TEST_COMPILER="$CXX"
 [ -z "$TEST_COMPILER" ] && TEST_COMPILER=$QMAKE_CONF_COMPILER
 if [ -z "$TEST_COMPILER" ]; then
     echo "ERROR: Cannot set the compiler for the configuration tests"
@@ -4424,6 +4434,9 @@ if true; then ###[ '!' -f "$outpath/bin/qmake" ];
 		EXTRA_LFLAGS="$EXTRA_LFLAGS \$(SDK_LFLAGS)"
             fi
         fi
+	if [ "$PLATFORM_X11" = "yes" ] && [ "$PLATFORM_DARWIN" = "yes" ]; then
+	    EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS -D__USE_WS_X11__"
+	fi
         [ "$CFG_EMBEDDED" != "no" ] && EXTRA_CFLAGS="$EXTRA_CFLAGS -DQWS"
         if [ '!' -z "$D_FLAGS" ]; then
             for DEF in $D_FLAGS; do
@@ -5410,7 +5423,7 @@ if [ "$PLATFORM_X11" = "yes" ]; then
 fi # X11
 
 
-if [ "$PLATFORM_MAC" = "yes" ]; then
+if [ "$PLATFORM_MAC" = "yes" ] || [ "$PLATFORM_DARWIN" = "yes" ]; then
     if [ "$CFG_PHONON" != "no" ]; then
         # Always enable Phonon (unless it was explicitly disabled)
         CFG_PHONON=yes
@@ -5553,7 +5566,7 @@ if [ "$CFG_LIBFREETYPE" = "auto" ]; then
 fi
 
 if [ "$CFG_ENDIAN" = "auto" ]; then
-    if [ "$PLATFORM_MAC" = "yes" ]; then
+    if [ "$PLATFORM_MAC" = "yes" ] || [ "$PLATFORM_DARWIN" = "yes" ]; then
 	true #leave as auto
     else
         "$unixtests/endian.test" "$XQMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath"
@@ -5574,7 +5587,7 @@ if [ "$CFG_ENDIAN" = "auto" ]; then
 fi
 
 if [ "$CFG_HOST_ENDIAN" = "auto" ]; then
-    if [ "$PLATFORM_MAC" = "yes" ]; then
+    if [ "$PLATFORM_MAC" = "yes" ] || [ "$PLATFORM_DARWIN" = "yes" ]; then
 	true #leave as auto
     else
         "$unixtests/endian.test" "$QMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath"
@@ -6222,7 +6235,7 @@ else
     QT_CONFIG="$QT_CONFIG freetype"
 fi
 
-if [ "x$PLATFORM_MAC" = "xyes" ]; then
+if [ "x$PLATFORM_MAC" = "xyes" ] || [ "x$PLATFORM_DARWIN" = "xyes" ]; then
     #On Mac we implicitly link against libz, so we
     #never use the 3rdparty stuff.
     [ "$CFG_ZLIB" = "yes" ] && CFG_ZLIB="system"
@@ -6302,7 +6315,7 @@ fi
 [ '!' -z "$L_FLAGS" ] && QMakeVar add QMAKE_LIBDIR_FLAGS "$L_FLAGS"
 [ '!' -z "$l_FLAGS" ] && QMakeVar add LIBS "$l_FLAGS"
 
-if [ "$PLATFORM_MAC" = "yes" ]; then
+if [ "$PLATFORM_MAC" = "yes" ] || [ "$PLATFORM_DARWIN" = "yes" ]; then
     if [ "$CFG_RPATH" = "yes" ]; then
        QMAKE_CONFIG="$QMAKE_CONFIG absolute_library_soname"
     fi
@@ -6911,7 +6924,7 @@ if [ "$CFG_FRAMEWORK" = "yes" ]; then
     echo "#define QT_MAC_FRAMEWORK_BUILD" >>"$outpath/src/corelib/global/qconfig.h.new"
 fi
 
-if [ "$PLATFORM_MAC" = "yes" ]; then
+if [ "$PLATFORM_MAC" = "yes" ] || [ "$PLATFORM_DARWIN" = "yes" ]; then
     cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
 #if defined(__LP64__)
 # define QT_POINTER_SIZE 8
diff --git a/configure-for-fink.sh b/configure-for-fink.sh
new file mode 100755
index 0000000..58e09ef
--- /dev/null
+++ b/configure-for-fink.sh
@@ -0,0 +1,57 @@
+#!/bin/sh -e
+
+MYDIR=`dirname $0`
+TOPDIR=`cd $MYDIR; pwd`
+
+FINKPREFIX="$1"; shift
+PKGNAME="$1"; shift
+
+if [ -z "$FINKPREFIX" ] || [ -z "$PKGNAME" ]; then
+	echo "usage: $0 <fink_prefix> <pkgname>"
+	exit 1
+fi
+
+QTDIR=`pwd`
+PATH="$QTDIR/bin:$FINKPREFIX/lib/freetype219/bin:$PATH"
+
+EXTRA_ARGS=""
+
+[ -z "$CC"  ] && CC=gcc-4.0
+[ -z "$CXX" ] && CXX=g++-4.0
+
+if [ "$PKGNAME" = "qt4-x11" ]; then
+	EXTRA_ARGS="-x11 -platform darwin-g++ -xplatform darwin-g++"
+else
+	EXTRA_ARGS="-platform macx-g++ -xplatform macx-g++"
+fi
+
+case `sw_vers -productVersion` in
+	10.[01234]*)
+		;;
+	*)
+		LDFLAGS="$LDFLAGS -Wl,-dead_strip_dylibs"
+		;;
+esac
+
+export FINKPREFIX QTDIR PATH LIBRESOLV CC CXX EXTRA_ARGS LDFLAGS
+
+echo "yes" | sh $TOPDIR/configure \
+	"-I$FINKPREFIX/lib/system-openssl/include" "-L$FINKPREFIX/lib/system-openssl/lib" \
+	"-I$FINKPREFIX/lib/freetype219/include" "-I$FINKPREFIX/lib/freetype219/include/freetype2" "-L$FINKPREFIX/lib/freetype219/lib" \
+	"-I$FINKPREFIX/lib/fontconfig2/include" "-I$FINKPREFIX/lib/fontconfig2/include" "-L$FINKPREFIX/lib/fontconfig2/lib" \
+	"-I$FINKPREFIX/include" -isystem /usr/X11R6/include "-L$FINKPREFIX/lib" "-L/usr/X11R6/lib" \
+	-prefix "$FINKPREFIX/lib/$PKGNAME" -docdir "$FINKPREFIX/share/doc/$PKGNAME" \
+	-no-fast -webkit -openssl-linked -reduce-exports \
+	-exceptions -qt-gif -system-freetype -phonon -phonon-backend \
+	-no-sql-ibase -no-sql-mysql -no-sql-odbc -no-sql-psql \
+	-plugin-sql-sqlite -dbus-linked $EXTRA_ARGS "$@"
+
+# don't link against older versions of self
+/usr/bin/find . -name Makefile -print0 | xargs -0 perl -pi -e "s,-L$FINKPREFIX/lib/$PKGNAME/lib,,g"
+
+# attempt to counterfix qmake's warped fileFixify logic that makes install break
+# when $FINKPREFIX is a symlink and something exists already at -libdir or -datadir etc
+pushd $FINKPREFIX;
+	FixifiedSW=`/bin/pwd`;
+popd
+/usr/bin/find . -name Makefile -print0 | xargs -0 perl -pi -e "s,\\$\\(INSTALL_ROOT\\)$FixifiedSW,\\$\\(INSTALL_ROOT\\)$FINKPREFIX,g"
diff --git a/mkspecs/common/mac-g++.conf b/mkspecs/common/mac-g++.conf
index 1863898..0f99197 100644
--- a/mkspecs/common/mac-g++.conf
+++ b/mkspecs/common/mac-g++.conf
@@ -55,7 +55,7 @@ QMAKE_LFLAGS_RELEASE	+=
 QMAKE_LFLAGS_DEBUG	+=
 QMAKE_LFLAGS_APP	+=
 QMAKE_LFLAGS_SHLIB	+= -single_module -dynamiclib
-QMAKE_LFLAGS_PLUGIN	+= $$QMAKE_LFLAGS_SHLIB
+QMAKE_LFLAGS_PLUGIN	+= -bundle -flat_namespace
 QMAKE_LFLAGS_THREAD	+=
 QMAKE_LFLAGS_INCREMENTAL+= -undefined suppress -flat_namespace
 QMAKE_LFLAGS_SONAME	+= -install_name$${LITERAL_WHITESPACE}
diff --git a/mkspecs/common/mac.conf b/mkspecs/common/mac.conf
index 5d88ac4..651a126 100644
--- a/mkspecs/common/mac.conf
+++ b/mkspecs/common/mac.conf
@@ -5,6 +5,7 @@
 QMAKE_RESOURCE		= /Developer/Tools/Rez
 
 QMAKE_EXTENSION_SHLIB	= dylib
+QMAKE_EXTENSION_PLUGIN	= bundle
 
 QMAKE_LIBDIR		=
 QMAKE_INCDIR_QT		= $$[QT_INSTALL_HEADERS]
@@ -17,7 +18,7 @@ QMAKE_FIX_RPATH         = install_name_tool -id
 QMAKE_RPATH		=
 
 QMAKE_LIBS_DYNLOAD	=
-QMAKE_LIBS_OPENGL	= -framework OpenGL -framework AGL
+QMAKE_LIBS_OPENGL	= -framework OpenGL -framework AGL -Wl,-dylib_file,/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib
 QMAKE_LIBS_OPENGL_QT	= $$QMAKE_LIBS_OPENGL
 QMAKE_LIBS_THREAD	=
 
diff --git a/mkspecs/darwin-g++/qmake.conf b/mkspecs/darwin-g++/qmake.conf
index 72baa89..4b02ed0 100644
--- a/mkspecs/darwin-g++/qmake.conf
+++ b/mkspecs/darwin-g++/qmake.conf
@@ -6,7 +6,7 @@
 
 MAKEFILE_GENERATOR	= UNIX
 TEMPLATE		= app
-CONFIG			+= qt warn_on release link_prl native_precompiled_headers
+CONFIG			+= qt warn_on release lib_version_first link_prl native_precompiled_headers
 QT			+= core gui
 DEFINES                 += __USE_WS_X11__
 
@@ -69,12 +69,13 @@ QMAKE_LFLAGS_VERSION    = -current_version$${LITERAL_WHITESPACE}
 QMAKE_LFLAGS_COMPAT_VERSION = -compatibility_version$${LITERAL_WHITESPACE}
 
 QMAKE_RPATH		=
+QMAKE_FIX_RPATH		= install_name_tool -id 
 
 QMAKE_LIBS_DYNLOAD	=
 QMAKE_LIBS_X11		= -lXext -lX11 -lm
 QMAKE_LIBS_X11SM	= -lSM -lICE
-QMAKE_LIBS_OPENGL	= -lGLU -lGL
-QMAKE_LIBS_OPENGL_QT	= -lGL
+QMAKE_LIBS_OPENGL	= -lGLU -lGL -Wl,-dylib_file,/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib
+QMAKE_LIBS_OPENGL_QT	= -lGL -Wl,-dylib_file,/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib
 QMAKE_LIBS_THREAD	=
 
 QMAKE_MOC		= $$[QT_INSTALL_BINS]/moc
diff --git a/projects.pro b/projects.pro
index d405a5b..7ad3b58 100644
--- a/projects.pro
+++ b/projects.pro
@@ -154,6 +154,9 @@ unix {
    DEFAULT_QMAKESPEC ~= s,^.*mkspecs/,,g
    mkspecs.commands += $(DEL_FILE) $(INSTALL_ROOT)$$mkspecs.path/default; $(SYMLINK) $$DEFAULT_QMAKESPEC $(INSTALL_ROOT)$$mkspecs.path/default
 }
+win32 {
+   mkspecs.files += $$QT_BUILD_TREE/mkspecs/default
+}
 INSTALLS += mkspecs
 
 false:macx { #mac install location
diff --git a/qmake/generators/mac/pbuilder_pbx.cpp b/qmake/generators/mac/pbuilder_pbx.cpp
index 488d8d0..1c21110 100644
--- a/qmake/generators/mac/pbuilder_pbx.cpp
+++ b/qmake/generators/mac/pbuilder_pbx.cpp
@@ -52,7 +52,7 @@
 #  include <sys/types.h>
 #  include <sys/stat.h>
 #endif
-#ifdef Q_OS_DARWIN
+#ifdef Q_OS_MAC
 #include <ApplicationServices/ApplicationServices.h>
 #include <private/qcore_mac_p.h>
 #endif
@@ -1689,7 +1689,7 @@ ProjectBuilderMakefileGenerator::pbuilderVersion() const
     } else {
         QString version, version_plist = project->first("QMAKE_PBUILDER_VERSION_PLIST");
         if(version_plist.isEmpty()) {
-#ifdef Q_OS_DARWIN
+#ifdef Q_OS_MAC
             ret = QLatin1String("34");
             QCFType<CFURLRef> cfurl;
             OSStatus err = LSFindApplicationForInfo(0, CFSTR("com.apple.Xcode"), 0, 0, &cfurl);
diff --git a/qmake/property.cpp b/qmake/property.cpp
index ea4842a..ac54854 100644
--- a/qmake/property.cpp
+++ b/qmake/property.cpp
@@ -81,29 +81,32 @@ QMakeProperty::keyBase(bool version) const
 QString
 QMakeProperty::value(QString v, bool just_check)
 {
+    QString ret;
     if(v == "QT_INSTALL_PREFIX")
-        return QLibraryInfo::location(QLibraryInfo::PrefixPath);
+        ret = QLibraryInfo::location(QLibraryInfo::PrefixPath);
     else if(v == "QT_INSTALL_DATA")
-        return QLibraryInfo::location(QLibraryInfo::DataPath);
+        ret = QLibraryInfo::location(QLibraryInfo::DataPath);
     else if(v == "QT_INSTALL_DOCS")
-        return QLibraryInfo::location(QLibraryInfo::DocumentationPath);
+        ret = QLibraryInfo::location(QLibraryInfo::DocumentationPath);
     else if(v == "QT_INSTALL_HEADERS")
-        return QLibraryInfo::location(QLibraryInfo::HeadersPath);
+        ret = QLibraryInfo::location(QLibraryInfo::HeadersPath);
     else if(v == "QT_INSTALL_LIBS")
-        return QLibraryInfo::location(QLibraryInfo::LibrariesPath);
+        ret = QLibraryInfo::location(QLibraryInfo::LibrariesPath);
     else if(v == "QT_INSTALL_BINS")
-        return QLibraryInfo::location(QLibraryInfo::BinariesPath);
+        ret = QLibraryInfo::location(QLibraryInfo::BinariesPath);
     else if(v == "QT_INSTALL_PLUGINS")
-        return QLibraryInfo::location(QLibraryInfo::PluginsPath);
+        ret = QLibraryInfo::location(QLibraryInfo::PluginsPath);
     else if(v == "QT_INSTALL_TRANSLATIONS")
-        return QLibraryInfo::location(QLibraryInfo::TranslationsPath);
+        ret = QLibraryInfo::location(QLibraryInfo::TranslationsPath);
     else if(v == "QT_INSTALL_CONFIGURATION")
-        return QLibraryInfo::location(QLibraryInfo::SettingsPath);
+        ret = QLibraryInfo::location(QLibraryInfo::SettingsPath);
     else if(v == "QT_INSTALL_EXAMPLES")
-        return QLibraryInfo::location(QLibraryInfo::ExamplesPath);
+        ret = QLibraryInfo::location(QLibraryInfo::ExamplesPath);
     else if(v == "QT_INSTALL_DEMOS")
-        return QLibraryInfo::location(QLibraryInfo::DemosPath);
-    else if(v == "QMAKE_MKSPECS")
+        ret = QLibraryInfo::location(QLibraryInfo::DemosPath);
+    if(!ret.isEmpty())
+        return QDir::toNativeSeparators(ret);
+    if(v == "QMAKE_MKSPECS")
         return qmake_mkspec_paths().join(Option::target_mode == Option::TARG_WIN_MODE ? ";" : ":");
     else if(v == "QMAKE_VERSION")
         return qmake_version();
@@ -116,7 +119,7 @@ QMakeProperty::value(QString v, bool just_check)
     int slash = v.lastIndexOf('/');
     QVariant var = settings->value(keyBase(slash == -1) + v);
     bool ok = var.isValid();
-    QString ret = var.toString();
+    ret = var.toString();
     if(!ok) {
         QString version = qmake_version();
         if(slash != -1) {
diff --git a/src/3rdparty/phonon/CMakeLists.txt b/src/3rdparty/phonon/CMakeLists.txt
index a25ec5d..c931199 100644
--- a/src/3rdparty/phonon/CMakeLists.txt
+++ b/src/3rdparty/phonon/CMakeLists.txt
@@ -55,7 +55,7 @@ if (CMAKE_COMPILER_IS_GNUCXX)
    if (CMAKE_SYSTEM_NAME MATCHES Linux)
      set ( CMAKE_C_FLAGS     "${CMAKE_C_FLAGS} -Wno-long-long -std=iso9899:1990 -Wundef -Wcast-align -Werror-implicit-function-declaration -Wchar-subscripts -Wall -W -Wpointer-arith -Wwrite-strings -Wformat-security -Wmissing-format-attribute -fno-common")
      set ( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wnon-virtual-dtor -Wno-long-long -ansi -Wundef -Wcast-align -Wchar-subscripts -Wall -W -Wpointer-arith -Wformat-security -fno-exceptions -fno-check-new -fno-common")
-     add_definitions (-D_BSD_SOURCE -DQT_NO_EXCEPTIONS)
+     add_definitions (-D_BSD_SOURCE)
    endif (CMAKE_SYSTEM_NAME MATCHES Linux)
 
    # gcc under Windows
@@ -115,7 +115,7 @@ if (CMAKE_COMPILER_IS_GNUCXX)
       string(REGEX MATCH "(--enable-libstdcxx-allocator=mt)" _GCC_COMPILED_WITH_BAD_ALLOCATOR "${_gcc_alloc_info}")
    endif (GCC_IS_NEWER_THAN_4_1)
 
-   if (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR AND NOT WIN32)
+   if (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR)
       set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility=hidden")
       set (KDE4_C_FLAGS "-fvisibility=hidden")
       # check that Qt defines Q_DECL_EXPORT as __attribute__ ((visibility("default")))
@@ -137,9 +137,9 @@ if (CMAKE_COMPILER_IS_GNUCXX)
       if (GCC_IS_NEWER_THAN_4_2)
           set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility-inlines-hidden")
       endif (GCC_IS_NEWER_THAN_4_2)
-   else (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR AND NOT WIN32)
+   else (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR)
       set (__KDE_HAVE_GCC_VISIBILITY 0)
-   endif (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR AND NOT WIN32)
+   endif (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR)
 
 endif (CMAKE_COMPILER_IS_GNUCXX)
 
@@ -149,7 +149,7 @@ set(CMAKE_COLOR_MAKEFILE ON)
 
 set(PHONON_LIB_MAJOR_VERSION "4")
 set(PHONON_LIB_MINOR_VERSION "3")
-set(PHONON_LIB_PATCH_VERSION "50")
+set(PHONON_LIB_PATCH_VERSION "80")
 set(PHONON_LIB_VERSION "${PHONON_LIB_MAJOR_VERSION}.4.0")
 set(PHONON_LIB_SOVERSION ${PHONON_LIB_MAJOR_VERSION})
 
@@ -177,15 +177,11 @@ endmacro(_SET_FANCY)
 
 set(LIB_SUFFIX "" CACHE STRING "Define suffix of directory name (32/64)" )
 
-if (WIN32)
-    _set_fancy(EXEC_INSTALL_PREFIX         "."                                     "Base directory for executables and libraries")
-else(WIN32)
-    _set_fancy(EXEC_INSTALL_PREFIX         "${CMAKE_INSTALL_PREFIX}"              "Base directory for executables and libraries")
-endif(WIN32)
-_set_fancy(SHARE_INSTALL_PREFIX        "${EXEC_INSTALL_PREFIX}/share"             "Base directory for files which go to share/")
-_set_fancy(INCLUDE_INSTALL_DIR         "${EXEC_INSTALL_PREFIX}/include"           "The subdirectory to the header prefix")
+_set_fancy(EXEC_INSTALL_PREFIX         "${CMAKE_INSTALL_PREFIX}"                   "Base directory for executables and libraries")
+_set_fancy(SHARE_INSTALL_PREFIX        "${CMAKE_INSTALL_PREFIX}/share"             "Base directory for files which go to share/")
 _set_fancy(BIN_INSTALL_DIR             "${EXEC_INSTALL_PREFIX}/bin"                "The install dir for executables (default ${EXEC_INSTALL_PREFIX}/bin)")
 _set_fancy(LIB_INSTALL_DIR             "${EXEC_INSTALL_PREFIX}/lib${LIB_SUFFIX}"   "The subdirectory relative to the install prefix where libraries will be installed (default is ${EXEC_INSTALL_PREFIX}/lib${LIB_SUFFIX})")
+_set_fancy(INCLUDE_INSTALL_DIR         "${CMAKE_INSTALL_PREFIX}/include"           "The subdirectory to the header prefix")
 _set_fancy(PLUGIN_INSTALL_DIR          "${LIB_INSTALL_DIR}/kde4"                   "The subdirectory relative to the install prefix where plugins will be installed (default is ${LIB_INSTALL_DIR}/kde4)")
 _set_fancy(ICON_INSTALL_DIR            "${SHARE_INSTALL_PREFIX}/icons"             "The icon install dir (default ${SHARE_INSTALL_PREFIX}/share/icons/)")
 _set_fancy(SERVICES_INSTALL_DIR        "${SHARE_INSTALL_PREFIX}/kde4/services"     "The install dir for service (desktop, protocol, ...) files")
@@ -200,8 +196,6 @@ set(INSTALL_TARGETS_DEFAULT_ARGS  RUNTIME DESTINATION "${BIN_INSTALL_DIR}"
 if(APPLE)
    set(INSTALL_TARGETS_DEFAULT_ARGS  ${INSTALL_TARGETS_DEFAULT_ARGS}
                                      BUNDLE DESTINATION "${BUNDLE_INSTALL_DIR}" )
-	set(CMAKE_SHARED_MODULE_CREATE_C_FLAGS   "${CMAKE_SHARED_MODULE_CREATE_C_FLAGS}   -flat_namespace -undefined dynamic_lookup")
-	set(CMAKE_SHARED_MODULE_CREATE_CXX_FLAGS "${CMAKE_SHARED_MODULE_CREATE_CXX_FLAGS} -flat_namespace -undefined dynamic_lookup")
 endif(APPLE)
 
 if (CMAKE_SYSTEM_NAME MATCHES Linux)
@@ -255,6 +249,7 @@ if(APPLE)
 endif(APPLE)
 
 
+add_subdirectory(cmake)
 add_subdirectory(phonon)
 add_subdirectory(includes)
 if (Q_WS_MAC AND BUILD_PHONON_QT7)
@@ -266,7 +261,7 @@ endif (Q_WS_WIN)
 
 if (Q_WS_X11)
    add_subdirectory(gstreamer)
-   add_subdirectory(xine)
+#   add_subdirectory(xine)
 endif (Q_WS_X11)
 
 if(NOT WIN32) # pkgconfig file
diff --git a/src/3rdparty/phonon/Mainpage.dox b/src/3rdparty/phonon/Mainpage.dox
new file mode 100644
index 0000000..bf73440
--- /dev/null
+++ b/src/3rdparty/phonon/Mainpage.dox
@@ -0,0 +1,64 @@
+/** @mainpage The Phonon Library API Reference
+
+<p><b>
+Overview |
+@ref development
+</b></p>
+
+<a href="http://phonon.kde.org/">Phonon</a> provides a Qt-style interface for audio
+and video.  It is aimed at the average desktop application, whether that is a game
+that needs sound effects or a full-blown multimedia playback application like
+<a href="http://amarok.kde.org/">Amarok</a> or
+<a href="http://www.dragonplayer.org/">Dragon Player</a>.
+
+If you writing a Qt program and want audio or video playback, then Phonon is almost
+certainly the right choice for you.  It provides an API that any Qt developer will
+be comfortable with, and uses the native sound systems on Windows and MacOS.  On
+UNIX systems, where there is no one standard multimedia system, it offers
+<a href="http://www.gstreamer.net/">GStreamer</a> and <a href="http://xinehq.de/">Xine</a>
+backends, and more (such as <a href="http://www.videolan.org/">VLC</a>) are available
+from third parties.
+
+However, Phonon is not aimed at professional audio applications (in the style of
+<a href="http://audacity.sourceforge.net/">Audacity</a>, say).  For these applications,
+you will probably want more control over the audio layer than Phonon will give you,
+and you should probably be using something like <a href="http://jackaudio.org/">JACK</a>.
+
+@authors
+Matthias Kretz \<kretz@kde.org\><br>
+Ricardo Villalba \<rvm@escomposlinux.org\><br>
+Ian Monroe \<ian@monroe.nu\><br>
+Nokia Corporation and/or its subsidiary(-ies)
+
+@maintainers
+Matthias Kretz \<kretz@kde.org\>
+
+@licenses
+Libraries: @lgpl<br>
+Examples: @mit<br>
+Backends: @lgpl or @gpl
+
+*/
+
+/** @page development Development
+
+<p><b>
+@ref index "Overview" |
+Development
+</b></p>
+
+If you want to get involved with Phonon backend development please subscribe to <a href="https://mail.kde.org/mailman/listinfo/phonon-backends">phonon-backends@kde.org</a>.
+
+If you want to contribute, make comments or useful suggestions you can also write to the <a href="mailto:kde-multimedia@kde.org">KDE Multimedia mailinglist</a> or <a href="mailto:kretz@kde.org">Matthias Kretz</a>. You can join the mailinglist using the <a href="https://mail.kde.org/mailman/listinfo/kde-multimedia">webinterface</a> or take a look at the <a href="http://lists.kde.org/?l=kde-multimedia">archives</a>
+
+*/
+
+// DOXYGEN_VERSION=4.3
+// DOXYGEN_NAME=Phonon
+// DOXYGEN_ENABLE=YES
+// DOXYGEN_SET_INPUT = @topdir@/phonon/phonon @topdir@/phonon/Mainpage.dox
+// DOXYGEN_SET_FILE_PATTERNS = *.h *.dox */phononnamespace.h.in
+// ignore backend docs
+// DOXYGEN_SET_EXCLUDE_PATTERNS = *interface.h */phonon/examples/* */tests/* *_p.h */experimental/videocapturedevice/* */phonon/backend*
+
+// vim:ts=4:sw=4:expandtab:filetype=doxygen
diff --git a/src/3rdparty/phonon/cmake/COPYING-CMAKE-SCRIPTS b/src/3rdparty/phonon/cmake/COPYING-CMAKE-SCRIPTS
new file mode 100644
index 0000000..4b41776
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/COPYING-CMAKE-SCRIPTS
@@ -0,0 +1,22 @@
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+1. Redistributions of source code must retain the copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products 
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/src/3rdparty/phonon/cmake/FindAlsa.cmake b/src/3rdparty/phonon/cmake/FindAlsa.cmake
new file mode 100644
index 0000000..23003b3
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/FindAlsa.cmake
@@ -0,0 +1,69 @@
+# Alsa check, based on libkmid/configure.in.in.
+# Only the support for Alsa >= 0.9.x was included; 0.5.x was dropped (but feel free to re-add it if you need it)
+# It defines ...
+# It offers the following macros:
+#  ALSA_CONFIGURE_FILE(config_header) - generate a config.h, typical usage: 
+#                                       ALSA_CONFIGURE_FILE(${CMAKE_BINARY_DIR}/config-alsa.h)
+#  ALSA_VERSION_STRING(version_string)  looks for alsa/version.h and reads the version string into
+#                                       the first argument passed to the macro
+
+# Copyright (c) 2006, David Faure, <faure@kde.org>
+# Copyright (c) 2007, Matthias Kretz <kretz@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+include(CheckIncludeFiles)
+include(CheckIncludeFileCXX)
+include(CheckLibraryExists)
+
+# Already done by toplevel
+find_library(ASOUND_LIBRARY asound)
+set(ASOUND_LIBRARY_DIR "")
+if(ASOUND_LIBRARY)
+   get_filename_component(ASOUND_LIBRARY_DIR ${ASOUND_LIBRARY} PATH)
+endif(ASOUND_LIBRARY)
+
+check_library_exists(asound snd_seq_create_simple_port "${ASOUND_LIBRARY_DIR}" HAVE_LIBASOUND2)
+if(HAVE_LIBASOUND2)
+    message(STATUS "Found ALSA: ${ASOUND_LIBRARY}")
+else(HAVE_LIBASOUND2)
+    message(STATUS "ALSA not found")
+endif(HAVE_LIBASOUND2)
+set(ALSA_FOUND ${HAVE_LIBASOUND2})
+
+find_path(ALSA_INCLUDES alsa/version.h)
+
+macro(ALSA_VERSION_STRING _result)
+    # check for version in alsa/version.h
+    if(ALSA_INCLUDES)
+        file(READ "${ALSA_INCLUDES}/alsa/version.h" _ALSA_VERSION_CONTENT)
+        string(REGEX REPLACE ".*SND_LIB_VERSION_STR.*\"(.*)\".*" "\\1" ${_result} ${_ALSA_VERSION_CONTENT})
+    else(ALSA_INCLUDES)
+        message(STATUS "ALSA version not known. ALSA output will probably not work correctly.")
+    endif(ALSA_INCLUDES)
+endmacro(ALSA_VERSION_STRING _result)
+
+
+get_filename_component(_FIND_ALSA_MODULE_DIR ${CMAKE_CURRENT_LIST_FILE} PATH)
+macro(ALSA_CONFIGURE_FILE _destFile)
+    check_include_files(sys/soundcard.h HAVE_SYS_SOUNDCARD_H)
+    check_include_files(machine/soundcard.h HAVE_MACHINE_SOUNDCARD_H)
+
+    check_include_files(linux/awe_voice.h HAVE_LINUX_AWE_VOICE_H)
+    check_include_files(awe_voice.h HAVE_AWE_VOICE_H)
+    check_include_files(/usr/src/sys/i386/isa/sound/awe_voice.h HAVE__USR_SRC_SYS_I386_ISA_SOUND_AWE_VOICE_H)
+    check_include_files(/usr/src/sys/gnu/i386/isa/sound/awe_voice.h HAVE__USR_SRC_SYS_GNU_I386_ISA_SOUND_AWE_VOICE_H)
+
+    check_include_file_cxx(sys/asoundlib.h HAVE_SYS_ASOUNDLIB_H)
+    check_include_file_cxx(alsa/asoundlib.h HAVE_ALSA_ASOUNDLIB_H)
+
+    check_library_exists(asound snd_pcm_resume "${ASOUND_LIBRARY_DIR}" ASOUND_HAS_SND_PCM_RESUME)
+    if(ASOUND_HAS_SND_PCM_RESUME)
+        set(HAVE_SND_PCM_RESUME 1)
+    endif(ASOUND_HAS_SND_PCM_RESUME)
+
+    configure_file(${_FIND_ALSA_MODULE_DIR}/config-alsa.h.cmake ${_destFile})
+endmacro(ALSA_CONFIGURE_FILE _destFile)
+
+mark_as_advanced(ALSA_INCLUDES ASOUND_LIBRARY)
diff --git a/src/3rdparty/phonon/cmake/FindAutomoc4.cmake b/src/3rdparty/phonon/cmake/FindAutomoc4.cmake
new file mode 100644
index 0000000..86baf8d
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/FindAutomoc4.cmake
@@ -0,0 +1,81 @@
+# - Try to find automoc4
+# Once done this will define
+#
+#  AUTOMOC4_FOUND - automoc4 has been found
+#  AUTOMOC4_EXECUTABLE - the automoc4 tool
+#  AUTOMOC4_VERSION - the full version of automoc4
+#  AUTOMOC4_VERSION_MAJOR, AUTOMOC4_VERSION_MINOR, AUTOMOC4_VERSION_PATCH - AUTOMOC4_VERSION 
+#                     broken into its components
+#
+# It also adds the following macros
+#  AUTOMOC4(<target> <SRCS_VAR>)
+#    Use this to run automoc4 on all files contained in the list <SRCS_VAR>.
+#
+#  AUTOMOC4_MOC_HEADERS(<target> header1.h header2.h ...)
+#    Use this to add more header files to be processed with automoc4.
+#
+#  AUTOMOC4_ADD_EXECUTABLE(<target_NAME> src1 src2 ...)
+#    This macro does the same as ADD_EXECUTABLE, but additionally
+#    adds automoc4 handling for all source files.
+#
+# AUTOMOC4_ADD_LIBRARY(<target_NAME> src1 src2 ...)
+#    This macro does the same as ADD_LIBRARY, but additionally
+#    adds automoc4 handling for all source files.
+
+# Internal helper macro, may change or be removed anytime:
+# _ADD_AUTOMOC4_TARGET(<target_NAME> <SRCS_VAR>)
+#
+# Since version 0.9.88:
+# The following two macros are only to be used for KDE4 projects
+# and do something which makes sure automoc4 works for KDE. Don't
+# use them anywhere else.
+# _AUTOMOC4_KDE4_PRE_TARGET_HANDLING(<target_NAME> <SRCS_VAR>)
+# _AUTOMOC4_KDE4_POST_TARGET_HANDLING(<target_NAME>)
+
+
+# Copyright (c) 2008-2009, Alexander Neundorf, <neundorf@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+
+# check if we are inside KDESupport and automoc is enabled
+if("${KDESupport_SOURCE_DIR}" STREQUAL "${CMAKE_SOURCE_DIR}")
+   # when building this project as part of kdesupport
+   set(AUTOMOC4_CONFIG_FILE "${KDESupport_SOURCE_DIR}/automoc/Automoc4Config.cmake")
+else("${KDESupport_SOURCE_DIR}" STREQUAL "${CMAKE_SOURCE_DIR}")
+   # when building this project outside kdesupport
+
+   # CMAKE_[SYSTEM_]PREFIX_PATH exists starting with cmake 2.6.0
+   file(TO_CMAKE_PATH "$ENV{CMAKE_PREFIX_PATH}" _env_CMAKE_PREFIX_PATH)
+   file(TO_CMAKE_PATH "$ENV{CMAKE_LIBRARY_PATH}" _env_CMAKE_LIBRARY_PATH)
+
+   find_file(AUTOMOC4_CONFIG_FILE NAMES Automoc4Config.cmake 
+             PATH_SUFFIXES automoc4 lib/automoc4 lib64/automoc4
+             PATHS ${_env_CMAKE_PREFIX_PATH} ${CMAKE_PREFIX_PATH} ${CMAKE_SYSTEM_PREFIX_PATH} 
+                   ${_env_CMAKE_LIBRARY_PATH} ${CMAKE_LIBRARY_PATH} ${CMAKE_SYSTEM_LIBRARY_PATH}
+                   ${CMAKE_INSTALL_PREFIX}
+             NO_DEFAULT_PATH )
+endif("${KDESupport_SOURCE_DIR}" STREQUAL "${CMAKE_SOURCE_DIR}")
+
+
+if(AUTOMOC4_CONFIG_FILE)
+   include(${AUTOMOC4_CONFIG_FILE})
+   set(AUTOMOC4_FOUND TRUE)
+else(AUTOMOC4_CONFIG_FILE)
+   set(AUTOMOC4_FOUND FALSE)
+endif(AUTOMOC4_CONFIG_FILE)
+
+if (AUTOMOC4_FOUND)
+   if (NOT Automoc4_FIND_QUIETLY)
+      message(STATUS "Found Automoc4: ${AUTOMOC4_EXECUTABLE}")
+   endif (NOT Automoc4_FIND_QUIETLY)
+else (AUTOMOC4_FOUND)
+   if (Automoc4_FIND_REQUIRED)
+      message(FATAL_ERROR "Did not find automoc4 (part of kdesupport).")
+   else (Automoc4_FIND_REQUIRED)
+      if (NOT Automoc4_FIND_QUIETLY)
+         message(STATUS "Did not find automoc4 (part of kdesupport).")
+      endif (NOT Automoc4_FIND_QUIETLY)
+   endif (Automoc4_FIND_REQUIRED)
+endif (AUTOMOC4_FOUND)
diff --git a/src/3rdparty/phonon/cmake/FindGLIB2.cmake b/src/3rdparty/phonon/cmake/FindGLIB2.cmake
new file mode 100644
index 0000000..e19d6a4
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/FindGLIB2.cmake
@@ -0,0 +1,43 @@
+# - Try to find the GLIB2 libraries
+# Once done this will define
+#
+#  GLIB2_FOUND - system has glib2
+#  GLIB2_INCLUDE_DIR - the glib2 include directory
+#  GLIB2_LIBRARIES - glib2 library
+
+
+if(GLIB2_INCLUDE_DIR AND GLIB2_LIBRARIES)
+    # Already in cache, be silent
+    set(GLIB2_FIND_QUIETLY TRUE)
+endif(GLIB2_INCLUDE_DIR AND GLIB2_LIBRARIES)
+
+if (NOT WIN32)
+   find_package(PkgConfig REQUIRED)
+   pkg_check_modules(PKG_GLIB REQUIRED glib-2.0)
+endif(NOT WIN32)
+
+find_path(GLIB2_MAIN_INCLUDE_DIR glib.h
+          PATH_SUFFIXES glib-2.0
+          PATHS ${PKG_GLIB_INCLUDE_DIRS} )
+
+# search the glibconfig.h include dir under the same root where the library is found
+find_library(GLIB2_LIBRARIES
+             NAMES glib-2.0
+             PATHS ${PKG_GLIB_LIBRARY_DIRS} )
+
+find_path(GLIB2_INTERNAL_INCLUDE_DIR glibconfig.h
+          PATH_SUFFIXES glib-2.0/include ../lib/glib-2.0/include
+          PATHS ${PKG_GLIB_INCLUDE_DIRS} ${PKG_GLIB_LIBRARIES} ${CMAKE_SYSTEM_LIBRARY_PATH})
+
+set(GLIB2_INCLUDE_DIR ${GLIB2_MAIN_INCLUDE_DIR})
+
+# not sure if this include dir is optional or required
+# for now it is optional
+if(GLIB2_INTERNAL_INCLUDE_DIR)
+  set(GLIB2_INCLUDE_DIR ${GLIB2_INCLUDE_DIR} ${GLIB2_INTERNAL_INCLUDE_DIR})
+endif(GLIB2_INTERNAL_INCLUDE_DIR)
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(GLIB2  DEFAULT_MSG  GLIB2_LIBRARIES GLIB2_MAIN_INCLUDE_DIR)
+
+mark_as_advanced(GLIB2_INCLUDE_DIR GLIB2_LIBRARIES)
diff --git a/src/3rdparty/phonon/cmake/FindGObject.cmake b/src/3rdparty/phonon/cmake/FindGObject.cmake
new file mode 100644
index 0000000..1507b43
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/FindGObject.cmake
@@ -0,0 +1,75 @@
+# - Try to find GObject
+# Once done this will define
+#
+#  GOBJECT_FOUND - system has GObject
+#  GOBJECT_INCLUDE_DIR - the GObject include directory
+#  GOBJECT_LIBRARIES - the libraries needed to use GObject
+#  GOBJECT_DEFINITIONS - Compiler switches required for using GObject
+
+# Copyright (c) 2008 Helio Chissini de Castro, <helio@kde.org>
+#  (c)2006, Tim Beaulen <tbscope@gmail.com>
+
+
+IF (GOBJECT_INCLUDE_DIR AND GOBJECT_LIBRARIES)
+   # in cache already
+   SET(GObject_FIND_QUIETLY TRUE)
+ELSE (GOBJECT_INCLUDE_DIR AND GOBJECT_LIBRARIES)
+   SET(GObject_FIND_QUIETLY FALSE)
+ENDIF (GOBJECT_INCLUDE_DIR AND GOBJECT_LIBRARIES)
+
+IF (NOT WIN32)
+   FIND_PACKAGE(PkgConfig REQUIRED)
+   # use pkg-config to get the directories and then use these values
+   # in the FIND_PATH() and FIND_LIBRARY() calls
+   PKG_CHECK_MODULES(PKG_GOBJECT2 REQUIRED gobject-2.0)
+   SET(GOBJECT_DEFINITIONS ${PKG_GOBJECT2_CFLAGS})
+ENDIF (NOT WIN32)
+
+FIND_PATH(GOBJECT_INCLUDE_DIR gobject/gobject.h
+   PATHS
+   ${PKG_GOBJECT2_INCLUDE_DIRS}
+   /usr/include/glib-2.0/
+   PATH_SUFFIXES glib-2.0
+   )
+
+FIND_LIBRARY(_GObjectLibs NAMES gobject-2.0
+   PATHS
+   ${PKG_GOBJECT2_LIBRARY_DIRS}
+   )
+FIND_LIBRARY(_GModuleLibs NAMES gmodule-2.0
+   PATHS
+   ${PKG_GOBJECT2_LIBRARY_DIRS}
+   )
+FIND_LIBRARY(_GThreadLibs NAMES gthread-2.0
+   PATHS
+   ${PKG_GOBJECT2_LIBRARY_DIRS}
+   )
+FIND_LIBRARY(_GLibs NAMES glib-2.0
+   PATHS
+   ${PKG_GOBJECT2_LIBRARY_DIRS}
+   )
+
+IF (WIN32)
+SET (GOBJECT_LIBRARIES ${_GObjectLibs} ${_GModuleLibs} ${_GThreadLibs} ${_GLibs})
+ELSE (WIN32)
+SET (GOBJECT_LIBRARIES ${PKG_GOBJECT2_LIBRARIES})
+ENDIF (WIN32)
+
+IF (GOBJECT_INCLUDE_DIR AND GOBJECT_LIBRARIES)
+   SET(GOBJECT_FOUND TRUE)
+ELSE (GOBJECT_INCLUDE_DIR AND GOBJECT_LIBRARIES)
+   SET(GOBJECT_FOUND FALSE)
+ENDIF (GOBJECT_INCLUDE_DIR AND GOBJECT_LIBRARIES)
+
+IF (GOBJECT_FOUND)
+   IF (NOT GObject_FIND_QUIETLY)
+      MESSAGE(STATUS "Found GObject libraries: ${GOBJECT_LIBRARIES}")
+      MESSAGE(STATUS "Found GObject includes : ${GOBJECT_INCLUDE_DIR}")
+   ENDIF (NOT GObject_FIND_QUIETLY)
+ELSE (GOBJECT_FOUND)
+    IF (GObject_FIND_REQUIRED)
+      MESSAGE(STATUS "Could NOT find GObject")
+    ENDIF(GObject_FIND_REQUIRED)
+ENDIF (GOBJECT_FOUND)
+
+MARK_AS_ADVANCED(GOBJECT_INCLUDE_DIR GOBJECT_LIBRARIES)
diff --git a/src/3rdparty/phonon/cmake/FindGStreamer.cmake b/src/3rdparty/phonon/cmake/FindGStreamer.cmake
new file mode 100644
index 0000000..54a08ec
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/FindGStreamer.cmake
@@ -0,0 +1,85 @@
+# - Try to find GStreamer
+# Once done this will define
+#
+#  GSTREAMER_FOUND - system has GStreamer
+#  GSTREAMER_INCLUDE_DIR - the GStreamer include directory
+#  GSTREAMER_LIBRARIES - the libraries needed to use GStreamer
+#  GSTREAMER_DEFINITIONS - Compiler switches required for using GStreamer
+#  GSTREAMER_VERSION - the version of GStreamer
+
+# Copyright (c) 2008 Helio Chissini de Castro, <helio@kde.org>
+#  (c)2006, Tim Beaulen <tbscope@gmail.com>
+
+# TODO: Other versions --> GSTREAMER_X_Y_FOUND (Example: GSTREAMER_0_8_FOUND and GSTREAMER_0_10_FOUND etc)
+
+
+IF (GSTREAMER_INCLUDE_DIR AND GSTREAMER_LIBRARIES AND GSTREAMER_BASE_LIBRARY AND GSTREAMER_INTERFACE_LIBRARY)
+   # in cache already
+   SET(GStreamer_FIND_QUIETLY TRUE)
+ELSE (GSTREAMER_INCLUDE_DIR AND GSTREAMER_LIBRARIES AND GSTREAMER_BASE_LIBRARY AND GSTREAMER_INTERFACE_LIBRARY)
+   SET(GStreamer_FIND_QUIETLY FALSE)
+ENDIF (GSTREAMER_INCLUDE_DIR AND GSTREAMER_LIBRARIES AND GSTREAMER_BASE_LIBRARY AND GSTREAMER_INTERFACE_LIBRARY)
+
+IF (NOT WIN32)
+   FIND_PACKAGE(PkgConfig REQUIRED)
+   # use pkg-config to get the directories and then use these values
+   # in the FIND_PATH() and FIND_LIBRARY() calls
+   # don't make this check required - otherwise you can't use macro_optional_find_package on this one
+   PKG_CHECK_MODULES(PKG_GSTREAMER gstreamer-0.10)
+   SET(GSTREAMER_VERSION ${PKG_GSTREAMER_VERSION})
+   SET(GSTREAMER_DEFINITIONS ${PKG_GSTREAMER_CFLAGS})
+ENDIF (NOT WIN32)
+
+FIND_PATH(GSTREAMER_INCLUDE_DIR gst/gst.h
+   PATHS
+   ${PKG_GSTREAMER_INCLUDE_DIRS}
+   PATH_SUFFIXES gstreamer-0.10
+   )
+
+FIND_LIBRARY(GSTREAMER_LIBRARIES NAMES gstreamer-0.10
+   PATHS
+   ${PKG_GSTREAMER_LIBRARY_DIRS}
+   )
+
+FIND_LIBRARY(GSTREAMER_BASE_LIBRARY NAMES gstbase-0.10
+   PATHS
+   ${PKG_GSTREAMER_LIBRARY_DIRS}
+   )
+
+FIND_LIBRARY(GSTREAMER_INTERFACE_LIBRARY NAMES gstinterfaces-0.10
+   PATHS
+   ${PKG_GSTREAMER_LIBRARY_DIRS}
+   )
+
+IF (GSTREAMER_INCLUDE_DIR)
+ELSE (GSTREAMER_INCLUDE_DIR)
+   MESSAGE(STATUS "GStreamer: WARNING: include dir not found")
+ENDIF (GSTREAMER_INCLUDE_DIR)
+
+IF (GSTREAMER_LIBRARIES)
+ELSE (GSTREAMER_LIBRARIES)
+   MESSAGE(STATUS "GStreamer: WARNING: library not found")
+ENDIF (GSTREAMER_LIBRARIES)
+
+IF (GSTREAMER_INTERFACE_LIBRARY)
+ELSE (GSTREAMER_INTERFACE_LIBRARY)
+   MESSAGE(STATUS "GStreamer: WARNING: interface library not found")
+ENDIF (GSTREAMER_INTERFACE_LIBRARY)
+
+IF (GSTREAMER_INCLUDE_DIR AND GSTREAMER_LIBRARIES AND GSTREAMER_BASE_LIBRARY AND GSTREAMER_INTERFACE_LIBRARY)
+   SET(GSTREAMER_FOUND TRUE)
+ELSE (GSTREAMER_INCLUDE_DIR AND GSTREAMER_LIBRARIES AND GSTREAMER_BASE_LIBRARY AND GSTREAMER_INTERFACE_LIBRARY)
+   SET(GSTREAMER_FOUND FALSE)
+ENDIF (GSTREAMER_INCLUDE_DIR AND GSTREAMER_LIBRARIES AND GSTREAMER_BASE_LIBRARY AND GSTREAMER_INTERFACE_LIBRARY)
+
+IF (GSTREAMER_FOUND)
+   IF (NOT GStreamer_FIND_QUIETLY)
+      MESSAGE(STATUS "Found GStreamer: ${GSTREAMER_LIBRARIES}")
+   ENDIF (NOT GStreamer_FIND_QUIETLY)
+ELSE (GSTREAMER_FOUND)
+   IF (GStreamer_FIND_REQUIRED)
+      MESSAGE(SEND_ERROR "Could NOT find GStreamer")
+   ENDIF (GStreamer_FIND_REQUIRED)
+ENDIF (GSTREAMER_FOUND)
+
+MARK_AS_ADVANCED(GSTREAMER_INCLUDE_DIR GSTREAMER_LIBRARIES GSTREAMER_BASE_LIBRARY GSTREAMER_INTERFACE_LIBRARY)
diff --git a/src/3rdparty/phonon/cmake/FindGStreamerPlugins.cmake b/src/3rdparty/phonon/cmake/FindGStreamerPlugins.cmake
new file mode 100644
index 0000000..f6d70d5
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/FindGStreamerPlugins.cmake
@@ -0,0 +1,144 @@
+# - Try to find GStreamer_Plugins
+# Once done this will define
+#
+#  GSTREAMERPLUGINSBASE_FOUND - system has GStreamer_Plugins
+#  GSTREAMERPLUGINSBASE_INCLUDE_DIR - the GStreamer_Plugins include directory
+#  GSTREAMERPLUGINSBASE_LIBRARIES - the libraries needed to use GStreamer_Plugins
+#  GSTREAMERPLUGINSBASE_DEFINITIONS - Compiler switches required for using GStreamer_Plugins
+#
+#  (c)2009 Nokia Corporation
+
+FIND_PACKAGE(PkgConfig REQUIRED)
+
+IF (NOT WIN32)
+   # don't make this check required - otherwise you can't use macro_optional_find_package on this one
+   PKG_CHECK_MODULES( PKG_GSTREAMER gstreamer-plugins-base-0.10 )
+ENDIF (NOT WIN32)
+
+#
+# Base plugins:
+#  audio
+#  cdda
+#  netbuffer
+#  pbutils
+#  riff
+#  rtp
+#  rtsp
+#  sdp
+#  tag
+#  video
+#
+# The gstinterfaces-0.10 library is found by FindGStreamer.cmake
+#
+
+FIND_LIBRARY(GSTREAMER_PLUGIN_AUDIO_LIBRARIES NAMES gstaudio-0.10
+   PATHS
+   ${PKG_GSTREAMER_LIBRARY_DIRS}
+   )
+FIND_LIBRARY(GSTREAMER_PLUGIN_CDDA_LIBRARIES NAMES gstcdda-0.10
+   PATHS
+   ${PKG_GSTREAMER_LIBRARY_DIRS}
+   )
+FIND_LIBRARY(GSTREAMER_PLUGIN_NETBUFFER_LIBRARIES NAMES gstnetbuffer-0.10
+   PATHS
+   ${PKG_GSTREAMER_LIBRARY_DIRS}
+   )
+FIND_LIBRARY(GSTREAMER_PLUGIN_PBUTILS_LIBRARIES NAMES gstpbutils-0.10
+   PATHS
+   ${PKG_GSTREAMER_LIBRARY_DIRS}
+   )
+FIND_LIBRARY(GSTREAMER_PLUGIN_RIFF_LIBRARIES NAMES gstriff-0.10
+   PATHS
+   ${PKG_GSTREAMER_LIBRARY_DIRS}
+   )
+FIND_LIBRARY(GSTREAMER_PLUGIN_RTP_LIBRARIES NAMES gstrtp-0.10
+   PATHS
+   ${PKG_GSTREAMER_LIBRARY_DIRS}
+   )
+FIND_LIBRARY(GSTREAMER_PLUGIN_RTSP_LIBRARIES NAMES gstrtsp-0.10
+   PATHS
+   ${PKG_GSTREAMER_LIBRARY_DIRS}
+   )
+FIND_LIBRARY(GSTREAMER_PLUGIN_SDP_LIBRARIES NAMES gstsdp-0.10
+   PATHS
+   ${PKG_GSTREAMER_LIBRARY_DIRS}
+   )
+FIND_LIBRARY(GSTREAMER_PLUGIN_TAG_LIBRARIES NAMES gsttag-0.10
+   PATHS
+   ${PKG_GSTREAMER_LIBRARY_DIRS}
+   )
+FIND_LIBRARY(GSTREAMER_PLUGIN_VIDEO_LIBRARIES NAMES gstvideo-0.10
+   PATHS
+   ${PKG_GSTREAMER_LIBRARY_DIRS}
+   )
+
+IF (GSTREAMER_PLUGIN_AUDIO_LIBRARIES AND
+    GSTREAMER_PLUGIN_CDDA_LIBRARIES AND
+    GSTREAMER_PLUGIN_NETBUFFER_LIBRARIES AND
+    GSTREAMER_PLUGIN_PBUTILS_LIBRARIES AND
+    GSTREAMER_PLUGIN_RIFF_LIBRARIES AND
+    GSTREAMER_PLUGIN_RTP_LIBRARIES AND
+    GSTREAMER_PLUGIN_RTSP_LIBRARIES AND
+    GSTREAMER_PLUGIN_SDP_LIBRARIES AND
+    GSTREAMER_PLUGIN_TAG_LIBRARIES AND
+    GSTREAMER_PLUGIN_VIDEO_LIBRARIES)
+   SET(GSTREAMERPLUGINSBASE_FOUND TRUE)
+ELSE (GSTREAMER_PLUGIN_AUDIO_LIBRARIES AND
+    GSTREAMER_PLUGIN_CDDA_LIBRARIES AND
+    GSTREAMER_PLUGIN_NETBUFFER_LIBRARIES AND
+    GSTREAMER_PLUGIN_PBUTILS_LIBRARIES AND
+    GSTREAMER_PLUGIN_RIFF_LIBRARIES AND
+    GSTREAMER_PLUGIN_RTP_LIBRARIES AND
+    GSTREAMER_PLUGIN_RTSP_LIBRARIES AND
+    GSTREAMER_PLUGIN_SDP_LIBRARIES AND
+    GSTREAMER_PLUGIN_TAG_LIBRARIES AND
+    GSTREAMER_PLUGIN_VIDEO_LIBRARIES)
+   SET(GSTREAMERPLUGINSBASE_FOUND FALSE)
+ENDIF (GSTREAMER_PLUGIN_AUDIO_LIBRARIES AND
+    GSTREAMER_PLUGIN_CDDA_LIBRARIES AND
+    GSTREAMER_PLUGIN_NETBUFFER_LIBRARIES AND
+    GSTREAMER_PLUGIN_PBUTILS_LIBRARIES AND
+    GSTREAMER_PLUGIN_RIFF_LIBRARIES AND
+    GSTREAMER_PLUGIN_RTP_LIBRARIES AND
+    GSTREAMER_PLUGIN_RTSP_LIBRARIES AND
+    GSTREAMER_PLUGIN_SDP_LIBRARIES AND
+    GSTREAMER_PLUGIN_TAG_LIBRARIES AND
+    GSTREAMER_PLUGIN_VIDEO_LIBRARIES)
+
+IF (GSTREAMERPLUGINSBASE_FOUND)
+   SET(GSTREAMERPLUGINS_FOUND TRUE)
+ELSE (GSTREAMERPLUGINSBASE_FOUND)
+   SET(GSTREAMERPLUGINS_FOUND FALSE)
+ENDIF (GSTREAMERPLUGINSBASE_FOUND)
+
+IF (GSTREAMERPLUGINS_FOUND)
+   IF (NOT GStreamer_Plugins_FIND_QUIETLY)
+      MESSAGE(STATUS "Found GStreamer Plugins:
+    ${GSTREAMER_PLUGIN_AUDIO_LIBRARIES}
+    ${GSTREAMER_PLUGIN_CDDA_LIBRARIES}
+    ${GSTREAMER_PLUGIN_NETBUFFER_LIBRARIES}
+    ${GSTREAMER_PLUGIN_PBUTILS_LIBRARIES}
+    ${GSTREAMER_PLUGIN_RIFF_LIBRARIES}
+    ${GSTREAMER_PLUGIN_RTP_LIBRARIES}
+    ${GSTREAMER_PLUGIN_RTSP_LIBRARIES}
+    ${GSTREAMER_PLUGIN_SDP_LIBRARIES}
+    ${GSTREAMER_PLUGIN_TAG_LIBRARIES}
+    ${GSTREAMER_PLUGIN_VIDEO_LIBRARIES}")
+   ENDIF (NOT GStreamer_Plugins_FIND_QUIETLY)
+ELSE (GSTREAMERPLUGINS_FOUND)
+   IF (GStreamer_Plugins_FIND_REQUIRED)
+      MESSAGE(SEND_ERROR "Could NOT find GStreamer Plugins")
+   ENDIF (GStreamer_Plugins_FIND_REQUIRED)
+ENDIF (GSTREAMERPLUGINS_FOUND)
+
+MARK_AS_ADVANCED(GSTREAMERPLUGINS_DEFINITIONS
+    GSTREAMER_PLUGIN_AUDIO_LIBRARIES
+    GSTREAMER_PLUGIN_CDDA_LIBRARIES
+    GSTREAMER_PLUGIN_NETBUFFER_LIBRARIES
+    GSTREAMER_PLUGIN_PBUTILS_LIBRARIES
+    GSTREAMER_PLUGIN_RIFF_LIBRARIES
+    GSTREAMER_PLUGIN_RTP_LIBRARIES
+    GSTREAMER_PLUGIN_RTSP_LIBRARIES
+    GSTREAMER_PLUGIN_SDP_LIBRARIES
+    GSTREAMER_PLUGIN_TAG_LIBRARIES
+    GSTREAMER_PLUGIN_VIDEO_LIBRARIES)
diff --git a/src/3rdparty/phonon/cmake/FindPackageHandleStandardArgs.cmake b/src/3rdparty/phonon/cmake/FindPackageHandleStandardArgs.cmake
new file mode 100644
index 0000000..7f122ed
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/FindPackageHandleStandardArgs.cmake
@@ -0,0 +1,60 @@
+# FIND_PACKAGE_HANDLE_STANDARD_ARGS(NAME (DEFAULT_MSG|"Custom failure message") VAR1 ... )
+#
+# This macro is intended to be used in FindXXX.cmake modules files.
+# It handles the REQUIRED and QUIET argument to FIND_PACKAGE() and
+# it also sets the <UPPERCASED_NAME>_FOUND variable.
+# The package is found if all variables listed are TRUE.
+# Example:
+#
+#    FIND_PACKAGE_HANDLE_STANDARD_ARGS(LibXml2 DEFAULT_MSG LIBXML2_LIBRARIES LIBXML2_INCLUDE_DIR)
+#
+# LibXml2 is considered to be found, if both LIBXML2_LIBRARIES and 
+# LIBXML2_INCLUDE_DIR are valid. Then also LIBXML2_FOUND is set to TRUE.
+# If it is not found and REQUIRED was used, it fails with FATAL_ERROR, 
+# independent whether QUIET was used or not.
+#
+# If it is found, the location is reported using the VAR1 argument, so 
+# here a message "Found LibXml2: /usr/lib/libxml2.so" will be printed out.
+# If the second argument is DEFAULT_MSG, the message in the failure case will 
+# be "Could NOT find LibXml2", if you don't like this message you can specify
+# your own custom failure message there.
+
+MACRO(FIND_PACKAGE_HANDLE_STANDARD_ARGS _NAME _FAIL_MSG _VAR1 )
+
+  IF("${_FAIL_MSG}" STREQUAL "DEFAULT_MSG")
+    IF (${_NAME}_FIND_REQUIRED)
+      SET(_FAIL_MESSAGE "Could not find REQUIRED package ${_NAME}")
+    ELSE (${_NAME}_FIND_REQUIRED)
+      SET(_FAIL_MESSAGE "Could not find OPTIONAL package ${_NAME}")
+    ENDIF (${_NAME}_FIND_REQUIRED)
+  ELSE("${_FAIL_MSG}" STREQUAL "DEFAULT_MSG")
+    SET(_FAIL_MESSAGE "${_FAIL_MSG}")
+  ENDIF("${_FAIL_MSG}" STREQUAL "DEFAULT_MSG")
+
+  STRING(TOUPPER ${_NAME} _NAME_UPPER)
+
+  SET(${_NAME_UPPER}_FOUND TRUE)
+  IF(NOT ${_VAR1})
+    SET(${_NAME_UPPER}_FOUND FALSE)
+  ENDIF(NOT ${_VAR1})
+
+  FOREACH(_CURRENT_VAR ${ARGN})
+    IF(NOT ${_CURRENT_VAR})
+      SET(${_NAME_UPPER}_FOUND FALSE)
+    ENDIF(NOT ${_CURRENT_VAR})
+  ENDFOREACH(_CURRENT_VAR)
+
+  IF (${_NAME_UPPER}_FOUND)
+    IF (NOT ${_NAME}_FIND_QUIETLY)
+        MESSAGE(STATUS "Found ${_NAME}: ${${_VAR1}}")
+    ENDIF (NOT ${_NAME}_FIND_QUIETLY)
+  ELSE (${_NAME_UPPER}_FOUND)
+    IF (${_NAME}_FIND_REQUIRED)
+        MESSAGE(FATAL_ERROR "${_FAIL_MESSAGE}")
+    ELSE (${_NAME}_FIND_REQUIRED)
+      IF (NOT ${_NAME}_FIND_QUIETLY)
+        MESSAGE(STATUS "${_FAIL_MESSAGE}")
+      ENDIF (NOT ${_NAME}_FIND_QUIETLY)
+    ENDIF (${_NAME}_FIND_REQUIRED)
+  ENDIF (${_NAME_UPPER}_FOUND)
+ENDMACRO(FIND_PACKAGE_HANDLE_STANDARD_ARGS)
diff --git a/src/3rdparty/phonon/cmake/FindPulseAudio.cmake b/src/3rdparty/phonon/cmake/FindPulseAudio.cmake
new file mode 100644
index 0000000..6223029
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/FindPulseAudio.cmake
@@ -0,0 +1,76 @@
+# Try to find the PulseAudio library
+#
+# Once done this will define:
+#
+#  PULSEAUDIO_FOUND - system has the PulseAudio library
+#  PULSEAUDIO_INCLUDE_DIR - the PulseAudio include directory
+#  PULSEAUDIO_LIBRARY - the libraries needed to use PulseAudio
+#  PULSEAUDIO_MAINLOOP_LIBRARY - the libraries needed to use PulsAudio Mailoop
+#
+# Copyright (c) 2008, Matthias Kretz, <kretz@kde.org>
+# Copyright (c) 2009, Marcus Hufgard, <Marcus.Hufgard@hufgard.de>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+if (NOT PULSEAUDIO_MINIMUM_VERSION)
+  set(PULSEAUDIO_MINIMUM_VERSION "0.9.9")
+endif (NOT PULSEAUDIO_MINIMUM_VERSION)
+
+if (PULSEAUDIO_INCLUDE_DIR AND PULSEAUDIO_LIBRARY AND PULSEAUDIO_MAINLOOP_LIBRARY)
+   # Already in cache, be silent
+   set(PULSEAUDIO_FIND_QUIETLY TRUE)
+endif (PULSEAUDIO_INCLUDE_DIR AND PULSEAUDIO_LIBRARY AND PULSEAUDIO_MAINLOOP_LIBRARY)
+
+if (NOT WIN32)
+   include(FindPkgConfig)
+   pkg_check_modules(PC_PULSEAUDIO libpulse>=${PULSEAUDIO_MINIMUM_VERSION})
+   pkg_check_modules(PC_PULSEAUDIO_MAINLOOP libpulse-mainloop-glib)
+endif (NOT WIN32)
+
+FIND_PATH(PULSEAUDIO_INCLUDE_DIR pulse/pulseaudio.h
+   HINTS
+   ${PC_PULSEAUDIO_INCLUDEDIR}
+   ${PC_PULSEAUDIO_INCLUDE_DIRS}
+   )
+
+FIND_LIBRARY(PULSEAUDIO_LIBRARY NAMES pulse libpulse
+   HINTS
+   ${PC_PULSEAUDIO_LIBDIR}
+   ${PC_PULSEAUDIO_LIBRARY_DIRS}
+   )
+
+FIND_LIBRARY(PULSEAUDIO_MAINLOOP_LIBRARY NAMES pulse-mainloop pulse-mainloop-glib libpulse-mainloop-glib
+   HINTS
+   ${PC_PULSEAUDIO_LIBDIR}
+   ${PC_PULSEAUDIO_LIBRARY_DIRS}
+   )
+
+if (PULSEAUDIO_INCLUDE_DIR AND PULSEAUDIO_LIBRARY)
+   include(MacroEnsureVersion)
+
+   # get PulseAudio's version from its version.h, and compare it with our minimum version
+   file(STRINGS "${PULSEAUDIO_INCLUDE_DIR}/pulse/version.h" pulse_version_h
+        REGEX ".*pa_get_headers_version\\(\\).*"
+        )
+   string(REGEX REPLACE ".*pa_get_headers_version\\(\\)\ \\(\"([0-9]+\\.[0-9]+\\.[0-9]+)\"\\).*" "\\1"
+                         PULSEAUDIO_VERSION "${pulse_version_h}")
+   macro_ensure_version("${PULSEAUDIO_MINIMUM_VERSION}" "${PULSEAUDIO_VERSION}" PULSEAUDIO_FOUND)
+else (PULSEAUDIO_INCLUDE_DIR AND PULSEAUDIO_LIBRARY)
+   set(PULSEAUDIO_FOUND FALSE)
+endif (PULSEAUDIO_INCLUDE_DIR AND PULSEAUDIO_LIBRARY)
+
+if (PULSEAUDIO_FOUND)
+   if (NOT PULSEAUDIO_FIND_QUIETLY)
+      message(STATUS "Found PulseAudio: ${PULSEAUDIO_LIBRARY}")
+      if (PULSEAUDIO_MAINLOOP_LIBRARY)
+          message(STATUS "Found PulseAudio Mainloop: ${PULSEAUDIO_MAINLOOP_LIBRARY}")
+      else (PULSAUDIO_MAINLOOP_LIBRARY)
+          message(STATUS "Could NOT find PulseAudio Mainloop Library")
+      endif (PULSEAUDIO_MAINLOOP_LIBRARY)
+   endif (NOT PULSEAUDIO_FIND_QUIETLY)
+else (PULSEAUDIO_FOUND)
+   message(STATUS "Could NOT find PulseAudio")
+endif (PULSEAUDIO_FOUND)
+
+mark_as_advanced(PULSEAUDIO_INCLUDE_DIR PULSEAUDIO_LIBRARY PULSEAUDIO_MAINLOOP_LIBRARY)
diff --git a/src/3rdparty/phonon/cmake/FindQt4.cmake b/src/3rdparty/phonon/cmake/FindQt4.cmake
new file mode 100644
index 0000000..b1d2899
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/FindQt4.cmake
@@ -0,0 +1,1465 @@
+# - Find QT 4
+# This module can be used to find Qt4.
+# The most important issue is that the Qt4 qmake is available via the system path.
+# This qmake is then used to detect basically everything else.
+# This module defines a number of key variables and macros. 
+# First is QT_USE_FILE which is the path to a CMake file that can be included 
+# to compile Qt 4 applications and libraries.  By default, the QtCore and QtGui 
+# libraries are loaded. This behavior can be changed by setting one or more 
+# of the following variables to true before doing INCLUDE(${QT_USE_FILE}):
+#                    QT_DONT_USE_QTCORE
+#                    QT_DONT_USE_QTGUI
+#                    QT_USE_QT3SUPPORT
+#                    QT_USE_QTASSISTANT
+#                    QT_USE_QTDESIGNER
+#                    QT_USE_QTMOTIF
+#                    QT_USE_QTMAIN
+#                    QT_USE_QTNETWORK
+#                    QT_USE_QTNSPLUGIN
+#                    QT_USE_QTOPENGL
+#                    QT_USE_QTSQL
+#                    QT_USE_QTXML
+#                    QT_USE_QTSVG
+#                    QT_USE_QTTEST
+#                    QT_USE_QTUITOOLS
+#                    QT_USE_QTDBUS
+#                    QT_USE_QTSCRIPT
+#                    QT_USE_QTASSISTANTCLIENT
+#                    QT_USE_QTHELP
+#                    QT_USE_QTWEBKIT
+#                    QT_USE_QTXMLPATTERNS
+#                    QT_USE_PHONON
+#
+# The file pointed to by QT_USE_FILE will set up your compile environment
+# by adding include directories, preprocessor defines, and populate a
+# QT_LIBRARIES variable containing all the Qt libraries and their dependencies.
+# Add the QT_LIBRARIES variable to your TARGET_LINK_LIBRARIES.
+#
+# Typical usage could be something like:
+#   FIND_PACKAGE(Qt4)
+#   SET(QT_USE_QTXML 1)
+#   INCLUDE(${QT_USE_FILE})
+#   ADD_EXECUTABLE(myexe main.cpp)
+#   TARGET_LINK_LIBRARIES(myexe ${QT_LIBRARIES})
+#
+#
+# There are also some files that need processing by some Qt tools such as moc
+# and uic.  Listed below are macros that may be used to process those files.
+#  
+#  macro QT4_WRAP_CPP(outfiles inputfile ... OPTIONS ...)
+#        create moc code from a list of files containing Qt class with
+#        the Q_OBJECT declaration.  Options may be given to moc, such as those found
+#        when executing "moc -help"
+#
+#  macro QT4_WRAP_UI(outfiles inputfile ... OPTIONS ...)
+#        create code from a list of Qt designer ui files.
+#        Options may be given to uic, such as those found
+#        when executing "uic -help"
+#
+#  macro QT4_ADD_RESOURCES(outfiles inputfile ... OPTIONS ...)
+#        create code from a list of Qt resource files.
+#        Options may be given to rcc, such as those found
+#        when executing "rcc -help"
+#
+#  macro QT4_GENERATE_MOC(inputfile outputfile )
+#        creates a rule to run moc on infile and create outfile.
+#        Use this if for some reason QT4_WRAP_CPP() isn't appropriate, e.g.
+#        because you need a custom filename for the moc file or something similar.
+#
+#  macro QT4_AUTOMOC(sourcefile1 sourcefile2 ... )
+#        This macro is still experimental.
+#        It can be used to have moc automatically handled.
+#        So if you have the files foo.h and foo.cpp, and in foo.h a 
+#        a class uses the Q_OBJECT macro, moc has to run on it. If you don't
+#        want to use QT4_WRAP_CPP() (which is reliable and mature), you can insert
+#        #include "foo.moc"
+#        in foo.cpp and then give foo.cpp as argument to QT4_AUTOMOC(). This will the
+#        scan all listed files at cmake-time for such included moc files and if it finds
+#        them cause a rule to be generated to run moc at build time on the 
+#        accompanying header file foo.h.
+#        If a source file has the SKIP_AUTOMOC property set it will be ignored by this macro.
+#
+#  macro QT4_ADD_DBUS_INTERFACE(outfiles interface basename)
+#        create a the interface header and implementation files with the 
+#        given basename from the given interface xml file and add it to 
+#        the list of sources.
+#        To disable generating a namespace header, set the source file property 
+#        NO_NAMESPACE to TRUE on the interface file.
+#
+#  macro QT4_ADD_DBUS_INTERFACES(outfiles inputfile ... )
+#        create the interface header and implementation files 
+#        for all listed interface xml files
+#        the name will be automatically determined from the name of the xml file
+#        To disable generating namespace headers, set the source file property 
+#        NO_NAMESPACE to TRUE for these inputfiles.
+#
+#  macro QT4_ADD_DBUS_ADAPTOR(outfiles xmlfile parentheader parentclassname [basename] [classname])
+#        create a dbus adaptor (header and implementation file) from the xml file
+#        describing the interface, and add it to the list of sources. The adaptor
+#        forwards the calls to a parent class, defined in parentheader and named
+#        parentclassname. The name of the generated files will be
+#        <basename>adaptor.{cpp,h} where basename defaults to the basename of the xml file.
+#        If <classname> is provided, then it will be used as the classname of the
+#        adaptor itself.
+#
+#  macro QT4_GENERATE_DBUS_INTERFACE( header [interfacename] OPTIONS ...)
+#        generate the xml interface file from the given header.
+#        If the optional argument interfacename is omitted, the name of the 
+#        interface file is constructed from the basename of the header with
+#        the suffix .xml appended.
+#        Options may be given to uic, such as those found when executing "qdbuscpp2xml --help"
+#
+#  QT_FOUND         If false, don't try to use Qt.
+#  QT4_FOUND        If false, don't try to use Qt 4.
+#
+#  QT_QTCORE_FOUND        True if QtCore was found.
+#  QT_QTGUI_FOUND         True if QtGui was found.
+#  QT_QT3SUPPORT_FOUND    True if Qt3Support was found.
+#  QT_QTASSISTANT_FOUND   True if QtAssistant was found.
+#  QT_QTDBUS_FOUND        True if QtDBus was found.
+#  QT_QTDESIGNER_FOUND    True if QtDesigner was found.
+#  QT_QTDESIGNERCOMPONENTS True if QtDesignerComponents was found.
+#  QT_QTMOTIF_FOUND       True if QtMotif was found.
+#  QT_QTNETWORK_FOUND     True if QtNetwork was found.
+#  QT_QTNSPLUGIN_FOUND    True if QtNsPlugin was found.
+#  QT_QTOPENGL_FOUND      True if QtOpenGL was found.
+#  QT_QTSQL_FOUND         True if QtSql was found.
+#  QT_QTXML_FOUND         True if QtXml was found.
+#  QT_QTSVG_FOUND         True if QtSvg was found.
+#  QT_QTSCRIPT_FOUND      True if QtScript was found.
+#  QT_QTTEST_FOUND        True if QtTest was found.
+#  QT_QTUITOOLS_FOUND     True if QtUiTools was found.
+#  QT_QTASSISTANTCLIENT_FOUND         True if QtAssistantClient was found.
+#  QT_QTHELP_FOUND      True if QtHelp was found.
+#  QT_QTWEBKIT_FOUND        True if QtWebKit was found.
+#  QT_QTXMLPATTERNS_FOUND   True if QtXmlPatterns was found.
+#  QT_PHONON_FOUND          True if phonon was found.
+#
+#
+#  QT_DEFINITIONS   Definitions to use when compiling code that uses Qt.
+#                   You do not need to use this if you include QT_USE_FILE.
+#                   The QT_USE_FILE will also define QT_DEBUG and QT_NO_DEBUG
+#                   to fit your current build type.  Those are not contained
+#                   in QT_DEFINITIONS.
+#                  
+#  QT_INCLUDES      List of paths to all include directories of 
+#                   Qt4 QT_INCLUDE_DIR and QT_QTCORE_INCLUDE_DIR are
+#                   always in this variable even if NOTFOUND,
+#                   all other INCLUDE_DIRS are
+#                   only added if they are found.
+#                   You do not need to use this if you include QT_USE_FILE.
+#   
+#
+#  Include directories for the Qt modules are listed here.
+#  You do not need to use these variables if you include QT_USE_FILE.
+#
+#  QT_INCLUDE_DIR              Path to "include" of Qt4
+#  QT_QT_INCLUDE_DIR           Path to "include/Qt" 
+#  QT_QT3SUPPORT_INCLUDE_DIR   Path to "include/Qt3Support" 
+#  QT_QTASSISTANT_INCLUDE_DIR  Path to "include/QtAssistant" 
+#  QT_QTCORE_INCLUDE_DIR       Path to "include/QtCore"         
+#  QT_QTDESIGNER_INCLUDE_DIR   Path to "include/QtDesigner" 
+#  QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR   Path to "include/QtDesigner"
+#  QT_QTDBUS_INCLUDE_DIR       Path to "include/QtDBus" 
+#  QT_QTGUI_INCLUDE_DIR        Path to "include/QtGui" 
+#  QT_QTMOTIF_INCLUDE_DIR      Path to "include/QtMotif" 
+#  QT_QTNETWORK_INCLUDE_DIR    Path to "include/QtNetwork" 
+#  QT_QTNSPLUGIN_INCLUDE_DIR   Path to "include/QtNsPlugin" 
+#  QT_QTOPENGL_INCLUDE_DIR     Path to "include/QtOpenGL" 
+#  QT_QTSQL_INCLUDE_DIR        Path to "include/QtSql" 
+#  QT_QTXML_INCLUDE_DIR        Path to "include/QtXml" 
+#  QT_QTSVG_INCLUDE_DIR        Path to "include/QtSvg"
+#  QT_QTSCRIPT_INCLUDE_DIR     Path to "include/QtScript"
+#  QT_QTTEST_INCLUDE_DIR       Path to "include/QtTest"
+#  QT_QTASSISTANTCLIENT_INCLUDE_DIR       Path to "include/QtAssistant"
+#  QT_QTHELP_INCLUDE_DIR       Path to "include/QtHelp"
+#  QT_QTWEBKIT_INCLUDE_DIR     Path to "include/QtWebKit"
+#  QT_QTXMLPATTERNS_INCLUDE_DIR  Path to "include/QtXmlPatterns"
+#  QT_PHONON_INCLUDE_DIR       Path to "include/phonon"
+#                            
+#  QT_LIBRARY_DIR              Path to "lib" of Qt4
+# 
+#  QT_PLUGINS_DIR              Path to "plugins" for Qt4
+#                            
+# For every library of Qt, a QT_QTFOO_LIBRARY variable is defined, with the full path to the library.
+#
+# So there are the following variables:
+# The Qt3Support library:     QT_QT3SUPPORT_LIBRARY
+#
+# The QtAssistant library:    QT_QTASSISTANT_LIBRARY
+#
+# The QtCore library:         QT_QTCORE_LIBRARY
+#
+# The QtDBus library:         QT_QTDBUS_LIBRARY
+#
+# The QtDesigner library:     QT_QTDESIGNER_LIBRARY
+#
+# The QtDesignerComponents library:     QT_QTDESIGNERCOMPONENTS_LIBRARY
+#
+# The QtGui library:          QT_QTGUI_LIBRARY
+#
+# The QtMotif library:        QT_QTMOTIF_LIBRARY
+#
+# The QtNetwork library:      QT_QTNETWORK_LIBRARY
+#
+# The QtNsPLugin library:     QT_QTNSPLUGIN_LIBRARY
+#
+# The QtOpenGL library:       QT_QTOPENGL_LIBRARY
+#
+# The QtSql library:          QT_QTSQL_LIBRARY
+#
+# The QtXml library:          QT_QTXML_LIBRARY
+#
+# The QtSvg library:          QT_QTSVG_LIBRARY
+#
+# The QtScript library:       QT_QTSCRIPT_LIBRARY
+#
+# The QtTest library:         QT_QTTEST_LIBRARY
+#
+# The qtmain library for Windows QT_QTMAIN_LIBRARY
+#
+# The QtUiTools library:      QT_QTUITOOLS_LIBRARY
+
+#
+# The QtAssistantClient library:  QT_QTASSISTANTCLIENT_LIBRARY
+#
+# The QtHelp library:             QT_QTHELP_LIBRARY
+#
+# The QtWebKit library:           QT_QTWEBKIT_LIBRARY
+#
+# The QtXmlPatterns library:      QT_QTXMLPATTERNS_LIBRARY
+#
+# The Phonon library:             QT_PHONON_LIBRARY
+
+
+
+#  
+# also defined, but NOT for general use are
+#  QT_MOC_EXECUTABLE          Where to find the moc tool.
+#  QT_UIC_EXECUTABLE          Where to find the uic tool.
+#  QT_UIC3_EXECUTABLE         Where to find the uic3 tool.
+#  QT_RCC_EXECUTABLE          Where to find the rcc tool
+#  QT_DBUSCPP2XML_EXECUTABLE  Where to find the qdbuscpp2xml tool.
+#  QT_DBUSXML2CPP_EXECUTABLE  Where to find the qdbusxml2cpp tool.
+#  QT_LUPDATE_EXECUTABLE      Where to find the lupdate tool.
+#  QT_LRELEASE_EXECUTABLE     Where to find the lrelease tool.
+#  
+#  QT_DOC_DIR                 Path to "doc" of Qt4
+#  QT_MKSPECS_DIR             Path to "mkspecs" of Qt4
+#
+#
+# These are around for backwards compatibility 
+# they will be set
+#  QT_WRAP_CPP  Set true if QT_MOC_EXECUTABLE is found
+#  QT_WRAP_UI   Set true if QT_UIC_EXECUTABLE is found
+#  
+# These variables do _NOT_ have any effect anymore (compared to FindQt.cmake)
+#  QT_MT_REQUIRED         Qt4 is now always multithreaded
+#  
+# These variables are set to "" Because Qt structure changed 
+# (They make no sense in Qt4)
+#  QT_QT_LIBRARY        Qt-Library is now split
+
+# Copyright (c) 2002 Kitware, Inc., Insight Consortium.  All rights reserved.
+# See Copyright.txt or http://www.cmake.org/HTML/Copyright.html for details.
+
+if (QT4_QMAKE_FOUND)
+   # Check already done in this cmake run, nothing more to do
+
+else (QT4_QMAKE_FOUND)
+
+# check that QT_NO_DEBUG is defined for release configurations
+MACRO(QT_CHECK_FLAG_EXISTS FLAG VAR DOC)
+  IF(NOT ${VAR} MATCHES "${FLAG}")
+    SET(${VAR} "${${VAR}} ${FLAG}" 
+      CACHE STRING "Flags used by the compiler during ${DOC} builds." FORCE)
+  ENDIF(NOT ${VAR} MATCHES "${FLAG}")
+ENDMACRO(QT_CHECK_FLAG_EXISTS FLAG VAR)
+QT_CHECK_FLAG_EXISTS(-DQT_NO_DEBUG CMAKE_CXX_FLAGS_RELWITHDEBINFO "Release with Debug Info")
+QT_CHECK_FLAG_EXISTS(-DQT_NO_DEBUG CMAKE_CXX_FLAGS_RELEASE "release")
+QT_CHECK_FLAG_EXISTS(-DQT_NO_DEBUG CMAKE_CXX_FLAGS_MINSIZEREL "release minsize")
+
+INCLUDE(CheckSymbolExists)
+INCLUDE(MacroAddFileDependencies)
+INCLUDE(MacroPushRequiredVars)
+
+SET(QT_USE_FILE ${CMAKE_ROOT}/Modules/UseQt4.cmake)
+
+SET( QT_DEFINITIONS "")
+
+IF (WIN32)
+  SET(QT_DEFINITIONS -DQT_DLL)
+ENDIF(WIN32)
+
+SET(QT4_INSTALLED_VERSION_TOO_OLD FALSE)
+
+#  macro for asking qmake to process pro files
+MACRO(QT_QUERY_QMAKE outvar invar)
+  FILE(WRITE ${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmpQmake/tmp.pro
+    "message(CMAKE_MESSAGE<$$${invar}>)")
+
+  # Invoke qmake with the tmp.pro program to get the desired
+  # information.  Use the same variable for both stdout and stderr
+  # to make sure we get the output on all platforms.
+  EXECUTE_PROCESS(COMMAND ${QT_QMAKE_EXECUTABLE}
+    WORKING_DIRECTORY  
+    ${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmpQmake
+    OUTPUT_VARIABLE _qmake_query_output
+    RESULT_VARIABLE _qmake_result
+    ERROR_VARIABLE _qmake_query_output )
+  
+  FILE(REMOVE_RECURSE 
+    "${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmpQmake")
+
+  IF(_qmake_result)
+    MESSAGE(WARNING " querying qmake for ${invar}.  qmake reported:\n${_qmake_query_output}")
+  ELSE(_qmake_result)
+    STRING(REGEX REPLACE ".*CMAKE_MESSAGE<([^>]*).*" "\\1" ${outvar} "${_qmake_query_output}")
+  ENDIF(_qmake_result)
+
+ENDMACRO(QT_QUERY_QMAKE)
+
+GET_FILENAME_COMPONENT(qt_install_version "[HKEY_CURRENT_USER\\Software\\trolltech\\Versions;DefaultQtVersion]" NAME)
+# check for qmake
+FIND_PROGRAM(QT_QMAKE_EXECUTABLE NAMES qmake qmake4 qmake-qt4 PATHS
+  "[HKEY_CURRENT_USER\\Software\\Trolltech\\Qt3Versions\\4.0.0;InstallDir]/bin"
+  "[HKEY_CURRENT_USER\\Software\\Trolltech\\Versions\\4.0.0;InstallDir]/bin"
+  "[HKEY_CURRENT_USER\\Software\\Trolltech\\Versions\\${qt_install_version};InstallDir]/bin"
+  $ENV{QTDIR}/bin
+)
+
+IF (QT_QMAKE_EXECUTABLE)
+
+  SET(QT4_QMAKE_FOUND FALSE)
+  
+  EXEC_PROGRAM(${QT_QMAKE_EXECUTABLE} ARGS "-query QT_VERSION" OUTPUT_VARIABLE QTVERSION)
+
+  # check for qt3 qmake and then try and find qmake4 or qmake-qt4 in the path
+  IF("${QTVERSION}" MATCHES "Unknown")
+    SET(QT_QMAKE_EXECUTABLE NOTFOUND CACHE FILEPATH "" FORCE)
+    FIND_PROGRAM(QT_QMAKE_EXECUTABLE NAMES qmake4 qmake-qt4 PATHS
+      "[HKEY_CURRENT_USER\\Software\\Trolltech\\Qt3Versions\\4.0.0;InstallDir]/bin"
+      "[HKEY_CURRENT_USER\\Software\\Trolltech\\Versions\\4.0.0;InstallDir]/bin"
+      $ENV{QTDIR}/bin
+      )
+    IF(QT_QMAKE_EXECUTABLE)
+      EXEC_PROGRAM(${QT_QMAKE_EXECUTABLE} 
+        ARGS "-query QT_VERSION" OUTPUT_VARIABLE QTVERSION)
+    ENDIF(QT_QMAKE_EXECUTABLE)
+  ENDIF("${QTVERSION}" MATCHES "Unknown")
+
+  # check that we found the Qt4 qmake, Qt3 qmake output won't match here
+  STRING(REGEX MATCH "^[0-9]+\\.[0-9]+\\.[0-9]+" qt_version_tmp "${QTVERSION}")
+  IF (qt_version_tmp)
+
+    # we need at least version 4.0.0
+    IF (NOT QT_MIN_VERSION)
+      SET(QT_MIN_VERSION "4.0.0")
+    ENDIF (NOT QT_MIN_VERSION)
+
+    #now parse the parts of the user given version string into variables
+    STRING(REGEX MATCH "^[0-9]+\\.[0-9]+\\.[0-9]+" req_qt_major_vers "${QT_MIN_VERSION}")
+    IF (NOT req_qt_major_vers)
+      MESSAGE( FATAL_ERROR "Invalid Qt version string given: \"${QT_MIN_VERSION}\", expected e.g. \"4.0.1\"")
+    ENDIF (NOT req_qt_major_vers)
+
+    # now parse the parts of the user given version string into variables
+    STRING(REGEX REPLACE "^([0-9]+)\\.[0-9]+\\.[0-9]+" "\\1" req_qt_major_vers "${QT_MIN_VERSION}")
+    STRING(REGEX REPLACE "^[0-9]+\\.([0-9])+\\.[0-9]+" "\\1" req_qt_minor_vers "${QT_MIN_VERSION}")
+    STRING(REGEX REPLACE "^[0-9]+\\.[0-9]+\\.([0-9]+)" "\\1" req_qt_patch_vers "${QT_MIN_VERSION}")
+
+    IF (NOT req_qt_major_vers EQUAL 4)
+      MESSAGE( FATAL_ERROR "Invalid Qt version string given: \"${QT_MIN_VERSION}\", major version 4 is required, e.g. \"4.0.1\"")
+    ENDIF (NOT req_qt_major_vers EQUAL 4)
+
+    # and now the version string given by qmake
+    STRING(REGEX REPLACE "^([0-9]+)\\.[0-9]+\\.[0-9]+.*" "\\1" found_qt_major_vers "${QTVERSION}")
+    STRING(REGEX REPLACE "^[0-9]+\\.([0-9])+\\.[0-9]+.*" "\\1" found_qt_minor_vers "${QTVERSION}")
+    STRING(REGEX REPLACE "^[0-9]+\\.[0-9]+\\.([0-9]+).*" "\\1" found_qt_patch_vers "${QTVERSION}")
+
+    # compute an overall version number which can be compared at once
+    MATH(EXPR req_vers "${req_qt_major_vers}*10000 + ${req_qt_minor_vers}*100 + ${req_qt_patch_vers}")
+    MATH(EXPR found_vers "${found_qt_major_vers}*10000 + ${found_qt_minor_vers}*100 + ${found_qt_patch_vers}")
+
+    IF (found_vers LESS req_vers)
+      SET(QT4_QMAKE_FOUND FALSE)
+      SET(QT4_INSTALLED_VERSION_TOO_OLD TRUE)
+    ELSE (found_vers LESS req_vers)
+      SET(QT4_QMAKE_FOUND TRUE)
+    ENDIF (found_vers LESS req_vers)
+  ENDIF (qt_version_tmp)
+
+ENDIF (QT_QMAKE_EXECUTABLE)
+
+IF (QT4_QMAKE_FOUND)
+
+  if (WIN32)
+    # get qt install dir 
+    get_filename_component(_DIR ${QT_QMAKE_EXECUTABLE} PATH )
+    get_filename_component(QT_INSTALL_DIR ${_DIR} PATH )
+  endif (WIN32)
+
+  # ask qmake for the library dir
+  # Set QT_LIBRARY_DIR
+  IF (NOT QT_LIBRARY_DIR)
+    EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+      ARGS "-query QT_INSTALL_LIBS"
+      OUTPUT_VARIABLE QT_LIBRARY_DIR_TMP )
+    # make sure we have / and not \ as qmake gives on windows
+    FILE(TO_CMAKE_PATH "${QT_LIBRARY_DIR_TMP}" QT_LIBRARY_DIR_TMP)
+    IF(EXISTS "${QT_LIBRARY_DIR_TMP}")
+      SET(QT_LIBRARY_DIR ${QT_LIBRARY_DIR_TMP} CACHE PATH "Qt library dir")
+    ELSE(EXISTS "${QT_LIBRARY_DIR_TMP}")
+      MESSAGE("Warning: QT_QMAKE_EXECUTABLE reported QT_INSTALL_LIBS as ${QT_LIBRARY_DIR_TMP}")
+      MESSAGE("Warning: ${QT_LIBRARY_DIR_TMP} does NOT exist, Qt must NOT be installed correctly.")
+    ENDIF(EXISTS "${QT_LIBRARY_DIR_TMP}")
+  ENDIF(NOT QT_LIBRARY_DIR)
+  
+  IF (APPLE)
+    IF (EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+      SET(QT_USE_FRAMEWORKS ON
+        CACHE BOOL "Set to ON if Qt build uses frameworks.")
+    ELSE (EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+      SET(QT_USE_FRAMEWORKS OFF
+        CACHE BOOL "Set to ON if Qt build uses frameworks.")
+    ENDIF (EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+    
+    MARK_AS_ADVANCED(QT_USE_FRAMEWORKS)
+  ENDIF (APPLE)
+  
+  # ask qmake for the binary dir
+  IF (QT_LIBRARY_DIR AND NOT QT_BINARY_DIR)
+     EXEC_PROGRAM(${QT_QMAKE_EXECUTABLE}
+       ARGS "-query QT_INSTALL_BINS"
+       OUTPUT_VARIABLE qt_bins )
+     # make sure we have / and not \ as qmake gives on windows
+     FILE(TO_CMAKE_PATH "${qt_bins}" qt_bins)
+     SET(QT_BINARY_DIR ${qt_bins} CACHE INTERNAL "")
+  ENDIF (QT_LIBRARY_DIR AND NOT QT_BINARY_DIR)
+
+  # ask qmake for the include dir
+  IF (QT_LIBRARY_DIR AND NOT QT_HEADERS_DIR)
+      EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+        ARGS "-query QT_INSTALL_HEADERS" 
+        OUTPUT_VARIABLE qt_headers ) 
+      # make sure we have / and not \ as qmake gives on windows
+      FILE(TO_CMAKE_PATH "${qt_headers}" qt_headers)
+      SET(QT_HEADERS_DIR ${qt_headers} CACHE INTERNAL "")
+  ENDIF(QT_LIBRARY_DIR AND NOT QT_HEADERS_DIR)
+
+
+  # ask qmake for the documentation directory
+  IF (QT_LIBRARY_DIR AND NOT QT_DOC_DIR)
+    EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+      ARGS "-query QT_INSTALL_DOCS"
+      OUTPUT_VARIABLE qt_doc_dir )
+    # make sure we have / and not \ as qmake gives on windows
+    FILE(TO_CMAKE_PATH "${qt_doc_dir}" qt_doc_dir)
+    SET(QT_DOC_DIR ${qt_doc_dir} CACHE PATH "The location of the Qt docs")
+  ENDIF (QT_LIBRARY_DIR AND NOT QT_DOC_DIR)
+
+  # ask qmake for the mkspecs directory
+  IF (QT_LIBRARY_DIR AND NOT QT_MKSPECS_DIR)
+    EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+      ARGS "-query QMAKE_MKSPECS"
+      OUTPUT_VARIABLE qt_mkspecs_dirs )
+    # do not replace : on windows as it might be a drive letter
+    # and windows should already use ; as a separator
+    IF(UNIX)
+      STRING(REPLACE ":" ";" qt_mkspecs_dirs "${qt_mkspecs_dirs}")
+    ENDIF(UNIX)
+    FIND_PATH(QT_MKSPECS_DIR qconfig.pri PATHS ${qt_mkspecs_dirs}
+      DOC "The location of the Qt mkspecs containing qconfig.pri"
+      NO_DEFAULT_PATH )
+  ENDIF (QT_LIBRARY_DIR AND NOT QT_MKSPECS_DIR)
+
+  # ask qmake for the plugins directory
+  IF (QT_LIBRARY_DIR AND NOT QT_PLUGINS_DIR)
+    EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+      ARGS "-query QT_INSTALL_PLUGINS"
+      OUTPUT_VARIABLE qt_plugins_dir )
+    # make sure we have / and not \ as qmake gives on windows
+    FILE(TO_CMAKE_PATH "${qt_plugins_dir}" qt_plugins_dir)
+    SET(QT_PLUGINS_DIR ${qt_plugins_dir} CACHE PATH "The location of the Qt plugins")
+  ENDIF (QT_LIBRARY_DIR AND NOT QT_PLUGINS_DIR)
+  ########################################
+  #
+  #       Setting the INCLUDE-Variables
+  #
+  ########################################
+
+  FIND_PATH(QT_QTCORE_INCLUDE_DIR QtGlobal
+    ${QT_HEADERS_DIR}/QtCore
+    ${QT_LIBRARY_DIR}/QtCore.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_INCLUDE_DIR by removine "/QtCore" in the string ${QT_QTCORE_INCLUDE_DIR}
+  IF( QT_QTCORE_INCLUDE_DIR AND NOT QT_INCLUDE_DIR)
+    IF (QT_USE_FRAMEWORKS)
+      SET(QT_INCLUDE_DIR ${QT_HEADERS_DIR})
+    ELSE (QT_USE_FRAMEWORKS)
+      STRING( REGEX REPLACE "/QtCore$" "" qt4_include_dir ${QT_QTCORE_INCLUDE_DIR})
+      SET( QT_INCLUDE_DIR ${qt4_include_dir} CACHE PATH "")
+    ENDIF (QT_USE_FRAMEWORKS)
+  ENDIF( QT_QTCORE_INCLUDE_DIR AND NOT QT_INCLUDE_DIR)
+
+  IF( NOT QT_INCLUDE_DIR)
+    IF( NOT Qt4_FIND_QUIETLY AND Qt4_FIND_REQUIRED)
+      MESSAGE( FATAL_ERROR "Could NOT find QtGlobal header")
+    ENDIF( NOT Qt4_FIND_QUIETLY AND Qt4_FIND_REQUIRED)
+  ENDIF( NOT QT_INCLUDE_DIR)
+
+  #############################################
+  #
+  # Find out what window system we're using
+  #
+  #############################################
+  # Save required includes and required_flags variables
+  macro_push_required_vars()
+  # Add QT_INCLUDE_DIR to CMAKE_REQUIRED_INCLUDES
+  SET(CMAKE_REQUIRED_INCLUDES "${CMAKE_REQUIRED_INCLUDES};${QT_INCLUDE_DIR}")
+  # On Mac OS X when Qt has framework support, also add the framework path
+  IF( QT_USE_FRAMEWORKS )
+    SET(CMAKE_REQUIRED_FLAGS "-F${QT_LIBRARY_DIR} ")
+  ENDIF( QT_USE_FRAMEWORKS )
+  # Check for Window system symbols (note: only one should end up being set)
+  CHECK_SYMBOL_EXISTS(Q_WS_X11 "QtCore/qglobal.h" Q_WS_X11)
+  CHECK_SYMBOL_EXISTS(Q_WS_WIN "QtCore/qglobal.h" Q_WS_WIN)
+  CHECK_SYMBOL_EXISTS(Q_WS_QWS "QtCore/qglobal.h" Q_WS_QWS)
+  CHECK_SYMBOL_EXISTS(Q_WS_MAC "QtCore/qglobal.h" Q_WS_MAC)
+
+  IF (QT_QTCOPY_REQUIRED)
+     CHECK_SYMBOL_EXISTS(QT_IS_QTCOPY "QtCore/qglobal.h" QT_KDE_QT_COPY)
+     IF (NOT QT_IS_QTCOPY)
+        MESSAGE(FATAL_ERROR "qt-copy is required, but hasn't been found")
+     ENDIF (NOT QT_IS_QTCOPY)
+  ENDIF (QT_QTCOPY_REQUIRED)
+
+  # Restore CMAKE_REQUIRED_INCLUDES+CMAKE_REQUIRED_FLAGS variables
+  macro_pop_required_vars()
+  #
+  #############################################
+
+  IF (QT_USE_FRAMEWORKS)
+    SET(QT_DEFINITIONS ${QT_DEFINITIONS} -F${QT_LIBRARY_DIR} -L${QT_LIBRARY_DIR} )
+  ENDIF (QT_USE_FRAMEWORKS)
+
+  # Set QT_QT3SUPPORT_INCLUDE_DIR
+  FIND_PATH(QT_QT3SUPPORT_INCLUDE_DIR Qt3Support
+    PATHS
+    ${QT_INCLUDE_DIR}/Qt3Support
+    ${QT_LIBRARY_DIR}/Qt3Support.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QT_INCLUDE_DIR
+  FIND_PATH(QT_QT_INCLUDE_DIR qglobal.h
+    PATHS
+    ${QT_INCLUDE_DIR}/Qt
+    ${QT_LIBRARY_DIR}/QtCore.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTGUI_INCLUDE_DIR
+  FIND_PATH(QT_QTGUI_INCLUDE_DIR QtGui
+    PATHS
+    ${QT_INCLUDE_DIR}/QtGui
+    ${QT_LIBRARY_DIR}/QtGui.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTSVG_INCLUDE_DIR
+  FIND_PATH(QT_QTSVG_INCLUDE_DIR QtSvg
+    PATHS
+    ${QT_INCLUDE_DIR}/QtSvg
+    ${QT_LIBRARY_DIR}/QtSvg.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTSCRIPT_INCLUDE_DIR
+  FIND_PATH(QT_QTSCRIPT_INCLUDE_DIR QtScript
+    PATHS
+    ${QT_INCLUDE_DIR}/QtScript
+    ${QT_LIBRARY_DIR}/QtScript.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTTEST_INCLUDE_DIR
+  FIND_PATH(QT_QTTEST_INCLUDE_DIR QtTest
+    PATHS
+    ${QT_INCLUDE_DIR}/QtTest
+    ${QT_LIBRARY_DIR}/QtTest.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTUITOOLS_INCLUDE_DIR
+  FIND_PATH(QT_QTUITOOLS_INCLUDE_DIR QtUiTools
+    PATHS
+    ${QT_INCLUDE_DIR}/QtUiTools
+    ${QT_LIBRARY_DIR}/QtUiTools.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTMOTIF_INCLUDE_DIR
+  IF(Q_WS_X11)
+    FIND_PATH(QT_QTMOTIF_INCLUDE_DIR QtMotif 
+      PATHS 
+      ${QT_INCLUDE_DIR}/QtMotif 
+      NO_DEFAULT_PATH )
+  ENDIF(Q_WS_X11)
+
+  # Set QT_QTNETWORK_INCLUDE_DIR
+  FIND_PATH(QT_QTNETWORK_INCLUDE_DIR QtNetwork
+    PATHS
+    ${QT_INCLUDE_DIR}/QtNetwork
+    ${QT_LIBRARY_DIR}/QtNetwork.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTNSPLUGIN_INCLUDE_DIR
+  FIND_PATH(QT_QTNSPLUGIN_INCLUDE_DIR QtNsPlugin
+    PATHS
+    ${QT_INCLUDE_DIR}/QtNsPlugin
+    ${QT_LIBRARY_DIR}/QtNsPlugin.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTOPENGL_INCLUDE_DIR
+  FIND_PATH(QT_QTOPENGL_INCLUDE_DIR QtOpenGL
+    PATHS
+    ${QT_INCLUDE_DIR}/QtOpenGL
+    ${QT_LIBRARY_DIR}/QtOpenGL.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTSQL_INCLUDE_DIR
+  FIND_PATH(QT_QTSQL_INCLUDE_DIR QtSql
+    PATHS
+    ${QT_INCLUDE_DIR}/QtSql
+    ${QT_LIBRARY_DIR}/QtSql.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTXML_INCLUDE_DIR
+  FIND_PATH(QT_QTXML_INCLUDE_DIR QtXml
+    PATHS
+    ${QT_INCLUDE_DIR}/QtXml
+    ${QT_LIBRARY_DIR}/QtXml.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTASSISTANT_INCLUDE_DIR
+  FIND_PATH(QT_QTASSISTANT_INCLUDE_DIR QtAssistant
+    PATHS
+    ${QT_INCLUDE_DIR}/QtAssistant
+    ${QT_HEADERS_DIR}/QtAssistant
+    ${QT_LIBRARY_DIR}/QtAssistant.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTDESIGNER_INCLUDE_DIR
+  FIND_PATH(QT_QTDESIGNER_INCLUDE_DIR QDesignerComponents
+    PATHS
+    ${QT_INCLUDE_DIR}/QtDesigner
+    ${QT_HEADERS_DIR}/QtDesigner 
+    ${QT_LIBRARY_DIR}/QtDesigner.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR
+  FIND_PATH(QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR QDesignerComponents
+    PATHS
+    ${QT_INCLUDE_DIR}/QtDesigner
+    ${QT_HEADERS_DIR}/QtDesigner
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTDBUS_INCLUDE_DIR
+  FIND_PATH(QT_QTDBUS_INCLUDE_DIR QtDBus
+    PATHS
+    ${QT_INCLUDE_DIR}/QtDBus
+    ${QT_HEADERS_DIR}/QtDBus
+    NO_DEFAULT_PATH
+    )
+  
+  # Set QT_QTASSISTANTCLIENT_INCLUDE_DIR
+  FIND_PATH(QT_QTASSISTANTCLIENT_INCLUDE_DIR QAssistantClient
+    PATHS
+    ${QT_INCLUDE_DIR}/QtAssistant
+    ${QT_HEADERS_DIR}/QtAssistant
+    NO_DEFAULT_PATH
+    )
+  
+  # Set QT_QTHELP_INCLUDE_DIR
+  FIND_PATH(QT_QTHELP_INCLUDE_DIR QtHelp
+    PATHS
+    ${QT_INCLUDE_DIR}/QtHelp
+    ${QT_HEADERS_DIR}/QtHelp
+    NO_DEFAULT_PATH
+    )
+  
+  # Set QT_QTWEBKIT_INCLUDE_DIR
+  FIND_PATH(QT_QTWEBKIT_INCLUDE_DIR QtWebKit
+    PATHS
+    ${QT_INCLUDE_DIR}/QtWebKit
+    ${QT_HEADERS_DIR}/QtWebKit
+    NO_DEFAULT_PATH
+    )
+  
+  # Set QT_QTXMLPATTERNS_INCLUDE_DIR
+  FIND_PATH(QT_QTXMLPATTERNS_INCLUDE_DIR QtXmlPatterns
+    PATHS
+    ${QT_INCLUDE_DIR}/QtXmlPatterns
+    ${QT_HEADERS_DIR}/QtXmlPatterns
+    NO_DEFAULT_PATH
+    )
+  
+  # Set QT_PHONON_INCLUDE_DIR
+  FIND_PATH(QT_PHONON_INCLUDE_DIR phonon
+    PATHS
+    ${QT_INCLUDE_DIR}/phonon
+    NO_DEFAULT_PATH
+    )
+
+  # Make variables changeble to the advanced user
+  MARK_AS_ADVANCED( QT_LIBRARY_DIR QT_INCLUDE_DIR QT_QT_INCLUDE_DIR QT_DOC_DIR QT_MKSPECS_DIR QT_PLUGINS_DIR)
+
+  # Set QT_INCLUDES
+  SET( QT_INCLUDES ${QT_QT_INCLUDE_DIR} ${QT_MKSPECS_DIR}/default ${QT_INCLUDE_DIR} )
+
+  ########################################
+  #
+  #       Setting the LIBRARY-Variables
+  #
+  ########################################
+
+  IF (QT_USE_FRAMEWORKS)
+    # If FIND_LIBRARY found libraries in Apple frameworks, we would NOT have
+    # to jump through these hoops.
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+      SET(QT_QTCORE_FOUND TRUE)
+      SET(QT_QTCORE_LIBRARY "-F${QT_LIBRARY_DIR} -framework QtCore" CACHE STRING "The QtCore library.")
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+      SET(QT_QTCORE_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtGui.framework)
+      SET(QT_QTGUI_FOUND TRUE)
+      SET(QT_QTGUI_LIBRARY "-F${QT_LIBRARY_DIR} -framework QtGui" CACHE STRING "The QtGui library.")
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtGui.framework)
+      SET(QT_QTGUI_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtGui.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/Qt3Support.framework)
+      SET(QT_QT3SUPPORT_FOUND TRUE)
+      SET(QT_QT3SUPPORT_LIBRARY "-F${QT_LIBRARY_DIR} -framework Qt3Support" CACHE STRING "The Qt3Support library.")
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/Qt3Support.framework)
+      SET(QT_QT3SUPPORT_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/Qt3Support.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtNetwork.framework)
+      SET(QT_QTNETWORK_FOUND TRUE)
+      SET(QT_QTNETWORK_LIBRARY "-F${QT_LIBRARY_DIR} -framework QtNetwork" CACHE STRING "The QtNetwork library.")
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtNetwork.framework)
+      SET(QT_QTNETWORK_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtNetwork.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtOpenGL.framework)
+      SET(QT_QTOPENGL_FOUND TRUE)
+      SET(QT_QTOPENGL_LIBRARY "-F${QT_LIBRARY_DIR} -framework QtOpenGL" CACHE STRING "The QtOpenGL library.")
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtOpenGL.framework)
+      SET(QT_QTOPENGL_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtOpenGL.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtSql.framework)
+      SET(QT_QTSQL_FOUND TRUE)
+      SET(QT_QTSQL_LIBRARY "-F${QT_LIBRARY_DIR} -framework QtSql" CACHE STRING "The QtSql library.")
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtSql.framework)
+      SET(QT_QTSQL_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtSql.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtXml.framework)
+      SET(QT_QTXML_FOUND TRUE)
+      SET(QT_QTXML_LIBRARY "-F${QT_LIBRARY_DIR} -framework QtXml" CACHE STRING "The QtXml library.")
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtXml.framework)
+      SET(QT_QTXML_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtXml.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtSvg.framework)
+      SET(QT_QTSVG_FOUND TRUE)
+      SET(QT_QTSVG_LIBRARY "-F${QT_LIBRARY_DIR} -framework QtSvg" CACHE STRING "The QtSvg library.")
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtSvg.framework)
+      SET(QT_QTSVG_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtSvg.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtDBus.framework)
+      SET(QT_QTDBUS_FOUND TRUE)
+      SET(QT_QTDBUS_LIBRARY "-F${QT_LIBRARY_DIR} -framework QtDBus" CACHE STRING "The QtDBus library.")
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtDBus.framework)
+      SET(QT_QTDBUS_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtDBus.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtTest.framework)
+      SET(QT_QTTEST_FOUND TRUE)
+      SET(QT_QTTEST_LIBRARY "-F${QT_LIBRARY_DIR} -framework QtTest" CACHE STRING "The QtTest library.")
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtTest.framework)
+      SET(QT_QTTEST_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtTest.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtAssistantClient.framework)
+      SET(QT_QTASSISTANTCLIENT_FOUND TRUE)
+      SET(QT_QTASSISTANTCLIENT_LIBRARY "-F${QT_LIBRARY_DIR} -framework QtAssistantClient" CACHE STRING "The QtAssistantClient library.")
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtAssistantClient.framework)
+      SET(QT_QTASSISTANTCLIENT_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtAssistantClient.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtWebKit.framework)
+      SET(QT_QTWEBKIT_FOUND TRUE)
+      SET(QT_QTWEBKIT_LIBRARY "-F${QT_LIBRARY_DIR} -framework QtWebKit" CACHE STRING "The QtWebKit library.")
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtWebKit.framework)
+      SET(QT_QTWEBKIT_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtWebKit.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtXmlPatterns.framework)
+      SET(QT_QTXMLPATTERNS_FOUND TRUE)
+      SET(QT_QTXMLPATTERNS_LIBRARY "-F${QT_LIBRARY_DIR} -framework QtXmlPatterns" CACHE STRING "The QtXmlPatterns library.")
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtXmlPatterns.framework)
+      SET(QT_QTXMLPATTERNS_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtXmlPatterns.framework)
+
+
+    # WTF?  why don't we have frameworks?  :P
+    # Set QT_QTUITOOLS_LIBRARY
+    FIND_LIBRARY(QT_QTUITOOLS_LIBRARY NAMES QtUiTools QtUiTools4 PATHS ${QT_LIBRARY_DIR} )
+    # Set QT_QTSCRIPT_LIBRARY
+    FIND_LIBRARY(QT_QTSCRIPT_LIBRARY NAMES QtScript QtScript4    PATHS ${QT_LIBRARY_DIR} )
+
+  ELSE (QT_USE_FRAMEWORKS)
+    
+    # Set QT_QTCORE_LIBRARY by searching for a lib with "QtCore."  as part of the filename
+    FIND_LIBRARY(QT_QTCORE_LIBRARY NAMES QtCore QtCore4 QtCored4 QtCore_debug         PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH )
+
+    # Set QT_QT3SUPPORT_LIBRARY
+    FIND_LIBRARY(QT_QT3SUPPORT_LIBRARY NAMES Qt3Support Qt3Support_debug Qt3Support4 Qt3Supportd4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTGUI_LIBRARY
+    FIND_LIBRARY(QT_QTGUI_LIBRARY NAMES QtGui QtGui_debug QtGui_debug QtGui4 QtGuid4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTMOTIF_LIBRARY
+    IF(Q_WS_X11)
+      FIND_LIBRARY(QT_QTMOTIF_LIBRARY NAMES QtMotif  QtMotif_debug PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+    ENDIF(Q_WS_X11)
+
+    # Set QT_QTNETWORK_LIBRARY
+    FIND_LIBRARY(QT_QTNETWORK_LIBRARY NAMES QtNetwork QtNetwork_debug QtNetwork4 QtNetworkd4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTNSPLUGIN_LIBRARY
+    FIND_LIBRARY(QT_QTNSPLUGIN_LIBRARY NAMES QtNsPlugin QtNsPlugin_debug PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTOPENGL_LIBRARY
+    FIND_LIBRARY(QT_QTOPENGL_LIBRARY NAMES QtOpenGL QtOpenGL_debug QtOpenGL4 QtOpenGLd4    PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTSQL_LIBRARY
+    FIND_LIBRARY(QT_QTSQL_LIBRARY NAMES QtSql QtSql_debug QtSql4 QtSqld4       PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTXML_LIBRARY
+    FIND_LIBRARY(QT_QTXML_LIBRARY NAMES QtXml QtXml_debug QtXml4 QtXmld4       PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTSVG_LIBRARY
+    FIND_LIBRARY(QT_QTSVG_LIBRARY NAMES QtSvg QtSvg_debug QtSvg4 QtSvgd4       PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTSCRIPT_LIBRARY
+    FIND_LIBRARY(QT_QTSCRIPT_LIBRARY NAMES QtScript QtScript_debug QtScript4 QtScriptd4   PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTUITOOLS_LIBRARY
+    FIND_LIBRARY(QT_QTUITOOLS_LIBRARY NAMES QtUiTools QtUiTools_debug QtUiTools4 QtUiToolsd4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTTEST_LIBRARY
+    FIND_LIBRARY(QT_QTTEST_LIBRARY NAMES QtTest QtTest_debug QtTest4 QtTestd4          PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    FIND_LIBRARY(QT_QTDBUS_LIBRARY NAMES QtDBus QtDBus_debug QtDBus4 QtDBusd4         PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    FIND_LIBRARY(QT_QTASSISTANTCLIENT_LIBRARY NAMES QtAssistantClient QtAssistantClient_debug QtAssistantClient4 QtAssistantClientd4         PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    FIND_LIBRARY(QT_QTHELP_LIBRARY NAMES QtHelp QtHelp_debug QtHelp4 QtHelpd4         PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    FIND_LIBRARY(QT_QTWEBKIT_LIBRARY NAMES QtWebKit QtWebKit_debug QtWebKit4 QtWebKitd4         PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    FIND_LIBRARY(QT_QTXMLPATTERNS_LIBRARY NAMES QtXmlPatterns QtXmlPatterns_debug QtXmlPatterns4 QtXmlPatternsd4         PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    FIND_LIBRARY(QT_PHONON_LIBRARY NAMES phonon phonon4 phonon_debug phonond4    PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+
+    IF(MSVC)
+      FIND_LIBRARY(QT_QTCORE_LIBRARY_RELEASE    NAMES QtCore4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTCORE_LIBRARY_DEBUG      NAMES QtCored4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QT3SUPPORT_LIBRARY_RELEASE NAMES Qt3Support4        PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QT3SUPPORT_LIBRARY_DEBUG  NAMES Qt3Supportd4        PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTGUI_LIBRARY_RELEASE     NAMES QtGui4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTGUI_LIBRARY_DEBUG       NAMES QtGuid4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTNETWORK_LIBRARY_RELEASE NAMES QtNetwork4         PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTNETWORK_LIBRARY_DEBUG   NAMES QtNetworkd4         PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTOPENGL_LIBRARY_RELEASE  NAMES QtOpenGL4          PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTOPENGL_LIBRARY_DEBUG    NAMES QtOpenGLd4          PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTSQL_LIBRARY_RELEASE     NAMES QtSql4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTSQL_LIBRARY_DEBUG       NAMES QtSqld4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTXML_LIBRARY_RELEASE     NAMES QtXml4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTXML_LIBRARY_DEBUG       NAMES QtXmld4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTSVG_LIBRARY_RELEASE     NAMES QtSvg4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTSVG_LIBRARY_DEBUG       NAMES QtSvgd4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTSCRIPT_LIBRARY_RELEASE  NAMES QtScript4          PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTSCRIPT_LIBRARY_DEBUG    NAMES QtScriptd4          PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTUITOOLS_LIBRARY_RELEASE NAMES QtUiTools QtUiTools4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTUITOOLS_LIBRARY_DEBUG   NAMES QtUiToolsd QtUiToolsd4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTTEST_LIBRARY_RELEASE    NAMES QtTest4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTTEST_LIBRARY_DEBUG      NAMES QtTestd4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTDBUS_LIBRARY_RELEASE    NAMES QtDBus4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTDBUS_LIBRARY_DEBUG      NAMES QtDBusd4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTASSISTANT_LIBRARY_RELEASE NAMES QtAssistantClient4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTASSISTANT_LIBRARY_DEBUG NAMES QtAssistantClientd4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTDESIGNER_LIBRARY_RELEASE NAMES QtDesigner4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTDESIGNER_LIBRARY_DEBUG  NAMES QtDesignerd4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTDESIGNERCOMPONENTS_LIBRARY_RELEASE NAMES QtDesignerComponents4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTDESIGNERCOMPONENTS_LIBRARY_DEBUG NAMES QtDesignerComponentsd4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTMAIN_LIBRARY_RELEASE    NAMES qtmain             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTMAIN_LIBRARY_DEBUG      NAMES qtmaind             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+    ENDIF(MSVC)
+  ENDIF (QT_USE_FRAMEWORKS)
+
+  IF( NOT QT_QTCORE_LIBRARY )
+    IF( NOT Qt4_FIND_QUIETLY AND Qt4_FIND_REQUIRED)
+      MESSAGE( FATAL_ERROR "Could NOT find QtCore. Check ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeError.log for more details.")
+    ENDIF( NOT Qt4_FIND_QUIETLY AND Qt4_FIND_REQUIRED)
+  ENDIF( NOT QT_QTCORE_LIBRARY )
+
+  # Set QT_QTASSISTANT_LIBRARY
+  FIND_LIBRARY(QT_QTASSISTANT_LIBRARY NAMES QtAssistantClient QtAssistantClient4 QtAssistant QtAssistant4 QtAssistantd4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+  # Set QT_QTDESIGNER_LIBRARY
+  FIND_LIBRARY(QT_QTDESIGNER_LIBRARY NAMES QtDesigner QtDesigner_debug QtDesigner4 QtDesignerd4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+  # Set QT_QTDESIGNERCOMPONENTS_LIBRARY
+  FIND_LIBRARY(QT_QTDESIGNERCOMPONENTS_LIBRARY NAMES QtDesignerComponents QtDesignerComponents_debug QtDesignerComponents4 QtDesignerComponentsd4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+  # Set QT_QTMAIN_LIBRARY
+  IF(WIN32)
+    FIND_LIBRARY(QT_QTMAIN_LIBRARY NAMES qtmain qtmaind PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+  ENDIF(WIN32)
+
+  ############################################
+  #
+  # Check the existence of the libraries.
+  #
+  ############################################
+
+  MACRO (_QT4_ADJUST_LIB_VARS basename)
+    IF (QT_${basename}_LIBRARY OR QT_${basename}_LIBRARY_DEBUG)
+
+      IF(MSVC)
+        # Both set
+        IF (QT_${basename}_LIBRARY_RELEASE AND QT_${basename}_LIBRARY_DEBUG)
+          SET(QT_${basename}_LIBRARY optimized ${QT_${basename}_LIBRARY_RELEASE} debug ${QT_${basename}_LIBRARY_DEBUG})
+        ENDIF (QT_${basename}_LIBRARY_RELEASE AND QT_${basename}_LIBRARY_DEBUG)
+
+        # Only debug was found
+        IF (NOT QT_${basename}_LIBRARY_RELEASE AND QT_${basename}_LIBRARY_DEBUG)
+          SET(QT_${basename}_LIBRARY ${QT_${basename}_LIBRARY_DEBUG})
+        ENDIF (NOT QT_${basename}_LIBRARY_RELEASE AND QT_${basename}_LIBRARY_DEBUG)
+
+        # Only release was found
+        IF (QT_${basename}_LIBRARY_RELEASE AND NOT QT_${basename}_LIBRARY_DEBUG)
+          SET(QT_${basename}_LIBRARY ${QT_${basename}_LIBRARY_RELEASE})
+        ENDIF (QT_${basename}_LIBRARY_RELEASE AND NOT QT_${basename}_LIBRARY_DEBUG)
+
+        # Hmm, is this used anywhere ? Yes, in UseQt4.cmake. We are currently incompatible :-(
+        SET(QT_${basename}_LIBRARIES optimized ${QT_${basename}_LIBRARY} debug ${QT_${basename}_LIBRARY_DEBUG})
+
+      ENDIF(MSVC)
+
+      SET(QT_${basename}_LIBRARY ${QT_${basename}_LIBRARY} CACHE FILEPATH "The Qt ${basename} library")
+
+      IF (QT_${basename}_LIBRARY)
+        SET(QT_${basename}_FOUND 1)
+      ENDIF (QT_${basename}_LIBRARY)
+      
+    ENDIF (QT_${basename}_LIBRARY OR QT_${basename}_LIBRARY_DEBUG)
+    
+    IF (QT_${basename}_INCLUDE_DIR)
+      #add the include directory to QT_INCLUDES
+      SET(QT_INCLUDES "${QT_${basename}_INCLUDE_DIR}" ${QT_INCLUDES})
+    ENDIF (QT_${basename}_INCLUDE_DIR)
+
+    # Make variables changeble to the advanced user
+    MARK_AS_ADVANCED(QT_${basename}_LIBRARY QT_${basename}_INCLUDE_DIR)
+  ENDMACRO (_QT4_ADJUST_LIB_VARS)
+
+
+  # Set QT_xyz_LIBRARY variable and add 
+  # library include path to QT_INCLUDES
+  _QT4_ADJUST_LIB_VARS(QTCORE)
+  _QT4_ADJUST_LIB_VARS(QTGUI)
+  _QT4_ADJUST_LIB_VARS(QT3SUPPORT)
+  _QT4_ADJUST_LIB_VARS(QTASSISTANT)
+  _QT4_ADJUST_LIB_VARS(QTDESIGNER)
+  _QT4_ADJUST_LIB_VARS(QTDESIGNERCOMPONENTS)
+  _QT4_ADJUST_LIB_VARS(QTNETWORK)
+  _QT4_ADJUST_LIB_VARS(QTNSPLUGIN)
+  _QT4_ADJUST_LIB_VARS(QTOPENGL)
+  _QT4_ADJUST_LIB_VARS(QTSQL)
+  _QT4_ADJUST_LIB_VARS(QTXML)
+  _QT4_ADJUST_LIB_VARS(QTSVG)
+  _QT4_ADJUST_LIB_VARS(QTSCRIPT)
+  _QT4_ADJUST_LIB_VARS(QTUITOOLS)
+  _QT4_ADJUST_LIB_VARS(QTTEST)
+  _QT4_ADJUST_LIB_VARS(QTDBUS)
+  _QT4_ADJUST_LIB_VARS(QTASSISTANTCLIENT)
+  _QT4_ADJUST_LIB_VARS(QTHELP)
+  _QT4_ADJUST_LIB_VARS(QTWEBKIT)
+  _QT4_ADJUST_LIB_VARS(QTXMLPATTERNS)
+  _QT4_ADJUST_LIB_VARS(PHONON)
+
+  # platform dependent libraries
+  IF(Q_WS_X11)
+    _QT4_ADJUST_LIB_VARS(QTMOTIF)
+  ENDIF(Q_WS_X11)
+  IF(WIN32)
+    _QT4_ADJUST_LIB_VARS(QTMAIN)
+  ENDIF(WIN32)
+  
+
+  #######################################
+  #
+  #       Check the executables of Qt 
+  #          ( moc, uic, rcc )
+  #
+  #######################################
+
+
+  # find moc and uic using qmake
+  QT_QUERY_QMAKE(QT_MOC_EXECUTABLE_INTERNAL "QMAKE_MOC")
+  QT_QUERY_QMAKE(QT_UIC_EXECUTABLE_INTERNAL "QMAKE_UIC")
+
+  # make sure we have / and not \ as qmake gives on windows
+  FILE(TO_CMAKE_PATH 
+    "${QT_MOC_EXECUTABLE_INTERNAL}" QT_MOC_EXECUTABLE_INTERNAL)
+  # make sure we have / and not \ as qmake gives on windows
+  FILE(TO_CMAKE_PATH 
+    "${QT_UIC_EXECUTABLE_INTERNAL}" QT_UIC_EXECUTABLE_INTERNAL)
+
+  SET(QT_MOC_EXECUTABLE 
+    ${QT_MOC_EXECUTABLE_INTERNAL} CACHE FILEPATH "The moc executable")
+  SET(QT_UIC_EXECUTABLE 
+    ${QT_UIC_EXECUTABLE_INTERNAL} CACHE FILEPATH "The uic executable")
+
+  FIND_PROGRAM(QT_UIC3_EXECUTABLE
+    NAMES uic3
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_RCC_EXECUTABLE 
+    NAMES rcc
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_DBUSCPP2XML_EXECUTABLE 
+    NAMES qdbuscpp2xml
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_DBUSXML2CPP_EXECUTABLE 
+    NAMES qdbusxml2cpp
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_LUPDATE_EXECUTABLE
+    NAMES lupdate
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_LRELEASE_EXECUTABLE
+    NAMES lrelease
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  IF (QT_MOC_EXECUTABLE)
+     SET(QT_WRAP_CPP "YES")
+  ENDIF (QT_MOC_EXECUTABLE)
+
+  IF (QT_UIC_EXECUTABLE)
+     SET(QT_WRAP_UI "YES")
+  ENDIF (QT_UIC_EXECUTABLE)
+
+
+
+  MARK_AS_ADVANCED( QT_UIC_EXECUTABLE QT_UIC3_EXECUTABLE QT_MOC_EXECUTABLE
+    QT_RCC_EXECUTABLE QT_DBUSXML2CPP_EXECUTABLE QT_DBUSCPP2XML_EXECUTABLE
+    QT_LUPDATE_EXECUTABLE QT_LRELEASE_EXECUTABLE)
+
+  ######################################
+  #
+  #       Macros for building Qt files
+  #
+  ######################################
+
+  MACRO (QT4_EXTRACT_OPTIONS _qt4_files _qt4_options)
+    SET(${_qt4_files})
+    SET(${_qt4_options})
+    SET(_QT4_DOING_OPTIONS FALSE)
+    FOREACH(_currentArg ${ARGN})
+      IF ("${_currentArg}" STREQUAL "OPTIONS")
+        SET(_QT4_DOING_OPTIONS TRUE)
+      ELSE ("${_currentArg}" STREQUAL "OPTIONS")
+        IF(_QT4_DOING_OPTIONS) 
+          LIST(APPEND ${_qt4_options} "${_currentArg}")
+        ELSE(_QT4_DOING_OPTIONS)
+          LIST(APPEND ${_qt4_files} "${_currentArg}")
+        ENDIF(_QT4_DOING_OPTIONS)
+      ENDIF ("${_currentArg}" STREQUAL "OPTIONS")
+    ENDFOREACH(_currentArg) 
+  ENDMACRO (QT4_EXTRACT_OPTIONS)
+
+  MACRO (QT4_GET_MOC_INC_DIRS _moc_INC_DIRS)
+     SET(${_moc_INC_DIRS})
+     GET_DIRECTORY_PROPERTY(_inc_DIRS INCLUDE_DIRECTORIES)
+
+     FOREACH(_current ${_inc_DIRS})
+        SET(${_moc_INC_DIRS} ${${_moc_INC_DIRS}} "-I" ${_current})
+     ENDFOREACH(_current ${_inc_DIRS})
+
+  ENDMACRO(QT4_GET_MOC_INC_DIRS)
+
+
+  MACRO (QT4_GENERATE_MOC infile outfile )
+  # get include dirs
+     QT4_GET_MOC_INC_DIRS(moc_includes)
+
+     GET_FILENAME_COMPONENT(abs_infile ${infile} ABSOLUTE)
+
+     IF (MSVC_IDE)
+        SET (_moc_parameter_file ${outfile}_parameters)
+        SET (_moc_param "${moc_includes} \n-o${outfile} \n${abs_infile}")
+        STRING(REGEX REPLACE ";-I;" "\\n-I" _moc_param "${_moc_param}")
+        FILE (WRITE ${_moc_parameter_file} "${_moc_param}")
+        ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+          COMMAND ${QT_MOC_EXECUTABLE}
+          ARGS @"${_moc_parameter_file}"
+          DEPENDS ${abs_infile})
+     ELSE (MSVC_IDE)     
+        ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+           COMMAND ${QT_MOC_EXECUTABLE}
+           ARGS ${moc_includes} -o ${outfile} ${abs_infile}
+           DEPENDS ${abs_infile})     
+     ENDIF (MSVC_IDE)
+
+     SET_SOURCE_FILES_PROPERTIES(${outfile} PROPERTIES SKIP_AUTOMOC TRUE)  # dont run automoc on this file
+
+     MACRO_ADD_FILE_DEPENDENCIES(${abs_infile} ${outfile})
+  ENDMACRO (QT4_GENERATE_MOC)
+
+
+  # QT4_WRAP_CPP(outfiles inputfile ... )
+
+  MACRO (QT4_WRAP_CPP outfiles )
+    # get include dirs
+    QT4_GET_MOC_INC_DIRS(moc_includes)
+    QT4_EXTRACT_OPTIONS(moc_files moc_options ${ARGN})
+
+    FOREACH (it ${moc_files})
+      GET_FILENAME_COMPONENT(it ${it} ABSOLUTE)
+      GET_FILENAME_COMPONENT(outfile ${it} NAME_WE)
+
+      SET(outfile ${CMAKE_CURRENT_BINARY_DIR}/moc_${outfile}.cxx)
+      ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+        COMMAND ${QT_MOC_EXECUTABLE}
+        ARGS ${moc_includes} ${moc_options} -o ${outfile} ${it}
+        DEPENDS ${it})
+      SET(${outfiles} ${${outfiles}} ${outfile})
+    ENDFOREACH(it)
+
+  ENDMACRO (QT4_WRAP_CPP)
+
+
+  # QT4_WRAP_UI(outfiles inputfile ... )
+
+  MACRO (QT4_WRAP_UI outfiles )
+    QT4_EXTRACT_OPTIONS(ui_files ui_options ${ARGN})
+
+    FOREACH (it ${ui_files})
+      GET_FILENAME_COMPONENT(outfile ${it} NAME_WE)
+      GET_FILENAME_COMPONENT(infile ${it} ABSOLUTE)
+      SET(outfile ${CMAKE_CURRENT_BINARY_DIR}/ui_${outfile}.h)
+      ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+        COMMAND ${QT_UIC_EXECUTABLE}
+        ARGS ${ui_options} -o ${outfile} ${infile}
+        MAIN_DEPENDENCY ${infile})
+      SET(${outfiles} ${${outfiles}} ${outfile})
+    ENDFOREACH (it)
+
+  ENDMACRO (QT4_WRAP_UI)
+
+
+  # QT4_ADD_RESOURCES(outfiles inputfile ... )
+
+  MACRO (QT4_ADD_RESOURCES outfiles )
+    QT4_EXTRACT_OPTIONS(rcc_files rcc_options ${ARGN})
+
+    FOREACH (it ${rcc_files})
+      GET_FILENAME_COMPONENT(outfilename ${it} NAME_WE)
+      GET_FILENAME_COMPONENT(infile ${it} ABSOLUTE)
+      GET_FILENAME_COMPONENT(rc_path ${infile} PATH)
+      SET(outfile ${CMAKE_CURRENT_BINARY_DIR}/qrc_${outfilename}.cxx)
+      #  parse file for dependencies 
+      #  all files are absolute paths or relative to the location of the qrc file
+      FILE(READ "${infile}" _RC_FILE_CONTENTS)
+      STRING(REGEX MATCHALL "<file[^<]+" _RC_FILES "${_RC_FILE_CONTENTS}")
+      SET(_RC_DEPENDS)
+      FOREACH(_RC_FILE ${_RC_FILES})
+        STRING(REGEX REPLACE "^<file[^>]*>" "" _RC_FILE "${_RC_FILE}")
+        STRING(REGEX MATCH "^/|([A-Za-z]:/)" _ABS_PATH_INDICATOR "${_RC_FILE}")
+        IF(NOT _ABS_PATH_INDICATOR)
+          SET(_RC_FILE "${rc_path}/${_RC_FILE}")
+        ENDIF(NOT _ABS_PATH_INDICATOR)
+        SET(_RC_DEPENDS ${_RC_DEPENDS} "${_RC_FILE}")
+      ENDFOREACH(_RC_FILE)
+      ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+        COMMAND ${QT_RCC_EXECUTABLE}
+        ARGS ${rcc_options} -name ${outfilename} -o ${outfile} ${infile}
+        MAIN_DEPENDENCY ${infile}
+        DEPENDS ${_RC_DEPENDS})
+      SET(${outfiles} ${${outfiles}} ${outfile})
+    ENDFOREACH (it)
+
+  ENDMACRO (QT4_ADD_RESOURCES)
+
+  MACRO(QT4_ADD_DBUS_INTERFACE _sources _interface _basename)
+    GET_FILENAME_COMPONENT(_infile ${_interface} ABSOLUTE)
+    SET(_header ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.h)
+    SET(_impl   ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.cpp)
+    SET(_moc    ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.moc)
+
+    GET_SOURCE_FILE_PROPERTY(_nonamespace ${_interface} NO_NAMESPACE)
+    IF ( _nonamespace )
+        SET(_params -N -m)
+    ELSE ( _nonamespace )
+        SET(_params -m)
+    ENDIF ( _nonamespace )
+
+    GET_SOURCE_FILE_PROPERTY(_include ${_interface} INCLUDE)
+    IF ( _include )
+        SET(_params ${_params} -i ${_include})
+    ENDIF ( _include )
+
+    ADD_CUSTOM_COMMAND(OUTPUT ${_impl} ${_header}
+        COMMAND ${QT_DBUSXML2CPP_EXECUTABLE} ${_params} -p ${_basename} ${_infile}
+        DEPENDS ${_infile})
+  
+    SET_SOURCE_FILES_PROPERTIES(${_impl} PROPERTIES SKIP_AUTOMOC TRUE)
+    
+    QT4_GENERATE_MOC(${_header} ${_moc})
+  
+    SET(${_sources} ${${_sources}} ${_impl} ${_header} ${_moc})
+    MACRO_ADD_FILE_DEPENDENCIES(${_impl} ${_moc})
+  
+  ENDMACRO(QT4_ADD_DBUS_INTERFACE)
+  
+  
+  MACRO(QT4_ADD_DBUS_INTERFACES _sources)
+     FOREACH (_current_FILE ${ARGN})
+        GET_FILENAME_COMPONENT(_infile ${_current_FILE} ABSOLUTE)
+        # get the part before the ".xml" suffix
+        STRING(REGEX REPLACE "(.*[/\\.])?([^\\.]+)\\.xml" "\\2" _basename ${_current_FILE})
+        STRING(TOLOWER ${_basename} _basename)
+        QT4_ADD_DBUS_INTERFACE(${_sources} ${_infile} ${_basename}interface)
+     ENDFOREACH (_current_FILE)
+  ENDMACRO(QT4_ADD_DBUS_INTERFACES)
+  
+  
+  MACRO(QT4_GENERATE_DBUS_INTERFACE _header) # _customName OPTIONS -some -options )
+    QT4_EXTRACT_OPTIONS(_customName _qt4_dbus_options ${ARGN})
+
+    GET_FILENAME_COMPONENT(_in_file ${_header} ABSOLUTE)
+    GET_FILENAME_COMPONENT(_basename ${_header} NAME_WE)
+    
+    IF (_customName)
+      SET(_target ${CMAKE_CURRENT_BINARY_DIR}/${_customName})
+    ELSE (_customName)
+      SET(_target ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.xml)
+    ENDIF (_customName)
+  
+    ADD_CUSTOM_COMMAND(OUTPUT ${_target}
+        COMMAND ${QT_DBUSCPP2XML_EXECUTABLE} ${_qt4_dbus_options} ${_in_file} > ${_target}
+        DEPENDS ${_in_file}
+    )
+  ENDMACRO(QT4_GENERATE_DBUS_INTERFACE)
+  
+  
+  MACRO(QT4_ADD_DBUS_ADAPTOR _sources _xml_file _include _parentClass) # _optionalBasename _optionalClassName)
+    GET_FILENAME_COMPONENT(_infile ${_xml_file} ABSOLUTE)
+    
+    SET(_optionalBasename "${ARGV4}")
+    IF (_optionalBasename)
+       SET(_basename ${_optionalBasename} )
+    ELSE (_optionalBasename)
+       STRING(REGEX REPLACE "(.*[/\\.])?([^\\.]+)\\.xml" "\\2adaptor" _basename ${_infile})
+       STRING(TOLOWER ${_basename} _basename)
+    ENDIF (_optionalBasename)
+
+    SET(_optionalClassName "${ARGV5}")
+    SET(_header ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.h)
+    SET(_impl   ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.cpp)
+    SET(_moc    ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.moc)
+
+    IF(_optionalClassName)
+       ADD_CUSTOM_COMMAND(OUTPUT ${_impl} ${_header}
+          COMMAND ${QT_DBUSXML2CPP_EXECUTABLE} -m -a ${_basename} -c ${_optionalClassName} -i ${_include} -l ${_parentClass} ${_infile}
+          DEPENDS ${_infile}
+        )
+    ELSE(_optionalClassName)
+       ADD_CUSTOM_COMMAND(OUTPUT ${_impl} ${_header}
+          COMMAND ${QT_DBUSXML2CPP_EXECUTABLE} -m -a ${_basename} -i ${_include} -l ${_parentClass} ${_infile}
+          DEPENDS ${_infile}
+        )
+    ENDIF(_optionalClassName)
+
+    QT4_GENERATE_MOC(${_header} ${_moc})
+    SET_SOURCE_FILES_PROPERTIES(${_impl} PROPERTIES SKIP_AUTOMOC TRUE)
+    MACRO_ADD_FILE_DEPENDENCIES(${_impl} ${_moc})
+
+    SET(${_sources} ${${_sources}} ${_impl} ${_header} ${_moc})
+  ENDMACRO(QT4_ADD_DBUS_ADAPTOR)
+
+   MACRO(QT4_AUTOMOC)
+      QT4_GET_MOC_INC_DIRS(_moc_INCS)
+
+      SET(_matching_FILES )
+      FOREACH (_current_FILE ${ARGN})
+
+         GET_FILENAME_COMPONENT(_abs_FILE ${_current_FILE} ABSOLUTE)
+         # if "SKIP_AUTOMOC" is set to true, we will not handle this file here.
+         # This is required to make uic work correctly:
+         # we need to add generated .cpp files to the sources (to compile them),
+         # but we cannot let automoc handle them, as the .cpp files don't exist yet when
+         # cmake is run for the very first time on them -> however the .cpp files might
+         # exist at a later run. at that time we need to skip them, so that we don't add two
+         # different rules for the same moc file
+         GET_SOURCE_FILE_PROPERTY(_skip ${_abs_FILE} SKIP_AUTOMOC)
+
+         IF ( NOT _skip AND EXISTS ${_abs_FILE} )
+
+            FILE(READ ${_abs_FILE} _contents)
+
+            GET_FILENAME_COMPONENT(_abs_PATH ${_abs_FILE} PATH)
+
+            STRING(REGEX MATCHALL "#include +[^ ]+\\.moc[\">]" _match "${_contents}")
+            IF(_match)
+               FOREACH (_current_MOC_INC ${_match})
+                  STRING(REGEX MATCH "[^ <\"]+\\.moc" _current_MOC "${_current_MOC_INC}")
+
+                  GET_filename_component(_basename ${_current_MOC} NAME_WE)
+   #               SET(_header ${CMAKE_CURRENT_SOURCE_DIR}/${_basename}.h)
+                  SET(_header ${_abs_PATH}/${_basename}.h)
+                  SET(_moc    ${CMAKE_CURRENT_BINARY_DIR}/${_current_MOC})
+                  ADD_CUSTOM_COMMAND(OUTPUT ${_moc}
+                     COMMAND ${QT_MOC_EXECUTABLE}
+                     ARGS ${_moc_INCS} ${_header} -o ${_moc}
+                     DEPENDS ${_header}
+                  )
+
+                  MACRO_ADD_FILE_DEPENDENCIES(${_abs_FILE} ${_moc})
+               ENDFOREACH (_current_MOC_INC)
+            ENDIF(_match)
+         ENDIF ( NOT _skip AND EXISTS ${_abs_FILE} )
+      ENDFOREACH (_current_FILE)
+   ENDMACRO(QT4_AUTOMOC)
+
+
+
+  ######################################
+  #
+  #       decide if Qt got found
+  #
+  ######################################
+
+  # if the includes,libraries,moc,uic and rcc are found then we have it
+  IF( QT_LIBRARY_DIR AND QT_INCLUDE_DIR AND QT_MOC_EXECUTABLE AND QT_UIC_EXECUTABLE AND QT_RCC_EXECUTABLE)
+    SET( QT4_FOUND "YES" )
+    IF( NOT Qt4_FIND_QUIETLY)
+      MESSAGE(STATUS "Found Qt-Version ${QTVERSION} (using ${QT_QMAKE_EXECUTABLE})")
+    ENDIF( NOT Qt4_FIND_QUIETLY)
+  ELSE( QT_LIBRARY_DIR AND QT_INCLUDE_DIR AND QT_MOC_EXECUTABLE AND QT_UIC_EXECUTABLE AND QT_RCC_EXECUTABLE)
+    SET( QT4_FOUND "NO")
+    SET(QT_QMAKE_EXECUTABLE "${QT_QMAKE_EXECUTABLE}-NOTFOUND" CACHE FILEPATH "Invalid qmake found" FORCE)
+    IF( Qt4_FIND_REQUIRED)
+      IF ( NOT QT_LIBRARY_DIR )
+        MESSAGE(STATUS "Qt libraries NOT found!")
+      ENDIF(NOT QT_LIBRARY_DIR )
+      IF ( NOT QT_INCLUDE_DIR )
+        MESSAGE(STATUS "Qt includes NOT found!")
+      ENDIF( NOT QT_INCLUDE_DIR )
+      IF ( NOT QT_MOC_EXECUTABLE )
+        MESSAGE(STATUS "Qt's moc NOT found!")
+      ENDIF( NOT QT_MOC_EXECUTABLE )
+      IF ( NOT QT_UIC_EXECUTABLE )
+        MESSAGE(STATUS "Qt's uic NOT found!")
+      ENDIF( NOT QT_UIC_EXECUTABLE )
+      IF ( NOT QT_RCC_EXECUTABLE )
+        MESSAGE(STATUS "Qt's rcc NOT found!")
+      ENDIF( NOT QT_RCC_EXECUTABLE )
+      MESSAGE( FATAL_ERROR "Qt libraries, includes, moc, uic or/and rcc NOT found!")
+    ENDIF( Qt4_FIND_REQUIRED)
+  ENDIF( QT_LIBRARY_DIR AND QT_INCLUDE_DIR AND QT_MOC_EXECUTABLE AND QT_UIC_EXECUTABLE AND  QT_RCC_EXECUTABLE)
+  SET(QT_FOUND ${QT4_FOUND})
+
+
+  #######################################
+  #
+  #       System dependent settings  
+  #
+  #######################################
+  # for unix add X11 stuff
+  IF(UNIX)
+    # on OS X X11 may not be required
+    IF (Q_WS_X11)
+      FIND_PACKAGE(X11 REQUIRED)
+    ENDIF (Q_WS_X11)
+    FIND_PACKAGE(Threads)
+    SET(QT_QTCORE_LIBRARY ${QT_QTCORE_LIBRARY} ${CMAKE_THREAD_LIBS_INIT})
+  ENDIF(UNIX)
+
+
+  #######################################
+  #
+  #       compatibility settings 
+  #
+  #######################################
+  # Backwards compatibility for CMake1.4 and 1.2
+  SET (QT_MOC_EXE ${QT_MOC_EXECUTABLE} )
+  SET (QT_UIC_EXE ${QT_UIC_EXECUTABLE} )
+
+  SET( QT_QT_LIBRARY "")
+
+ELSE(QT4_QMAKE_FOUND)
+   
+   SET(QT_QMAKE_EXECUTABLE "${QT_QMAKE_EXECUTABLE}-NOTFOUND" CACHE FILEPATH "Invalid qmake found" FORCE)
+   IF(Qt4_FIND_REQUIRED)
+      IF(QT4_INSTALLED_VERSION_TOO_OLD)
+         MESSAGE(FATAL_ERROR "The installed Qt version ${QTVERSION} is too old, at least version ${QT_MIN_VERSION} is required")
+      ELSE(QT4_INSTALLED_VERSION_TOO_OLD)
+         MESSAGE( FATAL_ERROR "Qt qmake not found!")
+      ENDIF(QT4_INSTALLED_VERSION_TOO_OLD)
+   ELSE(Qt4_FIND_REQUIRED)
+      IF(QT4_INSTALLED_VERSION_TOO_OLD AND NOT Qt4_FIND_QUIETLY)
+         MESSAGE(STATUS "The installed Qt version ${QTVERSION} is too old, at least version ${QT_MIN_VERSION} is required")
+      ENDIF(QT4_INSTALLED_VERSION_TOO_OLD AND NOT Qt4_FIND_QUIETLY)
+   ENDIF(Qt4_FIND_REQUIRED)
+ 
+ENDIF (QT4_QMAKE_FOUND)
+ENDIF (QT4_QMAKE_FOUND)
+
diff --git a/src/3rdparty/phonon/cmake/FindXCB.cmake b/src/3rdparty/phonon/cmake/FindXCB.cmake
new file mode 100644
index 0000000..517ad26
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/FindXCB.cmake
@@ -0,0 +1,43 @@
+# - Try to find libxcb
+# Once done this will define
+#
+#  LIBXCB_FOUND - system has libxcb
+#  LIBXCB_LIBRARIES - Link these to use libxcb
+#  LIBXCB_INCLUDE_DIR - the libxcb include dir
+#  LIBXCB_DEFINITIONS - compiler switches required for using libxcb
+
+# Copyright (c) 2008 Helio Chissini de Castro, <helio@kde.org>
+# Copyright (c) 2007, Matthias Kretz, <kretz@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+
+IF (NOT WIN32)
+  IF (LIBXCB_INCLUDE_DIR AND LIBXCB_LIBRARIES)
+    # in cache already
+    SET(XCB_FIND_QUIETLY TRUE)
+  ENDIF (LIBXCB_INCLUDE_DIR AND LIBXCB_LIBRARIES)
+
+  # use pkg-config to get the directories and then use these values
+  # in the FIND_PATH() and FIND_LIBRARY() calls
+  FIND_PACKAGE(PkgConfig)
+  PKG_CHECK_MODULES(PKG_XCB xcb)
+
+  SET(LIBXCB_DEFINITIONS ${PKG_XCB_CFLAGS})
+
+  FIND_PATH(LIBXCB_INCLUDE_DIR xcb/xcb.h
+    ${PKG_XCB_INCLUDE_DIRS}
+    )
+
+  FIND_LIBRARY(LIBXCB_LIBRARIES NAMES xcb libxcb
+    PATHS
+    ${PKG_XCB_LIBRARY_DIRS}
+    )
+
+  include(FindPackageHandleStandardArgs)
+  FIND_PACKAGE_HANDLE_STANDARD_ARGS(XCB DEFAULT_MSG LIBXCB_INCLUDE_DIR LIBXCB_LIBRARIES )
+
+
+  MARK_AS_ADVANCED(LIBXCB_INCLUDE_DIR LIBXCB_LIBRARIES XCBPROC_EXECUTABLE)
+ENDIF (NOT WIN32)
diff --git a/src/3rdparty/phonon/cmake/FindXine.cmake b/src/3rdparty/phonon/cmake/FindXine.cmake
new file mode 100644
index 0000000..d007ea1
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/FindXine.cmake
@@ -0,0 +1,57 @@
+# - Try to find the XINE  library
+# Once done this will define
+#
+#  XINE_FOUND - system has the XINE library
+#  XINE_VERSION - XINE version
+#  XINE_BUGFIX_VERSION - the XINE bugfix version
+#  XINE_INCLUDE_DIR - the XINE include directory
+#  XINE_LIBRARY - The libraries needed to use XINE
+#  XINE_XCB_FOUND - libxine can use XCB for video output
+
+# Copyright (c) 2008 Helio Chissini de Castro, <helio@kde.org>
+# Copyright (c) 2006,2007 Laurent Montel, <montel@kde.org>
+# Copyright (c) 2006, Matthias Kretz, <kretz@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+if (XINE_INCLUDE_DIR AND XINE_LIBRARY)
+  # Already in cache, be silent
+  set(Xine_FIND_QUIETLY TRUE)
+endif (XINE_INCLUDE_DIR AND XINE_LIBRARY)
+
+IF (NOT WIN32)
+    FIND_PACKAGE(PkgConfig)
+	PKG_CHECK_MODULES(PKG_XINE libxine)
+ENDIF (NOT WIN32)
+
+FIND_PATH(XINE_INCLUDE_DIR NAMES xine.h
+    PATHS ${PKG_XINE_INCLUDE_DIRS} )
+
+FIND_LIBRARY(XINE_LIBRARY NAMES xine
+ PATHS ${PKG_XINE_LIBRARY_DIRS} )
+
+if (XINE_INCLUDE_DIR AND XINE_LIBRARY)
+   macro_ensure_version(1.1.9 ${PKG_XINE_VERSION} XINE_VERSION_OK)
+   if (XINE_VERSION_OK)
+      set(XINE_FOUND TRUE)
+      string(REGEX REPLACE "[0-9].[0-9]." "" XINE_BUGFIX_VERSION ${PKG_XINE_VERSION})
+	  set(XINE_VERSION ${PKG_XINE_VERSION})
+   endif (XINE_VERSION_OK)
+endif (XINE_INCLUDE_DIR AND XINE_LIBRARY)
+
+
+if( XINE_FOUND )
+  INCLUDE(CheckCSourceCompiles)
+  SET(CMAKE_REQUIRED_INCLUDES ${XINE_INCLUDE_DIR})
+  SET(CMAKE_REQUIRED_LIBRARIES ${XINE_LIBRARY})
+  CHECK_C_SOURCE_COMPILES("#include <xine.h>\nint main()\n{\n  xine_open_video_driver(xine_new(), \"auto\", XINE_VISUAL_TYPE_XCB, NULL);\n  return 0;\n}\n" XINE_XCB_FOUND)
+endif(XINE_FOUND)
+
+if (XINE_FOUND)
+   if (NOT Xine_FIND_QUIETLY)
+      message(STATUS "Found XINE: ${XINE_LIBRARY}")
+   endif (NOT Xine_FIND_QUIETLY)
+endif (XINE_FOUND)
+
+MARK_AS_ADVANCED(XINE_INCLUDE_DIR XINE_LIBRARY)
diff --git a/src/3rdparty/phonon/cmake/MacroEnsureVersion.cmake b/src/3rdparty/phonon/cmake/MacroEnsureVersion.cmake
new file mode 100644
index 0000000..6797e5b
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/MacroEnsureVersion.cmake
@@ -0,0 +1,117 @@
+# This file defines the following macros for developers to use in ensuring
+# that installed software is of the right version:
+#
+# MACRO_ENSURE_VERSION        - test that a version number is greater than
+#                               or equal to some minimum
+# MACRO_ENSURE_VERSION_RANGE - test that a version number is greater than
+#                               or equal to some minimum and less than some
+#                               maximum
+# MACRO_ENSURE_VERSION2       - deprecated, do not use in new code
+#
+
+# MACRO_ENSURE_VERSION
+# This macro compares version numbers of the form "x.y.z" or "x.y"
+# MACRO_ENSURE_VERSION( FOO_MIN_VERSION FOO_VERSION_FOUND FOO_VERSION_OK)
+# will set FOO_VERSION_OK to true if FOO_VERSION_FOUND >= FOO_MIN_VERSION
+# Leading and trailing text is ok, e.g.
+# MACRO_ENSURE_VERSION( "2.5.31" "flex 2.5.4a" VERSION_OK)
+# which means 2.5.31 is required and "flex 2.5.4a" is what was found on the system
+
+# Copyright (c) 2006, David Faure, <faure@kde.org>
+# Copyright (c) 2007, Will Stephenson <wstephenson@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+# MACRO_ENSURE_VERSION_RANGE
+# This macro ensures that a version number of the form
+# "x.y.z" or "x.y" falls within a range defined by
+# min_version <= found_version < max_version.
+# If this expression holds, FOO_VERSION_OK will be set TRUE
+#
+# Example: MACRO_ENSURE_VERSION_RANGE3( "0.1.0" ${FOOCODE_VERSION} "0.7.0" FOO_VERSION_OK )
+#
+# This macro will break silently if any of x,y,z are greater than 100.
+#
+# Copyright (c) 2007, Will Stephenson <wstephenson@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+# NORMALIZE_VERSION
+# Helper macro to convert version numbers of the form "x.y.z"
+# to an integer equal to 10^4 * x + 10^2 * y + z
+#
+# This macro will break silently if any of x,y,z are greater than 100.
+#
+# Copyright (c) 2006, David Faure, <faure@kde.org>
+# Copyright (c) 2007, Will Stephenson <wstephenson@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+# CHECK_RANGE_INCLUSIVE_LOWER
+# Helper macro to check whether x <= y < z
+#
+# Copyright (c) 2007, Will Stephenson <wstephenson@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+
+MACRO(NORMALIZE_VERSION _requested_version _normalized_version)
+    STRING(REGEX MATCH "[^0-9]*[0-9]+\\.[0-9]+\\.[0-9]+.*" _threePartMatch "${_requested_version}")
+    if (_threePartMatch)
+    # parse the parts of the version string
+        STRING(REGEX REPLACE "[^0-9]*([0-9]+)\\.[0-9]+\\.[0-9]+.*" "\\1" _major_vers "${_requested_version}")
+        STRING(REGEX REPLACE "[^0-9]*[0-9]+\\.([0-9]+)\\.[0-9]+.*" "\\1" _minor_vers "${_requested_version}")
+        STRING(REGEX REPLACE "[^0-9]*[0-9]+\\.[0-9]+\\.([0-9]+).*" "\\1" _patch_vers "${_requested_version}")
+    else (_threePartMatch)
+        STRING(REGEX REPLACE "([0-9]+)\\.[0-9]+" "\\1" _major_vers "${_requested_version}")
+        STRING(REGEX REPLACE "[0-9]+\\.([0-9]+)" "\\1" _minor_vers "${_requested_version}")
+        set(_patch_vers "0")
+    endif (_threePartMatch)
+
+    # compute an overall version number which can be compared at once
+    MATH(EXPR ${_normalized_version} "${_major_vers}*10000 + ${_minor_vers}*100 + ${_patch_vers}")
+ENDMACRO(NORMALIZE_VERSION)
+
+MACRO(MACRO_CHECK_RANGE_INCLUSIVE_LOWER _lower_limit _value _upper_limit _ok)
+   if (${_value} LESS ${_lower_limit})
+      set( ${_ok} FALSE )
+  elseif (${_value} EQUAL ${_lower_limit})
+      set( ${_ok} TRUE )
+  elseif (${_value} EQUAL ${_upper_limit})
+      set( ${_ok} FALSE )
+  elseif (${_value} GREATER ${_upper_limit})
+      set( ${_ok} FALSE )
+  else (${_value} LESS ${_lower_limit})
+      set( ${_ok} TRUE )
+  endif (${_value} LESS ${_lower_limit})
+ENDMACRO(MACRO_CHECK_RANGE_INCLUSIVE_LOWER)
+
+MACRO(MACRO_ENSURE_VERSION requested_version found_version var_too_old)
+    NORMALIZE_VERSION( ${requested_version} req_vers_num )
+    NORMALIZE_VERSION( ${found_version} found_vers_num )
+
+    if (found_vers_num LESS req_vers_num)
+        set( ${var_too_old} FALSE )
+    else (found_vers_num LESS req_vers_num)
+        set( ${var_too_old} TRUE )
+    endif (found_vers_num LESS req_vers_num)
+
+ENDMACRO(MACRO_ENSURE_VERSION)
+
+MACRO(MACRO_ENSURE_VERSION2 requested_version2 found_version2 var_too_old2)
+    MACRO_ENSURE_VERSION( ${requested_version2} ${found_version2} ${var_too_old2})
+ENDMACRO(MACRO_ENSURE_VERSION2)
+
+MACRO(MACRO_ENSURE_VERSION_RANGE min_version found_version max_version var_ok)
+    NORMALIZE_VERSION( ${min_version} req_vers_num )
+    NORMALIZE_VERSION( ${found_version} found_vers_num )
+    NORMALIZE_VERSION( ${max_version} max_vers_num )
+
+    MACRO_CHECK_RANGE_INCLUSIVE_LOWER( ${req_vers_num} ${found_vers_num} ${max_vers_num} ${var_ok})
+ENDMACRO(MACRO_ENSURE_VERSION_RANGE)
+
+
diff --git a/src/3rdparty/phonon/cmake/MacroLogFeature.cmake b/src/3rdparty/phonon/cmake/MacroLogFeature.cmake
new file mode 100644
index 0000000..f0f3988
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/MacroLogFeature.cmake
@@ -0,0 +1,125 @@
+# This file defines the Feature Logging macros.
+#
+# MACRO_LOG_FEATURE(VAR FEATURE DESCRIPTION URL [REQUIRED [MIN_VERSION [COMMENTS]]])
+#   Logs the information so that it can be displayed at the end
+#   of the configure run
+#   VAR : TRUE or FALSE, indicating whether the feature is supported
+#   FEATURE: name of the feature, e.g. "libjpeg"
+#   DESCRIPTION: description what this feature provides
+#   URL: home page
+#   REQUIRED: TRUE or FALSE, indicating whether the featue is required
+#   MIN_VERSION: minimum version number. empty string if unneeded
+#   COMMENTS: More info you may want to provide.  empty string if unnecessary
+#
+# MACRO_DISPLAY_FEATURE_LOG()
+#   Call this to display the collected results.
+#   Exits CMake with a FATAL error message if a required feature is missing
+#
+# Example:
+#
+# INCLUDE(MacroLogFeature)
+#
+# FIND_PACKAGE(JPEG)
+# MACRO_LOG_FEATURE(JPEG_FOUND "libjpeg" "Support JPEG images" "http://www.ijg.org" TRUE "3.2a" "")
+# ...
+# MACRO_DISPLAY_FEATURE_LOG()
+
+# Copyright (c) 2006, Alexander Neundorf, <neundorf@kde.org>
+# Copyright (c) 2006, Allen Winter, <winter@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+IF (NOT _macroLogFeatureAlreadyIncluded)
+   SET(_file ${CMAKE_BINARY_DIR}/MissingRequirements.txt)
+   IF (EXISTS ${_file})
+      FILE(REMOVE ${_file})
+   ENDIF (EXISTS ${_file})
+
+   SET(_file ${CMAKE_BINARY_DIR}/EnabledFeatures.txt)
+   IF (EXISTS ${_file})
+      FILE(REMOVE ${_file})
+   ENDIF (EXISTS ${_file})
+
+   SET(_file ${CMAKE_BINARY_DIR}/DisabledFeatures.txt)
+   IF (EXISTS ${_file})
+      FILE(REMOVE ${_file})
+  ENDIF (EXISTS ${_file})
+
+  SET(_macroLogFeatureAlreadyIncluded TRUE)
+ENDIF (NOT _macroLogFeatureAlreadyIncluded)
+
+
+MACRO(MACRO_LOG_FEATURE _var _package _description _url ) # _required _minvers _comments)
+
+   SET(_required "${ARGV4}")
+   SET(_minvers "${ARGV5}")
+   SET(_comments "${ARGV6}")
+
+   IF (${_var})
+     SET(_LOGFILENAME ${CMAKE_BINARY_DIR}/EnabledFeatures.txt)
+   ELSE (${_var})
+     IF (${_required} MATCHES "[Tt][Rr][Uu][Ee]")
+       SET(_LOGFILENAME ${CMAKE_BINARY_DIR}/MissingRequirements.txt)
+     ELSE (${_required} MATCHES "[Tt][Rr][Uu][Ee]")
+       SET(_LOGFILENAME ${CMAKE_BINARY_DIR}/DisabledFeatures.txt)
+     ENDIF (${_required} MATCHES "[Tt][Rr][Uu][Ee]")
+   ENDIF (${_var})
+
+   SET(_logtext "+ ${_package}")
+
+   IF (NOT ${_var})
+      IF (${_minvers} MATCHES ".*")
+        SET(_logtext "${_logtext}, ${_minvers}")
+      ENDIF (${_minvers} MATCHES ".*")
+      SET(_logtext "${_logtext}: ${_description} <${_url}>")
+      IF (${_comments} MATCHES ".*")
+        SET(_logtext "${_logtext}\n${_comments}")
+      ENDIF (${_comments} MATCHES ".*")
+#      SET(_logtext "${_logtext}\n") #double-space missing features?
+   ENDIF (NOT ${_var})
+   FILE(APPEND "${_LOGFILENAME}" "${_logtext}\n")
+ 
+ENDMACRO(MACRO_LOG_FEATURE)
+
+
+MACRO(MACRO_DISPLAY_FEATURE_LOG)
+
+   SET(_file ${CMAKE_BINARY_DIR}/MissingRequirements.txt)
+   IF (EXISTS ${_file})
+      FILE(READ ${_file} _requirements)
+      MESSAGE(STATUS "\n-----------------------------------------------------------------------------\n-- The following REQUIRED packages could NOT be located on your system.\n-- Please install them before continuing this software installation.\n-----------------------------------------------------------------------------\n${_requirements}-----------------------------------------------------------------------------")
+      FILE(REMOVE ${_file})
+      MESSAGE(FATAL_ERROR "Exiting: Missing Requirements")
+   ENDIF (EXISTS ${_file})
+
+   SET(_summary "\n")
+
+   SET(_elist 0)
+   SET(_file ${CMAKE_BINARY_DIR}/EnabledFeatures.txt)
+   IF (EXISTS ${_file})
+      SET(_elist 1)
+      FILE(READ ${_file} _enabled)
+      FILE(REMOVE ${_file})
+      SET(_summary "${_summary}-----------------------------------------------------------------------------\n-- The following external packages were located on your system.\n-- This installation will have the extra features provided by these packages.\n${_enabled}")
+   ENDIF (EXISTS ${_file})
+
+   SET(_dlist 0)
+   SET(_file ${CMAKE_BINARY_DIR}/DisabledFeatures.txt)
+   IF (EXISTS ${_file})
+      SET(_dlist 1)
+      FILE(READ ${_file} _disabled)
+      FILE(REMOVE ${_file})
+      SET(_summary "${_summary}-----------------------------------------------------------------------------\n-- The following OPTIONAL packages could NOT be located on your system.\n-- Consider installing them to enable more features from this software.\n${_disabled}")
+   ELSE (EXISTS ${_file})
+      IF (${_elist})
+        SET(_summary "${_summary}Congratulations! All external packages have been found.\n")
+      ENDIF (${_elist})
+   ENDIF (EXISTS ${_file})
+
+   IF (${_elist} OR ${_dlist})
+      SET(_summary "${_summary}-----------------------------------------------------------------------------\n")
+   ENDIF (${_elist} OR ${_dlist})
+   MESSAGE(STATUS "${_summary}")
+
+ENDMACRO(MACRO_DISPLAY_FEATURE_LOG)
diff --git a/src/3rdparty/phonon/cmake/MacroOptionalFindPackage.cmake b/src/3rdparty/phonon/cmake/MacroOptionalFindPackage.cmake
new file mode 100644
index 0000000..816cdb7
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/MacroOptionalFindPackage.cmake
@@ -0,0 +1,28 @@
+# - MACRO_OPTIONAL_FIND_PACKAGE() combines FIND_PACKAGE() with an OPTION()
+# MACRO_OPTIONAL_FIND_PACKAGE( <name> [QUIT] )
+# This macro is a combination of OPTION() and FIND_PACKAGE(), it
+# works like FIND_PACKAGE(), but additionally it automatically creates
+# an option name WITH_<name>, which can be disabled via the cmake GUI.
+# or via -DWITH_<name>=OFF
+# The standard <name>_FOUND variables can be used in the same way
+# as when using the normal FIND_PACKAGE()
+
+# Copyright (c) 2006, Alexander Neundorf, <neundorf@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+
+MACRO (MACRO_OPTIONAL_FIND_PACKAGE _name )
+   OPTION(WITH_${_name} "Search for ${_name} package" ON)
+   if (WITH_${_name})
+      FIND_PACKAGE(${_name} ${ARGN})
+   else (WITH_${_name})
+      set(${_name}_FOUND)
+      set(${_name}_INCLUDE_DIR)
+      set(${_name}_INCLUDES)
+      set(${_name}_LIBRARY)
+      set(${_name}_LIBRARIES)
+   endif (WITH_${_name})
+ENDMACRO (MACRO_OPTIONAL_FIND_PACKAGE)
+
diff --git a/src/3rdparty/phonon/cmake/MacroPushRequiredVars.cmake b/src/3rdparty/phonon/cmake/MacroPushRequiredVars.cmake
new file mode 100644
index 0000000..650b566
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/MacroPushRequiredVars.cmake
@@ -0,0 +1,47 @@
+# this module defines two macros:
+# MACRO_PUSH_REQUIRED_VARS()
+# and
+# MACRO_POP_REQUIRED_VARS()
+# use these if you call cmake macros which use
+# any of the CMAKE_REQUIRED_XXX variables
+#
+# Usage:
+# MACRO_PUSH_REQUIRED_VARS()
+# SET(CMAKE_REQUIRED_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS} -DSOME_MORE_DEF)
+# CHECK_FUNCTION_EXISTS(...)
+# MACRO_POP_REQUIRED_VARS()
+
+# Copyright (c) 2006, Alexander Neundorf, <neundorf@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+MACRO(MACRO_PUSH_REQUIRED_VARS)
+
+   IF(NOT DEFINED _PUSH_REQUIRED_VARS_COUNTER)
+      SET(_PUSH_REQUIRED_VARS_COUNTER 0)
+   ENDIF(NOT DEFINED _PUSH_REQUIRED_VARS_COUNTER)
+
+   MATH(EXPR _PUSH_REQUIRED_VARS_COUNTER "${_PUSH_REQUIRED_VARS_COUNTER}+1")
+
+   SET(_CMAKE_REQUIRED_INCLUDES_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}    ${CMAKE_REQUIRED_INCLUDES})
+   SET(_CMAKE_REQUIRED_DEFINITIONS_SAVE_${_PUSH_REQUIRED_VARS_COUNTER} ${CMAKE_REQUIRED_DEFINITIONS})
+   SET(_CMAKE_REQUIRED_LIBRARIES_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}   ${CMAKE_REQUIRED_LIBRARIES})
+   SET(_CMAKE_REQUIRED_FLAGS_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}       ${CMAKE_REQUIRED_FLAGS})
+ENDMACRO(MACRO_PUSH_REQUIRED_VARS)
+
+MACRO(MACRO_POP_REQUIRED_VARS)
+
+# don't pop more than we pushed
+   IF("${_PUSH_REQUIRED_VARS_COUNTER}" GREATER "0")
+
+      SET(CMAKE_REQUIRED_INCLUDES    ${_CMAKE_REQUIRED_INCLUDES_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}})
+      SET(CMAKE_REQUIRED_DEFINITIONS ${_CMAKE_REQUIRED_DEFINITIONS_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}})
+      SET(CMAKE_REQUIRED_LIBRARIES   ${_CMAKE_REQUIRED_LIBRARIES_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}})
+      SET(CMAKE_REQUIRED_FLAGS       ${_CMAKE_REQUIRED_FLAGS_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}})
+
+      MATH(EXPR _PUSH_REQUIRED_VARS_COUNTER "${_PUSH_REQUIRED_VARS_COUNTER}-1")
+   ENDIF("${_PUSH_REQUIRED_VARS_COUNTER}" GREATER "0")
+
+ENDMACRO(MACRO_POP_REQUIRED_VARS)
+
diff --git a/src/3rdparty/phonon/cmake/PhononMacros.cmake b/src/3rdparty/phonon/cmake/PhononMacros.cmake
new file mode 100644
index 0000000..2ef05a5
--- /dev/null
+++ b/src/3rdparty/phonon/cmake/PhononMacros.cmake
@@ -0,0 +1,206 @@
+
+# Phonon helper macros:
+#
+# macro (phonon_add_executable _target)
+# macro (PHONON_ADD_UNIT_TEST _test_NAME)
+# macro (PHONON_UPDATE_ICONCACHE)
+# macro (PHONON_UPDATE_ICONCACHE)
+# macro (_PHONON_ADD_ICON_INSTALL_RULE _install_SCRIPT _install_PATH _group _orig_NAME _install_NAME _l10n_SUBDIR)
+# macro (PHONON_INSTALL_ICONS _defaultpath )
+
+set(_global_add_executable_param)
+if (Q_WS_MAC)
+   set(_global_add_executable_param MACOSX_BUNDLE)
+endif (Q_WS_MAC)
+if (WIN32)
+   # no WIN32 here - all executables are command line executables
+   set(_global_add_executable_param)
+endif (WIN32)
+
+macro(phonon_add_executable _target)
+   set(_srcs ${ARGN})
+   automoc4_add_executable(${_target} ${_global_add_executable_param} ${_srcs})
+endmacro(phonon_add_executable _target)
+
+macro (PHONON_ADD_UNIT_TEST _test_NAME)
+   set(_srcList ${ARGN})
+   set(_nogui)
+   list(GET ${_srcList} 0 first_PARAM)
+   set(_add_executable_param ${_global_add_executable_param})
+   if(${first_PARAM} STREQUAL "NOGUI")
+      set(_nogui "NOGUI")
+      set(_add_executable_param)
+   endif(${first_PARAM} STREQUAL "NOGUI")
+
+   if (NOT PHONON_BUILD_TESTS)
+      set(_add_executable_param ${_add_executable_param} EXCLUDE_FROM_ALL)
+   endif (NOT PHONON_BUILD_TESTS)
+
+   automoc4_add_executable(${_test_NAME} ${_add_executable_param} ${_srcList})
+
+   if(NOT PHONON_TEST_OUTPUT)
+      set(PHONON_TEST_OUTPUT plaintext)
+   endif(NOT PHONON_TEST_OUTPUT)
+   set(PHONON_TEST_OUTPUT ${PHONON_TEST_OUTPUT} CACHE STRING "The output to generate when running the QTest unit tests")
+
+   set(using_qtest "")
+   foreach(_filename ${_srcList})
+      if(NOT using_qtest)
+         if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${_filename}")
+            file(READ ${_filename} file_CONTENT)
+            string(REGEX MATCH "QTEST_(KDE)?MAIN" using_qtest "${file_CONTENT}")
+         endif(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${_filename}")
+      endif(NOT using_qtest)
+   endforeach(_filename)
+
+   set(_executable ${EXECUTABLE_OUTPUT_PATH}/${_test_NAME})
+   if (Q_WS_MAC AND NOT _nogui)
+      set(_executable ${EXECUTABLE_OUTPUT_PATH}/${_test_NAME}.app/Contents/MacOS/${_test_NAME})
+   else (Q_WS_MAC AND NOT _nogui)
+      # Use .shell wrapper where available, to use uninstalled libs.
+      #if (UNIX)
+      #   set(_executable ${_executable}.shell)
+      #endif (UNIX)
+   endif (Q_WS_MAC AND NOT _nogui)
+
+   if (using_qtest AND PHONON_TEST_OUTPUT STREQUAL "xml")
+      add_test( ${_test_NAME} ${_executable} -xml -o ${_test_NAME}.tml)
+   else (using_qtest AND PHONON_TEST_OUTPUT STREQUAL "xml")
+      add_test( ${_test_NAME} ${_executable} )
+   endif (using_qtest AND PHONON_TEST_OUTPUT STREQUAL "xml")
+
+   if (NOT MSVC_IDE)   #not needed for the ide
+      # if the tests are EXCLUDE_FROM_ALL, add a target "buildtests" to build all tests
+      if (NOT PHONON_BUILD_TESTS)
+         get_directory_property(_buildtestsAdded BUILDTESTS_ADDED)
+         if(NOT _buildtestsAdded)
+            add_custom_target(buildtests)
+            set_directory_properties(PROPERTIES BUILDTESTS_ADDED TRUE)
+         endif(NOT _buildtestsAdded)
+         add_dependencies(buildtests ${_test_NAME})
+      endif (NOT PHONON_BUILD_TESTS)
+   endif (NOT MSVC_IDE)
+endmacro (PHONON_ADD_UNIT_TEST)
+
+macro (PHONON_UPDATE_ICONCACHE)
+    # Update mtime of hicolor icon theme dir.
+    # We don't always have touch command (e.g. on Windows), so instead create
+    #  and delete a temporary file in the theme dir.
+   install(CODE "
+    set(DESTDIR_VALUE \"\$ENV{DESTDIR}\")
+    if (NOT DESTDIR_VALUE)
+        file(WRITE \"${ICON_INSTALL_DIR}/hicolor/temp.txt\" \"update\")
+        file(REMOVE \"${ICON_INSTALL_DIR}/hicolor/temp.txt\")
+    endif (NOT DESTDIR_VALUE)
+    ")
+endmacro (PHONON_UPDATE_ICONCACHE)
+
+# a "map" of short type names to the directories
+# unknown names should give empty results
+# KDE 3 compatibility
+set(_PHONON_ICON_GROUP_mime       "mimetypes")
+set(_PHONON_ICON_GROUP_filesys    "places")
+set(_PHONON_ICON_GROUP_device     "devices")
+set(_PHONON_ICON_GROUP_app        "apps")
+set(_PHONON_ICON_GROUP_action     "actions")
+# KDE 4 / icon naming specification compatibility
+set(_PHONON_ICON_GROUP_mimetypes  "mimetypes")
+set(_PHONON_ICON_GROUP_places     "places")
+set(_PHONON_ICON_GROUP_devices    "devices")
+set(_PHONON_ICON_GROUP_apps       "apps")
+set(_PHONON_ICON_GROUP_actions    "actions")
+set(_PHONON_ICON_GROUP_categories "categories")
+set(_PHONON_ICON_GROUP_status     "status")
+set(_PHONON_ICON_GROUP_emblems    "emblems")
+set(_PHONON_ICON_GROUP_emotes     "emotes")
+set(_PHONON_ICON_GROUP_animations "animations")
+set(_PHONON_ICON_GROUP_intl       "intl")
+
+# a "map" of short theme names to the theme directory
+set(_PHONON_ICON_THEME_ox "oxygen")
+set(_PHONON_ICON_THEME_cr "crystalsvg")
+set(_PHONON_ICON_THEME_lo "locolor")
+set(_PHONON_ICON_THEME_hi "hicolor")
+
+macro (_PHONON_ADD_ICON_INSTALL_RULE _install_SCRIPT _install_PATH _group _orig_NAME _install_NAME _l10n_SUBDIR)
+
+   # if the string doesn't match the pattern, the result is the full string, so all three have the same content
+   if (NOT ${_group} STREQUAL ${_install_NAME} )
+      set(_icon_GROUP  ${_PHONON_ICON_GROUP_${_group}})
+      if(NOT _icon_GROUP)
+         set(_icon_GROUP "actions")
+      endif(NOT _icon_GROUP)
+#      message(STATUS "icon: ${_current_ICON} size: ${_size} group: ${_group} name: ${_name} l10n: ${_l10n_SUBDIR}")
+      install(FILES ${_orig_NAME} DESTINATION ${_install_PATH}/${_icon_GROUP}/${_l10n_SUBDIR}/ RENAME ${_install_NAME} )
+   endif (NOT ${_group} STREQUAL ${_install_NAME} )
+
+endmacro (_PHONON_ADD_ICON_INSTALL_RULE)
+
+
+macro (PHONON_INSTALL_ICONS _defaultpath )
+
+   # the l10n-subdir if language given as second argument (localized icon)
+   set(_lang ${ARGV1})
+   if(_lang)
+      set(_l10n_SUBDIR l10n/${_lang})
+   else(_lang)
+      set(_l10n_SUBDIR ".")
+   endif(_lang)
+
+   # first the png icons
+   file(GLOB _icons *.png)
+   foreach (_current_ICON ${_icons} )
+      # since CMake 2.6 regex matches are stored in special variables CMAKE_MATCH_x, if it didn't match, they are empty
+      string(REGEX MATCH "^.*/([a-zA-Z]+)([0-9]+)\\-([a-z]+)\\-(.+\\.png)$" _dummy  "${_current_ICON}")
+      set(_type  "${CMAKE_MATCH_1}")
+      set(_size  "${CMAKE_MATCH_2}")
+      set(_group "${CMAKE_MATCH_3}")
+      set(_name  "${CMAKE_MATCH_4}")
+
+      set(_theme_GROUP ${_PHONON_ICON_THEME_${_type}})
+      if( _theme_GROUP)
+         _PHONON_ADD_ICON_INSTALL_RULE(${CMAKE_CURRENT_BINARY_DIR}/install_icons.cmake
+                    ${_defaultpath}/${_theme_GROUP}/${_size}x${_size}
+                    ${_group} ${_current_ICON} ${_name} ${_l10n_SUBDIR})
+      endif( _theme_GROUP)
+   endforeach (_current_ICON)
+
+   # mng icons
+   file(GLOB _icons *.mng)
+   foreach (_current_ICON ${_icons} )
+      # since CMake 2.6 regex matches are stored in special variables CMAKE_MATCH_x, if it didn't match, they are empty
+      string(REGEX MATCH "^.*/([a-zA-Z]+)([0-9]+)\\-([a-z]+)\\-(.+\\.mng)$" _dummy  "${_current_ICON}")
+      set(_type  "${CMAKE_MATCH_1}")
+      set(_size  "${CMAKE_MATCH_2}")
+      set(_group "${CMAKE_MATCH_3}")
+      set(_name  "${CMAKE_MATCH_4}")
+
+      set(_theme_GROUP ${_PHONON_ICON_THEME_${_type}})
+      if( _theme_GROUP)
+         _PHONON_ADD_ICON_INSTALL_RULE(${CMAKE_CURRENT_BINARY_DIR}/install_icons.cmake
+                ${_defaultpath}/${_theme_GROUP}/${_size}x${_size}
+                ${_group} ${_current_ICON} ${_name} ${_l10n_SUBDIR})
+      endif( _theme_GROUP)
+   endforeach (_current_ICON)
+
+   # and now the svg icons
+   file(GLOB _icons *.svgz)
+   foreach (_current_ICON ${_icons} )
+      # since CMake 2.6 regex matches are stored in special variables CMAKE_MATCH_x, if it didn't match, they are empty
+      string(REGEX MATCH "^.*/([a-zA-Z]+)sc\\-([a-z]+)\\-(.+\\.svgz)$" _dummy "${_current_ICON}")
+      set(_type  "${CMAKE_MATCH_1}")
+      set(_group "${CMAKE_MATCH_2}")
+      set(_name  "${CMAKE_MATCH_3}")
+
+      set(_theme_GROUP ${_PHONON_ICON_THEME_${_type}})
+      if( _theme_GROUP)
+          _PHONON_ADD_ICON_INSTALL_RULE(${CMAKE_CURRENT_BINARY_DIR}/install_icons.cmake
+                            ${_defaultpath}/${_theme_GROUP}/scalable
+                            ${_group} ${_current_ICON} ${_name} ${_l10n_SUBDIR})
+      endif( _theme_GROUP)
+   endforeach (_current_ICON)
+
+   phonon_update_iconcache()
+
+endmacro (PHONON_INSTALL_ICONS)
+
diff --git a/src/3rdparty/phonon/ds9/CMakeLists.txt b/src/3rdparty/phonon/ds9/CMakeLists.txt
index 7378b53..1bb6f6f 100644
--- a/src/3rdparty/phonon/ds9/CMakeLists.txt
+++ b/src/3rdparty/phonon/ds9/CMakeLists.txt
@@ -40,15 +40,14 @@ if (BUILD_PHONON_DS9)
 	)
 
     add_definitions(-DPHONON_MAKE_QT_ONLY_BACKEND -DUNICODE)
-    automoc4_add_library(phonon_ds9 MODULE ${phonon_ds9_SRCS})
+    automoc4_add_library(phonon_ds9 SHARED ${phonon_ds9_SRCS})
     set_target_properties(phonon_ds9 PROPERTIES PREFIX "")
     target_link_libraries(phonon_ds9
                 ${PHONON_LIBS}  ${QT_QTOPENGL_LIBRARY} ${OPENGL_gl_LIBRARY}
                 dxguid strmiids dmoguids msdmo ole32 oleaut32 uuid gdi32)
-    # 'MODULE' is treated as a LIBRARY
     install(TARGETS phonon_ds9
 	    RUNTIME DESTINATION ${BIN_INSTALL_DIR}/phonon_backend
-	    LIBRARY DESTINATION ${BIN_INSTALL_DIR}/phonon_backend
+	    LIBRARY DESTINATION ${LIB_INSTALL_DIR}
 	    ARCHIVE DESTINATION ${LIB_INSTALL_DIR})
     install(FILES ds9.desktop DESTINATION ${SERVICES_INSTALL_DIR}/phononbackends)
 endif (BUILD_PHONON_DS9)
diff --git a/src/3rdparty/phonon/ds9/abstractvideorenderer.cpp b/src/3rdparty/phonon/ds9/abstractvideorenderer.cpp
index a9d0694..e932e70 100644
--- a/src/3rdparty/phonon/ds9/abstractvideorenderer.cpp
+++ b/src/3rdparty/phonon/ds9/abstractvideorenderer.cpp
@@ -99,8 +99,8 @@ namespace Phonon
             m_dstX = m_dstY = 0;
 
             if (ratio > 0) {
-                if ((realWidth / realHeight > ratio && scaleMode == Phonon::VideoWidget::FitInView)
-                    || (realWidth / realHeight < ratio && scaleMode == Phonon::VideoWidget::ScaleAndCrop)) {
+                if (realWidth / realHeight > ratio && scaleMode == Phonon::VideoWidget::FitInView
+                    || realWidth / realHeight < ratio && scaleMode == Phonon::VideoWidget::ScaleAndCrop) {
                         //the height is correct, let's change the width
                         m_dstWidth = qRound(realHeight * ratio);
                         m_dstX = qRound((realWidth - realHeight * ratio) / 2.);
diff --git a/src/3rdparty/phonon/ds9/backend.cpp b/src/3rdparty/phonon/ds9/backend.cpp
index fbc4bdc..245749a 100644
--- a/src/3rdparty/phonon/ds9/backend.cpp
+++ b/src/3rdparty/phonon/ds9/backend.cpp
@@ -41,8 +41,6 @@ namespace Phonon
 {
     namespace DS9
     {
-        QMutex *Backend::directShowMutex = 0;
-
         bool Backend::AudioMoniker::operator==(const AudioMoniker &other)
         {
             return other->IsEqual(*this) == S_OK;
@@ -52,9 +50,7 @@ namespace Phonon
         Backend::Backend(QObject *parent, const QVariantList &)
             : QObject(parent)
         {
-            directShowMutex = &m_directShowMutex;
-
-            ::CoInitialize(0);
+			::CoInitialize(0);
 
             //registering meta types
             qRegisterMetaType<HRESULT>("HRESULT");
@@ -65,9 +61,7 @@ namespace Phonon
         {
             m_audioOutputs.clear();
             m_audioEffects.clear();
-            ::CoUninitialize();
-
-            directShowMutex = 0;
+			::CoUninitialize();
         }
 
         QObject *Backend::createObject(BackendInterface::Class c, QObject *parent, const QList<QVariant> &args)
@@ -137,7 +131,6 @@ namespace Phonon
 
         QList<int> Backend::objectDescriptionIndexes(Phonon::ObjectDescriptionType type) const
         {
-            QMutexLocker locker(&m_directShowMutex);
             QList<int> ret;
 
             switch(type)
@@ -164,7 +157,7 @@ namespace Phonon
                     while (S_OK == enumMon->Next(1, mon.pparam(), 0)) {
                         LPOLESTR str = 0;
                         mon->GetDisplayName(0,0,&str);
-                        const QString name = QString::fromWCharArray(str);
+                        const QString name = QString::fromUtf16((unsigned short*)str);
 						ComPointer<IMalloc> alloc;
 						::CoGetMalloc(1, alloc.pparam());
                         alloc->Free(str);
@@ -211,7 +204,6 @@ namespace Phonon
 
         QHash<QByteArray, QVariant> Backend::objectDescriptionProperties(Phonon::ObjectDescriptionType type, int index) const
         {
-            QMutexLocker locker(&m_directShowMutex);
             QHash<QByteArray, QVariant> ret;
             switch (type)
             {
@@ -224,7 +216,7 @@ namespace Phonon
                     LPOLESTR str = 0;
                     HRESULT hr = mon->GetDisplayName(0,0, &str);
                     if (SUCCEEDED(hr)) {
-                        QString name = QString::fromWCharArray(str);
+                        QString name = QString::fromUtf16((unsigned short*)str); 
 						ComPointer<IMalloc> alloc;
 						::CoGetMalloc(1, alloc.pparam());
                         alloc->Free(str);
@@ -239,7 +231,7 @@ namespace Phonon
                     WCHAR name[80]; // 80 is clearly stated in the MSDN doc
                     HRESULT hr = ::DMOGetName(m_audioEffects[index], name);
                     if (SUCCEEDED(hr)) {
-                        ret["name"] = QString::fromWCharArray(name);
+                        ret["name"] = QString::fromUtf16((unsigned short*)name);
                     }
                 }
                 break;
diff --git a/src/3rdparty/phonon/ds9/backend.h b/src/3rdparty/phonon/ds9/backend.h
index 7c3c109..ad638f2 100644
--- a/src/3rdparty/phonon/ds9/backend.h
+++ b/src/3rdparty/phonon/ds9/backend.h
@@ -23,7 +23,6 @@ along with this library.  If not, see <http://www.gnu.org/licenses/>.
 #include <phonon/phononnamespace.h>
 
 #include <QtCore/QList>
-#include <QtCore/QMutex>
 
 #include "compointer.h"
 #include "backendnode.h"
@@ -64,8 +63,6 @@ namespace Phonon
 
             Filter getAudioOutputFilter(int index) const;
 
-            static QMutex *directShowMutex;
-
         Q_SIGNALS:
             void objectDescriptionChanged(ObjectDescriptionType);
 
@@ -77,7 +74,6 @@ namespace Phonon
             };
             mutable QVector<AudioMoniker> m_audioOutputs;
             mutable QVector<CLSID> m_audioEffects;
-            mutable QMutex m_directShowMutex;
         };
     }
 }
diff --git a/src/3rdparty/phonon/ds9/backendnode.cpp b/src/3rdparty/phonon/ds9/backendnode.cpp
index 3afcafa..7e0b3cd 100644
--- a/src/3rdparty/phonon/ds9/backendnode.cpp
+++ b/src/3rdparty/phonon/ds9/backendnode.cpp
@@ -57,25 +57,6 @@ namespace Phonon
 
         BackendNode::~BackendNode()
         {
-            //this will remove the filter from the graph
-            FILTER_INFO info;
-            for(int i = 0; i < FILTER_COUNT; ++i) {
-                const Filter &filter = m_filters[i];
-                if (!filter)
-                    continue;
-                filter->QueryFilterInfo(&info);
-                if (info.pGraph) {
-                    HRESULT hr = info.pGraph->RemoveFilter(filter);
-
-                    if (hr == VFW_E_NOT_STOPPED && m_mediaObject) {
-                        m_mediaObject->ensureStopped();
-
-                        hr = info.pGraph->RemoveFilter(filter);
-                    }
-                    Q_ASSERT(SUCCEEDED(hr));
-                    info.pGraph->Release();
-                }
-            }
         }
 
         void BackendNode::setMediaObject(MediaObject *mo)
diff --git a/src/3rdparty/phonon/ds9/ds9.desktop b/src/3rdparty/phonon/ds9/ds9.desktop
index 764390e..91877a7 100644
--- a/src/3rdparty/phonon/ds9/ds9.desktop
+++ b/src/3rdparty/phonon/ds9/ds9.desktop
@@ -5,12 +5,13 @@ MimeType=application/x-annodex;video/quicktime;video/x-quicktime;audio/x-m4a;app
 X-KDE-Library=phonon_ds9
 X-KDE-PhononBackendInfo-InterfaceVersion=1
 X-KDE-PhononBackendInfo-Version=0.1
-X-KDE-PhononBackendInfo-Website=http://qt.nokia.com/
+X-KDE-PhononBackendInfo-Website=http://www.trolltech.com/
 InitialPreference=15
 
 Name=DirectShow9
 Name[bg]=DirectShow9
 Name[ca]=DirectShow9
+Name[ca@valencia]=DirectShow9
 Name[cs]=DirectShow9
 Name[da]=DirectShow9
 Name[de]=DirectShow9
@@ -19,11 +20,14 @@ Name[en_GB]=DirectShow9
 Name[es]=DirectShow9
 Name[et]=DirectShow9
 Name[eu]=DirectShow9
+Name[fi]=DirectShow9
 Name[fr]=DirectShow9
 Name[ga]=DirectShow9
 Name[gl]=DirectShow9
+Name[hr]=DirectShow9
 Name[hsb]=DirectShow9
 Name[hu]=DirectShow9
+Name[id]=DirectShow9
 Name[is]=DirectShow9
 Name[it]=DirectShow9
 Name[ja]=DirectShow9
@@ -31,6 +35,7 @@ Name[ko]=DirectShow9
 Name[ku]=DirectShow9
 Name[lt]=DirectShow9
 Name[lv]=DirectShow9
+Name[nb]=DirectShow9
 Name[nds]=DirectShow9
 Name[nl]=DirectShow9
 Name[nn]=DirectShow9
@@ -38,41 +43,41 @@ Name[pa]=ਡਾਇਰੈਕਸ਼ੋ9
 Name[pl]=DirectShow9
 Name[pt]=DirectShow9
 Name[pt_BR]=DirectShow9
+Name[ru]=DirectShow9
 Name[se]=DirectShow9
 Name[sk]=DirectShow 9
 Name[sl]=DirectShow 9
 Name[sr]=Директшоу‑9
+Name[sr@ijekavian]=Директшоу‑9
+Name[sr@ijekavianlatin]=DirectShow‑9
 Name[sr@latin]=DirectShow‑9
 Name[sv]=Directshow 9
-Name[tr]=DirectShow9
-Name[uk]=DirectShow9
 Name[x-test]=xxDirectShow9xx
-Name[zh_CN]=DirectShow9
-Name[zh_TW]=DirectShow9
 
 Comment=Phonon DirectShow9 backend
 Comment[bg]=Phonon DirectShow9
 Comment[ca]=Dorsal DirectShow9 del Phonon
+Comment[ca@valencia]=Dorsal DirectShow9 del Phonon
 Comment[cs]=Phonon DirectShow9 backend
 Comment[da]=DirectShow9-backend til Phonon
 Comment[de]=Phonon-Treiber für DirectShow9
 Comment[el]=Σύστημα υποστήριξης DirectShow9 του Phonon
-Comment[en_GB]=Phonon DirectShow9 backend
 Comment[es]=Motor DirectShow9 para Phonon
 Comment[et]=Phononi DirectShow9 taustaprogramm
 Comment[eu]=Phonon DirectShow9 backend
+Comment[fi]=Phonon DirectShow9-taustaohjelma
 Comment[fr]=Système de gestion DirectShow9 pour Phonon 
 Comment[ga]=Inneall DirectShow9 le haghaidh Phonon
 Comment[gl]=Infraestrutura de DirectShow9 para Phonon
 Comment[hsb]=Phonon DirectShow9 backend
 Comment[hu]=Phonon DirectShow9 modul
+Comment[id]=Phonon DirectShow9 backend
 Comment[is]=Phonon DirectShow9 bakendi
 Comment[it]=Motore DirectShow9 di Phonon
 Comment[ja]=Phonon DirectShow9 バックエンド
 Comment[ko]=Phonon DirectShow9 백엔드
-Comment[ku]=Binesaza Phonon DirectShow9
-Comment[lt]=Phonon DirectShow9 galinė sąsaja
 Comment[lv]=Phonon DirectShow9 aizmugure
+Comment[nb]=Phonon-motor for DirectShow9
 Comment[nds]=Phonon-Hülpprogrmm DirectShow9
 Comment[nl]=DirectShow9-backend (Phonon)
 Comment[nn]=Phonon-motor for DirectShow9
@@ -80,10 +85,13 @@ Comment[pa]=ਫੋਨੋਨ ਡਾਇਰੈਕਟਸ਼ੋ9 ਬੈਕਐਂਡ
 Comment[pl]=Obsługa DirectShow9 przez Phonon
 Comment[pt]=Infra-estrutura do DirectShow9 para o Phonon
 Comment[pt_BR]=Infraestrutura Phonon DirectShow9
+Comment[ru]=Механизм DirectShow9 для Phonon
 Comment[se]=Phonon DirectShow9 duogášmohtor
 Comment[sk]=Phonon DirectShow 9 podsystém
 Comment[sl]=Phononova Hrbtenica DirectShow 9
 Comment[sr]=Директшоу‑9 као позадина Фонона
+Comment[sr@ijekavian]=Директшоу‑9 као позадина Фонона
+Comment[sr@ijekavianlatin]=DirectShow‑9 kao pozadina Phonona
 Comment[sr@latin]=DirectShow‑9 kao pozadina Phonona
 Comment[sv]=Phonon Directshow 9-gränssnitt
 Comment[tr]=Phonon DirectShow9 arka ucu
diff --git a/src/3rdparty/phonon/ds9/effect.cpp b/src/3rdparty/phonon/ds9/effect.cpp
index ebe976b..dc4ac3d 100644
--- a/src/3rdparty/phonon/ds9/effect.cpp
+++ b/src/3rdparty/phonon/ds9/effect.cpp
@@ -82,7 +82,7 @@ namespace Phonon
                         current += wcslen(current) + 1; //skip the name
                         current += wcslen(current) + 1; //skip the unit
                         for(; *current; current += wcslen(current) + 1) {
-                            values.append( QString::fromWCharArray(current) );
+                            values.append( QString::fromUtf16((unsigned short*)current) );
                         }
                     }
                     //FALLTHROUGH
@@ -107,7 +107,7 @@ namespace Phonon
                 Phonon::EffectParameter::Hints hint = info.mopCaps == MP_CAPS_CURVE_INVSQUARE ?
                     Phonon::EffectParameter::LogarithmicHint : Phonon::EffectParameter::Hints(0);
 
-                const QString n = QString::fromWCharArray(name);
+                const QString n = QString::fromUtf16((unsigned short*)name);
                 ret.append(Phonon::EffectParameter(i, n, hint, def, min, max, values));
                 ::CoTaskMemFree(name); //let's free the memory
             }
@@ -138,7 +138,8 @@ namespace Phonon
                 ComPointer<IMediaParams> params(filter, IID_IMediaParams);
                 Q_ASSERT(params);
 
-                params->SetParam(p.id(), v.toFloat());
+                MP_DATA data = float(v.toDouble());
+                params->SetParam(p.id(), data);
             }
         }
 
diff --git a/src/3rdparty/phonon/ds9/fakesource.cpp b/src/3rdparty/phonon/ds9/fakesource.cpp
index 4dce138..9a61a2e 100644
--- a/src/3rdparty/phonon/ds9/fakesource.cpp
+++ b/src/3rdparty/phonon/ds9/fakesource.cpp
@@ -29,10 +29,8 @@ namespace Phonon
     namespace DS9
     {
         static WAVEFORMATEX g_defaultWaveFormat = {WAVE_FORMAT_PCM, 2, 44100, 176400, 4, 16, 0};
-        static VIDEOINFOHEADER2 g_defaultVideoInfo = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, 0, 0, 0, 0, 0, 0, 0, {0}, 0, {sizeof(BITMAPINFOHEADER), 1, 1, 1, 0, 0, 0, 0, 0, 0, 0} };
-
-        static const AM_MEDIA_TYPE g_fakeAudioType = {MEDIATYPE_Audio, MEDIASUBTYPE_PCM, 0, 0, 2, FORMAT_WaveFormatEx, 0, sizeof(WAVEFORMATEX), reinterpret_cast<BYTE*>(&g_defaultWaveFormat)};
-        static const AM_MEDIA_TYPE g_fakeVideoType = {MEDIATYPE_Video, MEDIASUBTYPE_RGB32, TRUE, FALSE, 0, FORMAT_VideoInfo2, 0, sizeof(VIDEOINFOHEADER2), reinterpret_cast<BYTE*>(&g_defaultVideoInfo)};
+        static BITMAPINFOHEADER g_defautBitmapHeader = { sizeof(BITMAPINFOHEADER), 1, 1, 1, 0, 0, 0, 0, 0, 0, 0};
+        static VIDEOINFOHEADER2 g_defaultVideoInfo = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 
         class FakePin : public QPin
         {
@@ -130,12 +128,36 @@ namespace Phonon
 
         void FakeSource::createFakeAudioPin()
         {
-            new FakePin(this, g_fakeAudioType);
+            AM_MEDIA_TYPE mt;
+            qMemSet(&mt, 0, sizeof(AM_MEDIA_TYPE));
+            mt.majortype = MEDIATYPE_Audio;
+            mt.subtype = MEDIASUBTYPE_PCM;
+            mt.formattype = FORMAT_WaveFormatEx;
+            mt.lSampleSize = 2;
+
+            //fake the format (stereo 44.1 khz stereo 16 bits)
+            mt.cbFormat = sizeof(WAVEFORMATEX);
+            mt.pbFormat = reinterpret_cast<BYTE*>(&g_defaultWaveFormat);
+
+            new FakePin(this, mt);
         }
 
         void FakeSource::createFakeVideoPin()
         {
-            new FakePin(this, g_fakeVideoType);
+            AM_MEDIA_TYPE mt;
+            qMemSet(&mt, 0, sizeof(AM_MEDIA_TYPE));
+            mt.majortype = MEDIATYPE_Video;
+            mt.subtype = MEDIASUBTYPE_RGB32;
+            mt.formattype = FORMAT_VideoInfo2;
+            mt.bFixedSizeSamples = 1;
+
+            g_defaultVideoInfo.bmiHeader = g_defautBitmapHeader;
+
+            //fake the format
+            mt.cbFormat = sizeof(VIDEOINFOHEADER2);
+            mt.pbFormat = reinterpret_cast<BYTE*>(&g_defaultVideoInfo);
+
+            new FakePin(this, mt);
         }
 
     }
diff --git a/src/3rdparty/phonon/ds9/iodevicereader.cpp b/src/3rdparty/phonon/ds9/iodevicereader.cpp
index 695af59..ec10278 100644
--- a/src/3rdparty/phonon/ds9/iodevicereader.cpp
+++ b/src/3rdparty/phonon/ds9/iodevicereader.cpp
@@ -36,20 +36,26 @@ namespace Phonon
         //these mediatypes define a stream, its type will be autodetected by DirectShow
         static QVector<AM_MEDIA_TYPE> getMediaTypes()
         {
-            //the order here is important because otherwise,
-            //directshow might not be able to detect the stream type correctly
-
-            AM_MEDIA_TYPE mt = { MEDIATYPE_Stream, MEDIASUBTYPE_Avi, TRUE, FALSE, 1, GUID_NULL, 0, 0, 0};
+            AM_MEDIA_TYPE mt;
+            mt.majortype = MEDIATYPE_Stream;
+            mt.bFixedSizeSamples = TRUE;
+            mt.bTemporalCompression = FALSE;
+            mt.lSampleSize = 1;
+            mt.formattype = GUID_NULL;
+            mt.pUnk = 0;
+            mt.cbFormat = 0;
+            mt.pbFormat = 0;
 
             QVector<AM_MEDIA_TYPE> ret;
+            //normal auto-detect stream
+            mt.subtype = MEDIASUBTYPE_NULL;
+            ret << mt;
             //AVI stream
+            mt.subtype = MEDIASUBTYPE_Avi;
             ret << mt;
             //WAVE stream
             mt.subtype = MEDIASUBTYPE_WAVE;
             ret << mt;
-            //normal auto-detect stream (must be at the end!)
-            mt.subtype = MEDIASUBTYPE_NULL;
-            ret << mt;
             return ret;
         }
 
@@ -66,6 +72,7 @@ namespace Phonon
               //for Phonon::StreamInterface
               void writeData(const QByteArray &data)
               {
+                  QWriteLocker locker(&m_lock);
                   m_pos += data.size();
                   m_buffer += data;
               }
@@ -76,22 +83,54 @@ namespace Phonon
 
               void setStreamSize(qint64 newSize)
               {
-                  QMutexLocker locker(&m_mutex);
+                  QWriteLocker locker(&m_lock);
                   m_size = newSize;
               }
 
+              qint64 streamSize() const
+              {
+                  QReadLocker locker(&m_lock);
+                  return m_size;
+              }
+
               void setStreamSeekable(bool s)
               {
-                  QMutexLocker locker(&m_mutex);
+                  QWriteLocker locker(&m_lock);
                   m_seekable = s;
               }
 
+              bool streamSeekable() const
+              {
+                  QReadLocker locker(&m_lock);
+                  return m_seekable;
+              }
+
+              void setCurrentPos(qint64 pos)
+              {
+                  QWriteLocker locker(&m_lock);
+                  m_pos = pos;
+                  seekStream(pos);
+                  m_buffer.clear();
+              }
+
+              qint64 currentPos() const
+              {
+                  QReadLocker locker(&m_lock);
+                  return m_pos;
+              }
+
+              int currentBufferSize() const
+              {
+                  QReadLocker locker(&m_lock);
+                  return m_buffer.size();
+              }
+
               //virtual pure members
 
               //implementation from IAsyncReader
               STDMETHODIMP Length(LONGLONG *total, LONGLONG *available)
               {
-                  QMutexLocker locker(&m_mutex);
+                  QReadLocker locker(&m_lock);
                   if (total) {
                       *total = m_size;
                   }
@@ -106,42 +145,44 @@ namespace Phonon
 
               HRESULT read(LONGLONG pos, LONG length, BYTE *buffer, LONG *actual)
               {
-                  Q_ASSERT(!m_mutex.tryLock());
+                  QMutexLocker locker(&m_mutexRead);
+
                   if (m_mediaGraph->isStopping()) {
                       return VFW_E_WRONG_STATE;
                   }
 
-                  if(m_size != 1 && pos + length > m_size) {
+                  if(streamSize() != 1 && pos + length > streamSize()) {
                       //it tries to read outside of the boundaries
                       return E_FAIL;
                   }
 
-                  if (m_pos - m_buffer.size() != pos) {
-                      if (!m_seekable) {
+                  if (currentPos() - currentBufferSize() != pos) {
+                      if (!streamSeekable()) {
                           return S_FALSE;
                       }
-                      m_pos = pos;
-                      seekStream(pos);
-                      m_buffer.clear();
+                      setCurrentPos(pos);
                   }
 
-                  int oldSize = m_buffer.size();
-                  while (m_buffer.size() < int(length)) {
+                  int oldSize = currentBufferSize();
+                  while (currentBufferSize() < int(length)) {
                       needData();
                       if (m_mediaGraph->isStopping()) {
                           return VFW_E_WRONG_STATE;
                       }
 
-                      if (oldSize == m_buffer.size()) {
+                      if (oldSize == currentBufferSize()) {
                           break; //we didn't get any data
                       }
-                      oldSize = m_buffer.size();
+                      oldSize = currentBufferSize();
                   }
 
-                  int bytesRead = qMin(m_buffer.size(), int(length));
-                  qMemCopy(buffer, m_buffer.data(), bytesRead);
-                  //truncate the buffer
-                  m_buffer = m_buffer.mid(bytesRead);
+                  DWORD bytesRead = qMin(currentBufferSize(), int(length));
+                  {
+                      QWriteLocker locker(&m_lock);
+                      qMemCopy(buffer, m_buffer.data(), bytesRead);
+                      //truncate the buffer
+                      m_buffer = m_buffer.mid(bytesRead);
+                  }
 
                   if (actual) {
                       *actual = bytesRead; //initialization
@@ -157,6 +198,7 @@ namespace Phonon
             qint64 m_pos;
             qint64 m_size;
 
+            QMutex m_mutexRead;
             const MediaGraph *m_mediaGraph;
         };
 
@@ -170,6 +212,14 @@ namespace Phonon
         IODeviceReader::~IODeviceReader()
         {
         }
+
+        STDMETHODIMP IODeviceReader::Stop()
+        {
+            HRESULT hr = QBaseFilter::Stop();
+            m_streamReader->enoughData(); //this asks to cancel any blocked call to needData
+            return hr;
+        }
+
     }
 }
 
diff --git a/src/3rdparty/phonon/ds9/iodevicereader.h b/src/3rdparty/phonon/ds9/iodevicereader.h
index c8b91c3..af4b271 100644
--- a/src/3rdparty/phonon/ds9/iodevicereader.h
+++ b/src/3rdparty/phonon/ds9/iodevicereader.h
@@ -41,6 +41,7 @@ namespace Phonon
         public:
             IODeviceReader(const MediaSource &source, const MediaGraph *);
             ~IODeviceReader();
+            STDMETHODIMP Stop();
 
         private:
             StreamReader *m_streamReader;
diff --git a/src/3rdparty/phonon/ds9/mediagraph.cpp b/src/3rdparty/phonon/ds9/mediagraph.cpp
index a467dd7..db0ec84 100644
--- a/src/3rdparty/phonon/ds9/mediagraph.cpp
+++ b/src/3rdparty/phonon/ds9/mediagraph.cpp
@@ -68,8 +68,6 @@ namespace Phonon
             return ret;
         }
                 
-
-/*
         static HRESULT saveToFile(Graph graph, const QString &filepath)
         {
             const WCHAR wszStreamName[] = L"ActiveMovieGraph";
@@ -105,7 +103,7 @@ namespace Phonon
 
             return hr;
         }
-*/
+
 
         MediaGraph::MediaGraph(MediaObject *mo, short index) :
             m_graph(CLSID_FilterGraph, IID_IGraphBuilder),
@@ -383,8 +381,7 @@ namespace Phonon
 #endif
             if (info.pGraph) {
                 info.pGraph->Release();
-                if (info.pGraph == m_graph)
-                    return m_graph->RemoveFilter(filter);
+                return m_graph->RemoveFilter(filter);
             }
 
             //already removed
@@ -540,11 +537,11 @@ namespace Phonon
                     const QList<OutputPin> outputs = BackendNode::pins(filter, PINDIR_OUTPUT);
                     for(int i = 0; i < outputs.count(); ++i) {
                         const OutputPin &pin = outputs.at(i);
-                        if (HRESULT(VFW_E_NOT_CONNECTED) == pin->ConnectedTo(inPin.pparam())) {
+                        if (VFW_E_NOT_CONNECTED == pin->ConnectedTo(inPin.pparam())) {
                             return SUCCEEDED(pin->Connect(newIn, 0));
                         }
                     }
-                    //we shoud never go here
+                    //we should never go here
                     return false;
                 } else {
                     QAMMediaType type;
@@ -682,6 +679,7 @@ namespace Phonon
  #ifndef QT_NO_PHONON_MEDIACONTROLLER
                } else if (source.discType() == Phonon::Cd) {
                     m_realSource = Filter(new QAudioCDPlayer);
+                    m_result = m_graph->AddFilter(m_realSource, 0);
 
 #endif //QT_NO_PHONON_MEDIACONTROLLER
                 } else {
@@ -811,7 +809,7 @@ namespace Phonon
                 for (int i = 0; i < outputs.count(); ++i) {
                     const OutputPin &out = outputs.at(i);
                     InputPin pin;
-                    if (out->ConnectedTo(pin.pparam()) == HRESULT(VFW_E_NOT_CONNECTED)) {
+                    if (out->ConnectedTo(pin.pparam()) == VFW_E_NOT_CONNECTED) {
                         m_decoderPins += out; //unconnected outputs can be decoded outputs
                     }
                 }
@@ -822,7 +820,7 @@ namespace Phonon
             //let's reestablish the connections
             for (int i = 0; i < connections.count(); ++i) {
                 const GraphConnection &connection = connections.at(i);
-                //check if we shoud transfer the sink node
+                //check if we should transfer the sink node
 
                 grabFilter(connection.input);
                 grabFilter(connection.output);
@@ -1008,27 +1006,27 @@ namespace Phonon
                 BSTR str;
                 HRESULT hr = mediaContent->get_AuthorName(&str);
                 if (SUCCEEDED(hr)) {
-                    ret.insert(QLatin1String("ARTIST"), QString::fromWCharArray(str));
+                    ret.insert(QLatin1String("ARTIST"), QString::fromUtf16((const unsigned short*)str));
                     SysFreeString(str);
                 }
                 hr = mediaContent->get_Title(&str);
                 if (SUCCEEDED(hr)) {
-                    ret.insert(QLatin1String("TITLE"), QString::fromWCharArray(str));
+                    ret.insert(QLatin1String("TITLE"), QString::fromUtf16((const unsigned short*)str));
                     SysFreeString(str);
                 }
                 hr = mediaContent->get_Description(&str);
                 if (SUCCEEDED(hr)) {
-                    ret.insert(QLatin1String("DESCRIPTION"), QString::fromWCharArray(str));
+                    ret.insert(QLatin1String("DESCRIPTION"), QString::fromUtf16((const unsigned short*)str));
                     SysFreeString(str);
                 }
                 hr = mediaContent->get_Copyright(&str);
                 if (SUCCEEDED(hr)) {
-                    ret.insert(QLatin1String("COPYRIGHT"), QString::fromWCharArray(str));
+                    ret.insert(QLatin1String("COPYRIGHT"), QString::fromUtf16((const unsigned short*)str));
                     SysFreeString(str);
                 }
                 hr = mediaContent->get_MoreInfoText(&str);
                 if (SUCCEEDED(hr)) {
-                    ret.insert(QLatin1String("MOREINFO"), QString::fromWCharArray(str));
+                    ret.insert(QLatin1String("MOREINFO"), QString::fromUtf16((const unsigned short*)str));
                     SysFreeString(str);
                 }
             }
diff --git a/src/3rdparty/phonon/ds9/mediaobject.cpp b/src/3rdparty/phonon/ds9/mediaobject.cpp
index 34f92c2..2867daa 100644
--- a/src/3rdparty/phonon/ds9/mediaobject.cpp
+++ b/src/3rdparty/phonon/ds9/mediaobject.cpp
@@ -23,10 +23,11 @@ along with this library.  If not, see <http://www.gnu.org/licenses/>.
 
 #ifndef Q_CC_MSVC
 #include <dshow.h>
-#endif
+#endif //Q_CC_MSVC
 #include <objbase.h>
 #include <initguid.h>
 #include <qnetwork.h>
+#include <comdef.h>
 #include <evcode.h>
 
 #include "mediaobject.h"
@@ -36,7 +37,7 @@ along with this library.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <QtCore/QDebug>
 
-#define TIMER_INTERVAL 16 //... ms for the timer that polls the current state (we use the multimedia timer)
+#define TIMER_INTERVAL 16 //... ms for the timer that polls the current state (we use the multimedia timer
 #define PRELOAD_TIME 2000 // 2 seconds to load a source
 
 QT_BEGIN_NAMESPACE
@@ -49,7 +50,7 @@ namespace Phonon
 
         //first the definition of the WorkerThread class
         WorkerThread::WorkerThread()
-          : QThread(), m_finished(false), m_currentWorkId(1)
+          : QThread(), m_currentRenderId(0), m_finished(false), m_currentWorkId(1)
         {
         }
 
@@ -57,6 +58,24 @@ namespace Phonon
         {
         }
 
+        WorkerThread::Work WorkerThread::dequeueWork()
+        {
+            QMutexLocker locker(&m_mutex);
+            if (m_finished) {
+                return Work();
+            }
+            Work ret = m_queue.dequeue();
+
+            //we ensure to have the wait condition in the right state
+            if (m_queue.isEmpty()) {
+                m_waitCondition.reset();
+            } else {
+                m_waitCondition.set();
+            }
+
+            return ret;
+        }
+
         void WorkerThread::run()
         {
             while (m_finished == false) {
@@ -70,6 +89,11 @@ namespace Phonon
                 }
                 DWORD result = ::WaitForMultipleObjects(count, handles, FALSE, INFINITE);
                 if (result == WAIT_OBJECT_0) {
+                    if (m_finished) {
+                        //that's the end if the thread execution
+                        return;
+                    }
+
                     handleTask();
                 } else {
                     //this is the event management
@@ -157,7 +181,6 @@ namespace Phonon
             //we create a new graph
             w.graph = Graph(CLSID_FilterGraph, IID_IGraphBuilder);
             w.filter = filter;
-            w.graph->AddFilter(filter, 0);
             w.id = m_currentWorkId++;
             m_queue.enqueue(w);
             m_waitCondition.set();
@@ -177,29 +200,23 @@ namespace Phonon
 
         void WorkerThread::handleTask()
         {
-            QMutexLocker locker(Backend::directShowMutex);
-            {
-                QMutexLocker locker(&m_mutex);
-                if (m_finished || m_queue.isEmpty()) {
-                    return;
-                }
-
-                m_currentWork = m_queue.dequeue();
+            const Work w = dequeueWork();
 
-                //we ensure to have the wait condition in the right state
-                if (m_queue.isEmpty()) {
-                    m_waitCondition.reset();
-                } else {
-                    m_waitCondition.set();
-                }
+            if (m_finished) {
+                return;
             }
 
             HRESULT hr = S_OK;
 
-            if (m_currentWork.task == ReplaceGraph) {
+            m_currentRender = w.graph;
+			m_currentRenderId = w.id;
+            if (w.task == ReplaceGraph) {
+                QMutexLocker locker(&m_mutex);
+                HANDLE h;
+
                 int index = -1;
                 for(int i = 0; i < FILTER_COUNT; ++i) {
-                    if (m_graphHandle[i].graph == m_currentWork.oldGraph) {
+                    if (m_graphHandle[i].graph == w.oldGraph) {
                         m_graphHandle[i].graph = Graph();
                         index = i;
                         break;
@@ -212,40 +229,51 @@ namespace Phonon
                 Q_ASSERT(index != -1);
 
                 //add the new graph
-                HANDLE h;
-                if (SUCCEEDED(ComPointer<IMediaEvent>(m_currentWork.graph, IID_IMediaEvent)
+                if (SUCCEEDED(ComPointer<IMediaEvent>(w.graph, IID_IMediaEvent)
                     ->GetEventHandle(reinterpret_cast<OAEVENT*>(&h)))) {
-                    m_graphHandle[index].graph = m_currentWork.graph;
+                    m_graphHandle[index].graph = w.graph;
                     m_graphHandle[index].handle = h;
                 }
-            } else if (m_currentWork.task == Render) {
-                if (m_currentWork.filter) {
+            } else if (w.task == Render) {
+                if (w.filter) {
                     //let's render pins
-                    const QList<OutputPin> outputs = BackendNode::pins(m_currentWork.filter, PINDIR_OUTPUT);
-                    for (int i = 0; SUCCEEDED(hr) && i < outputs.count(); ++i) {
-                        hr = m_currentWork.graph->Render(outputs.at(i));
+                    w.graph->AddFilter(w.filter, 0);
+                    const QList<OutputPin> outputs = BackendNode::pins(w.filter, PINDIR_OUTPUT);
+                    for (int i = 0; i < outputs.count(); ++i) {
+                        //blocking call
+                        hr = w.graph->Render(outputs.at(i));
+                        if (FAILED(hr)) {
+                            break;
+                        }
                     }
-                } else if (!m_currentWork.url.isEmpty()) {
+                } else if (!w.url.isEmpty()) {
                     //let's render a url (blocking call)
-                    hr = m_currentWork.graph->RenderFile(reinterpret_cast<const wchar_t *>(m_currentWork.url.utf16()), 0);
+                    hr = w.graph->RenderFile(reinterpret_cast<const wchar_t *>(w.url.utf16()), 0);
                 }
                 if (hr != E_ABORT) {
-                    emit asyncRenderFinished(m_currentWork.id, hr, m_currentWork.graph);
+					emit asyncRenderFinished(w.id, hr, w.graph);
                 }
-            } else if (m_currentWork.task == Seek) {
+            } else if (w.task == Seek) {
                 //that's a seekrequest
-                ComPointer<IMediaSeeking> mediaSeeking(m_currentWork.graph, IID_IMediaSeeking);
-                qint64 newtime = m_currentWork.time * 10000;
+                ComPointer<IMediaSeeking> mediaSeeking(w.graph, IID_IMediaSeeking);
+                qint64 newtime = w.time * 10000;
                 hr = mediaSeeking->SetPositions(&newtime, AM_SEEKING_AbsolutePositioning,
                     0, AM_SEEKING_NoPositioning);
-                emit asyncSeekingFinished(m_currentWork.id, newtime / 10000);
-                hr = E_ABORT; //to avoid emitting asyncRenderFinished
-            } else if (m_currentWork.task == ChangeState) {
+                qint64 currentTime = -1;
+                if (SUCCEEDED(hr)) {
+                    hr = mediaSeeking->GetCurrentPosition(&currentTime);
+                    if (SUCCEEDED(hr)) {
+                        currentTime /= 10000; //convert to ms
+                    }
+                }
+                emit asyncSeekingFinished(w.id, currentTime);
+                hr = E_ABORT; //to avoid emitting asyncRenderFinished 
+            } else if (w.task == ChangeState) {
 
                 //remove useless decoders
                 QList<Filter> unused;
-                for (int i = 0; i < m_currentWork.decoders.count(); ++i) {
-                    const Filter &filter = m_currentWork.decoders.at(i);
+                for (int i = 0; i < w.decoders.count(); ++i) {
+                    const Filter &filter = w.decoders.at(i);
                     bool used = false;
                     const QList<OutputPin> pins = BackendNode::pins(filter, PINDIR_OUTPUT);
                     for( int i = 0; i < pins.count(); ++i) {
@@ -262,15 +290,15 @@ namespace Phonon
                 //we can get the state
                 for (int i = 0; i < unused.count(); ++i) {
                     //we should remove this filter from the graph
-                    m_currentWork.graph->RemoveFilter(unused.at(i));
+                    w.graph->RemoveFilter(unused.at(i));
                 }
 
 
                 //we can get the state
-                ComPointer<IMediaControl> mc(m_currentWork.graph, IID_IMediaControl);
+                ComPointer<IMediaControl> mc(w.graph, IID_IMediaControl);
 
                 //we change the state here
-                switch(m_currentWork.state)
+                switch(w.state)
                 {
                 case State_Stopped:
                     mc->Stop();
@@ -288,48 +316,46 @@ namespace Phonon
 
                 if (SUCCEEDED(hr)) {
                     if (s == State_Stopped) {
-                        emit stateReady(m_currentWork.graph, Phonon::StoppedState);
+                        emit stateReady(w.graph, Phonon::StoppedState);
                     } else if (s == State_Paused) {
-                        emit stateReady(m_currentWork.graph, Phonon::PausedState);
+                        emit stateReady(w.graph, Phonon::PausedState);
                     } else /*if (s == State_Running)*/ {
-                        emit stateReady(m_currentWork.graph, Phonon::PlayingState);
+                        emit stateReady(w.graph, Phonon::PlayingState);
                     }
                 }
             }
 
-            {
-                QMutexLocker locker(&m_mutex);
-                m_currentWork = Work(); //reinitialize
-            }
+            m_currentRender = Graph();
+			m_currentRenderId = 0;
+
         }
 
-        void WorkerThread::abortCurrentRender(qint16 renderId)
-        {
+		void WorkerThread::abortCurrentRender(qint16 renderId)
+		{
             QMutexLocker locker(&m_mutex);
-            if (m_currentWork.id == renderId) {
-                m_currentWork.graph->Abort();
-            }
             bool found = false;
+            //we try to see if there is already an attempt to seek and we remove it
             for(int i = 0; !found && i < m_queue.size(); ++i) {
                 const Work &w = m_queue.at(i);
                 if (w.id == renderId) {
                     found = true;
                     m_queue.removeAt(i);
-                    if (m_queue.isEmpty()) {
-                        m_waitCondition.reset();
-                    }
                 }
             }
-        }
+
+			if (m_currentRender && m_currentRenderId == renderId) {
+				m_currentRender->Abort();
+			}
+		}
 
         //tells the thread to stop processing
         void WorkerThread::signalStop()
         {
             QMutexLocker locker(&m_mutex);
             m_queue.clear();
-            if (m_currentWork.graph) {
+            if (m_currentRender) {
                 //in case we're currently rendering something
-                m_currentWork.graph->Abort();
+                m_currentRender->Abort();
 
             }
 
@@ -358,20 +384,20 @@ namespace Phonon
         {
 
             for(int i = 0; i < FILTER_COUNT; ++i) {
-                m_graphs[i] = new MediaGraph(this, i);
+                m_graphs[i] = new MediaGraph(this, i);                
             }
 
-            connect(&m_thread, SIGNAL(stateReady(Graph,Phonon::State)),
-                               SLOT(slotStateReady(Graph,Phonon::State)));
+            connect(&m_thread, SIGNAL(stateReady(Graph, Phonon::State)), 
+                               SLOT(slotStateReady(Graph, Phonon::State)));
 
-            connect(&m_thread, SIGNAL(eventReady(Graph,long,long)),
-                               SLOT(handleEvents(Graph,long,long)));
+            connect(&m_thread, SIGNAL(eventReady(Graph, long, long)), 
+                               SLOT(handleEvents(Graph, long, long)));
 
-            connect(&m_thread, SIGNAL(asyncRenderFinished(quint16,HRESULT,Graph)),
-                SLOT(finishLoading(quint16,HRESULT,Graph)));
+            connect(&m_thread, SIGNAL(asyncRenderFinished(quint16, HRESULT, Graph)),
+                SLOT(finishLoading(quint16, HRESULT, Graph)));
 
-            connect(&m_thread, SIGNAL(asyncSeekingFinished(quint16,qint64)),
-                SLOT(finishSeeking(quint16,qint64)));
+            connect(&m_thread, SIGNAL(asyncSeekingFinished(quint16, qint64)),
+                SLOT(finishSeeking(quint16, qint64)));
             //really special case
             m_mediaObject = this;
             m_thread.start();
@@ -459,7 +485,7 @@ namespace Phonon
                     }
 
                     if (!m_aboutToFinishSent && remaining < PRELOAD_TIME - m_transitionTime  + TIMER_INTERVAL/2) {
-                        //let's take a 2 seconds time to actually load the next file
+                        //let's take a 2 seconds time time to actually load the next file
 #ifdef GRAPH_DEBUG
                         qDebug() << "DS9: emit aboutToFinish" << remaining << QTime::currentTime().toString();
 #endif
@@ -494,18 +520,6 @@ namespace Phonon
 
             qSwap(m_graphs[0], m_graphs[1]); //swap the graphs
 
-            if (m_transitionTime >= 0)
-                m_graphs[1]->stop(); //make sure we stop the previous graph
-
-            if (currentGraph()->mediaSource().type() != Phonon::MediaSource::Invalid &&
-                catchComError(currentGraph()->renderResult())) {
-                    setState(Phonon::ErrorState);
-                    return;
-            }
-
-            //we need to play the next media
-            play();
-
             //we tell the video widgets to switch now to the new source
 #ifndef QT_NO_PHONON_VIDEO
             for (int i = 0; i < m_videoWidgets.count(); ++i) {
@@ -514,6 +528,15 @@ namespace Phonon
 #endif //QT_NO_PHONON_VIDEO
 
             emit currentSourceChanged(currentGraph()->mediaSource());
+
+            if (currentGraph()->isLoading()) {
+                //will simply tell that when loading is finished 
+                //it should start the playback
+                play(); 
+            }
+
+
+
             emit metaDataChanged(currentGraph()->metadata());
 
             if (nextGraph()->hasVideo() != currentGraph()->hasVideo()) {
@@ -526,6 +549,15 @@ namespace Phonon
 #ifndef QT_NO_PHONON_MEDIACONTROLLER
             setTitles(currentGraph()->titles());
 #endif //QT_NO_PHONON_MEDIACONTROLLER
+
+            //this manages only gapless transitions
+            if (currentGraph()->mediaSource().type() != Phonon::MediaSource::Invalid) {
+                if (catchComError(currentGraph()->renderResult())) {
+                    setState(Phonon::ErrorState);
+                } else {
+                    play();
+                }
+            }
         }
 
         Phonon::State MediaObject::state() const
@@ -551,7 +583,7 @@ namespace Phonon
         {
 #ifndef QT_NO_PHONON_MEDIACONTROLLER
             //1st, check if there is more titles after
-            const qint64 ret = (m_currentTitle < _iface_availableTitles() - 1) ?
+            const qint64 ret = (m_currentTitle < _iface_availableTitles() - 1) ? 
                 titleAbsolutePosition(m_currentTitle+1) : currentGraph()->absoluteTotalTime();
 
             //this is the duration of the current title
@@ -564,7 +596,7 @@ namespace Phonon
         qint64 MediaObject::currentTime() const
         {
             //this handles inaccuracy when stopping on a title
-            return currentGraph()->absoluteCurrentTime()
+            return currentGraph()->absoluteCurrentTime() 
 #ifndef QT_NO_PHONON_MEDIACONTROLLER
                 - titleAbsolutePosition(m_currentTitle)
 #endif //QT_NO_PHONON_MEDIACONTROLLER
@@ -714,7 +746,7 @@ namespace Phonon
             m_oldHasVideo = currentGraph()->hasVideo();
             setState(Phonon::LoadingState);
             //After loading we go into stopped state
-            m_nextState = Phonon::StoppedState;
+            m_nextState = Phonon::StoppedState; 
             catchComError(currentGraph()->loadSource(source));
             emit currentSourceChanged(source);
         }
@@ -728,7 +760,7 @@ namespace Phonon
 
         void MediaObject::loadingFinished(MediaGraph *mg)
         {
-            if (mg == currentGraph()) {
+            if (mg == currentGraph()) { 
 #ifndef QT_NO_PHONON_MEDIACONTROLLER
                 //Title interface
                 m_currentTitle = 0;
@@ -760,16 +792,15 @@ namespace Phonon
                 case Phonon::PausedState:
                     pause();
                     break;
+                case Phonon::StoppedState:
+                    stop();
+                    break;
                 case Phonon::PlayingState:
                     play();
                     break;
                 case Phonon::ErrorState:
                     setState(Phonon::ErrorState);
                     break;
-                case Phonon::StoppedState:
-                default:
-                    stop();
-                    break;
                 }
             }
         }
@@ -786,7 +817,7 @@ namespace Phonon
 
         void MediaObject::seekingFinished(MediaGraph *mg)
         {
-            if (mg == currentGraph()) {
+            if (mg == currentGraph()) { 
 
                 updateTargetTick();
                 if (currentTime() < totalTime() - m_prefinishMark) {
@@ -817,11 +848,11 @@ namespace Phonon
 #endif
                 LPAMGETERRORTEXT getErrorText = (LPAMGETERRORTEXT)QLibrary::resolve(QLatin1String("quartz"), "AMGetErrorTextW");
 
-                WCHAR buffer[MAX_ERROR_TEXT_LEN];
-                if (getErrorText && getErrorText(hr, buffer, MAX_ERROR_TEXT_LEN)) {
-                    m_errorString = QString::fromWCharArray(buffer);
+                ushort buffer[MAX_ERROR_TEXT_LEN];
+                if (getErrorText && getErrorText(hr, (WCHAR*)buffer, MAX_ERROR_TEXT_LEN)) {
+                    m_errorString = QString::fromUtf16(buffer);
                 } else {
-                    m_errorString = QString::fromLatin1("Unknown error");
+                    m_errorString = QString::fromUtf16((ushort*)_com_error(hr).ErrorMessage());
                 }
                 const QString comError = QString::number(uint(hr), 16);
                 if (!m_errorString.toLower().contains(comError.toLower())) {
@@ -861,7 +892,7 @@ namespace Phonon
 #ifndef QT_NO_PHONON_VIDEO
                 if (VideoWidget *video = qobject_cast<VideoWidget*>(sink)) {
                     m_videoWidgets += video;
-                } else
+                } else 
 #endif //QT_NO_PHONON_VIDEO
                     if (AudioOutput *audio = qobject_cast<AudioOutput*>(sink)) {
                     m_audioOutputs += audio;
@@ -880,7 +911,7 @@ namespace Phonon
 #ifndef QT_NO_PHONON_VIDEO
                 if (VideoWidget *video = qobject_cast<VideoWidget*>(sink)) {
                     m_videoWidgets.removeOne(video);
-                } else
+                } else 
 #endif //QT_NO_PHONON_VIDEO
                     if (AudioOutput *audio = qobject_cast<AudioOutput*>(sink)) {
                         m_audioOutputs.removeOne(audio);
@@ -962,7 +993,7 @@ namespace Phonon
                     emit stateChanged(state(), m_state);
                 }
                 break;
-            case EC_LENGTH_CHANGED:
+            case EC_LENGTH_CHANGED: 
                 if (graph == currentGraph()->graph()) {
                     emit totalTimeChanged( totalTime() );
                 }
diff --git a/src/3rdparty/phonon/ds9/mediaobject.h b/src/3rdparty/phonon/ds9/mediaobject.h
index 34aa666..2c34ffc 100644
--- a/src/3rdparty/phonon/ds9/mediaobject.h
+++ b/src/3rdparty/phonon/ds9/mediaobject.h
@@ -114,7 +114,6 @@ namespace Phonon
 
             enum Task
             {
-                None,
                 Render,
                 Seek,
                 ChangeState,
@@ -123,7 +122,6 @@ namespace Phonon
 
             struct Work
             {
-                Work() : task(None), id(0), time(0) { }
                 Task task;
                 quint16 id;
                 Graph graph;
@@ -137,14 +135,16 @@ namespace Phonon
                 };
                 QList<Filter> decoders; //for the state change requests
             };
+            Work dequeueWork();
             void handleTask();
 
-            Work m_currentWork;
+            Graph m_currentRender;
+			qint16 m_currentRenderId;
             QQueue<Work> m_queue;
             bool m_finished;
             quint16 m_currentWorkId;
             QWinWaitCondition m_waitCondition;
-            QMutex m_mutex; // mutex for the m_queue, m_finished and m_currentWorkId
+            QMutex m_mutex;
 
             //this is for WaitForMultipleObjects
             struct
diff --git a/src/3rdparty/phonon/ds9/qasyncreader.cpp b/src/3rdparty/phonon/ds9/qasyncreader.cpp
index a3f9cda..68ec1f8 100644
--- a/src/3rdparty/phonon/ds9/qasyncreader.cpp
+++ b/src/3rdparty/phonon/ds9/qasyncreader.cpp
@@ -15,6 +15,8 @@ You should have received a copy of the GNU Lesser General Public License
 along with this library.  If not, see <http://www.gnu.org/licenses/>.
 */
 
+#include <QtCore/QFile>
+
 #include "qasyncreader.h"
 #include "qbasefilter.h"
 
@@ -78,7 +80,8 @@ namespace Phonon
 
         STDMETHODIMP QAsyncReader::Request(IMediaSample *sample,DWORD_PTR user)
         {
-            QMutexLocker locker(&m_mutex);
+            QMutexLocker mutexLocker(&m_mutexWait);
+            QWriteLocker locker(&m_lock);
             if (m_flushing) {
                 return VFW_E_WRONG_STATE;
             }
@@ -90,28 +93,33 @@ namespace Phonon
 
         STDMETHODIMP QAsyncReader::WaitForNext(DWORD timeout, IMediaSample **sample, DWORD_PTR *user)
         {
-            QMutexLocker locker(&m_mutex);
+            QMutexLocker locker(&m_mutexWait);
             if (!sample ||!user) {
                 return E_POINTER;
             }
 
-            //msdn says to return immediately if we're flushing but that doesn't seem to be true
-            //since it triggers a dead-lock somewhere inside directshow (see task 258830)
-
             *sample = 0;
             *user = 0;
 
-            if (m_requestQueue.isEmpty()) {
-                if (m_requestWait.wait(&m_mutex, timeout) == false) {
-                    return VFW_E_TIMEOUT;
-                }
-                if (m_requestQueue.isEmpty()) {
+            AsyncRequest r = getNextRequest();
+
+            if (r.sample == 0) {
+                //there is no request in the queue
+                if (isFlushing()) {
                     return VFW_E_WRONG_STATE;
+                } else {
+                    //First we need to lock the mutex
+                    if (m_requestWait.wait(&m_mutexWait, timeout) == false) {
+                        return VFW_E_TIMEOUT;
+                    }
+                    if (isFlushing()) {
+                        return VFW_E_WRONG_STATE;
+                    }
+
+                    r = getNextRequest();
                 }
             }
 
-            AsyncRequest r = m_requestQueue.dequeue();
-
             //at this point we're sure to have a request to proceed
             if (r.sample == 0) {
                 return E_FAIL;
@@ -119,12 +127,14 @@ namespace Phonon
 
             *sample = r.sample;
             *user = r.user;
-            return syncReadAlignedUnlocked(r.sample);
+
+            return SyncReadAligned(r.sample);
         }
 
         STDMETHODIMP QAsyncReader::BeginFlush()
         {
-            QMutexLocker locker(&m_mutex);
+            QMutexLocker mutexLocker(&m_mutexWait);
+            QWriteLocker locker(&m_lock);
             m_flushing = true;
             m_requestWait.wakeOne();
             return S_OK;
@@ -132,28 +142,13 @@ namespace Phonon
 
         STDMETHODIMP QAsyncReader::EndFlush()
         {
-            QMutexLocker locker(&m_mutex);
+            QWriteLocker locker(&m_lock);
             m_flushing = false;
             return S_OK;
         }
 
         STDMETHODIMP QAsyncReader::SyncReadAligned(IMediaSample *sample)
         {
-            QMutexLocker locker(&m_mutex);
-            return syncReadAlignedUnlocked(sample);
-        }
-
-        STDMETHODIMP QAsyncReader::SyncRead(LONGLONG pos, LONG length, BYTE *buffer)
-        {
-            QMutexLocker locker(&m_mutex);
-            return read(pos, length, buffer, 0);
-        }
-
-
-        STDMETHODIMP QAsyncReader::syncReadAlignedUnlocked(IMediaSample *sample)
-        {
-            Q_ASSERT(!m_mutex.tryLock());
-
             if (!sample) {
                 return E_POINTER;
             }
@@ -180,6 +175,23 @@ namespace Phonon
             return sample->SetActualDataLength(actual);
         }
 
+        STDMETHODIMP QAsyncReader::SyncRead(LONGLONG pos, LONG length, BYTE *buffer)
+        {
+            return read(pos, length, buffer, 0);
+        }
+
+
+        //addition
+        QAsyncReader::AsyncRequest QAsyncReader::getNextRequest()
+        {
+            QWriteLocker locker(&m_lock);
+            AsyncRequest ret;
+            if (!m_requestQueue.isEmpty()) {
+                ret = m_requestQueue.dequeue();
+            }
+
+            return ret;
+        }
     }
 }
 
diff --git a/src/3rdparty/phonon/ds9/qasyncreader.h b/src/3rdparty/phonon/ds9/qasyncreader.h
index 95872f9..cb789ee 100644
--- a/src/3rdparty/phonon/ds9/qasyncreader.h
+++ b/src/3rdparty/phonon/ds9/qasyncreader.h
@@ -48,12 +48,11 @@ namespace Phonon
             STDMETHODIMP WaitForNext(DWORD,IMediaSample **,DWORD_PTR *);
             STDMETHODIMP SyncReadAligned(IMediaSample *);
             STDMETHODIMP SyncRead(LONGLONG,LONG,BYTE *);
-            STDMETHODIMP Length(LONGLONG *,LONGLONG *) = 0;
+            virtual STDMETHODIMP Length(LONGLONG *,LONGLONG *) = 0;
             STDMETHODIMP BeginFlush();
             STDMETHODIMP EndFlush();
 
         protected:
-            STDMETHODIMP syncReadAlignedUnlocked(IMediaSample *);
             virtual HRESULT read(LONGLONG pos, LONG length, BYTE *buffer, LONG *actual) = 0;
 
         private:
@@ -63,6 +62,9 @@ namespace Phonon
                 IMediaSample *sample;
                 DWORD_PTR user;
             };
+            AsyncRequest getNextRequest();
+
+            QMutex m_mutexWait;
 
             QQueue<AsyncRequest> m_requestQueue;
             QWaitCondition m_requestWait;
diff --git a/src/3rdparty/phonon/ds9/qaudiocdreader.cpp b/src/3rdparty/phonon/ds9/qaudiocdreader.cpp
index 6d0f335..b9f9fd6 100644
--- a/src/3rdparty/phonon/ds9/qaudiocdreader.cpp
+++ b/src/3rdparty/phonon/ds9/qaudiocdreader.cpp
@@ -103,8 +103,8 @@ namespace Phonon
 
         private:
             HANDLE m_cddrive;
-            CDROM_TOC m_toc;
-            WaveStructure m_waveHeader;
+            CDROM_TOC *m_toc;
+            WaveStructure *m_waveHeader;
             qint64 m_trackAddress;
         };
 
@@ -112,8 +112,19 @@ namespace Phonon
 #define SECTOR_SIZE 2352
 #define NB_SECTORS_READ 20
 
-        static const AM_MEDIA_TYPE audioCDMediaType = { MEDIATYPE_Stream, MEDIASUBTYPE_WAVE, TRUE, FALSE, 1, GUID_NULL, 0, 0, 0};
- 
+        static AM_MEDIA_TYPE getAudioCDMediaType()
+        {
+            AM_MEDIA_TYPE mt;
+            qMemSet(&mt, 0, sizeof(AM_MEDIA_TYPE));
+            mt.majortype = MEDIATYPE_Stream;
+            mt.subtype = MEDIASUBTYPE_WAVE;
+            mt.bFixedSizeSamples = TRUE;
+            mt.bTemporalCompression = FALSE;
+            mt.lSampleSize = 1;
+            mt.formattype = GUID_NULL;
+            return mt;
+        }
+
         int addressToSectors(UCHAR address[4])
         {
             return ((address[0] * 60 + address[1]) * 60 + address[2]) * 75 + address[3] - 150;
@@ -130,8 +141,11 @@ namespace Phonon
         }
 
 
-        QAudioCDReader::QAudioCDReader(QBaseFilter *parent, QChar drive) : QAsyncReader(parent, QVector<AM_MEDIA_TYPE>() << audioCDMediaType)
+        QAudioCDReader::QAudioCDReader(QBaseFilter *parent, QChar drive) : QAsyncReader(parent, QVector<AM_MEDIA_TYPE>() << getAudioCDMediaType())
         {
+            m_toc = new CDROM_TOC;
+            m_waveHeader = new WaveStructure;
+
             //now open the cd-drive
             QString path; 
             if (drive.isNull()) {
@@ -140,30 +154,36 @@ namespace Phonon
                 path = QString::fromLatin1("\\\\.\\%1:").arg(drive); 	 
             }
 
-            m_cddrive = ::CreateFile((const wchar_t *)path.utf16(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
+            m_cddrive = QT_WA_INLINE (
+			::CreateFile( (TCHAR*)path.utf16(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL ),
+			::CreateFileA( path.toLocal8Bit().constData(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL )
+	                );
 
-            qMemSet(&m_toc, 0, sizeof(CDROM_TOC));
+            qMemSet(m_toc, 0, sizeof(CDROM_TOC));
             //read the TOC
             DWORD bytesRead = 0;
-            bool tocRead = ::DeviceIoControl(m_cddrive, IOCTL_CDROM_READ_TOC, 0, 0, &m_toc, sizeof(CDROM_TOC), &bytesRead, 0);
+            bool tocRead = ::DeviceIoControl(m_cddrive, IOCTL_CDROM_READ_TOC, 0, 0, m_toc, sizeof(CDROM_TOC), &bytesRead, 0);
 
             if (!tocRead) {
                 qWarning("unable to load the TOC from the CD");
                 return;
             }
 
-            m_trackAddress = addressToSectors(m_toc.TrackData[0].Address);
-            const qint32 nbSectorsToRead = (addressToSectors(m_toc.TrackData[m_toc.LastTrack + 1 - m_toc.FirstTrack].Address) 
+            m_trackAddress = addressToSectors(m_toc->TrackData[0].Address);
+            const qint32 nbSectorsToRead = (addressToSectors(m_toc->TrackData[m_toc->LastTrack + 1 - m_toc->FirstTrack].Address) 
                 - m_trackAddress);
             const qint32 dataLength = nbSectorsToRead * SECTOR_SIZE;
 
-            m_waveHeader.chunksize = 4 + (8 + m_waveHeader.chunksize2) + (8 + dataLength);
-            m_waveHeader.dataLength = dataLength;
+            m_waveHeader->chunksize = 4 + (8 + m_waveHeader->chunksize2) + (8 + dataLength);
+            m_waveHeader->dataLength = dataLength;
         }
 
         QAudioCDReader::~QAudioCDReader()
         {
             ::CloseHandle(m_cddrive);
+            delete m_toc;
+            delete m_waveHeader;
+
         }
 
         STDMETHODIMP_(ULONG) QAudioCDReader::AddRef()
@@ -179,7 +199,7 @@ namespace Phonon
 
         STDMETHODIMP QAudioCDReader::Length(LONGLONG *total,LONGLONG *available)
         {
-            const LONGLONG length = sizeof(WaveStructure) + m_waveHeader.dataLength;
+            const LONGLONG length = sizeof(WaveStructure) + m_waveHeader->dataLength;
             if (total) {
                 *total = length;
             }
@@ -218,11 +238,11 @@ namespace Phonon
             if (pos < sizeof(WaveStructure)) {
                 //we first copy the content of the structure
                 nbRead = qMin(LONG(sizeof(WaveStructure) - pos), length);
-                qMemCopy(buffer, reinterpret_cast<char*>(&m_waveHeader) + pos, nbRead);
+                qMemCopy(buffer, reinterpret_cast<char*>(m_waveHeader) + pos, nbRead);
             }
 
             const LONGLONG posInTrack = pos - sizeof(WaveStructure) + nbRead;
-            const int bytesLeft = qMin(m_waveHeader.dataLength - posInTrack, LONGLONG(length - nbRead));
+            const int bytesLeft = qMin(m_waveHeader->dataLength - posInTrack, LONGLONG(length - nbRead));
 
             if (bytesLeft > 0) {
 
@@ -277,8 +297,8 @@ namespace Phonon
         {
             QList<qint64> ret;
             ret << 0;
-            for(int i = m_toc.FirstTrack; i <= m_toc.LastTrack ; ++i) {
-                const uchar *address = m_toc.TrackData[i].Address;
+            for(int i = m_toc->FirstTrack; i <= m_toc->LastTrack ; ++i) {
+                const uchar *address = m_toc->TrackData[i].Address;
                 ret << ((address[0] * 60 + address[1]) * 60 + address[2]) * 1000 + address[3]*1000/75 - 2000;
 
             }
diff --git a/src/3rdparty/phonon/ds9/qaudiocdreader.h b/src/3rdparty/phonon/ds9/qaudiocdreader.h
index eff845d..9049b66 100644
--- a/src/3rdparty/phonon/ds9/qaudiocdreader.h
+++ b/src/3rdparty/phonon/ds9/qaudiocdreader.h
@@ -31,7 +31,7 @@ namespace Phonon
     {
         struct CDROM_TOC;
         struct WaveStructure;
-        EXTERN_C const IID IID_ITitleInterface;
+        extern const IID IID_ITitleInterface;
 
         //interface for the Titles
         struct ITitleInterface : public IUnknown
diff --git a/src/3rdparty/phonon/ds9/qbasefilter.cpp b/src/3rdparty/phonon/ds9/qbasefilter.cpp
index 78b8b8f..95cab92 100644
--- a/src/3rdparty/phonon/ds9/qbasefilter.cpp
+++ b/src/3rdparty/phonon/ds9/qbasefilter.cpp
@@ -92,8 +92,8 @@ namespace Phonon
                     return E_POINTER;
                 }
 
-                uint nbfetched = 0;
-                while (nbfetched < count && m_index < m_pins.count()) {
+                int nbfetched = 0;
+                while (nbfetched < int(count) && m_index < m_pins.count()) {
                     IPin *current = m_pins[m_index];
                     current->AddRef();
                     ret[nbfetched] = current;
@@ -166,19 +166,19 @@ namespace Phonon
 
         const QList<QPin *> QBaseFilter::pins() const
         {
-            QMutexLocker locker(&m_mutex);
+            QReadLocker locker(&m_lock);
             return m_pins;
         }
 
         void QBaseFilter::addPin(QPin *pin)
         {
-            QMutexLocker locker(&m_mutex);
+            QWriteLocker locker(&m_lock);
             m_pins.append(pin);
         }
 
         void QBaseFilter::removePin(QPin *pin)
         {
-            QMutexLocker locker(&m_mutex);
+            QWriteLocker locker(&m_lock);
             m_pins.removeAll(pin);
         }
 
@@ -211,8 +211,7 @@ namespace Phonon
             }
             else if (iid == IID_IMediaPosition || iid == IID_IMediaSeeking) {
                 if (inputPins().isEmpty()) {
-                    *out = getUpStreamInterface(iid);
-                    if (*out) {
+                    if (*out = getUpStreamInterface(iid)) {
                         return S_OK; //we return here to avoid adding a reference
                     } else {
                         hr = E_NOINTERFACE;
@@ -251,35 +250,35 @@ namespace Phonon
 
         STDMETHODIMP QBaseFilter::GetClassID(CLSID *clsid)
         {
-            QMutexLocker locker(&m_mutex);
+            QReadLocker locker(&m_lock);
             *clsid = m_clsid;
             return S_OK;
         }
 
         STDMETHODIMP QBaseFilter::Stop()
         {
-            QMutexLocker locker(&m_mutex);
+            QWriteLocker locker(&m_lock);
             m_state = State_Stopped;
             return S_OK;
         }
 
         STDMETHODIMP QBaseFilter::Pause()
         {
-            QMutexLocker locker(&m_mutex);
+            QWriteLocker locker(&m_lock);
             m_state = State_Paused;
             return S_OK;
         }
 
         STDMETHODIMP QBaseFilter::Run(REFERENCE_TIME)
         {
-            QMutexLocker locker(&m_mutex);
+            QWriteLocker locker(&m_lock);
             m_state = State_Running;
             return S_OK;
         }
 
         STDMETHODIMP QBaseFilter::GetState(DWORD, FILTER_STATE *state)
         {
-            QMutexLocker locker(&m_mutex);
+            QReadLocker locker(&m_lock);
             if (!state) {
                 return E_POINTER;
             }
@@ -290,7 +289,7 @@ namespace Phonon
 
         STDMETHODIMP QBaseFilter::SetSyncSource(IReferenceClock *clock)
         {
-            QMutexLocker locker(&m_mutex);
+            QWriteLocker locker(&m_lock);
             if (clock) {
                 clock->AddRef();
             }
@@ -303,7 +302,7 @@ namespace Phonon
 
         STDMETHODIMP QBaseFilter::GetSyncSource(IReferenceClock **clock)
         {
-            QMutexLocker locker(&m_mutex);
+            QReadLocker locker(&m_lock);
             if (!clock) {
                 return E_POINTER;
             }
@@ -342,7 +341,7 @@ namespace Phonon
 
         STDMETHODIMP QBaseFilter::QueryFilterInfo(FILTER_INFO *info )
         {
-            QMutexLocker locker(&m_mutex);
+            QReadLocker locker(&m_lock);
             if (!info) {
                 return E_POINTER;
             }
@@ -356,9 +355,9 @@ namespace Phonon
 
         STDMETHODIMP QBaseFilter::JoinFilterGraph(IFilterGraph *graph, LPCWSTR name)
         {
-            QMutexLocker locker(&m_mutex);
+            QWriteLocker locker(&m_lock);
             m_graph = graph;
-            m_name = QString::fromWCharArray(name);
+            m_name = QString::fromUtf16((const unsigned short*)name);
             return S_OK;
         }
 
diff --git a/src/3rdparty/phonon/ds9/qbasefilter.h b/src/3rdparty/phonon/ds9/qbasefilter.h
index a72d6fe..85f1431 100644
--- a/src/3rdparty/phonon/ds9/qbasefilter.h
+++ b/src/3rdparty/phonon/ds9/qbasefilter.h
@@ -22,7 +22,7 @@ along with this library.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <QtCore/QString>
 #include <QtCore/QList>
-#include <QtCore/QMutex>
+#include <QtCore/QReadWriteLock>
 
 #include <dshow.h>
 
@@ -127,7 +127,7 @@ namespace Phonon
             IFilterGraph *m_graph;
             FILTER_STATE m_state;
             QList<QPin *> m_pins;
-            mutable QMutex m_mutex;
+            mutable QReadWriteLock m_lock;
         };
     }
 }
diff --git a/src/3rdparty/phonon/ds9/qmeminputpin.cpp b/src/3rdparty/phonon/ds9/qmeminputpin.cpp
index a21fbe7..0af1bfd 100644
--- a/src/3rdparty/phonon/ds9/qmeminputpin.cpp
+++ b/src/3rdparty/phonon/ds9/qmeminputpin.cpp
@@ -28,8 +28,8 @@ namespace Phonon
     namespace DS9
     {
 
-        QMemInputPin::QMemInputPin(QBaseFilter *parent, const QVector<AM_MEDIA_TYPE> &mt, bool transform, QPin *output) :
-            QPin(parent, PINDIR_INPUT, mt), m_shouldDuplicateSamples(true), m_transform(transform), m_output(output)
+        QMemInputPin::QMemInputPin(QBaseFilter *parent, const QVector<AM_MEDIA_TYPE> &mt, bool transform) : 
+            QPin(parent, PINDIR_INPUT, mt), m_shouldDuplicateSamples(true), m_transform(transform)
         {
         }
 
@@ -66,9 +66,11 @@ namespace Phonon
         {
             //this allows to serialize with Receive calls
             QMutexLocker locker(&m_mutexReceive);
-            IPin *conn = m_output ? m_output->connected() : 0;
-            if (conn) {
-                conn->EndOfStream();
+            for(int i = 0; i < m_outputs.count(); ++i) {
+                IPin *conn = m_outputs.at(i)->connected();
+                if (conn) {
+                    conn->EndOfStream();
+                }
             }
             return S_OK;
         }
@@ -76,11 +78,13 @@ namespace Phonon
         STDMETHODIMP QMemInputPin::BeginFlush()
         {
             //pass downstream
-            IPin *conn = m_output ? m_output->connected() : 0;
-            if (conn) {
-                conn->BeginFlush();
+            for(int i = 0; i < m_outputs.count(); ++i) {
+                IPin *conn = m_outputs.at(i)->connected();
+                if (conn) {
+                    conn->BeginFlush();
+                }
             }
-            QMutexLocker locker(&m_mutex);
+            QWriteLocker locker(&m_lock);
             m_flushing = true;
             return S_OK;
         }
@@ -88,19 +92,22 @@ namespace Phonon
         STDMETHODIMP QMemInputPin::EndFlush()
         {
             //pass downstream
-            IPin *conn = m_output ? m_output->connected() : 0;
-            if (conn) {
-                conn->EndFlush();
+            for(int i = 0; i < m_outputs.count(); ++i) {
+                IPin *conn = m_outputs.at(i)->connected();
+                if (conn) {
+                    conn->EndFlush();
+                }
             }
-            QMutexLocker locker(&m_mutex);
+            QWriteLocker locker(&m_lock);
             m_flushing = false;
             return S_OK;
         }
 
         STDMETHODIMP QMemInputPin::NewSegment(REFERENCE_TIME start, REFERENCE_TIME stop, double rate)
         {
-            if (m_output)
-                m_output->NewSegment(start, stop, rate);
+            for(int i = 0; i < m_outputs.count(); ++i) {
+                m_outputs.at(i)->NewSegment(start, stop, rate);
+            }
             return S_OK;
         }
 
@@ -112,9 +119,14 @@ namespace Phonon
             if (hr == S_OK &&
                 mt->majortype != MEDIATYPE_NULL &&
                 mt->subtype != MEDIASUBTYPE_NULL &&
-                mt->formattype != GUID_NULL && m_output) {
-                    //we tell the output pin that it should connect with this type
-                    hr = m_output->setAcceptedMediaType(connectedType());
+                mt->formattype != GUID_NULL) {
+                    //we tell the output pins that they should connect with this type
+                    for(int i = 0; i < m_outputs.count(); ++i) {
+                        hr = m_outputs.at(i)->setAcceptedMediaType(connectedType());
+                        if (FAILED(hr)) {
+                            break;
+                        }
+                    }
             }
             return hr;
         }
@@ -125,8 +137,7 @@ namespace Phonon
                 return E_POINTER;
             }
 
-            *alloc = memoryAllocator(true);
-            if (*alloc) {
+            if (*alloc = memoryAllocator(true)) {
                 return S_OK;
             }
 
@@ -140,15 +151,18 @@ namespace Phonon
             }
 
             {
-                QMutexLocker locker(&m_mutex);
+                QWriteLocker locker(&m_lock);
                 m_shouldDuplicateSamples = m_transform && readonly;
             }
 
             setMemoryAllocator(alloc);
 
-            if (m_output) {
-                ComPointer<IMemInputPin> input(m_output, IID_IMemInputPin);
-                input->NotifyAllocator(alloc, m_shouldDuplicateSamples);
+            for(int i = 0; i < m_outputs.count(); ++i) {
+                IPin *pin = m_outputs.at(i)->connected();
+                if (pin) {
+                    ComPointer<IMemInputPin> input(pin, IID_IMemInputPin);
+                    input->NotifyAllocator(alloc, m_shouldDuplicateSamples);
+                }
             }
 
             return S_OK;
@@ -187,18 +201,22 @@ namespace Phonon
                 }
             }
 
-            if (m_output) {
-                IMediaSample *outSample = m_shouldDuplicateSamples ?
-                    duplicateSampleForOutput(sample, m_output->memoryAllocator())
+            for (int i = 0; i < m_outputs.count(); ++i) {
+                QPin *current = m_outputs.at(i);
+                IMediaSample *outSample = m_shouldDuplicateSamples ? 
+                    duplicateSampleForOutput(sample, current->memoryAllocator())
                     : sample;
 
                 if (m_shouldDuplicateSamples) {
                     m_parent->processSample(outSample);
                 }
 
-                ComPointer<IMemInputPin> input(m_output->connected(), IID_IMemInputPin);
-                if (input) {
-                    input->Receive(outSample);
+                IPin *pin = current->connected();
+                if (pin) {
+                    ComPointer<IMemInputPin> input(pin, IID_IMemInputPin);
+                    if (input) {
+                        input->Receive(outSample);
+                    }
                 }
 
                 if (m_shouldDuplicateSamples) {
@@ -229,16 +247,39 @@ namespace Phonon
 
         STDMETHODIMP QMemInputPin::ReceiveCanBlock()
         {
-            //we test the output to see if it can block
-            if (m_output) {
-                ComPointer<IMemInputPin> meminput(m_output->connected(), IID_IMemInputPin);
-                if (meminput && meminput->ReceiveCanBlock() != S_FALSE) {
-                    return S_OK;
+            //we test the output to see if they can block
+            for(int i = 0; i < m_outputs.count(); ++i) {
+                IPin *input = m_outputs.at(i)->connected();
+                if (input) {
+                    ComPointer<IMemInputPin> meminput(input, IID_IMemInputPin);
+                    if (meminput && meminput->ReceiveCanBlock() != S_FALSE) {
+                        return S_OK;
+                    }
                 }
             }
             return S_FALSE;
         }
 
+        //addition
+        //this should be used by the filter to tell it's input pins to which output they should route the samples
+
+        void QMemInputPin::addOutput(QPin *output)
+        {
+            QWriteLocker locker(&m_lock);
+            m_outputs += output;
+        }
+
+        void QMemInputPin::removeOutput(QPin *output)
+        {
+            QWriteLocker locker(&m_lock);
+            m_outputs.removeOne(output);
+        }
+
+        QList<QPin*> QMemInputPin::outputs() const
+        {
+            QReadLocker locker(&m_lock);
+            return m_outputs;
+        }
 
         ALLOCATOR_PROPERTIES QMemInputPin::getDefaultAllocatorProperties() const
         {
@@ -253,7 +294,7 @@ namespace Phonon
             LONG length = sample->GetActualDataLength();
 
             HRESULT hr = alloc->Commit();
-            if (hr == HRESULT(VFW_E_SIZENOTSET)) {
+            if (hr == VFW_E_SIZENOTSET) {
                 ALLOCATOR_PROPERTIES prop = getDefaultAllocatorProperties();
                 prop.cbBuffer = qMax(prop.cbBuffer, length);
                 ALLOCATOR_PROPERTIES actual;
@@ -283,7 +324,7 @@ namespace Phonon
             {
                 LONGLONG start, end;
                 hr = sample->GetMediaTime(&start, &end);
-                if (hr != HRESULT(VFW_E_MEDIA_TIME_NOT_SET)) {
+                if (hr != VFW_E_MEDIA_TIME_NOT_SET) {
                     hr = out->SetMediaTime(&start, &end);
                     Q_ASSERT(SUCCEEDED(hr));
                 }
diff --git a/src/3rdparty/phonon/ds9/qmeminputpin.h b/src/3rdparty/phonon/ds9/qmeminputpin.h
index d74c451..c449721 100644
--- a/src/3rdparty/phonon/ds9/qmeminputpin.h
+++ b/src/3rdparty/phonon/ds9/qmeminputpin.h
@@ -37,7 +37,7 @@ namespace Phonon
         class QMemInputPin : public QPin, public IMemInputPin
         {
         public:
-            QMemInputPin(QBaseFilter *, const QVector<AM_MEDIA_TYPE> &, bool transform, QPin *output);
+            QMemInputPin(QBaseFilter *, const QVector<AM_MEDIA_TYPE> &, bool transform);
             ~QMemInputPin();
 
             //reimplementation from IUnknown
@@ -60,13 +60,18 @@ namespace Phonon
             STDMETHODIMP ReceiveMultiple(IMediaSample **,long,long *);
             STDMETHODIMP ReceiveCanBlock();
 
+            //addition
+            void addOutput(QPin *output);
+            void removeOutput(QPin *output);
+            QList<QPin*> outputs() const;
+
         private:
             IMediaSample *duplicateSampleForOutput(IMediaSample *, IMemAllocator *);
             ALLOCATOR_PROPERTIES getDefaultAllocatorProperties() const;
 
             bool m_shouldDuplicateSamples;
             const bool m_transform; //defines if the pin is transforming the samples
-            QPin* const m_output;
+            QList<QPin*> m_outputs;
             QMutex m_mutexReceive;
         };
     }
diff --git a/src/3rdparty/phonon/ds9/qpin.cpp b/src/3rdparty/phonon/ds9/qpin.cpp
index b4afd10..37fe48d 100644
--- a/src/3rdparty/phonon/ds9/qpin.cpp
+++ b/src/3rdparty/phonon/ds9/qpin.cpp
@@ -28,7 +28,20 @@ namespace Phonon
     namespace DS9
     {
 
-        static const AM_MEDIA_TYPE defaultMediaType = { MEDIATYPE_NULL, MEDIASUBTYPE_NULL, TRUE, FALSE, 1, GUID_NULL, 0, 0, 0};
+        static const AM_MEDIA_TYPE defaultMediaType()
+        {
+            AM_MEDIA_TYPE ret;
+            ret.majortype = MEDIATYPE_NULL;
+            ret.subtype = MEDIASUBTYPE_NULL;
+            ret.bFixedSizeSamples = TRUE;
+            ret.bTemporalCompression = FALSE;
+            ret.lSampleSize = 1;
+            ret.formattype = GUID_NULL;
+            ret.pUnk = 0;
+            ret.cbFormat = 0;
+            ret.pbFormat = 0;
+            return ret;
+        }
 
         class QEnumMediaTypes : public IEnumMediaTypes
         {
@@ -91,8 +104,8 @@ namespace Phonon
                     return E_INVALIDARG;
                 }
 
-                uint nbFetched = 0;
-                while (nbFetched < count && m_index < m_pin->mediaTypes().count()) {
+                int nbFetched = 0;
+                while (nbFetched < int(count) && m_index < m_pin->mediaTypes().count()) {
                     //the caller will deallocate the memory
                     *out = static_cast<AM_MEDIA_TYPE *>(::CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE)));
                     const AM_MEDIA_TYPE original = m_pin->mediaTypes().at(m_index);
@@ -145,9 +158,9 @@ namespace Phonon
 
 
         QPin::QPin(QBaseFilter *parent, PIN_DIRECTION dir, const QVector<AM_MEDIA_TYPE> &mt) :
-            m_parent(parent), m_flushing(false), m_refCount(1),  m_connected(0),
-            m_direction(dir), m_mediaTypes(mt), m_connectedType(defaultMediaType),
-            m_memAlloc(0)
+        m_memAlloc(0), m_parent(parent), m_refCount(1),  m_connected(0),
+            m_direction(dir), m_mediaTypes(mt), m_connectedType(defaultMediaType()),
+            m_flushing(false)
         {
             Q_ASSERT(m_parent);
             m_parent->addPin(this);
@@ -260,7 +273,7 @@ namespace Phonon
 
             if (FAILED(hr)) {
                 setConnected(0);
-                setConnectedType(defaultMediaType);
+                setConnectedType(defaultMediaType());
             } else {
                 ComPointer<IMemInputPin> input(pin, IID_IMemInputPin);
                 if (input) {
@@ -302,8 +315,10 @@ namespace Phonon
             }
 
             setConnected(0);
-            setConnectedType(defaultMediaType);
-            setMemoryAllocator(0);
+            setConnectedType(defaultMediaType());
+            if (m_direction == PINDIR_INPUT) {
+                setMemoryAllocator(0);
+            }
             return S_OK;
         }
 
@@ -323,7 +338,7 @@ namespace Phonon
 
         STDMETHODIMP QPin::ConnectionMediaType(AM_MEDIA_TYPE *type)
         {
-            QMutexLocker locker(&m_mutex);
+            QReadLocker locker(&m_lock);
             if (!type) {
                 return E_POINTER;
             }
@@ -338,6 +353,7 @@ namespace Phonon
 
         STDMETHODIMP QPin::QueryPinInfo(PIN_INFO *info)
         {
+            QReadLocker locker(&m_lock);
             if (!info) {
                 return E_POINTER;
             }
@@ -345,12 +361,14 @@ namespace Phonon
             info->dir = m_direction;
             info->pFilter = m_parent;
             m_parent->AddRef();
-            info->achName[0] = 0;
+            qMemCopy(info->achName, m_name.utf16(), qMin(MAX_FILTER_NAME, m_name.length()+1) *2);
+
             return S_OK;
         }
 
         STDMETHODIMP QPin::QueryDirection(PIN_DIRECTION *dir)
         {
+            QReadLocker locker(&m_lock);
             if (!dir) {
                 return E_POINTER;
             }
@@ -361,18 +379,20 @@ namespace Phonon
 
         STDMETHODIMP QPin::QueryId(LPWSTR *id)
         {
+            QReadLocker locker(&m_lock);
             if (!id) {
                 return E_POINTER;
             }
 
-            *id = static_cast<LPWSTR>(::CoTaskMemAlloc(2));
-            *id[0] = 0;
+            int nbBytes = (m_name.length()+1)*2;
+            *id = static_cast<LPWSTR>(::CoTaskMemAlloc(nbBytes));
+            qMemCopy(*id, m_name.utf16(), nbBytes);
             return S_OK;
         }
 
         STDMETHODIMP QPin::QueryAccept(const AM_MEDIA_TYPE *type)
         {
-            QMutexLocker locker(&m_mutex);
+            QReadLocker locker(&m_lock);
             if (!type) {
                 return E_POINTER;
             }
@@ -419,7 +439,7 @@ namespace Phonon
 
         STDMETHODIMP QPin::NewSegment(REFERENCE_TIME start, REFERENCE_TIME stop, double rate)
         {
-            QMutexLocker locker(&m_mutex);
+            QReadLocker locker(&m_lock);
             if (m_direction == PINDIR_OUTPUT && m_connected) {
                 //we deliver this downstream
                 m_connected->NewSegment(start, stop, rate);
@@ -436,8 +456,8 @@ namespace Phonon
 
         HRESULT QPin::checkOutputMediaTypesConnection(IPin *pin)
         {
-            ComPointer<IEnumMediaTypes> emt;
-            HRESULT hr = pin->EnumMediaTypes(emt.pparam());
+            IEnumMediaTypes *emt = 0;
+            HRESULT hr = pin->EnumMediaTypes(&emt);
             if (hr != S_OK) {
                 return hr;
             }
@@ -450,7 +470,7 @@ namespace Phonon
                         freeMediaType(type);
                         return S_OK;
                     } else {
-                        setConnectedType(defaultMediaType);
+                        setConnectedType(defaultMediaType());
                         freeMediaType(type);
                     }
                 }
@@ -500,7 +520,7 @@ namespace Phonon
 
         void QPin::setConnectedType(const AM_MEDIA_TYPE &type)
         {
-            QMutexLocker locker(&m_mutex);
+            QWriteLocker locker(&m_lock);
 
             //1st we free memory
             freeMediaType(m_connectedType);
@@ -510,13 +530,13 @@ namespace Phonon
 
         const AM_MEDIA_TYPE &QPin::connectedType() const 
         {
-            QMutexLocker locker(&m_mutex);
+            QReadLocker locker(&m_lock);
             return m_connectedType;
         }
 
         void QPin::setConnected(IPin *pin)
         {
-            QMutexLocker locker(&m_mutex);
+            QWriteLocker locker(&m_lock);
             if (pin) {
                 pin->AddRef();
             }
@@ -528,7 +548,7 @@ namespace Phonon
 
         IPin *QPin::connected(bool addref) const
         {
-            QMutexLocker locker(&m_mutex);
+            QReadLocker locker(&m_lock);
             if (addref && m_connected) {
                 m_connected->AddRef();
             }
@@ -537,12 +557,13 @@ namespace Phonon
 
         bool QPin::isFlushing() const
         {
-            QMutexLocker locker(&m_mutex);
+            QReadLocker locker(&m_lock);
             return m_flushing;
         }
 
         FILTER_STATE QPin::filterState() const
         {
+            QReadLocker locker(&m_lock);
             FILTER_STATE fstate = State_Stopped;
             m_parent->GetState(0, &fstate);
             return fstate;
@@ -550,7 +571,7 @@ namespace Phonon
 
         QVector<AM_MEDIA_TYPE> QPin::mediaTypes() const
         {
-            QMutexLocker locker(&m_mutex);
+            QReadLocker locker(&m_lock);
             return m_mediaTypes;
         }
 
@@ -586,7 +607,7 @@ namespace Phonon
 
         void QPin::setMemoryAllocator(IMemAllocator *alloc)
         {
-            QMutexLocker locker(&m_mutex);
+            QWriteLocker locker(&m_lock);
             if (alloc) {
                 alloc->AddRef();
             }
@@ -598,7 +619,7 @@ namespace Phonon
 
         IMemAllocator *QPin::memoryAllocator(bool addref) const
         {
-            QMutexLocker locker(&m_mutex);
+            QReadLocker locker(&m_lock);
             if (addref && m_memAlloc) {
                 m_memAlloc->AddRef();
             }
diff --git a/src/3rdparty/phonon/ds9/qpin.h b/src/3rdparty/phonon/ds9/qpin.h
index 280ad61..a3287c4 100644
--- a/src/3rdparty/phonon/ds9/qpin.h
+++ b/src/3rdparty/phonon/ds9/qpin.h
@@ -22,7 +22,7 @@ along with this library.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <QtCore/QString>
 #include <QtCore/QVector>
-#include <QtCore/QMutex>
+#include <QtCore/QReadWriteLock>
 
 #include <dshow.h>
 
@@ -85,8 +85,8 @@ namespace Phonon
 
         protected:
             //this can be used by sub-classes
-            mutable QMutex m_mutex;
-            QBaseFilter * const m_parent;
+            mutable QReadWriteLock m_lock;
+            QBaseFilter *m_parent;
             bool m_flushing;
 
         private:
@@ -98,6 +98,7 @@ namespace Phonon
             const PIN_DIRECTION m_direction;
             QVector<AM_MEDIA_TYPE> m_mediaTypes; //accepted media types
             AM_MEDIA_TYPE m_connectedType;
+            QString m_name;
             IMemAllocator *m_memAlloc;
         };
 
diff --git a/src/3rdparty/phonon/ds9/videorenderer_soft.cpp b/src/3rdparty/phonon/ds9/videorenderer_soft.cpp
index f7d42cf..dd6e076 100644
--- a/src/3rdparty/phonon/ds9/videorenderer_soft.cpp
+++ b/src/3rdparty/phonon/ds9/videorenderer_soft.cpp
@@ -63,9 +63,9 @@ along with this library.  If not, see <http://www.gnu.org/licenses/>.
 static const char yv12ToRgb[] =
 "!!ARBfp1.0"
 "PARAM c[5] = { program.local[0..1],"
-"{ 1.164, 0, 1.596, 0.5 },"
-"{ 0.0625, 1.164, -0.391, -0.81300002 },"
-"{ 1.164, 2.0179999, 0 } };"
+"                { 1.164, 0, 1.596, 0.5 },"
+"                { 0.0625, 1.164, -0.391, -0.81300002 },"
+"                { 1.164, 2.0179999, 0 } };"
 "TEMP R0;"
 "TEX R0.x, fragment.texcoord[0], texture[1], 2D;"
 "ADD R0.y, R0.x, -c[2].w;"
@@ -89,11 +89,11 @@ static const char yv12ToRgb[] =
 "END";
 
 static const char yuy2ToRgb[] =
-"!!ARBfp1.0"
+    "!!ARBfp1.0"
 "PARAM c[5] = { program.local[0..1],"
-"{ 0.5, 2, 1, 0.0625 },"
-"{ 1.164, 0, 1.596, 2.0179999 },"
-"{ 1.164, -0.391, -0.81300002 } };"
+"                { 0.5, 2, 1, 0.0625 },"
+"                { 1.164, 0, 1.596, 2.0179999 },"
+"                { 1.164, -0.391, -0.81300002 } };"
 "TEMP R0;"
 "TEMP R1;"
 "TEMP R2;"
@@ -149,16 +149,24 @@ namespace Phonon
     {
         static const QVector<AM_MEDIA_TYPE> videoMediaTypes()
         {
-            AM_MEDIA_TYPE mt = { MEDIATYPE_Video, MEDIASUBTYPE_YV12, 0, 0, 0, GUID_NULL, 0, 0, 0 };
+            AM_MEDIA_TYPE mt;
+            qMemSet(&mt, 0, sizeof(AM_MEDIA_TYPE));
+            mt.majortype = MEDIATYPE_Video;
+
+            //we accept any video format
+            mt.formattype = GUID_NULL;
+            mt.cbFormat = 0;
+            mt.pbFormat = 0;
 
             QVector<AM_MEDIA_TYPE> ret;
 
-            //we add all the subtypes we support
-            ret << mt; //YV12
+            //we support YUV (YV12 and YUY2) and RGB32
+            mt.subtype = MEDIASUBTYPE_YV12;
+            ret << mt;
             mt.subtype = MEDIASUBTYPE_YUY2;
-            ret << mt; //YUY2
+            ret << mt;
             mt.subtype = MEDIASUBTYPE_RGB32;
-            ret << mt; //RGB32
+            ret << mt;
 
             return ret;
         }
@@ -194,8 +202,8 @@ namespace Phonon
                 m_sampleBuffer = ComPointer<IMediaSample>();
 #ifndef QT_NO_OPENGL
                 freeGLResources();
-                m_textureUploaded = false;
 #endif // QT_NO_OPENGL
+                m_textureUploaded = false;
             }
 
             void endOfStream()
@@ -314,6 +322,7 @@ namespace Phonon
             REFERENCE_TIME m_start;
             HANDLE m_renderEvent, m_receiveCanWait;         // Signals sample to render
             QSize m_size;
+            bool m_textureUploaded;
 
             //mixer settings
             qreal m_brightness,
@@ -355,7 +364,6 @@ namespace Phonon
 
             bool m_checkedPrograms;
             bool m_usingOpenGL;
-            bool m_textureUploaded;
             GLuint m_program[2];
             GLuint m_texture[3];
 #endif
@@ -365,7 +373,7 @@ namespace Phonon
         {
         public:
             VideoRendererSoftPin(VideoRendererSoftFilter *parent) :
-              QMemInputPin(parent, videoMediaTypes(), false /*no transformation of the samples*/, 0),
+              QMemInputPin(parent, videoMediaTypes(), false /*no transformation of the samples*/),
                   m_renderer(parent)
               {
               }
@@ -436,7 +444,7 @@ namespace Phonon
         QBaseFilter(CLSID_NULL), m_inputPin(new VideoRendererSoftPin(this)),
             m_renderer(renderer), m_start(0)
 #ifndef QT_NO_OPENGL
-            , m_checkedPrograms(false), m_usingOpenGL(false), m_textureUploaded(false)
+            ,m_usingOpenGL(false), m_checkedPrograms(false), m_textureUploaded(false)
 #endif
         {
             m_renderEvent    = ::CreateEvent(0, 0, 0, 0);
@@ -661,10 +669,7 @@ namespace Phonon
 
 
 #ifndef QT_NO_OPENGL
-            if (painter.paintEngine() && 
-                (painter.paintEngine()->type() == QPaintEngine::OpenGL || painter.paintEngine()->type() == QPaintEngine::OpenGL2)
-                && checkGLPrograms()) {
-
+            if (painter.paintEngine() && painter.paintEngine()->type() == QPaintEngine::OpenGL && checkGLPrograms()) {
                 //for now we only support YUV (both YV12 and YUY2)
                 updateTexture();
 
@@ -676,7 +681,6 @@ namespace Phonon
                 }
 
                 //let's draw the texture
-                painter.beginNativePainting();
 
                 //Let's pass the other arguments
                 const Program prog = (m_inputPin->connectedType().subtype == MEDIASUBTYPE_YV12) ? YV12toRGB : YUY2toRGB;
@@ -726,7 +730,6 @@ namespace Phonon
                 glDisableClientState(GL_VERTEX_ARRAY);
 
                 glDisable(GL_FRAGMENT_PROGRAM_ARB);
-                painter.endNativePainting();
                 return;
             } else
 #endif
diff --git a/src/3rdparty/phonon/ds9/videorenderer_vmr9.cpp b/src/3rdparty/phonon/ds9/videorenderer_vmr9.cpp
index 81ebb8b..298e9fa 100644
--- a/src/3rdparty/phonon/ds9/videorenderer_vmr9.cpp
+++ b/src/3rdparty/phonon/ds9/videorenderer_vmr9.cpp
@@ -169,7 +169,6 @@ namespace Phonon
             Q_ASSERT(SUCCEEDED(hr));
             ComPointer<IVMRWindowlessControl9> windowlessControl(m_filter, IID_IVMRWindowlessControl9);
             windowlessControl->SetVideoClippingWindow(reinterpret_cast<HWND>(target->winId()));
-            windowlessControl->SetAspectRatioMode(VMR9ARMode_None); //we're in control of the size
         }
 
         QImage VideoRendererVMR9::snapshot() const
diff --git a/src/3rdparty/phonon/ds9/videowidget.cpp b/src/3rdparty/phonon/ds9/videowidget.cpp
index 091be16..de7ce5f 100644
--- a/src/3rdparty/phonon/ds9/videowidget.cpp
+++ b/src/3rdparty/phonon/ds9/videowidget.cpp
@@ -84,19 +84,7 @@ namespace Phonon
             void setCurrentRenderer(AbstractVideoRenderer *renderer)
             {
                 m_currentRenderer = renderer;
-                //we disallow repaint on that widget for just a fraction of second
-                //this allows better transition between videos
-                setUpdatesEnabled(false);
-                m_flickerFreeTimer.start(20, this);
-            }
-
-            void timerEvent(QTimerEvent *e)
-            {
-                if (e->timerId() == m_flickerFreeTimer.timerId()) {
-                    m_flickerFreeTimer.stop();
-                    setUpdatesEnabled(true);
-                }
-                QWidget::timerEvent(e);
+                update();
             }
 
             QSize sizeHint() const
@@ -118,8 +106,6 @@ namespace Phonon
 
             void paintEvent(QPaintEvent *e)
             {
-                if (!updatesEnabled())
-                    return; //this avoids repaint from native events
                 checkCurrentRenderingMode();
                 m_currentRenderer->repaintCurrentFrame(this, e->rect());
             }
@@ -167,14 +153,13 @@ namespace Phonon
                     }
                 } else if (!isEmbedded()) {
                     m_currentRenderer = m_node->switchRendering(m_currentRenderer);
-                    setAttribute(Qt::WA_PaintOnScreen, false);
+                    setAttribute(Qt::WA_PaintOnScreen, true);
                 }
             }
 
             VideoWidget *m_node;
             AbstractVideoRenderer *m_currentRenderer;
             QVariant m_restoreScreenSaverActive;
-            QBasicTimer m_flickerFreeTimer;
         };
 
         VideoWidget::VideoWidget(QWidget *parent)
@@ -276,7 +261,6 @@ namespace Phonon
         {
             m_aspectRatio = aspectRatio;
             updateVideoSize();
-            m_widget->update();
         }
 
         Phonon::VideoWidget::ScaleMode VideoWidget::scaleMode() const
@@ -295,7 +279,6 @@ namespace Phonon
         {
             m_scaleMode = scaleMode;
             updateVideoSize();
-            m_widget->update();
         }
 
         void VideoWidget::setBrightness(qreal b)
diff --git a/src/3rdparty/phonon/ds9/volumeeffect.cpp b/src/3rdparty/phonon/ds9/volumeeffect.cpp
index a93b074..2fd1afc 100644
--- a/src/3rdparty/phonon/ds9/volumeeffect.cpp
+++ b/src/3rdparty/phonon/ds9/volumeeffect.cpp
@@ -68,7 +68,17 @@ namespace Phonon
         static const QVector<AM_MEDIA_TYPE> audioMediaType()
         {
             QVector<AM_MEDIA_TYPE> ret;
-            AM_MEDIA_TYPE mt = { MEDIATYPE_Audio, MEDIASUBTYPE_PCM, 1, 0, 1, GUID_NULL, 0, 0, 0};
+
+            AM_MEDIA_TYPE mt;
+            mt.majortype = MEDIATYPE_Audio;
+            mt.subtype = MEDIASUBTYPE_PCM;
+            mt.bFixedSizeSamples = 1;
+            mt.bTemporalCompression = 0;
+            mt.pUnk = 0;
+            mt.lSampleSize = 1;
+            mt.cbFormat = 0;
+            mt.pbFormat = 0;
+            mt.formattype = GUID_NULL;
             ret << mt;
             return ret;
         }
@@ -76,7 +86,7 @@ namespace Phonon
         class VolumeMemInputPin : public QMemInputPin
         {
         public:
-            VolumeMemInputPin(QBaseFilter *parent, const QVector<AM_MEDIA_TYPE> &mt, QPin *output) : QMemInputPin(parent, mt, true /*transform*/, output)
+            VolumeMemInputPin(QBaseFilter *parent, const QVector<AM_MEDIA_TYPE> &mt) : QMemInputPin(parent, mt, true /*transform*/)
             {
             }
 
@@ -139,7 +149,8 @@ namespace Phonon
 
             //then creating the input
             mt << audioMediaType();
-            m_input = new VolumeMemInputPin(this, mt, m_output);
+            m_input = new VolumeMemInputPin(this, mt);
+            m_input->addOutput(m_output); //make the connection here
         }
 
         void VolumeEffectFilter::treatOneSamplePerChannel(BYTE **buffer, int sampleSize, int channelCount, int frequency)
diff --git a/src/3rdparty/phonon/ds9/volumeeffect.h b/src/3rdparty/phonon/ds9/volumeeffect.h
index d1b0186..39b20d0 100644
--- a/src/3rdparty/phonon/ds9/volumeeffect.h
+++ b/src/3rdparty/phonon/ds9/volumeeffect.h
@@ -47,7 +47,7 @@ namespace Phonon
         private:
             float m_volume;
 
-            //paramaters used to fade
+            //parameters used to fade
             Phonon::VolumeFaderEffect::FadeCurve m_fadeCurve;
 
             bool m_fading; //determines if we should be fading.
diff --git a/src/3rdparty/phonon/gstreamer/CMakeLists.txt b/src/3rdparty/phonon/gstreamer/CMakeLists.txt
index 08f892a..d529fb6 100644
--- a/src/3rdparty/phonon/gstreamer/CMakeLists.txt
+++ b/src/3rdparty/phonon/gstreamer/CMakeLists.txt
@@ -1,4 +1,4 @@
-# Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+# Copyright (C) 2009 Nokia Corporation. All rights reserved.
 # Copyright (C) 2008 Matthias Kretz <kretz@kde.org>
 #
 # This library is free software: you can redistribute it and/or modify
@@ -19,7 +19,7 @@ include(ConfigureChecks.cmake)
 if (BUILD_PHONON_GSTREAMER)
    include_directories(
 	  ${CMAKE_CURRENT_BINARY_DIR}
-	  ${GSTREAMER_INCLUDE_DIR} 
+	  ${GSTREAMER_INCLUDE_DIR}
 	  ${GLIB2_INCLUDE_DIR}
       ${LIBXML2_INCLUDE_DIR}
 	  ${X11_X11_INCLUDE_PATH})
@@ -34,7 +34,6 @@ if (BUILD_PHONON_GSTREAMER)
 
    set(phonon_gstreamer_SRCS
       audiooutput.cpp
-      artssink.cpp
       backend.cpp
       devicemanager.cpp
       effectmanager.cpp
@@ -50,14 +49,20 @@ if (BUILD_PHONON_GSTREAMER)
       message.cpp
       audioeffect.cpp
       abstractrenderer.cpp
-      x11renderer.cpp
       widgetrenderer.cpp
       glrenderer.cpp
       volumefadereffect.cpp
+      audiodataoutput.cpp
       )
 
-   find_package(Alsa)
-   macro_ensure_version("0.10.22" ${GSTREAMER_VERSION} GSTREAMER_HAS_NONBLOCKING_ALSASINK)
+   if(NOT WIN32)
+      set(phonon_gstreamer_SRCS
+          ${phonon_gstreamer_SRCS}
+          artssink.cpp
+          x11renderer.cpp)
+      macro_optional_find_package(Alsa)
+      macro_ensure_version("0.10.22" ${GSTREAMER_VERSION} GSTREAMER_HAS_NONBLOCKING_ALSASINK)
+   endif(NOT WIN32)
    if(ALSA_FOUND AND NOT GSTREAMER_HAS_NONBLOCKING_ALSASINK)
       add_definitions(-DUSE_ALSASINK2)
       include_directories(${ALSA_INCLUDES})
@@ -78,6 +83,9 @@ if (BUILD_PHONON_GSTREAMER)
    if(ALSA_FOUND)
       target_link_libraries(phonon_gstreamer ${ASOUND_LIBRARY})
    endif(ALSA_FOUND)
+   if(USE_INSTALL_PLUGIN)
+       target_link_libraries(phonon_gstreamer ${GSTREAMER_PLUGIN_PBUTILS_LIBRARIES})
+   endif(USE_INSTALL_PLUGIN)
 
    install(TARGETS phonon_gstreamer DESTINATION ${PLUGIN_INSTALL_DIR}/plugins/phonon_backend)
    install(FILES gstreamer.desktop DESTINATION ${SERVICES_INSTALL_DIR}/phononbackends)
diff --git a/src/3rdparty/phonon/gstreamer/ConfigureChecks.cmake b/src/3rdparty/phonon/gstreamer/ConfigureChecks.cmake
index f2922e1..095a0e9 100644
--- a/src/3rdparty/phonon/gstreamer/ConfigureChecks.cmake
+++ b/src/3rdparty/phonon/gstreamer/ConfigureChecks.cmake
@@ -1,4 +1,4 @@
-# Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+# Copyright (C) 2009 Nokia Corporation. All rights reserved.
 #
 # This library is free software: you can redistribute it and/or modify
 # it under the terms of the GNU Lesser General Public License as published by
@@ -17,6 +17,7 @@ macro_log_feature(GSTREAMER_FOUND "GStreamer" "gstreamer 0.10 is required for th
 
 macro_optional_find_package(GStreamerPlugins)
 macro_log_feature(GSTREAMER_PLUGIN_VIDEO_LIBRARIES "GStreamer video plugin" "The gstreamer video plugin (part of gstreamer-plugins-base 0.10) is required for the multimedia gstreamer backend" "http://gstreamer.freedesktop.org/modules/" FALSE "0.10")
+macro_log_feature(GSTREAMER_PLUGIN_AUDIO_LIBRARIES "GStreamer audio plugin" "The gstreamer audio plugin (part of gstreamer-plugins-base 0.10) is required for the multimedia gstreamer backend" "http://gstreamer.freedesktop.org/modules/" FALSE "0.10")
 
 macro_optional_find_package(GLIB2)
 macro_log_feature(GLIB2_FOUND "GLib2" "GLib 2 is required to compile the gstreamer backend for Phonon" "http://www.gtk.org/download/" FALSE)
@@ -30,8 +31,8 @@ macro_log_feature(LIBXML2_FOUND "LibXml2" "LibXml2 is required to compile the gs
 macro_optional_find_package(OpenGL)
 macro_log_feature(OPENGL_FOUND "OpenGL" "OpenGL support is required to compile the gstreamer backend for Phonon" "" FALSE)
 
-if (GSTREAMER_FOUND AND GSTREAMER_PLUGIN_VIDEO_LIBRARIES AND GLIB2_FOUND AND GOBJECT_FOUND AND LIBXML2_FOUND AND OPENGL_FOUND)
+if (GSTREAMER_FOUND AND GSTREAMER_PLUGIN_VIDEO_LIBRARIES AND GSTREAMER_PLUGIN_AUDIO_LIBRARIES AND GLIB2_FOUND AND GOBJECT_FOUND AND LIBXML2_FOUND AND OPENGL_FOUND)
    set(BUILD_PHONON_GSTREAMER TRUE)
-else (GSTREAMER_FOUND AND GSTREAMER_PLUGIN_VIDEO_LIBRARIES AND GLIB2_FOUND AND GOBJECT_FOUND AND LIBXML2_FOUND AND OPENGL_FOUND)
+else (GSTREAMER_FOUND AND GSTREAMER_PLUGIN_VIDEO_LIBRARIES AND GSTREAMER_PLUGIN_AUDIO_LIBRARIES AND GLIB2_FOUND AND GOBJECT_FOUND AND LIBXML2_FOUND AND OPENGL_FOUND)
    set(BUILD_PHONON_GSTREAMER FALSE)
-endif (GSTREAMER_FOUND AND GSTREAMER_PLUGIN_VIDEO_LIBRARIES AND GLIB2_FOUND AND GOBJECT_FOUND AND LIBXML2_FOUND AND OPENGL_FOUND)
+endif (GSTREAMER_FOUND AND GSTREAMER_PLUGIN_VIDEO_LIBRARIES AND GSTREAMER_PLUGIN_AUDIO_LIBRARIES AND GLIB2_FOUND AND GOBJECT_FOUND AND LIBXML2_FOUND AND OPENGL_FOUND)
diff --git a/src/3rdparty/phonon/gstreamer/abstractrenderer.cpp b/src/3rdparty/phonon/gstreamer/abstractrenderer.cpp
index 5d88d10..924b611 100644
--- a/src/3rdparty/phonon/gstreamer/abstractrenderer.cpp
+++ b/src/3rdparty/phonon/gstreamer/abstractrenderer.cpp
@@ -17,7 +17,6 @@
 
 #include "abstractrenderer.h"
 
-#ifndef QT_NO_PHONON_VIDEO
 QT_BEGIN_NAMESPACE
 
 namespace Phonon
@@ -53,5 +52,5 @@ void AbstractRenderer::movieSizeChanged(const QSize &size)
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_VIDEO
+
 
diff --git a/src/3rdparty/phonon/gstreamer/abstractrenderer.h b/src/3rdparty/phonon/gstreamer/abstractrenderer.h
index 10a2822..140413d 100644
--- a/src/3rdparty/phonon/gstreamer/abstractrenderer.h
+++ b/src/3rdparty/phonon/gstreamer/abstractrenderer.h
@@ -23,7 +23,6 @@
 #include "medianode.h"
 #include <phonon/videowidget.h>
 
-#ifndef QT_NO_PHONON_VIDEO
 QT_BEGIN_NAMESPACE
 
 class QString;
@@ -59,5 +58,5 @@ protected:
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_VIDEO
+
 #endif // Phonon_GSTREAMER_ABSTRACTRENDERER_H
diff --git a/src/3rdparty/phonon/gstreamer/artssink.cpp b/src/3rdparty/phonon/gstreamer/artssink.cpp
index 441607d..ff56da9 100644
--- a/src/3rdparty/phonon/gstreamer/artssink.cpp
+++ b/src/3rdparty/phonon/gstreamer/artssink.cpp
@@ -233,7 +233,7 @@ static void arts_sink_init (ArtsSink * src, ArtsSinkClass * g_class)
     Q_UNUSED(g_class);
     GST_DEBUG_OBJECT (src, "initializing artssink");
     src->stream = 0;
-#ifndef QT_NO_LIBRARY
+
     p_arts_init =  (Ptr_arts_init)QLibrary::resolve(QLatin1String("artsc"), 0, "arts_init");
     p_arts_play_stream =  (Ptr_arts_play_stream)QLibrary::resolve(QLatin1String("artsc"), 0, "arts_play_stream");
     p_arts_close_stream =  (Ptr_arts_close_stream)QLibrary::resolve(QLatin1String("artsc"), 0, "arts_close_stream");
@@ -250,7 +250,6 @@ static void arts_sink_init (ArtsSink * src, ArtsSinkClass * g_class)
         }
     }
     sinkCount ++;
-#endif //QT_NO_LIBRARY
 }
 
 static void arts_sink_dispose (GObject * object)
diff --git a/src/3rdparty/phonon/gstreamer/audiodataoutput.cpp b/src/3rdparty/phonon/gstreamer/audiodataoutput.cpp
new file mode 100644
index 0000000..30dabdf
--- /dev/null
+++ b/src/3rdparty/phonon/gstreamer/audiodataoutput.cpp
@@ -0,0 +1,143 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
+    Copyright (C) 2009 Martin Sandsmark <sandsmark@samfundet.no>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "audiodataoutput.h"
+#include "gsthelper.h"
+#include "medianode.h"
+#include "mediaobject.h"
+#include <QtCore/QVector>
+#include <QtCore/QMap>
+#include <phonon/audiooutput.h>
+
+namespace Phonon
+{
+namespace Gstreamer
+{
+AudioDataOutput::AudioDataOutput(Backend *backend, QObject *parent)
+    : QObject(parent),
+    MediaNode(backend, AudioSink | AudioSource)
+{
+    static int count = 0;
+    m_name = "AudioDataOutput" + QString::number(count++);
+
+    m_queue = gst_element_factory_make ("identity", NULL);
+    gst_object_ref(m_queue);
+    m_isValid = true;
+}
+
+AudioDataOutput::~AudioDataOutput()
+{
+    gst_element_set_state(m_queue, GST_STATE_NULL);
+    gst_object_unref(m_queue);
+}
+
+int AudioDataOutput::dataSize() const
+{
+    return m_dataSize;
+}
+
+int AudioDataOutput::sampleRate() const
+{
+    return 44100;
+}
+
+void AudioDataOutput::setDataSize(int size)
+{
+    m_dataSize = size;
+}
+
+typedef QMap<Phonon::AudioDataOutput::Channel, QVector<float> > FloatMap;
+typedef QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > IntMap;
+
+inline void AudioDataOutput::convertAndEmit(const QVector<qint16> &leftBuffer, const QVector<qint16> &rightBuffer)
+{
+    //TODO: Floats
+    IntMap map;
+    map.insert(Phonon::AudioDataOutput::LeftChannel, leftBuffer);
+    map.insert(Phonon::AudioDataOutput::RightChannel, rightBuffer);
+    emit dataReady(map);
+}
+
+void AudioDataOutput::processBuffer(GstPad*, GstBuffer* buffer, gpointer gThat)
+{
+    // TODO emit endOfMedia
+    AudioDataOutput *that = reinterpret_cast<AudioDataOutput*>(gThat);
+
+    // determine the number of channels
+    GstStructure* structure = gst_caps_get_structure (GST_BUFFER_CAPS(buffer), 0);
+    gst_structure_get_int (structure, "channels", &that->m_channels);
+
+    if (that->m_channels > 2 || that->m_channels < 0) {
+        qWarning() << Q_FUNC_INFO << ": Number of channels not supported: " << that->m_channels;
+        return;
+    }
+
+    gint16 *data = reinterpret_cast<gint16*>(GST_BUFFER_DATA(buffer));
+    guint size = GST_BUFFER_SIZE(buffer) / sizeof(gint16);
+
+    that->m_pendingData.reserve(that->m_pendingData.size() + size);
+
+    for (uint i=0; i<size; i++) {
+        // 8 bit? interleaved? yay for lacking documentation!
+        that->m_pendingData.append(data[i]);
+    }
+
+    while (that->m_pendingData.size() > that->m_dataSize * that->m_channels) {
+        if (that->m_channels == 1) {
+            QVector<qint16> intBuffer(that->m_dataSize);
+            memcpy(intBuffer.data(), that->m_pendingData.constData(), that->m_dataSize * sizeof(qint16));
+
+            that->convertAndEmit(intBuffer, intBuffer);
+            int newSize = that->m_pendingData.size() - that->m_dataSize;
+            memmove(that->m_pendingData.data(), that->m_pendingData.constData() + that->m_dataSize, newSize * sizeof(qint16));
+            that->m_pendingData.resize(newSize);
+        } else {
+            QVector<qint16> left(that->m_dataSize), right(that->m_dataSize);
+            for (int i=0; i<that->m_dataSize; i++) {
+                left[i] = that->m_pendingData[i*2];
+                right[i] = that->m_pendingData[i*2+1];
+            }
+            that->m_pendingData.resize(that->m_pendingData.size() - that->m_dataSize*2);
+            that->convertAndEmit(left, right);
+        }
+    }
+}
+
+void AudioDataOutput::mediaNodeEvent(const MediaNodeEvent *event)
+{
+    if (event->type() == MediaNodeEvent::MediaObjectConnected && root()) {
+        g_object_set(G_OBJECT(audioElement()), "sync", true, (const char*)NULL);
+        GstPad *audiopad = gst_element_get_pad (audioElement(), "src");
+        gst_pad_add_buffer_probe (audiopad, G_CALLBACK(processBuffer), this);
+        gst_object_unref (audiopad);
+        return;
+    }
+
+    MediaNode::mediaNodeEvent(event);
+}
+
+}} //namespace Phonon::Gstreamer
+
+#include "moc_audiodataoutput.cpp"
+// vim: sw=4 ts=4
+
diff --git a/src/3rdparty/phonon/gstreamer/audiodataoutput.h b/src/3rdparty/phonon/gstreamer/audiodataoutput.h
new file mode 100644
index 0000000..5e30a1d
--- /dev/null
+++ b/src/3rdparty/phonon/gstreamer/audiodataoutput.h
@@ -0,0 +1,84 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
+    Copyright (C) 2009 Martin Sandsmark <sandsmark@samfundet.no>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef Phonon_GSTREAMER_AUDIODATAOUTPUT_H
+#define Phonon_GSTREAMER_AUDIODATAOUTPUT_H
+
+#include "abstractaudiooutput.h"
+#include "backend.h"
+#include "medianode.h"
+#include <phonon/audiodataoutput.h>
+#include <phonon/audiodataoutputinterface.h>
+
+namespace Phonon
+{
+namespace Gstreamer
+{
+    /**
+     * \author Martin Sandsmark <sandsmark@samfundet.no>
+     */
+    class AudioDataOutput : public QObject,
+                            public AudioDataOutputInterface,
+                            public MediaNode
+    {
+        Q_OBJECT
+        Q_INTERFACES(Phonon::AudioDataOutputInterface Phonon::Gstreamer::MediaNode)
+
+        public:
+            AudioDataOutput(Backend *, QObject *);
+            ~AudioDataOutput();
+
+        public Q_SLOTS:
+            int dataSize() const;
+            int sampleRate() const;
+            void setDataSize(int size);
+
+        public:
+            /// callback function for handling new audio data
+            static void processBuffer(GstPad*, GstBuffer*, gpointer);
+
+            Phonon::AudioDataOutput* frontendObject() const { return m_frontend; }
+            void setFrontendObject(Phonon::AudioDataOutput *frontend) { m_frontend = frontend; }
+
+            GstElement *audioElement() { return m_queue; }
+
+            void mediaNodeEvent(const MediaNodeEvent *event);
+
+
+        signals:
+            void dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &data);
+            void dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<float> > &data);
+            void endOfMedia(int remainingSamples);
+
+        private:
+            void convertAndEmit(const QVector<qint16>&, const QVector<qint16>&);
+
+            GstElement *m_queue;
+            int m_dataSize;
+            QVector<qint16> m_pendingData;
+            Phonon::AudioDataOutput *m_frontend;
+            int m_channels;
+    };
+}} //namespace Phonon::Gstreamer
+
+// vim: sw=4 ts=4 tw=80
+#endif // Phonon_FAKE_AUDIODATAOUTPUT_H
diff --git a/src/3rdparty/phonon/gstreamer/audioeffect.cpp b/src/3rdparty/phonon/gstreamer/audioeffect.cpp
index d3d7a35..db72c8b 100644
--- a/src/3rdparty/phonon/gstreamer/audioeffect.cpp
+++ b/src/3rdparty/phonon/gstreamer/audioeffect.cpp
@@ -23,7 +23,7 @@
 #include "gsthelper.h"
 
 #include <gst/gst.h>
-#ifndef QT_NO_PHONON_EFFECT
+
 QT_BEGIN_NAMESPACE
 
 namespace Phonon
@@ -75,5 +75,4 @@ GstElement* AudioEffect::createEffectBin()
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_EFFECT
 #include "moc_audioeffect.cpp"
diff --git a/src/3rdparty/phonon/gstreamer/audioeffect.h b/src/3rdparty/phonon/gstreamer/audioeffect.h
index f49f8d2..3a985e5 100644
--- a/src/3rdparty/phonon/gstreamer/audioeffect.h
+++ b/src/3rdparty/phonon/gstreamer/audioeffect.h
@@ -29,8 +29,8 @@
 
 #include <gst/gst.h>
 
-#ifndef QT_NO_PHONON_EFFECT
 QT_BEGIN_NAMESPACE
+
 namespace Phonon
 {
 namespace Gstreamer
@@ -49,7 +49,7 @@ namespace Gstreamer
             QString m_effectName;
     };
 }} //namespace Phonon::Gstreamer
+
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_EFFECT
 
 #endif // Phonon_GSTREAMER_AUDIOEFFECT_H
diff --git a/src/3rdparty/phonon/gstreamer/audiooutput.cpp b/src/3rdparty/phonon/gstreamer/audiooutput.cpp
index 641ff6b..f3137b2 100644
--- a/src/3rdparty/phonon/gstreamer/audiooutput.cpp
+++ b/src/3rdparty/phonon/gstreamer/audiooutput.cpp
@@ -125,6 +125,7 @@ void AudioOutput::setVolume(qreal newVolume)
 bool AudioOutput::setOutputDevice(int newDevice)
 {
     m_backend->logMessage(Q_FUNC_INFO + QString::number(newDevice), Backend::Info, this);
+
     if (newDevice == m_device)
         return true;
 
@@ -135,20 +136,11 @@ bool AudioOutput::setOutputDevice(int newDevice)
     }
 
     bool success = false;
-    const QList<AudioDevice> deviceList = m_backend->deviceManager()->audioOutputDevices();
-    int deviceIdx = -1;
-    for (int i=0; i<deviceList.size(); i++) {
-        if (deviceList.at(i).id == newDevice) {
-            deviceIdx = i;
-            break;
-        }
-    }
-
-    if (m_audioSink && deviceIdx >= 0) {
+    if (m_audioSink &&  newDevice >= 0) {
         // Save previous state
         GstState oldState = GST_STATE(m_audioSink);
         const QByteArray oldDeviceValue = GstHelper::property(m_audioSink, "device");
-        const QByteArray deviceId = deviceList.at(deviceIdx).gstId;
+        const QByteArray deviceId = m_backend->deviceManager()->gstId(newDevice);
         m_device = newDevice;
 
         // We test if the device can be opened by checking if it can go from NULL to READY state
@@ -170,7 +162,7 @@ bool AudioOutput::setOutputDevice(int newDevice)
                                   deviceId, Backend::Info, this);
         }
 
-        // Note the stopped state should not really be neccessary, but seems to be required to 
+        // Note the stopped state should not really be necessary, but seems to be required to
         // properly reset after changing the audio state
         if (root()) {
             QMetaObject::invokeMethod(root(), "setState", Qt::QueuedConnection, Q_ARG(State, StoppedState));
diff --git a/src/3rdparty/phonon/gstreamer/backend.cpp b/src/3rdparty/phonon/gstreamer/backend.cpp
index dab6f35..1f07236 100644
--- a/src/3rdparty/phonon/gstreamer/backend.cpp
+++ b/src/3rdparty/phonon/gstreamer/backend.cpp
@@ -18,6 +18,7 @@
 #include "common.h"
 #include "backend.h"
 #include "audiooutput.h"
+#include "audiodataoutput.h"
 #include "audioeffect.h"
 #include "mediaobject.h"
 #include "videowidget.h"
@@ -26,6 +27,7 @@
 #include "message.h"
 #include "volumefadereffect.h"
 #include <gst/interfaces/propertyprobe.h>
+#include <phonon/pulsesupport.h>
 
 #include <QtCore/QSet>
 #include <QtCore/QVariant>
@@ -49,26 +51,28 @@ Backend::Backend(QObject *parent, const QVariantList &)
         , m_debugLevel(Warning)
         , m_isValid(false)
 {
+    // Initialise PulseAudio support
+    PulseSupport *pulse = PulseSupport::getInstance();
+    connect(pulse, SIGNAL(objectDescriptionChanged(ObjectDescriptionType)), SIGNAL(objectDescriptionChanged(ObjectDescriptionType)));
+
     // In order to support reloading, we only set the app name once...
     static bool first = true;
     if (first) {
         first = false;
         g_set_application_name(qApp->applicationName().toUtf8());
     }
-
     GError *err = 0;
     bool wasInit = gst_init_check(0, 0, &err);  //init gstreamer: must be called before any gst-related functions
     if (err)
         g_error_free(err);
 
     qRegisterMetaType<Message>("Message");
-#ifndef QT_NO_PROPERTIES
+
     setProperty("identifier",     QLatin1String("phonon_gstreamer"));
     setProperty("backendName",    QLatin1String("Gstreamer"));
     setProperty("backendComment", QLatin1String("Gstreamer plugin for Phonon"));
     setProperty("backendVersion", QLatin1String("0.2"));
-    setProperty("backendWebsite", QLatin1String("http://qt.nokia.com/"));
-#endif //QT_NO_PROPERTIES
+    setProperty("backendWebsite", QLatin1String("http://qtsoftware.com/"));
 
     //check if we should enable debug output
     QString debugLevelString = qgetenv("PHONON_GST_DEBUG");
@@ -92,6 +96,9 @@ Backend::Backend(QObject *parent, const QVariantList &)
 
 Backend::~Backend() 
 {
+    delete m_effectManager;
+    delete m_deviceManager;
+    PulseSupport::shutdown();
 }
 
 gboolean Backend::busCall(GstBus *bus, GstMessage *msg, gpointer data)
@@ -119,20 +126,15 @@ QObject *Backend::createObject(BackendInterface::Class c, QObject *parent, const
     case MediaObjectClass:
         return new MediaObject(this, parent);
 
-    case AudioOutputClass: {
-            AudioOutput *ao = new AudioOutput(this, parent);
-            m_audioOutputs.append(ao);
-            return ao;
-        }
-#ifndef QT_NO_PHONON_EFFECT
+    case AudioOutputClass:
+        return new AudioOutput(this, parent);
+
     case EffectClass:
         return new AudioEffect(this, args[0].toInt(), parent);
-#endif //QT_NO_PHONON_EFFECT
+
     case AudioDataOutputClass:
-        logMessage("createObject() : AudioDataOutput not implemented");
-        break;
+        return new AudioDataOutput(this, parent);
 
-#ifndef QT_NO_PHONON_VIDEO
     case VideoDataOutputClass:
         logMessage("createObject() : VideoDataOutput not implemented");
         break;
@@ -141,11 +143,9 @@ QObject *Backend::createObject(BackendInterface::Class c, QObject *parent, const
             QWidget *widget =  qobject_cast<QWidget*>(parent);
             return new VideoWidget(this, widget);
         }
-#endif //QT_NO_PHONON_VIDEO
-#ifndef QT_NO_PHONON_VOLUMEFADEREFFECT
+
     case VolumeFaderEffectClass:
         return new VolumeFaderEffect(this, parent);
-#endif //QT_NO_PHONON_VOLUMEFADEREFFECT
 
     case VisualizationClass:  //Fall through
     default:
@@ -214,14 +214,14 @@ QStringList Backend::availableMimeTypes() const
         GstPluginFeature *feature = GST_PLUGIN_FEATURE(iter->data);
         QString klass = gst_element_factory_get_klass(GST_ELEMENT_FACTORY(feature));
 
-        if (klass == QLatin1String("Codec/Decoder") ||
-            klass == QLatin1String("Codec/Decoder/Audio") ||
-            klass == QLatin1String("Codec/Decoder/Video") ||
-            klass == QLatin1String("Codec/Demuxer") ||
-            klass == QLatin1String("Codec/Demuxer/Audio") ||
-            klass == QLatin1String("Codec/Demuxer/Video") ||
-            klass == QLatin1String("Codec/Parser") ||
-            klass == QLatin1String("Codec/Parser/Audio") ||
+        if (klass == QLatin1String("Codec/Decoder") || 
+            klass == QLatin1String("Codec/Decoder/Audio") || 
+            klass == QLatin1String("Codec/Decoder/Video") || 
+            klass == QLatin1String("Codec/Demuxer") || 
+            klass == QLatin1String("Codec/Demuxer/Audio") || 
+            klass == QLatin1String("Codec/Demuxer/Video") || 
+            klass == QLatin1String("Codec/Parser") || 
+            klass == QLatin1String("Codec/Parser/Audio") || 
             klass == QLatin1String("Codec/Parser/Video")) {
 
             const GList *static_templates;
@@ -244,6 +244,15 @@ QStringList Backend::availableMimeTypes() const
         }
     }
     g_list_free(factoryList);
+    if (availableMimeTypes.contains("audio/x-vorbis")
+        && availableMimeTypes.contains("application/x-ogm-audio")) {
+        if (!availableMimeTypes.contains("audio/x-vorbis+ogg"))
+            availableMimeTypes.append("audio/x-vorbis+ogg");
+        if (!availableMimeTypes.contains("application/ogg"))  /* *.ogg */
+            availableMimeTypes.append("application/ogg");
+        if (!availableMimeTypes.contains("audio/ogg")) /* *.oga */
+            availableMimeTypes.append("audio/ogg");
+    }
     availableMimeTypes.sort();
     return availableMimeTypes;
 }
@@ -258,6 +267,10 @@ QList<int> Backend::objectDescriptionIndexes(ObjectDescriptionType type) const
     if (!isValid())
         return list;
 
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive() && (Phonon::AudioOutputDeviceType == type || Phonon::AudioCaptureDeviceType == type))
+        return pulse->objectDescriptionIndexes(type);
+
     switch (type) {
     case Phonon::AudioOutputDeviceType: {
             QList<AudioDevice> deviceList = deviceManager()->audioOutputDevices();
@@ -291,16 +304,17 @@ QHash<QByteArray, QVariant> Backend::objectDescriptionProperties(ObjectDescripti
     if (!isValid())
         return ret;
 
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive() && (Phonon::AudioOutputDeviceType == type || Phonon::AudioCaptureDeviceType == type))
+        return pulse->objectDescriptionProperties(type, index);
+
     switch (type) {
     case Phonon::AudioOutputDeviceType: {
-            QList<AudioDevice> audioDevices = deviceManager()->audioOutputDevices();
-            foreach(const AudioDevice &device, audioDevices) {
-                if (device.id == index) {
-                    ret.insert("name", device.gstId);
-                    ret.insert("description", device.description);
-                    ret.insert("icon", QLatin1String("audio-card"));
-                    break;
-                }
+            AudioDevice* ad;
+            if ((ad = deviceManager()->audioDevice(index))) {
+                ret.insert("name", ad->gstId);
+                ret.insert("description", ad->description);
+                ret.insert("icon", ad->icon);
             }
         }
         break;
@@ -429,7 +443,7 @@ EffectManager* Backend::effectManager() const
 
 /**
  * Returns a debuglevel that is determined by the
- * PHONON_GSTREAMER_DEBUG environment variable.
+ * PHONON_GST_DEBUG environment variable.
  *
  *  Warning - important warnings
  *  Info    - general info
diff --git a/src/3rdparty/phonon/gstreamer/backend.h b/src/3rdparty/phonon/gstreamer/backend.h
index 2aab6fa..d157f11 100644
--- a/src/3rdparty/phonon/gstreamer/backend.h
+++ b/src/3rdparty/phonon/gstreamer/backend.h
@@ -86,7 +86,6 @@ private Q_SLOTS:
 
 private:
     static gboolean busCall(GstBus *bus, GstMessage *msg, gpointer data);
-    QList<QPointer<AudioOutput> > m_audioOutputs;
 
     DeviceManager *m_deviceManager;
     EffectManager *m_effectManager;
diff --git a/src/3rdparty/phonon/gstreamer/devicemanager.cpp b/src/3rdparty/phonon/gstreamer/devicemanager.cpp
index 60e860f..e62d281 100644
--- a/src/3rdparty/phonon/gstreamer/devicemanager.cpp
+++ b/src/3rdparty/phonon/gstreamer/devicemanager.cpp
@@ -24,6 +24,7 @@
 #include "widgetrenderer.h"
 #include "x11renderer.h"
 #include "artssink.h"
+#include "pulsesupport.h"
 
 #ifdef USE_ALSASINK2
 #include "alsasink2.h"
@@ -44,9 +45,12 @@ namespace Gstreamer
 AudioDevice::AudioDevice(DeviceManager *manager, const QByteArray &gstId)
         : gstId(gstId)
 {
-    //get an id
-    static int counter = 0;
-    id = counter++;
+    // This should never be called when PulseAudio is active.
+    Q_ASSERT(!PulseSupport::getInstance()->isActive());
+
+    id = manager->allocateDeviceId();
+    icon = "audio-card";
+
     //get name from device
     if (gstId == "default") {
         description = "Default audio device";
@@ -71,22 +75,25 @@ AudioDevice::AudioDevice(DeviceManager *manager, const QByteArray &gstId)
 DeviceManager::DeviceManager(Backend *backend)
         : QObject(backend)
         , m_backend(backend)
+        , m_audioDeviceCounter(0)
 {
-    m_audioSink = qgetenv("PHONON_GST_AUDIOSINK");
-    m_videoSinkWidget = qgetenv("PHONON_GST_VIDEOMODE");
-
-#ifndef QT_NO_SETTINGS
     QSettings settings(QLatin1String("Trolltech"));
     settings.beginGroup(QLatin1String("Qt"));
 
+    PulseSupport *pulse = PulseSupport::getInstance();
+    m_audioSink = qgetenv("PHONON_GST_AUDIOSINK");
     if (m_audioSink.isEmpty()) {
         m_audioSink = settings.value(QLatin1String("audiosink"), "Auto").toByteArray().toLower();
+        if (m_audioSink == "auto" && pulse->isActive())
+            m_audioSink = "pulsesink";
     }
+    if ("pulsesink" != m_audioSink)
+        pulse->disable();
 
+    m_videoSinkWidget = qgetenv("PHONON_GST_VIDEOMODE");
     if (m_videoSinkWidget.isEmpty()) {
         m_videoSinkWidget = settings.value(QLatin1String("videomode"), "Auto").toByteArray().toLower();
     }
-#endif //QT_NO_SETTINGS
 
     if (m_backend->isValid())
         updateDeviceList();
@@ -246,7 +253,6 @@ GstElement *DeviceManager::createAudioSink(Category category)
     return sink;
 }
 
-#ifndef QT_NO_PHONON_VIDEO
 AbstractRenderer *DeviceManager::createVideoRenderer(VideoWidget *parent)
 {
 #if !defined(QT_NO_OPENGL) && !defined(QT_OPENGL_ES)
@@ -269,11 +275,18 @@ AbstractRenderer *DeviceManager::createVideoRenderer(VideoWidget *parent)
 #endif
     return new WidgetRenderer(parent);
 }
-#endif //QT_NO_PHONON_VIDEO
 
-/*
- * Returns a positive device id or -1 if device
- * does not exist
+/**
+ * Allocate a device id for a new audio device
+ */
+int DeviceManager::allocateDeviceId()
+{
+    return m_audioDeviceCounter++;
+}
+
+
+/**
+ * Returns a positive device id or -1 if device does not exist
  *
  * The gstId is typically in the format hw:1,0
  */
@@ -288,16 +301,30 @@ int DeviceManager::deviceId(const QByteArray &gstId) const
 }
 
 /**
- * Get a human-readable description from a device id
+ * Returns a gstId or "default" if device does not exist
+ *
+ * The gstId is typically in the format hw:1,0
  */
-QByteArray DeviceManager::deviceDescription(int id) const
+const QByteArray DeviceManager::gstId(int deviceId)
+{
+    if (!PulseSupport::getInstance()->isActive()) {
+        AudioDevice *ad = audioDevice(deviceId);
+        if (ad)
+            return QByteArray(ad->gstId);
+    }
+    return QByteArray("default");
+}
+
+/**
+* Get the AudioDevice for a given device id
+*/
+AudioDevice* DeviceManager::audioDevice(int id)
 {
     for (int i = 0 ; i < m_audioDeviceList.size() ; ++i) {
-        if (m_audioDeviceList[i].id == id) {
-            return m_audioDeviceList[i].description;
-        }
+        if (m_audioDeviceList[i].id == id)
+            return &m_audioDeviceList[i];
     }
-    return QByteArray();
+    return NULL;
 }
 
 /**
@@ -311,8 +338,11 @@ void DeviceManager::updateDeviceList()
     QList<QByteArray> list;
 
     if (audioSink) {
-        list = GstHelper::extractProperties(audioSink, "device");
-        list.prepend("default");
+        if (!PulseSupport::getInstance()->isActive()) {
+            // If we're using pulse, the PulseSupport class takes care of things for us.
+            list = GstHelper::extractProperties(audioSink, "device");
+            list.prepend("default");
+        }
 
         for (int i = 0 ; i < list.size() ; ++i) {
             QByteArray gstId = list.at(i);
diff --git a/src/3rdparty/phonon/gstreamer/devicemanager.h b/src/3rdparty/phonon/gstreamer/devicemanager.h
index a5e8289..9c6aa8d 100644
--- a/src/3rdparty/phonon/gstreamer/devicemanager.h
+++ b/src/3rdparty/phonon/gstreamer/devicemanager.h
@@ -42,6 +42,7 @@ public :
     int id;
     QByteArray gstId;
     QByteArray description;
+    QString icon;
 };
 
 class DeviceManager : public QObject {
@@ -51,8 +52,10 @@ public:
     virtual ~DeviceManager();
     const QList<AudioDevice> audioOutputDevices() const;
     GstPad *requestPad(int device) const;
+    int allocateDeviceId();
     int deviceId(const QByteArray &gstId) const;
-    QByteArray deviceDescription(int id) const;
+    const QByteArray gstId(int id);
+    AudioDevice* audioDevice(int id);
     GstElement *createGNOMEAudioSink(Category category);
     GstElement *createAudioSink(Category category = NoCategory);
     AbstractRenderer *createVideoRenderer(VideoWidget *parent);
@@ -68,6 +71,7 @@ private:
     bool canOpenDevice(GstElement *element) const;
     Backend *m_backend;
     QList <AudioDevice> m_audioDeviceList;
+    int m_audioDeviceCounter;
     QTimer m_devicePollTimer;
     QByteArray m_audioSink;
     QByteArray m_videoSinkWidget;
diff --git a/src/3rdparty/phonon/gstreamer/effect.cpp b/src/3rdparty/phonon/gstreamer/effect.cpp
index 4937246..f653535 100644
--- a/src/3rdparty/phonon/gstreamer/effect.cpp
+++ b/src/3rdparty/phonon/gstreamer/effect.cpp
@@ -25,8 +25,8 @@
 
 #include <gst/gst.h>
 
-#ifndef QT_NO_PHONON_EFFECT
 QT_BEGIN_NAMESPACE
+
 namespace Phonon
 {
 namespace Gstreamer
@@ -241,6 +241,6 @@ void Effect::setParameterValue(const EffectParameter &p, const QVariant &v)
 
 }
 } //namespace Phonon::Gstreamer
+
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_EFFECT
 #include "moc_effect.cpp"
diff --git a/src/3rdparty/phonon/gstreamer/effect.h b/src/3rdparty/phonon/gstreamer/effect.h
index 51cbe9c..dbbb457 100644
--- a/src/3rdparty/phonon/gstreamer/effect.h
+++ b/src/3rdparty/phonon/gstreamer/effect.h
@@ -28,8 +28,8 @@
 
 #include <gst/gst.h>
 
-#ifndef QT_NO_PHONON_EFFECT
 QT_BEGIN_NAMESPACE
+
 namespace Phonon
 {
 namespace Gstreamer
@@ -58,7 +58,7 @@ namespace Gstreamer
             QList<Phonon::EffectParameter> m_parameterList;
     };
 }} //namespace Phonon::Gstreamer
+
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_EFFECT
 
 #endif // Phonon_GSTREAMER_EFFECT_H
diff --git a/src/3rdparty/phonon/gstreamer/effectmanager.cpp b/src/3rdparty/phonon/gstreamer/effectmanager.cpp
index 563e6fc..6c88148 100644
--- a/src/3rdparty/phonon/gstreamer/effectmanager.cpp
+++ b/src/3rdparty/phonon/gstreamer/effectmanager.cpp
@@ -54,7 +54,7 @@ EffectManager::EffectManager(Backend *backend)
             // "volume" not needed
             // "equalizer-nbands" not really useful at the moment
 
-            // These plugins simply dont work or have major stability issues:
+            // These plugins simply don't work or have major stability issues:
             // "iir" Does not seem to do much at the moment
             // "audioinvert" Only works for some streams, should be invesigated
             // "lpwsinc" Crashes for large values of filter kernel
diff --git a/src/3rdparty/phonon/gstreamer/glrenderer.cpp b/src/3rdparty/phonon/gstreamer/glrenderer.cpp
index 6cf3459..c72780a 100644
--- a/src/3rdparty/phonon/gstreamer/glrenderer.cpp
+++ b/src/3rdparty/phonon/gstreamer/glrenderer.cpp
@@ -266,7 +266,7 @@ GLRenderWidgetImplementation::GLRenderWidgetImplementation(VideoWidget*videoWidg
     palette.setColor(QPalette::Background, Qt::black);
     setPalette(palette);
     setAutoFillBackground(true);
-    // Videowidget allways have this property to allow hiding the mouse cursor
+    // Videowidget always have this property to allow hiding the mouse cursor
     setMouseTracking(true);
 }
 
diff --git a/src/3rdparty/phonon/gstreamer/gstreamer.desktop b/src/3rdparty/phonon/gstreamer/gstreamer.desktop
index b62472b..0861762 100644
--- a/src/3rdparty/phonon/gstreamer/gstreamer.desktop
+++ b/src/3rdparty/phonon/gstreamer/gstreamer.desktop
@@ -10,28 +10,81 @@ Icon=phonon-gstreamer
 InitialPreference=10
 
 Name=GStreamer
+Name[bg]=GStreamer
+Name[ca]=GStreamer
+Name[ca@valencia]=GStreamer
+Name[cs]=GStreamer
+Name[da]=GStreamer
+Name[de]=GStreamer
+Name[el]=GStreamer
+Name[en_GB]=GStreamer
+Name[es]=GStreamer
+Name[et]=GStreamer
+Name[eu]=GStreamer
+Name[fi]=GStreamer
+Name[fr]=GStreamer
+Name[ga]=GStreamer
+Name[gl]=GStreamer
+Name[hsb]=GStreamer
+Name[hu]=GStreamer
+Name[id]=GStreamer
+Name[is]=GStreamer
+Name[it]=GStreamer
+Name[ja]=GStreamer
+Name[ko]=GStreamer
+Name[ku]=GStreamer
+Name[lt]=GStreamer
+Name[lv]=GStreamer
+Name[nb]=GStreamer
+Name[nds]=GStreamer
+Name[nl]=GStreamer
+Name[nn]=GStreamer
 Name[pa]=ਜੀਸਟੀਰਮਰ
+Name[pl]=GStreamer
+Name[pt]=GStreamer
+Name[pt_BR]=GStreamer
+Name[ru]=GStreamer
+Name[se]=GStreamer
+Name[sk]=GStreamer
+Name[sl]=GStreamer
 Name[sr]=Гстример
+Name[sr@ijekavian]=Гстример
+Name[sr@ijekavianlatin]=GStreamer
+Name[sr@latin]=GStreamer
 Name[sv]=Gstreamer
+Name[tr]=GStreamer
+Name[uk]=GStreamer
 Name[x-test]=xxGStreamerxx
+Name[zh_CN]=GStreamer
+Name[zh_TW]=GStreamer
 
 Comment=Phonon GStreamer backend
 Comment[bg]=Phonon GStreamer
 Comment[ca]=Dorsal GStreamer del Phonon
+Comment[ca@valencia]=Dorsal GStreamer del Phonon
+Comment[cs]=Phonon GStreamer backend
 Comment[da]=GStreamer-backend til Phonon
 Comment[de]=Phonon-Treiber für GStreamer
 Comment[el]=Σύστημα υποστήριξης GStreamer του Phonon
+Comment[en_GB]=Phonon GStreamer backend
 Comment[es]=Motor GStreamer para Phonon
 Comment[et]=Phononi GStreameri taustaprogramm
+Comment[eu]=Phonon GStreamer backend
+Comment[fi]=Phonon GStreamer-taustaohjelma
 Comment[fr]=Système de gestion GStreamer pour Phonon 
 Comment[ga]=Inneall GStreamer le haghaidh Phonon
 Comment[gl]=Infraestrutura de GStreamer para Phonon
+Comment[hsb]=Phonon GStreamer backend
+Comment[hu]=Phonon GStreamer modul
+Comment[id]=Phonon GStreamer backend
 Comment[is]=Phonon GStreamer bakendi
 Comment[it]=Motore Gstreamer di Phonon
 Comment[ja]=Phonon GStreamer バックエンド
 Comment[ko]=Phonon GStreamer 백엔드
 Comment[ku]=Binesaza Phonon GStreamer
+Comment[lt]=Phonon GStreamer galinė sąsaja
 Comment[lv]=Phonon GStreamer aizmugure
+Comment[nb]=Phonon-motor for GStreamer
 Comment[nds]=Phonon-Hülpprogramm GStreamer
 Comment[nl]=GStreamer-backend (Phonon)
 Comment[nn]=Phonon-motor for GStreamer
@@ -39,9 +92,13 @@ Comment[pa]=ਫੋਨੋਨ ਜਸਟੀਰਮਰ ਬੈਕਐਂਡ
 Comment[pl]=Obsługa GStreamera przez Phonon
 Comment[pt]=Infra-estrutura do GStreamer para o Phonon
 Comment[pt_BR]=Infraestrutura Phonon GStreamer
+Comment[ru]=Механизм GStreamer для Phonon
+Comment[se]=Phonon GStreamer duogášmohtor
 Comment[sk]=GStreamer podsystém
 Comment[sl]=Phononova hrbtenica GStreamer
 Comment[sr]=Гстример као позадина Фонона
+Comment[sr@ijekavian]=Гстример као позадина Фонона
+Comment[sr@ijekavianlatin]=GStreamer kao pozadina Phonona
 Comment[sr@latin]=GStreamer kao pozadina Phonona
 Comment[sv]=Phonon Gstreamer-gränssnitt
 Comment[tr]=Phonon GStreamer arka ucu
diff --git a/src/3rdparty/phonon/gstreamer/medianode.cpp b/src/3rdparty/phonon/gstreamer/medianode.cpp
index 7257972..1a84592 100644
--- a/src/3rdparty/phonon/gstreamer/medianode.cpp
+++ b/src/3rdparty/phonon/gstreamer/medianode.cpp
@@ -198,9 +198,9 @@ bool MediaNode::disconnectNode(QObject *obj)
         // Disconnecting elements while playing or paused seems to cause
         // potential deadlock. Hence we force the pipeline into ready state
         // before any nodes are disconnected.
-        gst_element_set_state(root()->pipeline(), GST_STATE_READY);    
+        gst_element_set_state(root()->pipeline(), GST_STATE_READY);
 
-        Q_ASSERT(sink->root()); //sink has to have a root since it is onnected
+        Q_ASSERT(sink->root()); //sink has to have a root since it is connected
 
         if (sink->description() & (AudioSink)) {
             GstPad *sinkPad = gst_element_get_pad(sink->audioElement(), "sink");
diff --git a/src/3rdparty/phonon/gstreamer/mediaobject.cpp b/src/3rdparty/phonon/gstreamer/mediaobject.cpp
index b6d23ec..11b67b5 100644
--- a/src/3rdparty/phonon/gstreamer/mediaobject.cpp
+++ b/src/3rdparty/phonon/gstreamer/mediaobject.cpp
@@ -16,6 +16,7 @@
 */
 #include <cmath>
 #include <gst/interfaces/propertyprobe.h>
+#include <gst/pbutils/install-plugins.h>
 #include "common.h"
 #include "mediaobject.h"
 #include "videowidget.h"
@@ -23,6 +24,7 @@
 #include "backend.h"
 #include "streamreader.h"
 #include "phononsrc.h"
+#include "phonon-config-gstreamer.h"
 #include <QtCore>
 #include <QtCore/QTimer>
 #include <QtCore/QVector>
@@ -53,6 +55,7 @@ MediaObject::MediaObject(Backend *backend, QObject *parent)
         , m_tickTimer(new QTimer(this))
         , m_prefinishMark(0)
         , m_transitionTime(0)
+        , m_isStream(false)
         , m_posAtSeek(-1)
         , m_prefinishMarkReachedNotEmitted(true)
         , m_aboutToFinishEmitted(false)
@@ -79,6 +82,7 @@ MediaObject::MediaObject(Backend *backend, QObject *parent)
         , m_autoplayTitles(true)
         , m_availableTitles(0)
         , m_currentTitle(1)
+        , m_pendingTitle(1)
 {
     qRegisterMetaType<GstCaps*>("GstCaps*");
     qRegisterMetaType<State>("State");
@@ -87,7 +91,7 @@ MediaObject::MediaObject(Backend *backend, QObject *parent)
     m_name = "MediaObject" + QString::number(count++);
 
     if (!m_backend->isValid()) {
-        setError(tr("Cannot start playback. \n\nCheck your GStreamer installation and make sure you "
+        setError(tr("Cannot start playback. \n\nCheck your Gstreamer installation and make sure you "
                     "\nhave libgstreamer-plugins-base installed."), Phonon::FatalError);
     } else {
         m_root = this;
@@ -95,8 +99,8 @@ MediaObject::MediaObject(Backend *backend, QObject *parent)
         m_backend->addBusWatcher(this);
         connect(m_tickTimer, SIGNAL(timeout()), SLOT(emitTick()));
     }
-    connect(this, SIGNAL(stateChanged(Phonon::State,Phonon::State)), 
-            this, SLOT(notifyStateChange(Phonon::State,Phonon::State)));
+    connect(this, SIGNAL(stateChanged(Phonon::State, Phonon::State)),
+            this, SLOT(notifyStateChange(Phonon::State, Phonon::State)));
 
 }
 
@@ -136,6 +140,14 @@ QString stateString(const Phonon::State &state)
     return QString();
 }
 
+void
+pluginInstallationDone( GstInstallPluginsReturn res, gpointer userData )
+{
+    // Nothing inside yet
+    Q_UNUSED(res);
+    Q_UNUSED(userData);
+}
+
 void MediaObject::saveState()
 {
     //Only first resumeState is respected
@@ -195,13 +207,35 @@ void MediaObject::noMorePadsAvailable ()
     if (m_missingCodecs.size() > 0) {
         bool canPlay = (m_hasAudio || m_videoStreamFound);
         Phonon::ErrorType error = canPlay ? Phonon::NormalError : Phonon::FatalError;
+#ifdef PLUGIN_INSTALL_API
+        GstInstallPluginsContext *ctx = gst_install_plugins_context_new ();
+        gchar *details[2];
+        details[0] = m_missingCodecs[0].toLocal8Bit().data();
+        details[1] = NULL;
+        GstInstallPluginsReturn status;
+
+        status = gst_install_plugins_async( details, ctx, pluginInstallationDone, NULL );
+        gst_install_plugins_context_free ( ctx );
+
+        if ( status != GST_INSTALL_PLUGINS_STARTED_OK )
+        {
+            if( status == GST_INSTALL_PLUGINS_HELPER_MISSING )
+                setError(QString(tr("Missing codec helper script assistant.")), Phonon::FatalError );
+            else
+                setError(QString(tr("Plugin codec installation failed for codec: %0"))
+                        .arg(m_missingCodecs[0].split("|")[3]), error);
+        }
+        m_missingCodecs.clear();
+#else
+        QString codecs = m_missingCodecs.join(", ");
+
         if (error == Phonon::NormalError && m_hasVideo && !m_videoStreamFound) {
             m_hasVideo = false;
             emit hasVideoChanged(false);
         }
-        QString codecs = m_missingCodecs.join(", ");
         setError(QString(tr("A required codec is missing. You need to install the following codec(s) to play this content: %0")).arg(codecs), error);
         m_missingCodecs.clear();
+#endif
     }
 }
 
@@ -226,7 +260,6 @@ void MediaObject::cb_unknown_type (GstElement *decodebin, GstPad *pad, GstCaps *
     QString value = "unknown codec";
 
     // These functions require GStreamer > 0.10.12
-#ifndef QT_NO_LIBRARY
     static Ptr_gst_pb_utils_init p_gst_pb_utils_init = 0;
     static Ptr_gst_pb_utils_get_codec_description p_gst_pb_utils_get_codec_description = 0;
     if (!p_gst_pb_utils_init) {
@@ -240,15 +273,21 @@ void MediaObject::cb_unknown_type (GstElement *decodebin, GstPad *pad, GstCaps *
         codecName = p_gst_pb_utils_get_codec_description (caps);
         value = QString::fromUtf8(codecName);
         g_free (codecName);
-    } else
-#endif //QT_NO_LIBRARY
-    {
+    } else {
         // For GStreamer versions < 0.10.12
         GstStructure *str = gst_caps_get_structure (caps, 0);
         value = QString::fromUtf8(gst_structure_get_name (str));
-
     }
-    media->addMissingCodecName(value);
+
+#ifdef PLUGIN_INSTALL_API
+    QString plugins = QString("gstreamer|0.10|%0|%1|decoder-%2")
+        .arg( qApp->applicationName() )
+        .arg( value )
+        .arg( QString::fromUtf8(gst_caps_to_string (caps) ) );
+    media->addMissingCodecName( plugins );
+#else
+    media->addMissingCodecName( value );
+#endif
 }
 
 static void notifyVideoCaps(GObject *obj, GParamSpec *, gpointer data)
@@ -309,7 +348,7 @@ void MediaObject::connectVideo(GstPad *pad)
             m_backend->logMessage("Video track connected", Backend::Info, this);
             // Note that the notify::caps _must_ be installed after linking to work with Dapper
             m_capsHandler = g_signal_connect(pad, "notify::caps", G_CALLBACK(notifyVideoCaps), this);
- 
+
             if (!m_loading && !m_hasVideo) {
                 m_hasVideo = m_videoStreamFound;
                 emit hasVideoChanged(m_hasVideo);
@@ -368,7 +407,10 @@ bool MediaObject::createPipefromURL(const QUrl &url)
     }
 
     // Create a new datasource based on the input URL
-    QByteArray encoded_cstr_url = url.toEncoded();
+    // add the 'file' scheme if it's missing; the double '/' is needed!
+    QByteArray encoded_cstr_url = (url.scheme() == QLatin1String("") ?
+                    "file://" + url.toEncoded() :
+                    url.toEncoded());
     m_datasource = gst_element_make_from_uri(GST_URI_SRC, encoded_cstr_url.constData(), (const char*)NULL);
     if (!m_datasource)
         return false;
@@ -388,6 +430,14 @@ bool MediaObject::createPipefromURL(const QUrl &url)
             g_object_set (G_OBJECT (m_datasource), "read-speed", 2, (const char*)NULL);
             m_backend->logMessage(QString("new device speed : 2X"), Backend::Info, this);
         }
+  }
+
+    /* make HTTP sources send extra headers so we get icecast
+     * metadata in case the stream is an icecast stream */
+    if (encoded_cstr_url.startsWith("http://")
+        && g_object_class_find_property (G_OBJECT_GET_CLASS (m_datasource), "iradio-mode")) {
+        g_object_set (m_datasource, "iradio-mode", TRUE, NULL);
+        m_isStream = true;
     }
 
     // Link data source into pipeline
@@ -408,7 +458,6 @@ bool MediaObject::createPipefromURL(const QUrl &url)
  */
 bool MediaObject::createPipefromStream(const MediaSource &source)
 {
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     // Remove any existing data source
     if (m_datasource) {
         gst_bin_remove(GST_BIN(m_pipeline), m_datasource);
@@ -430,10 +479,6 @@ bool MediaObject::createPipefromStream(const MediaSource &source)
         return false;
     }
     return true;
-#else //QT_NO_PHONON_ABSTRACTMEDIASTREAM
-    Q_UNUSED(source);
-    return false;
-#endif
 }
 
 void MediaObject::createPipeline()
@@ -646,7 +691,7 @@ void MediaObject::setState(State newstate)
             m_backend->logMessage("EOS already reached", Backend::Info, this);
         } else if (currentState == GST_STATE_PLAYING) {
             changeState(Phonon::PlayingState);
-        } else if (!m_atEndOfStream && gst_element_set_state(m_pipeline, GST_STATE_PLAYING) != GST_STATE_CHANGE_FAILURE) {
+        } else if (gst_element_set_state(m_pipeline, GST_STATE_PLAYING) != GST_STATE_CHANGE_FAILURE) {
             m_pendingState = Phonon::PlayingState;
         } else {
             m_backend->logMessage("phonon state request failed", Backend::Info, this);
@@ -676,7 +721,7 @@ void MediaObject::changeState(State newstate)
         return;
 
     Phonon::State oldState = m_state;
-    m_state = newstate; // m_state must be set before emitting, since 
+    m_state = newstate; // m_state must be set before emitting, since
                         // Error state requires that state() will return the new value
     m_pendingState = newstate;
     emit stateChanged(newstate, oldState);
@@ -696,6 +741,8 @@ void MediaObject::changeState(State newstate)
 
     case Phonon::StoppedState:
         m_backend->logMessage("phonon state changed: Stopped", Backend::Info, this);
+        // We must reset the pipeline when playing again
+        m_resetNeeded = true;
         m_tickTimer->stop();
         break;
 
@@ -861,7 +908,7 @@ void MediaObject::setSource(const MediaSource &source)
     // such as failing duration queries etc
     GstState state;
     gst_element_set_state(m_pipeline, GST_STATE_NULL);
-    gst_element_get_state (m_pipeline, &state, NULL, 2000);
+    gst_element_get_state(m_pipeline, &state, NULL, 2000);
 
     m_source = source;
     emit currentSourceChanged(m_source);
@@ -871,7 +918,9 @@ void MediaObject::setSource(const MediaSource &source)
     // Go into to loading state
     changeState(Phonon::LoadingState);
     m_loading = true;
-    m_resetNeeded = false;
+    // IMPORTANT: Honor the m_resetNeeded flag as it currently stands.
+    // See https://qa.mandriva.com/show_bug.cgi?id=56807
+    //m_resetNeeded = false;
     m_resumeState = false;
     m_pendingState = Phonon::StoppedState;
 
@@ -884,8 +933,8 @@ void MediaObject::setSource(const MediaSource &source)
     // Clear any existing errors
     m_aboutToFinishEmitted = false;
     m_error = NoError;
-    m_errorString = QString();
-    
+    m_errorString.clear();
+
     m_bufferPercent = 0;
     m_prefinishMarkReachedNotEmitted = true;
     m_aboutToFinishEmitted = false;
@@ -894,22 +943,23 @@ void MediaObject::setSource(const MediaSource &source)
     setTotalTime(-1);
     m_atEndOfStream = false;
 
-    // Clear exising meta tags
+    m_availableTitles = 0;
+    m_pendingTitle = 1;
+    m_currentTitle = 1;
+
+    // Clear existing meta tags
     m_metaData.clear();
+    m_isStream = false;
 
     switch (source.type()) {
-    case MediaSource::Url: {            
-            if (createPipefromURL(source.url()))
-                m_loading = true;
-            else
+    case MediaSource::Url: {
+            if (!createPipefromURL(source.url()))
                 setError(tr("Could not open media source."));
         }
         break;
 
     case MediaSource::LocalFile: {
-            if (createPipefromURL(QUrl::fromLocalFile(source.fileName())))
-                m_loading = true;
-            else
+            if (!createPipefromURL(QUrl::fromLocalFile(source.fileName())))
                 setError(tr("Could not open media source."));
         }
         break;
@@ -922,17 +972,15 @@ void MediaObject::setSource(const MediaSource &source)
         break;
 
     case MediaSource::Stream:
-        if (createPipefromStream(source))
-            m_loading = true;
-        else
+        if (!createPipefromStream(source))
             setError(tr("Could not open media source."));
         break;
 
     case MediaSource::Disc:
         {
-            QString mediaUrl;
-            switch (source.discType()) {
-            case Phonon::NoDisc:
+       QString mediaUrl;
+       switch (source.discType()) {
+       case Phonon::NoDisc:
                 qWarning() << "I should never get to see a MediaSource that is a disc but doesn't specify which one";
                 return;
             case Phonon::Cd:  // CD tracks can be specified by setting the url in the following way uri=cdda:4
@@ -948,9 +996,7 @@ void MediaObject::setSource(const MediaSource &source)
                 qWarning() <<  "media " << source.discType() << " not implemented";
                 return;
             }
-            if (!mediaUrl.isEmpty() && createPipefromURL(QUrl(mediaUrl)))
-                m_loading = true;
-            else
+            if (mediaUrl.isEmpty() || !createPipefromURL(QUrl(mediaUrl)))
                 setError(tr("Could not open media source."));
         }
         break;
@@ -966,8 +1012,7 @@ void MediaObject::setSource(const MediaSource &source)
 
     // We need to link this node to ensure that fake sinks are connected
     // before loading, otherwise the stream will be blocked
-    if (m_loading)
-        link();
+    link();
     beginLoad();
 }
 
@@ -1004,13 +1049,10 @@ void MediaObject::getStreamInfo()
         emit hasVideoChanged(m_hasVideo);
     }
 
-    m_availableTitles = 1;
-    gint64 titleCount;
-    GstFormat format = gst_format_get_by_nick("track");
-    if (gst_element_query_duration (m_pipeline, &format, &titleCount)) {
-        //check if returned format is still "track",
-        //gstreamer sometimes returns the total time, if tracks information is not available.
-        if (qstrcmp(gst_format_get_name(format), "track") == 0)  {
+    if (m_source.discType() == Phonon::Cd) {
+        gint64 titleCount;
+        GstFormat format = gst_format_get_by_nick("track");
+        if (gst_element_query_duration (m_pipeline, &format, &titleCount)) {
             int oldAvailableTitles = m_availableTitles;
             m_availableTitles = (int)titleCount;
             if (m_availableTitles != oldAvailableTitles) {
@@ -1077,7 +1119,7 @@ void MediaObject::seek(qint64 time)
         }
 
         quint64 current = currentTime();
-        quint64 total = totalTime(); 
+        quint64 total = totalTime();
 
         if (current < total - m_prefinishMark)
             m_prefinishMarkReachedNotEmitted = true;
@@ -1098,7 +1140,7 @@ void MediaObject::emitTick()
 
     if (m_tickInterval > 0 && currentTime != m_previousTickTime) {
         emit tick(currentTime);
-        m_previousTickTime = currentTime;        
+        m_previousTickTime = currentTime;
     }
     if (m_state == Phonon::PlayingState) {
         if (currentTime >= totalTime - m_prefinishMark) {
@@ -1109,7 +1151,12 @@ void MediaObject::emitTick()
         }
         // Prepare load of next source
         if (currentTime >= totalTime - ABOUT_TO_FINNISH_TIME) {
-            if (!m_aboutToFinishEmitted) {
+            if (m_source.type() == MediaSource::Disc &&
+                m_autoplayTitles &&
+                m_availableTitles > 1 &&
+                m_currentTitle < m_availableTitles) {
+                m_aboutToFinishEmitted = false;
+            } else if (!m_aboutToFinishEmitted) {
                 m_aboutToFinishEmitted = true; // track is about to finish
                 emit aboutToFinish();
             }
@@ -1213,8 +1260,8 @@ void MediaObject::handleBusMessage(const Message &message)
 
     switch (GST_MESSAGE_TYPE (gstMessage)) {
 
-    case GST_MESSAGE_EOS: 
-        m_backend->logMessage("EOS recieved", Backend::Info, this);
+    case GST_MESSAGE_EOS:
+        m_backend->logMessage("EOS received", Backend::Info, this);
         handleEndOfStream();
         break;
 
@@ -1222,14 +1269,98 @@ void MediaObject::handleBusMessage(const Message &message)
             GstTagList* tag_list = 0;
             gst_message_parse_tag(gstMessage, &tag_list);
             if (tag_list) {
+                TagMap newTags;
+                gst_tag_list_foreach (tag_list, &foreach_tag_function, &newTags);
+                gst_tag_list_free(tag_list);
+
+                // Determine if we should no fake the album/artist tags.
+                // This is a little confusing as we want to fake it on initial
+                // connection where title, album and artist are all missing.
+                // There are however times when we get just other information,
+                // e.g. codec, and so we want to only do clever stuff if we
+                // have a commonly available tag (ORGANIZATION) or we have a
+                // change in title
+                bool fake_it =
+                   (m_isStream
+                    && ((!newTags.contains("TITLE")
+                         && newTags.contains("ORGANIZATION"))
+                        || (newTags.contains("TITLE")
+                            && m_metaData.value("TITLE") != newTags.value("TITLE")))
+                    && !newTags.contains("ALBUM")
+                    && !newTags.contains("ARTIST"));
+
                 TagMap oldMap = m_metaData; // Keep a copy of the old one for reference
-                // Append any new meta tags to the existing tag list
-                gst_tag_list_foreach (tag_list, &foreach_tag_function, &m_metaData);
+
+                // Now we've checked the new data, append any new meta tags to the existing tag list
+                // We cannot use TagMap::iterator as this is a multimap and when streaming data
+                // could in theory be lost.
+                QList<QString> keys = newTags.keys();
+                for (QList<QString>::iterator i = keys.begin(); i != keys.end(); ++i) {
+                    QString key = *i;
+                    if (m_isStream) {
+                        // If we're streaming, we need to remove data in m_metaData
+                        // in order to stop it filling up indefinitely (as it's a multimap)
+                        m_metaData.remove(key);
+                    }
+                    QList<QString> values = newTags.values(key);
+                    for (QList<QString>::iterator j = values.begin(); j != values.end(); ++j) {
+                        QString value = *j;
+                        QString currVal = m_metaData.value(key);
+                        if (!m_metaData.contains(key) || currVal != value) {
+                            m_metaData.insert(key, value);
+                        }
+                    }
+                }
+
                 m_backend->logMessage("Meta tags found", Backend::Info, this);
-                if (oldMap != m_metaData && !m_loading)
-                    emit metaDataChanged(m_metaData);
-                gst_tag_list_free(tag_list);
-            }
+                if (oldMap != m_metaData) {
+                    // This is a bit of a hack to ensure that stream metadata is
+                    // returned. We get as much as we can from the Shoutcast server's
+                    // StreamTitle= header. If further info is decoded from the stream
+                    // itself later, then it will overwrite this info.
+                    if (m_isStream && fake_it) {
+                        m_metaData.remove("ALBUM");
+                        m_metaData.remove("ARTIST");
+
+                        // Detect whether we want to "fill in the blanks"
+                        QString str;
+                        if (m_metaData.contains("TITLE"))
+                        {
+                            str = m_metaData.value("TITLE");
+                            int splitpoint;
+                            // Check to see if our title matches "%s - %s"
+                            // Where neither %s are empty...
+                            if ((splitpoint = str.indexOf(" - ")) > 0
+                                && str.size() > (splitpoint+3)) {
+                                m_metaData.insert("ARTIST", str.left(splitpoint));
+                                m_metaData.replace("TITLE", str.mid(splitpoint+3));
+                            }
+                        } else {
+                            str = m_metaData.value("GENRE");
+                            if (!str.isEmpty())
+                                m_metaData.insert("TITLE", str);
+                            else
+                                m_metaData.insert("TITLE", "Streaming Data");
+                        }
+                        if (!m_metaData.contains("ARTIST")) {
+                            str = m_metaData.value("LOCATION");
+                            if (!str.isEmpty())
+                                m_metaData.insert("ARTIST", str);
+                            else
+                                m_metaData.insert("ARTIST", "Streaming Data");
+                        }
+                        str = m_metaData.value("ORGANIZATION");
+                        if (!str.isEmpty())
+                            m_metaData.insert("ALBUM", str);
+                        else
+                            m_metaData.insert("ALBUM", "Streaming Data");
+                    }
+                    // As we manipulate the title, we need to recompare
+                    // oldMap and m_metaData here...
+                    if (oldMap != m_metaData && !m_loading)
+                        emit metaDataChanged(m_metaData);
+                }
+			}
         }
         break;
 
@@ -1255,6 +1386,9 @@ void MediaObject::handleBusMessage(const Message &message)
                 m_backend->logMessage("gstreamer: pipeline state set to playing", Backend::Info, this);
                 m_tickTimer->start();
                 changeState(Phonon::PlayingState);
+                if ((m_source.type() == MediaSource::Disc) && (m_currentTitle != m_pendingTitle)) {
+                    setTrack(m_pendingTitle);
+                }
                 if (m_resumeState && m_oldState == Phonon::PlayingState) {
                     seek(m_oldPos);
                     m_resumeState = false;
@@ -1290,6 +1424,9 @@ void MediaObject::handleBusMessage(const Message &message)
                     changeState(Phonon::StoppedState);
                 m_backend->logMessage("gstreamer: pipeline state set to ready", Backend::Debug, this);
                 m_tickTimer->stop();
+                if ((m_source.type() == MediaSource::Disc) && (m_currentTitle != m_pendingTitle)) {
+                    setTrack(m_pendingTitle);
+                }
                 break;
 
             case GST_STATE_VOID_PENDING :
@@ -1328,7 +1465,7 @@ void MediaObject::handleBusMessage(const Message &message)
                             setError(err->message, Phonon::FatalError);
                         gst_caps_unref (caps);
                         gst_object_unref (sinkPad);
-                   } 
+                   }
                } else {
                     setError(QString(err->message), Phonon::FatalError);
                }
@@ -1400,8 +1537,8 @@ void MediaObject::handleBusMessage(const Message &message)
         //case GST_MESSAGE_STEP_DONE:
         //case GST_MESSAGE_LATENCY: only from 0.10.12
         //case GST_MESSAGE_ASYNC_DONE: only from 0.10.13
-    default: 
-        break; 
+    default:
+        break;
     }
 }
 
@@ -1417,7 +1554,8 @@ void MediaObject::handleEndOfStream()
     if (!m_seekable)
         m_atEndOfStream = true;
 
-    if (m_autoplayTitles &&
+    if (m_source.type() == MediaSource::Disc &&
+        m_autoplayTitles &&
         m_availableTitles > 1 &&
         m_currentTitle < m_availableTitles) {
         _iface_setCurrentTitle(m_currentTitle + 1);
@@ -1444,6 +1582,14 @@ void MediaObject::handleEndOfStream()
     }
 }
 
+void MediaObject::invalidateGraph()
+{
+    m_resetNeeded = true;
+    if (m_state == Phonon::PlayingState || m_state == Phonon::PausedState) {
+        changeState(Phonon::StoppedState);
+    }
+}
+
 // Notifes the pipeline about state changes in the media object
 void MediaObject::notifyStateChange(Phonon::State newstate, Phonon::State oldstate)
 {
@@ -1502,15 +1648,30 @@ int MediaObject::_iface_currentTitle() const
 
 void MediaObject::_iface_setCurrentTitle(int title)
 {
-    GstFormat trackFormat = gst_format_get_by_nick("track");
     m_backend->logMessage(QString("setCurrentTitle %0").arg(title), Backend::Info, this);
-    if ((title == m_currentTitle) || (title < 1) || (title > m_availableTitles))
+    if ((title == m_currentTitle) || (title == m_pendingTitle))
+        return;
+
+    m_pendingTitle = title;
+
+    if (m_state == Phonon::PlayingState || m_state == Phonon::StoppedState) {
+        setTrack(m_pendingTitle);
+    } else {
+        setState(Phonon::StoppedState);
+    }
+}
+
+void MediaObject::setTrack(int title)
+{
+    if (((m_state != Phonon::PlayingState) && (m_state != Phonon::StoppedState)) || (title < 1) || (title > m_availableTitles))
         return;
 
-    m_currentTitle = title;
 
     //let's seek to the beginning of the song
-    if (gst_element_seek_simple(m_pipeline, trackFormat, GST_SEEK_FLAG_FLUSH, m_currentTitle - 1)) {
+    GstFormat trackFormat = gst_format_get_by_nick("track");
+    m_backend->logMessage(QString("setTrack %0").arg(title), Backend::Info, this);
+    if (gst_element_seek_simple(m_pipeline, trackFormat, GST_SEEK_FLAG_FLUSH, title - 1)) {
+        m_currentTitle = title;
         updateTotalTime();
         m_atEndOfStream = false;
         emit titleChanged(title);
diff --git a/src/3rdparty/phonon/gstreamer/mediaobject.h b/src/3rdparty/phonon/gstreamer/mediaobject.h
index 64b3510..d588ffc 100644
--- a/src/3rdparty/phonon/gstreamer/mediaobject.h
+++ b/src/3rdparty/phonon/gstreamer/mediaobject.h
@@ -55,6 +55,7 @@ class MediaObject : public QObject, public MediaObjectInterface
         , public MediaNode
 {
     friend class Stream;
+    friend class AudioDataOutput;
     Q_OBJECT
     Q_INTERFACES(Phonon::MediaObjectInterface
 #ifndef QT_NO_PHONON_MEDIACONTROLLER
@@ -144,12 +145,8 @@ public:
     void handleBusMessage(const Message &msg);
     void handleEndOfStream();
     void addMissingCodecName(const QString &codec) { m_missingCodecs.append(codec); }
-    void invalidateGraph() {
-        m_resetNeeded = true;
-        if (m_state == Phonon::PlayingState || m_state == Phonon::PausedState) {
-            changeState(Phonon::StoppedState);
-        }
-    }
+    void invalidateGraph();
+
     static void cb_newpad (GstElement *decodebin, GstPad *pad, gboolean last, gpointer data);
     static void cb_pad_added (GstElement *decodebin, GstPad *pad, gpointer data);
     static void cb_unknown_type (GstElement *decodebin, GstPad *pad, GstCaps *caps, gpointer data);
@@ -236,6 +233,7 @@ private:
     int _iface_availableTitles() const;
     int _iface_currentTitle() const;
     void _iface_setCurrentTitle(int title);
+    void setTrack(int title);
 
     bool m_resumeState;
     State m_oldState;
@@ -250,6 +248,7 @@ private:
     MediaSource m_nextSource;
     qint32 m_prefinishMark;
     qint32 m_transitionTime;
+	bool m_isStream;
 
     qint64 m_posAtSeek;
 
@@ -285,6 +284,7 @@ private:
     bool m_autoplayTitles;
     int m_availableTitles;
     int m_currentTitle;
+    int m_pendingTitle;
 };
 }
 } //namespace Phonon::Gstreamer
diff --git a/src/3rdparty/phonon/gstreamer/phonon-config-gstreamer.h.cmake b/src/3rdparty/phonon/gstreamer/phonon-config-gstreamer.h.cmake
new file mode 100644
index 0000000..fb4eb04
--- /dev/null
+++ b/src/3rdparty/phonon/gstreamer/phonon-config-gstreamer.h.cmake
@@ -0,0 +1,5 @@
+/* GStreamer install plugin definitions */
+
+/* If api-plugin is defined */
+#cmakedefine PLUGIN_INSTALL_API 1
+
diff --git a/src/3rdparty/phonon/gstreamer/phononsrc.cpp b/src/3rdparty/phonon/gstreamer/phononsrc.cpp
index 97d7220..f893fb5 100644
--- a/src/3rdparty/phonon/gstreamer/phononsrc.cpp
+++ b/src/3rdparty/phonon/gstreamer/phononsrc.cpp
@@ -109,25 +109,18 @@ static void phonon_src_class_init (PhononSrcClass * klass)
 static void phonon_src_init (PhononSrc * src, PhononSrcClass * g_class)
 {
     Q_UNUSED(g_class);
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     src->device = 0;
-#else
-    Q_UNUSED(src);
-#endif
 }
 
 static void phonon_src_finalize (GObject * object)
 {
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     PhononSrc *src;
     src = GST_PHONON_SRC (object);
     delete src->device;
     src->device = 0;
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
     G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
 static gboolean phonon_src_set_device(PhononSrc * src, StreamReader* device)
 {
     GstState state;
@@ -152,7 +145,6 @@ wrong_state:
         return FALSE;
     }
 }
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
 
 static void phonon_src_set_property (GObject * object, guint prop_id, const GValue * value, GParamSpec * pspec)
 {
@@ -161,7 +153,6 @@ static void phonon_src_set_property (GObject * object, guint prop_id, const GVal
     src = GST_PHONON_SRC (object);
 
     switch (prop_id) {
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     case ARG_PHONONSRC:
     {
         StreamReader *dev = (StreamReader*)(g_value_get_pointer(value));
@@ -169,9 +160,6 @@ static void phonon_src_set_property (GObject * object, guint prop_id, const GVal
             phonon_src_set_device(src, dev);
         break;
     }
-#else
-    Q_UNUSED(value);
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
    default:
        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
        break;
@@ -186,13 +174,9 @@ static void phonon_src_get_property (GObject * object, guint prop_id, GValue * v
     src = GST_PHONON_SRC (object);
 
     switch (prop_id) {
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     case ARG_PHONONSRC:
         g_value_set_pointer(value, src->device);
         break;
-#else //QT_NO_PHONON_ABSTRACTMEDIASTREAM
-    Q_UNUSED(value);
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
     default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
         break;
@@ -201,7 +185,6 @@ static void phonon_src_get_property (GObject * object, guint prop_id, GValue * v
 
 static GstFlowReturn phonon_src_create_read (PhononSrc * src, guint64 offset, guint length, GstBuffer ** buffer)
 {
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     Q_ASSERT(src->device);
     if (!src->device)
         return GST_FLOW_ERROR;
@@ -221,13 +204,6 @@ static GstFlowReturn phonon_src_create_read (PhononSrc * src, guint64 offset, gu
 
     gst_mini_object_unref(GST_MINI_OBJECT(buf));
     return GST_FLOW_ERROR;
-#else //QT_NO_PHONON_ABSTRACTMEDIASTREAM
-    Q_UNUSED(src);
-    Q_UNUSED(offset);
-    Q_UNUSED(length);
-    Q_UNUSED(buffer);
-    return GST_FLOW_ERROR;
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
 }
 
 static GstFlowReturn phonon_src_create (GstBaseSrc * basesrc, guint64 offset, guint length, GstBuffer ** buffer)
@@ -242,23 +218,19 @@ static GstFlowReturn phonon_src_create (GstBaseSrc * basesrc, guint64 offset, gu
 static gboolean phonon_src_is_seekable (GstBaseSrc * basesrc)
 {
     PhononSrc *src = GST_PHONON_SRC (basesrc);
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     if (src->device)
         return src->device->streamSeekable();
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
     return false;
 }
 
 static gboolean phonon_src_get_size (GstBaseSrc * basesrc, guint64 * size)
 {
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     PhononSrc *src;
     src = GST_PHONON_SRC (basesrc);
     if (src->device && src->device->streamSeekable()) {
         *size = src->device->streamSize();
         return TRUE;
     }
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
     *size = 0;
     return FALSE;
 }
diff --git a/src/3rdparty/phonon/gstreamer/phononsrc.h b/src/3rdparty/phonon/gstreamer/phononsrc.h
index a50f8a2..a2cd8b3 100644
--- a/src/3rdparty/phonon/gstreamer/phononsrc.h
+++ b/src/3rdparty/phonon/gstreamer/phononsrc.h
@@ -49,9 +49,7 @@ typedef struct _PhononSrcClass PhononSrcClass;
 // PhononSrc:
 struct _PhononSrc {
     GstBaseSrc element;
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     StreamReader *device;
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
 };
 
 struct _PhononSrcClass {
diff --git a/src/3rdparty/phonon/gstreamer/qwidgetvideosink.h b/src/3rdparty/phonon/gstreamer/qwidgetvideosink.h
index 73a494a..f83dba5 100644
--- a/src/3rdparty/phonon/gstreamer/qwidgetvideosink.h
+++ b/src/3rdparty/phonon/gstreamer/qwidgetvideosink.h
@@ -19,6 +19,7 @@
 #define Phonon_GSTREAMER_VIDEOSINK_H
 
 #include "common.h"
+#include "qwidgetvideosink.h"
 
 #include <QtCore/QByteArray>
 #include <QtCore/QEvent>
diff --git a/src/3rdparty/phonon/gstreamer/streamreader.cpp b/src/3rdparty/phonon/gstreamer/streamreader.cpp
index f8219e6..04fa6cc 100644
--- a/src/3rdparty/phonon/gstreamer/streamreader.cpp
+++ b/src/3rdparty/phonon/gstreamer/streamreader.cpp
@@ -20,7 +20,7 @@ along with this library.  If not, see <http://www.gnu.org/licenses/>.
 #include <phonon/streaminterface.h>
 
 QT_BEGIN_NAMESPACE
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
+
 namespace Phonon
 {
 namespace Gstreamer
@@ -49,6 +49,5 @@ bool StreamReader::read(quint64 pos, int length, char * buffer)
 
 }
 }
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
 
 QT_END_NAMESPACE
diff --git a/src/3rdparty/phonon/gstreamer/streamreader.h b/src/3rdparty/phonon/gstreamer/streamreader.h
index 387370c..c2e61c8 100644
--- a/src/3rdparty/phonon/gstreamer/streamreader.h
+++ b/src/3rdparty/phonon/gstreamer/streamreader.h
@@ -23,8 +23,6 @@ along with this library.  If not, see <http://www.gnu.org/licenses/>.
 
 QT_BEGIN_NAMESPACE
 
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
-
 namespace Phonon
 {
     class MediaSource;
@@ -93,8 +91,6 @@ private:
     }
 }
 
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
-
 QT_END_NAMESPACE
 
 #endif
diff --git a/src/3rdparty/phonon/gstreamer/videowidget.cpp b/src/3rdparty/phonon/gstreamer/videowidget.cpp
index e1f0ec9..efc750a 100644
--- a/src/3rdparty/phonon/gstreamer/videowidget.cpp
+++ b/src/3rdparty/phonon/gstreamer/videowidget.cpp
@@ -33,7 +33,6 @@
 #include "widgetrenderer.h"
 #include "x11renderer.h"
 
-#ifndef QT_NO_PHONON_VIDEO
 QT_BEGIN_NAMESPACE
 
 namespace Phonon
@@ -384,6 +383,5 @@ void VideoWidget::mediaNodeEvent(const MediaNodeEvent *event)
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_VIDEO
 
 #include "moc_videowidget.cpp"
diff --git a/src/3rdparty/phonon/gstreamer/videowidget.h b/src/3rdparty/phonon/gstreamer/videowidget.h
index dc0754d..47f4e08 100644
--- a/src/3rdparty/phonon/gstreamer/videowidget.h
+++ b/src/3rdparty/phonon/gstreamer/videowidget.h
@@ -25,10 +25,10 @@
 #include "common.h"
 #include "medianode.h"
 #include "abstractrenderer.h"
+#include "videowidget.h"
 
 #include <gst/gst.h>
 
-#ifndef QT_NO_PHONON_VIDEO
 QT_BEGIN_NAMESPACE
 
 class QString;
@@ -103,5 +103,5 @@ private:
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_VIDEO
+
 #endif // Phonon_GSTREAMER_VIDEOWIDGET_H
diff --git a/src/3rdparty/phonon/gstreamer/volumefadereffect.cpp b/src/3rdparty/phonon/gstreamer/volumefadereffect.cpp
index bf0d646..d7ee11b 100644
--- a/src/3rdparty/phonon/gstreamer/volumefadereffect.cpp
+++ b/src/3rdparty/phonon/gstreamer/volumefadereffect.cpp
@@ -21,11 +21,11 @@
 
 QT_BEGIN_NAMESPACE
 
-#ifndef QT_NO_PHONON_VOLUMEFADEREFFECT
 namespace Phonon
 {
 namespace Gstreamer
 {
+
 VolumeFaderEffect::VolumeFaderEffect(Backend *backend, QObject *parent) 
     : Effect(backend, parent, AudioSource | AudioSink)
     , m_fadeCurve(Phonon::VolumeFaderEffect::Fade3Decibel)
@@ -156,7 +156,7 @@ bool VolumeFaderEffect::event(QEvent *event)
 }
 
 }} //namespace Phonon::Gstreamer
-#endif //QT_NO_PHONON_VOLUMEFADEREFFECT
+
 QT_END_NAMESPACE
 
 #include "moc_volumefadereffect.cpp"
diff --git a/src/3rdparty/phonon/gstreamer/volumefadereffect.h b/src/3rdparty/phonon/gstreamer/volumefadereffect.h
index 748d2d6..d74014c 100644
--- a/src/3rdparty/phonon/gstreamer/volumefadereffect.h
+++ b/src/3rdparty/phonon/gstreamer/volumefadereffect.h
@@ -30,7 +30,7 @@
 #include <gst/gst.h>
 
 QT_BEGIN_NAMESPACE
-#ifndef QT_NO_PHONON_VOLUMEFADEREFFECT
+
 namespace Phonon
 {
 namespace Gstreamer
@@ -64,7 +64,7 @@ namespace Gstreamer
             QTime m_fadeStartTime;
     };
 }} //namespace Phonon::Gstreamer
-#endif //QT_NO_PHONON_VOLUMEFADEREFFECT
+
 QT_END_NAMESPACE
 
 #endif // Phonon_GSTREAMER_VOLUMEFADEREFFECT_H
diff --git a/src/3rdparty/phonon/gstreamer/widgetrenderer.cpp b/src/3rdparty/phonon/gstreamer/widgetrenderer.cpp
index 423af9d..d4a411f 100644
--- a/src/3rdparty/phonon/gstreamer/widgetrenderer.cpp
+++ b/src/3rdparty/phonon/gstreamer/widgetrenderer.cpp
@@ -32,7 +32,6 @@
 # define GL_TEXTURE2    0x84C2
 #endif
 
-#ifndef QT_NO_PHONON_VIDEO
 QT_BEGIN_NAMESPACE
 
 static void frameRendered()
@@ -149,4 +148,3 @@ bool WidgetRenderer::eventFilter(QEvent * event)
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_VIDEO
diff --git a/src/3rdparty/phonon/gstreamer/widgetrenderer.h b/src/3rdparty/phonon/gstreamer/widgetrenderer.h
index 03ee9c0..ff64fa7 100644
--- a/src/3rdparty/phonon/gstreamer/widgetrenderer.h
+++ b/src/3rdparty/phonon/gstreamer/widgetrenderer.h
@@ -26,7 +26,6 @@
 #include <QtOpenGL/QGLWidget>
 #endif
 
-#ifndef QT_NO_PHONON_VIDEO
 QT_BEGIN_NAMESPACE
 
 class QString;
@@ -60,5 +59,5 @@ private:
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_VIDEO
+
 #endif // Phonon_GSTREAMER_WIDGETRENDERER_H
diff --git a/src/3rdparty/phonon/gstreamer/x11renderer.cpp b/src/3rdparty/phonon/gstreamer/x11renderer.cpp
index 73877a8..968f3a8 100644
--- a/src/3rdparty/phonon/gstreamer/x11renderer.cpp
+++ b/src/3rdparty/phonon/gstreamer/x11renderer.cpp
@@ -90,7 +90,7 @@ GstElement* X11Renderer::createVideoSink()
             gst_object_unref(GST_OBJECT(videoSink));
             videoSink = 0;
         } else {
-            // Note that this should not really be neccessary as these are 
+            // Note that this should not really be necessary as these are
             // default values, though under certain conditions values are retained
             // even between application instances. (reproducible on 0.10.16/Gutsy)
             g_object_set(G_OBJECT(videoSink), "brightness", 0, (const char*)NULL);
@@ -138,6 +138,7 @@ void X11Renderer::scaleModeChanged(Phonon::VideoWidget::ScaleMode)
 void X11Renderer::movieSizeChanged(const QSize &movieSize)
 {
     Q_UNUSED(movieSize);
+
     if (m_renderWidget) {
         m_renderWidget->setGeometry(m_videoWidget->calculateDrawFrameRect());
     }
diff --git a/src/3rdparty/phonon/includes/CMakeLists.txt b/src/3rdparty/phonon/includes/CMakeLists.txt
index dff86c3..349acd8 100644
--- a/src/3rdparty/phonon/includes/CMakeLists.txt
+++ b/src/3rdparty/phonon/includes/CMakeLists.txt
@@ -35,7 +35,7 @@ install( FILES
   Phonon/VolumeFaderEffect
   Phonon/VolumeFaderInterface
   Phonon/VolumeSlider
-DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/Phonon COMPONENT Devel)
+DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/Phonon)
 
 install(FILES
   Phonon/Experimental/AbstractVideoDataOutput
@@ -46,4 +46,4 @@ install(FILES
   Phonon/Experimental/VideoFrame
   Phonon/Experimental/VideoFrame2
   Phonon/Experimental/Visualization
-DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/Phonon/Experimental COMPONENT Devel)
+DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/Phonon/Experimental)
diff --git a/src/3rdparty/phonon/mmf/abstractaudioeffect.cpp b/src/3rdparty/phonon/mmf/abstractaudioeffect.cpp
deleted file mode 100644
index e7ef9b2..0000000
--- a/src/3rdparty/phonon/mmf/abstractaudioeffect.cpp
+++ /dev/null
@@ -1,97 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "mediaobject.h"
-
-#include "abstractaudioeffect.h"
-#include "audioplayer.h"
-#include "mmf_videoplayer.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::AbstractAudioEffect
-  \internal
-*/
-
-/*! \namespace Phonon::MMF
-  \internal
-*/
-
-AbstractAudioEffect::AbstractAudioEffect(QObject *parent,
-                                         const QList<EffectParameter> &params)
-    :   MediaNode::MediaNode(parent)
-    ,   m_player(0)
-    ,   m_params(params)
-{
-}
-
-QList<EffectParameter> AbstractAudioEffect::parameters() const
-{
-    return m_params;
-}
-
-QVariant AbstractAudioEffect::parameterValue(const EffectParameter &queriedParam) const
-{
-    const QVariant &val = m_values.value(queriedParam.id());
-
-    if (val.isNull())
-        return queriedParam.defaultValue();
-    else
-        return val;
-}
-
-void AbstractAudioEffect::setParameterValue(const EffectParameter &param,
-                                            const QVariant &newValue)
-{
-    m_values.insert(param.id(), newValue);
-    parameterChanged(param.id(), newValue);
-    // TODO: handle audio effect errors
-    TRAP_IGNORE(m_effect->ApplyL());
-}
-
-void AbstractAudioEffect::connectMediaObject(MediaObject *mediaObject)
-{
-    Q_ASSERT_X(!m_player, Q_FUNC_INFO, "Player already connected");
-    Q_ASSERT_X(!m_effect.data(), Q_FUNC_INFO, "Effect already created");
-
-    AbstractMediaPlayer *const player =
-        qobject_cast<AbstractMediaPlayer *>(mediaObject->abstractPlayer());
-
-    if (player) {
-        m_player = player;
-
-        if (AudioPlayer *audioPlayer = qobject_cast<AudioPlayer *>(player)) {
-            connectAudioPlayer(audioPlayer->nativePlayer());
-            applyParameters();
-            // TODO: handle audio effect errors
-            TRAP_IGNORE(m_effect->EnableL());
-        }
-    }
-}
-
-void AbstractAudioEffect::disconnectMediaObject(MediaObject * /*mediaObject*/)
-{
-    m_player = 0;
-    m_effect.reset();
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/abstractaudioeffect.h b/src/3rdparty/phonon/mmf/abstractaudioeffect.h
deleted file mode 100644
index ca29fd3..0000000
--- a/src/3rdparty/phonon/mmf/abstractaudioeffect.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_ABSTRACTEFFECT_H
-#define PHONON_MMF_ABSTRACTEFFECT_H
-
-#include <QScopedPointer>
-
-#include <AudioEffectBase.h>
-
-#include <Phonon/effectinterface.h>
-#include <Phonon/effectparameter.h>
-
-#include "audioplayer.h"
-#include "mmf_medianode.h"
-#include "mmf_videoplayer.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-class AbstractMediaPlayer;
-
-/**
- * @short Base class for all effects for MMF.
- *
- * Adhering to Phonon with MMF is cumbersome because of a number of reasons:
- *
- * - MMF has no concept of effect chaining. Simply, an effect is a applied
- *   to PlayerUtility, that's it. This means that the order of effects is
- *   undefined.
- * - We apply an effect to a PlayerUtility, and MediaObject has that one.
- *   However, effects might be created before MediaObject, but nevertheless
- *   needs to work. We solve this by that we are aware of the whole connection
- *   chain, and whenever a connection happens, we walk the chain, find effects
- *   that aren't applied, and apply it if we have a media object.
- * - There are plenty of corner cases which we don't handle and where behavior
- *   are undefined. For instance, graphs with more than one MediaObject.
- */
-class AbstractAudioEffect : public MediaNode
-                          , public EffectInterface
-{
-    Q_OBJECT
-    Q_INTERFACES(Phonon::EffectInterface)
-public:
-    AbstractAudioEffect(QObject *parent,
-                        const QList<EffectParameter> &params);
-
-    virtual QList<EffectParameter> parameters() const;
-    virtual QVariant parameterValue(const EffectParameter &param) const;
-    virtual void setParameterValue(const EffectParameter &,
-                                   const QVariant &newValue);
-
-    enum Type
-    {
-        EffectAudioEqualizer = 1,
-        EffectBassBoost,
-        EffectDistanceAttenuation,
-        EffectEnvironmentalReverb,
-        EffectListenerOrientation,
-        EffectLoudness,
-        EffectSourceOrientation,
-        EffectStereoWidening
-    };
-
-protected:
-    // MediaNode
-    void connectMediaObject(MediaObject *mediaObject);
-    void disconnectMediaObject(MediaObject *mediaObject);
-
-    virtual void connectAudioPlayer(AudioPlayer::NativePlayer *player) = 0;
-    virtual void applyParameters() = 0;
-
-    virtual void parameterChanged(const int id,
-                                  const QVariant &value) = 0;
-
-protected:
-    QScopedPointer<CAudioEffect>    m_effect;
-
-private:
-    AbstractMediaPlayer *           m_player;
-    const QList<EffectParameter>    m_params;
-    QHash<int, QVariant>            m_values;
-};
-
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
-
diff --git a/src/3rdparty/phonon/mmf/abstractmediaplayer.cpp b/src/3rdparty/phonon/mmf/abstractmediaplayer.cpp
deleted file mode 100644
index 544762a..0000000
--- a/src/3rdparty/phonon/mmf/abstractmediaplayer.cpp
+++ /dev/null
@@ -1,490 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <QUrl>
-
-#include "abstractmediaplayer.h"
-#include "defs.h"
-#include "mediaobject.h"
-#include "utils.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::AbstractMediaPlayer
-  \internal
-*/
-
-//-----------------------------------------------------------------------------
-// Constants
-//-----------------------------------------------------------------------------
-
-const int       NullMaxVolume = -1;
-const int       BufferStatusTimerInterval = 100; // ms
-
-
-//-----------------------------------------------------------------------------
-// Constructor / destructor
-//-----------------------------------------------------------------------------
-
-MMF::AbstractMediaPlayer::AbstractMediaPlayer
-    (MediaObject *parent, const AbstractPlayer *player)
-        :   AbstractPlayer(player)
-        ,   m_parent(parent)
-        ,   m_playPending(false)
-        ,   m_positionTimer(new QTimer(this))
-        ,   m_bufferStatusTimer(new QTimer(this))
-        ,   m_mmfMaxVolume(NullMaxVolume)
-        ,   m_prefinishMarkSent(false)
-        ,   m_aboutToFinishSent(false)
-{
-    connect(m_positionTimer.data(), SIGNAL(timeout()), this, SLOT(positionTick()));
-    connect(m_bufferStatusTimer.data(), SIGNAL(timeout()), this, SLOT(bufferStatusTick()));
-}
-
-//-----------------------------------------------------------------------------
-// MediaObjectInterface
-//-----------------------------------------------------------------------------
-
-void MMF::AbstractMediaPlayer::play()
-{
-    TRACE_CONTEXT(AbstractMediaPlayer::play, EAudioApi);
-    TRACE_ENTRY("state %d", privateState());
-
-    switch (privateState()) {
-    case GroundState:
-        setError(tr("Not ready to play"));
-        break;
-
-    case LoadingState:
-        m_playPending = true;
-        break;
-
-    case StoppedState:
-    case PausedState:
-        doPlay();
-        startPositionTimer();
-        changeState(PlayingState);
-        break;
-
-    case PlayingState:
-    case BufferingState:
-    case ErrorState:
-        // Do nothing
-        break;
-
-        // Protection against adding new states and forgetting to update this switch
-    default:
-        TRACE_PANIC(InvalidStatePanic);
-    }
-
-    TRACE_EXIT("state %d", privateState());
-}
-
-void MMF::AbstractMediaPlayer::pause()
-{
-    TRACE_CONTEXT(AbstractMediaPlayer::pause, EAudioApi);
-    TRACE_ENTRY("state %d", privateState());
-
-    m_playPending = false;
-    stopTimers();
-
-    switch (privateState()) {
-    case GroundState:
-    case LoadingState:
-    case PausedState:
-    case StoppedState:
-        // Do nothing
-        break;
-
-    case PlayingState:
-    case BufferingState:
-        changeState(PausedState);
-        // Fall through
-    case ErrorState:
-        doPause();
-        break;
-
-        // Protection against adding new states and forgetting to update this switch
-    default:
-        TRACE_PANIC(InvalidStatePanic);
-    }
-
-    TRACE_EXIT("state %d", privateState());
-}
-
-void MMF::AbstractMediaPlayer::stop()
-{
-    TRACE_CONTEXT(AbstractMediaPlayer::stop, EAudioApi);
-    TRACE_ENTRY("state %d", privateState());
-
-    m_playPending = false;
-    stopTimers();
-
-    switch (privateState()) {
-    case GroundState:
-    case LoadingState:
-    case StoppedState:
-    case ErrorState:
-        // Do nothing
-        break;
-
-    case PlayingState:
-    case BufferingState:
-    case PausedState:
-        doStop();
-        changeState(StoppedState);
-        break;
-
-        // Protection against adding new states and forgetting to update this switch
-    default:
-        TRACE_PANIC(InvalidStatePanic);
-    }
-
-    TRACE_EXIT("state %d", privateState());
-}
-
-void MMF::AbstractMediaPlayer::seek(qint64 ms)
-{
-    TRACE_CONTEXT(AbstractMediaPlayer::seek, EAudioApi);
-    TRACE_ENTRY("state %d pos %Ld", state(), ms);
-
-    switch (privateState()) {
-    // Fallthrough all these
-    case GroundState:
-    case StoppedState:
-    case PausedState:
-    case PlayingState:
-    case LoadingState:
-    {
-        bool wasPlaying = false;
-        if (state() == PlayingState) {
-            stopPositionTimer();
-            doPause();
-            wasPlaying = true;
-        }
-
-        doSeek(ms);
-        resetMarksIfRewound();
-
-        if(wasPlaying && state() != ErrorState) {
-            doPlay();
-            startPositionTimer();
-        }
-
-        break;
-    }
-    case BufferingState:
-    // Fallthrough
-    case ErrorState:
-        // Do nothing
-        break;
-    }
-
-    TRACE_EXIT_0();
-}
-
-bool MMF::AbstractMediaPlayer::isSeekable() const
-{
-    return true;
-}
-
-void MMF::AbstractMediaPlayer::doSetTickInterval(qint32 interval)
-{
-    TRACE_CONTEXT(AbstractMediaPlayer::doSetTickInterval, EAudioApi);
-    TRACE_ENTRY("state %d m_interval %d interval %d", privateState(), tickInterval(), interval);
-
-    m_positionTimer->setInterval(interval);
-
-    TRACE_EXIT_0();
-}
-
-void MMF::AbstractMediaPlayer::open(const MediaSource &source, RFile& file)
-{
-    TRACE_CONTEXT(AbstractMediaPlayer::setFileSource, EAudioApi);
-    TRACE_ENTRY("state %d source.type %d", privateState(), source.type());
-
-    close();
-    changeState(GroundState);
-
-    TInt symbianErr = KErrNone;
-    QString errorMessage;
-
-    switch (source.type()) {
-    case MediaSource::LocalFile: {
-        symbianErr = openFile(file);
-        if (KErrNone != symbianErr)
-            errorMessage = tr("Error opening file");
-        break;
-    }
-
-    case MediaSource::Url: {
-        const QUrl url(source.url());
-
-        if (url.scheme() == QLatin1String("file")) {
-            symbianErr = openFile(file);
-            if (KErrNone != symbianErr)
-                errorMessage = tr("Error opening file");
-        } else {
-            symbianErr = openUrl(url.toString());
-            if (KErrNone != symbianErr)
-                errorMessage = tr("Error opening URL");
-        }
-
-        break;
-    }
-
-    // Other source types are handled in MediaObject::createPlayer
-
-    // Protection against adding new media types and forgetting to update this switch
-    default:
-        TRACE_PANIC(InvalidMediaTypePanic);
-    }
-
-    if (errorMessage.isEmpty()) {
-        changeState(LoadingState);
-    } else {
-        if (symbianErr)
-            setError(errorMessage, symbianErr);
-        else
-            setError(errorMessage);
-    }
-
-    TRACE_EXIT_0();
-}
-
-void MMF::AbstractMediaPlayer::volumeChanged(qreal volume)
-{
-    TRACE_CONTEXT(AbstractMediaPlayer::volumeChanged, EAudioInternal);
-    TRACE_ENTRY("state %d", privateState());
-
-    AbstractPlayer::volumeChanged(volume);
-    doVolumeChanged();
-
-    TRACE_EXIT_0();
-}
-
-//-----------------------------------------------------------------------------
-// Private functions
-//-----------------------------------------------------------------------------
-
-void MMF::AbstractMediaPlayer::startPositionTimer()
-{
-    m_positionTimer->start(tickInterval());
-}
-
-void MMF::AbstractMediaPlayer::stopPositionTimer()
-{
-    m_positionTimer->stop();
-}
-
-void MMF::AbstractMediaPlayer::startBufferStatusTimer()
-{
-    m_bufferStatusTimer->start(BufferStatusTimerInterval);
-}
-
-void MMF::AbstractMediaPlayer::stopBufferStatusTimer()
-{
-    m_bufferStatusTimer->stop();
-}
-
-void MMF::AbstractMediaPlayer::stopTimers()
-{
-    stopPositionTimer();
-    stopBufferStatusTimer();
-}
-
-void MMF::AbstractMediaPlayer::doVolumeChanged()
-{
-    switch (privateState()) {
-    case GroundState:
-    case LoadingState:
-    case ErrorState:
-        // Do nothing
-        break;
-
-    case StoppedState:
-    case PausedState:
-    case PlayingState:
-    case BufferingState: {
-        const qreal volume = (m_volume * m_mmfMaxVolume) + 0.5;
-        const int err = setDeviceVolume(volume);
-
-        if (KErrNone != err) {
-            setError(tr("Setting volume failed"), err);
-        }
-        break;
-    }
-
-    // Protection against adding new states and forgetting to update this
-    // switch
-    default:
-        Utils::panic(InvalidStatePanic);
-    }
-}
-
-//-----------------------------------------------------------------------------
-// Protected functions
-//-----------------------------------------------------------------------------
-
-void MMF::AbstractMediaPlayer::bufferingStarted()
-{
-    m_stateBeforeBuffering = privateState();
-    changeState(BufferingState);
-    bufferStatusTick();
-    startBufferStatusTimer();
-}
-
-void MMF::AbstractMediaPlayer::bufferingComplete()
-{
-    stopBufferStatusTimer();
-    emit MMF::AbstractPlayer::bufferStatus(100);
-    changeState(m_stateBeforeBuffering);
-}
-
-void MMF::AbstractMediaPlayer::maxVolumeChanged(int mmfMaxVolume)
-{
-    m_mmfMaxVolume = mmfMaxVolume;
-    doVolumeChanged();
-}
-
-void MMF::AbstractMediaPlayer::playbackComplete(int error)
-{
-    stopTimers();
-
-    if (KErrNone == error) {
-        changeState(StoppedState);
-
-        // MediaObject::switchToNextSource deletes the current player, so we
-        // call it via delayed slot invokation to ensure that this object does
-        // not get deleted during execution of a member function.
-        QMetaObject::invokeMethod(m_parent, "switchToNextSource", Qt::QueuedConnection);
-    }
-    else {
-        setError(tr("Playback complete"), error);
-    }
-}
-
-qint64 MMF::AbstractMediaPlayer::toMilliSeconds(const TTimeIntervalMicroSeconds &in)
-{
-    return in.Int64() / 1000;
-}
-
-//-----------------------------------------------------------------------------
-// Slots
-//-----------------------------------------------------------------------------
-
-void MMF::AbstractMediaPlayer::positionTick()
-{
-    emitMarksIfReached();
-
-    const qint64 current = currentTime();
-    emit MMF::AbstractPlayer::tick(current);
-}
-
-void MMF::AbstractMediaPlayer::emitMarksIfReached()
-{
-    const qint64 current = currentTime();
-    const qint64 total = totalTime();
-    const qint64 remaining = total - current;
-
-    if (prefinishMark() && !m_prefinishMarkSent) {
-        if (remaining < (prefinishMark() + tickInterval()/2)) {
-            m_prefinishMarkSent = true;
-            emit prefinishMarkReached(remaining);
-        }
-    }
-
-    if (!m_aboutToFinishSent) {
-        if (remaining < tickInterval()) {
-            m_aboutToFinishSent = true;
-            emit aboutToFinish();
-        }
-    }
-}
-
-void MMF::AbstractMediaPlayer::resetMarksIfRewound()
-{
-    const qint64 current = currentTime();
-    const qint64 total = totalTime();
-    const qint64 remaining = total - current;
-
-    if (prefinishMark() && m_prefinishMarkSent)
-        if (remaining >= (prefinishMark() + tickInterval()/2))
-            m_prefinishMarkSent = false;
-
-    if (m_aboutToFinishSent)
-        if (remaining >= tickInterval())
-            m_aboutToFinishSent = false;
-}
-
-void MMF::AbstractMediaPlayer::bufferStatusTick()
-{
-    emit MMF::AbstractPlayer::bufferStatus(bufferStatus());
-}
-
-void MMF::AbstractMediaPlayer::changeState(PrivateState newState)
-{
-    TRACE_CONTEXT(AbstractMediaPlayer::changeState, EAudioInternal);
-
-    const Phonon::State oldPhononState = phononState(privateState());
-    const Phonon::State newPhononState = phononState(newState);
-
-    // TODO: add some invariants to check that the transition is valid
-    AbstractPlayer::changeState(newState);
-
-    if (LoadingState == oldPhononState && StoppedState == newPhononState) {
-        // Ensure initial volume is set on MMF API before starting playback
-        doVolumeChanged();
-
-        // Check whether play() was called while clip was being loaded.  If so,
-        // playback should be started now
-        if (m_playPending) {
-            TRACE_0("play was called while loading; starting playback now");
-            m_playPending = false;
-            play();
-        }
-    }
-}
-
-void MMF::AbstractMediaPlayer::updateMetaData()
-{
-    TRACE_CONTEXT(AbstractMediaPlayer::updateMetaData, EAudioInternal);
-    TRACE_ENTRY_0();
-
-    m_metaData.clear();
-
-    const int numberOfEntries = numberOfMetaDataEntries();
-    for(int i=0; i<numberOfEntries; ++i) {
-        const QPair<QString, QString> entry = metaDataEntry(i);
-
-        // Note that we capitalize the key, as required by the Ogg Vorbis
-        // metadata standard to which Phonon adheres:
-        // http://xiph.org/vorbis/doc/v-comment.html
-        m_metaData.insert(entry.first.toUpper(), entry.second);
-    }
-
-    emit metaDataChanged(m_metaData);
-
-    TRACE_EXIT_0();
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/abstractmediaplayer.h b/src/3rdparty/phonon/mmf/abstractmediaplayer.h
deleted file mode 100644
index abd6bff..0000000
--- a/src/3rdparty/phonon/mmf/abstractmediaplayer.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_ABSTRACTMEDIAPLAYER_H
-#define PHONON_MMF_ABSTRACTMEDIAPLAYER_H
-
-#include <QTimer>
-#include <QScopedPointer>
-#include <e32std.h>
-#include "abstractplayer.h"
-
-class RFile;
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-class AudioOutput;
-class MediaObject;
-
-/**
- * Interface via which MMF client APIs for both audio and video can be
- * accessed.
- */
-class AbstractMediaPlayer : public AbstractPlayer
-{
-    Q_OBJECT
-
-protected:
-    AbstractMediaPlayer(MediaObject *parent, const AbstractPlayer *player);
-
-public:
-    virtual void open(const Phonon::MediaSource&, RFile&);
-
-    // MediaObjectInterface
-    virtual void play();
-    virtual void pause();
-    virtual void stop();
-    virtual void seek(qint64 milliseconds);
-    virtual bool isSeekable() const;
-    virtual void volumeChanged(qreal volume);
-
-protected:
-    // AbstractPlayer
-    virtual void doSetTickInterval(qint32 interval);
-
-    virtual void doPlay() = 0;
-    virtual void doPause() = 0;
-    virtual void doStop() = 0;
-    virtual void doSeek(qint64 pos) = 0;
-    virtual int setDeviceVolume(int mmfVolume) = 0;
-    virtual int openFile(RFile& file) = 0;
-    virtual int openUrl(const QString& url) = 0;
-    virtual int bufferStatus() const = 0;
-    virtual void close() = 0;
-    virtual void changeState(PrivateState newState);
-
-    void updateMetaData();
-    virtual int numberOfMetaDataEntries() const = 0;
-    virtual QPair<QString, QString> metaDataEntry(int index) const = 0;
-
-protected:
-    void bufferingStarted();
-    void bufferingComplete();
-    void maxVolumeChanged(int maxVolume);
-    void playbackComplete(int error);
-
-    static qint64 toMilliSeconds(const TTimeIntervalMicroSeconds &);
-
-private:
-    void startPositionTimer();
-    void stopPositionTimer();
-    void startBufferStatusTimer();
-    void stopBufferStatusTimer();
-    void stopTimers();
-    void doVolumeChanged();
-    void emitMarksIfReached();
-    void resetMarksIfRewound();
-
-private Q_SLOTS:
-    void positionTick();
-    void bufferStatusTick();
-
-private:
-    MediaObject *const          m_parent;
-
-    /**
-     * This flag is set to true if play is called when the object is
-     * in a Loading state.  Once loading is complete, playback will
-     * be started.
-     */
-    bool                        m_playPending;
-
-    QScopedPointer<QTimer>      m_positionTimer;
-
-    QScopedPointer<QTimer>      m_bufferStatusTimer;
-    PrivateState                m_stateBeforeBuffering;
-
-    int                         m_mmfMaxVolume;
-
-    bool                        m_prefinishMarkSent;
-    bool                        m_aboutToFinishSent;
-
-    QMultiMap<QString, QString> m_metaData;
-
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
-
diff --git a/src/3rdparty/phonon/mmf/abstractplayer.cpp b/src/3rdparty/phonon/mmf/abstractplayer.cpp
deleted file mode 100644
index 53973eb..0000000
--- a/src/3rdparty/phonon/mmf/abstractplayer.cpp
+++ /dev/null
@@ -1,194 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "abstractplayer.h"
-#include "defs.h"
-#include "utils.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::AbstractPlayer
-  \internal
-*/
-
-//-----------------------------------------------------------------------------
-// Constructor / destructor
-//-----------------------------------------------------------------------------
-
-MMF::AbstractPlayer::AbstractPlayer(const AbstractPlayer *player)
-        :   m_videoOutput(0)
-        ,   m_volume(InitialVolume)
-        ,   m_state(GroundState)
-        ,   m_error(NoError)
-        ,   m_tickInterval(DefaultTickInterval)
-        ,   m_transitionTime(0)
-        ,   m_prefinishMark(0)
-{
-    if(player) {
-        m_videoOutput = player->m_videoOutput;
-        m_volume = player->m_volume;
-        m_tickInterval = player->m_tickInterval;
-        m_transitionTime = player->m_transitionTime;
-        m_prefinishMark = player->m_prefinishMark;
-    }
-}
-
-//-----------------------------------------------------------------------------
-// MediaObjectInterface
-//-----------------------------------------------------------------------------
-
-qint32 MMF::AbstractPlayer::tickInterval() const
-{
-    return m_tickInterval;
-}
-
-void MMF::AbstractPlayer::setTickInterval(qint32 interval)
-{
-    m_tickInterval = interval;
-    doSetTickInterval(interval);
-}
-
-qint32 MMF::AbstractPlayer::prefinishMark() const
-{
-    return m_prefinishMark;
-}
-
-void MMF::AbstractPlayer::setPrefinishMark(qint32 mark)
-{
-    m_prefinishMark = mark;
-}
-
-qint32 MMF::AbstractPlayer::transitionTime() const
-{
-    return m_transitionTime;
-}
-
-void MMF::AbstractPlayer::setTransitionTime(qint32 time)
-{
-    m_transitionTime = time;
-}
-
-void MMF::AbstractPlayer::volumeChanged(qreal volume)
-{
-    m_volume = volume;
-}
-
-
-//-----------------------------------------------------------------------------
-// Video output
-//-----------------------------------------------------------------------------
-
-void MMF::AbstractPlayer::setVideoOutput(VideoOutput* videoOutput)
-{
-    m_videoOutput = videoOutput;
-    videoOutputChanged();
-}
-
-void MMF::AbstractPlayer::videoOutputChanged()
-{
-    // Default behaviour is empty - overridden by VideoPlayer
-}
-
-void MMF::AbstractPlayer::setError(const QString &errorMessage)
-{
-    TRACE_CONTEXT(AbstractPlayer::setError, EAudioInternal);
-    TRACE_ENTRY("state %d", m_state);
-
-    m_error = Phonon::NormalError;
-    m_errorString = errorMessage;
-    changeState(ErrorState);
-
-    TRACE_EXIT_0();
-}
-
-void MMF::AbstractPlayer::setError(const QString &errorMessage, int symbianError)
-{
-    setError(errorMessage + ": " + Utils::symbianErrorToString(symbianError));
-}
-
-Phonon::ErrorType MMF::AbstractPlayer::errorType() const
-{
-    const Phonon::ErrorType result = (ErrorState == m_state)
-                                     ? m_error : NoError;
-    return result;
-}
-
-QString MMF::AbstractPlayer::errorString() const
-{
-    return m_errorString;
-}
-
-Phonon::State MMF::AbstractPlayer::phononState() const
-{
-    return phononState(m_state);
-}
-
-Phonon::State MMF::AbstractPlayer::phononState(PrivateState state)
-{
-    const Phonon::State phononState =
-        GroundState == state
-        ?    Phonon::LoadingState
-        :    static_cast<Phonon::State>(state);
-
-    return phononState;
-}
-
-AbstractPlayer::PrivateState AbstractPlayer::privateState() const
-{
-    return m_state;
-}
-
-Phonon::State MMF::AbstractPlayer::state() const
-{
-    return phononState(m_state);
-}
-
-void MMF::AbstractPlayer::setState(PrivateState newState)
-{
-    m_state = newState;
-}
-
-void MMF::AbstractPlayer::changeState(PrivateState newState)
-{
-    TRACE_CONTEXT(AbstractPlayer::changeState, EAudioInternal);
-    TRACE_ENTRY("state %d newState %d", privateState(), newState);
-
-    // TODO: add some invariants to check that the transition is valid
-
-    const Phonon::State oldPhononState = phononState(privateState());
-
-    // We need to change the state before we emit stateChanged(), because
-    // some user code, for instance the mediaplayer, switch on MediaObject's
-    // state.
-    setState(newState);
-
-    const Phonon::State newPhononState = phononState(newState);
-
-    if (oldPhononState != newPhononState) {
-        TRACE("emit stateChanged(%d, %d)", newPhononState, oldPhononState);
-        emit stateChanged(newPhononState, oldPhononState);
-    }
-
-    TRACE_EXIT_0();
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/abstractplayer.h b/src/3rdparty/phonon/mmf/abstractplayer.h
deleted file mode 100644
index 310383d..0000000
--- a/src/3rdparty/phonon/mmf/abstractplayer.h
+++ /dev/null
@@ -1,178 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_ABSTRACTPLAYER_H
-#define PHONON_MMF_ABSTRACTPLAYER_H
-
-#include <Phonon/phononnamespace.h>
-#include <Phonon/mediasource.h>
-
-#include <QObject>
-
-#include "videooutput.h"
-
-class RFile;
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-class VideoOutput;
-
-/**
- * @short Interface which abstracts from MediaObject the current
- * media type
- *
- * This may be:
- *  -   Nothing, in which case this interface is implemented by
- *      DummyPlayer
- *  -   Audio, in which case the implementation is AudioPlayer
- *  -   Video, in which case the implementation is VideoPlayer
- */
-class AbstractPlayer : public QObject
-{
-    // Required although this class has no signals or slots
-    // Without this, qobject_cast will fail
-    Q_OBJECT
-
-public:
-    AbstractPlayer(const AbstractPlayer *player);
-
-    virtual void open(const Phonon::MediaSource&, RFile&) = 0;
-
-    // MediaObjectInterface (implemented)
-    qint32 tickInterval() const;
-    void setTickInterval(qint32);
-    void setTransitionTime(qint32);
-    qint32 transitionTime() const;
-    void setPrefinishMark(qint32);
-    qint32 prefinishMark() const;
-
-    // MediaObjectInterface (abstract)
-    virtual void play() = 0;
-    virtual void pause() = 0;
-    virtual void stop() = 0;
-    virtual void seek(qint64 milliseconds) = 0;
-    virtual bool hasVideo() const = 0;
-    virtual bool isSeekable() const = 0;
-    virtual qint64 currentTime() const = 0;
-    virtual Phonon::ErrorType errorType() const;
-    virtual QString errorString() const;
-    virtual qint64 totalTime() const = 0;
-
-    virtual void volumeChanged(qreal volume);
-
-    void setVideoOutput(VideoOutput* videoOutput);
-
-    /**
-     * Records error message and changes state to ErrorState
-     */
-    void setError(const QString &errorMessage);
-
-    /**
-     * Records error message and changes state to ErrorState
-     *
-     * Appends a human-readable version of symbianErrorCode to the error message,
-     * e.g.
-     * @code
-     *      setError("Opening file failed", KErrPermissionDenied)
-     * @endcode
-     * results in the following error message:
-     *      "Opening file failed: permission denied"
-     */
-    void setError(const QString &errorMessage, int symbianErrorCode);
-
-    Phonon::State state() const;
-
-Q_SIGNALS:
-    void totalTimeChanged(qint64 length);
-    void finished();
-    void tick(qint64 time);
-    void bufferStatus(int percentFilled);
-    void stateChanged(Phonon::State oldState,
-                      Phonon::State newState);
-    void metaDataChanged(const QMultiMap<QString, QString>& metaData);
-    void aboutToFinish();
-    void prefinishMarkReached(qint32 remaining);
-
-protected:
-    /**
-     * Defined private state enumeration in order to add GroundState
-     */
-    enum PrivateState {
-        LoadingState    = Phonon::LoadingState,
-        StoppedState    = Phonon::StoppedState,
-        PlayingState    = Phonon::PlayingState,
-        BufferingState  = Phonon::BufferingState,
-        PausedState     = Phonon::PausedState,
-        ErrorState      = Phonon::ErrorState,
-        GroundState
-    };
-
-    /**
-     * Converts PrivateState into the corresponding Phonon::State
-     */
-    Phonon::State phononState() const;
-
-    /**
-     * Converts PrivateState into the corresponding Phonon::State
-     */
-    static Phonon::State phononState(PrivateState state);
-
-    virtual void videoOutputChanged();
-
-    PrivateState privateState() const;
-
-    /**
-     * Changes state and emits stateChanged()
-     */
-    virtual void changeState(PrivateState newState);
-
-    /**
-     * Modifies m_state directly. Typically you want to call changeState(),
-     * which performs the business logic.
-     */
-    void setState(PrivateState newState);
-
-private:
-    virtual void doSetTickInterval(qint32 interval) = 0;
-
-protected:
-    // Not owned
-    VideoOutput*                m_videoOutput;
-
-    qreal                       m_volume;
-
-private:
-    PrivateState                m_state;
-    Phonon::ErrorType           m_error;
-    QString                     m_errorString;
-    qint32                      m_tickInterval;
-    qint32                      m_transitionTime;
-    qint32                      m_prefinishMark;
-
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
-
diff --git a/src/3rdparty/phonon/mmf/ancestormovemonitor.cpp b/src/3rdparty/phonon/mmf/ancestormovemonitor.cpp
deleted file mode 100644
index 18ced94..0000000
--- a/src/3rdparty/phonon/mmf/ancestormovemonitor.cpp
+++ /dev/null
@@ -1,180 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "ancestormovemonitor.h"
-#include "utils.h"
-#include "videooutput.h"
-
-#include <QCoreApplication>
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon::MMF;
-
-/*! \class Phonon::MMF::AncestorMoveMonitor
-  \internal
-  \brief Class which installs a global event filter, and listens for move
-  events which may affect the absolute position of widgets registered with
-  the monitor
-  See QTBUG-4956
-*/
-
-
-/*! \class Phonon::MMF::VideoOutputObserver
-    \internal
-*/
-
-//-----------------------------------------------------------------------------
-// Constructor / destructor
-//-----------------------------------------------------------------------------
-
-AncestorMoveMonitor::AncestorMoveMonitor(QObject *parent)
-    :   QObject(parent)
-{
-    QCoreApplication::instance()->installEventFilter(this);
-}
-
-AncestorMoveMonitor::~AncestorMoveMonitor()
-{
-    QCoreApplication::instance()->removeEventFilter(this);
-}
-
-
-//-----------------------------------------------------------------------------
-// Public functions
-//-----------------------------------------------------------------------------
-
-void AncestorMoveMonitor::registerTarget(VideoOutput *target)
-{
-    TRACE_CONTEXT(AncestorMoveMonitor::registerTarget, EVideoInternal);
-    TRACE_ENTRY("target 0x%08x", target);
-
-    // First un-register the target, in case this is being called as a result
-    // of re-parenting.  This is not the most efficient way to update the
-    // target hash, but since this is not likely to be a frequent operation,
-    // simplicity is preferred over outright speed.  In any case, re-parenting
-    // of the video widget leads to re-creation of native windows, which is
-    // likely to take far more processing than any implementation of this
-    // function.
-    unRegisterTarget(target);
-
-    QWidget *ancestor = target->parentWidget();
-    while(ancestor) {
-        const Hash::iterator it = m_hash.find(ancestor);
-        if(m_hash.end() == it) {
-            TargetList targetList;
-            targetList.append(target);
-            m_hash.insert(ancestor, targetList);
-        } else {
-            TargetList& targetList = it.value();
-            Q_ASSERT(targetList.indexOf(target) == -1);
-            targetList.append(target);
-        }
-        ancestor = ancestor->parentWidget();
-    }
-
-    dump();
-
-    TRACE_EXIT_0();
-}
-
-void AncestorMoveMonitor::unRegisterTarget(VideoOutput *target)
-{
-    TRACE_CONTEXT(AncestorMoveMonitor::unRegisterTarget, EVideoInternal);
-    TRACE_ENTRY("target 0x%08x", target);
-
-    Hash::iterator it = m_hash.begin();
-    while(it != m_hash.end()) {
-        TargetList& targetList = it.value();
-        const int index = targetList.indexOf(target);
-        if(index != -1)
-            targetList.removeAt(index);
-        if(targetList.count())
-            ++it;
-        else
-            it = m_hash.erase(it);
-    }
-
-    dump();
-
-    TRACE_EXIT_0();
-}
-
-bool AncestorMoveMonitor::eventFilter(QObject *watched, QEvent *event)
-{
-    TRACE_CONTEXT(AncestorMoveMonitor::eventFilter, EVideoInternal);
-
-    if(event->type() == QEvent::Move || event->type() == QEvent::ParentChange) {
-
-        //TRACE_ENTRY("watched 0x%08x event.type %d", watched, event->type());
-
-        const Hash::const_iterator it = m_hash.find(watched);
-        if(it != m_hash.end()) {
-            const TargetList& targetList = it.value();
-            VideoOutput* target = 0;
-            foreach(target, targetList) {
-                switch (event->type()) {
-
-                case QEvent::Move:
-                    // Notify the target that its ancestor has moved
-                    target->ancestorMoved();
-                    break;
-
-                case QEvent::ParentChange:
-                    // Update ancestor list for the target
-                    registerTarget(target);
-                    break;
-
-                default:
-                    Q_ASSERT(false);
-                }
-            }
-        }
-
-        //TRACE_EXIT_0();
-    }
-
-    // The event is never consumed by this filter
-    return false;
-}
-
-//-----------------------------------------------------------------------------
-// Private functions
-//-----------------------------------------------------------------------------
-
-void AncestorMoveMonitor::dump()
-{
-#ifndef QT_NO_DEBUG
-    TRACE_CONTEXT(AncestorMoveMonitor::dump, EVideoInternal);
-    for(Hash::const_iterator it = m_hash.begin();
-        it != m_hash.end(); ++it) {
-        const QObject *ancestor = it.key();
-        TRACE("ancestor 0x%08x", ancestor);
-        const TargetList& targetList = it.value();
-        VideoOutput* target = 0;
-        foreach(target, targetList) {
-            TRACE("    target 0x%08x", target);
-        }
-    }
-#endif
-}
-
-
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/ancestormovemonitor.h b/src/3rdparty/phonon/mmf/ancestormovemonitor.h
deleted file mode 100644
index 0e681aa..0000000
--- a/src/3rdparty/phonon/mmf/ancestormovemonitor.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_ANCESTORMOVEMONITOR_H
-#define PHONON_MMF_ANCESTORMOVEMONITOR_H
-
-#include <QObject>
-#include <QHash>
-#include <QList>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-class VideoOutput;
-
-class AncestorMoveMonitor : public QObject
-{
-    Q_OBJECT
-
-public:
-    explicit AncestorMoveMonitor(QObject *parent);
-    ~AncestorMoveMonitor();
-
-    /**
-     * Register target widget for notification.
-     *
-     * The widget receives an ancestorMoveEvent callback when a move event
-     * is delivered to any of its ancestors:
-     *
-     * If the target is already registered, this function causes its
-     * ancestor list to be updated - therefore it should be called when
-     * the target receives a ParentChange event.
-     */
-    void registerTarget(VideoOutput *target);
-
-    /**
-     * Remove target from the monitor.
-     *
-     * The target will no longer receive notification when move events are
-     * delivered to its ancestors.
-     */
-    void unRegisterTarget(VideoOutput *target);
-
-protected:
-    /**
-     * Function which receives events from the global event filter.
-     */
-    bool eventFilter(QObject *watched, QEvent *event);
-
-    void dump();
-
-private:
-    /**
-     * List of registered target widgets which descend from a given
-     * ancestor.
-     *
-     * Note that the members of the list should be non-redundant; this
-     * invariant is checked in debug builds.  Semantically, the value is
-     * therefore a set, however we use QList rather than QSet for
-     * efficiency of iteration.
-     */
-    typedef QList<VideoOutput *> TargetList;
-
-    /**
-     * Map from widget on which the move event occurs, to widgets which
-     * descend from it and therefore need to be notified.
-     */
-    typedef QHash<QObject *, TargetList> Hash;
-    Hash m_hash;
-
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/mmf/audioequalizer.cpp b/src/3rdparty/phonon/mmf/audioequalizer.cpp
deleted file mode 100644
index c2936c5..0000000
--- a/src/3rdparty/phonon/mmf/audioequalizer.cpp
+++ /dev/null
@@ -1,107 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <AudioEqualizerBase.h>
-#include "audioequalizer.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::AudioEqualizer
-  \internal
-*/
-
-AudioEqualizer::AudioEqualizer(QObject *parent) : AbstractAudioEffect::AbstractAudioEffect(parent, createParams())
-{
-}
-
-void AudioEqualizer::parameterChanged(const int pid,
-                                      const QVariant &value)
-{
-    if (m_effect.data()) {
-        const int band = pid;
-        const int level = value.toInt();
-        setBandLevel(band, level);
-    }
-}
-
-void AudioEqualizer::connectAudioPlayer(AudioPlayer::NativePlayer *player)
-{
-    CAudioEqualizer *ptr = 0;
-    QT_TRAP_THROWING(ptr = CAudioEqualizer::NewL(*player));
-    m_effect.reset(ptr);
-}
-
-void AudioEqualizer::applyParameters()
-{
-    if (m_effect.data()) {
-        EffectParameter param;
-        foreach (param, parameters()) {
-            const int band = param.id();
-            const int level = parameterValue(param).toInt();
-            setBandLevel(band, level);
-        }
-    }
-}
-
-void AudioEqualizer::setBandLevel(int band, int level)
-{
-    CAudioEqualizer *const effect = static_cast<CAudioEqualizer *>(m_effect.data());
-    // TODO: handle audio effect errors
-    TRAP_IGNORE(effect->SetBandLevelL(band, level));
-}
-
-QList<EffectParameter> AudioEqualizer::createParams()
-{
-    QList<EffectParameter> retval;
-
-    // We temporarily create an AudioPlayer, and run the effect on it, so
-    // we can extract the readonly data we need.
-    AudioPlayer dummyPlayer;
-
-    CAudioEqualizer *eqPtr = 0;
-    QT_TRAP_THROWING(eqPtr = CAudioEqualizer::NewL(*dummyPlayer.nativePlayer()));
-    QScopedPointer<CAudioEqualizer> e(eqPtr);
-
-    TInt32 dbMin;
-    TInt32 dbMax;
-    e->DbLevelLimits(dbMin, dbMax);
-
-    const int bandCount = e->NumberOfBands();
-
-    for (int i = 0; i < bandCount; ++i) {
-        const qint32 hz = e->CenterFrequency(i);
-
-        const qint32 defVol = e->BandLevel(i);
-
-        retval.append(EffectParameter(i,
-                                      tr("Frequency band, %1 Hz").arg(hz),
-                                      EffectParameter::LogarithmicHint,
-                                      QVariant(qint32(defVol)),
-                                      QVariant(qint32(dbMin)),
-                                      QVariant(qint32(dbMax)),
-                                      QVariantList(),
-                                      QString()));
-    }
-
-    return retval;
-}
-
-QT_END_NAMESPACE
diff --git a/src/3rdparty/phonon/mmf/audioequalizer.h b/src/3rdparty/phonon/mmf/audioequalizer.h
deleted file mode 100644
index 10fe9ad..0000000
--- a/src/3rdparty/phonon/mmf/audioequalizer.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_AUDIOEQUALIZER_H
-#define PHONON_MMF_AUDIOEQUALIZER_H
-
-#include "abstractaudioeffect.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-/**
- * @short A classic equalizer.
- *
- * The equalizer has a number of bands, and each band has a frequency, and a
- * volume. With Phonon's API, this is modeled such that each band is one
- * Phonon::EffectParameter, where Phonon::EffectParameter::id() is the band
- * number, and the setting is the volume level.
- */
-class AudioEqualizer : public AbstractAudioEffect
-{
-    Q_OBJECT
-public:
-    AudioEqualizer(QObject *parent);
-
-protected:
-    // AbstractAudioEffect
-    virtual void connectAudioPlayer(AudioPlayer::NativePlayer *player);
-    virtual void applyParameters();
-    virtual void parameterChanged(const int id, const QVariant &value);
-
-private:
-    void setBandLevel(int band, int level);
-
-private:
-    static QList<EffectParameter> createParams();
-
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
-
diff --git a/src/3rdparty/phonon/mmf/audiooutput.cpp b/src/3rdparty/phonon/mmf/audiooutput.cpp
deleted file mode 100644
index c6be20b..0000000
--- a/src/3rdparty/phonon/mmf/audiooutput.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <e32debug.h>
-
-#include <QCoreApplication>
-
-#include "audiooutput.h"
-#include "defs.h"
-#include "mediaobject.h"
-#include "utils.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::AudioOutput
-  \internal
-*/
-
-//-----------------------------------------------------------------------------
-// Constructor / destructor
-//-----------------------------------------------------------------------------
-
-MMF::AudioOutput::AudioOutput(Backend *, QObject *parent) : MediaNode(parent)
-        , m_volume(InitialVolume)
-{
-
-}
-
-
-//-----------------------------------------------------------------------------
-// Public API
-//-----------------------------------------------------------------------------
-
-qreal MMF::AudioOutput::volume() const
-{
-    return m_volume;
-}
-
-void MMF::AudioOutput::setVolume(qreal volume)
-{
-    TRACE_CONTEXT(AudioOutput::setVolume, EAudioApi);
-    TRACE_ENTRY("volume %f", volume);
-
-    if (volume != m_volume) {
-
-        m_volume = volume;
-        TRACE("emit volumeChanged(%f)", volume)
-        emit volumeChanged(volume);
-    }
-
-    TRACE_EXIT_0();
-}
-
-int MMF::AudioOutput::outputDevice() const
-{
-    return AudioOutputDeviceID;
-}
-
-bool MMF::AudioOutput::setOutputDevice(int index)
-{
-    Q_ASSERT_X(index == AudioOutputDeviceID, Q_FUNC_INFO,
-               "We only support one output device, with id 0");
-    return true;
-}
-
-void MMF::AudioOutput::connectMediaObject(MediaObject *mediaObject)
-{
-    // Ensure that the MediaObject has the correct initial volume
-    mediaObject->volumeChanged(m_volume);
-    // Connect MediaObject to receive future volume changes
-    connect(this, SIGNAL(volumeChanged(qreal)), mediaObject, SLOT(volumeChanged(qreal)));
-}
-
-void MMF::AudioOutput::disconnectMediaObject(MediaObject *mediaObject)
-{
-    // Disconnect all signal-slot connections
-    disconnect(this, 0, mediaObject, 0);
-}
-
-QHash<QByteArray, QVariant> MMF::AudioOutput::audioOutputDescription(int index)
-{
-    QHash<QByteArray, QVariant> retval;
-
-    if (index == AudioOutputDeviceID) {
-        retval.insert("name", QCoreApplication::translate("Phonon::MMF", "Audio Output"));
-        retval.insert("description", QCoreApplication::translate("Phonon::MMF", "The audio output device"));
-        retval.insert("available", true);
-    }
-
-    return retval;
-}
-
-QT_END_NAMESPACE
diff --git a/src/3rdparty/phonon/mmf/audiooutput.h b/src/3rdparty/phonon/mmf/audiooutput.h
deleted file mode 100644
index 67aaa38..0000000
--- a/src/3rdparty/phonon/mmf/audiooutput.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_AUDIOOUTPUT_H
-#define PHONON_MMF_AUDIOOUTPUT_H
-
-#include <QHash>
-
-#include "mmf_medianode.h"
-#include <phonon/audiooutputinterface.h>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-class Backend;
-
-/**
- * @short AudioOutputInterface implementation for MMF.
- *
- * Forwards volume commands to the MediaObject instance,
- * which is provided by the backend when MediaNode objects are
- * connected.
- *
- * \section volume Volume
- *
- * Phonon's concept on volume is from 0.0 to 1.0, and from 1< it does
- * voltage multiplication. CDrmPlayerUtility goes from 1 to
- * CDrmPlayerUtility::MaxVolume(). We apply some basic math to convert
- * between the two.
- *
- * @author Frans Englich<frans.englich@nokia.com>
- */
-class AudioOutput : public MediaNode
-                  , public AudioOutputInterface
-{
-    Q_OBJECT
-    Q_INTERFACES(Phonon::AudioOutputInterface)
-
-public:
-    AudioOutput(Backend *backend, QObject *parent);
-    virtual qreal volume() const;
-    virtual void setVolume(qreal volume);
-
-    virtual int outputDevice() const;
-
-    /**
-     * Has no effect.
-     */
-    virtual bool setOutputDevice(int);
-
-    static QHash<QByteArray, QVariant> audioOutputDescription(int index);
-
-    enum Constants
-    {
-        AudioOutputDeviceID = 0
-    };
-
-protected:
-    // MediaNode
-    void connectMediaObject(MediaObject *mediaObject);
-    void disconnectMediaObject(MediaObject *mediaObject);
-
-Q_SIGNALS:
-    void volumeChanged(qreal volume);
-    void audioDeviceFailed();
-
-private:
-    qreal                           m_volume;
-
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/mmf/audioplayer.cpp b/src/3rdparty/phonon/mmf/audioplayer.cpp
deleted file mode 100644
index ee07229..0000000
--- a/src/3rdparty/phonon/mmf/audioplayer.cpp
+++ /dev/null
@@ -1,279 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <QUrl>
-
-#include "audioplayer.h"
-#include "utils.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::AudioPlayer
-  \internal
-*/
-
-//-----------------------------------------------------------------------------
-// Constructor / destructor
-//-----------------------------------------------------------------------------
-
-MMF::AudioPlayer::AudioPlayer(MediaObject *parent, const AbstractPlayer *player)
-        :   AbstractMediaPlayer(parent, player)
-        ,   m_totalTime(0)
-{
-    construct();
-}
-
-void MMF::AudioPlayer::construct()
-{
-    TRACE_CONTEXT(AudioPlayer::AudioPlayer, EAudioApi);
-    TRACE_ENTRY_0();
-
-    NativePlayer *player = 0;
-    QT_TRAP_THROWING(player = NativePlayer::NewL(*this, 0, EMdaPriorityPreferenceNone));
-    m_player.reset(player);
-    m_player->RegisterForAudioLoadingNotification(*this);
-
-    TRACE_EXIT_0();
-}
-
-MMF::AudioPlayer::~AudioPlayer()
-{
-    TRACE_CONTEXT(AudioPlayer::~AudioPlayer, EAudioApi);
-    TRACE_ENTRY_0();
-
-    TRACE_EXIT_0();
-}
-
-MMF::AudioPlayer::NativePlayer *MMF::AudioPlayer::nativePlayer() const
-{
-    return m_player.data();
-}
-
-//-----------------------------------------------------------------------------
-// Public API
-//-----------------------------------------------------------------------------
-
-void MMF::AudioPlayer::doPlay()
-{
-    m_player->Play();
-}
-
-void MMF::AudioPlayer::doPause()
-{
-    m_player->Pause();
-}
-
-void MMF::AudioPlayer::doStop()
-{
-    m_player->Stop();
-}
-
-void MMF::AudioPlayer::doSeek(qint64 ms)
-{
-    m_player->SetPosition(TTimeIntervalMicroSeconds(ms * 1000));
-}
-
-int MMF::AudioPlayer::setDeviceVolume(int mmfVolume)
-{
-    /* In SDK 3.1, SetVolume() returns void. If we're compiling against
-     * 3.1, we handle it with ifdefs. However, if we compile against a later
-     * SDK but are _running_ against 3.1, we avoid returning from an undefined
-     * stack by doing a runtime check of the SDK version. */
-#if !defined(__SERIES60_31__)
-    const int err = m_player->SetVolume(mmfVolume);
-    if (QSysInfo::s60Version() >= QSysInfo::SV_S60_5_0)
-        return err;
-    else
-        return KErrNone;
- #else
-     m_player->SetVolume(mmfVolume);
-     return KErrNone;
-#endif
-}
-
-int MMF::AudioPlayer::openFile(RFile& file)
-{
-    TRAPD(err, m_player->OpenFileL(file));
-
-#ifdef QT_PHONON_MMF_AUDIO_DRM
-    if (KErrNone == err) {
-        // There appears to be a bug in the CDrmPlayerUtility implementation (at least
-        // in S60 5.x) whereby the player does not check whether the loading observer
-        // pointer is null before dereferencing it.  Therefore we must register for
-        // loading notification, even though we do nothing in the callback functions.
-        m_player->RegisterForAudioLoadingNotification(*this);
-    }
-#endif
-
-    return err;
-}
-
-int MMF::AudioPlayer::openUrl(const QString& /*url*/)
-{
-    // Streaming playback is generally not supported by the implementation
-    // of the audio player API, so we use CVideoPlayerUtility for both
-    // audio and video streaming.
-    Utils::panic(AudioUtilityUrlNotSupported);
-
-    // Silence warning
-    return 0;
-}
-
-int MMF::AudioPlayer::bufferStatus() const
-{
-    int result = 0;
-    TRAP_IGNORE(m_player->GetAudioLoadingProgressL(result));
-    return result;
-}
-
-void MMF::AudioPlayer::close()
-{
-    m_player->Close();
-}
-
-bool MMF::AudioPlayer::hasVideo() const
-{
-    return false;
-}
-
-qint64 MMF::AudioPlayer::currentTime() const
-{
-    TRACE_CONTEXT(AudioPlayer::currentTime, EAudioApi);
-
-    TTimeIntervalMicroSeconds us;
-    const TInt err = m_player->GetPosition(us);
-
-    qint64 result = 0;
-
-    if (KErrNone == err) {
-        result = toMilliSeconds(us);
-    } else {
-        TRACE("GetPosition err %d", err);
-
-        // If we don't cast away constness here, we simply have to ignore
-        // the error.
-        const_cast<AudioPlayer*>(this)->setError(tr("Getting position failed"), err);
-    }
-
-    return result;
-}
-
-qint64 MMF::AudioPlayer::totalTime() const
-{
-    return m_totalTime;
-}
-
-
-//-----------------------------------------------------------------------------
-// Symbian multimedia client observer callbacks
-//-----------------------------------------------------------------------------
-
-#ifdef QT_PHONON_MMF_AUDIO_DRM
-void MMF::AudioPlayer::MdapcInitComplete(TInt aError,
-        const TTimeIntervalMicroSeconds &)
-#else
-void MMF::AudioPlayer::MapcInitComplete(TInt aError,
-                                        const TTimeIntervalMicroSeconds &)
-#endif
-{
-    TRACE_CONTEXT(AudioPlayer::MapcInitComplete, EAudioInternal);
-    TRACE_ENTRY("state %d error %d", state(), aError);
-
-    __ASSERT_ALWAYS(LoadingState == state(), Utils::panic(InvalidStatePanic));
-
-    if (KErrNone == aError) {
-        maxVolumeChanged(m_player->MaxVolume());
-        m_totalTime = toMilliSeconds(m_player->Duration());
-        emit totalTimeChanged(m_totalTime);
-        updateMetaData();
-        changeState(StoppedState);
-    } else {
-        setError(tr("Opening clip failed"), aError);
-    }
-
-    TRACE_EXIT_0();
-}
-
-#ifdef QT_PHONON_MMF_AUDIO_DRM
-void MMF::AudioPlayer::MdapcPlayComplete(TInt aError)
-#else
-void MMF::AudioPlayer::MapcPlayComplete(TInt aError)
-#endif
-{
-    TRACE_CONTEXT(AudioPlayer::MapcPlayComplete, EAudioInternal);
-    TRACE_ENTRY("state %d error %d", state(), aError);
-
-    // Call base class function which handles end of playback for both
-    // audio and video clips.
-    playbackComplete(aError);
-
-    TRACE_EXIT_0();
-}
-
-#ifdef QT_PHONON_MMF_AUDIO_DRM
-void MMF::AudioPlayer::MaloLoadingStarted()
-{
-
-}
-
-void MMF::AudioPlayer::MaloLoadingComplete()
-{
-
-}
-#endif // QT_PHONON_MMF_AUDIO_DRM
-
-
-//-----------------------------------------------------------------------------
-// MAudioLoadingObserver callbacks
-//-----------------------------------------------------------------------------
-
-void MMF::AudioPlayer::MaloLoadingStarted()
-{
-    bufferingStarted();
-}
-
-void MMF::AudioPlayer::MaloLoadingComplete()
-{
-    bufferingComplete();
-}
-
-
-//-----------------------------------------------------------------------------
-// Private functions
-//-----------------------------------------------------------------------------
-
-int MMF::AudioPlayer::numberOfMetaDataEntries() const
-{
-    int numberOfEntries = 0;
-    m_player->GetNumberOfMetaDataEntries(numberOfEntries); // ignoring return code
-    return numberOfEntries;
-}
-
-QPair<QString, QString> MMF::AudioPlayer::metaDataEntry(int index) const
-{
-    CMMFMetaDataEntry *entry = 0;
-    QT_TRAP_THROWING(entry = m_player->GetMetaDataEntryL(index));
-    return QPair<QString, QString>(qt_TDesC2QString(entry->Name()), qt_TDesC2QString(entry->Value()));
-}
-
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/audioplayer.h b/src/3rdparty/phonon/mmf/audioplayer.h
deleted file mode 100644
index 0eb8bb7..0000000
--- a/src/3rdparty/phonon/mmf/audioplayer.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_AUDIOPLAYER_H
-#define PHONON_MMF_AUDIOPLAYER_H
-
-#include "abstractmediaplayer.h"
-
-class CDrmPlayerUtility;
-class TTimeIntervalMicroSeconds;
-
-#ifdef QT_PHONON_MMF_AUDIO_DRM
-#include <drmaudiosampleplayer.h>
-typedef MDrmAudioPlayerCallback NativePlayerObserver;
-#else
-#include <mdaaudiosampleplayer.h>
-typedef MMdaAudioPlayerCallback NativePlayerObserver;
-#endif
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-/**
- * @short Wrapper over MMF audio client utility
- */
-class AudioPlayer   :   public AbstractMediaPlayer
-                    ,   public NativePlayerObserver
-                    ,   public MAudioLoadingObserver
-{
-    Q_OBJECT
-
-public:
-    AudioPlayer(MediaObject *parent = 0, const AbstractPlayer *player = 0);
-    virtual ~AudioPlayer();
-
-#ifdef QT_PHONON_MMF_AUDIO_DRM
-typedef CDrmPlayerUtility NativePlayer;
-#else
-typedef CMdaAudioPlayerUtility NativePlayer;
-#endif
-
-    NativePlayer *nativePlayer() const;
-
-    // AbstractMediaPlayer
-    virtual void doPlay();
-    virtual void doPause();
-    virtual void doStop();
-    virtual void doSeek(qint64 milliseconds);
-    virtual int setDeviceVolume(int mmfVolume);
-    virtual int openFile(RFile& file);
-    virtual int openUrl(const QString& url);
-    virtual int bufferStatus() const;
-    virtual void close();
-
-    // MediaObjectInterface
-    virtual bool hasVideo() const;
-    virtual qint64 currentTime() const;
-    virtual qint64 totalTime() const;
-
-    // AbstractMediaPlayer
-    virtual int numberOfMetaDataEntries() const;
-    virtual QPair<QString, QString> metaDataEntry(int index) const;
-
-    /**
-     * This class owns the pointer.
-     */
-    NativePlayer *player() const;
-
-private:
-    void construct();
-
-private:
-#ifdef QT_PHONON_MMF_AUDIO_DRM
-    // MDrmAudioPlayerCallback
-    virtual void MdapcInitComplete(TInt aError,
-                                   const TTimeIntervalMicroSeconds &aDuration);
-    virtual void MdapcPlayComplete(TInt aError);
-#else
-    // MMdaAudioPlayerCallback
-    virtual void MapcInitComplete(TInt aError,
-                                  const TTimeIntervalMicroSeconds &aDuration);
-    virtual void MapcPlayComplete(TInt aError);
-#endif
-
-    // MAudioLoadingObserver
-    virtual void MaloLoadingStarted();
-    virtual void MaloLoadingComplete();
-
-private:
-    /**
-     * Using CPlayerType typedef in order to be able to easily switch between
-     * CMdaAudioPlayerUtility and CDrmPlayerUtility
-     */
-    QScopedPointer<NativePlayer> m_player;
-
-    qint64                      m_totalTime;
-
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/mmf/backend.cpp b/src/3rdparty/phonon/mmf/backend.cpp
deleted file mode 100644
index 0c07f66..0000000
--- a/src/3rdparty/phonon/mmf/backend.cpp
+++ /dev/null
@@ -1,214 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <QStringList>
-#include <QtPlugin>
-
-#include <apgcli.h> // for RApaLsSession
-#include <apmrec.h> // for CDataTypeArray
-#include <apmstd.h> // for TDataType
-
-#include "abstractaudioeffect.h"
-#include "ancestormovemonitor.h"
-#include "audiooutput.h"
-#include "audioplayer.h"
-#include "backend.h"
-#include "effectfactory.h"
-#include "mediaobject.h"
-#include "utils.h"
-#include "videowidget.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::Backend
-  \internal
-*/
-
-Backend::Backend(QObject *parent)
-    : QObject(parent)
-    , m_ancestorMoveMonitor(new AncestorMoveMonitor(this))
-{
-    TRACE_CONTEXT(Backend::Backend, EBackend);
-    TRACE_ENTRY_0();
-
-    setProperty("identifier",     QLatin1String("phonon_mmf"));
-    setProperty("backendName",    QLatin1String("MMF"));
-    setProperty("backendComment", QLatin1String("Backend using Symbian Multimedia Framework (MMF)"));
-    setProperty("backendVersion", QLatin1String("0.1"));
-    setProperty("backendWebsite", QLatin1String("http://qt.nokia.com/"));
-
-    TRACE_EXIT_0();
-}
-
-QObject *Backend::createObject(BackendInterface::Class c, QObject *parent, const QList<QVariant> &args)
-{
-    TRACE_CONTEXT(Backend::createObject, EBackend);
-    TRACE_ENTRY("class %d", c);
-
-    QObject* result = 0;
-
-    switch (c) {
-    case AudioOutputClass:
-        result = new AudioOutput(this, parent);
-        break;
-
-    case MediaObjectClass:
-        result = new MediaObject(parent);
-        break;
-
-    case VolumeFaderEffectClass:
-    case VisualizationClass:
-    case VideoDataOutputClass:
-    case EffectClass:
-    {
-        Q_ASSERT(args.count() == 1);
-        Q_ASSERT(args.first().type() == QVariant::Int);
-        const AbstractAudioEffect::Type effect = AbstractAudioEffect::Type(args.first().toInt());
-
-        return EffectFactory::createAudioEffect(effect, parent);
-    }
-    case VideoWidgetClass:
-        result = new VideoWidget(m_ancestorMoveMonitor.data(), qobject_cast<QWidget *>(parent));
-        break;
-
-    default:
-        TRACE_PANIC(InvalidBackendInterfaceClass);
-    }
-
-    TRACE_RETURN("0x%08x", result);
-}
-
-QList<int> Backend::objectDescriptionIndexes(ObjectDescriptionType type) const
-{
-    TRACE_CONTEXT(Backend::objectDescriptionIndexes, EAudioApi);
-    TRACE_ENTRY_0();
-    QList<int> retval;
-
-    switch(type)
-    {
-        case EffectType:
-            retval.append(EffectFactory::effectIndexes());
-            break;
-        case AudioOutputDeviceType:
-            // We only have one possible output device, but we need at least
-            // one.
-            retval.append(AudioOutput::AudioOutputDeviceID);
-            break;
-        default:
-            ;
-    }
-
-    TRACE_EXIT_0();
-    return retval;
-}
-
-QHash<QByteArray, QVariant> Backend::objectDescriptionProperties(ObjectDescriptionType type, int index) const
-{
-    TRACE_CONTEXT(Backend::connectNodes, EBackend);
-
-    switch (type) {
-        case EffectType:
-            return EffectFactory::audioEffectDescriptions(AbstractAudioEffect::Type(index));
-        case AudioOutputDeviceType:
-            return AudioOutput::audioOutputDescription(index);
-        default:
-            return QHash<QByteArray, QVariant>();
-    }
-}
-
-bool Backend::startConnectionChange(QSet<QObject *>)
-{
-    return true;
-}
-
-bool Backend::connectNodes(QObject *sourceObject, QObject *targetObject)
-{
-    TRACE_CONTEXT(Backend::connectNodes, EBackend);
-    TRACE_ENTRY("source 0x%08x target 0x%08x", sourceObject, targetObject);
-
-    MediaNode *const source = qobject_cast<MediaNode *>(sourceObject);
-    MediaNode *const target = qobject_cast<MediaNode *>(targetObject);
-
-    Q_ASSERT_X(source, Q_FUNC_INFO, "source is not a MediaNode");
-    Q_ASSERT_X(target, Q_FUNC_INFO, "target is not a MediaNode");
-
-    return source->connectOutput(target);
-}
-
-bool Backend::disconnectNodes(QObject *sourceObject, QObject *targetObject)
-{
-    TRACE_CONTEXT(Backend::disconnectNodes, EBackend);
-    TRACE_ENTRY("source 0x%08x target 0x%08x", sourceObject, targetObject);
-
-    MediaNode *const source = qobject_cast<MediaNode *>(sourceObject);
-    MediaNode *const target = qobject_cast<MediaNode *>(targetObject);
-
-    Q_ASSERT_X(source, Q_FUNC_INFO, "source is not a MediaNode");
-    Q_ASSERT_X(target, Q_FUNC_INFO, "target is not a MediaNode");
-
-    return source->disconnectOutput(target);
-}
-
-bool Backend::endConnectionChange(QSet<QObject *>)
-{
-    return true;
-}
-
-void getAvailableMimeTypesL(QStringList& result)
-{
-    RApaLsSession apaSession;
-    User::LeaveIfError(apaSession.Connect());
-    CleanupClosePushL(apaSession);
-
-    static const TInt DataTypeArrayGranularity = 8;
-    CDataTypeArray* array = new(ELeave) CDataTypeArray(DataTypeArrayGranularity);
-    CleanupStack::PushL(array);
-
-    apaSession.GetSupportedDataTypesL(*array);
-
-    for (TInt i = 0; i < array->Count(); ++i) {
-        const TPtrC mimeType = array->At(i).Des();
-        const MediaType mediaType = Utils::mimeTypeToMediaType(mimeType);
-        if (MediaTypeAudio == mediaType or MediaTypeVideo == mediaType) {
-            result.append(qt_TDesC2QString(mimeType));
-        }
-    }
-
-    CleanupStack::PopAndDestroy(2); // apaSession, array
-}
-
-QStringList Backend::availableMimeTypes() const
-{
-    QStringList result;
-
-    // There is no way to return an error from this function, so we just
-    // have to trap and ignore exceptions...
-    TRAP_IGNORE(getAvailableMimeTypesL(result));
-
-    result.sort();
-
-    return result;
-}
-
-Q_EXPORT_PLUGIN2(phonon_mmf, Phonon::MMF::Backend);
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/backend.h b/src/3rdparty/phonon/mmf/backend.h
deleted file mode 100644
index 9db9e40..0000000
--- a/src/3rdparty/phonon/mmf/backend.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_BACKEND_H
-#define PHONON_MMF_BACKEND_H
-
-#include "ancestormovemonitor.h"
-
-#include <Phonon/mediasource.h>
-#include <Phonon/backendinterface.h>
-#include <QScopedPointer>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-class Backend : public QObject
-              , public BackendInterface
-{
-    Q_OBJECT
-    Q_INTERFACES(Phonon::BackendInterface)
-public:
-    Backend(QObject *parent = 0);
-
-    virtual QObject *createObject(BackendInterface::Class c, QObject *parent, const QList<QVariant> &args);
-    virtual QList<int> objectDescriptionIndexes(ObjectDescriptionType type) const;
-    virtual QHash<QByteArray, QVariant> objectDescriptionProperties(ObjectDescriptionType type, int index) const;
-    virtual bool startConnectionChange(QSet<QObject *>);
-    virtual bool connectNodes(QObject *, QObject *);
-    virtual bool disconnectNodes(QObject *, QObject *);
-    virtual bool endConnectionChange(QSet<QObject *>);
-    virtual QStringList availableMimeTypes() const;
-
-Q_SIGNALS:
-    void objectDescriptionChanged(ObjectDescriptionType);
-
-private:
-    QScopedPointer<AncestorMoveMonitor> m_ancestorMoveMonitor;
-
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/mmf/bassboost.cpp b/src/3rdparty/phonon/mmf/bassboost.cpp
deleted file mode 100644
index ae96b45..0000000
--- a/src/3rdparty/phonon/mmf/bassboost.cpp
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <BassBoostBase.h>
-#include "bassboost.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::BassBoost
-  \internal
-*/
-
-BassBoost::BassBoost(QObject *parent) : AbstractAudioEffect::AbstractAudioEffect(parent,
-                                                                                QList<EffectParameter>())
-{
-}
-
-void BassBoost::parameterChanged(const int,
-                                 const QVariant &)
-{
-    Q_ASSERT_X(false, Q_FUNC_INFO, "BassBoost has not parameters");
-}
-
-void BassBoost::connectAudioPlayer(AudioPlayer::NativePlayer *player)
-{
-    CBassBoost *ptr = 0;
-    QT_TRAP_THROWING(ptr = CBassBoost::NewL(*player));
-    m_effect.reset(ptr);
-}
-
-void BassBoost::applyParameters()
-{
-    // No parameters to apply
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/bassboost.h b/src/3rdparty/phonon/mmf/bassboost.h
deleted file mode 100644
index 4ad0a6c..0000000
--- a/src/3rdparty/phonon/mmf/bassboost.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_BASSBOOST_H
-#define PHONON_MMF_BASSBOOST_H
-
-#include "abstractaudioeffect.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-/**
- * @short An "bass boost" effect.
- *
- * The documentation does not say what "bass boost" is, neither has it anykind
- * of setting. It's an on or off thing.
- */
-class BassBoost : public AbstractAudioEffect
-{
-    Q_OBJECT
-public:
-    BassBoost(QObject *parent);
-
-protected:
-    // AbstractAudioEffect
-    virtual void connectAudioPlayer(AudioPlayer::NativePlayer *player);
-    virtual void applyParameters();
-    virtual void parameterChanged(const int id, const QVariant &value);
-
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
-
diff --git a/src/3rdparty/phonon/mmf/defs.h b/src/3rdparty/phonon/mmf/defs.h
deleted file mode 100644
index 1a93aa9..0000000
--- a/src/3rdparty/phonon/mmf/defs.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_DEFS_H
-#define PHONON_MMF_DEFS_H
-
-#include <QtGlobal>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-static const qint32 DefaultTickInterval = 10;
-static const qreal  InitialVolume = 0.5;
-
-enum MediaType {
-    MediaTypeUnknown,
-    MediaTypeAudio,
-    MediaTypeVideo
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif // PHONON_MMF_DEFS_H
diff --git a/src/3rdparty/phonon/mmf/dummyplayer.cpp b/src/3rdparty/phonon/mmf/dummyplayer.cpp
deleted file mode 100644
index 6970088..0000000
--- a/src/3rdparty/phonon/mmf/dummyplayer.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "dummyplayer.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::DummyPlayer
-  \internal
-*/
-
-//-----------------------------------------------------------------------------
-// Constructor / destructor
-//-----------------------------------------------------------------------------
-
-MMF::DummyPlayer::DummyPlayer(const AbstractPlayer *player)
-        :   AbstractPlayer(player)
-{
-
-}
-
-
-//-----------------------------------------------------------------------------
-// MediaObjectInterface
-//-----------------------------------------------------------------------------
-
-void MMF::DummyPlayer::play()
-{
-
-}
-
-void MMF::DummyPlayer::pause()
-{
-
-}
-
-void MMF::DummyPlayer::stop()
-{
-
-}
-
-void MMF::DummyPlayer::seek(qint64)
-{
-
-}
-
-bool MMF::DummyPlayer::hasVideo() const
-{
-    return false;
-}
-
-bool MMF::DummyPlayer::isSeekable() const
-{
-    return false;
-}
-
-Phonon::State MMF::DummyPlayer::state() const
-{
-    return Phonon::LoadingState;
-}
-
-qint64 MMF::DummyPlayer::currentTime() const
-{
-    return 0;
-}
-
-Phonon::ErrorType MMF::DummyPlayer::errorType() const
-{
-    return Phonon::NoError;
-}
-
-qint64 MMF::DummyPlayer::totalTime() const
-{
-    return 0;
-}
-
-void MMF::DummyPlayer::open(const Phonon::MediaSource &, RFile &)
-{
-
-}
-
-
-//-----------------------------------------------------------------------------
-// AbstractPlayer
-//-----------------------------------------------------------------------------
-
-void MMF::DummyPlayer::doSetTickInterval(qint32)
-{
-
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/dummyplayer.h b/src/3rdparty/phonon/mmf/dummyplayer.h
deleted file mode 100644
index 6841b5d..0000000
--- a/src/3rdparty/phonon/mmf/dummyplayer.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_DUMMYPLAYER_H
-#define PHONON_MMF_DUMMYPLAYER_H
-
-#include "abstractplayer.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-class AudioOutput;
-
-/**
- * @short Stub implementation of AbstractPlayer.
- *
- * The functions of this class are:
- * -    Allow MediaObject to call a subset of the MediaObjectInterface
- *      API, before SetSource has been called.
- * -    Cache any parameters which are set in this state (e.g.
- *      prefinish mark), so that they can be copied into the 'real'
- *      AbstractPlayer implementation once a source has been loaded.
- */
-class DummyPlayer : public AbstractPlayer
-{
-public:
-    DummyPlayer(const AbstractPlayer *player = 0);
-
-    // MediaObjectInterface
-    virtual void play();
-    virtual void pause();
-    virtual void stop();
-    virtual void seek(qint64 milliseconds);
-    virtual bool hasVideo() const;
-    virtual bool isSeekable() const;
-    virtual qint64 currentTime() const;
-    virtual Phonon::State state() const;
-    virtual Phonon::ErrorType errorType() const;
-    virtual qint64 totalTime() const;
-
-    // AbstractPlayer
-    virtual void open(const Phonon::MediaSource&, RFile&);
-    virtual void doSetTickInterval(qint32 interval);
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/mmf/effectfactory.cpp b/src/3rdparty/phonon/mmf/effectfactory.cpp
deleted file mode 100644
index cc94367..0000000
--- a/src/3rdparty/phonon/mmf/effectfactory.cpp
+++ /dev/null
@@ -1,155 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <QObject>
-#include <QCoreApplication>
-
-#include <AudioEqualizerBase.h>
-#include <BassBoostBase.h>
-#include <DistanceAttenuationBase.h>
-#include <DopplerBase.h>
-#include <EnvironmentalReverbBase.h>
-#include <ListenerOrientationBase.h>
-#include <LocationBase.h>
-#include <LoudnessBase.h>
-#include <SourceOrientationBase.h>
-#include <StereoWideningBase.h>
-
-#include "audioequalizer.h"
-#include "bassboost.h"
-
-#include "effectfactory.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::EffectFactory
-  \internal
-*/
-
-QHash<QByteArray, QVariant> EffectFactory::constructEffectDescription(const QString &name,
-                                                                      const QString &description)
-{
-    QHash<QByteArray, QVariant> retval;
-
-    retval.insert("name", name);
-    retval.insert("description", description);
-    retval.insert("available", true);
-
-    return retval;
-}
-
-
-QHash<QByteArray, QVariant> EffectFactory::audioEffectDescriptions(AbstractAudioEffect::Type type)
-{
-    switch (type)
-    {
-        case AbstractAudioEffect::EffectAudioEqualizer:
-            return constructEffectDescription(QCoreApplication::translate("Phonon::MMF::EffectFactory", "Audio Equalizer"), "Audio equalizer.");
-        case AbstractAudioEffect::EffectBassBoost:
-            return constructEffectDescription(QCoreApplication::translate("Phonon::MMF::EffectFactory", "Bass Boost"), "Bass boost.");
-        case AbstractAudioEffect::EffectDistanceAttenuation:
-            return constructEffectDescription(QCoreApplication::translate("Phonon::MMF::EffectFactory", "Distance Attenuation"), "Distance Attenuation.");
-        case AbstractAudioEffect::EffectEnvironmentalReverb:
-            return constructEffectDescription(QCoreApplication::translate("Phonon::MMF::EffectFactory", "Environmental Reverb"), "Environmental Reverb.");
-        case AbstractAudioEffect::EffectListenerOrientation:
-            return constructEffectDescription(QCoreApplication::translate("Phonon::MMF::EffectFactory", "Environmental Reverb"), "Environmental Reverb.");
-        case AbstractAudioEffect::EffectLoudness:
-            return constructEffectDescription(QCoreApplication::translate("Phonon::MMF::EffectFactory", "Loudness"), "Loudness.");
-        case AbstractAudioEffect::EffectSourceOrientation:
-            return constructEffectDescription(QCoreApplication::translate("Phonon::MMF::EffectFactory", "Source Orientation"), "Source Orientation.");
-        case AbstractAudioEffect::EffectStereoWidening:
-            return constructEffectDescription(QCoreApplication::translate("Phonon::MMF::EffectFactory", "Stereo Widening"), "Stereo Widening.");
-    }
-
-    Q_ASSERT_X(false, Q_FUNC_INFO, "Unknown effect type.");
-    return QHash<QByteArray, QVariant>();
-}
-
-AbstractAudioEffect *EffectFactory::createAudioEffect(AbstractAudioEffect::Type type,
-                                                      QObject *parent)
-{
-    Q_ASSERT(parent);
-
-    switch (type)
-    {
-        case AbstractAudioEffect::EffectBassBoost:
-            return new BassBoost(parent);
-        case AbstractAudioEffect::EffectAudioEqualizer:
-            return new AudioEqualizer(parent);
-        case AbstractAudioEffect::EffectDistanceAttenuation:
-        case AbstractAudioEffect::EffectEnvironmentalReverb:
-        case AbstractAudioEffect::EffectListenerOrientation:
-        case AbstractAudioEffect::EffectLoudness:
-        case AbstractAudioEffect::EffectSourceOrientation:
-        case AbstractAudioEffect::EffectStereoWidening:
-            ;
-    }
-
-    Q_ASSERT_X(false, Q_FUNC_INFO, "Unknown effect.");
-    return 0;
-}
-
-template<typename TEffect>
-bool isEffectSupported()
-{
-    AudioPlayer audioPlayer;
-
-    QScopedPointer<TEffect> eff;
-    TRAPD(errorCode, eff.reset(TEffect::NewL(*audioPlayer.nativePlayer())));
-
-    return errorCode != KErrNone;
-}
-
-QList<int> EffectFactory::effectIndexes()
-{
-    QList<int> retval;
-
-    if (isEffectSupported<CAudioEqualizer>())
-        retval.append(AbstractAudioEffect::EffectAudioEqualizer);
-
-    if (isEffectSupported<CBassBoost>())
-        retval.append(AbstractAudioEffect::EffectBassBoost);
-
-    /* We haven't implemented these yet.
-    if (isEffectSupported<CDistanceAttenuation>())
-        retval.append(AbstractAudioEffect::EffectDistanceAttenuation);
-
-    if (isEffectSupported<CEnvironmentalReverb>())
-        retval.append(AbstractAudioEffect::EffectEnvironmentalReverb);
-
-    if (isEffectSupported<CLoudness>())
-        retval.append(AbstractAudioEffect::EffectLoudness);
-
-    if (isEffectSupported<CListenerOrientation>())
-        retval.append(AbstractAudioEffect::EffectListenerOrientation);
-
-    if (isEffectSupported<CSourceOrientation>())
-        retval.append(AbstractAudioEffect::EffectSourceOrientation);
-
-    if (isEffectSupported<CStereoWidening>())
-        retval.append(AbstractAudioEffect::EffectStereoWidening);
-    */
-
-    return retval;
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/effectfactory.h b/src/3rdparty/phonon/mmf/effectfactory.h
deleted file mode 100644
index e83ad15..0000000
--- a/src/3rdparty/phonon/mmf/effectfactory.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_EFFECTFACTORY_H
-#define PHONON_MMF_EFFECTFACTORY_H
-
-#include "abstractaudioeffect.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-
-/**
- * @short Contains utility functions related to effects.
- */
-class EffectFactory
-{
-public:
-    /**
-     * @short Creates an audio effect of type @p type.
-     */
-    static AbstractAudioEffect *createAudioEffect(AbstractAudioEffect::Type type,
-                                                  QObject *parent);
-
-    /**
-     * @short Return the properties for effect @p type.
-     *
-     * This handles the effects for
-     * BackendInterface::objectDescriptionProperties().
-     */
-    static QHash<QByteArray, QVariant> audioEffectDescriptions(AbstractAudioEffect::Type type);
-
-    /**
-     * @short Returns the indexes for the supported effects.
-     *
-     * This handles the effects for
-     * BackendInterface::objectDescriptionIndexes().
-     */
-    static QList<int> effectIndexes();
-
-private:
-    static inline QHash<QByteArray, QVariant> constructEffectDescription(const QString &name,
-                                                                         const QString &description);
-
-    /**
-     * This class is not supposed to be instantiated, so disable
-     * the default constructor.
-     */
-    inline EffectFactory();
-    Q_DISABLE_COPY(EffectFactory)
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
-
diff --git a/src/3rdparty/phonon/mmf/mediaobject.cpp b/src/3rdparty/phonon/mmf/mediaobject.cpp
deleted file mode 100644
index 4653fee..0000000
--- a/src/3rdparty/phonon/mmf/mediaobject.cpp
+++ /dev/null
@@ -1,408 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "audiooutput.h"
-#include "audioplayer.h"
-#include "defs.h"
-#include "dummyplayer.h"
-#include "utils.h"
-#include "utils.h"
-#include "mmf_videoplayer.h"
-#include "videowidget.h"
-
-#include "mediaobject.h"
-
-#include <QDir>
-#include <QUrl>
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::MediaObject
-  \internal
-*/
-
-//-----------------------------------------------------------------------------
-// Constructor / destructor
-//-----------------------------------------------------------------------------
-
-MMF::MediaObject::MediaObject(QObject *parent) : MMF::MediaNode::MediaNode(parent)
-                                               , m_recognizerOpened(false)
-                                               , m_nextSourceSet(false)
-{
-    m_player.reset(new DummyPlayer());
-
-    TRACE_CONTEXT(MediaObject::MediaObject, EAudioApi);
-    TRACE_ENTRY_0();
-
-    Q_UNUSED(parent);
-
-    TRACE_EXIT_0();
-}
-
-MMF::MediaObject::~MediaObject()
-{
-    TRACE_CONTEXT(MediaObject::~MediaObject, EAudioApi);
-    TRACE_ENTRY_0();
-
-    m_file.Close();
-    m_fileServer.Close();
-    m_recognizer.Close();
-
-    TRACE_EXIT_0();
-}
-
-
-//-----------------------------------------------------------------------------
-// Recognizer
-//-----------------------------------------------------------------------------
-
-bool MMF::MediaObject::openRecognizer()
-{
-    TRACE_CONTEXT(MediaObject::openRecognizer, EAudioInternal);
-
-    if (!m_recognizerOpened) {
-        TInt err = m_recognizer.Connect();
-        if (KErrNone != err) {
-            TRACE("RApaLsSession::Connect error %d", err);
-            return false;
-        }
-
-        err = m_fileServer.Connect();
-        if (KErrNone != err) {
-            TRACE("RFs::Connect error %d", err);
-            return false;
-        }
-
-        // This must be called in order to be able to share file handles with
-        // the recognizer server (see fileMediaType function).
-        err = m_fileServer.ShareProtected();
-        if (KErrNone != err) {
-            TRACE("RFs::ShareProtected error %d", err);
-            return false;
-        }
-
-        m_recognizerOpened = true;
-    }
-
-    return true;
-}
-
-MMF::MediaType MMF::MediaObject::fileMediaType
-(const QString& fileName)
-{
-    TRACE_CONTEXT(MediaObject::fileMediaType, EAudioInternal);
-
-    MediaType result = MediaTypeUnknown;
-
-    if (openRecognizer()) {
-
-        const QHBufC fileNameSymbian(QDir::toNativeSeparators(fileName));
-
-        m_file.Close();
-        TInt err = m_file.Open(m_fileServer, *fileNameSymbian, EFileRead | EFileShareReadersOnly);
-
-        if (KErrNone == err) {
-            TDataRecognitionResult recognizerResult;
-            err = m_recognizer.RecognizeData(m_file, recognizerResult);
-            if (KErrNone == err) {
-                const TPtrC mimeType = recognizerResult.iDataType.Des();
-                result = Utils::mimeTypeToMediaType(mimeType);
-            } else {
-                TRACE("RApaLsSession::RecognizeData filename %S error %d", fileNameSymbian.data(), err);
-            }
-        } else {
-            TRACE("RFile::Open filename %S error %d", fileNameSymbian.data(), err);
-        }
-    }
-
-    return result;
-}
-
-
-//-----------------------------------------------------------------------------
-// MediaObjectInterface
-//-----------------------------------------------------------------------------
-
-void MMF::MediaObject::play()
-{
-    m_player->play();
-}
-
-void MMF::MediaObject::pause()
-{
-    m_player->pause();
-}
-
-void MMF::MediaObject::stop()
-{
-    m_player->stop();
-}
-
-void MMF::MediaObject::seek(qint64 ms)
-{
-    m_player->seek(ms);
-
-    if (state() == PausedState or state() == PlayingState) {
-        emit tick(currentTime());
-    }
-}
-
-qint32 MMF::MediaObject::tickInterval() const
-{
-    return m_player->tickInterval();
-}
-
-void MMF::MediaObject::setTickInterval(qint32 interval)
-{
-    m_player->setTickInterval(interval);
-}
-
-bool MMF::MediaObject::hasVideo() const
-{
-    return m_player->hasVideo();
-}
-
-bool MMF::MediaObject::isSeekable() const
-{
-    return m_player->isSeekable();
-}
-
-Phonon::State MMF::MediaObject::state() const
-{
-    return m_player->state();
-}
-
-qint64 MMF::MediaObject::currentTime() const
-{
-    return m_player->currentTime();
-}
-
-QString MMF::MediaObject::errorString() const
-{
-    return m_player->errorString();
-}
-
-Phonon::ErrorType MMF::MediaObject::errorType() const
-{
-    return m_player->errorType();
-}
-
-qint64 MMF::MediaObject::totalTime() const
-{
-    return m_player->totalTime();
-}
-
-MediaSource MMF::MediaObject::source() const
-{
-    return m_source;
-}
-
-void MMF::MediaObject::setSource(const MediaSource &source)
-{
-    switchToSource(source);
-}
-
-void MMF::MediaObject::switchToSource(const MediaSource &source)
-{
-    createPlayer(source);
-    m_source = source;
-    m_player->open(m_source, m_file);
-    emit currentSourceChanged(m_source);
-}
-
-void MMF::MediaObject::createPlayer(const MediaSource &source)
-{
-    TRACE_CONTEXT(MediaObject::createPlayer, EAudioApi);
-    TRACE_ENTRY("state %d source.type %d", state(), source.type());
-    TRACE_ENTRY("source.type %d", source.type());
-
-    MediaType mediaType = MediaTypeUnknown;
-
-    AbstractPlayer* oldPlayer = m_player.data();
-
-    const bool oldPlayerHasVideo = oldPlayer->hasVideo();
-    const bool oldPlayerSeekable = oldPlayer->isSeekable();
-
-    QString errorMessage;
-
-    // Determine media type
-    switch (source.type()) {
-    case MediaSource::LocalFile:
-        mediaType = fileMediaType(source.fileName());
-        break;
-
-    case MediaSource::Url:
-        {
-            const QUrl url(source.url());
-            if (url.scheme() == QLatin1String("file")) {
-                mediaType = fileMediaType(url.toLocalFile());
-            }
-            else {
-                // Streaming playback is generally not supported by the implementation
-                // of the audio player API, so we use CVideoPlayerUtility for both
-                // audio and video streaming.
-                mediaType = MediaTypeVideo;
-            }
-        }
-        break;
-
-    case MediaSource::Invalid:
-    case MediaSource::Disc:
-    case MediaSource::Stream:
-        errorMessage = tr("Error opening source: type not supported");
-        break;
-
-    case MediaSource::Empty:
-        TRACE_0("Empty media source");
-        break;
-    }
-
-    AbstractPlayer* newPlayer = 0;
-
-    // Construct newPlayer using oldPlayer (if not 0) in order to copy
-    // parameters (volume, prefinishMark, transitionTime) which may have
-    // been set on oldPlayer.
-
-    switch (mediaType) {
-    case MediaTypeUnknown:
-        TRACE_0("Media type could not be determined");
-        newPlayer = new DummyPlayer(oldPlayer);
-        errorMessage = tr("Error opening source: media type could not be determined");
-        break;
-
-    case MediaTypeAudio:
-        newPlayer = new AudioPlayer(this, oldPlayer);
-        break;
-
-    case MediaTypeVideo:
-        newPlayer = new VideoPlayer(this, oldPlayer);
-        break;
-    }
-
-    m_player.reset(newPlayer);
-
-    if (oldPlayerHasVideo != hasVideo()) {
-        emit hasVideoChanged(hasVideo());
-    }
-
-    if (oldPlayerSeekable != isSeekable()) {
-        emit seekableChanged(isSeekable());
-    }
-
-    connect(m_player.data(), SIGNAL(totalTimeChanged(qint64)), SIGNAL(totalTimeChanged(qint64)));
-    connect(m_player.data(), SIGNAL(stateChanged(Phonon::State,Phonon::State)), SIGNAL(stateChanged(Phonon::State,Phonon::State)));
-    connect(m_player.data(), SIGNAL(finished()), SIGNAL(finished()));
-    connect(m_player.data(), SIGNAL(tick(qint64)), SIGNAL(tick(qint64)));
-    connect(m_player.data(), SIGNAL(bufferStatus(int)), SIGNAL(bufferStatus(int)));
-    connect(m_player.data(), SIGNAL(metaDataChanged(QMultiMap<QString,QString>)), SIGNAL(metaDataChanged(QMultiMap<QString,QString>)));
-    connect(m_player.data(), SIGNAL(aboutToFinish()), SIGNAL(aboutToFinish()));
-    connect(m_player.data(), SIGNAL(prefinishMarkReached(qint32)), SIGNAL(tick(qint32)));
-
-    // We need to call setError() after doing the connects, otherwise the
-    // error won't be received.
-    if (!errorMessage.isEmpty()) {
-        Q_ASSERT(m_player);
-        m_player->setError(errorMessage);
-    }
-
-    TRACE_EXIT_0();
-}
-
-void MMF::MediaObject::setNextSource(const MediaSource &source)
-{
-    m_nextSource = source;
-    m_nextSourceSet = true;
-}
-
-qint32 MMF::MediaObject::prefinishMark() const
-{
-    return m_player->prefinishMark();
-}
-
-void MMF::MediaObject::setPrefinishMark(qint32 mark)
-{
-    m_player->setPrefinishMark(mark);
-}
-
-qint32 MMF::MediaObject::transitionTime() const
-{
-    return m_player->transitionTime();
-}
-
-void MMF::MediaObject::setTransitionTime(qint32 time)
-{
-    m_player->setTransitionTime(time);
-}
-
-void MMF::MediaObject::volumeChanged(qreal volume)
-{
-    m_player->volumeChanged(volume);
-}
-
-//-----------------------------------------------------------------------------
-// MediaNode
-//-----------------------------------------------------------------------------
-
-void MMF::MediaObject::connectMediaObject(MediaObject * /*mediaObject*/)
-{
-    // This function should never be called - see MediaNode::setMediaObject()
-    Q_ASSERT_X(false, Q_FUNC_INFO,
-        "Connection of MediaObject to MediaObject");
-}
-
-void MMF::MediaObject::disconnectMediaObject(MediaObject * /*mediaObject*/)
-{
-    // This function should never be called - see MediaNode::setMediaObject()
-    Q_ASSERT_X(false, Q_FUNC_INFO,
-        "Disconnection of MediaObject from MediaObject");
-}
-
-
-//-----------------------------------------------------------------------------
-// Video output
-//-----------------------------------------------------------------------------
-
-void MMF::MediaObject::setVideoOutput(VideoOutput* videoOutput)
-{
-    m_player->setVideoOutput(videoOutput);
-}
-
-
-AbstractPlayer *MMF::MediaObject::abstractPlayer() const
-{
-    return m_player.data();
-}
-
-//-----------------------------------------------------------------------------
-// Playlist support
-//-----------------------------------------------------------------------------
-
-void MMF::MediaObject::switchToNextSource()
-{
-    if (m_nextSourceSet) {
-        m_nextSourceSet = false;
-        switchToSource(m_nextSource);
-        play();
-    }
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/mediaobject.h b/src/3rdparty/phonon/mmf/mediaobject.h
deleted file mode 100644
index f3b818a..0000000
--- a/src/3rdparty/phonon/mmf/mediaobject.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_MEDIAOBJECT_H
-#define PHONON_MMF_MEDIAOBJECT_H
-
-#include <Phonon/mediasource.h>
-#include <Phonon/mediaobjectinterface.h>
-#include <QScopedPointer>
-#include <QTimer>
-
-// For recognizer
-#include <apgcli.h>
-
-#include "abstractplayer.h"
-#include "mmf_medianode.h"
-#include "defs.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-class AbstractPlayer;
-class VideoOutput;
-
-/**
- * @short Facade class which wraps MMF client utility instance
- */
-class MediaObject : public MediaNode
-                  , public MediaObjectInterface
-{
-    Q_OBJECT
-    Q_INTERFACES(Phonon::MediaObjectInterface)
-
-public:
-    MediaObject(QObject *parent);
-    virtual ~MediaObject();
-
-    // MediaObjectInterface
-    virtual void play();
-    virtual void pause();
-    virtual void stop();
-    virtual void seek(qint64 milliseconds);
-    virtual qint32 tickInterval() const;
-    virtual void setTickInterval(qint32 interval);
-    virtual bool hasVideo() const;
-    virtual bool isSeekable() const;
-    virtual qint64 currentTime() const;
-    virtual Phonon::State state() const;
-    virtual QString errorString() const;
-    virtual Phonon::ErrorType errorType() const;
-    virtual qint64 totalTime() const;
-    virtual MediaSource source() const;
-    virtual void setSource(const MediaSource &);
-    virtual void setNextSource(const MediaSource &source);
-    virtual qint32 prefinishMark() const;
-    virtual void setPrefinishMark(qint32);
-    virtual qint32 transitionTime() const;
-    virtual void setTransitionTime(qint32);
-
-    // MediaNode
-    void connectMediaObject(MediaObject *mediaObject);
-    void disconnectMediaObject(MediaObject *mediaObject);
-
-    /**
-     * This class owns the AbstractPlayer, and will delete it upon
-     * destruction.
-     */
-    AbstractPlayer *abstractPlayer() const;
-
-    void setVideoOutput(VideoOutput* videoOutput);
-
-public Q_SLOTS:
-    void volumeChanged(qreal volume);
-    void switchToNextSource();
-
-Q_SIGNALS:
-    void totalTimeChanged(qint64 length);
-    void hasVideoChanged(bool hasVideo);
-    void seekableChanged(bool seekable);
-    void bufferStatus(int);
-    void aboutToFinish();
-    void prefinishMarkReached(qint32 remaining);
-    // TODO: emit metaDataChanged from MediaObject
-    void metaDataChanged(const QMultiMap<QString, QString>& metaData);
-    void currentSourceChanged(const MediaSource& source);
-    void stateChanged(Phonon::State oldState,
-                      Phonon::State newState);
-    void finished();
-    void tick(qint64 time);
-
-private:
-    void switchToSource(const MediaSource &source);
-    void createPlayer(const MediaSource &source);
-    bool openRecognizer();
-
-    // Audio / video media type recognition
-    MediaType fileMediaType(const QString& fileName);
-    // TODO: urlMediaType function
-
-    static qint64 toMilliSeconds(const TTimeIntervalMicroSeconds &);
-
-private:
-
-    // Audio / video media type recognition
-    bool                                m_recognizerOpened;
-    RApaLsSession                       m_recognizer;
-    RFs                                 m_fileServer;
-
-    MediaSource                         m_source;
-    MediaSource                         m_nextSource;
-    bool                                m_nextSourceSet;
-
-    // Storing the file handle here to work around KErrInUse error
-    // from MMF player utility OpenFileL functions
-    RFile                               m_file;
-
-    QScopedPointer<AbstractPlayer>      m_player;
-
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/mmf/mmf_medianode.cpp b/src/3rdparty/phonon/mmf/mmf_medianode.cpp
deleted file mode 100644
index ca413d9..0000000
--- a/src/3rdparty/phonon/mmf/mmf_medianode.cpp
+++ /dev/null
@@ -1,152 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "mediaobject.h"
-
-#include "mmf_medianode.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::MediaNode
-  \internal
-*/
-
-MMF::MediaNode::MediaNode(QObject *parent)
-    :   QObject(parent)
-    ,   m_mediaObject(qobject_cast<MediaObject *>(this))
-    ,   m_input(0)
-{
-
-}
-
-MMF::MediaNode::~MediaNode()
-{
-    // Phonon framework ensures nodes are disconnected before being destroyed.
-    Q_ASSERT_X(!m_mediaObject, Q_FUNC_INFO,
-        "Media node not disconnected before destruction");
-}
-
-bool MMF::MediaNode::connectOutput(MediaNode *output)
-{
-    Q_ASSERT_X(output, Q_FUNC_INFO, "Null output pointer");
-
-    bool connected = false;
-
-    // Check that this connection will not result in a graph which
-    // containing more than one MediaObject
-    const bool mediaObjectMisMatch =
-            m_mediaObject
-        &&  output->m_mediaObject
-        &&  m_mediaObject != output->m_mediaObject;
-
-    const bool canConnect =
-            !output->isMediaObject()
-        &&  !output->m_input
-        &&  !m_outputs.contains(output);
-
-    if (canConnect && !mediaObjectMisMatch) {
-        output->m_input = this;
-        m_outputs += output;
-        updateMediaObject();
-        connected = true;
-    }
-
-    return connected;
-}
-
-bool MMF::MediaNode::disconnectOutput(MediaNode *output)
-{
-    Q_ASSERT_X(output, Q_FUNC_INFO, "Null output pointer");
-
-    bool disconnected = false;
-
-    if (m_outputs.contains(output) && this == output->m_input) {
-        output->m_input = 0;
-        const bool removed = m_outputs.removeOne(output);
-        Q_ASSERT_X(removed, Q_FUNC_INFO, "Output removal failed");
-
-        Q_ASSERT_X(!m_outputs.contains(output), Q_FUNC_INFO,
-            "Output list contains duplicate entries");
-
-        // Perform traversal across each of the two graphs separately
-        updateMediaObject();
-        output->updateMediaObject();
-
-        disconnected = true;
-    }
-
-    return disconnected;
-}
-
-bool MMF::MediaNode::isMediaObject() const
-{
-    return (qobject_cast<const MediaObject *>(this) != 0);
-}
-
-void MMF::MediaNode::updateMediaObject()
-{
-    QList<MediaNode *> nodes;
-    MediaObject *mediaObject = 0;
-
-    // Traverse the graph, collecting a list of nodes, and locating
-    // the MediaObject node, if present
-    visit(nodes, mediaObject);
-
-    MediaNode *node = 0;
-    foreach(node, nodes)
-        node->setMediaObject(mediaObject);
-}
-
-void MMF::MediaNode::setMediaObject(MediaObject *mediaObject)
-{
-    if(!isMediaObject() && m_mediaObject != mediaObject) {
-        if (!mediaObject)
-            disconnectMediaObject(m_mediaObject);
-        else {
-            Q_ASSERT_X(!m_mediaObject, Q_FUNC_INFO, "MediaObject already set");
-            connectMediaObject(mediaObject);
-        }
-        m_mediaObject = mediaObject;
-    }
-}
-
-void MMF::MediaNode::visit(QList<MediaNode *>& visited, MediaObject*& mediaObject)
-{
-    if (isMediaObject()) {
-        // There can never be more than one MediaObject per graph, due to the
-        // mediaObjectMisMatch test in connectOutput().
-        Q_ASSERT_X(!mediaObject, Q_FUNC_INFO, "MediaObject already found");
-        mediaObject = static_cast<MediaObject *>(this);
-    }
-
-    visited += this;
-
-    if (m_input && !visited.contains(m_input))
-        m_input->visit(visited, mediaObject);
-
-    MediaNode *output = 0;
-    foreach (output, m_outputs)
-        if (!visited.contains(output))
-            output->visit(visited, mediaObject);
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/mmf_medianode.h b/src/3rdparty/phonon/mmf/mmf_medianode.h
deleted file mode 100644
index 4f9d809..0000000
--- a/src/3rdparty/phonon/mmf/mmf_medianode.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_MEDIANODE_H
-#define PHONON_MMF_MEDIANODE_H
-
-#include <QObject>
-#include <Phonon/effectinterface.h>
-#include "audioplayer.h"
-
-QT_BEGIN_NAMESPACE
-
-/**
- * @file mmf_medianode.h mmf_medianode.cpp
- *
- * This file starts with mmf_ in order to avoid clash with Phonon's
- * medianode.h. The GStreamer backend has a file named medianode.h, but it
- * isn't compiled with ABLD build system, which have problems with separating
- * user and system include paths.
- */
-
-namespace Phonon
-{
-namespace MMF
-{
-class MediaObject;
-
-/**
- * @short Base class for all nodes in the MMF backend.
- *
- * MediaNode is the base class for all nodes created by the MMF
- * backend.
- *
- * These nodes may be one of the following types:
- *
- * - MediaObject
- *      This represents the source of media data.  It encapsulates the
- *      appropriate MMF client API for playing audio or video.
- * - AudioOutput
- *      This represents the audio output device.  Since the MMF client API
- *      does not expose the output device directly, this backend node
- *      simply forwards volume control commands to the MediaObject.
- * - VideoWidget
- *      A native widget on which video will be rendered.
- * - An audio effect, derived form AbstractAudioEffect
- *
- * Because the MMF API does not support the concept of a media filter graph,
- * this class must ensure the following:
- *
- * - Each media graph contains at most one MediaObject instance.
- * - Every non-MediaObject node holds a reference to the MediaObject.  This
- * allows commands to be sent through the graph to the encapsulated MMF client
- * API.
- */
-class MediaNode : public QObject
-{
-    Q_OBJECT
-public:
-    MediaNode(QObject *parent);
-    ~MediaNode();
-
-    bool connectOutput(MediaNode *output);
-    bool disconnectOutput(MediaNode *output);
-
-    virtual void connectMediaObject(MediaObject *mediaObject) = 0;
-    virtual void disconnectMediaObject(MediaObject *mediaObject) = 0;
-
-private:
-    bool isMediaObject() const;
-
-    void updateMediaObject();
-    void setMediaObject(MediaObject *mediaObject);
-
-    typedef QList<const MediaNode *> NodeList;
-    void visit(QList<MediaNode *>& visited, MediaObject*& mediaObject);
-
-private:
-    MediaObject *       m_mediaObject;
-
-    // All nodes except MediaObject may have an input
-    MediaNode *         m_input;
-
-    // Only MediaObject can have more than one output
-    QList<MediaNode *>  m_outputs;
-};
-
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
-
diff --git a/src/3rdparty/phonon/mmf/mmf_videoplayer.cpp b/src/3rdparty/phonon/mmf/mmf_videoplayer.cpp
deleted file mode 100644
index 127edb4..0000000
--- a/src/3rdparty/phonon/mmf/mmf_videoplayer.cpp
+++ /dev/null
@@ -1,658 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <QApplication>    // for QApplication::activeWindow
-#include <QUrl>
-#include <QTimer>
-#include <QWidget>
-
-#include <coemain.h>    // for CCoeEnv
-#include <coecntrl.h>
-
-#include "mmf_videoplayer.h"
-#include "utils.h"
-
-#ifndef QT_NO_DEBUG
-#include "objectdump.h"
-#endif
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::VideoPlayer
-  \internal
-*/
-
-//-----------------------------------------------------------------------------
-// Constructor / destructor
-//-----------------------------------------------------------------------------
-
-MMF::VideoPlayer::VideoPlayer(MediaObject *parent, const AbstractPlayer *player)
-        :   AbstractMediaPlayer(parent, player)
-        ,   m_wsSession(CCoeEnv::Static()->WsSession())
-        ,   m_screenDevice(*CCoeEnv::Static()->ScreenDevice())
-        ,   m_window(0)
-        ,   m_totalTime(0)
-        ,   m_pendingChanges(false)
-        ,   m_dsaActive(false)
-{
-    construct();
-}
-
-void MMF::VideoPlayer::construct()
-{
-    TRACE_CONTEXT(VideoPlayer::VideoPlayer, EVideoApi);
-    TRACE_ENTRY_0();
-
-    getVideoWindow();
-
-    const TInt priority = 0;
-    const TMdaPriorityPreference preference = EMdaPriorityPreferenceNone;
-
-    CVideoPlayerUtility *player = 0;
-    QT_TRAP_THROWING(player = CVideoPlayerUtility::NewL
-            (
-                 *this,
-                 priority, preference,
-                 m_wsSession, m_screenDevice,
-                 *m_window,
-                 m_videoRect, m_videoRect
-            )
-        );
-    m_player.reset(player);
-
-    // CVideoPlayerUtility::NewL starts DSA
-    m_dsaActive = true;
-
-    m_player->RegisterForVideoLoadingNotification(*this);
-
-    TRACE_EXIT_0();
-}
-
-MMF::VideoPlayer::~VideoPlayer()
-{
-    TRACE_CONTEXT(VideoPlayer::~VideoPlayer, EVideoApi);
-    TRACE_ENTRY_0();
-
-    // QObject destructor removes all signal-slot connections involving this
-    // object, so we do not need to disconnect from m_videoOutput here.
-
-    TRACE_EXIT_0();
-}
-
-CVideoPlayerUtility* MMF::VideoPlayer::nativePlayer() const
-{
-    return m_player.data();
-}
-
-//-----------------------------------------------------------------------------
-// Public API
-//-----------------------------------------------------------------------------
-
-void MMF::VideoPlayer::doPlay()
-{
-    TRACE_CONTEXT(VideoPlayer::doPlay, EVideoApi);
-
-    applyPendingChanges();
-
-    m_player->Play();
-}
-
-void MMF::VideoPlayer::doPause()
-{
-    TRACE_CONTEXT(VideoPlayer::doPause, EVideoApi);
-
-    TRAPD(err, m_player->PauseL());
-    if (KErrNone != err && state() != ErrorState) {
-        TRACE("PauseL error %d", err);
-        setError(tr("Pause failed"), err);
-    }
-}
-
-void MMF::VideoPlayer::doStop()
-{
-    m_player->Stop();
-}
-
-void MMF::VideoPlayer::doSeek(qint64 ms)
-{
-    TRACE_CONTEXT(VideoPlayer::doSeek, EVideoApi);
-
-    TRAPD(err, m_player->SetPositionL(TTimeIntervalMicroSeconds(ms * 1000)));
-
-    if(KErrNone != err)
-        setError(tr("Seek failed"), err);
-}
-
-int MMF::VideoPlayer::setDeviceVolume(int mmfVolume)
-{
-    TRAPD(err, m_player->SetVolumeL(mmfVolume));
-    return err;
-}
-
-int MMF::VideoPlayer::openFile(RFile& file)
-{
-    TRAPD(err, m_player->OpenFileL(file));
-    return err;
-}
-
-int MMF::VideoPlayer::openUrl(const QString& url)
-{
-    TRAPD(err, m_player->OpenUrlL(qt_QString2TPtrC(url)));
-    return err;
-}
-
-int MMF::VideoPlayer::bufferStatus() const
-{
-    int result = 0;
-    TRAP_IGNORE(m_player->GetVideoLoadingProgressL(result));
-    return result;
-}
-
-void MMF::VideoPlayer::close()
-{
-    m_player->Close();
-}
-
-bool MMF::VideoPlayer::hasVideo() const
-{
-    return true;
-}
-
-qint64 MMF::VideoPlayer::currentTime() const
-{
-    TRACE_CONTEXT(VideoPlayer::currentTime, EVideoApi);
-
-    TTimeIntervalMicroSeconds us;
-    TRAPD(err, us = m_player->PositionL())
-
-    qint64 result = 0;
-
-    if (KErrNone == err) {
-        result = toMilliSeconds(us);
-    } else {
-        TRACE("PositionL error %d", err);
-
-        // If we don't cast away constness here, we simply have to ignore
-        // the error.
-        const_cast<VideoPlayer*>(this)->setError(tr("Getting position failed"), err);
-    }
-
-    return result;
-}
-
-qint64 MMF::VideoPlayer::totalTime() const
-{
-    return m_totalTime;
-}
-
-
-//-----------------------------------------------------------------------------
-// MVideoPlayerUtilityObserver callbacks
-//-----------------------------------------------------------------------------
-
-void MMF::VideoPlayer::MvpuoOpenComplete(TInt aError)
-{
-    TRACE_CONTEXT(VideoPlayer::MvpuoOpenComplete, EVideoApi);
-    TRACE_ENTRY("state %d error %d", state(), aError);
-
-    __ASSERT_ALWAYS(LoadingState == state(), Utils::panic(InvalidStatePanic));
-
-    if (KErrNone == aError)
-        m_player->Prepare();
-    else
-        setError(tr("Opening clip failed"), aError);
-
-    TRACE_EXIT_0();
-}
-
-void MMF::VideoPlayer::MvpuoPrepareComplete(TInt aError)
-{
-    TRACE_CONTEXT(VideoPlayer::MvpuoPrepareComplete, EVideoApi);
-    TRACE_ENTRY("state %d error %d", state(), aError);
-
-    __ASSERT_ALWAYS(LoadingState == state(), Utils::panic(InvalidStatePanic));
-
-    TRAPD(err, doPrepareCompleteL(aError));
-
-    if (KErrNone == err) {
-        maxVolumeChanged(m_player->MaxVolume());
-
-        if (m_videoOutput)
-            m_videoOutput->setVideoSize(m_videoFrameSize);
-
-        updateVideoRect();
-        applyPendingChanges();
-
-        emit totalTimeChanged(totalTime());
-        changeState(StoppedState);
-    } else {
-        setError(tr("Buffering clip failed"), err);
-    }
-
-    TRACE_EXIT_0();
-}
-
-void MMF::VideoPlayer::doPrepareCompleteL(TInt aError)
-{
-    User::LeaveIfError(aError);
-
-    // Get frame size
-    TSize size;
-    m_player->VideoFrameSizeL(size);
-    m_videoFrameSize = QSize(size.iWidth, size.iHeight);
-
-    // Get duration
-    m_totalTime = toMilliSeconds(m_player->DurationL());
-}
-
-
-void MMF::VideoPlayer::MvpuoFrameReady(CFbsBitmap &aFrame, TInt aError)
-{
-    TRACE_CONTEXT(VideoPlayer::MvpuoFrameReady, EVideoApi);
-    TRACE_ENTRY("state %d error %d", state(), aError);
-
-    Q_UNUSED(aFrame);
-    Q_UNUSED(aError);   // suppress warnings in release builds
-
-    TRACE_EXIT_0();
-}
-
-void MMF::VideoPlayer::MvpuoPlayComplete(TInt aError)
-{
-    TRACE_CONTEXT(VideoPlayer::MvpuoPlayComplete, EVideoApi)
-    TRACE_ENTRY("state %d error %d", state(), aError);
-
-    // Call base class function which handles end of playback for both
-    // audio and video clips.
-    playbackComplete(aError);
-
-    TRACE_EXIT_0();
-}
-
-void MMF::VideoPlayer::MvpuoEvent(const TMMFEvent &aEvent)
-{
-    TRACE_CONTEXT(VideoPlayer::MvpuoEvent, EVideoApi);
-    TRACE_ENTRY("state %d", state());
-
-    Q_UNUSED(aEvent);
-
-    TRACE_EXIT_0();
-}
-
-
-//-----------------------------------------------------------------------------
-// MVideoLoadingObserver callbacks
-//-----------------------------------------------------------------------------
-
-void MMF::VideoPlayer::MvloLoadingStarted()
-{
-    bufferingStarted();
-}
-
-void MMF::VideoPlayer::MvloLoadingComplete()
-{
-    bufferingComplete();
-}
-
-
-//-----------------------------------------------------------------------------
-// Video window updates
-//-----------------------------------------------------------------------------
-
-void MMF::VideoPlayer::getVideoWindow()
-{
-    TRACE_CONTEXT(VideoPlayer::getVideoWindow, EVideoInternal);
-    TRACE_ENTRY_0();
-
-    if(m_videoOutput) {
-        // Dump information to log, only in debug builds
-        m_videoOutput->dump();
-
-        initVideoOutput();
-        videoWindowChanged();
-    } else
-        // Top-level window
-        m_window = QApplication::activeWindow()->effectiveWinId()->DrawableWindow();
-
-    TRACE_EXIT_0();
-}
-
-void MMF::VideoPlayer::videoOutputChanged()
-{
-    TRACE_CONTEXT(VideoPlayer::videoOutputChanged, EVideoInternal);
-    TRACE_ENTRY_0();
-
-    if (m_videoOutput) {
-        initVideoOutput();
-        videoWindowChanged();
-    }
-
-    TRACE_EXIT_0();
-}
-
-void MMF::VideoPlayer::initVideoOutput()
-{
-    m_videoOutput->winId();
-    m_videoOutput->setVideoSize(m_videoFrameSize);
-
-    bool connected = connect(
-        m_videoOutput, SIGNAL(videoWindowChanged()),
-        this, SLOT(videoWindowChanged())
-    );
-    Q_ASSERT(connected);
-
-    connected = connect(
-        m_videoOutput, SIGNAL(beginVideoWindowNativePaint()),
-        this, SLOT(suspendDirectScreenAccess())
-    );
-    Q_ASSERT(connected);
-
-    connected = connect(
-        m_videoOutput, SIGNAL(endVideoWindowNativePaint()),
-        this, SLOT(resumeDirectScreenAccess())
-    );
-    Q_ASSERT(connected);
-
-    connected = connect(
-        m_videoOutput, SIGNAL(aspectRatioChanged()),
-        this, SLOT(aspectRatioChanged())
-    );
-    Q_ASSERT(connected);
-
-    connected = connect(
-        m_videoOutput, SIGNAL(scaleModeChanged()),
-        this, SLOT(scaleModeChanged())
-    );
-    Q_ASSERT(connected);
-
-    // Suppress warnings in release builds
-    Q_UNUSED(connected);
-}
-
-void MMF::VideoPlayer::videoWindowChanged()
-{
-    TRACE_CONTEXT(VideoPlayer::videoOutputRegionChanged, EVideoInternal);
-    TRACE_ENTRY("state %d", state());
-
-    m_window = m_videoOutput->videoWindow();
-    updateVideoRect();
-
-    TRACE_EXIT_0();
-}
-
-void MMF::VideoPlayer::suspendDirectScreenAccess()
-{
-    m_dsaWasActive = stopDirectScreenAccess();
-}
-
-void MMF::VideoPlayer::resumeDirectScreenAccess()
-{
-    if(m_dsaWasActive) {
-        startDirectScreenAccess();
-        m_dsaWasActive = false;
-    }
-}
-
-void MMF::VideoPlayer::startDirectScreenAccess()
-{
-    if(!m_dsaActive) {
-        TRAPD(err, m_player->StartDirectScreenAccessL());
-        if(KErrNone == err)
-            m_dsaActive = true;
-        else
-            setError(tr("Video display error"), err);
-    }
-}
-
-bool MMF::VideoPlayer::stopDirectScreenAccess()
-{
-    const bool dsaWasActive = m_dsaActive;
-    if(m_dsaActive) {
-        TRAPD(err, m_player->StopDirectScreenAccessL());
-        if(KErrNone == err)
-            m_dsaActive = false;
-        else
-            setError(tr("Video display error"), err);
-    }
-    return dsaWasActive;
-}
-
-// Helper function for aspect ratio / scale mode handling
-QSize scaleToAspect(const QSize& srcRect, int aspectWidth, int aspectHeight)
-{
-    const qreal aspectRatio = qreal(aspectWidth) / aspectHeight;
-
-    int width = srcRect.width();
-    int height = srcRect.width() / aspectRatio;
-    if (height > srcRect.height()){
-        height = srcRect.height();
-        width = srcRect.height() * aspectRatio;
-    }
-    return QSize(width, height);
-}
-
-void MMF::VideoPlayer::updateVideoRect()
-{
-    QRect videoRect;
-    QRect windowRect = m_videoOutput->videoWindowRect();
-
-    // Clip to physical window size
-    // This is due to a defect in the layout when running on S60 3.2, which
-    // results in the rectangle of the video widget extending outside the
-    // screen in certain circumstances.  These include the initial startup
-    // of the mediaplayer demo in portrait mode.  When this rectangle is
-    // passed to the CVideoPlayerUtility, no video is rendered.
-    const TSize screenSize = m_screenDevice.SizeInPixels();
-    const QRect screenRect(0, 0, screenSize.iWidth, screenSize.iHeight);
-    windowRect = windowRect.intersected(screenRect);
-
-    const QSize windowSize = windowRect.size();
-
-    // Calculate size of smallest rect which contains video frame size
-    // and conforms to aspect ratio
-    switch (m_videoOutput->aspectRatio()) {
-    case Phonon::VideoWidget::AspectRatioAuto:
-        videoRect.setSize(m_videoFrameSize);
-        break;
-
-    case Phonon::VideoWidget::AspectRatioWidget:
-        videoRect.setSize(windowSize);
-        break;
-
-    case Phonon::VideoWidget::AspectRatio4_3:
-        videoRect.setSize(scaleToAspect(m_videoFrameSize, 4, 3));
-        break;
-
-    case Phonon::VideoWidget::AspectRatio16_9:
-        videoRect.setSize(scaleToAspect(m_videoFrameSize, 16, 9));
-        break;
-    }
-
-    // Scale to fill the window width
-    const int windowWidth = windowSize.width();
-    const int windowHeight = windowSize.height();
-    const qreal windowScaleFactor = qreal(windowWidth) / videoRect.width();
-    int videoWidth = windowWidth;
-    int videoHeight = videoRect.height() * windowScaleFactor;
-
-    const qreal windowToVideoHeightRatio = qreal(windowHeight) / videoHeight;
-
-    switch(m_videoOutput->scaleMode()) {
-    case Phonon::VideoWidget::ScaleAndCrop:
-        if(videoHeight < windowHeight) {
-            videoWidth *= windowToVideoHeightRatio;
-            videoHeight = windowHeight;
-        }
-        break;
-    case Phonon::VideoWidget::FitInView:
-    default:
-        if(videoHeight > windowHeight) {
-            videoWidth *= windowToVideoHeightRatio;
-            videoHeight = windowHeight;
-        }
-        break;
-    }
-
-    // Calculate scale factors
-    m_scaleWidth = 100.0f * videoWidth / m_videoFrameSize.width();
-    m_scaleHeight = 100.0f * videoHeight / m_videoFrameSize.height();
-
-    m_videoRect = qt_QRect2TRect(windowRect);
-
-    if (state() == LoadingState)
-        m_pendingChanges = true;
-    else {
-        applyVideoWindowChange();
-        m_pendingChanges = false;
-    }
-}
-
-void MMF::VideoPlayer::aspectRatioChanged()
-{
-    TRACE_CONTEXT(VideoPlayer::aspectRatioChanged, EVideoInternal);
-    TRACE_ENTRY("state %d aspectRatio %d", state());
-
-    updateVideoRect();
-
-    TRACE_EXIT_0();
-}
-
-void MMF::VideoPlayer::scaleModeChanged()
-{
-    TRACE_CONTEXT(VideoPlayer::scaleModeChanged, EVideoInternal);
-    TRACE_ENTRY("state %d", state());
-
-    updateVideoRect();
-
-    TRACE_EXIT_0();
-}
-
-#ifndef QT_NO_DEBUG
-
-// The following code is for debugging problems related to video visibility.  It allows
-// the VideoPlayer instance to query the window server in order to determine the
-// DSA drawing region for the video window.
-
-class CDummyAO : public CActive
-{
-public:
-    CDummyAO() : CActive(CActive::EPriorityStandard) { CActiveScheduler::Add(this); }
-    void RunL() { }
-    void DoCancel() { }
-    TRequestStatus& Status() { return iStatus; }
-    void SetActive() { CActive::SetActive(); }
-};
-
-void getDsaRegion(RWsSession &session, const RWindowBase &window)
-{
-    RDirectScreenAccess dsa(session);
-    TInt err = dsa.Construct();
-    CDummyAO ao;
-    RRegion* region;
-    err = dsa.Request(region, ao.Status(), window);
-    ao.SetActive();
-    dsa.Close();
-    ao.Cancel();
-    if (region) {
-        qDebug() << "Phonon::MMF::getDsaRegion count" << region->Count();
-        for (int i=0; i<region->Count(); ++i) {
-            const TRect& rect = region->RectangleList()[i];
-            qDebug() << "Phonon::MMF::getDsaRegion rect"
-                << rect.iTl.iX << rect.iTl.iY << rect.iBr.iX << rect.iBr.iY;
-        }
-        region->Close();
-    }
-}
-
-#endif // _DEBUG
-
-void MMF::VideoPlayer::applyPendingChanges()
-{
-    if(m_pendingChanges)
-        applyVideoWindowChange();
-
-    m_pendingChanges = false;
-}
-
-void MMF::VideoPlayer::applyVideoWindowChange()
-{
-    TRACE_CONTEXT(VideoPlayer::applyVideoWindowChange, EVideoInternal);
-    TRACE_ENTRY_0();
-
-#ifndef QT_NO_DEBUG
-    getDsaRegion(m_wsSession, *m_window);
-#endif
-
-    static const TBool antialias = ETrue;
-
-    TRAPD(err, m_player->SetScaleFactorL(m_scaleWidth, m_scaleHeight, antialias));
-    if(KErrNone != err) {
-        TRACE("SetScaleFactorL (1) err %d", err);
-        setError(tr("Video display error"), err);
-    }
-
-    if(KErrNone == err) {
-        TRAP(err,
-            m_player->SetDisplayWindowL
-                (
-                    m_wsSession, m_screenDevice,
-                    *m_window,
-                    m_videoRect, m_videoRect
-                )
-            );
-
-        if (KErrNone != err) {
-            TRACE("SetDisplayWindowL err %d", err);
-            setError(tr("Video display error"), err);
-        } else {
-            m_dsaActive = true;
-            TRAP(err, m_player->SetScaleFactorL(m_scaleWidth, m_scaleHeight, antialias));
-            if(KErrNone != err) {
-                TRACE("SetScaleFactorL (2) err %d", err);
-                setError(tr("Video display error"), err);
-            }
-        }
-    }
-
-    TRACE_EXIT_0();
-}
-
-
-//-----------------------------------------------------------------------------
-// Metadata
-//-----------------------------------------------------------------------------
-
-int MMF::VideoPlayer::numberOfMetaDataEntries() const
-{
-    int numberOfEntries = 0;
-    TRAP_IGNORE(numberOfEntries = m_player->NumberOfMetaDataEntriesL());
-    return numberOfEntries;
-}
-
-QPair<QString, QString> MMF::VideoPlayer::metaDataEntry(int index) const
-{
-    CMMFMetaDataEntry *entry = 0;
-    QT_TRAP_THROWING(entry = m_player->MetaDataEntryL(index));
-    return QPair<QString, QString>(qt_TDesC2QString(entry->Name()), qt_TDesC2QString(entry->Value()));
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/mmf_videoplayer.h b/src/3rdparty/phonon/mmf/mmf_videoplayer.h
deleted file mode 100644
index 0253ab9..0000000
--- a/src/3rdparty/phonon/mmf/mmf_videoplayer.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_VIDEOPLAYER_H
-#define PHONON_MMF_VIDEOPLAYER_H
-
-#include <videoplayer.h> // from epoc32/include
-
-#include "abstractmediaplayer.h"
-#include "videooutput.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-/**
- * @short Wrapper over MMF video client utility
- *
- * See
- * <a href="http://wiki.forum.nokia.com/index.php/How_to_play_a_video_file_using_CVideoPlayerUtility">How to
- * play a video file using CVideoPlayerUtility</a>
- */
-class VideoPlayer : public AbstractMediaPlayer
-                  , public MVideoPlayerUtilityObserver
-                  , public MVideoLoadingObserver
-{
-    Q_OBJECT
-
-public:
-    VideoPlayer(MediaObject *parent = 0, const AbstractPlayer *player = 0);
-    virtual ~VideoPlayer();
-
-    typedef CVideoPlayerUtility NativePlayer;
-    NativePlayer *nativePlayer() const;
-
-    // AbstractPlayer
-    virtual void doPlay();
-    virtual void doPause();
-    virtual void doStop();
-    virtual void doSeek(qint64 milliseconds);
-    virtual int setDeviceVolume(int mmfVolume);
-    virtual int openFile(RFile& file);
-    virtual int openUrl(const QString& url);
-    virtual int bufferStatus() const;
-    virtual void close();
-
-    // MediaObjectInterface
-    virtual bool hasVideo() const;
-    virtual qint64 currentTime() const;
-    virtual qint64 totalTime() const;
-
-    // AbstractPlayer
-    virtual void videoOutputChanged();
-
-    // AbstractMediaPlayer
-    virtual int numberOfMetaDataEntries() const;
-    virtual QPair<QString, QString> metaDataEntry(int index) const;
-
-public Q_SLOTS:
-    void videoWindowChanged();
-    void aspectRatioChanged();
-    void scaleModeChanged();
-    void suspendDirectScreenAccess();
-    void resumeDirectScreenAccess();
-
-private:
-    void construct();
-
-    void doPrepareCompleteL(TInt aError);
-
-    void getVideoWindow();
-    void initVideoOutput();
-    void updateVideoRect();
-
-    void applyPendingChanges();
-    void applyVideoWindowChange();
-
-    void startDirectScreenAccess();
-    bool stopDirectScreenAccess();
-
-private:
-    // MVideoPlayerUtilityObserver
-    virtual void MvpuoOpenComplete(TInt aError);
-    virtual void MvpuoPrepareComplete(TInt aError);
-    virtual void MvpuoFrameReady(CFbsBitmap &aFrame, TInt aError);
-    virtual void MvpuoPlayComplete(TInt aError);
-    virtual void MvpuoEvent(const TMMFEvent &aEvent);
-
-    // MVideoLoadingObserver
-    virtual void MvloLoadingStarted();
-    virtual void MvloLoadingComplete();
-
-private:
-    QScopedPointer<NativePlayer>        m_player;
-
-    // Not owned
-    RWsSession&                         m_wsSession;
-    CWsScreenDevice&                    m_screenDevice;
-    RWindowBase*                        m_window;
-
-    /* Extent of the video display - will be clipped to m_windowRect */
-    TRect                               m_videoRect;
-
-    TReal32                             m_scaleWidth;
-    TReal32                             m_scaleHeight;
-
-    QSize                               m_videoFrameSize;
-    qint64                              m_totalTime;
-
-    bool                                m_pendingChanges;
-    bool                                m_dsaActive;
-    bool                                m_dsaWasActive;
-
-};
-
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/mmf/objectdump.cpp b/src/3rdparty/phonon/mmf/objectdump.cpp
deleted file mode 100644
index 778cde9..0000000
--- a/src/3rdparty/phonon/mmf/objectdump.cpp
+++ /dev/null
@@ -1,525 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <QByteArray>
-#include <QDebug>
-#include <QHash>
-#include <QTextStream>
-#include <QWidget>
-
-#include "objectdump.h"
-#include "objecttree.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace ObjectDump
-{
-
-//-----------------------------------------------------------------------------
-// QObjectAnnotator
-//-----------------------------------------------------------------------------
-
-QAnnotator::~QAnnotator()
-{
-
-}
-
-
-//-----------------------------------------------------------------------------
-// Annotators
-//-----------------------------------------------------------------------------
-
-QList<QByteArray> QAnnotatorBasic::annotation(const QObject& object)
-{
-    QList<QByteArray> result;
-
-    QByteArray array;
-    QTextStream stream(&array);
-
-    stream << '[' << &object << ']';
-    stream << ' ';
-    stream << object.metaObject()->className();
-
-    if (object.objectName() != "")
-        stream << " \"" << object.objectName() << '"';
-
-    if (object.isWidgetType())
-        stream << " isWidget";
-
-    stream.flush();
-    result.append(array);
-    return result;
-}
-
-QList<QByteArray> QAnnotatorWidget::annotation(const QObject& object)
-{
-    QList<QByteArray> result;
-
-    const QWidget* widget = qobject_cast<const QWidget*>(&object);
-    if (widget) {
-
-        QByteArray array;
-        QTextStream stream(&array);
-
-        stream << "widget: ";
-
-        if (widget->isVisible())
-            stream << "visible ";
-        else
-            stream << "invisible ";
-
-        stream << widget->x() << ',' << widget->y() << ' ';
-        stream << widget->size().width() << 'x'<< widget->size().height() << ' ';
-
-        stream << "hint " << widget->sizeHint().width() << 'x' << widget->sizeHint().height();
-
-        stream.flush();
-        result.append(array);
-    }
-
-    return result;
-}
-
-
-//-----------------------------------------------------------------------------
-// Base class for QDumperPrivate, QVisitorPrivate
-//-----------------------------------------------------------------------------
-
-class QDumperBase
-{
-public:
-    QDumperBase();
-    ~QDumperBase();
-
-    void setPrefix(const QString& prefix);
-    void addAnnotator(QAnnotator* annotator);
-
-protected:
-    QByteArray m_prefix;
-    QList<QAnnotator*> m_annotators;
-
-};
-
-QDumperBase::QDumperBase()
-{
-
-}
-
-QDumperBase::~QDumperBase()
-{
-    QAnnotator* annotator;
-    foreach(annotator, m_annotators)
-        delete annotator;
-}
-
-void QDumperBase::setPrefix(const QString& prefix)
-{
-    m_prefix = prefix.count()
-        ? (prefix + " ").toAscii()
-        : prefix.toAscii();
-}
-
-void QDumperBase::addAnnotator(QAnnotator* annotator)
-{
-    // Protect against an exception occurring during QList::append
-    QScopedPointer<QAnnotator> holder(annotator);
-    m_annotators.append(annotator);
-    holder.take();
-}
-
-
-//-----------------------------------------------------------------------------
-// QDumper
-//-----------------------------------------------------------------------------
-
-class QDumperPrivate : public QDumperBase
-{
-public:
-    QDumperPrivate();
-    ~QDumperPrivate();
-
-    void dumpObject(const QObject& object);
-
-};
-
-
-QDumperPrivate::QDumperPrivate()
-{
-
-}
-
-QDumperPrivate::~QDumperPrivate()
-{
-
-}
-
-void QDumperPrivate::dumpObject(const QObject& object)
-{
-    QAnnotator* annotator;
-    foreach(annotator, m_annotators) {
-
-        const QList<QByteArray> annotations = annotator->annotation(object);
-        QByteArray annotation;
-        foreach(annotation, annotations) {
-            QByteArray buffer(m_prefix);
-            buffer.append(annotation);
-            qDebug() << buffer.constData();
-        }
-    }
-}
-
-
-QDumper::QDumper()
-    : d_ptr(new QDumperPrivate)
-{
-
-}
-
-QDumper::~QDumper()
-{
-
-}
-
-void QDumper::setPrefix(const QString& prefix)
-{
-    d_func()->setPrefix(prefix);
-}
-
-void QDumper::addAnnotator(QAnnotator* annotator)
-{
-    d_func()->addAnnotator(annotator);
-}
-
-void QDumper::dumpObject(const QObject& object)
-{
-    d_func()->dumpObject(object);
-}
-
-
-//-----------------------------------------------------------------------------
-// QVisitor
-//-----------------------------------------------------------------------------
-
-class QVisitorPrivate : public QDumperBase
-{
-public:
-    QVisitorPrivate();
-    ~QVisitorPrivate();
-
-    void setIndent(unsigned indent);
-
-    void visitNode(const QObject& object);
-    void visitComplete();
-
-private:
-    class Node
-    {
-    public:
-        Node();
-        ~Node();
-
-        QList<QByteArray>   m_annotation;
-        QList<Node*>        m_children;
-
-        typedef QList<Node*>::const_iterator child_iterator;
-    };
-
-private:
-    Node* findNode(const QObject* object) const;
-    QByteArray branchBuffer(const QList<bool>& branches, bool isNodeLine, bool isLastChild) const;
-    void dumpRecursive(const Node& node, QList<bool> branches, bool isLastChild);
-    void dumpNode(const Node& node, const QList<bool>& branches, bool isLastChild);
-
-private:
-    unsigned m_indent;
-
-    QScopedPointer<Node> m_root;
-
-    // Hash table used to associate internal nodes with QObjects
-    typedef QHash<const QObject*, Node*> Hash;
-    Hash m_hash;
-};
-
-static const unsigned DefaultIndent = 2;
-
-QVisitorPrivate::QVisitorPrivate()
-    :   m_indent(DefaultIndent)
-{
-
-}
-
-QVisitorPrivate::~QVisitorPrivate()
-{
-
-}
-
-void QVisitorPrivate::setIndent(unsigned indent)
-{
-    m_indent = indent;
-}
-
-// Builds up a mirror of the object tree, rooted in m_root, with each node
-// storing annotations generated by
-void QVisitorPrivate::visitNode(const QObject& object)
-{
-    QObject* const objectParent = object.parent();
-    Node* const nodeParent = objectParent ? findNode(objectParent) : 0;
-
-    // Create a new node and store in scoped pointer for exception safety
-    Node* node = new Node;
-    QScopedPointer<Node> nodePtr(node);
-
-    // Associate node with QObject
-    m_hash.insert(&object, node);
-
-    // Insert node into internal tree
-    if (nodeParent)
-    {
-        nodeParent->m_children.append(nodePtr.take());
-    }
-    else
-    {
-        Q_ASSERT(m_root.isNull());
-        m_root.reset(nodePtr.take());
-    }
-
-    // Generate and store annotations
-    QAnnotator* annotator;
-    foreach(annotator, m_annotators)
-        node->m_annotation.append( annotator->annotation(object) );
-}
-
-void QVisitorPrivate::visitComplete()
-{
-    QList<bool> branches;
-    static const bool isLastChild = true;
-    dumpRecursive(*m_root, branches, isLastChild);
-    m_root.reset(0);
-}
-
-QVisitorPrivate::Node* QVisitorPrivate::findNode(const QObject* object) const
-{
-    Hash::const_iterator i = m_hash.find(object);
-    return (m_hash.end() == i) ? 0 : *i;
-}
-
-QByteArray QVisitorPrivate::branchBuffer
-    (const QList<bool>& branches, bool isNodeLine, bool isLastChild) const
-{
-    const int depth = branches.count();
-
-    const QByteArray indent(m_indent, ' ');
-    const QByteArray horiz(m_indent, '-');
-
-    QByteArray buffer;
-    QTextStream stream(&buffer);
-
-    for (int i=0; i<depth-1; ++i) {
-        if (branches[i])
-            stream << '|';
-        else
-            stream << ' ';
-        stream << indent;
-    }
-
-    if (depth) {
-        if (isNodeLine)
-            stream << '+' << horiz;
-        else {
-            if (!isLastChild)
-                stream << '|';
-            else
-                stream << ' ';
-            stream << indent;
-        }
-    }
-
-    stream.flush();
-    buffer.push_front(m_prefix);
-
-    return buffer;
-}
-
-void QVisitorPrivate::dumpRecursive
-    (const Node& node, QList<bool> branches, bool isLastChild)
-{
-    dumpNode(node, branches, isLastChild);
-
-    // Recurse down tree
-    const Node::child_iterator begin = node.m_children.begin();
-    const Node::child_iterator end = node.m_children.end();
-    for (Node::child_iterator i = begin; end != i; ++i) {
-
-        isLastChild = (end == i + 1);
-
-        if (begin == i)
-            branches.push_back(!isLastChild);
-        else
-            branches.back() = !isLastChild;
-
-        static const bool isNodeLine = false;
-        const QByteArray buffer = branchBuffer(branches, isNodeLine, false);
-        qDebug() << buffer.constData();
-
-        dumpRecursive(**i, branches, isLastChild);
-    }
-}
-
-void QVisitorPrivate::dumpNode
-    (const Node& node, const QList<bool>& branches, bool isLastChild)
-{
-    const QList<QByteArray>::const_iterator
-        begin = node.m_annotation.begin(), end = node.m_annotation.end();
-
-    if (begin == end) {
-        // No annotations - just dump the object pointer
-        const bool isNodeLine = true;
-        QByteArray buffer = branchBuffer(branches, isNodeLine, isLastChild);
-        qDebug() << 0;
-    }
-    else {
-        // Dump annotations
-        for (QList<QByteArray>::const_iterator i = begin; end != i; ++i) {
-            const bool isNodeLine = (begin == i);
-            QByteArray buffer = branchBuffer(branches, isNodeLine, isLastChild);
-            buffer.append(*i);
-            qDebug() << buffer.constData();
-        }
-    }
-}
-
-
-// QVisitorPrivate::Node
-
-QVisitorPrivate::Node::Node()
-{
-
-}
-
-QVisitorPrivate::Node::~Node()
-{
-    Node* child;
-    foreach(child, m_children)
-        delete child;
-}
-
-
-// QVisitor
-
-QVisitor::QVisitor()
-    : d_ptr(new QVisitorPrivate)
-{
-
-}
-
-QVisitor::~QVisitor()
-{
-
-}
-
-void QVisitor::setPrefix(const QString& prefix)
-{
-    d_func()->setPrefix(prefix);
-}
-
-void QVisitor::setIndent(unsigned indent)
-{
-    d_func()->setIndent(indent);
-}
-
-void QVisitor::addAnnotator(QAnnotator* annotator)
-{
-    d_func()->addAnnotator(annotator);
-}
-
-void QVisitor::visitPrepare()
-{
-    // Do nothing
-}
-
-void QVisitor::visitNode(const QObject& object)
-{
-    d_func()->visitNode(object);
-}
-
-void QVisitor::visitComplete()
-{
-    d_func()->visitComplete();
-}
-
-
-//-----------------------------------------------------------------------------
-// Utility functions
-//-----------------------------------------------------------------------------
-
-void addDefaultAnnotators_sys(QDumper& visitor);
-void addDefaultAnnotators_sys(QVisitor& visitor);
-
-void addDefaultAnnotators(QDumper& dumper)
-{
-    dumper.addAnnotator(new QAnnotatorBasic);
-    dumper.addAnnotator(new QAnnotatorWidget);
-
-    // Add platform-specific annotators
-    addDefaultAnnotators_sys(dumper);
-}
-
-void addDefaultAnnotators(QVisitor& visitor)
-{
-    visitor.addAnnotator(new QAnnotatorBasic);
-    visitor.addAnnotator(new QAnnotatorWidget);
-
-    // Add platform-specific annotators
-    addDefaultAnnotators_sys(visitor);
-}
-
-void dumpTreeFromRoot(const QObject& root, QVisitor& visitor)
-{
-    // Set up iteration range
-    ObjectTree::DepthFirstConstIterator begin(root), end;
-
-    // Invoke generic visitor algorithm
-    ObjectTree::visit(begin, end, visitor);
-}
-
-void dumpTreeFromLeaf(const QObject& leaf, QVisitor& visitor)
-{
-    // Walk up to root
-    const QObject* root = &leaf;
-    while(root->parent())
-    {
-        root = root->parent();
-    }
-
-    dumpTreeFromRoot(*root, visitor);
-}
-
-void dumpAncestors(const QObject& leaf, QVisitor& visitor)
-{
-    // Set up iteration range
-    ObjectTree::AncestorConstIterator begin(leaf), end;
-
-    // Invoke generic visitor algorithm
-    ObjectTree::visit(begin, end, visitor);
-}
-
-
-} // namespace ObjectDump
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/objectdump.h b/src/3rdparty/phonon/mmf/objectdump.h
deleted file mode 100644
index 86aeaba..0000000
--- a/src/3rdparty/phonon/mmf/objectdump.h
+++ /dev/null
@@ -1,164 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef OBJECTDUMP_H
-#define OBJECTDUMP_H
-
-#include <QObject>
-#include <QList>
-#include <QByteArray>
-#include <QScopedPointer>
-
-QT_BEGIN_NAMESPACE
-
-namespace ObjectDump
-{
-
-/**
- * Abstract base for annotator classes invoked by QVisitor.
- */
-class QAnnotator : public QObject
-{
-    Q_OBJECT
-public:
-    virtual ~QAnnotator();
-    virtual QList<QByteArray> annotation(const QObject& object) = 0;
-};
-
-/**
- * Annotator which replicates QObject::dumpObjectTree functionality.
- */
-class QAnnotatorBasic : public QAnnotator
-{
-    Q_OBJECT
-public:
-    QList<QByteArray> annotation(const QObject& object);
-};
-
-/**
- * Annotator which returns widget information.
- */
-class QAnnotatorWidget : public QAnnotator
-{
-    Q_OBJECT
-public:
-    QList<QByteArray> annotation(const QObject& object);
-};
-
-
-class QDumperPrivate;
-
-/**
- * Class used to dump information about individual QObjects.
- */
-class QDumper : public QObject
-{
-    Q_OBJECT
-    Q_DECLARE_PRIVATE(QDumper)
-
-public:
-    QDumper();
-    ~QDumper();
-
-    /**
-     * Specify a prefix, to be printed on each line of output.
-     */
-    void setPrefix(const QString& prefix);
-
-    /**
-     * Takes ownership of annotator.
-     */
-    void addAnnotator(QAnnotator* annotator);
-
-    /**
-     * Invoke each annotator on the object and write to debug output.
-     */
-    void dumpObject(const QObject& object);
-
-private:
-    QScopedPointer<QDumperPrivate> d_ptr;
-
-};
-
-
-class QVisitorPrivate;
-
-/**
- * Visitor class which dumps information about nodes in the object tree.
- */
-class QVisitor : public QObject
-{
-    Q_OBJECT
-    Q_DECLARE_PRIVATE(QVisitor)
-
-public:
-    QVisitor();
-    ~QVisitor();
-
-    /**
-     * Specify a prefix, to be printed on each line of output.
-     */
-    void setPrefix(const QString& prefix);
-
-    /**
-     * Set number of spaces by which each level of the tree is indented.
-     */
-    void setIndent(unsigned indent);
-
-    /**
-     * Called by the visitor algorithm before starting the visit.
-     */
-    void visitPrepare();
-
-    /**
-     * Called by the visitor algorithm as each node is visited.
-     */
-    void visitNode(const QObject& object);
-
-    /**
-     * Called by the visitor algorithm when the visit is complete.
-     */
-    void visitComplete();
-
-    /**
-     * Takes ownership of annotator.
-     */
-    void addAnnotator(QAnnotator* annotator);
-
-private:
-    QScopedPointer<QVisitorPrivate> d_ptr;
-
-};
-
-
-//-----------------------------------------------------------------------------
-// Utility functions
-//-----------------------------------------------------------------------------
-
-void addDefaultAnnotators(QDumper& dumper);
-void addDefaultAnnotators(QVisitor& visitor);
-
-void dumpTreeFromRoot(const QObject& root, QVisitor& visitor);
-void dumpTreeFromLeaf(const QObject& leaf, QVisitor& visitor);
-void dumpAncestors(const QObject& leaf, QVisitor& visitor);
-
-} // namespace ObjectDump
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/mmf/objectdump_symbian.cpp b/src/3rdparty/phonon/mmf/objectdump_symbian.cpp
deleted file mode 100644
index edad537..0000000
--- a/src/3rdparty/phonon/mmf/objectdump_symbian.cpp
+++ /dev/null
@@ -1,160 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <QTextStream>
-#include <QWidget>
-#include <coecntrl.h>
-#include "objectdump_symbian.h"
-
-#include <QtGui/private/qwidget_p.h> // to access QWExtra
-
-QT_BEGIN_NAMESPACE
-
-namespace ObjectDump
-{
-namespace Symbian
-{
-
-QList<QByteArray> QAnnotatorWidget::annotation(const QObject& object)
-{
-    QList<QByteArray> result;
-
-    const QWidget* widget = qobject_cast<const QWidget*>(&object);
-    if (widget) {
-
-        const QWExtra* extra = qt_widget_private(const_cast<QWidget *>(widget))->extraData();
-
-        if (extra) {
-
-            QByteArray array;
-            QTextStream stream(&array);
-
-            stream << "widget (Symbian): ";
-            stream << "activated " << extra->activated << ' ';
-            stream << "nativePaintMode " << extra->nativePaintMode << ' ';
-
-            stream.flush();
-            result.append(array);
-        }
-    }
-
-    return result;
-}
-
-QList<QByteArray> QAnnotatorControl::annotation(const QObject& object)
-{
-    QList<QByteArray> result;
-
-    const QWidget* widget = qobject_cast<const QWidget*>(&object);
-    if (widget) {
-
-        const CCoeControl* control = widget->effectiveWinId();
-        if (control) {
-
-            QByteArray array;
-            QTextStream stream(&array);
-
-            stream << "control: " << control << ' ';
-            stream << "parent " << control->Parent() << ' ';
-
-            if (control->IsVisible())
-                stream << "visible ";
-            else
-                stream << "invisible ";
-
-            stream << control->Position().iX << ',' << control->Position().iY << ' ';
-            stream << control->Size().iWidth << 'x' << control->Size().iHeight;
-
-            if (control->OwnsWindow())
-                stream << " ownsWindow ";
-
-            stream.flush();
-            result.append(array);
-        }
-    }
-
-    return result;
-}
-
-QList<QByteArray> QAnnotatorWindow::annotation(const QObject& object)
-{
-    QList<QByteArray> result;
-
-    const QWidget* widget = qobject_cast<const QWidget*>(&object);
-    if (widget) {
-
-        const CCoeControl* control = widget->effectiveWinId();
-
-        if (control) {
-            RDrawableWindow *const window = control->DrawableWindow();
-            if(window) {
-                QByteArray array;
-                QTextStream stream(&array);
-
-                stream << "window: ";
-
-                // Server-side address of CWsWindow object
-                // This is useful for correlation with the window tree dumped by the window
-                // server (see RWsSession::LogCommand).
-                // Cast to a void pointer so that log output is in hexadecimal format.
-                stream << "srv " << reinterpret_cast<const void*>(window->WsHandle()) << ' ';
-
-                stream << "group " << window->WindowGroupId() << ' ';
-
-                // Client-side handle to the parent window.
-                // Cast to a void pointer so that log output is in hexadecimal format.
-                stream << "parent " << reinterpret_cast<const void*>(window->Parent()) << ' ';
-
-                stream << window->Position().iX << ',' << window->Position().iY << ' ';
-                stream << '(' << window->AbsPosition().iX << ',' << window->AbsPosition().iY << ") ";
-                stream << window->Size().iWidth << 'x' << window->Size().iHeight << ' ';
-
-                const TDisplayMode displayMode = window->DisplayMode();
-                stream << "mode " << displayMode << ' ';
-
-                stream << "ord " << window->OrdinalPosition();
-
-                stream.flush();
-                result.append(array);
-            }
-        }
-    }
-
-    return result;
-}
-
-} // namespace Symbian
-
-void addDefaultAnnotators_sys(QDumper& dumper)
-{
-    dumper.addAnnotator(new Symbian::QAnnotatorWidget);
-    dumper.addAnnotator(new Symbian::QAnnotatorControl);
-    dumper.addAnnotator(new Symbian::QAnnotatorWindow);
-}
-
-void addDefaultAnnotators_sys(QVisitor& visitor)
-{
-    visitor.addAnnotator(new Symbian::QAnnotatorWidget);
-    visitor.addAnnotator(new Symbian::QAnnotatorControl);
-    visitor.addAnnotator(new Symbian::QAnnotatorWindow);
-}
-
-} // namespace ObjectDump
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/objectdump_symbian.h b/src/3rdparty/phonon/mmf/objectdump_symbian.h
deleted file mode 100644
index 563c862..0000000
--- a/src/3rdparty/phonon/mmf/objectdump_symbian.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef OBJECTDUMP_SYMBIAN_H
-#define OBJECTDUMP_SYMBIAN_H
-
-#include "objectdump.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace ObjectDump
-{
-namespace Symbian
-{
-
-/**
- * Annotator which returns Symbian-specific widget information
- */
-class QAnnotatorWidget : public QAnnotator
-{
-    Q_OBJECT
-public:
-    QList<QByteArray> annotation(const QObject& object);
-};
-
-/**
- * Annotator which returns control information
- */
-class QAnnotatorControl : public QAnnotator
-{
-    Q_OBJECT
-public:
-    QList<QByteArray> annotation(const QObject& object);
-};
-
-/**
- * Annotator which returns window information
- */
-class QAnnotatorWindow : public QAnnotator
-{
-    Q_OBJECT
-public:
-    QList<QByteArray> annotation(const QObject& object);
-};
-
-} // namespace Symbian
-} // namespace ObjectDump
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/mmf/objecttree.cpp b/src/3rdparty/phonon/mmf/objecttree.cpp
deleted file mode 100644
index 06b0ced..0000000
--- a/src/3rdparty/phonon/mmf/objecttree.cpp
+++ /dev/null
@@ -1,100 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <QTextStream>
-#include <QWidget>
-#include "objecttree.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace ObjectTree
-{
-
-DepthFirstConstIterator::DepthFirstConstIterator()
-    :   m_pointee(0)
-{
-
-}
-
-DepthFirstConstIterator::DepthFirstConstIterator
-    (const QObject& root)
-    :   m_pointee(&root)
-{
-
-}
-
-DepthFirstConstIterator&
-    DepthFirstConstIterator::operator++()
-{
-    const QObjectList& children = m_pointee->children();
-
-    if (children.count() == 0) {
-        backtrack();
-    }
-    else {
-        m_history.push(0);
-        m_pointee = children.first();
-    }
-
-    return *this;
-}
-
-void DepthFirstConstIterator::backtrack()
-{
-    if (m_history.count()) {
-        const int index = m_history.top();
-        m_history.pop();
-
-        const QObjectList& siblings = m_pointee->parent()->children();
-        if (siblings.count() > index + 1) {
-            m_history.push(index + 1);
-            m_pointee = siblings[index + 1];
-        }
-        else {
-            m_pointee = m_pointee->parent();
-            backtrack();
-        }
-    }
-    else {
-        // Reached end of search
-        m_pointee = 0;
-    }
-}
-
-
-
-AncestorConstIterator::AncestorConstIterator()
-{
-
-}
-
-AncestorConstIterator::AncestorConstIterator(const QObject& leaf)
-{
-    m_ancestors.push(&leaf);
-    QObject* ancestor = leaf.parent();
-    while(ancestor)
-    {
-        m_ancestors.push(ancestor);
-        ancestor = ancestor->parent();
-    }
-}
-
-} // namespace ObjectTree
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/objecttree.h b/src/3rdparty/phonon/mmf/objecttree.h
deleted file mode 100644
index 96adb6f..0000000
--- a/src/3rdparty/phonon/mmf/objecttree.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef OBJECTTREE_H
-#define OBJECTTREE_H
-
-#include <QObject>
-#include <QStack>
-
-QT_BEGIN_NAMESPACE
-
-namespace ObjectTree
-{
-
-/**
- * Depth-first iterator for QObject tree
- */
-class DepthFirstConstIterator
-{
-public:
-    DepthFirstConstIterator();
-    DepthFirstConstIterator(const QObject& root);
-
-    DepthFirstConstIterator& operator++();
-
-    inline bool operator==(const DepthFirstConstIterator& other) const
-    { return other.m_pointee == m_pointee; }
-
-    inline bool operator!=(const DepthFirstConstIterator& other) const
-    { return other.m_pointee != m_pointee; }
-
-    inline const QObject* operator->() const { return m_pointee; }
-    inline const QObject& operator*() const { return *m_pointee; }
-
-private:
-    void backtrack();
-
-private:
-    const QObject* m_pointee;
-    QStack<int> m_history;
-};
-
-/**
- * Ancestor iterator for QObject tree
- */
-class AncestorConstIterator
-{
-public:
-    AncestorConstIterator();
-    AncestorConstIterator(const QObject& root);
-
-    inline AncestorConstIterator& operator++()
-    { m_ancestors.pop(); return *this; }
-
-    inline bool operator==(const AncestorConstIterator& other) const
-    { return other.m_ancestors == m_ancestors; }
-
-    inline bool operator!=(const AncestorConstIterator& other) const
-    { return other.m_ancestors != m_ancestors; }
-
-    inline const QObject* operator->() const { return m_ancestors.top(); }
-    inline const QObject& operator*() const { return *m_ancestors.top(); }
-
-private:
-    QStack<const QObject*> m_ancestors;
-
-};
-
-/**
- * Generic algorithm for visiting nodes in an object tree.  Nodes in the
- * tree are visited in a const context, therefore they are not modified
- * by this algorithm.
- *
- * Visitor must provide functions with the following signatures:
- *
- *      Called before visit begins
- *          void visitPrepare()
- *
- *      Called on each node visited
- *          void visitNode(const QObject& object)
- *
- *      Called when visit is complete
- *          void visitComplete()
- */
-template <class Iterator, class Visitor>
-void visit(Iterator begin, Iterator end, Visitor& visitor)
-{
-    visitor.visitPrepare();
-
-    for ( ; begin != end; ++begin)
-        visitor.visitNode(*begin);
-
-    visitor.visitComplete();
-}
-
-} // namespace ObjectTree
-
-QT_END_NAMESPACE
-
-#endif // OBJECTTREE_H
diff --git a/src/3rdparty/phonon/mmf/utils.cpp b/src/3rdparty/phonon/mmf/utils.cpp
deleted file mode 100644
index 2d17bd2..0000000
--- a/src/3rdparty/phonon/mmf/utils.cpp
+++ /dev/null
@@ -1,258 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "utils.h"
-#include <e32std.h>
-#include <mmf/common/mmferrors.h>
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \namespace Phonon::MMF::Utils
-  \internal
-*/
-
-/*! \class Phonon::MMF::TTraceContext
-  \internal
-*/
-
-/*! \enum Phonon::MMF::PanicCode
- \internal
-*/
-
-/*! \enum Phonon::MMF::TTraceCategory
- \internal
-*/
-
-/*! \enum Phonon::MMF::MediaType
- \internal
-*/
-
-_LIT(PanicCategory, "Phonon::MMF");
-
-void MMF::Utils::panic(PanicCode code)
-{
-    User::Panic(PanicCategory, code);
-}
-
-
-static const TInt KMimePrefixLength = 6; // either "audio/" or "video/"
-_LIT(KMimePrefixAudio, "audio/");
-_LIT(KMimePrefixVideo, "video/");
-
-MMF::MediaType MMF::Utils::mimeTypeToMediaType(const TDesC& mimeType)
-{
-    MediaType result = MediaTypeUnknown;
-
-    if (mimeType.Left(KMimePrefixLength).Compare(KMimePrefixAudio) == 0) {
-        result = MediaTypeAudio;
-    } else if (mimeType.Left(KMimePrefixLength).Compare(KMimePrefixVideo) == 0) {
-        result = MediaTypeVideo;
-    }
-
-    return result;
-}
-
-QString MMF::Utils::symbianErrorToString(int errorCode)
-{
-    /**
-     * Here we translate only the error codes which are likely to be
-     * meaningful to the user.  For example, when an error occurs
-     * during opening of a media file, displaying "not found" or
-     * "permission denied" is informative.  On the other hand,
-     * differentiating between KErrGeneral and KErrArgument at the UI
-     * level does not make sense.
-     */
-    switch (errorCode)
-    {
-    // System-wide errors
-    case KErrNone:
-        return tr("No error");
-    case KErrNotFound:
-        return tr("Not found");
-    case KErrNoMemory:
-        return tr("Out of memory");
-    case KErrNotSupported:
-        return tr("Not supported");
-    case KErrOverflow:
-        return tr("Overflow");
-    case KErrUnderflow:
-        return tr("Underflow");
-    case KErrAlreadyExists:
-        return tr("Already exists");
-    case KErrPathNotFound:
-        return tr("Path not found");
-    case KErrInUse:
-        return tr("In use");
-    case KErrNotReady:
-        return tr("Not ready");
-    case KErrAccessDenied:
-        return tr("Access denied");
-    case KErrCouldNotConnect:
-        return tr("Could not connect");
-    case KErrDisconnected:
-        return tr("Disconnected");
-    case KErrPermissionDenied:
-        return tr("Permission denied");
-
-    // Multimedia framework errors
-    case KErrMMNotEnoughBandwidth:
-        return tr("Insufficient bandwidth");
-    case KErrMMSocketServiceNotFound:
-    case KErrMMServerSocket:
-        return tr("Network unavailable");
-    case KErrMMNetworkRead:
-    case KErrMMNetworkWrite:
-    case KErrMMUDPReceive:
-        return tr("Network communication error");
-    case KErrMMServerNotSupported:
-        return tr("Streaming not supported");
-    case KErrMMServerAlert:
-        return tr("Server alert");
-    case KErrMMInvalidProtocol:
-        return tr("Invalid protocol");
-    case KErrMMInvalidURL:
-        return tr("Invalid URL");
-    case KErrMMMulticast:
-        return tr("Multicast error");
-    case KErrMMProxyServer:
-    case KErrMMProxyServerConnect:
-        return tr("Proxy server error");
-    case KErrMMProxyServerNotSupported:
-        return tr("Proxy server not supported");
-    case KErrMMAudioDevice:
-        return tr("Audio output error");
-    case KErrMMVideoDevice:
-        return tr("Video output error");
-    case KErrMMDecoder:
-        return tr("Decoder error");
-    case KErrMMPartialPlayback:
-        return tr("Audio or video components could not be played");
-    case KErrMMDRMNotAuthorized:
-        return tr("DRM error");
-
-    /*
-    // We don't use QoS settings
-    case KErrMMQosLowBandwidth:
-    case KErrMMQosUnsupportedTrafficClass:
-    case KErrMMQosPoorTrafficClass:
-    case KErrMMQosUnsupportedParameters:
-    case KErrMMQosPoorParameters:
-    case KErrMMQosNotSupported:
-    */
-
-    // Catch-all for errors other than those above
-    default:
-    {
-        return tr("Unknown error (%1)").arg(errorCode);
-    }
-    }
-}
-
-#ifndef QT_NO_DEBUG
-
-#include <hal.h>
-#include <hal_data.h>
-#include <gdi.h>
-#include <eikenv.h>
-
-struct TScreenInfo
-{
-    int width;
-    int height;
-    int bpp;
-    const char* address;
-    int initialOffset;
-    int lineOffset;
-    TDisplayMode displayMode;
-};
-
-static void getScreenInfoL(TScreenInfo& info)
-{
-    info.displayMode = CEikonEnv::Static()->ScreenDevice()->DisplayMode();
-
-    // Then we must set these as the input parameter
-    info.width = info.displayMode;
-    info.height = info.displayMode;
-    info.initialOffset = info.displayMode;
-    info.lineOffset = info.displayMode;
-    info.bpp = info.displayMode;
-
-    User::LeaveIfError( HAL::Get(HALData::EDisplayXPixels, info.width) );
-    User::LeaveIfError( HAL::Get(HALData::EDisplayYPixels, info.width) );
-
-    int address;
-    User::LeaveIfError( HAL::Get(HALData::EDisplayMemoryAddress, address) );
-    info.address = reinterpret_cast<const char*>(address);
-
-    User::LeaveIfError( HAL::Get(HALData::EDisplayOffsetToFirstPixel, info.initialOffset) );
-
-    User::LeaveIfError( HAL::Get(HALData::EDisplayOffsetBetweenLines, info.lineOffset) );
-
-    User::LeaveIfError( HAL::Get(HALData::EDisplayBitsPerPixel, info.bpp) );
-}
-
-
-QColor MMF::Utils::getScreenPixel(const QPoint& pos)
-{
-    TScreenInfo info;
-    TRAPD(err, getScreenInfoL(info));
-    QColor pixel;
-    if (err == KErrNone and pos.x() < info.width and pos.y() < info.height)
-    {
-        const int bytesPerPixel = info.bpp / 8;
-        Q_ASSERT(bytesPerPixel >= 3);
-
-        const int stride = (info.width * bytesPerPixel) + info.lineOffset;
-
-        const char* ptr =
-                info.address
-            +    info.initialOffset
-            +    pos.y() * stride
-            +    pos.x() * bytesPerPixel;
-
-        // BGRA
-        pixel.setBlue(*ptr++);
-        pixel.setGreen(*ptr++);
-        pixel.setRed(*ptr++);
-
-        if (bytesPerPixel == 4)
-            pixel.setAlpha(*ptr++);
-    }
-    return pixel;
-}
-
-// Debugging: for debugging video visibility
-void MMF::Utils::dumpScreenPixelSample()
-{
-    for (int i=0; i<20; ++i) {
-        const QPoint pos(i*10, i*10);
-        const QColor pixel = Utils::getScreenPixel(pos);
-        RDebug::Printf(
-            "Phonon::MMF::Utils::dumpScreenPixelSample %d %d = %d %d %d %d",
-            pos.x(), pos.y(), pixel.red(), pixel.green(), pixel.blue(), pixel.alpha()
-        );
-    }
-}
-
-#endif // _DEBUG
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/utils.h b/src/3rdparty/phonon/mmf/utils.h
deleted file mode 100644
index 56ccafc..0000000
--- a/src/3rdparty/phonon/mmf/utils.h
+++ /dev/null
@@ -1,176 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_UTILS_H
-#define PHONON_MMF_UTILS_H
-
-#include <private/qcore_symbian_p.h>
-#include <e32debug.h>   // for RDebug
-#include <QtCore/QCoreApplication> // for Q_DECLARE_TR_FUNCTIONS
-#include <QColor>
-
-#include "defs.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-/**
- * Panic codes for fatal errors
- */
-enum PanicCode {
-    InvalidStatePanic               = 1,
-    InvalidMediaTypePanic           = 2,
-    InvalidBackendInterfaceClass    = 3,
-    AudioUtilityUrlNotSupported     = 4
-};
-
-class Utils
-{
-    Q_DECLARE_TR_FUNCTIONS(Utils)
-
-public:
-/**
- * Raise a fatal exception
- */
-static void panic(PanicCode code);
-
-/**
- * Determines whether the provided MIME type is an audio or video
- * type.  If it is neither, the function returns MediaTypeUnknown.
- */
-static MediaType mimeTypeToMediaType(const TDesC& mimeType);
-
-/**
- * Translates a Symbian error code into a user-readable string.
- */
-static QString symbianErrorToString(int errorCode);
-
-#ifndef QT_NO_DEBUG
-/**
- * Retrieve color of specified pixel from the screen.
- */
-static QColor getScreenPixel(const QPoint& pos);
-
-/**
- * Samples a small number of pixels from the screen, and dumps their
- * colors to the debug log.
- */
-static void dumpScreenPixelSample();
-#endif
-};
-
-/**
- * Available trace categories;
- */
-enum TTraceCategory {
-    /**
-     * Backend
-     */
-    EBackend             = 0x00000001,
-
-    /**
-     * Functions which map directly to the public Phonon audio API
-     */
-    EAudioApi            = 0x00000010,
-
-    /**
-     * Internal functions in the audio implementation
-     */
-    EAudioInternal       = 0x00000020,
-
-    /**
-     * Functions which map directly to the public Phonon video API
-     */
-    EVideoApi            = 0x00010000,
-
-    /**
-     * Internal functions in the video implementation
-     */
-    EVideoInternal       = 0x00020000
-};
-
-/**
- * Mask indicating which trace categories are enabled
- *
- * Note that, at the moment, this is a compiled static constant.  For
- * runtime control over enabled trace categories, this could be replaced
- * by a per-thread singleton object which owns the trace mask, and which
- * exposes an API allowing it to be modified.
- */
-static const TUint KTraceMask = 0xffffffff;
-
-/**
- * Data structure used by tracing macros
- */
-class TTraceContext
-{
-public:
-    TTraceContext(const TText* aFunction, const TUint aAddr,
-                  const TUint aCategory = 0)
-            :    iFunction(aFunction),
-            iAddr(aAddr),
-            iCategory(aCategory) { }
-
-    /**
-     * Check whether iCategory appears in the trace mask
-     */
-    TBool Enabled() const {
-        return (iCategory == 0) or(iCategory & KTraceMask);
-    }
-
-    const TText*    iFunction;    // Name of function
-    const TUint        iAddr;        // 'this' pointer
-    const TUint        iCategory;
-};
-
-// Macros used internally by the trace system
-#define _TRACE_PRINT RDebug::Print
-#define _TRACE_TEXT(x) (TPtrC((const TText *)(x)))
-#define _TRACE_MODULE Phonon::MMF
-
-// Macros available for use by implementation code
-#ifndef QT_NO_DEBUG
-#define TRACE_CONTEXT(_fn, _cat) const ::Phonon::MMF::TTraceContext _tc((TText*)L ## #_fn, (TUint)this, _cat);
-#define TRACE_ENTRY_0() { if (_tc.Enabled()) _TRACE_PRINT(_TRACE_TEXT(L ## "+ Phonon::MMF::%s [0x%08x]"), _tc.iFunction, _tc.iAddr); }
-#define TRACE_ENTRY(string, args...) { if (_tc.Enabled()) _TRACE_PRINT(_TRACE_TEXT(L ## "+ Phonon::MMF::%s [0x%08x] " L ## string), _tc.iFunction, _tc.iAddr, args); }
-#define TRACE_EXIT_0() { if (_tc.Enabled()) _TRACE_PRINT(_TRACE_TEXT(L ## "- Phonon::MMF::%s [0x%08x]"), _tc.iFunction, _tc.iAddr); }
-#define TRACE_EXIT(string, args...) { if (_tc.Enabled()) _TRACE_PRINT(_TRACE_TEXT(L ## "- Phonon::MMF::%s [0x%08x] " L ## string), _tc.iFunction, _tc.iAddr, args); }
-#define TRACE_RETURN(string, result) { if (_tc.Enabled()) _TRACE_PRINT(_TRACE_TEXT(L ## "r Phonon::MMF::%s [0x%08x] " L ## string), _tc.iFunction, _tc.iAddr, result); } return result;
-#define TRACE_PANIC(code) { _TRACE_PRINT(_TRACE_TEXT(L ## "! Phonon::MMF::%s [0x%08x] panic %d"), _tc.iFunction, _tc.iAddr, code); } Utils::panic(code);
-#define TRACE_0(string) { if (_tc.Enabled()) _TRACE_PRINT(_TRACE_TEXT(L ## "  Phonon::MMF::%s [0x%08x] " L ## string), _tc.iFunction, _tc.iAddr); }
-#define TRACE(string, args...) { if (_tc.Enabled()) _TRACE_PRINT(_TRACE_TEXT(L ## "  Phonon::MMF::%s [0x%08x] " L ## string), _tc.iFunction, _tc.iAddr, args); }
-#else
-#define TRACE_CONTEXT(_fn, _cat)
-#define TRACE_ENTRY_0()
-#define TRACE_ENTRY(string, args...)
-#define TRACE_EXIT_0()
-#define TRACE_EXIT(string, args...)
-#define TRACE_RETURN(string, result) return result;
-#define TRACE_PANIC(code) Utils::panic(code);
-#define TRACE_0(string)
-#define TRACE(string, args...)
-#endif
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/mmf/videooutput.cpp b/src/3rdparty/phonon/mmf/videooutput.cpp
deleted file mode 100644
index 119dcb1..0000000
--- a/src/3rdparty/phonon/mmf/videooutput.cpp
+++ /dev/null
@@ -1,303 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "ancestormovemonitor.h"
-#include "utils.h"
-#include "videooutput.h"
-
-#ifndef QT_NO_DEBUG
-#include "objectdump.h"
-#endif
-
-#include <QPaintEvent>
-#include <QPainter>
-#include <QMoveEvent>
-#include <QResizeEvent>
-
-#include <QtCore/private/qcore_symbian_p.h> // for qt_TRect2QRect
-#include <QtGui/private/qwidget_p.h> // to access QWExtra
-
-#include <coecntrl.h>
-
-#include <coemain.h>    // for CCoeEnv
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::VideoOutput
-  \internal
-*/
-
-//-----------------------------------------------------------------------------
-// Constants
-//-----------------------------------------------------------------------------
-
-static const Phonon::VideoWidget::AspectRatio DefaultAspectRatio =
-    Phonon::VideoWidget::AspectRatioAuto;
-static const Phonon::VideoWidget::ScaleMode DefaultScaleMode =
-    Phonon::VideoWidget::FitInView;
-
-
-//-----------------------------------------------------------------------------
-// Constructor / destructor
-//-----------------------------------------------------------------------------
-
-MMF::VideoOutput::VideoOutput
-    (AncestorMoveMonitor* ancestorMoveMonitor, QWidget* parent)
-        :   QWidget(parent)
-        ,   m_ancestorMoveMonitor(ancestorMoveMonitor)
-        ,   m_aspectRatio(DefaultAspectRatio)
-        ,   m_scaleMode(DefaultScaleMode)
-{
-    TRACE_CONTEXT(VideoOutput::VideoOutput, EVideoInternal);
-    TRACE_ENTRY("parent 0x%08x", parent);
-
-    setPalette(QPalette(Qt::black));
-    setAttribute(Qt::WA_OpaquePaintEvent, true);
-    setAttribute(Qt::WA_NoSystemBackground, true);
-    setAutoFillBackground(false);
-
-    qt_widget_private(this)->extraData()->nativePaintMode = QWExtra::ZeroFill;
-    qt_widget_private(this)->extraData()->receiveNativePaintEvents = true;
-
-    getVideoWindowRect();
-    registerForAncestorMoved();
-
-    dump();
-
-    TRACE_EXIT_0();
-}
-
-MMF::VideoOutput::~VideoOutput()
-{
-    TRACE_CONTEXT(VideoOutput::~VideoOutput, EVideoInternal);
-    TRACE_ENTRY_0();
-
-    m_ancestorMoveMonitor->unRegisterTarget(this);
-
-    TRACE_EXIT_0();
-}
-
-void MMF::VideoOutput::setVideoSize(const QSize& frameSize)
-{
-    TRACE_CONTEXT(VideoOutput::setVideoSize, EVideoInternal);
-    TRACE("oldSize %d %d newSize %d %d",
-          m_videoFrameSize.width(), m_videoFrameSize.height(),
-          frameSize.width(), frameSize.height());
-
-    if (frameSize != m_videoFrameSize) {
-        m_videoFrameSize = frameSize;
-        updateGeometry();
-    }
-}
-
-void MMF::VideoOutput::ancestorMoved()
-{
-    TRACE_CONTEXT(VideoOutput::ancestorMoved, EVideoInternal);
-    TRACE_ENTRY_0();
-
-    RWindowBase *const window = videoWindow();
-
-    if(window) {
-        const TPoint newWindowPosSymbian = window->AbsPosition();
-        const QPoint newWindowPos(newWindowPosSymbian.iX, newWindowPosSymbian.iY);
-
-        if(newWindowPos != m_videoWindowRect.topLeft()) {
-            m_videoWindowRect.moveTo(newWindowPos);
-            emit videoWindowChanged();
-        }
-    }
-
-    TRACE_EXIT_0();
-}
-
-//-----------------------------------------------------------------------------
-// QWidget
-//-----------------------------------------------------------------------------
-
-QSize MMF::VideoOutput::sizeHint() const
-{
-    // TODO: replace this with a more sensible default
-    QSize result(320, 240);
-
-    if (!m_videoFrameSize.isNull())
-        result = m_videoFrameSize;
-
-    return result;
-}
-
-void MMF::VideoOutput::paintEvent(QPaintEvent* event)
-{
-    TRACE_CONTEXT(VideoOutput::paintEvent, EVideoInternal);
-    TRACE("rect %d %d - %d %d",
-          event->rect().left(), event->rect().top(),
-          event->rect().right(), event->rect().bottom());
-    TRACE("regions %d", event->region().rectCount());
-    TRACE("type %d", event->type());
-
-    // Do nothing
-}
-
-void MMF::VideoOutput::resizeEvent(QResizeEvent* event)
-{
-    TRACE_CONTEXT(VideoOutput::resizeEvent, EVideoInternal);
-    TRACE("%d %d -> %d %d",
-          event->oldSize().width(), event->oldSize().height(),
-          event->size().width(), event->size().height());
-
-    if(event->size() != event->oldSize()) {
-        m_videoWindowRect.setSize(event->size());
-        emit videoWindowChanged();
-    }
-}
-
-void MMF::VideoOutput::moveEvent(QMoveEvent* event)
-{
-    TRACE_CONTEXT(VideoOutput::moveEvent, EVideoInternal);
-    TRACE("%d %d -> %d %d",
-          event->oldPos().x(), event->oldPos().y(),
-          event->pos().x(), event->pos().y());
-
-    if(event->pos() != event->oldPos()) {
-        m_videoWindowRect.moveTo(event->pos());
-        emit videoWindowChanged();
-    }
-}
-
-bool MMF::VideoOutput::event(QEvent* event)
-{
-    TRACE_CONTEXT(VideoOutput::event, EVideoInternal);
-
-    if (event->type() == QEvent::WinIdChange) {
-        TRACE_0("WinIdChange");
-        getVideoWindowRect();
-        emit videoWindowChanged();
-        return true;
-    } else if (event->type() == QEvent::ParentChange) {
-        // Tell ancestor move monitor to update ancestor list for this widget
-        registerForAncestorMoved();
-        return true;
-    } else
-        return QWidget::event(event);
-}
-
-
-//-----------------------------------------------------------------------------
-// Public functions
-//-----------------------------------------------------------------------------
-
-RWindowBase* MMF::VideoOutput::videoWindow()
-{
-    CCoeControl *control = internalWinId();
-    if(!control)
-        control = effectiveWinId();
-
-    RWindowBase *window = 0;
-    if(control)
-        window = control->DrawableWindow();
-
-    return window;
-}
-
-const QRect& MMF::VideoOutput::videoWindowRect() const
-{
-    return m_videoWindowRect;
-}
-
-Phonon::VideoWidget::AspectRatio MMF::VideoOutput::aspectRatio() const
-{
-    return m_aspectRatio;
-}
-
-void MMF::VideoOutput::setAspectRatio
-    (Phonon::VideoWidget::AspectRatio aspectRatio)
-{
-    if(m_aspectRatio != aspectRatio) {
-        m_aspectRatio = aspectRatio;
-        emit aspectRatioChanged();
-    }
-}
-
-Phonon::VideoWidget::ScaleMode MMF::VideoOutput::scaleMode() const
-{
-    return m_scaleMode;
-}
-
-void MMF::VideoOutput::setScaleMode
-    (Phonon::VideoWidget::ScaleMode scaleMode)
-{
-    if(m_scaleMode != scaleMode) {
-        m_scaleMode = scaleMode;
-        emit scaleModeChanged();
-    }
-}
-
-
-//-----------------------------------------------------------------------------
-// Private functions
-//-----------------------------------------------------------------------------
-
-void MMF::VideoOutput::getVideoWindowRect()
-{
-    RWindowBase *const window = videoWindow();
-    if(window)
-        m_videoWindowRect =
-            qt_TRect2QRect(TRect(window->AbsPosition(), window->Size()));
-}
-
-void MMF::VideoOutput::registerForAncestorMoved()
-{
-    m_ancestorMoveMonitor->registerTarget(this);
-}
-
-void MMF::VideoOutput::dump() const
-{
-#ifndef QT_NO_DEBUG
-    TRACE_CONTEXT(VideoOutput::dump, EVideoInternal);
-
-    QScopedPointer<ObjectDump::QVisitor> visitor(new ObjectDump::QVisitor);
-    visitor->setPrefix("Phonon::MMF"); // to aid searchability of logs
-    ObjectDump::addDefaultAnnotators(*visitor);
-    TRACE("Dumping tree from leaf 0x%08x:", this);
-    ObjectDump::dumpTreeFromLeaf(*this, *visitor);
-
-    QScopedPointer<ObjectDump::QDumper> dumper(new ObjectDump::QDumper);
-    dumper->setPrefix("Phonon::MMF"); // to aid searchability of logs
-    ObjectDump::addDefaultAnnotators(*dumper);
-    TRACE_0("Dumping VideoOutput:");
-    dumper->dumpObject(*this);
-#endif
-}
-
-void MMF::VideoOutput::beginNativePaintEvent(const QRect& /*controlRect*/)
-{
-    emit beginVideoWindowNativePaint();
-}
-
-void MMF::VideoOutput::endNativePaintEvent(const QRect& /*controlRect*/)
-{
-    // Ensure that draw ops are executed into the WSERV output framebuffer
-    CCoeEnv::Static()->WsSession().Flush();
-
-    emit endVideoWindowNativePaint();
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/videooutput.h b/src/3rdparty/phonon/mmf/videooutput.h
deleted file mode 100644
index 0bf7586..0000000
--- a/src/3rdparty/phonon/mmf/videooutput.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_VIDEOOUTPUT_H
-#define PHONON_MMF_VIDEOOUTPUT_H
-
-#include <QtGui/QWidget>
-#include <QVector>
-#include <QRect>
-#include "defs.h"
-
-#include <Phonon/videowidget.h>
-
-#include <e32std.h>
-class RWindowBase;
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-class AncestorMoveMonitor;
-
-class VideoOutput       :   public QWidget
-{
-    Q_OBJECT
-
-public:
-    VideoOutput(AncestorMoveMonitor* ancestorMoveMonitor, QWidget* parent);
-    ~VideoOutput();
-
-    // Set size of video frame.  Called by VideoPlayer.
-    void setVideoSize(const QSize& size);
-
-    RWindowBase* videoWindow();
-    const QRect& videoWindowRect() const;
-
-    Phonon::VideoWidget::AspectRatio aspectRatio() const;
-    void setAspectRatio(Phonon::VideoWidget::AspectRatio aspectRatio);
-
-    Phonon::VideoWidget::ScaleMode scaleMode() const;
-    void setScaleMode(Phonon::VideoWidget::ScaleMode scaleMode);
-
-    // Called by AncestorMoveMonitor
-    void ancestorMoved();
-
-    // Debugging output
-    void dump() const;
-
-public Q_SLOTS:
-    void beginNativePaintEvent(const QRect& /*controlRect*/);
-    void endNativePaintEvent(const QRect& /*controlRect*/);
-
-Q_SIGNALS:
-    void videoWindowChanged();
-    void aspectRatioChanged();
-    void scaleModeChanged();
-    void beginVideoWindowNativePaint();
-    void endVideoWindowNativePaint();
-
-protected:
-    // Override QWidget functions
-    QSize sizeHint() const;
-    void paintEvent(QPaintEvent* event);
-    void resizeEvent(QResizeEvent* event);
-    void moveEvent(QMoveEvent* event);
-    bool event(QEvent* event);
-
-private:
-    void getVideoWindowRect();
-    void registerForAncestorMoved();
-
-private:
-    // Not owned
-    AncestorMoveMonitor*    m_ancestorMoveMonitor;
-
-    QSize                   m_videoFrameSize;
-    QRect                   m_videoWindowRect;
-
-    Phonon::VideoWidget::AspectRatio        m_aspectRatio;
-    Phonon::VideoWidget::ScaleMode          m_scaleMode;
-
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/mmf/videowidget.cpp b/src/3rdparty/phonon/mmf/videowidget.cpp
deleted file mode 100644
index bc9acfd..0000000
--- a/src/3rdparty/phonon/mmf/videowidget.cpp
+++ /dev/null
@@ -1,175 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "mediaobject.h"
-#include "utils.h"
-#include "videooutput.h"
-
-#include "videowidget.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Phonon;
-using namespace Phonon::MMF;
-
-/*! \class MMF::VideoWidget
-  \internal
-*/
-
-//-----------------------------------------------------------------------------
-// Constants
-//-----------------------------------------------------------------------------
-
-static const qreal DefaultBrightness = 1.0;
-static const qreal DefaultContrast = 1.0;
-static const qreal DefaultHue = 1.0;
-static const qreal DefaultSaturation = 1.0;
-
-
-//-----------------------------------------------------------------------------
-// Constructor / destructor
-//-----------------------------------------------------------------------------
-
-MMF::VideoWidget::VideoWidget
-    (AncestorMoveMonitor* ancestorMoveMonitor, QWidget* parent)
-        :   MediaNode(parent)
-        ,   m_videoOutput(new VideoOutput(ancestorMoveMonitor, parent))
-        ,   m_brightness(DefaultBrightness)
-        ,   m_contrast(DefaultContrast)
-        ,   m_hue(DefaultHue)
-        ,   m_saturation(DefaultSaturation)
-{
-    TRACE_CONTEXT(VideoWidget::VideoWidget, EVideoApi);
-    TRACE_ENTRY_0();
-
-    TRACE_EXIT_0();
-}
-
-MMF::VideoWidget::~VideoWidget()
-{
-    TRACE_CONTEXT(VideoWidget::~VideoWidget, EVideoApi);
-    TRACE_ENTRY_0();
-
-    TRACE_EXIT_0();
-}
-
-
-//-----------------------------------------------------------------------------
-// VideoWidgetInterface
-//-----------------------------------------------------------------------------
-
-Phonon::VideoWidget::AspectRatio MMF::VideoWidget::aspectRatio() const
-{
-    return m_videoOutput->aspectRatio();
-}
-
-void MMF::VideoWidget::setAspectRatio
-(Phonon::VideoWidget::AspectRatio aspectRatio)
-{
-    TRACE_CONTEXT(VideoWidget::setAspectRatio, EVideoApi);
-    TRACE("aspectRatio %d", aspectRatio);
-
-    m_videoOutput->setAspectRatio(aspectRatio);
-}
-
-qreal MMF::VideoWidget::brightness() const
-{
-    return m_brightness;
-}
-
-void MMF::VideoWidget::setBrightness(qreal brightness)
-{
-    TRACE_CONTEXT(VideoWidget::setBrightness, EVideoApi);
-    TRACE("brightness %f", brightness);
-
-    m_brightness = brightness;
-}
-
-Phonon::VideoWidget::ScaleMode MMF::VideoWidget::scaleMode() const
-{
-    return m_videoOutput->scaleMode();
-}
-
-void MMF::VideoWidget::setScaleMode(Phonon::VideoWidget::ScaleMode scaleMode)
-{
-    TRACE_CONTEXT(VideoWidget::setScaleMode, EVideoApi);
-    TRACE("setScaleMode %d", setScaleMode);
-
-    m_videoOutput->setScaleMode(scaleMode);
-}
-
-qreal MMF::VideoWidget::contrast() const
-{
-    return m_contrast;
-}
-
-void MMF::VideoWidget::setContrast(qreal contrast)
-{
-    TRACE_CONTEXT(VideoWidget::setContrast, EVideoApi);
-    TRACE("contrast %f", contrast);
-
-    m_contrast = contrast;
-}
-
-qreal MMF::VideoWidget::hue() const
-{
-    return m_hue;
-}
-
-void MMF::VideoWidget::setHue(qreal hue)
-{
-    TRACE_CONTEXT(VideoWidget::setHue, EVideoApi);
-    TRACE("hue %f", hue);
-
-    m_hue = hue;
-}
-
-qreal MMF::VideoWidget::saturation() const
-{
-    return m_saturation;
-}
-
-void MMF::VideoWidget::setSaturation(qreal saturation)
-{
-    TRACE_CONTEXT(VideoWidget::setSaturation, EVideoApi);
-    TRACE("saturation %f", saturation);
-
-    m_saturation = saturation;
-}
-
-QWidget* MMF::VideoWidget::widget()
-{
-    return m_videoOutput.data();
-}
-
-//-----------------------------------------------------------------------------
-// MediaNode
-//-----------------------------------------------------------------------------
-
-void MMF::VideoWidget::connectMediaObject(MediaObject *mediaObject)
-{
-    mediaObject->setVideoOutput(m_videoOutput.data());
-}
-
-void MMF::VideoWidget::disconnectMediaObject(MediaObject *mediaObject)
-{
-    mediaObject->setVideoOutput(0);
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/videowidget.h b/src/3rdparty/phonon/mmf/videowidget.h
deleted file mode 100644
index 45845db..0000000
--- a/src/3rdparty/phonon/mmf/videowidget.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_MMF_VIDEOWIDGET_H
-#define PHONON_MMF_VIDEOWIDGET_H
-
-#include "mmf_medianode.h"
-#include "videooutput.h"
-
-#include <QtGui/QWidget>
-#include <Phonon/videowidget.h>
-#include <Phonon/videowidgetinterface.h>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace MMF
-{
-class AncestorMoveMonitor;
-class VideoOutput;
-
-class VideoWidget       :   public MediaNode
-                        ,   public Phonon::VideoWidgetInterface
-{
-    Q_OBJECT
-    Q_INTERFACES(Phonon::VideoWidgetInterface)
-
-public:
-    VideoWidget(AncestorMoveMonitor* ancestorMoveMonitor, QWidget* parent);
-    ~VideoWidget();
-
-    // VideoWidgetInterface
-    virtual Phonon::VideoWidget::AspectRatio aspectRatio() const;
-    virtual void setAspectRatio(Phonon::VideoWidget::AspectRatio aspectRatio);
-    virtual qreal brightness() const;
-    virtual void setBrightness(qreal brightness);
-    virtual Phonon::VideoWidget::ScaleMode scaleMode() const;
-    virtual void setScaleMode(Phonon::VideoWidget::ScaleMode scaleMode);
-    virtual qreal contrast() const;
-    virtual void setContrast(qreal constrast);
-    virtual qreal hue() const;
-    virtual void setHue(qreal hue);
-    virtual qreal saturation() const;
-    virtual void setSaturation(qreal saturation);
-    virtual QWidget *widget();
-
-protected:
-    // MediaNode
-    void connectMediaObject(MediaObject *mediaObject);
-    void disconnectMediaObject(MediaObject *mediaObject);
-
-private:
-    QScopedPointer<VideoOutput>             m_videoOutput;
-
-    qreal                                   m_brightness;
-    qreal                                   m_contrast;
-    qreal                                   m_hue;
-    qreal                                   m_saturation;
-
-};
-}
-}
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/phonon/CMakeLists.txt b/src/3rdparty/phonon/phonon/CMakeLists.txt
index 11d7913..d669ef0 100644
--- a/src/3rdparty/phonon/phonon/CMakeLists.txt
+++ b/src/3rdparty/phonon/phonon/CMakeLists.txt
@@ -1,12 +1,48 @@
-if (PHONON_BUILD_TESTS)
-    add_subdirectory(tests)
-endif (PHONON_BUILD_TESTS)
-
 if (PHONON_BUILD_EXAMPLES)
     add_subdirectory(examples)
 endif (PHONON_BUILD_EXAMPLES)
 
-add_subdirectory(experimental)
+#add_subdirectory(experimental)
+
+set(PULSEAUDIO_MINIMUM_VERSION "0.9.15")
+macro_optional_find_package(PulseAudio)
+if (PULSEAUDIO_FOUND)
+    # PULSEAUDIO_DEVICE_MANAGER feature check could be moved to FindPulseAudio.cmake, hint hint. -- Rex
+    macro_ensure_version("0.9.21" "${PULSEAUDIO_VERSION}" PULSEAUDIO_DEVICE_MANAGER)
+endif (PULSEAUDIO_FOUND)
+macro_log_feature(PULSEAUDIO_FOUND "PulseAudio" "A cross-platform, networked sound server." "http://www.pulseaudio.org" FALSE "" "Allows audio playback via the PulseAudio soundserver when it is running")
+macro_optional_find_package(GLIB2)
+macro_log_feature(GLIB2_FOUND "GLib2" "GLib 2 is required to compile the pulseaudio for Phonon" "http://www.gtk.org/download/" FALSE)
+
+
+if (GLIB2_FOUND AND PULSEAUDIO_FOUND)
+   add_definitions(-DHAVE_PULSEAUDIO)
+   include_directories(${GLIB2_INCLUDE_DIR} ${PULSEAUDIO_INCLUDE_DIR})
+   if (PULSEAUDIO_DEVICE_MANAGER)
+      add_definitions(-DHAVE_PULSEAUDIO_DEVICE_MANAGER)
+   endif(PULSEAUDIO_DEVICE_MANAGER)
+else(GLIB2_FOUND AND PULSEAUDIO_FOUND)
+   set(PULSEAUDIO_INCLUDE_DIR "")
+   set(PULSEAUDIO_LIBRARY "")
+   set(PULSEAUDIO_MAINLOOP_LIBRARY "")
+endif(GLIB2_FOUND AND PULSEAUDIO_FOUND)
+
+
+set(PULSEAUDIO_MINIMUM_VERSION "0.9.21")
+macro_optional_find_package(PulseAudio)
+macro_log_feature(PULSEAUDIO_FOUND "PulseAudio" "A cross-platform, networked sound server." "http://www.pulseaudio.org" FALSE "" "Allows audio playback via the PulseAudio soundserver when it is running")
+macro_optional_find_package(GLIB2)
+macro_log_feature(GLIB2_FOUND "GLib2" "GLib 2 is required to compile the pulseaudio for Phonon" "http://www.gtk.org/download/" FALSE)
+
+if (GLIB2_FOUND AND PULSEAUDIO_FOUND)
+   add_definitions(-DHAVE_PULSEAUDIO)
+   include_directories(${GLIB2_INCLUDE_DIR} ${PULSEAUDIO_INCLUDE_DIR})
+else(GLIB2_FOUND AND PULSEAUDIO_FOUND)
+   set(PULSEAUDIO_INCLUDE_DIR "")
+   set(PULSEAUDIO_LIBRARY "")
+   set(PULSEAUDIO_MAINLOOP_LIBRARY "")
+endif(GLIB2_FOUND AND PULSEAUDIO_FOUND)
+
 
 set(phonon_LIB_SRCS
    objectdescription.cpp
@@ -35,9 +71,12 @@ set(phonon_LIB_SRCS
    videowidget.cpp
    videoplayer.cpp
    seekslider.cpp
+   swiftslider.cpp
    volumeslider.cpp
    effectwidget.cpp
    iodevicestream.cpp
+   audiodataoutput.cpp
+   pulsesupport.cpp
    )
 
 if (QT_QTDBUS_FOUND)
@@ -50,6 +89,10 @@ endif (QT_QTDBUS_FOUND)
 add_definitions(-DPHONON_LIBRARY_PATH="${PLUGIN_INSTALL_DIR}/plugins")
 automoc4_add_library(phonon SHARED ${phonon_LIB_SRCS})
 target_link_libraries(phonon ${QT_QTCORE_LIBRARY} ${QT_QTGUI_LIBRARY})
+if (GLIB2_FOUND AND PULSEAUDIO_FOUND)
+target_link_libraries(phonon ${GLIB2_LIBRARIES} ${GOBJECT_LIBRARIES} ${PULSEAUDIO_LIBRARY} ${PULSEAUDIO_MAINLOOP_LIBRARY})
+endif (GLIB2_FOUND AND PULSEAUDIO_FOUND)
+
 if (QT_QTDBUS_FOUND)
   target_link_libraries(phonon ${QT_QTDBUS_LIBRARY})
 endif (QT_QTDBUS_FOUND)
@@ -99,6 +142,10 @@ install(FILES
    volumeslider.h
    effectwidget.h
    platformplugin.h
+   audiodataoutput.h
+   audiodataoutputinterface.h
+   globalconfig.h
+   pulsesupport.h
    DESTINATION ${INCLUDE_INSTALL_DIR}/phonon COMPONENT Devel)
 
 install(FILES org.kde.Phonon.AudioOutput.xml  DESTINATION  ${DBUS_INTERFACES_INSTALL_DIR})
diff --git a/src/3rdparty/phonon/phonon/abstractmediastream.cpp b/src/3rdparty/phonon/phonon/abstractmediastream.cpp
index f4a7db6..26e6fd0 100644
--- a/src/3rdparty/phonon/phonon/abstractmediastream.cpp
+++ b/src/3rdparty/phonon/phonon/abstractmediastream.cpp
@@ -49,6 +49,7 @@ AbstractMediaStream::AbstractMediaStream(AbstractMediaStreamPrivate &dd, QObject
 
 AbstractMediaStream::~AbstractMediaStream()
 {
+    delete d_ptr;
 }
 
 qint64 AbstractMediaStream::streamSize() const
diff --git a/src/3rdparty/phonon/phonon/abstractmediastream.h b/src/3rdparty/phonon/phonon/abstractmediastream.h
index 87fa140..5d5bce8 100644
--- a/src/3rdparty/phonon/phonon/abstractmediastream.h
+++ b/src/3rdparty/phonon/phonon/abstractmediastream.h
@@ -214,7 +214,7 @@ class PHONON_EXPORT AbstractMediaStream : public QObject
         virtual void seekStream(qint64 offset);
 
         AbstractMediaStream(AbstractMediaStreamPrivate &dd, QObject *parent);
-        QScopedPointer<AbstractMediaStreamPrivate> d_ptr;
+        AbstractMediaStreamPrivate *d_ptr;
 };
 
 } // namespace Phonon
diff --git a/src/3rdparty/phonon/phonon/abstractmediastream_p.h b/src/3rdparty/phonon/phonon/abstractmediastream_p.h
index a676716..e4c2be9 100644
--- a/src/3rdparty/phonon/phonon/abstractmediastream_p.h
+++ b/src/3rdparty/phonon/phonon/abstractmediastream_p.h
@@ -45,7 +45,6 @@ class PHONON_EXPORT AbstractMediaStreamPrivate : private MediaNodeDestructionHan
     public:
         void setStreamInterface(StreamInterface *);
         void setMediaObjectPrivate(MediaObjectPrivate *);
-        ~AbstractMediaStreamPrivate();
 
     protected:
         AbstractMediaStreamPrivate()
@@ -57,6 +56,7 @@ class PHONON_EXPORT AbstractMediaStreamPrivate : private MediaNodeDestructionHan
             errorType(NoError)
         {
         }
+        ~AbstractMediaStreamPrivate();
 
         virtual void setStreamSize(qint64 newSize);
         virtual void setStreamSeekable(bool s);
diff --git a/src/3rdparty/phonon/phonon/audiodataoutput.cpp b/src/3rdparty/phonon/phonon/audiodataoutput.cpp
new file mode 100644
index 0000000..efbaa3e
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/audiodataoutput.cpp
@@ -0,0 +1,68 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2005 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "audiodataoutput.h"
+#include "audiodataoutput_p.h"
+#include "factory_p.h"
+
+#define PHONON_CLASSNAME AudioDataOutput
+
+namespace Phonon
+{
+
+PHONON_HEIR_IMPL(AbstractAudioOutput)
+
+PHONON_GETTER(int, dataSize, d->dataSize)
+PHONON_GETTER(int, sampleRate, -1)
+PHONON_SETTER(setDataSize, dataSize, int)
+
+bool AudioDataOutputPrivate::aboutToDeleteBackendObject()
+{
+    Q_ASSERT(m_backendObject);
+    pBACKEND_GET(int, dataSize, "dataSize");
+
+    return AbstractAudioOutputPrivate::aboutToDeleteBackendObject();
+}
+
+void AudioDataOutputPrivate::setupBackendObject()
+{
+    Q_Q(AudioDataOutput);
+    Q_ASSERT(m_backendObject);
+    AbstractAudioOutputPrivate::setupBackendObject();
+
+    // set up attributes
+    pBACKEND_CALL1("setDataSize", int, dataSize);
+
+    qRegisterMetaType<QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > >("QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> >");
+
+    QObject::connect(m_backendObject,
+            SIGNAL(dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &)),
+            q, SIGNAL(dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &)));
+    QObject::connect(m_backendObject, SIGNAL(endOfMedia(int)), q, SIGNAL(endOfMedia(int)));
+}
+
+} // namespace Phonon
+
+// #include "audiodataoutput.moc"
+
+#undef PHONON_CLASSNAME
+// vim: sw=4 ts=4 tw=80
diff --git a/src/3rdparty/phonon/phonon/audiodataoutput.h b/src/3rdparty/phonon/phonon/audiodataoutput.h
new file mode 100644
index 0000000..fefd68e
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/audiodataoutput.h
@@ -0,0 +1,135 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2005-2006 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+#ifndef Phonon_AUDIODATAOUTPUT_H
+#define Phonon_AUDIODATAOUTPUT_H
+
+#include "phonon_export.h"
+#include "abstractaudiooutput.h"
+#include "phonondefs.h"
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+template<typename T> class QVector;
+template<typename Key, typename T> class QMap;
+#endif
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+    class AudioDataOutputPrivate;
+
+    /**
+     * \short This class gives you the audio data (for visualizations).
+     *
+     * This class implements a special AbstractAudioOutput that gives your
+     * application the audio data. Don't expect realtime performance. But
+     * the latencies should be low enough to use the audio data for
+     * visualizations. You can also use the audio data for further processing
+     * (e.g. encoding and saving to a file).
+     *
+     * \author Matthias Kretz <kretz@kde.org>
+     */
+    class PHONON_EXPORT AudioDataOutput : public AbstractAudioOutput
+    {
+        Q_OBJECT
+        K_DECLARE_PRIVATE(AudioDataOutput)
+        Q_ENUMS(Channel)
+        Q_PROPERTY(int dataSize READ dataSize WRITE setDataSize)
+        PHONON_HEIR(AudioDataOutput)
+        public:
+            /**
+             * Specifies the channel the audio data belongs to.
+             */
+            enum Channel
+            {
+                LeftChannel,
+                RightChannel,
+                CenterChannel,
+                LeftSurroundChannel,
+                RightSurroundChannel,
+                SubwooferChannel
+            };
+
+            /**
+             * Returns the currently used number of samples passed through
+             * the signal.
+             *
+             * \see setDataSize
+             */
+            int dataSize() const;
+
+            /**
+             * Returns the sample rate in Hz. Common sample rates are 44100 Hz
+             * and 48000 Hz. AudioDataOutput will not do any sample rate
+             * conversion for you. If you need to convert the sample rate you
+             * might want to take a look at libsamplerate. For visualizations it
+             * is often enough to do simple interpolation or even drop/duplicate
+             * samples.
+             *
+             * \return The sample rate as reported by the backend. If the
+             * backend is unavailable -1 is returned.
+             */
+            int sampleRate() const;
+
+        public Q_SLOTS:
+            /**
+             * Sets the number of samples to be passed in one signal emission.
+             *
+             * Defaults to 512 samples per emitted signal.
+             *
+             * \param size the number of samples
+             */
+            void setDataSize(int size);
+
+        Q_SIGNALS:
+            /**
+             * Emitted whenever another dataSize number of samples are ready.
+             *
+             * \param data A mapping of Channel to a vector holding the audio data.
+             */
+            void dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &data);
+
+
+            /**
+             * This signal is emitted before the last dataReady signal of a
+             * media is emitted.
+             *
+             * If, for example, the playback of a media file has finished and the
+             * last audio data of that file is going to be passed with the next
+             * dataReady signal, and only the 28 first samples of the data
+             * vector are from that media file endOfMedia will be emitted right
+             * before dataReady with \p remainingSamples = 28.
+             *
+             * \param remainingSamples The number of samples in the next
+             * dataReady vector that belong to the media that was playing to
+             * this point.
+             */
+            void endOfMedia(int remainingSamples);
+    };
+} // namespace Phonon
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+// vim: sw=4 ts=4 tw=80
+#endif // Phonon_AUDIODATAOUTPUT_H
diff --git a/src/3rdparty/phonon/phonon/audiodataoutput_p.h b/src/3rdparty/phonon/phonon/audiodataoutput_p.h
new file mode 100644
index 0000000..91103a9
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/audiodataoutput_p.h
@@ -0,0 +1,48 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef AUDIODATAOUTPUT_P_H
+#define AUDIODATAOUTPUT_P_H
+
+#include "audiodataoutput.h"
+#include "abstractaudiooutput_p.h"
+
+namespace Phonon
+{
+
+class AudioDataOutputPrivate : public AbstractAudioOutputPrivate
+{
+    Q_DECLARE_PUBLIC(AudioDataOutput)
+    PHONON_PRIVATECLASS
+    protected:
+        AudioDataOutputPrivate()
+            : dataSize(512)
+        {
+        }
+
+        int dataSize;
+};
+
+} // namespace Phonon
+
+#endif // AUDIODATAOUTPUT_P_H
+// vim: sw=4 ts=4 tw=80
diff --git a/src/3rdparty/phonon/phonon/audiodataoutputinterface.h b/src/3rdparty/phonon/phonon/audiodataoutputinterface.h
new file mode 100644
index 0000000..bc1aad0
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/audiodataoutputinterface.h
@@ -0,0 +1,44 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2008 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef PHONON_AUDIODATAOUTPUTINTERFACE_H
+#define PHONON_AUDIODATAOUTPUTINTERFACE_H
+
+namespace Phonon
+{
+
+class AudioDataOutput;
+
+class AudioDataOutputInterface
+{
+    public:
+        virtual ~AudioDataOutputInterface() {}
+
+        virtual AudioDataOutput *frontendObject() const = 0;
+        virtual void setFrontendObject(AudioDataOutput *) = 0;
+};
+
+} // namespace Phonon
+
+Q_DECLARE_INTERFACE(Phonon::AudioDataOutputInterface, "0AudioDataOutputInterface.phonon.kde.org")
+
+#endif // PHONON_AUDIODATAOUTPUTINTERFACE_H
diff --git a/src/3rdparty/phonon/phonon/audiooutput.cpp b/src/3rdparty/phonon/phonon/audiooutput.cpp
index 0f6a49b..89b24bd 100644
--- a/src/3rdparty/phonon/phonon/audiooutput.cpp
+++ b/src/3rdparty/phonon/phonon/audiooutput.cpp
@@ -24,10 +24,11 @@
 #include "factory_p.h"
 #include "objectdescription.h"
 #include "audiooutputadaptor_p.h"
-#include "globalconfig_p.h"
+#include "globalconfig.h"
 #include "audiooutputinterface.h"
 #include "phononnamespace_p.h"
 #include "platform_p.h"
+#include "pulsesupport.h"
 
 #include <QtCore/qmath.h>
 
@@ -42,8 +43,12 @@ QT_BEGIN_NAMESPACE
 namespace Phonon
 {
 
-static inline bool callSetOutputDevice(MediaNodePrivate *const d, int index)
+static inline bool callSetOutputDevice(AudioOutputPrivate *const d, int index)
 {
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive())
+        return pulse->setOutputDevice(d->getStreamUuid(), index);
+
     Iface<IFACES2> iface(d);
     if (iface) {
         return iface->setOutputDevice(AudioOutputDevice::fromIndex(index));
@@ -51,8 +56,12 @@ static inline bool callSetOutputDevice(MediaNodePrivate *const d, int index)
     return Iface<IFACES0>::cast(d)->setOutputDevice(index);
 }
 
-static inline bool callSetOutputDevice(MediaNodePrivate *const d, const AudioOutputDevice &dev)
+static inline bool callSetOutputDevice(AudioOutputPrivate *const d, const AudioOutputDevice &dev)
 {
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive())
+        return pulse->setOutputDevice(d->getStreamUuid(), dev.index());
+
     Iface<IFACES2> iface(d);
     if (iface) {
         return iface->setOutputDevice(dev);
@@ -89,6 +98,8 @@ void AudioOutputPrivate::init(Phonon::Category c)
 #endif
 
     category = c;
+    streamUuid = QUuid::createUuid().toString();
+    PulseSupport::getInstance()->setStreamPropList(category, streamUuid);
 
     // select hardware device according to the category
     device = AudioOutputDevice::fromIndex(GlobalConfig().audioOutputDeviceFor(category, GlobalConfig::AdvancedDevicesFromSettings | GlobalConfig::HideUnavailableDevices));
@@ -98,7 +109,10 @@ void AudioOutputPrivate::init(Phonon::Category c)
     q->connect(Factory::sender(), SIGNAL(availableAudioOutputDevicesChanged()), SLOT(_k_deviceListChanged()));
 }
 
-
+QString AudioOutputPrivate::getStreamUuid()
+{
+    return streamUuid;
+}
 
 void AudioOutputPrivate::createBackendObject()
 {
@@ -234,7 +248,7 @@ bool AudioOutput::setOutputDevice(const AudioOutputDevice &newAudioOutputDevice)
         d->device = newAudioOutputDevice;
     }
     if (k_ptr->backendObject()) {
-        return callSetOutputDevice(k_ptr, d->device.index());
+        return callSetOutputDevice(d, d->device.index());
     }
     return true;
 }
@@ -259,7 +273,6 @@ void AudioOutputPrivate::setupBackendObject()
     // set up attributes
     pINTERFACE_CALL(setVolume(pow(volume, VOLTAGE_TO_LOUDNESS_EXPONENT)));
 
-#ifndef QT_NO_PHONON_SETTINGSGROUP
     // if the output device is not available and the device was not explicitly set
     if (!callSetOutputDevice(this, device) && !outputDeviceOverridden) {
         // fall back in the preference list of output devices
@@ -267,8 +280,8 @@ void AudioOutputPrivate::setupBackendObject()
         if (deviceList.isEmpty()) {
             return;
         }
-        for (int i = 0; i < deviceList.count(); ++i) {
-            const AudioOutputDevice &dev = AudioOutputDevice::fromIndex(deviceList.at(i));
+        foreach (int devIndex, deviceList) {
+            const AudioOutputDevice &dev = AudioOutputDevice::fromIndex(devIndex);
             if (callSetOutputDevice(this, dev)) {
                 handleAutomaticDeviceChange(dev, AudioOutputPrivate::FallbackChange);
                 return; // found one that works
@@ -279,7 +292,6 @@ void AudioOutputPrivate::setupBackendObject()
         callSetOutputDevice(this, none);
         handleAutomaticDeviceChange(none, FallbackChange);
     }
-#endif //QT_NO_PHONON_SETTINGSGROUP
 }
 
 void AudioOutputPrivate::_k_volumeChanged(qreal newVolume)
@@ -309,10 +321,8 @@ void AudioOutputPrivate::_k_audioDeviceFailed()
     pDebug() << Q_FUNC_INFO;
     // outputDeviceIndex identifies a failing device
     // fall back in the preference list of output devices
-#ifndef QT_NO_PHONON_SETTINGSGROUP
-    const QList<int> deviceList = GlobalConfig().audioOutputDeviceListFor(category, GlobalConfig::AdvancedDevicesFromSettings | GlobalConfig::HideUnavailableDevices);
-    for (int i = 0; i < deviceList.count(); ++i) {
-        const int devIndex = deviceList.at(i);
+    QList<int> deviceList = GlobalConfig().audioOutputDeviceListFor(category, GlobalConfig::AdvancedDevicesFromSettings | GlobalConfig::HideUnavailableDevices);
+    foreach (int devIndex, deviceList) {
         // if it's the same device as the one that failed, ignore it
         if (device.index() != devIndex) {
             const AudioOutputDevice &info = AudioOutputDevice::fromIndex(devIndex);
@@ -322,7 +332,6 @@ void AudioOutputPrivate::_k_audioDeviceFailed()
             }
         }
     }
-#endif //QT_NO_PHONON_SETTINGSGROUP
     // if we get here there is no working output device. Tell the backend.
     const AudioOutputDevice none;
     callSetOutputDevice(this, none);
@@ -332,12 +341,10 @@ void AudioOutputPrivate::_k_audioDeviceFailed()
 void AudioOutputPrivate::_k_deviceListChanged()
 {
     pDebug() << Q_FUNC_INFO;
-#ifndef QT_NO_PHONON_SETTINGSGROUP
     // let's see if there's a usable device higher in the preference list
-    const QList<int> deviceList = GlobalConfig().audioOutputDeviceListFor(category, GlobalConfig::AdvancedDevicesFromSettings);
+    QList<int> deviceList = GlobalConfig().audioOutputDeviceListFor(category, GlobalConfig::AdvancedDevicesFromSettings);
     DeviceChangeType changeType = HigherPreferenceChange;
-    for (int i = 0; i < deviceList.count(); ++i) {
-        const int devIndex = deviceList.at(i);
+    foreach (int devIndex, deviceList) {
         const AudioOutputDevice &info = AudioOutputDevice::fromIndex(devIndex);
         if (!info.property("available").toBool()) {
             if (device.index() == devIndex) {
@@ -358,7 +365,6 @@ void AudioOutputPrivate::_k_deviceListChanged()
             break; // found one with higher preference that works
         }
     }
-#endif //QT_NO_PHONON_SETTINGSGROUP
 }
 
 static struct
@@ -410,6 +416,7 @@ void AudioOutputPrivate::handleAutomaticDeviceChange(const AudioOutputDevice &de
 
 AudioOutputPrivate::~AudioOutputPrivate()
 {
+    PulseSupport::getInstance()->clearStreamCache(streamUuid);
 #ifndef QT_NO_DBUS
     if (adaptor) {
         emit adaptor->outputDestroyed();
diff --git a/src/3rdparty/phonon/phonon/audiooutput_p.h b/src/3rdparty/phonon/phonon/audiooutput_p.h
index fdee299..0a90c3d 100644
--- a/src/3rdparty/phonon/phonon/audiooutput_p.h
+++ b/src/3rdparty/phonon/phonon/audiooutput_p.h
@@ -46,6 +46,7 @@ class AudioOutputPrivate : public AbstractAudioOutputPrivate
             return 0;
         }
         void init(Phonon::Category c);
+        QString getStreamUuid();
 
 
     protected:
@@ -79,6 +80,7 @@ class AudioOutputPrivate : public AbstractAudioOutputPrivate
         QString name;
         Phonon::AudioOutputDevice device;
         qreal volume;
+        QString streamUuid;
 #ifndef QT_NO_DBUS
         Phonon::AudioOutputAdaptor *adaptor;
 #endif
diff --git a/src/3rdparty/phonon/phonon/audiooutputinterface.h b/src/3rdparty/phonon/phonon/audiooutputinterface.h
index 80ba11c..cce12b2 100644
--- a/src/3rdparty/phonon/phonon/audiooutputinterface.h
+++ b/src/3rdparty/phonon/phonon/audiooutputinterface.h
@@ -64,7 +64,7 @@ class AudioOutputInterface40
          * A value of 0.0 means muted, 1.0 means unchanged, 2.0 means double voltage (i.e. all
          * samples are multiplied by 2).
          *
-         * Everytime the volume in the backend changes it should emit volumeChanged(qreal), also
+         * Every time the volume in the backend changes it should emit volumeChanged(qreal), also
          * inside this function.
          */
         virtual void setVolume(qreal) = 0;
diff --git a/src/3rdparty/phonon/phonon/backend/Mainpage.dox b/src/3rdparty/phonon/phonon/backend/Mainpage.dox
new file mode 100644
index 0000000..db4cac1
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/backend/Mainpage.dox
@@ -0,0 +1,109 @@
+/** \mainpage Phonon Backend Interface
+
+
+\section phonon_backend_development Backend Development
+If you want to write a new backend for %Phonon this is for you:
+\li \ref phonon_backend_development_page "Phonon Backend Development"
+\li \ref Backend
+
+\authors
+Matthias Kretz \<kretz@kde.org\>
+
+\maintainers
+Matthias Kretz \<kretz@kde.org\>
+
+\licenses
+\lgpl
+
+
+
+
+
+
+
+
+\page phonon_tut1 Phonon Tutorial Part 1: a simple audio player
+
+<p><b>
+\ref index "Overview" |
+Application Example |
+\ref phonon_backend_development_page "Backend Development"
+</b></p>
+
+\includelineno tutorial2.cpp
+
+
+
+
+
+
+
+
+\page phonon_backend_development_page Phonon Backend Development
+
+<p><b>
+\ref index "Overview" |
+\ref phonon_tut1 "Application Example" |
+Backend Development
+</b></p>
+
+The backend is the most important part in %Phonon to provide functionality. This
+document will get you started how backends work, how to start development of a
+new backend and how to understand existing backend code.
+
+\section phonon_backend_introduction Introduction
+
+The first step is to understand how the %Phonon frontend calls the backend: In
+the frontend objects all backend objects are "only" QObjects. But QObject has
+powerful introspection capabilities that %Phonon uses to call methods in the
+backend. If you're interested look at \ref QMetaObject::invokeMethod. In order
+to make sure that a backend is fully operational (there are no abstract classes
+that tell the backend developer what method signatures are wrong or what
+methods are missing) there are two test programs compiled with kdelibs (if
+KDE4_BUILD_TESTS is set in cmake) that inspects the backend.
+
+In short that requires the backend classes to inherit from QObject and to make
+all methods that are to be called from the frontend slots or prefixed with
+Q_INVOKABLE (the latter doesn't work reliable with Qt 4.1.3 at least, so you
+should simply make those methods slots).
+
+\section phonon_backend_classes The Backend Classes
+
+The central class that needs to be implemented is the backend factory class,
+throughout this documentation simply called Backend:
+
+\li \ref phonon_Backend "Backend"
+
+\subsection phonon_mediaproducingclasses The classes producing media data (sources)
+
+\li \ref Phonon::MediaObjectInterface "common methods/signals for media producing classes"
+\li \ref phonon_MediaObject "MediaObject"
+
+\subsection phonon_pathclass The path class
+
+\li \ref phonon_Path "Path"
+
+\subsection phonon_outputclasses The output classes
+\li \ref phonon_AudioDataOutput "AudioDataOutput"
+\li \ref phonon_AudioOutput "AudioOutput"
+\li \ref phonon_VideoDataOutput "VideoDataOutput"
+\li \ref phonon_VideoWidget "VideoWidget"
+
+\subsection phonon_EffectClasses The effect classes
+
+\li \ref phonon_Effect "Effect"
+\li \ref phonon_Visualization "Visualization"
+\li \ref phonon_VolumeFaderEffect "VolumeFaderEffect"
+
+*/
+// DOXYGEN_REFERENCES = phonon
+// DOXYGEN_SET_EXPAND_AS_DEFINED = PHONON_OBJECT PHONON_HEIR PHONON_INTERFACE_GETTER
+// DOXYGEN_SET_HIDE_SCOPE_NAMES = YES
+// DOXYGEN_SET_HIDE_FRIEND_COMPOUNDS = YES
+// DOXYGEN_SET_PROJECT_NAME = Backend
+// DOXYGEN_SET_EXTRACT_ALL = NO
+// DOXYGEN_SET_HIDE_UNDOC_MEMBERS = YES
+// DOXYGEN_SET_SOURCE_BROWSER = NO
+// DOXYGEN_SET_INPUT = @topdir@/phonon/phonon
+// DOXYGEN_SET_FILE_PATTERNS = *interface.h */phonon/backend/Mainpage.dox */backend.dox
+// vim: tw=100 ts=4 sw=4 expandtab filetype=doxygen
diff --git a/src/3rdparty/phonon/phonon/backendcapabilities.cpp b/src/3rdparty/phonon/phonon/backendcapabilities.cpp
index fbeb020..654e87c 100644
--- a/src/3rdparty/phonon/phonon/backendcapabilities.cpp
+++ b/src/3rdparty/phonon/phonon/backendcapabilities.cpp
@@ -26,7 +26,7 @@
 #include "phonondefs_p.h"
 #include "backendinterface.h"
 #include "factory_p.h"
-#include "globalconfig_p.h"
+#include "globalconfig.h"
 #include "globalstatic_p.h"
 #include "objectdescription.h"
 
@@ -75,12 +75,10 @@ bool BackendCapabilities::isMimeTypeAvailable(const QString &mimeType)
 QList<AudioOutputDevice> BackendCapabilities::availableAudioOutputDevices()
 {
     QList<AudioOutputDevice> ret;
-#ifndef QT_NO_PHONON_SETTINGSGROUP
     const QList<int> deviceIndexes = GlobalConfig().audioOutputDeviceListFor(Phonon::NoCategory);
-    for (int i = 0; i < deviceIndexes.count(); ++i) {
-        ret.append(AudioOutputDevice::fromIndex(deviceIndexes.at(i)));
+    foreach (int i, deviceIndexes) {
+        ret.append(AudioOutputDevice::fromIndex(i));
     }
-#endif //QT_NO_PHONON_SETTINGSGROUP
     return ret;
 }
 
@@ -90,8 +88,8 @@ QList<AudioCaptureDevice> BackendCapabilities::availableAudioCaptureDevices()
 {
     QList<AudioCaptureDevice> ret;
     const QList<int> deviceIndexes = GlobalConfig().audioCaptureDeviceListFor(Phonon::NoCategory);
-    for (int i = 0; i < deviceIndexes.count(); ++i) {
-        ret.append(AudioCaptureDevice::fromIndex(deviceIndexes.at(i)));
+    foreach (int i, deviceIndexes) {
+        ret.append(AudioCaptureDevice::fromIndex(i));
     }
     return ret;
 }
@@ -103,9 +101,9 @@ QList<EffectDescription> BackendCapabilities::availableAudioEffects()
     BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend());
     QList<EffectDescription> ret;
     if (backendIface) {
-        const QList<int> deviceIndexes = backendIface->objectDescriptionIndexes(Phonon::EffectType);
-        for (int i = 0; i < deviceIndexes.count(); ++i) {
-            ret.append(EffectDescription::fromIndex(deviceIndexes.at(i)));
+        QList<int> deviceIndexes = backendIface->objectDescriptionIndexes(Phonon::EffectType);
+        foreach (int i, deviceIndexes) {
+            ret.append(EffectDescription::fromIndex(i));
         }
     }
     return ret;
diff --git a/src/3rdparty/phonon/phonon/backendcapabilities.h b/src/3rdparty/phonon/phonon/backendcapabilities.h
index 643c8ef..bbe6937 100644
--- a/src/3rdparty/phonon/phonon/backendcapabilities.h
+++ b/src/3rdparty/phonon/phonon/backendcapabilities.h
@@ -15,7 +15,7 @@
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public
+    You should have received a copy of the GNU Lesser General Public 
     License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 
 */
@@ -88,18 +88,19 @@ namespace BackendCapabilities
     };
 
     /**
-     * Use this function to get a QObject pointer to connect to one of the Notifier signals.
+     * Use this function to get a QObject pointer to connect to the capabilitiesChanged signal.
      *
      * \return a pointer to a QObject.
      *
-     * To connect to the signal do the following:
+     * The capabilitiesChanged signal is emitted if the capabilities have changed. This can
+     * happen if the user has requested a backend change.
+     *
+     * To connect to this signal do the following:
      * \code
      * QObject::connect(BackendCapabilities::notifier(), SIGNAL(capabilitiesChanged()), ...
      * \endcode
      *
      * \see Notifier::capabilitiesChanged()
-     * \see Notifier::availableAudioOutputDevicesChanged()
-     * \see Notifier::availableAudioCaptureDevicesChanged()
      */
     PHONON_EXPORT Notifier *notifier();
 
diff --git a/src/3rdparty/phonon/phonon/effect.cpp b/src/3rdparty/phonon/phonon/effect.cpp
index dfcb290..f0ac454 100644
--- a/src/3rdparty/phonon/phonon/effect.cpp
+++ b/src/3rdparty/phonon/phonon/effect.cpp
@@ -107,8 +107,7 @@ bool EffectPrivate::aboutToDeleteBackendObject()
 {
     if (m_backendObject) {
         const QList<EffectParameter> parameters = pINTERFACE_CALL(parameters());
-        for (int i = 0; i < parameters.count(); ++i) {
-            const EffectParameter &p = parameters.at(i);
+        foreach (const EffectParameter &p, parameters) {
             parameterValues[p] = pINTERFACE_CALL(parameterValue(p));
         }
     }
@@ -121,8 +120,7 @@ void EffectPrivate::setupBackendObject()
 
     // set up attributes
     const QList<EffectParameter> parameters = pINTERFACE_CALL(parameters());
-    for (int i = 0; i < parameters.count(); ++i) {
-        const EffectParameter &p = parameters.at(i);
+    foreach (const EffectParameter &p, parameters) {
         pINTERFACE_CALL(setParameterValue(p, parameterValues[p]));
     }
 }
diff --git a/src/3rdparty/phonon/phonon/effectwidget.cpp b/src/3rdparty/phonon/phonon/effectwidget.cpp
index 2334d7f..6738382 100644
--- a/src/3rdparty/phonon/phonon/effectwidget.cpp
+++ b/src/3rdparty/phonon/phonon/effectwidget.cpp
@@ -97,9 +97,7 @@ void EffectWidgetPrivate::autogenerateUi()
     Q_Q(EffectWidget);
     QVBoxLayout *mainLayout = new QVBoxLayout(q);
     mainLayout->setMargin(0);
-    const QList<Phonon::EffectParameter> parameters = effect->parameters();
-    for (int i = 0; i < parameters.count(); ++i) {
-        const EffectParameter &para = parameters.at(i);
+    foreach (const EffectParameter &para, effect->parameters()) {
         QVariant value = effect->parameterValue(para);
         QHBoxLayout *pLayout = new QHBoxLayout;
         mainLayout->addLayout(pLayout);
@@ -119,14 +117,13 @@ void EffectWidgetPrivate::autogenerateUi()
                 control = cb;
                 if (value.type() == QVariant::Int) {
                     //value just defines the item index
-                    for (int i = 0; i < para.possibleValues().count(); ++i) {
-                        cb->addItem(para.possibleValues().at(i).toString());
+                    foreach (const QVariant &item, para.possibleValues()) {
+                        cb->addItem(item.toString());
                     }
                     cb->setCurrentIndex(value.toInt());
                     QObject::connect(cb, SIGNAL(currentIndexChanged(int)), q, SLOT(_k_setIntParameter(int)));
                 } else {
-                    for (int i = 0; i < para.possibleValues().count(); ++i) {
-                        const QVariant &item = para.possibleValues().at(i);
+                    foreach (const QVariant &item, para.possibleValues()) {
                         cb->addItem(item.toString());
                         if (item == value) {
                             cb->setCurrentIndex(cb->count() - 1);
@@ -158,20 +155,18 @@ void EffectWidgetPrivate::autogenerateUi()
                 QObject::connect(sb, SIGNAL(valueChanged(int)), q, SLOT(_k_setIntParameter(int)));
             }
             break;
-        case QMetaType::Float:
         case QVariant::Double:
             {
-                const qreal minValue = para.minimumValue().canConvert(QVariant::Double) ?
-                    para.minimumValue().toReal() : DEFAULT_MIN;
-                const qreal maxValue = para.maximumValue().canConvert(QVariant::Double) ?
-                    para.maximumValue().toReal() : DEFAULT_MAX;
+                const double minValue = (para.minimumValue().type() == QVariant::Double ?
+                    para.minimumValue().toDouble() : DEFAULT_MIN);
+                const double maxValue = (para.maximumValue().type() == QVariant::Double ?
+                    para.maximumValue().toDouble() : DEFAULT_MAX);
 
                 if (minValue == -1. && maxValue == 1.) {
                     //Special case values between -1 and 1.0 to use a slider for improved usability
                     QSlider *slider = new QSlider(Qt::Horizontal, q);
-                    control = slider;
                     slider->setRange(-SLIDER_RANGE, +SLIDER_RANGE);
-                    slider->setValue(int(SLIDER_RANGE * value.toReal()));
+                    slider->setValue(int(SLIDER_RANGE * value.toDouble()));
                     slider->setTickPosition(QSlider::TicksBelow);
                     slider->setTickInterval(TICKINTERVAL);
                     QObject::connect(slider, SIGNAL(valueChanged(int)), q, SLOT(_k_setSliderParameter(int)));
@@ -193,10 +188,10 @@ void EffectWidgetPrivate::autogenerateUi()
             break;
         }
 
-        if (control) {
 #ifndef QT_NO_TOOLTIP
         control->setToolTip(para.description());
 #endif
+        if (control) {
 #ifndef QT_NO_SHORTCUT
             label->setBuddy(control);
 #endif
diff --git a/src/3rdparty/phonon/phonon/factory.cpp b/src/3rdparty/phonon/phonon/factory.cpp
index 9967c97..b26c4f3 100644
--- a/src/3rdparty/phonon/phonon/factory.cpp
+++ b/src/3rdparty/phonon/phonon/factory.cpp
@@ -111,7 +111,6 @@ void Factory::setBackend(QObject *b)
 
 bool FactoryPrivate::createBackend()
 {
-#ifndef QT_NO_LIBRARY
     Q_ASSERT(m_backendObject == 0);
 #ifndef QT_NO_PHONON_PLATFORMPLUGIN
     PlatformPlugin *f = globalFactory->platformPlugin();
@@ -125,39 +124,15 @@ bool FactoryPrivate::createBackend()
         // could not load a backend through the platform plugin. Falling back to the default
         // (finding the first loadable backend).
         const QLatin1String suffix("/phonon_backend/");
-        const QStringList paths = QCoreApplication::libraryPaths();
-        for (int i = 0; i < paths.count(); ++i) {
-            const QString libPath = paths.at(i) + suffix;
+        foreach (QString libPath, QCoreApplication::libraryPaths()) {
+            libPath += suffix;
             const QDir dir(libPath);
             if (!dir.exists()) {
                 pDebug() << Q_FUNC_INFO << dir.absolutePath() << "does not exist";
                 continue;
             }
-
-			QStringList plugins(dir.entryList(QDir::Files));
-
-#ifdef Q_OS_SYMBIAN
-            /* On Symbian OS we might have two plugins, one which uses Symbian
-             * MMF framework("phonon_mmf"), and one which uses Real Networks's
-             * Helix("hxphonon"). We prefer the latter because it's more
-             * sophisticated, so we make sure the Helix backend is attempted
-             * to be loaded first, and the MMF backend is used for backup. */
-            {
-
-                const int hxphonon = plugins.indexOf(QLatin1String("hxphonon"));
-                if (hxphonon != -1)
-                    plugins.move(hxphonon, 0);
-
-                // Code for debugging the MMF backend.
-                if(hxphonon != -1) {
-                    qDebug() << "Found hxphonon backend and removed it from the lookup list.";
-                    plugins.removeAll(QLatin1String("hxphonon"));
-                }
-            }
-#endif
-
-            for (int i = 0; i < plugins.count(); ++i) {
-                QPluginLoader pluginLoader(libPath + plugins.at(i));
+            foreach (const QString &pluginName, dir.entryList(QDir::Files)) {
+                QPluginLoader pluginLoader(libPath + pluginName);
                 if (!pluginLoader.load()) {
                     pDebug() << Q_FUNC_INFO << "  load failed:"
                              << pluginLoader.errorString();
@@ -187,20 +162,14 @@ bool FactoryPrivate::createBackend()
             SLOT(objectDescriptionChanged(ObjectDescriptionType)));
 
     return true;
-#else //QT_NO_LIBRARY
-    pWarning() << Q_FUNC_INFO << "Trying to use Phonon with QT_NO_LIBRARY defined. "
-                                 "That is currently not supported";
-    return false;
-#endif
 }
 
 FactoryPrivate::FactoryPrivate()
-    :
 #ifndef QT_NO_PHONON_PLATFORMPLUGIN
-    m_platformPlugin(0),
-    m_noPlatformPlugin(false),
+    : m_platformPlugin(0),
+    m_noPlatformPlugin(false)
 #endif //QT_NO_PHONON_PLATFORMPLUGIN
-    m_backendObject(0)
+    , m_backendObject(0)
 {
     // Add the post routine to make sure that all other global statics (especially the ones from Qt)
     // are still available. If the FactoryPrivate dtor is called too late many bad things can happen
@@ -214,8 +183,14 @@ FactoryPrivate::FactoryPrivate()
 
 FactoryPrivate::~FactoryPrivate()
 {
-    for (int i = 0; i < mediaNodePrivateList.count(); ++i) {
-        mediaNodePrivateList.at(i)->deleteBackendObject();
+    foreach (QObject *o, objects) {
+        MediaObject *m = qobject_cast<MediaObject *>(o);
+        if (m) {
+            m->stop();
+        }
+    }
+    foreach (MediaNodePrivate *bp, mediaNodePrivateList) {
+        bp->deleteBackendObject();
     }
     if (objects.size() > 0) {
         pError() << "The backend objects are not deleted as was requested.";
@@ -283,8 +258,8 @@ void Factory::deregisterFrontendObject(MediaNodePrivate *bp)
 void FactoryPrivate::phononBackendChanged()
 {
     if (m_backendObject) {
-        for (int i = 0; i < mediaNodePrivateList.count(); ++i) {
-            mediaNodePrivateList.at(i)->deleteBackendObject();
+        foreach (MediaNodePrivate *bp, mediaNodePrivateList) {
+            bp->deleteBackendObject();
         }
         if (objects.size() > 0) {
             pDebug() << "WARNING: we were asked to change the backend but the application did\n"
@@ -293,8 +268,8 @@ void FactoryPrivate::phononBackendChanged()
                 "backendswitching possible.";
             // in case there were objects deleted give 'em a chance to recreate
             // them now
-            for (int i = 0; i < mediaNodePrivateList.count(); ++i) {
-                mediaNodePrivateList.at(i)->createBackendObject();
+            foreach (MediaNodePrivate *bp, mediaNodePrivateList) {
+                bp->createBackendObject();
             }
             return;
         }
@@ -302,8 +277,8 @@ void FactoryPrivate::phononBackendChanged()
         m_backendObject = 0;
     }
     createBackend();
-    for (int i = 0; i < mediaNodePrivateList.count(); ++i) {
-        mediaNodePrivateList.at(i)->createBackendObject();
+    foreach (MediaNodePrivate *bp, mediaNodePrivateList) {
+        bp->createBackendObject();
     }
     emit backendChanged();
 }
@@ -350,6 +325,7 @@ FACTORY_IMPL(AudioOutput)
 #ifndef QT_NO_PHONON_VIDEO
 FACTORY_IMPL(VideoWidget)
 #endif //QT_NO_PHONON_VIDEO
+FACTORY_IMPL(AudioDataOutput)
 
 #undef FACTORY_IMPL
 
@@ -387,17 +363,15 @@ PlatformPlugin *FactoryPrivate::platformPlugin()
              QStringList())
             );
     dir.setFilter(QDir::Files);
-    const QStringList libPaths = QCoreApplication::libraryPaths();
     forever {
-        for (int i = 0; i < libPaths.count(); ++i) {
-            const QString libPath = libPaths.at(i) + suffix;
+        foreach (QString libPath, QCoreApplication::libraryPaths()) {
+            libPath += suffix;
             dir.setPath(libPath);
             if (!dir.exists()) {
                 continue;
             }
-            const QStringList files = dir.entryList(QDir::Files);
-            for (int i = 0; i < files.count(); ++i) {
-                QPluginLoader pluginLoader(libPath + files.at(i));
+            foreach (const QString &pluginName, dir.entryList()) {
+                QPluginLoader pluginLoader(libPath + pluginName);
                 if (!pluginLoader.load()) {
                     pDebug() << Q_FUNC_INFO << "  platform plugin load failed:"
                         << pluginLoader.errorString();
@@ -449,7 +423,6 @@ QObject *Factory::backend(bool createWhenNull)
     return globalFactory->m_backendObject;
 }
 
-#ifndef QT_NO_PROPERTIES
 #define GET_STRING_PROPERTY(name) \
 QString Factory::name() \
 { \
@@ -465,11 +438,11 @@ GET_STRING_PROPERTY(backendComment)
 GET_STRING_PROPERTY(backendVersion)
 GET_STRING_PROPERTY(backendIcon)
 GET_STRING_PROPERTY(backendWebsite)
-#endif //QT_NO_PROPERTIES
+
 QObject *Factory::registerQObject(QObject *o)
 {
     if (o) {
-        QObject::connect(o, SIGNAL(destroyed(QObject*)), globalFactory, SLOT(objectDestroyed(QObject*)), Qt::DirectConnection);
+        QObject::connect(o, SIGNAL(destroyed(QObject *)), globalFactory, SLOT(objectDestroyed(QObject *)), Qt::DirectConnection);
         globalFactory->objects.append(o);
     }
     return o;
diff --git a/src/3rdparty/phonon/phonon/factory_p.h b/src/3rdparty/phonon/phonon/factory_p.h
index dee2b56..41b8c5b 100644
--- a/src/3rdparty/phonon/phonon/factory_p.h
+++ b/src/3rdparty/phonon/phonon/factory_p.h
@@ -122,6 +122,13 @@ namespace Factory
 #endif //QT_NO_PHONON_VIDEO
 
     /**
+    * Create a new backend object for a AudioDataOutput.
+    *
+    * \return a pointer to the AudioDataOutput the backend provides.
+    */
+    PHONON_EXPORT QObject *createAudioDataOutput(QObject *parent = 0);
+
+    /**
      * \return a pointer to the backend interface.
      */
     PHONON_EXPORT QObject *backend(bool createWhenNull = true);
diff --git a/src/3rdparty/phonon/phonon/globalconfig.cpp b/src/3rdparty/phonon/phonon/globalconfig.cpp
index 3b77a18..44bf49a 100644
--- a/src/3rdparty/phonon/phonon/globalconfig.cpp
+++ b/src/3rdparty/phonon/phonon/globalconfig.cpp
@@ -20,6 +20,7 @@
 
 */
 
+#include "globalconfig.h"
 #include "globalconfig_p.h"
 
 #include "factory_p.h"
@@ -29,6 +30,7 @@
 #include "backendinterface.h"
 #include "qsettingsgroup_p.h"
 #include "phononnamespace_p.h"
+#include "pulsesupport.h"
 
 #include <QtCore/QList>
 #include <QtCore/QVariant>
@@ -38,15 +40,18 @@ QT_BEGIN_NAMESPACE
 namespace Phonon
 {
 
+GlobalConfigPrivate::GlobalConfigPrivate() : config(QLatin1String("kde.org"), QLatin1String("libphonon"))
+{
+}
+
 GlobalConfig::GlobalConfig()
-#ifndef QT_NO_SETTINGS
-    : m_config(QLatin1String("kde.org"), QLatin1String("libphonon"))
-#endif //QT_NO_SETTINGS
+    : k_ptr(new GlobalConfigPrivate)
 {
 }
 
 GlobalConfig::~GlobalConfig()
 {
+    delete k_ptr;
 }
 
 enum WhatToFilter {
@@ -85,9 +90,12 @@ static void filter(ObjectDescriptionType type, BackendInterface *backendIface, Q
     }
 }
 
-#ifndef QT_NO_PHONON_SETTINGSGROUP
-static QList<int> listSortedByConfig(const QSettingsGroup &backendConfig, Phonon::Category category, QList<int> &defaultList)
+static QList<int> sortDevicesByCategoryPriority(const GlobalConfig *config, const QSettingsGroup *backendConfig, ObjectDescriptionType type, Phonon::Category category, QList<int> &defaultList)
 {
+    Q_ASSERT(config);
+    Q_ASSERT(backendConfig);
+    Q_ASSERT(type == AudioOutputDeviceType || type == AudioCaptureDeviceType);
+
     if (defaultList.size() <= 1) {
         // nothing to sort
         return defaultList;
@@ -104,20 +112,26 @@ static QList<int> listSortedByConfig(const QSettingsGroup &backendConfig, Phonon
         }
     }
 
-    QString categoryKey = QLatin1String("Category_") + QString::number(static_cast<int>(category));
-    if (!backendConfig.hasKey(categoryKey)) {
-        // no list in config for the given category
-        categoryKey = QLatin1String("Category_") + QString::number(static_cast<int>(Phonon::NoCategory));
-        if (!backendConfig.hasKey(categoryKey)) {
-            // no list in config for NoCategory
-            return defaultList;
+    QList<int> deviceList;
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive()) {
+        deviceList = pulse->objectIndexesByCategory(type, category);
+    } else {
+        QString categoryKey = QLatin1String("Category_") + QString::number(static_cast<int>(category));
+        if (!backendConfig->hasKey(categoryKey)) {
+            // no list in config for the given category
+            categoryKey = QLatin1String("Category_") + QString::number(static_cast<int>(Phonon::NoCategory));
+            if (!backendConfig->hasKey(categoryKey)) {
+                // no list in config for NoCategory
+                return defaultList;
+            }
         }
-    }
 
-    //Now the list from m_config
-    QList<int> deviceList = backendConfig.value(categoryKey, QList<int>());
+        //Now the list from d->config
+        deviceList = backendConfig->value(categoryKey, QList<int>());
+    }
 
-    //if there are devices in m_config that the backend doesn't report, remove them from the list
+    //if there are devices in d->config that the backend doesn't report, remove them from the list
     QMutableListIterator<int> i(deviceList);
     while (i.hasNext()) {
         if (0 == defaultList.removeAll(i.next())) {
@@ -125,49 +139,176 @@ static QList<int> listSortedByConfig(const QSettingsGroup &backendConfig, Phonon
         }
     }
 
-    //if the backend reports more devices that are not in m_config append them to the list
+    //if the backend reports more devices that are not in d->config append them to the list
     deviceList += defaultList;
 
     return deviceList;
 }
-#endif //QT_NO_PHONON_SETTINGSGROUP
 
-#ifndef QT_NO_PHONON_SETTINGSGROUP
-QList<int> GlobalConfig::audioOutputDeviceListFor(Phonon::Category category, int override) const
+bool GlobalConfig::hideAdvancedDevices() const
 {
+    K_D(const GlobalConfig);
     //The devices need to be stored independently for every backend
-    const QSettingsGroup backendConfig(&m_config, QLatin1String("AudioOutputDevice")); // + Factory::identifier());
-    const QSettingsGroup generalGroup(&m_config, QLatin1String("General"));
-    const bool hideAdvancedDevices = ((override & AdvancedDevicesFromSettings)
-            ? generalGroup.value(QLatin1String("HideAdvancedDevices"), true)
+    const QSettingsGroup generalGroup(&d->config, QLatin1String("General"));
+    return generalGroup.value(QLatin1String("HideAdvancedDevices"), true);
+}
+
+void GlobalConfig::setHideAdvancedDevices(bool hide)
+{
+    K_D(GlobalConfig);
+    QSettingsGroup generalGroup(&d->config, QLatin1String("General"));
+    generalGroup.setValue(QLatin1String("HideAdvancedDevices"), hide);
+}
+
+static bool isHiddenAudioOutputDevice(const GlobalConfig *config, int i)
+{
+    Q_ASSERT(config);
+
+    if (!config->hideAdvancedDevices())
+        return false;
+
+    AudioOutputDevice ad = AudioOutputDevice::fromIndex(i);
+    const QVariant var = ad.property("isAdvanced");
+    return (var.isValid() && var.toBool());
+}
+
+#ifndef QT_NO_PHONON_AUDIOCAPTURE
+static bool isHiddenAudioCaptureDevice(const GlobalConfig *config, int i)
+{
+    Q_ASSERT(config);
+
+    if (!config->hideAdvancedDevices())
+        return false;
+
+    AudioCaptureDevice ad = AudioCaptureDevice::fromIndex(i);
+    const QVariant var = ad.property("isAdvanced");
+    return (var.isValid() && var.toBool());
+}
+#endif
+
+static QList<int> reindexList(const GlobalConfig *config, Phonon::Category category, QList<int>newOrder, bool output)
+{
+    Q_ASSERT(config);
+#ifdef QT_NO_PHONON_AUDIOCAPTURE
+    Q_ASSERT(output);
+#endif
+
+    /*QString sb;
+    sb = QString("(Size %1)").arg(currentList.size());
+    foreach (int i, currentList)
+    sb += QString("%1, ").arg(i);
+    fprintf(stderr, "=== Reindex Current: %s\n", sb.toUtf8().constData());
+    sb = QString("(Size %1)").arg(newOrder.size());
+    foreach (int i, newOrder)
+    sb += QString("%1, ").arg(i);
+    fprintf(stderr, "=== Reindex Before : %s\n", sb.toUtf8().constData());*/
+
+    QList<int> currentList;
+    if (output)
+        currentList = config->audioOutputDeviceListFor(category, GlobalConfig::ShowUnavailableDevices|GlobalConfig::ShowAdvancedDevices);
+#ifndef QT_NO_PHONON_AUDIOCAPTURE
+    else
+        currentList = config->audioCaptureDeviceListFor(category, GlobalConfig::ShowUnavailableDevices|GlobalConfig::ShowAdvancedDevices);
+#endif
+
+    QList<int> newList;
+
+    foreach (int i, newOrder) {
+        int found = currentList.indexOf(i);
+        if (found < 0) {
+            // It's not in the list, so something is odd (e.g. client error). Ignore it.
+            continue;
+        }
+
+        // Iterate through the list from this point onward. If there are hidden devices
+        // immediately following, take them too.
+        newList.append(currentList.takeAt(found));
+        while (found < currentList.size()) {
+            bool hidden = true;
+            if (output)
+                hidden = isHiddenAudioOutputDevice(config, currentList.at(found));
+#ifndef QT_NO_PHONON_AUDIOCAPTURE
+            else
+                hidden = isHiddenAudioCaptureDevice(config, currentList.at(found));
+#endif
+
+            if (!hidden)
+                break;
+            newList.append(currentList.takeAt(found));
+        }
+    }
+
+    // If there are any devices left in.. just tack them on the end.
+    if (currentList.size() > 0)
+        newList += currentList;
+
+    /*sb = QString("(Size %1)").arg(newList.size());
+    foreach (int i, newList)
+    sb += QString("%1, ").arg(i);
+    fprintf(stderr, "=== Reindex After  : %s\n", sb.toUtf8().constData());*/
+    return newList;
+}
+
+
+void GlobalConfig::setAudioOutputDeviceListFor(Phonon::Category category, QList<int> order)
+{
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive()) {
+        pulse->setOutputDevicePriorityForCategory(category, order);
+        return;
+    }
+
+    K_D(GlobalConfig);
+    QSettingsGroup backendConfig(&d->config, QLatin1String("AudioOutputDevice")); // + Factory::identifier());
+
+    order = reindexList(this, category, order, true);
+
+    const QList<int> noCategoryOrder = audioOutputDeviceListFor(Phonon::NoCategory, ShowUnavailableDevices|ShowAdvancedDevices);
+    if (category != Phonon::NoCategory && order == noCategoryOrder) {
+        backendConfig.removeEntry(QLatin1String("Category_") + QString::number(category));
+    } else {
+        backendConfig.setValue(QLatin1String("Category_") + QString::number(category), order);
+    }
+}
+
+QList<int> GlobalConfig::audioOutputDeviceListFor(Phonon::Category category, int override) const
+{
+    K_D(const GlobalConfig);
+
+    const bool hide = ((override & AdvancedDevicesFromSettings)
+            ? hideAdvancedDevices()
             : static_cast<bool>(override & HideAdvancedDevices));
 
     QList<int> defaultList;
+    BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend());
+
 #ifndef QT_NO_PHONON_PLATFORMPLUGIN
-    if (PlatformPlugin *platformPlugin = Factory::platformPlugin()) {
-        // the platform plugin lists the audio devices for the platform
-        // this list already is in default order (as defined by the platform plugin)
-        defaultList = platformPlugin->objectDescriptionIndexes(Phonon::AudioOutputDeviceType);
-        if (hideAdvancedDevices) {
-            QMutableListIterator<int> it(defaultList);
-            while (it.hasNext()) {
-                AudioOutputDevice objDesc = AudioOutputDevice::fromIndex(it.next());
-                const QVariant var = objDesc.property("isAdvanced");
-                if (var.isValid() && var.toBool()) {
-                    it.remove();
+    if (!backendIface || !PulseSupport::getInstance()->isActive()) {
+        if (PlatformPlugin *platformPlugin = Factory::platformPlugin()) {
+            // the platform plugin lists the audio devices for the platform
+            // this list already is in default order (as defined by the platform plugin)
+            defaultList = platformPlugin->objectDescriptionIndexes(Phonon::AudioOutputDeviceType);
+            if (hide) {
+                QMutableListIterator<int> it(defaultList);
+                while (it.hasNext()) {
+                    AudioOutputDevice objDesc = AudioOutputDevice::fromIndex(it.next());
+                    const QVariant var = objDesc.property("isAdvanced");
+                    if (var.isValid() && var.toBool()) {
+                        it.remove();
+                    }
                 }
             }
         }
     }
 #endif //QT_NO_PHONON_PLATFORMPLUGIN
 
-    // lookup the available devices directly from the backend (mostly for virtual devices)
-    if (BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend())) {
+    // lookup the available devices directly from the backend
+    if (backendIface) {
         // this list already is in default order (as defined by the backend)
         QList<int> list = backendIface->objectDescriptionIndexes(Phonon::AudioOutputDeviceType);
-        if (hideAdvancedDevices || !defaultList.isEmpty() || (override & HideUnavailableDevices)) {
+        if (hide || !defaultList.isEmpty() || (override & HideUnavailableDevices)) {
             filter(AudioOutputDeviceType, backendIface, &list,
-                    (hideAdvancedDevices ? FilterAdvancedDevices : 0)
+                    (hide ? FilterAdvancedDevices : 0)
                     // the platform plugin already provided the hardware devices
                     | (defaultList.isEmpty() ? 0 : FilterHardwareDevices)
                     | ((override & HideUnavailableDevices) ? FilterUnavailableDevices : 0)
@@ -176,56 +317,78 @@ QList<int> GlobalConfig::audioOutputDeviceListFor(Phonon::Category category, int
         defaultList += list;
     }
 
-    return listSortedByConfig(backendConfig, category, defaultList);
+    const QSettingsGroup backendConfig(&d->config, QLatin1String("AudioOutputDevice")); // + Factory::identifier());
+    return sortDevicesByCategoryPriority(this, &backendConfig, AudioOutputDeviceType, category, defaultList);
 }
-#endif //QT_NO_PHONON_SETTINGSGROUP
+
 int GlobalConfig::audioOutputDeviceFor(Phonon::Category category, int override) const
 {
-#ifndef QT_NO_PHONON_SETTINGSGROUP
     QList<int> ret = audioOutputDeviceListFor(category, override);
-    if (!ret.isEmpty())
-        return ret.first();
-#endif //QT_NO_PHONON_SETTINGSGROUP
-    return -1;
+    if (ret.isEmpty())
+        return -1;
+    return ret.first();
 }
 
 #ifndef QT_NO_PHONON_AUDIOCAPTURE
+void GlobalConfig::setAudioCaptureDeviceListFor(Phonon::Category category, QList<int> order)
+{
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive()) {
+        pulse->setCaptureDevicePriorityForCategory(category, order);
+        return;
+    }
+
+    K_D(GlobalConfig);
+    QSettingsGroup backendConfig(&d->config, QLatin1String("AudioCaptureDevice")); // + Factory::identifier());
+
+    order = reindexList(this, category, order, false);
+
+    const QList<int> noCategoryOrder = audioCaptureDeviceListFor(Phonon::NoCategory, ShowUnavailableDevices|ShowAdvancedDevices);
+    if (category != Phonon::NoCategory && order == noCategoryOrder) {
+        backendConfig.removeEntry(QLatin1String("Category_") + QString::number(category));
+    } else {
+        backendConfig.setValue(QLatin1String("Category_") + QString::number(category), order);
+    }
+}
+
 QList<int> GlobalConfig::audioCaptureDeviceListFor(Phonon::Category category, int override) const
 {
-#ifndef QT_NO_PHONON_SETTINGSGROUP
-    //The devices need to be stored independently for every backend
-    const QSettingsGroup backendConfig(&m_config, QLatin1String("AudioCaptureDevice")); // + Factory::identifier());
-    const QSettingsGroup generalGroup(&m_config, QLatin1String("General"));
-    const bool hideAdvancedDevices = ((override & AdvancedDevicesFromSettings)
-            ? generalGroup.value(QLatin1String("HideAdvancedDevices"), true)
+    K_D(const GlobalConfig);
+
+    const bool hide = ((override & AdvancedDevicesFromSettings)
+            ? hideAdvancedDevices()
             : static_cast<bool>(override & HideAdvancedDevices));
 
     QList<int> defaultList;
+    BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend());
+
 #ifndef QT_NO_PHONON_PLATFORMPLUGIN
-    if (PlatformPlugin *platformPlugin = Factory::platformPlugin()) {
-        // the platform plugin lists the audio devices for the platform
-        // this list already is in default order (as defined by the platform plugin)
-        defaultList = platformPlugin->objectDescriptionIndexes(Phonon::AudioCaptureDeviceType);
-        if (hideAdvancedDevices) {
-            QMutableListIterator<int> it(defaultList);
-            while (it.hasNext()) {
-                AudioCaptureDevice objDesc = AudioCaptureDevice::fromIndex(it.next());
-                const QVariant var = objDesc.property("isAdvanced");
-                if (var.isValid() && var.toBool()) {
-                    it.remove();
+    if (!backendIface || !PulseSupport::getInstance()->isActive()) {
+        if (PlatformPlugin *platformPlugin = Factory::platformPlugin()) {
+            // the platform plugin lists the audio devices for the platform
+            // this list already is in default order (as defined by the platform plugin)
+            defaultList = platformPlugin->objectDescriptionIndexes(Phonon::AudioCaptureDeviceType);
+            if (hide) {
+                QMutableListIterator<int> it(defaultList);
+                while (it.hasNext()) {
+                    AudioCaptureDevice objDesc = AudioCaptureDevice::fromIndex(it.next());
+                    const QVariant var = objDesc.property("isAdvanced");
+                    if (var.isValid() && var.toBool()) {
+                        it.remove();
+                    }
                 }
             }
         }
     }
 #endif //QT_NO_PHONON_PLATFORMPLUGIN
 
-    // lookup the available devices directly from the backend (mostly for virtual devices)
-    if (BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend())) {
+    // lookup the available devices directly from the backend
+    if (backendIface) {
         // this list already is in default order (as defined by the backend)
         QList<int> list = backendIface->objectDescriptionIndexes(Phonon::AudioCaptureDeviceType);
-        if (hideAdvancedDevices || !defaultList.isEmpty() || (override & HideUnavailableDevices)) {
+        if (hide || !defaultList.isEmpty() || (override & HideUnavailableDevices)) {
             filter(AudioCaptureDeviceType, backendIface, &list,
-                    (hideAdvancedDevices ? FilterAdvancedDevices : 0)
+                    (hide ? FilterAdvancedDevices : 0)
                     // the platform plugin already provided the hardware devices
                     | (defaultList.isEmpty() ? 0 : FilterHardwareDevices)
                     | ((override & HideUnavailableDevices) ? FilterUnavailableDevices : 0)
@@ -234,10 +397,8 @@ QList<int> GlobalConfig::audioCaptureDeviceListFor(Phonon::Category category, in
         defaultList += list;
     }
 
-    return listSortedByConfig(backendConfig, category, defaultList);
-#else //QT_NO_SETTINGSGROUP
-    return QList<int>();
-#endif //QT_NO_SETTINGSGROUP
+    const QSettingsGroup backendConfig(&d->config, QLatin1String("AudioCaptureDevice")); // + Factory::identifier());
+    return sortDevicesByCategoryPriority(this, &backendConfig, AudioCaptureDeviceType, category, defaultList);
 }
 
 int GlobalConfig::audioCaptureDeviceFor(Phonon::Category category, int override) const
diff --git a/src/3rdparty/phonon/phonon/globalconfig.h b/src/3rdparty/phonon/phonon/globalconfig.h
new file mode 100644
index 0000000..5233c7b
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/globalconfig.h
@@ -0,0 +1,71 @@
+/*  This file is part of the KDE project
+Copyright (C) 2006-2008 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public 
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef PHONON_GLOBALCONFIG_H
+#define PHONON_GLOBALCONFIG_H
+
+#include "phonon_export.h"
+#include "phononnamespace.h"
+#include "phonondefs.h"
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+    class GlobalConfigPrivate;
+
+    class PHONON_EXPORT GlobalConfig
+    {
+        K_DECLARE_PRIVATE(GlobalConfig)
+    public:
+        GlobalConfig();
+        virtual ~GlobalConfig();
+
+        enum DevicesToHideFlag {
+            ShowUnavailableDevices = 0,
+            ShowAdvancedDevices = 0,
+            HideAdvancedDevices = 1,
+            AdvancedDevicesFromSettings = 2,
+            HideUnavailableDevices = 4
+        };
+        bool hideAdvancedDevices() const;
+        void setHideAdvancedDevices(bool hide = true);
+        void setAudioOutputDeviceListFor(Phonon::Category category, QList<int> order);
+        QList<int> audioOutputDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+        int audioOutputDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+
+#ifndef QT_NO_PHONON_AUDIOCAPTURE
+        void setAudioCaptureDeviceListFor(Phonon::Category category, QList<int> order);
+        QList<int> audioCaptureDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+        int audioCaptureDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+#endif //QT_NO_PHONON_AUDIOCAPTURE
+
+    protected:
+        GlobalConfigPrivate *const k_ptr;
+    };
+} // namespace Phonon
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // PHONON_GLOBALCONFIG_H
diff --git a/src/3rdparty/phonon/phonon/globalconfig_p.h b/src/3rdparty/phonon/phonon/globalconfig_p.h
index ec70b6f..090ca6b 100644
--- a/src/3rdparty/phonon/phonon/globalconfig_p.h
+++ b/src/3rdparty/phonon/phonon/globalconfig_p.h
@@ -26,40 +26,19 @@ Copyright (C) 2006-2008 Matthias Kretz <kretz@kde.org>
 #include <QtCore/QSettings>
 
 #include "phonon_export.h"
-#include "phononnamespace.h"
 
 QT_BEGIN_HEADER
 QT_BEGIN_NAMESPACE
 
 namespace Phonon
 {
-    class PHONON_EXPORT GlobalConfig
+    class GlobalConfigPrivate
     {
-    public:
-        GlobalConfig();
-        virtual ~GlobalConfig();
+        public:
+            GlobalConfigPrivate();
+            virtual ~GlobalConfigPrivate() {}
 
-        enum DevicesToHideFlag {
-            ShowUnavailableDevices = 0,
-            ShowAdvancedDevices = 0,
-            HideAdvancedDevices = 1,
-            AdvancedDevicesFromSettings = 2,
-            HideUnavailableDevices = 4
-        };
-#ifndef QT_NO_PHONON_SETTINGSGROUP
-        QList<int> audioOutputDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-#endif //QT_NO_PHONON_SETTINGSGROUP
-        int audioOutputDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-
-#ifndef QT_NO_PHONON_AUDIOCAPTURE
-        QList<int> audioCaptureDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-        int audioCaptureDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-#endif //QT_NO_PHONON_AUDIOCAPTURE
-
-    protected:
-#ifndef QT_NO_SETTINGS
-        QSettings m_config;
-#endif //QT_NO_SETTINGS
+            QSettings config;
     };
 } // namespace Phonon
 
diff --git a/src/3rdparty/phonon/phonon/medianode.cpp b/src/3rdparty/phonon/phonon/medianode.cpp
index bc1caed..f855766 100644
--- a/src/3rdparty/phonon/phonon/medianode.cpp
+++ b/src/3rdparty/phonon/phonon/medianode.cpp
@@ -67,8 +67,8 @@ bool MediaNode::isValid() const
 
     MediaNodePrivate::~MediaNodePrivate()
     {
-        for (int i = 0 ; i < handlers.count(); ++i) {
-            handlers.at(i)->phononObjectDestroyed(this);
+        foreach (MediaNodeDestructionHandler *handler, handlers) {
+            handler->phononObjectDestroyed(this);
         }
         Factory::deregisterFrontendObject(this);
         delete m_backendObject;
diff --git a/src/3rdparty/phonon/phonon/mediaobject.cpp b/src/3rdparty/phonon/phonon/mediaobject.cpp
index 41e8dc2..0801bd7 100644
--- a/src/3rdparty/phonon/phonon/mediaobject.cpp
+++ b/src/3rdparty/phonon/phonon/mediaobject.cpp
@@ -300,15 +300,15 @@ void MediaObject::enqueue(const MediaSource &source)
 
 void MediaObject::enqueue(const QList<MediaSource> &sources)
 {
-    for (int i = 0; i < sources.count(); ++i) {
-        enqueue(sources.at(i));
+    foreach (const MediaSource &m, sources) {
+        enqueue(m);
     }
 }
 
 void MediaObject::enqueue(const QList<QUrl> &urls)
 {
-    for (int i = 0; i < urls.count(); ++i) {
-        enqueue(urls.at(i));
+    foreach (const QUrl &url, urls) {
+        enqueue(url);
     }
 }
 
@@ -453,9 +453,9 @@ void MediaObjectPrivate::setupBackendObject()
     //pDebug() << Q_FUNC_INFO;
 
 #ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
-    QObject::connect(m_backendObject, SIGNAL(stateChanged(Phonon::State,Phonon::State)), q, SLOT(_k_stateChanged(Phonon::State,Phonon::State)));
+    QObject::connect(m_backendObject, SIGNAL(stateChanged(Phonon::State, Phonon::State)), q, SLOT(_k_stateChanged(Phonon::State, Phonon::State)));
 #else
-    QObject::connect(m_backendObject, SIGNAL(stateChanged(Phonon::State,Phonon::State)), q, SIGNAL(stateChanged(Phonon::State,Phonon::State)));
+    QObject::connect(m_backendObject, SIGNAL(stateChanged(Phonon::State, Phonon::State)), q, SIGNAL(stateChanged(Phonon::State, Phonon::State)));
 #endif // QT_NO_PHONON_ABSTRACTMEDIASTREAM
     QObject::connect(m_backendObject, SIGNAL(tick(qint64)),             q, SIGNAL(tick(qint64)));
     QObject::connect(m_backendObject, SIGNAL(seekableChanged(bool)),    q, SIGNAL(seekableChanged(bool)));
@@ -467,10 +467,10 @@ void MediaObjectPrivate::setupBackendObject()
     QObject::connect(m_backendObject, SIGNAL(aboutToFinish()),          q, SLOT(_k_aboutToFinish()));
     QObject::connect(m_backendObject, SIGNAL(prefinishMarkReached(qint32)), q, SIGNAL(prefinishMarkReached(qint32)));
     QObject::connect(m_backendObject, SIGNAL(totalTimeChanged(qint64)), q, SIGNAL(totalTimeChanged(qint64)));
-    QObject::connect(m_backendObject, SIGNAL(metaDataChanged(QMultiMap<QString,QString>)),
-            q, SLOT(_k_metaDataChanged(QMultiMap<QString,QString>)));
-    QObject::connect(m_backendObject, SIGNAL(currentSourceChanged(MediaSource)), 
-        q, SLOT(_k_currentSourceChanged(MediaSource)));
+    QObject::connect(m_backendObject, SIGNAL(metaDataChanged(const QMultiMap<QString, QString> &)),
+            q, SLOT(_k_metaDataChanged(const QMultiMap<QString, QString> &)));
+    QObject::connect(m_backendObject, SIGNAL(currentSourceChanged(const MediaSource&)), 
+        q, SLOT(_k_currentSourceChanged(const MediaSource&)));
 
     // set up attributes
     pINTERFACE_CALL(setTickInterval(tickInterval));
@@ -502,8 +502,8 @@ void MediaObjectPrivate::setupBackendObject()
     }
 
 #ifndef QT_NO_PHONON_MEDIACONTROLLER
-    for (int i = 0 ; i < interfaceList.count(); ++i) {
-        interfaceList.at(i)->_backendObjectChanged();
+    foreach (FrontendInterfacePrivate *f, interfaceList) {
+        f->_backendObjectChanged();
     }
 #endif //QT_NO_PHONON_MEDIACONTROLLER
 
diff --git a/src/3rdparty/phonon/phonon/mediaobject.h b/src/3rdparty/phonon/phonon/mediaobject.h
index ade966a..c1fa3c6 100644
--- a/src/3rdparty/phonon/phonon/mediaobject.h
+++ b/src/3rdparty/phonon/phonon/mediaobject.h
@@ -15,7 +15,7 @@
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public
+    You should have received a copy of the GNU Lesser General Public 
     License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 
 */
@@ -198,18 +198,18 @@ namespace Phonon
              * Check whether the current media may be seeked.
              *
              * \warning This information cannot be known immediately. It is best
-             * to also listen to the seekableChanged signal.
+             * to also listen to the hasVideoChanged signal.
              *
              * \code
-             *   connect(media, SIGNAL(seekableChanged(bool)), seekableChanged(bool));
+             *   connect(media, SIGNAL(hasVideoChanged(bool)), hasVideoChanged(bool));
              *   media->setCurrentSource("somevideo.avi");
-             *   media->isSeekable(); // returns false;
+             *   media->hasVideo(); // returns false;
              * }
              *
-             * void seekableChanged(bool b)
+             * void hasVideoChanged(bool b)
              * {
              *   // b == true
-             *   media->isSeekable(); // returns true;
+             *   media->hasVideo(); // returns true;
              * }
              * \endcode
              *
@@ -301,7 +301,7 @@ namespace Phonon
             void setCurrentSource(const MediaSource &source);
 
             /**
-             * Returns the queued media sources. This list does not include
+             * Returns the queued media sources. This does list does not include
              * the current source (returned by currentSource).
              */
             QList<MediaSource> queue() const;
@@ -456,6 +456,8 @@ namespace Phonon
         Q_SIGNALS:
             /**
              * Emitted when the state of the MediaObject has changed.
+             * In case you're not interested in the old state you can also
+             * connect to a slot that only has one State argument.
              *
              * @param newstate The state the Player is in now.
              * @param oldstate The state the Player was in before.
@@ -585,7 +587,7 @@ namespace Phonon
             /**
              * This signal is emitted as soon as the total time of the media file is
              * known or has changed. For most non-local media data the total
-             * time of the media can only be known after some time. Initially the
+             * time of the media can only be known after some time. At that time the
              * totalTime function can not return useful information. You have
              * to wait for this signal to know the real total time.
              *
diff --git a/src/3rdparty/phonon/phonon/mediasource.cpp b/src/3rdparty/phonon/phonon/mediasource.cpp
index be22dc3..c8db1e6 100644
--- a/src/3rdparty/phonon/phonon/mediasource.cpp
+++ b/src/3rdparty/phonon/phonon/mediasource.cpp
@@ -140,12 +140,8 @@ MediaSourcePrivate::~MediaSourcePrivate()
 {
 #ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     if (autoDelete) {
-        //here we use deleteLater because this object
-        //might be destroyed from another thread
-        if (stream)
-            stream->deleteLater();
-        if (ioDevice)
-            ioDevice->deleteLater();
+        delete stream;
+        delete ioDevice;
     }
 #endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
 }
diff --git a/src/3rdparty/phonon/phonon/objectdescription.cpp b/src/3rdparty/phonon/phonon/objectdescription.cpp
index e058b89..4afd9dd 100644
--- a/src/3rdparty/phonon/phonon/objectdescription.cpp
+++ b/src/3rdparty/phonon/phonon/objectdescription.cpp
@@ -29,6 +29,7 @@
 #include <QtCore/QStringList>
 #include "backendinterface.h"
 #include "platformplugin.h"
+#include "pulsesupport.h"
 
 QT_BEGIN_NAMESPACE
 
@@ -108,22 +109,24 @@ bool ObjectDescriptionData::isValid() const
 
 ObjectDescriptionData *ObjectDescriptionData::fromIndex(ObjectDescriptionType type, int index)
 {
+    BackendInterface *iface = qobject_cast<BackendInterface *>(Factory::backend());
+
     // prefer to get the ObjectDescriptionData from the platform plugin for audio devices
 #ifndef QT_NO_PHONON_PLATFORMPLUGIN
-    if (type == AudioOutputDeviceType || type == AudioCaptureDeviceType) {
-        PlatformPlugin *platformPlugin = Factory::platformPlugin();
-        if (platformPlugin) {
-            QList<int> indexes = platformPlugin->objectDescriptionIndexes(type);
-            if (indexes.contains(index)) {
-                QHash<QByteArray, QVariant> properties = platformPlugin->objectDescriptionProperties(type, index);
-                return new ObjectDescriptionData(index, properties);
+    if (!iface || !PulseSupport::getInstance()->isActive()) {
+        if (type == AudioOutputDeviceType || type == AudioCaptureDeviceType) {
+            PlatformPlugin *platformPlugin = Factory::platformPlugin();
+            if (platformPlugin) {
+                QList<int> indexes = platformPlugin->objectDescriptionIndexes(type);
+                if (indexes.contains(index)) {
+                    QHash<QByteArray, QVariant> properties = platformPlugin->objectDescriptionProperties(type, index);
+                    return new ObjectDescriptionData(index, properties);
+                }
             }
         }
     }
 #endif //QT_NO_PHONON_PLATFORMPLUGIN
 
-    QObject *b = Factory::backend();
-    BackendInterface *iface = qobject_cast<BackendInterface *>(b);
     if (iface) {
         QList<int> indexes = iface->objectDescriptionIndexes(type);
         if (indexes.contains(index)) {
diff --git a/src/3rdparty/phonon/phonon/objectdescriptionmodel.cpp b/src/3rdparty/phonon/phonon/objectdescriptionmodel.cpp
index 7237e91..3d48a46 100644
--- a/src/3rdparty/phonon/phonon/objectdescriptionmodel.cpp
+++ b/src/3rdparty/phonon/phonon/objectdescriptionmodel.cpp
@@ -67,8 +67,6 @@ static const char qt_meta_stringdata_Phonon__ObjectDescriptionModel_Visualizatio
 namespace Phonon
 {
 
-#if !defined(Q_CC_MINGW) || __MINGW32_MAJOR_VERSION >= 4
-
 template<> const QMetaObject ObjectDescriptionModel<AudioOutputDeviceType>::staticMetaObject = {
     { &QAbstractListModel::staticMetaObject, qt_meta_stringdata_Phonon__ObjectDescriptionModel_AudioOutputDeviceType,
       qt_meta_data_Phonon__ObjectDescriptionModel, 0 }
@@ -139,7 +137,6 @@ int ObjectDescriptionModel<type>::qt_metacall(QMetaObject::Call _c, int _id, voi
     return QAbstractListModel::qt_metacall(_c, _id, _a);
 }
 */
-#endif
 
 int ObjectDescriptionModelData::rowCount(const QModelIndex &parent) const
 {
@@ -321,8 +318,8 @@ bool ObjectDescriptionModelData::dropMimeData(ObjectDescriptionType type, const
         }
     }
     d->model->beginInsertRows(QModelIndex(), row, row + toInsert.size() - 1);
-    for (int i = 0 ; i < toInsert.count(); ++i) {
-        d->data.insert(row, toInsert.at(i));
+    foreach (const QExplicitlySharedDataPointer<ObjectDescriptionData> &obj, toInsert) {
+        d->data.insert(row, obj);
     }
     d->model->endInsertRows();
     return true;
@@ -365,8 +362,7 @@ QStringList ObjectDescriptionModelData::mimeTypes(ObjectDescriptionType type) co
     return QStringList(QLatin1String("application/x-phonon-objectdescription") + QString::number(static_cast<int>(type)));
 }
 
-#if !defined(Q_CC_MINGW) || __MINGW32_MAJOR_VERSION >= 4
-#if !defined(Q_CC_MSVC) || _MSC_VER > 1300 || defined(Q_CC_INTEL)
+#if !defined(Q_CC_MSVC) || _MSC_VER > 1300 || defined(Q_CC_INTEL) || defined(Q_CC_MINGW)
 #define INSTANTIATE_META_FUNCTIONS(type) \
 template const QMetaObject *ObjectDescriptionModel<type>::metaObject() const; \
 template void *ObjectDescriptionModel<type>::qt_metacast(const char *)
@@ -384,7 +380,6 @@ INSTANTIATE_META_FUNCTIONS(VideoCodecType);
 INSTANTIATE_META_FUNCTIONS(ContainerFormatType);
 INSTANTIATE_META_FUNCTIONS(VisualizationType);
 */
-#endif //Q_CC_MINGW
 } // namespace Phonon
 
 #endif //QT_NO_PHONON_OBJECTDESCRIPTIONMODEL
diff --git a/src/3rdparty/phonon/phonon/objectdescriptionmodel.h b/src/3rdparty/phonon/phonon/objectdescriptionmodel.h
index 96187c3..495225e 100644
--- a/src/3rdparty/phonon/phonon/objectdescriptionmodel.h
+++ b/src/3rdparty/phonon/phonon/objectdescriptionmodel.h
@@ -35,6 +35,18 @@ QT_BEGIN_NAMESPACE
 
 #ifndef QT_NO_PHONON_OBJECTDESCRIPTIONMODEL
 
+/* MinGW 3.4.x gives an ICE when trying to instantiate one of the
+   ObjectDescriptionModel<foo> classes because it can't handle
+   half exported classes correct. gcc 4.3.x has a fix for this but
+   we currently there's no official gcc 4.3 on windows available.
+   Because of this we need this little hack
+ */
+#if defined(Q_CC_MINGW)
+#define PHONON_EXPORT_ODM
+#else
+#define PHONON_EXPORT_ODM  PHONON_EXPORT
+#endif
+
 namespace Phonon
 {
     class ObjectDescriptionModelDataPrivate;
@@ -139,21 +151,6 @@ namespace Phonon
             ObjectDescriptionModelDataPrivate *const d;
     };
 
-/* Required to ensure template class vtables are exported on both symbian
-and existing builds. */
-#if defined(Q_OS_SYMBIAN) && defined(Q_CC_RVCT)
-// RVCT compiler (2.2.686) requires the export declaration to be on the class to export vtables
-// MWC compiler works both ways
-// GCCE compiler is unknown (it can't compile QtCore yet)
-#define PHONON_TEMPLATE_CLASS_EXPORT PHONON_EXPORT
-#define PHONON_TEMPLATE_CLASS_MEMBER_EXPORT
-#else
-// Windows builds (at least) do not support export declaration on templated class
-// But if you export a member function, the vtable is implicitly exported
-#define PHONON_TEMPLATE_CLASS_EXPORT
-#define PHONON_TEMPLATE_CLASS_MEMBER_EXPORT PHONON_EXPORT
-#endif
-
     /** \class ObjectDescriptionModel objectdescriptionmodel.h Phonon/ObjectDescriptionModel
      * \short The ObjectDescriptionModel class provides a model from
      * a list of ObjectDescription objects.
@@ -190,26 +187,17 @@ and existing builds. */
      * \author Matthias Kretz <kretz@kde.org>
      */
     template<ObjectDescriptionType type>
-    class PHONON_TEMPLATE_CLASS_EXPORT ObjectDescriptionModel : public QAbstractListModel
+    class ObjectDescriptionModel : public QAbstractListModel
     {
         public:
             Q_OBJECT_CHECK
-
-/* MinGW 3.4.x gives an ICE when trying to instantiate one of the
-   ObjectDescriptionModel<foo> classes because it can't handle
-   half exported classes correct. gcc 4.3.x has a fix for this but
-   we currently there's no official gcc 4.3 on windows available.
-   Because of this we need this little hack
- */
-#if !defined(Q_CC_MINGW) || __MINGW32_MAJOR_VERSION >= 4
             /** \internal */
-            static PHONON_TEMPLATE_CLASS_MEMBER_EXPORT const QMetaObject staticMetaObject;
+            static PHONON_EXPORT const QMetaObject staticMetaObject;
             /** \internal */
-            PHONON_TEMPLATE_CLASS_MEMBER_EXPORT const QMetaObject *metaObject() const;
+            PHONON_EXPORT_ODM const QMetaObject *metaObject() const;
             /** \internal */
-            PHONON_TEMPLATE_CLASS_MEMBER_EXPORT void *qt_metacast(const char *_clname);
+            PHONON_EXPORT_ODM void *qt_metacast(const char *_clname);
             //int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
-#endif
 
             /**
              * Returns the number of rows in the model. This value corresponds
@@ -307,8 +295,8 @@ and existing builds. */
              */
             inline void setModelData(const QList<ObjectDescription<type> > &data) { //krazy:exclude=inline
                 QList<QExplicitlySharedDataPointer<ObjectDescriptionData> > list;
-                for (int i = 0; i < data.count(); ++i) {
-                    list += data.at(i).d;
+                Q_FOREACH (const ObjectDescription<type> &desc, data) {
+                    list << desc.d;
                 }
                 d->setModelData(list);
             }
@@ -322,8 +310,8 @@ and existing builds. */
             inline QList<ObjectDescription<type> > modelData() const { //krazy:exclude=inline
                 QList<ObjectDescription<type> > ret;
                 QList<QExplicitlySharedDataPointer<ObjectDescriptionData> > list = d->modelData();
-                for (int i = 0; i < list.count(); ++i) {
-                    ret << ObjectDescription<type>(list.at(i));
+                Q_FOREACH (const QExplicitlySharedDataPointer<ObjectDescriptionData> &data, list) {
+                    ret << ObjectDescription<type>(data);
                 }
                 return ret;
             }
diff --git a/src/3rdparty/phonon/phonon/path.cpp b/src/3rdparty/phonon/phonon/path.cpp
index 51c33b2..b225697 100644
--- a/src/3rdparty/phonon/phonon/path.cpp
+++ b/src/3rdparty/phonon/phonon/path.cpp
@@ -58,8 +58,8 @@ class ConnectionTransaction
 PathPrivate::~PathPrivate()
 {
 #ifndef QT_NO_PHONON_EFFECT
-    for (int i = 0; i < effects.count(); ++i) {
-        effects.at(i)->k_ptr->removeDestructionHandler(this);
+    foreach (Effect *e, effects) {
+        e->k_ptr->removeDestructionHandler(this);
     }
     delete effectsParent;
 #endif
@@ -233,8 +233,8 @@ bool Path::disconnect()
     if (d->sourceNode)
         list << d->sourceNode->k_ptr->backendObject();
 #ifndef QT_NO_PHONON_EFFECT
-    for (int i = 0; i < d->effects.count(); ++i) {
-        list << d->effects.at(i)->k_ptr->backendObject();
+    foreach(Effect *e, d->effects) {
+        list << e->k_ptr->backendObject();
     }
 #endif
     if (d->sinkNode) {
@@ -260,8 +260,8 @@ bool Path::disconnect()
         d->sourceNode = 0;
 
 #ifndef QT_NO_PHONON_EFFECT
-        for (int i = 0; i < d->effects.count(); ++i) {
-            d->effects.at(i)->k_ptr->removeDestructionHandler(d.data());
+        foreach(Effect *e, d->effects) {
+            e->k_ptr->removeDestructionHandler(d.data());
         }
         d->effects.clear();
 #endif 
@@ -292,13 +292,11 @@ MediaNode *Path::sink() const
 bool PathPrivate::executeTransaction( const QList<QObjectPair> &disconnections, const QList<QObjectPair> &connections)
 {
     QSet<QObject*> nodesForTransaction;
-    for (int i = 0; i < disconnections.count(); ++i) {
-        const QObjectPair &pair = disconnections.at(i);
+    foreach(const QObjectPair &pair, disconnections) {
         nodesForTransaction << pair.first;
         nodesForTransaction << pair.second;
     }
-    for (int i = 0; i < connections.count(); ++i) {
-        const QObjectPair &pair = connections.at(i);
+    foreach(const QObjectPair &pair, connections) {
         nodesForTransaction << pair.first;
         nodesForTransaction << pair.second;
     }
@@ -310,8 +308,8 @@ bool PathPrivate::executeTransaction( const QList<QObjectPair> &disconnections,
     if (!transaction)
         return false;
 
-    QList<QObjectPair>::const_iterator it = disconnections.constBegin();
-    for(;it != disconnections.constEnd();++it) {
+    QList<QObjectPair>::const_iterator it = disconnections.begin();
+    for(;it != disconnections.end();++it) {
         const QObjectPair &pair = *it;
         if (!backend->disconnectNodes(pair.first, pair.second)) {
 
@@ -327,8 +325,8 @@ bool PathPrivate::executeTransaction( const QList<QObjectPair> &disconnections,
         }
     }
 
-    for(it = connections.constBegin(); it != connections.constEnd(); ++it) {
-        const QObjectPair pair = *it;
+    for(it = connections.begin(); it != connections.end();++it) {
+        const QObjectPair &pair = *it;
         if (!backend->connectNodes(pair.first, pair.second)) {
             //Error: a connection failed
             QList<QObjectPair>::const_iterator it2 = connections.begin();
@@ -340,8 +338,7 @@ bool PathPrivate::executeTransaction( const QList<QObjectPair> &disconnections,
             }
 
             //and now let's reconnect the nodes that were disconnected: rollback
-            for (int i = 0; i < disconnections.count(); ++i) {
-                const QObjectPair &pair = disconnections.at(i);
+            foreach(const QObjectPair &pair, disconnections) {
                 bool success = backend->connectNodes(pair.first, pair.second);
                 Q_ASSERT(success); //a failure here means it is impossible to reestablish the connection
                 Q_UNUSED(success);
@@ -420,8 +417,7 @@ void PathPrivate::phononObjectDestroyed(MediaNodePrivate *mediaNodePrivate)
         sinkNode = 0;
     } else {
 #ifndef QT_NO_PHONON_EFFECT
-        for (int i = 0; i < effects.count(); ++i) {
-            Effect *e = effects.at(i);
+        foreach (Effect *e, effects) {
             if (e->k_ptr == mediaNodePrivate) {
                 removeEffect(e);
             }
diff --git a/src/3rdparty/phonon/phonon/phonondefs.h b/src/3rdparty/phonon/phonon/phonondefs.h
index 15a1815..765eb1c 100644
--- a/src/3rdparty/phonon/phonon/phonondefs.h
+++ b/src/3rdparty/phonon/phonon/phonondefs.h
@@ -29,6 +29,11 @@
 QT_BEGIN_HEADER
 QT_BEGIN_NAMESPACE
 
+#ifdef PHONON_BACKEND_VERSION_4_4
+# ifndef PHONON_BACKEND_VERSION_4_3
+#  define PHONON_BACKEND_VERSION_4_3
+# endif
+#endif
 #ifdef PHONON_BACKEND_VERSION_4_3
 # ifndef PHONON_BACKEND_VERSION_4_2
 #  define PHONON_BACKEND_VERSION_4_2
diff --git a/src/3rdparty/phonon/phonon/phononnamespace.h b/src/3rdparty/phonon/phonon/phononnamespace.h
index ec42d51..89ff21d 100644
--- a/src/3rdparty/phonon/phonon/phononnamespace.h
+++ b/src/3rdparty/phonon/phonon/phononnamespace.h
@@ -41,12 +41,12 @@
 /**
  * PHONON_VERSION is (major << 16) + (minor << 8) + patch.
  */
-#define PHONON_VERSION PHONON_VERSION_CHECK(4, 3, 1)
+#define PHONON_VERSION PHONON_VERSION_CHECK(4, 3, 80)
 
 /**
  * PHONON_VERSION_STR is "major.minor.patch". E.g. "4.2.1"
  */
-#define PHONON_VERSION_STR "4.3.1"
+#define PHONON_VERSION_STR "4.3.80"
 
 QT_BEGIN_HEADER
 QT_BEGIN_NAMESPACE
@@ -95,7 +95,7 @@ namespace Phonon
     };
 
     /**
-     * Provided as keys for \ref MediaObject::metaData for convenience, in addition to the strings defined in
+     * Provided as keys for MediaObject::metaData for convenience, in addition to the strings defined in
      * the Ogg Vorbis specification.
      */
     enum MetaData {
diff --git a/src/3rdparty/phonon/phonon/pulsesupport.cpp b/src/3rdparty/phonon/phonon/pulsesupport.cpp
new file mode 100644
index 0000000..497e6a2
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/pulsesupport.cpp
@@ -0,0 +1,1013 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2009 Colin Guthrie <cguthrie@mandriva.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include <QtCore/QtGlobal>
+#include <QtCore/QEventLoop>
+#include <QtCore/QDebug>
+#include <QtCore/QStringList>
+
+#ifdef HAVE_PULSEAUDIO
+#include <glib.h>
+#include <pulse/pulseaudio.h>
+#include <pulse/xmalloc.h>
+#include <pulse/glib-mainloop.h>
+#ifdef HAVE_PULSEAUDIO_DEVICE_MANAGER
+#  include <pulse/ext-device-manager.h>
+#endif
+#endif // HAVE_PULSEAUDIO
+
+#include "pulsesupport.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+
+static PulseSupport* s_instance = NULL;
+
+#ifdef HAVE_PULSEAUDIO
+/***
+* Prints a conditional debug message based on the current debug level
+* If obj is provided, classname and objectname will be printed as well
+*
+* see debugLevel()
+*/
+
+static int debugLevel() {
+    static int level = -1;
+    if (level < 1) {
+        level = 0;
+        QString pulseenv = qgetenv("PHONON_PULSEAUDIO_DEBUG");
+        int l = pulseenv.toInt();
+        if (l > 0)
+            level = (l > 2 ? 2 : l);
+    }
+    return level;
+}
+
+static void logMessage(const QString &message, int priority = 2, QObject *obj=0);
+static void logMessage(const QString &message, int priority, QObject *obj)
+{
+    if (debugLevel() > 0) {
+        QString output;
+        if (obj) {
+            // Strip away namespace from className
+            QString className(obj->metaObject()->className());
+            int nameLength = className.length() - className.lastIndexOf(':') - 1;
+            className = className.right(nameLength);
+            output.sprintf("%s %s (%s %p)", message.toLatin1().constData(), 
+                           obj->objectName().toLatin1().constData(), 
+                           className.toLatin1().constData(), obj);
+        }
+        else {
+            output = message;
+        }
+        if (priority <= debugLevel()) {
+            qDebug() << QString("PulseSupport(%1): %2").arg(priority).arg(output);
+        }
+    }
+}
+
+
+class AudioDevice
+{
+    public:
+        inline
+        AudioDevice(QString name, QString desc, QString icon, uint32_t index)
+        : pulseName(name), pulseIndex(index)
+        {
+            properties["name"] = desc;
+            properties["description"] = ""; // We don't have descriptions (well we do, but we use them as the name!)
+            properties["icon"] = icon;
+            properties["available"] = (index != PA_INVALID_INDEX);
+            properties["isAdvanced"] = false; // Nothing is advanced!
+        }
+
+        // Needed for QMap
+        inline AudioDevice() {}
+
+        QString pulseName;
+        uint32_t pulseIndex;
+        QHash<QByteArray, QVariant> properties;
+};
+bool operator!=(const AudioDevice &a, const AudioDevice &b)
+{
+    return !(a.pulseName == b.pulseName && a.properties == b.properties);
+}
+
+class PulseUserData
+{
+    public:
+        inline 
+        PulseUserData()
+        {
+        }
+
+        QMap<QString, AudioDevice> newOutputDevices;
+        QMap<Phonon::Category, QMap<int, int> > newOutputDevicePriorities; // prio, device
+
+        QMap<QString, AudioDevice> newCaptureDevices;
+        QMap<Phonon::Category, QMap<int, int> > newCaptureDevicePriorities; // prio, device
+};
+
+static QMap<QString, Phonon::Category> s_roleCategoryMap;
+
+static bool s_pulseActive = false;
+
+static pa_glib_mainloop *s_mainloop = NULL;
+static pa_context *s_context = NULL;
+static QEventLoop *s_connectionEventloop = NULL;
+
+
+
+static int s_deviceIndexCounter = 0;
+
+static QMap<QString, int> s_outputDeviceIndexes;
+static QMap<int, AudioDevice> s_outputDevices;
+static QMap<Phonon::Category, QMap<int, int> > s_outputDevicePriorities; // prio, device
+static QMap<QString, uint32_t> s_outputStreamIndexMap;
+static QMap<QString, int> s_outputStreamMoveQueue;
+
+static QMap<QString, int> s_captureDeviceIndexes;
+static QMap<int, AudioDevice> s_captureDevices;
+static QMap<Phonon::Category, QMap<int, int> > s_captureDevicePriorities; // prio, device
+static QMap<QString, uint32_t> s_captureStreamIndexMap;
+static QMap<QString, int> s_captureStreamMoveQueue;
+
+static void createGenericDevices()
+{
+    // OK so we don't have the device manager extension, but we can show a single device and fake it.
+    int index;
+    s_outputDeviceIndexes.clear();
+    s_outputDevices.clear();
+    s_outputDevicePriorities.clear();
+    index = s_deviceIndexCounter++;
+    s_outputDeviceIndexes.insert("sink:default", index);
+    s_outputDevices.insert(index, AudioDevice("sink:default", QObject::tr("PulseAudio Sound Server").toUtf8(), "audio-backend-pulseaudio", 0));
+    for (int i = Phonon::NoCategory; i <= Phonon::LastCategory; ++i) {
+        Phonon::Category cat = static_cast<Phonon::Category>(i);
+        s_outputDevicePriorities[cat].insert(0, index);
+    }
+
+    s_captureDeviceIndexes.clear();
+    s_captureDevices.clear();
+    s_captureDevicePriorities.clear();
+    index = s_deviceIndexCounter++;
+    s_captureDeviceIndexes.insert("source:default", index);
+    s_captureDevices.insert(index, AudioDevice("source:default", QObject::tr("PulseAudio Sound Server").toUtf8(), "audio-backend-pulseaudio", 0));
+    for (int i = Phonon::NoCategory; i <= Phonon::LastCategory; ++i) {
+        Phonon::Category cat = static_cast<Phonon::Category>(i);
+        s_captureDevicePriorities[cat].insert(0, index);
+    }
+}
+
+#ifdef HAVE_PULSEAUDIO_DEVICE_MANAGER
+static void ext_device_manager_subscribe_cb(pa_context *, void *);
+static void ext_device_manager_read_cb(pa_context *c, const pa_ext_device_manager_info *info, int eol, void *userdata) {
+    Q_ASSERT(c);
+    Q_ASSERT(userdata);
+
+    // If this is our first iteration, set things up properly
+    if (s_connectionEventloop) {
+        logMessage("Exiting connection event loop (PulseAudio server found)");
+        s_connectionEventloop->exit(0);
+        s_connectionEventloop = NULL;
+        s_pulseActive = true;
+
+        pa_operation *o;
+        pa_ext_device_manager_set_subscribe_cb(c, ext_device_manager_subscribe_cb, NULL);
+        if ((o = pa_ext_device_manager_subscribe(c, 1, NULL, NULL)))
+            pa_operation_unref(o);
+    }
+
+    if (eol < 0) {
+        logMessage(QString("Failed to initialize device manager extension: %1").arg(pa_strerror(pa_context_errno(c))));
+        createGenericDevices();
+        return;
+    }
+
+    PulseUserData *u = reinterpret_cast<PulseUserData*>(userdata);
+    if (eol) {
+        // We're done reading the data, so order it by priority and copy it into the
+        // static variables where it can then be accessed by those classes that need it.
+
+        QMap<QString, AudioDevice>::iterator newdev_it;
+
+        // Check for new output devices or things changing about known output devices.
+        bool output_changed = false;
+        for (newdev_it = u->newOutputDevices.begin(); newdev_it != u->newOutputDevices.end(); ++newdev_it) {
+            QString name = newdev_it.key();
+
+            // The name + index map is always written when a new device is added.
+            Q_ASSERT(s_outputDeviceIndexes.contains(name));
+
+            int index = s_outputDeviceIndexes[name];
+            if (!s_outputDevices.contains(index)) {
+                // This is a totally new device
+                output_changed = true;
+                logMessage(QString("Brand New Output Device Found."));
+                s_outputDevices.insert(index, *newdev_it);
+            } else  if (s_outputDevices[index] != *newdev_it) {
+                // We have this device already, but is it different?
+                output_changed = true;
+                logMessage(QString("Change to Existing Output Device (may be Added/Removed or something else)"));
+                s_outputDevices.remove(index);
+                s_outputDevices.insert(index, *newdev_it);
+            }
+        }
+        // Go through the output devices we know about and see if any are no longer mentioned in the list.
+        QMutableMapIterator<QString, int> output_existing_it(s_outputDeviceIndexes);
+        while (output_existing_it.hasNext()) {
+            output_existing_it.next();
+            if (!u->newOutputDevices.contains(output_existing_it.key())) {
+                output_changed = true;
+                logMessage(QString("Output Device Completely Removed"));
+                s_outputDevices.remove(output_existing_it.value());
+                output_existing_it.remove();
+            }
+        }
+
+        // Check for new capture devices or things changing about known capture devices.
+        bool capture_changed = false;
+        for (newdev_it = u->newCaptureDevices.begin(); newdev_it != u->newCaptureDevices.end(); ++newdev_it) {
+            QString name = newdev_it.key();
+
+            // The name + index map is always written when a new device is added.
+            Q_ASSERT(s_captureDeviceIndexes.contains(name));
+
+            int index = s_captureDeviceIndexes[name];
+            if (!s_captureDevices.contains(index)) {
+                // This is a totally new device
+                capture_changed = true;
+                logMessage(QString("Brand New Capture Device Found."));
+                s_captureDevices.insert(index, *newdev_it);
+            } else  if (s_captureDevices[index] != *newdev_it) {
+                // We have this device already, but is it different?
+                capture_changed = true;
+                logMessage(QString("Change to Existing Capture Device (may be Added/Removed or something else)"));
+                s_captureDevices.remove(index);
+                s_captureDevices.insert(index, *newdev_it);
+            }
+        }
+        // Go through the capture devices we know about and see if any are no longer mentioned in the list.
+        QMutableMapIterator<QString, int> capture_existing_it(s_captureDeviceIndexes);
+        while (capture_existing_it.hasNext()) {
+            capture_existing_it.next();
+            if (!u->newCaptureDevices.contains(capture_existing_it.key())) {
+                capture_changed = true;
+                logMessage(QString("Capture Device Completely Removed"));
+                s_captureDevices.remove(capture_existing_it.value());
+                capture_existing_it.remove();
+            }
+        }
+
+        // Just copy accross the new priority lists as we know they are valid
+        if (s_outputDevicePriorities != u->newOutputDevicePriorities) {
+            output_changed = true;
+            s_outputDevicePriorities = u->newOutputDevicePriorities;
+        }
+        if (s_captureDevicePriorities != u->newCaptureDevicePriorities) {
+            capture_changed = true;
+            s_captureDevicePriorities = u->newCaptureDevicePriorities;
+        }
+
+        if (s_instance) {
+            if (output_changed)
+                s_instance->emitObjectDescriptionChanged(AudioOutputDeviceType);
+            if (capture_changed)
+                s_instance->emitObjectDescriptionChanged(AudioCaptureDeviceType);
+        }
+
+        // We can free the user data as we will not be called again.
+        delete u;
+
+        // Some debug
+        logMessage(QString("Output Device Priority List:"));
+        for (int i = Phonon::NoCategory; i <= Phonon::LastCategory; ++i) {
+            Phonon::Category cat = static_cast<Phonon::Category>(i);
+            if (s_outputDevicePriorities.contains(cat)) {
+                logMessage(QString("  Phonon Category %1").arg(cat));
+                int count = 0;
+                foreach (int j, s_outputDevicePriorities[cat]) {
+                    QHash<QByteArray, QVariant> &props = s_outputDevices[j].properties;
+                    logMessage(QString("    %1. %2 (Available: %3)").arg(++count).arg(props["name"].toString()).arg(props["available"].toBool()));
+                }
+            }
+        }
+        logMessage(QString("Capture Device Priority List:"));
+        for (int i = Phonon::NoCategory; i <= Phonon::LastCategory; ++i) {
+            Phonon::Category cat = static_cast<Phonon::Category>(i);
+            if (s_captureDevicePriorities.contains(cat)) {
+                logMessage(QString("  Phonon Category %1").arg(cat));
+                int count = 0;
+                foreach (int j, s_captureDevicePriorities[cat]) {
+                    QHash<QByteArray, QVariant> &props = s_captureDevices[j].properties;
+                    logMessage(QString("    %1. %2 (Available: %3)").arg(++count).arg(props["name"].toString()).arg(props["available"].toBool()));
+                }
+            }
+        }
+    }
+
+    if (!info)
+        return;
+
+    Q_ASSERT(info->name);
+    Q_ASSERT(info->description);
+    Q_ASSERT(info->icon);
+
+    // QString wrapper
+    QString name(info->name);
+    int index;
+    QMap<Phonon::Category, QMap<int, int> > *new_prio_map_cats; // prio, device
+    QMap<QString, AudioDevice> *new_devices;
+
+    if (name.startsWith("sink:")) {
+        new_devices = &u->newOutputDevices;
+        new_prio_map_cats = &u->newOutputDevicePriorities;
+
+        if (s_outputDeviceIndexes.contains(name))
+            index = s_outputDeviceIndexes[name];
+        else
+            index = s_outputDeviceIndexes[name] = s_deviceIndexCounter++;
+    } else if (name.startsWith("source:")) {
+        new_devices = &u->newCaptureDevices;
+        new_prio_map_cats = &u->newCaptureDevicePriorities;
+
+        if (s_captureDeviceIndexes.contains(name))
+            index = s_captureDeviceIndexes[name];
+        else
+            index = s_captureDeviceIndexes[name] = s_deviceIndexCounter++;
+    } else {
+        // This indicates a bug in pulseaudio.
+        return;
+    }
+
+    // Add the new device itself.
+    new_devices->insert(name, AudioDevice(name, info->description, info->icon, info->index));
+
+    // For each role in the priority, map it to a phonon category and store the order.
+    for (uint32_t i = 0; i < info->n_role_priorities; ++i) {
+        pa_ext_device_manager_role_priority_info* role_prio = &info->role_priorities[i];
+        Q_ASSERT(role_prio->role);
+
+        if (s_roleCategoryMap.contains(role_prio->role)) {
+            Phonon::Category cat = s_roleCategoryMap[role_prio->role];
+
+            (*new_prio_map_cats)[cat].insert(role_prio->priority, index);
+        }
+    }
+}
+#endif
+
+static void set_output_device(QString streamUuid)
+{
+    // If we only have one device, bail. This will be true if we are not using module-device-manager
+    if (s_outputDevices.size() < 2)
+        return;
+
+    if (!s_outputStreamMoveQueue.contains(streamUuid))
+        return;
+
+    if (!s_outputStreamIndexMap.contains(streamUuid))
+        return;
+
+    if (s_outputStreamIndexMap[streamUuid] == PA_INVALID_INDEX)
+        return;
+
+    int device = s_outputStreamMoveQueue[streamUuid];
+    if (!s_outputDevices.contains(device))
+        return;
+
+    // We don't remove the uuid from the s_captureStreamMoveQueue
+    // as an application may reuse the phonon AudioOutput object
+
+    uint32_t pulse_device_index = s_outputDevices[device].pulseIndex;
+    uint32_t pulse_stream_index = s_outputStreamIndexMap[streamUuid];
+
+    const QVariant var = s_outputDevices[device].properties["name"];
+    logMessage(QString("Moving Pulse Sink Input %1 to '%2' (Pulse Sink %3)").arg(pulse_stream_index).arg(var.toString()).arg(pulse_device_index));
+
+    /// @todo Find a way to move the stream without saving it... We don't want to pollute the stream restore db.
+    pa_operation* o;
+    if (!(o = pa_context_move_sink_input_by_index(s_context, pulse_stream_index, pulse_device_index, NULL, NULL))) {
+        logMessage(QString("pa_context_move_sink_input_by_index() failed"));
+        return;
+    }
+    pa_operation_unref(o);
+}
+
+static void set_capture_device(QString streamUuid)
+{
+    // If we only have one device, bail. This will be true if we are not using module-device-manager
+    if (s_captureDevices.size() < 2)
+        return;
+
+    if (!s_captureStreamMoveQueue.contains(streamUuid))
+        return;
+
+    if (!s_captureStreamIndexMap.contains(streamUuid))
+        return;
+
+    if (s_captureStreamIndexMap[streamUuid] == PA_INVALID_INDEX)
+        return;
+
+    int device = s_captureStreamMoveQueue[streamUuid];
+    if (!s_captureDevices.contains(device))
+        return;
+
+    // We don't remove the uuid from the s_captureStreamMoveQueue
+    // as an application may reuse the phonon AudioCapture object (when it exists!)
+
+    uint32_t pulse_device_index = s_captureDevices[device].pulseIndex;
+    uint32_t pulse_stream_index = s_captureStreamIndexMap[streamUuid];
+
+    const QVariant var = s_captureDevices[device].properties["name"];
+    logMessage(QString("Moving Pulse Source Output %1 to '%2' (Pulse Sink %3)").arg(pulse_stream_index).arg(var.toString()).arg(pulse_device_index));
+
+    /// @todo Find a way to move the stream without saving it... We don't want to pollute the stream restore db.
+    pa_operation* o;
+    if (!(o = pa_context_move_source_output_by_index(s_context, pulse_stream_index, pulse_device_index, NULL, NULL))) {
+        logMessage(QString("pa_context_move_source_output_by_index() failed"));
+        return;
+    }
+    pa_operation_unref(o);
+}
+
+void sink_input_cb(pa_context *c, const pa_sink_input_info *i, int eol, void *userdata) {
+    Q_UNUSED(userdata);
+    Q_ASSERT(c);
+
+    if (eol < 0) {
+        if (pa_context_errno(c) == PA_ERR_NOENTITY)
+            return;
+
+        logMessage(QString("Sink input callback failure"));
+        return;
+    }
+
+    if (eol > 0)
+        return;
+
+    Q_ASSERT(i);
+
+    // loop through (*i) and extract phonon->streamindex...
+    const char *t;
+    if ((t = pa_proplist_gets(i->proplist, "phonon.streamid"))) {
+        logMessage(QString("Found PulseAudio stream index %1 for Phonon Output Stream %2").arg(i->index).arg(t));
+        s_outputStreamIndexMap[QString(t)] = i->index;
+        // Process any pending moves...
+        set_output_device(QString(t));
+    }
+}
+
+void source_output_cb(pa_context *c, const pa_source_output_info *i, int eol, void *userdata) {
+    Q_UNUSED(userdata);
+    Q_ASSERT(c);
+
+    if (eol < 0) {
+        if (pa_context_errno(c) == PA_ERR_NOENTITY)
+            return;
+
+        logMessage(QString("Source output callback failure"));
+        return;
+    }
+
+    if (eol > 0)
+        return;
+
+    Q_ASSERT(i);
+
+    // loop through (*i) and extract phonon->streamindex...
+    const char *t;
+    if ((t = pa_proplist_gets(i->proplist, "phonon.streamid"))) {
+        logMessage(QString("Found PulseAudio stream index %1 for Phonon Capture Stream %2").arg(i->index).arg(t));
+        s_captureStreamIndexMap[QString(t)] = i->index;
+        // Process any pending moves...
+        set_capture_device(QString(t));
+    }
+}
+
+static void subscribe_cb(pa_context *c, pa_subscription_event_type_t t, uint32_t index, void *userdata) {
+    Q_UNUSED(userdata);
+
+    switch (t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) {
+        case PA_SUBSCRIPTION_EVENT_SINK_INPUT:
+            if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                QString phononid = s_outputStreamIndexMap.key(index);
+                if (!phononid.isEmpty()) {
+                    if (s_outputStreamIndexMap.contains(phononid)) {
+                        logMessage(QString("Phonon Output Stream %1 is gone at the PA end. Marking it as invalid in our cache as we may reuse it.").arg(phononid));
+                        s_outputStreamIndexMap[phononid] = PA_INVALID_INDEX;
+                    } else {
+                        logMessage(QString("Removing Phonon Output Stream %1 (it's gone!)").arg(phononid));
+                        s_outputStreamIndexMap.remove(phononid);
+                        s_outputStreamMoveQueue.remove(phononid);
+                    }
+                }
+            } else {
+                pa_operation *o;
+                if (!(o = pa_context_get_sink_input_info(c, index, sink_input_cb, NULL))) {
+                    logMessage(QString("pa_context_get_sink_input_info() failed"));
+                    return;
+                }
+                pa_operation_unref(o);
+            }
+            break;
+
+        case PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT:
+            if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                QString phononid = s_captureStreamIndexMap.key(index);
+                if (!phononid.isEmpty()) {
+                    if (s_captureStreamIndexMap.contains(phononid)) {
+                        logMessage(QString("Phonon Capture Stream %1 is gone at the PA end. Marking it as invalid in our cache as we may reuse it.").arg(phononid));
+                        s_captureStreamIndexMap[phononid] = PA_INVALID_INDEX;
+                    } else {
+                        logMessage(QString("Removing Phonon Capture Stream %1 (it's gone!)").arg(phononid));
+                        s_captureStreamIndexMap.remove(phononid);
+                        s_captureStreamMoveQueue.remove(phononid);
+                    }
+                }
+            } else {
+                pa_operation *o;
+                if (!(o = pa_context_get_source_output_info(c, index, source_output_cb, NULL))) {
+                    logMessage(QString("pa_context_get_sink_input_info() failed"));
+                    return;
+                }
+                pa_operation_unref(o);
+            }
+            break;
+    }
+}
+
+
+static void ext_device_manager_subscribe_cb(pa_context *c, void *) {
+    Q_ASSERT(c);
+
+    pa_operation *o;
+#ifdef HAVE_PULSEAUDIO_DEVICE_MANAGER 
+    PulseUserData *u = new PulseUserData; /** @todo Make some object to receive the info... */
+    if (!(o = pa_ext_device_manager_read(c, ext_device_manager_read_cb, u))) {
+        // We need to deal with failure on first iteration
+        if (s_connectionEventloop) {
+            logMessage("Entering connection eventloop (initialisation failed)");
+            s_connectionEventloop->exit(0);
+            s_connectionEventloop = NULL;
+        }
+        logMessage(QString("pa_ext_device_manager_read() failed"));
+        return;
+    }
+    pa_operation_unref(o);
+#else
+    // If we do not have Device Manager support. We just bail out now
+    // and say we are active with our single "devices" for playback and capture
+    s_pulseActive = true;
+    logMessage("Entering connection eventloop (successfully detected PulseAudio)");
+    if (s_connectionEventloop) {
+        s_connectionEventloop->exit(0);
+        s_connectionEventloop = NULL;
+    }
+    createGenericDevices();
+#endif
+
+
+    // Register for the stream changes...
+    pa_context_set_subscribe_callback(c, subscribe_cb, NULL);
+
+    if (!(o = pa_context_subscribe(c, (pa_subscription_mask_t)
+                                   (PA_SUBSCRIPTION_MASK_SINK_INPUT|
+                                    PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT), NULL, NULL))) {
+        logMessage(QString("pa_context_subscribe() failed"));
+        return;
+    }
+    pa_operation_unref(o);
+}
+
+
+static const char* statename(pa_context_state_t state)
+{
+    switch (state)
+    {
+        case PA_CONTEXT_UNCONNECTED:  return "Unconnected";
+        case PA_CONTEXT_CONNECTING:   return "Connecting";
+        case PA_CONTEXT_AUTHORIZING:  return "Authorizing";
+        case PA_CONTEXT_SETTING_NAME: return "Setting Name";
+        case PA_CONTEXT_READY:        return "Ready";
+        case PA_CONTEXT_FAILED:       return "Failed";
+        case PA_CONTEXT_TERMINATED:   return "Terminated";
+    }
+
+    static QString unknown;
+    unknown = QString("Unknown state: %0").arg(state);
+    return unknown.toAscii().constData();
+}
+
+static void context_state_callback(pa_context *c, void *)
+{
+    Q_ASSERT(c);
+
+    logMessage(QString("context_state_callback %1").arg(statename(pa_context_get_state(c))));
+    switch (pa_context_get_state(c)) {
+        case PA_CONTEXT_UNCONNECTED:
+        case PA_CONTEXT_CONNECTING:
+        case PA_CONTEXT_AUTHORIZING:
+        case PA_CONTEXT_SETTING_NAME:
+            break;
+
+        case PA_CONTEXT_READY:
+            // Attempt to load things up
+            ext_device_manager_subscribe_cb(c, NULL);
+            break;
+
+        case PA_CONTEXT_FAILED:
+            s_pulseActive = false;
+            if (s_connectionEventloop) {
+                logMessage("Entering connection eventloop (connection failed)");
+                s_connectionEventloop->exit(0);
+                s_connectionEventloop = NULL;
+            }
+            break;
+
+        case PA_CONTEXT_TERMINATED:
+        default:
+            s_pulseActive = false;
+            /// @todo Deal with reconnection...
+            break;
+    }
+}
+#endif // HAVE_PULSEAUDIO
+
+
+PulseSupport* PulseSupport::getInstance()
+{
+    if (NULL == s_instance) {
+        s_instance = new PulseSupport();
+    }
+    return s_instance;
+}
+
+void PulseSupport::shutdown()
+{
+    if (NULL != s_instance) {
+        delete s_instance;
+        s_instance = NULL;
+    }
+}
+
+PulseSupport::PulseSupport()
+ : QObject()
+{
+#ifdef HAVE_PULSEAUDIO
+    // Initialise our map (is there a better way to do this?)
+    s_roleCategoryMap["none"] = Phonon::NoCategory;
+    s_roleCategoryMap["video"] = Phonon::VideoCategory;
+    s_roleCategoryMap["music"] = Phonon::MusicCategory;
+    s_roleCategoryMap["game"] = Phonon::GameCategory;
+    s_roleCategoryMap["event"] = Phonon::NotificationCategory;
+    s_roleCategoryMap["phone"] = Phonon::CommunicationCategory;
+    //s_roleCategoryMap["animation"]; // No Mapping
+    //s_roleCategoryMap["production"]; // No Mapping
+    s_roleCategoryMap["a11y"] = Phonon::AccessibilityCategory;
+
+    // To allow for easy debugging, give an easy way to disable this pulseaudio check
+    QString pulseenv = qgetenv("PHONON_PULSEAUDIO_DISABLE");
+    if (pulseenv.toInt())
+        return;
+
+    s_mainloop = pa_glib_mainloop_new(NULL);
+    Q_ASSERT(s_mainloop);
+    pa_mainloop_api *api = pa_glib_mainloop_get_api(s_mainloop);
+
+    // We create a simple event loop to allow the glib loop
+    // to iterate until we've connected or not to the server.
+    s_connectionEventloop = new QEventLoop;
+
+    // XXX I don't want to show up in the client list. All I want to know is the list of sources
+    // and sinks...
+    s_context = pa_context_new(api, "libphonon");
+    // (cg) Convert to PA_CONTEXT_NOFLAGS when PulseAudio 0.9.19 is required
+    if (pa_context_connect(s_context, NULL, static_cast<pa_context_flags_t>(0), 0) >= 0) {
+        pa_context_set_state_callback(s_context, &context_state_callback, s_connectionEventloop);
+        // Now we block until we connect or otherwise...
+        logMessage("Entering connection eventloop...");
+        s_connectionEventloop->exec();
+    }
+#endif
+}
+
+PulseSupport::~PulseSupport()
+{
+#ifdef HAVE_PULSEAUDIO
+    if (s_context) {
+        pa_context_disconnect(s_context);
+        s_context = NULL;
+    }
+
+    if (s_mainloop) {
+        pa_glib_mainloop_free(s_mainloop);
+        s_mainloop = NULL;
+    }
+
+    if (s_connectionEventloop) {
+        delete s_connectionEventloop;
+        s_connectionEventloop = NULL;
+    }
+#endif
+}
+
+bool PulseSupport::isActive()
+{
+#ifdef HAVE_PULSEAUDIO
+    return s_pulseActive;
+#else
+    return false;
+#endif
+}
+
+void PulseSupport::disable()
+{
+#ifdef HAVE_PULSEAUDIO
+    s_pulseActive = false;
+#endif
+}
+
+QList<int> PulseSupport::objectDescriptionIndexes(ObjectDescriptionType type) const
+{
+    QList<int> list;
+
+    if (type != AudioOutputDeviceType && type != AudioCaptureDeviceType)
+        return list;
+
+#ifdef HAVE_PULSEAUDIO
+    if (s_pulseActive) {
+        switch (type) {
+
+            case AudioOutputDeviceType: {
+                QMap<QString, int>::iterator it;
+                for (it = s_outputDeviceIndexes.begin(); it != s_outputDeviceIndexes.end(); ++it) {
+                    list.append(*it);
+                }
+                break;
+            }
+            case AudioCaptureDeviceType: {
+                QMap<QString, int>::iterator it;
+                for (it = s_captureDeviceIndexes.begin(); it != s_captureDeviceIndexes.end(); ++it) {
+                    list.append(*it);
+                }
+                break;
+            }
+            default:
+                break;
+        }
+    }
+#endif
+
+    return list;
+}
+
+QHash<QByteArray, QVariant> PulseSupport::objectDescriptionProperties(ObjectDescriptionType type, int index) const
+{
+    QHash<QByteArray, QVariant> ret;
+
+    if (type != AudioOutputDeviceType && type != AudioCaptureDeviceType)
+        return ret;
+
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(index);
+#else
+    if (s_pulseActive) {
+        switch (type) {
+
+            case AudioOutputDeviceType:
+                Q_ASSERT(s_outputDevices.contains(index));
+                ret = s_outputDevices[index].properties;
+                break;
+
+            case AudioCaptureDeviceType:
+                Q_ASSERT(s_captureDevices.contains(index));
+                ret = s_captureDevices[index].properties;
+                break;
+
+            default:
+                break;
+        }
+    }
+#endif
+
+    return ret;
+}
+
+QList<int> PulseSupport::objectIndexesByCategory(ObjectDescriptionType type, Category category) const
+{
+    QList<int> ret;
+
+    if (type != AudioOutputDeviceType && type != AudioCaptureDeviceType)
+        return ret;
+
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(category);
+#else
+    if (s_pulseActive) {
+        switch (type) {
+
+            case AudioOutputDeviceType:
+                if (s_outputDevicePriorities.contains(category))
+                    ret = s_outputDevicePriorities[category].values();
+                break;
+
+            case AudioCaptureDeviceType:
+                if (s_captureDevicePriorities.contains(category))
+                    ret = s_captureDevicePriorities[category].values();
+                break;
+
+            default:
+                break;
+        }
+    }
+#endif
+
+    return ret;
+}
+
+#ifdef HAVE_PULSEAUDIO
+static void setDevicePriority(Category category, QStringList list)
+{
+    QString role = s_roleCategoryMap.key(category);
+    if (role.isEmpty())
+        return;
+
+    logMessage(QString("Reindexing %1: %2").arg(role).arg(list.join(", ")));
+
+    char **devices;
+    devices = pa_xnew(char *, list.size()+1);
+    int i = 0;
+    foreach (QString str, list) {
+        devices[i++] = pa_xstrdup(str.toUtf8().constData());
+    }
+    devices[list.size()] = NULL;
+
+#ifdef HAVE_PULSEAUDIO_DEVICE_MANAGER 
+    pa_operation *o;
+    if (!(o = pa_ext_device_manager_reorder_devices_for_role(s_context, role.toUtf8().constData(), (const char**)devices, NULL, NULL)))
+        logMessage(QString("pa_ext_device_manager_reorder_devices_for_role() failed"));
+    else
+        pa_operation_unref(o);
+#endif
+
+    for (i = 0; i < list.size(); ++i)
+        pa_xfree(devices[i]);
+    pa_xfree(devices);
+}
+#endif
+
+void PulseSupport::setOutputDevicePriorityForCategory(Category category, QList<int> order)
+{
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(category);
+    Q_UNUSED(order);
+#else
+    QStringList list;
+    QList<int>::iterator it;
+
+    for (it = order.begin(); it != order.end(); ++it) {
+        if (s_outputDevices.contains(*it)) {
+            list << s_outputDeviceIndexes.key(*it);
+        }
+    }
+    setDevicePriority(category, list);
+#endif
+}
+
+void PulseSupport::setCaptureDevicePriorityForCategory(Category category, QList<int> order)
+{
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(category);
+    Q_UNUSED(order);
+#else
+    QStringList list;
+    QList<int>::iterator it;
+
+    for (it = order.begin(); it != order.end(); ++it) {
+        if (s_captureDevices.contains(*it)) {
+            list << s_captureDeviceIndexes.key(*it);
+        }
+    }
+    setDevicePriority(category, list);
+#endif
+}
+
+void PulseSupport::setStreamPropList(Category category, QString streamUuid)
+{
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(category);
+    Q_UNUSED(streamUuid);
+#else
+    QString role = s_roleCategoryMap.key(category);
+    if (role.isEmpty())
+        return;
+
+    logMessage(QString("Setting role to %1 for streamindex %2").arg(role).arg(streamUuid));
+    setenv("PULSE_PROP_media.role", role.toLatin1().constData(), 1);
+    setenv("PULSE_PROP_phonon.streamid", streamUuid.toLatin1().constData(), 1);
+#endif
+}
+
+void PulseSupport::emitObjectDescriptionChanged(ObjectDescriptionType type)
+{
+    emit objectDescriptionChanged(type);
+}
+
+bool PulseSupport::setOutputDevice(QString streamUuid, int device) {
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(streamUuid);
+    Q_UNUSED(device);
+    return false;
+#else
+    if (s_outputDevices.size() < 2)
+        return true;
+
+    if (!s_outputDevices.contains(device)) {
+        logMessage(QString("Attempting to set Output Device for invalid device id %1.").arg(device));
+        return false;
+    }
+    const QVariant var = s_outputDevices[device].properties["name"];
+    logMessage(QString("Attempting to set Output Device to '%1' for Output Stream %2").arg(var.toString()).arg(streamUuid));
+
+    s_outputStreamMoveQueue[streamUuid] = device;
+    // Attempt to look up the pulse stream index.
+    if (s_outputStreamIndexMap.contains(streamUuid) && s_outputStreamIndexMap[streamUuid] != PA_INVALID_INDEX) {
+        logMessage(QString("... Found in map. Moving now"));
+        set_output_device(streamUuid);
+    } else {
+        logMessage(QString("... Not found in map. Saving move for when the stream appears"));
+    }
+    return true;
+#endif
+}
+
+bool PulseSupport::setCaptureDevice(QString streamUuid, int device) {
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(streamUuid);
+    Q_UNUSED(device);
+    return false;
+#else
+    if (s_captureDevices.size() < 2)
+        return true;
+
+    if (!s_captureDevices.contains(device)) {
+        logMessage(QString("Attempting to set Capture Device for invalid device id %1.").arg(device));
+        return false;
+    }
+    const QVariant var = s_captureDevices[device].properties["name"];
+    logMessage(QString("Attempting to set Capture Device to '%1' for Capture Stream %2").arg(var.toString()).arg(streamUuid));
+
+    s_captureStreamMoveQueue[streamUuid] = device;
+    // Attempt to look up the pulse stream index.
+    if (s_captureStreamIndexMap.contains(streamUuid) && s_captureStreamIndexMap[streamUuid] == PA_INVALID_INDEX) {
+        logMessage(QString("... Found in map. Moving now"));
+        set_capture_device(streamUuid);
+    } else {
+        logMessage(QString("... Not found in map. Saving move for when the stream appears"));
+    }
+    return true;
+#endif
+}
+
+void PulseSupport::clearStreamCache(QString streamUuid) {
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(streamUuid);
+    return;
+#else
+    logMessage(QString("Clearing stream cache for stream %1").arg(streamUuid));
+    s_outputStreamIndexMap.remove(streamUuid);
+    s_outputStreamMoveQueue.remove(streamUuid);
+    s_captureStreamIndexMap.remove(streamUuid);
+    s_captureStreamMoveQueue.remove(streamUuid);
+#endif
+}
+
+} // namespace Phonon
+
+QT_END_NAMESPACE
+
+#include "moc_pulsesupport.cpp"
+
+// vim: sw=4 ts=4
diff --git a/src/3rdparty/phonon/phonon/pulsesupport.h b/src/3rdparty/phonon/phonon/pulsesupport.h
new file mode 100644
index 0000000..ad711ed
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/pulsesupport.h
@@ -0,0 +1,73 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2009 Colin Guthrie <cguthrie@mandriva.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public 
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef PHONON_PULSESUPPORT_H
+#define PHONON_PULSESUPPORT_H
+
+#include "phonon_export.h"
+#include "phononnamespace.h"
+#include "objectdescription.h"
+
+#include <QtCore/QtGlobal>
+#include <QtCore/QSet>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+    class PHONON_EXPORT PulseSupport : public QObject
+    {
+        Q_OBJECT
+        public:
+            static PulseSupport* getInstance();
+            static void shutdown();
+
+            bool isActive();
+            void disable();
+
+            QList<int> objectDescriptionIndexes(ObjectDescriptionType type) const;
+            QHash<QByteArray, QVariant> objectDescriptionProperties(ObjectDescriptionType type, int index) const;
+            QList<int> objectIndexesByCategory(ObjectDescriptionType type, Category category) const;
+
+            void setOutputDevicePriorityForCategory(Category category, QList<int> order);
+            void setCaptureDevicePriorityForCategory(Category category, QList<int> order);
+
+            void setStreamPropList(Category category, QString streamUuid);
+            void emitObjectDescriptionChanged(ObjectDescriptionType);
+
+            bool setOutputDevice(QString streamUuid, int device);
+            bool setCaptureDevice(QString streamUuid, int device);
+            void clearStreamCache(QString streamUuid);
+
+        signals:
+            void objectDescriptionChanged(ObjectDescriptionType);
+        private:
+            PulseSupport();
+            ~PulseSupport();
+    };
+} // namespace Phonon
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // PHONON_PULSESUPPORT_H
diff --git a/src/3rdparty/phonon/phonon/qsettingsgroup_p.h b/src/3rdparty/phonon/phonon/qsettingsgroup_p.h
index f28ecaa..ac7ca8d 100644
--- a/src/3rdparty/phonon/phonon/qsettingsgroup_p.h
+++ b/src/3rdparty/phonon/phonon/qsettingsgroup_p.h
@@ -27,8 +27,6 @@
 #include <QtCore/QString>
 #include <QtCore/QVariant>
 
-#ifndef QT_NO_PHONON_SETTINGSGROUP
-
 QT_BEGIN_HEADER
 QT_BEGIN_NAMESPACE
 
@@ -89,6 +87,5 @@ class QSettingsGroup
 
 QT_END_NAMESPACE
 QT_END_HEADER
-#endif //QT_NO_PHONON_SETTINGSGROUP
 
 #endif // PHONON_QSETTINGSGROUP_P_H
diff --git a/src/3rdparty/phonon/phonon/seekslider.cpp b/src/3rdparty/phonon/phonon/seekslider.cpp
index 41baf2d..b5b25f0 100644
--- a/src/3rdparty/phonon/phonon/seekslider.cpp
+++ b/src/3rdparty/phonon/phonon/seekslider.cpp
@@ -72,12 +72,12 @@ void SeekSlider::setMediaObject(MediaObject *media)
     d->media = media;
 
     if (media) {
-        connect(media, SIGNAL(stateChanged(Phonon::State,Phonon::State)),
+        connect(media, SIGNAL(stateChanged(Phonon::State, Phonon::State)),
                 SLOT(_k_stateChanged(Phonon::State)));
         connect(media, SIGNAL(totalTimeChanged(qint64)), SLOT(_k_length(qint64)));
         connect(media, SIGNAL(tick(qint64)), SLOT(_k_tick(qint64)));
         connect(media, SIGNAL(seekableChanged(bool)), SLOT(_k_seekableChanged(bool)));
-        connect(media, SIGNAL(currentSourceChanged(Phonon::MediaSource)), SLOT(_k_currentSourceChanged()));
+        connect(media, SIGNAL(currentSourceChanged(const Phonon::MediaSource&)), SLOT(_k_currentSourceChanged()));
         d->_k_stateChanged(media->state());
         d->_k_seekableChanged(media->isSeekable());
         d->_k_length(media->totalTime());
diff --git a/src/3rdparty/phonon/phonon/seekslider_p.h b/src/3rdparty/phonon/phonon/seekslider_p.h
index c87a4b0..911ab25 100644
--- a/src/3rdparty/phonon/phonon/seekslider_p.h
+++ b/src/3rdparty/phonon/phonon/seekslider_p.h
@@ -24,8 +24,8 @@
 #define SEEKSLIDER_P_H
 
 #include "seekslider.h"
+#include "swiftslider_p.h"
 #include <QtGui/QBoxLayout>
-#include <QtGui/QSlider>
 #include <QtGui/QLabel>
 #include <QtGui/QPixmap>
 #include <QtGui/QIcon>
@@ -84,7 +84,7 @@ class SeekSliderPrivate
         void _k_currentSourceChanged();
 
         QBoxLayout layout;
-        QSlider slider;
+        SwiftSlider slider;
         QLabel iconLabel;
         QPointer<MediaObject> media;
         bool ticking;
diff --git a/src/3rdparty/phonon/phonon/swiftslider.cpp b/src/3rdparty/phonon/phonon/swiftslider.cpp
new file mode 100644
index 0000000..1e274aa
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/swiftslider.cpp
@@ -0,0 +1,103 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006-2008 Ricardo Villalba <rvm@escomposlinux.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "swiftslider_p.h"
+
+#include <QtGui/QMouseEvent>
+#include <QtGui/QStyle>
+#include <QtGui/QStyleOption>
+
+QT_BEGIN_NAMESPACE
+
+#if !defined(QT_NO_PHONON_SEEKSLIDER) && !defined(QT_NO_PHONON_VOLUMESLIDER)
+
+namespace Phonon
+{
+
+SwiftSlider::SwiftSlider(Qt::Orientation orientation, QWidget * parent)
+	: QSlider(orientation, parent)
+{
+}
+
+SwiftSlider::~SwiftSlider()
+{
+}
+
+// Function copied from qslider.cpp
+inline int SwiftSlider::pick(const QPoint &pt) const
+{
+    return orientation() == Qt::Horizontal ? pt.x() : pt.y();
+}
+
+// Function copied from qslider.cpp and modified to make it compile
+int SwiftSlider::pixelPosToRangeValue(int pos) const
+{
+    QStyleOptionSlider opt;
+    initStyleOption(&opt);
+    QRect gr = style()->subControlRect(QStyle::CC_Slider, &opt, QStyle::SC_SliderGroove, this);
+    QRect sr = style()->subControlRect(QStyle::CC_Slider, &opt, QStyle::SC_SliderHandle, this);
+    int sliderMin, sliderMax, sliderLength;
+
+    if (orientation() == Qt::Horizontal) {
+        sliderLength = sr.width();
+        sliderMin = gr.x();
+        sliderMax = gr.right() - sliderLength + 1;
+    } else {
+        sliderLength = sr.height();
+        sliderMin = gr.y();
+        sliderMax = gr.bottom() - sliderLength + 1;
+    }
+    return QStyle::sliderValueFromPosition(minimum(), maximum(), pos - sliderMin,
+                                           sliderMax - sliderMin, opt.upsideDown);
+}
+
+// Based on code from qslider.cpp
+void SwiftSlider::mousePressEvent(QMouseEvent *event)
+{
+    if (event->button() == Qt::LeftButton) {
+        QStyleOptionSlider opt;
+        initStyleOption(&opt);
+        const QRect sliderRect = style()->subControlRect(QStyle::CC_Slider, &opt, QStyle::SC_SliderHandle, this);
+        const QPoint center = sliderRect.center() - sliderRect.topLeft();
+        // to take half of the slider off for the setSliderPosition call we use the center - topLeft
+
+        if (!sliderRect.contains(event->pos())) {
+            event->accept();
+
+            setSliderPosition(pixelPosToRangeValue(pick(event->pos() - center)));
+            triggerAction(SliderMove);
+            setRepeatAction(SliderNoAction);
+        } else {
+            QSlider::mousePressEvent(event);
+        }
+    } else {
+        QSlider::mousePressEvent(event);
+    }
+}
+
+} // namespace Phonon
+
+#endif //QT_NO_PHONON_VOLUMESLIDER && QT_NO_PHONON_VOLUMESLIDER
+
+QT_END_NAMESPACE
+
+#include "moc_swiftslider_p.cpp"
diff --git a/src/3rdparty/phonon/phonon/swiftslider_p.h b/src/3rdparty/phonon/phonon/swiftslider_p.h
new file mode 100644
index 0000000..f1e9c88
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/swiftslider_p.h
@@ -0,0 +1,68 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006-2008 Ricardo Villalba <rvm@escomposlinux.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef SWIFTSLIDER_H
+#define SWIFTSLIDER_H
+
+#include <QtGui/QSlider>
+
+QT_BEGIN_NAMESPACE
+
+#if !defined(QT_NO_PHONON_SEEKSLIDER) && !defined(QT_NO_PHONON_VOLUMESLIDER)
+
+namespace Phonon
+{
+
+/** \class SwiftSlider swiftslider_p.h Phonon/SwiftSlider
+ * \short Modified QSlider that allows sudden/quick moves instead of stepped moves ("Click'n'Go" QSlider)
+ *
+ * This is an internal class used by SeekSlider and VolumeSlider.
+ *
+ * Ricardo Villalba, the original author of MySlider.cpp (from the SMPlayer project)
+ * gave his permission for the inclusion of this code inside Phonon by
+ * switching MySlider.cpp to the LGPLv2.1+ license.
+ * See http://smplayer.svn.sourceforge.net/viewvc/smplayer/smplayer/trunk/src/myslider.cpp?revision=2406&view=markup
+ *
+ * The original discussion about a "Click'n'Go QSlider": http://lists.trolltech.com/qt-interest/2006-11/msg00363.html
+ *
+ * \ingroup PhononWidgets
+ */
+class SwiftSlider : public QSlider
+{
+	Q_OBJECT
+public:
+	SwiftSlider(Qt::Orientation orientation, QWidget * parent);
+	~SwiftSlider();
+
+private:
+	void mousePressEvent(QMouseEvent *event);
+	inline int pick(const QPoint &pt) const;
+	int pixelPosToRangeValue(int pos) const;
+};
+
+} // namespace Phonon
+
+#endif //QT_NO_PHONON_VOLUMESLIDER && QT_NO_PHONON_VOLUMESLIDER
+
+QT_END_NAMESPACE
+
+#endif //SWIFTSLIDER_H
diff --git a/src/3rdparty/phonon/phonon/videowidget.cpp b/src/3rdparty/phonon/phonon/videowidget.cpp
index a9e83a6..4575dfd 100644
--- a/src/3rdparty/phonon/phonon/videowidget.cpp
+++ b/src/3rdparty/phonon/phonon/videowidget.cpp
@@ -28,8 +28,9 @@
 #include "phononnamespace_p.h"
 
 #include <QtGui/QAction>
-
-#define PHONON_INTERFACENAME VideoWidgetInterface
+#define IFACES4 VideoWidgetInterface44
+#define IFACES0 VideoWidgetInterface, IFACES4
+#define PHONON_INTERFACENAME IFACES0
 
 QT_BEGIN_NAMESPACE
 
@@ -48,6 +49,8 @@ VideoWidget::VideoWidget(QWidget *parent)
     setMouseTracking(true);
 }
 
+
+
 VideoWidget::VideoWidget(VideoWidgetPrivate &dd, QWidget *parent)
     : QWidget(parent),
     Phonon::AbstractVideoOutput(dd)
@@ -98,6 +101,15 @@ PHONON_INTERFACE_SETTER(setHue, hue, qreal)
 PHONON_INTERFACE_GETTER(qreal, saturation, d->saturation)
 PHONON_INTERFACE_SETTER(setSaturation, saturation, qreal)
 
+
+QImage VideoWidget::snapshot() const {
+    K_D(const VideoWidget);
+    ConstIface<IFACES4> iface(d);
+    if(iface) return iface->snapshot();
+    return QImage(); // TODO not implemented in VideoInterface
+}
+
+
 void VideoWidget::setFullScreen(bool newFullScreen)
 {
     pDebug() << Q_FUNC_INFO << newFullScreen;
diff --git a/src/3rdparty/phonon/phonon/videowidget.h b/src/3rdparty/phonon/phonon/videowidget.h
index 1d95490..804e61a 100644
--- a/src/3rdparty/phonon/phonon/videowidget.h
+++ b/src/3rdparty/phonon/phonon/videowidget.h
@@ -172,6 +172,7 @@ class AbstractVideoOutput;
             qreal contrast() const;
             qreal hue() const;
             qreal saturation() const;
+            QImage snapshot() const;
 
             //TODO: bar colors property
         public Q_SLOTS:
diff --git a/src/3rdparty/phonon/phonon/videowidgetinterface.h b/src/3rdparty/phonon/phonon/videowidgetinterface.h
index 3e6fd22..0c33956 100644
--- a/src/3rdparty/phonon/phonon/videowidgetinterface.h
+++ b/src/3rdparty/phonon/phonon/videowidgetinterface.h
@@ -53,8 +53,21 @@ class VideoWidgetInterface
 //X        virtual int overlayCapabilities() const = 0;
 //X        virtual bool createOverlay(QWidget *widget, int type) = 0;
 };
+
+class VideoWidgetInterface44 : public VideoWidgetInterface
+{
+    public:
+        virtual QImage snapshot() const = 0;
+};
 }
 
+#ifdef PHONON_BACKEND_VERSION_4_4
+namespace Phonon { typedef VideoWidgetInterface44 VideoWidgetInterfaceLatest; }
+#else
+namespace Phonon { typedef VideoWidgetInterface VideoWidgetInterfaceLatest; }
+#endif
+
+Q_DECLARE_INTERFACE(Phonon::VideoWidgetInterface44, "VideoWidgetInterface44.phonon.kde.org")
 Q_DECLARE_INTERFACE(Phonon::VideoWidgetInterface, "VideoWidgetInterface3.phonon.kde.org")
 
 #endif //QT_NO_PHONON_VIDEO
diff --git a/src/3rdparty/phonon/phonon/volumeslider.cpp b/src/3rdparty/phonon/phonon/volumeslider.cpp
index 00970c1..923f8d0 100644
--- a/src/3rdparty/phonon/phonon/volumeslider.cpp
+++ b/src/3rdparty/phonon/phonon/volumeslider.cpp
@@ -85,7 +85,7 @@ VolumeSlider::~VolumeSlider()
 
 bool VolumeSlider::isMuteVisible() const
 {
-    return !k_ptr->muteButton.isHidden();
+    return k_ptr->muteButton.isVisible();
 }
 
 void VolumeSlider::setMuteVisible(bool visible)
diff --git a/src/3rdparty/phonon/phonon/volumeslider_p.h b/src/3rdparty/phonon/phonon/volumeslider_p.h
index 3827659..623275f 100644
--- a/src/3rdparty/phonon/phonon/volumeslider_p.h
+++ b/src/3rdparty/phonon/phonon/volumeslider_p.h
@@ -24,8 +24,8 @@
 #define VOLUMESLIDER_P_H
 
 #include "volumeslider.h"
+#include "swiftslider_p.h"
 #include <QtGui/QBoxLayout>
-#include <QtGui/QSlider>
 #include <QtGui/QLabel>
 #include <QtGui/QPixmap>
 #include <QtGui/QToolButton>
@@ -83,7 +83,7 @@ class VolumeSliderPrivate
 
     private:
         QBoxLayout layout;
-        QSlider slider;
+        SwiftSlider slider;
         QToolButton muteButton;
         QIcon volumeIcon;
         QIcon mutedIcon;
diff --git a/src/3rdparty/phonon/qt7/audionode.h b/src/3rdparty/phonon/qt7/audionode.h
index 2498e49..dfec817 100644
--- a/src/3rdparty/phonon/qt7/audionode.h
+++ b/src/3rdparty/phonon/qt7/audionode.h
@@ -72,7 +72,7 @@ namespace QT7
             AudioUnit m_audioUnit;
 
             // Only the following methods needs to
-            // be overidden by only_one-audio-unit nodes:
+            // be overridden by only_one-audio-unit nodes:
             virtual ComponentDescription getAudioNodeDescription() const;
             virtual void initializeAudioUnit();
 
diff --git a/src/3rdparty/phonon/qt7/audionode.mm b/src/3rdparty/phonon/qt7/audionode.mm
index 961230c..cb9e82f 100644
--- a/src/3rdparty/phonon/qt7/audionode.mm
+++ b/src/3rdparty/phonon/qt7/audionode.mm
@@ -68,15 +68,13 @@ void AudioNode::createAndConnectAUNodes()
         << QString(!FindNextComponent(0, &description) ? "ERROR: COMPONENT NOT FOUND!" : "OK!"))
 
     OSStatus err = noErr;
-
-    // The proper function to call here is AUGraphAddNode() but the type has
-    // changed between 10.5 and 10.6. it's still OK to call this function, but
-    // if we want to use the proper thing we need to move over to
-    // AudioComponentDescription everywhere, which is very similar to the
-    // ComponentDescription, but a different size.  however,
-    // AudioComponentDescription only exists on 10.6+. More fun than we need to
-    // deal with at the moment, so we'll take the "deprecated" warning instead.
-    err = AUGraphNewNode(m_audioGraph->audioGraphRef(), &description, 0, 0, &m_auNode);
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
+    if (QSysInfo::MacintoshVersion >= QSysInfo::MV_10_5)
+        err = AUGraphAddNode(m_audioGraph->audioGraphRef(), &description, &m_auNode);
+    else
+#endif
+        err = AUGraphNewNode(m_audioGraph->audioGraphRef(), &description, 0, 0, &m_auNode);
+        
     BACKEND_ASSERT2(err != kAUGraphErr_OutputNodeErr, "A MediaObject can only be connected to one audio output device.", FATAL_ERROR)
     BACKEND_ASSERT2(err == noErr, "Could not create new AUNode.", FATAL_ERROR)
 }
diff --git a/src/3rdparty/phonon/qt7/backend.mm b/src/3rdparty/phonon/qt7/backend.mm
index b3ca106..327ddd7 100644
--- a/src/3rdparty/phonon/qt7/backend.mm
+++ b/src/3rdparty/phonon/qt7/backend.mm
@@ -59,7 +59,7 @@ Backend::Backend(QObject *parent, const QStringList &) : QObject(parent)
     setProperty("backendComment", QLatin1String("Developed by Trolltech"));
     setProperty("backendVersion", QLatin1String("0.1"));
     setProperty("backendIcon",    QLatin1String(""));
-    setProperty("backendWebsite", QLatin1String("http://qt.nokia.com/"));
+    setProperty("backendWebsite", QLatin1String("http://qtsoftware.com/"));
 }
 
 Backend::~Backend()
diff --git a/src/3rdparty/phonon/qt7/backendinfo.mm b/src/3rdparty/phonon/qt7/backendinfo.mm
index 0d51db0..938359c 100644
--- a/src/3rdparty/phonon/qt7/backendinfo.mm
+++ b/src/3rdparty/phonon/qt7/backendinfo.mm
@@ -22,7 +22,7 @@
 #include <AudioUnit/AudioUnit.h>
 #include <CoreServices/CoreServices.h>
 
-#include <QtGui/qmacdefines_mac.h>
+#undef slots
 #import <QTKit/QTMovie.h>
 
 #ifdef QUICKTIME_C_API_AVAILABLE
diff --git a/src/3rdparty/phonon/qt7/mediaobject.h b/src/3rdparty/phonon/qt7/mediaobject.h
index c93eddc..27949ec 100644
--- a/src/3rdparty/phonon/qt7/mediaobject.h
+++ b/src/3rdparty/phonon/qt7/mediaobject.h
@@ -25,10 +25,6 @@
 
 #include "medianode.h"
 
-#if QT_ALLOW_QUICKTIME
-    #include <QuickTime/QuickTime.h>
-#endif
-
 QT_BEGIN_NAMESPACE
 
 namespace Phonon
@@ -42,10 +38,7 @@ namespace QT7
     class MediaObjectAudioNode;
 
     class MediaObject : public MediaNode,
-        public Phonon::MediaObjectInterface
-#ifndef QT_NO_PHONON_MEDIACONTROLLER
-        , public Phonon::AddonInterface
-#endif
+        public Phonon::MediaObjectInterface, public Phonon::AddonInterface
     {
         Q_OBJECT
         Q_INTERFACES(Phonon::MediaObjectInterface Phonon::AddonInterface)
@@ -99,10 +92,6 @@ namespace QT7
 
 		int videoOutputCount();
 
-#if QT_ALLOW_QUICKTIME
-        void displayLinkEvent();
-#endif
-
     signals:
         void stateChanged(Phonon::State,Phonon::State);
         void tick(qint64);
@@ -116,16 +105,6 @@ namespace QT7
         void metaDataChanged(QMultiMap<QString,QString>);
         void currentSourceChanged(const MediaSource &newSource);
 
-        // Add-on interface:
-        void availableSubtitlesChanged();
-        void availableAudioChannelsChanged();
-        void titleChanged(int);
-        void availableTitlesChanged(int);
-        void chapterChanged(int);
-        void availableChaptersChanged(int);
-        void angleChanged(int);
-        void availableAnglesChanged(int);
-
     protected:
         void mediaNodeEvent(const MediaNodeEvent *event);
         bool event(QEvent *event);
@@ -139,14 +118,7 @@ namespace QT7
         QuickTimeVideoPlayer *m_nextVideoPlayer;
         QuickTimeAudioPlayer *m_nextAudioPlayer;
         MediaObjectAudioNode *m_mediaObjectAudioNode;
-
-#if QT_ALLOW_QUICKTIME
-        CVDisplayLinkRef m_displayLink;
-        QMutex m_displayLinkMutex;
-        bool m_pendingDisplayLinkEvent;
-        void startDisplayLink();
-        void stopDisplayLink();
-#endif
+        QuickTimeMetaData *m_metaData;
 
         qint32 m_tickInterval;
         qint32 m_transitionTime;
@@ -155,14 +127,12 @@ namespace QT7
         float m_percentageLoaded;
 
         int m_tickTimer;
-        int m_videoTimer;
-        int m_audioTimer;
+        int m_bufferTimer;
         int m_rapidTimer;
 
         bool m_waitNextSwap;
         int m_swapTimeLeft;
         QTime m_swapTime;
-        bool m_autoplayTitles;
 
         void synchAudioVideo();
         void updateCurrentTime();
@@ -171,7 +141,8 @@ namespace QT7
         void pause_internal();
         void play_internal();
         void setupAudioSystem();
-        void restartAudioVideoTimers();
+        void updateTimer(int &timer, int interval);
+        void bufferAudioVideo();
         void updateRapidly();
         void updateCrossFade();
         void updateAudioBuffers();
@@ -183,7 +154,6 @@ namespace QT7
 		void inspectVideoGraphRecursive(MediaNode *node, int &effectCount, int &outputCount);
         void inspectGraph();
         bool isCrossFading();
-        void setCurrentTrack(int track);
 
         QString m_errorString;
         Phonon::ErrorType m_errorType;
diff --git a/src/3rdparty/phonon/qt7/mediaobject.mm b/src/3rdparty/phonon/qt7/mediaobject.mm
index 677640c..002c337 100644
--- a/src/3rdparty/phonon/qt7/mediaobject.mm
+++ b/src/3rdparty/phonon/qt7/mediaobject.mm
@@ -46,6 +46,7 @@ MediaObject::MediaObject(QObject *parent) : MediaNode(AudioSource | VideoSource,
     m_mediaObjectAudioNode = new MediaObjectAudioNode(m_audioPlayer, m_nextAudioPlayer);
     setAudioNode(m_mediaObjectAudioNode);
 
+    m_metaData = new QuickTimeMetaData();
     m_audioGraph = new AudioGraph(this);
 
     m_tickInterval = 0;
@@ -54,7 +55,6 @@ MediaObject::MediaObject(QObject *parent) : MediaNode(AudioSource | VideoSource,
     m_transitionTime = 0;
     m_percentageLoaded = 0;
     m_waitNextSwap = false;
-    m_autoplayTitles = true;
     m_audioEffectCount = 0;
     m_audioOutputCount = 0;
     m_videoEffectCount = 0;
@@ -63,28 +63,20 @@ MediaObject::MediaObject(QObject *parent) : MediaNode(AudioSource | VideoSource,
     m_errorType = Phonon::NoError;
 
     m_tickTimer = 0;
-    m_videoTimer = 0;
-    m_audioTimer = 0;
+    m_bufferTimer = 0;
     m_rapidTimer = 0;
 
-#if QT_ALLOW_QUICKTIME
-    m_displayLink = 0;
-    m_pendingDisplayLinkEvent = false;
-#endif
-
     checkForError();
 }
 
 MediaObject::~MediaObject()
-{
-    // m_mediaObjectAudioNode is owned by super class.
-#if QT_ALLOW_QUICKTIME
-    stopDisplayLink();
-#endif
+{   
+    // m_mediaObjectAudioNode is owned by super class.    
     m_audioPlayer->unsetVideoPlayer();
     m_nextAudioPlayer->unsetVideoPlayer();
     delete m_videoPlayer;
     delete m_nextVideoPlayer;
+    delete m_metaData;
     checkForError();
 }
 
@@ -96,7 +88,7 @@ bool MediaObject::setState(Phonon::State state)
         emit stateChanged(m_state, prevState);
         if (m_state != state){
             // End-application did something
-            // upon  receiving the signal.
+            // upon  receiving the signal. 
             return false;
         }
     }
@@ -130,7 +122,7 @@ void MediaObject::inspectGraph()
     // Inspect the graph to check wether there are any
     // effects or outputs connected. This will have
     // influence on the audio system and video system that ends up beeing used:
-    int prevVideoOutputCount = m_videoOutputCount;
+    int prevVideoOutputCount = m_videoOutputCount;	
     m_audioEffectCount = 0;
     m_audioOutputCount = 0;
     m_videoEffectCount = 0;
@@ -142,7 +134,7 @@ void MediaObject::inspectGraph()
 	if (m_videoOutputCount != prevVideoOutputCount){
 	    MediaNodeEvent e1(MediaNodeEvent::VideoOutputCountChanged, &m_videoOutputCount);
 	    notify(&e1);
-    }
+	}	
 }
 
 void MediaObject::setupAudioSystem()
@@ -175,14 +167,14 @@ void MediaObject::setupAudioSystem()
 
     if (newAudioSystem == m_audioSystem)
         return;
-
+  
     // Enable selected audio system:
-    m_audioSystem = newAudioSystem;
+    m_audioSystem = newAudioSystem; 
     switch (newAudioSystem){
         case AS_Silent:
             m_audioGraph->stop();
             m_videoPlayer->enableAudio(false);
-            m_nextVideoPlayer->enableAudio(false);
+            m_nextVideoPlayer->enableAudio(false);    
             m_audioPlayer->enableAudio(false);
             m_nextAudioPlayer->enableAudio(false);
         break;
@@ -222,28 +214,28 @@ void MediaObject::setSource(const MediaSource &source)
     IMPLEMENTED;
 	PhononAutoReleasePool pool;
     setState(Phonon::LoadingState);
-
+    
     // Save current state for event/signal handling below:
     bool prevHasVideo = m_videoPlayer->hasVideo();
     qint64 prevTotalTime = totalTime();
-    int prevTrackCount = m_videoPlayer->trackCount();
     m_waitNextSwap = false;
-
+        
     // Cancel cross-fade if any:
     m_nextVideoPlayer->pause();
     m_nextAudioPlayer->pause();
     m_mediaObjectAudioNode->cancelCrossFade();
-
+    
     // Set new source:
     m_audioPlayer->unsetVideoPlayer();
     m_videoPlayer->setMediaSource(source);
     m_audioPlayer->setVideoPlayer(m_videoPlayer);
+    m_metaData->setVideo(m_videoPlayer);        
 
-    m_audioGraph->updateStreamSpecifications();
+    m_audioGraph->updateStreamSpecifications();        
     m_nextAudioPlayer->unsetVideoPlayer();
-    m_nextVideoPlayer->unsetCurrentMediaSource();
+    m_nextVideoPlayer->unsetVideo();
     m_currentTime = 0;
-
+        
     // Emit/notify information about the new source:
     QRect videoRect = m_videoPlayer->videoRect();
     MediaNodeEvent e1(MediaNodeEvent::VideoFrameSizeChanged, &videoRect);
@@ -254,14 +246,12 @@ void MediaObject::setSource(const MediaSource &source)
     updateVideo(emptyFrame);
 
     emit currentSourceChanged(source);
-    emit metaDataChanged(m_videoPlayer->metaData());
+    emit metaDataChanged(m_metaData->metaData());
 
     if (prevHasVideo != m_videoPlayer->hasVideo())
-        emit hasVideoChanged(m_videoPlayer->hasVideo());
+        emit hasVideoChanged(m_videoPlayer->hasVideo());        
     if (prevTotalTime != totalTime())
-        emit totalTimeChanged(totalTime());
-    if (prevTrackCount != m_videoPlayer->trackCount())
-        emit availableTitlesChanged(m_videoPlayer->trackCount());
+        emit totalTimeChanged(totalTime());        
     if (checkForError())
         return;
     if (!m_videoPlayer->isDrmAuthorized())
@@ -270,7 +260,7 @@ void MediaObject::setSource(const MediaSource &source)
         return;
     if (!m_videoPlayer->canPlayMedia())
         SET_ERROR("Cannot play media.", FATAL_ERROR)
-
+        
     // The state might have changed from LoadingState
     // as a response to an error state change. So we
     // need to check it before stopping: 
@@ -297,30 +287,28 @@ void MediaObject::swapCurrentWithNext(qint32 transitionTime)
     // Save current state for event/signal handling below:
     bool prevHasVideo = m_videoPlayer->hasVideo();
     qint64 prevTotalTime = totalTime();
-    int prevTrackCount = m_videoPlayer->trackCount();
 
     qSwap(m_audioPlayer, m_nextAudioPlayer);
     qSwap(m_videoPlayer, m_nextVideoPlayer);
     m_mediaObjectAudioNode->startCrossFade(transitionTime);
     m_audioGraph->updateStreamSpecifications();
+    m_metaData->setVideo(m_videoPlayer);
 
     m_waitNextSwap = false;
     m_currentTime = 0;
-
+        
     // Emit/notify information about the new source:
     QRect videoRect = m_videoPlayer->videoRect();
     MediaNodeEvent e1(MediaNodeEvent::VideoFrameSizeChanged, &videoRect);
     notify(&e1);
 
     emit currentSourceChanged(m_videoPlayer->mediaSource());
-    emit metaDataChanged(m_videoPlayer->metaData());
+    emit metaDataChanged(m_metaData->metaData());
 
     if (prevHasVideo != m_videoPlayer->hasVideo())
-        emit hasVideoChanged(m_videoPlayer->hasVideo());
+        emit hasVideoChanged(m_videoPlayer->hasVideo());        
     if (prevTotalTime != totalTime())
         emit totalTimeChanged(totalTime());
-    if (prevTrackCount != m_videoPlayer->trackCount())
-        emit availableTitlesChanged(m_videoPlayer->trackCount());
     if (checkForError())
         return;
     if (!m_videoPlayer->isDrmAuthorized())
@@ -339,107 +327,28 @@ void MediaObject::swapCurrentWithNext(qint32 transitionTime)
     }
 }
 
-#if QT_ALLOW_QUICKTIME
-static CVReturn displayLinkCallback(CVDisplayLinkRef /*displayLink*/,
-								 const CVTimeStamp */*inNow*/,
-								 const CVTimeStamp */*inOutputTime*/,
-								 CVOptionFlags /*flagsIn*/,
-								 CVOptionFlags */*flagsOut*/,
-                                 void *userData)
-{
-    MediaObject *mediaObject = static_cast<MediaObject *>(userData);
-    mediaObject->displayLinkEvent();
-    return kCVReturnSuccess;
-}
-
-void MediaObject::displayLinkEvent()
-{
-    // This function is called from a
-    // thread != gui thread. So we post the event.
-    // But we need to make sure that we don't post faster
-    // than the event loop can eat:
-    m_displayLinkMutex.lock();
-    bool pending = m_pendingDisplayLinkEvent;
-    m_pendingDisplayLinkEvent = true;
-    m_displayLinkMutex.unlock();
-
-    if (!pending)
-        qApp->postEvent(this, new QEvent(QEvent::User), Qt::HighEventPriority);
-}
-
-void MediaObject::startDisplayLink()
+void MediaObject::updateTimer(int &timer, int interval)
 {
-    if (m_displayLink)
-        return;
-    OSStatus err = CVDisplayLinkCreateWithCGDisplay(kCGDirectMainDisplay, &m_displayLink);
-    if (err != noErr)
-        goto fail;
-    err = CVDisplayLinkSetCurrentCGDisplay(m_displayLink, kCGDirectMainDisplay);
-    if (err != noErr)
-        goto fail;
-    err = CVDisplayLinkSetOutputCallback(m_displayLink, displayLinkCallback, this);
-    if (err != noErr)
-        goto fail;
-    err = CVDisplayLinkStart(m_displayLink);
-    if (err != noErr)
-        goto fail;
-    return;
-fail:
-    stopDisplayLink();
-}
-
-void MediaObject::stopDisplayLink()
-{
-    if (!m_displayLink)
-        return;
-    CVDisplayLinkStop(m_displayLink);
-    CFRelease(m_displayLink);
-    m_displayLink = 0;
-}
-#endif
-
-void MediaObject::restartAudioVideoTimers()
-{
-    if (m_videoTimer)
-        killTimer(m_videoTimer);
-    if (m_audioTimer)
-        killTimer(m_audioTimer);
-
-#if QT_ALLOW_QUICKTIME
-    // We prefer to use a display link as timer if available, since
-    // it is more steady, and results in better and smoother frame drawing:
-    startDisplayLink();
-    if (!m_displayLink){
-        float fps = m_videoPlayer->staticFps();
-        long videoUpdateFrequency = fps ? long(1000.0f / fps) : 0.001;
-        m_videoTimer = startTimer(videoUpdateFrequency);
-    }
-#else
-    float fps = m_videoPlayer->staticFps();
-    long videoUpdateFrequency = fps ? long(1000.0f / fps) : 0.001;
-    m_videoTimer = startTimer(videoUpdateFrequency);
-#endif
-
-    long audioUpdateFrequency = m_audioPlayer->regularTaskFrequency();
-    m_audioTimer = startTimer(audioUpdateFrequency);
-    updateVideoFrames();
-    updateAudioBuffers();
+    if (timer)
+        killTimer(timer);
+    timer = 0;
+    if (interval >= 0)    
+        timer = startTimer(interval); 
 }
 
 void MediaObject::play_internal()
 {
     // Play main audio/video:
     m_videoPlayer->play();
-    m_audioPlayer->play();
+    m_audioPlayer->play();     
     updateLipSynch(0);
     // Play old audio/video to finish cross-fade:
     if (m_nextVideoPlayer->currentTime() > 0){
         m_nextVideoPlayer->play();
         m_nextAudioPlayer->play();
     }
-    restartAudioVideoTimers();
-    if (!m_rapidTimer)
-        m_rapidTimer = startTimer(100);
+    bufferAudioVideo();
+    updateTimer(m_rapidTimer, 100);
 }
 
 void MediaObject::pause_internal()
@@ -449,15 +358,9 @@ void MediaObject::pause_internal()
     m_nextAudioPlayer->pause();
     m_videoPlayer->pause();
     m_nextVideoPlayer->pause();
-    killTimer(m_rapidTimer);
-    killTimer(m_videoTimer);
-    killTimer(m_audioTimer);
-    m_rapidTimer = 0;
-    m_videoTimer = 0;
-    m_audioTimer = 0;
-#if QT_ALLOW_QUICKTIME
-    stopDisplayLink();
-#endif
+    updateTimer(m_rapidTimer, -1);
+    updateTimer(m_bufferTimer, -1);
+
     if (m_waitNextSwap)
         m_swapTimeLeft = m_swapTime.msecsTo(QTime::currentTime());
 }
@@ -479,7 +382,7 @@ void MediaObject::play()
     if (!m_videoPlayer->canPlayMedia())
         return;
     if (!setState(Phonon::PlayingState))
-        return;
+        return;        
     if (m_audioSystem == AS_Graph){
         m_audioGraph->start();
         m_mediaObjectAudioNode->setMute(true);
@@ -520,7 +423,7 @@ void MediaObject::stop()
     if (!setState(Phonon::StoppedState))
         return;
     m_waitNextSwap = false;
-    m_nextVideoPlayer->unsetCurrentMediaSource();
+    m_nextVideoPlayer->unsetVideo();
     m_nextAudioPlayer->unsetVideoPlayer();
     pause_internal();
     seek(0);
@@ -532,9 +435,9 @@ void MediaObject::seek(qint64 milliseconds)
     IMPLEMENTED;
     if (m_state == Phonon::ErrorState)
         return;
-
+        
     // Stop cross-fade if any:
-    m_nextVideoPlayer->unsetCurrentMediaSource();
+    m_nextVideoPlayer->unsetVideo();
     m_nextAudioPlayer->unsetVideoPlayer();
     m_mediaObjectAudioNode->cancelCrossFade();
 
@@ -543,7 +446,7 @@ void MediaObject::seek(qint64 milliseconds)
     m_videoPlayer->seek(milliseconds);
     m_audioPlayer->seek(m_videoPlayer->currentTime());
     m_mediaObjectAudioNode->setMute(false);
-
+    
     // Update time and cancel pending swap:
     if (m_currentTime < m_videoPlayer->duration())
         m_waitNextSwap = false;
@@ -654,7 +557,7 @@ bool MediaObject::isSeekable() const
 qint64 MediaObject::currentTime() const
 {
     IMPLEMENTED_SILENT;
-    const_cast<MediaObject *>(this)->updateCurrentTime();
+    const_cast<MediaObject *>(this)->updateCurrentTime(); 
     return m_currentTime;
 }
 
@@ -664,24 +567,19 @@ void MediaObject::updateCurrentTime()
     m_currentTime = (m_audioSystem == AS_Graph) ? m_audioPlayer->currentTime() : m_videoPlayer->currentTime();
     quint64 total = m_videoPlayer->duration();
 
-    if (m_videoPlayer->currentTrack() < m_videoPlayer->trackCount() - 1){
-        // There are still more tracks to play after the current track.
-        if (m_autoplayTitles) {
-            if (lastUpdateTime < m_currentTime && m_currentTime == total)
-                setCurrentTrack(m_videoPlayer->currentTrack() + 1);
-        }
-    } else if (m_nextVideoPlayer->state() == QuickTimeVideoPlayer::NoMedia){
-        // There is no more sources or tracks to play after the current source.
-        // Check if it's time to emit aboutToFinish:
-        quint32 mark = qMax(quint64(0), qMin(total, total + m_transitionTime - 2000));
-        if (lastUpdateTime < mark && mark <= m_currentTime)
-            emit aboutToFinish();
-
-        // Check if it's time to emit prefinishMarkReached:
-        mark = qMax(quint64(0), total - m_prefinishMark);
-        if (lastUpdateTime < mark && mark <= m_currentTime)
-            emit prefinishMarkReached(total - m_currentTime);
+    // Check if it's time to emit aboutToFinish:
+    quint32 mark = qMax(quint64(0), qMin(total, total + m_transitionTime - 2000));
+    if (lastUpdateTime < mark && mark <= m_currentTime)
+        emit aboutToFinish();
 
+    // Check if it's time to emit prefinishMarkReached:
+    mark = qMax(quint64(0), total - m_prefinishMark);
+    if (lastUpdateTime < mark && mark <= m_currentTime)
+        emit prefinishMarkReached(total - m_currentTime);
+
+    if (m_nextVideoPlayer->state() == QuickTimeVideoPlayer::NoMedia){
+        // There is no next source in que.
+        // Check if it's time to emit finished:
         if (lastUpdateTime < m_currentTime && m_currentTime == total){
             emit finished();
             m_currentTime = (m_audioSystem == AS_Graph) ? m_audioPlayer->currentTime() : m_videoPlayer->currentTime();
@@ -691,7 +589,7 @@ void MediaObject::updateCurrentTime()
     } else {
         // We have a next source.
         // Check if it's time to swap to next source:
-        quint32 mark = qMax(quint64(0), total + m_transitionTime);
+        mark = qMax(quint64(0), total + m_transitionTime);
         if (m_waitNextSwap && m_state == Phonon::PlayingState &&
             m_transitionTime < m_swapTime.msecsTo(QTime::currentTime())){
             swapCurrentWithNext(0);
@@ -794,14 +692,14 @@ bool MediaObject::setAudioDeviceOnMovie(int id)
 
 void MediaObject::updateCrossFade()
 {
-    m_mediaObjectAudioNode->updateCrossFade(m_currentTime);
+    m_mediaObjectAudioNode->updateCrossFade(m_currentTime);   
     // Clean-up previous movie if done fading:
     if (m_mediaObjectAudioNode->m_fadeDuration == 0){
         if (m_nextVideoPlayer->isPlaying() || m_nextAudioPlayer->isPlaying()){
-            m_nextVideoPlayer->unsetCurrentMediaSource();
+            m_nextVideoPlayer->unsetVideo();
             m_nextAudioPlayer->unsetVideoPlayer();
         }
-    }
+    }        
 }
 
 void MediaObject::updateBufferStatus()
@@ -830,7 +728,7 @@ void MediaObject::updateVideoFrames()
     // Draw next frame if awailable:
     if (m_videoPlayer->videoFrameChanged()){
         updateLipSynch(50);
-        VideoFrame frame(m_videoPlayer);
+        VideoFrame frame(m_videoPlayer);           
         if (m_nextVideoPlayer->isPlaying()
             && m_nextVideoPlayer->hasVideo()
             && isCrossFading()){
@@ -838,9 +736,9 @@ void MediaObject::updateVideoFrames()
             frame.setBackgroundFrame(bgFrame);
             frame.setBaseOpacity(m_mediaObjectAudioNode->m_volume1);
         }
-
+        
         // Send the frame through the graph:
-        updateVideo(frame);
+        updateVideo(frame);    
         checkForError();
     }
 }
@@ -851,7 +749,7 @@ void MediaObject::updateLipSynch(int allowedOffset)
         return;
     if (m_videoSinkList.isEmpty() || m_audioSinkList.isEmpty())
         return;
-
+        
     if (m_videoPlayer->hasVideo()){
         qint64 diff = m_audioPlayer->currentTime() - m_videoPlayer->currentTime();
         if (-allowedOffset > diff || diff > allowedOffset)
@@ -865,6 +763,16 @@ void MediaObject::updateLipSynch(int allowedOffset)
     }
 }
 
+void MediaObject::bufferAudioVideo()
+{
+    long nextVideoUpdate = m_videoPlayer->hasVideo() ? 30 : INT_MAX;
+    long nextAudioUpdate = m_audioPlayer->regularTaskFrequency();
+    updateAudioBuffers();
+    updateVideoFrames();
+    if (m_state == Phonon::PlayingState)
+        updateTimer(m_bufferTimer, qMin(nextVideoUpdate, nextAudioUpdate));
+}
+
 void MediaObject::updateRapidly()
 {
     updateCurrentTime();
@@ -889,8 +797,8 @@ void MediaObject::mediaNodeEvent(const MediaNodeEvent *event)
             synchAudioVideo();
             checkForError();
             m_mediaObjectAudioNode->setMute(false);
-            if (m_state == Phonon::PlayingState)
-                restartAudioVideoTimers();
+             if (m_state == Phonon::PlayingState)
+                bufferAudioVideo();
             break;
         case MediaNodeEvent::AudioGraphCannotPlay:
         case MediaNodeEvent::AudioGraphInitialized:
@@ -901,7 +809,7 @@ void MediaObject::mediaNodeEvent(const MediaNodeEvent *event)
                 checkForError();
                 m_mediaObjectAudioNode->setMute(false);
             }
-            break;
+            break; 
         default:
             break;
     }
@@ -910,67 +818,29 @@ void MediaObject::mediaNodeEvent(const MediaNodeEvent *event)
 bool MediaObject::event(QEvent *event)
 {
     switch (event->type()){
-#if QT_ALLOW_QUICKTIME
-        case QEvent::User:{
-            m_displayLinkMutex.lock();
-            m_pendingDisplayLinkEvent = false;
-            m_displayLinkMutex.unlock();
-            updateVideoFrames();
-            break; }
-#endif
-        case QEvent::Timer:{
-            int timerId = static_cast<QTimerEvent *>(event)->timerId();
-            if (timerId == m_rapidTimer)
+        case QEvent::Timer: {
+            QTimerEvent *timerEvent = static_cast<QTimerEvent *>(event);
+            if (timerEvent->timerId() == m_rapidTimer)
                 updateRapidly();
-            else if (timerId == m_tickTimer)
+            else if (timerEvent->timerId() == m_tickTimer)
                 emit tick(currentTime());
-            else if (timerId == m_videoTimer)
-                updateVideoFrames();
-            else if (timerId == m_audioTimer)
-                updateAudioBuffers();
-            break; }
+            else if (timerEvent->timerId() == m_bufferTimer)
+                bufferAudioVideo();
+            }
+            break;
         default:
             break;
     }
     return QObject::event(event);
 }
 
-void MediaObject::setCurrentTrack(int track)
+bool MediaObject::hasInterface(Interface /*interface*/) const
 {
-    if (track == m_videoPlayer->currentTrack() || track < 0 || track >= m_videoPlayer->trackCount())
-        return;
-
-    m_videoPlayer->setCurrentTrack(track);
-    emit titleChanged(track);
-    emit metaDataChanged(m_videoPlayer->metaData());
+    return false;
 }
 
-bool MediaObject::hasInterface(Interface iface) const
+QVariant MediaObject::interfaceCall(Interface /*interface*/, int /*command*/, const QList<QVariant> &/*arguments*/)
 {
-    return iface == AddonInterface::TitleInterface;
-}
-
-QVariant MediaObject::interfaceCall(Interface iface, int command, const QList<QVariant> &params)
-{
-    switch (iface) {
-        case TitleInterface:
-            switch (command) {
-                case availableTitles:
-                    return m_videoPlayer->trackCount();
-                case title:
-                    return m_videoPlayer->currentTrack();
-                case setTitle:
-                    setCurrentTrack(params.first().toInt());
-                    break;
-                case autoplayTitles:
-                    return m_autoplayTitles;
-                case setAutoplayTitles:
-                    m_autoplayTitles = params.first().toBool();
-                    break;
-            }
-        default:
-            break;
-    }
     return QVariant();
 }
 
diff --git a/src/3rdparty/phonon/qt7/quicktimemetadata.h b/src/3rdparty/phonon/qt7/quicktimemetadata.h
index c589535..d524183 100644
--- a/src/3rdparty/phonon/qt7/quicktimemetadata.h
+++ b/src/3rdparty/phonon/qt7/quicktimemetadata.h
@@ -38,8 +38,10 @@ namespace QT7
     class QuickTimeMetaData
     {
         public:
-            QuickTimeMetaData(QuickTimeVideoPlayer *videoPlayer);
-            void update();
+            QuickTimeMetaData();
+            virtual ~QuickTimeMetaData();
+
+            void setVideo(QuickTimeVideoPlayer *videoPlayer);
             QMultiMap<QString, QString> metaData();
 
         private:
@@ -47,8 +49,6 @@ namespace QT7
             bool m_movieChanged;
             QuickTimeVideoPlayer *m_videoPlayer;
             void readMetaData();
-            void guessMetaDataForCD();
-            void readMetaDataFromMovie();
 
 #ifdef QUICKTIME_C_API_AVAILABLE
             QString stripCopyRightSymbol(const QString &key);
diff --git a/src/3rdparty/phonon/qt7/quicktimemetadata.mm b/src/3rdparty/phonon/qt7/quicktimemetadata.mm
index 2dcc152..851e707 100644
--- a/src/3rdparty/phonon/qt7/quicktimemetadata.mm
+++ b/src/3rdparty/phonon/qt7/quicktimemetadata.mm
@@ -15,7 +15,6 @@
     along with this library.  If not, see <http://www.gnu.org/licenses/>.
 */
 
-#include <QtCore/QFileInfo>
 #include "quicktimemetadata.h"
 #include "quicktimevideoplayer.h"
 
@@ -26,14 +25,19 @@ namespace Phonon
 namespace QT7
 {
 
-QuickTimeMetaData::QuickTimeMetaData(QuickTimeVideoPlayer *videoPlayer)
+QuickTimeMetaData::QuickTimeMetaData()
 {
-    m_videoPlayer = videoPlayer;
+    m_videoPlayer = 0;
     m_movieChanged = false;
 }
 
-void QuickTimeMetaData::update()
+QuickTimeMetaData::~QuickTimeMetaData()
 {
+}
+
+void QuickTimeMetaData::setVideo(QuickTimeVideoPlayer *videoPlayer)
+{
+    m_videoPlayer = videoPlayer;
     m_movieChanged = true;
     m_metaData.clear();
 }
@@ -141,22 +145,14 @@ void QuickTimeMetaData::readFormattedData(QTMetaDataRef metaDataRef, OSType form
 
 #endif // QUICKTIME_C_API_AVAILABLE
 
-void QuickTimeMetaData::guessMetaDataForCD()
-{
-    QString album = QFileInfo(m_videoPlayer->movieCompactDiscPath()).fileName();
-    QString title = QFileInfo(m_videoPlayer->currentTrackPath()).fileName();
-    title = title.left(title.lastIndexOf('.'));
-    m_metaData.insert(QLatin1String("ALBUM"), album);
-    m_metaData.insert(QLatin1String("TITLE"), title);
-    m_metaData.insert(QLatin1String("TRACKNUMBER"), QString::number(m_videoPlayer->currentTrack()));
-}
-
-void QuickTimeMetaData::readMetaDataFromMovie()
+void QuickTimeMetaData::readMetaData()
 {
+	if (!m_videoPlayer)
+        return;
     QMultiMap<QString, QString> metaMap;
-
+    
 #ifdef QUICKTIME_C_API_AVAILABLE
-    QTMetaDataRef metaDataRef;
+	QTMetaDataRef metaDataRef;        
 	OSStatus err = QTCopyMovieMetaData([m_videoPlayer->qtMovie() quickTimeMovie], &metaDataRef);
     BACKEND_ASSERT2(err == noErr, "Could not read QuickTime meta data", NORMAL_ERROR)
 
@@ -177,17 +173,6 @@ void QuickTimeMetaData::readMetaDataFromMovie()
     m_metaData.insert(QLatin1String("DESCRIPTION"), metaMap.value(QLatin1String("des")));
 }
 
-void QuickTimeMetaData::readMetaData()
-{
-	if (!m_videoPlayer)
-        return;
-
-    if (m_videoPlayer->mediaSource().type() == Phonon::MediaSource::Disc)
-        guessMetaDataForCD();
-    else
-        readMetaDataFromMovie();
-}
-
 QMultiMap<QString, QString> QuickTimeMetaData::metaData()
 {
     if (m_videoPlayer && m_videoPlayer->hasMovie() && m_movieChanged)
diff --git a/src/3rdparty/phonon/qt7/quicktimevideoplayer.h b/src/3rdparty/phonon/qt7/quicktimevideoplayer.h
index 98eacb5..8e73cde 100644
--- a/src/3rdparty/phonon/qt7/quicktimevideoplayer.h
+++ b/src/3rdparty/phonon/qt7/quicktimevideoplayer.h
@@ -20,8 +20,8 @@
 
 #include "backendheader.h"
 
-#include <QtGui/qmacdefines_mac.h>
 #import <QTKit/QTDataReference.h>
+#undef slots
 #import <QTKit/QTMovie.h>
 
 #include <phonon/mediasource.h>
@@ -39,7 +39,6 @@ namespace Phonon
 namespace QT7
 {
     class QuickTimeStreamReader;
-    class QuickTimeMetaData;
 	class VideoRenderWidgetQTMovieView;
 
     class QuickTimeVideoPlayer : QObject
@@ -57,7 +56,7 @@ namespace QT7
 
             void setMediaSource(const MediaSource &source);
             MediaSource mediaSource() const;
-            void unsetCurrentMediaSource();
+            void unsetVideo();
 
             void play();
             void pause();
@@ -68,13 +67,11 @@ namespace QT7
             GLuint currentFrameAsGLTexture();
 			void *currentFrameAsCIImage();
             QImage currentFrameAsQImage();
-            void releaseImageCache();
             QRect videoRect() const;
 
             quint64 duration() const;
             quint64 currentTime() const;
             long timeScale() const;
-            float staticFps();
             QString currentTimeString();
 
             void setColors(qreal brightness = 0, qreal contrast = 1, qreal hue = 0, qreal saturation = 1);
@@ -87,7 +84,6 @@ namespace QT7
             bool setAudioDevice(int id);
             void setPlaybackRate(float rate);
             QTMovie *qtMovie() const;
-            QMultiMap<QString, QString> metaData();
 
             float playbackRate() const;
             float prefferedPlaybackRate() const;
@@ -107,12 +103,6 @@ namespace QT7
             float percentageLoaded();
             quint64 timeLoaded();
 
-            int trackCount() const;
-            int currentTrack() const;
-            void setCurrentTrack(int track);
-            QString movieCompactDiscPath() const;
-            QString currentTrackPath() const;
-
             static QString timeToString(quint64 ms);
 
 			// Help functions when drawing to more that one widget in cocoa 64:
@@ -126,10 +116,6 @@ namespace QT7
             QTMovie *m_QTMovie;
             State m_state;
             QGLPixelBuffer *m_QImagePixelBuffer;
-            QuickTimeMetaData *m_metaData;
-
-            CVOpenGLTextureRef m_cachedCVTextureRef;
-            QImage m_cachedQImage;
 
             bool m_playbackRateSat;
             bool m_isDrmProtected;
@@ -140,18 +126,13 @@ namespace QT7
             float m_masterVolume;
             float m_relativeVolume;
             float m_playbackRate;
-            float m_staticFps;
             quint64 m_currentTime;
             MediaSource m_mediaSource;
-
 			void *m_primaryRenderingCIImage;
 			qreal m_brightness;
 			qreal m_contrast;
 			qreal m_hue;
 			qreal m_saturation;
-            NSArray *m_folderTracks;
-            int m_currentTrack;
-            QString m_movieCompactDiscPath;
 
 #ifdef QUICKTIME_C_API_AVAILABLE
             QTVisualContextRef m_visualContext;
@@ -159,26 +140,20 @@ namespace QT7
             VideoFrame m_currentFrame;
             QuickTimeStreamReader *m_streamReader;
 
-            void prepareCurrentMovieForPlayback();
             void createVisualContext();
             void openMovieFromCurrentMediaSource();
             void openMovieFromDataRef(QTDataReference *dataRef);
             void openMovieFromFile();
             void openMovieFromUrl();
             void openMovieFromStream();
-            void openMovieFromCompactDisc();
             void openMovieFromData(QByteArray *data, char *fileType);
             void openMovieFromDataGuessType(QByteArray *data);
 			QString mediaSourcePath();
 			bool codecExistsAccordingToSuffix(const QString &fileName);
-            NSString* pathToCompactDisc();
-            bool isCompactDisc(NSString *path);
-            NSArray* scanFolder(NSString *path);
 
             void setError(NSError *error);
             bool errorOccured();
             void readProtection();
-            void calculateStaticFps();
             void checkIfVideoAwailable();
             bool movieNotLoaded();
             void waitStatePlayable();
diff --git a/src/3rdparty/phonon/qt7/quicktimevideoplayer.mm b/src/3rdparty/phonon/qt7/quicktimevideoplayer.mm
index 23c76e3..3f76132 100644
--- a/src/3rdparty/phonon/qt7/quicktimevideoplayer.mm
+++ b/src/3rdparty/phonon/qt7/quicktimevideoplayer.mm
@@ -20,7 +20,6 @@
 #include "videowidget.h"
 #include "audiodevice.h"
 #include "quicktimestreamreader.h"
-#include "quicktimemetadata.h"
 
 #include <QtCore/QCoreApplication>
 #include <QtCore/QEventLoop>
@@ -53,7 +52,6 @@ QuickTimeVideoPlayer::QuickTimeVideoPlayer() : QObject(0)
 {
     m_state = NoMedia;
     m_mediaSource = MediaSource();
-    m_metaData = new QuickTimeMetaData(this);
     m_QTMovie = 0;
     m_streamReader = 0;
     m_playbackRate = 1.0f;
@@ -63,16 +61,12 @@ QuickTimeVideoPlayer::QuickTimeVideoPlayer() : QObject(0)
     m_mute = false;
     m_audioEnabled = false;
     m_hasVideo = false;
-    m_staticFps = 0;
     m_playbackRateSat = false;
     m_isDrmProtected = false;
     m_isDrmAuthorized = true;
 	m_primaryRenderingTarget = 0;
 	m_primaryRenderingCIImage = 0;
     m_QImagePixelBuffer = 0;
-    m_cachedCVTextureRef = 0;
-    m_folderTracks = 0;
-    m_currentTrack = 0;
 
 #ifdef QUICKTIME_C_API_AVAILABLE
     OSStatus err = EnterMovies();
@@ -83,9 +77,7 @@ QuickTimeVideoPlayer::QuickTimeVideoPlayer() : QObject(0)
 
 QuickTimeVideoPlayer::~QuickTimeVideoPlayer()
 {
-	PhononAutoReleasePool pool;
-    unsetCurrentMediaSource();
-    delete m_metaData;
+    unsetVideo();
     [(NSObject*)m_primaryRenderingTarget release];
     m_primaryRenderingTarget = 0;
 #ifdef QUICKTIME_C_API_AVAILABLE
@@ -94,15 +86,6 @@ QuickTimeVideoPlayer::~QuickTimeVideoPlayer()
 #endif
 }
 
-void QuickTimeVideoPlayer::releaseImageCache()
-{
-    if (m_cachedCVTextureRef){
-        CVOpenGLTextureRelease(m_cachedCVTextureRef);
-        m_cachedCVTextureRef = 0;
-    }
-    m_cachedQImage = QImage();
-}
-
 void QuickTimeVideoPlayer::createVisualContext()
 {
 #ifdef QUICKTIME_C_API_AVAILABLE
@@ -142,10 +125,7 @@ bool QuickTimeVideoPlayer::videoFrameChanged()
 		return false;
 
     QTVisualContextTask(m_visualContext);
-    bool changed = QTVisualContextIsNewImageAvailable(m_visualContext, 0);
-    if (changed)
-        releaseImageCache();
-    return changed;
+    return QTVisualContextIsNewImageAvailable(m_visualContext, 0);
 
 #elif defined(QT_MAC_USE_COCOA)
     return true;
@@ -160,11 +140,10 @@ CVOpenGLTextureRef QuickTimeVideoPlayer::currentFrameAsCVTexture()
 #ifdef QUICKTIME_C_API_AVAILABLE
     if (!m_visualContext)
         return 0;
-    if (!m_cachedCVTextureRef){
-        OSStatus err = QTVisualContextCopyImageForTime(m_visualContext, 0, 0, &m_cachedCVTextureRef);
-        BACKEND_ASSERT3(err == noErr, "Could not copy image for time in QuickTime player", FATAL_ERROR, 0)
-    }
-    return m_cachedCVTextureRef;
+    CVOpenGLTextureRef texture = 0;
+    OSStatus err = QTVisualContextCopyImageForTime(m_visualContext, 0, 0, &texture);
+    BACKEND_ASSERT3(err == noErr, "Could not copy image for time in QuickTime player", FATAL_ERROR, 0)
+    return texture;
 
 #else
     return 0;
@@ -173,9 +152,6 @@ CVOpenGLTextureRef QuickTimeVideoPlayer::currentFrameAsCVTexture()
 
 QImage QuickTimeVideoPlayer::currentFrameAsQImage()
 {
-    if (!m_cachedQImage.isNull())
-        return m_cachedQImage;
-
 #ifdef QUICKTIME_C_API_AVAILABLE
     QGLContext *prevContext = const_cast<QGLContext *>(QGLContext::currentContext());
     CVOpenGLTextureRef texture = currentFrameAsCVTexture();
@@ -205,11 +181,12 @@ QImage QuickTimeVideoPlayer::currentFrameAsQImage()
         glVertex2i(-1, -1);
     glEnd();
 
-    m_cachedQImage = m_QImagePixelBuffer->toImage();
+    QImage image = m_QImagePixelBuffer->toImage();
+    CVOpenGLTextureRelease(texture);
     // Because of QuickTime, m_QImagePixelBuffer->doneCurrent() will fail.
     // So we store, and restore, the context our selves:
     prevContext->makeCurrent();
-    return m_cachedQImage;
+    return image;
 #else
 	CIImage *img = (CIImage *)currentFrameAsCIImage();
 	if (!img)
@@ -218,10 +195,10 @@ QImage QuickTimeVideoPlayer::currentFrameAsQImage()
 	NSBitmapImageRep* bitmap = [[NSBitmapImageRep alloc] initWithCIImage:img];
 	CGRect bounds = [img extent];
 	QImage qImg([bitmap bitmapData], bounds.size.width, bounds.size.height, QImage::Format_ARGB32);
-	m_cachedQImage = qImg.rgbSwapped();
+	QImage swapped = qImg.rgbSwapped();
 	[bitmap release];
 	[img release];
-	return m_cachedQImage;
+	return swapped;
 #endif
 }
 
@@ -273,7 +250,8 @@ void *QuickTimeVideoPlayer::currentFrameAsCIImage()
 #ifdef QUICKTIME_C_API_AVAILABLE
 	CVOpenGLTextureRef cvImg = currentFrameAsCVTexture();
 	CIImage *img = [[CIImage alloc] initWithCVImageBuffer:cvImg];
-	return img;
+	CVOpenGLTextureRelease(cvImg);
+	return img;	
 #else
 	return 0;
 #endif
@@ -295,7 +273,7 @@ GLuint QuickTimeVideoPlayer::currentFrameAsGLTexture()
 
     int samplesPerPixel = [bitmap samplesPerPixel];
     if (![bitmap isPlanar] && (samplesPerPixel == 3 || samplesPerPixel == 4)){
-        glTexImage2D(GL_TEXTURE_RECTANGLE_EXT, 0,
+        glTexImage2D(GL_TEXTURE_RECTANGLE_EXT, 0, 
             samplesPerPixel == 4 ? GL_RGBA8 : GL_RGB8,
             [bitmap pixelsWide], [bitmap pixelsHigh],
             0, samplesPerPixel == 4 ? GL_RGBA : GL_RGB,
@@ -324,7 +302,7 @@ void QuickTimeVideoPlayer::setVolume(float masterVolume, float relativeVolume)
     m_masterVolume = masterVolume;
     m_relativeVolume = relativeVolume;
     if (!m_QTMovie || !m_audioEnabled || m_mute)
-        return;
+        return;                
     [m_QTMovie setVolume:(m_masterVolume * m_relativeVolume)];
 }
 
@@ -335,7 +313,7 @@ void QuickTimeVideoPlayer::setMute(bool mute)
         return;
 
     // Work-around bug that happends if you set/unset mute
-    // before movie is playing, and audio is not played
+    // before movie is playing, and audio is not played 
     // through graph. Then audio is delayed.
     [m_QTMovie setMuted:mute];
     [m_QTMovie setVolume:(mute ? 0 : m_masterVolume * m_relativeVolume)];
@@ -348,7 +326,7 @@ void QuickTimeVideoPlayer::enableAudio(bool enable)
         return;
 
     // Work-around bug that happends if you set/unset mute
-    // before movie is playing, and audio is not played
+    // before movie is playing, and audio is not played 
     // through graph. Then audio is delayed.
     [m_QTMovie setMuted:(!enable || m_mute)];
     [m_QTMovie setVolume:((!enable || m_mute) ? 0 : m_masterVolume * m_relativeVolume)];
@@ -367,7 +345,7 @@ bool QuickTimeVideoPlayer::setAudioDevice(int id)
 #ifdef QUICKTIME_C_API_AVAILABLE
     // The following code will not work for some media codecs that
     // typically mingle audio/video frames (e.g mpeg).
-    CFStringRef idString = PhononCFString::toCFStringRef(AudioDevice::deviceUID(id));
+    CFStringRef idString = PhononCFString::toCFStringRef(AudioDevice::deviceUID(id));        
     QTAudioContextRef context;
     QTAudioContextCreateForAudioDevice(kCFAllocatorDefault, idString, 0, &context);
     OSStatus err = SetMovieAudioContext([m_QTMovie quickTimeMovie], context);
@@ -391,16 +369,11 @@ void QuickTimeVideoPlayer::setColors(qreal brightness, qreal contrast, qreal hue
     contrast += 1;
     saturation += 1;
 
-    if (m_brightness == brightness
-        && m_contrast == contrast
-        && m_hue == hue
-        && m_saturation == saturation)
-        return;
-
 	m_brightness = brightness;
 	m_contrast = contrast;
 	m_hue = hue;
 	m_saturation = saturation;
+	
 #ifdef QUICKTIME_C_API_AVAILABLE
     Float32 value;
     value = brightness;
@@ -412,7 +385,6 @@ void QuickTimeVideoPlayer::setColors(qreal brightness, qreal contrast, qreal hue
     value = saturation;
     SetMovieVisualSaturation([m_QTMovie quickTimeMovie], value, 0);
 #endif
-    releaseImageCache();
 }
 
 QRect QuickTimeVideoPlayer::videoRect() const
@@ -425,7 +397,7 @@ QRect QuickTimeVideoPlayer::videoRect() const
     return QRect(0, 0, size.width, size.height);
 }
 
-void QuickTimeVideoPlayer::unsetCurrentMediaSource()
+void QuickTimeVideoPlayer::unsetVideo()
 {
     if (!m_QTMovie)
         return;
@@ -438,17 +410,11 @@ void QuickTimeVideoPlayer::unsetCurrentMediaSource()
     m_state = NoMedia;
     m_isDrmProtected = false;
     m_isDrmAuthorized = true;
-    m_hasVideo = false;
-    m_staticFps = 0;
     m_mediaSource = MediaSource();
-    m_movieCompactDiscPath.clear();
 	[(CIImage *)m_primaryRenderingCIImage release];
 	m_primaryRenderingCIImage = 0;
     delete m_QImagePixelBuffer;
     m_QImagePixelBuffer = 0;
-    releaseImageCache();
-    [m_folderTracks release];
-    m_folderTracks = 0;
 }
 
 QuickTimeVideoPlayer::State QuickTimeVideoPlayer::state() const
@@ -558,25 +524,18 @@ bool QuickTimeVideoPlayer::codecExistsAccordingToSuffix(const QString &fileName)
 void QuickTimeVideoPlayer::setMediaSource(const MediaSource &mediaSource)
 {
     PhononAutoReleasePool pool;
-    unsetCurrentMediaSource();
-
+    unsetVideo();
     m_mediaSource = mediaSource;
     if (mediaSource.type() == MediaSource::Empty || mediaSource.type() == MediaSource::Invalid){
         m_state = NoMedia;
         return;
     }
-
     openMovieFromCurrentMediaSource();
     if (errorOccured()){
-        unsetCurrentMediaSource();
+        unsetVideo();
         return;
     }
 
-    prepareCurrentMovieForPlayback();
-}
-
-void QuickTimeVideoPlayer::prepareCurrentMovieForPlayback()
-{
 #ifdef QUICKTIME_C_API_AVAILABLE
     if (m_visualContext)
         SetMovieVisualContext([m_QTMovie quickTimeMovie], m_visualContext);
@@ -584,25 +543,23 @@ void QuickTimeVideoPlayer::prepareCurrentMovieForPlayback()
 
     waitStatePlayable();
     if (errorOccured()){
-        unsetCurrentMediaSource();
+        unsetVideo();
         return;
     }
 
     readProtection();
     preRollMovie();
     if (errorOccured()){
-        unsetCurrentMediaSource();
+        unsetVideo();
         return;
     }
 
     if (!m_playbackRateSat)
         m_playbackRate = prefferedPlaybackRate();
     checkIfVideoAwailable();
-    calculateStaticFps();
     enableAudio(m_audioEnabled);
     setMute(m_mute);
     setVolume(m_masterVolume, m_relativeVolume);
-    m_metaData->update();
     pause();
 }
 
@@ -616,7 +573,7 @@ void QuickTimeVideoPlayer::openMovieFromCurrentMediaSource()
         openMovieFromUrl();
         break;
     case MediaSource::Disc:
-        openMovieFromCompactDisc();
+        CASE_UNSUPPORTED("Could not open media source.", FATAL_ERROR)
         break;
     case MediaSource::Stream:
         openMovieFromStream();
@@ -678,7 +635,7 @@ void QuickTimeVideoPlayer::openMovieFromDataGuessType(QByteArray *data)
     // than using e.g [QTMovie movieFileTypes:QTIncludeCommonTypes]. Some
     // codecs *think* they can decode the stream, and crash...
 #define TryOpenMovieWithCodec(type) gClearError(); \
-    openMovieFromData(data, (char *)"."type); \
+    openMovieFromData(data, "."type); \
     if (m_QTMovie) return;
 
     TryOpenMovieWithCodec("avi");
@@ -718,50 +675,6 @@ void QuickTimeVideoPlayer::openMovieFromStream()
     openMovieFromDataGuessType(m_streamReader->pointerToData());
 }
 
-typedef void (*qt_sighandler_t)(int);
-static void sigtest(int) {
-    qApp->exit(0);
-}
-
-void QuickTimeVideoPlayer::openMovieFromCompactDisc()
-{
-    // Interrupting the application while the device is open
-    // causes the application to hang. So we need to handle
-    // this in a more graceful way:
-    qt_sighandler_t hndl = signal(SIGINT, sigtest);
-    if (hndl)
-        signal(SIGINT, hndl);
-
-    PhononAutoReleasePool pool;
-    NSString *cd = 0;
-    QString devName = m_mediaSource.deviceName();
-    if (devName.isEmpty()) {
-        cd = pathToCompactDisc();
-        if (!cd) {
-            SET_ERROR("Could not open media source.", NORMAL_ERROR)
-            return;
-        }
-        m_movieCompactDiscPath = PhononCFString::toQString(reinterpret_cast<CFStringRef>(cd));
-    } else {
-       if (!QFileInfo(devName).isAbsolute())
-           devName = QLatin1String("/Volumes/") + devName;
-       cd = [reinterpret_cast<const NSString *>(PhononCFString::toCFStringRef(devName)) autorelease];
-       if (!isCompactDisc(cd)) {
-           SET_ERROR("Could not open media source.", NORMAL_ERROR)
-           return;
-       }
-       m_movieCompactDiscPath = devName;
-    }
-
-    m_folderTracks = [scanFolder(cd) retain];
-    setCurrentTrack(0);
-}
-
-QString QuickTimeVideoPlayer::movieCompactDiscPath() const
-{
-    return m_movieCompactDiscPath;
-}
-
 MediaSource QuickTimeVideoPlayer::mediaSource() const
 {
     return m_mediaSource;
@@ -807,44 +720,6 @@ long QuickTimeVideoPlayer::timeScale() const
     return [[m_QTMovie attributeForKey:@"QTMovieTimeScaleAttribute"] longValue];
 }
 
-float QuickTimeVideoPlayer::staticFps()
-{
-    return m_staticFps;
-}
-
-void QuickTimeVideoPlayer::calculateStaticFps()
-{
-    if (!m_hasVideo){
-        m_staticFps = 0;
-        return;
-    }
-
-#ifdef QT_ALLOW_QUICKTIME
-    Boolean isMpeg = false;
-    Track videoTrack = GetMovieIndTrackType([m_QTMovie quickTimeMovie], 1,
-            FOUR_CHAR_CODE('vfrr'), // 'vfrr' means: has frame rate
-            movieTrackCharacteristic | movieTrackEnabledOnly);
-    Media media = GetTrackMedia(videoTrack);
-    MediaHandler mediaH = GetMediaHandler(media);
-    MediaHasCharacteristic(mediaH, FOUR_CHAR_CODE('mpeg'), &isMpeg);
-
-    if (isMpeg){
-        MHInfoEncodedFrameRateRecord frameRate;
-        Size frameRateSize = sizeof(frameRate);
-        MediaGetPublicInfo(mediaH, kMHInfoEncodedFrameRate, &frameRate, &frameRateSize);
-        m_staticFps = float(Fix2X(frameRate.encodedFrameRate));
-    } else {
-        Media media = GetTrackMedia(videoTrack);
-        long sampleCount = GetMediaSampleCount(media);
-        TimeValue64 duration = GetMediaDisplayDuration(media);
-        TimeValue64 timeScale = GetMediaTimeScale(media);
-        m_staticFps = float((double)sampleCount * (double)timeScale / (double)duration);
-    }
-#else
-    m_staticFps = 30.0f;
-#endif
-}
-
 QString QuickTimeVideoPlayer::timeToString(quint64 ms)
 {
     int sec = ms/1000;
@@ -1075,94 +950,6 @@ void QuickTimeVideoPlayer::readProtection()
     }
 }
 
-QMultiMap<QString, QString> QuickTimeVideoPlayer::metaData()
-{
-    return m_metaData->metaData();
-}
-
-int QuickTimeVideoPlayer::trackCount() const
-{
-    if (!m_folderTracks)
-        return 0;
-    return [m_folderTracks count];
-}
-
-int QuickTimeVideoPlayer::currentTrack() const
-{
-    return m_currentTrack;
-}
-
-QString QuickTimeVideoPlayer::currentTrackPath() const
-{
-    if (!m_folderTracks)
-        return QString();
-
-    PhononAutoReleasePool pool;
-    NSString *trackPath = [m_folderTracks objectAtIndex:m_currentTrack];
-    return PhononCFString::toQString(reinterpret_cast<CFStringRef>(trackPath));
-}
-
-NSString* QuickTimeVideoPlayer::pathToCompactDisc()
-{
-    PhononAutoReleasePool pool;
-    NSArray *devices = [[NSWorkspace sharedWorkspace] mountedRemovableMedia];
-    for (unsigned int i=0; i<[devices count]; ++i) {
-        NSString *dev = [devices objectAtIndex:i];
-        if (isCompactDisc(dev))
-            return [dev retain];
-    }
-    return 0;
-}
-
-bool QuickTimeVideoPlayer::isCompactDisc(NSString *path)
-{
-    PhononAutoReleasePool pool;
-    NSString *type = [NSString string];
-    [[NSWorkspace sharedWorkspace] getFileSystemInfoForPath:path
-        isRemovable:0
-        isWritable:0
-        isUnmountable:0
-        description:0
-        type:&type];
-    return [type hasPrefix:@"cdd"];
-}
-
-NSArray* QuickTimeVideoPlayer::scanFolder(NSString *path)
-{
-    NSMutableArray *tracks = [NSMutableArray arrayWithCapacity:20];
-    if (!path)
-        return tracks;
-
-    NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:path];
-    while (NSString *track = [enumerator nextObject]) {
-        if (![track hasPrefix:@"."])
-            [tracks addObject:[path stringByAppendingPathComponent:track]];
-    }
-    return tracks;
-}
-
-void QuickTimeVideoPlayer::setCurrentTrack(int track)
-{
-    PhononAutoReleasePool pool;
-    [m_QTMovie release];
-	m_QTMovie = 0;
-    m_currentTime = 0;
-    m_currentTrack = track;
-
-    if (!m_folderTracks)
-        return;
-    if (track < 0 || track >= (int)[m_folderTracks count])
-        return;
-
-    NSString *trackPath = [m_folderTracks objectAtIndex:track];
-    QTDataReference *dataRef = [QTDataReference dataReferenceWithReferenceToFile:trackPath];
-    State currentState = m_state;
-    openMovieFromDataRef(dataRef);
-    prepareCurrentMovieForPlayback();
-    if (currentState == Playing)
-        play();
-}
-
 }}
 
 QT_END_NAMESPACE
diff --git a/src/3rdparty/phonon/qt7/videoframe.mm b/src/3rdparty/phonon/qt7/videoframe.mm
index 7b67b5e..92a3cd5 100644
--- a/src/3rdparty/phonon/qt7/videoframe.mm
+++ b/src/3rdparty/phonon/qt7/videoframe.mm
@@ -20,8 +20,6 @@
 #import <QuartzCore/CIFilter.h>
 #import <QuartzCore/CIContext.h>
 
-//#define CACHE_CV_TEXTURE
-
 QT_BEGIN_NAMESPACE
 
 namespace Phonon
@@ -72,9 +70,7 @@ namespace QT7
 
     void VideoFrame::copyMembers(const VideoFrame& frame)
     {
-#ifdef CACHE_CV_TEXTURE
         m_cachedCVTextureRef = frame.m_cachedCVTextureRef;
-#endif
 		m_cachedCIImage = frame.m_cachedCIImage;
 		m_cachedQImage = frame.m_cachedQImage;
         m_cachedNSBitmap = frame.m_cachedNSBitmap;
@@ -109,20 +105,11 @@ namespace QT7
 
     CVOpenGLTextureRef VideoFrame::cachedCVTexture() const
     {
-#ifdef CACHE_CV_TEXTURE
         if (!m_cachedCVTextureRef && m_videoPlayer){
             m_videoPlayer->setColors(m_brightness, m_contrast, m_hue, m_saturation);
             (const_cast<VideoFrame *>(this))->m_cachedCVTextureRef = m_videoPlayer->currentFrameAsCVTexture();
-            CVOpenGLTextureRetain((const_cast<VideoFrame *>(this))->m_cachedCVTextureRef);
         }
         return m_cachedCVTextureRef;
-#else
-        if (m_videoPlayer){
-            m_videoPlayer->setColors(m_brightness, m_contrast, m_hue, m_saturation);
-            return m_videoPlayer->currentFrameAsCVTexture();
-        }
-        return 0;
-#endif
     }
 
     void *VideoFrame::cachedCIImage() const
@@ -342,12 +329,10 @@ namespace QT7
 
     void VideoFrame::invalidateImage() const
     {
-#ifdef CACHE_CV_TEXTURE
         if (m_cachedCVTextureRef){
             CVOpenGLTextureRelease(m_cachedCVTextureRef);
             (const_cast<VideoFrame *>(this))->m_cachedCVTextureRef = 0;
         }
-#endif
         if (m_cachedCIImage){
 			[(CIImage *) m_cachedCIImage release];
             (const_cast<VideoFrame *>(this))->m_cachedCIImage = 0;
@@ -361,10 +346,8 @@ namespace QT7
 
     void VideoFrame::retain() const
     {
-#ifdef CACHE_CV_TEXTURE
         if (m_cachedCVTextureRef)
             CVOpenGLTextureRetain(m_cachedCVTextureRef);
-#endif
 		if (m_cachedCIImage)
 			[(CIImage *) m_cachedCIImage retain];
         if (m_backgroundFrame)
@@ -375,12 +358,8 @@ namespace QT7
 
     void VideoFrame::release() const
     {
-#ifdef CACHE_CV_TEXTURE
-        if (m_cachedCVTextureRef){
+        if (m_cachedCVTextureRef)
             CVOpenGLTextureRelease(m_cachedCVTextureRef);
-            (const_cast<VideoFrame *>(this))->m_cachedCVTextureRef = 0;
-        }
-#endif
 		if (m_cachedCIImage)
 			[(CIImage *) m_cachedCIImage release];
         if (m_backgroundFrame)
@@ -389,6 +368,7 @@ namespace QT7
             [m_cachedNSBitmap release];
 
         (const_cast<VideoFrame *>(this))->m_backgroundFrame = 0;
+        (const_cast<VideoFrame *>(this))->m_cachedCVTextureRef = 0;
         (const_cast<VideoFrame *>(this))->m_cachedCIImage = 0;
         (const_cast<VideoFrame *>(this))->m_cachedNSBitmap = 0;
     }
diff --git a/src/3rdparty/phonon/waveout/mediaobject.cpp b/src/3rdparty/phonon/waveout/mediaobject.cpp
index db71942..dbaec44 100644
--- a/src/3rdparty/phonon/waveout/mediaobject.cpp
+++ b/src/3rdparty/phonon/waveout/mediaobject.cpp
@@ -247,7 +247,7 @@ namespace Phonon
                                                     m_stopped(0)
         {
             m_thread = new WorkerThread();
-            connect(this, SIGNAL(outOfData(QIODevice*,QByteArray*,bool*)), m_thread, SLOT(stream(QIODevice*,QByteArray*,bool*)));
+            connect(this, SIGNAL(outOfData(QIODevice*, QByteArray*, bool*)), m_thread, SLOT(stream(QIODevice*, QByteArray*, bool*)));
             m_thread->start();
             m_soundBuffer1.waveHeader = new WAVEHDR;
             m_soundBuffer2.waveHeader = new WAVEHDR;
@@ -258,7 +258,7 @@ namespace Phonon
         MediaObject::~MediaObject()
         {
             stop();
-            disconnect(this, SIGNAL(outOfData(QIODevice*,QByteArray*,bool*)), m_thread, SLOT(stream(QIODevice*,QByteArray*,bool*)));
+            disconnect(this, SIGNAL(outOfData(QIODevice*, QByteArray*, bool*)), m_thread, SLOT(stream(QIODevice*, QByteArray*, bool*)));
             do { //The event loop of m_thread might not be started, yet
                 m_thread->quit(); //If the event loop is not started yet quit() does nothing
                 m_thread->wait(100);
@@ -281,8 +281,6 @@ namespace Phonon
 
         bool MediaObject::isSeekable() const
         {
-            if (!m_stream) 
-              return false; 
             return !m_stream->isSequential();
         }
 
diff --git a/src/3rdparty/webkit/WebCore/WebCore.pro b/src/3rdparty/webkit/WebCore/WebCore.pro
index 9432217..be4ec26 100644
--- a/src/3rdparty/webkit/WebCore/WebCore.pro
+++ b/src/3rdparty/webkit/WebCore/WebCore.pro
@@ -59,8 +59,8 @@ unix {
     lessThan(QT_MINOR_VERSION, 4): QMAKE_PKGCONFIG_REQUIRES += QtXml
 }
 
-unix:!mac:*-g++*:QMAKE_CXXFLAGS += -ffunction-sections -fdata-sections 
-unix:!mac:*-g++*:QMAKE_LFLAGS += -Wl,--gc-sections
+unix:!mac:!darwin-*:*-g++*:QMAKE_CXXFLAGS += -ffunction-sections -fdata-sections 
+unix:!mac:!darwin-*:*-g++*:QMAKE_LFLAGS += -Wl,--gc-sections
 
 CONFIG(release):!CONFIG(QTDIR_build) {
     contains(QT_CONFIG, reduce_exports):CONFIG += hide_symbols
diff --git a/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp b/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp
index 6d08c32..b57bb02 100644
--- a/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp
+++ b/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp
@@ -3106,7 +3106,7 @@ QString QWebPage::userAgentForUrl(const QUrl& url) const
     "AIX"
 #elif defined Q_OS_WIN32
     "%3"
-#elif defined Q_OS_DARWIN
+#elif defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #ifdef __i386__ || __x86_64__
     "Intel Mac OS X"
 #else
diff --git a/src/corelib/codecs/codecs.pri b/src/corelib/codecs/codecs.pri
index 17f4d91..7dfec12 100644
--- a/src/corelib/codecs/codecs.pri
+++ b/src/corelib/codecs/codecs.pri
@@ -25,6 +25,7 @@ unix {
         contains(QT_CONFIG,iconv) {
                 HEADERS += codecs/qiconvcodec_p.h
                 SOURCES += codecs/qiconvcodec.cpp
+                LIBS += -liconv
         } else:contains(QT_CONFIG,gnu-libiconv) {
                 HEADERS += codecs/qiconvcodec_p.h
                 SOURCES += codecs/qiconvcodec.cpp
diff --git a/src/corelib/codecs/qiconvcodec.cpp b/src/corelib/codecs/qiconvcodec.cpp
index 1d4fb2f..bcdfb07 100644
--- a/src/corelib/codecs/qiconvcodec.cpp
+++ b/src/corelib/codecs/qiconvcodec.cpp
@@ -62,7 +62,7 @@
 #elif defined(Q_OS_AIX)
 #  define NO_BOM
 #  define UTF16 "UCS-2"
-#elif defined(Q_OS_FREEBSD) || defined(Q_OS_MAC)
+#elif defined(Q_OS_FREEBSD) || defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #  define NO_BOM
 #  if Q_BYTE_ORDER == Q_BIG_ENDIAN
 #    define UTF16 "UTF-16BE"
diff --git a/src/corelib/concurrent/qtconcurrentiteratekernel.cpp b/src/corelib/concurrent/qtconcurrentiteratekernel.cpp
index 783abe5..375ea7c 100644
--- a/src/corelib/concurrent/qtconcurrentiteratekernel.cpp
+++ b/src/corelib/concurrent/qtconcurrentiteratekernel.cpp
@@ -41,7 +41,7 @@
 
 #include "qtconcurrentiteratekernel.h"
 
-#if defined(Q_OS_MAC)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #include <mach/mach.h>
 #include <mach/mach_time.h>
 #include <unistd.h>
@@ -67,7 +67,7 @@ enum {
     MedianSize = 7
 };
 
-#if defined(Q_OS_MAC)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 
 static qint64 getticks()
 {
diff --git a/src/corelib/corelib.pro b/src/corelib/corelib.pro
index 9a15bf1..aaea7ec 100644
--- a/src/corelib/corelib.pro
+++ b/src/corelib/corelib.pro
@@ -18,7 +18,7 @@ include(codecs/codecs.pri)
 include(statemachine/statemachine.pri)
 include(xml/xml.pri)
 
-mac|darwin:LIBS_PRIVATE += -framework ApplicationServices
+mac:LIBS_PRIVATE += -framework ApplicationServices
 
 mac:lib_bundle:DEFINES += QT_NO_DEBUG_PLUGIN_CHECK
 win32:DEFINES-=QT_NO_CAST_TO_ASCII
diff --git a/src/corelib/global/qglobal.cpp b/src/corelib/global/qglobal.cpp
index cec0cb8..d36d064 100644
--- a/src/corelib/global/qglobal.cpp
+++ b/src/corelib/global/qglobal.cpp
@@ -1260,7 +1260,7 @@ bool qSharedBuild()
     \macro Q_OS_DARWIN
     \relates <QtGlobal>
 
-    Defined on Darwin OS (synonym for Q_OS_MAC).
+    Defined on Darwin OS.
 */
 
 /*!
diff --git a/src/corelib/global/qglobal.h b/src/corelib/global/qglobal.h
index 8973bf2..994f6a1 100644
--- a/src/corelib/global/qglobal.h
+++ b/src/corelib/global/qglobal.h
@@ -128,7 +128,7 @@ namespace QT_NAMESPACE {}
 
 #endif /* __cplusplus */
 
-#if defined(Q_OS_MAC) && !defined(Q_CC_INTEL)
+#if ( defined(Q_OS_DARWIN) || defined(Q_OS_MAC) ) && !defined(Q_CC_INTEL)
 #define QT_BEGIN_HEADER extern "C++" {
 #define QT_END_HEADER }
 #define QT_BEGIN_INCLUDE_HEADER }
@@ -143,7 +143,7 @@ namespace QT_NAMESPACE {}
 /*
    The operating system, must be one of: (Q_OS_x)
 
-     DARWIN   - Darwin OS (synonym for Q_OS_MAC)
+     DARWIN   - Darwin OS (pure Darwin or Mac OS X using X11)
      SYMBIAN  - Symbian
      MSDOS    - MS-DOS and Windows
      OS2      - OS/2
@@ -265,12 +265,15 @@ namespace QT_NAMESPACE {}
 #  define Q_OS_WIN
 #endif
 
-#if defined(Q_OS_DARWIN)
+#if defined(Q_OS_DARWIN) && !defined(__USE_WS_X11__)
+#  undef Q_OS_DARWIN
 #  define Q_OS_MAC /* Q_OS_MAC is mostly for compatibility, but also more clear */
 #  define Q_OS_MACX /* Q_OS_MACX is only for compatibility.*/
 #  if defined(Q_OS_DARWIN64)
+#     undef Q_OS_DARWIN64
 #     define Q_OS_MAC64
 #  elif defined(Q_OS_DARWIN32)
+#     undef Q_OS_DARWIN32
 #     define Q_OS_MAC32
 #  endif
 #endif
@@ -294,11 +297,11 @@ namespace QT_NAMESPACE {}
 #  define Q_OS_UNIX
 #endif
 
-#if defined(Q_OS_DARWIN) && !defined(QT_LARGEFILE_SUPPORT)
+#if ( defined(Q_OS_DARWIN) || defined(Q_OS_MAC) ) && !defined(QT_LARGEFILE_SUPPORT)
 #  define QT_LARGEFILE_SUPPORT 64
 #endif
 
-#ifdef Q_OS_DARWIN
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #  ifdef MAC_OS_X_VERSION_MIN_REQUIRED
 #    undef MAC_OS_X_VERSION_MIN_REQUIRED
 #  endif
@@ -485,7 +488,7 @@ namespace QT_NAMESPACE {}
 #    define Q_NO_TEMPLATE_FRIENDS
 #  endif
 /* Apple's GCC 3.1 chokes on our streaming qDebug() */
-#  if defined(Q_OS_DARWIN) && __GNUC__ == 3 && (__GNUC_MINOR__ >= 1 && __GNUC_MINOR__ < 3)
+#  if ( defined(Q_OS_DARWIN) || defined(Q_OS_MAC) ) && __GNUC__ == 3 && (__GNUC_MINOR__ >= 1 && __GNUC_MINOR__ < 3)
 #    define Q_BROKEN_DEBUG_STREAM
 #  endif
 #  if (defined(Q_CC_GNU) || defined(Q_CC_INTEL)) && !defined(QT_MOC_CPP)
@@ -804,7 +807,7 @@ namespace QT_NAMESPACE {}
 #  define Q_WS_PM
 #  error "Qt does not work with OS/2 Presentation Manager or Workplace Shell"
 #elif defined(Q_OS_UNIX)
-#  if defined(Q_OS_MAC) && !defined(__USE_WS_X11__) && !defined(Q_WS_QWS)
+#  if defined(Q_OS_MAC) && !defined(Q_WS_QWS)
 #    define Q_WS_MAC
 #    define Q_WS_MACX
 #    if defined(Q_OS_MAC64)
@@ -1465,7 +1468,7 @@ public:
     static WinVersion windowsVersion();
 
 #endif
-#ifdef Q_OS_MAC
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
     enum MacVersion {
         MV_Unknown = 0x0000,
 
@@ -2078,7 +2081,7 @@ Q_DECLARE_TYPEINFO(qint64, Q_PRIMITIVE_TYPE);
 Q_DECLARE_TYPEINFO(quint64, Q_PRIMITIVE_TYPE);
 Q_DECLARE_TYPEINFO(float, Q_PRIMITIVE_TYPE);
 Q_DECLARE_TYPEINFO(double, Q_PRIMITIVE_TYPE);
-#ifndef Q_OS_DARWIN
+#if !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
 Q_DECLARE_TYPEINFO(long double, Q_PRIMITIVE_TYPE);
 #endif
 
diff --git a/src/corelib/io/qfile.cpp b/src/corelib/io/qfile.cpp
index 6cfe0c9..6f0f991 100644
--- a/src/corelib/io/qfile.cpp
+++ b/src/corelib/io/qfile.cpp
@@ -62,7 +62,7 @@ static const int QFILE_WRITEBUFFER_SIZE = 16384;
 
 static QByteArray locale_encode(const QString &f)
 {
-#ifndef Q_OS_DARWIN
+#if !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
     return f.toLocal8Bit();
 #else
     // Mac always expects UTF-8... and decomposed...
@@ -72,7 +72,7 @@ static QByteArray locale_encode(const QString &f)
 
 static QString locale_decode(const QByteArray &f)
 {
-#ifndef Q_OS_DARWIN
+#if !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
     return QString::fromLocal8Bit(f);
 #else
     // Mac always gives us UTF-8 and decomposed, we want that composed...
diff --git a/src/corelib/io/qfilesystemwatcher.cpp b/src/corelib/io/qfilesystemwatcher.cpp
index c810f44..7fc7749 100644
--- a/src/corelib/io/qfilesystemwatcher.cpp
+++ b/src/corelib/io/qfilesystemwatcher.cpp
@@ -57,8 +57,8 @@
 #elif defined(Q_OS_LINUX)
 #  include "qfilesystemwatcher_inotify_p.h"
 #  include "qfilesystemwatcher_dnotify_p.h"
-#elif defined(Q_OS_FREEBSD) || defined(Q_OS_MAC)
-#  if (defined Q_OS_MAC) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
+#elif defined(Q_OS_FREEBSD) || defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
+#  if ( (defined Q_OS_DARWIN || defined Q_OS_MAC) ) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
 #  include "qfilesystemwatcher_fsevents_p.h"
 #  endif //MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
 #  include "qfilesystemwatcher_kqueue_p.h"
@@ -247,7 +247,7 @@ QFileSystemWatcherEngine *QFileSystemWatcherPrivate::createNativeEngine()
     if(!eng)
         eng = QDnotifyFileSystemWatcherEngine::create();
     return eng;
-#elif defined(Q_OS_FREEBSD) || defined(Q_OS_MAC)
+#elif defined(Q_OS_FREEBSD) || defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #  if 0 && (defined Q_OS_MAC) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
     if (QSysInfo::MacintoshVersion >= QSysInfo::MV_10_5)
         return QFSEventsFileSystemWatcherEngine::create();
diff --git a/src/corelib/io/qfsfileengine_unix.cpp b/src/corelib/io/qfsfileengine_unix.cpp
index 9eca651..a5420b0 100644
--- a/src/corelib/io/qfsfileengine_unix.cpp
+++ b/src/corelib/io/qfsfileengine_unix.cpp
@@ -488,7 +488,7 @@ bool QFSFileEngine::mkdir(const QString &name, bool createParentDirectories) con
         }
         return true;
     }
-#if defined(Q_OS_DARWIN)  // Mac X doesn't support trailing /'s
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC) // Mac X doesn't support trailing /'s
     if (dirName.endsWith(QLatin1Char('/')))
         dirName.chop(1);
 #endif
diff --git a/src/corelib/io/qprocess.cpp b/src/corelib/io/qprocess.cpp
index 43d317c..3b38523 100644
--- a/src/corelib/io/qprocess.cpp
+++ b/src/corelib/io/qprocess.cpp
@@ -2166,7 +2166,7 @@ bool QProcess::startDetached(const QString &program)
 }
 
 QT_BEGIN_INCLUDE_NAMESPACE
-#ifdef Q_OS_MAC
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 # include <crt_externs.h>
 # define environ (*_NSGetEnviron())
 #elif defined(Q_OS_WINCE) || defined(Q_OS_SYMBIAN)
diff --git a/src/corelib/io/qprocess_unix.cpp b/src/corelib/io/qprocess_unix.cpp
index 3a2edf8..96956a0 100644
--- a/src/corelib/io/qprocess_unix.cpp
+++ b/src/corelib/io/qprocess_unix.cpp
@@ -471,7 +471,7 @@ static char **_q_dupEnvironment(const QHash<QByteArray, QByteArray> &environment
     // if LD_LIBRARY_PATH exists in the current environment, but
     // not in the environment list passed by the programmer, then
     // copy it over.
-#if defined(Q_OS_MAC)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
     static const char libraryPath[] = "DYLD_LIBRARY_PATH";
 #else
     static const char libraryPath[] = "LD_LIBRARY_PATH";
@@ -584,7 +584,7 @@ void QProcessPrivate::startProcess()
     // Add every argument to the list
     for (int i = 0; i < arguments.count(); ++i) {
         QString arg = arguments.at(i);
-#ifdef Q_OS_MAC
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
         // Mac OS X uses UTF8 for exec, regardless of the system locale.
         argv[i + 1] = ::strdup(arg.toUtf8().constData());
 #else
@@ -1207,7 +1207,7 @@ bool QProcessPrivate::startDetached(const QString &program, const QStringList &a
 
             char **argv = new char *[arguments.size() + 2];
             for (int i = 0; i < arguments.size(); ++i) {
-#ifdef Q_OS_MAC
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
                 argv[i + 1] = ::strdup(arguments.at(i).toUtf8().constData());
 #else
                 argv[i + 1] = ::strdup(arguments.at(i).toLocal8Bit().constData());
diff --git a/src/corelib/kernel/qcore_unix.cpp b/src/corelib/kernel/qcore_unix.cpp
index a67f23c..ad2dbe8 100644
--- a/src/corelib/kernel/qcore_unix.cpp
+++ b/src/corelib/kernel/qcore_unix.cpp
@@ -50,7 +50,7 @@
 
 #include <stdlib.h>
 
-#ifdef Q_OS_MAC
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #include <mach/mach_time.h>
 #endif
 
@@ -64,7 +64,7 @@ QT_BEGIN_NAMESPACE
 
 bool qt_gettime_is_monotonic()
 {
-#if (_POSIX_MONOTONIC_CLOCK-0 > 0) || defined(Q_OS_MAC)
+#if (_POSIX_MONOTONIC_CLOCK-0 > 0) || defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
     return true;
 #else
     static int returnValue = 0;
@@ -86,7 +86,7 @@ bool qt_gettime_is_monotonic()
 timeval qt_gettime()
 {
     timeval tv;
-#if defined(Q_OS_MAC)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
     static mach_timebase_info_data_t info = {0,0};
     if (info.denom == 0)
         mach_timebase_info(&info);
diff --git a/src/corelib/kernel/qeventdispatcher_unix.cpp b/src/corelib/kernel/qeventdispatcher_unix.cpp
index 8147c22..33b0ad9 100644
--- a/src/corelib/kernel/qeventdispatcher_unix.cpp
+++ b/src/corelib/kernel/qeventdispatcher_unix.cpp
@@ -313,7 +313,7 @@ QTimerInfoList::QTimerInfoList()
 {
     currentTime = qt_gettime();
 
-#if (_POSIX_MONOTONIC_CLOCK-0 <= 0) && !defined(Q_OS_MAC)
+#if (_POSIX_MONOTONIC_CLOCK-0 <= 0) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
     if (!qt_gettime_is_monotonic()) {
         // not using monotonic timers, initialize the timeChanged() machinery
         previousTime = currentTime;
@@ -340,7 +340,7 @@ timeval QTimerInfoList::updateCurrentTime()
     return (currentTime = qt_gettime());
 }
 
-#if ((_POSIX_MONOTONIC_CLOCK-0 <= 0) && !defined(Q_OS_MAC)) || defined(QT_BOOTSTRAPPED)
+#if ((_POSIX_MONOTONIC_CLOCK-0 <= 0) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)) || defined(QT_BOOTSTRAPPED)
 
 template <>
 timeval qAbs(const timeval &t)
diff --git a/src/corelib/kernel/qeventdispatcher_unix_p.h b/src/corelib/kernel/qeventdispatcher_unix_p.h
index 838c270..26f0759 100644
--- a/src/corelib/kernel/qeventdispatcher_unix_p.h
+++ b/src/corelib/kernel/qeventdispatcher_unix_p.h
@@ -82,7 +82,7 @@ struct QTimerInfo {
 
 class QTimerInfoList : public QList<QTimerInfo*>
 {
-#if ((_POSIX_MONOTONIC_CLOCK-0 <= 0) && !defined(Q_OS_MAC)) || defined(QT_BOOTSTRAPPED)
+#if ((_POSIX_MONOTONIC_CLOCK-0 <= 0) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)) || defined(QT_BOOTSTRAPPED)
     timeval previousTime;
     clock_t previousTicks;
     int ticksPerSecond;
diff --git a/src/corelib/kernel/qobject.cpp b/src/corelib/kernel/qobject.cpp
index fc6ac33..c2efdf3 100644
--- a/src/corelib/kernel/qobject.cpp
+++ b/src/corelib/kernel/qobject.cpp
@@ -1124,8 +1124,16 @@ void QObject::setObjectName(const QString &name)
 {
     Q_D(QObject);
     d->objectName = name;
+#if defined(Q_WS_X11)
+    d->checkWindowRole();
+#endif
 }
 
+#if defined(Q_WS_X11)
+void QObjectPrivate::checkWindowRole()
+{
+}
+#endif
 
 #ifdef QT3_SUPPORT
 /*! \internal
@@ -1478,7 +1486,7 @@ void QObject::moveToThread(QThread *targetThread)
                  "Cannot move to target thread (%p)\n",
                  d->threadData->thread, currentData->thread, targetData->thread);
 
-#ifdef Q_WS_MAC
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
         qWarning("On Mac OS X, you might be loading two sets of Qt binaries into the same process. "
                  "Check that all plugins are compiled against the right Qt binaries. Export "
                  "DYLD_PRINT_LIBRARIES=1 and check that only one set of binaries are being loaded.");
diff --git a/src/corelib/kernel/qobject_p.h b/src/corelib/kernel/qobject_p.h
index 7e7cbf8..5a312d1 100644
--- a/src/corelib/kernel/qobject_p.h
+++ b/src/corelib/kernel/qobject_p.h
@@ -83,7 +83,9 @@ void Q_CORE_EXPORT qt_register_signal_spy_callbacks(const QSignalSpyCallbackSet
 
 extern QSignalSpyCallbackSet Q_CORE_EXPORT qt_signal_spy_callback_set;
 
-enum { QObjectPrivateVersion = QT_VERSION };
+// add 0x1000000 to mark it as qt-copy version, with possible modifications
+// in some Q*Private class
+enum { QObjectPrivateVersion = QT_VERSION + 0x1000000 };
 
 class Q_CORE_EXPORT QDeclarativeData
 {
@@ -157,6 +159,9 @@ public:
     void sendPendingChildInsertedEvents();
     void removePendingChildInsertedEvents(QObject *child);
 #endif
+#if defined(Q_WS_X11)
+    virtual void checkWindowRole();
+#endif
 
     static Sender *setCurrentSender(QObject *receiver,
                                     Sender *sender);
diff --git a/src/corelib/plugin/qlibrary.cpp b/src/corelib/plugin/qlibrary.cpp
index 2c8f503..5e58433 100644
--- a/src/corelib/plugin/qlibrary.cpp
+++ b/src/corelib/plugin/qlibrary.cpp
@@ -556,7 +556,7 @@ bool QLibrary::isLibrary(const QString &fileName)
     if (completeSuffix.isEmpty())
         return false;
     QStringList suffixes = completeSuffix.split(QLatin1Char('.'));
-# if defined(Q_OS_DARWIN)
+# if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 
     // On Mac, libs look like libmylib.1.0.0.dylib
     const QString lastSuffix = suffixes.at(suffixes.count() - 1);
diff --git a/src/corelib/plugin/qlibrary_unix.cpp b/src/corelib/plugin/qlibrary_unix.cpp
index 8f73c91..83a7035 100644
--- a/src/corelib/plugin/qlibrary_unix.cpp
+++ b/src/corelib/plugin/qlibrary_unix.cpp
@@ -143,7 +143,7 @@ bool QLibraryPrivate::load_sys()
             suffixes << QLatin1String(".so");
         }
 #endif
-# ifdef Q_OS_MAC
+# if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
         if (!fullVersion.isEmpty()) {
             suffixes << QString::fromLatin1(".%1.bundle").arg(fullVersion);
             suffixes << QString::fromLatin1(".%1.dylib").arg(fullVersion);
diff --git a/src/corelib/thread/qthread.cpp b/src/corelib/thread/qthread.cpp
index a7c2a16..bde66f3 100644
--- a/src/corelib/thread/qthread.cpp
+++ b/src/corelib/thread/qthread.cpp
@@ -64,7 +64,7 @@
 /*
 #  elif defined(Q_OS_HPUX)
 #   include <sys/pstat.h>
-#  elif defined(Q_OS_FREEBSD) || defined(Q_OS_OPENBSD) || defined(Q_OS_MAC)
+#  elif defined(Q_OS_FREEBSD) || defined(Q_OS_OPENBSD) || defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #   include <sys/sysctl.h>
 #  endif
 #endif
diff --git a/src/corelib/thread/qthread_unix.cpp b/src/corelib/thread/qthread_unix.cpp
index f1c5835..3fac5d9 100644
--- a/src/corelib/thread/qthread_unix.cpp
+++ b/src/corelib/thread/qthread_unix.cpp
@@ -661,7 +661,7 @@ void QThread::setPriority(Priority priority)
 
     // copied from start() with a few modifications:
 
-#if defined(Q_OS_DARWIN) || !defined(Q_OS_OPENBSD) && defined(_POSIX_THREAD_PRIORITY_SCHEDULING) && (_POSIX_THREAD_PRIORITY_SCHEDULING-0 >= 0)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC) || ( !defined(Q_OS_OPENBSD) && defined(_POSIX_THREAD_PRIORITY_SCHEDULING) && (_POSIX_THREAD_PRIORITY_SCHEDULING-0 >= 0) )
     int sched_policy;
     sched_param param;
 
diff --git a/src/corelib/tools/qsharedpointer.cpp b/src/corelib/tools/qsharedpointer.cpp
index c684dc5..5c852f7 100644
--- a/src/corelib/tools/qsharedpointer.cpp
+++ b/src/corelib/tools/qsharedpointer.cpp
@@ -1281,7 +1281,7 @@ QT_END_NAMESPACE
 #  ifdef QT_SHARED_POINTER_BACKTRACE_SUPPORT
 #    if defined(__GLIBC__) && (__GLIBC__ >= 2) && !defined(__UCLIBC__) && !defined(QT_LINUXBASE)
 #      define BACKTRACE_SUPPORTED
-#    elif defined(Q_OS_MACX)
+#    elif defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #      define BACKTRACE_SUPPORTED
 #    endif
 #  endif
diff --git a/src/corelib/xml/qxmlstream.cpp b/src/corelib/xml/qxmlstream.cpp
index 3edfeae..508c725 100644
--- a/src/corelib/xml/qxmlstream.cpp
+++ b/src/corelib/xml/qxmlstream.cpp
@@ -41,7 +41,7 @@
 
 #include "QtCore/qxmlstream.h"
 
-#if defined(QT_BUILD_XML_LIB) && defined(Q_OS_MAC64)
+#if defined(QT_BUILD_XML_LIB) && (defined(Q_OS_DARWIN64) || defined(Q_OS_MAC64))
 // No need to define this in the 64-bit Mac libraries.
 // Since Qt 4.4 and previous weren't supported in 64-bit, there are
 // no QXmlStream* symbols to keep compatibility with
diff --git a/src/corelib/xml/qxmlstream.h b/src/corelib/xml/qxmlstream.h
index 786e1cc..3a6c885 100644
--- a/src/corelib/xml/qxmlstream.h
+++ b/src/corelib/xml/qxmlstream.h
@@ -85,7 +85,7 @@ QT_MODULE(Core)
 // We are taking the optimist scenario here to avoid creating more
 // symbols to be supported.
 
-#if defined(Q_OS_MAC32) || defined(Q_OS_AIX)
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32) || defined(Q_OS_AIX)
 # if !defined QT_BUILD_XML_LIB
 #  define Q_XMLSTREAM_RENAME_SYMBOLS
 # endif
diff --git a/src/gui/embedded/qlock.cpp b/src/gui/embedded/qlock.cpp
index 170c259..54f43d2 100644
--- a/src/gui/embedded/qlock.cpp
+++ b/src/gui/embedded/qlock.cpp
@@ -86,11 +86,11 @@ QT_END_NAMESPACE
 
 #include <unistd.h>
 #include <sys/types.h>
-#if defined(Q_OS_DARWIN)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #   define Q_NO_SEMAPHORE
 #   include <sys/stat.h>
 #   include <sys/file.h>
-#else // Q_OS_DARWIN
+#else // Q_OS_DARWIN || Q_OS_MAC
 #   include <sys/sem.h>
 #   if (defined(__GNU_LIBRARY__) && !defined(_SEM_SEMUN_UNDEFINED) && !defined(QT_LINUXBASE)) \
     || defined(Q_OS_FREEBSD) || defined(Q_OS_OPENBSD) || defined(Q_OS_NETBSD) \
@@ -104,7 +104,7 @@ union semun {
     unsigned short *array;      /* array for GETALL, SETALL */
 };
 #   endif
-#endif // Q_OS_DARWIN
+#endif // Q_OS_DARWIN || Q_OS_MAC
 #include <sys/ipc.h>
 #include <string.h>
 #include <errno.h>
diff --git a/src/gui/embedded/qscreenlinuxfb_qws.cpp b/src/gui/embedded/qscreenlinuxfb_qws.cpp
index f3fd7cb..71417ee 100644
--- a/src/gui/embedded/qscreenlinuxfb_qws.cpp
+++ b/src/gui/embedded/qscreenlinuxfb_qws.cpp
@@ -63,7 +63,7 @@
 
 #include "qwindowsystem_qws.h"
 
-#if !defined(Q_OS_DARWIN) && !defined(Q_OS_FREEBSD)
+#if !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC) && !defined(Q_OS_FREEBSD)
 #include <linux/fb.h>
 
 #ifdef __i386__
diff --git a/src/gui/embedded/qsoundqss_qws.h b/src/gui/embedded/qsoundqss_qws.h
index e8a14df..de4fd63 100644
--- a/src/gui/embedded/qsoundqss_qws.h
+++ b/src/gui/embedded/qsoundqss_qws.h
@@ -60,7 +60,7 @@ QT_MODULE(Gui)
 #define QT_NO_QWS_SOUNDSERVER
 #endif
 
-#ifndef Q_OS_MAC
+#if !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
 
 class QWSSoundServerPrivate;
 
@@ -166,7 +166,7 @@ Q_SIGNALS:
 };
 #endif
 
-#endif // Q_OS_MAC
+#endif // !Q_OS_DARWIN && !Q_OS_MAC
 
 QT_END_NAMESPACE
 
diff --git a/src/gui/embedded/qwindowsystem_qws.cpp b/src/gui/embedded/qwindowsystem_qws.cpp
index 7526b98..41e9127 100644
--- a/src/gui/embedded/qwindowsystem_qws.cpp
+++ b/src/gui/embedded/qwindowsystem_qws.cpp
@@ -94,7 +94,7 @@
 #include <sys/mount.h>
 #endif
 
-#if !defined(QT_NO_SOUND) && !defined(Q_OS_DARWIN)
+#if !defined(QT_NO_SOUND) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
 #ifdef QT_USE_OLD_QWS_SOUND
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -1445,7 +1445,7 @@ void QWSServerPrivate::initServer(int flags)
     }
 #endif
 
-#if !defined(QT_NO_SOUND) && !defined(QT_EXTERNAL_SOUND_SERVER) && !defined(Q_OS_DARWIN)
+#if !defined(QT_NO_SOUND) && !defined(QT_EXTERNAL_SOUND_SERVER) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
     soundserver = new QWSSoundServer(q);
 #endif
 }
@@ -1977,7 +1977,7 @@ void QWSServerPrivate::doClient(QWSClient *client)
         case QWSCommand::GrabKeyboard:
             invokeGrabKeyboard((QWSGrabKeyboardCommand*)cs->command, cs->client);
             break;
-#if !defined(QT_NO_SOUND) && !defined(Q_OS_DARWIN)
+#if !defined(QT_NO_SOUND) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
         case QWSCommand::PlaySound:
             invokePlaySound((QWSPlaySoundCommand*)cs->command, cs->client);
             break;
@@ -3200,7 +3200,7 @@ void QWSServerPrivate::invokeGrabKeyboard(QWSGrabKeyboardCommand *cmd, QWSClient
 #if !defined(QT_NO_SOUND)
 void QWSServerPrivate::invokePlaySound(QWSPlaySoundCommand *cmd, QWSClient *)
 {
-#if !defined(QT_EXTERNAL_SOUND_SERVER) && !defined(Q_OS_DARWIN)
+#if !defined(QT_EXTERNAL_SOUND_SERVER) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
     soundserver->playFile( 1, cmd->filename );
 #else
     Q_UNUSED(cmd);
diff --git a/src/gui/kernel/qapplication_qws.cpp b/src/gui/kernel/qapplication_qws.cpp
index 00f24d7..a7cb94a 100644
--- a/src/gui/kernel/qapplication_qws.cpp
+++ b/src/gui/kernel/qapplication_qws.cpp
@@ -116,7 +116,7 @@
 #ifdef QT_NO_QSHM
 #include <sys/ipc.h>
 #include <sys/shm.h>
-#ifndef Q_OS_DARWIN
+#if !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
 # include <sys/sem.h>
 #endif
 #include <sys/socket.h>
diff --git a/src/gui/kernel/qeventdispatcher_mac.mm b/src/gui/kernel/qeventdispatcher_mac.mm
index ead7a94..37bb889 100644
--- a/src/gui/kernel/qeventdispatcher_mac.mm
+++ b/src/gui/kernel/qeventdispatcher_mac.mm
@@ -125,7 +125,7 @@ static inline CFRunLoopRef mainRunLoop()
 void QEventDispatcherMacPrivate::activateTimer(CFRunLoopTimerRef, void *info)
 {
     int timerID =
-#ifdef Q_OS_MAC64
+#if defined(Q_OS_DARWIN64) || defined(Q_OS_MAC64)
     qint64(info);
 #else
     int(info);
diff --git a/src/gui/kernel/qkeymapper_mac.cpp b/src/gui/kernel/qkeymapper_mac.cpp
index 15da0b9..2c8a428 100644
--- a/src/gui/kernel/qkeymapper_mac.cpp
+++ b/src/gui/kernel/qkeymapper_mac.cpp
@@ -396,7 +396,7 @@ static Boolean qt_KeyEventComparatorProc(EventRef inEvent, void *data)
 static bool translateKeyEventInternal(EventHandlerCallRef er, EventRef keyEvent, int *qtKey,
                                       QChar *outChar, Qt::KeyboardModifiers *outModifiers, bool *outHandled)
 {
-#if !defined(QT_MAC_USE_COCOA) || defined(Q_OS_MAC64)
+#if !defined(QT_MAC_USE_COCOA) || defined(Q_OS_DARWIN64) || defined(Q_OS_MAC64)
     Q_UNUSED(er);
     Q_UNUSED(outHandled);
 #endif
@@ -421,7 +421,7 @@ static bool translateKeyEventInternal(EventHandlerCallRef er, EventRef keyEvent,
     //get mac mapping
     static UInt32 tmp_unused_state = 0L;
     const UCKeyboardLayout *uchrData = 0;
-#if defined(Q_OS_MAC32)
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
     KeyboardLayoutRef keyLayoutRef = 0;
     KLGetCurrentKeyboardLayout(&keyLayoutRef);
     OSStatus err;
@@ -481,7 +481,7 @@ static bool translateKeyEventInternal(EventHandlerCallRef er, EventRef keyEvent,
                      long(err), __FILE__, __LINE__);
         }
     }
-#ifdef Q_OS_MAC32
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
     else {
         // The road less travelled; use KeyTranslate
         const void *keyboard_layout;
@@ -554,7 +554,7 @@ QKeyMapperPrivate::QKeyMapperPrivate()
 {
     memset(keyLayout, 0, sizeof(keyLayout));
     keyboard_layout_format.unicode = 0;
-#ifdef Q_OS_MAC32
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
     keyboard_mode = NullMode;
 #else
     currentInputSource = 0;
@@ -570,7 +570,7 @@ bool
 QKeyMapperPrivate::updateKeyboard()
 {
     const UCKeyboardLayout *uchrData = 0;
-#ifdef Q_OS_MAC32
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
     KeyboardLayoutRef keyLayoutRef = 0;
     KLGetCurrentKeyboardLayout(&keyLayoutRef);
 
@@ -602,7 +602,7 @@ QKeyMapperPrivate::updateKeyboard()
         keyboard_layout_format.unicode = uchrData;
         keyboard_mode = UnicodeMode;
     }
-#ifdef Q_OS_MAC32
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
     else {
         void *happy;
         err = KLGetKeyboardLayoutProperty(keyLayoutRef, kKLKCHRData,
@@ -621,7 +621,7 @@ QKeyMapperPrivate::updateKeyboard()
 #endif
     keyboard_dead = 0;
     CFStringRef iso639Code;
-#ifdef Q_OS_MAC32
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
 # ifndef kKLLanguageCode
 # define kKLLanguageCode 9
 # endif
diff --git a/src/gui/kernel/qkeysequence.cpp b/src/gui/kernel/qkeysequence.cpp
index b9e5570..9afcf1f 100644
--- a/src/gui/kernel/qkeysequence.cpp
+++ b/src/gui/kernel/qkeysequence.cpp
@@ -1153,10 +1153,10 @@ int QKeySequencePrivate::decodeString(const QString &str, QKeySequence::Sequence
 
     QList<QModifKeyName> modifs;
     if (nativeText) {
-        modifs << QModifKeyName(Qt::CTRL, QShortcut::tr("Ctrl").toLower().append(QLatin1Char('+')))
-               << QModifKeyName(Qt::SHIFT, QShortcut::tr("Shift").toLower().append(QLatin1Char('+')))
-               << QModifKeyName(Qt::ALT, QShortcut::tr("Alt").toLower().append(QLatin1Char('+')))
-               << QModifKeyName(Qt::META, QShortcut::tr("Meta").toLower().append(QLatin1Char('+')));
+        modifs << QModifKeyName(Qt::CTRL, QShortcut::tr("Ctrl", "Ctrl key, used for shortcuts").toLower().append(QLatin1Char('+')))
+               << QModifKeyName(Qt::SHIFT, QShortcut::tr("Shift", "Shift key, used for shortcuts").toLower().append(QLatin1Char('+')))
+               << QModifKeyName(Qt::ALT, QShortcut::tr("Alt", "Alt key, used for shortcuts").toLower().append(QLatin1Char('+')))
+               << QModifKeyName(Qt::META, QShortcut::tr("Meta", "Meta key, used for shortcuts").toLower().append(QLatin1Char('+')));
     }
     modifs += *gmodifs; // Test non-translated ones last
 
@@ -1246,7 +1246,7 @@ QString QKeySequence::encodeString(int key)
 static inline void addKey(QString &str, const QString &theKey, QKeySequence::SequenceFormat format)
 {
     if (!str.isEmpty())
-        str += (format == QKeySequence::NativeText) ? QShortcut::tr("+")
+        str += (format == QKeySequence::NativeText) ? QShortcut::tr("+", "Symbol used to concatenate keys in shortcuts")
                                                     : QString::fromLatin1("+");
     str += theKey;
 }
@@ -1286,13 +1286,13 @@ QString QKeySequencePrivate::encodeString(int key, QKeySequence::SequenceFormat
     {
         // On other systems the order is Meta, Control, Alt, Shift
         if ((key & Qt::META) == Qt::META)
-            s = nativeText ? QShortcut::tr("Meta") : QString::fromLatin1("Meta");
+            s = nativeText ? QShortcut::tr("Meta", "Meta key, used for shortcuts") : QString::fromLatin1("Meta");
         if ((key & Qt::CTRL) == Qt::CTRL)
-            addKey(s, nativeText ? QShortcut::tr("Ctrl") : QString::fromLatin1("Ctrl"), format);
+            addKey(s, nativeText ? QShortcut::tr("Ctrl", "Ctrl key, used for shortcuts") : QString::fromLatin1("Ctrl"), format);
         if ((key & Qt::ALT) == Qt::ALT)
-            addKey(s, nativeText ? QShortcut::tr("Alt") : QString::fromLatin1("Alt"), format);
+            addKey(s, nativeText ? QShortcut::tr("Alt", "Alt key, used for shortcuts") : QString::fromLatin1("Alt"), format);
         if ((key & Qt::SHIFT) == Qt::SHIFT)
-            addKey(s, nativeText ? QShortcut::tr("Shift") : QString::fromLatin1("Shift"), format);
+            addKey(s, nativeText ? QShortcut::tr("Shift", "Shift key, used for shortcuts") : QString::fromLatin1("Shift"), format);
     }
 
 
@@ -1307,7 +1307,7 @@ QString QKeySequencePrivate::encodeString(int key, QKeySequence::SequenceFormat
             p += QChar((key-0x10000)%400+0xdc00);
         }
     } else if (key >= Qt::Key_F1 && key <= Qt::Key_F35) {
-            p = nativeText ? QShortcut::tr("F%1").arg(key - Qt::Key_F1 + 1)
+            p = nativeText ? QShortcut::tr("F%1", "Fx key, used for shortcuts").arg(key - Qt::Key_F1 + 1)
                            : QString::fromLatin1("F%1").arg(key - Qt::Key_F1 + 1);
     } else if (key) {
         int i=0;
diff --git a/src/gui/kernel/qt_mac.cpp b/src/gui/kernel/qt_mac.cpp
index 20f24ce..1d287e1 100644
--- a/src/gui/kernel/qt_mac.cpp
+++ b/src/gui/kernel/qt_mac.cpp
@@ -128,7 +128,7 @@ QColor qcolorForTheme(ThemeBrush brush)
 
 QColor qcolorForThemeTextColor(ThemeTextColor themeColor)
 {
-#ifdef Q_OS_MAC32
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
     RGBColor c;
     GetThemeTextColor(themeColor, 32, true, &c);
     QColor color = QColor(c.red / 256, c.green / 256, c.blue / 256);
diff --git a/src/gui/kernel/qwidget_p.h b/src/gui/kernel/qwidget_p.h
index 98d3001..d3a386b 100644
--- a/src/gui/kernel/qwidget_p.h
+++ b/src/gui/kernel/qwidget_p.h
@@ -691,6 +691,7 @@ public:
     static QWidget *keyboardGrabber;
 
     void setWindowRole();
+    virtual void checkWindowRole();
     void sendStartupMessage(const char *message) const;
     void setNetWmWindowTypes();
     void x11UpdateIsOpaque();
diff --git a/src/gui/kernel/qwidget_x11.cpp b/src/gui/kernel/qwidget_x11.cpp
index 87c9885..73600fc 100644
--- a/src/gui/kernel/qwidget_x11.cpp
+++ b/src/gui/kernel/qwidget_x11.cpp
@@ -763,6 +763,11 @@ void QWidgetPrivate::create_sys(WId window, bool initializeWindow, bool destroyO
         Q_ASSERT(id);
         XChangeWindowAttributes(dpy, id, CWOverrideRedirect | CWSaveUnder,
                                 &wsa);
+        XClassHint class_hint;
+        QByteArray appName = qAppName().toLatin1();
+        class_hint.res_name = appName.data(); // application name
+        class_hint.res_class = const_cast<char *>(QX11Info::appClass());   // application class
+        XSetWMProperties(dpy, id, 0, 0, 0, 0, 0, 0, &class_hint);
     } else if (topLevel && !desktop) {        // top-level widget
         if (!X11->wm_client_leader)
             create_wm_client_leader();
@@ -816,32 +821,40 @@ void QWidgetPrivate::create_sys(WId window, bool initializeWindow, bool destroyO
         // set EWMH window types
         setNetWmWindowTypes();
 
+        // when we create a toplevel widget, the frame strut should be dirty
+        data.fstrut_dirty = 1;
+
+    } else {
+        // non-toplevel widgets don't have a frame, so no need to
+        // update the strut
+        data.fstrut_dirty = 0;
+    }
+
+    if (initializeWindow && (popup || (topLevel && !desktop))) { // properties set on all toplevel windows
         // set _NET_WM_PID
         long curr_pid = getpid();
         XChangeProperty(dpy, id, ATOM(_NET_WM_PID), XA_CARDINAL, 32, PropModeReplace,
                         (unsigned char *) &curr_pid, 1);
 
-        // when we create a toplevel widget, the frame strut should be dirty
-        data.fstrut_dirty = 1;
 
         // declare the widget's window role
+        QByteArray windowRole;
         if (QTLWExtra *topData = maybeTopData()) {
-            if (!topData->role.isEmpty()) {
-                QByteArray windowRole = topData->role.toUtf8();
-                XChangeProperty(dpy, id,
-                                ATOM(WM_WINDOW_ROLE), XA_STRING, 8, PropModeReplace,
-                                (unsigned char *)windowRole.constData(), windowRole.length());
-            }
+            if (!topData->role.isEmpty())
+                windowRole = topData->role.toUtf8();
+        }
+        if (windowRole.isEmpty()) // use object name as a fallback
+            windowRole = objectName.toUtf8();
+        if (!windowRole.isEmpty()) {
+            XChangeProperty(dpy, id,
+                            ATOM(WM_WINDOW_ROLE), XA_STRING, 8, PropModeReplace,
+                            (unsigned char *)windowRole.constData(), windowRole.length());
         }
 
         // set client leader property
         XChangeProperty(dpy, id, ATOM(WM_CLIENT_LEADER),
                         XA_WINDOW, 32, PropModeReplace,
                         (unsigned char *)&X11->wm_client_leader, 1);
-    } else {
-        // non-toplevel widgets don't have a frame, so no need to
-        // update the strut
-        data.fstrut_dirty = 0;
     }
 
     if (initializeWindow && q->internalWinId()) {
@@ -2919,6 +2932,17 @@ void QWidgetPrivate::setWindowRole()
                     (unsigned char *)windowRole.constData(), windowRole.length());
 }
 
+void QWidgetPrivate::checkWindowRole()
+{
+    Q_Q(QWidget);
+    if( !q->windowRole().isEmpty() || !q->internalWinId())
+        return;
+    QByteArray windowRole = objectName.toUtf8(); // use as a fallback
+    XChangeProperty(X11->display, q->internalWinId(),
+                    ATOM(WM_WINDOW_ROLE), XA_STRING, 8, PropModeReplace,
+                    (unsigned char *)windowRole.constData(), windowRole.length());
+}
+
 Q_GLOBAL_STATIC(QX11PaintEngine, qt_widget_paintengine)
 QPaintEngine *QWidget::paintEngine() const
 {
diff --git a/src/gui/painting/qdrawhelper_p.h b/src/gui/painting/qdrawhelper_p.h
index 1968210..6737386 100644
--- a/src/gui/painting/qdrawhelper_p.h
+++ b/src/gui/painting/qdrawhelper_p.h
@@ -69,7 +69,7 @@
 
 // Disable MMX and SSE on Mac/PPC builds, or if the compiler
 // does not support -Xarch argument passing
-#if defined(QT_NO_MAC_XARCH) || (defined(Q_OS_DARWIN) && (defined(__ppc__) || defined(__ppc64__)))
+#if defined(QT_NO_MAC_XARCH) || ((defined(Q_OS_DARWIN) || defined(Q_OS_MAC)) && (defined(__ppc__) || defined(__ppc64__)))
 #undef QT_HAVE_SSE2
 #undef QT_HAVE_SSE
 #undef QT_HAVE_3DNOW
diff --git a/src/gui/widgets/qtabbar.cpp b/src/gui/widgets/qtabbar.cpp
index 9f03ff6..a9e4974 100644
--- a/src/gui/widgets/qtabbar.cpp
+++ b/src/gui/widgets/qtabbar.cpp
@@ -678,8 +678,8 @@ void QTabBarPrivate::refresh()
         layoutTabs();
         makeVisible(currentIndex);
         q->update();
-        q->updateGeometry();
     }
+    q->updateGeometry();
 }
 
 /*!
diff --git a/src/network/kernel/qhostinfo_unix.cpp b/src/network/kernel/qhostinfo_unix.cpp
index 2a05f05..933f6bc 100644
--- a/src/network/kernel/qhostinfo_unix.cpp
+++ b/src/network/kernel/qhostinfo_unix.cpp
@@ -148,7 +148,7 @@ QHostInfo QHostInfoAgent::fromName(const QString &hostName)
     if (address.setAddress(hostName)) {
         // Reverse lookup
 // Reverse lookups using getnameinfo are broken on darwin, use gethostbyaddr instead.
-#if !defined (QT_NO_GETADDRINFO) && !defined (Q_OS_DARWIN) && !defined (Q_OS_SYMBIAN)
+#if !defined (QT_NO_GETADDRINFO) && !defined (Q_OS_DARWIN) && !defined (Q_OS_MAC) && !defined (Q_OS_SYMBIAN)
         sockaddr_in sa4;
 #ifndef QT_NO_IPV6
         sockaddr_in6 sa6;
diff --git a/src/network/ssl/qsslsocket_openssl_symbols.cpp b/src/network/ssl/qsslsocket_openssl_symbols.cpp
index 86b94fc..5b6cade 100644
--- a/src/network/ssl/qsslsocket_openssl_symbols.cpp
+++ b/src/network/ssl/qsslsocket_openssl_symbols.cpp
@@ -320,7 +320,7 @@ static bool libGreaterThan(const QString &lhs, const QString &rhs)
 static QStringList findAllLibSsl()
 {
     QStringList paths;
-#  ifdef Q_OS_DARWIN
+#  if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
     paths = QString::fromLatin1(qgetenv("DYLD_LIBRARY_PATH"))
             .split(QLatin1Char(':'), QString::SkipEmptyParts);
 #  else
diff --git a/src/opengl/qgl_x11.cpp b/src/opengl/qgl_x11.cpp
index c5543db..90bf18e 100644
--- a/src/opengl/qgl_x11.cpp
+++ b/src/opengl/qgl_x11.cpp
@@ -54,7 +54,7 @@
 #include <private/qt_x11_p.h>
 #include <private/qpixmap_x11_p.h>
 #include <private/qimagepixmapcleanuphooks_p.h>
-#ifdef Q_OS_HPUX
+#if defined(Q_OS_HPUX) || defined(Q_OS_DARWIN)
 // for GLXPBuffer
 #include <private/qglpixelbuffer_p.h>
 #endif
@@ -1589,7 +1589,7 @@ void QGLExtensions::init()
 }
 
 // Solaris defines glXBindTexImageEXT as part of the GL library
-#if defined(GLX_VERSION_1_3) && !defined(Q_OS_HPUX)
+#if defined(GLX_VERSION_1_3) && !defined(Q_OS_HPUX) && !defined(Q_OS_DARWIN)
 typedef void (*qt_glXBindTexImageEXT)(Display*, GLXDrawable, int, const int*);
 typedef void (*qt_glXReleaseTexImageEXT)(Display*, GLXDrawable, int);
 static qt_glXBindTexImageEXT glXBindTexImageEXT = 0;
@@ -1624,7 +1624,7 @@ static bool qt_resolveTextureFromPixmap(QPaintDevice *paintDevice)
 QGLTexture *QGLContextPrivate::bindTextureFromNativePixmap(QPixmapData *pmd, const qint64 key,
                                                            QGLContext::BindOptions options)
 {
-#if !defined(GLX_VERSION_1_3) || defined(Q_OS_HPUX)
+#if !defined(GLX_VERSION_1_3) || defined(Q_OS_HPUX) || defined(Q_OS_DARWIN)
     return 0;
 #else
     Q_Q(QGLContext);
@@ -1745,7 +1745,7 @@ void QGLContextPrivate::destroyGlSurfaceForPixmap(QPixmapData* pmd)
 
 void QGLContextPrivate::unbindPixmapFromTexture(QPixmapData* pmd)
 {
-#if defined(GLX_VERSION_1_3) && !defined(Q_OS_HPUX)
+#if defined(GLX_VERSION_1_3) && !defined(Q_OS_HPUX) && !defined(Q_OS_DARWIN)
     Q_ASSERT(pmd->classId() == QPixmapData::X11Class);
     Q_ASSERT(QGLContext::currentContext());
     QX11PixmapData *pixmapData = static_cast<QX11PixmapData*>(pmd);
diff --git a/src/phonon/phonon.pro b/src/phonon/phonon.pro
index 0469839..f62e958 100644
--- a/src/phonon/phonon.pro
+++ b/src/phonon/phonon.pro
@@ -3,7 +3,7 @@ include(../qbase.pri)
 
 PHONON_MAJOR_VERSION = $${QT_MAJOR_VERSION}
 PHONON_MINOR_VERSION = 3
-PHONON_PATCH_VERSION = 1
+PHONON_PATCH_VERSION = 80
 VERSION = $${PHONON_MAJOR_VERSION}.$${PHONON_MINOR_VERSION}.$${PHONON_PATCH_VERSION}
 
 DEPENDPATH += .
@@ -21,6 +21,9 @@ HEADERS += $$PHONON_DIR/abstractaudiooutput.h \
            $$PHONON_DIR/abstractvideooutput.h \
            $$PHONON_DIR/abstractvideooutput_p.h \
            $$PHONON_DIR/addoninterface.h \
+           $$PHONON_DIR/audiodataoutput.h \
+           $$PHONON_DIR/audiodataoutput_p.h \
+           $$PHONON_DIR/audiodataoutputinterface.h \
            $$PHONON_DIR/audiooutput.h \
            $$PHONON_DIR/audiooutput_p.h \
            $$PHONON_DIR/audiooutputinterface.h \
@@ -36,6 +39,7 @@ HEADERS += $$PHONON_DIR/abstractaudiooutput.h \
            $$PHONON_DIR/effectwidget_p.h \
            $$PHONON_DIR/factory_p.h \
            $$PHONON_DIR/frontendinterface_p.h \
+           $$PHONON_DIR/globalconfig.h \
            $$PHONON_DIR/globalconfig_p.h \
            $$PHONON_DIR/iodevicestream_p.h \
            $$PHONON_DIR/mediacontroller.h \
@@ -59,11 +63,13 @@ HEADERS += $$PHONON_DIR/abstractaudiooutput.h \
            $$PHONON_DIR/phononnamespace_p.h \
            $$PHONON_DIR/platform_p.h \
            $$PHONON_DIR/platformplugin.h \
+           $$PHONON_DIR/pulsesupport.h \
            $$PHONON_DIR/qsettingsgroup_p.h \
            $$PHONON_DIR/seekslider.h \
            $$PHONON_DIR/seekslider_p.h \
            $$PHONON_DIR/streaminterface.h \
            $$PHONON_DIR/streaminterface_p.h \
+           $$PHONON_DIR/swiftslider_p.h \
            $$PHONON_DIR/videoplayer.h \
            $$PHONON_DIR/videowidget.h \
            $$PHONON_DIR/videowidget_p.h \
@@ -73,35 +79,39 @@ HEADERS += $$PHONON_DIR/abstractaudiooutput.h \
            $$PHONON_DIR/volumefaderinterface.h \
            $$PHONON_DIR/volumeslider.h \
            $$PHONON_DIR/volumeslider_p.h
-SOURCES += $$PHONON_DIR/objectdescription.cpp \
-           $$PHONON_DIR/objectdescriptionmodel.cpp \
-           $$PHONON_DIR/phononnamespace.cpp \
-           $$PHONON_DIR/mediasource.cpp \
-           $$PHONON_DIR/abstractmediastream.cpp \
-           $$PHONON_DIR/streaminterface.cpp \
-           $$PHONON_DIR/mediaobject.cpp \
-           $$PHONON_DIR/medianode.cpp \
-           $$PHONON_DIR/path.cpp \
-           $$PHONON_DIR/effectparameter.cpp \
-           $$PHONON_DIR/effect.cpp \
-           $$PHONON_DIR/volumefadereffect.cpp \
-           $$PHONON_DIR/abstractaudiooutput.cpp \
+
+SOURCES += $$PHONON_DIR/abstractaudiooutput.cpp \
            $$PHONON_DIR/abstractaudiooutput_p.cpp \
-           $$PHONON_DIR/audiooutput.cpp \
-           $$PHONON_DIR/audiooutputinterface.cpp \
+           $$PHONON_DIR/abstractmediastream.cpp \
            $$PHONON_DIR/abstractvideooutput.cpp \
            $$PHONON_DIR/abstractvideooutput_p.cpp \
+           $$PHONON_DIR/audiodataoutput.cpp \
+           $$PHONON_DIR/audiooutput.cpp \
+           $$PHONON_DIR/audiooutputinterface.cpp \
            $$PHONON_DIR/backendcapabilities.cpp \
-           $$PHONON_DIR/globalconfig.cpp \
+           $$PHONON_DIR/effect.cpp \
+           $$PHONON_DIR/effectparameter.cpp \
+           $$PHONON_DIR/effectwidget.cpp \
            $$PHONON_DIR/factory.cpp \
-           $$PHONON_DIR/platform.cpp \
+           $$PHONON_DIR/globalconfig.cpp \
+           $$PHONON_DIR/iodevicestream.cpp \
            $$PHONON_DIR/mediacontroller.cpp \
-           $$PHONON_DIR/videowidget.cpp \
-           $$PHONON_DIR/videoplayer.cpp \
+           $$PHONON_DIR/medianode.cpp \
+           $$PHONON_DIR/mediaobject.cpp \
+           $$PHONON_DIR/mediasource.cpp \
+           $$PHONON_DIR/objectdescription.cpp \
+           $$PHONON_DIR/objectdescriptionmodel.cpp \
+           $$PHONON_DIR/path.cpp \
+           $$PHONON_DIR/phononnamespace.cpp \
+           $$PHONON_DIR/platform.cpp \
+           $$PHONON_DIR/pulsesupport.cpp \
            $$PHONON_DIR/seekslider.cpp \
-           $$PHONON_DIR/volumeslider.cpp \
-           $$PHONON_DIR/effectwidget.cpp \
-           $$PHONON_DIR/iodevicestream.cpp
+           $$PHONON_DIR/streaminterface.cpp \
+           $$PHONON_DIR/swiftslider.cpp \
+           $$PHONON_DIR/videoplayer.cpp \
+           $$PHONON_DIR/videowidget.cpp \
+           $$PHONON_DIR/volumefadereffect.cpp \
+           $$PHONON_DIR/volumeslider.cpp
 
 contains(QT_CONFIG, dbus) {
        QT      += dbus
diff --git a/src/plugins/phonon/gstreamer/gstreamer.pro b/src/plugins/phonon/gstreamer/gstreamer.pro
index ae597fa..cd10b95 100644
--- a/src/plugins/phonon/gstreamer/gstreamer.pro
+++ b/src/plugins/phonon/gstreamer/gstreamer.pro
@@ -3,6 +3,8 @@ DESTDIR = $$QT_BUILD_TREE/plugins/phonon_backend
 
 DEPENDPATH += .
 INCLUDEPATH += .
+INCLUDEPATH += $$QT_SOURCE_TREE/src/3rdparty/phonon
+INCLUDEPATH += $$QT_SOURCE_TREE/src/3rdparty/phonon/phonon
 
 QT += phonon
 contains(QT_CONFIG, opengl):QT += opengl
@@ -14,47 +16,51 @@ LIBS += $$QT_LIBS_GSTREAMER -lgstinterfaces-0.10 -lgstvideo-0.10 -lgstbase-0.10
 PHONON_GSTREAMER_DIR = $$QT_SOURCE_TREE/src/3rdparty/phonon/gstreamer
 
 HEADERS += $$PHONON_GSTREAMER_DIR/common.h \
- $$PHONON_GSTREAMER_DIR/audiooutput.h \
- $$PHONON_GSTREAMER_DIR/artssink.h \
  $$PHONON_GSTREAMER_DIR/abstractrenderer.h \
+ $$PHONON_GSTREAMER_DIR/alsasink2.h \
+ $$PHONON_GSTREAMER_DIR/artssink.h \
+ $$PHONON_GSTREAMER_DIR/audiodataoutput.h \
+ $$PHONON_GSTREAMER_DIR/audioeffect.h \
+ $$PHONON_GSTREAMER_DIR/audiooutput.h \
  $$PHONON_GSTREAMER_DIR/backend.h \
  $$PHONON_GSTREAMER_DIR/devicemanager.h \
  $$PHONON_GSTREAMER_DIR/effect.h \
  $$PHONON_GSTREAMER_DIR/effectmanager.h \
+ $$PHONON_GSTREAMER_DIR/glrenderer.h \
  $$PHONON_GSTREAMER_DIR/gsthelper.h \
- $$PHONON_GSTREAMER_DIR/mediaobject.h \
  $$PHONON_GSTREAMER_DIR/medianode.h \
  $$PHONON_GSTREAMER_DIR/medianodeevent.h \
- $$PHONON_GSTREAMER_DIR/widgetrenderer.h \
- $$PHONON_GSTREAMER_DIR/videowidget.h \
- $$PHONON_GSTREAMER_DIR/glrenderer.h \
- $$PHONON_GSTREAMER_DIR/qwidgetvideosink.h \
+ $$PHONON_GSTREAMER_DIR/mediaobject.h \
+ $$PHONON_GSTREAMER_DIR/message.h \
  $$PHONON_GSTREAMER_DIR/phononsrc.h \
+ $$PHONON_GSTREAMER_DIR/qwidgetvideosink.h \
  $$PHONON_GSTREAMER_DIR/streamreader.h \
- $$PHONON_GSTREAMER_DIR/message.h \
- $$PHONON_GSTREAMER_DIR/audioeffect.h \
- $$PHONON_GSTREAMER_DIR/volumefadereffect.h
+ $$PHONON_GSTREAMER_DIR/videowidget.h \
+ $$PHONON_GSTREAMER_DIR/volumefadereffect.h \
+ $$PHONON_GSTREAMER_DIR/widgetrenderer.h
+
 
-SOURCES += $$PHONON_GSTREAMER_DIR/audiooutput.cpp \
- $$PHONON_GSTREAMER_DIR/abstractrenderer.cpp \
+SOURCES += $$PHONON_GSTREAMER_DIR/abstractrenderer.cpp \
  $$PHONON_GSTREAMER_DIR/artssink.cpp \
+ $$PHONON_GSTREAMER_DIR/audiodataoutput.cpp \
+ $$PHONON_GSTREAMER_DIR/audioeffect.cpp \
+ $$PHONON_GSTREAMER_DIR/audiooutput.cpp \
  $$PHONON_GSTREAMER_DIR/backend.cpp \
  $$PHONON_GSTREAMER_DIR/devicemanager.cpp \
  $$PHONON_GSTREAMER_DIR/effect.cpp \
  $$PHONON_GSTREAMER_DIR/effectmanager.cpp \
+ $$PHONON_GSTREAMER_DIR/glrenderer.cpp \
  $$PHONON_GSTREAMER_DIR/gsthelper.cpp \
- $$PHONON_GSTREAMER_DIR/mediaobject.cpp \
  $$PHONON_GSTREAMER_DIR/medianode.cpp \
  $$PHONON_GSTREAMER_DIR/medianodeevent.cpp \
- $$PHONON_GSTREAMER_DIR/widgetrenderer.cpp \
- $$PHONON_GSTREAMER_DIR/videowidget.cpp \
- $$PHONON_GSTREAMER_DIR/glrenderer.cpp \
- $$PHONON_GSTREAMER_DIR/qwidgetvideosink.cpp \
+ $$PHONON_GSTREAMER_DIR/mediaobject.cpp \
+ $$PHONON_GSTREAMER_DIR/message.cpp \
  $$PHONON_GSTREAMER_DIR/phononsrc.cpp \
+ $$PHONON_GSTREAMER_DIR/qwidgetvideosink.cpp \
  $$PHONON_GSTREAMER_DIR/streamreader.cpp \
- $$PHONON_GSTREAMER_DIR/message.cpp \
- $$PHONON_GSTREAMER_DIR/audioeffect.cpp \
- $$PHONON_GSTREAMER_DIR/volumefadereffect.cpp
+ $$PHONON_GSTREAMER_DIR/videowidget.cpp \
+ $$PHONON_GSTREAMER_DIR/volumefadereffect.cpp \
+ $$PHONON_GSTREAMER_DIR/widgetrenderer.cpp
 
 !embedded {
     HEADERS += $$PHONON_GSTREAMER_DIR/x11renderer.h
diff --git a/src/plugins/plugins.pro b/src/plugins/plugins.pro
index 004b816..a7d8d88 100644
--- a/src/plugins/plugins.pro
+++ b/src/plugins/plugins.pro
@@ -10,5 +10,5 @@ unix:!symbian {
 embedded:SUBDIRS *=  gfxdrivers decorations mousedrivers kbddrivers
 !win32:!embedded:!mac:!symbian:SUBDIRS *= inputmethods
 symbian:SUBDIRS += s60
-contains(QT_CONFIG, phonon): SUBDIRS *= phonon
 contains(QT_CONFIG, multimedia): SUBDIRS *= audio
+contains(QT_CONFIG, phonon-backend): SUBDIRS *= phonon
diff --git a/src/qt3support/other/q3process_unix.cpp b/src/qt3support/other/q3process_unix.cpp
index 05def77..1c3beea 100644
--- a/src/qt3support/other/q3process_unix.cpp
+++ b/src/qt3support/other/q3process_unix.cpp
@@ -790,7 +790,7 @@ bool Q3Process::start( QStringList *env )
 	} else { // start process with environment settins as specified in env
 	    // construct the environment for exec
 	    int numEntries = env->count();
-#if defined(Q_OS_MACX)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 	    QString ld_library_path(QLatin1String("DYLD_LIBRARY_PATH"));
 #else
 	    QString ld_library_path(QLatin1String("LD_LIBRARY_PATH"));
@@ -832,7 +832,7 @@ bool Q3Process::start( QStringList *env )
 			QFileInfo fileInfo( dir + QLatin1Char('/') + command );
 #endif
 			if ( fileInfo.isExecutable() ) {
-#if defined(Q_OS_MACX)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 			    arglistQ[0] = fileInfo.absFilePath().local8Bit();
 #else
 			    arglistQ[0] = fileInfo.filePath().local8Bit();
diff --git a/src/qt3support/qt3support.pro b/src/qt3support/qt3support.pro
index a30117c..c2e718b 100644
--- a/src/qt3support/qt3support.pro
+++ b/src/qt3support/qt3support.pro
@@ -26,6 +26,7 @@ unix {
    QMAKE_PKGCONFIG_REQUIRES = QtCore QtGui QtNetwork QtSql
 }
 mac:LIBS_PRIVATE += -framework Carbon
+darwin-*:LIBS += -lresolv
 
 QMAKE_LIBS += $$QMAKE_LIBS_COMPAT $$QMAKE_LIBS_NETWORK
 DEFINES -= QT3_SUPPORT_WARNINGS
diff --git a/src/qt3support/text/q3textedit.cpp b/src/qt3support/text/q3textedit.cpp
index 0d0e1a2..6887cec 100644
--- a/src/qt3support/text/q3textedit.cpp
+++ b/src/qt3support/text/q3textedit.cpp
@@ -4981,7 +4981,7 @@ void Q3TextEdit::pasteSubType(const QByteArray& subtype, QMimeSource *m)
 #if defined(Q_OS_WIN32)
         // Need to convert CRLF to LF
         t.replace(QLatin1String("\r\n"), QLatin1String("\n"));
-#elif defined(Q_OS_MAC)
+#elif defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
         //need to convert CR to LF
         t.replace(QLatin1Char('\r'), QLatin1Char('\n'));
 #endif
diff --git a/src/sql/drivers/odbc/qsql_odbc.h b/src/sql/drivers/odbc/qsql_odbc.h
index 76627b8..4daf4d3 100644
--- a/src/sql/drivers/odbc/qsql_odbc.h
+++ b/src/sql/drivers/odbc/qsql_odbc.h
@@ -49,7 +49,7 @@
 #include <QtCore/qt_windows.h>
 #endif
 
-#if defined (Q_OS_MAC) && (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_3)
+#if (defined (Q_OS_DARWIN) || defined (Q_OS_MAC)) && (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_3)
 // assume we use iodbc on MACX
 // comment next line out if you use a
 // unicode compatible manager
diff --git a/src/testlib/qbenchmark_p.h b/src/testlib/qbenchmark_p.h
index e981646..d59a071 100644
--- a/src/testlib/qbenchmark_p.h
+++ b/src/testlib/qbenchmark_p.h
@@ -55,7 +55,7 @@
 
 #include <QtCore/qglobal.h>
 
-#if (defined(Q_OS_LINUX) || defined Q_OS_MAC) && !defined(QT_NO_PROCESS)
+#if (defined(Q_OS_LINUX) || defined (Q_OS_DARWIN) || defined(Q_OS_MAC)) && !defined(QT_NO_PROCESS)
 #define QTESTLIB_USE_VALGRIND 
 #else
 #undef QTESTLIB_USE_VALGRIND
diff --git a/src/tools/moc/main.cpp b/src/tools/moc/main.cpp
index 8e033b7..b5b2edd 100644
--- a/src/tools/moc/main.cpp
+++ b/src/tools/moc/main.cpp
@@ -94,7 +94,13 @@ static QByteArray combinePath(const char *infile, const char *outfile)
         inSplitted.prepend(QLatin1String(".."));
     }
     inSplitted.append(inFileInfo.fileName());
+#ifdef Q_WS_WIN
+    const QString rel = inSplitted.join(QLatin1String("/"));
+    const QString abs = inFileInfo.absoluteFilePath();
+    return QFile::encodeName(rel.length() < abs.length() ? rel : abs);
+#else
     return QFile::encodeName(inSplitted.join(QLatin1String("/")));
+#endif
 }
 
 
diff --git a/tools/assistant/lib/fulltextsearch/qclucene-config_p.h b/tools/assistant/lib/fulltextsearch/qclucene-config_p.h
index ffa5f5d..3a20995 100644
--- a/tools/assistant/lib/fulltextsearch/qclucene-config_p.h
+++ b/tools/assistant/lib/fulltextsearch/qclucene-config_p.h
@@ -354,7 +354,7 @@ configure.
 #endif
 
 #if !defined(__SUNPRO_CC) && !defined(__SUNPRO_C) && !defined(__MINGW32__) && \
-    !defined(Q_OS_MAC) && !defined(__HP_aCC)
+    !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC) && !defined(__HP_aCC)
     /* Define to 1 if you have the `wcscasecmp' function. */
 #   ifndef _CL_HAVE_WCSCASECMP
 #   define _CL_HAVE_WCSCASECMP  1
diff --git a/tools/assistant/lib/lib.pro b/tools/assistant/lib/lib.pro
index 51933de..ad07bfe 100644
--- a/tools/assistant/lib/lib.pro
+++ b/tools/assistant/lib/lib.pro
@@ -22,7 +22,7 @@ linux-lsb-g++:LIBS_PRIVATE += --lsb-shared-libs=$$qclucene
 unix:QMAKE_PKGCONFIG_REQUIRES += QtNetwork \
     QtSql \
     QtXml
-LIBS_PRIVATE += -l$$qclucene
+LIBS += -l$$qclucene
 
 RESOURCES += helpsystem.qrc
 SOURCES += qhelpenginecore.cpp \
diff --git a/tools/designer/src/plugins/plugins.pro b/tools/designer/src/plugins/plugins.pro
index baf5261..9f3a4ce 100644
--- a/tools/designer/src/plugins/plugins.pro
+++ b/tools/designer/src/plugins/plugins.pro
@@ -1,5 +1,7 @@
 TEMPLATE = subdirs
 CONFIG += ordered
+CONFIG -= lib_bundle
+QT_CONFIG -= qt_framework
 
 REQUIRES = !CONFIG(static,shared|static)
 contains(QT_CONFIG, qt3support): SUBDIRS += widgets
diff --git a/translations/translations.pro b/translations/translations.pro
index 05dd968..c59e3d1 100644
--- a/translations/translations.pro
+++ b/translations/translations.pro
@@ -5,9 +5,9 @@ LRELEASE ~= s,/,$$QMAKE_DIR_SEP,
 
 contains(TEMPLATE_PREFIX, vc):vcproj = 1
 
-TEMPLATE = app
+TEMPLATE = lib
 TARGET = qm_phony_target
-CONFIG -= qt separate_debug_info
+CONFIG -= qt separate_debug_info app_bundle
 QT =
 LIBS =
 
