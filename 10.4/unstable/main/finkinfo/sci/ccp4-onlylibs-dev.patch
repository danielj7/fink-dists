diff -ruN ccp4-onlylibs-dev-orig/lib/clipper/clipper/core/derivs.h ccp4-onlylibs-dev/lib/clipper/clipper/core/derivs.h
--- ccp4-onlylibs-dev-orig/lib/clipper/clipper/core/derivs.h	2005-09-08 13:07:42.000000000 -0700
+++ ccp4-onlylibs-dev/lib/clipper/clipper/core/derivs.h	2006-03-22 21:17:07.000000000 -0800
@@ -169,7 +169,7 @@
   template<class T> Curv_orth<T> Curv_frac<T>::curv_orth( const Cell& cell ) const
   {
     Mat33<T> m( cell.matrix_frac() );
-    return Curv_frac<T>( m.transpose() * (*this) * m );
+    return Curv_orth<T>( m.transpose() * (*this) * m );
   }
 
   /*! \param g The grid concerned \return The transformed derivative. */
diff -ruN ccp4-onlylibs-dev-orig/lib/clipper/clipper/core/derivs.h.orig ccp4-onlylibs-dev/lib/clipper/clipper/core/derivs.h.orig
--- ccp4-onlylibs-dev-orig/lib/clipper/clipper/core/derivs.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ ccp4-onlylibs-dev/lib/clipper/clipper/core/derivs.h.orig	2005-09-08 13:07:42.000000000 -0700
@@ -0,0 +1,211 @@
+/*! \file lib/derivs.h
+    Fundamental types for the clipper libraries
+*/
+//C Copyright (C) 2000-2004 Kevin Cowtan and University of York
+//C Copyright (C) 2000-2005 Kevin Cowtan and University of York
+
+//L   This code is distributed under the terms and conditions of the
+//L   CCP4 Program Suite Licence Agreement as a CCP4 Library.
+//L   A copy of the CCP4 licence can be obtained by writing to the
+//L   CCP4 Secretary, Daresbury Laboratory, Warrington WA4 4AD, UK.
+
+#ifndef CLIPPER_DERIVS
+#define CLIPPER_DERIVS
+
+
+#include "coords.h"
+
+
+namespace clipper
+{
+  template<class T> class Grad_orth;
+  template<class T> class Grad_frac;
+  template<class T> class Grad_map;
+  template<class T> class Curv_orth;
+  template<class T> class Curv_frac;
+  template<class T> class Curv_map;
+
+
+  //! orthogonal (Angstom) gradient, with respect to orthogonal x,y,z
+  template<class T> class Grad_orth : public Vec3<T>
+  {
+  public:
+    Grad_orth() {}                 //!< null constructor
+    explicit Grad_orth( const Vec3<T>& v ) :
+      Vec3<T>( v ) {}          //!< constructor: copy/convert
+    Grad_orth( const T& dx, const T& dy, const T& dz ) :
+      Vec3<T>( dx, dy, dz ) {} //!< constructor: from d/dx,d/dy,d/dz
+    const T& dx() const { return (*this)[0]; }  //!< get d/dx
+    const T& dy() const { return (*this)[1]; }  //!< get d/dy
+    const T& dz() const { return (*this)[2]; }  //!< get d/dz
+    //! orthogonal-fractional derivative conversion
+    Grad_frac<T> grad_frac( const Cell& cell ) const;
+    String format() const;  //!< return formatted String representation
+  };
+
+
+  //! fractional (cell) gradient, with respect to fractional u,v,w
+  template<class T> class Grad_frac : public Vec3<T>
+  {
+  public:
+    Grad_frac() {}                 //!< null constructor
+    explicit Grad_frac( const Vec3<T>& v ) :
+      Vec3<T>( v ) {}          //!< constructor: copy/convert
+    Grad_frac( const T& du, const T& dv, const T& dw ) :
+      Vec3<T>( du, dv, dw ) {} //!< constructor: from d/du,d/dv,d/dw
+    const T& du() const { return (*this)[0]; }  //!< get d/du
+    const T& dv() const { return (*this)[1]; }  //!< get d/dv
+    const T& dw() const { return (*this)[2]; }  //!< get d/dw
+    //! fractional-orthogonal derivative conversion
+    Grad_orth<T> grad_orth( const Cell& cell ) const;
+    //! fractional-grid derivative conversion
+    Grad_map<T> grad_map( const Grid& g ) const;
+    String format() const;  //!< return formatted String representation
+  };
+
+
+  //! map coordinate gradient, with respect to grid u,v,w
+  template<class T> class Grad_map : public Vec3<T>
+  {
+  public:
+    Grad_map() {}                 //!< null constructor
+    explicit Grad_map( const Vec3<T>& v ) :
+      Vec3<T>( v ) {}          //!< constructor: copy/convert
+    Grad_map( const T& du, const T& dv, const T& dw ) :
+      Vec3<T>( du, dv, dw ) {} //!< constructor: from d/du,d/dv,d/dw
+    const T& du() const { return (*this)[0]; }  //!< get d/du
+    const T& dv() const { return (*this)[1]; }  //!< get d/dv
+    const T& dw() const { return (*this)[2]; }  //!< get d/dw
+    //! grid-fractional derivative conversion
+    Grad_frac<T> grad_frac( const Grid& g ) const;
+    String format() const;  //!< return formatted String representation
+  };
+
+
+  //! orthogonal (Angstom) curvatures, with respect to orthogonal x,y,z
+  template<class T> class Curv_orth : public Mat33<T>
+  {
+  public:
+    Curv_orth() {}                 //!< null constructor
+    explicit Curv_orth( const Mat33<T>& m ) :
+      Mat33<T>( m ) {}         //!< constructor: copy/convert
+    //! orthogonal-fractional derivative conversion
+    Curv_frac<T> curv_frac( const Cell& cell ) const;
+  };
+
+
+  //! fractional (cell) curvatures, with respect to fractional u,v,w
+  template<class T> class Curv_frac : public Mat33<T>
+  {
+  public:
+    Curv_frac() {}                 //!< null constructor
+    explicit Curv_frac( const Mat33<T>& m ) :
+      Mat33<T>( m ) {}         //!< constructor: copy/convert
+    //! fractional-orthogonal derivative conversion
+    Curv_orth<T> curv_orth( const Cell& cell ) const;
+    //! fractional-grid derivative conversion
+    Curv_map<T> curv_map( const Grid& g ) const;
+  };
+
+
+  //! map coordinate curvatures, with respect to grid u,v,w
+  template<class T> class Curv_map : public Mat33<T>
+  {
+  public:
+    Curv_map() {}                 //!< null constructor
+    explicit Curv_map( const Mat33<T>& m ) :
+      Mat33<T>( m ) {}         //!< constructor: copy/convert
+    //! grid-fractional derivative conversion
+    Curv_frac<T> curv_frac( const Grid& g ) const;
+  };
+
+
+
+  // template implementations
+
+  /*! The result is an RT operator. This is a redudent representation,
+    but is handy for assembling compound operators.
+    \return The operator */
+  /*! \return The formatted text string */
+  template<class T> String Grad_orth<T>::format() const
+    { return "d/dx,d/dy,d/dz = ("+String(dx())+","+String(dy())+","+String(dz())+")"; }
+
+  /*! \param cell The cell concerned \return The transformed derivative. */
+  template<class T> inline Grad_frac<T> Grad_orth<T>::grad_frac( const Cell& cell ) const
+    { return Grad_frac<T>( (*this) * Mat33<T>( cell.matrix_orth() ) ); }
+
+
+  /*! \return The formatted text string */
+  template<class T> String Grad_frac<T>::format() const
+    { return "d/du,d/dv,d/dw = ("+String(du())+","+String(dv())+","+String(dw())+")"; }
+
+  /*! \param cell The cell concerned \return The transformed derivative. */
+  template<class T> inline Grad_orth<T> Grad_frac<T>::grad_orth( const Cell& cell ) const
+    { return Grad_orth<T>( (*this) * Mat33<T>( cell.matrix_frac() ) ); }
+
+  /*! \param g The grid concerned \return The transformed derivative. */
+  template<class T> inline Grad_map<T> Grad_frac<T>::grad_map( const Grid& g ) const
+    { return Grad_map<T>( du()/g.nu(), dv()/g.nv(), dw()/g.nw() ); }
+
+
+  /*! \return The formatted text string */
+  template<class T> String Grad_map<T>::format() const
+    { return "d/du,d/dv,d/dw = ("+String(du())+","+String(dv())+","+String(dw())+")"; }
+
+  /*! \param g The grid concerned \return The transformed derivative. */
+  template<class T> inline Grad_frac<T> Grad_map<T>::grad_frac( const Grid& g ) const
+    { return Grad_frac<T>( du()*g.nu(), dv()*g.nv(), dw()*g.nw() ); }
+
+
+  /*! \param cell The cell concerned \return The transformed derivative. */
+  template<class T> Curv_frac<T> Curv_orth<T>::curv_frac( const Cell& cell ) const
+  {
+    Mat33<T> m( cell.matrix_orth() );
+    return Curv_frac<T>( m.transpose() * (*this) * m );
+  }
+
+
+  /*! \param cell The cell concerned \return The transformed derivative. */
+  template<class T> Curv_orth<T> Curv_frac<T>::curv_orth( const Cell& cell ) const
+  {
+    Mat33<T> m( cell.matrix_frac() );
+    return Curv_frac<T>( m.transpose() * (*this) * m );
+  }
+
+  /*! \param g The grid concerned \return The transformed derivative. */
+  template<class T> Curv_map<T> Curv_frac<T>::curv_map( const Grid& g ) const
+  {
+    Curv_map<T> c;
+    c(0,0) = (*this)(0,0) / T(g.nu()*g.nu());
+    c(0,1) = (*this)(0,1) / T(g.nu()*g.nv());
+    c(0,2) = (*this)(0,2) / T(g.nu()*g.nw());
+    c(1,0) = (*this)(1,0) / T(g.nv()*g.nu());
+    c(1,1) = (*this)(1,1) / T(g.nv()*g.nv());
+    c(1,2) = (*this)(1,2) / T(g.nv()*g.nw());
+    c(2,0) = (*this)(2,0) / T(g.nw()*g.nu());
+    c(2,1) = (*this)(2,1) / T(g.nw()*g.nv());
+    c(2,2) = (*this)(2,2) / T(g.nw()*g.nw());
+    return c;
+  }
+
+
+  /*! \param g The grid concerned \return The transformed derivative. */
+  template<class T> Curv_frac<T> Curv_map<T>::curv_frac( const Grid& g ) const
+  {
+    Curv_frac<T> c;
+    c(0,0) = (*this)(0,0) * T(g.nu()*g.nu());
+    c(0,1) = (*this)(0,1) * T(g.nu()*g.nv());
+    c(0,2) = (*this)(0,2) * T(g.nu()*g.nw());
+    c(1,0) = (*this)(1,0) * T(g.nv()*g.nu());
+    c(1,1) = (*this)(1,1) * T(g.nv()*g.nv());
+    c(1,2) = (*this)(1,2) * T(g.nv()*g.nw());
+    c(2,0) = (*this)(2,0) * T(g.nw()*g.nu());
+    c(2,1) = (*this)(2,1) * T(g.nw()*g.nv());
+    c(2,2) = (*this)(2,2) * T(g.nw()*g.nw());
+    return c;
+  }
+
+
+} // namespace clipper
+
+#endif
diff -ruN ccp4-onlylibs-dev-orig/lib/clipper/src/cphasecombine.cpp ccp4-onlylibs-dev/lib/clipper/src/cphasecombine.cpp
--- ccp4-onlylibs-dev-orig/lib/clipper/src/cphasecombine.cpp	2005-09-09 03:50:39.000000000 -0700
+++ ccp4-onlylibs-dev/lib/clipper/src/cphasecombine.cpp	2006-03-22 21:16:33.000000000 -0800
@@ -37,9 +37,9 @@
     } else if ( args[arg] == "-colin-hl-2" ) {
       if ( ++arg < args.size() ) ipcolh2 = args[arg];
     } else if ( args[arg] == "-weight-hl-1" ) {
-      if ( ++arg < args.size() ) hlwt1 = clipper::String(args[arg]).i();
+      if ( ++arg < args.size() ) hlwt1 = clipper::String(args[arg]).f();
     } else if ( args[arg] == "-weight-hl-2" ) {
-      if ( ++arg < args.size() ) hlwt2 = clipper::String(args[arg]).i();
+      if ( ++arg < args.size() ) hlwt2 = clipper::String(args[arg]).f();
     } else if ( args[arg] == "-colout" ) {
       if ( ++arg < args.size() ) opcol = args[arg];
     } else {
diff -ruN ccp4-onlylibs-dev-orig/lib/clipper/src/pirancslib.cpp ccp4-onlylibs-dev/lib/clipper/src/pirancslib.cpp
--- ccp4-onlylibs-dev-orig/lib/clipper/src/pirancslib.cpp	2005-10-14 02:37:23.000000000 -0700
+++ ccp4-onlylibs-dev/lib/clipper/src/pirancslib.cpp	2006-03-22 21:17:43.000000000 -0800
@@ -1083,9 +1083,9 @@
     Local_rtop rtinv = ncsops[i].inverse();
     int j;
     for ( j = 0; j < ncsopsi.size(); j++ )
-      if ( rtinv.symm_match( ncsops[j], spgr, cell, tol_dst_, tol_ang_ ).first
+      if ( rtinv.symm_match( ncsopsi[j], spgr, cell, tol_dst_, tol_ang_ ).first
 	   < 2.0 ) break;
-    if ( j == ncsopsi.size() ) ncsopsi.push_back( ncsops[j] );
+    if ( j == ncsopsi.size() ) ncsopsi.push_back( ncsops[i] );
   }
   return ncsopsi;
 }
diff -ruN ccp4-onlylibs-dev-orig/lib/src/ccplib.f ccp4-onlylibs-dev/lib/src/ccplib.f
--- ccp4-onlylibs-dev-orig/lib/src/ccplib.f	2005-09-08 08:17:41.000000000 -0700
+++ ccp4-onlylibs-dev/lib/src/ccplib.f	2006-03-22 21:16:02.000000000 -0800
@@ -16,7 +16,7 @@
 C     amalgamate ccppsf and fdir/fext/froot.  also add tests of these
 C     routines to testlib.
 C
-C     $Id: ccplib.f,v 1.102 2005/09/08 15:17:41 mdw Exp $
+C     $Id: ccplib.f,v 1.103 2006/02/27 15:26:20 ccb Exp $
 C
 C      CCFILL    Set specified number of elements of byte array
 C      CCPALC    Call subroutine with allocated memory
@@ -1307,7 +1307,7 @@
       INTEGER GETPID,LENSTR
       LOGICAL VAXVMS, WINMVS
       CHARACTER FDIR* (ISTRLN),FEXTN* (ISTRLN),FROOT* (ISTRLN), RTNBKS
-      EXTERNAL GETPID,LENSTR,VAXVMS,FDIR,FEXTN,FROOT
+      EXTERNAL LENSTR,VAXVMS,FDIR,FEXTN,FROOT
 C     ..
 C     .. External Subroutines ..
       EXTERNAL CCPERR,UGTARG,QPRINT,UGTENV,USTENV
