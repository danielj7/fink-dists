diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..82d0113
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,14 @@
+*.ii
+*.ii-*
+*.s
+*.s-*
+*.o
+*.o-*
+*.dylib
+*.a
+temp.*
+a.out
+*.pass
+*.fail
+*.log
+*.bz2
diff --git a/CMakeLists.txt b/CMakeLists.txt
index c20e5d1..99c0712 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -131,8 +131,10 @@ endmacro()
 if ("${LIBCXX_CXX_ABI}" STREQUAL "libstdc++" OR
     "${LIBCXX_CXX_ABI}" STREQUAL "libsupc++")
   set(_LIBSUPCXX_INCLUDE_FILES
-    cxxabi.h bits/c++config.h bits/os_defines.h bits/cpu_defines.h
-    bits/cxxabi_tweaks.h bits/cxxabi_forced.h
+    cxxabi.h bits/c++config.h bits/os_defines.h
+# bits/cpu_defines.h
+    bits/cxxabi_tweaks.h
+# bits/cxxabi_forced.h
     )
   if ("${LIBCXX_CXX_ABI}" STREQUAL "libstdc++")
     set(_LIBSUPCXX_DEFINES "-DLIBSTDCXX")
diff --git a/include/__atomic_locked b/include/__atomic_locked
new file mode 100644
index 0000000..f10dd74
--- /dev/null
+++ b/include/__atomic_locked
@@ -0,0 +1,240 @@
+// -*- C++ -*-
+//===--------------------------- __atomic_locked --------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef _LIBCPP_ATOMIC_LOCKED
+#define _LIBCPP_ATOMIC_LOCKED
+
+#include <__mutex_base>	// for mutex and lock_guard
+
+/**
+	This provides slow-but-usable lock-based atomic access to
+	structures for which atomic lock-free functions are missing.
+	This is motivated by the desire for 64b atomic operations
+	on 32b PowerPC architectures.  
+**/
+
+#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
+#pragma GCC system_header
+#endif
+
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
+struct __atomic_mutex_locked  // false
+{
+    mutable _Atomic(_Tp) __a_;
+    mutable mutex __lock_;
+    typedef lock_guard<mutex>	lock_type;
+
+    _Tp& na(void) const { return reinterpret_cast<_Tp&>(__a_); }
+    volatile _Tp& na(void) const volatile { return reinterpret_cast<volatile _Tp&>(__a_); }
+
+    _LIBCPP_INLINE_VISIBILITY
+    bool is_lock_free() const volatile _NOEXCEPT
+        {return false;}
+    _LIBCPP_INLINE_VISIBILITY
+    bool is_lock_free() const _NOEXCEPT
+        {return false;}
+    _LIBCPP_INLINE_VISIBILITY
+    void store(_Tp __d, memory_order = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_)); na() = __d; }
+    _LIBCPP_INLINE_VISIBILITY
+    void store(_Tp __d, memory_order = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_); na() = __d; }
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp load(memory_order = memory_order_seq_cst) const volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_)); return na(); }
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp load(memory_order = memory_order_seq_cst) const _NOEXCEPT
+        { const lock_type g(__lock_); return na(); }
+    _LIBCPP_INLINE_VISIBILITY
+    operator _Tp() const volatile _NOEXCEPT {return load();}
+    _LIBCPP_INLINE_VISIBILITY
+    operator _Tp() const _NOEXCEPT          {return load();}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp exchange(_Tp __d, memory_order = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	// or use std::swap
+          const _Tp ret = na(); na() = __d; return ret; }
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp exchange(_Tp __d, memory_order = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_);
+	// or use std::swap
+          const _Tp ret = na(); na() = __d; return ret; }
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_weak(_Tp& __e, _Tp __d,
+                               memory_order __s, memory_order __f) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	  if (na() == __e) { na() = __d; return true; }
+	  else { __e = na(); return false; }
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_weak(_Tp& __e, _Tp __d,
+                               memory_order __s, memory_order __f) _NOEXCEPT
+        { const lock_type g(__lock_);
+	  if (na() == __e) { na() = __d; return true; }
+	  else { __e = na(); return false; }
+	}
+
+    // for now, _weak inditinguishable from _strong
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_strong(_Tp& __e, _Tp __d,
+                                 memory_order __s, memory_order __f) volatile _NOEXCEPT
+        {return compare_exchange_weak(__e, __d, __s, __f);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_strong(_Tp& __e, _Tp __d,
+                                 memory_order __s, memory_order __f) _NOEXCEPT
+        {return compare_exchange_weak(__e, __d, __s, __f);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_weak(_Tp& __e, _Tp __d,
+                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {return compare_exchange_weak(__e, __d, __m, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_weak(_Tp& __e, _Tp __d,
+                               memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return compare_exchange_weak(__e, __d, __m, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_strong(_Tp& __e, _Tp __d,
+                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {return compare_exchange_strong(__e, __d, __m, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_strong(_Tp& __e, _Tp __d,
+                                 memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return compare_exchange_strong(__e, __d, __m, __m);}
+
+    _LIBCPP_INLINE_VISIBILITY
+#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
+    __atomic_mutex_locked() _NOEXCEPT = default;
+#else
+    __atomic_mutex_locked() _NOEXCEPT : __a_() {}
+#endif // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
+
+    _LIBCPP_INLINE_VISIBILITY
+    _LIBCPP_CONSTEXPR __atomic_mutex_locked(_Tp __d) _NOEXCEPT : __a_(__d) {}
+#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
+    __atomic_mutex_locked(const __atomic_mutex_locked&) = delete;
+    __atomic_mutex_locked& operator=(const __atomic_mutex_locked&) = delete;
+    __atomic_mutex_locked& operator=(const __atomic_mutex_locked&) volatile = delete;
+#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
+private:
+    __atomic_mutex_locked(const __atomic_mutex_locked&);
+    __atomic_mutex_locked& operator=(const __atomic_mutex_locked&);
+    __atomic_mutex_locked& operator=(const __atomic_mutex_locked&) volatile;
+#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
+};	// end struct __atomic_mutex_locked
+
+// atomic<Integral>
+
+template <class _Tp>
+struct __atomic_mutex_locked<_Tp, true>
+    : public __atomic_mutex_locked<_Tp, false>
+{
+    typedef __atomic_mutex_locked<_Tp, false> __base;
+    typedef	typename __base::lock_type	lock_type;
+    using __base::__lock_;
+    using __base::na;
+
+    _LIBCPP_INLINE_VISIBILITY
+    __atomic_mutex_locked() _NOEXCEPT _LIBCPP_DEFAULT
+    _LIBCPP_INLINE_VISIBILITY
+    _LIBCPP_CONSTEXPR __atomic_mutex_locked(_Tp __d) _NOEXCEPT : __base(__d) {}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	  const _Tp ret = na(); na() += __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_);
+	  const _Tp ret = na(); na() += __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	  const _Tp ret = na(); na() -= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_);
+	  const _Tp ret = na(); na() -= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	  const _Tp ret = na(); na() &= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_);
+	  const _Tp ret = na(); na() &= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	  const _Tp ret = na(); na() |= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_);
+	  const _Tp ret = na(); na() |= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	  const _Tp ret = na(); na() ^= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_);
+	  const _Tp ret = na(); na() ^= __op; return ret;
+	}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator++(int) volatile _NOEXCEPT      {return fetch_add(_Tp(1));}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator++(int) _NOEXCEPT               {return fetch_add(_Tp(1));}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--(int) volatile _NOEXCEPT      {return fetch_sub(_Tp(1));}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--(int) _NOEXCEPT               {return fetch_sub(_Tp(1));}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator++() volatile _NOEXCEPT         {return fetch_add(_Tp(1)) + _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator++() _NOEXCEPT                  {return fetch_add(_Tp(1)) + _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--() volatile _NOEXCEPT         {return fetch_sub(_Tp(1)) - _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--() _NOEXCEPT                  {return fetch_sub(_Tp(1)) - _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator+=(_Tp __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator+=(_Tp __op) _NOEXCEPT          {return fetch_add(__op) + __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator-=(_Tp __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator-=(_Tp __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator&=(_Tp __op) volatile _NOEXCEPT {return fetch_and(__op) & __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator&=(_Tp __op) _NOEXCEPT          {return fetch_and(__op) & __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator|=(_Tp __op) volatile _NOEXCEPT {return fetch_or(__op) | __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator|=(_Tp __op) _NOEXCEPT          {return fetch_or(__op) | __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator^=(_Tp __op) volatile _NOEXCEPT {return fetch_xor(__op) ^ __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator^=(_Tp __op) _NOEXCEPT          {return fetch_xor(__op) ^ __op;}
+};
+
+_LIBCPP_END_NAMESPACE_STD
+
+#endif  // _LIBCPP_ATOMIC_LOCKED
diff --git a/include/atomic b/include/atomic
index f6ab1cb..e580315 100644
--- a/include/atomic
+++ b/include/atomic
@@ -1528,4 +1528,50 @@ typedef atomic<uintmax_t> atomic_uintmax_t;
 
 _LIBCPP_END_NAMESPACE_STD
 
+#if	defined(__ppc__) && !defined(__ppc64__)
+// specialize fallback implementation where 64b atomics are missing
+#include <__atomic_locked>
+
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+template <>
+struct atomic<long long> : public __atomic_mutex_locked<long long>
+{
+    typedef long long		_Tp;
+    typedef __atomic_mutex_locked<_Tp> __base;
+    _LIBCPP_INLINE_VISIBILITY
+    atomic() _NOEXCEPT _LIBCPP_DEFAULT
+    _LIBCPP_INLINE_VISIBILITY
+    _LIBCPP_CONSTEXPR atomic(_Tp __d) _NOEXCEPT : __base(__d) {}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator=(_Tp __d) volatile _NOEXCEPT
+        {__base::store(__d); return __d;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator=(_Tp __d) _NOEXCEPT
+        {__base::store(__d); return __d;}
+};
+
+template <>
+struct atomic<unsigned long long> :
+	public __atomic_mutex_locked<unsigned long long>
+{
+    typedef unsigned long long		_Tp;
+    typedef __atomic_mutex_locked<_Tp> __base;
+    _LIBCPP_INLINE_VISIBILITY
+    atomic() _NOEXCEPT _LIBCPP_DEFAULT
+    _LIBCPP_INLINE_VISIBILITY
+    _LIBCPP_CONSTEXPR atomic(_Tp __d) _NOEXCEPT : __base(__d) {}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator=(_Tp __d) volatile _NOEXCEPT
+        {__base::store(__d); return __d;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator=(_Tp __d) _NOEXCEPT
+        {__base::store(__d); return __d;}
+};
+
+_LIBCPP_END_NAMESPACE_STD
+#endif	// defined(__ppc__) && !defined(__ppc64__)
+
 #endif  // _LIBCPP_ATOMIC
diff --git a/include/cmath b/include/cmath
index 964c672..c00f922 100644
--- a/include/cmath
+++ b/include/cmath
@@ -298,7 +298,27 @@ long double    truncl(long double x);
 */
 
 #include <__config>
+
+// The C++11 standard requires C99, but whether or not __STDC_VERSION__
+// is accordingly set is implementation-defined.
+// on darwin10: C99 is explicltly required to enable long long returning 
+// functions, like llrint and llround.
+// Alternatively, undefine __STRICT_ANSI__ for those symbols.
+// This is just a convenient, isolated workaround.
+// #if defined(__APPLE__) && (__cplusplus >= 201101L) && !defined(__STDC_VERSION__)
+#if defined(__APPLE__) && (__cplusplus >= 201101L) && !defined(__STDC_VERSION__) && defined(__STRICT_ANSI__)
+#define	__IMPLICIT_STDC_VERSION_C99__
+// #define	__STDC_VERSION__	199901L
+#undef	__STRICT_ANSI__
+#endif
 #include <math.h>
+#ifdef	__IMPLICIT_STDC_VERSION_C99__
+// undo the abvoe
+// #undef	__STDC_VERSION__
+#define	__STRICT_ANSI__
+// __IMPLICIT_STDC_VERSION_C99__ remains defined as evidence of what happened
+#endif
+
 #include <type_traits>
 
 #ifdef _LIBCPP_MSVCRT
diff --git a/include/iterator b/include/iterator
index f338e01..edef399 100644
--- a/include/iterator
+++ b/include/iterator
@@ -335,7 +335,7 @@ template <class C> auto crend(const C& c) -> decltype(std::rend(c));          //
 #include <iosfwd>
 #include <initializer_list>
 #ifdef __APPLE__
-#include <Availability.h>
+#include <AvailabilityMacros.h>
 #endif
 
 #ifdef _LIBCPP_DEBUG
@@ -913,8 +913,8 @@ public:
     _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}
 
 #if !defined(__APPLE__) || \
-    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \
-    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
+    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && defined(__MAC_10_8) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \
+    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && defined(__IPHONE_6_0) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
 
     template <class _Ch, class _Tr>
     friend
diff --git a/include/locale b/include/locale
index fcff402..eb415de 100644
--- a/include/locale
+++ b/include/locale
@@ -198,7 +198,7 @@ template <class charT> class messages_byname;
 #endif
 
 #ifdef __APPLE__
-#include <Availability.h>
+#include <AvailabilityMacros.h>
 #endif
 
 #include <__undef_min_max>
@@ -1467,8 +1467,8 @@ __pad_and_output(_OutputIterator __s,
 }
 
 #if !defined(__APPLE__) || \
-    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \
-    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
+    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && defined(__MAC_10_8) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \
+    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && defined(__IPHONE_6_0) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
 
 template <class _CharT, class _Traits>
 _LIBCPP_HIDDEN
diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
index 70adcb7..3222b29 100644
--- a/lib/CMakeLists.txt
+++ b/lib/CMakeLists.txt
@@ -50,14 +50,27 @@ append_if(compile_flags LIBCXX_HAS_FPIC_FLAG -fPIC)
 append_if(link_flags LIBCXX_HAS_NODEFAULTLIBS_FLAG -nodefaultlibs)
 
 if ( APPLE )
-  if ( CMAKE_OSX_DEPLOYMENT_TARGET STREQUAL "10.6" )
+  if ( CMAKE_OSX_DEPLOYMENT_TARGET VERSION_LESS "10.6" )
+    # libc++ must be built with clang++
+    execute_process(COMMAND ${CMAKE_CXX_COMPILER} -print-search-dirs
+      COMMAND grep "libraries:"
+      COMMAND cut -d= -f2
+      OUTPUT_VARIABLE CXX_LIBDIR
+      OUTPUT_STRIP_TRAILING_WHITESPACE
+    )
+    list(APPEND link_flags
+      "-compatibility_version 1"
+      "-Wl,-unexported_symbols_list,${CMAKE_CURRENT_SOURCE_DIR}/libc++unexp.exp"
+      "-lgcc_s.${CMAKE_OSX_DEPLOYMENT_TARGET}"
+      "${CXX_LIBDIR}/lib/darwin/libclang_rt.builtins-${CMAKE_OSX_ARCHITECTURES}.a"
+      "/usr/lib/libSystem.B.dylib"
+      "-lSystemStubs" )
+  elseif ( CMAKE_OSX_DEPLOYMENT_TARGET STREQUAL "10.6" )
     list(APPEND compile_flags "-U__STRICT_ANSI__")
     list(APPEND link_flags
       "-compatibility_version 1"
-      "-current_version ${LIBCXX_VERSION}"
-      "-install_name /usr/lib/libc++.1.dylib"
-      "-Wl,-reexport_library,/usr/lib/libc++abi.dylib"
       "-Wl,-unexported_symbols_list,${CMAKE_CURRENT_SOURCE_DIR}/libc++unexp.exp"
+      "-lgcc_s.1"
       "/usr/lib/libSystem.B.dylib")
   else()
     if ( ${CMAKE_OSX_SYSROOT} )
@@ -71,6 +84,7 @@ if ( APPLE )
           "-Wl,-reexport_library,${CMAKE_OSX_SYSROOT}/usr/lib/libc++abi.dylib")
       endif()
     else()
+      # FIXME: hard-coded libc++abi.dylib location doesn't work for me
       set (OSX_RE_EXPORT_LINE "/usr/lib/libc++abi.dylib -Wl,-reexported_symbols_list,${CMAKE_CURRENT_SOURCE_DIR}/libc++abi${LIBCXX_LIBCPPABI_VERSION}.exp")
     endif()
 
@@ -85,6 +99,7 @@ if ( APPLE )
 endif()
 
 string(REPLACE ";" " " link_flags "${link_flags}")
+string(REPLACE ";" " " compile_flags "${compile_flags}")
 
 set_target_properties(cxx
   PROPERTIES
diff --git a/src/exception.cpp b/src/exception.cpp
index 3ce6f2e..6c090e5 100644
--- a/src/exception.cpp
+++ b/src/exception.cpp
@@ -16,7 +16,8 @@
 #define __has_include(inc) 0
 #endif
 
-#ifdef __APPLE__
+// darwin8: there is no __cxxabiapple namespace anywhere
+#if defined(__APPLE__) && !defined(DARWIN_LIBSUPCXX)
   #include <cxxabi.h>
 
   using namespace __cxxabiv1;
@@ -31,6 +32,12 @@
   #endif  // _LIBCPPABI_VERSION
 #elif defined(LIBCXXRT) || __has_include(<cxxabi.h>)
   #include <cxxabi.h>
+  #if defined(DARWIN_LIBSUPCXX)
+  namespace __cxxabiv1 {
+    extern std::terminate_handler  __terminate_handler;
+    extern std::unexpected_handler __unexpected_handler;
+  }
+  #endif
   using namespace __cxxabiv1;
   #if defined(LIBCXXRT) || defined(_LIBCPPABI_VERSION)
     #define HAVE_DEPENDENT_EH_ABI 1
@@ -40,10 +47,18 @@
   static std::unexpected_handler __unexpected_handler;
 #endif // __has_include(<cxxabi.h>)
 
+#if defined(__APPLE__) && defined(DARWIN_LIBSUPCXX)
+// should clang provide -DPIC
+#define	PIC	1
+#include <bits/os_defines.h>
+// see https://www.opensource.apple.com/source/libstdcxx/libstdcxx-39/libstdcxx/libstdc++-v3/libsupc++/eh_terminate.cc
+#endif
+
 namespace std
 {
 
-#if !defined(LIBCXXRT) && !defined(_LIBCPPABI_VERSION) && !defined(__GLIBCXX__)
+#define	__PRED__	!defined(LIBCXXRT) && !defined(_LIBCPPABI_VERSION) && !defined(__GLIBCXX__)
+#if __PRED__
 
 // libcxxrt provides implementations of these functions itself.
 unexpected_handler
@@ -51,13 +66,22 @@ set_unexpected(unexpected_handler func) _NOEXCEPT
 {
     return __sync_lock_test_and_set(&__unexpected_handler, func);
 }
-
+#endif
+#if __PRED__ || defined(DARWIN_LIBSUPCXX)
 unexpected_handler
 get_unexpected() _NOEXCEPT
 {
+#if defined(__APPLE__) && defined(__ppc__) && defined(PIC)
+    const std::unexpected_handler
+	old(reinterpret_cast<std::unexpected_handler>(
+		_keymgr_get_per_thread_data(KEYMGR_UNEXPECTED_HANDLER_KEY)));
+    return old ? old : __unexpected_handler;
+#else
     return __sync_fetch_and_add(&__unexpected_handler, (unexpected_handler)0);
+#endif /* __APPLE__ etc. */
 }
-
+#endif
+#if __PRED__
 _LIBCPP_NORETURN
 void
 unexpected()
@@ -73,12 +97,23 @@ set_terminate(terminate_handler func) _NOEXCEPT
     return __sync_lock_test_and_set(&__terminate_handler, func);
 }
 
+#endif
+#if __PRED__ || defined(DARWIN_LIBSUPCXX)
 terminate_handler
 get_terminate() _NOEXCEPT
 {
+// FIXME: see https://www.opensource.apple.com/source/libstdcxx/libstdcxx-39/libstdcxx/libstdc++-v3/libsupc++/eh_terminate.cc
+#if defined(__APPLE__) && defined(__ppc__) && defined(PIC)
+    const std::terminate_handler
+	old(reinterpret_cast<std::terminate_handler>(
+		_keymgr_get_per_thread_data(KEYMGR_TERMINATE_HANDLER_KEY)));
+    return old ? old : __terminate_handler;
+#else
     return __sync_fetch_and_add(&__terminate_handler, (terminate_handler)0);
+#endif
 }
-
+#endif
+#if __PRED__
 #ifndef __EMSCRIPTEN__ // We provide this in JS
 _LIBCPP_NORETURN
 void
@@ -104,8 +139,10 @@ terminate() _NOEXCEPT
 }
 #endif // !__EMSCRIPTEN__
 #endif // !defined(LIBCXXRT) && !defined(_LIBCPPABI_VERSION)
+#undef	__PRED__
 
 #if !defined(LIBCXXRT) && !defined(__GLIBCXX__) && !defined(__EMSCRIPTEN__)
+#if !defined(DARWIN_LIBSUPCXX)
 bool uncaught_exception() _NOEXCEPT
 {
 #if defined(__APPLE__) || defined(_LIBCPPABI_VERSION)
@@ -121,6 +158,7 @@ bool uncaught_exception() _NOEXCEPT
     ::abort();
 #endif  // __APPLE__
 }
+#endif
 
 
 #ifndef _LIBCPPABI_VERSION
@@ -141,7 +179,8 @@ const char* exception::what() const _NOEXCEPT
 bad_exception::~bad_exception() _NOEXCEPT
 {
 }
-
+#endif
+#if !defined(_LIBCPPABI_VERSION) && !defined(__GLIBCXX__) || (defined(DARWIN_LIBSUPCXX) && DARWIN_LIBSUPCXX < 10)
 const char* bad_exception::what() const _NOEXCEPT
 {
   return "std::bad_exception";
@@ -149,7 +188,9 @@ const char* bad_exception::what() const _NOEXCEPT
 
 #endif
 
-#if defined(__GLIBCXX__)
+#define	GLIBCXX_HAS___EXCEPTION_PTR		!defined(DARWIN_LIBSUPCXX)
+
+#if defined(__GLIBCXX__) && GLIBCXX_HAS___EXCEPTION_PTR
 
 // libsupc++ does not implement the dependent EH ABI and the functionality
 // it uses to implement std::exception_ptr (which it declares as an alias of
@@ -182,7 +223,7 @@ exception_ptr::~exception_ptr() _NOEXCEPT
 {
 #if HAVE_DEPENDENT_EH_ABI
     __cxa_decrement_exception_refcount(__ptr_);
-#elif defined(__GLIBCXX__)
+#elif defined(__GLIBCXX__) && GLIBCXX_HAS___EXCEPTION_PTR
     reinterpret_cast<__exception_ptr::exception_ptr*>(this)->~exception_ptr();
 #else
 #   if defined(_MSC_VER) && ! defined(__clang__)
@@ -200,7 +241,7 @@ exception_ptr::exception_ptr(const exception_ptr& other) _NOEXCEPT
 {
 #if HAVE_DEPENDENT_EH_ABI
     __cxa_increment_exception_refcount(__ptr_);
-#elif defined(__GLIBCXX__)
+#elif defined(__GLIBCXX__) && GLIBCXX_HAS___EXCEPTION_PTR
     new (reinterpret_cast<void*>(this)) __exception_ptr::exception_ptr(
         reinterpret_cast<const __exception_ptr::exception_ptr&>(other));
 #else
@@ -224,7 +265,7 @@ exception_ptr& exception_ptr::operator=(const exception_ptr& other) _NOEXCEPT
         __ptr_ = other.__ptr_;
     }
     return *this;
-#elif defined(__GLIBCXX__)
+#elif defined(__GLIBCXX__) && GLIBCXX_HAS___EXCEPTION_PTR
     *reinterpret_cast<__exception_ptr::exception_ptr*>(this) =
         reinterpret_cast<const __exception_ptr::exception_ptr&>(other);
     return *this;
@@ -244,7 +285,7 @@ nested_exception::nested_exception() _NOEXCEPT
 {
 }
 
-#if !defined(__GLIBCXX__)
+#if !defined(__GLIBCXX__) || defined(DARWIN_LIBSUPCXX)
 
 nested_exception::~nested_exception() _NOEXCEPT
 {
@@ -261,7 +302,7 @@ nested_exception::rethrow_nested() const
     rethrow_exception(__ptr_);
 }
 
-#if !defined(__GLIBCXX__)
+#if !defined(__GLIBCXX__) || defined(DARWIN_LIBSUPCXX)
 
 exception_ptr current_exception() _NOEXCEPT
 {
@@ -292,7 +333,7 @@ void rethrow_exception(exception_ptr p)
     __cxa_rethrow_primary_exception(p.__ptr_);
     // if p.__ptr_ is NULL, above returns so we terminate
     terminate();
-#elif defined(__GLIBCXX__)
+#elif defined(__GLIBCXX__) && GLIBCXX_HAS___EXCEPTION_PTR
     rethrow_exception(reinterpret_cast<__exception_ptr::exception_ptr&>(p));
 #else
 #   if defined(_MSC_VER) && ! defined(__clang__)
diff --git a/src/new.cpp b/src/new.cpp
index 3b7c341..7d0efe7 100644
--- a/src/new.cpp
+++ b/src/new.cpp
@@ -17,7 +17,7 @@
 #define __has_include(inc) 0
 #endif
 
-#ifdef __APPLE__
+#if defined(__APPLE__) && !defined(DARWIN_LIBSUPCXX)
     #include <cxxabi.h>
 
     #ifndef _LIBCPPABI_VERSION
@@ -30,11 +30,21 @@
     #if defined(LIBCXXRT) || __has_include(<cxxabi.h>)
         #include <cxxabi.h>
     #endif  // __has_include(<cxxabi.h>)
+    #if defined(DARWIN_LIBSUPCXX)
+        extern std::new_handler	__new_handler;
+    #endif
     #if !defined(_LIBCPPABI_VERSION) && !defined(__GLIBCXX__)
         static std::new_handler __new_handler;
     #endif  // _LIBCPPABI_VERSION
 #endif
 
+#if defined(__APPLE__) && defined(DARWIN_LIBSUPCXX)
+// should clang provide -DPIC
+#define	PIC	1
+#include <bits/os_defines.h>
+// see https://www.opensource.apple.com/source/libstdcxx/libstdcxx-39/libstdcxx/libstdc++-v3/libsupc++/new_handler.cc
+#endif
+
 #ifndef __GLIBCXX__
 
 // Implement all new and delete operators as weak definitions
@@ -150,9 +160,11 @@ operator delete[] (void* ptr, const std::nothrow_t&) _NOEXCEPT
 namespace std
 {
 
+#if	!defined(DARWIN_LIBSUPCXX)
 #ifndef __GLIBCXX__
 const nothrow_t nothrow = {};
 #endif
+#endif
 
 #ifndef _LIBCPPABI_VERSION
 
@@ -163,11 +175,20 @@ set_new_handler(new_handler handler) _NOEXCEPT
 {
     return __sync_lock_test_and_set(&__new_handler, handler);
 }
-
+#endif
+#if !defined(__GLIBCXX__) || defined(DARWIN_LIBSUPCXX)
 new_handler
 get_new_handler() _NOEXCEPT
 {
+/* APPLE LOCAL begin keymgr */
+#if defined(__APPLE__) && defined(__ppc__) && defined(PIC)
+    const new_handler prev_handler(reinterpret_cast<new_handler>(
+	_keymgr_get_per_thread_data(KEYMGR_NEW_HANDLER_KEY)));
+    return prev_handler ? prev_handler : __new_handler;
+#else	/* __APPLE__ etc. */
     return __sync_fetch_and_add(&__new_handler, nullptr);
+#endif	/* __APPLE__ etc. */
+/* APPLE LOCAL end keymgr */
 }
 
 #endif // !__GLIBCXX__
@@ -183,7 +204,9 @@ bad_alloc::bad_alloc() _NOEXCEPT
 bad_alloc::~bad_alloc() _NOEXCEPT
 {
 }
+#endif // !__GLIBCXX__
 
+#if !defined(__GLIBCXX__) || (defined(DARWIN_LIBSUPCXX) && DARWIN_LIBSUPCXX < 10)
 const char*
 bad_alloc::what() const _NOEXCEPT
 {
diff --git a/src/typeinfo.cpp b/src/typeinfo.cpp
index b428120..4153372 100644
--- a/src/typeinfo.cpp
+++ b/src/typeinfo.cpp
@@ -35,23 +35,29 @@ std::bad_typeid::bad_typeid() _NOEXCEPT
 std::bad_cast::~bad_cast() _NOEXCEPT
 {
 }
+#endif
 
+#if !defined(__GLIBCXX__) || (defined(DARWIN_LIBSUPCXX) && DARWIN_LIBSUPCXX < 10)
 const char*
 std::bad_cast::what() const _NOEXCEPT
 {
   return "std::bad_cast";
 }
+#endif
 
+#ifndef __GLIBCXX__
 std::bad_typeid::~bad_typeid() _NOEXCEPT
 {
 }
-
+#endif
+#if !defined(__GLIBCXX__) || (defined(DARWIN_LIBSUPCXX) && DARWIN_LIBSUPCXX < 10)
 const char*
 std::bad_typeid::what() const _NOEXCEPT
 {
   return "std::bad_typeid";
 }
-
+#endif
+#ifndef __GLIBCXX__
 #ifdef __APPLE__
   // On Darwin, the cxa_bad_* functions cannot be in the lower level library
   // because bad_cast and bad_typeid are defined in his higher level library
diff --git a/test/atomics/atomics.types.generic/integral.pass.cpp b/test/atomics/atomics.types.generic/integral.pass.cpp
index 26caa50..8c15231 100644
--- a/test/atomics/atomics.types.generic/integral.pass.cpp
+++ b/test/atomics/atomics.types.generic/integral.pass.cpp
@@ -88,6 +88,8 @@
 #include <new>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class A, class T>
 void
 do_test()
@@ -160,7 +162,6 @@ void test()
     do_test<volatile A, T>();
 }
 
-
 int main()
 {
     test<std::atomic_char, char>();
@@ -172,8 +173,10 @@ int main()
     test<std::atomic_uint, unsigned int>();
     test<std::atomic_long, long>();
     test<std::atomic_ulong, unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<std::atomic_llong, long long>();
     test<std::atomic_ullong, unsigned long long>();
+#endif
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<std::atomic_char16_t, char16_t>();
     test<std::atomic_char32_t, char32_t>();
@@ -189,8 +192,10 @@ int main()
     test<volatile std::atomic_uint, unsigned int>();
     test<volatile std::atomic_long, long>();
     test<volatile std::atomic_ulong, unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<volatile std::atomic_llong, long long>();
     test<volatile std::atomic_ullong, unsigned long long>();
+#endif
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<volatile std::atomic_char16_t, char16_t>();
     test<volatile std::atomic_char32_t, char32_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong.pass.cpp
index fd5102b..6a30715 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -73,8 +75,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong_explicit.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong_explicit.pass.cpp
index f2610a3..d11719a 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong_explicit.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong_explicit.pass.cpp
@@ -24,6 +24,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -80,8 +82,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak.pass.cpp
index a3f95a4..60baf8a 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak.pass.cpp
@@ -20,6 +20,7 @@
 #include <atomic>
 #include <type_traits>
 #include <cassert>
+#include "powerpc-darwin.h"
 
 template <class T>
 void
@@ -73,8 +74,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak_explicit.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak_explicit.pass.cpp
index 2f3e996..91dcdb7 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak_explicit.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak_explicit.pass.cpp
@@ -24,6 +24,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -80,8 +82,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange.pass.cpp
index 4264943..6de81b5 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -58,8 +60,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange_explicit.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange_explicit.pass.cpp
index 0f3add5..4c65a68 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange_explicit.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange_explicit.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -60,8 +62,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add.pass.cpp
index 9ce60ad..703451b 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add.pass.cpp
@@ -29,6 +29,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -96,8 +98,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add_explicit.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add_explicit.pass.cpp
index a2a1a44..3822ce8 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add_explicit.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add_explicit.pass.cpp
@@ -29,6 +29,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -100,8 +102,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and.pass.cpp
index 01d2cc6..37f76c0 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -52,8 +54,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and_explicit.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and_explicit.pass.cpp
index abfb83d..1a9c1ba 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and_explicit.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and_explicit.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -54,8 +56,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or.pass.cpp
index 43b6c4f..09fa660 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -52,8 +54,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or_explicit.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or_explicit.pass.cpp
index 21078bb..23d5d2d 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or_explicit.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or_explicit.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -54,8 +56,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub.pass.cpp
index d33b81e..5b8124d 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub.pass.cpp
@@ -29,6 +29,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -96,8 +98,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub_explicit.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub_explicit.pass.cpp
index 886a65f..615facc 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub_explicit.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub_explicit.pass.cpp
@@ -30,6 +30,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -101,8 +103,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor.pass.cpp
index 78120a7..c6668d2 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -52,8 +54,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor_explicit.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor_explicit.pass.cpp
index 0a0cd15..a4b23ec 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor_explicit.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor_explicit.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -54,8 +56,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_init.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_init.pass.cpp
index f0d9a24..059a207 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_init.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_init.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -56,8 +58,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load.pass.cpp
index b239886..c8043a9 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -56,8 +58,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load_explicit.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load_explicit.pass.cpp
index 3072dd5..d19afbd 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load_explicit.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load_explicit.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -56,8 +58,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store.pass.cpp
index f9044bf..7a001d5 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -56,8 +58,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store_explicit.pass.cpp b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store_explicit.pass.cpp
index 18038ae..de03f64 100644
--- a/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store_explicit.pass.cpp
+++ b/test/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store_explicit.pass.cpp
@@ -21,6 +21,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -56,8 +58,10 @@ int main()
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff --git a/test/containers/associative/map/types.pass.cpp b/test/containers/associative/map/types.pass.cpp
index d117def..80083c0 100644
--- a/test/containers/associative/map/types.pass.cpp
+++ b/test/containers/associative/map/types.pass.cpp
@@ -33,6 +33,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -47,7 +48,11 @@ int main()
     static_assert((std::is_same<C::const_reference, const std::pair<const int, double>&>::value), "");
     static_assert((std::is_same<C::pointer, std::pair<const int, double>*>::value), "");
     static_assert((std::is_same<C::const_pointer, const std::pair<const int, double>*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+    static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
     static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
     static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff --git a/test/containers/associative/multimap/types.pass.cpp b/test/containers/associative/multimap/types.pass.cpp
index a0f4db0..dc86da1 100644
--- a/test/containers/associative/multimap/types.pass.cpp
+++ b/test/containers/associative/multimap/types.pass.cpp
@@ -33,6 +33,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -47,7 +48,11 @@ int main()
     static_assert((std::is_same<C::const_reference, const std::pair<const int, double>&>::value), "");
     static_assert((std::is_same<C::pointer, std::pair<const int, double>*>::value), "");
     static_assert((std::is_same<C::const_pointer, const std::pair<const int, double>*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+    static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
     static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
     static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff --git a/test/containers/associative/multiset/types.pass.cpp b/test/containers/associative/multiset/types.pass.cpp
index e1e3ad9..f05a4c9 100644
--- a/test/containers/associative/multiset/types.pass.cpp
+++ b/test/containers/associative/multiset/types.pass.cpp
@@ -33,6 +33,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -47,7 +48,11 @@ int main()
     static_assert((std::is_same<C::const_reference, const int&>::value), "");
     static_assert((std::is_same<C::pointer, int*>::value), "");
     static_assert((std::is_same<C::const_pointer, const int*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+    static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
     static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
     static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff --git a/test/containers/associative/set/types.pass.cpp b/test/containers/associative/set/types.pass.cpp
index 3362c42..f3664b2 100644
--- a/test/containers/associative/set/types.pass.cpp
+++ b/test/containers/associative/set/types.pass.cpp
@@ -33,6 +33,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -47,7 +48,11 @@ int main()
     static_assert((std::is_same<C::const_reference, const int&>::value), "");
     static_assert((std::is_same<C::pointer, int*>::value), "");
     static_assert((std::is_same<C::const_pointer, const int*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+    static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
     static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
     static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff --git a/test/containers/sequences/array/types.pass.cpp b/test/containers/sequences/array/types.pass.cpp
index 065ade9..ff0a267 100644
--- a/test/containers/sequences/array/types.pass.cpp
+++ b/test/containers/sequences/array/types.pass.cpp
@@ -29,6 +29,8 @@
 #include <iterator>
 #include <type_traits>
 
+#include "powerpc-darwin.h"
+
 int main()
 {
     {
@@ -40,7 +42,11 @@ int main()
         static_assert((std::is_same<C::const_iterator, const T*>::value), "");
         static_assert((std::is_same<C::pointer, T*>::value), "");
         static_assert((std::is_same<C::const_pointer, const T*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+        static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
         static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
         static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
         static_assert((std::is_same<C::reverse_iterator, std::reverse_iterator<C::iterator> >::value), "");
         static_assert((std::is_same<C::const_reverse_iterator, std::reverse_iterator<C::const_iterator> >::value), "");
@@ -54,7 +60,11 @@ int main()
         static_assert((std::is_same<C::const_iterator, const T*>::value), "");
         static_assert((std::is_same<C::pointer, T*>::value), "");
         static_assert((std::is_same<C::const_pointer, const T*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+        static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
         static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
         static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
         static_assert((std::is_same<C::reverse_iterator, std::reverse_iterator<C::iterator> >::value), "");
         static_assert((std::is_same<C::const_reverse_iterator, std::reverse_iterator<C::const_iterator> >::value), "");
diff --git a/test/containers/sequences/forwardlist/types.pass.cpp b/test/containers/sequences/forwardlist/types.pass.cpp
index c955487..7480f88 100644
--- a/test/containers/sequences/forwardlist/types.pass.cpp
+++ b/test/containers/sequences/forwardlist/types.pass.cpp
@@ -40,7 +40,11 @@ int main()
     static_assert((std::is_same<C::const_reference, const char&>::value), "");
     static_assert((std::is_same<C::pointer, char*>::value), "");
     static_assert((std::is_same<C::const_pointer, const char*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+    static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
     static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
     static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff --git a/test/containers/unord/unord.map/types.pass.cpp b/test/containers/unord/unord.map/types.pass.cpp
index b53ff8e..be5c890 100644
--- a/test/containers/unord/unord.map/types.pass.cpp
+++ b/test/containers/unord/unord.map/types.pass.cpp
@@ -32,6 +32,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -47,7 +48,11 @@ int main()
         static_assert((std::is_same<C::const_reference, const C::value_type&>::value), "");
         static_assert((std::is_same<C::pointer, C::value_type*>::value), "");
         static_assert((std::is_same<C::const_pointer, const C::value_type*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+        static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
         static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
         static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff --git a/test/containers/unord/unord.multimap/types.pass.cpp b/test/containers/unord/unord.multimap/types.pass.cpp
index 55ae749..3a32612 100644
--- a/test/containers/unord/unord.multimap/types.pass.cpp
+++ b/test/containers/unord/unord.multimap/types.pass.cpp
@@ -32,6 +32,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -47,7 +48,11 @@ int main()
         static_assert((std::is_same<C::const_reference, const C::value_type&>::value), "");
         static_assert((std::is_same<C::pointer, C::value_type*>::value), "");
         static_assert((std::is_same<C::const_pointer, const C::value_type*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+        static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
         static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
         static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff --git a/test/containers/unord/unord.multiset/types.pass.cpp b/test/containers/unord/unord.multiset/types.pass.cpp
index 5222222..338077c 100644
--- a/test/containers/unord/unord.multiset/types.pass.cpp
+++ b/test/containers/unord/unord.multiset/types.pass.cpp
@@ -31,6 +31,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -45,7 +46,11 @@ int main()
         static_assert((std::is_same<C::const_reference, const C::value_type&>::value), "");
         static_assert((std::is_same<C::pointer, C::value_type*>::value), "");
         static_assert((std::is_same<C::const_pointer, const C::value_type*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+        static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
         static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
         static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff --git a/test/containers/unord/unord.set/types.pass.cpp b/test/containers/unord/unord.set/types.pass.cpp
index 7e752a4..a1f611c 100644
--- a/test/containers/unord/unord.set/types.pass.cpp
+++ b/test/containers/unord/unord.set/types.pass.cpp
@@ -31,6 +31,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -45,7 +46,11 @@ int main()
         static_assert((std::is_same<C::const_reference, const C::value_type&>::value), "");
         static_assert((std::is_same<C::pointer, C::value_type*>::value), "");
         static_assert((std::is_same<C::const_pointer, const C::value_type*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+        static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
         static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
         static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff --git a/test/depr/depr.c.headers/ctype_h.pass.cpp b/test/depr/depr.c.headers/ctype_h.pass.cpp
index 042084e..1953664 100644
--- a/test/depr/depr.c.headers/ctype_h.pass.cpp
+++ b/test/depr/depr.c.headers/ctype_h.pass.cpp
@@ -13,6 +13,9 @@
 #include <type_traits>
 #include <cassert>
 
+// on darwin8, <ctype.h> defines these functions as:
+// #define isalpha(c)      __istype((c), _CTYPE_A)
+#if !defined(DARWIN_LIBSUPCXX) || (DARWIN_LIBSUPCXX >= 9)
 #ifdef isalnum
 #error isalnum defined
 #endif
@@ -68,6 +71,7 @@
 #ifdef toupper
 #error toupper defined
 #endif
+#endif
 
 int main()
 {
diff --git a/test/depr/depr.c.headers/inttypes_h.pass.cpp b/test/depr/depr.c.headers/inttypes_h.pass.cpp
index 4adf82d..65f4d65 100644
--- a/test/depr/depr.c.headers/inttypes_h.pass.cpp
+++ b/test/depr/depr.c.headers/inttypes_h.pass.cpp
@@ -9,6 +9,13 @@
 
 // test <inttypes.h>
 
+/* "C++ implementations should define these macros only when
+ *  __STDC_FORMAT_MACROS is defined before <inttypes.h> is included."
+ */
+#ifndef	__STDC_FORMAT_MACROS
+#define	__STDC_FORMAT_MACROS
+#endif
+
 #include <inttypes.h>
 #include <type_traits>
 
diff --git a/test/depr/depr.c.headers/wctype_h.pass.cpp b/test/depr/depr.c.headers/wctype_h.pass.cpp
index ad31071..23245f6 100644
--- a/test/depr/depr.c.headers/wctype_h.pass.cpp
+++ b/test/depr/depr.c.headers/wctype_h.pass.cpp
@@ -16,6 +16,9 @@
 #error WEOF not defined
 #endif
 
+// on darwin8, <_wctype.h> defines these functions as:
+// #define isalpha(c)      __istype((c), _CTYPE_A)
+#if !defined(DARWIN_LIBSUPCXX) || (DARWIN_LIBSUPCXX >= 9)
 #ifdef iswalnum
 #error iswalnum defined
 #endif
@@ -87,6 +90,7 @@
 #ifdef wctrans
 #error wctrans defined
 #endif
+#endif
 
 int main()
 {
diff --git a/test/input.output/file.streams/c.files/cinttypes.pass.cpp b/test/input.output/file.streams/c.files/cinttypes.pass.cpp
index 4cb2c4c..fcf20b6 100644
--- a/test/input.output/file.streams/c.files/cinttypes.pass.cpp
+++ b/test/input.output/file.streams/c.files/cinttypes.pass.cpp
@@ -9,6 +9,13 @@
 
 // test <cinttypes>
 
+/* "C++ implementations should define these macros only when
+ *  __STDC_FORMAT_MACROS is defined before <inttypes.h> is included."
+ */
+#ifndef	__STDC_FORMAT_MACROS
+#define	__STDC_FORMAT_MACROS
+#endif
+
 #include <cinttypes>
 #include <type_traits>
 
diff --git a/test/language.support/support.dynamic/new.delete/new.delete.array/new_array_nothrow_replace.pass.cpp b/test/language.support/support.dynamic/new.delete/new.delete.array/new_array_nothrow_replace.pass.cpp
index 9bf6e8a..a8852be 100644
--- a/test/language.support/support.dynamic/new.delete/new.delete.array/new_array_nothrow_replace.pass.cpp
+++ b/test/language.support/support.dynamic/new.delete/new.delete.array/new_array_nothrow_replace.pass.cpp
@@ -17,7 +17,10 @@
 
 int new_called = 0;
 
-void* operator new(std::size_t s) throw(std::bad_alloc)
+void* operator new(std::size_t s)
+#if !__has_feature(cxx_noexcept)
+	throw(std::bad_alloc)
+#endif
 {
     ++new_called;
     return std::malloc(s);
diff --git a/test/lit.cfg b/test/lit.cfg
index 5e64e54..bf2ee2c 100644
--- a/test/lit.cfg
+++ b/test/lit.cfg
@@ -214,6 +214,19 @@ if cxx_has_stdcxx0x_flag_str is not None:
 else:
     cxx_has_stdcxx0x_flag = getattr(config, 'cxx_has_stdcxx0x_flag', True)
 
+# global linker flags, like -B
+exe_linker_flags = lit_config.params.get('exe_linker_flags', None)
+if exe_linker_flags is None:
+    exe_linker_flags = getattr(config, 'exe_linker_flags', '')
+exe_linker_flags = exe_linker_flags.split(' ')
+lit_config.note("inferred exe_linker_flags as: %r" % (exe_linker_flags,))
+
+cxx_flags = lit_config.params.get('cxx_flags', None)
+if cxx_flags is None:
+    cxx_flags = getattr(config, 'cxx_flags', '')
+cxx_flags = cxx_flags.split(' ')
+lit_config.note("inferred cxx_flags as: %r" % (cxx_flags,))
+
 # This test suite supports testing against either the system library or the
 # locally built one; the former mode is useful for testing ABI compatibility
 # between the current headers and a shipping dynamic library.
@@ -248,7 +261,33 @@ if link_flags_str is None:
         lit_config.fatal('C++ ABI setting %s unsupported for tests' % cxx_abi)
 
       if sys.platform == 'darwin':
+        # need libgcc_s for libunwind
+        darwin_vers = int(platform.release().split('.')[0])
+        osx_vers_maj = '.'.join(platform.mac_ver()[0].split('.')[0:2])
+        if darwin_vers < 10:
+          link_flags += ['.'.join(['-lgcc_s', osx_vers_maj])]
+        elif darwin_vers < 11:
+          link_flags += ['-lgcc_s.1']
+        # need libclang_rt for eprintf
+        arch = platform.processor()
+        if arch == 'powerpc':
+          arch = 'ppc'
+        libcrt = '.'.join(['libclang_rt', '-'.join(['builtins', arch]), 'a'])
+        cmd = [cxx_under_test, '-print-search-dirs']
+        p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
+        out,err = p.communicate()
+        exitCode = p.wait()
+        # should probably check exitCode
+        for l in out.splitlines():
+          ll = l.split(' ')
+          if ll[0] == 'libraries:':
+            crt_libdir = ll[1][1:]
+        
+        link_flags += [os.path.join(crt_libdir, 'lib', sys.platform, libcrt)]
         link_flags += ['-lSystem']
+        # better yet, test existence of SystemStubs
+        if darwin_vers < 11:
+          link_flags += ['-lSystemStubs']
       elif sys.platform == 'linux2':
         link_flags += [ '-lgcc_eh', '-lc', '-lm', '-lpthread',
               '-lrt', '-lgcc_s']
@@ -282,8 +321,8 @@ else:
 
 config.test_format = LibcxxTestFormat(
     cxx_under_test,
-    cpp_flags = ['-nostdinc++'] + compile_flags + include_paths,
-    ld_flags = ['-nodefaultlibs'] + library_paths + ['-lc++'] + link_flags,
+    cpp_flags = cxx_flags + ['-nostdinc++'] + compile_flags + include_paths,
+    ld_flags = exe_linker_flags + ['-nodefaultlibs'] + library_paths + ['-lc++'] + link_flags,
     exec_env = exec_env)
 
 # Get or infer the target triple.
diff --git a/test/lit.site.cfg.in b/test/lit.site.cfg.in
index 5343eda..56068c2 100644
--- a/test/lit.site.cfg.in
+++ b/test/lit.site.cfg.in
@@ -6,6 +6,9 @@ config.libcxx_obj_root       = "@LIBCXX_BINARY_DIR@"
 config.python_executable     = "@PYTHON_EXECUTABLE@"
 config.enable_shared         = @LIBCXX_ENABLE_SHARED@
 config.cxx_abi               = "@LIBCXX_CXX_ABI@"
+# use same options used to build libc++
+config.exe_linker_flags      = "@CMAKE_EXE_LINKER_FLAGS@"
+config.cxx_flags             = "@CMAKE_CXX_FLAGS@"
 
 # Let the main config do the real work.
 lit_config.load_config(config, "@LIBCXX_SOURCE_DIR@/test/lit.cfg")
diff --git a/test/support/powerpc-darwin.h b/test/support/powerpc-darwin.h
new file mode 100644
index 0000000..fd8228f
--- /dev/null
+++ b/test/support/powerpc-darwin.h
@@ -0,0 +1,28 @@
+#ifndef	__LIBCXX_TEST_SUPPORT_POWERPC_DARWIN_H__
+#define	__LIBCXX_TEST_SUPPORT_POWERPC_DARWIN_H__
+
+#if defined(__APPLE__) && defined(__ppc__)
+#define	__powerpc_darwin__		1
+#endif
+// control certain workarounds for the powerpc-darwin8 port
+
+/**
+	On PowerPC-darwin, ptrdiff_t is int, but size_t is unsigned long.
+	Tests that rely on is_same<make_unsigned<ptrdiff_t>, size_t>
+	will fail, but as long as the underlying integer types are
+	the same size (which is true on PPC32), then it is still safe.
+ */
+#if defined(__powerpc_darwin__)
+#define	PTRDIFF_T_VS_SIZE_T_DIFFER
+#endif
+
+/**
+	PPC32 doesn't have native 64b atomic operations.
+	Thus, they must be emulated using mutex or lock.
+	TODO: provide specializations of struct atomic using std::mutex.
+	TODO: implement in compiler front-end
+	Undefine the following to enable mutex-based emulated 64b atomics.
+ */
+// #define	MISSING_64B_ATOMIC_OPS
+
+#endif	// __LIBCXX_TEST_SUPPORT_POWERPC_DARWIN_H__
diff --git a/test/testit b/test/testit
index 821292e..6b0d505 100755
--- a/test/testit
+++ b/test/testit
@@ -24,6 +24,7 @@ done
 
 cd ..
 LIBCXX_ROOT=`pwd`
+cpd=`echo "$LIBCXX_ROOT" | awk 'BEGIN{FS="/";}{print NF+1;}'`
 cd $origpath
 
 if [ -z "$CC" ]
@@ -36,6 +37,10 @@ then
 	fi
 fi
 
+if [ -z "$KEEP_EXE" ]
+then
+	KEEP_EXE=1
+fi
 if [ -z "$CXX_LANG" ]
 then
     CXX_LANG=c++11
@@ -56,6 +61,7 @@ then
        SOURCE_LIB="-L$LIBCXX_ROOT/lib"
 fi
 
+# use distinct test executables (parallelizable)
 case $TRIPLE in
   *-*-mingw* | *-*-cygwin* | *-*-win*)
 	TEST_EXE=test.exe
@@ -78,14 +84,16 @@ IMPLEMENTED_FAIL=0
 IMPLEMENTED_PASS=0
 
 afunc() {
+	rwd=`pwd | cut -d/ -f$cpd-`
 	fail=0
 	pass=0
 	if (ls ${TEST_PREFIX}*fail.cpp > /dev/null 2>&1)
 	then
 		for FILE in $(ls ${TEST_PREFIX}*fail.cpp); do
-			if $CC $OPTIONS $HEADER_INCLUDE $SOURCE_LIB $FILE $LIBS -o ./$TEST_EXE > /dev/null 2>&1
+			t_exe=`basename $FILE .cpp`
+			if $CC $OPTIONS $HEADER_INCLUDE $SOURCE_LIB $FILE $LIBS -o ./$t_exe > /dev/null 2>&1
 			then
-				rm ./$TEST_EXE
+				test "$KEEP_EXE" = 1 || rm ./$t_exe
 				echo "$FILE should not compile"
 				fail=$(($fail+1))
 			else
@@ -97,24 +105,25 @@ afunc() {
 	if (ls ${TEST_PREFIX}*pass.cpp > /dev/null 2>&1)
 	then
 		for FILE in $(ls ${TEST_PREFIX}*pass.cpp); do
+		t_exe=`basename $FILE .cpp`
             if [ "$VERBOSE" ]
             then
              	echo "Running test: " $FILE
             fi
-			if $CC $OPTIONS $HEADER_INCLUDE $SOURCE_LIB $FILE $LIBS $(test $1 = no || echo $THREAD_FLAGS) -o ./$TEST_EXE
+			if $CC $OPTIONS $HEADER_INCLUDE $SOURCE_LIB $FILE $LIBS $(test $1 = no || echo $THREAD_FLAGS) -o ./$t_exe
 			then
-				if ./$TEST_EXE
+				if ./$t_exe
 				then
-					rm ./$TEST_EXE
+					test "$KEEP_EXE" = 1 || rm ./$t_exe
 					pass=$(($pass+1))
 				else
-					echo "`pwd`/$FILE failed at run time"
+					echo "$rwd/$FILE failed at run time"
 					echo "Compile line was:" $CC $OPTIONS $HEADER_INCLUDE $SOURCE_LIB $FILE $LIBS $(test $1 = no || echo $THREAD_FLAGS)
 					fail=$(($fail+1))
-					rm ./$TEST_EXE
+					test "$KEEP_EXE" = 1 || rm ./$t_exe
 				fi
 			else
-				echo "`pwd`/$FILE failed to compile"
+				echo "$rwd/$FILE failed to compile"
 				echo "Compile line was:" $CC $OPTIONS $HEADER_INCLUDE $SOURCE_LIB $FILE $LIBS $(test $1 = no || echo $THREAD_FLAGS)
 				fail=$(($fail+1))
 			fi
@@ -123,12 +132,12 @@ afunc() {
 
 	if [ $fail -gt 0 ]
 	then
-		echo "failed $fail tests in `pwd`"
+		echo "failed $fail tests in $rwd"
 		IMPLEMENTED_FAIL=$(($IMPLEMENTED_FAIL+1))
 	fi
 	if [ $pass -gt 0 ]
 	then
-		echo "passed $pass tests in `pwd`"
+		echo "passed $pass tests in $rwd"
 		if [ $fail -eq 0 ]
 		then
 			IMPLEMENTED_PASS=$((IMPLEMENTED_PASS+1))
@@ -136,7 +145,7 @@ afunc() {
 	fi
 	if [ $fail -eq 0 -a $pass -eq 0 ]
 	then
-		echo "not implemented:  `pwd`"
+		echo "not implemented:  $rwd"
 		UNIMPLEMENTED=$(($UNIMPLEMENTED+1))
 	fi
 
@@ -163,6 +172,7 @@ afunc no
 echo "****************************************************"
 echo "Results for `pwd`:"
 echo "using `$CC --version`"
+echo "  (`which $CC`)"
 echo "with $OPTIONS $HEADER_INCLUDE $SOURCE_LIB"
 echo "----------------------------------------------------"
 echo "sections without tests   : $UNIMPLEMENTED"
