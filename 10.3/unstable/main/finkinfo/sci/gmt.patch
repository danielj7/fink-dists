diff -uNr GMT3.4.2.orig/man/manl/grdbarb.l GMT3.4.2/man/manl/grdbarb.l
--- GMT3.4.2.orig/man/manl/grdbarb.l	Thu Jan  1 09:00:00 1970
+++ GMT3.4.2/man/manl/grdbarb.l	Thu Feb 13 18:00:03 2003
@@ -0,0 +1,185 @@
+.TH GRDVECTOR l "1 Mar 2002"
+.SH NAME
+grdbarb \- Plot wind barb fields from grdfiles
+.SH SYNOPSIS
+\fBgrdbarb\fP \fIcompx.grd\fP \fIcompy.grd\fP \fB\-J\fP\fIparameters\fP [ \fB\-A\fP ]
+[ \fB\-B\fP\fItickinfo\fP ] [ \fB\-E\fP ]
+[ \fB\-I\fP\fIx_inc\fP[\fBm|c\fP][/\fIy_inc\fP[\fBm|c\fP]] ] [ \fB\-K\fP ] [ \fB\-N\fP ] [ \fB\-O\fP ] [ \fB\-P\fP ]
+[ \fB\-Q\fP\fIparameters\fP ] [ \fB\-R\fP\fIwest/east/south/north\fP[\fBr\fP] ]
+[ \fB\-T\fP ] [ \fB\-U\fP[\fI/dx/dy/\fP][\fIlabel\fP] ] [ \fB\-V\fP ] [ \fB\-W\fP\fIcontourpen\fP ] [ \fB\-X\fP\fIx-shift\fP ]
+[ \fB\-Y\fP\fIy-shift\fP ] [ \fB\-Z\fP ] [ \fB\-c\fP\fIcopies\fP ]
+.SH DESCRIPTION
+\fBgrdbarb\fP reads two 2-D gridded files which represents the x- and y-components of a vector field and
+produces a wind barb field plot by
+drawing barbs with orientation and length according to the information in the files. Alternatively,
+polar coordinate components may be used (r, theta).
+.TP
+\fIcompx.grd\fP
+Contains the x-component of the vector field.
+.TP
+\fIcompy.grd\fP
+Contains the y-component of the vector field.
+.TP
+.B \-J
+Selects the map projection. Scale is UNIT/degree, 1:xxxxx, or width in UNIT (upper case modifier).
+UNIT is cm, inch, or m, depending on the MEASURE_UNIT setting in .gmtdefaults, but this can be
+overridden on the command line by appending the c, i, or m to the scale/width value.
+.br
+.sp
+\fBCYLINDRICAL PROJECTIONS:\fP
+.br
+.sp
+\fB\-Jc\fP\fIlon0/lat0/scale\fP (Cassini)
+.br
+\fB\-Jj\fP\fIlon0/scale\fP (Miller)
+.br
+\fB\-Jm\fP\fIscale\fP (Mercator - Greenwich and Equator as origin)
+.br
+\fB\-Jm\fP\fIlon0/lat0/scale\fP (Mercator - Give meridian and standard parallel)
+.br
+\fB\-Joa\fP\fIlon0/lat0/azimuth/scale\fP (Oblique Mercator - point and azimuth)
+.br
+\fB\-Job\fP\fIlon0/lat0/lon1/lat1/scale\fP (Oblique Mercator - two points)
+.br
+\fB\-Joc\fP\fIlon0/lat0/lonp/latp/scale\fP (Oblique Mercator - point and pole)
+.br
+\fB\-Jq\fP\fIlon0/scale\fP (Equidistant Cylindrical Projection (Plate Carree))
+.br
+\fB\-Jt\fP\fIlon0/scale\fP (TM - Transverse Mercator, with Equator as y = 0)
+.br
+\fB\-Jt\fP\fIlon0/lat0/scale\fP (TM - Transverse Mercator, set origin)
+.br
+\fB\-Ju\fP\fIzone/scale\fP (UTM - Universal Transverse Mercator)
+.br
+\fB\-Jy\fP\fIlon0/lats/scale\fP (Basic Cylindrical Projection)
+.br
+.sp
+\fBAZIMUTHAL PROJECTIONS:\fP
+.br
+.sp
+\fB\-Ja\fP\fIlon0/lat0/scale\fP (Lambert).
+.br
+\fB\-Je\fP\fIlon0/lat0/scale\fP (Equidistant).
+.br
+\fB\-Jf\fP\fIlon0/lat0/horizon/scale\fP (Gnomonic).
+.br
+\fB\-Jg\fP\fIlon0/lat0/scale\fP (Orthographic).
+.br
+\fB\-Js\fP\fIlon0/lat0/\fP[\fIslat/\fP]\fIscale\fP (General Stereographic)
+.br
+.sp
+\fBCONIC PROJECTIONS:\fP
+.br
+.sp
+\fB\-Jb\fP\fIlon0/lat0/lat1/lat2/scale\fP (Albers)
+.br
+\fB\-Jd\fP\fIlon0/lat0/lat1/lat2/scale\fP (Equidistant)
+.br
+\fB\-Jl\fP\fIlon0/lat0/lat1/lat2/scale\fP (Lambert)
+.br
+.sp
+\fBMISCELLANEOUS PROJECTIONS:\fP
+.br
+.sp
+\fB\-Jh\fP\fIlon0/scale\fP (Hammer)
+.br
+\fB\-Ji\fP\fIlon0/scale\fP (Sinusoidal)
+.br
+\fB\-Jk\fP[\fBf|s\fP]\fIlon0/scale\fP (Eckert IV (f) and VI (s))
+.br
+\fB\-Jn\fP\fIlon0/scale\fP (Robinson)
+.br
+\fB\-Jr\fP\fIlon0/scale\fP (Winkel Tripel)
+.br
+\fB\-Jv\fP\fIlon0/scale\fP (Van der Grinten)
+.br
+\fB\-Jw\fP\fIlon0/scale\fP (Mollweide)
+.br
+.sp
+\fBNON-GEOGRAPHICAL PROJECTIONS:\fP
+.br
+.sp
+\fB\-Jp\fP[\fBa\fP]\fIscale\fP[\fI/origin\fP] (polar (theta,r) coordinates, optional \fBa\fP for azimuths and offset theta [0])
+.br
+\fB\-Jx\fP\fIx-scale\fP[\fBl|p\fP\fIpow\fP][\fI/y-scale\fP[\fBl|p\fP\fIpow\fP]] (Linear, log, and power scaling)
+.br
+More details can be found in the \fBpsbasemap\fP manpages.
+.br
+.SH OPTIONS
+No space between the option flag and the associated arguments.
+.TP
+.B \-A
+Means grdfiles have polar (r, theta) components instead of Cartesian (x, y).
+.TP
+.B \-B
+Sets map boundary tickmark intervals. See \fBpsbasemap\fP for details.
+.TP
+.B \-E
+Center vectors on grid nodes [Default draws from grid node].
+.TP
+.B \-I
+Only plot vectors at nodes every \fIx_inc, y_inc\fP apart (must be multiples of
+original grid spacing). Append \fBm\fP for minutes or \fBc\fP for seconds. [Default plots every node].
+.TP
+.B \-K
+More \fIPostScript\fP code will be appended later [Default terminates the plot system].
+.TP
+.B \-N
+Do NOT clip vectors at map boundaries [Default will clip].
+.TP
+.B \-O
+Selects Overlay plot mode [Default initializes a new plot system].
+.TP
+.B \-P
+Selects Portrait plotting mode [\fBGMT\fP Default is Landscape, see gmtdefaults to change this].
+.TP
+.B \-Q
+Select barb plot. Optionally, specify \fIparameters\fP which
+are \fIbarbwidth/barblength/barbangle/barbscale\fP [Default is 0.1\fBi\fP/0.2\fBi\fP/120/5]. 
+.TP
+.B \-R
+\fIwest, east, south,\fP and \fInorth\fP specify the Region of interest. To specify boundaries
+in degrees and minutes [and seconds], use the dd:mm[:ss] format. Append \fBr\fP if lower left and upper right
+map coordinates are given instead of wesn.
+Specify a subset of the grid.
+.TP
+.B \-T
+Means azimuth should be converted to angles based on the selected map projection.
+.TP
+.B \-U
+Draw Unix System time stamp on plot. User may specify where the lower left corner
+of the stamp should fall on the page relative to lower left corner of plot. Optionally,
+append a label, or \fBc\fP (which will plot the command string.). The GMT parameters
+UNIX_TIME and UNIX_TIME_POS can affect the appearance; see the \fBgmtdefaults\fP man
+page for details.
+.TP
+.B \-V
+Selects verbose mode, which will send progress reports to stderr [Default runs "silently"].
+.TP
+.B \-W
+Set pen attributes used for vector outlines [Default: width = 1, color = 0/0/0, texture = solid].
+.TP
+.B \-X \-Y
+Shift origin of plot by (\fIx-shift,y-shift\fP).
+Prepend \fBa\fP for absolute coordinates;
+the default (\fBr\fP) will reset plot origin.
+.TP
+.B \-Z
+Means the angles provided are azimuths rather than direction (requires \fB\-A\fP).
+.TP
+.B \-c
+Specifies the number of plot copies. [Default is 1]
+.SH EXAMPLES
+To draw the vector field given by the files r.grd and theta.grd on a linear plot
+with scale 5 cm per data unit,
+using vector rather than stick plot, and scale vector magnitudes so that 10 units
+equal 1 inch, try
+.br
+.sp
+grdvector r.grd theta.grd \fB\-Jx\fP5\fBc\fP \fB\-Q\fP \fB\-S\fP10\fBi\fP > gradient.ps
+.br
+.sp
+.SH "SEE ALSO"
+.IR gmt (l),
+.IR grdcontour (l),
+.IR psxy (l)
diff -uNr GMT3.4.2.orig/man/manl/psxy.l GMT3.4.2/man/manl/psxy.l
--- GMT3.4.2.orig/man/manl/psxy.l	Thu Oct  3 02:25:53 2002
+++ GMT3.4.2/man/manl/psxy.l	Thu Feb 13 18:03:43 2003
@@ -225,6 +225,16 @@
 .B \-Sp
 \fBp\fPoint. No size needs to be specified (1 pixel is used).
 .TP
+.B \-Sr
+\fBw\fPind barb. Direction (in degrees counter-clockwise from horizontal) and length must be found in columns 3 and 4. \fIsize\fP,
+if present, will be interpreted as barbwidth/barblength/barbangle/barbscale [Default is 0.1\fBi\fP/0.2\fBi\fP/120/5].
+.TP
+.B \-SR
+Same as \fB\-Sr\fP, except azimuth (in degrees east of north) should be given instead of direction. The azimuth will
+be mapped into an angle based on the chosen map projection (\fB\-Sr\fP leaves the directions
+unchanged.)
+.TP
+.B \-Ss
 .B \-Ss
 \fBs\fPquare. \fIsize\fP is diameter of circumscribing circle.
 .TP
diff -uNr GMT3.4.3/src/Makefile GMT3.4.3.new/src/Makefile
--- GMT3.4.3/src/Makefile	2003-04-11 08:03:00.000000000 +0900
+++ GMT3.4.3.new/src/Makefile	2003-04-30 22:12:50.000000000 +0900
@@ -103,7 +103,7 @@
 	  psbasemap.c psclip.c pscoast.c pshistogram.c psimage.c psmask.c \
 	  psrose.c psscale.c pstext.c pscontour.c pswiggle.c psxy.c psxyz.c \
 	  sample1d.c spectrum1d.c splitxyz.c surface.c trend1d.c trend2d.c \
-	  triangulate.c xyz2grd.c
+	  triangulate.c xyz2grd.c grdbarb.c
 
 first:	all
 
@@ -144,7 +144,7 @@
 all:		init libs $(PROGS)
 
 init:		gmtmacros gmt_notposix.h gmt_nan.h
-		
+
 gmtmacros:	
 		if [ `cat makegmt.macros | wc -c` = 0 ]; then \
 			echo "src/makegmt.macros is empty - you must rerun configure in the main GMT directory"; \
diff -uNr GMT3.4.3/src/grdbarb.c GMT3.4.3.new/src/grdbarb.c
--- GMT3.4.3/src/grdbarb.c	1970-01-01 09:00:00.000000000 +0900
+++ GMT3.4.3.new/src/grdbarb.c	2003-04-30 22:12:51.000000000 +0900
@@ -0,0 +1,420 @@
+/*--------------------------------------------------------------------
+ *	$Id: grdbarb.c,v 0.5 2002/05/27 $
+ *
+ *	Copyright (c) 1991-2002 by P. Wessel and W. H. F. Smith
+ *	See COPYING file for copying and redistribution conditions.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; version 2 of the License.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	Contact info: gmt.soest.hawaii.edu
+ *--------------------------------------------------------------------*/
+/*
+
+   grdbarb reads 2 grdfiles that contains the 2 components of a vector
+   field (cartesian or polar) and plots wind barb at the grid positions.
+
+   *** CAUTION ***
+   This program is under construction.
+
+   Author:     cachu
+   Date:       27-MAY-2002
+   Revised:    -----------
+   Version:	0.5 ( for GMT-3.4.1 )
+ 
+ */
+
+
+#include "gmt.h"
+
+float *r, *theta;
+
+main (int argc, char **argv)
+{
+
+	int	i, j, n = 0, nm, nx, ny, ij, i0, j0, di, dj, off;
+	int     dummy[4], knot_or_ms = 0;
+	
+	BOOLEAN convert_angles = FALSE, get_rgb = FALSE, cartesian = TRUE, shrink = FALSE, set_fill = FALSE;
+	BOOLEAN error = FALSE, center = FALSE, outline = FALSE, azimuth = FALSE, stick_plot = TRUE, inc_set = FALSE;
+	BOOLEAN clip = TRUE , got_fix_length = FALSE;
+	
+	char *file[2], *cpt, txt_a[32], txt_b[32], txt_c[32], unit = 0;
+	
+	double dx2, dy2, b_width = 0.1, b_length = 0.2, b_angle = 120., b_scale = 5.;
+	double v_w, h_l, h_w, v_shrink, v_norm = 0.0, tmp, x, y, plot_x, plot_y, x_off, y_off;
+	double west, east, south, north, x2, y2, scale = 1.0, fix_length = 0.0;
+	double data_west, data_east, data_south, data_north, value, c, s;
+	
+	struct GRD_HEADER h[2];
+	struct GMT_FILL fill;
+	struct GMT_PEN pen;
+
+	GMT_init_pen (&pen, GMT_PENWIDTH);
+	GMT_init_fill (&fill, -1, -1, -1);
+	west = east = south = north = 0.0;
+	dummy[0] = dummy[1] = dummy[2] = dummy[3] = 0;
+	di = dj = 1;
+	i0 = j0 = 0;
+	dx2 = dy2 = 0.0;
+	
+	argc = GMT_begin (argc, argv);
+
+	for (i = 1; i < argc; i++) {
+		if (argv[i][0] == '-') {
+			switch (argv[i][1]) {
+				/* Common parameters */
+			
+				case 'B':
+				case 'J':
+				case 'K':
+				case 'O':
+				case 'P':
+				case 'R':
+				case 'U':
+				case 'V':
+				case 'X':
+				case 'x':
+				case 'Y':
+				case 'y':
+				case 'c':
+				case '\0':
+					error += GMT_get_common_args (argv[i], &west, &east, &south, &north);
+					break;
+				
+				/* Supplemental parameters */
+			
+				case 'A':
+					cartesian = FALSE;
+					break;
+				case 'C':	/* Vary symbol color with z */
+					cpt = &argv[i][2];
+					get_rgb = TRUE;
+					break;
+				case 'E':
+					center = TRUE;
+					break;
+				case 'G':		/* Set Gray shade for polygon */
+					if (GMT_getfill (&argv[i][2], &fill)) {
+						GMT_fill_syntax ('G');
+						error++;
+					}
+					set_fill = TRUE;
+					break;
+				case 'I':	/* Only use gridnodes dx2,dy2 apart */
+					GMT_getinc (&argv[i][2], &dx2, &dy2);
+					inc_set = TRUE;
+					break;
+				case 'N':	/* Do not clip at border */
+					clip = FALSE;
+					break;
+				case 'Q':
+					if (argv[i][2] && argv[i][3] != 'n') {
+						if (sscanf (&argv[i][2], "%[^/]/%[^/]/%lf/%lf", txt_a, txt_b, &b_angle, &b_scale) != 4) {
+						        fprintf (stderr, "%s: GMT SYNTAX ERROR -Q option:  Could not decode barbwidth/barblength/barbangle/barbscale\n", GMT_program);
+							error++;
+						}
+						else {
+							b_width  = GMT_convert_units (txt_a, GMT_INCH);
+							b_length = GMT_convert_units (txt_b, GMT_INCH);
+						}
+					}
+					stick_plot = FALSE;
+					break;
+				case 'S':
+					j = strlen (argv[i]) - 1;
+					if (strchr ("cimpCIMP", (int)argv[i][j])) unit = argv[i][j];
+					if (argv[i][2] == 'l' || argv[i][2] == 'L') {
+						got_fix_length = TRUE;
+						fix_length = atof (&argv[i][3]);
+					}
+					else
+						scale = atof (&argv[i][2]);
+					break;
+				case 'T':
+					convert_angles = TRUE;
+					break;
+				case 'W':		/* Set line attributes */
+					if (argv[i][2] && GMT_getpen (&argv[i][2], &pen)) {
+						GMT_pen_syntax ('W');
+						error++;
+					}
+					outline = TRUE;
+					break;
+				case 'Z':
+					azimuth = TRUE;
+					break;
+				default:
+					error = TRUE;
+					GMT_default_error (argv[i][1]);
+					break;
+			}
+		}
+		else if (n < 2)
+			file[n++] = argv[i];
+		else
+			n++;
+	}
+	
+	if (argc == 1 || GMT_quick) {
+		fprintf (stderr, "grdbarb %s - Plot wind barb fields from grdfiles\n\n", GMT_VERSION);
+		fprintf (stderr, "usage: grdbarb compx.grd compy.grd -J<params> -R<west/east/south/north> [-A]\n");
+		fprintf (stderr, "\t[-B<tickinfo>] [-E] [-I<dx/dy>] [-K] [-O] [-P] [-Q<params>] [-N] [-T]\n");
+		fprintf (stderr, "\t[-U[<label>]] [-V] [-W<pen>] [-X<x_shift>] [-Y<y_shift>] [-Z] [-c<ncopies>] [-:]\n\n");
+		
+		if (GMT_quick) exit (EXIT_FAILURE);
+		
+		fprintf (stderr, "\tcompx & compy are grdfiles with the 2 vector components.\n");
+		GMT_explain_option ('j');
+		fprintf (stderr, "\n\tOPTIONS:\n");
+		fprintf (stderr, "\t-A means grdfiles have polar (r, theta) components [Default is Cartesian]\n");
+		GMT_explain_option ('b');
+		fprintf (stderr, "\t-E cEnter vectors on grid nodes [Default draws from grid node]\n");
+		fprintf (stderr, "\t   Default is no fill (vector outlines only)\n");
+		fprintf (stderr, "\t-I plots only those nodes that are <dx/dy> apart [Default is all nodes]\n");
+		GMT_explain_option ('K');
+		fprintf (stderr, "\t-N Do Not clip vectors that exceed the map boundaries [Default will clip]\n");
+		GMT_explain_option ('O');
+		GMT_explain_option ('P');
+		fprintf (stderr, "\t-Q Select vector plot [Default is stick-plot].\n");
+		fprintf (stderr, "\t   Optionally, specify vector parameters\n");
+		fprintf (stderr, "\t   <params> are barbwidth/barblength/barbangle/barbscale [Default is 0.4i/1.0i/120/5]\n");
+		fprintf (stderr, "\t   Append n<size> which will cause vectors shorter than <size> to be\n");
+		fprintf (stderr, "\t     scaled down\n");
+		GMT_explain_option ('R');
+		fprintf (stderr, "\t-T means azimuth should be converted to angles based on map projection\n");
+		GMT_explain_option ('U');
+		GMT_explain_option ('V');
+		fprintf (stderr, "\t-W sets pen attributes [width = %lgp, color = (%d/%d/%d), texture = solid line].\n", 
+			pen.width, pen.rgb[0], pen.rgb[1], pen.rgb[2]);
+		GMT_explain_option ('X');
+		fprintf (stderr, "\t-Z means the angles provided are azimuths rather than direction\n");
+		GMT_explain_option ('c');
+		GMT_explain_option ('.');
+		exit (EXIT_FAILURE);
+	}
+
+	if (inc_set && (dx2 <= 0.0 || dy2 <= 0.0)) {
+		fprintf (stderr, "%s: GMT SYNTAX ERROR -I option:  Must specify positive increments\n", GMT_program);
+		error++;
+	}
+	/*
+	if (scale == 0.0 && !got_fix_length) {
+		fprintf (stderr, "%s: GMT SYNTAX ERROR -S option:  Scale must be nonzero\n", GMT_program);
+		error++;
+	}
+	if (fix_length <= 0.0 && got_fix_length) {
+		fprintf (stderr, "%s: GMT SYNTAX ERROR -Sl option:  Length must be positive\n", GMT_program);
+		error++;
+	}
+	if (got_fix_length && shrink) {
+		fprintf (stderr, "%s: GMT SYNTAX ERROR -Sl, -Q options:  Cannot use -Q..n<size> with -Sl\n", GMT_program);
+		error++;
+	}
+	*/
+	if (azimuth && cartesian) {
+		fprintf (stderr, "%s: GMT SYNTAX ERROR -Z option:  Azimuths not valid input for Cartesian data\n", GMT_program);
+		error++;
+	}
+	if (get_rgb && !cpt) {
+		fprintf (stderr, "%s: GMT SYNTAX ERROR -C option:  Must specify a color palette table\n", GMT_program);
+		error++;
+	}
+	if (!(set_fill || outline || get_rgb)) {
+		fprintf (stderr, "%s: GMT SYNTAX ERROR:  Must specify -W\n", GMT_program);
+		/*		fprintf (stderr, "%s: GMT SYNTAX ERROR:  Must specify at least one of -G, -W, -C\n", GMT_program); */
+		error++;
+	}
+	if (n != 2) {
+		fprintf (stderr, "%s: GMT SYNTAX ERROR:  Must specify two input grdfiles\n", GMT_program);
+		error++;
+	}
+	
+	if (error) exit (EXIT_FAILURE);
+
+	GMT_put_history (argc, argv);	/* Update .gmtcommands */
+
+	if (get_rgb) GMT_read_cpt (cpt);
+
+	if (!(strcmp (file[0], "=") || strcmp (file[1], "="))) {
+		fprintf (stderr, "%s: Piping of grdfiles not supported!\n", GMT_program);
+		exit (EXIT_FAILURE);
+	}
+
+	if (GMT_read_grd_info (file[0], &h[0])) {
+		fprintf (stderr, "%s: Error opening file %s\n", GMT_program, file[0]);
+		exit (EXIT_FAILURE);
+	}
+	
+	if (GMT_read_grd_info (file[1], &h[1])) {
+		fprintf (stderr, "%s: Error opening file %s\n", GMT_program, file[1]);
+		exit (EXIT_FAILURE);
+	}
+	
+	if (!(h[0].nx == h[1].nx && h[0].ny == h[1].ny && h[0].x_min == h[1].x_min && h[0].y_min == h[1].y_min 
+		&& h[0].x_inc == h[1].x_inc && h[0].y_inc == h[1].y_inc)) {
+		fprintf (stderr, "%s: files %s and %s does not match!\n", GMT_program, file[0], file[1]);
+		exit (EXIT_FAILURE);
+	}
+	off = (h[0].node_offset) ? 0 : 1;
+		
+	/* Determine what wesn to pass to map_setup */
+
+	if (!project_info.region_supplied) {
+		west = h[0].x_min;
+		east = h[0].x_max;
+		south = h[0].y_min;
+		north = h[0].y_max;
+	}
+
+	GMT_map_setup (west, east, south, north);
+
+	/* Determine the wesn to be used to read the grdfile */
+
+	GMT_grd_setregion (&h[0], &data_west, &data_east, &data_south, &data_north);
+
+	/* Read data */
+
+	nx = irint ( (data_east - data_west) / h[0].x_inc) + off;
+	ny = irint ( (data_north - data_south) / h[0].y_inc) + off;
+	nm = nx * ny;
+	r = (float *) GMT_memory (VNULL, (size_t)nm, sizeof (float), GMT_program);
+	theta = (float *) GMT_memory (VNULL, (size_t)nm, sizeof (float), GMT_program);
+	if (GMT_read_grd (file[0], &h[0], r, data_west, data_east, data_south, data_north, GMT_pad, FALSE)) {
+		fprintf (stderr, "%s: Error reading file %s\n", GMT_program, file[0]);
+		exit (EXIT_FAILURE);
+	}
+	if (GMT_read_grd (file[1], &h[1], theta, data_west, data_east, data_south, data_north, GMT_pad, FALSE)) {
+		fprintf (stderr, "%s: Error reading file %s\n", GMT_program, file[1]);
+		exit (EXIT_FAILURE);
+	}
+	/*	if (!got_fix_length) scale = 1.0 / scale; */
+
+	switch (unit) {	/* Adjust for possible unit selection */
+		case 'C':
+		case 'c':
+			scale *= GMT_u2u[GMT_CM][GMT_INCH];
+			fix_length *= GMT_u2u[GMT_CM][GMT_INCH];
+			break;
+		case 'I':
+		case 'i':
+			scale *= GMT_u2u[GMT_INCH][GMT_INCH];
+			fix_length *= GMT_u2u[GMT_INCH][GMT_INCH];
+			break;
+		case 'M':
+		case 'm':
+			scale *= GMT_u2u[GMT_M][GMT_INCH];
+			fix_length *= GMT_u2u[GMT_M][GMT_INCH];
+			break;
+		case 'P':
+		case 'p':
+			scale *= GMT_u2u[GMT_PT][GMT_INCH];
+			fix_length *= GMT_u2u[GMT_PT][GMT_INCH];
+			break;
+		default:
+			scale *= GMT_u2u[gmtdefs.measure_unit][GMT_INCH];
+			fix_length *= GMT_u2u[gmtdefs.measure_unit][GMT_INCH];
+			break;
+	}
+	
+	ps_plotinit (CNULL, gmtdefs.overlay, gmtdefs.page_orientation, gmtdefs.x_origin, gmtdefs.y_origin,
+		gmtdefs.global_x_scale, gmtdefs.global_y_scale, gmtdefs.n_copies,
+		gmtdefs.dpi, GMT_INCH, gmtdefs.paper_width, gmtdefs.page_rgb, GMT_epsinfo (argv[0]));
+	GMT_echo_command (argc, argv);
+	if (gmtdefs.unix_time) GMT_timestamp (argc, argv);
+
+	GMT_setpen (&pen);
+
+        if (clip) GMT_map_clip_on (GMT_no_rgb, 3);
+
+	if (dx2 != 0.0 && dy2 != 0.0) {
+		dj = irint (dy2 / h[0].y_inc);
+		di = irint (dx2 / h[0].x_inc);
+		tmp = ceil (h[0].y_max / dy2) * dy2;
+		if (tmp > h[0].y_max) tmp -= dy2;
+		j0 = irint ((h[0].y_max - tmp) / h[0].y_inc);
+		tmp = floor (h[0].x_min / dx2) * dx2;
+		if (tmp < h[0].x_min) tmp += dx2;
+		i0 = irint ((tmp - h[0].x_min) / h[0].x_inc);
+	}
+	
+	for (j = j0; j < h[1].ny; j += dj) {
+		y = h[0].y_max - j *h[0].y_inc;
+		for (i = i0; i < h[1].nx; i += di) {
+		
+			ij = j * h[0].nx + i;
+			if (GMT_is_fnan (r[ij]) || GMT_is_fnan (theta[ij])) continue;	/* Cannot plot NaN-vectors */
+			
+			value = r[ij];
+			
+			if (cartesian) {
+				value = hypot (theta[ij], r[ij]);
+				if (value == 0.0) continue;
+				theta[ij] = (float)(R2D * atan2 (theta[ij], r[ij]));
+				r[ij] = (float)value;
+			}
+			else if (r[ij] < 0.0) {
+				r[ij] = -r[ij];
+				theta[ij] += 180.0;
+			}
+			else if (r[ij] == 0.0) continue;
+			
+			if (get_rgb) GMT_get_rgb24 (value, fill.rgb);
+			
+			x = h[0].x_min + i * h[0].x_inc;
+			GMT_geo_to_xy (x, y, &plot_x, &plot_y);
+			
+			if (convert_angles) {
+				if (!azimuth) theta[ij] = (float)90.0 - theta[ij];
+				GMT_azim_to_angle (x, y, 0.1, (double)theta[ij], &tmp);
+				theta[ij] = (float)(tmp * D2R);
+			}
+			else
+				theta[ij] *= (float)D2R;
+			
+			if (got_fix_length)
+				r[ij] = (float)fix_length;
+			else
+				r[ij] *= (float)scale;
+			
+			sincos (theta[ij], &s, &c);
+			x2 = plot_x + r[ij] * c;
+			y2 = plot_y + r[ij] * s;
+			
+			if (center) {
+				x_off = 0.5 * (x2 - plot_x);
+				y_off = 0.5 * (y2 - plot_y);
+				plot_x -= x_off;
+				plot_y -= y_off;
+				x2 -= x_off;
+				y2 -= y_off;
+			}
+			
+			if (stick_plot) {
+				if (get_rgb) ps_setpaint (fill.rgb);
+				ps_plot (plot_x, plot_y, 3);
+				ps_plot (x2, y2, 2);
+				continue;
+			}
+			
+			ps_barb (plot_x, plot_y, x2, y2, b_width, b_length, b_angle, b_scale, knot_or_ms, fill.rgb, outline);
+		}
+	}
+	
+        if (clip) GMT_map_clip_off ();
+
+	if (frame_info.plot) GMT_map_basemap ();
+
+	ps_plotend (gmtdefs.last_page);
+
+	GMT_free ((void *)r);
+	GMT_free ((void *)theta);
+	
+	GMT_end (argc, argv);
+}
diff -uNr GMT3.4.3/src/pslib.c GMT3.4.3.new/src/pslib.c
--- GMT3.4.3/src/pslib.c	2003-04-18 07:39:25.000000000 +0900
+++ GMT3.4.3.new/src/pslib.c	2003-04-30 22:12:51.000000000 +0900
@@ -99,6 +99,7 @@
  *	ps_transrotate		: Translates and rotates the coordinate system
  *	ps_triangle		: Plots a triangle and [optionally] fills it
  *	ps_vector		: Draws an vector as specified
+ *	ps_barb			: Draws an barb as specified
  *	ps_words		: Plots a text paragraph
  *
  *
@@ -112,6 +113,8 @@
  * Date:	09-MAR-2001
  * Version:	3.4.3
  *
+ * Modified by cachu <cachu@cocoa.ocn.ne.jp> 13-FEB-2003
+ *
  * The environmental variable GMTHOME must be set to the directory that holds the subdirectory
  *   share where all the pattern Sun raster files are stored
  */
@@ -1366,6 +1369,8 @@
 		fprintf (ps.fp, "/A2 {0 exch M 0 D D D D D 0 D P V C F U N} bind def\n");
 		fprintf (ps.fp, "/A3 {0 exch M 0 D D D D D 0 D P V C F U S} bind def\n");
 		fprintf (ps.fp, "/A4 {0 exch M 0 D D D D D 0 D P S} bind def\n");
+		fprintf (ps.fp, "/Bt {0 M D D P F} bind def\n");
+		fprintf (ps.fp, "/Bl {0 M D S} bind def\n");
 		fprintf (ps.fp, "/C0 {0 360 arc V A F U N} bind def\n");
 		fprintf (ps.fp, "/C1 {0 360 arc V A F U S} bind def\n");
 		fprintf (ps.fp, "/C2 {0 360 arc V C F U N} bind def\n");
@@ -2212,6 +2217,76 @@
 	 ps_vector (*xtail, *ytail, *xtip, *ytip, *tailwidth, *headlength, *headwidth, *headshape, rgb, *outline);
 }
 
+void ps_barb (double xtail, double ytail, double xtip, double ytip, double barbwidth, double barblength, double barbangle, double barbscale, int knot_or_ms, int rgb[], int outline)
+{
+	/* Will make sure that arrow has a finite width in PS coordinates */
+	
+	double angle, barb_tmp, length;
+	int w0, w1, dx, dy, nloop, number_of_barb, loop, itri;
+	int num_of_tri, num_of_ful, num_of_hlf;
+	int num_of_TRI, num_of_FUL, num_of_BLB;
+	
+	length = hypot((xtail-xtip), (ytail-ytip));
+	if (length == 0.) return;
+
+	angle = atan2 ((ytip-ytail),(xtip-xtail)) * R2D + 180.;
+	fprintf (ps.fp, "V %d %d T", irint (xtail * ps.scale), irint (ytail * ps.scale));
+	if (angle != 0.0) fprintf (ps.fp, " %lg R", angle);
+
+	w0 = irint (barblength * ps.scale / 2.);
+	w1 = irint (0.25 * (barblength * ps.scale - w0));
+	dx = irint(- barbwidth * ps.scale * cos(barbangle / R2D));
+	dy = irint(- barbwidth * ps.scale * sin(barbangle / R2D));
+
+	nloop = 1;
+	num_of_tri = (int) (length/barbscale/5. + 0.0001);
+	barb_tmp   = length - barbscale * (double) ( 5 * num_of_tri );
+	num_of_ful = (int)(barb_tmp/barbscale + 0.0001);
+	barb_tmp   = barb_tmp - barbscale * (double)num_of_ful;
+	num_of_hlf = (int)(barb_tmp * 2. / barbscale + 0.0001);
+	number_of_barb = num_of_tri + num_of_ful + num_of_hlf;
+
+	num_of_TRI = 0;
+	num_of_FUL = num_of_ful;
+	num_of_BLB = 0;
+	itri = (num_of_tri == 0) ? 0 : 1;
+	itri *= w1;
+
+	fprintf (ps.fp, " %d 0 0 Bl", irint(barblength * ps.scale));
+
+	for(loop=1;loop <= number_of_barb; loop++) {
+	  if(num_of_tri != 0){
+	    if(num_of_FUL == 0){
+	      fprintf(ps.fp, " %d %d %d %d %d Bt",dx,dy,-2*w1,0,irint(barblength*ps.scale)+w1+2*num_of_TRI*w1);
+	    }else{
+	      fprintf(ps.fp, " %d %d %d %d %d Bt",dx,dy,-2*w1,0,irint(barblength*ps.scale)+2*w1+2*num_of_TRI*w1);
+	    }
+	    num_of_tri--;
+	    num_of_TRI++;
+	  }else if(num_of_ful != 0){
+	    fprintf(ps.fp, " %d %d %d Bl",dx,dy,irint(barblength*ps.scale)-w1*num_of_BLB-itri);
+	    num_of_ful--;
+	    num_of_BLB++;
+	  }else{
+	    if(num_of_BLB == 0){
+	      fprintf(ps.fp, " %d %d %d Bl",irint(dx/2),irint(dy/2),irint(barblength*ps.scale)-w1-itri);
+	    }else{
+	      fprintf(ps.fp, " %d %d %d Bl",irint(dx/2),irint(dy/2),irint(barblength*ps.scale)-w1*num_of_BLB-itri);
+	      num_of_hlf = 0;
+	    }
+	  }
+	}	  
+	fprintf(ps.fp, " U \n");
+}
+
+/* fortran interface */
+/*
+void ps_barb_ (double *xtail, double *ytail, double *xtip, double *ytip, double *barbwidth, double *barblength, double *barbwidth, double *barbscale, int *knot_or_ms, int *rgb, int *outline)
+{
+	 ps_barb (*xtail, *ytail, *xtip, *ytip, *barbwidth, *barblength, *barbwidth, *barbscale, *knot_or_ms, rgb, *outline);
+}
+*/
+
 /* Support functions used in ps_* functions.  No Fortran bindings needed */
 
 void get_uppercase (char *new, char *old)
diff -uNr GMT3.4.3/src/pslib.h GMT3.4.3.new/src/pslib.h
--- GMT3.4.3/src/pslib.h	2003-04-18 07:39:25.000000000 +0900
+++ GMT3.4.3.new/src/pslib.h	2003-04-30 22:12:51.000000000 +0900
@@ -118,6 +118,7 @@
 EXTERN_MSC void ps_transrotate(double x, double y, double angle);
 EXTERN_MSC void ps_triangle(double x, double y, double side, int rgb[], int outline);
 EXTERN_MSC void ps_vector(double xtail, double ytail, double xtip, double ytip, double tailwidth, double headlength, double headwidth, double headshape, int rgb[], int outline);
+EXTERN_MSC void ps_barb(double xtail, double ytail, double xtip, double ytip, double barbwidth, double barblength, double barbangle, double barbscale, int knot_or_ms, int rgb[], int outline);
 EXTERN_MSC unsigned char *ps_loadraster (char *file, struct rasterfile *header, BOOLEAN invert, BOOLEAN monochrome, BOOLEAN colorize, int f_rgb[], int b_rgb[]);
 EXTERN_MSC void ps_words (double x, double y, char **text, int n_words, double line_space, double par_width, int par_just, int font, int font_size, double angle, int rgb[3], int justify, int draw_box, double x_off, double y_off, double x_gap, double y_gap, int boxpen_width, char *boxpen_texture, int boxpen_offset, int boxpen_rgb[], int vecpen_width, char *vecpen_texture, int vecpen_offset, int vecpen_rgb[], int boxfill_rgb[3]);
 
diff -uNr GMT3.4.3/src/psxy.c GMT3.4.3.new/src/psxy.c
--- GMT3.4.3/src/psxy.c	2003-04-18 07:39:25.000000000 +0900
+++ GMT3.4.3.new/src/psxy.c	2003-04-30 22:12:51.000000000 +0900
@@ -26,6 +26,8 @@
  * Date:	29-AUG-2000
  * Version:	3.4.3
  *
+ * Modified by cachu <cachu@cocoa.ocn.ne.jp> at 13-FEB-2003
+ *
  */
 
 #include "gmt.h"
@@ -48,6 +50,7 @@
 #define VECTOR2		13
 #define TEXT		14
 #define PIE		15
+#define BARB		16
 #define FRONT	-16
 
 /* FRONT symbols */
@@ -92,12 +95,17 @@
 
 	BOOLEAN convert_angles;	/* If TRUE, convert azimuth to angle on map */
 	BOOLEAN read_vector;	/* if TRUE must read vector attributes */
+	BOOLEAN read_barb;	/* if TRUE must read barb attributes */
 	BOOLEAN shrink;		/* If TRUE, shrink vector attributes for small lengths */
 	double v_norm;		/* shrink when lengths are smaller than this */
 	double v_shrink;	/* Required scale factor */
 	double v_width;		/* Width of vector stem in inches */
 	double h_length;	/* Length of vector head in inches */
 	double h_width;		/* Width of vector head in inches */
+	double b_width;		/* Width of wind barb in inches */
+	double b_length;	/* Length of wind barb in inches */
+	double b_angle;		/* Angle of wind barb in degree */
+	double b_scale;		/* Scale of each wind barb */
 
 	char string[64];	/* Character code to plot (could be octal) */
 
@@ -153,15 +161,23 @@
 	S.symbol = S.n_required = 0;
 	S.size = S.base = S.v_norm = S.v_shrink = 0.0;
 	S.read_size = S.user_unit = S.convert_angles = S.shrink = S.read_vector = FALSE;
+	S.read_barb = FALSE;
 	S.v_width = 0.03;
 	memset ((void *)S.string, 0, (size_t)(16 * sizeof (char)));
 	S.h_length = 0.12;
 	S.h_width = 0.1;
 	S.font_no = gmtdefs.anot_font;
 
+	S.b_width  = 0.1;
+	S.b_length = 0.2;
+	S.b_angle  = 120.;
+	S.b_scale  = 5.;
+
 	if ((S.u = gmtdefs.measure_unit) == GMT_CM) {
 		S.v_width = 0.075 / 2.54;	S.h_length = 0.3 / 2.54;
 		S.h_width = 0.25 / 2.54; error_width = 0.25 / 2.54;
+		S.b_width = 0.25 / 2.54;
+		S.b_length = 0.50 / 2.54;
 	}
 	
 	/* Check and interpret the command line arguments */
@@ -319,8 +335,8 @@
 		GMT_explain_option ('O');
 		GMT_explain_option ('P');
 		fprintf (stderr, "\t-S to select symbol type and symbol size (in %s).  Choose between\n", GMT_unit_names[gmtdefs.measure_unit]);
-		fprintf (stderr, "\t   st(a)r, (b)ar, (c)ircle, (d)iamond, (e)llipse, (f)ront, (h)exagon,\n");
-		fprintf (stderr, "\t   (i)nvtriangle, (l)etter, (p)oint, (s)quare, (t)riangle, (v)ector, (w)edge, (x)cross\n");
+		fprintf (stderr, "\t   st(a)r, (b)ar, (c)ircle, (d)iamond, (e)llipse, (f)ront, (h)exagon, (i)nvtriangle\n");
+		fprintf (stderr, "\t   (l)etter, (p)oint, ba(r)b, (s)quare, (t)riangle, (v)ector, (w)edge, (x)cross\n");
 		fprintf (stderr, "\t   If no size is specified, psxy expects the 3rd column to have sizes.\n");
 		fprintf (stderr, "\t   If no symbol is specified, psxy expects the last column to have symbol code.\n");
 		fprintf (stderr, "\t   [Note: if -C is selected then 3rd means 4th column, etc.]\n");
@@ -344,6 +360,10 @@
 		fprintf (stderr, "\t     Furthermore, <size> means arrowwidth/headlength/headwith [Default is %lg/%lg/%lg]\n", S.v_width, S.h_length, S.h_width);
 		fprintf (stderr, "\t     If -SV rather than -Sv is selected, psxy will expect azimuth and length\n");
 		fprintf (stderr, "\t     and convert azimuths based on the chosen map projection\n");
+		fprintf (stderr, "\t   Barbs: the direction and length must be in input columns 3 and 4.\n");
+		fprintf (stderr, "\t     Furthermore, <size> means barbwidth/barblength/barbangle/barbscale [Default is %lg/%lg/%lg/%lg]\n", S.b_width, S.b_length, S.b_angle, S.b_scale);
+		fprintf (stderr, "\t     If -SR rather than -Sr is selected, psxy will expect azimuth and length\n");
+		fprintf (stderr, "\t     and convert azimuths based on the chosen map projection\n");
 		fprintf (stderr, "\t   Wedges: the start and stop directions of pie wedge must be in input columns 3, 4.\n");
 		GMT_explain_option ('U');
 		GMT_explain_option ('V');
@@ -364,8 +384,8 @@
 	
 	if (S.symbol > 0 && cpt_given) get_rgb = TRUE;	/* Need to read z-vales from input data file */
 	
-	if (error_bars && (S.read_vector || S.symbol == ELLIPSE || S.symbol == FRONT)) {
-		fprintf (stderr, "%s: GMT SYNTAX ERROR -E option: Incompatible with -Se, -Sf, -Sv\n", GMT_program);
+	if (error_bars && (S.read_vector || S.read_barb || S.symbol == ELLIPSE || S.symbol == FRONT)) {
+		fprintf (stderr, "%s: GMT SYNTAX ERROR -E option: Incompatible with -Se, -Sf, -Sv, -Sr\n", GMT_program);
 		error++;
 	}
 	if (fill.use_pattern && S.symbol != LINE) {	/* fill-pattern only for polygons */
@@ -587,6 +607,10 @@
 					dir1 = in[two+S.read_size];
 					dir2 = in[three+S.read_size];
 				}
+				else if (S.read_barb){
+					direction = in[two];
+					length = in[three];
+				}
 				
 				/* Skip zero-size symbols */
 				
@@ -595,7 +619,7 @@
 					continue;
 				}
 				
-				if (S.read_vector && length <= 0.0) {
+				if ( ( S.read_vector || S.read_barb ) && length <= 0.0) {
 					if (gmtdefs.verbose) fprintf (stderr, "%s: Warning: Vector length <= 0.0 near line %d (skipped)\n", GMT_program, n_total_read);
 					continue;
 				}
@@ -691,6 +715,15 @@
 						else
 							ps_ellipse (plot_x, plot_y, direction, major, minor, fill.rgb, outline);
 						break;
+					case BARB:
+						if (S.convert_angles) {
+							GMT_azim_to_angle (in[0], in[1], 0.1, direction, &tmp);
+							direction = tmp;
+						}
+						x2 = plot_x + length * cos (direction * D2R);
+						y2 = plot_y + length * sin (direction * D2R);
+						ps_barb (plot_x, plot_y, x2, y2, S.b_width, S.b_length, S.b_angle, S.b_scale, 0, fill.rgb, outline);
+						break;
 					case VECTOR:
 						if (S.convert_angles) {
 							GMT_azim_to_angle (in[0], in[1], 0.1, direction, &tmp);
@@ -1081,6 +1114,24 @@
 			p->symbol = POINT;
 			check = FALSE;
 			break;
+		case 'R':
+			p->convert_angles = TRUE;
+		case 'r':
+			p->symbol = BARB;
+			len = strlen(text) - 1;
+			if (text[1]) {
+				if (isalpha ((int)text[len]) && isalpha ((int)text[len-1])) {
+					p->u = GMT_get_unit (text[len]);
+					text[len] = 0;
+				}
+				sscanf (&text[1], "%[^/]/%[^/]/%lf/%lf", txt_a, txt_b, &p->b_angle, &p->b_scale);
+				p->b_width  = GMT_convert_units (txt_a, GMT_INCH);
+				p->b_length = GMT_convert_units (txt_b, GMT_INCH);
+			}
+			p->read_barb = TRUE;
+			p->n_required = 2;
+			check = FALSE;
+			break;
 		case 'S':
 			p->size *= 1.25331413731;	/* To equal area of circle with same size */
 		case 's':
