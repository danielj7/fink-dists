--- nedit-5.3/makefiles/Makefile.macosx.orig	 Mon Jul  1 05:47:10 2002
+++ nedit-5.3/makefiles/Makefile.macosx		Mon Jul  1 05:42:43 2002
@@ -2,16 +2,16 @@
 # Makefile for MacOS X, using Tenon's Xtools
 # Contributed from hopperj@macconnect.com
 CC=cc
-AR=Libtool
+AR=libtool
 # For editres, add -DEDITRES to CFLAGS and -lXmu to LIBS\\
-CFLAGS=-O -no-cpp-precomp -DNO_XMIM -I${PREFIX}/include -DUSE_DIRENT -DUSE_LPR_PRINT_CMD -DUSE_XMIM
-LIBS= ${MOTIFLIB} -bind_at_load -L/usr/X11R6/lib /usr/X11R6/lib/libXm.2.dylib /usr/X11R6/lib/libXp.6.dylib -lm -lXpm \
--lXext -lXt -lSM -lICE -lX11
+CFLAGS=-O -no-cpp-precomp -DNO_XMIM -I${PREFIX}/include -I/usr/X11R6/include -DUSE_DIRENT -DUSE_LPR_PRINT_CMD -DUSE_XMIM
+#LIBS= ${MOTIFLIB} -bind_at_load -L/usr/X11R6/lib /usr/X11R6/lib/libXm.2.dylib /usr/X11R6/lib/libXp.6.dylib -lm -lXpm \
+#-lXext -lXt -lSM -lICE -lX11
 #
 # That would be an alternative set of flags using XFree86 with LessTif:
 #
-#LIBS=-flat-namespace -force_flat_namespace -L/usr/local/lib\
-#     -L/usr/X11R6/lib -lm -lXm -lXt -lXpm -lXext -lSM -lICE -lX11
+LIBS=-force_flat_namespace -L${PREFIX}/lib\
+     -L/usr/X11R6/lib -lXm -lXt -lXpm -lXext -lSM -lICE -lX11
 
 #
 # generic part
Index: source/file.c
===================================================================
retrieving revision 1.42.2.1
diff -u -r1.42.2.1 file.c
--- nedit-5.3/source/file.c	2002/04/15 10:46:35	1.42.2.1
+++ nedit-5.3/source/file.c	2002/08/16 03:30:12
@@ -82,6 +82,7 @@
    system which is slow to process stat requests (which I'm not sure exists) */
 #define MOD_CHECK_INTERVAL 3000
 
+void UpdateBufferTabBar(WindowInfo *window);
 static int doSave(WindowInfo *window);
 static void safeClose(WindowInfo *window);
 static int doOpen(WindowInfo *window, const char *name, const char *path,
@@ -103,8 +104,8 @@
 void removeVersionNumber(char *fileName);
 #endif /*VMS*/
 
-void EditNewFile(char *geometry, int iconic, const char *languageMode,
-	const char *defaultPath)
+WindowInfo *EditNewFile(WindowInfo *inWindow, char *geometry, int iconic,
+        const char *languageMode, const char *defaultPath)
 {
     char name[MAXPATHLEN];
     WindowInfo *window;
@@ -114,8 +115,12 @@
     /* Find a (relatively) unique name for the new file */
     UniqueUntitledName(name);
 
-    /* create the window */
-    window = CreateWindow(name, geometry, iconic);
+    /* create the window/buffer */
+    if (GetPrefWindowBufferMode() && WindowList)
+	window = CreateBuffer(inWindow, name, geometry, iconic);
+    else 
+	window = CreateWindow(name, geometry, iconic);
+	
     strcpy(window->filename, name);
     strcpy(window->path, defaultPath ? defaultPath : "");
     window->filenameSet = FALSE;
@@ -126,10 +131,14 @@
     UpdateWindowReadOnly(window);
     UpdateStatsLine(window);
     UpdateWindowTitle(window);
+    UpdateBufferTabBar(window);
+
     if (languageMode == NULL) 
     	DetermineLanguageMode(window, True);
     else
 	SetLanguageMode(window, FindLanguageMode(languageMode), True);
+	
+    return window;
 }
 
 /*
@@ -156,21 +165,24 @@
     /* first look to see if file is already displayed in a window */
     window = FindWindowWithFile(name, path);
     if (window != NULL) {
-    	RaiseShellWindow(window->shell);
+    	RaiseBufferWindow(window);
 	return window;
     }
     
     /* If an existing window isn't specified; or the window is already
        in use (not Untitled or Untitled and modified), or is currently
        busy running a macro; create the window */
-    if (inWindow == NULL || inWindow->filenameSet || inWindow->fileChanged ||
-	    inWindow->macroCmdData != NULL)
+    if (inWindow == NULL)
 	window = CreateWindow(name, geometry, iconic);
-    else {
+    else if (inWindow->filenameSet || inWindow->fileChanged ||
+	    inWindow->macroCmdData != NULL)
+	if (GetPrefWindowBufferMode())
+	    window = CreateBuffer(inWindow, name, geometry, iconic);
+	else
+	    window = CreateWindow(name, geometry, iconic);
+    else
     	window = inWindow;
-        RaiseShellWindow(window->shell);
-    }
-    	
+
     /* Open the file */
     if (!doOpen(window, name, path, flags)) {
 	/* The user may have destroyed the window instead of closing the 
@@ -184,6 +196,7 @@
     UpdateWindowTitle(window);
     UpdateWindowReadOnly(window);
     UpdateStatsLine(window);
+    UpdateBufferTabBar(window);
     
     /* Add the name to the convenience menu of previously opened files */
     strcpy(fullname, path);
@@ -548,9 +561,13 @@
 int CloseFileAndWindow(WindowInfo *window, int preResponse)
 { 
     int response, stat;
+    int bufferDetachMode = preResponse & BUFFER_DETACH_MODE;
+
+    preResponse &= 0xFF;
     
     /* Make sure that the window is not in iconified state */
-    RaiseShellWindow(window->shell);
+    if (!bufferDetachMode)
+    	RaiseBufferWindow(window);
 
     /* if window is modified, ask about saving, otherwise just close */
     if (!window->fileChanged) {
@@ -674,6 +691,7 @@
     retVal = doSave(window);
     UpdateWindowTitle(window);
     UpdateWindowReadOnly(window);
+    UpdateBufferTabBar(window);
     
     /* Add the name to the convenience menu of previously opened files */
     AddToPrevOpenMenu(fullname);
Index: source/file.h
===================================================================
retrieving revision 1.9
diff -u -r1.9 file.h
--- nedit-5.3/source/file.h	2001/10/15 17:28:16	1.9
+++ nedit-5.3/source/file.h	2002/08/06 02:07:55
@@ -7,9 +7,10 @@
 #define PROMPT_SBC_DIALOG_RESPONSE 0
 #define YES_SBC_DIALOG_RESPONSE 1
 #define NO_SBC_DIALOG_RESPONSE 2
+#define BUFFER_DETACH_MODE 0x100
 
-void EditNewFile(char *geometry, int iconic, const char *languageMode,
-    	const char *defaultPath);
+WindowInfo *EditNewFile(WindowInfo *inWindow, char *geometry, int iconic,
+        const char *languageMode, const char *defaultPath);
 WindowInfo *EditExistingFile(WindowInfo *inWindow, const char *name,
         const char *path, int flags, char *geometry, int iconic,
 	const char *languageMode);
Index: source/help_data.h
===================================================================
retrieving revision 1.9.2.4
diff -u -r1.9.2.4 help_data.h
--- nedit-5.3/source/help_data.h	2002/06/01 13:44:08	1.9.2.4
+++ nedit-5.3/source/help_data.h	2002/08/06 02:07:55
@@ -3234,6 +3234,11 @@
 "options not settable via the Preferences menu (for preference resource names, ",
 "see your .nedit file): ",
 "\n\n",
+"\01A\01Bnedit.windowBufferMode\01A: False \n",
+"\01I\n",
+"When set to True, run NEdit in buffer mode. ",
+"Same as running NEdit with the '-buffers' option."
+"\n\n",
 "\01A\01Bnedit.tagFile\01A: (not defined) \n",
 "\01I\n",
 "This can be the name of a file, or multiple files separated by a colon (:) ",
@@ -3856,7 +3861,7 @@
 "      [-\01Biconic\01A] [-\01Bnoiconic\01A] [-\01Bdisplay\01A [host]:server[.screen]\n",
 "      [-\01Bxrm\01A resourcestring] [-\01Bsvrname\01A name] [-\01Bimport\01A file]\n",
 "      [-\01Bbackground\01A color] [-\01Bforeground\01A color] [-\01BV\01A|-\01Bversion\01A]\n",
-"      [--] [file...]\n",
+"      [-\01Bbuffers\01A] [-\01Bnobuffers\01A] [--] [file...]\n",
 "\01I\n",
 "\01A\01B-read\01A\n",
 "\01IOpen the file Read Only regardless of the actual file protection. ",
@@ -3872,6 +3877,12 @@
 "nc program.  nc can be used to interface NEdit to code development ",
 "environments, mailers, etc., or just as a quick way to open files from the ",
 "shell command line without starting a new NEdit session. ",
+"\n\n",
+"\01A\01B-buffers\01A\n",
+"\01IRun NEdit in buffer mode - allow multiple buffers (files) per window. ",
+"\n\n",
+"\01A\01B-nobuffers\01A\n",
+"\01IDisable buffer mode, run NEdit in normal (one file per window) mode ",
 "\n\n",
 "\01A\01B-do command\01A\n",
 "\01IExecute an NEdit macro or action. On each file following the -do argument on ",
Index: source/interpret.c
===================================================================
retrieving revision 1.22
diff -u -r1.22 interpret.c
--- nedit-5.3/source/interpret.c	2002/03/01 22:44:54	1.22
+++ nedit-5.3/source/interpret.c	2002/08/06 02:07:55
@@ -49,6 +49,7 @@
 #include "text.h"
 #include "rbTree.h"
 #include "interpret.h"
+#include "window.h"
 
 #define PROGRAM_SIZE  4096	/* Maximum program size */
 #define MAX_ERR_MSG_LEN 256	/* Max. length for error messages */
@@ -594,6 +595,7 @@
 void SetMacroFocusWindow(WindowInfo *window)
 {
     FocusWindow = window;
+    RaiseBuffer(window);
 }
 
 /*
Index: source/macro.c
===================================================================
retrieving revision 1.38
diff -u -r1.38 macro.c
--- nedit-5.3/source/macro.c	2001/12/24 11:50:24	1.38
+++ nedit-5.3/source/macro.c	2002/08/06 02:07:55
@@ -1012,6 +1012,9 @@
 	XSendEvent(XtDisplay(window->shell), XtWindow(window->shell), False,
 		NoEventMask, (XEvent *)&event);
     }
+    
+    if (window)
+    	RaiseBuffer(window);
 }
 
 /*
Index: source/menu.c
===================================================================
retrieving revision 1.53
diff -u -r1.53 menu.c
--- nedit-5.3/source/menu.c	2002/03/11 22:05:11	1.53
+++ nedit-5.3/source/menu.c	2002/08/08 05:29:41
@@ -263,6 +263,18 @@
 static void findDefAP(Widget w, XEvent *event, String *args, Cardinal *nArgs); 
 static void splitWindowAP(Widget w, XEvent *event, String *args,
 	Cardinal *nArgs);
+static void detachBufferDialogAP(Widget w, XEvent *event, String *args,
+	Cardinal *nArgs);
+static void detachBufferAP(Widget w, XEvent *event, String *args,
+	Cardinal *nArgs);
+static void attachBufferDialogAP(Widget w, XEvent *event, String *args,
+	Cardinal *nArgs);
+static void nextBufferAP(Widget w, XEvent *event, String *args,
+	Cardinal *nArgs);
+static void prevBufferAP(Widget w, XEvent *event, String *args,
+	Cardinal *nArgs);
+static void toggleBufferAP(Widget w, XEvent *event, String *args,
+	Cardinal *nArgs);
 static void closePaneAP(Widget w, XEvent *event, String *args, Cardinal *nArgs);
 static void capitalizeAP(Widget w, XEvent *event, String *args,
 	Cardinal *nArgs);
@@ -318,6 +330,7 @@
 static void updateWindowSizeMenu(WindowInfo *win);
 static int strCaseCmp(const char *str1, const char *str2);
 static int compareWindowNames(const void *windowA, const void *windowB);
+static int compareWindowShell(const void *windowA, const void *windowB);
 static void bgMenuPostAP(Widget w, XEvent *event, String *args,
 	Cardinal *nArgs);
 static void raiseWindowAP(Widget w, XEvent *event, String *args,
@@ -459,6 +472,18 @@
     {"split_window", splitWindowAP},
     {"close-pane", closePaneAP},
     {"close_pane", closePaneAP},
+    {"detach-buffer", detachBufferAP},
+    {"detach_buffer", detachBufferAP},
+    {"detach-buffer-dialog", detachBufferDialogAP},
+    {"detach_buffer_dialog", detachBufferDialogAP},
+    {"attach-buffer-dialog", attachBufferDialogAP},
+    {"attach_buffer_dialog", attachBufferDialogAP},
+    {"next-buffer", nextBufferAP},
+    {"next_buffer", nextBufferAP},
+    {"prev-buffer", prevBufferAP},
+    {"prev_buffer", prevBufferAP},
+    {"toggle-buffer", toggleBufferAP},
+    {"toggle_buffer", toggleBufferAP},
     {"uppercase", capitalizeAP},
     {"lowercase", lowercaseAP},
     {"fill-paragraph", fillAP},
@@ -1072,6 +1097,27 @@
     	    "Close Pane", 'C', doActionCB, "close_pane", SHORT);
     XtVaSetValues(window->closePaneItem, XmNuserData, PERMANENT_MENU_ITEM,NULL);
     XtSetSensitive(window->closePaneItem, False);
+
+    if (GetPrefWindowBufferMode()) {
+	btn = createMenuSeparator(menuPane, "sep01", SHORT);
+	XtVaSetValues(btn, XmNuserData, PERMANENT_MENU_ITEM, NULL);
+	window->detachBufferItem = createMenuItem(menuPane, "detachBuffer",
+    		"Detach Buffer", 'D', doActionCB, "detach_buffer", SHORT);
+    	XtSetSensitive(window->detachBufferItem, False);
+	
+	window->attachBufferItem = createMenuItem(menuPane, "attachBuffer",
+    		"Attach Buffer...", 'A', doActionCB, "attach_buffer_dialog", SHORT);
+    	XtSetSensitive(window->attachBufferItem, False);
+	btn = createMenuSeparator(menuPane, "sep0", SHORT);
+	XtVaSetValues(btn, XmNuserData, PERMANENT_MENU_ITEM, NULL);
+	createMenuItem(menuPane, "nextBuffer",
+    		"Next Buffer", 'N', doActionCB, "next_buffer", SHORT);
+	createMenuItem(menuPane, "prevBuffer",
+    		"Prev Buffer", 'P', doActionCB, "prev_buffer", SHORT);
+	createMenuItem(menuPane, "toggleBuffer",
+    		"Toggle Buffer", 'o', doActionCB, "toggle_buffer", SHORT);
+    }
+
     btn = createMenuSeparator(menuPane, "sep1", SHORT);
     XtVaSetValues(btn, XmNuserData, PERMANENT_MENU_ITEM, NULL);
     
@@ -1110,7 +1156,7 @@
 
 static void helpCB( Widget menuItem, XtPointer clientData, XtPointer callData )
 {
-    WindowInfo *window = (WindowInfo*) clientData;
+    WindowInfo *window = WidgetToWindow(menuItem);
     enum HelpTopic topic;
     
     XtVaGetValues( menuItem, XmNuserData, &topic, 0 );
@@ -1217,13 +1263,13 @@
 {
     static char *params[1] = {"rect"};
     
-    XtCallActionProc(((WindowInfo *)clientData)->lastFocus, "paste_clipboard",
+    XtCallActionProc(WidgetToWindow(w)->lastFocus, "paste_clipboard",
     	    ((XmAnyCallbackStruct *)callData)->event, params, 1);
 }
 
 static void shiftLeftCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    XtCallActionProc(((WindowInfo *)clientData)->lastFocus,
+    XtCallActionProc(WidgetToWindow(w)->lastFocus,
     	    ((XmAnyCallbackStruct *)callData)->event->xbutton.state & ShiftMask
     	    ? "shift_left_by_tab" : "shift_left",
     	    ((XmAnyCallbackStruct *)callData)->event, NULL, 0);
@@ -1231,7 +1277,7 @@
 
 static void shiftRightCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    XtCallActionProc(((WindowInfo *)clientData)->lastFocus,
+    XtCallActionProc(WidgetToWindow(w)->lastFocus,
     	    ((XmAnyCallbackStruct *)callData)->event->xbutton.state & ShiftMask
     	    ? "shift_right_by_tab" : "shift_right",
     	    ((XmAnyCallbackStruct *)callData)->event, NULL, 0);
@@ -1239,49 +1285,49 @@
 
 static void findCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    XtCallActionProc(((WindowInfo *)clientData)->lastFocus, "find_dialog",
+    XtCallActionProc(WidgetToWindow(w)->lastFocus, "find_dialog",
     	    ((XmAnyCallbackStruct *)callData)->event,
     	    shiftKeyToDir(callData), 1);
 }
 
 static void findSameCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-     XtCallActionProc(((WindowInfo *)clientData)->lastFocus, "find_again",
+     XtCallActionProc(WidgetToWindow(w)->lastFocus, "find_again",
     	    ((XmAnyCallbackStruct *)callData)->event,
     	    shiftKeyToDir(callData), 1);
 }
 
 static void findSelCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    XtCallActionProc(((WindowInfo *)clientData)->lastFocus, "find_selection",
+    XtCallActionProc(WidgetToWindow(w)->lastFocus, "find_selection",
     	    ((XmAnyCallbackStruct *)callData)->event, 
     	    shiftKeyToDir(callData), 1);
 }
 
 static void findIncrCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    XtCallActionProc(((WindowInfo *)clientData)->lastFocus,
+    XtCallActionProc(WidgetToWindow(w)->lastFocus,
 	    "start_incremental_find", ((XmAnyCallbackStruct *)callData)->event, 
     	    shiftKeyToDir(callData), 1);
 }
 
 static void replaceCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    XtCallActionProc(((WindowInfo *)clientData)->lastFocus, "replace_dialog",
+    XtCallActionProc(WidgetToWindow(w)->lastFocus, "replace_dialog",
     	    ((XmAnyCallbackStruct *)callData)->event,
     	    shiftKeyToDir(callData), 1);
 }
 
 static void replaceSameCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    XtCallActionProc(((WindowInfo *)clientData)->lastFocus, "replace_again",
+    XtCallActionProc(WidgetToWindow(w)->lastFocus, "replace_again",
     	    ((XmAnyCallbackStruct *)callData)->event,
     	    shiftKeyToDir(callData), 1);
 }
 
 static void replaceFindSameCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    XtCallActionProc(((WindowInfo *)clientData)->lastFocus, "replace_find_same",
+    XtCallActionProc(WidgetToWindow(w)->lastFocus, "replace_find_same",
     	    ((XmAnyCallbackStruct *)callData)->event,
     	    shiftKeyToDir(callData), 1);
 }
@@ -1289,8 +1335,8 @@
 static void markCB(Widget w, XtPointer clientData, XtPointer callData)
 {
     XEvent *event = ((XmAnyCallbackStruct *)callData)->event;
-    WindowInfo *window = (WindowInfo *)clientData;
-    
+    WindowInfo *window = WidgetToWindow(w);
+
     if (event->type == KeyPress)
     	BeginMarkCommand(window);
     else
@@ -1300,7 +1346,7 @@
 static void gotoMarkCB(Widget w, XtPointer clientData, XtPointer callData)
 {
     XEvent *event = ((XmAnyCallbackStruct *)callData)->event;
-    WindowInfo *window = (WindowInfo *)clientData;
+    WindowInfo *window = WidgetToWindow(w);
     int extend = event->xbutton.state & ShiftMask;
     static char *params[1] = {"extend"};
     
@@ -1313,7 +1359,7 @@
 
 static void gotoMatchingCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    XtCallActionProc(((WindowInfo *)clientData)->lastFocus,
+    XtCallActionProc(WidgetToWindow(w)->lastFocus,
     	    ((XmAnyCallbackStruct *)callData)->event->xbutton.state & ShiftMask
     	    ? "select_to_matching" : "goto_matching",
     	    ((XmAnyCallbackStruct *)callData)->event, NULL, 0);
@@ -1327,6 +1373,10 @@
 #else
     Widget menu = w;
 #endif
+
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(menu);
+
 #ifdef SGI_CUSTOM
     if (shortPrefAskDefault(window->shell, w, "Auto Indent Off")) {
 	autoIndentOffDefCB(w, window, callData);
@@ -1345,6 +1395,10 @@
 #else
     Widget menu = w;
 #endif
+
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(menu);
+
 #ifdef SGI_CUSTOM
     if (shortPrefAskDefault(window->shell, w, "Auto Indent")) {
 	autoIndentDefCB(w, window, callData);
@@ -1363,6 +1417,10 @@
 #else
     Widget menu = w;
 #endif
+
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(menu);
+
 #ifdef SGI_CUSTOM
     if (shortPrefAskDefault(window->shell, w, "Smart Indent")) {
 	smartIndentDefCB(w, window, callData);
@@ -1380,6 +1438,10 @@
 #else
     Widget menu = w;
 #endif
+
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(menu);
+
 #ifdef SGI_CUSTOM
     if (shortPrefAskDefault(window->shell, w, "Incremental Backup")) {
 	autoSaveDefCB(w, window, callData);
@@ -1397,6 +1459,10 @@
 #else
     Widget menu = w;
 #endif
+
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(menu);
+
 #ifdef SGI_CUSTOM
     if (shortPrefAskDefault(window->shell, w, "Make Backup Copy")) {
         preserveDefCB(w, window, callData);
@@ -1416,6 +1482,10 @@
 #else
     Widget menu = w;
 #endif
+
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(menu);
+
 #ifdef SGI_CUSTOM
     if (shortPrefAskDefault(window->shell, w, "Show Matching Off")) {
 	showMatchingOffDefCB(w, window, callData);
@@ -1434,6 +1504,10 @@
 #else
     Widget menu = w;
 #endif
+
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(menu);
+
 #ifdef SGI_CUSTOM
     if (shortPrefAskDefault(window->shell, w, "Show Matching Delimiter")) {
 	showMatchingDelimitDefCB(w, window, callData);
@@ -1452,6 +1526,10 @@
 #else
     Widget menu = w;
 #endif
+
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(menu);
+
 #ifdef SGI_CUSTOM
     if (shortPrefAskDefault(window->shell, w, "Show Matching Range")) {
 	showMatchingRangeDefCB(w, window, callData);
@@ -1469,6 +1547,10 @@
 #else
     Widget menu = w;
 #endif
+
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(menu);
+
 #ifdef SGI_CUSTOM
     if (shortPrefAskDefault(window->shell, w, "Match Syntax Based")) {
 	matchSyntaxBasedDefCB(w, window, callData);
@@ -1481,7 +1563,7 @@
 
 static void fontCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    ChooseFonts(window, True);
+    ChooseFonts(WidgetToWindow(w), True);
 }
 
 static void noWrapCB(Widget w, WindowInfo *window, caddr_t callData)
@@ -1492,6 +1574,10 @@
 #else
     Widget menu = w;
 #endif
+
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(menu);
+
 #ifdef SGI_CUSTOM
     if (shortPrefAskDefault(window->shell, w, "No Wrap")) {
 	noWrapDefCB(w, window, callData);
@@ -1510,6 +1596,10 @@
 #else
     Widget menu = w;
 #endif
+
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(menu);
+
 #ifdef SGI_CUSTOM
     if (shortPrefAskDefault(window->shell, w, "Auto Newline Wrap")) {
 	newlineWrapDefCB(w, window, callData);
@@ -1528,6 +1618,10 @@
 #else
     Widget menu = w;
 #endif
+
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(menu);
+
 #ifdef SGI_CUSTOM
     if (shortPrefAskDefault(window->shell, w, "Continuous Wrap")) {
     	contWrapDefCB(w, window, callData);
@@ -1540,11 +1634,13 @@
 
 static void wrapMarginCB(Widget w, WindowInfo *window, caddr_t callData)
 {
+    window = WidgetToWindow(w);
     WrapMarginDialog(window->shell, window);
 }
 
 static void tabsCB(Widget w, WindowInfo *window, caddr_t callData)
 {
+    window = WidgetToWindow(w);
     TabsPrefDialog(window->shell, window);
 }
 
@@ -1555,6 +1651,10 @@
 #else
     Widget menu = w;
 #endif
+
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(menu);
+
 #ifdef SGI_CUSTOM
     if (shortPrefAskDefault(window->shell, w, "Statistics Line")) {
 	statsLineDefCB(w, window, callData);
@@ -1629,7 +1729,7 @@
 
 static void fontDefCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    ChooseFonts(window, False);
+    ChooseFonts(WidgetToWindow(w), False);
 }
 
 static void noWrapDefCB(Widget w, WindowInfo *window, caddr_t callData)
@@ -1673,7 +1773,7 @@
 
 static void wrapMarginDefCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    WrapMarginDialog(window->shell, NULL);
+    WrapMarginDialog(WidgetToWindow(w)->shell, NULL);
 }
 
 static void smartTagsDefCB(Widget parent, XtPointer client_data, XtPointer call_data)
@@ -1700,7 +1800,7 @@
 
 static void tabsDefCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    TabsPrefDialog(window->shell, NULL);
+    TabsPrefDialog(WidgetToWindow(w)->shell, NULL);
 }
 
 static void showMatchingOffDefCB(Widget w, WindowInfo *window, caddr_t callData)
@@ -1781,44 +1881,45 @@
 
 static void highlightingDefCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    EditHighlightPatterns(window);
+    EditHighlightPatterns(WidgetToWindow(w));
 }
 
 static void smartMacrosDefCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    EditSmartIndentMacros(window);
+    EditSmartIndentMacros(WidgetToWindow(w));
 }
 
 static void stylesDefCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    EditHighlightStyles(window->shell, NULL);
+    EditHighlightStyles(WidgetToWindow(w)->shell, NULL);
 }
 
 static void languageDefCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    EditLanguageModes(window->shell);
+    EditLanguageModes(WidgetToWindow(w)->shell);
 }
 
 #ifndef VMS
 static void shellDefCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    EditShellMenu(window);
+    EditShellMenu(WidgetToWindow(w));
 }
 #endif /* VMS */
 
 static void macroDefCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    EditMacroMenu(window);
+    EditMacroMenu(WidgetToWindow(w));
 }
 
 static void bgMenuDefCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    EditBGMenu(window);
+    EditBGMenu(WidgetToWindow(w));
 }
 
 static void customizeTitleDefCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-   EditCustomTitleFormat(window->shell, window);
+    window = WidgetToWindow(w);
+    EditCustomTitleFormat(window->shell, window);
 }
 
 static void searchDlogsDefCB(Widget w, WindowInfo *window, caddr_t callData)
@@ -2145,33 +2246,33 @@
 
 static void sizeCustomCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    RowColumnPrefDialog(window->shell);
+    RowColumnPrefDialog(WidgetToWindow(w)->shell);
     updateWindowSizeMenus();
 }
 
 static void savePrefCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    SaveNEditPrefs(window->shell, False);
+    SaveNEditPrefs(WidgetToWindow(w)->shell, False);
 }
 
 static void formFeedCB(Widget w, XtPointer clientData, XtPointer callData)
 {
     static char *params[1] = {"\f"};
     
-    XtCallActionProc(((WindowInfo *)clientData)->lastFocus, "insert_string",
+    XtCallActionProc(WidgetToWindow(w)->lastFocus, "insert_string",
     	    ((XmAnyCallbackStruct *)callData)->event, params, 1);
 }
 
 static void cancelShellCB(Widget w, WindowInfo *window, XtPointer callData)
 {
 #ifndef VMS
-    AbortShellCommand(window);
+    AbortShellCommand(WidgetToWindow(w));
 #endif
 }
 
 static void learnCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    BeginLearn(window);
+    BeginLearn(WidgetToWindow(w));
 }
 
 static void finishLearnCB(Widget w, WindowInfo *window, caddr_t callData)
@@ -2181,16 +2282,19 @@
 
 static void cancelLearnCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    CancelMacroOrLearn(window);
+    CancelMacroOrLearn(WidgetToWindow(w));
 }
 
 static void replayCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    Replay(window);
+    Replay(WidgetToWindow(w));
 }
 
 static void windowMenuCB(Widget w, WindowInfo *window, caddr_t callData)
 {
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(w);
+    
     if (!window->windowMenuValid) {
     	updateWindowMenu(window);
     	window->windowMenuValid = True;
@@ -2199,6 +2303,9 @@
 
 static void prevOpenMenuCB(Widget w, WindowInfo *window, caddr_t callData)
 {
+    /* in case of buffer mode, get the active window data */
+    window = WidgetToWindow(w);
+
     if (!window->prevOpenMenuValid) {
     	updatePrevOpenMenu(window);
     	window->prevOpenMenuValid = True;
@@ -2207,7 +2314,7 @@
 
 static void unloadTagsFileMenuCB(Widget w, WindowInfo *window, caddr_t callData)
 {
-    updateTagsFileMenu(window);
+    updateTagsFileMenu(WidgetToWindow(w));
 }
 
 /*
@@ -2215,7 +2322,9 @@
 */
 static void newAP(Widget w, XEvent *event, String *args, Cardinal *nArgs) 
 {
-    EditNewFile(NULL, False, NULL, WidgetToWindow(w)->path);
+    WindowInfo *window = WidgetToWindow(w);
+
+    EditNewFile(window, NULL, False, NULL, window->path);
     CheckCloseDim();
 }
 
@@ -2464,6 +2573,7 @@
     if (GetPrefWarnExit() && !(window == WindowList && window->next == NULL)) {
         int resp, titleLen, lineLen;
         char exitMsg[DF_MAX_MSG_LENGTH], *ptr, *title;
+	char filename[MAXPATHLEN];
         WindowInfo *win;
 
         /* List the windows being edited and make sure the
@@ -2472,7 +2582,8 @@
 	lineLen = 0;
         strcpy(ptr, "Editing: "); ptr += 9; lineLen += 9;
         for (win=WindowList; win!=NULL; win=win->next) {
-            XtVaGetValues(win->shell, XmNiconName, &title, NULL);
+    	    sprintf(filename, "%s%s", win->filename, win->fileChanged? "*": "");
+	    title = filename;
             titleLen = strlen(title);
             if (ptr - exitMsg + titleLen + 30 >= DF_MAX_MSG_LENGTH) {
         	strcpy(ptr, "..."); ptr += 3;
@@ -2858,6 +2969,57 @@
     XtSetSensitive(window->closePaneItem, window->nPanes > 0);
 }
 
+static void detachBufferDialogAP(Widget w, XEvent *event, String *args,
+	Cardinal *nArgs)
+{
+    WindowInfo *window = WidgetToWindow(w);
+    int resp;
+    
+    if (NumOfBufferInWindow(window) < 2)
+    	return;
+    
+    resp = DialogF(DF_QUES, window->shell, 2, "Detach %s?", 
+	    "Detach", "Cancel", window->filename);
+
+    if (resp == 1)
+    	DetachBuffer(window);
+}
+
+static void detachBufferAP(Widget w, XEvent *event, String *args,
+	Cardinal *nArgs)
+{
+    WindowInfo *window = WidgetToWindow(w);
+    
+    if (NumOfBufferInWindow(window) < 2)
+    	return;
+    
+    DetachBuffer(window);
+}
+
+static void attachBufferDialogAP(Widget w, XEvent *event, String *args,
+	Cardinal *nArgs)
+{
+    AttachBufferDialog(w);
+}
+
+static void nextBufferAP(Widget w, XEvent *event, String *args,
+	Cardinal *nArgs)
+{
+    NextBuffer(WidgetToWindow(w));    
+}
+
+static void prevBufferAP(Widget w, XEvent *event, String *args,
+	Cardinal *nArgs)
+{
+    PreviousBuffer(WidgetToWindow(w));    
+}
+
+static void toggleBufferAP(Widget w, XEvent *event, String *args,
+	Cardinal *nArgs)
+{    
+    ToggleBuffer(WidgetToWindow(w));    
+}
+
 static void capitalizeAP(Widget w, XEvent *event, String *args, Cardinal *nArgs)
 {
     WindowInfo *window = WidgetToWindow(w);
@@ -3169,7 +3331,7 @@
         }
     }
     if (window != NULL) {
-        RaiseShellWindow(window->shell);
+	RaiseBufferWindow(window);
     }
     else {
         XBell(TheDisplay, 0);
@@ -3821,13 +3983,23 @@
 #ifdef SGI_CUSTOM
     title = title + SGI_WINDOW_TITLE_LEN;
 #endif
-    strcpy(fullTitle, title);
+
+    /* in buffer mode, put brackets around the filename
+       of buffers that don't belong to this window */
+    sprintf(fullTitle, "%s%s%s",
+    	    GetPrefWindowBufferMode() && 
+	            thisWindow->shell != window->shell? "[ " : "",
+    	    window->filename, 
+	    window->fileChanged? "*" : "");
+
     if (thisWindow->showPathInWindowsMenu && window->filenameSet)
     {
        strcat(fullTitle, " - ");
        strcat(fullTitle, window->path);
     }
     
+    strcat(fullTitle, GetPrefWindowBufferMode() && 
+            thisWindow->shell != window->shell? " ]" : "");
     return(fullTitle);
 }             
 
@@ -3837,18 +4009,16 @@
 */
 static void updateWindowMenu(const WindowInfo *window)
 {
-    WindowInfo *w;
     WidgetList items;
     Cardinal nItems;
-    int i, n, nWindows, windowIndex;
+    int n, nWindows, windowIndex;
     WindowInfo **windows;
     
-    /* Make a sorted list of windows */
-    for (w=WindowList, nWindows=0; w!=NULL; w=w->next, nWindows++);
-    windows = (WindowInfo **)XtMalloc(sizeof(WindowInfo *) * nWindows);
-    for (w=WindowList, i=0; w!=NULL; w=w->next, i++)
-    	windows[i] = w;
-    qsort(windows, nWindows, sizeof(WindowInfo *), compareWindowNames);
+    if (!IsTopBuffer(window))
+    	return;
+	
+    nWindows = NWindows();
+    windows = MakeSortedWindowArray();
     
     /* While it is not possible on some systems (ibm at least) to substitute
        a new menu pane, it is possible to substitute menu items, as long as
@@ -4264,8 +4434,8 @@
 }
 
 static void raiseCB(Widget w, WindowInfo *window, caddr_t callData)
-{
-    RaiseShellWindow(window->shell);
+{    
+    RaiseBufferWindow(window);
 }
 
 static void openPrevCB(Widget w, char *name, caddr_t callData)
@@ -4338,7 +4508,41 @@
     return rc;
 }
 
+static int compareWindowShell(const void *windowA, const void *windowB)
+{
+    const WindowInfo *a = *((WindowInfo**)windowA);
+    const WindowInfo *b = *((WindowInfo**)windowB);
+
+    return a->shell > b->shell;
+}
+
 /*
+** create & return a sorted list of windows
+** Windows are first sort by their filename then,
+** if in buffer mode, grouped by their shell windows
+**
+** Note: caller must XtFree the returned window list.
+*/
+WindowInfo **MakeSortedWindowArray(void)
+{
+    WindowInfo *w, **windows;
+    int i, nWindows;
+    
+    /* Make a sorted list of windows */
+    for (w=WindowList, nWindows=0; w!=NULL; w=w->next, nWindows++);
+    windows = (WindowInfo **)XtMalloc(sizeof(WindowInfo *) * nWindows);
+    for (w=WindowList, i=0; w!=NULL; w=w->next, i++)
+    	windows[i] = w;
+    qsort(windows, nWindows, sizeof(WindowInfo *), compareWindowNames);
+    
+    /* group the buffers together by their shell window */
+    if (GetPrefWindowBufferMode())
+        qsort(windows, nWindows, sizeof(WindowInfo *), compareWindowShell);
+
+    return windows;
+}
+
+/*
 ** Create popup for right button programmable menu
 */
 Widget CreateBGMenu(WindowInfo *window)
@@ -4407,6 +4611,8 @@
     WindowInfo *win;
     int i, state = XmToggleButtonGetState(w);
     Widget parent;
+
+    window = WidgetToWindow(w);
 
     /* Set the preference */
     SetPrefShortMenus(state);
Index: source/menu.h
===================================================================
retrieving revision 1.5
diff -u -r1.5 menu.h
--- nedit-5.3/source/menu.h	2001/02/26 23:38:03	1.5
+++ nedit-5.3/source/menu.h	2002/08/06 02:07:55
@@ -12,3 +12,4 @@
 void ReadNEditDB(void);
 Widget CreateBGMenu(WindowInfo *window);
 void AddBGMenuAction(Widget widget);
+WindowInfo **MakeSortedWindowArray(void);
Index: source/nedit.c
===================================================================
retrieving revision 1.30.2.2
diff -u -r1.30.2.2 nedit.c
--- nedit-5.3/source/nedit.c	2002/03/18 23:15:38	1.30.2.2
+++ nedit-5.3/source/nedit.c	2002/08/06 02:07:55
@@ -118,6 +118,8 @@
     "nedit*helpText.background: #cccccc",
     "nedit*helpText.foreground: black",
     "nedit*helpText.selectBackground: #b3b3b3",
+    "nedit*toolTip.background: LemonChiffon1",
+    "nedit*toolTip.foreground: black",
     "nedit*statsLine.background: #b3b3b3",
     "nedit*statsLine.fontList: " NEDIT_DEFAULT_FONT,
     "nedit*helpText.font: " NEDIT_FIXED_FONT,
@@ -261,6 +263,12 @@
     "*windowsMenu.splitWindow.acceleratorText: Ctrl+2",
     "*windowsMenu.closePane.accelerator: Ctrl<Key>1",
     "*windowsMenu.closePane.acceleratorText: Ctrl+1",
+    "*windowsMenu.nextBuffer.accelerator: Ctrl Alt<Key>N",
+    "*windowsMenu.nextBuffer.acceleratorText: Ctrl+Alt+N",
+    "*windowsMenu.prevBuffer.accelerator: Ctrl Alt<Key>P",
+    "*windowsMenu.prevBuffer.acceleratorText: Ctrl+Alt+P",
+    "*windowsMenu.toggleBuffer.accelerator: Ctrl Alt<Key>O",
+    "*windowsMenu.toggleBuffer.acceleratorText: Ctrl+Alt+O",
     "*helpMenu.mnemonic: H",
     "nedit.helpForm.sw.helpText*translations: #override\
 <Key>Tab:help-focus-buttons()\\n\
@@ -286,7 +294,7 @@
 	      [-geometry geometry] [-iconic] [-noiconic] [-svrname name]\n\
 	      [-display [host]:server[.screen] [-xrm resourcestring]\n\
 	      [-import file] [-background color] [-foreground color]\n\
-	      [-V|-version] [--]\n\
+	      [-V|-version] [-buffers] [-nobuffers] [--]\n\
 	      [file...]\n";
 #else
 "";
@@ -510,7 +518,7 @@
     
     /* If no file to edit was specified, open a window to edit "Untitled" */
     if (!fileSpecified) {
-    	EditNewFile(geometry, iconic, langMode, NULL);
+    	EditNewFile(NULL, geometry, iconic, langMode, NULL);
 	ReadMacroInitFile(WindowList);
 	if (toDoCommand != NULL)
 	    DoMacro(WindowList, toDoCommand, "-do macro");
Index: source/nedit.h
===================================================================
retrieving revision 1.23
diff -u -r1.23 nedit.h
--- nedit-5.3/source/nedit.h	2002/03/11 22:05:11	1.23
+++ nedit-5.3/source/nedit.h	2002/08/06 02:07:55
@@ -130,6 +130,8 @@
 typedef struct _WindowInfo {
     struct _WindowInfo *next;
     Widget	shell;			/* application shell of window */
+    Widget	mainWin;		/* main window of shell */
+    Widget	textForm;		/* form for text areas */
     Widget	splitPane;		/* paned win. for splitting text area */
     Widget	textArea;		/* the first text editing area widget */
     Widget	textPanes[MAX_PANES];	/* additional ones created on demand */
@@ -141,6 +143,7 @@
     Widget  	iSearchCaseToggle;
     Widget  	iSearchRevToggle;
     Widget	menuBar;    	    	/* the main menu bar */
+    Widget	bufferTabBar;		/* toolbar for tabbed window */
     Widget	replaceDlog;		/* replace dialog */
     Widget	replaceText;		/* replace dialog settable widgets... */
     Widget	replaceWithText;
@@ -270,6 +273,8 @@
     Widget	repeatItem;
     Widget	splitWindowItem;
     Widget	closePaneItem;
+    Widget	detachBufferItem;
+    Widget	attachBufferItem;
     Widget  	bgMenuUndoItem;
     Widget  	bgMenuRedoItem;
 #ifdef SGI_CUSTOM
Index: source/preferences.c
===================================================================
retrieving revision 1.49.2.5
diff -u -r1.49.2.5 preferences.c
--- nedit-5.3/source/preferences.c	2002/05/16 07:53:09	1.49.2.5
+++ nedit-5.3/source/preferences.c	2002/08/06 02:07:55
@@ -184,6 +184,7 @@
 
 /* Repository for simple preferences settings */
 static struct prefData {
+    int windowBufferMode;   	/* run nedit in vi-like buffer mode */
     int wrapStyle;		/* what kind of wrapping to do */
     int wrapMargin;		/* 0=wrap at window width, other=wrap margin */
     int autoIndent;		/* style for auto-indent */
@@ -195,6 +196,8 @@
     int searchWraps;	/* whether to attempt search again if reach bof or eof */
     int statsLine;		/* whether to show the statistics line */
     int iSearchLine;	    	/* whether to show the incremental search line*/
+    int bufferTabs;	    	/* whether to show the windows/buffers tabs */
+    int toolTips;	    	/* whether to show the tooltips */
     int lineNums;   	    	/* whether to show line numbers */
     int pathInWindowsMenu;   	/* whether to show path in windows menu */
     int warnFileMods;	    	/* " warn user if files externally modified */
@@ -661,6 +664,8 @@
     	&PrefData.autoIndent, AutoIndentTypes, True},
     {"autoSave", "AutoSave", PREF_BOOLEAN, "True",
     	&PrefData.autoSave, NULL, True},
+    {"windowBufferMode", "WindowBufferMode", PREF_BOOLEAN, "False",
+    	&PrefData.windowBufferMode, NULL, False},
     {"saveOldVersion", "SaveOldVersion", PREF_BOOLEAN, "False",
     	&PrefData.saveOldVersion, NULL, True},
     {"showMatching", "ShowMatching", PREF_ENUM, "Delimiter",
@@ -694,6 +699,10 @@
     	&PrefData.statsLine, NULL, True},
     {"iSearchLine", "ISearchLine", PREF_BOOLEAN, "False",
     	&PrefData.iSearchLine, NULL, True},
+    {"bufferTabs", "BufferTabs", PREF_BOOLEAN, "True",
+    	&PrefData.bufferTabs, NULL, False},
+    {"toolTips", "ToolTips", PREF_BOOLEAN, "True",
+    	&PrefData.toolTips, NULL, False},
     {"lineNumbers", "LineNumbers", PREF_BOOLEAN, "False",
     	&PrefData.lineNums, NULL, True},
     {"pathInWindowsMenu", "PathInWindowsMenu", PREF_BOOLEAN, "True",
@@ -835,6 +844,8 @@
     {"-noautoindent", ".autoIndent", XrmoptionNoArg, (caddr_t)"False"},
     {"-autosave", ".autoSave", XrmoptionNoArg, (caddr_t)"True"},
     {"-noautosave", ".autoSave", XrmoptionNoArg, (caddr_t)"False"},
+    {"-buffers", ".windowBufferMode", XrmoptionNoArg, (caddr_t)"True"},
+    {"-nobuffers", ".windowBufferMode", XrmoptionNoArg, (caddr_t)"False"},
     {"-rows", ".textRows", XrmoptionSepArg, (caddr_t)NULL},
     {"-columns", ".textCols", XrmoptionSepArg, (caddr_t)NULL},
     {"-tabs", ".tabDistance", XrmoptionSepArg, (caddr_t)NULL},
@@ -1158,6 +1169,16 @@
 	}
 }
 
+void SetPrefWindowBufferMode(int state)
+{
+    setIntPref(&PrefData.windowBufferMode, state);
+}
+
+int GetPrefWindowBufferMode(void)
+{
+    return PrefData.windowBufferMode;
+}
+
 void SetPrefWrap(int state)
 {
     setIntPref(&PrefData.wrapStyle, state);
@@ -1306,6 +1327,26 @@
     return PrefData.iSearchLine;
 }
 
+void SetPrefBufferTabs(int state)
+{
+    setIntPref(&PrefData.bufferTabs, state);
+}
+
+int GetPrefBufferTabs(void)
+{
+    return PrefData.bufferTabs && GetPrefWindowBufferMode();
+}
+
+void SetPrefToolTips(int state)
+{
+    setIntPref(&PrefData.toolTips, state);
+}
+
+int GetPrefToolTips(void)
+{
+    return PrefData.toolTips && GetPrefWindowBufferMode();
+}
+
 void SetPrefLineNums(int state)
 {
     setIntPref(&PrefData.lineNums, state);
@@ -4353,7 +4394,7 @@
 
 static void setLangModeCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    WindowInfo *window = (WindowInfo *)clientData;
+    WindowInfo *window = WidgetToWindow(w);
     char *params[1];
     void *mode;
     
Index: source/preferences.h
===================================================================
retrieving revision 1.20.2.1
diff -u -r1.20.2.1 preferences.h
--- nedit-5.3/source/preferences.h	2002/04/15 10:46:35	1.20.2.1
+++ nedit-5.3/source/preferences.h	2002/08/06 02:07:55
@@ -33,6 +33,10 @@
 int GetPrefStatsLine(void);
 void SetPrefISearchLine(int state);
 int GetPrefISearchLine(void);
+void SetPrefBufferTabs(int state);
+int GetPrefBufferTabs(void);
+void SetPrefToolTips(int state);
+int GetPrefToolTips(void);
 void SetPrefLineNums(int state);
 int GetPrefLineNums(void);
 void SetPrefShowPathInWindowsMenu(int state);
@@ -145,3 +149,5 @@
 void SetPrefTitleFormat(const char* format);
 const char* GetPrefTitleFormat(void);
 int GetPrefOverrideVirtKeyBindings(void);
+void SetPrefWindowBufferMode(int state);
+int GetPrefWindowBufferMode(void);
Index: source/search.c
===================================================================
retrieving revision 1.43
diff -u -r1.43 search.c
--- nedit-5.3/source/search.c	2002/03/11 22:05:11	1.43
+++ nedit-5.3/source/search.c	2002/08/06 02:07:55
@@ -94,9 +94,9 @@
 static void setTextField(WindowInfo* window, Time time, Widget textField);
 static void getSelectionCB(Widget w, SelectionInfo *selectionInfo, Atom *selection,
 	Atom *type, char *value, int *length, int *format);
-static void createReplaceDlog(Widget parent, WindowInfo *window);
-static void createFindDlog(Widget parent, WindowInfo *window);
-static void createReplaceMultiFileDlog(Widget parent, WindowInfo *window);
+void createReplaceDlog(Widget parent, WindowInfo *window);
+void createFindDlog(Widget parent, WindowInfo *window);
+void createReplaceMultiFileDlog(Widget parent, WindowInfo *window);
 static void fFocusCB(Widget w, WindowInfo *window, caddr_t *callData);
 static void rFocusCB(Widget w, WindowInfo *window, caddr_t *callData);
 static void rKeepCB(Widget w, WindowInfo *window, caddr_t *callData);
@@ -154,7 +154,7 @@
 static int countWindows(void);
 static int countWritableWindows(void);
 static void collectWritableWindows(WindowInfo* window);
-static void freeWritableWindowsCB(Widget* w, WindowInfo* window,
+static void freeWritableWindowsCB(Widget w, WindowInfo* window,
                                   XmAnyCallbackStruct *callData);
 static void checkMultiReplaceListForDoomedW(WindowInfo* window, 
                                                      WindowInfo* doomedWindow);
@@ -623,7 +623,7 @@
           checkMultiReplaceListForDoomedW(w, doomedWindow);
 }
 
-static void createReplaceDlog(Widget parent, WindowInfo *window)
+void createReplaceDlog(Widget parent, WindowInfo *window)
 {
     Arg    	args[50];
     int    	argcnt, defaultBtnOffset;
@@ -1026,7 +1026,7 @@
     XtSetArg(args[argcnt], XmNtopOffset, defaultBtnOffset); argcnt++;
     XtSetArg(args[argcnt], XmNbottomOffset, defaultBtnOffset); argcnt++;
     findBtn = XmCreatePushButton(btnForm, "find", args, argcnt);
-    XtAddCallback(findBtn, XmNactivateCallback, (XtCallbackProc)rFindCB,  window);
+    XtAddCallback(findBtn, XmNactivateCallback, (XtCallbackProc)rFindCB, window);
     XmStringFree(st1);
     XtManageChild(findBtn);
  
@@ -1122,7 +1122,7 @@
 #endif
 }
 
-static void createFindDlog(Widget parent, WindowInfo *window)
+void createFindDlog(Widget parent, WindowInfo *window)
 {
     Arg    	args[50];
     int    	argcnt, defaultBtnOffset;
@@ -1334,7 +1334,7 @@
     window->findSearchTypeBox = searchTypeBox;
 }
 
-static void createReplaceMultiFileDlog(Widget parent, WindowInfo *window) 
+void createReplaceMultiFileDlog(Widget parent, WindowInfo *window) 
 {
     Arg		args[50];
     int		argcnt, defaultBtnOffset;
@@ -1616,10 +1616,12 @@
 */
 static void fFocusCB(Widget w, WindowInfo *window, caddr_t *callData) 
 {
+    window = WidgetToWindow(w);
     SET_ONE_RSRC(window->findDlog, XmNdefaultButton, window->findBtn);
 }
 static void rFocusCB(Widget w, WindowInfo *window, caddr_t *callData) 
 {
+    window = WidgetToWindow(w);
     SET_ONE_RSRC(window->replaceDlog, XmNdefaultButton, window->replaceBtn);
 }
 
@@ -1628,6 +1630,8 @@
 {
     char title[MAXPATHLEN + 19];
 
+    window = WidgetToWindow(w);
+
     if (XmToggleButtonGetState(w)) {
     	sprintf(title, "Replace/Find (in %s)", window->filename);
     	XtVaSetValues(XtParent(window->replaceDlog), XmNtitle, title, NULL);
@@ -1638,6 +1642,8 @@
 {
     char title[MAXPATHLEN + 11];
 
+    window = WidgetToWindow(w);
+
     if (XmToggleButtonGetState(w)) {
     	sprintf(title, "Find (in %s)", window->filename);
     	XtVaSetValues(XtParent(window->findDlog), XmNtitle, title, NULL);
@@ -1652,6 +1658,8 @@
     int direction, searchType;
     char *params[5];
     
+    window = WidgetToWindow(w);
+
     /* Validate and fetch the find and replace strings from the dialog */
     if (!getReplaceDlogInfo(window, &direction, searchString, replaceString,
     	    &searchType))
@@ -1680,6 +1688,8 @@
     int direction, searchType;
     char *params[3];
     
+    window = WidgetToWindow(w);
+
     /* Validate and fetch the find and replace strings from the dialog */
     if (!getReplaceDlogInfo(window, &direction, searchString, replaceString,
     	    &searchType))
@@ -1703,16 +1713,18 @@
 static void replaceMultiFileCB(Widget w, WindowInfo *window,
 				   XmAnyCallbackStruct *callData) 
 {
-   DoReplaceMultiFileDlog(window);
+    window = WidgetToWindow(w);
+    DoReplaceMultiFileDlog(window);
 }
 
 /*
 ** Callback that frees the list of windows the multi-file replace
 ** dialog is unmapped.
 **/
-static void freeWritableWindowsCB(Widget* w, WindowInfo* window,
+static void freeWritableWindowsCB(Widget w, WindowInfo* window,
                                   XmAnyCallbackStruct *callData)
 {
+    window = WidgetToWindow(w);
     XtFree((XtPointer)window->writableWindows);
     window->writableWindows = NULL;
     window->nWritableWindows = 0;
@@ -1803,6 +1815,7 @@
     WindowInfo 	*writableWin;
     Bool 	replaceFailed, noWritableLeft;
 
+    window = WidgetToWindow(w);
     nSelected = 0;
     for (i=0; i<window->nWritableWindows; ++i)
        if (XmListPosSelected(window->replaceMultiFileList, i+1))
@@ -1856,20 +1869,27 @@
 	   (possible due to Lesstif modal dialog bug), we just skip the 
 	   window. */
 	    if (!IS_ANY_LOCKED(writableWin->lockReasons)) {
+		WindowInfo *activeBuffer = WidgetToWindow(writableWin->lastFocus);
+		
 		noWritableLeft = False;
 		writableWin->multiFileReplSelected = True;
 		writableWin->multiFileBusy = True; /* Avoid multi-beep/dialog */
 		writableWin->replaceFailed = False;
+		RaiseBuffer(writableWin);
 		XtCallActionProc(writableWin->lastFocus, "replace_all",
 		    callData->event, params, 3);
 		writableWin->multiFileBusy = False;
-		if (!writableWin->replaceFailed) replaceFailed = False;
+		if (!writableWin->replaceFailed)
+		    replaceFailed = False;
+		RaiseBuffer(activeBuffer);
 	    }
 	} else {
 	    writableWin->multiFileReplSelected = False;
 	}
     }                          
-
+    
+    RaiseBuffer(window);
+    
     if (!XmToggleButtonGetState(window->replaceKeepBtn)) {
        /* Pop down both replace dialogs. */
        unmanageReplaceDialogs(window);
@@ -1897,6 +1917,8 @@
 
 static void rMultiFileCancelCB(Widget w, WindowInfo *window, caddr_t callData) 
 {
+    window = WidgetToWindow(w);
+
     /* Set the initial focus of the dialog back to the search string	*/
     resetReplaceTabGroup(window);
 
@@ -1909,7 +1931,10 @@
 {
     int i;
     char policy;
-    Widget list = window->replaceMultiFileList;
+    Widget list;
+    
+    window = WidgetToWindow(w);
+    list = window->replaceMultiFileList;
     
     /*
      * If the list is in extended selection mode, we can't select more 
@@ -1937,13 +1962,15 @@
 static void rMultiFileDeselectAllCB(Widget w, WindowInfo *window,  
    XmAnyCallbackStruct *callData) 
 {
-   XmListDeselectAllItems(window->replaceMultiFileList);
+    window = WidgetToWindow(w);
+    XmListDeselectAllItems(window->replaceMultiFileList);
 }
 
 static void rMultiFilePathCB(Widget w, WindowInfo *window,  
    XmAnyCallbackStruct *callData) 
 {
-   uploadFileListItems(window, True);  /* Replace */
+    window = WidgetToWindow(w);
+    uploadFileListItems(window, True);  /* Replace */
 }
 
 /*
@@ -2091,6 +2118,8 @@
     int direction, searchType;
     char *params[3];
     
+    window = WidgetToWindow(w);
+
     /* Validate and fetch the find and replace strings from the dialog */
     if (!getReplaceDlogInfo(window, &direction, searchString, replaceString,
     	    &searchType))
@@ -2113,6 +2142,8 @@
 
 static void rCancelCB(Widget w, WindowInfo *window, caddr_t callData) 
 {
+    window = WidgetToWindow(w);
+
     /* Set the initial focus of the dialog back to the search string	*/
     resetReplaceTabGroup(window);
 
@@ -2122,6 +2153,8 @@
 
 static void fCancelCB(Widget w, WindowInfo *window, caddr_t callData) 
 {
+    window = WidgetToWindow(w);
+
     /* Set the initial focus of the dialog back to the search string	*/
     resetFindTabGroup(window);
     
@@ -2135,6 +2168,8 @@
     int direction, searchType;
     char *params[4];
     
+    window = WidgetToWindow(w);
+
     /* Validate and fetch the find and replace strings from the dialog */
     if (!getReplaceDlogInfo(window, &direction, searchString, replaceString,
     	    &searchType))
@@ -2170,6 +2205,8 @@
     int direction, searchType;
     char *params[4];
     
+    window = WidgetToWindow(w);
+
     /* Validate and fetch the find and replace strings from the dialog */
     if (!getReplaceDlogInfo(window, &direction, searchString, replaceString,
             &searchType))
@@ -2247,6 +2284,7 @@
 static void rScopeWinCB(Widget w, WindowInfo *window, 
     XmAnyCallbackStruct *callData)
 {
+    window = WidgetToWindow(w);
     if (XmToggleButtonGetState(window->replaceScopeWinToggle)) {
 	window->replaceScope = REPL_SCOPE_WIN;
         UpdateReplaceActionButtons(window);
@@ -2256,6 +2294,7 @@
 static void rScopeSelCB(Widget w, WindowInfo *window, 
     XmAnyCallbackStruct *callData)
 {
+    window = WidgetToWindow(w);
     if (XmToggleButtonGetState(window->replaceScopeSelToggle)) {
 	window->replaceScope = REPL_SCOPE_SEL;
         UpdateReplaceActionButtons(window);
@@ -2265,6 +2304,7 @@
 static void rScopeMultiCB(Widget w, WindowInfo *window, 
     XmAnyCallbackStruct *callData)
 {
+    window = WidgetToWindow(w);
     if (XmToggleButtonGetState(window->replaceScopeMultiToggle)) {
 	window->replaceScope = REPL_SCOPE_MULTI;
         UpdateReplaceActionButtons(window);
@@ -2278,6 +2318,7 @@
 static void replaceAllScopeCB(Widget w, WindowInfo *window, 
     XmAnyCallbackStruct *callData)
 {
+    window = WidgetToWindow(w);
     switch(window->replaceScope) {
 	case REPL_SCOPE_WIN:
            replaceAllCB(w, window, callData);
@@ -2302,16 +2343,20 @@
 
 static void rFindTextValueChangedCB(Widget w, WindowInfo *window, XKeyEvent *event)
 {
+    window = WidgetToWindow(w);
     UpdateReplaceActionButtons(window);
 }
 
 static void rFindArrowKeyCB(Widget w, WindowInfo *window, XKeyEvent *event)
 {
     KeySym keysym = XLookupKeysym(event, 0);
-    int index = window->rHistIndex;
+    int index;
     char *searchStr, *replaceStr;
     int searchType;
     
+    window = WidgetToWindow(w);
+    index = window->rHistIndex;
+    
     /* only process up and down arrow keys */
     if (keysym != XK_Up && keysym != XK_Down)
     	return;
@@ -2325,6 +2370,8 @@
     	return;
     }
     
+    window = WidgetToWindow(w);
+
     /* determine the strings and button settings to use */
     if (index == 0) {
     	searchStr = "";
@@ -2354,8 +2401,11 @@
 static void replaceArrowKeyCB(Widget w, WindowInfo *window, XKeyEvent *event)
 {
     KeySym keysym = XLookupKeysym(event, 0);
-    int index = window->rHistIndex;
+    int index;
     
+    window = WidgetToWindow(w);
+    index = window->rHistIndex;
+
     /* only process up and down arrow keys */
     if (keysym != XK_Up && keysym != XK_Down)
     	return;
@@ -2369,6 +2419,8 @@
     	return;
     }
     
+    window = WidgetToWindow(w);
+
     /* change only the replace field information */
     if (index == 0)
     	XmTextSetString(window->replaceWithText, "");
@@ -2386,16 +2438,20 @@
 
 static void findTextValueChangedCB(Widget w, WindowInfo *window, XKeyEvent *event)
 {
-   fUpdateActionButtons(window);
+    window = WidgetToWindow(w);
+    fUpdateActionButtons(window);
 }
 
 static void findArrowKeyCB(Widget w, WindowInfo *window, XKeyEvent *event)
 {
     KeySym keysym = XLookupKeysym(event, 0);
-    int index = window->fHistIndex;
+    int index;
     char *searchStr;
     int searchType;
     
+    window = WidgetToWindow(w);
+    index = window->fHistIndex;
+    
     /* only process up and down arrow keys */
     if (keysym != XK_Up && keysym != XK_Down)
     	return;
@@ -2409,6 +2465,7 @@
     	return;
     }
     
+
     /* determine the strings and button settings to use */
     if (index == 0) {
     	searchStr = "";
@@ -2437,6 +2494,8 @@
     int direction, searchType;
     char *params[4];
     
+    window = WidgetToWindow(w);
+
     /* fetch find string, direction and type from the dialog */
     if (!getFindDlogInfo(window, &direction, searchString, &searchType))
     	return;
@@ -2686,6 +2745,8 @@
     int searchType;
     char searchString[SEARCHMAX+1];
     
+    window = WidgetToWindow(w);
+
     /* skip if we can't get the selection data or it's too long */
     if (*type == XT_CONVERT_FAIL || value == NULL) {
     	if (GetPrefSearchDlogs())
@@ -2916,7 +2977,9 @@
     char *params[4];
     char *searchString;
     int searchType, direction;
-   
+
+    window = WidgetToWindow(w);
+       
     /* Fetch the string, search type and direction from the incremental
        search bar widgets at the top of the window */
     searchString = XmTextGetString(window->iSearchText);
@@ -2959,6 +3022,8 @@
     char *searchString;
     int searchType, direction, nParams;
    
+    window = WidgetToWindow(w);
+    
     /* Fetch the string, search type and direction from the incremental
        search bar widgets at the top of the window */
     searchString = XmTextGetString(window->iSearchText);
@@ -4558,7 +4623,7 @@
 */
 static void findRegExpToggleCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    WindowInfo * window = (WindowInfo *) clientData;
+    WindowInfo * window = WidgetToWindow(w);
     int searchRegex = XmToggleButtonGetState(w);
     int searchCaseSense = XmToggleButtonGetState(window->findCaseToggle);
     
@@ -4580,7 +4645,7 @@
 
 static void replaceRegExpToggleCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    WindowInfo * window = (WindowInfo *) clientData;
+    WindowInfo * window = WidgetToWindow(w);
     int searchRegex = XmToggleButtonGetState(w);
     int searchCaseSense = XmToggleButtonGetState(window->replaceCaseToggle);
     
@@ -4602,7 +4667,7 @@
 
 static void iSearchRegExpToggleCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    WindowInfo * window = (WindowInfo *) clientData;
+    WindowInfo * window = WidgetToWindow(w);
     int searchRegex = XmToggleButtonGetState(w);
     int searchCaseSense = XmToggleButtonGetState(window->iSearchCaseToggle);
     
@@ -4622,7 +4687,7 @@
 }
 static void findCaseToggleCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    WindowInfo * window = (WindowInfo *) clientData;
+    WindowInfo * window = WidgetToWindow(w);
     int searchCaseSense = XmToggleButtonGetState(w);
     
     /* Save the state of the Case Sensitive button 
@@ -4635,7 +4700,7 @@
 
 static void replaceCaseToggleCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    WindowInfo * window = (WindowInfo *) clientData;
+    WindowInfo * window = WidgetToWindow(w);
     int searchCaseSense = XmToggleButtonGetState(w);
     
     /* Save the state of the Case Sensitive button 
@@ -4648,7 +4713,7 @@
 
 static void iSearchCaseToggleCB(Widget w, XtPointer clientData, XtPointer callData)
 {
-    WindowInfo * window = (WindowInfo *) clientData;
+    WindowInfo * window = WidgetToWindow(w);
     int searchCaseSense = XmToggleButtonGetState(w);
     
     /* Save the state of the Case Sensitive button 
Index: source/selection.c
===================================================================
retrieving revision 1.18
diff -u -r1.18 selection.c
--- nedit-5.3/source/selection.c	2001/12/17 16:28:46	1.18
+++ nedit-5.3/source/selection.c	2002/08/06 02:07:55
@@ -312,7 +312,7 @@
         XBell(TheDisplay, 0);
 	return;
     }	
-    EditExistingFile(WindowList, filename, pathname, 0, NULL, False, NULL);
+    EditExistingFile(window, filename, pathname, 0, NULL, False, NULL);
 #elif defined(USE_MOTIF_GLOB)
     { char **nameList = NULL;
       int i, nFiles = 0, maxFiles = 30;
@@ -328,7 +328,7 @@
 	      XBell(TheDisplay, 0);
 	  }
         else {
-    	      EditExistingFile(WindowList, filename, pathname, 0, NULL, 
+    	      EditExistingFile(window, filename, pathname, 0, NULL, 
 	                       False, NULL);
 	  }
       }
@@ -346,7 +346,7 @@
 	  if (ParseFilename(globbuf.gl_pathv[i], filename, pathname) != 0)
 	      XBell(TheDisplay, 0);
 	  else
-    	      EditExistingFile(WindowList, filename, pathname, 0, NULL,
+    	      EditExistingFile(window, filename, pathname, 0, NULL,
 	                       False, NULL);
       }
       globfree(&globbuf);
Index: source/server.c
===================================================================
retrieving revision 1.13.2.1
diff -u -r1.13.2.1 server.c
--- nedit-5.3/source/server.c	2002/04/16 17:29:12	1.13.2.1
+++ nedit-5.3/source/server.c	2002/08/06 02:07:55
@@ -182,11 +182,14 @@
     	    if (!window->filenameSet && !window->fileChanged)
     	    	break;
     	if (window == NULL) {
-    	    EditNewFile(NULL, False, NULL, NULL);
+    	    EditNewFile(WindowList, NULL, False, NULL, NULL);
     	    CheckCloseDim();
-    	} else
+    	} 
+	else {
     	    XMapRaised(TheDisplay, XtWindow(window->shell));
-    	return;
+	    RaiseBufferWindow(window);
+    	}
+	return;
     }
 
     /*
@@ -255,8 +258,11 @@
 	/* Do the actions requested (note DoMacro is last, since the do
 	   command can do anything, including closing the window!) */
 	if (window != NULL) {
-	    if (!iconicFlag)
+	    if (!iconicFlag) {
 	    	XMapRaised(TheDisplay, XtWindow(window->shell));
+		RaiseBufferWindow(window);
+	    }
+	    
 	    if (lineNum > 0)
 		SelectNumberedLine(window, lineNum);
 	    if (*doCommand != '\0')
Index: source/shell.c
===================================================================
retrieving revision 1.18.2.3
diff -u -r1.18.2.3 shell.c
--- nedit-5.3/source/shell.c	2002/05/02 00:01:55	1.18.2.3
+++ nedit-5.3/source/shell.c	2002/08/06 02:07:55
@@ -371,7 +371,7 @@
 	flags |= OUTPUT_TO_DIALOG;
     	left = right = 0;
     } else if (output == TO_NEW_WINDOW) {
-    	EditNewFile(NULL, False, NULL, window->path);
+    	EditNewFile(inWindow, NULL, False, NULL, window->path);
     	outWidget = WindowList->textArea;
 	inWindow = WindowList;
     	left = right = 0;
Index: source/smartIndent.c
===================================================================
retrieving revision 1.13
diff -u -r1.13 smartIndent.c
--- nedit-5.3/source/smartIndent.c	2001/08/23 14:59:14	1.13
+++ nedit-5.3/source/smartIndent.c	2002/08/06 02:07:55
@@ -779,7 +779,7 @@
 */
 void SmartIndentCB(Widget w, XtPointer clientData, XtPointer callData) 
 {
-    WindowInfo *window = (WindowInfo *)clientData;
+    WindowInfo *window = WidgetToWindow(w);
     smartIndentCBStruct *cbInfo = (smartIndentCBStruct *)callData;
     
     if (window->smartIndentData == NULL)
Index: source/tags.c
===================================================================
retrieving revision 1.32.2.2
diff -u -r1.32.2.2 tags.c
--- nedit-5.3/source/tags.c	2002/03/21 08:41:09	1.32.2.2
+++ nedit-5.3/source/tags.c	2002/08/06 02:07:55
@@ -853,6 +853,7 @@
     char **dupTagsList;
     int startPos, endPos, lineNum, rows, i,nTag=0,samePath=0;
     WindowInfo *windowToSearch;
+    WindowInfo *parentWindow = WidgetToWindow(dialogParent);
 
     /* verify that the string is reasonable as a tag */
     if (*string == '\0' || strlen(string) > MAX_TAG_LEN) {
@@ -956,7 +957,7 @@
     */
     ParseFilename(tagFiles[0],filename,pathname);
     /* open the file containing the definition */
-    EditExistingFile(WindowList, filename, pathname, 0, NULL, False, NULL);
+    EditExistingFile(parentWindow, filename, pathname, 0, NULL, False, NULL);
     windowToSearch = FindWindowWithFile(filename, pathname);
     if (windowToSearch == NULL) {
 	DialogF(DF_WARN, dialogParent, 1, "File %s not found", 
@@ -999,6 +1000,7 @@
     char filename[MAXPATHLEN], pathname[MAXPATHLEN];
     char *eptr;
     WindowInfo *windowToSearch;
+    WindowInfo *parentWindow = WidgetToWindow(parent);
     
     XmSelectionBoxCallbackStruct *cbs = 
       	    (XmSelectionBoxCallbackStruct *) call_data;
@@ -1016,7 +1018,7 @@
     }
     ParseFilename(tagFiles[i],filename,pathname);
     /* open the file containing the definition */
-    EditExistingFile(WindowList, filename, pathname, 0, NULL, False, NULL);
+    EditExistingFile(parentWindow, filename, pathname, 0, NULL, False, NULL);
     windowToSearch = FindWindowWithFile(filename, pathname);
     if (windowToSearch == NULL) {
 	DialogF(DF_WARN, parent, 1, "File %s not found", 
Index: source/text.c
===================================================================
retrieving revision 1.23
diff -u -r1.23 text.c
--- nedit-5.3/source/text.c	2002/02/27 11:26:07	1.23
+++ nedit-5.3/source/text.c	2002/08/06 02:07:55
@@ -3962,3 +3962,8 @@
         return(1);
 	 }
 }
+
+const char *GetDefaultTranslations(void)
+{
+    return defaultTranslations;
+}
Index: source/text.h
===================================================================
retrieving revision 1.5
diff -u -r1.5 text.h
--- nedit-5.3/source/text.h	2001/11/16 10:06:34	1.5
+++ nedit-5.3/source/text.h	2002/08/06 02:07:55
@@ -118,5 +118,6 @@
 int TextFirstVisiblePos(Widget w);
 int TextLastVisiblePos(Widget w);
 char *TextGetWrapped(Widget w, int startPos, int endPos, int *length);
+const char *GetDefaultTranslations(void);
 XtActionsRec *TextGetActions(int *nActions);
 #endif
Index: source/userCmds.c
===================================================================
retrieving revision 1.23
diff -u -r1.23 userCmds.c
--- nedit-5.3/source/userCmds.c	2001/12/13 13:14:33	1.23
+++ nedit-5.3/source/userCmds.c	2002/08/06 03:51:41
@@ -1114,6 +1114,9 @@
     int i, nTreeEntries, isDefaultLM;
     char *hierName, *namePtr, *subMenuName, *subSep, *strippedName, *name;
     
+    if (!IsTopBuffer(window))
+    	return;
+	
     /* Fetch the appropriate menu pane and item list for this menu type */
     if (menuType == SHELL_CMDS) {
     	menuPane = window->shellMenuPane;
Index: source/window.c
===================================================================
retrieving revision 1.48.2.4
diff -u -r1.48.2.4 window.c
--- nedit-5.3/source/window.c	2002/04/23 19:52:40	1.48.2.4
+++ nedit-5.3/source/window.c	2002/08/17 03:29:38
@@ -48,10 +48,15 @@
 #include <Xm/PanedW.h>
 #include <Xm/PanedWP.h>
 #include <Xm/RowColumnP.h>
+#include <Xm/Separator.h>
 #include <Xm/Text.h>
 #include <Xm/ToggleB.h>
+#include <Xm/PushB.h>
 #include <Xm/Form.h>
+#include <Xm/Frame.h>
 #include <Xm/Label.h>
+#include <Xm/SelectioB.h>
+#include <Xm/List.h>
 #include <Xm/Protocols.h>
 #include <Xm/ScrolledW.h>
 #include <Xm/ScrollBar.h>
@@ -61,6 +66,7 @@
 /* extern void _XEditResCheckMessages(); */
 #endif /* EDITRES */
 
+#include "../util/fileUtils.h"
 #include "../util/DialogF.h"
 #include "../util/misc.h"
 #include "textBuf.h"
@@ -94,6 +100,26 @@
    below the main menu bar */
 #define STAT_SHADOW_THICKNESS 1
 
+/* buffer tabs & tooltip configuration */
+#define TAB_TOOLTIP_DELAY 500
+#define TAB_MAX_WIDTH 150
+#define TOOLTIP_EDGE_GUARD 10
+
+void UpdateBufferTabBar(WindowInfo *window);
+void createFindDlog(Widget parent, WindowInfo *window);
+void createReplaceDlog(Widget parent, WindowInfo *window);
+void createReplaceMultiFileDlog(Widget parent, WindowInfo *window);
+static Widget manageToolBars(Widget toolBarsForm);
+static void showToolTip(Widget w);
+static void hideToolTip(void);
+static void showToolTipProc(XtPointer clientData, XtIntervalId *id);
+static void hideToolTipProc(XtPointer clientData, XtIntervalId *id);
+static void refreshBufferTabStates(WindowInfo *window);
+static void CloseBufferWindow(Widget w, WindowInfo *window, XtPointer callData);
+static void toolTipEventHandler(Widget w, WindowInfo *window,
+	XKeyEvent *event);
+static void resizeBufferTabBar(Widget w, XEvent *event, String args[],
+	Cardinal *num_args);
 static Widget createTextArea(Widget parent, WindowInfo *window, int rows,
 	int cols, int emTabDist, char *delimiters, int wrapMargin,
 	int lineNumCols);
@@ -126,15 +152,29 @@
 static int sortAlphabetical(const void* k1, const void* k2);
 static int virtKeyBindingsAreInvalid(const unsigned char* bindings);
 static void restoreInsaneVirtualKeyBindings(unsigned char* bindings);
+static void setBufferSharedPref(WindowInfo *window, WindowInfo *lastwin);
+static void refreshBufferMenuBar(WindowInfo *window);
+static void cloneBuffer(WindowInfo *window, WindowInfo *orgWin);
+static void cloneTextPane(WindowInfo *window, WindowInfo *orgWin);
+static void refreshBufferWindowState(WindowInfo *window);
+
+static WindowInfo *focusInBuffer = NULL;  	/* where we are now */
+static WindowInfo *lastBuffer = NULL;	    	/* where we came from */
+static int DoneWithAttachBufferDialog;
 
+static Widget toolTip = NULL;
+static XtIntervalId toolTipTimeoutID = 0;	/* timer procedure id for tooltip */
+
 /*
 ** Create a new editor window
 */
 WindowInfo *CreateWindow(const char *name, char *geometry, int iconic)
 {
-    Widget appShell, mainWin, menuBar, pane, text, stats, statsForm;
-    Widget iSearchLabel;
+    Widget appShell, mainWin, menuBar, pane, text, stats;
+    Widget iSearchLabel, form, statsForm;
     WindowInfo *window;
+    Pixel color;
+    XtActionsRec rec; 
     Arg al[20];
     int ac;
     XmString s1;
@@ -212,6 +252,8 @@
     window->prevOpenMenuValid = FALSE;
     window->flashTimeoutID = 0;
     window->wasSelected = FALSE;
+    toolTip = NULL;
+    toolTipTimeoutID = 0;
     strcpy(window->fontName, GetPrefFontName());
     strcpy(window->italicFontName, GetPrefItalicFontName());
     strcpy(window->boldFontName, GetPrefBoldFontName());
@@ -303,14 +345,16 @@
        window pointer from the widget id of any of the window's widgets */
     XtSetArg(al[ac], XmNuserData, window); ac++;
     mainWin = XmCreateMainWindow(appShell, "main", al, ac);
-    XtManageChild(mainWin);
+    window->mainWin = mainWin;
+    XtManageChild(mainWin);    
     
     statsForm = XtVaCreateWidget("statsForm", 
        	    xmFormWidgetClass, mainWin,
 	    XmNshadowThickness, STAT_SHADOW_THICKNESS, NULL);
-    if(window->showISearchLine || window->showStats)
-	XtManageChild(statsForm);
-       	    
+
+    if (GetPrefBufferTabs() || window->showISearchLine || window->showStats)
+        XtManageChild(statsForm);
+    
     /* NOTE: due to a bug in openmotif 2.1.30, NEdit used to crash when
        the i-search bar was active, and the i-search text widget was focussed,
        and the window's width was resized to nearly zero. 
@@ -323,14 +367,13 @@
        
     window->iSearchForm = XtVaCreateWidget("iSearchForm", 
        	    xmFormWidgetClass, statsForm,
+	    XmNshadowThickness, 0,
 	    XmNleftAttachment, XmATTACH_FORM,
 	    XmNleftOffset, STAT_SHADOW_THICKNESS,
 	    XmNtopAttachment, XmATTACH_FORM,
 	    XmNtopOffset, STAT_SHADOW_THICKNESS,
 	    XmNrightAttachment, XmATTACH_FORM,
 	    XmNrightOffset, STAT_SHADOW_THICKNESS,
-	    XmNbottomAttachment, window->showStats ?
-	    	XmATTACH_NONE : XmATTACH_FORM,
 	    XmNbottomOffset, STAT_SHADOW_THICKNESS, NULL);
     if(window->showISearchLine)
 	XtManageChild(window->iSearchForm);
@@ -406,6 +449,46 @@
     RemapDeleteKey(window->iSearchText);
 
     SetISearchTextCallbacks(window);
+ 
+    window->bufferTabBar = XtVaCreateWidget("bufferTabBar", 
+       	    xmRowColumnWidgetClass, statsForm,
+	    XmNorientation, XmHORIZONTAL,
+	    XmNpacking, XmPACK_TIGHT,
+	    XmNmarginHeight, 1,
+	    XmNmarginWidth, 0,
+	    XmNspacing, 0,
+    	    XmNresizeWidth, False, 
+	    XmNleftAttachment, XmATTACH_FORM,
+	    XmNrightAttachment, XmATTACH_FORM,
+	    XmNshadowThickness, STAT_SHADOW_THICKNESS, NULL);
+     
+    /* create first tab to keep the tabbar's height right */
+    XtVaGetValues(window->bufferTabBar, XmNbackground, &color, NULL);
+    XtVaCreateManagedWidget("bufferTab",
+      	    xmPushButtonWidgetClass, window->bufferTabBar,
+	    XmNlabelString, s1=XmStringCreateSimple(" "),
+	    XmNmarginHeight, 1,
+	    XmNleftOffset, 1,
+	    XmNtopOffset, 1,
+    	    XmNbottomShadowColor, color,
+    	    XmNhighlightThickness, 1,
+    	    XmNshadowThickness, 2,
+            XmNtraversalOn, False,
+	    XmNwidth, TAB_MAX_WIDTH,
+	    XmNrecomputeSize, False,
+	    NULL);
+    XmStringFree(s1);		
+	
+    if (GetPrefBufferTabs()) {
+    	XtManageChild(window->bufferTabBar);
+	
+	/* fit the tabs into bar when window is resized */
+	rec.string = "resize";
+	rec.proc   = resizeBufferTabBar;
+	XtAppAddActions(XtWidgetToApplicationContext(window->shell), &rec, 1);
+	XtOverrideTranslations(mainWin,  
+    		XtParseTranslationTable("<Configure>: resize()"));
+    }
     
     /* Create file statistics display area.  Using a text widget rather than
        a label solves a layout problem with the main window, which messes up
@@ -415,8 +498,9 @@
        widget, because many users and some system defaults color text
        backgrounds differently from other widgets. */
 
-    stats = XtVaCreateWidget("statsLine", xmTextWidgetClass,  statsForm,
-    	    XmNshadowThickness, 0,
+    stats = XtVaCreateWidget("statsLine", xmTextWidgetClass, statsForm,
+	    XmNshadowThickness, 1,
+	    XmNshadowType, XmSHADOW_ETCHED_IN,
     	    XmNmarginHeight, 0,
     	    XmNscrollHorizontal, False,
     	    XmNeditMode, XmSINGLE_LINE_EDIT,
@@ -425,8 +509,6 @@
     	    XmNcursorPositionVisible, False,
 	    XmNleftAttachment, XmATTACH_FORM,
 	    XmNleftOffset, STAT_SHADOW_THICKNESS,
-	    XmNtopAttachment, window->showISearchLine ?
-	    	XmATTACH_WIDGET : XmATTACH_FORM,
 	    XmNtopWidget, window->iSearchForm,
 	    XmNtopOffset, STAT_SHADOW_THICKNESS,
 	    XmNrightAttachment, XmATTACH_FORM,
@@ -436,28 +518,45 @@
     window->statsLine = stats;
     if(window->showStats)
 	XtManageChild(stats);
-    	
+
     /* If the fontList was NULL, use the magical default provided by Motif,
        since it must have worked if we've gotten this far */
     if (window->fontList == NULL)
     	XtVaGetValues(stats, XmNfontList, &window->fontList, NULL);
 
+    manageToolBars(statsForm);
+
     /* Create the menu bar */
     menuBar = CreateMenuBar(mainWin, window);
     window->menuBar = menuBar;
     XtManageChild(menuBar);
     
+    form = XtVaCreateManagedWidget("textForm", 
+	    xmFormWidgetClass, mainWin,
+	    XmNmarginWidth, 0, XmNmarginHeight, 0,
+	    XmNshadowThickness, STAT_SHADOW_THICKNESS, NULL);
+    window->textForm = form;
+    
+    XmMainWindowSetAreas(mainWin, menuBar, statsForm, NULL, NULL, form);
+
     /* Create paned window to manage split window behavior */
-    pane = XtVaCreateManagedWidget("pane", xmPanedWindowWidgetClass,  mainWin,
+    pane = XtVaCreateManagedWidget("pane", xmPanedWindowWidgetClass, window->textForm,
     	    XmNmarginWidth, 0, XmNmarginHeight, 0, XmNseparatorOn, False,
-    	    XmNspacing, 3, XmNsashIndent, -2, NULL);
+    	    XmNspacing, 3, XmNsashIndent, -2, 
+	    XmNleftAttachment, XmATTACH_FORM,
+	    XmNtopAttachment, XmATTACH_FORM,
+	    XmNrightAttachment, XmATTACH_FORM,
+	    XmNbottomAttachment, XmATTACH_FORM,
+	    NULL);
     window->splitPane = pane;
-    XmMainWindowSetAreas(mainWin, menuBar, statsForm, NULL, NULL, pane);
-
+    
+    /* buffer/window info should associate with text pane */
+    XtVaSetValues(pane, XmNuserData, window, NULL);
+    
     /* Patch around Motif's most idiotic "feature", that its menu accelerators
        recognize Caps Lock and Num Lock as modifiers, and don't trigger if
        they are engaged */ 
-    AccelLockBugPatch(pane, menuBar);
+    AccelLockBugPatch(pane, window->menuBar);
 
     /* Create the first, and most permanent text area (other panes may
        be added & removed, but this one will never be removed */
@@ -523,6 +622,14 @@
     
     restoreInsaneVirtualKeyBindings(invalidBindings);
     
+    /* create persistant dialog upfront, shared by all buffers
+       in a common shell window */
+    createFindDlog(window->shell, window);
+    createReplaceDlog(window->shell, window);
+    createReplaceMultiFileDlog(window->shell, window);
+
+    RaiseBuffer(window);
+
     return window;
 }
 
@@ -533,7 +640,10 @@
 {
     int keepWindow;
     char name[MAXPATHLEN];
-    
+    WindowInfo *nextBuf = NULL;
+
+    hideToolTip();
+        
     /* Free smart indent macro programs */
     EndSmartIndent(window);
     
@@ -584,6 +694,7 @@
     	    	    	    	    	           line from long file names */
     	UpdateStatsLine(window);
 	DetermineLanguageMode(window, True);
+    	UpdateBufferTabBar(window);
 	return;
     }
     
@@ -603,12 +714,44 @@
     ClearUndoList(window);
     ClearRedoList(window);
     
-    /* remove and deallocate all of the widgets associated with window */
-    XtDestroyWidget(window->shell);
+    /* close window, or buffer */
+    if (NumOfBufferInWindow(window) > 1) {
+	if (IsTopBuffer(window)) {
+	    /* if this is the active buffer, then we need to find a 
+	       its successor before it goes out in flame */
+	    WindowInfo **windows = MakeSortedWindowArray();
+	    int n, i=0;
+	    
+	    /* the 'left-hand' tab get the new seat, unless the
+	       closing buffer is first tab on the left */
+	    for (n=0; n<NWindows(); n++) {
+    		if (windows[n]->shell == window->shell) {		
+		    if (windows[n] == window) {
+	    	    	nextBuf = i > 0? windows[n-1] : windows[n+1];
+			break;
+		    }
+		    i++;    /* tab position in the window */
+		}
+	    }
+	    
+	    XtFree((char *)windows);
+	}	
+    }
+    else {
+	/* remove and deallocate all of the widgets associated with window */
+	XtDestroyWidget(window->shell);
+    }
     
     /* remove the window from the global window list, update window menus */
     removeFromWindowList(window);
     InvalidateWindowMenus();
+    DeleteBuffer(window);
+    
+    /* delete buffer might change the menu states */
+    if (nextBuf) {
+    	RaiseBufferWindow(nextBuf);
+	UpdateBufferTabBar(nextBuf);    	
+    }
     
     /* deallocate the window data structure */
     XtFree((char *)window);
@@ -639,6 +782,7 @@
     int insertPositions[MAX_PANES+1], topLines[MAX_PANES+1];
     int horizOffsets[MAX_PANES+1];
     int i, focusPane, emTabDist, wrapMargin, lineNumCols, totalHeight=0;
+    Dimension paneWidth, paneHeight;
     char *delimiters;
     Widget text;
     
@@ -693,6 +837,12 @@
     	setPaneDesiredHeight(XtParent(text), paneHeights[i]);
     }
 
+    /* work-around for Lesstif to 'expose' all split panes */
+    XtVaGetValues(window->textForm, XmNwidth, &paneWidth, 
+    	    XmNheight, &paneHeight, NULL);
+    XtVaSetValues(window->splitPane, XmNwidth, paneWidth,
+    	    XmNheight, paneHeight, NULL);
+
     /* Re-manage panedWindow to recalculate pane heights & reset selection */
     XtManageChild(window->splitPane);
     
@@ -701,7 +851,6 @@
     	text = i==0 ? window->textArea : window->textPanes[i-1];
 	TextSetCursorPos(text, insertPositions[i]);
 	TextSetScroll(text, topLines[i], horizOffsets[i]);
-    	setPaneDesiredHeight(XtParent(text), totalHeight/(window->nPanes+1));
     }
     XmProcessTraversal(window->lastFocus, XmTRAVERSE_CURRENT);
     
@@ -746,6 +895,7 @@
     int insertPositions[MAX_PANES+1], topLines[MAX_PANES+1];
     int horizOffsets[MAX_PANES+1];
     int i, focusPane,totalHeight=0;
+    Dimension paneWidth, paneHeight;
     Widget text;
     
     /* Don't delete the last pane */
@@ -769,7 +919,14 @@
     XtUnmanageChild(window->splitPane);
     
     /* Destroy last pane, and make sure lastFocus points to an existing pane */
-    XtDestroyWidget(XtParent(window->textPanes[--window->nPanes]));
+    window->nPanes--;
+    
+    /* Workaround for OM 2.1.30: text widget must be unmanaged for 
+       xmPanedWindowWidget to calculate the correct pane heights for
+       the remaining panes, simply detroying it didn't seem enough */
+    XtUnmanageChild(XtParent(window->textPanes[window->nPanes]));
+    XtDestroyWidget(XtParent(window->textPanes[window->nPanes]));
+
     if (window->nPanes == 0)
 	window->lastFocus = window->textArea;
     else if (focusPane > window->nPanes)
@@ -777,7 +934,7 @@
     
     /* adjust the heights, scroll positions, etc., to make it look
        like the pane with the input focus was closed */
-    for (i=window->nPanes; i>=focusPane; i--) {
+    for (i=focusPane; i<=window->nPanes; i++) {
     	insertPositions[i] = insertPositions[i+1];
     	paneHeights[i] = paneHeights[i+1];
     	topLines[i] = topLines[i+1];
@@ -790,6 +947,13 @@
     	text = i==0 ? window->textArea : window->textPanes[i-1];
     	setPaneDesiredHeight(XtParent(text), paneHeights[i]);
     }
+
+    /* work-around for Lesstif to 'expose' all split panes */
+    XtVaGetValues(window->textForm, XmNwidth, &paneWidth, 
+    	    XmNheight, &paneHeight, NULL);
+    XtVaSetValues(window->splitPane, XmNwidth, paneWidth,
+    	    XmNheight, paneHeight, NULL);
+
     XtManageChild(window->splitPane);
     
     /* Reset all of the scroll positions, insert positions, etc. */
@@ -797,7 +961,6 @@
     	text = i==0 ? window->textArea : window->textPanes[i-1];
 	TextSetCursorPos(text, insertPositions[i]);
 	TextSetScroll(text, topLines[i], horizOffsets[i]);
-    	setPaneDesiredHeight(XtParent(text), totalHeight/(window->nPanes+1));
     }
     XmProcessTraversal(window->lastFocus, XmTRAVERSE_CURRENT);
 
@@ -914,15 +1077,10 @@
 static void showStats(WindowInfo *window, int state)
 {
     if (state) {
-	XtVaSetValues(window->iSearchForm,
-		XmNbottomAttachment, XmATTACH_NONE, NULL);
 	XtManageChild(window->statsLine);
 	showStatsForm(window, True);
     } else {
 	XtUnmanageChild(window->statsLine);
-	XtVaSetValues(window->iSearchForm,
-		XmNbottomAttachment, XmATTACH_FORM,
-		XmNbottomOffset, STAT_SHADOW_THICKNESS, NULL);
 	showStatsForm(window, window->showISearchLine);
     }
       
@@ -961,13 +1119,10 @@
 static void showISearch(WindowInfo *window, int state)
 {
     if (state) {
-	XtVaSetValues(window->statsLine, XmNtopAttachment, XmATTACH_WIDGET,
-		XmNtopWidget, window->iSearchForm, NULL);
 	XtManageChild(window->iSearchForm);
 	showStatsForm(window, True);
     } else {
 	XtUnmanageChild(window->iSearchForm);
-	XtVaSetValues(window->statsLine, XmNtopAttachment, XmATTACH_FORM, NULL);
 	showStatsForm(window, window->showStats || window->modeMessageDisplayed);
     }
       
@@ -993,8 +1148,8 @@
        this occurs may be earlier than 2.1.  If the stats line shows
        double thickness shadows in earlier Motif versions, the #if XmVersion
        directive should be moved back to that earlier version) */
-    if (state) {
-    	XtUnmanageChild(statsForm);    /*... will this fix Solaris 7??? */
+    if (manageToolBars(statsForm)) {
+	XtUnmanageChild(statsForm);
 	XtVaSetValues(mainW, XmNcommandWindowLocation,
     		XmCOMMAND_ABOVE_WORKSPACE, NULL);
 #if XmVersion < 2001
@@ -1004,11 +1159,11 @@
     	XtVaSetValues(mainW, XmNshowSeparator, False, NULL);
    	UpdateStatsLine(window);
     } else {
-     	XtUnmanageChild(statsForm);
-   	XtVaSetValues(mainW, XmNcommandWindowLocation,
-   		XmCOMMAND_BELOW_WORKSPACE, NULL);
+	XtUnmanageChild(statsForm);
+	XtVaSetValues(mainW, XmNcommandWindowLocation,
+    		XmCOMMAND_BELOW_WORKSPACE, NULL);
     }
-      
+    
     /* Tell WM that the non-expandable part of the window has changed size */
     UpdateWMSizeHints(window);
 }
@@ -1241,22 +1396,49 @@
 /*
 ** Recover the window pointer from any widget in the window, by searching
 ** up the widget hierarcy for the top level container widget where the window
-** pointer is stored in the userData field.
+** pointer is stored in the userData field. In buffer mode, this is the window
+** pointer of the top (active) buffer, which is returned if w is 'shell-level'
+** widget - menus, find/replace dialogs, etc.
+**
+** To support action routine in buffer mode, a copy of the window pointer 
+** is also store in the splitPane widget.
 */
 WindowInfo *WidgetToWindow(Widget w)
 {
-    WindowInfo *window;
+    WindowInfo *window = NULL;
     Widget parent;
     
     while (True) {
+    	/* return window pointer of buffer */
+    	if (XtClass(w) == xmPanedWindowWidgetClass)
+	    break;
+	    
     	parent = XtParent(w);
-    	if (parent == NULL)
-    	    return NULL;
-    	if (XtClass(parent) == applicationShellWidgetClass)
+    	if (parent == NULL) {
+	    /* if widget is window->shell */
+	    if (XtClass(w) == applicationShellWidgetClass) {
+    		WidgetList items;
+
+		/* there should be only 1 child for the shell -
+		   the main window widget */
+    		XtVaGetValues(w, XmNchildren, &items, NULL);
+		w = items[0];
+		break;
+	    }
+	    else
+    		return NULL;
+    	}
+	
+	/* make sure it is not a dialog shell */
+    	if (XtClass(parent) == applicationShellWidgetClass &&
+	    	XmIsMainWindow(w))
     	    break;
+
     	w = parent;
     }
+    
     XtVaGetValues(w, XmNuserData, &window, NULL);
+
     return window;
 }
 
@@ -1270,9 +1452,11 @@
     	XtSetSensitive(window->closeItem, TRUE);
     	window->fileChanged = TRUE;
     	UpdateWindowTitle(window);
+	refreshBufferTabStates(window);
     } else if (window->fileChanged == TRUE && modified == FALSE) {
     	window->fileChanged = FALSE;
     	UpdateWindowTitle(window);
+	refreshBufferTabStates(window);
     }
 }
 
@@ -1282,7 +1466,12 @@
 */
 void UpdateWindowTitle(const WindowInfo *window)
 {
-    char *title = FormatWindowTitle(window->filename,
+    char *iconTitle, *title;
+    
+    if (!IsTopBuffer((WindowInfo*)window))
+    	return;
+
+    title = FormatWindowTitle(window->filename,
                                     window->path,
 #ifdef VMS
                                     NULL,
@@ -1296,7 +1485,7 @@
                                     window->fileChanged,
                                     GetPrefTitleFormat());
                    
-    char *iconTitle = XtMalloc(strlen(window->filename) + 2); /* strlen("*")+1 */
+    iconTitle = XtMalloc(strlen(window->filename) + 2); /* strlen("*")+1 */
 
     strcpy(iconTitle, window->filename);
     if (window->fileChanged)
@@ -1310,7 +1499,7 @@
     	XtVaSetValues(XtParent(window->findDlog), XmNtitle, title, NULL);
     }
     if (window->replaceDlog && XmToggleButtonGetState(window->replaceKeepBtn)) {
-    	sprintf(title, "Replace (in %s)", window->filename);
+    	sprintf(title, "Replace/Find (in %s)", window->filename);
     	XtVaSetValues(XtParent(window->replaceDlog), XmNtitle, title, NULL);
     }
     XtFree(iconTitle);
@@ -1328,6 +1517,9 @@
 {
     int i, state;
     
+    if (!IsTopBuffer(window))
+    	return;
+
     state = IS_ANY_LOCKED(window->lockReasons);
     XtVaSetValues(window->textArea, textNreadOnly, state, NULL);
     for (i=0; i<window->nPanes; i++)
@@ -1484,7 +1676,7 @@
     vScrollBar = XtVaCreateManagedWidget("textVertScrollBar",
     	    xmScrollBarWidgetClass, sw, XmNorientation, XmVERTICAL,
     	    XmNrepeatDelay, 10, NULL);
-    text = XtVaCreateManagedWidget("text", textWidgetClass, sw,
+    text = XtVaCreateWidget("text", textWidgetClass, sw,
     	    textNrows, rows, textNcolumns, cols,
 	    textNlineNumCols, lineNumCols,
     	    textNemulateTabs, emTabDist,
@@ -1498,6 +1690,16 @@
     	    textNautoWrap, window->wrapMode == NEWLINE_WRAP,
     	    textNcontinuousWrap, window->wrapMode == CONTINUOUS_WRAP,
     	    textNoverstrike, window->overstrike, NULL);
+
+    /* The text area now sits inside a form widget (which comes from
+       a bulletin widget). According to Motif FAQ, althoguh ours is 
+       not inside a dialog shell, the bulletin stole the translation,
+       so we try to take it back. This is particularly true on Solaris
+       2.5 with Motif 1.2 */
+    XtOverrideTranslations(text,
+            XtParseTranslationTable(GetDefaultTranslations()));
+    XtManageChild(text);
+
     XtVaSetValues(sw, XmNworkWindow, text, XmNhorizontalScrollBar, hScrollBar,
     	    XmNverticalScrollBar, vScrollBar, NULL);
     
@@ -1562,24 +1764,29 @@
     if ((window->wasSelected && !selected) ||
         (!window->wasSelected && selected)) {
     	window->wasSelected = selected;
-    	XtSetSensitive(window->printSelItem, selected);
-    	XtSetSensitive(window->cutItem, selected);
-    	XtSetSensitive(window->copyItem, selected);
-        XtSetSensitive(window->delItem, selected);
-        /* Note we don't change the selection for items like
-           "Open Selected" and "Find Selected".  That's because
-           it works on selections in external applications.
-           Desensitizing it if there's no NEdit selection 
-           disables this feature. */
+	
+	/* buffers may share a common shell window, menu-bar etc.
+	   we don't do much if things happen to the hidden ones */
+        if (IsTopBuffer(window)) {
+    	    XtSetSensitive(window->printSelItem, selected);
+    	    XtSetSensitive(window->cutItem, selected);
+    	    XtSetSensitive(window->copyItem, selected);
+            XtSetSensitive(window->delItem, selected);
+            /* Note we don't change the selection for items like
+               "Open Selected" and "Find Selected".  That's because
+               it works on selections in external applications.
+               Desensitizing it if there's no NEdit selection 
+               disables this feature. */
 #ifndef VMS
-        XtSetSensitive(window->filterItem, selected);
+            XtSetSensitive(window->filterItem, selected);
 #endif
 
-        DimSelectionDepUserMenuItems(window, selected);
-        if (window->replaceDlog != NULL)
-        {
-            UpdateReplaceActionButtons(window);
-        }
+            DimSelectionDepUserMenuItems(window, selected);
+            if (window->replaceDlog != NULL)
+            {
+        	UpdateReplaceActionButtons(window);
+            }
+	}
     }
     
     /* Make sure line number display is sufficient for new data */
@@ -1651,15 +1858,25 @@
 
 static void closeCB(Widget w, WindowInfo *window, XtPointer callData) 
 {
-    if (WindowList->next == NULL) {
-	if (!CheckPrefsChangesSaved(window->shell))
-    	    return;
-	if (!WindowList->fileChanged)
-     	    exit(EXIT_SUCCESS);
-     	if (CloseFileAndWindow(window, PROMPT_SBC_DIALOG_RESPONSE))
-     	    exit(EXIT_SUCCESS);
-    } else
-    	CloseFileAndWindow(window, PROMPT_SBC_DIALOG_RESPONSE);
+    window = WidgetToWindow(w);
+    
+    if (GetPrefWindowBufferMode()) {
+	/* in window-buffer mode, we now have only one app window,
+	   to close is to quit */
+	CloseBufferWindow(w, window, callData);
+    }
+    else {
+    	/* close this window */
+	if (WindowList->next == NULL) {
+	    if (!CheckPrefsChangesSaved(window->shell))
+    		return;
+	    if (!WindowList->fileChanged)
+     		exit(EXIT_SUCCESS);
+     	    if (CloseFileAndWindow(window, PROMPT_SBC_DIALOG_RESPONSE))
+     		exit(EXIT_SUCCESS);
+	} else
+    	    CloseFileAndWindow(window, PROMPT_SBC_DIALOG_RESPONSE);    
+    }
 }
 
 static void saveYourselfCB(Widget w, WindowInfo *window, XtPointer callData) 
@@ -1670,6 +1887,8 @@
     char **argv;
     int wasIconic = False;
     
+    window = WidgetToWindow(w);
+    
     /* Only post a restart command on the first window in the window list so
        session manager can restart the whole set of windows in one executable,
        rather than one nedit per file.  Even if the restart command is not on
@@ -1743,7 +1962,7 @@
 static void focusToISearchTextCB(Widget w, WindowInfo *window,
 	XtPointer callData) 
 {
-    XmProcessTraversal(window->iSearchText, XmTRAVERSE_CURRENT);
+    XmProcessTraversal(WidgetToWindow(w)->iSearchText, XmTRAVERSE_CURRENT);
 }
 
 /*
@@ -1857,6 +2076,9 @@
     char *sleft, *smid, *sright;
 #endif
     
+    if (!IsTopBuffer(window))
+    	return;
+
     /* This routine is called for each character typed, so its performance
        affects overall editor perfomance.  Only update if the line is on
        and not displaying a special mode message */ 
@@ -2250,3 +2472,1319 @@
       XFree((char*)insaneVirtKeyBindings);
    }
 }
+
+/*
+** perform generic management on the children (toolbars) of toolBarsForm,
+** a.k.a. statsForm, by setting the form attachment of the managed child 
+** widgets per their position/order.
+**
+** It also takes care of the attachment offset settings of the child
+** widgets to keep the border lines of the parent form displayed, so
+** you don't have set them before hand.
+**
+** Note: XtManage/XtUnmange the target child (toolbar) before calling this
+**       function.
+*/
+static Widget manageToolBars(Widget toolBarsForm)
+{
+    Widget topWidget = NULL;
+    WidgetList children;
+    int n, nItems=0;
+
+    XtVaGetValues(toolBarsForm, XmNchildren, &children, 
+    	    XmNnumChildren, &nItems, NULL);
+
+    for (n=0; n<nItems; n++) {
+    	if (XtIsManaged(children[n])) {	    
+	    if (topWidget)
+		XtVaSetValues(children[n], XmNtopAttachment, XmATTACH_WIDGET,
+			XmNtopWidget, topWidget,
+			XmNbottomAttachment, XmATTACH_NONE,
+	    	    	XmNleftOffset, STAT_SHADOW_THICKNESS,
+	    	    	XmNrightOffset, STAT_SHADOW_THICKNESS,			
+			NULL);
+	    else
+	    	/* the very first toolbar on top */
+	    	XtVaSetValues(children[n], XmNtopAttachment, XmATTACH_FORM,
+		    	XmNbottomAttachment, XmATTACH_NONE,
+	    	    	XmNleftOffset, STAT_SHADOW_THICKNESS,
+	    	    	XmNtopOffset, STAT_SHADOW_THICKNESS,			
+	    	    	XmNrightOffset, STAT_SHADOW_THICKNESS,			
+			NULL);
+	    
+	    topWidget = children[n];	    
+	} 
+	else {
+	    /* Remove top attachment to widget to avoid circular dependency.
+	       Attach bottom to form so that when the widget is redisplayed
+	       later, it will trigger the parent form to resize properly as
+	       if the widget is being inserted */
+	    XtVaSetValues(children[n], XmNtopAttachment, XmATTACH_NONE,
+		    XmNbottomAttachment, XmATTACH_FORM, NULL);
+	}
+    }
+    
+    if (topWidget)
+	XtVaSetValues(topWidget, 
+		XmNbottomAttachment, XmATTACH_FORM,
+		XmNbottomOffset, STAT_SHADOW_THICKNESS,
+		NULL);
+    return topWidget;
+}
+
+/*
+** when mainWin is resized, so is the tab bar. We need to update
+** the tab bar if the width has changed. 
+*/
+static void resizeBufferTabBar(Widget w, XEvent *event, String args[],
+	Cardinal *num_args)
+{
+    Dimension width = 0; 
+    int lastWidth = 0;
+    WindowInfo *window = WidgetToWindow(w);
+    
+    /* check the last width record to see if we need to 
+       update the tab bar */
+    XtVaGetValues(window->bufferTabBar, XmNuserData, &lastWidth,
+    	    XmNwidth, &width, NULL);
+
+    if (lastWidth != width) {
+        UpdateBufferTabBar(window);
+    }
+}
+
+/*
+** Create a new buffer on the window
+*/
+WindowInfo *CreateBuffer(WindowInfo *shellWindow, const char *name,
+	char *geometry, int iconic)
+{
+    Widget pane, text;
+    WindowInfo *window;
+    Dimension paneWidth, paneHeight;
+    
+#ifdef SGI_CUSTOM
+    char sgi_title[MAXPATHLEN + 14 + SGI_WINDOW_TITLE_LEN] = SGI_WINDOW_TITLE; 
+#endif
+
+    /* Allocate some memory for the new window data structure */
+    window = (WindowInfo *)XtMalloc(sizeof(WindowInfo));
+    memcpy(window, shellWindow, sizeof(WindowInfo));
+    
+    /* initialize window structure */
+    /* + Schwarzenberg: should a 
+      memset(window, 0, sizeof(WindowInfo));
+         be added here ?
+    */
+#if 0
+    /* share these dialog items with parent shell */
+    window->replaceDlog = NULL;
+    window->replaceText = NULL;
+    window->replaceWithText = NULL;
+    window->replaceWordToggle = NULL;
+    window->replaceCaseToggle = NULL;
+    window->replaceRegexToggle = NULL;
+    window->findDlog = NULL;
+    window->findText = NULL;
+    window->findWordToggle = NULL;
+    window->findCaseToggle = NULL;
+    window->findRegexToggle = NULL;
+    window->replaceMultiFileDlog = NULL;
+    window->replaceMultiFilePathBtn = NULL;
+    window->replaceMultiFileList = NULL;
+#endif
+    window->multiFileReplSelected = FALSE;
+    window->multiFileBusy = FALSE;
+    window->writableWindows = NULL;
+    window->nWritableWindows = 0;
+    window->fileChanged = FALSE;
+    window->fileMode = 0;
+    window->filenameSet = FALSE;
+    window->fileFormat = UNIX_FILE_FORMAT;
+    window->lastModTime = 0;
+    strcpy(window->filename, name);
+    window->undo = NULL;
+    window->redo = NULL;
+    window->nPanes = 0;
+    window->autoSaveCharCount = 0;
+    window->autoSaveOpCount = 0;
+    window->undoOpCount = 0;
+    window->undoMemUsed = 0;
+    CLEAR_ALL_LOCKS(window->lockReasons);
+    window->indentStyle = GetPrefAutoIndent(PLAIN_LANGUAGE_MODE);
+    window->autoSave = GetPrefAutoSave();
+    window->saveOldVersion = GetPrefSaveOldVersion();
+    window->wrapMode = GetPrefWrap(PLAIN_LANGUAGE_MODE);
+    window->overstrike = False;
+    window->showMatchingStyle = GetPrefShowMatching();
+    window->matchSyntaxBased = GetPrefMatchSyntaxBased();
+    window->showStats = GetPrefStatsLine();
+    window->showISearchLine = GetPrefISearchLine();
+    window->showLineNumbers = GetPrefLineNums();
+    window->showPathInWindowsMenu = GetPrefShowPathInWindowsMenu();
+    window->highlightSyntax = GetPrefHighlightSyntax();
+    window->modeMessageDisplayed = FALSE;
+    window->ignoreModify = FALSE;
+    window->windowMenuValid = FALSE;
+    window->prevOpenMenuValid = FALSE;
+    window->flashTimeoutID = 0;
+    window->wasSelected = FALSE;
+    strcpy(window->fontName, GetPrefFontName());
+    strcpy(window->italicFontName, GetPrefItalicFontName());
+    strcpy(window->boldFontName, GetPrefBoldFontName());
+    strcpy(window->boldItalicFontName, GetPrefBoldItalicFontName());
+    window->fontList = GetPrefFontList();
+    window->italicFontStruct = GetPrefItalicFont();
+    window->boldFontStruct = GetPrefBoldFont();
+    window->boldItalicFontStruct = GetPrefBoldItalicFont();
+    window->fontDialog = NULL;
+    window->nMarks = 0;
+    window->markTimeoutID = 0;
+    window->highlightData = NULL;
+    window->shellCmdData = NULL;
+    window->macroCmdData = NULL;
+    window->smartIndentData = NULL;
+    window->languageMode = PLAIN_LANGUAGE_MODE;
+    window->iSearchHistIndex = 0;
+    window->iSearchStartPos = -1;
+    window->replaceLastRegexCase   = TRUE;
+    window->replaceLastLiteralCase = FALSE;
+    window->iSearchLastRegexCase   = TRUE;
+    window->iSearchLastLiteralCase = FALSE;
+    window->findLastRegexCase      = TRUE;
+    window->findLastLiteralCase    = FALSE;
+
+    /* Create paned window to manage split window behavior.
+
+       To work around a bug (?) in XmForm in Lesstif (0.93.0), which
+       refuses to expand the pane to fit into the window, we create the
+       pane without attachment, resize it manually later, then set the 
+       attachment so that XmForm will manage the resizing thereafter
+       
+       The mapping of the pane widget has been suspended to reduce 
+       flickers while resizing the pane */
+    pane = XtVaCreateManagedWidget("pane",
+    	    xmPanedWindowWidgetClass, window->textForm,
+    	    XmNmarginWidth, 0, XmNmarginHeight, 0, XmNseparatorOn, False,
+    	    XmNspacing, 3, XmNsashIndent, -2,
+	    XmNmappedWhenManaged, False,
+	    NULL);
+    window->splitPane = pane;
+
+    /* buffer/window info should associate with text pane */
+    XtVaSetValues(pane, XmNuserData, window, NULL);
+
+    /* Patch around Motif's most idiotic "feature", that its menu accelerators
+       recognize Caps Lock and Num Lock as modifiers, and don't trigger if
+       they are engaged */ 
+    AccelLockBugPatch(pane, window->menuBar);
+
+    /* Create the first, and most permanent text area (other panes may
+       be added & removed, but this one will never be removed */
+    text = createTextArea(pane, window, 1, 1,
+    	    GetPrefEmTabDist(PLAIN_LANGUAGE_MODE), GetPrefDelimiters(),
+	    GetPrefWrapMargin(), window->showLineNumbers?MIN_LINE_NUM_COLS:0);
+    XtManageChild(text);
+    window->textArea = text;
+    window->lastFocus = text;
+    
+    /* fit buffer pane into window and let XmForm takes care of 
+       its resizing from now on */
+    XtVaGetValues(shellWindow->textForm, XmNwidth, &paneWidth, 
+    	    XmNheight, &paneHeight, NULL);
+    XtVaSetValues(pane, XmNwidth, paneWidth,
+    	    XmNheight, paneHeight,
+	    XmNleftAttachment, XmATTACH_FORM,
+	    XmNtopAttachment, XmATTACH_FORM,
+	    XmNrightAttachment, XmATTACH_FORM,
+	    XmNbottomAttachment, XmATTACH_FORM,
+    	    NULL);
+    XtMapWidget(pane);
+    
+    /* Create the right button popup menu (note: order is important here,
+       since the translation for popping up this menu was probably already
+       added in createTextArea, but CreateBGMenu requires window->textArea
+       to be set so it can attach the menu to it (because menu shells are
+       finicky about the kinds of widgets they are attached to)) */
+    window->bgMenuPane = CreateBGMenu(window);
+    
+    /* Create the text buffer rather than using the one created automatically
+       with the text area widget.  This is done so the syntax highlighting
+       modify callback can be called to synchronize the style buffer BEFORE
+       the text display's callback is called upon to display a modification */
+    window->buffer = BufCreate();
+    BufAddModifyCB(window->buffer, SyntaxHighlightModifyCB, window);
+    
+    /* Attach the buffer to the text widget, and add callbacks for modify */
+    TextSetBuffer(text, window->buffer);
+    BufAddModifyCB(window->buffer, modifiedCB, window);
+    
+    /* Designate the permanent text area as the owner for selections */
+    HandleXSelections(text);
+    
+    /* Set the requested hardware tab distance and useTabs in the text buffer */
+    BufSetTabDistance(window->buffer, GetPrefTabDist(PLAIN_LANGUAGE_MODE));
+    window->buffer->useTabs = GetPrefInsertTabs();
+
+    /* add the window to the global window list, update the Windows menus */
+    InvalidateWindowMenus();
+    addToWindowList(window);
+
+    if (iconic && isIconic(shellWindow))
+        RaiseBuffer(window);
+    else
+        RaiseBufferWindow(window);
+	
+    return window;
+}
+
+static void CloseBufferWindow(Widget w, WindowInfo *window, XtPointer callData) 
+{
+    WindowInfo *win;
+    int nShellWindow = 1;
+    
+    /* see if this is the only shell window */
+    for (win = WindowList; win; win = win->next) {
+    	if (win->shell != window->shell)
+	    nShellWindow++;
+    }
+    
+    if (nShellWindow < 2) {
+    	/* this is only window, then exit */
+	XtCallActionProc(WindowList->lastFocus, "exit",
+    		((XmAnyCallbackStruct *)callData)->event, NULL, 0);
+
+    }
+    else if (NumOfBufferInWindow(window) == 1) {
+    	/* the only buffer in the window */
+    	CloseFileAndWindow(WidgetToWindow(w), PROMPT_SBC_DIALOG_RESPONSE);
+    }
+    else {
+    	/* more than one buffer in the window */
+        int resp = DialogF(DF_QUES, window->shell, 3, 
+	    	"Close buffer %s?", "Close", "Close Window", "Cancel", 
+		window->filename
+	        );
+
+        if (resp == 1) {
+	    /* close the active buffer */
+    	    CloseFileAndWindow(window, PROMPT_SBC_DIALOG_RESPONSE);
+	}	
+    	if (resp == 2) {
+	    Widget winShell = window->shell;
+	    
+    	    /* close all buffers belong to this window */
+	    for (win = WindowList; win; ) {
+    		if (win->shell == winShell) {
+	    	    WindowInfo *next = win->next;
+    	    	    if (!CloseFileAndWindow(win, PROMPT_SBC_DIALOG_RESPONSE))
+		    	break;
+		    win = next;
+		}
+		else
+	    	    win = win->next;
+	    }
+	}
+	else
+            return; 	/* cancelled */
+    
+    }
+}
+
+static void cloneTextPane(WindowInfo *window, WindowInfo *orgWin)
+{
+    short paneHeights[MAX_PANES+1];
+    int insertPositions[MAX_PANES+1], topLines[MAX_PANES+1];
+    int horizOffsets[MAX_PANES+1];
+    int i, focusPane, emTabDist, wrapMargin, lineNumCols, totalHeight=0;
+    char *delimiters;
+    Dimension paneWidth, paneHeight;
+    Widget text;
+    selection sel;
+    
+    /* old window must disown hilite data */
+    orgWin->highlightData = NULL;
+        
+    /* transfer the primary selection */
+    memcpy(&sel, &orgWin->buffer->primary, sizeof(selection));
+	    
+    if (sel.selected) {
+    	if (sel.rectangular)
+    	    BufRectSelect(window->buffer, sel.start, sel.end,
+		    sel.rectStart, sel.rectEnd);
+    	else
+    	    BufSelect(window->buffer, sel.start, sel.end);
+    } else
+    	BufUnselect(window->buffer);
+
+    /* Record the current heights, scroll positions, and insert positions
+       of the existing panes, keyboard focus */
+    focusPane = 0;
+    for (i=0; i<=orgWin->nPanes; i++) {
+    	text = i==0 ? orgWin->textArea : orgWin->textPanes[i-1];
+    	insertPositions[i] = TextGetCursorPos(text);
+    	XtVaGetValues(XtParent(text), XmNheight, &paneHeights[i], NULL);
+    	totalHeight += paneHeights[i];
+    	TextGetScroll(text, &topLines[i], &horizOffsets[i]);
+    	if (text == orgWin->lastFocus)
+    	    focusPane = i;
+    }
+    
+    window->nPanes = orgWin->nPanes;
+    
+    /* clone split panes, if any */
+    if (window->nPanes) {
+	/* Unmanage & remanage the panedWindow so it recalculates pane heights */
+    	XtUnmanageChild(window->splitPane);
+
+	/* Create a text widget to add to the pane and set its buffer and
+	   highlight data to be the same as the other panes in the orgWin */
+	XtVaGetValues(orgWin->textArea, textNemulateTabs, &emTabDist,
+    		textNwordDelimiters, &delimiters, textNwrapMargin, &wrapMargin,
+		textNlineNumCols, &lineNumCols, NULL);
+
+	for(i=0; i<orgWin->nPanes; i++) {
+	    text = createTextArea(window->splitPane, window, 1, 1, emTabDist,
+    		    delimiters, wrapMargin, lineNumCols);
+	    TextSetBuffer(text, window->buffer);
+
+	    if (window->highlightData != NULL)
+    		AttachHighlightToWidget(text, window);
+	    XtManageChild(text);
+	    window->textPanes[i] = text;
+	}
+
+	/* Set the minimum pane height in the new pane */
+	UpdateMinPaneHeights(window);
+
+	for (i=0; i<=window->nPanes; i++) {
+    	    text = i==0 ? window->textArea : window->textPanes[i-1];
+    	    setPaneDesiredHeight(XtParent(text), paneHeights[i]);
+	}
+
+	/* work-around for Lesstif to 'expose' all split panes */
+	XtVaGetValues(window->textForm, XmNwidth, &paneWidth, 
+    		XmNheight, &paneHeight, NULL);
+	XtVaSetValues(window->splitPane, XmNwidth, paneWidth,
+    		XmNheight, paneHeight, NULL);
+
+	/* Re-manage panedWindow to recalculate pane heights & reset selection */
+    	XtManageChild(window->splitPane);
+    }
+
+    /* Reset all of the heights, scroll positions, etc. */
+    for (i=0; i<=window->nPanes; i++) {
+    	text = i==0 ? window->textArea : window->textPanes[i-1];
+	TextSetCursorPos(text, insertPositions[i]);
+	TextSetScroll(text, topLines[i], horizOffsets[i]);
+    }
+        
+    /* set the focus pane */
+    for (i=0; i<=window->nPanes; i++) {
+    	text = i==0 ? window->textArea : window->textPanes[i-1];
+	if(i == focusPane) {
+    	    XmProcessTraversal(text, XmTRAVERSE_CURRENT);
+	    break;
+	}
+    }
+    
+    /* Update the window manager size hints after the sizes of the panes have
+       been set (the widget heights are not yet readable here, but they will
+       be by the time the event loop gets around to running this timer proc) */
+    XtAppAddTimeOut(XtWidgetToApplicationContext(window->shell), 0,
+    	    wmSizeUpdateProc, window);
+}
+
+static void refreshBufferMenuBar(WindowInfo *window)
+{
+    WindowInfo *win;
+    
+    /* File menu */
+    XtSetSensitive(window->printSelItem, window->wasSelected);
+
+    /* Edit menu */
+    XtSetSensitive(window->undoItem, window->undo != NULL);
+    XtSetSensitive(window->redoItem, window->redo != NULL);
+    XtSetSensitive(window->printSelItem, window->wasSelected);
+    XtSetSensitive(window->cutItem, window->wasSelected);
+    XtSetSensitive(window->copyItem, window->wasSelected);
+    XtSetSensitive(window->delItem, window->wasSelected);
+    
+    /* Preferences menu */
+    XmToggleButtonSetState(window->statsLineItem, window->showStats, False);
+    XmToggleButtonSetState(window->iSearchLineItem, window->showISearchLine, False);
+    XmToggleButtonSetState(window->lineNumsItem, window->showLineNumbers, False);
+    XmToggleButtonSetState(window->highlightItem, window->highlightSyntax, False);
+    XtSetSensitive(window->highlightItem, window->languageMode != PLAIN_LANGUAGE_MODE);
+    XmToggleButtonSetState(window->saveLastItem, window->saveOldVersion, False);
+    XmToggleButtonSetState(window->autoSaveItem, window->autoSave, False);
+    XmToggleButtonSetState(window->overtypeModeItem, window->overstrike, False);
+    XmToggleButtonSetState(window->matchSyntaxBasedItem, window->matchSyntaxBased, False);
+    XmToggleButtonSetState(window->readOnlyItem, IS_USER_LOCKED(window->lockReasons), False);
+
+    SetAutoIndent(window, window->indentStyle);
+    SetAutoWrap(window, window->wrapMode);
+    SetShowMatching(window, window->showMatchingStyle);
+    SetLanguageMode(window, window->languageMode, FALSE);
+    
+    /* Shell & Macro menu */
+    UpdateShellMenu(window);
+    UpdateMacroMenu(window);
+    DimSelectionDepUserMenuItems(window, window->wasSelected);
+
+    /* Windows Menu */
+    XtSetSensitive(window->splitWindowItem, window->nPanes < MAX_PANES);
+    XtSetSensitive(window->closePaneItem, window->nPanes > 0);
+    XtSetSensitive(window->detachBufferItem, NumOfBufferInWindow(window)>1);
+
+    for (win=WindowList; win; win=win->next)
+    	if (win->shell != window->shell)  
+	    break;
+    XtSetSensitive(window->attachBufferItem, win != NULL);
+}
+
+static void setBufferSharedPref(WindowInfo *window, WindowInfo *lastwin)
+{
+    window->showStats = lastwin->showStats;
+    window->showISearchLine = lastwin->showISearchLine;
+}
+
+WindowInfo *MarkLastBuffer(WindowInfo *window)
+{
+    WindowInfo *prev = lastBuffer;
+    
+    if (window)
+    	lastBuffer = window;
+	
+    return prev;
+}
+
+WindowInfo *MarkActiveBuffer(WindowInfo *window)
+{
+    WindowInfo *prev = focusInBuffer;
+
+    if (window)
+    	focusInBuffer = window;
+
+    return prev;
+}
+
+void NextBuffer(WindowInfo *window)
+{
+    WindowInfo **windows;
+    int i, nWindows;
+    
+    if (WindowList->next == NULL)
+    	return;
+
+    windows = MakeSortedWindowArray();
+    nWindows = NWindows();
+    for(i=0; i<nWindows && windows[i] != window; i++)
+    	;
+
+    i = i==(nWindows-1)? 0 : i+1;
+    
+    if (window->shell == windows[i]->shell)
+	RaiseBuffer(windows[i]);
+    else
+    	RaiseBufferWindow(windows[i]);
+	
+    XtFree((char *)windows);
+}
+
+void PreviousBuffer(WindowInfo *window)
+{
+    WindowInfo **windows;
+    int i, nWindows;
+    
+    if (WindowList->next == NULL)
+    	return;
+
+    windows = MakeSortedWindowArray();
+    nWindows = NWindows();
+    for(i=0; i<nWindows && windows[i] != window; i++)
+    	;
+
+    i = i>0? i-1 : nWindows-1;
+
+    if (window->shell == windows[i]->shell)
+	RaiseBuffer(windows[i]);
+    else
+    	RaiseBufferWindow(windows[i]);
+	
+    XtFree((char *)windows);
+}
+
+void ToggleBuffer(WindowInfo *window)
+{
+    WindowInfo *win;
+    
+    for(win = WindowList; win; win=win->next)
+    	if (lastBuffer == win)
+	    break;
+    
+    if (!win)
+    	return;
+
+    if (window->shell == win->shell)
+	RaiseBuffer(win);
+    else
+    	RaiseBufferWindow(win);
+	
+}
+
+void RaiseBufferWindow(WindowInfo *window)
+{
+    /* first raise the shell window, then the buffer if any */
+    RaiseShellWindow(window->shell);
+    RaiseBuffer(window);
+}
+
+void RaiseBuffer(WindowInfo *window)
+{
+    WindowInfo *win, *lastwin;        
+
+    lastwin = MarkActiveBuffer(window);
+    if (lastwin != window)
+    	MarkLastBuffer(lastwin);
+
+    if (!GetPrefWindowBufferMode() || !window || !WindowList)
+    	return;
+    
+    /* buffer already active? */
+    XtVaGetValues(window->mainWin, XmNuserData, &win, NULL);
+
+    if (win == window)
+    	return;    
+    
+    /* refresh shared menu items */
+    setBufferSharedPref(window, win);
+    
+    /* set the buffer as active */
+    XtVaSetValues(window->mainWin, XmNuserData, window, NULL);
+
+    /* raise buffer to top */ 
+    XRaiseWindow(TheDisplay, XtWindow(window->splitPane));
+    refreshBufferTabStates(window);
+    
+    /* set keyboard focus */
+    XmProcessTraversal(window->lastFocus, XmTRAVERSE_CURRENT);
+    
+    /* now refresh window state/info. refreshBufferWindowState() 
+       has a lot of work to do, so we update the screen first so
+       the buffers appear to switch immediately */
+    XmUpdateDisplay(window->splitPane);
+    refreshBufferWindowState(window);
+}
+
+WindowInfo* GetTopBuffer(Widget w)
+{
+    WindowInfo *window = WidgetToWindow(w);
+    
+    return WidgetToWindow(window->shell);
+}
+
+Boolean IsTopBuffer(const WindowInfo *window)
+{
+    return window == GetTopBuffer(window->shell)? True : False;
+}
+
+void DeleteBuffer(WindowInfo *window)
+{    
+    WindowInfo *win;
+    
+    if (!GetPrefWindowBufferMode() || !window)
+    	return;
+    
+    for (win=WindowList; win; win=win->next)
+    	refreshBufferWindowState(win);
+
+    XtDestroyWidget(window->splitPane);
+}
+
+static void cloneBuffer(WindowInfo *window, WindowInfo *orgWin)
+{
+    char *orgBuffer;
+    
+    strcpy(window->path, orgWin->path);
+    strcpy(window->filename, orgWin->filename);
+
+    ShowLineNumbers(window, orgWin->showLineNumbers);
+
+    /* copy the buffer */
+    window->ignoreModify = True;
+    orgBuffer = BufGetAll(orgWin->buffer);
+    BufSetAll(window->buffer, orgBuffer);
+    window->ignoreModify = False;
+    XtFree(orgBuffer);
+
+    /* recycle the hilite data */    
+    window->highlightData = orgWin->highlightData;
+    if (window->highlightData != NULL)
+    	AttachHighlightToWidget(window->textArea, window);
+
+    /* copy the text/split panes settings, cursor pos & selection */
+    cloneTextPane(window, orgWin);
+    
+    /* clone original buffer's states */
+    window->filenameSet = orgWin->filenameSet;
+    window->fileFormat = orgWin->fileFormat;
+    window->lastModTime = orgWin->lastModTime;
+    window->fileChanged = orgWin->fileChanged;
+    window->lockReasons = orgWin->lockReasons;
+    window->nPanes = orgWin->nPanes;
+    window->autoSaveCharCount = orgWin->autoSaveCharCount;
+    window->autoSaveOpCount = orgWin->autoSaveOpCount;
+    window->undoOpCount = orgWin->undoOpCount;
+    window->undoMemUsed = orgWin->undoMemUsed;
+    window->lockReasons = orgWin->lockReasons;
+    window->indentStyle = orgWin->indentStyle;
+    window->autoSave = orgWin->autoSave;
+    window->saveOldVersion = orgWin->saveOldVersion;
+    window->wrapMode = orgWin->wrapMode;
+    window->overstrike = orgWin->overstrike;
+    window->showMatchingStyle = orgWin->showMatchingStyle;
+    window->matchSyntaxBased = orgWin->matchSyntaxBased;
+    window->highlightSyntax = orgWin->highlightSyntax;
+#if 0    
+    window->showStats = orgWin->showStats;
+    window->showISearchLine = orgWin->showISearchLine;
+    window->showLineNumbers = orgWin->showLineNumbers;
+    window->showPathInWindowsMenu = orgWin->showPathInWindowsMenu;
+    window->modeMessageDisplayed = orgWin->modeMessageDisplayed;
+    window->ignoreModify = orgWin->ignoreModify;
+    window->windowMenuValid = orgWin->windowMenuValid;
+    window->prevOpenMenuValid = orgWin->prevOpenMenuValid;
+    window->flashTimeoutID = orgWin->flashTimeoutID;
+    window->wasSelected = orgWin->wasSelected;
+#endif
+    strcpy(window->fontName, orgWin->fontName);
+    strcpy(window->italicFontName, orgWin->italicFontName);
+    strcpy(window->boldFontName, orgWin->boldFontName);
+    strcpy(window->boldItalicFontName, orgWin->boldItalicFontName);
+    window->fontList = orgWin->fontList;
+    window->italicFontStruct = orgWin->italicFontStruct;
+    window->boldFontStruct = orgWin->boldFontStruct;
+    window->boldItalicFontStruct = orgWin->boldItalicFontStruct;
+    window->nMarks = orgWin->nMarks;
+#if 0    
+    window->markTimeoutID = orgWin->markTimeoutID;
+    window->highlightData = orgWin->highlightData;
+    window->shellCmdData = orgWin->shellCmdData;
+    window->macroCmdData = orgWin->macroCmdData;
+    window->smartIndentData = orgWin->smartIndentData;
+#endif    
+    window->languageMode = orgWin->languageMode;
+    window->iSearchHistIndex = orgWin->iSearchHistIndex;
+    window->iSearchStartPos = orgWin->iSearchStartPos;
+    window->replaceLastRegexCase = orgWin->replaceLastRegexCase;
+    window->replaceLastLiteralCase = orgWin->replaceLastLiteralCase;
+    window->iSearchLastRegexCase = orgWin->iSearchLastRegexCase;
+    window->iSearchLastLiteralCase = orgWin->iSearchLastLiteralCase;
+    window->findLastRegexCase = orgWin->findLastRegexCase;
+    window->findLastLiteralCase = orgWin->findLastLiteralCase;
+    
+    /* takeover undo list */
+    window->undo = orgWin->undo;
+    orgWin->undo = NULL;
+        
+    /* takeover redo list */
+    window->redo = orgWin->redo;
+    orgWin->redo = NULL;
+
+    /* synchronize window state to this buffer */
+    refreshBufferWindowState(window);
+}
+
+/*
+** return number of buffers own by this shell window
+*/
+int NumOfBufferInWindow(WindowInfo *window)
+{
+    WindowInfo *win;
+    int nBuffer = 0;
+    
+    if (!GetPrefWindowBufferMode())
+    	return 1;
+	
+    for (win = WindowList; win; win = win->next) {
+    	if (win->shell == window->shell)
+	    nBuffer++;
+    }
+    
+    return nBuffer;
+}
+
+/* 
+** refresh window state for this buffer
+*/
+static void refreshBufferWindowState(WindowInfo *window)
+{
+    if (!IsTopBuffer(window))
+    	return;
+	
+    UpdateWindowReadOnly(window);
+    UpdateStatsLine(window);
+    UpdateWindowTitle(window);
+    refreshBufferMenuBar(window);    
+
+    /* we need to force the statsline to reveal itself */
+    XmTextSetCursorPosition(window->statsLine, 0);	/* start of line */
+    XmTextSetCursorPosition(window->statsLine, 9000);	/* end of line */
+}
+
+/*
+** spin off the buffer to a new window
+*/
+WindowInfo *DetachBuffer(WindowInfo *window)
+{
+    WindowInfo *win, *cloneWin;
+    Dimension windowHeight, windowWidth;
+    char *dim, geometry[MAX_GEOM_STRING_LEN];
+    
+    /* raise another buffer in the same shell window */
+    for (win = WindowList; win; win = win->next) {
+    	if (win->shell == window->shell && window != win) {
+    	    RaiseBuffer(win);
+	    break;
+	}
+    }
+    
+    /* create new window in roughly the size of original window,
+       to reduce flicker when the window is resized later */
+    getGeometryString(window, geometry);
+    dim = strtok(geometry, "+-");
+    cloneWin = CreateWindow("", dim, False);
+    
+    /* duplicate the shell window setting. this, as well as the
+       statistic line sand incr search line,  must be done
+       before cloning window, else the height of split panes 
+       may not come out correctly */
+    XtVaGetValues(window->shell, XmNheight, &windowHeight,
+    	    XmNwidth, &windowWidth, NULL);
+    XtVaSetValues(cloneWin->shell, XmNheight, windowHeight,
+    	    XmNwidth, windowWidth, NULL);
+
+    /* these settings should follow the detached buffer */
+    ShowISearchLine(cloneWin, window->showISearchLine);
+    ShowStatsLine(cloneWin, window->showStats);
+
+    /* clone the buffer & its pref settings */
+    cloneBuffer(cloneWin, window);
+
+    /* remove the buffer from the old window */
+    CloseFileAndWindow(window, NO_SBC_DIALOG_RESPONSE | BUFFER_DETACH_MODE);
+    
+    /* some menu states might have changed when deleting buffer */
+    refreshBufferWindowState(win);
+    UpdateBufferTabBar(win);
+    
+    /* this should keep the new buffer window fresh */
+    refreshBufferWindowState(cloneWin);
+    UpdateBufferTabBar(cloneWin);
+    
+    return cloneWin;
+}
+
+/*
+** attach (move) a buffer to an other window.
+**
+** the attaching buffer will inherit the window settings from
+** its new hosts, i.e. the window size, stats and isearch lines.
+*/
+WindowInfo *AttachBuffer(WindowInfo *toWindow, WindowInfo *window)
+{
+    WindowInfo *win, *cloneWin;
+
+    /* raise another buffer in the window of attaching buffer */
+    for (win = WindowList; win; win = win->next) {
+    	if (win->shell == window->shell && window != win)
+	    break;
+    }
+
+    if (win) 
+    	RaiseBuffer(win);
+    else
+    	XtUnmapWidget(window->shell);
+    
+    /* relocate the buffer to target window */
+    cloneWin = CreateBuffer(toWindow, window->filename, NULL, False);
+    cloneBuffer(cloneWin, window);
+    
+    /* remove the buffer from the old window */
+    CloseFileAndWindow(window, NO_SBC_DIALOG_RESPONSE | BUFFER_DETACH_MODE);
+    
+    /* some menu states might have changed when deleting buffer */
+    if (win) {
+    	refreshBufferWindowState(win);
+        UpdateBufferTabBar(win);
+    }
+    
+    /* this should keep the new buffer window fresh */
+    refreshBufferWindowState(cloneWin);
+    UpdateBufferTabBar(cloneWin);
+    
+    return cloneWin;
+}
+
+static void attachBufferCB(Widget dialog, WindowInfo *parentWin,
+	XtPointer call_data)
+{
+    XmSelectionBoxCallbackStruct *cbs = (XmSelectionBoxCallbackStruct *) call_data;
+    DoneWithAttachBufferDialog = cbs->reason;
+}
+
+/*
+** present dialog to selecting target window for attaching
+** buffers. Return immediately if there is only one shell window.
+*/
+void AttachBufferDialog(Widget parent)
+{
+    WindowInfo *parentWin = WidgetToWindow(parent);    
+    WindowInfo *win, *attachWin, **shellWinList;
+    int i, nList=0, nWindows=0, ac;
+    char tmpStr[MAXPATHLEN+50];
+    Widget dialog, listBox;
+    XmString *list = NULL;
+    XmString popupTitle, s1;
+    Arg csdargs[20];
+    int *position_list, position_count;
+    
+    /* create the window list */    
+    nWindows = NWindows();
+    list = (XmStringTable) XtMalloc(nWindows * sizeof(XmString *));
+    shellWinList = (WindowInfo **) XtMalloc(nWindows * sizeof(WindowInfo *));
+
+    for (win=WindowList; win; win=win->next) {
+	if (win->shell == parentWin->shell)
+	    continue;
+	
+	if (!IsTopBuffer(win))
+	    continue;
+	        
+	sprintf(tmpStr, "%s%s",
+		win->filenameSet? win->path : "", win->filename);
+
+	list[nList] = XmStringCreateSimple(tmpStr);
+	shellWinList[nList] = win;
+	nList++;
+    }
+
+    if (!nList) {
+    	XtFree((char *)list);
+    	return;    
+    }
+    
+    sprintf(tmpStr, "Attach %s to:", parentWin->filename);
+    popupTitle = XmStringCreateSimple(tmpStr);
+    ac = 0;
+    XtSetArg(csdargs[ac], XmNdialogStyle, XmDIALOG_FULL_APPLICATION_MODAL); ac++;
+    XtSetArg(csdargs[ac], XmNlistLabelString, popupTitle); ac++;
+    XtSetArg(csdargs[ac], XmNlistItems, list); ac++;
+    XtSetArg(csdargs[ac], XmNlistItemCount, nList); ac++;
+    XtSetArg(csdargs[ac], XmNvisibleItemCount, 12); ac++;
+    XtSetArg(csdargs[ac], XmNautoUnmanage, False); ac++;
+    dialog = CreateSelectionDialog(parent,"attachBuffer",csdargs,ac);
+    XtUnmanageChild(XmSelectionBoxGetChild(dialog, XmDIALOG_TEXT));
+    XtUnmanageChild(XmSelectionBoxGetChild(dialog, XmDIALOG_HELP_BUTTON));
+    XtUnmanageChild(XmSelectionBoxGetChild(dialog, XmDIALOG_SELECTION_LABEL));        
+    XtAddCallback(dialog, XmNokCallback, (XtCallbackProc)attachBufferCB, parentWin);
+    XtAddCallback(dialog, XmNapplyCallback, (XtCallbackProc)attachBufferCB, parentWin);
+    XtAddCallback(dialog, XmNcancelCallback, (XtCallbackProc)attachBufferCB, parentWin);
+    XmStringFree(popupTitle);
+
+    /* free the window list */
+    for (i=0; i<nList; i++)
+	XmStringFree(list[i]);
+    XtFree((char *)list);    
+    
+    /* setup the button per window condition*/
+    if (NumOfBufferInWindow(parentWin) >1) {
+    	/* few buffers in this window */
+	s1 = MKSTRING("Attach");
+	XtVaSetValues (dialog, XmNokLabelString, s1, NULL);
+	XmStringFree(s1);
+
+	s1 = MKSTRING("Attach All");
+	XtVaSetValues (dialog, XmNapplyLabelString, s1, NULL);
+	XmStringFree(s1);
+    }
+    else {
+    	/* only one buffer in the window */
+        XtUnmanageChild(XmSelectionBoxGetChild(dialog, XmDIALOG_OK_BUTTON));
+
+	s1 = MKSTRING("Attach");
+	XtVaSetValues (dialog, XmNapplyLabelString, s1, NULL);
+	XmStringFree(s1);
+    }
+    
+    /* default to the first window on the list */
+    listBox = XmSelectionBoxGetChild(dialog, XmDIALOG_LIST);
+    XmListSelectPos(listBox, 1, True);
+
+    /* show the dialog */
+    DoneWithAttachBufferDialog = 0;
+    ManageDialogCenteredOnPointer(dialog);
+    while (!DoneWithAttachBufferDialog)
+        XtAppProcessEvent(XtWidgetToApplicationContext(parent), XtIMAll);
+
+    /* get window to attach buffer */   
+    XmListGetSelectedPos(listBox, &position_list, &position_count);
+    attachWin = shellWinList[position_list[0]-1];
+    XtFree((char *)position_list);
+    
+    /* now attach buffer(s) */
+    if (DoneWithAttachBufferDialog == XmCR_OK) {
+    	/* attach top (active) buffer */
+    	AttachBuffer(attachWin, parentWin);
+    }
+    else if (DoneWithAttachBufferDialog == XmCR_APPLY) {
+    	/* attach all buffers */
+	for (win = WindowList; win; ) {		
+    	    if (win != parentWin && win->shell == parentWin->shell) {
+	    	WindowInfo *next = win->next;
+    	    	AttachBuffer(attachWin, win);
+		win = next;
+	    }
+	    else
+	    	win = win->next;
+	}
+	
+	/* top buffer is last to attach */
+    	AttachBuffer(attachWin, parentWin);	
+    }
+
+    XtFree((char *)shellWinList);    
+    XtDestroyWidget(dialog);	
+}
+
+/*
+** callback to clicks on the tab button that raise the buffer.
+*/
+static void raiseTabCB(Widget w, WindowInfo *window, caddr_t callData)
+{    
+    RaiseBuffer(window);
+}
+
+/*
+** popup the tooltip, a.k.a. bubble, off the buffer tab, which
+** show the filepath of the underlying buffer.
+*/
+static void showToolTip(Widget w)
+{    
+    Widget toolTipShell;
+    WindowInfo *window;
+    XmString s1;
+    Position tabRootX, tabRootY;
+    Dimension tabWidth, tabHeight, tipWidth, tipHeight, xPos, yPos;
+    XWindowAttributes screenAttr;
+    char title[MAXPATHLEN+10];
+
+    if (!GetPrefToolTips())
+    	return;
+	
+    XtVaGetValues(w, XmNuserData, &window, XmNwidth, &tabWidth, XmNheight, &tabHeight, NULL);
+    
+    if (toolTip == NULL) {
+	Arg args[5];
+	int ac = 0;
+	    
+	XtSetArg(args[ac], XmNsaveUnder, True); ac++;
+	XtSetArg(args[ac], XmNallowShellResize, True); ac++;
+	toolTipShell = CreateShellWithBestVis(APP_NAME, APP_CLASS,
+		    overrideShellWidgetClass, TheDisplay, args, ac);
+
+	toolTip = XtVaCreateManagedWidget( 
+		"toolTip", xmLabelWidgetClass, toolTipShell,
+		XmNborderWidth, 1,
+		XmNhighlightThickness, 0,
+		XmNalignment, XmALIGNMENT_BEGINNING,
+		NULL);
+	
+	/* we may need to adjust the position of the tooltip later */
+	XtPopup(toolTipShell, XtGrabNone); 
+	XtPopdown(toolTipShell);	
+    }
+    else
+    	toolTipShell = XtParent(toolTip);
+	
+    /* show filepath as tooltip */
+    sprintf(title, "%s%s", window->filename, window->fileChanged? "*" : "");
+    if (window->showPathInWindowsMenu && window->filenameSet) {
+       strcat(title, " - ");
+       strcat(title, window->path);
+    }
+        
+    s1=XmStringCreateSimple(title);
+    XtVaSetValues(toolTip, XmNlabelString, s1, NULL);
+    XmStringFree(s1);
+    
+    /* calculate position for the tooltip */
+    XtTranslateCoords(w, 0, 0, &tabRootX, &tabRootY);
+    xPos = tabRootX + (tabWidth / 2);
+    yPos = tabRootY + (tabHeight * 1.5);
+    
+    /* make sure tooltip doesn't get obscured */
+    XGetWindowAttributes(XtDisplay(w), RootWindowOfScreen(XtScreen(w)), &screenAttr);
+    XtVaGetValues(toolTipShell, XmNwidth, &tipWidth, XmNheight, &tipHeight, NULL);
+
+    if (xPos + tipWidth >= screenAttr.width - TOOLTIP_EDGE_GUARD)
+    	xPos = screenAttr.width - tipWidth - TOOLTIP_EDGE_GUARD;
+
+    if (yPos + tipHeight >= screenAttr.height - TOOLTIP_EDGE_GUARD)
+    	yPos = tabRootY - (tabHeight * 1.5);
+    
+    /* show the tooltip */
+    XtVaSetValues(toolTipShell, XmNx, xPos, XmNy, yPos, NULL);    
+    XtPopup(toolTipShell, XtGrabNone); 
+}
+
+/*
+** hide the tooltip of buffer tab
+*/
+static void hideToolTip(void)
+{    
+    if (!GetPrefToolTips() || toolTip == NULL)
+    	return;
+	
+    XtPopdown(XtParent(toolTip));
+}
+
+/*
+** TimeOut proc for displaying tooltip on buffer tabs
+*/
+static void showToolTipProc(XtPointer clientData, XtIntervalId *id)
+{
+    Widget w = (Widget) clientData;
+    WindowInfo *window;
+
+    /* tab might have been destroyed before timeout */
+    if (!XtIsManaged(w))
+    	return;
+	
+    XtVaGetValues(w, XmNuserData, &window, NULL);
+    showToolTip(w);
+    toolTipTimeoutID = 0;
+}
+
+/*
+** TimeOut proc for hiding tooltip on buffer tabs
+*/
+static void hideToolTipProc(XtPointer clientData, XtIntervalId *id)
+{    
+    hideToolTip();
+}
+
+/*
+** Event handler for tooltips on buffer tabs.
+**
+** to see the tooltips, leave the mouse pointer inside the tabs for awhile
+**
+*/
+static void toolTipEventHandler(Widget w, WindowInfo *window,
+	XKeyEvent *event)
+{
+    switch (event->type) {
+	case EnterNotify:
+	    if (toolTipTimeoutID)
+	    	break;
+		
+    	    toolTipTimeoutID = XtAppAddTimeOut(
+    	    	    XtWidgetToApplicationContext(window->shell),
+		    TAB_TOOLTIP_DELAY, showToolTipProc, w);
+	    break;
+	    
+    	case LeaveNotify:
+	    /* if we didn't manage to catch the timer for showToolTop(),
+	       this timer will take care of it */
+    	    XtAppAddTimeOut(XtWidgetToApplicationContext(window->shell),
+		    0, hideToolTipProc, w);
+
+    	    /* cancel the timer for showToolTop() */
+    	    if (toolTipTimeoutID) {
+    	    	XtRemoveTimeOut(toolTipTimeoutID);
+    	    	toolTipTimeoutID = 0;
+	    }
+	    break;
+	    
+	default:
+	    break;
+    }
+}
+
+/*
+** update the tab bar to show the buffers in the shell window
+*/
+void UpdateBufferTabBar(WindowInfo *window)
+{
+    WindowInfo *win, **windows;
+    XmString s1;
+    WidgetList items;
+    Cardinal nItems;
+    Widget btn;
+    int i, index, nWindows;
+    EventMask event_mask = EnterWindowMask | LeaveWindowMask;
+    Pixel color;
+    Dimension tabBarWidth, tabWidth;
+
+
+    if (!GetPrefBufferTabs())
+    	return;
+
+    XtVaGetValues(window->bufferTabBar, XmNchildren, &items,
+    	    XmNnumChildren, &nItems, NULL);
+
+    /* we'll take out the bottom shadow of the buttons to make 
+       them look like tabs */
+    XtVaGetValues(window->bufferTabBar, XmNbackground, &color,
+    	    XmNwidth, &tabBarWidth, NULL);
+
+    /* we'll check back the tabbar width to see if we really need
+       to update the tabs */
+    XtVaSetValues(window->bufferTabBar, XmNuserData, (int)tabBarWidth, NULL);
+
+    /* calculate tab width so that all tabs will fit in the window.
+       We need some guardband margin to prevent the right-most tab  
+       from growing off the tab bar - XmRowColumn will hide it when
+       that happens */
+    tabWidth = (tabBarWidth-2)/NumOfBufferInWindow(window);
+    if (tabWidth > TAB_MAX_WIDTH)
+    	tabWidth = TAB_MAX_WIDTH;
+    
+    XtUnmanageChild(window->bufferTabBar);
+    
+    windows = MakeSortedWindowArray();
+    nWindows = NWindows();
+
+    index=0;
+    for(i=0; i<nWindows; i++) {
+    	win = windows[i];
+    	if (win->shell == window->shell) {
+	    if ((int)nItems <= index) {
+	    	/* new tab added */
+		btn = XtVaCreateManagedWidget("bufferTab",
+      			xmPushButtonWidgetClass, window->bufferTabBar,
+			XmNlabelString, s1=XmStringCreateSimple(win->filename),
+			XmNmarginHeight, 1,
+			XmNleftOffset, 1,
+			XmNtopOffset, 1,
+			XmNbottomShadowColor, color,
+    	    	    	XmNhighlightThickness, 1,
+    	    	    	XmNshadowThickness, 1,
+        		XmNtraversalOn, False,
+			XmNuserData, win,
+			XmNwidth, tabWidth,
+			XmNrecomputeSize, False,
+			XmNfillOnArm, False,
+			NULL);
+		XmStringFree(s1);		
+	    }
+	    else {
+	    	/* recycle the existing tabs */
+		WindowInfo *oldWin;
+		
+		btn = items[index];
+        	XtVaGetValues(btn, XmNuserData, &oldWin, NULL);
+        	XtRemoveAllCallbacks(btn, XmNactivateCallback);
+		XtRemoveEventHandler(btn, event_mask, False, 
+			(XtEventHandler)toolTipEventHandler, oldWin);
+
+        	XtVaSetValues(btn, XmNlabelString, 
+	    		s1=XmStringCreateSimple(win->filename),
+			XmNmarginHeight, 1,
+			XmNleftOffset, 1,
+			XmNtopOffset, 1,
+			XmNbottomShadowColor, color,
+    	    	    	XmNhighlightThickness, 1,
+    	    	    	XmNshadowThickness, 1,
+        		XmNtraversalOn, False,
+			XmNuserData, win,
+			XmNwidth, tabWidth,
+			XmNrecomputeSize, False,
+			XmNfillOnArm, False,
+			NULL);
+		XmStringFree(s1);	    
+	    }
+	    
+	    if (GetPrefToolTips())
+	    	XtAddEventHandler(btn, event_mask, False, 
+		        (XtEventHandler)toolTipEventHandler, win);
+
+	    XtAddCallback(btn, XmNactivateCallback, (XtCallbackProc)raiseTabCB, 
+		    win);
+	    index++;
+	}
+    }
+    
+    XtFree((char *)windows);
+    
+    /* remove the extra tabs */
+    for (;  index<(int)nItems; index++) {
+        XtUnmanageChild(items[index]);
+        XtDestroyWidget(items[index]);  
+    }
+    
+    refreshBufferTabStates(window);
+    XtManageChild(window->bufferTabBar);
+}
+
+/*
+** set the tab buttons' appearance to reflect active buffer
+*/
+static void refreshBufferTabStates(WindowInfo *window)
+{
+    WindowInfo *win;
+    WidgetList items;
+    Cardinal n, nItems;
+    Pixel passiveColor, activeColor;
+    char labelString[MAXPATHLEN];
+    XmString s1;
+    
+    if (!GetPrefBufferTabs())
+    	return;
+
+    XtVaGetValues(window->bufferTabBar, XmNchildren, &items,
+	    XmNnumChildren, &nItems, XmNbackground, &activeColor, NULL);
+
+    if (!nItems)
+    	return;
+	
+    /* turn off tooltips */
+    if (toolTip)
+        XtPopdown(XtParent(toolTip));
+
+    /* use the arm color for tabs of non-active buffers */
+    XtVaGetValues(items[0], XmNarmColor, &passiveColor, NULL);
+ 
+    for (n=0; n<(int)nItems; n++) {
+    	/* when things happen too quickly, some tab buttons
+	   deleted in UpdateBufferTabBar() might still be 
+	   waiting to be destroyed */
+    	if (!XtIsManaged(items[n]))
+	    continue;
+	    
+    	XtVaGetValues(items[n], XmNuserData, &win, NULL);
+	
+    	/* set tab background color to differentiate the active
+	   buffer from the rest */
+    	if (win == window) {		    
+	    sprintf(labelString, "%s%s", win->fileChanged? "*" : "",
+	    	    win->filename);
+            XtVaSetValues(items[n], 
+		    XmNlabelString, s1=XmStringCreateSimple(labelString),
+		    XmNshadowThickness, 2,
+	    	    XmNbackground,
+		    	IsTopBuffer(win)? activeColor : passiveColor, 
+		    NULL);
+	    XmStringFree(s1);
+    	}
+	else {
+            XtVaSetValues(items[n], 
+	    	    XmNshadowThickness, 1, 
+		    XmNbackground, 
+	    	    	IsTopBuffer(win)? activeColor : passiveColor,
+		    NULL);
+	}
+    }   
+}
+
Index: source/window.h
===================================================================
retrieving revision 1.8
diff -u -r1.8 window.h
--- nedit-5.3/source/window.h	2001/11/18 19:02:58	1.8
+++ nedit-5.3/source/window.h	2002/08/06 03:51:25
@@ -35,3 +35,18 @@
 void AddSmallIcon(Widget shell);
 void SetTabDist(WindowInfo *window, int tabDist);
 void SetEmTabDist(WindowInfo *window, int emTabDist);
+WindowInfo *CreateBuffer(WindowInfo *shellWindow, const char *name, char *geometry, int iconic);
+void RaiseBuffer(WindowInfo *window);
+void RaiseBufferWindow(WindowInfo *window);
+void DeleteBuffer(WindowInfo *window);
+WindowInfo *MarkLastBuffer(WindowInfo *window);
+WindowInfo *MarkActiveBuffer(WindowInfo *window);
+void NextBuffer(WindowInfo *window);
+void PreviousBuffer(WindowInfo *window);
+void ToggleBuffer(WindowInfo *window);
+int NumOfBufferInWindow(WindowInfo *window);
+WindowInfo *AttachBuffer(WindowInfo *toWindow, WindowInfo *window);
+WindowInfo *DetachBuffer(WindowInfo *window);
+void AttachBufferDialog(Widget parent);
+WindowInfo* GetTopBuffer(Widget w);
+Boolean IsTopBuffer(const WindowInfo *window);
