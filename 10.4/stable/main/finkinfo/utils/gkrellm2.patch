diff -ru gkrellm-2.3.1/Makefile gkrellm-2.3.1-darwin9/Makefile
--- gkrellm-2.3.1/Makefile	2007-07-19 16:21:50.000000000 -0500
+++ gkrellm-2.3.1-darwin9/Makefile	2008-01-24 20:08:35.000000000 -0600
@@ -166,6 +166,11 @@
 	(cd src && ${MAKE} install STRIP="")
 	(cd server && ${MAKE} install STRIP="")
 
+install_darwin9: install_gkrellm.pc
+	(cd po && ${MAKE} install)
+	(cd src && ${MAKE} install STRIP="")
+	(cd server && ${MAKE} install STRIP="")
+
 install_freebsd: install_gkrellm.pc
 	(cd po && ${MAKE} install)
 	(cd src && ${MAKE} install_freebsd)
@@ -227,6 +232,17 @@
 		LINK_FLAGS="-prebind -Wl,-bind_at_load -framework CoreFoundation" \
 		gkrellmd )
 
+darwin9: gkrellm.pc
+	(cd po && ${MAKE} all)
+	(cd src && ${MAKE} GTK_CONFIG=gtk-config STRIP= HAVE_GETADDRINFO=1 \
+		EXTRAOBJS= SYS_LIBS="-framework IOKit" \
+		LINK_FLAGS="-prebind -Wl,-bind_at_load -framework CoreFoundation -lX11" \
+		gkrellm )
+	(cd server && ${MAKE} GTK_CONFIG=gtk-config STRIP= HAVE_GETADDRINFO=1 \
+		EXTRAOBJS= SYS_LIBS="-framework IOKit" \
+		LINK_FLAGS="-prebind -Wl,-bind_at_load -framework CoreFoundation" \
+		gkrellmd )
+
 netbsd1: gkrellm.pc
 	(cd po && ${MAKE} all)
 	(cd src && ${MAKE} \
diff -ru gkrellm-2.3.1/server/Makefile gkrellm-2.3.1-darwin9/server/Makefile
--- gkrellm-2.3.1/server/Makefile	2007-05-28 14:12:20.000000000 -0500
+++ gkrellm-2.3.1-darwin9/server/Makefile	2008-01-24 20:08:35.000000000 -0600
@@ -131,6 +131,11 @@
 		EXTRAOBJS= SYS_LIBS="-lkvm -lmd5" \
 		LINK_FLAGS="-flat_namespace -undefined warning" gkrellmd
 
+darwin9: 
+	$(MAKE) GTK_CONFIG=gtk-config STRIP= \
+		EXTRAOBJS= SYS_LIBS="-lmd5" \
+		LINK_FLAGS="-flat_namespace -undefined warning" gkrellmd
+
 netbsd1:
 	$(MAKE) EXTRAOBJS= SYS_LIBS="-lkvm" gkrellmd
 
@@ -180,6 +185,9 @@
 install_darwin:
 	$(MAKE) install STRIP=
 
+install_darwin9:
+	$(MAKE) install STRIP=
+
 install_freebsd:
 	$(MAKE) install
 	chgrp kmem $(SINSTALLDIR)/$(PACKAGE_D)
diff -ru gkrellm-2.3.1/src/Makefile gkrellm-2.3.1-darwin9/src/Makefile
--- gkrellm-2.3.1/src/Makefile	2007-05-28 14:12:20.000000000 -0500
+++ gkrellm-2.3.1-darwin9/src/Makefile	2008-01-24 20:08:35.000000000 -0600
@@ -142,6 +142,17 @@
 		gkrellm
 endif
 
+darwin9: 
+ifeq ($(HAVE_SSL),1)
+	$(MAKE) GTK_CONFIG=gtk-config STRIP= \
+		EXTRAOBJS= SYS_LIBS="" \
+		gkrellm
+else
+	$(MAKE) GTK_CONFIG=gtk-config STRIP= \
+		EXTRAOBJS= SYS_LIBS="-lmd5" \
+		gkrellm
+endif
+
 netbsd1:
 	$(MAKE) EXTRAOBJS= SYS_LIBS="-lkvm" \
 		SMC_LIBS="-L/usr/X11R6/lib -lSM -lICE -Wl,-R/usr/X11R6/lib" \
@@ -191,6 +202,9 @@
 install_darwin:
 	$(MAKE) install STRIP=
 
+install_darwin9:
+	$(MAKE) install STRIP=
+
 install_freebsd:
 	$(MAKE) install
 	chgrp kmem $(INSTALLDIR)/$(PACKAGE)
diff -ru gkrellm-2.3.1/src/client.c gkrellm-2.3.1-darwin9/src/client.c
--- gkrellm-2.3.1/src/client.c	2007-07-19 16:45:18.000000000 -0500
+++ gkrellm-2.3.1-darwin9/src/client.c	2008-01-24 20:08:35.000000000 -0600
@@ -1681,7 +1681,7 @@
   /* Read setup info from gkrellmd server.  Stuff needed before the
   |  client_init calls must be read here.
   */
-static void
+static gboolean
 read_server_setup(gint fd)
 	{
 	gchar			buf[256];
@@ -1696,9 +1696,13 @@
 
 	gkrellm_free_glist_and_data(&client_plugin_setup_line_list);
 
+    gint rs;
+    
 	while (1)
 		{
-		getline(fd, buf, sizeof(buf));
+		rs=getline(fd, buf, sizeof(buf));
+        if(rs<0)
+            return FALSE;
 		if (!strcmp(buf, "</gkrellmd_setup>"))
 			break;
 		process_server_line(&setup_table[0], table_size, buf);
@@ -1714,12 +1718,15 @@
 	table_size = sizeof(update_table) / sizeof(KeyTable);
 	while (1)
 		{
-		getline(fd, buf, sizeof(buf));
+		rs=getline(fd, buf, sizeof(buf));
+        if(rs<0)
+            return FALSE;
 		if (!strcmp(buf, "</initial_update>"))
 			break;
 		process_server_line(&update_table[0], table_size, buf);
 		}
 	setup_done = TRUE;
+    return TRUE;
 	}
 
 void
@@ -1870,7 +1877,10 @@
 
 	/* Initial setup lines from server are read in blocking mode.
 	*/
-	read_server_setup(client_fd);
+	if(!read_server_setup(client_fd)){
+        close(client_fd);
+        return FALSE;
+    }
 
 	/* Extra stuff not handled in read_server_setup()
 	*/
Only in gkrellm-2.3.1-darwin9/src: inet.c.orig
Only in gkrellm-2.3.1-darwin9/src: inet.c.rej
diff -ru gkrellm-2.3.1/src/sysdeps/darwin.c gkrellm-2.3.1-darwin9/src/sysdeps/darwin.c
--- gkrellm-2.3.1/src/sysdeps/darwin.c	2007-07-06 18:52:12.000000000 -0500
+++ gkrellm-2.3.1-darwin9/src/sysdeps/darwin.c	2008-01-24 20:08:35.000000000 -0600
@@ -21,19 +21,23 @@
 |  along with this program. If not, see http://www.gnu.org/licenses/
 */
 
+#ifdef HAVE_KVM_H
 #include <kvm.h>
+#endif
 
 #include <mach/mach_init.h>
 #include <mach/mach_host.h>
 #include <mach/vm_map.h>
 
+#ifdef HAVE_KVM_H
 kvm_t	*kvmd = NULL;
 char	errbuf[_POSIX2_LINE_MAX];
-
+#endif
 
 void
 gkrellm_sys_main_init(void)
 	{
+#ifdef HAVE_KVM_H
 	/* We just ignore error, here.  Even if GKrellM doesn't have
 	|  kmem privilege, it runs with available information.
 	*/
@@ -43,6 +47,7 @@
 		fprintf(stderr, "Can't drop setgid privileges.");
 		exit(1);
 		}
+#endif
 	}
 
 void
@@ -53,7 +58,7 @@
 /* ===================================================================== */
 /* CPU monitor interface */
 
-static gint		n_cpus;
+static guint		n_cpus;
 
 void
 gkrellm_sys_cpu_read_data(void)
@@ -107,7 +112,9 @@
 #include <sys/user.h>
 #define	PID_MAX		30000
 
+#ifdef HAVE_KVM_H
 #include <kvm.h>
+#endif
 #include <limits.h>
 #include <paths.h>
 #include <utmp.h>
@@ -154,13 +161,14 @@
 	u_int		n_vforks, n_rforks;
 	gint		r_forks, r_vforks, r_rforks;
 	size_t		len;
+#ifdef HAVE_KVM_H
 	gint		nextpid, nforked;
 	static struct nlist nl[] = {
 #define N_NEXTPID	0
 		{ "_nextpid" },
 		{ "" }
 	};
-
+#endif
 
 	if (getloadavg(&avenrun, 1) <= 0)
 		avenrun = 0;
@@ -181,6 +189,7 @@
 		if (r_forks >= 0 && r_vforks >= 0 && r_rforks >= 0)
 			n_forks = n_forks + n_vforks + n_rforks;
 		}
+#ifdef HAVE_KVM_H
 	else
 		{
 		/* workaround: Can I get total number of processes? */
@@ -203,7 +212,8 @@
 				}
 			}
 		}
-
+#endif
+        
 	if (sysctl(oid_proc, 3, NULL, &len, NULL, 0) >= 0)
 		n_processes = len / sizeof(struct kinfo_proc);
 
@@ -395,19 +405,117 @@
 }
 
 
-/* ===================================================================== */
-/* Inet monitor interface - not implemented */
+#include "../inet.h"
 
-void
-gkrellm_sys_inet_read_tcp_data(void)
-	{
-	}
+#include <net/route.h>
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#ifdef INET6
+#include <netinet/ip6.h>
+#endif /* INET6 */
+#include <netinet/in_pcb.h>
+#include <netinet/ip_icmp.h>
+#include <netinet/icmp_var.h>
+#include <netinet/igmp_var.h>
+#include <netinet/ip_var.h>
+#include <netinet/tcp.h>
+#include <netinet/tcpip.h>
+#include <netinet/tcp_seq.h>
+#define TCPSTATES
+#include <netinet/tcp_fsm.h>
+#include <netinet/tcp_var.h>
+#include <netinet/udp.h>
+#include <netinet/udp_var.h>
+#include <sys/types.h>
 
-gboolean
-gkrellm_sys_inet_init(void)
-	{
-	return FALSE;
+#define warn(x...) fprintf(stderr,x)
+ 
+ void
+ gkrellm_sys_inet_read_tcp_data(void)
+{
+	ActiveTCP	tcp;
+    const char *mibvar="net.inet.tcp.pcblist";
+	char *buf;
+	struct tcpcb *tp = NULL;
+	struct inpcb *inp;
+	struct xinpgen *xig, *oxig;
+	struct xsocket *so;
+	size_t len=0;
+	if (sysctlbyname(mibvar, 0, &len, 0, 0) < 0) {
+		if (errno != ENOENT)
+			warn("sysctl: %s", mibvar);
+		return;
+	}        
+	if ((buf = malloc(len)) == 0) {
+		warn("malloc %lu bytes", (u_long)len);
+		return;
+ 	}
+	if (sysctlbyname(mibvar, buf, &len, 0, 0) < 0) {
+		warn("sysctl: %s", mibvar);
+		free(buf);
+		return;
 	}
+     /*
+         * Bail-out to avoid logic error in the loop below when
+         * there is in fact no more control block to process
+         */
+        if (len <= sizeof(struct xinpgen)) {
+            free(buf);
+            return;
+        }
+ 	oxig = xig = (struct xinpgen *)buf;
+	for (xig = (struct xinpgen *)((char *)xig + xig->xig_len);
+	     xig->xig_len > sizeof(struct xinpgen);
+	     xig = (struct xinpgen *)((char *)xig + xig->xig_len)) {
+    	tp = &((struct xtcpcb *)xig)->xt_tp;
+	   	inp = &((struct xtcpcb *)xig)->xt_inp;
+		so = &((struct xtcpcb *)xig)->xt_socket;
+    if (so->xso_protocol != IPPROTO_TCP)
+ 			continue;
+		/* Ignore PCBs which were freed during copyout. */
+		if (inp->inp_gencnt > oxig->xig_gen)
+			continue;
+	if ((inp->inp_vflag & INP_IPV4) == 0
+#ifdef INET6
+		    && (inp->inp_vflag & INP_IPV6) == 0
+#endif /* INET6 */
+			)
+			continue;
+                /*
+                 * Local address is not an indication of listening socket or
+                 * server sockey but just rather the socket has been bound.
+                 * That why many UDP sockets were not displayed in the original code.
+                 */
+                if (tp->t_state <= TCPS_LISTEN){
+                    continue;
+                    }
+			if (inp->inp_vflag & INP_IPV4) {
+			     tcp.local_port=ntohs(inp->inp_lport);
+			     tcp.remote_addr.s_addr=(uint32_t)inp->inp_faddr.s_addr;
+			     tcp.remote_port=ntohs(inp->inp_fport);
+			     tcp.family=AF_INET;
+			     gkrellm_inet_log_tcp_port_data(&tcp);
+            }
+#ifdef INET6
+			else if (inp->inp_vflag & INP_IPV6) {
+			     tcp.local_port=ntohs(inp->inp_lport);
+    			 memcpy(&(tcp.remote_addr6),&(inp->in6p_faddr),sizeof(struct in6_addr));
+			     tcp.remote_port=ntohs(inp->inp_fport);
+			     tcp.family=AF_INET;
+			     gkrellm_inet_log_tcp_port_data(&tcp);
+			} /* else nothing printed now */
+#endif /* INET6 */
+}  
+free(buf);
+}
+ 
+ gboolean
+ gkrellm_sys_inet_init(void)
+ 	{
+	return TRUE;
+ 	}
+ 
 
 
 /* ===================================================================== */
@@ -453,12 +561,12 @@
 			pshift++;
 	}
 	
-	used = (natural_t)(vm_info.active_count + vm_info.inactive_count + vm_info.wire_count) << pshift;
-	free = (natural_t)vm_info.free_count << pshift;	
-	total = (natural_t)(vm_info.active_count + vm_info.inactive_count + vm_info.free_count + vm_info.wire_count) << pshift;
+	used = (guint64)(vm_info.active_count) << pshift;
+	free = (guint64)vm_info.free_count << pshift;	
+	total = (guint64)(vm_info.active_count + vm_info.inactive_count + vm_info.free_count + vm_info.wire_count) << pshift;
 	/* Don't know how to get cached or buffers. */
-	buffers = 0;
-	cached = 0;
+	buffers =  (guint64) (vm_info.wire_count) << pshift;
+	cached = (guint64) (vm_info.inactive_count) << pshift;
 	/* shared  0 for now, shared is a PITA */
         shared = 0;	
 	gkrellm_mem_assign_data(total, used, free, shared, buffers, cached);
