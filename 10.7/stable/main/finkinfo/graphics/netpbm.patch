diff -ruN netpbm-9.25-orig/configure netpbm-9.25/configure
--- netpbm-9.25-orig/configure	2011-07-23 13:57:01.000000000 +0200
+++ netpbm-9.25/configure	2011-07-23 13:57:22.000000000 +0200
@@ -607,8 +607,9 @@
     # Nothing to do.
 } elsif ($platform eq "DARWIN") {
     push(@Makefile_config, "CC = cc -no-cpp-precomp\n");
+    push(@Makefile_config, 'CFLAGS = -Os -fstrict-aliasing -funroll-loops', "\n");
     push(@Makefile_config, 'CFLAGS_SHLIB = -fno-common', "\n");
-    push(@Makefile_config, 'LDSHLIB = -dynamiclib -install_name $(INSTALLLIBS)/lib$(LIBROOT).$(MAJ).dylib', "\n");
+    push(@Makefile_config, 'LDSHLIB = -dynamiclib -install_name $(INSTALLLIBS)/lib$(LIBROOT).$(MAJ).dylib -compatibility_version `expr $(MAJ) + 1` -current_version `expr $(MAJ) + 1`.$(MIN)', "\n");
 #    push(@Makefile_config, "INSTALL = install\n");
     push(@Makefile_config, 'TIFFHDR_DIR = $(LOCALBASE)/include', "\n");
     push(@Makefile_config, 'TIFFLIB_DIR = $(LOCALBASE)/lib', "\n"); 
diff -ruN netpbm-9.25-orig/pnm/anytopnm netpbm-9.25/pnm/anytopnm
--- netpbm-9.25-orig/pnm/anytopnm	2011-07-23 13:57:02.000000000 +0200
+++ netpbm-9.25/pnm/anytopnm	2011-07-23 13:57:22.000000000 +0200
@@ -22,6 +22,7 @@
 fi
 
 tmpfiles=""
+tmpdir=$(mktemp -d /tmp/anytopnm.XXXXXXXXXX) || exit 1 #219019
 
 # Take out all spaces
 # Find the filename extension for last-ditch efforts later
@@ -29,8 +30,7 @@
 
 # Sanitize the filename by making our own temporary files as safely as
 # possible.
-file="/tmp/atn.stdin.$$"
-rm -f "$file"
+file="$tmpdir/atn.stdin"
 if [ $# -eq 0 -o "$1" = "-" ] ; then
 	cat > "$file"
 else
@@ -57,10 +57,6 @@
     cat < "$1" > "$file"
 fi
 
-tmpfiles="$tmpfiles $file"
-
-
-
 filetype=`file "$file" | cut -d: -f2-`
 
 case "$filetype" in
@@ -70,7 +66,7 @@
     ;;
 
     *uuencoded* )
-    newfile="/tmp/atn.decode.$$"
+    newfile="$tmpdir/atn.decode"
     rm -f "$newfile"
     (echo begin 600 $newfile; tail +2 < "$file") | uudecode
     tmpfiles="$tmpfiles $newfile"
@@ -257,8 +253,7 @@
 
 esac
 
-
-if [ "$tmpfiles" ] ; then
-    rm -f $tmpfiles
+if [ -d "$tmpdir" ] ; then
+    rm -rf "$tmpdir"
 fi
 exit 0
diff -ruN netpbm-9.25-orig/pnm/pnmindex netpbm-9.25/pnm/pnmindex
--- netpbm-9.25-orig/pnm/pnmindex	2011-07-23 13:57:02.000000000 +0200
+++ netpbm-9.25/pnm/pnmindex	2011-07-23 13:57:22.000000000 +0200
@@ -24,10 +24,6 @@
   exit 1
 }
 
-if [ "$TMPDIR"x = ""x ] ; then
-    TMPDIR=/tmp
-fi
-
 while :; do
     case "$1" in
 
@@ -94,8 +90,10 @@
 fi
 
 #tmpfile=`tempfile -p pi -m 600`
-tmpfile=$TMPDIR/pi.tmp.$$
-rm -f $tmpfile
+#tmpfile=$TMPDIR/pi.tmp.$$
+#rm -f $tmpfile
+tmpdir=$(mktemp -d /tmp/pi.XXXXXXXX) || exit 1 #219019
+tmpfile="$tmpdir/pi.tmp"
 maxformat=PBM
 
 rowfiles=()
@@ -105,7 +103,7 @@
 
 if [ "$title"x != ""x ] ; then
 #    rowfile=`tempfile -p pirow -m 600`
-    rowfile=$TMPDIR/pi.${row}.$$
+    rowfile="$tmpdir/pi.${row}.$$"
     pbmtext "$title" > $rowfile
     rowfiles=(${rowfiles[*]} $rowfile )
     row=$(($row + 1))
@@ -153,7 +151,7 @@
         esac
     fi
 
-    imagefile=$TMPDIR/pi.${row}.${col}.$$
+    imagefile="$tmpdir/pi.${row}.${col}.$$"
     rm -f $imagefile
     if [ "$back" = "-white" ]; then
         pbmtext "$i" | pnmcat $back -tb $tmpfile - > $imagefile
@@ -164,7 +162,7 @@
     imagefiles=( ${imagefiles[*]} $imagefile )
 
     if [ $col -ge $across ]; then
-        rowfile=$TMPDIR/pi.${row}.$$
+        rowfile="$tmpdir/pi.${row}.$$"
         rm -f $rowfile
 
         if [ $maxformat != PPM -o "$doquant" = "false" ]; then
@@ -189,7 +187,7 @@
 # Now put the final partial row in its row file.
 
 if [ ${#imagefiles[*]} -gt 0 ]; then
-    rowfile=$TMPDIR/pi.${row}.$$
+    rowfile="$tmpdir/pi.${row}.$$"
     rm -f $rowfile
     if [ $maxformat != PPM -o "$doquant" = "false" ]; then
         pnmcat $back -lr -jbottom ${imagefiles[*]} > $rowfile
@@ -212,5 +210,9 @@
 fi
 rm -f ${rowfiles[*]}
 
+if [ -d "$tmpdir" ]; then
+    rm -rf "$tmpdir";
+fi
+
 exit 0
 
diff -ruN netpbm-9.25-orig/pnm/pnmmargin netpbm-9.25/pnm/pnmmargin
--- netpbm-9.25-orig/pnm/pnmmargin	2011-07-23 13:57:02.000000000 +0200
+++ netpbm-9.25/pnm/pnmmargin	2011-07-23 13:57:22.000000000 +0200
@@ -11,11 +11,16 @@
 # documentation.  This software is provided "as is" without express or
 # implied warranty.
 
-tmp1=/tmp/pnmm1$$
-tmp2=/tmp/pnmm2$$
-tmp3=/tmp/pnmm3$$
-tmp4=/tmp/pnmm4$$
-rm -f $tmp1 $tmp2 $tmp3 $tmp4
+#tmp1=/tmp/pnmm1$$
+#tmp2=/tmp/pnmm2$$
+#tmp3=/tmp/pnmm3$$
+#tmp4=/tmp/pnmm4$$
+#rm -f $tmp1 $tmp2 $tmp3 $tmp4
+tmpdir=$(mktemp -d /tmp/ppmmargin.XXXXXXX) || exit 1 #219019
+tmp1="$tmpdir/tmp1"
+tmp2="$tmpdir/tmp2"
+tmp3="$tmpdir/tmp3"
+tmp4="$tmpdir/tmp4"
 
 color="-gofigure"
 
@@ -83,4 +88,7 @@
 pnmcat -tb $tmp3 $tmp4 $tmp3
 
 # All done.
-rm -f $tmp1 $tmp2 $tmp3 $tmp4
+#rm -f $tmp1 $tmp2 $tmp3 $tmp4
+if [ -d "$tmpdir" ]; then
+    rm -rf "$tmpdir"
+fi
diff -ruN netpbm-9.25-orig/pnm/pnmtopng.c netpbm-9.25/pnm/pnmtopng.c
--- netpbm-9.25-orig/pnm/pnmtopng.c	2011-07-23 13:57:02.000000000 +0200
+++ netpbm-9.25/pnm/pnmtopng.c	2011-07-23 13:57:22.000000000 +0200
@@ -205,7 +205,8 @@
 FILE *tfp;
 #endif
 {
-  char textline[256];
+#define MAXLINE 1024
+  char textline[MAXLINE];
   int textpos;
   int i, j;
   int c;
@@ -217,6 +218,7 @@
   textpos = 0;
   while ((c = getc (tfp)) != EOF) {
     if (c != '\n' && c != EOF) {
+      if (textpos >= MAXLINE) continue;
       textline[textpos++] = c;
     } else {
       textline[textpos++] = '\0';
@@ -227,33 +229,41 @@
         else
           info_ptr->text[j].compression = 0;
         cp = malloc (textpos);
+        if ( cp == NULL )
+          pm_error("out of memory");
         info_ptr->text[j].key = cp;
         i = 0;
         if (textline[0] == '"') {
           i++;
-          while (textline[i] != '"' && textline[i] != '\n')
+          while (textline[i] != '"' && textline[i] != '\n' && i<textpos)
             *(cp++) = textline[i++];
           i++;
         } else {
-          while (textline[i] != ' ' && textline[i] != '\t' && textline[i] != '\n')
+          while (textline[i] != ' ' && textline[i] != '\t' && textline[i] != '\n' && i<textpos)
             *(cp++) = textline[i++];
         }
         *(cp++) = '\0';
         cp = malloc (textpos);
+        if ( cp == NULL )
+          pm_error("out of memory");
         info_ptr->text[j].text = cp;
-        while (textline[i] == ' ' || textline[i] == '\t')
+        while ((textline[i] == ' ' || textline[i] == '\t') && i<textpos)
           i++;
         strcpy (cp, &textline[i]);
         info_ptr->text[j].text_length = strlen (cp);
         j++;
       } else {
         j--;
+        if ( info_ptr->text[j].text_length + textpos <= 0 )
+          pm_error("allocation underflow");
         cp = malloc (info_ptr->text[j].text_length + textpos);
+        if ( cp == NULL )
+          pm_error("out of memory");
         strcpy (cp, info_ptr->text[j].text);
         strcat (cp, "\n");
         info_ptr->text[j].text = cp;
         i = 0;
-        while (textline[i] == ' ' || textline[i] == '\t')
+        while ((textline[i] == ' ' || textline[i] == '\t') && i<textpos)
         i++;
         strcat (cp, &textline[i]);
         info_ptr->text[j].text_length = strlen (cp);
@@ -572,8 +582,8 @@
   int alpha_rows;
   int alpha_cols;
   int alpha_can_be_transparency_index;
-  gray *alphas_of_color[MAXCOLORS];
-  int alphas_of_color_cnt[MAXCOLORS];
+  gray *alphas_of_color[MAXCOLORS+1];
+  int alphas_of_color_cnt[MAXCOLORS+1];
   int alphas_first_index[MAXCOLORS+1];
   int mapping[MAXCOLORS];
   int colors;
diff -ruN netpbm-9.25-orig/pnm/pnmtopng.c.orig netpbm-9.25/pnm/pnmtopng.c.orig
--- netpbm-9.25-orig/pnm/pnmtopng.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ netpbm-9.25/pnm/pnmtopng.c.orig	2011-07-23 13:57:22.000000000 +0200
@@ -0,0 +1,1558 @@
+/*
+** pnmtopng.c -
+** read a portable anymap and produce a Portable Network Graphics file
+**
+** derived from pnmtorast.c (c) 1990,1991 by Jef Poskanzer and some
+** parts derived from ppmtogif.c by Marcel Wijkstra <wijkstra@fwi.uva.nl>
+** thanks to Greg Roelofs <newt@pobox.com> for contributions and bug-fixes
+**
+** Copyright (C) 1995-1998 by Alexander Lehmann <alex@hal.rhein-main.de>
+**                        and Willem van Schaik <willem@schaik.com>
+**
+** Permission to use, copy, modify, and distribute this software and its
+** documentation for any purpose and without fee is hereby granted, provided
+** that the above copyright notice appear in all copies and that both that
+** copyright notice and this permission notice appear in supporting
+** documentation.  This software is provided "as is" without express or
+** implied warranty.
+*/
+
+/* A performance note: This program reads one row at a time because
+   the whole image won't fit in memory always.  When you realize that
+   in a Netpbm xel array a one bit pixel can take 96 bits of memory,
+   it's easy to see that an ordinary fax could deplete your virtual
+   memory and even if it didn't, it might deplete your real memory and
+   iterating through the array would cause thrashing.  This program
+   iterates through the image multiple times.  
+
+   So instead, we read the image into memory one row at a time, into a
+   single row buffer.  We use Netpbm's pm_openr_seekable() facility to
+   access the file.  That facility copies the file into a temporary
+   file if it isn't seekable, so we always end up with a file that we
+   can rewind and reread multiple times.
+
+   This shouldn't cause I/O delays because the entire image ought to fit
+   in the system's I/O cache (remember that the file is a lot smaller that
+   the xel array you'd get by doing a pnm_pnmread() of it).
+
+   However, it does introduce some delay because of all the system calls 
+   required to read the file.  A future enhancement might read the entire
+   file into an xel array in some cases, and read one row at a time in 
+   others, depending on the needs of the particular use.
+
+   We do still read the entire alpha mask (if there is one) into a
+   'gray' array, rather than access it one row at a time.  
+
+   Before May 2001, we did in fact read the whole image into an xel array,
+   and we got complaints.  Before April 2000, it wasn't as big a problem
+   because xels were only 8 bits.  Now they're 32.
+*/
+   
+/* GRR 20000930:  fixed bug reported by Steven Grady <grady@xcf.berkeley.edu>:
+ *  if -transparent option given but exact color does not exist (e.g., when
+ *  doing batch conversion of a web site), pnmtopng would pick an approximate
+ *  color instead of ignoring the transparency.  Also added 2 (== warning)
+ *  return code for such cases.  (1 already used by pm_error().) */
+
+/* GRR 20000315:  ifdef'd out a never-reached (for non-PGM_BIGGRAYS) case
+ *  that causes a gcc warning. */
+
+/* GRR 19991203:  incorporated fix by Rafal Rzeczkowski <rzeczkrg@mcmaster.ca>:
+ *  gray images with exactly 16 shades were being to 8-bit grayscale rather
+ *  than 4-bit palette due to misuse of the pm_maxvaltobits() function.  Also
+ *  moved VERSION to new version.h header file. */
+
+/* GRR 19990713:  fixed redundant freeing of png_ptr and info_ptr in setjmp()
+ *  blocks and added png_destroy_write_struct() and pm_close(ifp) in each
+ *  pm_error() block.  */
+
+/* GRR 19990308:  declared "clobberable" automatic variables in convertpnm()
+ *  static to fix Solaris/gcc stack-corruption bug.  Also installed custom
+ *  error-handler to avoid jmp_buf size-related problems (i.e., jmp_buf
+ *  compiled with one size in libpng and another size here).  */
+
+/* GRR 19980621:  moved some if-tests out of full-image loops; added fix for
+ *  following problem discovered by Magnus Holmgren and debugged by Glenn:
+ *
+ *    The pnm has three colors:  0 0 0, 204 204 204, and 255 255 255.
+ *    These were apparently scaled to 0 0 0, 12 12 12, and 15 15 15.
+ *    That would have been OK if the file had been written as color-type
+ *    0 (grayscale), but it was written as an indexed-color file, in
+ *    which the colors from the pnm file should have been used rather
+ *    than the scaled colors.  What appears in the PLTE chunk is
+ *    0 0 0, 12 12 12, and 15 15 15, which of course results in a
+ *    very dark image.
+ *
+ *  (temporarily ifdef'd for easier inspection and before/after testing)
+ */
+#define GRR_GRAY_PALETTE_FIX
+
+#ifndef PNMTOPNG_WARNING_LEVEL
+#  define PNMTOPNG_WARNING_LEVEL 0   /* use 0 for backward compatibility, */
+#endif                               /*  2 for warnings (1 == error) */
+
+#include <string.h>	/* strcat() */
+#include <png.h>	/* includes zlib.h and setjmp.h */
+#define VERSION "2.37.5 (24 October 2000) +netpbm"
+#include "pnm.h"
+
+#include "ppmcmap.h"
+
+typedef struct _jmpbuf_wrapper {
+  jmp_buf jmpbuf;
+} jmpbuf_wrapper;
+
+/* GRR 19991205:  this is used as a test for pre-1999 versions of netpbm and
+ *   pbmplus vs. 1999 or later (in which pm_close was split into two) 
+ */
+#ifdef PBMPLUS_RAWBITS
+#  define pm_closer pm_close
+#  define pm_closew pm_close
+#endif
+
+#ifndef TRUE
+#  define TRUE 1
+#endif
+#ifndef FALSE
+#  define FALSE 0
+#endif
+#ifndef NONE
+#  define NONE 0
+#endif
+#define MAXCOLORS 256
+#define MAXCOMMENTS 256
+
+/* function prototypes */
+#ifdef __STDC__
+static int closestcolor (pixel color, colorhist_vector chv, int colors,
+                         xelval maxval);
+static void read_text (png_info *info_ptr, FILE *tfp);
+static void pnmtopng_error_handler (png_structp png_ptr, png_const_charp msg);
+static int convertpnm (FILE *ifp, FILE *afp, FILE *tfp);
+int main (int argc, char *argv[]);
+#endif
+
+static int verbose = FALSE;
+static int interlace = FALSE;
+static int downscale = FALSE;
+static int transparent = -1;
+static char *transstring;
+static int alpha = FALSE;
+static char *alpha_file;
+static int background = -1;
+static char *backstring;
+static float gamma = -1.0;
+static int hist = FALSE;
+static float chroma_wx = -1.0;
+static float chroma_wy = -1.0;
+static float chroma_rx = -1.0;
+static float chroma_ry = -1.0;
+static float chroma_gx = -1.0;
+static float chroma_gy = -1.0;
+static float chroma_bx = -1.0;
+static float chroma_by = -1.0;
+static int phys_x = -1.0;
+static int phys_y = -1.0;
+static int phys_unit = -1.0;
+static int text = FALSE;
+static int ztxt = FALSE;
+static char *text_file;
+static int mtime = FALSE;
+static char *date_string;
+static char *time_string;
+static struct tm time_struct;
+static int filter = -1;
+static int compression = -1;
+static int force = FALSE;
+static jmpbuf_wrapper pnmtopng_jmpbuf_struct;
+
+#ifdef __STDC__
+static int closestcolor (pixel color, colorhist_vector chv, int colors, xelval maxval)
+#else
+static int closestcolor (color, chv, colors, maxval)
+pixel color;
+colorhist_vector chv;
+int colors;
+xelval maxval;
+#endif
+{
+  int i, r, g, b, d;
+  int imin, dmin;
+
+  r = (int)PPM_GETR (color) * 255 / maxval;
+  g = (int)PPM_GETG (color) * 255 / maxval;
+  b = (int)PPM_GETB (color) * 255 / maxval;
+
+  imin = 0;
+  dmin = 1000000;
+  for (i = 0 ; i < colors ; i++) {
+    d = (r - PPM_GETR (chv[i].color)) * (r - PPM_GETR (chv[i].color))+
+        (g - PPM_GETG (chv[i].color)) * (g - PPM_GETG (chv[i].color))+
+        (b - PPM_GETB (chv[i].color)) * (b - PPM_GETB (chv[i].color));
+    if (d < dmin) {
+      dmin = d;
+      imin = i;
+    }
+  }
+  return imin;
+}
+
+#ifdef __STDC__
+static void read_text (png_info *info_ptr, FILE *tfp)
+#else
+static void read_text (info_ptr, tfp)
+png_info *info_ptr;
+FILE *tfp;
+#endif
+{
+#define MAXLINE 1024
+  char textline[MAXLINE];
+  int textpos;
+  int i, j;
+  int c;
+  char *cp;
+
+  /* GRR:  need to check for malloc failure here */
+  info_ptr->text = (png_text *)malloc (MAXCOMMENTS * sizeof (png_text));
+  j = 0;
+  textpos = 0;
+  while ((c = getc (tfp)) != EOF) {
+    if (c != '\n' && c != EOF) {
+      if (textpos >= MAXLINE) continue;
+      textline[textpos++] = c;
+    } else {
+      textline[textpos++] = '\0';
+      if ((textline[0] != ' ') && (textline[0] != '\t')) {
+        /* the following is a not that accurate check on Author or Title */
+        if ((!ztxt) || (textline[0] == 'A') || (textline[0] == 'T'))
+          info_ptr->text[j].compression = -1;
+        else
+          info_ptr->text[j].compression = 0;
+        cp = malloc (textpos);
+        if ( cp == NULL )
+          pm_error("out of memory");
+        info_ptr->text[j].key = cp;
+        i = 0;
+        if (textline[0] == '"') {
+          i++;
+          while (textline[i] != '"' && textline[i] != '\n' && i<textpos)
+            *(cp++) = textline[i++];
+          i++;
+        } else {
+          while (textline[i] != ' ' && textline[i] != '\t' && textline[i] != '\n' && i<textpos)
+            *(cp++) = textline[i++];
+        }
+        *(cp++) = '\0';
+        cp = malloc (textpos);
+        if ( cp == NULL )
+          pm_error("out of memory");
+        info_ptr->text[j].text = cp;
+        while ((textline[i] == ' ' || textline[i] == '\t') && i<textpos)
+          i++;
+        strcpy (cp, &textline[i]);
+        info_ptr->text[j].text_length = strlen (cp);
+        j++;
+      } else {
+        j--;
+        if ( info_ptr->text[j].text_length + textpos <= 0 )
+          pm_error("allocation underflow");
+        cp = malloc (info_ptr->text[j].text_length + textpos);
+        if ( cp == NULL )
+          pm_error("out of memory");
+        strcpy (cp, info_ptr->text[j].text);
+        strcat (cp, "\n");
+        info_ptr->text[j].text = cp;
+        i = 0;
+        while ((textline[i] == ' ' || textline[i] == '\t') && i<textpos)
+        i++;
+        strcat (cp, &textline[i]);
+        info_ptr->text[j].text_length = strlen (cp);
+        j++;
+      }
+      textpos = 0;
+    }
+  } /* end while */
+  info_ptr->num_text = j;
+}
+
+#ifdef __STDC__
+static void pnmtopng_error_handler (png_structp png_ptr, png_const_charp msg)
+#else
+static void pnmtopng_error_handler (png_ptr, msg)
+png_structp png_ptr;
+png_const_charp msg;
+#endif
+{
+  jmpbuf_wrapper  *jmpbuf_ptr;
+
+  /* this function, aside from the extra step of retrieving the "error
+   * pointer" (below) and the fact that it exists within the application
+   * rather than within libpng, is essentially identical to libpng's
+   * default error handler.  The second point is critical:  since both
+   * setjmp() and longjmp() are called from the same code, they are
+   * guaranteed to have compatible notions of how big a jmp_buf is,
+   * regardless of whether _BSD_SOURCE or anything else has (or has not)
+   * been defined. */
+
+  fprintf(stderr, "pnmtopng:  fatal libpng error: %s\n", msg);
+  fflush(stderr);
+
+  jmpbuf_ptr = png_get_error_ptr(png_ptr);
+  if (jmpbuf_ptr == NULL) {         /* we are completely hosed now */
+    fprintf(stderr,
+      "pnmtopng:  EXTREMELY fatal error: jmpbuf unrecoverable; terminating.\n");
+    fflush(stderr);
+    exit(99);
+  }
+
+  longjmp(jmpbuf_ptr->jmpbuf, 1);
+}
+
+
+static void
+meaningful_bits_pgm(FILE *         const ifp, 
+                    int            const imagepos, 
+                    int            const cols,
+                    int            const rows,
+                    xelval         const maxval,
+                    int            const format,
+                    unsigned int * const retvalP) {
+/*----------------------------------------------------------------------------
+   In the PGM raster with maxval 'maxval' at file offset 'imagepos'
+   in file 'ifp', the samples may be composed of groups of 1, 2, 4, or 8
+   bits repeated.  This would be the case if the image were converted
+   at some point from a 2 bits-per-pixel image to an 8-bits-per-pixel
+   image, for example.
+
+   If this is the case, we find out and find out how small these repeated
+   groups of bits are and return the number of bits.
+-----------------------------------------------------------------------------*/
+    int mayscale;
+    int x, y;
+    xel * xelrow;
+
+    xelrow = pnm_allocrow(cols);
+
+    *retvalP = pm_maxvaltobits(maxval);
+
+    if (maxval == 65535) {
+        pm_seek(ifp, imagepos);
+        for (y = 0 ; y < rows && mayscale ; y++) {
+            pnm_readpnmrow(ifp, xelrow, cols, maxval, format);
+            for (x = 0 ; x < cols && mayscale ; x++) {
+                xel const p = xelrow[x];
+                if ( (PNM_GET1 (p)&0xff)*0x101 != PNM_GET1 (p) )
+                    mayscale = FALSE;
+            }
+        }
+        if (mayscale)
+            *retvalP = 8;
+    }
+    if (maxval == 255 || *retvalP == 8) {
+        mayscale = TRUE;
+        pm_seek(ifp, imagepos);
+        for (y = 0 ; y < rows && mayscale ; y++) {
+            pnm_readpnmrow(ifp, xelrow, cols, maxval, format);
+            for (x = 0 ; x < cols && mayscale ; x++) {
+                if ((PNM_GET1 (xelrow[x]) & 0xf) * 0x11 
+                    != PNM_GET1 (xelrow[x]))
+                    mayscale = FALSE;
+            }
+        }
+        if (mayscale)
+            *retvalP = 4;
+    }
+
+    if (maxval == 15 || *retvalP == 4) {
+        mayscale = TRUE;
+        pm_seek(ifp, imagepos);
+        for (y = 0 ; y < rows && mayscale ; y++) {
+            pnm_readpnmrow(ifp, xelrow, cols, maxval, format);
+            for (x = 0 ; x < cols && mayscale ; x++) {
+                if ((PNM_GET1 (xelrow[x])&3) * 0x5 != PNM_GET1 (xelrow[x]))
+                    mayscale = FALSE;
+            }
+        }
+        if (mayscale) {
+            *retvalP = 2;
+        }
+    }
+
+    if (maxval == 3 || *retvalP == 2) {
+        mayscale = TRUE;
+        pm_seek(ifp, imagepos);
+        for (y = 0 ; y < rows && mayscale ; y++) {
+            pnm_readpnmrow(ifp, xelrow, cols, maxval, format);
+            for (x = 0 ; x < cols && mayscale ; x++) {
+                if ((PNM_GET1 (xelrow[x])&1) * 0x3 != PNM_GET1 (xelrow[x]))
+                    mayscale = FALSE;
+            }
+        }
+        if (mayscale) {
+            *retvalP = 1;
+        }
+    }
+    pnm_freerow(xelrow);
+}
+
+
+static void
+meaningful_bits_ppm(FILE *         const ifp, 
+                    int            const imagepos, 
+                    int            const cols,
+                    int            const rows,
+                    xelval         const maxval,
+                    int            const format,
+                    unsigned int * const retvalP) {
+/*----------------------------------------------------------------------------
+   In the PPM raster with maxval 'maxval' at file offset 'imagepos'
+   in file 'ifp', the samples may be composed of groups of 8
+   bits repeated twice.  This would be the case if the image were converted
+   at some point from a 8 bits-per-pixel image to an 16-bits-per-pixel
+   image, for example.
+
+   We return the smallest number of bits we can take from the right of
+   a sample without losing information (8 or all).
+-----------------------------------------------------------------------------*/
+    int mayscale;
+    int x, y;
+    xel * xelrow;
+
+    xelrow = pnm_allocrow(cols);
+
+    *retvalP = pm_maxvaltobits(maxval);
+
+    if (maxval == 65535) {
+        pm_seek(ifp, imagepos);
+        for (y = 0 ; y < rows && mayscale ; y++) {
+            pnm_readpnmrow(ifp, xelrow, cols, maxval, format);
+            for (x = 0 ; x < cols && mayscale ; x++) {
+                xel const p = xelrow[x];
+                if ( (PPM_GETR (p)&0xff)*0x101 != PPM_GETR (p) ||
+                     (PPM_GETG (p)&0xff)*0x101 != PPM_GETG (p) ||
+                     (PPM_GETB (p)&0xff)*0x101 != PPM_GETB (p) )
+                    mayscale = FALSE;
+            }
+        }
+        if (mayscale)
+            *retvalP = 8;
+    }
+    pnm_freerow(xelrow);
+}
+
+
+
+static void
+alpha_trans(FILE *  const ifp, 
+            int     const imagepos, 
+            int     const cols, 
+            int     const rows, 
+            pixval  const maxval, int const format, 
+            gray ** const alpha_mask, gray alpha_maxval,
+            bool *  const alpha_can_be_transparency_indexP, 
+            pixel*  const alpha_transcolorP) {
+/*----------------------------------------------------------------------------
+  Check if the alpha mask can be represented by a single transparency
+  value (i.e. all colors fully opaque except one fully transparent;
+  the transparent color may not also occur as fully opaque.
+  we have to do this before any scaling occurs, since alpha is only
+  possible with 8 and 16-bit.
+-----------------------------------------------------------------------------*/
+    xel * xelrow;
+    bool retval;
+        /* Our eventual return value -- alpha mask can be represented by
+           a simple transparency index.
+        */
+    bool found_transparent_pixel;
+        /* We found a pixel in the image where the alpha mask says it is
+           transparent.
+        */
+    pixel transcolor;
+        /* Color of the transparent pixel mentioned above. */
+    int const pnm_type = PNM_FORMAT_TYPE(format);
+    
+    xelrow = pnm_allocrow(cols);
+
+    {
+        int row;
+        /* Find a candidate transparent color -- the color of any pixel in the
+           image that the alpha mask says should be transparent.
+        */
+        found_transparent_pixel = FALSE;  /* initial assumption */
+        pm_seek(ifp, imagepos);
+        for (row = 0 ; row < rows && !found_transparent_pixel ; ++row) {
+            int col;
+            pnm_readpnmrow(ifp, xelrow, cols, maxval, format);
+            for (col = 0 ; col < cols && !found_transparent_pixel; ++col) {
+                if (alpha_mask[row][col] == 0) {
+                    found_transparent_pixel = TRUE;
+                    transcolor = xeltopixel(xelrow[col]);
+                }
+            }
+        }
+    }
+
+    if (found_transparent_pixel) {
+        int row;
+        pm_seek(ifp, imagepos);
+        retval = TRUE;  /* initial assumption */
+        
+        for (row = 0 ; row < rows && retval == TRUE; ++row) {
+            int col;
+            pnm_readpnmrow(ifp, xelrow, cols, maxval, format);
+            for (col = 0 ; col < cols && retval == TRUE; ++col) {
+                if (alpha_mask[row][col] == 0) { /* transparent */
+                    /* If we have a second transparent color, we're
+                       disqualified
+                    */
+                    if (pnm_type == PPM_TYPE) {
+                        if (!PPM_EQUAL (xelrow[col], transcolor))
+                            retval = FALSE;
+                    } else {
+                        if (PNM_GET1 (xelrow[col]) != PNM_GET1 (transcolor))
+                            retval = FALSE;
+                    }
+                } else if (alpha_mask[row][col] != alpha_maxval) {
+                    /* Here's an area of the mask that is translucent.  That
+                       disqualified us.
+                    */
+                    retval = FALSE;
+                } else 
+                    /* Here's an area of the mask that is opaque.  If it's
+                       the same color as our candidate transparent color,
+                       that disqualifies us.
+                    */
+                    if (pnm_type == PPM_TYPE) {
+                        if (PPM_EQUAL (xelrow[col], transcolor))
+                            retval = FALSE;
+                    } else {
+                        if (PNM_GET1 (xelrow[col]) == PNM_GET1 (transcolor))
+                            retval = FALSE;
+                    }
+            }
+        }  
+    }
+    pnm_freerow(xelrow);
+
+    *alpha_can_be_transparency_indexP = retval;
+    *alpha_transcolorP = transcolor;
+}
+
+
+
+#ifdef __STDC__
+static int convertpnm (FILE *ifp, FILE *afp, FILE *tfp)
+#else
+static int convertpnm (ifp, afp, tfp)
+    FILE *ifp, *afp, *tfp;
+#endif
+{
+  xel p;	/*        (pnm.h)                  (ppm.h)  */
+  int rows, cols, format;
+  xelval maxval;
+      /* The maxval of the input image */
+  xelval png_maxval;
+      /* The maxval of the samples in the PNG output 
+         (must be 1, 3, 7, 15, 255, or 65535)
+      */
+  pixel transcolor;
+      /* The color that is to be transparent, with maxval equal to that
+         of the input image.
+      */
+  int transexact;  
+    /* boolean: the user wants only the exact color he specified to be
+       transparent; not just something close to it.
+    */
+  xelval pnm_meaningful_bits;
+  pixel backcolor;
+      /* The background color, with maxval equal to that of the input
+         image.
+      */
+  png_struct *png_ptr;
+  png_info *info_ptr;
+
+  png_color palette[MAXCOLORS];
+  png_byte trans[MAXCOLORS];
+  png_uint_16 histogram[MAXCOLORS];
+  png_byte *line;
+  png_byte *pp;
+  int pass;
+  int color;
+  gray alpha_maxval;
+  int alpha_rows;
+  int alpha_cols;
+  int alpha_can_be_transparency_index;
+  gray *alphas_of_color[MAXCOLORS];
+  int alphas_of_color_cnt[MAXCOLORS];
+  int alphas_first_index[MAXCOLORS+1];
+  int mapping[MAXCOLORS];
+  int colors;
+  int fulldepth;
+      /* The total number of bits per pixel, including all channels */
+  int x, y;
+  int i, j;
+  int imagepos;  
+      /* file position in input image file of start of image (i.e. after
+         the header)
+      */
+  xel *xelrow;    /* malloc'ed */
+      /* The row of the input image currently being processed */
+
+  /* these variables are declared static because gcc wasn't kidding
+   * about "variable XXX might be clobbered by `longjmp' or `vfork'"
+   * (stack corruption observed on Solaris 2.6 with gcc 2.8.1, even
+   * in the absence of any other error condition) */
+  static int pnm_type;
+  static xelval maxmaxval;
+  static gray **alpha_mask;
+  static int num_alphas_of_color;
+  static int palette_size;
+  static colorhist_vector chv;
+  static colorhash_table cht;
+  static int depth;
+  static int errorlevel;
+  
+
+  /* these guys are initialized to quiet compiler warnings: */
+  maxmaxval = 255;
+  num_alphas_of_color = 0;
+  alpha_mask = NULL;
+  palette_size = 0;
+  cht = NULL;
+  depth = 0;
+  errorlevel = 0;
+
+  png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING,
+    &pnmtopng_jmpbuf_struct, pnmtopng_error_handler, NULL);
+  if (png_ptr == NULL) {
+    pm_closer (ifp);
+    pm_error ("cannot allocate LIBPNG structure");
+  }
+
+  info_ptr = png_create_info_struct (png_ptr);
+  if (info_ptr == NULL) {
+    png_destroy_write_struct (&png_ptr, (png_infopp)NULL);
+    pm_closer (ifp);
+    pm_error ("cannot allocate LIBPNG structures");
+  }
+
+  if (setjmp (pnmtopng_jmpbuf_struct.jmpbuf)) {
+    png_destroy_write_struct (&png_ptr, &info_ptr);
+    pm_closer (ifp);
+    pm_error ("setjmp returns error condition (1)");
+  }
+
+  pnm_readpnminit (ifp, &cols, &rows, &maxval, &format);
+  imagepos = pm_tell(ifp);
+  pnm_type = PNM_FORMAT_TYPE (format);
+
+  xelrow = pnm_allocrow(cols);
+
+  if (verbose) {
+    if (pnm_type == PBM_TYPE)    
+      pm_message ("reading a PBM file (maxval=%d)", maxval);
+    else if (pnm_type == PGM_TYPE)    
+      pm_message ("reading a PGM file (maxval=%d)", maxval);
+    else if (pnm_type == PPM_TYPE)    
+      pm_message ("reading a PPM file (maxval=%d)", maxval);
+  }
+
+  if (pnm_type == PGM_TYPE)
+    maxmaxval = PGM_OVERALLMAXVAL;
+  else if (pnm_type == PPM_TYPE)
+    maxmaxval = PPM_OVERALLMAXVAL;
+
+  if (transparent > 0) {  /* -1 or 1 are the only possibilities so far */
+    char * transstring2;  
+      /* Same as transstring, but with possible leading '=' removed */
+    if (transstring[0] == '=') {
+      transexact = 1;
+      transstring2 = transstring+1;
+    } else {
+      transexact = 0;
+      transstring2 = transstring;
+    }  
+    /* We do this funny PPM_DEPTH thing instead of just passing 'maxval'
+       to ppm_parsecolor() because ppm_parsecolor() does a cheap maxval
+       scaling, and this is more precise.
+    */
+    PPM_DEPTH (transcolor, ppm_parsecolor(transstring2, maxmaxval),
+               maxmaxval, maxval);
+  }
+  if (alpha) {
+    pixel alpha_transcolor;
+
+    alpha_mask = pgm_readpgm (afp, &alpha_cols, &alpha_rows, &alpha_maxval);
+    if (alpha_cols != cols || alpha_rows != rows) {
+      png_destroy_write_struct (&png_ptr, &info_ptr);
+      pm_closer (ifp);
+      pm_error ("dimensions for image and alpha mask do not agree");
+    }
+    alpha_trans(ifp, imagepos, cols, rows, maxval, format, 
+                alpha_mask, alpha_maxval,
+                &alpha_can_be_transparency_index, &alpha_transcolor);
+
+    if (alpha_can_be_transparency_index && !force) {
+      if (verbose)
+        pm_message ("converting alpha mask to transparency index");
+      alpha = FALSE;
+      transparent = 2;
+      transcolor = alpha_transcolor;
+    } else {
+      transparent = -1;
+    }
+  }
+
+  /* gcc 2.7.0 -fomit-frame-pointer causes stack corruption here */
+  if (background > -1) 
+      PPM_DEPTH(backcolor, ppm_parsecolor (backstring, maxmaxval), 
+                maxmaxval, maxval);;
+
+  /* first of all, check if we have a grayscale image written as PPM */
+
+  if (pnm_type == PPM_TYPE && !force) {
+    int isgray = TRUE;
+
+    pm_seek(ifp, imagepos);
+    for (y = 0 ; y < rows && isgray ; y++) {
+      pnm_readpnmrow(ifp, xelrow, cols, maxval, format);
+      for (x = 0 ; x < cols && isgray ; x++) {
+        p = xelrow[x];
+        if (PPM_GETR (p) != PPM_GETG (p) || PPM_GETG (p) != PPM_GETB (p))
+          isgray = FALSE;
+      }
+    }
+    if (isgray)
+      pnm_type = PGM_TYPE;
+  }
+
+  /* handle `odd' maxvalues */
+
+    if (maxval > 65535 && !downscale) {
+      png_destroy_write_struct (&png_ptr, &info_ptr);
+      pm_closer (ifp);
+      pm_error ("can only handle files up to 16-bit (use -downscale to override");
+    }
+
+  /* Find out if we can mask off redundant (repeated) bits in sample values */
+
+  if (!alpha && pnm_type == PGM_TYPE && !force) 
+      meaningful_bits_pgm(ifp, imagepos, cols, rows, maxval, format,
+                          &pnm_meaningful_bits);
+  else if (pnm_type == PPM_TYPE && !force)
+      meaningful_bits_ppm(ifp, imagepos, cols, rows, maxval, format,
+                          &pnm_meaningful_bits);
+  else 
+      pnm_meaningful_bits = pm_maxvaltobits(maxval);
+
+  if (verbose && pnm_meaningful_bits != pm_maxvaltobits(maxval))
+      pm_message("Using only %d rightmost bits of input samples.  The "
+                 "rest are just copies of those.", pnm_meaningful_bits);
+
+  /* 
+     We can write a palette file if maxval <= 255 and one of the following is
+     true:
+       - for ppm files if we have <= 256 colors
+       - for alpha if we have <= 256 color/transparency pairs
+       - for pgm files (with or without alpha) if the number of bits needed for
+         the gray-transparency pairs is smaller than the number of bits needed
+         for maxval
+     When maxval > 255, we never write a paletted image.
+  */
+
+  if ((!force) && (pnm_type != PBM_TYPE) && (maxval <= 255)) {
+    if (verbose) {
+      pm_message ("computing colormap...");
+    }
+    pm_seek(ifp, imagepos);
+    chv = ppm_computecolorhist2 (ifp, cols, rows, maxval, format, 
+                                 MAXCOLORS, &colors);
+    if (verbose) {
+      if (chv)
+          pm_message ("%d colors found", colors);
+      else
+          pm_message ("More than %d colors found", MAXCOLORS);
+    }
+    /* RR:  note that if colors == 16, maxval == 15 (i.e., range == 0-15) */
+    if ((chv == (colorhist_vector) NULL) ||    /* GRR:      v-- was `=' here */
+        (pnm_type == PGM_TYPE && pm_maxvaltobits(colors-1) > 
+                                (pm_maxvaltobits(maxval) / 2)) ||
+        (pnm_type == PPM_TYPE && maxval > 255)) {
+      chv = NULL;
+      if (verbose) {
+        pm_message ("too many colors for writing a colormapped image");
+      }      
+    }
+
+    if (chv != (colorhist_vector) NULL) {
+
+      if (alpha) {
+        /* now check if there are different alpha values for the same color
+           and if all pairs still fit into 256 (MAXCOLORS) entries; malloc
+           one extra for possible background color */
+        cht = ppm_colorhisttocolorhash (chv, colors);
+        for (i = 0 ; i < colors + 1 ; i++) {
+          if ((alphas_of_color[i] = (gray *)malloc (MAXCOLORS * sizeof (int)))
+              == NULL)
+          {
+            png_destroy_write_struct (&png_ptr, &info_ptr);
+            pm_closer (ifp);
+            pm_error ("out of memory allocating alpha/palette entries");
+          }
+          alphas_of_color_cnt[i] = 0;
+        }
+        num_alphas_of_color = colors + 1;
+        pm_seek(ifp, imagepos);
+        for (y = 0 ; y < rows ; y++) {
+          pnm_readpnmrow(ifp, xelrow, cols, maxval, format);
+          pnm_promoteformatrow(xelrow, cols, maxval, format, maxval, PPM_TYPE);
+          for (x = 0 ; x < cols ; x++) {
+            color = ppm_lookupcolor (cht, &xelrow[x]);
+            for (i = 0 ; i < alphas_of_color_cnt[color] ; i++) {
+              if (alpha_mask[y][x] == alphas_of_color[color][i])
+                break;
+            }
+            if (i == alphas_of_color_cnt[color]) {
+              alphas_of_color[color][i] = alpha_mask[y][x];
+              alphas_of_color_cnt[color]++;
+            }
+          }
+        }
+        alphas_first_index[0] = 0;
+        for (i = 0 ; i < colors ; i++)
+          alphas_first_index[i+1] = alphas_first_index[i] +
+                                    alphas_of_color_cnt[i];
+        if (verbose)
+          pm_message ("number of color/transparency pairs is %d",
+            alphas_first_index[colors]);
+        if (alphas_first_index[colors] > MAXCOLORS) {
+          ppm_freecolorhist (chv);
+          chv = NULL;
+          if (verbose)
+            pm_message (
+              "too many color/transparency pairs, writing a non-mapped file");
+        }
+      } /* if alpha */
+
+      /* add possible background color to palette */
+      if (background > -1) {
+        cht = ppm_colorhisttocolorhash (chv, colors);
+        background = ppm_lookupcolor (cht, &backcolor);
+        if (background == -1) {
+          if ((!alpha && colors < MAXCOLORS) ||
+               (alpha && alphas_first_index[colors] < MAXCOLORS))
+          {
+            background = colors;
+            ppm_addtocolorhist (chv, &colors, MAXCOLORS, &backcolor, colors,
+              colors);
+            if (alpha) {
+              alphas_of_color[background][0] = 255;   /* opaque */
+              alphas_of_color_cnt[background] = 1;    /* unique */
+              alphas_first_index[colors] = alphas_first_index[background] + 1;
+            }
+            if (verbose)
+              pm_message ("added background color to palette");
+          } else {
+            background = closestcolor (backcolor, chv, colors, maxval);
+            errorlevel = PNMTOPNG_WARNING_LEVEL;
+            if (verbose)
+              pm_message ("no room in palette for background color; using closest match instead");
+          }
+        }
+        ppm_freecolorhash (cht);   /* built again about 110 lines below */
+      }
+
+    }
+  } else {
+    chv = NULL;
+  }
+
+  if (chv) {
+    if (alpha)
+      palette_size = alphas_first_index[colors];
+    else
+      palette_size = colors;
+
+    if (palette_size <= 2)
+      depth = 1;
+    else if (palette_size <= 4)
+      depth = 2;
+    else if (palette_size <= 16)
+      depth = 4;
+    else
+      depth = 8;
+    fulldepth = depth;
+    if (verbose)
+      pm_message("Writing %d-bit color indexes", depth);
+  } else {
+    /* truecolor (or grayscale) - not colormapped (paletted) image */
+      if (pnm_type == PPM_TYPE || alpha) {
+          /* PNG allows only depths of 8 and 16 for a truecolor image 
+             and for a grayscale image with an alpha channel.
+          */
+          if (pnm_meaningful_bits > 8)
+              depth = 16;
+          else 
+              depth = 8;
+      } else {
+          /* A grayscale, non-colormapped, no-alpha PNG may have any 
+             bit depth from 1 to 16
+          */
+          if (pnm_meaningful_bits > 8)
+              depth = 16;
+          else if (pnm_meaningful_bits > 4)
+              depth = 8;
+          else if (pnm_meaningful_bits > 2)
+              depth = 4;
+          else if (pnm_meaningful_bits > 1)
+              depth = 2;
+          else
+              depth = 1;
+      }
+    if (alpha) {
+      if (pnm_type == PPM_TYPE)
+        fulldepth = 4 * depth;
+      else
+        fulldepth = 2 * depth;
+    } else {
+      if (pnm_type == PPM_TYPE)
+        fulldepth = 3 * depth;
+      else
+        fulldepth = depth;
+    }
+    if (verbose)
+      pm_message("Writing %d bits per component per pixel", depth);
+  }
+
+  if (verbose)
+    pm_message ("writing a%s %d-bit %s%s file%s",
+                fulldepth == 8 ? "n" : "", fulldepth,
+                chv ? "palette": (pnm_type == PPM_TYPE ? "RGB" : "gray"),
+                alpha ? (chv ? "+transparency" : "+alpha") : "",
+                interlace? " (interlaced)" : "");
+
+  /* now write the file */
+
+  if (setjmp (pnmtopng_jmpbuf_struct.jmpbuf)) {
+    png_destroy_write_struct (&png_ptr, &info_ptr);
+    pm_closer (ifp);
+    pm_error ("setjmp returns error condition (2)");
+  }
+
+#ifdef OLDPNG
+  png_write_init (png_ptr);
+  png_info_init (info_ptr);
+#endif
+  png_init_io (png_ptr, stdout);
+  info_ptr->width = cols;
+  info_ptr->height = rows;
+  info_ptr->bit_depth = depth;
+
+  if (chv != NULL)
+    info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
+  else if (pnm_type == PPM_TYPE)
+    info_ptr->color_type = PNG_COLOR_TYPE_RGB;
+  else
+    info_ptr->color_type = PNG_COLOR_TYPE_GRAY;
+
+  if (alpha && info_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
+    info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
+
+  info_ptr->interlace_type = interlace;
+
+  /* gAMA chunk */
+  if (gamma != -1.0) {
+    info_ptr->valid |= PNG_INFO_gAMA;
+    info_ptr->gamma = gamma;
+  }
+
+  /* cHRM chunk */
+  if (chroma_wx != -1.0) {
+    info_ptr->valid |= PNG_INFO_cHRM;
+    info_ptr->x_white = chroma_wx;
+    info_ptr->y_white = chroma_wy;
+    info_ptr->x_red = chroma_rx;
+    info_ptr->y_red = chroma_ry;
+    info_ptr->x_green = chroma_gx;
+    info_ptr->y_green = chroma_gy;
+    info_ptr->x_blue = chroma_bx;
+    info_ptr->y_blue = chroma_by;
+  }
+
+  /* pHYS chunk */
+  if (phys_unit != -1.0) {
+    info_ptr->valid |= PNG_INFO_pHYs;
+    info_ptr->x_pixels_per_unit = phys_x;
+    info_ptr->y_pixels_per_unit = phys_y;
+    info_ptr->phys_unit_type = phys_unit;
+  }
+
+  /* PLTE chunk */
+
+  if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+    cht = ppm_colorhisttocolorhash (chv, colors);
+    /* before creating palette figure out the transparent color */
+    if (transparent > 0) {
+      transparent = ppm_lookupcolor (cht, &transcolor);
+      if (transparent == -1) {
+        if (transexact) {
+          pm_message ("specified transparent color not present in palette; "
+                      "ignoring -transparent");
+          errorlevel = PNMTOPNG_WARNING_LEVEL;
+        } else {
+          transparent = closestcolor (transcolor, chv, colors, maxval);
+          transcolor = chv[transparent].color;
+        }
+      } 
+      if (transparent != -1) {
+        /* now put transparent color in entry 0 by swapping */
+        chv[transparent].color = chv[0].color;
+        chv[0].color = transcolor;
+        /* check if background color was by bad luck part of swap */
+        if (background == transparent)
+            background = 0;
+        else if (background == 0)
+            background = transparent;
+        /* rebuild hashtable */
+        ppm_freecolorhash (cht);
+        cht = ppm_colorhisttocolorhash (chv, colors);
+        transparent = 0;
+        trans[0] = 0; /* fully transparent */
+        info_ptr->valid |= PNG_INFO_tRNS;
+        info_ptr->trans = trans;
+        info_ptr->num_trans = 1;
+      }
+    }
+
+    /* creating PNG palette (tRNS *not* yet valid) */
+    /* Note that while the PNM image, and thus chv and cht may have
+       any maxval, the "maxval" of the PNG palette is always 255.
+    */
+    if (alpha) {
+      int bot_idx = 0;
+      int top_idx = alphas_first_index[colors] - 1;
+
+      /* remap palette indices so opaque entries are last (omittable) */
+      for (i = 0;  i < colors;  ++i) {
+        for (j = alphas_first_index[i];  j < alphas_first_index[i+1];  ++j) {
+          if (alphas_of_color[i][j-alphas_first_index[i]] == 255)
+            mapping[j] = top_idx--;
+          else
+            mapping[j] = bot_idx++;
+        }
+      }
+      /* indices should have just crossed paths */
+      if (bot_idx != top_idx + 1) {
+        png_destroy_write_struct (&png_ptr, &info_ptr);
+        pm_closer (ifp);
+        pm_error ("internal inconsistency: remapped bot_idx = %d, top_idx = %d",
+          bot_idx, top_idx);
+      }
+      for (i = 0 ; i < colors ; i++) {
+        for (j = alphas_first_index[i] ; j < alphas_first_index[i+1] ; j++) {
+          pixel p;
+          PPM_DEPTH(p, chv[i].color, maxval, 255);
+          palette[mapping[j]].red   = PPM_GETR (p);
+          palette[mapping[j]].green = PPM_GETG (p);
+          palette[mapping[j]].blue  = PPM_GETB (p);
+          trans[mapping[j]] = alphas_of_color[i][j-alphas_first_index[i]];
+        }
+      }
+      info_ptr->valid |= PNG_INFO_tRNS;
+      info_ptr->trans = trans;
+      info_ptr->num_trans = bot_idx;   /* omit opaque values */
+      pm_message ("writing %d non-opaque transparency values", bot_idx);
+    } else {
+      for (i = 0 ; i < MAXCOLORS ; i++) {
+          pixel p;
+          PPM_DEPTH(p, chv[i].color, maxval, 255);
+          palette[i].red = PPM_GETR (p);
+          palette[i].green = PPM_GETG (p);
+          palette[i].blue = PPM_GETB (p);
+      }
+    }
+    info_ptr->valid |= PNG_INFO_PLTE;
+    info_ptr->palette = palette;
+    info_ptr->num_palette = palette_size;
+
+    /* creating hIST chunk */
+    if (hist) {
+      for (i = 0 ; i < MAXCOLORS ; i++)
+        histogram[i] = chv[i].value;
+      info_ptr->valid |= PNG_INFO_hIST;
+      info_ptr->hist = histogram;
+      if (verbose)
+        pm_message ("histogram created");
+    }
+    ppm_freecolorhist (chv);
+
+  } else { /* color_type != PNG_COLOR_TYPE_PALETTE */
+    pixel png_transcolor;
+        /* Same as 'transcolor', only based on the maxval that is used in
+           the samples we send to the PNG compressor instead of the maxval
+           of the samples we get from the PNM input.
+        */
+
+    PPM_DEPTH(png_transcolor, transcolor, maxval, pm_bitstomaxval(depth));
+
+    if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY) {
+      if (transparent > 0) {
+        info_ptr->valid |= PNG_INFO_tRNS;
+        info_ptr->trans_values.gray = PNM_GET1 (png_transcolor);
+      }
+    } else
+    if (info_ptr->color_type == PNG_COLOR_TYPE_RGB) {
+      if (transparent > 0) {
+        info_ptr->valid |= PNG_INFO_tRNS;
+        info_ptr->trans_values.red =   PPM_GETR (png_transcolor);
+        info_ptr->trans_values.green = PPM_GETG (png_transcolor);
+        info_ptr->trans_values.blue =  PPM_GETB (png_transcolor);
+      }
+    } else {
+        /* This is PNG_COLOR_MASK_ALPHA.  Transparency will be handled
+           by the alpha channel, not a transparency color.
+        */
+    }
+    if (verbose) {
+        if (info_ptr->valid && PNG_INFO_tRNS) 
+            pm_message("Transparent color {gray, red, green, blue} = "
+                       "{%d, %d, %d, %d}",
+                       info_ptr->trans_values.gray,
+                       info_ptr->trans_values.red,
+                       info_ptr->trans_values.green,
+                       info_ptr->trans_values.blue);
+        else
+            pm_message("No transparent color");
+    }
+  }
+  /* bKGD chunk */
+  if (background > -1) {
+    info_ptr->valid |= PNG_INFO_bKGD;
+    if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+      if (alpha)
+        info_ptr->background.index = mapping[alphas_first_index[background]];
+      else
+        info_ptr->background.index = background;
+    } else {
+      pixel png_backcolor;
+      /* Same as 'backcolor', only based on the maxval that is used in
+         the samples we send to the PNG compressor instead of the maxval
+         of the samples we get from the PNM input.
+      */
+
+     PPM_DEPTH(png_backcolor, backcolor, maxval, pm_bitstomaxval(depth));
+     if (info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
+        info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
+      info_ptr->background.red =   PPM_GETR (png_backcolor);
+      info_ptr->background.green = PPM_GETG (png_backcolor);
+      info_ptr->background.blue =  PPM_GETB (png_backcolor);
+    } else
+    if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
+        info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {
+      info_ptr->background.gray = PNM_GET1 (png_backcolor);
+    }
+     if (verbose)
+         pm_message("Writing bKGD chunk with background color "
+                    " {gray, red, green, blue} = {%d, %d, %d, %d}",
+                    info_ptr->background.gray, 
+                    info_ptr->background.red, 
+                    info_ptr->background.green, 
+                    info_ptr->background.blue ); 
+  }
+  }
+
+  if (!chv && (pm_bitstomaxval(depth) != maxval || 
+               (alpha && pm_bitstomaxval(depth) != alpha_maxval))) {
+    /* We're writing in a bit depth that doesn't match the maxval of the
+       input image and the alpha mask.  So we write an sBIT chunk to tell
+       what the original image's maxval was.  The sBit chunk doesn't let
+       us specify any maxval -- only powers of two minus one.  So we pick
+       the power of two minus one which is greater than or equal to the
+       actual input maxval.
+    */
+    /* sBIT chunk */
+    int sbitval;
+
+    info_ptr->valid |= PNG_INFO_sBIT;
+
+    sbitval = pm_maxvaltobits(maxval);
+
+    if (info_ptr->color_type & PNG_COLOR_MASK_COLOR) {
+      info_ptr->sig_bit.red   = sbitval;
+      info_ptr->sig_bit.green = sbitval;
+      info_ptr->sig_bit.blue  = sbitval;
+    } else {
+      info_ptr->sig_bit.gray = sbitval;
+    }
+    if (verbose)
+        pm_message("Writing sBIT chunk with sbitval = %d", sbitval);
+
+    if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA) {
+      info_ptr->sig_bit.alpha = pm_maxvaltobits(alpha_maxval);
+    }
+  }
+
+  /* tEXT and zTXT chunks */
+  if ((text) || (ztxt)) {
+    read_text (info_ptr, tfp);
+  }
+
+  /* tIME chunk */
+  if (mtime) {
+    info_ptr->valid |= PNG_INFO_tIME;
+    sscanf (date_string, "%d-%d-%d", &time_struct.tm_year,
+                                     &time_struct.tm_mon,
+                                     &time_struct.tm_mday);
+    if (time_struct.tm_year > 1900)
+      time_struct.tm_year -= 1900;
+    time_struct.tm_mon--; /* tm has monthes 0..11 */
+    sscanf (time_string, "%d:%d:%d", &time_struct.tm_hour,
+                                     &time_struct.tm_min,
+                                     &time_struct.tm_sec);
+    png_convert_from_struct_tm (&info_ptr->mod_time, &time_struct);
+  }
+
+  /* explicit filter-type (or none) required */
+  if ((filter >= 0) && (filter <= 4))
+  {
+    png_set_filter (png_ptr, 0, filter);
+  }
+
+  /* zlib compression-level (or none) required */
+  if ((compression >= 0) && (compression <= 9))
+  {
+    png_set_compression_level (png_ptr, compression);
+  }
+
+  /* write the png-info struct */
+  png_write_info (png_ptr, info_ptr);
+
+  if ((text) || (ztxt))
+    /* prevent from being written twice with png_write_end */
+    info_ptr->num_text = 0;
+
+  if (mtime)
+    /* prevent from being written twice with png_write_end */
+    info_ptr->valid &= ~PNG_INFO_tIME;
+
+  /* let libpng take care of, e.g., bit-depth conversions */
+  png_set_packing (png_ptr);
+
+  /* max: 3 color channels, one alpha channel, 16-bit */
+  if ((line = (png_byte *) malloc (cols*8)) == NULL)
+  {
+    png_destroy_write_struct (&png_ptr, &info_ptr);
+    pm_closer (ifp);
+    pm_error ("out of memory allocating PNG row buffer");
+  }
+
+  png_maxval = pm_bitstomaxval(depth);
+
+  for (pass = 0 ; pass < png_set_interlace_handling (png_ptr) ; pass++) {
+    pm_seek(ifp, imagepos);
+    for (y = 0 ; y < rows ; y++) {
+      pnm_readpnmrow(ifp, xelrow, cols, maxval, format);
+      pnm_promoteformatrow(xelrow, cols, maxval, format, maxval, PPM_TYPE);
+      pp = line;
+      for (x = 0 ; x < cols ; x++) {
+        pixel p, p_png;
+        p = xelrow[x];
+        PPM_DEPTH(p_png, p, maxval, png_maxval);
+        if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
+            info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {
+          if (depth == 16)
+            *pp++ = PNM_GET1 (p_png) >> 8;
+          *pp++ = PNM_GET1 (p_png)&0xff;
+        } else if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+          color = ppm_lookupcolor (cht, &p);
+          if (color == -1)
+              pm_error("Internal error - The color map we made doesn't "
+                       "contain the color of the pixel at row %d col %d): "
+                       "(%d, %d, %d)", y, x,
+                       PPM_GETR(p), PPM_GETG(p), PPM_GETB(p));
+          if (alpha) {
+            for (i = alphas_first_index[color] ;
+                 i < alphas_first_index[color+1] ; i++)
+              if (alpha_mask[y][x] ==
+                  alphas_of_color[color][i - alphas_first_index[color]])
+              {
+                color = mapping[i];
+                break;
+              }
+          }
+          *pp++ = color;
+        } else if (info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
+                   info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
+          if (depth == 16)
+            *pp++ = PPM_GETR (p_png) >> 8;
+          *pp++ = PPM_GETR (p_png)&0xff;
+          if (depth == 16)
+            *pp++ = PPM_GETG (p_png) >> 8;
+          *pp++ = PPM_GETG (p_png)&0xff;
+          if (depth == 16)
+            *pp++ = PPM_GETB (p_png) >> 8;
+          *pp++ = PPM_GETB (p_png)&0xff;
+        } else {
+          png_destroy_write_struct (&png_ptr, &info_ptr);
+          pm_closer (ifp);
+          pm_error (" (can't happen) undefined color_type");
+        }
+        if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA) {
+          int const png_alphaval = 
+              (int) alpha_mask[y][x] * (float) png_maxval / maxval +0.5;
+          if (depth == 16)
+            *pp++ = png_alphaval >> 8;
+          *pp++ = png_alphaval & 0xff;
+        }
+      }
+      png_write_row (png_ptr, line);
+    }
+  }
+  png_write_end (png_ptr, info_ptr);
+
+
+#if 0
+  /* The following code may be intended to solve some segfault problem
+     that arises with png_destroy_write_struct().  The latter is the
+     method recommended in the libpng documentation and this program 
+     will not compile under Cygwin because the Windows DLL for libpng
+     does not contain png_write_destroy() at all.  Since the author's
+     comment below does not make it clear what the segfault issue is,
+     we cannot consider it.  -Bryan 00.09.15
+*/
+
+  png_write_destroy (png_ptr);
+  /* flush first because free(png_ptr) can segfault due to jmpbuf problems
+     in png_write_destroy */
+  fflush (stdout);
+  free (png_ptr);
+  free (info_ptr);
+#else
+  png_destroy_write_struct(&png_ptr, &info_ptr);
+#endif
+
+  for (i = 0 ; i < num_alphas_of_color ; i++)
+    free(alphas_of_color[i]);
+  pnm_freerow(xelrow);
+
+  return errorlevel;
+}
+
+#ifdef __STDC__
+  int main (int argc, char *argv[])
+#else
+  int main (argc, argv)
+  int argc;
+  char *argv[];
+#endif
+{
+  FILE *ifp, *tfp, *afp;
+  int argn, errorlevel=0;
+
+  char *usage = "[-verbose] [-downscale] [-interlace] [-alpha file] ...\n\
+             ... [-transparent color] [-background color] [-gamma value] ...\n\
+             ... [-hist] [-chroma wx wy rx ry gx gy bx by] [-phys x y unit] ...\n\
+             ... [-text file] [-ztxt file] [-time [yy]yy-mm-dd hh:mm:ss] ...\n\
+             ... [-filter 0..4] [-compression 0..9] [-force] [pnmfile]";
+
+  pnm_init (&argc, argv);
+  argn = 1;
+
+  while (argn < argc && argv[argn][0] == '-' && argv[argn][1] != '\0') {
+    if (pm_keymatch (argv[argn], "-verbose", 2)) {
+      verbose = TRUE;
+    } else
+    if (pm_keymatch (argv[argn], "-downscale", 2)) {
+      downscale = TRUE;
+    } else
+    if (pm_keymatch (argv[argn], "-interlace", 2)) {
+      interlace = TRUE;
+    } else
+    if (pm_keymatch (argv[argn], "-alpha", 2)) {
+      if (transparent > 0)
+        pm_error ("-alpha and -transparent are mutually exclusive");
+      alpha = TRUE;
+      if (++argn < argc)
+        alpha_file = argv[argn];
+      else
+        pm_usage (usage);
+    } else
+    if (pm_keymatch (argv[argn], "-transparent", 3)) {
+      if (alpha)
+        pm_error ("-alpha and -transparent are mutually exclusive");
+      transparent = 1;
+      if (++argn < argc)
+        transstring = argv[argn];
+      else
+        pm_usage (usage);
+    } else
+    if (pm_keymatch (argv[argn], "-background", 2)) {
+      background = 1;
+      if (++argn < argc)
+        backstring = argv[argn];
+      else
+        pm_usage (usage);
+    } else
+    if (pm_keymatch (argv[argn], "-gamma", 2)) {
+      if (++argn < argc)
+        sscanf (argv[argn], "%f", &gamma);
+      else
+        pm_usage (usage);
+    } else
+    if (pm_keymatch (argv[argn], "-hist", 2)) {
+      hist = TRUE;
+    } else
+    if (pm_keymatch (argv[argn], "-chroma", 3)) {
+      if (++argn < argc)
+        sscanf (argv[argn], "%f", &chroma_wx);
+      else
+        pm_usage (usage);
+      if (++argn < argc)
+        sscanf (argv[argn], "%f", &chroma_wy);
+      else
+        pm_usage (usage);
+      if (++argn < argc)
+        sscanf (argv[argn], "%f", &chroma_rx);
+      else
+        pm_usage (usage);
+      if (++argn < argc)
+        sscanf (argv[argn], "%f", &chroma_ry);
+      else
+        pm_usage (usage);
+      if (++argn < argc)
+        sscanf (argv[argn], "%f", &chroma_gx);
+      else
+        pm_usage (usage);
+      if (++argn < argc)
+        sscanf (argv[argn], "%f", &chroma_gy);
+      else
+        pm_usage (usage);
+      if (++argn < argc)
+        sscanf (argv[argn], "%f", &chroma_bx);
+      else
+        pm_usage (usage);
+      if (++argn < argc)
+        sscanf (argv[argn], "%f", &chroma_by);
+      else
+        pm_usage (usage);
+    } else
+    if (pm_keymatch (argv[argn], "-phys", 3)) {
+      if (++argn < argc)
+        sscanf (argv[argn], "%d", &phys_x);
+      else
+        pm_usage (usage);
+      if (++argn < argc)
+        sscanf (argv[argn], "%d", &phys_y);
+      else
+        pm_usage (usage);
+      if (++argn < argc)
+        sscanf (argv[argn], "%d", &phys_unit);
+      else
+        pm_usage (usage);
+    } else
+    if (pm_keymatch (argv[argn], "-text", 3)) {
+      text = TRUE;
+      if (++argn < argc)
+        text_file = argv[argn];
+      else
+        pm_usage (usage);
+    } else
+    if (pm_keymatch (argv[argn], "-ztxt", 2)) {
+      ztxt = TRUE;
+      if (++argn < argc)
+        text_file = argv[argn];
+      else
+        pm_usage (usage);
+    } else
+    if (pm_keymatch (argv[argn], "-time", 3)) {
+      mtime = TRUE;
+      if (++argn < argc) {
+        date_string = argv[argn];
+        if (++argn < argc)
+          time_string = argv[argn];
+        else
+          pm_usage (usage);
+      } else {
+        pm_usage (usage);
+      }
+    } else 
+    if (pm_keymatch (argv[argn], "-filter", 3)) {
+      if (++argn < argc)
+      {
+        sscanf (argv[argn], "%d", &filter);
+        if ((filter < 0) || (filter > 4))
+        {
+          pm_message
+            ("filter must be 0 (none), 1 (sub), 2 (up), 3 (avg) or 4 (paeth)");
+          pm_usage (usage);
+        }
+      }
+      else
+        pm_usage (usage);
+    } else
+    if (pm_keymatch (argv[argn], "-compression", 3)) {
+      if (++argn < argc)
+      {
+        sscanf (argv[argn], "%d", &compression);
+        if ((compression < 0) || (compression > 9))
+        {
+          pm_message ("zlib compression must be between 0 (none) and 9 (max)");
+          pm_usage (usage);
+        }
+      }
+      else
+        pm_usage (usage);
+    } else
+    if (pm_keymatch (argv[argn], "-force", 3)) {
+      force = TRUE;
+    } else {
+      fprintf(stderr,"pnmtopng version %s.\n", VERSION);
+      fprintf(stderr, "   Compiled with libpng %s; using libpng %s.\n",
+        PNG_LIBPNG_VER_STRING, png_libpng_ver);
+      fprintf(stderr, "   Compiled with zlib %s; using zlib %s.\n",
+        ZLIB_VERSION, zlib_version);
+      fprintf(stderr,    
+        "   Compiled with %d-bit netpbm support (PPM_OVERALLMAXVAL = %d).\n",
+        pm_maxvaltobits (PPM_OVERALLMAXVAL), PPM_OVERALLMAXVAL);
+      fprintf(stderr, "\n");
+      pm_usage (usage);
+    }
+    argn++;
+  }
+
+  { 
+      char *input_file;
+      if (argn == argc)
+          input_file = "-";
+      else {
+          input_file = argv[argn];
+          argn++;
+      }
+      ifp = pm_openr_seekable(input_file);
+  }
+
+  if (argn != argc)
+    pm_usage (usage);
+
+  if (alpha)
+    afp = pm_openr (alpha_file);
+  else
+    afp = NULL;
+
+  if ((text) || (ztxt))
+    tfp = pm_openr (text_file);
+  else
+    tfp = NULL;
+
+  errorlevel = convertpnm (ifp, afp, tfp);
+
+  if (alpha)
+    pm_closer (afp);
+  if ((text) || (ztxt))
+    pm_closer (tfp);
+
+  pm_closer (ifp);
+  pm_closew (stdout);
+
+  return errorlevel;
+}
diff -ruN netpbm-9.25-orig/pnm/pstopnm.c netpbm-9.25/pnm/pstopnm.c
--- netpbm-9.25-orig/pnm/pstopnm.c	2011-07-23 13:57:02.000000000 +0200
+++ netpbm-9.25/pnm/pstopnm.c	2011-07-23 13:57:22.000000000 +0200
@@ -478,7 +478,7 @@
     
     sprintf(ghostscript_command,
             "gs -sDEVICE='%s' -sOutputFile='%s' -g'%dx%d' -r'%dx%d' "
-            "-q -dNOPAUSE -",
+            "-q -dNOPAUSE -dPARANOIDSAFER -",
             ghostscript_device, outfile_arg, 
             xsize, ysize, xres, yres);
 
diff -ruN netpbm-9.25-orig/pnm/pstopnm.c.orig netpbm-9.25/pnm/pstopnm.c.orig
--- netpbm-9.25-orig/pnm/pstopnm.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ netpbm-9.25/pnm/pstopnm.c.orig	2001-09-07 17:49:59.000000000 +0200
@@ -0,0 +1,583 @@
+/*----------------------------------------------------------------------------
+                                 pstopnm
+------------------------------------------------------------------------------
+  Use Ghostscript to convert a Postscript file into a PBM, PGM, or PNM
+  file.
+
+-----------------------------------------------------------------------------*/
+
+#define _BSD_SOURCE 1   /* Make sure strdup() is in string.h */
+
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/wait.h>   /* For popen() exit codes */
+#include <sys/stat.h>
+#include "pnm.h"
+
+enum orientation {PORTRAIT, LANDSCAPE, UNSPECIFIED};
+struct box {
+    /* Description of a rectangle within an image; all coordinates 
+       measured in pixels with lower left corner of page being the 
+       origin.
+       */
+    int llx;  /* lower left X coord */
+        /* -1 for llx means whole box is undefined. */
+    int lly;  /* lower left Y coord */
+    int urx;  /* upper right X coord */
+    int ury;  /* upper right Y coord */
+};
+
+struct cmdline_info {
+    /* All the information the user supplied in the command line,
+       in a form easy for the program to use.
+    */
+    char *input_filespec;  /* Filespecs of input files */
+    int forceplain;
+    struct box extract_box;
+    int nocrop;
+    int format_type;
+    int verbose;
+    float xborder;
+    int xmax;
+    int xsize;
+    float yborder;
+    int ymax;
+    int ysize;
+    enum orientation orientation;
+    int goto_stdout;
+} cmdline;
+
+
+static void
+parse_command_line(int argc, char ** argv,
+                   struct cmdline_info *cmdline_p) {
+/*----------------------------------------------------------------------------
+   Note that the file spec array we return is stored in the storage that
+   was passed to us as the argv array.
+-----------------------------------------------------------------------------*/
+    optStruct *option_def = malloc(100*sizeof(optStruct));
+        /* Instructions to OptParseOptions2 on how to parse our options.
+         */
+    optStruct2 opt;
+
+    unsigned int option_def_index;
+
+    int pbm_opt, pgm_opt, ppm_opt;
+    int portrait_opt, landscape_opt;
+    float llx, lly, urx, ury;
+    
+    option_def_index = 0;   /* incremented by OPTENTRY */
+    OPTENTRY(0,   "forceplain", OPT_FLAG,   &cmdline_p->forceplain,     0);
+    OPTENTRY(0,   "llx",        OPT_FLOAT,  &llx,                       0);
+    OPTENTRY(0,   "lly",        OPT_FLOAT,  &lly,                       0);
+    OPTENTRY(0,   "urx",        OPT_FLOAT,  &urx,                       0);
+    OPTENTRY(0,   "ury",        OPT_FLOAT,  &ury,                       0);
+    OPTENTRY(0,   "nocrop",     OPT_FLAG,   &cmdline_p->nocrop,         0);
+    OPTENTRY(0,   "pbm",        OPT_FLAG,   &pbm_opt,                   0);
+    OPTENTRY(0,   "pgm",        OPT_FLAG,   &pgm_opt,                   0);
+    OPTENTRY(0,   "ppm",        OPT_FLAG,   &ppm_opt,                   0);
+    OPTENTRY(0,   "verbose",    OPT_FLAG,   &cmdline_p->verbose,        0);
+    OPTENTRY(0,   "xborder",    OPT_FLOAT,  &cmdline_p->xborder,        0);
+    OPTENTRY(0,   "xmax",       OPT_UINT,   &cmdline_p->xmax,           0);
+    OPTENTRY(0,   "xsize",      OPT_UINT,   &cmdline_p->xsize,          0);
+    OPTENTRY(0,   "yborder",    OPT_FLOAT,  &cmdline_p->yborder,        0);
+    OPTENTRY(0,   "ymax",       OPT_UINT,   &cmdline_p->ymax,           0);
+    OPTENTRY(0,   "ysize",      OPT_UINT,   &cmdline_p->ysize,          0);
+    OPTENTRY(0,   "portrait",   OPT_FLAG,   &portrait_opt,              0);
+    OPTENTRY(0,   "landscape",  OPT_FLAG,   &landscape_opt,             0);
+    OPTENTRY(0,   "stdout",     OPT_FLAG,   &cmdline_p->goto_stdout,    0);
+
+    /* Set the defaults */
+    cmdline_p->forceplain = FALSE;
+    cmdline_p->nocrop = FALSE;
+    cmdline_p->verbose = FALSE;
+    pbm_opt = pgm_opt = ppm_opt = FALSE;
+    portrait_opt = landscape_opt = FALSE;
+    llx = lly = urx = ury = -1;
+    cmdline_p->xmax = 612;
+    cmdline_p->ymax = 792;
+    cmdline_p->xsize = cmdline_p->ysize = -1;
+    cmdline_p->xborder = cmdline_p->yborder = 0.1;
+
+    opt.opt_table = option_def;
+    opt.short_allowed = FALSE;  /* We have no short (old-fashioned) options */
+    opt.allowNegNum = FALSE;  /* We have no parms that are negative numbers */
+
+    pm_optParseOptions2(&argc, argv, opt, 0);
+        /* Uses and sets argc, argv, and some of *cmdline_p and others. */
+
+    if (argc-1 == 0)
+        cmdline_p->input_filespec = "-";  /* stdin */
+    else if (argc-1 == 1)
+        cmdline_p->input_filespec = argv[1];
+    else 
+        pm_error("Too many arguments (%d).  "
+                 "Only need one: the Postscript filespec", argc-1);
+
+    if (portrait_opt & !landscape_opt)
+        cmdline_p->orientation = PORTRAIT;
+    else if (!portrait_opt & landscape_opt)
+        cmdline_p->orientation = LANDSCAPE;
+    else if (!portrait_opt & !landscape_opt)
+        cmdline_p->orientation = UNSPECIFIED;
+    else
+        pm_error("Cannot specify both -portrait and -landscape options");
+
+    if (pbm_opt)
+        cmdline_p->format_type = PBM_TYPE;
+    else if (pgm_opt)
+        cmdline_p->format_type = PGM_TYPE;
+    else if (ppm_opt)
+        cmdline_p->format_type = PPM_TYPE;
+    else
+        cmdline_p->format_type = PPM_TYPE;
+
+    /* If any one of the 4 bounding box coordinates is given on the
+       command line, we default any of the 4 that aren't.  
+    */
+    if (llx != -1 || lly != -1 || urx != -1 || ury != -1) {
+        if (llx == -1) cmdline_p->extract_box.llx = 72;
+        else cmdline_p->extract_box.llx = llx * 72;
+        if (lly == -1) cmdline_p->extract_box.lly = 72;
+        else cmdline_p->extract_box.lly = lly * 72;
+        if (urx == -1) cmdline_p->extract_box.urx = 540;
+        else cmdline_p->extract_box.urx = urx * 72;
+        if (ury == -1) cmdline_p->extract_box.ury = 720;
+        else cmdline_p->extract_box.ury = ury * 72;
+    } else {
+        cmdline_p->extract_box.llx = -1;
+    }
+
+}
+
+
+
+static void
+add_ps_to_filespec(const char orig_filespec[], char ** const new_filespec_p,
+                   const int verbose) {
+/*----------------------------------------------------------------------------
+   If orig_filespec[] names an existing file, but the same name with ".ps"
+   added to the end does, return the name with the .ps attached.  Otherwise,
+   just return orig_filespec[].
+
+   Return the name in newly malloc'ed storage, pointed to by
+   *new_filespec_p.
+-----------------------------------------------------------------------------*/
+    struct stat statbuf;
+    int stat_rc;
+
+    stat_rc = lstat(orig_filespec, &statbuf);
+    
+    if (stat_rc == 0)
+        *new_filespec_p = strdup(orig_filespec);
+    else {
+        char *filespec_plus_ps;
+
+        filespec_plus_ps = malloc(strlen(orig_filespec) + 4);
+        strcpy(filespec_plus_ps, orig_filespec);
+        strcat(filespec_plus_ps, ".ps");
+
+        stat_rc = lstat(filespec_plus_ps, &statbuf);
+        if (stat_rc == 0)
+            *new_filespec_p = strdup(filespec_plus_ps);
+        else
+            *new_filespec_p = strdup(orig_filespec);
+    }
+    if (verbose)
+        pm_message("Input file is %s", *new_filespec_p);
+}
+
+
+
+static void
+compute_size_res(const struct cmdline_info cmdline, 
+                 const enum orientation orientation, 
+                 const struct box bordered_box,
+                 int * const xsize_p, int * const ysize_p,
+                 int * const xres_p, int * const yres_p) {
+
+    int sx, sy;
+
+    if (orientation == LANDSCAPE) {
+        sx = bordered_box.ury - bordered_box.lly;
+        sy = bordered_box.urx - bordered_box.llx;
+    } else {
+        sx = bordered_box.urx - bordered_box.llx;
+        sy = bordered_box.ury - bordered_box.lly;
+    }
+    if (cmdline.ysize == -1 && cmdline.xsize == -1) {
+        /* User didn't specify either x or y size, so we compute them
+           from xmax and ymax
+           */
+        *yres_p = cmdline.ymax * 72 / sy;
+        *xres_p = *yres_p = 
+            min(cmdline.xmax * 72 / sx, cmdline.ymax * 72 / sy);
+        
+        if (cmdline.nocrop) {
+            *xsize_p = cmdline.xmax;
+            *ysize_p = cmdline.ymax;
+        } else {
+            *xsize_p = (int) (sx * *xres_p / 72 + 0.5);
+            *ysize_p = (int) (sy * *yres_p / 72 + 0.5);
+        }
+    } else {
+        /* Compute the x and y size from the specified x and/or y sizes */
+        if (cmdline.xsize != -1) {
+            *xsize_p = cmdline.xsize;
+            *xres_p = cmdline.xsize * 72 / sx;
+            if (cmdline.ysize == -1) {
+                *yres_p = *xres_p;
+                *ysize_p = (int) (sy * *yres_p/72 + 0.5);
+            }
+        }
+
+        if (cmdline.ysize != -1) {
+            *ysize_p = cmdline.ysize;
+            *yres_p = cmdline.ysize * 72 / sy;
+            if (cmdline.xsize == -1) {
+                *xres_p = *yres_p;
+                *xsize_p = (int) (sx * *xres_p/72 + 0.5);
+            }
+        }
+    }
+}
+
+
+
+static struct box
+compute_box_to_extract(const struct box cmdline_extract_box,
+                       const char input_filespec[],
+                       const int verbose) {
+
+    struct box retval;
+
+    if (cmdline.extract_box.llx != -1)
+        /* User told us what box to extract, so that's what we'll do */
+        retval = cmdline_extract_box;
+    else {
+        /* Try to get the bounding box from the Postscript %%BoundingBox
+           statement in the input.
+           */
+        struct box ps_bb;  /* Box described by %%BoundingBox stmt in input */
+
+        if (strcmp(input_filespec, "-") == 0)
+            /* Can't read stdin, because we need it positioned for the 
+               Ghostscript interpreter to read it.
+            */
+            ps_bb.llx = -1;
+        else {
+            FILE *infile;
+            int found_BB, eof;  /* logical */
+            infile = pm_openr(input_filespec);
+            
+            found_BB = FALSE;
+            eof = FALSE;
+            while (!eof && !found_BB) {
+                char line[200];
+                
+                if (fgets(line, sizeof(line), infile) == NULL)
+                    eof = TRUE;
+                else {
+                    int rc;
+                    rc = sscanf(line, "%%%%BoundingBox: %d %d %d %d",
+                                &ps_bb.llx, &ps_bb.lly, 
+                                &ps_bb.urx, &ps_bb.ury);
+                    if (rc == 4) 
+                        found_BB = TRUE;
+                }
+            }
+            fclose(infile);
+
+            if (!found_BB) {
+                ps_bb.llx = -1;
+                pm_message("Warning: no %%%%BoundingBox statement "
+                           "in the input or command line.\n"
+                           "Will use defaults");
+            }
+        }
+        if (ps_bb.llx != -1) {
+            if (verbose)
+                pm_message("Using %%%%BoundingBox statement from input.");
+            retval = ps_bb;
+        } else { 
+            /* Use the center of an 8.5" x 11" page with 1" border all around*/
+            retval.llx = 72;
+            retval.lly = 72;
+            retval.urx = 540;
+            retval.ury = 720;
+        }
+    }
+    if (verbose)
+        pm_message("Extracting the box ((%d,%d),(%d,%d))",
+                   retval.llx, retval.lly, retval.urx, retval.ury);
+    return retval;
+}
+
+
+
+static enum orientation
+compute_orientation(const struct cmdline_info cmdline, 
+                    const struct box extract_box) {
+
+    enum orientation retval;
+    const int input_width = extract_box.urx - extract_box.llx;
+    const int input_height = extract_box.ury - extract_box.lly;
+
+    if (cmdline.orientation != UNSPECIFIED)
+        retval = cmdline.orientation;
+    else {
+        if ((cmdline.xsize == -1 || cmdline.ysize == -1) &
+            (cmdline.xsize != -1 || cmdline.ysize != -1)) {
+            /* User specified one output dimension, but not the other,
+               so we can't use output dimensions to make the decision.  So
+               just use the input dimensions.
+               */
+            if (input_height > input_width) retval = PORTRAIT;
+            else retval = LANDSCAPE;
+        } else {
+            int output_width, output_height;
+            if (cmdline.xsize != -1) {
+                /* He gave xsize and ysize, so that's the output size */
+                output_width = cmdline.xsize;
+                output_height = cmdline.ysize;
+            } else {
+                /* Well then we'll just use his (or default) xmax, ymax */
+                output_width = cmdline.xmax;
+                output_height = cmdline.ymax;
+            }
+
+            if (input_height > input_width && output_height > output_width)
+                retval = PORTRAIT;
+            else 
+                if (input_height < input_width && output_height < output_width)
+                    retval = PORTRAIT;
+            else 
+                retval = LANDSCAPE;
+        }
+    }
+    return retval;
+}
+
+
+
+static struct box
+add_borders(const struct box input_box, 
+            const float xborder_scale, float yborder_scale,
+            const int verbose) {
+
+    struct box retval;
+
+    const int left_right_border_size = 
+        (int) ((input_box.urx - input_box.llx) * xborder_scale + 0.5);
+    const int top_bottom_border_size = 
+        (int) ((input_box.ury - input_box.lly) * yborder_scale + 0.5);
+
+    retval.llx = input_box.llx - left_right_border_size;
+    retval.lly = input_box.lly - top_bottom_border_size;
+    retval.urx = input_box.urx + left_right_border_size;
+    retval.ury = input_box.ury + top_bottom_border_size;
+
+    if (verbose)
+        pm_message("With borders, extracted box is ((%d,%d),(%d,%d))",
+                   retval.llx, retval.lly, retval.urx, retval.ury);
+
+    return retval;
+}
+
+
+
+static char *
+compute_pstrans(const struct box box, const enum orientation orientation,
+                const int xsize, const int ysize, 
+                const int xres, const int yres) {
+
+    static char retval[100]; 
+
+    if (orientation == PORTRAIT) {
+        int llx, lly;
+        llx = box.llx - (xsize * 72 / xres - (box.urx - box.llx)) / 2;
+        lly = box.lly - (ysize * 72 / yres - (box.ury - box.lly)) / 2;
+        sprintf(retval, "%d neg %d neg translate", llx, lly);
+    } else {
+        int llx, ury;
+        llx = box.llx - (ysize * 72 / yres - (box.urx - box.llx)) / 2;
+        ury = box.ury + (xsize * 72 / xres - (box.ury - box.lly)) / 2;
+        sprintf(retval, "90 rotate %d neg %d neg translate", llx, ury);
+    }
+    return retval;
+}
+
+
+
+static char *
+compute_outfile_arg(const struct cmdline_info cmdline) {
+
+    char *retval;  /* malloc'ed */
+
+    retval = malloc(strlen(cmdline.input_filespec) + 10);
+
+    if (cmdline.goto_stdout)
+        strcpy(retval, "-");
+    else if (strcmp(cmdline.input_filespec, "-") == 0)
+        strcpy(retval, "-");
+    else {
+        strcpy(retval, cmdline.input_filespec);
+        if (strlen(retval) > 3 && strcmp(retval+strlen(retval)-3, ".ps") == 0) 
+            /* The input filespec ends in ".ps".  Chop it off. */
+            retval[strlen(retval)-3] = '\0';
+
+        strcat(retval, "%03d.");
+        switch (cmdline.format_type) {
+        case PBM_TYPE: strcat(retval, "pbm"); break;
+        case PGM_TYPE: strcat(retval, "pgm"); break;
+        case PPM_TYPE: strcat(retval, "ppm"); break;
+        default: pm_error("Internal error: invalid value format_type");
+        }
+    }
+    return(retval);
+}
+
+
+
+static char *
+compute_gs_device(const int format_type, const int forceplain) {
+
+    static char retval[20];
+
+    switch (cmdline.format_type) {
+    case PBM_TYPE: strcpy(retval, "pbm"); break;
+    case PGM_TYPE: strcpy(retval, "pgm"); break;
+    case PPM_TYPE: strcpy(retval, "ppm"); break;
+    default: pm_error("Internal error: invalid value format_type");
+    }
+    if (!forceplain)
+        strcat(retval, "raw");
+
+    return(retval);
+}
+
+
+
+static void
+execute_ghostscript(const char pstrans[], const char ghostscript_device[],
+                    const char outfile_arg[], 
+                    const int xsize, const int ysize, 
+                    const int xres, const int yres,
+                    const char input_filespec[], const int verbose) {
+
+    int gs_exit;  /* wait4 exit code from Ghostscript */
+    FILE *gs;  /* Pipe to Ghostscript's standard input */
+    FILE *infile;
+    int eof;  /* End of file on input */
+    char ghostscript_command[250];
+
+    if (strlen(outfile_arg) > 80)
+        pm_error("output file spec too long.");
+    
+    sprintf(ghostscript_command,
+            "gs -sDEVICE='%s' -sOutputFile='%s' -g'%dx%d' -r'%dx%d' "
+            "-q -dNOPAUSE -",
+            ghostscript_device, outfile_arg, 
+            xsize, ysize, xres, yres);
+
+    if (cmdline.verbose) {
+        pm_message("Shell command: %s", ghostscript_command);
+        pm_message("Postscript prefix command: '%s'", pstrans);
+    }
+
+    infile = pm_openr(input_filespec);
+
+    gs = popen(ghostscript_command, "w");
+    if (gs == NULL) 
+        pm_error("Unable to start Ghostscript shell command: %s\n",
+                 ghostscript_command);
+    
+    fprintf(gs, "%s\n", pstrans);
+
+    eof = FALSE;
+    while (!eof) {
+        char buffer[4096];
+        int bytes_read;
+        
+        bytes_read = fread(buffer, 1, sizeof(buffer), infile);
+        if (bytes_read == 0) 
+            eof = TRUE;
+        else 
+            fwrite(buffer, 1, bytes_read, gs);
+    }
+    
+    gs_exit = pclose(gs);
+    pm_close(infile);
+
+    if (gs_exit != 0) {
+        if (WIFEXITED(gs_exit))
+            pm_error("Ghostscript command failed.  Exit code=%d\n"
+                     "Command was: %s", WEXITSTATUS(gs_exit), 
+                     ghostscript_command);
+        else if (WIFSIGNALED(gs_exit))
+            pm_error("Ghostscript process died due to a signal %d.",
+                     WTERMSIG(gs_exit));
+        else 
+            pm_error("Ghostscript process died with exit code %d", gs_exit);
+    }
+}
+
+
+
+int
+main(int argc, char **argv) {
+
+    char *input_filespec;  /* malloc'ed */
+        /* The file specification of our Postscript input file */
+    int xres, yres;   /* Resolution in pixels per inch */
+    int xsize, ysize;  /* output image size in pixels */
+    struct box extract_box;
+        /* coordinates of the box within the input we are to extract; i.e.
+           that will become the output. 
+           */
+    struct box bordered_box;
+        /* Same as above, but expanded to include borders */
+
+    enum orientation orientation;
+    char *ghostscript_device;
+    char *outfile_arg;
+    char *pstrans;
+
+    pnm_init(&argc, argv);
+
+    parse_command_line(argc, argv, &cmdline);
+
+    add_ps_to_filespec(cmdline.input_filespec, &input_filespec,
+                       cmdline.verbose);
+
+    extract_box = compute_box_to_extract(cmdline.extract_box, input_filespec, 
+                                         cmdline.verbose);
+
+    orientation = compute_orientation(cmdline, extract_box);
+
+    bordered_box = add_borders(extract_box, cmdline.xborder, cmdline.yborder,
+                               cmdline.verbose);
+
+    compute_size_res(cmdline, orientation, bordered_box, 
+                     &xsize, &ysize, &xres, &yres);
+    
+    pstrans = compute_pstrans(bordered_box, orientation,
+                              xsize, ysize, xres, yres);
+
+    outfile_arg = compute_outfile_arg(cmdline);
+
+    ghostscript_device = 
+        compute_gs_device(cmdline.format_type, cmdline.forceplain);
+    
+    pm_message("Writing %s file", ghostscript_device);
+    
+    execute_ghostscript(pstrans, ghostscript_device, outfile_arg, 
+                        xsize, ysize, xres, yres, input_filespec,
+                        cmdline.verbose);
+
+    return 0;
+}
+
+
diff -ruN netpbm-9.25-orig/ppm/ppmfade netpbm-9.25/ppm/ppmfade
--- netpbm-9.25-orig/ppm/ppmfade	2011-07-23 13:57:02.000000000 +0200
+++ netpbm-9.25/ppm/ppmfade	2011-07-23 13:57:22.000000000 +0200
@@ -23,6 +23,7 @@
 #
 #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 use strict;
+use File::Temp "tempdir";
 
 my $SPREAD =  1;
 my $SHIFT =   2;
@@ -125,20 +126,25 @@
 
 print("Frames are " . $width . "W x " . $height . "H\n");
 
+#
+# We create a tmp-directory right here
+#
+my $tmpdir = tempdir("ppmfade.XXXXXX", CLEANUP => 1);
+
 if ($first_file eq "undefined") {
     print "Fading from black to ";
-    system("ppmmake \\#000 $width $height >junk1$$.ppm");
+    system("ppmmake \\#000 $width $height >$tmpdir/junk1.ppm");
 } else {
     print "Fading from $first_file to ";
-    system("cp", $first_file, "junk1$$.ppm");
+    system("cp", $first_file, "$tmpdir/junk1.ppm");
 }
 
 if ($last_file eq "undefined") {
     print "black.\n";
-    system("ppmmake \\#000 $width $height >junk2$$.ppm");
+    system("ppmmake \\#000 $width $height >$tmpdir/junk2.ppm");
 } else {
     print "$last_file\n";
-    system("cp", $last_file, "junk2$$.ppm");
+    system("cp", $last_file, "$tmpdir/junk2.ppm");
 }
 
 #
@@ -161,148 +167,150 @@
     if ($mode eq $SPREAD) {
         if ($i <= 10) {
             my $n = $spline20[$i] * 100;
-            system("ppmspread $n junk1$$.ppm >junk3$$.ppm");
+            system("ppmspread $n $tmpdir/junk1.ppm >$tmpdir/junk3.ppm");
         } elsif ($i <= 20) {
             my $n;
             $n = $spline20[$i] * 100;
-            system("ppmspread $n junk1$$.ppm >junk1a$$.ppm");
+            system("ppmspread $n $tmpdir/junk1.ppm >$tmpdir/junk1a.ppm");
             $n = (1-$spline20[$i-10]) * 100;
-            system("ppmspread $n junk2$$.ppm >junk2a$$.ppm");
+            system("ppmspread $n $tmpdir/junk2.ppm >$tmpdir/junk2a.ppm");
             $n = $spline10[$i-10];
-            system("ppmmix $n junk1a$$.ppm junk2a$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk1a.ppm $tmpdir/junk2a.ppm >$tmpdir/junk3.ppm");
         } else {
             my $n = (1-$spline20[$i-10])*100;
-            system("ppmspread $n junk2$$.ppm >junk3$$.ppm");
+            system("ppmspread $n $tmpdir/junk2.ppm >$tmpdir/junk3.ppm");
         }
     } elsif ($mode eq $SHIFT) {
         if ($i <= 10) {
             my $n = $spline20[$i] * 100;
-            system("ppmshift $n junk1$$.ppm >junk3$$.ppm");
+            system("ppmshift $n $tmpdir/junk1.ppm >$tmpdir/junk3.ppm");
         } elsif ($i <= 20) {
             my $n;
             $n = $spline20[$i] * 100;
-            system("ppmshift $n junk1$$.ppm >junk1a$$.ppm");
+            system("ppmshift $n $tmpdir/junk1.ppm >$tmpdir/junk1a.ppm");
             $n = (1-$spline20[$i-10])*100;
-            system("ppmshift $n junk2$$.ppm >junk2a$$.ppm");
+            system("ppmshift $n $tmpdir/junk2.ppm >$tmpdir/junk2a.ppm");
             $n = $spline10[$i-10];
-            system("ppmmix $n junk1a$$.ppm junk2a$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk1a.ppm $tmpdir/junk2a.ppm >$tmpdir/junk3.ppm");
         } else {
             my $n = (1-$spline20[$i-10]) * 100;
-            system("ppmshift $n junk2$$.ppm >junk3$$.ppm");
+            system("ppmshift $n $tmpdir/junk2.ppm >$tmpdir/junk3.ppm");
         }
     } elsif ($mode eq $RELIEF) {
         if ($i == 1) {
-            system("ppmrelief junk1$$.ppm >junk1r$$.ppm");
+            system("ppmrelief $tmpdir/junk1.ppm >$tmpdir/junk1r.ppm");
         }
         if ($i <= 10) {
             my $n = $spline10[$i];
-            system("ppmmix $n junk1$$.ppm junk1r$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk1.ppm $tmpdir/junk1r.ppm >$tmpdir/junk3.ppm");
         } elsif ($i <= 20) {
             my $n = $spline10[$i-10];
-            system("ppmmix $n junk1r$$.ppm junk2r$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk1r.ppm $tmpdir/junk2r.ppm >$tmpdir/junk3.ppm");
         } else {
             my $n = $spline10[$i-20];
-            system("ppmmix $n junk2r$$.ppm junk2$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk2r.ppm $tmpdir/junk2.ppm >$tmpdir/junk3.ppm");
         }
         if ($i == 10) {
-            system("ppmrelief junk2$$.ppm >junk2r$$.ppm");
+            system("ppmrelief $tmpdir/junk2.ppm >$tmpdir/junk2r.ppm");
         }
     } elsif ($mode eq $OIL) {
         if ($i == 1) {
-            system("ppmtopgm junk1$$.ppm | pgmoil >junko$$.ppm");
-            system("rgb3toppm junko$$.ppm junko$$.ppm junko$$.ppm " .
-                   ">junk1o$$.ppm");
+            system("ppmtopgm $tmpdir/junk1.ppm | pgmoil >$tmpdir/junko.ppm");
+            system("rgb3toppm $tmpdir/junko.ppm $tmpdir/junko.ppm $tmpdir/junko.ppm " .
+                   ">$tmpdir/junk1o.ppm");
         }
         if ($i <= 10) {
             my $n = $spline10[$i];
-            system("ppmmix $n junk1$$.ppm junk1o$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk1.ppm $tmpdir/junk1o.ppm >$tmpdir/junk3.ppm");
         } elsif ($i <= 20) {
             my $n = $spline10[$i-10];
-            system("ppmmix $n junk1o$$.ppm junk2o$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk1o.ppm $tmpdir/junk2o.ppm >$tmpdir/junk3.ppm");
         } else {
             my $n = $spline10[$i-20];
-            system("ppmmix $n junk2o$$.ppm junk2$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk2o.ppm $tmpdir/junk2.ppm >$tmpdir/junk3.ppm");
         }
         if ($i == 10) {
-            system("ppmtopgm junk2$$.ppm | pgmoil >junko$$.ppm");
-            system("rgb3toppm junko$$.ppm junko$$.ppm junko$$.ppm " .
-                   ">junk2o$$.ppm");
+            system("ppmtopgm $tmpdir/junk2.ppm | pgmoil >$tmpdir/junko.ppm");
+            system("rgb3toppm $tmpdir/junko.ppm $tmpdir/junko.ppm $tmpdir/junko.ppm " .
+                   ">$tmpdir/junk2o.ppm");
         }
     } elsif ($mode eq $EDGE) {
         if ($i == 1) {
-            system("ppmtopgm junk1$$.ppm | pgmedge >junko$$.ppm");
-            system("rgb3toppm junko$$.ppm junko$$.ppm junko$$.ppm " .
-                   ">junk1o$$.ppm");
+            system("ppmtopgm $tmpdir/junk1.ppm | pgmedge >$tmpdir/junko.ppm");
+            system("rgb3toppm $tmpdir/junko.ppm $tmpdir/junko.ppm $tmpdir/junko.ppm " .
+                   ">$tmpdir/junk1o.ppm");
         }
         if ($i <= 10) {
             my $n = $spline10[$i];
-            system("ppmmix $n junk1$$.ppm junk1o$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk1.ppm $tmpdir/junk1o.ppm >$tmpdir/junk3.ppm");
         } elsif ($i <= 20) {
             my $n = $spline10[$i-10];
-            system("ppmmix $n junk1o$$.ppm junk2o$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk1o.ppm $tmpdir/junk2o.ppm >$tmpdir/junk3.ppm");
         } else {
             my $n = $spline10[$i-20];
-            system("ppmmix $n junk2o$$.ppm junk2$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk2o.ppm $tmpdir/junk2.ppm >$tmpdir/junk3.ppm");
         }
         if ($i == 10) {
-            system("ppmtopgm junk2$$.ppm | pgmedge >junko$$.ppm");
-            system("rgb3toppm junko$$.ppm junko$$.ppm junko$$.ppm " .
-                   ">junk2o$$.ppm");
+            system("ppmtopgm $tmpdir/junk2.ppm | pgmedge >$tmpdir/junko.ppm");
+            system("rgb3toppm $tmpdir/junko.ppm $tmpdir/junko.ppm $tmpdir/junko.ppm " .
+                   ">$tmpdir/junk2o.ppm");
         } 
     } elsif ($mode eq $BENTLEY) {
         if ($i == 1) {
-            system("ppmtopgm junk1$$.ppm | pgmbentley >junko$$.ppm");
-            system("rgb3toppm junko$$.ppm junko$$.ppm junko$$.ppm " .
-                   ">junk1o$$.ppm");
+            system("ppmtopgm $tmpdir/junk1.ppm | pgmbentley >$tmpdir/junko.ppm");
+            system("rgb3toppm $tmpdir/junko.ppm $tmpdir/junko.ppm $tmpdir/junko.ppm " .
+                   ">$tmpdir/junk1o.ppm");
         }
         if ($i <= 10) {
             my $n = $spline10[$i];
-            system("ppmmix $n junk1$$.ppm junk1o$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk1.ppm $tmpdir/junk1o.ppm >$tmpdir/junk3.ppm");
         } elsif ($i <= 20) {
             my $n = $spline10[$i-10];
-            system("ppmmix $n junk1o$$.ppm junk2o$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk1o.ppm $tmpdir/junk2o.ppm >$tmpdir/junk3.ppm");
         } else {
             my $n = $spline10[$i-20];
-            system("ppmmix $n junk2o$$.ppm junk2$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk2o.ppm $tmpdir/junk2.ppm >$tmpdir/junk3.ppm");
         }
         if ($i == 10) {
-            system("ppmtopgm junk2$$.ppm | pgmbentley >junko$$.ppm");
-            system("rgb3toppm junko$$.ppm junko$$.ppm junko$$.ppm " .
-                   ">junk2o$$.ppm");
+            system("ppmtopgm $tmpdir/junk2.ppm | pgmbentley >$tmpdir/junko.ppm");
+            system("rgb3toppm $tmpdir/junko.ppm $tmpdir/junko.ppm $tmpdir/junko.ppm " .
+                   ">$tmpdir/junk2o.ppm");
         }
     } elsif ($mode eq $BLOCK) {
         if ($i <= 10) {
             my $n = 1 - 1.9*$spline20[$i];
-            system("pnmscale $n junk1$$.ppm | " .
-                   "pnmscale -width $width -height $height >junk3$$.ppm");
+            system("pnmscale $n $tmpdir/junk1.ppm | " .
+                   "pnmscale -width $width -height $height >$tmpdir/junk3.ppm");
         } elsif ($i <= 20) {
             my $n = $spline10[$i-10];
-            system("ppmmix $n junk1a$$.ppm junk2a$$.ppm >junk3$$.ppm");
+            system("ppmmix $n $tmpdir/junk1a.ppm $tmpdir/junk2a.ppm >$tmpdir/junk3.ppm");
         } else {
             my $n = 1 - 1.9*$spline20[31-$i];
-            system("pnmscale $n junk2$$.ppm | " .
-                   "pnmscale -width $width -height $height >junk3$$.ppm");
+            system("pnmscale $n $tmpdir/junk2.ppm | " .
+                   "pnmscale -width $width -height $height >$tmpdir/junk3.ppm");
         }
         if ($i == 10) {
-            system("cp", "junk3$$.ppm", "junk1a$$.ppm");
-            system("pnmscale $n junk2$$.ppm | " .
-                   "pnmscale -width $width -height $height >junk2a$$.ppm");
+            system("cp", "$tmpdir/junk3.ppm", "$tmpdir/junk1a.ppm");
+            system("pnmscale $n $tmpdir/junk2.ppm | " .
+                   "pnmscale -width $width -height $height >$tmpdir/junk2a.ppm");
         }    
     } elsif ($mode eq $MIX) {
         my $fade_factor = sqrt(1/($nframes-$i+1));
-        system("ppmmix $fade_factor junk1$$.ppm junk2$$.ppm >junk3$$.ppm");
+        system("ppmmix $fade_factor $tmpdir/junk1.ppm $tmpdir/junk2.ppm >$tmpdir/junk3.ppm");
     } else {
         print("Internal error: impossible mode value '$mode'\n");
     }
 
     my $outfile = sprintf("%s.%04d.ppm", $base_name, $i);
-    system("cp", "junk3$$.ppm", $outfile);
+    system("cp", "$tmpdir/junk3.ppm", $outfile);
 }
 
 #
 #  Clean up shop.
 #
-system("rm junk*$$.ppm");
+#system("rm $tmpdir/junk*.ppm");
+# As the temporary files are automatically deleted, nothing is needed for
+# cleanup any more.
 
 exit(0);
 
diff -ruN netpbm-9.25-orig/ppm/ppmtompeg/parallel.c netpbm-9.25/ppm/ppmtompeg/parallel.c
--- netpbm-9.25-orig/ppm/ppmtompeg/parallel.c	2011-07-23 13:57:02.000000000 +0200
+++ netpbm-9.25/ppm/ppmtompeg/parallel.c	2011-07-23 13:57:22.000000000 +0200
@@ -20,6 +20,8 @@
 /*==============*
  * HEADER FILES *
  *==============*/
+#define _BSD_SOURCE 1
+/* This makes sure that mkstemp() is in unistd.h */
 
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -557,6 +559,7 @@
   register int y;
   int	    numBytes;
   unsigned long data;
+#define TMPFILE_TEMPLATE "/tmp/ppmtompeg.XXXXXX"
   char    fileName[256];
 
   Fsize_Note(frameNumber, yuvWidth, yuvHeight);
@@ -575,7 +578,9 @@
 
   if ( frameNumber != -1 ) {
     if ( separateConversion ) {
-      sprintf(fileName, "/tmp/foobar%d", machineNumber);
+      strcpy(fileName, TMPFILE_TEMPLATE);
+      if (-1 == mkstemp(fileName))
+	  pm_error( "could not create temporary convolution file");
       filePtr = fopen(fileName, "wb");
 
       /* read in stuff, SafeWrite to file, perform local conversion */
diff -ruN netpbm-9.25-orig/ppm/ppmtompeg/ppmtompeg.1 netpbm-9.25/ppm/ppmtompeg/ppmtompeg.1
--- netpbm-9.25-orig/ppm/ppmtompeg/ppmtompeg.1	2011-07-23 13:57:02.000000000 +0200
+++ netpbm-9.25/ppm/ppmtompeg/ppmtompeg.1	2011-07-23 13:57:22.000000000 +0200
@@ -366,6 +366,9 @@
 .SH VERSION
 This is version 1.5 it contins new features and bug fixes from version 1.3.
 .SH BUGS
+Not really a bug, but at least a limitation: If writing to an output file,
+ppmtompeg sometimes uses <filename>.* as temporary files.
+.LP
 No known bugs, but if you find any, report them to mpeg-bugs@plateau.cs.berkeley.edu.
 .HP
 .SH AUTHORS
diff -ruN netpbm-9.25-orig/ppm/xpmtoppm.c netpbm-9.25/ppm/xpmtoppm.c
--- netpbm-9.25-orig/ppm/xpmtoppm.c	2011-07-23 13:57:02.000000000 +0200
+++ netpbm-9.25/ppm/xpmtoppm.c	2011-07-23 13:59:35.000000000 +0200
@@ -113,6 +113,9 @@
     */
 
 
+/* We shouldn't be redefining a library function */
+#define getline ppm_getline
+
 static void
 getline(char * const line, int const size, FILE * const stream) {
 /*----------------------------------------------------------------------------
diff -ruN netpbm-9.25-orig/ppm/xvminitoppm.c netpbm-9.25/ppm/xvminitoppm.c
--- netpbm-9.25-orig/ppm/xvminitoppm.c	2011-07-23 13:57:02.000000000 +0200
+++ netpbm-9.25/ppm/xvminitoppm.c	2011-07-23 14:02:14.000000000 +0200
@@ -14,6 +14,9 @@
 #include "ppm.h"
 #define BUFSIZE 256
 
+/* We shouldn't be redefining a library function */
+#define getline ppm_getline
+
 static void getline ARGS((FILE *fp, char *buf));
 
 int 
