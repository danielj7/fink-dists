--- gcc-4.2-20060822/gcc/testsuite/lib/prune.exp.org	2006-08-23 18:33:56.000000000 -0400
+++ gcc-4.2-20060822/gcc/testsuite/lib/prune.exp	2006-08-23 18:41:28.000000000 -0400
@@ -43,6 +43,7 @@
     regsub -all "(^|\n)\[^\n\]*file path prefix \[^\n\]* never used" $text "" text
     regsub -all "(^|\n)\[^\n\]*linker input file unused since linking not done" $text "" text
 
+    regsub -all "(^|\n)can't find atom for N_GSYM stabs \[^\n\]* in \[^\n\]*" $text "" text
     #send_user "After:$text\n"
 
     return $text
--- gcc-4.2-20060825/libstdc++-v3/testsuite/lib/prune.exp.org   2006-08-26 11:22:52.000000000 -0400
+++ gcc-4.2-20060825/libstdc++-v3/testsuite/lib/prune.exp       2006-08-26 11:23:39.000000000 -0400
@@ -29,5 +29,7 @@
     regsub -all "(^|\n)\[^\n\]*: Additional NOP may be necessary to workaround Itanium processor A/B step errata" $text "" text
     regsub -all "(^|\n)\[^\n*\]*: Assembler messages:\[^\n\]*" $text "" text
 
+    regsub -all "(^|\n)can't find atom for N_GSYM stabs \[^\n\]* in \[^\n\]*" $text "" text
+
     return $text
 }
--- gcc-4.2-20061107/libjava/configure.ac.orig	2006-11-13 20:36:59.000000000 -0500
+++ gcc-4.2-20061107/libjava/configure.ac	2006-11-13 20:38:22.000000000 -0500
@@ -180,6 +180,10 @@
 TOOLKIT=
 AC_SUBST(TOOLKIT)
 
+if test -n "${with_multisubdir}"; then
+  peerlibs=no
+fi
+
 for peer in $peerlibs ; do
   case $peer in
     xlib)
diff -uNr gcc-4.2-20070123/gcc/testsuite/gcc.dg/tree-ssa/loop-20.c gcc-4.2-20070123.pr29516/gcc/testsuite/gcc.dg/tree-ssa/loop-20.c
--- gcc-4.2-20070123/gcc/testsuite/gcc.dg/tree-ssa/loop-20.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.2-20070123.pr29516/gcc/testsuite/gcc.dg/tree-ssa/loop-20.c	2007-01-23 20:22:00.000000000 -0500
@@ -0,0 +1,23 @@
+/* PR tree-optimization/29516 */
+
+/* { dg-do compile { target fpic } } */
+/* { dg-options "-O -ftree-vrp -fPIC -fdump-tree-ivopts" } */
+
+typedef struct gfc_se { int pre; } gfc_se;
+typedef struct gfc_ss_info { int dim[7]; } gfc_ss_info;
+int gfc_rank_cst[7 + 1];
+gfc_conv_array_transpose (gfc_se * se) {
+  int dest, src, dest_index, src_index;
+  gfc_ss_info *dest_info;
+  int n;
+  for (n = 0; n < 2; n++) {
+    dest_info->dim[n] = n;
+    src_index = gfc_rank_cst[1 - n];
+    a (se->pre, b (dest, dest_index), c (src, src_index));
+  }
+}
+
+/* Ivopts should not produce multiplication by a pointer constant.  */
+
+/* { dg-final { scan-tree-dump-times "\\* \[0-9\]*B;" 0 "ivopts" } } */
+/* { dg-final { cleanup-tree-dump "ivopts" } } */
diff -uNr gcc-4.2-20070123/gcc/tree-ssa-address.c gcc-4.2-20070123.pr29516/gcc/tree-ssa-address.c
--- gcc-4.2-20070123/gcc/tree-ssa-address.c	2006-10-21 01:50:35.000000000 -0400
+++ gcc-4.2-20070123.pr29516/gcc/tree-ssa-address.c	2007-01-23 20:22:00.000000000 -0500
@@ -243,54 +243,54 @@
 tree
 tree_mem_ref_addr (tree type, tree mem_ref)
 {
-  tree addr = NULL_TREE;
+  tree addr;
   tree act_elem;
   tree step = TMR_STEP (mem_ref), offset = TMR_OFFSET (mem_ref);
+  tree sym = TMR_SYMBOL (mem_ref), base = TMR_BASE (mem_ref);
+  tree addr_base = NULL_TREE, addr_off = NULL_TREE;
 
-  act_elem = TMR_INDEX (mem_ref);
-  if (act_elem)
+  if (sym)
+    addr_base = fold_convert (type, build_addr (sym, current_function_decl));
+  else if (base && POINTER_TYPE_P (TREE_TYPE (base)))
     {
-      act_elem = fold_convert (type, act_elem);
-
-      if (step)
-	act_elem = fold_build2 (MULT_EXPR, type, act_elem,
-				fold_convert (type, step));
-      addr = act_elem;
+      addr_base = fold_convert (type, base);
+      base = NULL_TREE;
     }
 
-  act_elem = TMR_BASE (mem_ref);
+  act_elem = TMR_INDEX (mem_ref);
   if (act_elem)
     {
-      act_elem = fold_convert (type, act_elem);
-
-      if (addr)
-	addr = fold_build2 (PLUS_EXPR, type, addr, act_elem);
-      else
-	addr = act_elem;
+      if (step)
+	act_elem = fold_build2 (MULT_EXPR, sizetype, act_elem, step);
+      addr_off = act_elem;
     }
 
-  act_elem = TMR_SYMBOL (mem_ref);
+  act_elem = base;
   if (act_elem)
     {
-      act_elem = fold_convert (type, build_addr (act_elem,
-						 current_function_decl));
-      if (addr)
-	addr = fold_build2 (PLUS_EXPR, type, addr, act_elem);
+      if (addr_off)
+	addr_off = fold_build2 (PLUS_EXPR, sizetype, addr_off, act_elem);
       else
-	addr = act_elem;
+	addr_off = act_elem;
     }
 
   if (!zero_p (offset))
     {
-      act_elem = fold_convert (type, offset);
-
-      if (addr)
-	addr = fold_build2 (PLUS_EXPR, type, addr, act_elem);
+      if (addr_off)
+	addr_off = fold_build2 (PLUS_EXPR, sizetype, addr_off, offset);
       else
-	addr = act_elem;
+	addr_off = offset;
     }
 
-  if (!addr)
+  if (addr_off)
+    {
+      addr = fold_convert (type, addr_off);
+      if (addr_base)
+	addr = fold_build2 (PLUS_EXPR, type, addr_base, addr);
+    }
+  else if (addr_base)
+    addr = addr_base;
+  else
     addr = build_int_cst (type, 0);
 
   return addr;
@@ -342,52 +342,113 @@
 	      || DECL_EXTERNAL (obj)));
 }
 
-/* Adds COEF * ELT to PARTS.  TYPE is the type of the address we
-   construct.  */
+/* Remove M-th element from COMB.  */
 
 static void
-add_to_parts (struct mem_address *parts, tree type, tree elt,
-	      unsigned HOST_WIDE_INT coef)
+aff_combination_remove_elt (struct affine_tree_combination *comb, unsigned m)
 {
-  /* Check if this is a symbol.  */
-  if (!parts->symbol
-      && coef == 1
-      && TREE_CODE (elt) == ADDR_EXPR
-      && fixed_address_object_p (TREE_OPERAND (elt, 0)))
+  comb->n--;
+  if (m <= comb->n)
     {
-      parts->symbol = TREE_OPERAND (elt, 0);
-      return;
+      comb->coefs[m] = comb->coefs[comb->n];
+      comb->elts[m] = comb->elts[comb->n];
     }
+  if (comb->rest)
+    {
+      comb->coefs[comb->n] = 1;
+      comb->elts[comb->n] = comb->rest;
+      comb->rest = NULL_TREE;
+      comb->n++;
+    }
+}
 
-  if (coef != 1)
-    elt = fold_build2 (MULT_EXPR, type, fold_convert (type, elt),
-		       build_int_cst_type (type, coef));
-  else
-    elt = fold_convert (type, elt);
+/* If ADDR contains an address of object that is a link time constant,
+   move it to PARTS->symbol.  */
 
-  if (!parts->base)
+static void
+move_fixed_address_to_symbol (struct mem_address *parts,
+			      struct affine_tree_combination *addr)
+{
+  unsigned i;
+  tree val = NULL_TREE;
+
+  for (i = 0; i < addr->n; i++)
     {
-      parts->base = elt;
-      return;
+      if (addr->coefs[i] != 1)
+	continue;
+
+      val = addr->elts[i];
+      if (TREE_CODE (val) == ADDR_EXPR
+	  && fixed_address_object_p (TREE_OPERAND (val, 0)))
+	break;
     }
 
+  if (i == addr->n)
+    return;
+
+  parts->symbol = TREE_OPERAND (val, 0);
+  aff_combination_remove_elt (addr, i);
+}
+
+/* If ADDR contains an address of a dereferenced pointer, move it to
+   PARTS->base.  */
+
+static void
+move_pointer_to_base (struct mem_address *parts,
+		      struct affine_tree_combination *addr)
+{
+  unsigned i;
+  tree val = NULL_TREE;
+
+  for (i = 0; i < addr->n; i++)
+    {
+      if (addr->coefs[i] != 1)
+	continue;
+
+      val = addr->elts[i];
+      if (POINTER_TYPE_P (TREE_TYPE (val)))
+	break;
+    }
+
+  if (i == addr->n)
+    return;
+
+  parts->base = val;
+  aff_combination_remove_elt (addr, i);
+}
+
+/* Adds ELT to PARTS.  */
+
+static void
+add_to_parts (struct mem_address *parts, tree elt)
+{
+  tree type;
+
   if (!parts->index)
     {
       parts->index = elt;
       return;
     }
 
+  if (!parts->base)
+    {
+      parts->base = elt;
+      return;
+    }
+
   /* Add ELT to base.  */
-  parts->base = fold_build2 (PLUS_EXPR, type, parts->base, elt);
+  type = TREE_TYPE (parts->base);
+  parts->base = fold_build2 (PLUS_EXPR, type,
+			     parts->base,
+			     fold_convert (type, elt));
 }
 
 /* Finds the most expensive multiplication in ADDR that can be
    expressed in an addressing mode and move the corresponding
-   element(s) to PARTS.  TYPE is the type of the address we
-   construct.  */
+   element(s) to PARTS.  */
 
 static void
-most_expensive_mult_to_index (struct mem_address *parts, tree type,
+most_expensive_mult_to_index (struct mem_address *parts,
 			      struct affine_tree_combination *addr)
 {
   unsigned HOST_WIDE_INT best_mult = 0;
@@ -423,16 +484,16 @@
 	  continue;
 	}
 
-      elt = fold_convert (type, addr->elts[i]);
+      elt = fold_convert (sizetype, addr->elts[i]);
       if (!mult_elt)
 	mult_elt = elt;
       else
-	mult_elt = fold_build2 (PLUS_EXPR, type, mult_elt, elt);
+	mult_elt = fold_build2 (PLUS_EXPR, sizetype, mult_elt, elt);
     }
   addr->n = j;
 
   parts->index = mult_elt;
-  parts->step = build_int_cst_type (type, best_mult);
+  parts->step = build_int_cst_type (sizetype, best_mult);
 }
 
 /* Splits address ADDR into PARTS.
@@ -445,10 +506,10 @@
    for complicated addressing modes is useless.  */
 
 static void
-addr_to_parts (struct affine_tree_combination *addr, tree type,
-	       struct mem_address *parts)
+addr_to_parts (struct affine_tree_combination *addr, struct mem_address *parts)
 {
   unsigned i;
+  tree part;
 
   parts->symbol = NULL_TREE;
   parts->base = NULL_TREE;
@@ -456,19 +517,34 @@
   parts->step = NULL_TREE;
 
   if (addr->offset)
-    parts->offset = build_int_cst_type (type, addr->offset);
+    parts->offset = build_int_cst_type (sizetype, addr->offset);
   else
     parts->offset = NULL_TREE;
 
+  /* Try to find a symbol.  */
+  move_fixed_address_to_symbol (parts, addr);
+
   /* First move the most expensive feasible multiplication
      to index.  */
-  most_expensive_mult_to_index (parts, type, addr);
+  most_expensive_mult_to_index (parts, addr);
+
+  /* Try to find a base of the reference.  Since at the moment
+     there is no reliable way how to distinguish between pointer and its
+     offset, this is just a guess.  */
+  if (!parts->symbol)
+    move_pointer_to_base (parts, addr);
 
   /* Then try to process the remaining elements.  */
   for (i = 0; i < addr->n; i++)
-    add_to_parts (parts, type, addr->elts[i], addr->coefs[i]);
+    {
+      part = fold_convert (sizetype, addr->elts[i]);
+      if (addr->coefs[i] != 1)
+	part = fold_build2 (MULT_EXPR, sizetype, part,
+			    build_int_cst_type (sizetype, addr->coefs[i]));
+      add_to_parts (parts, part);
+    }
   if (addr->rest)
-    add_to_parts (parts, type, addr->rest, 1);
+    add_to_parts (parts, fold_convert (sizetype, addr->rest));
 }
 
 /* Force the PARTS to register.  */
@@ -493,10 +569,10 @@
 		struct affine_tree_combination *addr)
 {
   tree mem_ref, tmp;
-  tree addr_type = build_pointer_type (type);
+  tree addr_type = build_pointer_type (type), atype;
   struct mem_address parts;
 
-  addr_to_parts (addr, addr_type, &parts);
+  addr_to_parts (addr, &parts);
   gimplify_mem_ref_parts (bsi, &parts);
   mem_ref = create_mem_ref_raw (type, &parts);
   if (mem_ref)
@@ -509,9 +585,9 @@
       /* Move the multiplication to index.  */
       gcc_assert (parts.index);
       parts.index = force_gimple_operand_bsi (bsi,
-					      build2 (MULT_EXPR, addr_type,
-						      parts.index, parts.step),
-					      true, NULL_TREE);
+				fold_build2 (MULT_EXPR, sizetype,
+					     parts.index, parts.step),
+				true, NULL_TREE);
       parts.step = NULL_TREE;
   
       mem_ref = create_mem_ref_raw (type, &parts);
@@ -521,16 +597,18 @@
 
   if (parts.symbol)
     {
-      tmp = build_addr (parts.symbol, current_function_decl);
+      tmp = fold_convert (addr_type,
+			  build_addr (parts.symbol, current_function_decl));
     
       /* Add the symbol to base, eventually forcing it to register.  */
       if (parts.base)
 	{
 	  if (parts.index)
 	    parts.base = force_gimple_operand_bsi (bsi,
-						   build2 (PLUS_EXPR, addr_type,
-							   parts.base, tmp),
-						   true, NULL_TREE);
+			fold_build2 (PLUS_EXPR, addr_type,
+				     fold_convert (addr_type, parts.base),
+				     tmp),
+			true, NULL_TREE);
 	  else
 	    {
 	      parts.index = parts.base;
@@ -546,18 +624,21 @@
 	return mem_ref;
     }
 
-  if (parts.base)
+  if (parts.index)
     {
-      /* Add base to index.  */
-      if (parts.index)
-	parts.index = force_gimple_operand_bsi (bsi,
-						build2 (PLUS_EXPR, addr_type,
-							parts.base,
-							parts.index),
-						true, NULL_TREE);
+      /* Add index to base.  */
+      if (parts.base)
+	{
+	  atype = TREE_TYPE (parts.base);
+	  parts.base = force_gimple_operand_bsi (bsi,
+			fold_build2 (PLUS_EXPR, atype,
+				     parts.base,
+			    	     fold_convert (atype, parts.index)),
+			true, NULL_TREE);
+	}
       else
-	parts.index = parts.base;
-      parts.base = NULL_TREE;
+	parts.base = parts.index;
+      parts.index = NULL_TREE;
 
       mem_ref = create_mem_ref_raw (type, &parts);
       if (mem_ref)
@@ -566,15 +647,18 @@
 
   if (parts.offset && !integer_zerop (parts.offset))
     {
-      /* Try adding offset to index.  */
-      if (parts.index)
-	parts.index = force_gimple_operand_bsi (bsi, 
-						build2 (PLUS_EXPR, addr_type,
-							parts.index,
-							parts.offset),
-						true, NULL_TREE);
+      /* Try adding offset to base.  */
+      if (parts.base)
+	{
+	  atype = TREE_TYPE (parts.base);
+	  parts.base = force_gimple_operand_bsi (bsi, 
+			fold_build2 (PLUS_EXPR, atype,
+				     parts.base,
+				     fold_convert (atype, parts.offset)),
+			true, NULL_TREE);
+	}
       else
-	parts.index = parts.offset, bsi;
+	parts.base = parts.offset;
 
       parts.offset = NULL_TREE;
 
@@ -587,7 +671,7 @@
      (only a register).  If we cannot create such a memory reference,
      something is really wrong.  */
   gcc_assert (parts.symbol == NULL_TREE);
-  gcc_assert (parts.base == NULL_TREE);
+  gcc_assert (parts.index == NULL_TREE);
   gcc_assert (!parts.step || integer_onep (parts.step));
   gcc_assert (!parts.offset || integer_zerop (parts.offset));
   gcc_unreachable ();
@@ -632,8 +716,9 @@
   if (addr.base && TREE_CODE (addr.base) == INTEGER_CST)
     {
       if (addr.offset)
-	addr.offset = fold_binary_to_constant (PLUS_EXPR, ptr_type_node,
-					       addr.offset, addr.base);
+	addr.offset = fold_binary_to_constant (PLUS_EXPR, sizetype,
+			addr.offset,
+			fold_convert (sizetype, addr.base));
       else
 	addr.offset = addr.base;
 
@@ -646,14 +731,14 @@
       off = addr.index;
       if (addr.step)
 	{
-	  off = fold_binary_to_constant (MULT_EXPR, ptr_type_node,
+	  off = fold_binary_to_constant (MULT_EXPR, sizetype,
 					 off, addr.step);
 	  addr.step = NULL_TREE;
 	}
 
       if (addr.offset)
 	{
-	  addr.offset = fold_binary_to_constant (PLUS_EXPR, ptr_type_node,
+	  addr.offset = fold_binary_to_constant (PLUS_EXPR, sizetype,
 						 addr.offset, off);
 	}
       else
diff -uNr gcc-4.2-20070123/gcc/tree.def gcc-4.2-20070123.pr29516/gcc/tree.def
--- gcc-4.2-20070123/gcc/tree.def	2006-10-21 01:50:37.000000000 -0400
+++ gcc-4.2-20070123.pr29516/gcc/tree.def	2007-01-23 20:22:00.000000000 -0500
@@ -943,6 +943,9 @@
    OFFSET (integer constant).  Corresponding address is
    SYMBOL + BASE + STEP * INDEX + OFFSET.  Only variations and values valid on
    the target are allowed.
+
+   The type of STEP, INDEX and OFFSET is sizetype.  The type of BASE is
+   sizetype or a pointer type (if SYMBOL is NULL).
    
    The sixth argument is the reference to the original memory access, which
    is preserved for the purposes of the RTL alias analysis.  The seventh

 	  	 
