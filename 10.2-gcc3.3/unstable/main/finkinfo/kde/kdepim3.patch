--- ../kdepim-3.2.0/kontact/src/Makefile.am	Sun Oct 26 05:57:48 2003
+++ ./kontact/src/Makefile.am	Sun Feb  1 23:26:51 2004
@@ -4,7 +4,10 @@
 lib_LTLIBRARIES = libkontact.la
 libkontact_la_LDFLAGS = $(all_libraries) $(KDE_RPATH) -version-info 1:0
 libkontact_la_LIBADD = $(LIB_KDECORE)
-libkontact_la_SOURCES = prefs.kcfgc
+libkontact_la_SOURCES = prefs.kcfgc dummy.cpp
+
+dummy.cpp:
+	echo > dummy.cpp
 
 bin_PROGRAMS = kontact
 
--- ../kdepim-3.2.0/korganizer/plugins/Makefile.am	Sun Oct 26 05:57:51 2003
+++ ./korganizer/plugins/Makefile.am	Sun Feb  1 23:26:19 2004
@@ -2,5 +2,5 @@
 exchange_SUBDIR=exchange
 endif
 
-SUBDIRS=birthdays datenums holidays projectview webexport hebrew $(exchange_SUBDIR) 
+SUBDIRS=birthdays datenums projectview webexport hebrew $(exchange_SUBDIR) 
 
--- ../kdepim-3.2.0/kpilot/conduits/malconduit/mal-conduit.cc	Sun Oct 26 05:57:55 2003
+++ ./kpilot/conduits/malconduit/mal-conduit.cc	Sun Feb  1 23:26:19 2004
@@ -34,6 +34,7 @@
 
 #include "options.h"
 
+#include <stdarg.h>
 #include <qregexp.h>
 #include <kconfig.h>
 #include <kdebug.h>
--- ../kdepim-3.2.0/libical/src/libical/Makefile.am	Fri Jul 25 07:47:23 2003
+++ ./libical/src/libical/Makefile.am	Sun Feb  1 23:26:19 2004
@@ -26,7 +26,7 @@
 DESIGNDATA = $(top_srcdir)/libical/design-data
 ICALSCRIPTS = $(top_srcdir)/libical/scripts
 
-noinst_LTLIBRARIES = libical.la
+kde_module_LTLIBRARIES = libical.la
 
 AM_YFLAGS = -d -v -t -pical_yy
 AM_LFLAGS = -Pical_yy -olex.yy.c
--- ../kdepim-3.2.0/libical/src/libicalss/Makefile.am	Tue Sep  2 09:57:08 2003
+++ ./libical/src/libicalss/Makefile.am	Sun Feb  1 23:26:19 2004
@@ -1,5 +1,5 @@
 
-noinst_LTLIBRARIES = libicalss.la
+kde_module_LTLIBRARIES = libicalss.la
 
 AM_YFLAGS =-d -v -p ss
 AM_LFLAGS = -Pss
--- kaddressbook/kabcore.cpp	18 Jan 2004 15:49:39 -0000	1.62.2.2
+++ kaddressbook/kabcore.cpp	1 Feb 2004 10:45:03 -0000	1.62.2.3
@@ -77,8 +77,7 @@
                   const char *name )
   : KAB::Core( client, parent, name ), mStatusBar( 0 ), mViewManager( 0 ),
     mExtensionManager( 0 ), mCategorySelectDialog( 0 ), mCategoryEditDialog( 0 ),
-    mConfigureDialog( 0 ), mLdapSearchDialog( 0 ), mReadWrite( readWrite ),
-    mModified( false )
+    mLdapSearchDialog( 0 ), mReadWrite( readWrite ), mModified( false )
 {
   mWidget = new QWidget( parent, name );
 
@@ -819,17 +818,14 @@
   // Save the current config so we do not loose anything if the user accepts
   saveSettings();
 
-  if ( !mConfigureDialog ) {
-    mConfigureDialog = new KCMultiDialog( mWidget );
+  KCMultiDialog dlg( mWidget, "", true );
+  connect( &dlg, SIGNAL( configCommitted() ),
+           this, SLOT( configurationChanged() ) );
 
-    connect( mConfigureDialog, SIGNAL( configCommitted() ),
-             this, SLOT( configurationChanged() ) );
+  dlg.addModule( "kabconfig.desktop" );
+  dlg.addModule( "kabldapconfig.desktop" );
 
-    mConfigureDialog->addModule( "kabconfig.desktop" );
-    mConfigureDialog->addModule( "kabldapconfig.desktop" );
-  }
-
-  mConfigureDialog->show();
+  dlg.exec();
 }
 
 void KABCore::print()
--- kaddressbook/kabcore.h	6 Jan 2004 22:39:51 -0000	1.28
+++ kaddressbook/kabcore.h	1 Feb 2004 10:45:03 -0000	1.28.2.1
@@ -46,7 +46,6 @@
 class KAction;
 class KActionCollection;
 class KConfig;
-class KCMultiDialog;
 class KToggleAction;
 class KXMLGUIClient;
 
@@ -368,7 +367,6 @@
     QSplitter *mDetailsSplitter;
     QSplitter *mExtensionBarSplitter;
 
-    KCMultiDialog *mConfigureDialog;
     LDAPSearchDialog *mLdapSearchDialog;
     QDict<AddresseeEditorDialog> mEditorDict;
 
--- kaddressbook/soundwidget.cpp	22 Sep 2003 17:56:19 -0000	1.6
+++ kaddressbook/soundwidget.cpp	1 Feb 2004 10:38:38 -0000	1.6.4.1
@@ -1,25 +1,25 @@
-/*                                                                      
-    This file is part of KAddressBook.                                  
-    Copyright (c) 2003 Tobias Koenig <tokoe@kde.org>                   
-                                                                        
+/*
+    This file is part of KAddressBook.
+    Copyright (c) 2003 - 2004 Tobias Koenig <tokoe@kde.org>
+
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or   
-    (at your option) any later version.                                 
-                                                                        
-    This program is distributed in the hope that it will be useful,     
-    but WITHOUT ANY WARRANTY; without even the implied warranty of      
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the        
-    GNU General Public License for more details.                        
-                                                                        
-    You should have received a copy of the GNU General Public License   
-    along with this program; if not, write to the Free Software         
-    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.           
-                                                                        
-    As a special exception, permission is given to link this program    
-    with any edition of Qt, and distribute the resulting executable,    
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+    As a special exception, permission is given to link this program
+    with any edition of Qt, and distribute the resulting executable,
     without including the source code for Qt in the source distribution.
-*/                                                                      
+*/
 
 #include <kabc/sound.h>
 #include <kaudioplayer.h>
@@ -56,13 +56,15 @@
 
   mSoundUrl = new KURLRequester( this );
   topLayout->addWidget( mSoundUrl, 0, 2 );
-  
+
   mUseSoundUrl = new QCheckBox( i18n( "Store as URL" ), this );
   mUseSoundUrl->setEnabled( false );
   topLayout->addWidget( mUseSoundUrl, 1, 2 );
 
   connect( mSoundUrl, SIGNAL( textChanged( const QString& ) ),
            SIGNAL( changed() ) );
+  connect( mSoundUrl, SIGNAL( textChanged( const QString& ) ),
+           SLOT( urlChanged( const QString& ) ) );
   connect( mUseSoundUrl, SIGNAL( toggled( bool ) ),
            SIGNAL( changed() ) );
   connect( mUseSoundUrl, SIGNAL( toggled( bool ) ),
@@ -157,9 +159,16 @@
 
 void SoundWidget::updateGUI()
 {
-  if ( !mReadOnly )
-    mUseSoundUrl->setEnabled( true );  
-  mPlayButton->setEnabled( true );
+  mUseSoundUrl->setEnabled( !mReadOnly );
+}
+
+void SoundWidget::urlChanged( const QString &url )
+{
+  if ( !mUseSoundUrl->isChecked() ) {
+    bool state = !url.isEmpty();
+    mPlayButton->setEnabled( state );
+    mUseSoundUrl->setEnabled( state && !mSound.isIntern() );
+  }
 }
 
 #include "soundwidget.moc"
--- kaddressbook/soundwidget.h	22 Sep 2003 17:56:19 -0000	1.4
+++ kaddressbook/soundwidget.h	1 Feb 2004 10:38:38 -0000	1.4.4.1
@@ -1,25 +1,25 @@
-/*                                                                      
-    This file is part of KAddressBook.                                  
-    Copyright (c) 2003 Tobias Koenig <tokoe@kde.org>                   
-                                                                        
+/*
+    This file is part of KAddressBook.
+    Copyright (c) 2003 - 2004 Tobias Koenig <tokoe@kde.org>
+
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or   
-    (at your option) any later version.                                 
-                                                                        
-    This program is distributed in the hope that it will be useful,     
-    but WITHOUT ANY WARRANTY; without even the implied warranty of      
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the        
-    GNU General Public License for more details.                        
-                                                                        
-    You should have received a copy of the GNU General Public License   
-    along with this program; if not, write to the Free Software         
-    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.           
-                                                                        
-    As a special exception, permission is given to link this program    
-    with any edition of Qt, and distribute the resulting executable,    
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+    As a special exception, permission is given to link this program
+    with any edition of Qt, and distribute the resulting executable,
     without including the source code for Qt in the source distribution.
-*/                                                                      
+*/
 
 #ifndef SOUNDWIDGET_H
 #define SOUNDWIDGET_H
@@ -60,6 +60,7 @@
     void playSound();
     void loadSound();
     void updateGUI();
+    void urlChanged( const QString& );
 
   private:
     KURLRequester *mSoundUrl;
--- kalarm/alarmcalendar.cpp	8 Dec 2003 22:17:11 -0000	1.34
+++ kalarm/alarmcalendar.cpp	1 Feb 2004 19:45:07 -0000	1.34.4.1
@@ -46,7 +46,7 @@
 
 #include "kalarmapp.h"
 #include "preferences.h"
-#include "alarmcalendar.h"
+#include "alarmcalendar.moc"
 
 using namespace KCal;
 
@@ -227,8 +227,7 @@
 	if (!success)
 	{
 		kdError(5950) << "AlarmCalendar::saveCal(" << saveFilename << "): failed.\n";
-#warning "Temporary untranslated string"
-		KMessageBox::error(0, QString::fromLatin1("Failed to save calendar to\n'%1'").arg(mICalUrl.prettyURL()), kapp->aboutData()->programName());
+		KMessageBox::error(0, i18n("Failed to save calendar to\n'%1'").arg(mICalUrl.prettyURL()), kapp->aboutData()->programName());
 		return false;
 	}
 
@@ -560,6 +559,3 @@
 	}
 	return result;
 }
-
-#include "alarmcalendar.moc"
-
--- kalarm/dcophandler.cpp	17 Sep 2003 10:33:48 -0000	1.9
+++ kalarm/dcophandler.cpp	30 Jan 2004 19:43:12 -0000	1.9.4.1
@@ -99,7 +99,7 @@
 	//                scheduleEmail(addresses, subject, message, attachments, dateTime, flags, recurrence)
 	else if (func == "scheduleEmail(const QString&,const QString&,const QString&,const QString&,const QDateTime&,Q_UINT32,Q_INT32,const QString&)"
 	||       func == "scheduleEmail(QString,QString,QString,QString,QDateTime,Q_UINT32,QString)")
-		function = SCHEDULE | COMMAND;
+		function = SCHEDULE | EMAIL;
 
 	//                scheduleMessage(message, dateTime, colour, colourfg, flags, audioURL, reminder, repeatType, interval, repeatCount)
 	else if (func == "scheduleMessage(const QString&,const QDateTime&,const QColor&,const QColor&,Q_UINT32,const QString&,Q_INT32,Q_INT32,Q_INT32,Q_INT32)"
@@ -116,7 +116,7 @@
 	//                scheduleEmail(addresses, subject, message, attachments, dateTime, flags, repeatType, interval, repeatCount)
 	else if (func == "scheduleEmail(const QString&,const QString&,const QString&,const QString&,const QDateTime&,Q_UINT32,Q_INT32,Q_INT32,Q_INT32)"
 	||       func == "scheduleEmail(QString,QString,QString,QString,QDateTime,Q_UINT32,Q_INT32,Q_INT32,Q_INT32)")
-		function = SCHEDULE | COMMAND | REP_COUNT;
+		function = SCHEDULE | EMAIL | REP_COUNT;
 
 	//                scheduleMessage(message, dateTime, colour, colourfg, flags, audioURL, reminder, repeatType, interval, endTime)
 	else if (func == "scheduleMessage(const QString&,const QDateTime&,const QColor&,const QColor&,Q_UINT32,const QString&,Q_INT32,Q_INT32,Q_INT32,const QDateTime&)"
@@ -133,7 +133,7 @@
 	//                scheduleEmail(addresses, subject, message, attachments, dateTime, flags, repeatType, interval, endTime)
 	else if (func == "scheduleEmail(const QString&,const QString&,const QString&,const QString&,const QDateTime&,Q_UINT32,Q_INT32,Q_INT32,const QDateTime&)"
 	||       func == "scheduleEmail(QString,QString,QString,QString,QDateTime,Q_UINT32,Q_INT32,Q_INT32,QDateTime)")
-		function = SCHEDULE | COMMAND | REP_END;
+		function = SCHEDULE | EMAIL | REP_END;
 
 	// Deprecated methods: backwards compatibility with KAlarm pre-0.9.6
 	//                scheduleMessage(message, dateTime, colour, flags, audioURL, reminder, recurrence)
@@ -289,7 +289,7 @@
 				arg >> flags;
 				flags |= KAlarmEvent::DEFAULT_FONT;
 			}
-			if (!(function & PRE_070))
+			if ((action == KAlarmEvent::MESSAGE  ||  action == KAlarmEvent::FILE)  &&  !(function & PRE_070))
 				arg >> audioFile;
 			if (!(function & PRE_091))
 				arg >> reminderMinutes;
--- kalarm/editdlg.cpp	12 Jan 2004 00:14:58 -0000	1.106
+++ kalarm/editdlg.cpp	1 Feb 2004 23:36:46 -0000	1.106.2.2
@@ -685,7 +685,7 @@
 	}
 	else
 	{
-		// Only the deferral time has been changed
+		// Only the deferral time may have changed
 		event = *mSavedEvent;
 		if (mSavedEvent->deferred())
 		{
@@ -770,8 +770,7 @@
 				getEvent(event);
 				if (event.nextOccurrence(now, mAlarmDateTime) == KAlarmEvent::NO_OCCURRENCE)
 				{
-#warning "Temporary untranslated string"
-					KMessageBox::sorry(this, QString::fromLatin1("Recurrence has already expired"));
+					KMessageBox::sorry(this, i18n("Recurrence has already expired"));
 					return;
 				}
 			}
@@ -877,8 +876,8 @@
 	if (start.isValid())
 	{
 		bool deferred = mDeferDateTime.isValid();
-		DeferAlarmDlg* deferDlg = new DeferAlarmDlg(i18n("Defer Alarm"), (deferred ? mDeferDateTime : DateTime(QDateTime::currentDateTime().addSecs(60))),
-		                                            deferred, this, "deferDlg");
+		DeferAlarmDlg deferDlg(i18n("Defer Alarm"), (deferred ? mDeferDateTime : DateTime(QDateTime::currentDateTime().addSecs(60))),
+		                       deferred, this, "deferDlg");
 		// Don't allow deferral past the next recurrence
 		int reminder = mReminder->getMinutes();
 		if (reminder)
@@ -887,10 +886,10 @@
 			if (QDateTime::currentDateTime() < remindTime)
 				start = remindTime;
 		}
-		deferDlg->setLimit(start);
-		if (deferDlg->exec() == QDialog::Accepted)
+		deferDlg.setLimit(start);
+		if (deferDlg.exec() == QDialog::Accepted)
 		{
-			mDeferDateTime = deferDlg->getDateTime();
+			mDeferDateTime = deferDlg.getDateTime();
 			mDeferTimeLabel->setText(mDeferDateTime.isValid() ? mDeferDateTime.formatLocale() : QString::null);
 		}
 	}
--- kalarm/fontcolourbutton.cpp	10 Dec 2003 19:39:09 -0000	1.6
+++ kalarm/fontcolourbutton.cpp	1 Feb 2004 23:36:46 -0000	1.6.4.1
@@ -1,7 +1,7 @@
 /*
  *  fontcolourbutton.cpp  -  pushbutton widget to select a font and colour
  *  Program:  kalarm
- *  (C) 2003 by David Jarvie <software@astrojar.org.uk>
+ *  (C) 2003, 2004 by David Jarvie <software@astrojar.org.uk>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -51,15 +51,15 @@
 */
 void FontColourButton::slotButtonPressed()
 {
-	FontColourDlg* dlg = new FontColourDlg(mBgColour, mFgColour, mFont, mDefaultFont,
-	                                       i18n("Choose Alarm Font & Color"), this, "fontColourDlg");
-	dlg->setReadOnly(mReadOnly);
-	if (dlg->exec() == QDialog::Accepted)
+	FontColourDlg dlg(mBgColour, mFgColour, mFont, mDefaultFont,
+	                  i18n("Choose Alarm Font & Color"), this, "fontColourDlg");
+	dlg.setReadOnly(mReadOnly);
+	if (dlg.exec() == QDialog::Accepted)
 	{
-		mDefaultFont = dlg->defaultFont();
-		mFont        = dlg->font();
-		mBgColour    = dlg->bgColour();
-		mFgColour    = dlg->fgColour();
+		mDefaultFont = dlg.defaultFont();
+		mFont        = dlg.font();
+		mBgColour    = dlg.bgColour();
+		mFgColour    = dlg.fgColour();
 		emit selected();
 	}
 }
--- kalarm/kalarm.h	12 Jan 2004 00:15:27 -0000	1.41
+++ kalarm/kalarm.h	1 Feb 2004 23:38:24 -0000	1.41.2.1
@@ -1,7 +1,7 @@
 /*
  *  kalarm.h  -  global header file
  *  Program:  kalarm
- *  (C) 2001, 2002, 2003 by David Jarvie <software@astrojar.org.uk>
+ *  (C) 2001 - 2004 by David Jarvie <software@astrojar.org.uk>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -26,7 +26,7 @@
 #include <config.h>
 #endif
 
-#define KALARM_VERSION "1.0.2"
+#define KALARM_VERSION "1.0.3"
 
 #include <kdeversion.h>
 extern int  marginKDE2;   // KDE2 compatibility
--- kalarm/kalarmapp.cpp	3 Jan 2004 18:39:48 -0000	1.124
+++ kalarm/kalarmapp.cpp	1 Feb 2004 23:36:46 -0000	1.124.2.1
@@ -897,7 +897,8 @@
 */
 void KAlarmApp::slotPreferences()
 {
-	(new KAlarmPrefDlg(Preferences::instance()))->exec();
+	KAlarmPrefDlg prefDlg(Preferences::instance());
+	prefDlg.exec();
 }
 
 /******************************************************************************
--- kalarm/mainwindow.cpp	6 Nov 2003 13:54:01 -0000	1.78
+++ kalarm/mainwindow.cpp	1 Feb 2004 23:36:46 -0000	1.78.4.1
@@ -543,13 +543,13 @@
 */
 void KAlarmMainWindow::executeNew(KAlarmMainWindow* win, KAlarmEvent::Action action, const QString& text)
 {
-	EditAlarmDlg* editDlg = new EditAlarmDlg(i18n("New Alarm"), win, "editDlg");
+	EditAlarmDlg editDlg(i18n("New Alarm"), win, "editDlg");
 	if (!text.isNull())
-		editDlg->setAction(action, text);
-	if (editDlg->exec() == QDialog::Accepted)
+		editDlg.setAction(action, text);
+	if (editDlg.exec() == QDialog::Accepted)
 	{
 		KAlarmEvent event;
-		editDlg->getEvent(event);
+		editDlg.getEvent(event);
 
 		// Add the alarm to the displayed lists and to the calendar file
 		theApp()->addEvent(event, win);
@@ -573,11 +573,11 @@
 	if (item)
 	{
 		KAlarmEvent event = listView->getEvent(item);
-		EditAlarmDlg* editDlg = new EditAlarmDlg(i18n("New Alarm"), this, "editDlg", &event);
-		if (editDlg->exec() == QDialog::Accepted)
+		EditAlarmDlg editDlg(i18n("New Alarm"), this, "editDlg", &event);
+		if (editDlg.exec() == QDialog::Accepted)
 		{
 			KAlarmEvent event;
-			editDlg->getEvent(event);
+			editDlg.getEvent(event);
 
 			// Add the alarm to the displayed lists and to the calendar file
 			theApp()->addEvent(event, this);
@@ -598,11 +598,11 @@
 	if (item)
 	{
 		KAlarmEvent event = listView->getEvent(item);
-		EditAlarmDlg* editDlg = new EditAlarmDlg(i18n("Edit Alarm"), this, "editDlg", &event);
-		if (editDlg->exec() == QDialog::Accepted)
+		EditAlarmDlg editDlg(i18n("Edit Alarm"), this, "editDlg", &event);
+		if (editDlg.exec() == QDialog::Accepted)
 		{
 			KAlarmEvent newEvent;
-			editDlg->getEvent(newEvent);
+			editDlg.getEvent(newEvent);
 
 			// Update the event in the displays and in the calendar file
 			theApp()->modifyEvent(event, newEvent, this);
@@ -624,9 +624,9 @@
 	if (item)
 	{
 		KAlarmEvent event = listView->getEvent(item);
-		EditAlarmDlg* editDlg = new EditAlarmDlg((event.expired() ? i18n("Expired Alarm") : i18n("View Alarm")),
-		                                         this, "editDlg", &event, true);
-		editDlg->exec();
+		EditAlarmDlg editDlg((event.expired() ? i18n("Expired Alarm") : i18n("View Alarm")),
+		                     this, "editDlg", &event, true);
+		editDlg.exec();
 	}
 }
 
--- kalarm/messagewin.cpp	25 Oct 2003 20:59:19 -0000	1.77
+++ kalarm/messagewin.cpp	2 Feb 2004 00:37:16 -0000	1.77.4.1
@@ -589,15 +589,15 @@
 */
 void MessageWin::slotDefer()
 {
-	DeferAlarmDlg* deferDlg = new DeferAlarmDlg(i18n("Defer Alarm"), QDateTime::currentDateTime().addSecs(60),
-	                                            false, this, "deferDlg");
-	deferDlg->setLimit(eventID);
+	DeferAlarmDlg deferDlg(i18n("Defer Alarm"), QDateTime::currentDateTime().addSecs(60),
+	                       false, this, "deferDlg");
+	deferDlg.setLimit(eventID);
 	mDeferDlgShowing = true;
 	if (!Preferences::instance()->modalMessages())
 		lower();
-	if (deferDlg->exec() == QDialog::Accepted)
+	if (deferDlg.exec() == QDialog::Accepted)
 	{
-		DateTime dateTime = deferDlg->getDateTime();
+		DateTime dateTime = deferDlg.getDateTime();
 		const Event* kcalEvent = eventID.isNull() ? 0 : theApp()->getCalendar().event(eventID);
 		if (kcalEvent)
 		{
--- kalarmd/alarmdaemon.cpp	26 Nov 2003 12:37:50 -0000	1.61
+++ kalarmd/alarmdaemon.cpp	3 Feb 2004 00:06:56 -0000	1.61.4.1
@@ -50,40 +50,13 @@
 #include "alarmdaemon.moc"
 
 
-#ifdef CHECK_IF_SESSION_STARTED
-const int LOGIN_DELAY( 5 );
-#endif
-
 AlarmDaemon::AlarmDaemon(QObject *parent, const char *name)
   : DCOPObject(name), QObject(parent, name)
-#ifdef CHECK_IF_SESSION_STARTED
-    , mSessionStartTimer(0)
-#endif
 {
   kdDebug(5900) << "AlarmDaemon::AlarmDaemon()" << endl;
 
-#ifdef CHECK_IF_SESSION_STARTED
-  bool splash = kapp->dcopClient()->isApplicationRegistered("ksplash");
-  if (splash  ||  static_cast<AlarmApp*>(kapp)->startedAtLogin())
-  {
-    // Login session is starting up - need to wait for it to complete
-    // in order to prevent the daemon starting clients before they are
-    // restored by the session (where applicable).
-    // If ksplash can be detected as running, start a 1-second timer;
-    // otherwise, wait a few seconds.
-    kdDebug(5900) << "AlarmDaemon::AlarmDaemon(): session start\n";
-    mSessionStartTimer = new QTimer(this);
-    connect(mSessionStartTimer, SIGNAL(timeout()), SLOT(checkIfSessionStarted()));
-    mSessionStartTimer->start(splash ? 1000 : LOGIN_DELAY * 1000);
-  }
-#endif
-
   readCheckInterval();
-#ifdef CHECK_IF_SESSION_STARTED
-  readDaemonData(!!mSessionStartTimer);
-#else
   readDaemonData(false);
-#endif
 
   enableAutoStart(true);    // switch autostart on whenever the program is run
 
@@ -499,12 +472,24 @@
       return false;
     }
 
-    if (!kapp->dcopClient()->isApplicationRegistered(static_cast<const char*>(calendar->appName())))
+    bool registered = kapp->dcopClient()->isApplicationRegistered(static_cast<const char*>(calendar->appName()));
+    bool ready = registered;
+    if (registered)
+    {
+      QCStringList objects = kapp->dcopClient()->remoteObjects(calendar->appName());
+      if (objects.find(client.dcopObject) == objects.end())
+        ready = false;
+    }
+    if (!ready)
     {
-      // The client application is not running
+      // The client application is not running, or is not yet ready
+      // to receive notifications.
       if (client.notificationType == ClientInfo::NO_START_NOTIFY
       ||  client.notificationType == ClientInfo::DCOP_SIMPLE_NOTIFY) {
-        kdDebug(5900) << "AlarmDaemon::notifyEvent(): don't start client\n";
+        if (registered)
+          kdDebug(5900) << "AlarmDaemon::notifyEvent(): client not ready\n";
+        else
+          kdDebug(5900) << "AlarmDaemon::notifyEvent(): don't start client\n";
         return false;
       }
 
@@ -525,9 +510,15 @@
         kdDebug(5900) << "AlarmDaemon::notifyEvent(): used command line" << endl;
         return true;
       }
+
+      // Notification type = DCOP_NOTIFY: start client and then use DCOP
       p.start(KProcess::Block);
-      kdDebug(5900) << "AlarmDaemon::notifyEvent(): started "
-                    << cmd << endl;
+      kdDebug(5900) << "AlarmDaemon::notifyEvent(): started " << cmd << endl;
+      if (!ready)
+      {
+        kdDebug(5900) << "AlarmDaemon::notifyEvent(): client not ready\n";
+        return false;
+      }
     }
 
     if (client.notificationType == ClientInfo::DCOP_SIMPLE_NOTIFY)
@@ -568,39 +559,6 @@
   return true;
 }
 
-#ifdef CHECK_IF_SESSION_STARTED
-/*
- * Called by the timer to check whether session startup is complete.
- * If so, it checks which clients are already running and allows
- * notification of alarms to them. It also allows alarm notification
- * to clients which are not currently running but which allow the alarm
- * daemon to start them in order to notify them.
- * (Ideally checking for session startup would be done using a signal
- * from ksmserver, but until such a signal is available, we can check
- * whether ksplash is still running.)
- */
-void AlarmDaemon::checkIfSessionStarted()
-{
-  if (!kapp->dcopClient()->isApplicationRegistered("ksplash"))
-  {
-    // Session startup has now presumably completed. Cancel the timer.
-    kdDebug(5900) << "AlarmDaemon::checkIfSessionStarted(): startup complete\n";
-    delete mSessionStartTimer;
-
-    for (ClientList::Iterator client = mClients.begin();  client != mClients.end();  ++client)
-    {
-      if ((*client).notificationType == ClientInfo::DCOP_NOTIFY
-      ||  (*client).notificationType == ClientInfo::COMMAND_LINE_NOTIFY
-      ||  kapp->dcopClient()->isApplicationRegistered(static_cast<const char*>((*client).appName))) {
-        (*client).waitForRegistration = false;
-      }
-    }
-
-    mSessionStartTimer = 0;    // indicate that session startup is complete
-  }
-}
-#endif
-
 /*
  * Starts or stops the alarm timer as necessary after a calendar is enabled/disabled.
  */
--- kalarmd/alarmdaemon.h	11 Oct 2003 13:28:50 -0000	1.31
+++ kalarmd/alarmdaemon.h	3 Feb 2004 00:06:56 -0000	1.31.4.1
@@ -46,8 +46,6 @@
   private slots:
     void    calendarLoaded( ADCalendarBase *, bool success );
     void    checkAlarmsSlot();
-//    void    checkIfSessionStarted();
-
     void    checkAlarms();
 
   private:
@@ -118,7 +116,6 @@
 
     GuiMap            mGuis;                // client GUI application names and data
     QTimer*           mAlarmTimer;
-    QTimer*           mSessionStartTimer;   // timer waiting for session startup to complete
     QString           mClientDataFile;      // path of file containing client data
     int               mCheckInterval;       // alarm check interval (minutes)
     bool              mAlarmTimerSyncing;   // true while alarm timer interval < 1 minute
--- kmail/kmacctexppop.cpp	3 Jan 2004 22:39:10 -0000	1.145
+++ kmail/kmacctexppop.cpp	25 Jan 2004 22:51:15 -0000	1.145.2.1
@@ -353,6 +353,10 @@
 {
   if (infoMsg != "message complete") return;
   KMMessage *msg = new KMMessage;
+  // Make sure to use LF as line ending to make the processing easier
+  // when piping through external programs
+  uint newSize = KMFolder::crlf2lf( curMsgData.data(), curMsgData.size() );
+  curMsgData.resize( newSize );
   msg->fromByteArray( curMsgData , true );
   if (stage == Head)
   {
@@ -670,7 +674,7 @@
 void KMAcctExpPop::slotData( KIO::Job* job, const QByteArray &data)
 {
   if (data.size() == 0) {
-    kdDebug(5006) << "Data: <End>" << endl; 
+    kdDebug(5006) << "Data: <End>" << endl;
     if ((stage == Retr) && (numMsgBytesRead < curMsgLen))
       numBytesRead += curMsgLen - numMsgBytesRead;
     else if (stage == Head){
--- kmail/kmcommands.cpp	21 Jan 2004 22:59:15 -0000	1.99.2.1
+++ kmail/kmcommands.cpp	25 Jan 2004 19:11:51 -0000	1.99.2.2
@@ -629,7 +629,7 @@
 
 void KMSaveMsgCommand::execute()
 {
-  mJob = KIO::put( mUrl, -1, false, false );
+  mJob = KIO::put( mUrl, S_IRUSR|S_IWUSR, false, false );
   mJob->slotTotalSize( mTotalSize );
   mJob->setAsyncDataEnabled( true );
   mJob->setReportDataSent( true );
@@ -734,7 +734,7 @@
         == KMessageBox::Continue) {
         mOffset = 0;
 
-        mJob = KIO::put( mUrl, -1, true, false );
+        mJob = KIO::put( mUrl, S_IRUSR|S_IWUSR, true, false );
         mJob->slotTotalSize( mTotalSize );
         mJob->setAsyncDataEnabled( true );
         mJob->setReportDataSent( true );
@@ -1862,6 +1862,7 @@
 
     QFile file( filename );
     if( file.open( IO_WriteOnly ) ) {
+      fchmod( file.handle(), S_IRUSR | S_IWUSR );
       if ( mEncoded )
       {
         // This does not decode the Message Content-Transfer-Encoding
--- kmail/kmcomposewin.cpp	4 Jan 2004 16:14:53 -0000	1.770
+++ kmail/kmcomposewin.cpp	25 Jan 2004 22:51:16 -0000	1.770.2.1
@@ -203,14 +203,14 @@
   mAtmListView->setAllColumnsShowFocus( true );
 
   connect( mAtmListView,
-	   SIGNAL( doubleClicked( QListViewItem* ) ),
-	   SLOT( slotAttachProperties() ) );
+           SIGNAL( doubleClicked( QListViewItem* ) ),
+           SLOT( slotAttachProperties() ) );
   connect( mAtmListView,
            SIGNAL( rightButtonPressed( QListViewItem*, const QPoint&, int ) ),
            SLOT( slotAttachPopupMenu( QListViewItem*, const QPoint&, int ) ) );
   connect( mAtmListView,
-	   SIGNAL( selectionChanged() ),
-	   SLOT( slotUpdateAttachActions() ) );
+           SIGNAL( selectionChanged() ),
+           SLOT( slotUpdateAttachActions() ) );
   mAttachMenu = 0;
 
   readConfig();
@@ -220,14 +220,14 @@
   applyMainWindowSettings(KMKernel::config(), "Composer");
 
   connect(mEdtSubject,SIGNAL(textChanged(const QString&)),
-	  SLOT(slotUpdWinTitle(const QString&)));
+          SLOT(slotUpdWinTitle(const QString&)));
   connect(mBtnTo,SIGNAL(clicked()),SLOT(slotAddrBookTo()));
   connect(mBtnCc,SIGNAL(clicked()),SLOT(slotAddrBookTo()));
   connect(mBtnBcc,SIGNAL(clicked()),SLOT(slotAddrBookTo()));
   connect(mBtnReplyTo,SIGNAL(clicked()),SLOT(slotAddrBookReplyTo()));
   //connect(mBtnFrom,SIGNAL(clicked()),SLOT(slotAddrBookFrom()));
   connect(mIdentity,SIGNAL(identityChanged(uint)),
-	  SLOT(slotIdentityChanged(uint)));
+          SLOT(slotIdentityChanged(uint)));
 
   connect(mEdtTo,SIGNAL(completionModeChanged(KGlobalSettings::Completion)),
           SLOT(slotCompletionModeChanged(KGlobalSettings::Completion)));
@@ -239,12 +239,12 @@
           SLOT(slotCompletionModeChanged(KGlobalSettings::Completion)));
   connect(mEdtFrom,SIGNAL(completionModeChanged(KGlobalSettings::Completion)),
           SLOT(slotCompletionModeChanged(KGlobalSettings::Completion)));
-	connect(kmkernel->folderMgr(),SIGNAL(folderRemoved(KMFolder*)),
-					SLOT(slotFolderRemoved(KMFolder*)));
-	connect(kmkernel->imapFolderMgr(),SIGNAL(folderRemoved(KMFolder*)),
-					SLOT(slotFolderRemoved(KMFolder*)));
-	connect(kmkernel->dimapFolderMgr(),SIGNAL(folderRemoved(KMFolder*)),
-					SLOT(slotFolderRemoved(KMFolder*)));
+        connect(kmkernel->folderMgr(),SIGNAL(folderRemoved(KMFolder*)),
+                                        SLOT(slotFolderRemoved(KMFolder*)));
+        connect(kmkernel->imapFolderMgr(),SIGNAL(folderRemoved(KMFolder*)),
+                                        SLOT(slotFolderRemoved(KMFolder*)));
+        connect(kmkernel->dimapFolderMgr(),SIGNAL(folderRemoved(KMFolder*)),
+                                        SLOT(slotFolderRemoved(KMFolder*)));
   connect( kmkernel, SIGNAL( configChanged() ),
            this, SLOT( slotConfigChanged() ) );
 
@@ -353,7 +353,7 @@
     msgPart->setName(name);
     QValueList<int> dummy;
     msgPart->setBodyAndGuessCte(data, dummy,
-				kmkernel->msgSender()->sendQuotedPrintable());
+                                kmkernel->msgSender()->sendQuotedPrintable());
     msgPart->setTypeStr(type);
     msgPart->setSubtypeStr(subType);
     msgPart->setParameter(paramAttr,paramValue);
@@ -715,34 +715,34 @@
 
   if (!fromSlot) mIdentityAction->setChecked(abs(mShowHeaders)&HDR_IDENTITY);
   rethinkHeaderLine(showHeaders,HDR_IDENTITY, row, i18n("&Identity:"),
-		    mLblIdentity, mIdentity, mBtnIdentity);
+                    mLblIdentity, mIdentity, mBtnIdentity);
   if (!fromSlot) mDictionaryAction->setChecked(abs(mShowHeaders)&HDR_DICTIONARY);
   rethinkHeaderLine(showHeaders,HDR_DICTIONARY, row, i18n("&Dictionary:"),
-		    mDictionaryLabel, mDictionaryCombo, 0 );
+                    mDictionaryLabel, mDictionaryCombo, 0 );
   if (!fromSlot) mFccAction->setChecked(abs(mShowHeaders)&HDR_FCC);
   rethinkHeaderLine(showHeaders,HDR_FCC, row, i18n("Se&nt-Mail folder:"),
-		    mLblFcc, mFcc, mBtnFcc);
+                    mLblFcc, mFcc, mBtnFcc);
   if (!fromSlot) mTransportAction->setChecked(abs(mShowHeaders)&HDR_TRANSPORT);
   rethinkHeaderLine(showHeaders,HDR_TRANSPORT, row, i18n("Mai&l transport:"),
-		    mLblTransport, mTransport, mBtnTransport);
+                    mLblTransport, mTransport, mBtnTransport);
   if (!fromSlot) mFromAction->setChecked(abs(mShowHeaders)&HDR_FROM);
   rethinkHeaderLine(showHeaders,HDR_FROM, row, i18n("&From:"),
-		    mLblFrom, mEdtFrom /*, mBtnFrom */ );
+                    mLblFrom, mEdtFrom /*, mBtnFrom */ );
   if (!fromSlot) mReplyToAction->setChecked(abs(mShowHeaders)&HDR_REPLY_TO);
   rethinkHeaderLine(showHeaders,HDR_REPLY_TO,row,i18n("&Reply to:"),
-		    mLblReplyTo, mEdtReplyTo, mBtnReplyTo);
+                    mLblReplyTo, mEdtReplyTo, mBtnReplyTo);
   if (!fromSlot) mToAction->setChecked(abs(mShowHeaders)&HDR_TO);
   rethinkHeaderLine(showHeaders,HDR_TO, row, i18n("To:"),
-		    mLblTo, mEdtTo, mBtnTo);
+                    mLblTo, mEdtTo, mBtnTo);
   if (!fromSlot) mCcAction->setChecked(abs(mShowHeaders)&HDR_CC);
   rethinkHeaderLine(showHeaders,HDR_CC, row, i18n("&CC:"),
-		    mLblCc, mEdtCc, mBtnCc);
+                    mLblCc, mEdtCc, mBtnCc);
   if (!fromSlot) mBccAction->setChecked(abs(mShowHeaders)&HDR_BCC);
   rethinkHeaderLine(showHeaders,HDR_BCC, row, i18n("&BCC:"),
-		    mLblBcc, mEdtBcc, mBtnBcc);
+                    mLblBcc, mEdtBcc, mBtnBcc);
   if (!fromSlot) mSubjectAction->setChecked(abs(mShowHeaders)&HDR_SUBJECT);
   rethinkHeaderLine(showHeaders,HDR_SUBJECT, row, i18n("S&ubject:"),
-		    mLblSubject, mEdtSubject);
+                    mLblSubject, mEdtSubject);
   assert(row<=mNumHeaders);
 
   mGrid->addMultiCellWidget(mEditor, row, mNumHeaders, 0, 2);
@@ -773,8 +773,8 @@
 
 //-----------------------------------------------------------------------------
 void KMComposeWin::rethinkHeaderLine(int aValue, int aMask, int& aRow,
-				     const QString &aLabelStr, QLabel* aLbl,
-				     QLineEdit* aEdt, QPushButton* aBtn)
+                                     const QString &aLabelStr, QLabel* aLbl,
+                                     QLineEdit* aEdt, QPushButton* aBtn)
 {
   if (aValue & aMask)
   {
@@ -810,8 +810,8 @@
 
 //-----------------------------------------------------------------------------
 void KMComposeWin::rethinkHeaderLine(int aValue, int aMask, int& aRow,
-				     const QString &aLabelStr, QLabel* aLbl,
-				     QComboBox* aCbx, QCheckBox* aChk)
+                                     const QString &aLabelStr, QLabel* aLbl,
+                                     QComboBox* aCbx, QCheckBox* aChk)
 {
   if (aValue & aMask)
   {
@@ -870,8 +870,8 @@
   }
 
   (void) new KAction (i18n("Save in &Drafts Folder"), "filesave", 0,
-		      this, SLOT(slotSaveDraft()),
-		      actionCollection(), "save_in_drafts");
+                      this, SLOT(slotSaveDraft()),
+                      actionCollection(), "save_in_drafts");
   (void) new KAction (i18n("&Insert File..."), "fileopen", 0,
                       this,  SLOT(slotInsertFile()),
                       actionCollection(), "insert_file");
@@ -923,15 +923,15 @@
                                     actionCollection(),
                                     "urgent");
   mRequestMDNAction = new KToggleAction ( i18n("&Request Disposition Notification"), 0,
-					 actionCollection(),
-					 "options_request_mdn");
+                                         actionCollection(),
+                                         "options_request_mdn");
   mRequestMDNAction->setChecked(mAutoRequestMDN);
   //----- Message-Encoding Submenu
   mEncodingAction = new KSelectAction( i18n( "Se&t Encoding" ), "charset",
-				      0, this, SLOT(slotSetCharset() ),
-				      actionCollection(), "charsets" );
+                                      0, this, SLOT(slotSetCharset() ),
+                                      actionCollection(), "charsets" );
   mWordWrapAction = new KToggleAction (i18n("&Wordwrap"), 0,
-		      actionCollection(), "wordwrap");
+                      actionCollection(), "wordwrap");
   mWordWrapAction->setChecked(mWordWrap);
   connect(mWordWrapAction, SIGNAL(toggled(bool)), SLOT(slotWordWrapToggled(bool)));
 
@@ -957,8 +957,8 @@
                                        SLOT(slotView()),
                                        actionCollection(), "show_all_fields");
   mIdentityAction = new KToggleAction (i18n("&Identity"), 0, this,
-				      SLOT(slotView()),
-				      actionCollection(), "show_identity");
+                                      SLOT(slotView()),
+                                      actionCollection(), "show_identity");
   mDictionaryAction = new KToggleAction (i18n("&Dictionary"), 0, this,
                                          SLOT(slotView()),
                                          actionCollection(), "show_dictionary");
@@ -966,8 +966,8 @@
                                  SLOT(slotView()),
                                  actionCollection(), "show_fcc");
   mTransportAction = new KToggleAction (i18n("&Mail Transport"), 0, this,
-				      SLOT(slotView()),
-				      actionCollection(), "show_transport");
+                                      SLOT(slotView()),
+                                      actionCollection(), "show_transport");
   mFromAction = new KToggleAction (i18n("&From"), 0, this,
                                   SLOT(slotView()),
                                   actionCollection(), "show_from");
@@ -1142,13 +1142,13 @@
   slotUpdateFont();
 
   /* installRBPopup() is broken in kdelibs, we should wait for
-	  the new klibtextedit (dnaber, 2002-01-01)
+          the new klibtextedit (dnaber, 2002-01-01)
   menu = new QPopupMenu(this);
   //#ifdef BROKEN
   menu->insertItem(i18n("Undo"),mEditor,
-		   SLOT(undo()), KStdAccel::shortcut(KStdAccel::Undo));
+                   SLOT(undo()), KStdAccel::shortcut(KStdAccel::Undo));
   menu->insertItem(i18n("Redo"),mEditor,
-		   SLOT(redo()), KStdAccel::shortcut(KStdAccel::Redo));
+                   SLOT(redo()), KStdAccel::shortcut(KStdAccel::Redo));
   menu->insertSeparator();
   //#endif //BROKEN
   menu->insertItem(i18n("Cut"), this, SLOT(slotCut()));
@@ -1175,11 +1175,11 @@
   int oldPos = 0;
   if (mEditor->QMultiLineEdit::wordWrap() == QMultiLineEdit::FixedColumnWidth) {
     for (curPos = 0; curPos < (int)body.length(); ++curPos)
-	if (body[curPos] == '\n') {
-	  if ((curPos - oldPos) > maxLineLength)
-	    maxLineLength = curPos - oldPos;
-	  oldPos = curPos;
-	}
+        if (body[curPos] == '\n') {
+          if ((curPos - oldPos) > maxLineLength)
+            maxLineLength = curPos - oldPos;
+          oldPos = curPos;
+        }
     if ((curPos - oldPos) > maxLineLength)
       maxLineLength = curPos - oldPos;
     if (mEditor->wrapColumnOrWidth() < maxLineLength) // column
@@ -1220,7 +1220,7 @@
 
 //-----------------------------------------------------------------------------
 void KMComposeWin::setMsg(KMMessage* newMsg, bool mayAutoSign,
-			  bool allowDecryption, bool isModified)
+                          bool allowDecryption, bool isModified)
 {
   KMMessagePart bodyPart, *msgPart;
   int i, num;
@@ -1271,7 +1271,7 @@
   // requested
   QString mdnAddr = newMsg->headerField("Disposition-Notification-To");
   mRequestMDNAction->setChecked( ( !mdnAddr.isEmpty() &&
-				  im->thatIsMe( mdnAddr ) ) || mAutoRequestMDN );
+                                  im->thatIsMe( mdnAddr ) ) || mAutoRequestMDN );
 
   // check for presence of a priority header, indicating urgent mail:
   mUrgentAction->setChecked( newMsg->isUrgent() );
@@ -1452,7 +1452,7 @@
            i18n("Do you want to discard the message or save it for later?"),
            i18n("Discard or Save Message"),
            i18n("&Save as Draft"),
-	   KStdGuiItem::discard() );
+           KStdGuiItem::discard() );
     if (rc == KMessageBox::Cancel)
       return false;
     else if (rc == KMessageBox::Yes)
@@ -1685,128 +1685,128 @@
     else {
       // check whether all encrypted messages should be encrypted to self
       bool bEncryptToSelf = mSelectedCryptPlug
-	? mSelectedCryptPlug->alwaysEncryptToSelf()
-	: Kpgp::Module::getKpgp()->encryptToSelf();
+        ? mSelectedCryptPlug->alwaysEncryptToSelf()
+        : Kpgp::Module::getKpgp()->encryptToSelf();
       // check whether we have the user's key if necessary
       bool bEncryptionPossible = !bEncryptToSelf || !pgpUserId.isEmpty();
       // check whether we are using OpenPGP (built-in or plug-in)
       bool bUsingOpenPgp = !mSelectedCryptPlug || ( mSelectedCryptPlug &&
-						    ( -1 != mSelectedCryptPlug->libName().find( "openpgp" ) ) );
+                                                    ( -1 != mSelectedCryptPlug->libName().find( "openpgp" ) ) );
       // only try automatic encryption if all of the following conditions hold
       // a) the user enabled automatic encryption
       // b) we have the user's key if he wants to encrypt to himself
       // c) we are using OpenPGP
       // d) no message part is marked for encryption
       if( mAutoPgpEncrypt && bEncryptionPossible && bUsingOpenPgp &&
-	  !doEncryptPartially ) {
-	// check if encryption is possible and if yes suggest encryption
-	// first determine the complete list of recipients
-	QString _to = to().simplifyWhiteSpace();
-	if( !cc().isEmpty() ) {
-	  if( !_to.endsWith(",") )
-	    _to += ",";
-	  _to += cc().simplifyWhiteSpace();
-	}
-	if( !mBcc.isEmpty() ) {
-	  if( !_to.endsWith(",") )
-	    _to += ",";
-	  _to += mBcc.simplifyWhiteSpace();
-	}
-	QStringList allRecipients = KMMessage::splitEmailAddrList(_to);
-	// now check if encrypting to these recipients is possible and desired
-	Kpgp::Module *pgp = Kpgp::Module::getKpgp();
-	int status = pgp->encryptionPossible( allRecipients );
-	if( 1 == status ) {
-	  // encrypt all message parts
-	  doEncrypt = true;
-	  doEncryptCompletely = true;
-	}
-	else if( 2 == status ) {
-	  // the user wants to be asked or has to be asked
+          !doEncryptPartially ) {
+        // check if encryption is possible and if yes suggest encryption
+        // first determine the complete list of recipients
+        QString _to = to().simplifyWhiteSpace();
+        if( !cc().isEmpty() ) {
+          if( !_to.endsWith(",") )
+            _to += ",";
+          _to += cc().simplifyWhiteSpace();
+        }
+        if( !mBcc.isEmpty() ) {
+          if( !_to.endsWith(",") )
+            _to += ",";
+          _to += mBcc.simplifyWhiteSpace();
+        }
+        QStringList allRecipients = KMMessage::splitEmailAddrList(_to);
+        // now check if encrypting to these recipients is possible and desired
+        Kpgp::Module *pgp = Kpgp::Module::getKpgp();
+        int status = pgp->encryptionPossible( allRecipients );
+        if( 1 == status ) {
+          // encrypt all message parts
+          doEncrypt = true;
+          doEncryptCompletely = true;
+        }
+        else if( 2 == status ) {
+          // the user wants to be asked or has to be asked
           KCursorSaver idle(KBusyPtr::idle());
-	  int ret;
-	  if( doSign )
-	    ret = KMessageBox::questionYesNoCancel( this,
-						    i18n("<qt><p>You have a trusted OpenPGP key for every "
-							 "recipient of this message and the message will "
-							 "be signed.</p>"
-							 "<p>Should this message also be "
-							 "encrypted?</p></qt>"),
-						    i18n("Encrypt Message?"),
-						    KGuiItem( i18n("Sign && &Encrypt") ),
-						    KGuiItem( i18n("&Sign Only") ) );
-	  else
-	    ret = KMessageBox::questionYesNoCancel( this,
-						    i18n("<qt><p>You have a trusted OpenPGP key for every "
-							 "recipient of this message.</p>"
-							 "<p>Should this message be encrypted?</p></qt>"),
-						    i18n("Encrypt Message?"),
-						    KGuiItem( i18n("&Encrypt") ),
-						    KGuiItem( i18n("&Don't Encrypt") ) );
-	  if( KMessageBox::Cancel == ret )
-	    return false;
-	  else if( KMessageBox::Yes == ret ) {
-	    // encrypt all message parts
-	    doEncrypt = true;
-	    doEncryptCompletely = true;
-	  }
-	}
-	else if( status == -1 )
-	{
+          int ret;
+          if( doSign )
+            ret = KMessageBox::questionYesNoCancel( this,
+                                                    i18n("<qt><p>You have a trusted OpenPGP key for every "
+                                                         "recipient of this message and the message will "
+                                                         "be signed.</p>"
+                                                         "<p>Should this message also be "
+                                                         "encrypted?</p></qt>"),
+                                                    i18n("Encrypt Message?"),
+                                                    KGuiItem( i18n("Sign && &Encrypt") ),
+                                                    KGuiItem( i18n("&Sign Only") ) );
+          else
+            ret = KMessageBox::questionYesNoCancel( this,
+                                                    i18n("<qt><p>You have a trusted OpenPGP key for every "
+                                                         "recipient of this message.</p>"
+                                                         "<p>Should this message be encrypted?</p></qt>"),
+                                                    i18n("Encrypt Message?"),
+                                                    KGuiItem( i18n("&Encrypt") ),
+                                                    KGuiItem( i18n("&Don't Encrypt") ) );
+          if( KMessageBox::Cancel == ret )
+            return false;
+          else if( KMessageBox::Yes == ret ) {
+            // encrypt all message parts
+            doEncrypt = true;
+            doEncryptCompletely = true;
+          }
+        }
+        else if( status == -1 )
+        {
           // warn the user that there are conflicting encryption preferences
           KCursorSaver idle(KBusyPtr::idle());
-	  int ret =
-	    KMessageBox::warningYesNoCancel( this,
-					     i18n("<qt><p>There are conflicting encryption "
-						  "preferences!</p>"
-						  "<p>Should this message be encrypted?</p></qt>"),
-					     i18n("Encrypt Message?"),
-					     KGuiItem( i18n("&Encrypt") ),
-					     KGuiItem( i18n("&Don't Encrypt") ) );
-	  if( KMessageBox::Cancel == ret )
-	    bOk = false;
-	  else if( KMessageBox::Yes == ret ) {
-	    // encrypt all message parts
-	    doEncrypt = true;
-	    doEncryptCompletely = true;
-	  }
-	}
+          int ret =
+            KMessageBox::warningYesNoCancel( this,
+                                             i18n("<qt><p>There are conflicting encryption "
+                                                  "preferences!</p>"
+                                                  "<p>Should this message be encrypted?</p></qt>"),
+                                             i18n("Encrypt Message?"),
+                                             KGuiItem( i18n("&Encrypt") ),
+                                             KGuiItem( i18n("&Don't Encrypt") ) );
+          if( KMessageBox::Cancel == ret )
+            bOk = false;
+          else if( KMessageBox::Yes == ret ) {
+            // encrypt all message parts
+            doEncrypt = true;
+            doEncryptCompletely = true;
+          }
+        }
       }
       else if( !doEncryptCompletely && mSelectedCryptPlug ) {
-	// note: only ask for encrypting if "Warn me" flag is set! (khz)
-	if( mSelectedCryptPlug->warnSendUnencrypted() ) {
-	  int ret =
-	    KMessageBox::warningYesNoCancel( this,
-					     QString( "<qt><b>"
-						      + i18n("Warning:")
-						      + "</b><br>"
-						      + ((doEncrypt && !doEncryptCompletely)
-							 ? i18n("You specified not to encrypt some parts of this message, but"
-								" you wanted to be warned not to send unencrypted messages!")
-							 : i18n("You specified not to encrypt this message, but"
-								" you wanted to be warned not to send unencrypted messages!") )
-						      + "<br>&nbsp;<br><b>"
-						      + i18n("Encrypt all parts of this message?")
-						      + "</b></qt>" ),
-					     i18n("Encryption Warning"),
-					     KGuiItem( i18n("&Encrypt All Parts") ),
-					     KGuiItem( i18n("Send &as is") ) );
-	  if( ret == KMessageBox::Cancel )
-	    bOk = false;
-	  else if( ret == KMessageBox::Yes ) {
-	    doEncrypt = true;
-	    doEncryptCompletely = true;
-	  }
-	}
-
-	/*
-	  note: Processing the mSelectedCryptPlug->encryptEmail() flag here would
-	  be absolutely wrong: this is used for specifying
-	  if messages should be encrypted 'in general'.
-	  --> This sets the initial state of a freshly started Composer.
-	  --> This does *not* mean overriding user setting made while
-	  editing in that composer window!         (khz, 2002/06/26)
-	*/
+        // note: only ask for encrypting if "Warn me" flag is set! (khz)
+        if( mSelectedCryptPlug->warnSendUnencrypted() ) {
+          int ret =
+            KMessageBox::warningYesNoCancel( this,
+                                             QString( "<qt><b>"
+                                                      + i18n("Warning:")
+                                                      + "</b><br>"
+                                                      + ((doEncrypt && !doEncryptCompletely)
+                                                         ? i18n("You specified not to encrypt some parts of this message, but"
+                                                                " you wanted to be warned not to send unencrypted messages!")
+                                                         : i18n("You specified not to encrypt this message, but"
+                                                                " you wanted to be warned not to send unencrypted messages!") )
+                                                      + "<br>&nbsp;<br><b>"
+                                                      + i18n("Encrypt all parts of this message?")
+                                                      + "</b></qt>" ),
+                                             i18n("Encryption Warning"),
+                                             KGuiItem( i18n("&Encrypt All Parts") ),
+                                             KGuiItem( i18n("Send &as is") ) );
+          if( ret == KMessageBox::Cancel )
+            bOk = false;
+          else if( ret == KMessageBox::Yes ) {
+            doEncrypt = true;
+            doEncryptCompletely = true;
+          }
+        }
+
+        /*
+          note: Processing the mSelectedCryptPlug->encryptEmail() flag here would
+          be absolutely wrong: this is used for specifying
+          if messages should be encrypted 'in general'.
+          --> This sets the initial state of a freshly started Composer.
+          --> This does *not* mean overriding user setting made while
+          editing in that composer window!         (khz, 2002/06/26)
+        */
 
       }
     }
@@ -2376,10 +2376,10 @@
 
         StructuringInfoWrapper structuring( mSelectedCryptPlug );
 
-	QByteArray encryptedBody;
+        QByteArray encryptedBody;
         result = pgpEncryptedMsg( encryptedBody, innerContent,
-				  structuring,
-				  encryptCertFingerprints );
+                                  structuring,
+                                  encryptCertFingerprints );
 
         if( Kpgp::Ok == result ) {
           result = processStructuringInfo( QString::fromUtf8( mSelectedCryptPlug->bugURL() ),
@@ -2542,10 +2542,10 @@
             if( encryptThisNow ) {
 kdDebug(5006) << "                                 encrypt " << idx << ". attachment separately" << endl;
               StructuringInfoWrapper structuring( mSelectedCryptPlug );
-	      QByteArray encryptedBody;
+              QByteArray encryptedBody;
               result = pgpEncryptedMsg( encryptedBody, encodedAttachment,
-					structuring,
-					encryptCertFingerprints );
+                                        structuring,
+                                        encryptCertFingerprints );
 
               if( Kpgp::Ok == result ) {
                 result = processStructuringInfo( QString::fromUtf8( mSelectedCryptPlug->bugURL() ),
@@ -2831,12 +2831,12 @@
         codeStr += structuring.data.contentTypeCode;
         if(    structuring.data.contentTEncCode
             && 0 < strlen( structuring.data.contentTEncCode ) ) {
-	  codeStr += "\nContent-Transfer-Encoding: ";
+          codeStr += "\nContent-Transfer-Encoding: ";
           codeStr += structuring.data.contentTEncCode;
-	//} else {
+        //} else {
         //  codeStr += "\nContent-Transfer-Encoding: ";
-	//  codeStr += "base64";
-	}
+        //  codeStr += "base64";
+        }
         if( !contentDescCiph.isEmpty() ) {
           codeStr += "\nContent-Description: ";
           codeStr += contentDescCiph.utf8();
@@ -2855,7 +2855,7 @@
         //    && 0 < strlen( structuring.data.contentTEncCode ) ) {
         //  codeKmPa.setCteStr( structuring.data.contentTEncCode );
         //} else {
-	//  codeKmPa.setCteStr("base64");
+        //  codeKmPa.setCteStr("base64");
         //}
         codeKmPa.setBodyEncodedBinary( ciphertext );
         // store string representation of the cleartext headers
@@ -3016,7 +3016,7 @@
       QString oldText = mEditor->text();
       mEditor->setText(newText);
       KCursorSaver idle(KBusyPtr::idle());
-      bool anyway = (KMessageBox::warningYesNo(0,
+      bool anyway = (KMessageBox::warningYesNo(this,
                                                i18n("<qt>Not all characters fit into the chosen"
                                                     " encoding.<br><br>Send the message anyway?</qt>"),
                                                i18n("Some characters will be lost"),
@@ -3346,8 +3346,8 @@
                 }
                 signature.assign( ciphertext, cipherLen );
             } else if ( errId == /*GPGME_Canceled*/20 ) {
-	        return false;
-	    } else {
+                return false;
+            } else {
                 QString error("#");
                 error += QString::number( errId );
                 error += "  :  ";
@@ -3391,9 +3391,9 @@
 
 //-----------------------------------------------------------------------------
 Kpgp::Result KMComposeWin::pgpEncryptedMsg( QByteArray & encryptedBody,
-					    QCString cText,
-					    StructuringInfoWrapper& structuring,
-					    QCString& encryptCertFingerprints )
+                                            QCString cText,
+                                            StructuringInfoWrapper& structuring,
+                                            QCString& encryptCertFingerprints )
 {
   Kpgp::Result result = Kpgp::Ok;
 
@@ -3431,7 +3431,7 @@
                         KGuiItem( i18n( "&Encrypt" ) ),
                         KGuiItem( i18n( "&Don't Encrypt" ) ) );
             if( ret == KMessageBox::No )
-	      return Kpgp::Canceled;
+              return Kpgp::Canceled;
         }
     }
 #endif
@@ -3734,7 +3734,7 @@
 void KMComposeWin::addAttach(const KURL aUrl)
 {
   if ( !aUrl.isValid() ) {
-    KMessageBox::sorry( 0, i18n( "<qt><p>KMail couldn't recognize the location of the attachment (%1).</p>"
+    KMessageBox::sorry( this, i18n( "<qt><p>KMail couldn't recognize the location of the attachment (%1).</p>"
                                  "<p>You have to specify the full path if you wish to attach a file.</p></qt>" )
                         .arg( aUrl.prettyURL() ) );
     return;
@@ -3987,7 +3987,7 @@
   // this function.
 
   KURL::List files = KFileDialog::getOpenURLs(QString::null, QString::null,
-	this, i18n("Attach File"));
+        this, i18n("Attach File"));
   for (KURL::List::Iterator it = files.begin(); it != files.end(); ++it)
     addAttach(*it);
 }
@@ -4074,7 +4074,7 @@
   msgPart->setName(name);
   QValueList<int> allowedCTEs;
   msgPart->setBodyAndGuessCte((*it).data, allowedCTEs,
-			      !kmkernel->msgSender()->sendQuotedPrintable());
+                              !kmkernel->msgSender()->sendQuotedPrintable());
   kdDebug(5006) << "autodetected cte: " << msgPart->cteStr() << endl;
   int slash = mimeType.find( '/' );
   if( slash == -1 )
@@ -4097,7 +4097,7 @@
     KMMsgPartDialogCompat dlg;
     int encodings = 0;
     for ( QValueListConstIterator<int> it = allowedCTEs.begin() ;
-	  it != allowedCTEs.end() ; ++it )
+          it != allowedCTEs.end() ; ++it )
       switch ( *it ) {
       case DwMime::kCteBase64: encodings |= KMMsgPartDialog::Base64; break;
       case DwMime::kCteQp: encodings |= KMMsgPartDialog::QuotedPrintable; break;
@@ -4274,7 +4274,7 @@
   if (armoredKey.isEmpty())
   {
     KCursorSaver idle(KBusyPtr::idle());
-    KMessageBox::sorry( 0, i18n("Unable to obtain your public key.") );
+    KMessageBox::sorry( this, i18n("Unable to obtain your public key.") );
     return;
   }
 
@@ -4324,7 +4324,8 @@
     addAttach(msgPart);
     rethinkFields(); //work around initial-size bug in Qt-1.32
   } else {
-    KMessageBox::sorry( 0, i18n( "Unable to obtain the selected public key." ) );
+    KMessageBox::sorry( this,
+                        i18n( "Unable to obtain the selected public key." ) );
   }
 }
 
@@ -4843,18 +4844,23 @@
      if (to().isEmpty())
      {
         mEdtTo->setFocus();
-        KMessageBox::information(0,i18n("You must specify at least one receiver in the To: field."));
+        KMessageBox::information( this,
+                                  i18n("You must specify at least one "
+                                       "receiver in the To: field.") );
         return false;
      }
 
      if (subject().isEmpty())
      {
         mEdtSubject->setFocus();
-        int rc = KMessageBox::questionYesNo(0, i18n("You did not specify a subject. Send message anyway?"),
-                                            i18n("No Subject Specified"),
-                                            i18n("&Yes, Send as Is"),
-                                            i18n("&No, Let Me Specify the Subject"),
-                                            "no_subject_specified" );
+        int rc =
+          KMessageBox::questionYesNo( this,
+                                      i18n("You did not specify a subject. "
+                                           "Send message anyway?"),
+                                      i18n("No Subject Specified"),
+                                      i18n("&Yes, Send as Is"),
+                                      i18n("&No, Let Me Specify the Subject"),
+                                      "no_subject_specified" );
         if( rc == KMessageBox::No )
         {
            return false;
@@ -5261,7 +5267,7 @@
   KEditToolbar dlg(actionCollection(), "kmcomposerui.rc");
 
   connect( &dlg, SIGNAL(newToolbarConfig()),
-	   SLOT(slotUpdateToolbars()) );
+           SLOT(slotUpdateToolbars()) );
 
   dlg.exec();
 }
@@ -5275,8 +5281,8 @@
 void KMComposeWin::slotEditKeys()
 {
   KKeyDialog::configure( actionCollection(),
-			 false /*don't allow one-letter shortcuts*/
-			 );
+                         false /*don't allow one-letter shortcuts*/
+                         );
 }
 
 void KMComposeWin::setReplyFocus( bool hasMessage )
@@ -5317,12 +5323,12 @@
 */
 void KMComposeWin::slotFolderRemoved(KMFolder* folder)
 {
-	if ( (mFolder) && (folder->idString() == mFolder->idString()) )
-	{
-		mFolder = kmkernel->draftsFolder();
-		kdDebug(5006) << "restoring drafts to " << mFolder->idString() << endl;
-	}
-	if (mMsg) mMsg->setParent(0);
+        if ( (mFolder) && (folder->idString() == mFolder->idString()) )
+        {
+                mFolder = kmkernel->draftsFolder();
+                kdDebug(5006) << "restoring drafts to " << mFolder->idString() << endl;
+        }
+        if (mMsg) mMsg->setParent(0);
 }
 
 
@@ -5335,17 +5341,17 @@
 void KMEdit::contentsDragEnterEvent(QDragEnterEvent *e)
 {
     if (e->provides(MailListDrag::format()))
-	e->accept(true);
+        e->accept(true);
     else
-	return KEdit::dragEnterEvent(e);
+        return KEdit::dragEnterEvent(e);
 }
 
 void KMEdit::contentsDragMoveEvent(QDragMoveEvent *e)
 {
     if (e->provides(MailListDrag::format()))
-	e->accept();
+        e->accept();
     else
-	return KEdit::dragMoveEvent(e);
+        return KEdit::dragMoveEvent(e);
 }
 
 void KMEdit::keyPressEvent( QKeyEvent* e )
@@ -5410,31 +5416,31 @@
 void KMEdit::contentsDropEvent(QDropEvent *e)
 {
     if (e->provides(MailListDrag::format())) {
-	// Decode the list of serial numbers stored as the drag data
-	QByteArray serNums;
-	MailListDrag::decode( e, serNums );
-	QBuffer serNumBuffer(serNums);
-	serNumBuffer.open(IO_ReadOnly);
-	QDataStream serNumStream(&serNumBuffer);
-	unsigned long serNum;
-	KMFolder *folder = 0;
-	int idx;
-	QPtrList<KMMsgBase> messageList;
-	while (!serNumStream.atEnd()) {
-	    KMMsgBase *msgBase = 0;
-	    serNumStream >> serNum;
-	    kmkernel->msgDict()->getLocation(serNum, &folder, &idx);
-	    if (folder)
-		msgBase = folder->getMsgBase(idx);
-	    if (msgBase)
-		messageList.append( msgBase );
-	}
-	serNumBuffer.close();
-	uint identity = folder ? folder->identity() : 0;
-	KMCommand *command =
-	    new KMForwardAttachedCommand(mComposer, messageList,
-					 identity, mComposer);
-	command->start();
+        // Decode the list of serial numbers stored as the drag data
+        QByteArray serNums;
+        MailListDrag::decode( e, serNums );
+        QBuffer serNumBuffer(serNums);
+        serNumBuffer.open(IO_ReadOnly);
+        QDataStream serNumStream(&serNumBuffer);
+        unsigned long serNum;
+        KMFolder *folder = 0;
+        int idx;
+        QPtrList<KMMsgBase> messageList;
+        while (!serNumStream.atEnd()) {
+            KMMsgBase *msgBase = 0;
+            serNumStream >> serNum;
+            kmkernel->msgDict()->getLocation(serNum, &folder, &idx);
+            if (folder)
+                msgBase = folder->getMsgBase(idx);
+            if (msgBase)
+                messageList.append( msgBase );
+        }
+        serNumBuffer.close();
+        uint identity = folder ? folder->identity() : 0;
+        KMCommand *command =
+            new KMForwardAttachedCommand(mComposer, messageList,
+                                         identity, mComposer);
+        command->start();
     }
     else if( KURLDrag::canDecode( e ) ) {
         KURL::List urlList;
@@ -5446,7 +5452,7 @@
         }
     }
     else {
-	return KEdit::dropEvent(e);
+        return KEdit::dropEvent(e);
     }
 }
 
@@ -5708,7 +5714,7 @@
 void KMLineEditSpell::spellCheckDone( const QString &s )
 {
     if( s != text() )
-	setText( s );
+        setText( s );
 }
 
 void KMLineEditSpell::spellCheckerMisspelling( const QString &_text, const QStringList&, unsigned int pos)
@@ -5734,7 +5740,7 @@
 //=============================================================================
 KMEdit::KMEdit(QWidget *parent, KMComposeWin* composer,
                KSpellConfig* autoSpellConfig,
-	       const char *name)
+               const char *name)
   : KEdit( parent, name ),
     mComposer( composer ),
     mKSpell( 0 ),
@@ -5775,7 +5781,7 @@
                                                 col1, col2, col3, col4,
                                                 autoSpellConfig );
   connect( mSpellChecker, SIGNAL(activeChanged(const QString &)),
-	   mComposer, SLOT(slotStatusMessage(const QString &)));
+           mComposer, SLOT(slotStatusMessage(const QString &)));
   connect( mSpellChecker, SIGNAL(newSuggestions(const QString&, const QStringList&, unsigned int)),
            this, SLOT(addSuggestion(const QString&, const QStringList&, unsigned int)) );
 }
@@ -5864,13 +5870,14 @@
               SLOT(slotExternalEditorDone(KProcess*)));
       if (!mExtEditorProcess->start())
       {
-        KMessageBox::error(0, i18n("Unable to start external editor."));
-	killExternalEditor();
+        KMessageBox::error( topLevelWidget(),
+                            i18n("Unable to start external editor.") );
+        killExternalEditor();
       } else {
-	mExtEditorTempFileWatcher = new KDirWatch( this, "mExtEditorTempFileWatcher" );
-	connect( mExtEditorTempFileWatcher, SIGNAL(dirty(const QString&)),
-		 SLOT(slotExternalEditorTempFileChanged(const QString&)) );
-	mExtEditorTempFileWatcher->addFile( mExtEditorTempFile->name() );
+        mExtEditorTempFileWatcher = new KDirWatch( this, "mExtEditorTempFileWatcher" );
+        connect( mExtEditorTempFileWatcher, SIGNAL(dirty(const QString&)),
+                 SLOT(slotExternalEditorTempFileChanged(const QString&)) );
+        mExtEditorTempFileWatcher->addFile( mExtEditorTempFile->name() );
       }
       return TRUE;
     } else {
@@ -5999,11 +6006,11 @@
 bool KMEdit::checkExternalEditorFinished() {
   if ( !mExtEditorProcess )
     return true;
-  switch ( KMessageBox::warningYesNoCancel( this,
+  switch ( KMessageBox::warningYesNoCancel( topLevelWidget(),
            i18n("The external editor is still running.\n"
-		"Abort the external editor or leave it open?"),
+                "Abort the external editor or leave it open?"),
            i18n("External Editor"),
-	   i18n("Abort Editor"), i18n("Leave Editor Open") ) ) {
+           i18n("Abort Editor"), i18n("Leave Editor Open") ) ) {
   case KMessageBox::Yes:
     killExternalEditor();
     return true;
@@ -6022,7 +6029,7 @@
   mWasModifiedBeforeSpellCheck = isModified();
   mSpellLineEdit = !mSpellLineEdit;
   mKSpell = new KSpell(this, i18n("Spellcheck - KMail"), this,
-		       SLOT(slotSpellcheck2(KSpell*)));
+                       SLOT(slotSpellcheck2(KSpell*)));
   QStringList l = KSpellingHighlighter::personalWords();
   for ( QStringList::Iterator it = l.begin(); it != l.end(); ++it ) {
       mKSpell->addPersonal( *it );
@@ -6158,13 +6165,17 @@
   mComposer->sujectLineWidget()->deselect();
   if (status == KSpell::Error)
   {
-     KMessageBox::sorry(this, i18n("ISpell/Aspell could not be started. Please make sure you have ISpell or Aspell properly configured and in your PATH."));
+     KMessageBox::sorry( topLevelWidget(),
+                         i18n("ISpell/Aspell could not be started. Please "
+                              "make sure you have ISpell or Aspell properly "
+                              "configured and in your PATH.") );
      emit spellcheck_done( KS_CANCEL );
   }
   else if (status == KSpell::Crashed)
   {
      spellcheck_stop();
-     KMessageBox::sorry(this, i18n("ISpell/Aspell seems to have crashed."));
+     KMessageBox::sorry( topLevelWidget(),
+                         i18n("ISpell/Aspell seems to have crashed.") );
      emit spellcheck_done( KS_CANCEL );
   }
   else
@@ -6173,7 +6184,8 @@
           spellcheck();
 #if KDE_IS_VERSION( 3, 1, 90 )
       else if( status == KSpell::FinishedNoMisspellingsEncountered )
-          KMessageBox::information( this, i18n("No misspellings encountered."));
+          KMessageBox::information( topLevelWidget(),
+                                    i18n("No misspellings encountered.") );
 #endif
   }
 }
--- kmail/kmfilter.cpp	29 Nov 2003 15:46:43 -0000	1.58
+++ kmail/kmfilter.cpp	4 Feb 2004 17:25:57 -0000	1.58.4.1
@@ -147,9 +147,18 @@
   // that the pattern is purified.
   mPattern.readConfig(config);
 
-  if (bPopFilter)
+  if (bPopFilter) {
     // get the action description...
-    mAction = (KMPopFilterAction) config->readNumEntry( "action" );
+    QString action = config->readEntry( "action" );
+    if ( action == "down" )
+      mAction = Down;
+    else if ( action == "later" )
+      mAction = Later;
+    else if ( action == "delete" )
+      mAction = Delete;
+    else
+      mAction = NoAction;
+  }
   else {
     QStringList sets = config->readListEntry("apply-on");
     if ( sets.isEmpty() && !config->hasKey("apply-on") ) {
@@ -210,7 +219,19 @@
   mPattern.writeConfig(config);
 
   if (bPopFilter) {
-    config->writeEntry( "action", mAction );
+    switch ( mAction ) {
+    case Down:
+      config->writeEntry( "action", "down" );
+      break;
+    case Later:
+      config->writeEntry( "action", "later" );
+      break;
+    case Delete:
+      config->writeEntry( "action", "delete" );
+      break;
+    default:
+      config->writeEntry( "action", "" );
+    }
   } else {
     QStringList sets;
     if ( bApplyOnInbound )
--- kmail/kmfilterdlg.cpp	26 Oct 2003 19:07:37 -0000	1.108
+++ kmail/kmfilterdlg.cpp	1 Feb 2004 16:20:16 -0000	1.108.6.1
@@ -648,7 +648,7 @@
      i18n("Rename Filter"),
      i18n("Rename filter \"%1\" to:").arg( filter->pattern()->name() ) /*label*/,
      filter->pattern()->name() /* initial value */,
-     &okPressed, 0 /* parent */
+     &okPressed, topLevelWidget()
      );
 
   if ( !okPressed ) return;
--- kmail/kmfolderimap.cpp	14 Jan 2004 23:05:04 -0000	1.163
+++ kmail/kmfolderimap.cpp	4 Feb 2004 10:10:11 -0000	1.163.2.2
@@ -1207,7 +1207,16 @@
 {
   KURL url = mAccount->getUrl();
   KMFolderImap *msg_parent = static_cast<KMFolderImap*>(msg->parent());
-  url.setPath(msg_parent->imapPath() + ";UID=" + msg->headerField("X-UID"));
+  const QString uid = msg->headerField("X-UID");
+  /* If the uid is empty the delete job below will nuke all mail in the 
+     folder, so we better safeguard against that. See ::expungeFolder, as
+     to why. :( */
+  if ( uid.isEmpty() ) {
+     kdDebug( 5006 ) << "KMFolderImap::deleteMessage: Attempt to delete "
+                        "an empty UID. Aborting."  << endl;
+     return;
+  }
+  url.setPath(msg_parent->imapPath() + ";UID=" + uid );
   if ( mAccount->makeConnection() != ImapAccountBase::Connected )
     return;
   KIO::SimpleJob *job = KIO::file_delete(url, FALSE);
@@ -1228,7 +1237,11 @@
   KMFolderImap *msg_parent = static_cast<KMFolderImap*>(msgList.first()->parent());
   for ( QStringList::Iterator it = sets.begin(); it != sets.end(); ++it )
   {
-    url.setPath(msg_parent->imapPath() + ";UID=" + *it);
+    const QString uid = *it;
+    // Don't delete with no uid, that nukes the folder. Should not happen, but
+    // better safe than sorry.
+    if ( uid.isEmpty() ) continue;
+    url.setPath(msg_parent->imapPath() + ";UID=" + uid);
     if ( mAccount->makeConnection() != ImapAccountBase::Connected )
       return;
     KIO::SimpleJob *job = KIO::file_delete(url, FALSE);
--- kmail/kmfoldermaildir.cpp	12 Dec 2003 10:53:46 -0000	1.79
+++ kmail/kmfoldermaildir.cpp	25 Jan 2004 22:51:16 -0000	1.79.4.1
@@ -134,7 +134,7 @@
 
   assert(!name().isEmpty());
   assert(mOpenCount == 0);
-  
+
   // Make sure that neither a new, cur or tmp subfolder exists already.
   QFileInfo dirinfo;
   dirinfo.setFile(location() + "/new");
@@ -143,7 +143,7 @@
   if (dirinfo.exists()) return 1;
   dirinfo.setFile(location() + "/tmp");
   if (dirinfo.exists()) return 1;
-  
+
   // create the maildir directory structure
   if (::mkdir(QFile::encodeName(location()), S_IRWXU) > 0)
   {
@@ -509,7 +509,7 @@
   {
     FILE* stream = fopen(QFile::encodeName(abs_file), "r+");
     if (stream) {
-      size_t msgSize = mi->msgSize();
+      size_t msgSize = fi.size();
       char* msgText = new char[ msgSize + 1 ];
       fread(msgText, msgSize, 1, stream);
       fclose( stream );
@@ -541,9 +541,10 @@
     return mDest;
   }
 
-  mDest.resize(mi->msgSize()+2);
+  QFileInfo fi( abs_file );
+  mDest.resize(fi.size()+2);
   mDest = kFileToString(abs_file, false, false);
-  size_t newMsgSize = crlf2lf( mDest.data(), mi->msgSize() );
+  size_t newMsgSize = crlf2lf( mDest.data(), fi.size() );
   mDest[newMsgSize] = '\0';
   return mDest;
 }
@@ -905,7 +906,7 @@
         return 1;
 
     /* The subdirs are removed now. Check if there is anything else in the dir
-     * and only if not delete the dir itself. The user could have data stored 
+     * and only if not delete the dir itself. The user could have data stored
      * that would otherwise be deleted. */
     QDir dir(location());
     if ( dir.count() == 2 ) { // only . and ..
--- kmail/kmfoldermbox.cpp	3 Jan 2004 21:32:59 -0000	1.92
+++ kmail/kmfoldermbox.cpp	31 Jan 2004 13:34:02 -0000	1.92.2.1
@@ -42,7 +42,7 @@
 // Regular expression to find the line that seperates messages in a mail
 // folder:
 #define MSG_SEPERATOR_START "From "
-#define MSG_SEPERATOR_REGEX "^From .*..:...*$"
+#define MSG_SEPERATOR_REGEX "^From .*[0-9][0-9]:[0-9][0-9].*$"
 static short msgSepLen = strlen(MSG_SEPERATOR_START);
 
 
@@ -934,8 +934,7 @@
     if (aMsg->headerField("Content-Type").isEmpty())  // This might be added by
       aMsg->removeHeaderField("Content-Type");        // the line above
   }
-  msgText = aMsg->asString();
-  escapeFrom( msgText );
+  msgText = escapeFrom( aMsg->asString() );
   size_t len = msgText.length();
 
   assert(mStream != 0);
--- kmail/kmmainwin.cpp	11 Jan 2004 21:57:07 -0000	1.580
+++ kmail/kmmainwin.cpp	25 Jan 2004 22:51:16 -0000	1.580.2.1
@@ -210,7 +210,7 @@
   if (config->readBoolEntry("warn-before-expire", true)) {
     ret = KMessageBox::warningYesNo(KMainWindow::memberList->first(),
 			 str, i18n("Expire Old Messages?"), i18n("Expire"), i18n("Don't Expire"));
-    if (ret == KMessageBox::Continue) {
+    if (ret == KMessageBox::Yes) {
       kmkernel->setCanExpire(true);
     }
   }
--- kmail/kmmessage.cpp	2 Jan 2004 18:34:47 -0000	1.451
+++ kmail/kmmessage.cpp	1 Feb 2004 14:04:51 -0000	1.451.2.1
@@ -922,6 +922,10 @@
     // strip all my addresses from the list of recipients
     QStringList recipients = splitEmailAddrList( toStr );
     toStr = stripMyAddressesFromAddressList( recipients ).join(", ");
+    // ... unless the list contains only my addresses (reply to self)
+    if ( toStr.isEmpty() && !recipients.isEmpty() )
+      toStr = recipients[0];
+
     break;
   }
   case KMail::ReplyList : {
@@ -957,23 +961,21 @@
       }
     }
 
-    // if it is a mailing list, add the posting address
-    if ( !mailingListAddresses.isEmpty() )
-      recipients.prepend( mailingListAddresses[0] );
-
-    // add From address if appropriate
-    if ( !from().isEmpty() ) {
-      if ( !mailingListAddresses.isEmpty() ) {
-        // in case of replying to a mailing list message add the From address
-        // to the list of CC recipients if it's not already there
-        if ( !addressIsInAddressList( from(), recipients ) ) {
-          ccRecipients += from();
-          kdDebug(5006) << "Added " << from()
-                        << " to the list of CC recipients"
-                        << endl;
-        }
+    if ( !mailingListAddresses.isEmpty() ) {
+      // this is a mailing list message
+      if ( recipients.isEmpty() && !from().isEmpty() ) {
+        // The sender didn't set a Reply-to address, so we add the From
+        // address to the list of CC recipients.
+        ccRecipients += from();
+        kdDebug(5006) << "Added " << from() << " to the list of CC recipients"
+                      << endl;
       }
-      else if ( recipients.isEmpty() ) {
+      // if it is a mailing list, add the posting address
+      recipients.prepend( mailingListAddresses[0] );
+    }
+    else {
+      // this is a normal message
+      if ( recipients.isEmpty() && !from().isEmpty() ) {
         // in case of replying to a normal message only then add the From
         // address to the list of recipients if there was no Reply-to address
         recipients += from();
@@ -1005,8 +1007,21 @@
     if ( !ccRecipients.isEmpty() ) {
       // strip all my addresses from the list of CC recipients
       ccRecipients = stripMyAddressesFromAddressList( ccRecipients );
+
+      // in case of a reply to self toStr might be empty. if that's the case
+      // then propagate a cc recipient to To: (if there is any).
+      if ( toStr.isEmpty() && !ccRecipients.isEmpty() ) {
+        toStr = ccRecipients[0];
+        ccRecipients.pop_front();
+      }
+
       msg->setCc( ccRecipients.join(", ") );
     }
+
+    if ( toStr.isEmpty() && !recipients.isEmpty() ) {
+      // reply to self without other recipients
+      toStr = recipients[0];
+    }
     break;
   }
   case KMail::ReplyAuthor : {
--- kmail/kmmimeparttree.cpp	12 Oct 2003 14:11:07 -0000	1.50
+++ kmail/kmmimeparttree.cpp	1 Feb 2004 22:50:28 -0000	1.50.6.1
@@ -23,13 +23,13 @@
                                 QWidget* parent,
                                 const char* name )
     : KListView(  parent, name ),
-      mReaderWin( readerWin )
+      mReaderWin( readerWin ), mSizeColumn(0)
 {
     setStyleDependantFrameWidth();
     addColumn( i18n("Description") );
     addColumn( i18n("Type") );
     addColumn( i18n("Encoding") );
-    addColumn( i18n("Size") );
+    mSizeColumn = addColumn( i18n("Size") );
     setColumnAlignment( 3, Qt::AlignRight );
 
     restoreLayoutIfPresent();
@@ -192,6 +192,23 @@
   KListView::styleChange( oldStyle );
 }
 
+//-----------------------------------------------------------------------------
+void KMMimePartTree::correctSize( QListViewItem * item )
+{
+  if (!item) return;
+
+  KIO::filesize_t totalSize = 0;
+  QListViewItem * myChild = item->firstChild();
+  while ( myChild ) 
+  {
+    totalSize += static_cast<KMMimePartTreeItem*>(myChild)->origSize();
+    myChild = myChild->nextSibling();
+  }
+  if ( totalSize > static_cast<KMMimePartTreeItem*>(item)->origSize() )
+    item->setText( mSizeColumn, KIO::convertSize(totalSize) );
+  if ( item->parent() )
+    correctSize( item->parent() );
+}
 
 //=============================================================================
 KMMimePartTreeItem::KMMimePartTreeItem( KMMimePartTree * parent,
@@ -204,11 +221,13 @@
 		   QString::null, // set by setIconAndTextForType()
 		   encoding,
 		   KIO::convertSize( size ) ),
-    mPartNode( node )
+    mPartNode( node ), mOrigSize(size)
 {
   if( node )
     node->setMimePartTreeItem( this );
   setIconAndTextForType( mimetype );
+  if ( parent ) 
+    parent->correctSize(this);
 }
 
 KMMimePartTreeItem::KMMimePartTreeItem( KMMimePartTreeItem * parent,
@@ -222,7 +241,7 @@
 		   QString::null, // set by setIconAndTextForType()
 		   encoding,
 		   KIO::convertSize( size ) ),
-    mPartNode( node )
+    mPartNode( node ), mOrigSize(size)
 {
   if( revertOrder && nextSibling() ){
     QListViewItem* sib = nextSibling();
@@ -233,6 +252,8 @@
   if( node )
     node->setMimePartTreeItem( this );
   setIconAndTextForType( mimetype );
+  if ( listView() ) 
+    static_cast<KMMimePartTree*>(listView())->correctSize(this);
 }
 
 void KMMimePartTreeItem::setIconAndTextForType( const QString & mime )
@@ -252,5 +273,4 @@
 }
 
 
-
 #include "kmmimeparttree.moc"
--- kmail/kmmimeparttree.h	12 Oct 2003 14:11:07 -0000	1.15
+++ kmail/kmmimeparttree.h	1 Feb 2004 22:50:28 -0000	1.15.6.1
@@ -22,6 +22,8 @@
                   const char* name = 0 );
   virtual ~KMMimePartTree();
 
+  void correctSize( QListViewItem * item );
+
 protected slots:
   void itemClicked( QListViewItem* );
   void itemRightClicked( QListViewItem*, const QPoint& );
@@ -45,6 +47,7 @@
 protected:
   KMReaderWin* mReaderWin;
   KMMimePartTreeItem* mCurrentContextMenuItem;
+  int mSizeColumn;
 };
 
 class KMMimePartTreeItem :public QListViewItem
@@ -65,10 +68,14 @@
                       bool revertOrder = false );
   partNode* node() const { return mPartNode; }
 
+  KIO::filesize_t origSize() const { return mOrigSize; }
+  void setOrigSize( KIO::filesize_t size ) { mOrigSize = size; }
+
 private:
   void setIconAndTextForType( const QString & mimetype );
 
   partNode* mPartNode;
+  KIO::filesize_t mOrigSize;
 };
 
 #endif // KMMIMEPARTTREE_H
--- kmail/kmreaderwin.cpp	6 Jan 2004 23:22:27 -0000	1.733
+++ kmail/kmreaderwin.cpp	25 Jan 2004 22:51:16 -0000	1.733.2.1
@@ -799,8 +799,8 @@
         << aMsg->fromStrip() << ", readyToShow " << (aMsg->readyToShow()) << endl;
 
   bool complete = true;
-  if ( aMsg && 
-       !aMsg->readyToShow() && 
+  if ( aMsg &&
+       !aMsg->readyToShow() &&
        (aMsg->getMsgSerNum() != mLastSerNum) &&
        !aMsg->isComplete() )
     complete = false;
@@ -1413,7 +1413,7 @@
       KMCommand *command = new KMSetStatusCommand( KMMsgStatusRead, serNums );
       command->start();
       KMMessage * receipt = message()->createMDN( MDN::ManualAction,
-                                                  MDN::Displayed, 
+                                                  MDN::Displayed,
                                                   true /* allow GUI */ );
       if ( receipt )
         if ( !kmkernel->msgSender()->send( receipt ) ) // send or queue
@@ -2097,12 +2097,12 @@
 //-----------------------------------------------------------------------------
 void KMReaderWin::slotUrlCopy()
 {
-  KMMainWidget *mainWidget = dynamic_cast<KMMainWidget*>(mMainWindow);
-  if (mainWidget)
-  {
-    KMCommand *command = new KMUrlCopyCommand( mUrlClicked, mainWidget );
-    command->start();
-  }
+  // we don't necessarily need a mainWidget for KMUrlCopyCommand so
+  // it doesn't matter if the dynamic_cast fails.
+  KMCommand *command =
+    new KMUrlCopyCommand( mUrlClicked,
+                          dynamic_cast<KMMainWidget*>( mMainWindow ) );
+  command->start();
 }
 
 //-----------------------------------------------------------------------------
--- kmail/objecttreeparser.cpp	5 Jan 2004 22:15:10 -0000	1.92
+++ kmail/objecttreeparser.cpp	25 Jan 2004 22:51:17 -0000	1.92.2.1
@@ -91,22 +91,22 @@
       : otp( _otp ), wrapper( _otp ? _otp->cryptPlugWrapper() : 0 )
     {
       if ( otp )
-	otp->setCryptPlugWrapper( _w );
+        otp->setCryptPlugWrapper( _w );
     }
 
     ~CryptPlugWrapperSaver() {
       if ( otp )
-	otp->setCryptPlugWrapper( wrapper );
+        otp->setCryptPlugWrapper( wrapper );
     }
   };
 
 
   ObjectTreeParser::ObjectTreeParser( KMReaderWin * reader, CryptPlugWrapper * wrapper,
-				      bool showOnlyOneMimePart, bool keepEncryptions,
-				      bool includeSignatures,
-				      const AttachmentStrategy * strategy,
-				      HtmlWriter * htmlWriter,
-				      CSSHelper * cssHelper )
+                                      bool showOnlyOneMimePart, bool keepEncryptions,
+                                      bool includeSignatures,
+                                      const AttachmentStrategy * strategy,
+                                      HtmlWriter * htmlWriter,
+                                      CSSHelper * cssHelper )
     : mReader( reader ),
       mCryptPlugWrapper( wrapper ),
       mShowOnlyOneMimePart( showOnlyOneMimePart ),
@@ -119,7 +119,7 @@
   {
     if ( !attachmentStrategy() )
       mAttachmentStrategy = reader ? reader->attachmentStrategy()
-	                           : AttachmentStrategy::smart();
+                                   : AttachmentStrategy::smart();
     if ( reader && !this->htmlWriter() )
       mHtmlWriter = reader->htmlWriter();
     if ( reader && !this->cssHelper() )
@@ -143,9 +143,9 @@
   ObjectTreeParser::~ObjectTreeParser() {}
 
   void ObjectTreeParser::insertAndParseNewChildNode( partNode& startNode,
-						     const char* content,
-						     const char* cntDesc,
-						     bool append )
+                                                     const char* content,
+                                                     const char* cntDesc,
+                                                     bool append )
   {
     //  DwBodyPart* myBody = new DwBodyPart( DwString( content ), node.dwPart() );
     DwBodyPart* myBody = new DwBodyPart( DwString( content ), 0 );
@@ -189,12 +189,12 @@
     if ( startNode.mimePartTreeItem() ) {
       kdDebug(5006) << "\n     ----->  Inserting items into MimePartTree\n" << endl;
       newNode->fillMimePartTree( startNode.mimePartTreeItem(), 0,
-				 QString::null, QString::null, QString::null, 0,
-				 append );
+                                 QString::null, QString::null, QString::null, 0,
+                                 append );
       kdDebug(5006) << "\n     <-----  Finished inserting items into MimePartTree\n" << endl;
     } else {
       kdDebug(5006) << "\n     ------  Sorry, node.mimePartTreeItem() returns ZERO so"
-		    << "\n                    we cannot insert new lines into MimePartTree. :-(\n" << endl;
+                    << "\n                    we cannot insert new lines into MimePartTree. :-(\n" << endl;
     }
     kdDebug(5006) << "\n     ----->  Now parsing the MimePartTree\n" << endl;
     ObjectTreeParser otp( mReader, cryptPlugWrapper() );
@@ -208,9 +208,9 @@
 
   void ObjectTreeParser::parseObjectTree( partNode * node ) {
     kdDebug(5006) << "\n**\n** ObjectTreeParser::parseObjectTree( "
-		  << (node ? "node OK, " : "no node, ")
-		  << "showOnlyOneMimePart: " << (showOnlyOneMimePart() ? "TRUE" : "FALSE")
-		  << " ) **\n**" << endl;
+                  << (node ? "node OK, " : "no node, ")
+                  << "showOnlyOneMimePart: " << (showOnlyOneMimePart() ? "TRUE" : "FALSE")
+                  << " ) **\n**" << endl;
 
     if ( !node )
       return;
@@ -220,7 +220,7 @@
       // ... this node and all descendants
       node->setProcessed( false, false );
       if ( partNode * child = node->firstChild() )
-	child->setProcessed( false, true );
+        child->setProcessed( false, true );
     } else if ( mReader && !node->parentNode() ) {
       // ...this node and all it's siblings and descendants
       node->setProcessed( false, true );
@@ -230,21 +230,21 @@
       ProcessResult processResult;
 
       if ( node->processed() ) {
-	// ### (mmutz) I think this is a bug if node->processed() is
-	// true from the beginning (_can_ it?), then any crypto state is
-	// reset. I therefore believe that this code should be inside the
-	// corresponding conditional above:
-	processResult.adjustCryptoStatesOfNode( node );
-	continue;
+        // ### (mmutz) I think this is a bug if node->processed() is
+        // true from the beginning (_can_ it?), then any crypto state is
+        // reset. I therefore believe that this code should be inside the
+        // corresponding conditional above:
+        processResult.adjustCryptoStatesOfNode( node );
+        continue;
       }
 
       const BodyPartFormatter * bpf
-	= BodyPartFormatter::createFor( node->type(), node->subType() );
+        = BodyPartFormatter::createFor( node->type(), node->subType() );
       kdFatal( !bpf, 5006 ) << "THIS SHOULD NO LONGER HAPPEN ("
-			    << node->typeString() << '/' << node->subTypeString()
-			    << ')' << endl;
+                            << node->typeString() << '/' << node->subTypeString()
+                            << ')' << endl;
       if ( !bpf->process( this, node, processResult ) )
-	defaultHandling( node, processResult );
+        defaultHandling( node, processResult );
 
       node->setProcessed( true, false );
 
@@ -252,7 +252,7 @@
       processResult.adjustCryptoStatesOfNode( node );
 
       if ( showOnlyOneMimePart() )
-	break;
+        break;
     }
   }
 
@@ -262,8 +262,8 @@
     if ( !mReader )
       return;
     if ( attachmentStrategy() == AttachmentStrategy::hidden() &&
-	 !showOnlyOneMimePart() &&
-	 node->parentNode() /* message is not an attachment */ )
+         !showOnlyOneMimePart() &&
+         node->parentNode() /* message is not an attachment */ )
       return;
 
     bool asIcon = true;
@@ -274,30 +274,30 @@
       asIcon = !node->hasContentDispositionInline();
     else if ( !result.neverDisplayInline() )
       if ( const AttachmentStrategy * as = attachmentStrategy() )
-	asIcon = as->defaultDisplay( node ) == AttachmentStrategy::AsIcon;
+        asIcon = as->defaultDisplay( node ) == AttachmentStrategy::AsIcon;
     // neither image nor text -> show as icon
     if ( !result.isImage()
-	 && node->type() != DwMime::kTypeText )
+         && node->type() != DwMime::kTypeText )
       asIcon = true;
     if ( asIcon ) {
       if ( attachmentStrategy() != AttachmentStrategy::hidden()
-	   || showOnlyOneMimePart() )
-	writePartIcon( &node->msgPart(), node->nodeId() );
+           || showOnlyOneMimePart() )
+        writePartIcon( &node->msgPart(), node->nodeId() );
     } else if ( result.isImage() )
       writePartIcon( &node->msgPart(), node->nodeId(), true );
     else
       writeBodyString( node->msgPart().bodyDecoded(),
-		       node->trueFromAddress(),
-		       codecFor( node ), result );
+                       node->trueFromAddress(),
+                       codecFor( node ), result );
     // end of ###
   }
 
   void ProcessResult::adjustCryptoStatesOfNode( partNode * node ) const {
     if ( ( inlineSignatureState()  != KMMsgNotSigned ) ||
-	 ( inlineEncryptionState() != KMMsgNotEncrypted ) ) {
+         ( inlineEncryptionState() != KMMsgNotEncrypted ) ) {
       if (    partNode::CryptoTypeUnknown == node->cryptoType()
-	      || partNode::CryptoTypeNone    == node->cryptoType() ){
-	node->setCryptoType( partNode::CryptoTypeInlinePGP );
+              || partNode::CryptoTypeNone    == node->cryptoType() ){
+        node->setCryptoType( partNode::CryptoTypeInlinePGP );
       }
       node->setSignatureState( inlineSignatureState() );
       node->setEncryptionState( inlineEncryptionState() );
@@ -311,12 +311,12 @@
   //////////////////
 
   bool ObjectTreeParser::writeOpaqueOrMultipartSignedData( partNode* data,
-						      partNode& sign,
-						      const QString& fromAddress,
-						      bool doCheck,
-						      QCString* cleartextData,
-						      struct CryptPlugWrapper::SignatureMetaData* paramSigMeta,
-						      bool hideErrors )
+                                                      partNode& sign,
+                                                      const QString& fromAddress,
+                                                      bool doCheck,
+                                                      QCString* cleartextData,
+                                                      struct CryptPlugWrapper::SignatureMetaData* paramSigMeta,
+                                                      bool hideErrors )
   {
     bool bIsOpaqueSigned = false;
     enum { NO_PLUGIN, NOT_INITIALIZED, CANT_VERIFY_SIGNATURES }
@@ -481,18 +481,18 @@
         // The following if /should/ always result in TRUE but we
         // won't trust implicitely the plugin that gave us these data.
         if ( ext.emailList[ iMail ] && *ext.emailList[ iMail ] ) {
-	  QString email = QString::fromUtf8( ext.emailList[ iMail ] );
-	  // ### work around gpgme 0.3.x / cryptplug bug where the
-	  // ### email addresses are specified as angle-addr, not addr-spec:
-	  if ( email.startsWith( "<" ) && email.endsWith( ">" ) )
-	    email = email.mid( 1, email.length() - 2 );
+          QString email = QString::fromUtf8( ext.emailList[ iMail ] );
+          // ### work around gpgme 0.3.x / cryptplug bug where the
+          // ### email addresses are specified as angle-addr, not addr-spec:
+          if ( email.startsWith( "<" ) && email.endsWith( ">" ) )
+            email = email.mid( 1, email.length() - 2 );
           messagePart.signerMailAddresses.append( email );
-	}
+        }
       if ( ext.creation_time )
         messagePart.creationTime = *ext.creation_time;
       if (     70 > messagePart.creationTime.tm_year
           || 200 < messagePart.creationTime.tm_year
-	  ||   1 > messagePart.creationTime.tm_mon
+          ||   1 > messagePart.creationTime.tm_mon
           ||  12 < messagePart.creationTime.tm_mon
           ||   1 > messagePart.creationTime.tm_mday
           ||  31 < messagePart.creationTime.tm_mday ) {
@@ -505,8 +505,8 @@
           messagePart.signer = QString::fromUtf8( ext.name );
         if ( !messagePart.signerMailAddresses.empty() ) {
           if ( messagePart.signer.isEmpty() )
-	    messagePart.signer = messagePart.signerMailAddresses.front();
-	  else
+            messagePart.signer = messagePart.signerMailAddresses.front();
+          else
             messagePart.signer += " <" + messagePart.signerMailAddresses.front() + '>';
         }
       }
@@ -525,8 +525,8 @@
       if ( cleartextData || new_cleartext ) {
         if ( mReader )
           htmlWriter()->queue( writeSigstatHeader( messagePart,
-						   cryptPlug,
-						   fromAddress ) );
+                                                   cryptPlug,
+                                                   fromAddress ) );
         bIsOpaqueSigned = true;
 
 #ifndef NDEBUG
@@ -597,8 +597,8 @@
         }
 
         htmlWriter()->queue( writeSigstatHeader( messagePart,
-						 cryptPlug,
-						 fromAddress ) );
+                                                 cryptPlug,
+                                                 fromAddress ) );
       }
 
       ObjectTreeParser otp( mReader, cryptPlug, true );
@@ -613,18 +613,18 @@
       cryptPlug->freeSignatureMetaData( sigMeta );
 
     kdDebug(5006) << "\nObjectTreeParser::writeOpaqueOrMultipartSignedData: done, returning "
-		  << ( bIsOpaqueSigned ? "TRUE" : "FALSE" ) << endl;
+                  << ( bIsOpaqueSigned ? "TRUE" : "FALSE" ) << endl;
     return bIsOpaqueSigned;
   }
 
 
 bool ObjectTreeParser::okDecryptMIME( partNode& data,
-				      QCString& decryptedData,
-				      bool& signatureFound,
-				      struct CryptPlugWrapper::SignatureMetaData& sigMeta,
-				      bool showWarning,
-				      bool& passphraseError,
-				      QString& aErrorText )
+                                      QCString& decryptedData,
+                                      bool& signatureFound,
+                                      struct CryptPlugWrapper::SignatureMetaData& sigMeta,
+                                      bool showWarning,
+                                      bool& passphraseError,
+                                      QString& aErrorText )
 {
   passphraseError = false;
   aErrorText = QString::null;
@@ -756,9 +756,9 @@
 }
 
 QString ObjectTreeParser::byteArrayToTempFile( KMReaderWin* reader,
-					       const QString& dirExt,
-					       const QString& orgName,
-					       const QByteArray& theBody )
+                                               const QString& dirExt,
+                                               const QString& orgName,
+                                               const QByteArray& theBody )
 {
   KTempFile *tempFile = new KTempFile( QString::null, "." + dirExt );
   tempFile->setAutoDelete(true);
@@ -801,33 +801,33 @@
       return true;
 
     if ( mIsFirstTextPart ||
-	 attachmentStrategy()->defaultDisplay( curNode ) == AttachmentStrategy::Inline ||
-	 showOnlyOneMimePart() )
+         attachmentStrategy()->defaultDisplay( curNode ) == AttachmentStrategy::Inline ||
+         showOnlyOneMimePart() )
     {
       mIsFirstTextPart = false;
       if ( mReader->htmlMail() ) {
-	// ---Sven's strip </BODY> and </HTML> from end of attachment start-
-	// We must fo this, or else we will see only 1st inlined html
-	// attachment.  It is IMHO enough to search only for </BODY> and
-	// put \0 there.
-	int i = cstr.findRev("</body>", -1, false); //case insensitive
-	if ( 0 <= i )
-	  cstr.truncate(i);
-	else // just in case - search for </html>
-	{
-	  i = cstr.findRev("</html>", -1, false); //case insensitive
-	  if ( 0 <= i ) cstr.truncate(i);
-	}
-	// ---Sven's strip </BODY> and </HTML> from end of attachment end-
+        // ---Sven's strip </BODY> and </HTML> from end of attachment start-
+        // We must fo this, or else we will see only 1st inlined html
+        // attachment.  It is IMHO enough to search only for </BODY> and
+        // put \0 there.
+        int i = cstr.findRev("</body>", -1, false); //case insensitive
+        if ( 0 <= i )
+          cstr.truncate(i);
+        else // just in case - search for </html>
+        {
+          i = cstr.findRev("</html>", -1, false); //case insensitive
+          if ( 0 <= i ) cstr.truncate(i);
+        }
+        // ---Sven's strip </BODY> and </HTML> from end of attachment end-
       } else {
-	htmlWriter()->queue( "<div class=\"htmlWarn\">\n" );
-	htmlWriter()->queue( i18n("<b>Note:</b> This is an HTML message. For "
-				  "security reasons, only the raw HTML code "
-				  "is shown. If you trust the sender of this "
-				  "message then you can activate formatted "
-				  "HTML display for this message "
-				  "<a href=\"kmail:showHTML\">by clicking here</a>.") );
-	htmlWriter()->queue( "</div><br><br>" );
+        htmlWriter()->queue( "<div class=\"htmlWarn\">\n" );
+        htmlWriter()->queue( i18n("<b>Note:</b> This is an HTML message. For "
+                                  "security reasons, only the raw HTML code "
+                                  "is shown. If you trust the sender of this "
+                                  "message then you can activate formatted "
+                                  "HTML display for this message "
+                                  "<a href=\"kmail:showHTML\">by clicking here</a>.") );
+        htmlWriter()->queue( "</div><br><br>" );
       }
       htmlWriter()->queue( codecFor( curNode )->toUnicode( mReader->htmlMail() ? cstr : KMMessage::html2source( cstr )));
       mReader->mColorBar->setHtmlMode();
@@ -864,7 +864,7 @@
     QFile f( file );
     if ( !f.open( IO_WriteOnly ) ) {
       KMessageBox::error( mReader, i18n("Could not open file for writing:\n%1")
-		                   .arg( file ) );
+                                   .arg( file ) );
     } else {
       QByteArray msgArray = curNode->msgPart().bodyDecodedBinary();
       f.writeBlock( msgArray, msgArray.size() );
@@ -882,7 +882,7 @@
       if ( DwStrcasecmp( param->Attribute(), "method" ) == 0 ) {
         QCString method = QCString( param->Value().c_str() ).lower();
         kdDebug(5006) << "         method=" << method << endl;
-	if ( method == "request" || // an invitation to a meeting *or*
+        if ( method == "request" || // an invitation to a meeting *or*
              method == "reply" ||   // a reply to an invitation we sent
              method == "cancel" ) { // Outlook uses this when cancelling
           QByteArray theBody( curNode->msgPart().bodyDecodedBinary() );
@@ -904,13 +904,13 @@
               htmlWriter()->queue( postfix );
               return true;
             }
-	  }
-	}
+          }
+        }
         return false; // we found a "method" but we couldn't handle it
       }
     }
     return false;
-#endif  
+#endif
   }
 
 } // namespace KMail
@@ -965,8 +965,8 @@
     digestHeaderStr = "Content-Type=text/plain\nContent-Description=digest header\n\n";
     digestHeaderStr += cstr.mid( 0, thisDelim );
     insertAndParseNewChildNode( *curNode,
-				&*digestHeaderStr,
-				"Digest Header", true );
+                                &*digestHeaderStr,
+                                "Digest Header", true );
     //mReader->queueHtml("<br><hr><br>");
     // temporarily change curent node's Content-Type
     // to get our embedded RfC822 messages properly inserted
@@ -975,17 +975,17 @@
     while( -1 < nextDelim ){
       int thisEoL = cstr.find("\nMessage:", thisDelim, false);
       if ( -1 < thisEoL )
-	thisDelim = thisEoL+1;
+        thisDelim = thisEoL+1;
       else{
-	thisEoL = cstr.find("\n_____________", thisDelim, false);
-	if ( -1 < thisEoL )
-	  thisDelim = thisEoL+1;
+        thisEoL = cstr.find("\n_____________", thisDelim, false);
+        if ( -1 < thisEoL )
+          thisDelim = thisEoL+1;
       }
       thisEoL = cstr.find('\n', thisDelim);
       if ( -1 < thisEoL )
-	thisDelim = thisEoL+1;
+        thisDelim = thisEoL+1;
       else
-	thisDelim = thisDelim+1;
+        thisDelim = thisDelim+1;
       //while( thisDelim < cstr.size() && '\n' == cstr[thisDelim] )
       //  ++thisDelim;
 
@@ -995,24 +995,24 @@
       QCString subSearch("\nSubject:");
       int subPos = partStr.find(subSearch, 0, false);
       if ( -1 < subPos ){
-	subject = partStr.mid(subPos+subSearch.length());
-	thisEoL = subject.find('\n');
-	if ( -1 < thisEoL )
-	  subject.truncate( thisEoL );
+        subject = partStr.mid(subPos+subSearch.length());
+        thisEoL = subject.find('\n');
+        if ( -1 < thisEoL )
+          subject.truncate( thisEoL );
       }
       kdDebug(5006) << "        embedded message found: \"" << subject << "\"" << endl;
       insertAndParseNewChildNode( *curNode,
-				  &*partStr,
-				  subject, true );
+                                  &*partStr,
+                                  subject, true );
       //mReader->queueHtml("<br><hr><br>");
       thisDelim = nextDelim+1;
       nextDelim = cstr.find(delim1, thisDelim, false);
       if ( -1 == nextDelim )
-	nextDelim = cstr.find(delim2, thisDelim, false);
+        nextDelim = cstr.find(delim2, thisDelim, false);
       if ( -1 == nextDelim )
-	nextDelim = cstr.find(delimZ1, thisDelim, false);
+        nextDelim = cstr.find(delimZ1, thisDelim, false);
       if ( -1 == nextDelim )
-	nextDelim = cstr.find(delimZ2, thisDelim, false);
+        nextDelim = cstr.find(delimZ2, thisDelim, false);
     }
     // reset curent node's Content-Type
     curNode->setType(    DwMime::kTypeText );
@@ -1022,15 +1022,15 @@
       thisDelim = thisEoL;
       thisEoL = cstr.find('\n', thisDelim);
       if ( -1 < thisEoL )
-	thisDelim = thisEoL+1;
+        thisDelim = thisEoL+1;
     }
     else
       thisDelim = thisDelim+1;
     partStr = "Content-Type=text/plain\nContent-Description=digest footer\n\n";
     partStr += cstr.mid( thisDelim );
     insertAndParseNewChildNode( *curNode,
-				&*partStr,
-				"Digest Footer", true );
+                                &*partStr,
+                                "Digest Footer", true );
     return true;
   }
 
@@ -1043,8 +1043,8 @@
 
     //resultingRawData += cstr;
     if ( !mIsFirstTextPart &&
-	 attachmentStrategy()->defaultDisplay( curNode ) != AttachmentStrategy::Inline &&
-	 !showOnlyOneMimePart() )
+         attachmentStrategy()->defaultDisplay( curNode ) != AttachmentStrategy::Inline &&
+         !showOnlyOneMimePart() )
       return false;
 
     mRawReplyString = cstr;
@@ -1060,24 +1060,24 @@
       label = KMMessage::quoteHtmlChars( label, true );
 
       const QString comment =
-	KMMessage::quoteHtmlChars( curNode->msgPart().contentDescription(), true );
+        KMMessage::quoteHtmlChars( curNode->msgPart().contentDescription(), true );
 
       const QString fileName =
-	mReader->writeMessagePartToTempFile( &curNode->msgPart(),
-					     curNode->nodeId() );
+        mReader->writeMessagePartToTempFile( &curNode->msgPart(),
+                                             curNode->nodeId() );
 
       const QString dir = QApplication::reverseLayout() ? "rtl" : "ltr" ;
 
       QString htmlStr = "<table cellspacing=\"1\" class=\"textAtm\">"
                  "<tr class=\"textAtmH\"><td dir=\"" + dir + "\">";
       if ( !fileName.isEmpty() )
-	htmlStr += "<a href=\"" + QString("file:")
-	  + KURL::encode_string( fileName ) + "\">"
-	  + label + "</a>";
+        htmlStr += "<a href=\"" + QString("file:")
+          + KURL::encode_string( fileName ) + "\">"
+          + label + "</a>";
       else
-	htmlStr += label;
+        htmlStr += label;
       if ( !comment.isEmpty() )
-	htmlStr += "<br>" + comment;
+        htmlStr += "<br>" + comment;
       htmlStr += "</td></tr><tr class=\"textAtmB\"><td>";
 
       htmlWriter()->queue( htmlStr );
@@ -1085,9 +1085,9 @@
     // process old style not-multipart Mailman messages to
     // enable verification of the embedded messages' signatures
     if ( !isMailmanMessage( curNode ) ||
-	 !processMailmanMessage( curNode ) )
+         !processMailmanMessage( curNode ) )
       writeBodyString( cstr, curNode->trueFromAddress(),
-		       codecFor( curNode ), result );
+                       codecFor( curNode ), result );
     if ( bDrawFrame )
       htmlWriter()->queue( "</td></tr></table>" );
 
@@ -1114,11 +1114,11 @@
     // Might be a Kroupware message,
     // let's look for the parts contained in the mixture:
     partNode * dataPlain = child->findType( DwMime::kTypeText,
-					    DwMime::kSubtypePlain, false, true );
+                                            DwMime::kSubtypePlain, false, true );
 
     // special treatment of vCal attachment (might be invitation or similar)
     partNode * dataCal = child->findType( DwMime::kTypeText,
-					  DwMime::kSubtypeVCal, false, true );
+                                          DwMime::kSubtypeVCal, false, true );
     if ( dataCal ) {
       ProcessResult dummy;
       if ( processTextVCalSubtype( dataCal, dummy ) ) {
@@ -1132,7 +1132,7 @@
 
     // special treatment of TNEF attachment (might be invitation or similar)
     partNode * dataTNEF = child->findType( DwMime::kTypeApplication,
-					   DwMime::kSubtypeMsTNEF, false, true );
+                                           DwMime::kSubtypeMsTNEF, false, true );
     if ( dataTNEF ) {
       ProcessResult dummy;
       if ( processApplicationMsTnefSubtype( dataTNEF, dummy ) ) {
@@ -1155,9 +1155,9 @@
       return false;
 
     partNode * dataHtml = child->findType( DwMime::kTypeText,
-					   DwMime::kSubtypeHtml, false, true );
+                                           DwMime::kSubtypeHtml, false, true );
     partNode * dataPlain = child->findType( DwMime::kTypeText,
-					    DwMime::kSubtypePlain, false, true );
+                                            DwMime::kSubtypePlain, false, true );
 
     if ( (mReader && mReader->htmlMail() && dataHtml) ||
          (dataHtml && dataPlain && dataPlain->msgPart().body().isEmpty()) ) {
@@ -1204,28 +1204,28 @@
     // ATTENTION: This code is to be replaced by the new 'auto-detect' feature. --------------------------------------
     partNode * data = 0;
     partNode * sign = child->findType( DwMime::kTypeApplication,
-				       DwMime::kSubtypePgpSignature, false, true );
+                                       DwMime::kSubtypePgpSignature, false, true );
     if ( sign ) {
       kdDebug(5006) << "       OpenPGP signature found" << endl;
       data = child->findTypeNot( DwMime::kTypeApplication,
-				 DwMime::kSubtypePgpSignature, false, true );
+                                 DwMime::kSubtypePgpSignature, false, true );
       if ( data ) {
-	node->setCryptoType( partNode::CryptoTypeOpenPgpMIME );
-	useThisCryptPlug = kmkernel->cryptPlugList()->findForLibName( "openpgp" );
+        node->setCryptoType( partNode::CryptoTypeOpenPgpMIME );
+        useThisCryptPlug = kmkernel->cryptPlugList()->findForLibName( "openpgp" );
       }
     } else {
       sign = child->findType( DwMime::kTypeApplication,
-			      DwMime::kSubtypePkcs7Signature, false, true );
+                              DwMime::kSubtypePkcs7Signature, false, true );
       if ( sign ) {
-	kdDebug(5006) << "       S/MIME signature found" << endl;
-	data = child->findTypeNot( DwMime::kTypeApplication,
-				   DwMime::kSubtypePkcs7Signature, false, true );
-	if ( data ) {
-	  node->setCryptoType( partNode::CryptoTypeSMIME );
-	  useThisCryptPlug = kmkernel->cryptPlugList()->findForLibName( "smime" );
-	}
+        kdDebug(5006) << "       S/MIME signature found" << endl;
+        data = child->findTypeNot( DwMime::kTypeApplication,
+                                   DwMime::kSubtypePkcs7Signature, false, true );
+        if ( data ) {
+          node->setCryptoType( partNode::CryptoTypeSMIME );
+          useThisCryptPlug = kmkernel->cryptPlugList()->findForLibName( "smime" );
+        }
       } else {
-	kdDebug(5006) << "       Sorry, *neither* OpenPGP *nor* S/MIME signature could be found!\n\n" << endl;
+        kdDebug(5006) << "       Sorry, *neither* OpenPGP *nor* S/MIME signature could be found!\n\n" << endl;
       }
     }
 
@@ -1242,11 +1242,11 @@
 
     if ( !includeSignatures() ) {
       if ( !data )
-	data = child;
+        data = child;
       const QCString cstr = data->msgPart().bodyDecoded();
       if ( mReader )
-	writeBodyString( cstr, node->trueFromAddress(),
-			 codecFor( data ), result );
+        writeBodyString( cstr, node->trueFromAddress(),
+                         codecFor( data ), result );
       mRawReplyString += cstr;
       return true;
     } else if ( sign && data ) {
@@ -1254,8 +1254,8 @@
       // by parseObjectTree( data ) called from writeOpaqueOrMultipartSignedData().
       sign->setProcessed( true, false );
       writeOpaqueOrMultipartSignedData( data,
-					*sign,
-					node->trueFromAddress() );
+                                        *sign,
+                                        node->trueFromAddress() );
       return true;
     }
 
@@ -1272,8 +1272,8 @@
       node->setEncryptionState( KMMsgFullyEncrypted );
       const QCString cstr = node->msgPart().bodyDecoded();
       if ( mReader )
-	writeBodyString( cstr, node->trueFromAddress(),
-			 codecFor( node ), result );
+        writeBodyString( cstr, node->trueFromAddress(),
+                         codecFor( node ), result );
       mRawReplyString += cstr;
       return true;
     }
@@ -1284,17 +1284,17 @@
       ATTENTION: This code is to be replaced by the new 'auto-detect' feature. --------------------------------------
     */
     partNode * data = child->findType( DwMime::kTypeApplication,
-				       DwMime::kSubtypeOctetStream, false, true );
+                                       DwMime::kSubtypeOctetStream, false, true );
     if ( data ) {
       node->setCryptoType( partNode::CryptoTypeOpenPgpMIME );
       useThisCryptPlug = kmkernel->cryptPlugList()->findForLibName( "openpgp" );
     }
     if ( !data ) {
       data = child->findType( DwMime::kTypeApplication,
-			      DwMime::kSubtypePkcs7Mime, false, true );
+                              DwMime::kSubtypePkcs7Mime, false, true );
       if ( data ) {
-	node->setCryptoType( partNode::CryptoTypeSMIME );
-	useThisCryptPlug = kmkernel->cryptPlugList()->findForLibName( "smime" );
+        node->setCryptoType( partNode::CryptoTypeSMIME );
+        useThisCryptPlug = kmkernel->cryptPlugList()->findForLibName( "smime" );
       }
     }
     /*
@@ -1328,12 +1328,12 @@
     bool passphraseError;
 
     bool bOkDecrypt = okDecryptMIME( *data,
-				     decryptedData,
-				     signatureFound,
-				     sigMeta,
-				     true,
-				     passphraseError,
-				     messagePart.errorText );
+                                     decryptedData,
+                                     signatureFound,
+                                     sigMeta,
+                                     true,
+                                     passphraseError,
+                                     messagePart.errorText );
 
     // paint the frame
     if ( mReader ) {
@@ -1341,8 +1341,8 @@
       messagePart.isEncrypted = true;
       messagePart.isSigned = false;
       htmlWriter()->queue( writeSigstatHeader( messagePart,
-					       cryptPlugWrapper(),
-					       node->trueFromAddress() ) );
+                                               cryptPlugWrapper(),
+                                               node->trueFromAddress() ) );
     }
 
     if ( bOkDecrypt ) {
@@ -1358,25 +1358,25 @@
       // MUA 'should' have sent.  :-D       (khz, 12.09.2002)
       //
       if ( signatureFound ) {
-	writeOpaqueOrMultipartSignedData( 0,
-					  *node,
-					  node->trueFromAddress(),
-					  false,
-					  &decryptedData,
-					  &sigMeta,
-					  false );
-	node->setSignatureState( KMMsgFullySigned );
+        writeOpaqueOrMultipartSignedData( 0,
+                                          *node,
+                                          node->trueFromAddress(),
+                                          false,
+                                          &decryptedData,
+                                          &sigMeta,
+                                          false );
+        node->setSignatureState( KMMsgFullySigned );
       } else {
-	insertAndParseNewChildNode( *node,
-				    &*decryptedData,
-				    "encrypted data" );
+        insertAndParseNewChildNode( *node,
+                                    &*decryptedData,
+                                    "encrypted data" );
       }
     } else {
       mRawReplyString += decryptedData;
       if ( mReader ) {
-	// print the error message that was returned in decryptedData
-	// (utf8-encoded)
-	htmlWriter()->queue( QString::fromUtf8( decryptedData.data() ) );
+        // print the error message that was returned in decryptedData
+        // (utf8-encoded)
+        htmlWriter()->queue( QString::fromUtf8( decryptedData.data() ) );
       }
     }
 
@@ -1389,8 +1389,8 @@
 
   bool ObjectTreeParser::processMessageRfc822Subtype( partNode * node, ProcessResult & ) {
     if ( mReader
-	 && !attachmentStrategy()->inlineNestedMessages()
-	 && !showOnlyOneMimePart() )
+         && !attachmentStrategy()->inlineNestedMessages()
+         && !showOnlyOneMimePart() )
       return false;
 
     if ( partNode * child = node->firstChild() ) {
@@ -1412,8 +1412,8 @@
         mReader->writeMessagePartToTempFile( &node->msgPart(),
                                             node->nodeId() );
       htmlWriter()->queue( writeSigstatHeader( messagePart,
-					       cryptPlugWrapper(),
-					       node->trueFromAddress(),
+                                               cryptPlugWrapper(),
+                                               node->trueFromAddress(),
                                                filename ) );
     }
     QCString rfc822messageStr( node->msgPart().bodyDecoded() );
@@ -1435,8 +1435,8 @@
       //mReader->parseMsgHeader( &rfc822message );
     // display the body of the encapsulated message
     insertAndParseNewChildNode( *node,
-				&*rfc822messageStr,
-				"encapsulated message" );
+                                &*rfc822messageStr,
+                                "encapsulated message" );
     if ( mReader )
       htmlWriter()->queue( writeSigstatFooter( messagePart ) );
     return true;
@@ -1455,66 +1455,66 @@
 
     CryptPlugWrapper* oldUseThisCryptPlug = cryptPlugWrapper();
     if (    node->parentNode()
-	    && DwMime::kTypeMultipart    == node->parentNode()->type()
-	    && DwMime::kSubtypeEncrypted == node->parentNode()->subType() ) {
+            && DwMime::kTypeMultipart    == node->parentNode()->type()
+            && DwMime::kSubtypeEncrypted == node->parentNode()->subType() ) {
       kdDebug(5006) << "\n----->  Initially processing encrypted data\n" << endl;
       node->setEncryptionState( KMMsgFullyEncrypted );
       node->setCryptoType( partNode::CryptoTypeOpenPgpMIME );
       if ( keepEncryptions() ) {
-	const QCString cstr = node->msgPart().bodyDecoded();
-	if ( mReader )
-	  writeBodyString( cstr, node->trueFromAddress(),
-			   codecFor( node ), result );
-	mRawReplyString += cstr;
+        const QCString cstr = node->msgPart().bodyDecoded();
+        if ( mReader )
+          writeBodyString( cstr, node->trueFromAddress(),
+                           codecFor( node ), result );
+        mRawReplyString += cstr;
       } else {
-	/*
-	  ATTENTION: This code is to be replaced by the planned 'auto-detect' feature.
-	*/
-	PartMetaData messagePart;
-	setCryptPlugWrapper( kmkernel->cryptPlugList()->findForLibName( "openpgp" ) );
-	QCString decryptedData;
-	bool signatureFound;
-	struct CryptPlugWrapper::SignatureMetaData sigMeta;
-	sigMeta.status              = 0;
-	sigMeta.extended_info       = 0;
-	sigMeta.extended_info_count = 0;
-	sigMeta.nota_xml            = 0;
-	bool passphraseError;
-
-	bool bOkDecrypt = okDecryptMIME( *node,
-					 decryptedData,
-					 signatureFound,
-					 sigMeta,
-					 true,
-					 passphraseError,
-					 messagePart.errorText );
-
-	// paint the frame
-	if ( mReader ) {
-	  messagePart.isDecryptable = bOkDecrypt;
-	  messagePart.isEncrypted = true;
-	  messagePart.isSigned = false;
-	  htmlWriter()->queue( writeSigstatHeader( messagePart,
-						   cryptPlugWrapper(),
-						   node->trueFromAddress() ) );
-	}
-
-	if ( bOkDecrypt ) {
-	  // fixing the missing attachments bug #1090-b
-	  insertAndParseNewChildNode( *node,
-				      &*decryptedData,
-				      "encrypted data" );
-	} else {
-	  mRawReplyString += decryptedData;
-	  if ( mReader ) {
-	    // print the error message that was returned in decryptedData
-	    // (utf8-encoded)
-	    htmlWriter()->queue( QString::fromUtf8( decryptedData.data() ) );
-	  }
-	}
+        /*
+          ATTENTION: This code is to be replaced by the planned 'auto-detect' feature.
+        */
+        PartMetaData messagePart;
+        setCryptPlugWrapper( kmkernel->cryptPlugList()->findForLibName( "openpgp" ) );
+        QCString decryptedData;
+        bool signatureFound;
+        struct CryptPlugWrapper::SignatureMetaData sigMeta;
+        sigMeta.status              = 0;
+        sigMeta.extended_info       = 0;
+        sigMeta.extended_info_count = 0;
+        sigMeta.nota_xml            = 0;
+        bool passphraseError;
+
+        bool bOkDecrypt = okDecryptMIME( *node,
+                                         decryptedData,
+                                         signatureFound,
+                                         sigMeta,
+                                         true,
+                                         passphraseError,
+                                         messagePart.errorText );
+
+        // paint the frame
+        if ( mReader ) {
+          messagePart.isDecryptable = bOkDecrypt;
+          messagePart.isEncrypted = true;
+          messagePart.isSigned = false;
+          htmlWriter()->queue( writeSigstatHeader( messagePart,
+                                                   cryptPlugWrapper(),
+                                                   node->trueFromAddress() ) );
+        }
+
+        if ( bOkDecrypt ) {
+          // fixing the missing attachments bug #1090-b
+          insertAndParseNewChildNode( *node,
+                                      &*decryptedData,
+                                      "encrypted data" );
+        } else {
+          mRawReplyString += decryptedData;
+          if ( mReader ) {
+            // print the error message that was returned in decryptedData
+            // (utf8-encoded)
+            htmlWriter()->queue( QString::fromUtf8( decryptedData.data() ) );
+          }
+        }
 
-	if ( mReader )
-	  htmlWriter()->queue( writeSigstatFooter( messagePart ) );
+        if ( mReader )
+          htmlWriter()->queue( writeSigstatFooter( messagePart ) );
       }
       return true;
     }
@@ -1560,9 +1560,9 @@
     // or there is neither signed nor encrypted parameter.
     if ( !isSigned ) {
       if ( isEncrypted )
-	kdDebug(5006) << "pkcs7 mime     ==      S/MIME TYPE: enveloped (encrypted) data" << endl;
+        kdDebug(5006) << "pkcs7 mime     ==      S/MIME TYPE: enveloped (encrypted) data" << endl;
       else
-	kdDebug(5006) << "pkcs7 mime  -  type unknown  -  enveloped (encrypted) data ?" << endl;
+        kdDebug(5006) << "pkcs7 mime  -  type unknown  -  enveloped (encrypted) data ?" << endl;
       QCString decryptedData;
       PartMetaData messagePart;
       messagePart.isEncrypted = true;
@@ -1576,77 +1576,77 @@
       bool passphraseError;
 
       if ( okDecryptMIME( *node,
-			  decryptedData,
-			  signatureFound,
-			  sigMeta,
-			  false,
-			  passphraseError,
-			  messagePart.errorText ) ) {
-	kdDebug(5006) << "pkcs7 mime  -  encryption found  -  enveloped (encrypted) data !" << endl;
-	isEncrypted = true;
-	node->setEncryptionState( KMMsgFullyEncrypted );
-	signTestNode = 0;
-	// paint the frame
-	messagePart.isDecryptable = true;
-	if ( mReader )
-	  htmlWriter()->queue( writeSigstatHeader( messagePart,
-						   cryptPlugWrapper(),
-						   node->trueFromAddress() ) );
-	insertAndParseNewChildNode( *node,
-				    &*decryptedData,
-				    "encrypted data" );
-	if ( mReader )
-	  htmlWriter()->queue( writeSigstatFooter( messagePart ) );
+                          decryptedData,
+                          signatureFound,
+                          sigMeta,
+                          false,
+                          passphraseError,
+                          messagePart.errorText ) ) {
+        kdDebug(5006) << "pkcs7 mime  -  encryption found  -  enveloped (encrypted) data !" << endl;
+        isEncrypted = true;
+        node->setEncryptionState( KMMsgFullyEncrypted );
+        signTestNode = 0;
+        // paint the frame
+        messagePart.isDecryptable = true;
+        if ( mReader )
+          htmlWriter()->queue( writeSigstatHeader( messagePart,
+                                                   cryptPlugWrapper(),
+                                                   node->trueFromAddress() ) );
+        insertAndParseNewChildNode( *node,
+                                    &*decryptedData,
+                                    "encrypted data" );
+        if ( mReader )
+          htmlWriter()->queue( writeSigstatFooter( messagePart ) );
       } else {
 
-	if ( passphraseError ) {
-	  isEncrypted = true;
-	  signTestNode = 0;
-	}
-
-	if ( isEncrypted ) {
-	  kdDebug(5006) << "pkcs7 mime  -  ERROR: COULD NOT DECRYPT enveloped data !" << endl;
-	  // paint the frame
-	  messagePart.isDecryptable = false;
-	  if ( mReader ) {
-	    htmlWriter()->queue( writeSigstatHeader( messagePart,
-						     cryptPlugWrapper(),
-						     node->trueFromAddress() ) );
-	    writePartIcon( &node->msgPart(), node->nodeId() );
-	    htmlWriter()->queue( writeSigstatFooter( messagePart ) );
-	  }
-	} else {
-	  kdDebug(5006) << "pkcs7 mime  -  NO encryption found" << endl;
-	}
+        if ( passphraseError ) {
+          isEncrypted = true;
+          signTestNode = 0;
+        }
+
+        if ( isEncrypted ) {
+          kdDebug(5006) << "pkcs7 mime  -  ERROR: COULD NOT DECRYPT enveloped data !" << endl;
+          // paint the frame
+          messagePart.isDecryptable = false;
+          if ( mReader ) {
+            htmlWriter()->queue( writeSigstatHeader( messagePart,
+                                                     cryptPlugWrapper(),
+                                                     node->trueFromAddress() ) );
+            writePartIcon( &node->msgPart(), node->nodeId() );
+            htmlWriter()->queue( writeSigstatFooter( messagePart ) );
+          }
+        } else {
+          kdDebug(5006) << "pkcs7 mime  -  NO encryption found" << endl;
+        }
       }
       if ( isEncrypted )
-	node->setEncryptionState( KMMsgFullyEncrypted );
+        node->setEncryptionState( KMMsgFullyEncrypted );
     }
 
     // We now try signature verification if necessarry.
     if ( signTestNode ) {
       if ( isSigned )
-	kdDebug(5006) << "pkcs7 mime     ==      S/MIME TYPE: opaque signed data" << endl;
+        kdDebug(5006) << "pkcs7 mime     ==      S/MIME TYPE: opaque signed data" << endl;
       else
-	kdDebug(5006) << "pkcs7 mime  -  type unknown  -  opaque signed data ?" << endl;
+        kdDebug(5006) << "pkcs7 mime  -  type unknown  -  opaque signed data ?" << endl;
 
       bool sigFound = writeOpaqueOrMultipartSignedData( 0,
-							*signTestNode,
-							node->trueFromAddress(),
-							true,
-							0,
-							0,
-							isEncrypted );
+                                                        *signTestNode,
+                                                        node->trueFromAddress(),
+                                                        true,
+                                                        0,
+                                                        0,
+                                                        isEncrypted );
       if ( sigFound ) {
-	if ( !isSigned ) {
-	  kdDebug(5006) << "pkcs7 mime  -  signature found  -  opaque signed data !" << endl;
-	  isSigned = true;
-	}
-	signTestNode->setSignatureState( KMMsgFullySigned );
-	if ( signTestNode != node )
-	  node->setSignatureState( KMMsgFullySigned );
+        if ( !isSigned ) {
+          kdDebug(5006) << "pkcs7 mime  -  signature found  -  opaque signed data !" << endl;
+          isSigned = true;
+        }
+        signTestNode->setSignatureState( KMMsgFullySigned );
+        if ( signTestNode != node )
+          node->setSignatureState( KMMsgFullySigned );
       } else {
-	kdDebug(5006) << "pkcs7 mime  -  NO signature found   :-(" << endl;
+        kdDebug(5006) << "pkcs7 mime  -  NO signature found   :-(" << endl;
       }
     }
 
@@ -1662,9 +1662,9 @@
 
     QByteArray theBody( curNode->msgPart().bodyDecodedBinary() );
     QString fname( byteArrayToTempFile( mReader,
-					"groupware",
-					"msTNEF.raw",
-					theBody ) );
+                                        "groupware",
+                                        "msTNEF.raw",
+                                        theBody ) );
     if ( !fname.isEmpty() &&
          theBody.size() > 0 ) {
       QString vPart( curNode->msgPart().bodyDecoded() );
@@ -1690,14 +1690,14 @@
 
 
   void ObjectTreeParser::writeBodyString( const QCString & bodyString,
-					  const QString & fromAddress,
-					  const QTextCodec * codec,
-					  ProcessResult & result ) {
+                                          const QString & fromAddress,
+                                          const QTextCodec * codec,
+                                          ProcessResult & result ) {
     assert( mReader ); assert( codec );
     KMMsgSignatureState inlineSignatureState = result.inlineSignatureState();
     KMMsgEncryptionState inlineEncryptionState = result.inlineEncryptionState();
     writeBodyStr( bodyString, codec, fromAddress,
-		  inlineSignatureState, inlineEncryptionState );
+                  inlineSignatureState, inlineEncryptionState );
     result.setInlineSignatureState( inlineSignatureState );
     result.setInlineEncryptionState( inlineEncryptionState );
   }
@@ -1730,25 +1730,25 @@
     else {
       iconName = msgPart->iconName();
       if( iconName.right( 14 ) == "mime_empty.png" ) {
-	msgPart->magicSetType();
-	iconName = msgPart->iconName();
+        msgPart->magicSetType();
+        iconName = msgPart->iconName();
       }
     }
 
     if( inlineImage )
       // show the filename of the image below the embedded image
       htmlWriter()->queue( "<div><a href=\"" + href + "\">"
-			   "<img src=\"" + iconName + "\" border=\"0\"></a>"
-			   "</div>"
-			   "<div><a href=\"" + href + "\">" + label + "</a>"
-			   "</div>"
-			   "<div>" + comment + "</div><br>" );
+                           "<img src=\"" + iconName + "\" border=\"0\"></a>"
+                           "</div>"
+                           "<div><a href=\"" + href + "\">" + label + "</a>"
+                           "</div>"
+                           "<div>" + comment + "</div><br>" );
     else
       // show the filename next to the image
       htmlWriter()->queue( "<div><a href=\"" + href + "\"><img src=\"" +
-			   iconName + "\" border=\"0\">" + label +
-			   "</a></div>"
-			   "<div>" + comment + "</div><br>" );
+                           iconName + "\" border=\"0\">" + label +
+                           "</a></div>"
+                           "<div>" + comment + "</div><br>" );
   }
 
 #define SIG_FRAME_COL_UNDEF  99
@@ -1934,8 +1934,8 @@
 
 
 QString ObjectTreeParser::writeSigstatHeader( PartMetaData & block,
-					      CryptPlugWrapper * cryptPlug,
-					      const QString & fromAddress,
+                                              CryptPlugWrapper * cryptPlug,
+                                              const QString & fromAddress,
                                               const QString & filename )
 {
     bool isSMIME = cryptPlug && (0 <= cryptPlug->libName().find( "smime",   0, false ));
@@ -2079,7 +2079,7 @@
                                 i18n("sender: ") +
                                 msgFrom +
                                 "<br />" +
-			        i18n("stored: ");
+                                i18n("stored: ");
                             // We cannot use Qt's join() function here but
                             // have to join the addresses manually to
                             // extract the mail addresses (without '<''>')
@@ -2311,16 +2311,16 @@
     QString htmlStr;
 
     if (block.isSigned) {
-	htmlStr += "</td></tr><tr class=\"" + block.signClass + "H\">";
-	htmlStr += "<td dir=\"" + dir + "\">" +
-	    i18n( "End of signed message" ) +
-	    "</td></tr></table>";
+        htmlStr += "</td></tr><tr class=\"" + block.signClass + "H\">";
+        htmlStr += "<td dir=\"" + dir + "\">" +
+            i18n( "End of signed message" ) +
+            "</td></tr></table>";
     }
 
     if (block.isEncrypted) {
-	htmlStr += "</td></tr><tr class=\"encrH\"><td dir=\"" + dir + "\">" +
-		i18n( "End of encrypted message" ) +
-	    "</td></tr></table>";
+        htmlStr += "</td></tr><tr class=\"encrH\"><td dir=\"" + dir + "\">" +
+                i18n( "End of encrypted message" ) +
+            "</td></tr></table>";
     }
 
     if( block.isEncapsulatedRfc822Message )
@@ -2378,10 +2378,10 @@
       QString htmlStr;
       for( ; *pbit != 0; ++pbit, ++npbit )
       {
-	  // insert the next Non-OpenPGP block
-	  QCString str( *npbit );
-	  if( !str.isEmpty() ) {
-	    htmlStr += quotedHTML( aCodec->toUnicode( str ) );
+          // insert the next Non-OpenPGP block
+          QCString str( *npbit );
+          if( !str.isEmpty() ) {
+            htmlStr += quotedHTML( aCodec->toUnicode( str ) );
             kdDebug( 5006 ) << "Non-empty Non-OpenPGP block found: '" << str
                             << "'" << endl;
             // treat messages with empty lines before the first clearsigned
@@ -2401,74 +2401,81 @@
           }
           firstNonPgpBlock = false;
 
-	  //htmlStr += "<br>";
+          //htmlStr += "<br>";
 
-	  Kpgp::Block* block = *pbit;
-	  if( ( block->type() == Kpgp::PgpMessageBlock &&
+          Kpgp::Block* block = *pbit;
+          if( ( block->type() == Kpgp::PgpMessageBlock &&
                 // ### Workaround for bug 56693
                 !kmkernel->contextMenuShown() ) ||
-	      ( block->type() == Kpgp::ClearsignedBlock ) )
-	  {
-	      isPgpMessage = true;
-	      if( block->type() == Kpgp::PgpMessageBlock )
-	      {
-		if ( mReader )
-		  emit mReader->noDrag();
-		// try to decrypt this OpenPGP block
-		couldDecrypt = block->decrypt();
-		isEncrypted = block->isEncrypted();
-		if (!couldDecrypt) {
-		  decryptionError = pgp->lastErrorMsg();
-		}
-	      }
-	      else
-	      {
-		  // try to verify this OpenPGP block
-		  block->verify();
-	      }
-
-	      isSigned = block->isSigned();
-	      if( isSigned )
-	      {
+              ( block->type() == Kpgp::ClearsignedBlock ) )
+          {
+              isPgpMessage = true;
+              if( block->type() == Kpgp::PgpMessageBlock )
+              {
+                if ( mReader )
+                  emit mReader->noDrag();
+                // try to decrypt this OpenPGP block
+                couldDecrypt = block->decrypt();
+                isEncrypted = block->isEncrypted();
+                if (!couldDecrypt) {
+                  decryptionError = pgp->lastErrorMsg();
+                }
+              }
+              else
+              {
+                  // try to verify this OpenPGP block
+                  block->verify();
+              }
+
+              isSigned = block->isSigned();
+              if( isSigned )
+              {
                   keyId = block->signatureKeyId();
-		  signer = block->signatureUserId();
-		  if( !signer.isEmpty() )
-		  {
-		      goodSignature = block->goodSignature();
-
-		      if( !keyId.isEmpty() )
-			keyTrust = pgp->keyTrust( keyId );
-		      else
-			// This is needed for the PGP 6 support because PGP 6 doesn't
-			// print the key id of the signing key if the key is known.
-			keyTrust = pgp->keyTrust( signer );
-		  }
-	      }
+                  signer = block->signatureUserId();
+                  if( !signer.isEmpty() )
+                  {
+                      goodSignature = block->goodSignature();
+
+                      if( !keyId.isEmpty() ) {
+                        keyTrust = pgp->keyTrust( keyId );
+                        Kpgp::Key* key = pgp->publicKey( keyId );
+                        if ( key ) {
+                          // Use the user ID from the key because this one
+                          // is charset safe.
+                          signer = key->primaryUserID();
+                        }
+                      }
+                      else
+                        // This is needed for the PGP 6 support because PGP 6 doesn't
+                        // print the key id of the signing key if the key is known.
+                        keyTrust = pgp->keyTrust( signer );
+                  }
+              }
 
               if( isSigned )
                 inlineSignatureState = KMMsgPartiallySigned;
-	      if( isEncrypted )
+              if( isEncrypted )
                 inlineEncryptionState = KMMsgPartiallyEncrypted;
 
-	      PartMetaData messagePart;
+              PartMetaData messagePart;
+
+              messagePart.isSigned = isSigned;
+              messagePart.technicalProblem = false;
+              messagePart.isGoodSignature = goodSignature;
+              messagePart.isEncrypted = isEncrypted;
+              messagePart.isDecryptable = couldDecrypt;
+              messagePart.decryptionError = decryptionError;
+              messagePart.signer = signer;
+              messagePart.keyId = keyId;
+              messagePart.keyTrust = keyTrust;
 
-	      messagePart.isSigned = isSigned;
-	      messagePart.technicalProblem = false;
-	      messagePart.isGoodSignature = goodSignature;
-	      messagePart.isEncrypted = isEncrypted;
-	      messagePart.isDecryptable = couldDecrypt;
-	      messagePart.decryptionError = decryptionError;
-	      messagePart.signer = signer;
-	      messagePart.keyId = keyId;
-	      messagePart.keyTrust = keyTrust;
-
-	      htmlStr += writeSigstatHeader( messagePart, 0, fromAddress );
-
-	      htmlStr += quotedHTML( aCodec->toUnicode( block->text() ) );
-	      htmlStr += writeSigstatFooter( messagePart );
-	  }
-	  else // block is neither message block nor clearsigned block
-	    htmlStr += quotedHTML( aCodec->toUnicode( block->text() ) );
+              htmlStr += writeSigstatHeader( messagePart, 0, fromAddress );
+
+              htmlStr += quotedHTML( aCodec->toUnicode( block->text() ) );
+              htmlStr += writeSigstatFooter( messagePart );
+          }
+          else // block is neither message block nor clearsigned block
+            htmlStr += quotedHTML( aCodec->toUnicode( block->text() ) );
       }
 
       // add the last Non-OpenPGP block
@@ -2523,7 +2530,7 @@
     /* search next occurrence of '\n' */
     pos = s.find('\n', beg, FALSE);
     if (pos == (unsigned int)(-1))
-	pos = length;
+        pos = length;
 
     line = s.mid(beg,pos-beg);
     beg = pos+1;
@@ -2600,14 +2607,14 @@
 
 #ifdef MARCS_DEBUG
   void ObjectTreeParser::dumpToFile( const char * filename, const char * start,
-				     size_t len ) {
+                                     size_t len ) {
     assert( filename );
 
     QFile f( filename );
     if ( f.open( IO_WriteOnly ) ) {
       if ( start ) {
-	QDataStream ds( &f );
-	ds.writeRawBytes( start, len );
+        QDataStream ds( &f );
+        ds.writeRawBytes( start, len );
       }
       f.close();  // If data is 0 we just create a zero length file.
     }
--- knotes/knotesapp.cpp	26 Oct 2003 16:12:55 -0000	1.65
+++ knotes/knotesapp.cpp	1 Feb 2004 10:03:04 -0000	1.65.4.1
@@ -480,6 +480,8 @@
 
 void KNotesApp::saveNotes()
 {
+    ICalFormat format;
+
     QString file = KGlobal::dirs()->saveLocation( "appdata" ) + "notes.ics";
     QString backup = file + "~";
 
@@ -489,7 +491,7 @@
     if ( KIO::NetAccess::exists( KURL( file ) ) && !KIO::NetAccess::file_copy( KURL( file ), KURL( backup ), -1, true) )
         KMessageBox::error(0, i18n("<qt>Unable to save the notes backup to <b>%1</b>! Check that there is sufficient disk space.</qt>")
                                   .arg( backup ) );
-    else if ( !m_calendar.save( file, new ICalFormat() ) )
+    else if ( !m_calendar.save( file, &format ) )
         KMessageBox::error(0, i18n("<qt>Unable to save the notes to <b>%1</b>! Check that there is sufficient disk space.<br>"
                                    "There should be a backup in <b>%2</b> though.</qt>")
                                   .arg( file ).arg( backup ) );
