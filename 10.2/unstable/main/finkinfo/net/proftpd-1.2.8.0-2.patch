diff -ruN proftpd-1.2.8.orig/contrib/cron.monthly proftpd-1.2.8/contrib/cron.monthly
--- proftpd-1.2.8.orig/contrib/cron.monthly	Wed Dec 31 17:00:00 1969
+++ proftpd-1.2.8/contrib/cron.monthly	Tue Mar 18 21:53:09 2003
@@ -0,0 +1,12 @@
+#!/bin/sh
+#
+# cron script to rotate the proftpd server logfile, based on the
+# wu-ftpd script by Peter Tobias <tobias@et-inf.fho-emden.de>.
+
+[ -x @FINKPREFIX@/sbin/ftpstats ] || exit 0
+
+cd @FINKPREFIX@/var/log
+savelog -u root -g wheel -m 640 -c 12 @FINKPREFIX@/var/log/xferreport >/dev/null 2>/dev/null
+ftpstats -a -r -l 2 -d 2> /dev/null >@FINKPREFIX@/var/log/xferreport
+savelog -u root -g wheel -m 640 -c 7 @FINKPREFIX@/var/log/xferlog >/dev/null 2>/dev/null
+
diff -ruN proftpd-1.2.8.orig/contrib/ftpasswd proftpd-1.2.8/contrib/ftpasswd
--- proftpd-1.2.8.orig/contrib/ftpasswd	Thu Jan  2 10:28:14 2003
+++ proftpd-1.2.8/contrib/ftpasswd	Tue Mar 18 21:57:16 2003
@@ -36,7 +36,7 @@
 my $program = basename($0);
 my $default_passwd_file = "./ftpd.passwd";
 my $default_group_file = "./ftpd.group";
-my $shell_file = "/etc/shells";
+my $shell_file = "@FINKPREFIX@/etc/shells";
 my $default_cracklib_dict = "/usr/lib/cracklib_dict";
 my $cracklib_dict;
 my $output_file;
@@ -683,7 +683,7 @@
                 exist in the specified output-file, an entry will be created
                 for her.  Otherwise, the given fields will be updated.
 
-    --shell     Shell for the user (required).  Recommended: /bin/false
+    --shell     Shell for the user (required).  Recommended: /usr/bin/false
 
     --uid       Numerical user ID (required)
 
diff -ruN proftpd-1.2.8.orig/contrib/ftpstats proftpd-1.2.8/contrib/ftpstats
--- proftpd-1.2.8.orig/contrib/ftpstats	Wed Dec 31 17:00:00 1969
+++ proftpd-1.2.8/contrib/ftpstats	Tue Mar 18 21:53:09 2003
@@ -0,0 +1,389 @@
+#! /usr/bin/perl
+# ---------------------------------------------------------------------------
+#
+# USAGE: xferstats <options>
+#
+# OPTIONS:
+#       -f <filename>   Use <filename> for the log file
+#       -r              include real users 
+#       -a              include anonymous users 
+#       -h		include report on hourly traffic
+#       -d		include report on domain traffic
+#       -t		report on total traffic by section
+#	-i 		report incomming traffic only (uploads)
+#	-o		report outgoing traffic only (download)
+#       -D <domain>     report only on traffic from <domain>
+#				this option leads to problems with the local
+#				domain: e.g. test.com is counted under test
+#				and not recognized under com, -D com will give
+#				you only statistics about com excluding
+#				test.com! use -A com for correct results.
+#       -A <address>    report only on traffic from addresses ends matching
+#				<address> e.g. -A test.domain.com will report
+#				only on addresses ending with test.domain.com
+#       -l <depth>      Depth of path detail for sections
+#       -s <section>    Section to report on, For example: -s /pub will report
+#				only on paths under /pub
+#       -u <user>       Report traffic for specified user.
+#
+# ---------------------------------------------------------------------------
+# 05.09.01: minor change by Jamie Fifield (fifield@chebucto.ns.ca):
+# - added option u which singles out the data for a single user
+#
+# ---------------------------------------------------------------------------
+# 30.09.98: changes by Jan Menzel (jan.menzel@gmx.net):
+#  -documented problems with option -D
+#  -fixed same problems with spaces in the filenames (lines which are not
+#     exactly 16 elements long are skipped in earlier versions)
+#  -added option A which compares the addresses end with a given pattern
+#  -added option i and o which reports either incoming or outgoing traffic only
+
+@mydom = split(/\./, `dnsdomainname`);
+$mydom2 = pop(@mydom); chop($mydom2);
+$mydom1 = pop(@mydom);
+
+# If you want to specify $mydom1 and $mydom2 manually you should edit the
+# next two lines to customize for your domain. This will allow your domain
+# to be separated in the domain listing.
+# $mydom1 = "debian";
+# $mydom2 = "org";
+
+# edit the next line to customize for your default log file
+$usage_file = "@FINKPREFIX@/var/log/xferlog";
+
+# Edit the following lines for default report settings.
+# Entries defined here will be over-ridden by the command line.
+
+$opt_h = 0; 
+$opt_d = 0;
+$opt_t = 1;
+
+require 'getopts.pl';
+&Getopts('f:rahdD:l:s:A:iou:');
+
+$opt_l ||= 3;
+if ($opt_r) { $real = 1;}
+if ($opt_a) { $anon = 1;}
+if ($real == 0 && $anon == 0) { $anon = 1; }
+if ($opt_f) {$usage_file = $opt_f;}
+if ($opt_i) {$opt_i = 1;}
+if ($opt_o) {$opt_o = 1;}
+
+open (LOG,$usage_file) || die "Error opening usage log file: $usage_file\n";
+
+if ($opt_o) {
+   print "Transfer Totals include outgoing traffic only.\n\n";
+}
+
+if ($opt_i) {
+   print "Transfer Totals include incoming traffic only.\n\n";
+}
+
+if ($opt_D) {
+   $opt_D =~ tr/A-Z/a-z/;
+   print "Transfer Totals include the '$opt_D' domain only.\n";
+   print "All other domains are filtered out for this report.\n\n";
+}
+
+if ($opt_A) {
+   $opt_A =~ tr/A-Z/a-z/;
+   print "Transfer Totals include the addresses ending in '$opt_A' only.\n";
+   print "All other addresses are filtered out for this report.\n\n";
+}
+
+if ($opt_s) {
+   print "Transfer Totals include the '$opt_s' section only.\n";
+   print "All other sections are filtered out for this report.\n\n";
+}
+
+if ($opt_u) {
+   print "Transfer Totals are for user '$opt_u' only.\n";
+   print "All other users are filtered out for this report.\n\n";
+}
+
+line: while (<LOG>) {
+
+   @line = split;
+   # is the first entry week day abbreviation?
+   next if (length("$line[0]") != 3);
+
+   # check whether there is a valid 'username'
+   if ($line[-7] eq "a" or $line[-7] eq "b") {
+      # yes, there i
+      # offset points to the first element just behind the filename
+      $offset = $#line - 7;
+   } elsif ($line[-6] eq "a" or $line[-6] eq "b") {
+      $offset = $#line - 6
+   } else {
+      next;
+   }
+   next if (!$opt_u && !$anon && $line[$offset+3] eq "a");
+   next if (!$opt_u && !$real && $line[$offset+3] eq "r");
+   next if ($opt_i && $line[$offset+2] ne "i");
+   next if ($opt_o && $line[$offset+2] ne "o");
+   next if ($opt_u && $line[$offset+4] ne $opt_u);
+
+   $daytime = substr($_, 0, 10) . substr($_, 19, 5);
+   $time = substr($_,11,2); 
+
+   if ($line[8] eq "\.") { $line[8] = "/unreadable/filename";}
+   next if (substr($line[8],0,length("$opt_s")) ne "$opt_s");
+   $line[8] = substr($line[8],length("$opt_s"));
+   @path = split(/\//, $line[8]);
+
+#
+# Why was the original xferstats dropping leading 1 character path
+# segments???
+#
+#  while (length($path[1]) <= 1) {
+#     shift @path;
+#     next line if ($#path == -1);
+#  }
+
+# Things in the top-level directory are assumed to be informational files
+
+   if ($#path == 1)
+      { $pathkey = "Index/Informational Files"; }
+      else {
+	$pathkey = "";
+	for ($i=1; $i <= $#path-1 && $i <= $opt_l;$i++) {
+		$pathkey = $pathkey . "/" . $path[$i];
+		}
+	}
+
+   $line[6] =~ tr/A-Z/a-z/;
+
+   @address = split(/\./, $line[6]);
+
+   $domain = $address[$#address];
+   if ($domain eq "$mydom2" && $address[$#address-1] eq "$mydom1")
+      { $domain = $mydom1 . "." . $mydom2; }
+   if ( int($address[0]) > 0 || $#address < 2 )
+      { $domain = "unresolved"; }
+
+   $count = 1;
+   if ($opt_D and substr($domain,0,length("$opt_D")) ne "$opt_D" ) {
+      $count = 0;
+   }
+   if ($opt_A and substr($line[6],length("$line[6]")-length("$opt_A")) ne "$opt_A" ) {
+      $count = 0;
+   }
+
+
+   if ($count) {
+
+   $systemfiles{$line[6]}++;                    # Systems Accessing the Arc
+   $xferfiles++;                                # total files sent
+   $xfertfiles++;                               # total files sent
+   $xferfiles{$daytime}++;                      # files per day
+   $groupfiles{$pathkey}++;                     # per-group accesses
+   $domainfiles{$domain}++;
+
+   $xfersecs{$daytime}    += $line[5];          # xmit seconds per day
+   $domainsecs{$domain}   += $line[5];		# xmit seconds for domain
+   $xferbytes{$daytime}   += $line[7];          # bytes per day
+   $domainbytes{$domain}  += $line[7];		# xmit bytes to domain
+   $xferbytes             += $line[7];          # total bytes sent
+   $groupbytes{$pathkey}  += $line[7];          # per-group bytes sent
+
+   $xfertfiles{$time}++;                        # files per hour
+   $xfertsecs{$time}      += $line[5];          # xmit seconds per hour
+   $xfertbytes{$time}     += $line[7];          # bytes per hour
+   $xfertbytes            += $line[7];          # total bytes sent
+   }
+}
+close LOG;
+
+@syslist = keys(systemfiles);
+@dates = sort datecompare keys(xferbytes);
+
+if ($xferfiles == 0) {die "There was no data to process.\n";}
+
+
+print "TOTALS FOR SUMMARY PERIOD ", $dates[0], " TO ", $dates[$#dates], "\n\n";
+printf ("Files Transmitted During Summary Period  %12.0f\n", $xferfiles);
+printf ("Bytes Transmitted During Summary Period  %12.0f\n", $xferbytes); 
+printf ("Systems Using Archives                   %12.0f\n\n", $#syslist+1);
+
+printf ("Average Files Transmitted Daily          %12.0f\n",
+   $xferfiles / ($#dates + 1));
+printf ("Average Bytes Transmitted Daily          %12.0f\n",
+   $xferbytes / ($#dates + 1));
+
+format top1 =
+
+Daily Transmission Statistics
+
+                 Number Of    Number of    Average    Percent Of  Percent Of
+     Date        Files Sent  Bytes  Sent  Xmit  Rate  Files Sent  Bytes Sent
+---------------  ----------  -----------  ----------  ----------  ----------
+.
+
+format line1 =
+@<<<<<<<<<<<<<<  @>>>>>>>>>  @>>>>>>>>>>  @>>>>>>>>>  @>>>>>>>    @>>>>>>>  
+$date,           $nfiles,    $nbytes,     $avgrate,   $pctfiles,  $pctbytes
+.
+
+$^ = top1;
+$~ = line1;
+
+# sort daily traffic by bytes sendt
+#foreach $date ( sort datecompare keys(nbytes) ) {
+foreach $date ( sort datecompare keys(xferbytes) ) {
+
+   $nfiles = $xferfiles{$date};
+   $nbytes = $xferbytes{$date};
+   if ($xfersecs{$date}) {
+      $avgrate = sprintf("%5.1f KB/s", $xferbytes{$date}/$xfersecs{$date}/1024);
+   } else {
+      $avgrate = sprintf("undefined");
+   }
+   $pctfiles = sprintf("%8.2f", 100*$xferfiles{$date}/$xferfiles);
+   $pctbytes = sprintf("%8.2f", 100*$xferbytes{$date}/$xferbytes);
+   write;
+}
+
+if ($opt_t) {
+format top2 =
+
+Total Transfers from each Archive Section (By bytes)
+
+                                                   ---- Percent  Of ----
+     Archive Section      Files Sent Bytes Sent    Files Sent Bytes Sent
+------------------------- ---------- ------------- ---------- ----------
+.
+
+format line2 =
+@<<<<<<<<<<<<<<<<<<<<<<<< @>>>>>>>>> @>>>>>>>>>>>> @>>>>>>>   @>>>>>>>
+$section,                 $files,    $bytes,       $pctfiles, $pctbytes
+.
+
+$| = 1;
+$- = 0;
+$^ = top2;
+$~ = line2;
+
+# sort total transfer for each archive by # files transfered
+foreach $section ( sort bytecompare keys(groupfiles) ) {
+
+   $files = $groupfiles{$section};
+   $bytes = $groupbytes{$section};
+   $pctbytes = sprintf("%8.2f", 100 * $groupbytes{$section} / $xferbytes);
+   $pctfiles = sprintf("%8.2f", 100 * $groupfiles{$section} / $xferfiles);
+   write;
+
+}
+
+}
+
+if ($opt_d) {
+format top3 =
+
+Total Transfer Amount By Domain
+
+             Number Of    Number of     Average    Percent Of  Percent Of
+Domain Name  Files Sent   Bytes Sent   Xmit  Rate  Files Sent  Bytes Sent
+-----------  ----------  ------------  ----------  ----------  ----------
+.
+
+format line3 =
+@<<<<<<<<<<  @>>>>>>>>>  @>>>>>>>>>>>  @>>>>>>>>>  @>>>>>>>    @>>>>>>>  
+$domain,     $files,     $bytes,       $avgrate,   $pctfiles,  $pctbytes
+.
+
+$- = 0;
+$^ = top3;
+$~ = line3;
+
+# sort amount per domain by files
+foreach $domain ( sort domnamcompare keys(domainfiles) ) {
+
+   $files = $domainfiles{$domain};
+   $bytes = $domainbytes{$domain};
+   if ($domainsecs{$domain}) {
+      $avgrate = sprintf("%5.1f KB/s", $domainbytes{$domain}/$domainsecs{$domain}/1024);
+   } else {
+      $avgrate = sprintf("undefined");
+   }
+   $pctfiles = sprintf("%8.2f", 100 * $domainfiles{$domain} / $xferfiles);
+   $pctbytes = sprintf("%8.2f", 100 * $domainbytes{$domain} / $xferbytes);
+   write;
+
+}
+
+print "\n";
+
+}
+
+if ($opt_h) {
+
+format top8 =
+
+Hourly Transmission Statistics
+
+                 Number Of    Number of    Average    Percent Of  Percent Of
+     Time        Files Sent  Bytes  Sent  Xmit  Rate  Files Sent  Bytes Sent
+---------------  ----------  -----------  ----------  ----------  ----------
+.
+
+format line8 =
+@<<<<<<<<<<<<<<  @>>>>>>>>>  @>>>>>>>>>>  @>>>>>>>>>  @>>>>>>>    @>>>>>>>  
+$time,           $nfiles,    $nbytes,     $avgrate,   $pctfiles,  $pctbytes
+.
+
+
+$| = 1;
+$- = 0;
+$^ = top8;
+$~ = line8;
+
+# sort hourly transmission by sent bytes
+foreach $time ( sort keys(xfertbytes) ) {
+
+   $nfiles   = $xfertfiles{$time};
+   $nbytes   = $xfertbytes{$time};
+   if ($xfertsecs{$time}) {
+      $avgrate  = sprintf("%5.1f KB/s", $xfertbytes{$time}/$xfertsecs{$time}/1024);
+   } else {
+      $avgrate  = sprintf("undefined");
+   }
+   $pctfiles = sprintf("%8.2f", 100*$xfertfiles{$time} / $xferfiles);
+   $pctbytes = sprintf("%8.2f", 100*$xfertbytes{$time} / $xferbytes);
+   write;
+}
+}
+exit(0);
+
+sub datecompare {
+
+   $date1  = substr($a, 11, 4) * 4800;
+   $date2  = substr($b, 11, 4) * 4800;
+   $date1 += index("JanFebMarAprMayJunJulAugSepOctNovDec",substr($a, 4, 3)) / 3 * 400;
+   $date2 += index("JanFebMarAprMayJunJulAugSepOctNovDec",substr($b, 4, 3)) / 3 * 400;
+   $date1 += substr($a, 8, 2);
+   $date2 += substr($b, 8, 2);
+   $date1 - $date2;
+
+}
+
+sub domnamcompare {
+
+   $sdiff = length($a) - length($b);
+   ($sdiff < 0) ? -1 : ($sdiff > 0) ? 1 : ($a lt $b) ? -1 : ($a gt $b) ? 1 : 0;
+
+}
+
+sub bytecompare {
+
+   $bdiff = $groupbytes{$b} - $groupbytes{$a};
+   ($bdiff < 0) ? -1 : ($bdiff > 0) ? 1 : ($a lt $b) ? -1 : ($a gt $b) ? 1 : 0;
+
+}
+
+sub faccompare {
+
+   $fdiff = $fac{$b} - $fac{$a};
+   ($fdiff < 0) ? -1 : ($fdiff > 0) ? 1 : ($a lt $b) ? -1 : ($a gt $b) ? 1 : 0;
+
+}
+
diff -ruN proftpd-1.2.8.orig/include/default_paths.h proftpd-1.2.8/include/default_paths.h
--- proftpd-1.2.8.orig/include/default_paths.h	Thu Jan  2 10:28:15 2003
+++ proftpd-1.2.8/include/default_paths.h	Tue Mar 18 21:54:31 2003
@@ -36,7 +36,7 @@
  * ftpcount, ftpwho, etc.
  */
 #ifndef RUN_DIR
-#define RUN_DIR			"/var/run/proftpd"
+#define RUN_DIR			"@FINKPREFIX@/var/run/proftpd"
 #endif
 
 /* The location you wish to place any core files produced as a result of
@@ -50,37 +50,37 @@
  * when run in standalone daemon mode.
  */
 #ifndef PID_FILE_PATH
-#define PID_FILE_PATH		"/var/run/proftpd.pid"
+#define PID_FILE_PATH		"@FINKPREFIX@/var/run/proftpd.pid"
 #endif
 
 /* The default location of the proftpd configuration file.  Can be
  * overriden at runtime with the '-c' switch
  */
 #ifndef CONFIG_FILE_PATH
-#define	CONFIG_FILE_PATH	"/etc/proftpd.conf"
+#define	CONFIG_FILE_PATH	"@FINKPREFIX@/etc/proftpd.conf"
 #endif
 
 /* The location of your `shells' file; a newline delimited list of
  * valid shells on your system.
  */
-#define VALID_SHELL_PATH	"/etc/shells"
+#define VALID_SHELL_PATH	"@FINKPREFIX@/etc/shells"
 
 /* Where your log files are kept.  The "wu-ftpd style" xferlog is
  * stored here, as well as "extended" (not yet available) transfer
  * log files.  These can be overridden in the configuration file via
  * "TransferLog" and "ExtendedLog".  (note ExtendedLog does not work yet)
  */
-#define XFERLOG_PATH		"/var/log/xferlog"
-#define EXTLOG_PATH		"/var/log/proftpd-log"
+#define XFERLOG_PATH		"@FINKPREFIX@/var/log/xferlog"
+#define EXTLOG_PATH		"@FINKPREFIX@/var/log/proftpd-log"
 
 /* Location of the file that tells proftpd to discontinue servicing
  * requests.
  */
-#define SHUTMSG_PATH		"/etc/shutmsg"
+#define SHUTMSG_PATH		"@FINKPREFIX@/etc/shutmsg"
 
 /* Location of the file containing users that *cannot* use ftp
  * services (odd, eh?)
  */
-#define FTPUSERS_PATH		"/etc/ftpusers"
+#define FTPUSERS_PATH		"@FINKPREFIX@/etc/ftpusers"
 
 #endif /* PROFTPD_PATHS_H */
diff -ruN proftpd-1.2.8.orig/src/dirtree.c proftpd-1.2.8/src/dirtree.c
--- proftpd-1.2.8.orig/src/dirtree.c	Tue Feb 25 21:30:06 2003
+++ proftpd-1.2.8/src/dirtree.c	Tue Mar 18 21:53:09 2003
@@ -533,10 +533,10 @@
 
     /* Perform a fixup on configuration directives so that:
      * -argv[0]--  -argv[1]-- ----argv[2]-----
-     * <Option     /etc/adir  /etc/anotherdir>
+     * <Option     @FINKPREFIX@/etc/adir  @FINKPREFIX@/etc/anotherdir>
      *   .. becomes ..
      * -argv[0]--  -argv[1]-  ----argv[2]----
-     * <Option>    /etc/adir  /etc/anotherdir
+     * <Option>    @FINKPREFIX@/etc/adir  @FINKPREFIX@/etc/anotherdir
      */
 
     if (new_cmd->argc && *(new_cmd->argv[0]) == '<') {
@@ -2336,12 +2336,12 @@
        * Just a partial match on the pathname does not mean that the longer
        * path is the subdirectory of the other -- they might just be sharing
        * the last path component!
-       * /var/www/.1
-       * /var/www/.14
-       *            ^ -- not /, not subdir
-       * /var/www/.1
-       * /var/www/.1/images
-       *            ^ -- /, is subdir
+       * @FINKPREFIX@/var/www/.1
+       * @FINKPREFIX@/var/www/.14
+       *                        ^ -- not /, not subdir
+       * @FINKPREFIX@/var/www/.1
+       * @FINKPREFIX@/var/www/.1/images
+       *                        ^ -- /, is subdir
        */
       if (strlen(path) > len && path[len] != '/')
           continue;
diff -ruN proftpd-1.2.8.orig/src/main.c proftpd-1.2.8/src/main.c
--- proftpd-1.2.8.orig/src/main.c	Sun Mar  2 19:21:09 2003
+++ proftpd-1.2.8/src/main.c	Tue Mar 18 21:53:09 2003
@@ -1357,7 +1357,7 @@
     }
 
     /* If running (a flag signaling whether proftpd is just starting up)
-     * AND shutdownp (a flag signalling the present of /etc/shutmsg) are
+     * AND shutdownp (a flag signalling the present of @FINKPREFIX@/etc/shutmsg) are
      * true, then log an error stating this -- but don't stop the server.
      */
     if (shutdownp && !running) {
diff -ruN proftpd-1.2.8.orig/src/proftpd.8 proftpd-1.2.8/src/proftpd.8
--- proftpd-1.2.8.orig/src/proftpd.8	Thu Jan  2 10:28:21 2003
+++ proftpd-1.2.8/src/proftpd.8	Tue Mar 18 21:53:09 2003
@@ -30,7 +30,7 @@
 option, the main
 .B proftpd
 daemon writes its process ID to
-.B /var/run/proftpd.pid
+.B @FINKPREFIX@/var/run/proftpd.pid
 to make it easy to know which process to SIGHUP.
 .SH OPTIONS
 .TP 12
@@ -65,7 +65,7 @@
 .TP
 .BI \-c,\--config " config\-file"
 Specifies an alternate \fIconfig\-file\fP to be parsed at startup, rather
-than the default (typically found in \fB/etc/proftpd.conf\fP).
+than the default (typically found in \fB@FINKPREFIX@/etc/proftpd.conf\fP).
 .TP
 .BI \-t,\--configtest
 Read the configuration file, report any syntax errors, and exit.
@@ -80,21 +80,21 @@
 Lists all modules compiled into proftpd.
 .SH FILES
 .PD 0
-.B /usr/sbin/proftpd
+.B @FINKPREFIX@/sbin/proftpd
 .br
-.B /usr/bin/ftpwho
+.B @FINKPREFIX@/bin/ftpwho
 .br
-.B /usr/bin/ftpcount
+.B @FINKPREFIX@/bin/ftpcount
 .br
-.B /usr/bin/ftptop
+.B @FINKPREFIX@/bin/ftptop
 .br
-.B /usr/sbin/ftpshut
+.B @FINKPREFIX@/sbin/ftpshut
 .br
-.B /var/log/xferlog
+.B @FINKPREFIX@/var/log/xferlog
 .br
-.B /var/run/proftpd.pid
+.B @FINKPREFIX@/var/run/proftpd.pid
 .br
-.B /var/run/proftpd.scoreboard
+.B @FINKPREFIX@/var/run/proftpd.scoreboard
 .PD
 .SH AUTHORS
 .PP
diff -ruN proftpd-1.2.8.orig/src/xferlog.5 proftpd-1.2.8/src/xferlog.5
--- proftpd-1.2.8.orig/src/xferlog.5	Thu Jan  2 10:28:22 2003
+++ proftpd-1.2.8/src/xferlog.5	Tue Mar 18 21:53:09 2003
@@ -7,7 +7,7 @@
 .B xferlog
 file contains logging information from the FTP server daemon,
 .BR proftpd (8).
-This file usually is found in /var/log, but can be located anywhere by
+This file usually is found in @FINKPREFIX@/var/log, but can be located anywhere by
 using a
 .BR proftpd (8)
 configuration directive.
@@ -147,7 +147,7 @@
 .SH FILES
 .PD 0
 .TP 20
-.B /var/log/xferlog
+.B @FINKPREFIX@/var/log/xferlog
 .PP
 .PD
 .SH AUTHORS
diff -ruN proftpd-1.2.8.orig/utils/ftpcount.1 proftpd-1.2.8/utils/ftpcount.1
--- proftpd-1.2.8.orig/utils/ftpcount.1	Thu Jan  2 10:28:22 2003
+++ proftpd-1.2.8/utils/ftpcount.1	Tue Mar 18 21:53:09 2003
@@ -29,9 +29,9 @@
 proftpd's scoreboard.
 .SH FILES
 .PD 0
-.B /usr/bin/ftpcount
+.B @FINKPREFIX@/usr/bin/ftpcount
 .br
-.B /var/run/proftpd/proftpd.scoreboard
+.B @FINKPREFIX@/var/run/proftpd/proftpd.scoreboard
 .PD
 .SH AUTHORS
 .PP
diff -ruN proftpd-1.2.8.orig/utils/ftpcount.c proftpd-1.2.8/utils/ftpcount.c
--- proftpd-1.2.8.orig/utils/ftpcount.c	Sat Jan  4 18:31:35 2003
+++ proftpd-1.2.8/utils/ftpcount.c	Tue Mar 18 21:53:09 2003
@@ -24,7 +24,7 @@
  * the source code for OpenSSL in the source distribution.
  */
 
-/* Shows a count of "who" is online via proftpd.  Uses the /var/run/proftpd*
+/* Shows a count of "who" is online via proftpd.  Uses the @FINKPREFIX@/var/run/proftpd*
  * log files.
  *
  * $Id: ftpcount.c,v 1.8 2003/01/05 01:31:35 jwm Exp $
diff -ruN proftpd-1.2.8.orig/utils/ftpshut.8 proftpd-1.2.8/utils/ftpshut.8
--- proftpd-1.2.8.orig/utils/ftpshut.8	Wed Sep 25 17:45:24 2002
+++ proftpd-1.2.8/utils/ftpshut.8	Tue Mar 18 21:53:09 2003
@@ -21,7 +21,7 @@
 command provides an automated shutdown procedure that a superuser
 can use to automagically disconnect current proftpd connections,
 and deny new connections.  The command creates a control file as
-.B /etc/shutmsg
+.B @FINKPREFIX@/etc/shutmsg
 to inform proftpd processes about an impending shutdown.
 .SH OPTIONS
 .TP 10
@@ -97,9 +97,9 @@
 until the indicated time on the following day.
 .SH FILES
 .PD 0
-.B /usr/sbin/ftpshut
+.B @FINKPREFIX@/usr/sbin/ftpshut
 .br
-.B /etc/shutmsg
+.B @FINKPREFIX@/etc/shutmsg
 .PD
 .SH AUTHORS
 .PP
diff -ruN proftpd-1.2.8.orig/utils/ftpwho.1 proftpd-1.2.8/utils/ftpwho.1
--- proftpd-1.2.8.orig/utils/ftpwho.1	Thu Jan  2 10:28:22 2003
+++ proftpd-1.2.8/utils/ftpwho.1	Tue Mar 18 21:53:09 2003
@@ -38,9 +38,9 @@
 host and current working directory.
 .SH FILES
 .PD 0
-.B /usr/bin/ftpwho
+.B @FINKPREFIX@/usr/bin/ftpwho
 .br
-.B /var/run/proftpd/proftpd.scoreboard
+.B @FINKPREFIX@/var/run/proftpd/proftpd.scoreboard
 .PD
 .SH AUTHORS
 .PP
diff -ruN proftpd-1.2.8.orig/utils/ftpwho.c proftpd-1.2.8/utils/ftpwho.c
--- proftpd-1.2.8.orig/utils/ftpwho.c	Mon Feb 24 11:39:52 2003
+++ proftpd-1.2.8/utils/ftpwho.c	Tue Mar 18 21:53:09 2003
@@ -24,7 +24,7 @@
  * the source code for OpenSSL in the source distribution.
  */
 
-/* Shows a count of "who" is online via proftpd.  Uses the /var/run/proftpd*
+/* Shows a count of "who" is online via proftpd.  Uses the @FINKPREFIX@/var/run/proftpd*
  * log files.
  *
  * $Id: ftpwho.c,v 1.18 2003/02/24 18:39:52 castaglia Exp $
diff -ruN proftpd-1.2.8.orig/utils/ftpwho.c~ proftpd-1.2.8/utils/ftpwho.c~
--- proftpd-1.2.8.orig/utils/ftpwho.c~	Wed Dec 31 17:00:00 1969
+++ proftpd-1.2.8/utils/ftpwho.c~	Mon Feb 24 11:39:52 2003
@@ -0,0 +1,488 @@
+/*
+ * ProFTPD - FTP server daemon
+ * Copyright (c) 1997, 1998 Public Flood Software
+ * Copyright (c) 1999, 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>
+ * Copyright (c) 2001, 2002, 2003 The ProFTPD Project team
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * As a special exemption, Public Flood Software/MacGyver aka Habeeb J. Dihu
+ * and other respective copyright holders give permission to link this program
+ * with OpenSSL, and distribute the resulting executable, without including
+ * the source code for OpenSSL in the source distribution.
+ */
+
+/* Shows a count of "who" is online via proftpd.  Uses the /var/run/proftpd*
+ * log files.
+ *
+ * $Id: ftpwho.c,v 1.18 2003/02/24 18:39:52 castaglia Exp $
+ */
+
+#include "utils.h"
+
+#define MAX_CLASSES 100
+struct scoreboard_class {
+   char *score_class;
+   unsigned long score_count;
+};
+
+#define OF_COMPAT		0x001
+#define OF_ONELINE		0x002
+
+static const char *config_filename = CONFIG_FILE_PATH;
+
+char *util_sstrncpy(char *, const char *, size_t);
+
+static char *percent_complete(off_t size, off_t done) {
+  static char sbuf[32];
+
+  memset(sbuf, '\0', sizeof(sbuf));
+
+  if (done == 0) {
+    util_sstrncpy(sbuf, "0", sizeof(sbuf));
+
+  } else if (size == 0) {
+    util_sstrncpy(sbuf, "Inf", sizeof(sbuf));
+
+  } else if (done >= size) {
+    util_sstrncpy(sbuf, "100", sizeof(sbuf));
+
+  } else {
+    snprintf(sbuf, sizeof(sbuf), "%.0f",
+	     ((double) done / (double) size) * 100.0);
+    sbuf[sizeof(sbuf)-1] = '\0';
+  }
+
+  return sbuf;
+}
+
+static const char *show_time(time_t *i) {
+  time_t now = time(NULL);
+  unsigned long l;
+  static char sbuf[7];
+
+  if (!i || !*i)
+    return "-";
+
+  memset(sbuf, '\0', sizeof(sbuf));
+  l = now - *i;
+
+  if (l < 3600)
+    snprintf(sbuf, sizeof(sbuf), "%lum%lus",(l / 60),(l % 60));
+  else
+    snprintf(sbuf, sizeof(sbuf), "%luh%lum",(l / 3600),
+    ((l - (l / 3600) * 3600) / 60));
+
+  return sbuf;
+}
+
+/* scan_config_file() is a kludge for 1.2 which does a very simplistic attempt
+ * at determining what the "ScoreboardFile" directive is set to.  It will be
+ * replaced in 1.3 with the abstracted configure system (hopefully).
+ */
+static void scan_config_file(void) {
+  FILE *fp = NULL;
+  char buf[PR_TUNABLE_BUFFER_SIZE] = {'\0'};
+  char *cp, *file = NULL;
+
+  if (!config_filename || (fp = fopen(config_filename,"r")) == NULL)
+    return;
+
+  while (!file && fgets(buf, sizeof(buf) - 1, fp)) {
+    int i = strlen(buf);
+
+    if (i && buf[i - 1] == '\n')
+      buf[i-1] = '\0';
+
+    for (cp = buf; *cp && isspace((int) *cp); cp++);
+
+    if (*cp == '#' || !*cp)
+      continue;
+
+    i = strlen("ScoreboardFile");
+
+    if (strncasecmp(cp, "ScoreboardFile", i) != 0)
+      continue;
+
+    /* Found it! */
+    cp += i;
+
+    /* strip whitespace */
+    while (*cp && isspace((int) *cp))
+      cp++;
+
+    file = cp;
+
+    /* If the scoreboard file argument is quoted, dequote */
+    if (*cp == '"') {
+      char *src = cp;
+
+      cp++;
+      file++;
+
+      while (*++src) {
+        switch (*src) {
+          case '\\':
+            if (*++src)
+              *cp++ = *src;
+            break;
+
+          case '"':
+            src++;
+            break;
+
+          default:
+            *cp++ = *src;
+        }
+      }
+
+      *cp = '\0';
+    }
+  }
+
+  fclose(fp);
+
+  /* If we got something out of all this, go ahead and set it. */
+  if (file)
+    util_set_scoreboard(file);
+}
+
+static int check_scoreboard_file(void) {
+  struct stat sbuf;
+
+  if (stat(util_get_scoreboard(), &sbuf) < 0)
+    return -1;
+
+  return 0;
+}
+
+static struct option_help {
+  const char *long_opt,*short_opt,*desc;
+} opts_help[] = {
+  { "--config", "-c", "specify full path to proftpd configuration file" },
+  { "--file", "-f", "specify full path to scoreboard file" },
+  { "--help", "-h", NULL },
+  { "--outform", "-o", "specify an output format" },
+  { "--verbose","-v", "display additional information for each connection" },
+  { NULL }
+};
+
+#ifdef HAVE_GETOPT_LONG
+static struct option opts[] = {
+  { "config",  1, NULL, 'c' },
+  { "file",    1, NULL, 'f' },
+  { "help",    0, NULL, 'h' },
+  { "outform", 1, NULL, 'o' },
+  { "verbose", 0, NULL, 'v' },
+  { NULL,      0, NULL, 0   }
+};
+#endif /* HAVE_GETOPT_LONG */
+
+static void show_usage(const char *progname, int exit_code) {
+  struct option_help *h = NULL;
+
+  printf("usage: %s [options]\n", progname);
+  for (h = opts_help; h->long_opt; h++) {
+#ifdef HAVE_GETOPT_LONG
+    printf("  %s, %s\n", h->long_opt, h->short_opt);
+#else /* HAVE_GETOPT_LONG */
+    printf("  %s\n", h->short_opt);
+#endif
+    if (!h->desc)
+      printf("    display %s usage\n", progname);
+    else
+      printf("    %s\n", h->desc);
+  }
+
+  exit(exit_code);
+}
+
+int main(int argc, char **argv) {
+  pr_scoreboard_entry_t *score = NULL;
+  pid_t mpid = 0;
+  unsigned int count = 0, total = 0;
+  int c = 0, res = 0;
+  struct scoreboard_class classes[MAX_CLASSES];
+  char *cp, *progname = *argv;
+  const char *cmdopts = "c:f:ho:v";
+  unsigned char verbose = FALSE;
+  unsigned long outform = 0;
+
+  memset(classes, 0, MAX_CLASSES * sizeof(struct scoreboard_class));
+
+  if((cp = strrchr(progname,'/')) != NULL)
+    progname = cp+1;
+
+  opterr = 0;
+  while((c =
+#ifdef HAVE_GETOPT_LONG
+	 getopt_long(argc, argv, cmdopts, opts, NULL)
+#else /* HAVE_GETOPT_LONG */
+	 getopt(argc, argv, cmdopts)
+#endif /* HAVE_GETOPT_LONG */
+	 ) != -1) {
+    switch (c) {
+      case 'h':
+        show_usage(progname, 0);
+
+      case 'v':
+        verbose = TRUE;
+        break;
+
+      case 'f':
+        util_set_scoreboard(optarg);
+        break;
+
+      case 'c':
+        config_filename = strdup(optarg);
+        break;
+
+      case 'o':
+        /* Check the given outform parameter. */
+        if (!strcmp(optarg, "compat")) {
+          outform |= OF_COMPAT;
+          break;
+
+        } else if (!strcmp(optarg, "oneline")) {
+          outform |= OF_ONELINE;
+          break;
+        }
+
+        fprintf(stderr, "unknown outform value: '%s'\n", optarg);
+        return 1;
+
+      case '?':
+        fprintf(stderr, "unknown option: %c\n", (char)optopt);
+        show_usage(progname,1);
+    }
+  }
+
+  /* First attempt to check the supplied/default scoreboard path.  If this is
+   * incorrect, try the config file kludge.
+   */
+  if (check_scoreboard_file() < 0) {
+    scan_config_file();
+
+    if (check_scoreboard_file() < 0) {
+      fprintf(stderr, "%s: %s\n", util_get_scoreboard(), strerror(errno));
+      fprintf(stderr, "(Perhaps you need to specify the ScoreboardFile with -f, or change\n");
+      fprintf(stderr," the compile-time default directory?)\n");
+      exit(1);
+    }
+  }
+
+  count = 0;
+  if ((res = util_open_scoreboard(O_RDONLY, &mpid)) < 0) {
+    switch (res) {
+      case -1:
+        fprintf(stderr, "unable to open scoreboard: %s\n", strerror(errno));
+        return 1;
+
+      case UTIL_SCORE_ERR_BAD_MAGIC:
+        fprintf(stderr, "scoreboard is corrupted or old\n");
+        return 1;
+
+      case UTIL_SCORE_ERR_OLDER_VERSION:
+        fprintf(stderr, "scoreboard version is too old\n");
+        return 1;
+
+      case UTIL_SCORE_ERR_NEWER_VERSION:
+        fprintf(stderr, "scoreboard version is too new\n");
+        return 1;
+    }
+  }
+
+  if (!mpid)
+    printf("inetd FTP daemon:\n");
+
+  else
+    printf("standalone FTP daemon [%d]:\n",(int) mpid);
+
+  while ((score = util_scoreboard_read_entry()) != NULL) {
+    unsigned char uploading = FALSE;
+    register unsigned int i = 0;
+
+    if (!count++) {
+      if (total)
+        printf("   -  %d user%s\n\n", total, total > 1 ? "s" : "");
+
+      total = 0;
+    }
+
+    /* Tally up per-Class counters. */
+    for (i = 0; i != MAX_CLASSES; i++) {
+      if (classes[i].score_class == 0) {
+        classes[i].score_class = strdup(score->sce_class);
+        classes[i].score_count++;
+        break;
+      }
+
+      if (strcasecmp(classes[i].score_class, score->sce_class) == 0) {
+        classes[i].score_count++;
+        break;
+      }
+    }
+
+    total++;
+
+    if (strncmp(score->sce_cmd, "STOR", 4) == 0 ||
+        strncmp(score->sce_cmd, "STOU", 4) == 0 ||
+        strncmp(score->sce_cmd, "APPE", 4) == 0)
+      uploading = TRUE;
+
+    if (outform & OF_COMPAT) {
+      if (score->sce_xfer_size) {
+        if (uploading)
+          printf("%5d %-6s (n/a) %s\n", (int) score->sce_pid,
+            show_time(&score->sce_begin_idle), score->sce_cmd);
+
+        else
+          printf("%5d %-6s (%s%%) %s\n", (int) score->sce_pid,
+            show_time(&score->sce_begin_idle),
+            percent_complete(score->sce_xfer_size, score->sce_xfer_done),
+            score->sce_cmd);
+
+      } else
+        printf("%5d %-6s %s\n", (int) score->sce_pid,
+          show_time(&score->sce_begin_idle), score->sce_cmd);
+
+      if (verbose) {
+        if (score->sce_client_addr[0])
+          printf("             (host: %s [%s])\n", score->sce_client_name,
+            score->sce_client_addr);
+        if (score->sce_cwd[0])
+          printf("              (cwd: %s)\n", score->sce_cwd);
+        if (score->sce_class[0])
+          printf("               (class: %s)\n", score->sce_class);
+      }
+
+      continue;
+    }
+
+    /* Has the client authenticated yet, or not? */
+    if (strcmp(score->sce_user, "(none)")) {
+
+      /* Is the client idle? */
+      if (!strcmp(score->sce_cmd, "(idle)")) {
+
+        /* These printf() calls needs to be split up, as show_time() returns
+         * a pointer to a static buffer, and pushing two invocations onto
+         * the stack means that the times thus formatted will be incorrect.
+         */
+        printf("%5d %-8s [%6s] ", (int) score->sce_pid,
+          score->sce_user, show_time(&score->sce_begin_session));
+        printf("%6s %s", show_time(&score->sce_begin_idle), score->sce_cmd);
+
+        if (verbose && !(outform & OF_ONELINE))
+          printf("\n");
+
+      } else {
+        if (uploading)
+          printf("%5d %-8s [%6s] (n/a) %s", (int) score->sce_pid,
+            score->sce_user, show_time(&score->sce_begin_session),
+            score->sce_cmd);
+
+        else
+          printf("%5d %-8s [%6s] (%3s%%) %s", (int) score->sce_pid,
+            score->sce_user, show_time(&score->sce_begin_session),
+            percent_complete(score->sce_xfer_size, score->sce_xfer_done),
+            score->sce_cmd);
+
+        if (verbose) {
+          printf("%sKB/s: %3.2f%s",
+            (outform & OF_ONELINE) ? " " : "\n\t",
+            (score->sce_xfer_len / 1024.0) /
+              (score->sce_xfer_elapsed / 1000),
+            (outform & OF_ONELINE) ? "" : "\n");
+        }
+      }
+
+      /* Display additional information, if requested. */
+      if (verbose) {
+        if (score->sce_client_addr[0])
+          printf("%sclient: %s [%s]%s",
+            (outform & OF_ONELINE) ? " " : "\t",
+            score->sce_client_name, score->sce_client_addr,
+            (outform & OF_ONELINE) ? "" : "\n");
+
+        if (score->sce_server_addr[0])
+          printf("%sserver: %s (%s)%s",
+            (outform & OF_ONELINE) ? " " : "\t",
+            score->sce_server_addr, score->sce_server_label,
+            (outform & OF_ONELINE) ? "" : "\n");
+
+        if (score->sce_cwd[0])
+          printf("%slocation: %s%s",
+            (outform & OF_ONELINE) ? " " : "\t",
+            score->sce_cwd,
+            (outform & OF_ONELINE) ? "" : "\n");
+
+        if (score->sce_class[0])
+          printf("%sclass: %s",
+            (outform & OF_ONELINE) ? " " : "\t",
+            score->sce_class);
+
+        printf("%s", "\n");
+
+      } else
+        printf("%s", "\n");
+
+    } else {
+
+      printf("%5d %-8s [%6s] (authenticating)", (int) score->sce_pid,
+        score->sce_user, show_time(&score->sce_begin_session));
+
+      /* Display additional information, if requested. */
+      if (verbose) {
+        if (score->sce_client_addr[0])
+          printf("%sclient: %s [%s]%s",
+            (outform & OF_ONELINE) ? " " : "\n\t",
+            score->sce_client_name, score->sce_client_addr,
+            (outform & OF_ONELINE) ? "" : "\n");
+
+        if (score->sce_server_addr[0])
+          printf("%sserver: %s (%s)%s",
+            (outform & OF_ONELINE) ? " " : "\t",
+            score->sce_server_addr, score->sce_server_label,
+            (outform & OF_ONELINE) ? "" : "\n");
+
+        if (score->sce_class[0])
+          printf("%sclass: %s",
+            (outform & OF_ONELINE) ? " " : "\t",
+            score->sce_class);
+      }
+
+      printf("%s", "\n");
+    }
+  }
+  util_close_scoreboard();
+
+  if (total) {
+    register unsigned int i = 0;
+
+    for (i = 0; i != MAX_CLASSES; i++) {
+      if (classes[i].score_class == 0)
+         break;
+
+       printf("Service class %-20s - %3lu user%s\n", classes[i].score_class,
+         classes[i].score_count, classes[i].score_count > 1 ? "s" : "");
+    }
+
+  } else {
+    printf("no users connected\n");
+  }
+
+  return 0;
+}
