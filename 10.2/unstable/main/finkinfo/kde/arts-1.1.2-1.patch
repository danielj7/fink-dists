
--- configure.in.in	6 May 2003 16:58:33 -0000	1.1.1.8
+++ configure.in.in	6 May 2003 17:00:12 -0000	1.25
@@ -57,7 +57,7 @@
 KDE_CHECK_STL
 AC_HEADER_DIRENT
 AC_HEADER_STDC
-AC_CHECK_HEADERS(fcntl.h sys/time.h unistd.h sys/cdefs.h fnmatch.h sysent.h strings.h sys/stat.h sys/select.h sys/socket.h linux/socket.h socketbits.h sigaction.h paths.h malloc.h monetary.h sys/param.h limits.h sys/mnttab.h mntent.h fstab.h sys/soundcard.h fam.h)
+AC_CHECK_HEADERS(fcntl.h sys/time.h unistd.h sys/cdefs.h fnmatch.h sysent.h strings.h sys/stat.h sys/select.h sys/socket.h linux/socket.h socketbits.h sigaction.h paths.h malloc.h monetary.h sys/param.h limits.h sys/mnttab.h mntent.h fstab.h sys/soundcard.h sys/syscall.h fam.h)
 
 dnl Checks for libraries.
 AC_BASE_PATH_KDE([don't test]) dnl arts is a special case
@@ -183,6 +183,35 @@
   LDFLAGS="$ac_ldflags_save"
 ])
 
+dnl Check for libesd (for EsounD support)
+AC_DEFUN([AC_CHECK_LIBESD],
+[
+  ac_ldflags_save="$LDFLAGS"
+  ac_CPPFLAGS_save="$CPPFLAGS"
+  LDFLAGS="$all_libraries $LDFLAGS"
+  CPPFLAGS="$CPPFLAGS $all_includes"
+
+  AC_LANG_SAVE
+  AC_LANG_C
+  arts_libaudionas_include=no
+  AC_CHECK_HEADER(esd.h,
+  [
+    arts_libesd_include=yes
+  ])
+  if test "x$arts_libesd_include" = "xyes"; then
+    AC_CHECK_LIB(esd,esd_open_sound,[
+     dnl LDFLAGS in case it's in KDEDIR/lib
+     LIBESD="$LDFLAGS -lesd"
+     AC_DEFINE(HAVE_LIBESD, 1,
+        [Define if you have libesd (required if you want EsounD support)])
+   ])
+  fi
+  AC_SUBST(LIBESD)
+  AC_LANG_RESTORE
+  CPPFLAGS="$ac_CPPFLAGS_save"
+  LDFLAGS="$ac_ldflags_save"
+])
+
 dnl libaudiofile is used for loading wave files
 AC_DEFUN([AC_CHECK_LIBAUDIOFILE],
 [
@@ -283,6 +312,19 @@
 fi
 ])
 
+dnl needed for mach realtime scheduling
+AC_DEFUN([AC_CHECK_MACH_REALTIME_SCHED],
+[
+  AC_CHECK_HEADERS([mach/mach.h mach/thread_policy.h sys/param.h sys/sysctl.h],
+    [AC_CHECK_FUNCS(thread_policy_set,
+      arts_mach_realtime_sched=yes,
+      arts_mach_realtime_sched=no)]
+  )
+  if test "x$arts_mach_realtime_sched" = "xyes"; then
+    AC_DEFINE(HAVE_MACH_REALTIME_SCHED,1, [Define if your system supports mach realtime scheduling])
+  fi
+])
+
 dnl Type of the ioctl function test - after some tries, it seems that this
 dnl not required for Linux vs. FreeBSD (for which this test was written), and
 dnl that only the Linux documentation claims that it has an "int" as second
@@ -430,9 +472,11 @@
 dnl call the tests
 AC_CHECK_LIBAUDIOIO
 AC_CHECK_LIBAUDIONAS
+AC_CHECK_LIBESD
 AC_CHECK_LIBAUDIOFILE
 AC_CHECK_SGILIBAUDIO
 AC_CHECK_REALTIME_SCHED
+AC_CHECK_MACH_REALTIME_SCHED
 AC_CHECK_GETDOMAINNAME
 AC_CHECK_IOCTL_TYPE
 AC_CHECK_X86_FLOAT_INT
@@ -605,6 +649,27 @@
 AC_CHECK_HEADERS(soundcard.h)
 AC_CHECK_LIB(ossaudio, _oss_ioctl, [LIBOSSAUDIO="-lossaudio"])
 AC_SUBST(LIBOSSAUDIO)
+
+dnl MacOSX has a similar library called liboss
+dnl AC_MSG_CHECKING([for liboss])
+dnl 
+dnl LIBOSS_CFLAGS=
+dnl LIBOSS_LIBADD=
+dnl LIBOSS_LDFLAGS=
+dnl 
+dnl if test "x$PKG_CONFIG" != "xno" && test x`$PKG_CONFIG --modversion liboss 2>/dev/null` != x; then
+dnl   LIBOSS_CFLAGS=""
+dnl   LIBOSS_LIBADD="`$PKG_CONFIG --libs-only-l liboss`"
+dnl   LIBOSS_LDFLAGS="`$PKG_CONFIG --libs-only-L liboss`"
+dnl   AC_DEFINE(HAVE_LIBOSS,1,[Define if you have the liboss compatibility library])
+dnl   AC_MSG_RESULT(yes)
+dnl else
+dnl   AC_MSG_RESULT(not installed)
+dnl fi
+dnl 
+dnl AC_SUBST(LIBOSS_CFLAGS)
+dnl AC_SUBST(LIBOSS_LIBADD)
+dnl AC_SUBST(LIBOSS_LDFLAGS)
 
 dnl Don't remove !
 dnl AC_OUTPUT(artsc/artsc-config)
--- artsc/Makefile.am	14 Aug 2002 13:21:23 -0000	1.1.1.3
+++ artsc/Makefile.am	11 Mar 2003 06:13:09 -0000	1.11
@@ -9,19 +9,19 @@
 bin_SCRIPTS = artsc-config artsdsp
 
 libartsdsp_la_SOURCES = artsdsp.c
-libartsdsp_la_LDFLAGS = -no-undefined -module
+libartsdsp_la_LDFLAGS = -no-undefined -avoid-version
 libartsdsp_la_LIBADD = libartsc.la
 
 libartsdsp_st_la_SOURCES = artsc.c artsdsp.c
-libartsdsp_st_la_LDFLAGS = -no-undefined -module
+libartsdsp_st_la_LDFLAGS = -no-undefined -avoid-version
 libartsdsp_st_la_LIBADD = $(top_builddir)/libltdl/libltdlc.la
 
 libartsc_la_SOURCES = artsc.c
-libartsc_la_LDFLAGS = -no-undefined
+libartsc_la_LDFLAGS = -no-undefined -version-info 2:0:1
 libartsc_la_LIBADD = $(top_builddir)/libltdl/libltdlc.la $(LIBPTHREAD) $(USE_THREADS)
 
 libartscbackend_la_SOURCES = artscbackend.cc
-libartscbackend_la_LDFLAGS = -no-undefined -module $(KDE_RPATH)
+libartscbackend_la_LDFLAGS = -no-undefined -module $(KDE_RPATH) -avoid-version
 libartscbackend_la_LIBADD = $(FLOWLIBS) \
     $(top_builddir)/soundserver/libsoundserver_idl.la
 
--- artsc/artsc-config.in	25 Jun 2002 01:45:58 -0000	1.1.1.1
+++ artsc/artsc-config.in	26 Nov 2002 21:00:47 -0000	1.2
@@ -27,7 +27,7 @@
 do
   case $1 in
     --libs)
-	  flags="$flags -L$libdir $libdl -lartsc @USE_THREADS@ @LIBPTHREAD@"
+	  flags="$flags -L$libdir $libdl -lartsc @USE_THREADS@ @LIBPTHREAD@ @FRAMEWORK_COREAUDIO@"
 	  ;;
     --cflags)
 	  flags="$flags -I$includedir/artsc"
--- artsc/artsdsp.c	13 Mar 2003 02:11:05 -0000	1.1.1.3
+++ artsc/artsdsp.c	13 Mar 2003 02:12:42 -0000	1.3
@@ -3,6 +3,8 @@
  *
  * Copyright (C) 1998 Manish Singh <yosh@gimp.org>
  * Copyright (C) 2000 Stefan Westerfeld <stefan@space.twc.de> (aRts port)
+ * Port to Darwin and speedups by Alexander Strange <astrange@ithinksw.com>
+ * based on work by the LibOSS team <liboss-devel@lists.sourceforge.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -26,6 +28,10 @@
 #include <config.h>
 #endif
 
+#ifdef HAVE_SYS_SYSCALL_H
+#include <sys/syscall.h>
+#endif
+
 #ifdef HAVE_SYS_SOUNDCARD_H
 #include <stdlib.h>
 #include <stdio.h>
@@ -90,14 +96,17 @@
 /*
  * original C library functions
  */
-typedef int (*orig_open_ptr)(const char *pathname, int flags, ...);
+#ifndef HAVE_SYS_SYSCALL_H
+typedef int (*orig_open_ptr)(const char *pathname, int flags, int mode);
 typedef int (*orig_close_ptr)(int fd);
 typedef int (*orig_ioctl_ptr)(int fd, ioctl_request_t request, ...);
 typedef ssize_t (*orig_write_ptr)(int fd, const void *buf, size_t count);
 typedef void* (*orig_mmap_ptr)(void *start, size_t length, int prot,
                                  int flags, int fd, off_t offset);
 typedef int (*orig_munmap_ptr)(void *start, size_t length);
+#ifdef HAVE_ARTSDSP_STDIO_EMU
 typedef FILE* (*orig_fopen_ptr)(const char *path, const char *mode);
+#endif
 typedef int (*orig_access_ptr)(const char *pathname, int mode);   
 
 static orig_open_ptr orig_open;
@@ -106,8 +115,23 @@
 static orig_write_ptr orig_write;
 static orig_mmap_ptr orig_mmap;
 static orig_munmap_ptr orig_munmap;
+#ifdef HAVE_ARTSDSP_STDIO_EMU
 static orig_fopen_ptr orig_fopen;
+#endif
 static orig_access_ptr orig_access;
+#else
+static int orig_open(const char *pathname, int flags, int mode) { return syscall(SYS_open,pathname,flags,mode); }
+static int orig_close(int fd) { return syscall(SYS_close,fd); }
+static int orig_ioctl(int fd, ioctl_request_t request, void *ptr) { return syscall(SYS_ioctl,fd,request,ptr); }
+static ssize_t orig_write(int fd,const void *buf,size_t count) { return syscall(SYS_write,fd,buf,count); }
+static void *orig_mmap(void *start,size_t len,int prot,int flags,int fd,off_t off) { return syscall(SYS_mmap,start,len,prot,flags,fd,off); }
+static int orig_munmap(void *start,size_t len) { return syscall(SYS_munmap,start,len); }
+static int orig_access(const char *pathname,int mode) { return syscall(SYS_access,pathname,mode); }
+#ifdef HAVE_ARTSDSP_STDIO_EMU
+typedef FILE* (*orig_fopen_ptr)(const char *path, const char *mode);
+static orig_fopen_ptr orig_fopen;
+#endif
+#endif
 
 static int artsdsp_debug = 0;
 static int artsdsp_init = 0;
@@ -139,14 +163,18 @@
 	mmapemu = env && !strcmp(env,"1");
 
 	/* resolve original symbols */
+#ifndef HAVE_SYS_SYSCALL_H
 	orig_open = (orig_open_ptr)dlsym(RTLD_NEXT,"open");
 	orig_close = (orig_close_ptr)dlsym(RTLD_NEXT,"close");
 	orig_write = (orig_write_ptr)dlsym(RTLD_NEXT,"write");
 	orig_ioctl = (orig_ioctl_ptr)dlsym(RTLD_NEXT,"ioctl");
 	orig_mmap = (orig_mmap_ptr)dlsym(RTLD_NEXT,"mmap");
 	orig_munmap = (orig_munmap_ptr)dlsym(RTLD_NEXT,"munmap");
-	orig_fopen = (orig_fopen_ptr)dlsym(RTLD_NEXT,"fopen");
 	orig_access = (orig_access_ptr)dlsym(RTLD_NEXT,"access");
+#endif
+#ifdef HAVE_ARTSDSP_STDIO_EMU
+        orig_fopen = (orig_fopen_ptr)dlsym(RTLD_NEXT,"fopen");
+#endif
 }
 
 static void artsdspdebug(const char *fmt,...)
--- artsc/artsdsp.in	25 Jun 2002 01:45:58 -0000	1.1.1.1
+++ artsc/artsdsp.in	11 Mar 2003 06:13:09 -0000	1.3
@@ -96,13 +96,16 @@
 
 if test "$single_thread" = 1; then
   LD_PRELOAD=${libdir}/libartsdsp_st.so.0
+  DYLD_INSERT_LIBRARIES=${libdir}/libartsdsp_st.dylib
 else
   LD_PRELOAD=${libdir}/libartsdsp.so.0:${libdir}/libartsc.so.0
+  DYLD_INSERT_LIBRARIES=${libdir}/libartsdsp.dylib
 fi
 if test -f /lib/libdl.so.2; then
   LD_PRELOAD=$LD_PRELOAD:/lib/libdl.so.2
 fi
 export LD_PRELOAD
+export DYLD_INSERT_LIBRARIES
 
 # invoke the program with the args given
 exec "$@"
--- flow/Makefile.am	1 Oct 2002 01:48:02 -0000	1.1.1.3
+++ flow/Makefile.am	28 Mar 2003 00:30:43 -0000	1.18
@@ -1,3 +1,5 @@
+AM_CFLAGS = -DGSL_WANT_GLIB_WRAPPER -DGSL_WANT_ARTS_THREADS
+AM_CXXFLAGS = -DGSL_WANT_GLIB_WRAPPER -DGSL_WANT_ARTS_THREADS
 
 SUBDIRS = mcopclass gsl gslpp
 INCLUDES = -I$(top_srcdir)/mcop $(all_includes)
@@ -10,9 +12,9 @@
 libartsflow_idl_la_LDFLAGS = -no-undefined -version-info 1:0
 libartsflow_idl_la_LIBADD = $(top_builddir)/mcop/libmcop.la $(LIBPOSIX4)
 
-libartsflow_la_LIBADD = $(top_builddir)/mcop/libmcop.la libartsflow_idl.la $(top_builddir)/flow/gslpp/libgslpp.la $(LIBAUDIOFILE) $(LIBASOUND) $(LIBAUDIOIO) $(LIBOSSAUDIO) $(LIBAUDIONAS) $(LIBCSL) $(SGILIBAUDIO) -lm \
-  $(top_builddir)/flow/gsl/libgsl.la
-libartsflow_la_LDFLAGS = -no-undefined -version-info 1:0
+libartsflow_la_LIBADD = $(top_builddir)/mcop/libmcop.la libartsflow_idl.la $(top_builddir)/flow/gslpp/libgslpp.la $(LIBAUDIOFILE) $(LIBASOUND) $(LIBAUDIOIO) $(LIBOSSAUDIO) $(LIBAUDIONAS) $(LIBCSL) $(SGILIBAUDIO) $(LIBESD) -lm \
+ $(top_builddir)/flow/gsl/libgsl.la
+libartsflow_la_LDFLAGS = -no-undefined -version-info 1:0 $(FRAMEWORK_COREAUDIO)
 libartsflow_la_COMPILE_FIRST = artsflow.h
 libartsflow_la_SOURCES =  synth_play_impl.cc \
   synthschedule.cc gslschedule.cc audiosubsys.cc \
@@ -23,10 +25,10 @@
   stereoeffectstack_impl.cc fft.c stereofftscope_impl.cc virtualports.cc \
   bus.cc audiomanager_impl.cc synth_record_impl.cc resample.cc \
   audioio.cc audioiooss.cc audioioalsa.cc audioioalsa9.cc \
-  audioionull.cc audioiolibaudioio.cc \
+  audioionull.cc audioiolibaudioio.cc audioioesd.cc \
   audioiosun.cc audioioaix.cc audioionas.cc cpuinfo.cc \
   audioioossthreaded.cc audiotobytestream_impl.cc audioiosgi.cc \
-  audioiocsl.cc datahandle_impl.cc
+  audioiocsl.cc audioiocoreaudio.cc datahandle_impl.cc
 
 artsincludedir = $(includedir)/arts
 artsinclude_HEADERS = artsflow.h audiosubsys.h cache.h \
RCS file: flow/audioiocoreaudio.cc
diff -N flow/audioiocoreaudio.cc
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ flow/audioiocoreaudio.cc	2 Mar 2003 22:31:53 -0000	1.12
@@ -0,0 +1,689 @@
+    /*
+    
+    Copyright (C) 2001 Stefan Westerfeld
+                        stefan@space.twc.de
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+    
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+    Boston, MA 02111-1307, USA.
+    
+    */
+    /*
+        Modifications for ARTS -    
+        Ben Hines <bhines@alumni.ucsd.edu>
+        Ben Reed  <ranger@befunk.com>
+        
+        Some CoreAudio code borrowed from ESD -
+        Shawn Hsiao <phsiao@mac.com>
+        Masanori Sekino <m-sekino@mb.kcom.ne.jp>
+    */
+
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef HAVE_COREAUDIO
+
+#define DEBUG 1
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <sys/socket.h>
+#include <sys/file.h>
+
+/* for useful debugging macros */
+#include <mach/error.h>
+
+#include <CoreAudio/CoreAudio.h>
+
+#include "debug.h"
+#include "audioio.h"
+#include "audiosubsys.h"
+
+#define NAME_LEN 256		/* max length of a device name */
+#define BUF_SIZE (4 * 1024)  /* from ESD */
+
+#define driverVersion "0.01 alpha"
+
+#ifdef BIG_ENDIAN
+#define defaultFormat 17
+#else
+#define defaultFormat 16
+#endif
+  
+bool NotifyOnError (OSStatus inRetVal, const char * inStringDesc);
+
+struct audio_queue {
+    float dataBuf[BUF_SIZE];
+    pthread_mutex_t mutex;
+    pthread_cond_t condition;
+    int numSamples;
+};
+
+static OSStatus PlaybackIOProc(AudioDeviceID inDevice,
+			const AudioTimeStamp *inNow,
+			const AudioBufferList *inInputData,
+			const AudioTimeStamp *inInputTime,
+			AudioBufferList *outOutputData,
+			const AudioTimeStamp *inOutputTime,
+			audio_queue *inClientData);
+
+static OSStatus RecordIOProc(AudioDeviceID inDevice,
+		      const AudioTimeStamp *inNow,
+		      const AudioBufferList *inInputData,
+		      const AudioTimeStamp *inInputTime,
+		      AudioBufferList *outOutputData,
+		      const AudioTimeStamp *inOutputTime,
+		      audio_queue *inClientData);
+                      
+OSStatus PropertyListenerProc(AudioHardwarePropertyID	inPropertyID,
+                      void* inClientData);
+
+namespace Arts {
+
+class AudioIOCoreAudio : public AudioIO {
+
+protected:
+     /* From ESD */
+     AudioDeviceID gOutputDeviceID, gInputDeviceID;
+    
+     audio_queue input;
+     audio_queue output;    
+    
+     int audioPlaybackStarted, audioRecordStarted;
+     int coreaudio_has_output_device;
+     int coreaudio_has_input_device;
+     int coreaudio_init;
+     
+     /* Arts Specific */
+     int audio_fd;
+     int bytesPerSec;
+     timeval start;
+        
+public:
+	AudioIOCoreAudio();
+	bool supportsFormat(AudioDeviceID device, AudioStreamBasicDescription *format);
+	void setParam(AudioParam param, int& value);
+	int getParam(AudioParam param);
+
+	bool open();
+	void close();
+	int read(void *buffer, int size);
+	int write(void *buffer, int size);
+
+};
+
+REGISTER_AUDIO_IO(AudioIOCoreAudio, "coreaudio", "Apple CoreAudio");
+}; // end namespace Arts
+
+using namespace std;
+using namespace Arts;
+             
+AudioIOCoreAudio::AudioIOCoreAudio() {
+        
+        artsdebug("CoreAudio driver version %s", driverVersion);
+        /*
+         * default parameters
+         */
+        param(samplingRate) = 44100;
+        paramStr(deviceName) = "default";
+        param(fragmentSize) = 1024;
+        param(fragmentCount) = 7;
+        param(channels) = 2;
+        param(direction) = 2;
+        param(format) = defaultFormat;
+        
+        input.numSamples = output.numSamples = 0;
+    
+        audioPlaybackStarted = 0, audioRecordStarted = 0;
+        coreaudio_has_output_device = 0;
+        coreaudio_has_input_device = 0;
+        coreaudio_init = 0;
+}
+
+void
+AudioIOCoreAudio::close()
+{   
+    artsdebug("AudioIOCoreAudio::close().. ");
+    /* deactivate both of them */
+    if (coreaudio_has_output_device) {
+        if(audioPlaybackStarted)
+        NotifyOnError(AudioDeviceStop(gOutputDeviceID, 
+                  (AudioDeviceIOProc) PlaybackIOProc),
+                        "AudioDeviceStop (PlaybackIOProc)");
+                        
+        NotifyOnError(AudioDeviceRemoveIOProc(gOutputDeviceID,
+                  (AudioDeviceIOProc) PlaybackIOProc),
+                        "AudioDeviceRemoveIOProc (PlaybackIOProc)");
+                            
+        NotifyOnError(AudioHardwareRemovePropertyListener(
+            kAudioHardwarePropertyDefaultOutputDevice, 
+            PropertyListenerProc),
+                "AudioHardwareRemovePropertyListener (PropertyListenerProc)");
+                        
+        artsdebug(" ... closing output\n");
+        audioPlaybackStarted = 0;
+        coreaudio_has_output_device = 0;
+    }
+    
+    if (coreaudio_has_input_device) {        
+        if(audioRecordStarted)
+        NotifyOnError(AudioDeviceStop(gInputDeviceID, 
+                            (AudioDeviceIOProc) RecordIOProc),
+                        "AudioDeviceStop (RecordIOProc)");
+                        
+        NotifyOnError(AudioDeviceRemoveIOProc(gInputDeviceID,
+                            (AudioDeviceIOProc) RecordIOProc),
+                        "AudioDeviceRemoveIOProc (RecordIOProc)");
+                            
+        NotifyOnError(AudioHardwareRemovePropertyListener(
+            kAudioHardwarePropertyDefaultOutputDevice, 
+            PropertyListenerProc),
+                "AudioHardwareRemovePropertyListener (PropertyListenerProc)");
+                        
+        artsdebug(" ... closing intput\n");
+        audioRecordStarted = 0;
+        coreaudio_has_input_device = 0;
+    }
+}
+
+ 
+int 
+AudioIOCoreAudio::write(void *buffer, int buf_size) {
+
+  float scale = 1.0 / SHRT_MAX;
+  int remain_to_write = buf_size;
+
+  if (!coreaudio_has_output_device)
+  {
+    arts_warning("AudioIOCoreAudio::write with no output device!");
+    return -1;
+  }
+  if (!audioPlaybackStarted) {
+    NotifyOnError(AudioDeviceStart(gOutputDeviceID,(AudioDeviceIOProc)  PlaybackIOProc),
+                    "AudioDeviceStart (PlaybackIOProc)");
+    audioPlaybackStarted = 1;
+  }
+
+  while (remain_to_write)
+  {
+    pthread_mutex_lock(&output.mutex);
+
+    while(output.numSamples == BUF_SIZE)
+      pthread_cond_wait(&output.condition, &output.mutex);
+
+    {
+      short *src_data = (short *)buffer + (buf_size - remain_to_write) / sizeof(short);
+      float *dst_data = output.dataBuf + output.numSamples;
+      int src_samples = remain_to_write / sizeof(short);
+      int dst_samples = BUF_SIZE - output.numSamples;
+      int n = (dst_samples < src_samples) ? dst_samples : src_samples;
+      int i;
+
+      for (i = 0; i < n; i++)
+        dst_data[i] = scale * src_data[i];
+
+      output.numSamples += n;
+      remain_to_write -= n * sizeof(short);
+    }
+
+    pthread_mutex_unlock(&output.mutex);
+  }
+
+  return (buf_size);
+
+}
+
+int AudioIOCoreAudio::read(void *buffer, int buf_size) {
+  float scale = SHRT_MAX;
+  int remain_to_read = buf_size;
+
+  if (!coreaudio_has_input_device)
+  {
+    arts_warning("AudioIOCoreAudio::read with no input device!");
+    return -1;
+  }
+
+  if (!audioRecordStarted) {
+    NotifyOnError(AudioDeviceStart(gInputDeviceID,(AudioDeviceIOProc)  RecordIOProc),
+                    "AudioDeviceStart (RecordIOProc)");
+    audioRecordStarted = 1;
+  }
+
+  while (remain_to_read)
+  {
+    pthread_mutex_lock(&input.mutex);
+
+    while(input.numSamples == BUF_SIZE)
+      pthread_cond_wait(&input.condition, &input.mutex);
+
+    {
+      float *src_data = input.dataBuf + input.numSamples;
+      short *dst_data = (short *)buffer + (buf_size - remain_to_read) / sizeof(short);
+      int src_samples = BUF_SIZE - input.numSamples;
+      int dst_samples = remain_to_read / sizeof(short);
+      int n = (dst_samples < src_samples) ? dst_samples : src_samples;
+      int i;
+
+      for (i = 0; i < n; i++)
+        dst_data[i] = (short)(scale * src_data[i]);
+
+      input.numSamples += n;
+      remain_to_read -= n * sizeof(short);
+    }
+
+    pthread_mutex_unlock(&input.mutex);
+  }
+
+  return (buf_size);
+
+}
+
+
+bool
+AudioIOCoreAudio::open()
+{
+        #define LEN_DEVICE_NAME 128
+        UInt32 propertySize, bufferByteCount;
+        char deviceName[LEN_DEVICE_NAME];
+        char fdName[LEN_DEVICE_NAME + 50];
+        struct AudioStreamBasicDescription streamDesc;
+
+        /***** Arts Specific ***/
+	arts_warning("info: requesting %d, %d channel sound at %d hz\n",
+            param(direction), param(channels), param(samplingRate));
+
+        bytesPerSec = param(channels) * 2 * param(samplingRate);
+        gettimeofday(&start,0);
+	if (param(direction) & directionWrite) {
+            if(coreaudio_has_output_device)
+            {
+                arts_warning("yes.. AudioIOCoreAudio::open() called twice for writing!");
+                return true;
+            }
+                
+            /* HACK - create the file descriptor?  */
+            sprintf(fdName, "/tmp/audioiocoreaudio");
+            fopen(fdName, "w+");
+            audio_fd = ::open(fdName,  O_RDWR | O_NDELAY, 0);
+            /* Obtain a file descriptor for our "listening" socket */
+            if(audio_fd == -1)
+            {
+                arts_warning("file descriptor can't be created, %s\n", strerror(errno));
+                return false;
+            }
+            /***** End Arts Specific ***/
+            /*  Stuff from ESD... */
+            /********************** playback section ***************************/
+            /* get default output device */
+            propertySize = sizeof(gOutputDeviceID);
+            NotifyOnError(AudioHardwareGetProperty(kAudioHardwarePropertyDefaultOutputDevice,
+                                                &propertySize,
+                                                &gOutputDeviceID),
+                        "AudioHardwareGetProperty (Default Output Device)");
+            
+            arts_assert(gOutputDeviceID != kAudioDeviceUnknown);
+            
+            /* got default output device */
+            coreaudio_has_output_device = 1;
+        
+            /* get output device name */
+            propertySize = sizeof(char)*LEN_DEVICE_NAME;
+            NotifyOnError(AudioDeviceGetProperty(gOutputDeviceID,
+                                            1,
+                                            0,
+                                            kAudioDevicePropertyDeviceName,
+                                            &propertySize,
+                                            deviceName),
+                            "AudioDeviceGetProperty (Output Device Name)");
+        
+            /* get output format */
+            propertySize = sizeof(struct AudioStreamBasicDescription);
+            NotifyOnError(AudioDeviceGetProperty(gOutputDeviceID,
+                                            1,
+                                            0,
+                                            kAudioDevicePropertyStreamFormat,
+                                            &propertySize,
+                                            &streamDesc),
+                        "AudioDeviceGetProperty (Output StreamFormat)");
+                        
+            if ((streamDesc.mSampleRate != 44100.0) ||
+                (streamDesc.mFormatID != kAudioFormatLinearPCM) ||
+               !(streamDesc.mFormatFlags & kLinearPCMFormatFlagIsFloat) ||
+                (streamDesc.mChannelsPerFrame != 2))
+            {
+            	arts_warning("Unsupported output device format!\n");
+                return (-2);
+            }
+        
+            /* set buffer size */
+            bufferByteCount = BUF_SIZE * sizeof(float);
+            propertySize = sizeof(bufferByteCount);
+            NotifyOnError(AudioDeviceSetProperty(gOutputDeviceID,
+                                            0,
+                                            0,
+                                            0,
+                                            kAudioDevicePropertyBufferSize,
+                                            propertySize,
+                                            &bufferByteCount),
+                        "AudioDeviceSetProperty (Output BufferSize)");
+    
+            artsdebug("using device %s for output:\n", deviceName);
+            artsdebug("\twith sample rate %f, %ld channels and %ld-bit sample\n",
+                    streamDesc.mSampleRate,
+                    streamDesc.mChannelsPerFrame,
+                    streamDesc.mBitsPerChannel);
+        
+            arts_return_val_if_fail(pthread_mutex_init(&output.mutex, NULL) == 0, -1);
+            arts_return_val_if_fail(pthread_cond_init(&output.condition, NULL) == 0, -1);
+            
+            /* Registers PlaybackIOProc with the device without activating it. */
+            NotifyOnError(AudioDeviceAddIOProc(gOutputDeviceID, 
+                            (AudioDeviceIOProc) PlaybackIOProc, 
+                                                (void *)&output),
+                            "AudioDeviceAddIOProc (PlaybackIOProc)");
+                            
+            NotifyOnError(AudioHardwareAddPropertyListener(
+                kAudioHardwarePropertyDefaultOutputDevice, 
+                PropertyListenerProc, this),
+                 "AudioHardwareAddPropertyListener (PropertyListenerProc)");
+                
+	}
+
+        if (param(direction) & directionRead) {
+            /********************** record section ***************************/
+            if(coreaudio_has_input_device)
+            {
+                arts_warning("AudioIOCoreAudio::open() called twice for reading!");
+                return true;
+            }
+                
+            /* get default input device */
+            propertySize = sizeof(gInputDeviceID);
+            NotifyOnError(AudioHardwareGetProperty(kAudioHardwarePropertyDefaultInputDevice,
+                                                &propertySize,
+                                                &gInputDeviceID),
+                          "AudioHardwareGetProperty (Default Input Device)");
+
+            arts_assert(gInputDeviceID != kAudioDeviceUnknown);         
+            
+            /* got default input device */
+            coreaudio_has_input_device = 1;
+        
+            /* get input device name */
+            propertySize = sizeof(char)*64;
+            NotifyOnError(AudioDeviceGetProperty(gInputDeviceID,
+                                            1,
+                                            1,
+                                            kAudioDevicePropertyDeviceName,
+                                            &propertySize,
+                                            deviceName),
+                        "AudioDeviceGetProperty (Input Device Name)");
+
+            /* get input format */
+            propertySize = sizeof(struct AudioStreamBasicDescription);
+            NotifyOnError(AudioDeviceGetProperty(gInputDeviceID,
+                                            1,
+                                            1,
+                                            kAudioDevicePropertyStreamFormat,
+                                            &propertySize,
+                                            &streamDesc),
+                        "AudioDeviceGetProperty (Input Stream Size)");
+        
+            if ((streamDesc.mSampleRate != 44100.0) ||
+                (streamDesc.mFormatID != kAudioFormatLinearPCM) ||
+                !(streamDesc.mFormatFlags & kLinearPCMFormatFlagIsFloat) ||
+                (streamDesc.mChannelsPerFrame != 2))
+            {
+                artsdebug("Unsupported Input Device format.\n");
+                return (-2);
+            }
+        
+            /* set buffer size */
+            bufferByteCount = BUF_SIZE * sizeof(float);
+            propertySize = sizeof(bufferByteCount);
+            NotifyOnError(AudioDeviceSetProperty(gInputDeviceID,
+                                            0,
+                                            0,
+                                            1,
+                                            kAudioDevicePropertyBufferSize,
+                                            propertySize,
+                                            &bufferByteCount),
+                        "AudioDeviceSetProperty (input buffersize)");
+
+            artsdebug("using device %s for input:\n", deviceName);
+            artsdebug("\twith sample rate %f, %ld channels and %ld-bit sample\n",
+                    streamDesc.mSampleRate,
+                    streamDesc.mChannelsPerFrame,
+                    streamDesc.mBitsPerChannel);
+
+            arts_return_val_if_fail(pthread_mutex_init(&input.mutex, NULL) == 0, -1);
+            arts_return_val_if_fail(pthread_cond_init(&input.condition, NULL) == 0, -1);
+        
+            /* Registers PlaybackIOProc with the device without activating it. */
+            NotifyOnError(AudioDeviceAddIOProc(gInputDeviceID, 
+                                (AudioDeviceIOProc) RecordIOProc, 
+                                                (void *)&input),
+                            "AudioDeviceAddIOProc (RecordIOProc)");
+                                                                                        
+            NotifyOnError(AudioHardwareAddPropertyListener(
+                kAudioHardwarePropertyDefaultInputDevice, 
+                PropertyListenerProc, this),
+                 "AudioHardwareAddPropertyListener (PropertyListenerProc)");
+
+	}
+        
+	return true;
+}
+
+void AudioIOCoreAudio::setParam(AudioParam p, int& value) {
+	switch(p)
+	{
+		default:
+			param(p) = value;
+			break;
+	}
+}
+
+int AudioIOCoreAudio::getParam(AudioParam p) {
+	timeval now;
+	double delta;
+	int bytes;
+
+	switch(p)
+	{
+		case canRead:
+		case canWrite:
+			gettimeofday(&now,0);
+			delta = (double)now.tv_sec + (double)now.tv_usec/1000000.0;
+			delta -= (double)start.tv_sec + (double)start.tv_usec/1000000.0;
+			bytes = (int)( (delta * bytesPerSec) -  ((p == canRead)?input.numSamples:output.numSamples));
+               //         printf("%s %d bytes\n", ((p == canRead)?"canRead":"canWrite"), bytes);
+			return bytes;
+			break;
+
+		case autoDetect:
+			return 1;
+			break;
+                        
+		case selectReadFD:
+			return (param(direction) & directionRead)?audio_fd:-1;
+			break;
+
+		case selectWriteFD:
+			return (param(direction) & directionWrite)?audio_fd:-1;
+			break;
+                        
+		default:
+			return param(p);
+			break;
+	}
+}
+
+bool 
+AudioIOCoreAudio::supportsFormat(AudioDeviceID device, 
+                                 AudioStreamBasicDescription *format) {
+
+	UInt32 formatSize;
+	OSStatus err;
+
+	formatSize = sizeof(*format);
+	err = AudioDeviceGetProperty(device, 0, false,
+		kAudioDevicePropertyStreamFormatSupported, &formatSize, format);
+	NotifyOnError(err, "supportsFormat");
+
+	if (err == noErr) {
+		return true;
+	} else {
+		return false;
+	}
+
+}
+
+/* Add __attribute__((unused)) to unused parameters when that gcc bug is fixed for OS X (3.4?)*/
+static OSStatus PlaybackIOProc(AudioDeviceID inDevice,
+			const AudioTimeStamp *inNow,
+			const AudioBufferList *inInputData,
+			const AudioTimeStamp *inInputTime,
+			AudioBufferList *outOutputData,
+			const AudioTimeStamp *inOutputTime,
+			audio_queue *inClientData)
+{
+  float *bufPtr = (float *) outOutputData->mBuffers[0].mData;
+  int i;
+
+  pthread_mutex_lock(&inClientData->mutex);
+
+  for (i = 0; i < inClientData->numSamples; i++)
+    bufPtr[i] = inClientData->dataBuf[i];
+  for ( ; i < BUF_SIZE; i++)
+    bufPtr[i] = 0;
+  inClientData->numSamples = 0;
+
+  pthread_mutex_unlock(&inClientData->mutex);
+  pthread_cond_signal(&inClientData->condition);
+
+  return (kAudioHardwareNoError);
+}
+
+/* Add __attribute__((unused)) to unused parameters when that gcc bug is fixed for OS X (3.4?)*/
+static OSStatus RecordIOProc(AudioDeviceID inDevice,
+		      const AudioTimeStamp *inNow,
+		      const AudioBufferList *inInputData,
+		      const AudioTimeStamp *inInputTime,
+		      AudioBufferList *outOutputData,
+		      const AudioTimeStamp *inOutputTime,
+		      audio_queue *inClientData)
+{
+  float *bufPtr = inInputData->mBuffers[0].mData;
+  int i;
+
+  pthread_mutex_lock(&inClientData->mutex);
+
+  for (i = 0; i < BUF_SIZE; i++)
+    inClientData->dataBuf[i] = bufPtr[i];
+  inClientData->numSamples = 0;
+
+  pthread_mutex_unlock(&inClientData->mutex);
+  pthread_cond_signal(&inClientData->condition);
+
+  return (kAudioHardwareNoError);
+}
+
+OSStatus PropertyListenerProc(AudioHardwarePropertyID	inPropertyID, 
+                                void *	inClientData)
+{
+   UInt32 propertySize = sizeof(AudioDeviceID);
+   AudioDeviceID deviceID;
+   
+   arts_warning("PropertyListenerProc called ... ");
+    
+   switch(inPropertyID)
+   {
+        case kAudioHardwarePropertyDefaultOutputDevice:
+            artsdebug("PropertyListenerProc kAudioHardwarePropertyDefaultOutputDevice:\n");
+            ((AudioIOCoreAudio*)inClientData)->close();
+            ((AudioIOCoreAudio*)inClientData)->open();
+            return noErr;
+        case kAudioHardwarePropertyDefaultInputDevice:
+            artsdebug("PropertyListenerProc kAudioHardwarePropertyDefaultOutputDevice:\n");
+            ((AudioIOCoreAudio*)inClientData)->close();
+            ((AudioIOCoreAudio*)inClientData)->open();
+            return noErr;
+            break;
+            
+        default:
+            return noErr;
+            break;    
+    }
+}
+
+/* Utility */
+
+bool NotifyOnError (OSStatus inRetVal, const char * inStringDesc) {
+	if (inRetVal == noErr) {
+		return true;
+	} else {
+		switch(inRetVal) {
+			case kAudioHardwareNoError:
+				break;
+			case kAudioHardwareNotRunningError:
+				arts_warning("error: hardware not running in %s", inStringDesc);
+				break;
+			case kAudioHardwareUnspecifiedError:
+				arts_warning("error: unspecified error in %s", inStringDesc);
+				break;
+			case kAudioHardwareUnknownPropertyError:
+				arts_warning("error: unknown property in %s", inStringDesc);
+				break;
+			case kAudioHardwareBadPropertySizeError:
+				arts_warning("error: bad property size in %s", inStringDesc);
+				break;
+			case kAudioHardwareIllegalOperationError:
+				arts_warning("error: illegal operation in %s", inStringDesc);
+				break;
+			case kAudioHardwareBadDeviceError:
+				arts_warning("error: bad device in %s", inStringDesc);
+				break;
+			case kAudioHardwareBadStreamError:
+				arts_warning("error: bad stream in %s", inStringDesc);
+				break;
+			case kAudioDeviceUnsupportedFormatError:
+				arts_warning("error: unsupported format in %s", inStringDesc);
+				break;
+			case kAudioDevicePermissionsError:
+				arts_warning("error: bad device permissions in %s", inStringDesc);
+				break;
+			default:
+				arts_warning("error: unknown CoreAudio error in %s", inStringDesc);
+				break;
+		}
+			
+		arts_warning("  system: 0x%d", err_get_system(inRetVal));
+		arts_warning("  sub:    0x%d", err_get_sub(inRetVal));
+		arts_warning("  code:   0x%d", err_get_code(inRetVal));
+		return false;
+	}
+}
+
+void ExitOnError (OSStatus inRetVal, const char * inStringDesc) {
+	if ( NotifyOnError (inRetVal, inStringDesc) ) {
+		exit(1);
+	}
+}
+
+#endif // HAVE_COREAUDIO
RCS file: flow/audioioesd.cc
diff -N flow/audioioesd.cc
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ flow/audioioesd.cc	2 Mar 2003 22:31:53 -0000	1.3
@@ -0,0 +1,237 @@
+    /*
+
+    Copyright (C) 2001 Jochen Hoenicke
+                       jochen@gnu.org
+
+    Copyright (C) 2003 Ian Chiew
+                       ian@snork.net
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+  
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+   
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+    Boston, MA 02111-1307, USA.
+
+    */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+/**
+ * only compile esound AudioIO class if libesd was detected during
+ * configure
+ */
+#ifdef HAVE_LIBESD
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <sys/stat.h>
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <iostream>
+
+#include "audioio.h"
+#include "audiosubsys.h"
+#include "iomanager.h"
+#include "dispatcher.h"
+
+#include <esd.h>
+
+#ifdef __BIG_ENDIAN__
+#define _format_bits 17
+#else
+#define _format_bits 16
+#endif
+
+namespace Arts {
+
+class AudioIOESD : public AudioIO, public IONotify {
+protected:
+	int server_fd, read_fd, write_fd;
+
+public:
+	AudioIOESD();
+
+	void setParam(AudioParam param, int& value);
+	int getParam(AudioParam param);
+	void notifyIO(int fd, int type);
+
+	bool open();
+	void close();
+	void run();
+	int read(void *buffer, int size);
+	int write(void *buffer, int size);
+};
+
+REGISTER_AUDIO_IO(AudioIOESD,"esd","Enlightened Sound Daemon");
+};
+
+using namespace std;
+using namespace Arts;
+
+AudioIOESD::AudioIOESD()
+{
+	/*
+	 * default parameters
+	 */
+	param(samplingRate) = 44100;
+	paramStr(deviceName) = "null";
+	param(fragmentSize) = 1024;
+	param(fragmentCount) = 7;
+	param(format) = _format_bits;
+	param(channels) = 2;
+	param(direction) = 2;
+
+	server_fd = -1;
+	read_fd = -1;
+	write_fd = -1;
+}
+
+bool AudioIOESD::open()
+{
+	int& _channels = param(channels);
+	int& _direction = param(direction);
+	int& _fragmentSize = param(fragmentSize);
+	int& _fragmentCount = param(fragmentCount);
+	int& _samplingRate = param(samplingRate);
+	int& _format = param(format);
+	string& _device = paramStr(deviceName);
+	string& _error = paramStr(lastError);
+
+	if ((server_fd = esd_open_sound(NULL)) == -1)
+	{
+		_error = "Couldn't connect to server";
+		return false;
+	}
+
+	esd_server_info_t *server_info = esd_get_server_info(server_fd);
+
+	if (server_info == NULL)
+	{
+		_error = "Unable to query EsounD server";
+		return false;
+	}
+	
+	esd_format_t server_format = server_info->format;
+
+	_samplingRate = server_info->rate;
+	_channels     = (server_format & ESD_STEREO) ? 2            : 1;
+	_format       = (server_format & ESD_BITS16) ? _format_bits : 8;
+
+	esd_free_server_info(server_info);
+	
+	if (_direction & directionRead)
+	{
+		read_fd = esd_record_stream(server_format, _samplingRate,
+					    NULL, "aRts");
+		if (read_fd == -1)
+		{
+			_error = "Couldn't create read uflow";
+			return false;
+		}
+	}
+
+	if (_direction & directionWrite)
+	{
+		write_fd = esd_play_stream(server_format, _samplingRate,
+					   NULL, "aRts");
+		if (write_fd == -1)
+		{
+			_error = "Couldn't create write flow";
+			return false;
+		}
+	}
+
+	return true;
+}
+
+void AudioIOESD::notifyIO(int, int)
+{
+}
+
+void AudioIOESD::close()
+{
+	if (write_fd != -1) 
+		esd_close(write_fd);
+
+	if (read_fd != -1)
+		esd_close(read_fd);
+
+	if (server_fd != -1)
+		esd_close(server_fd);
+}
+
+void AudioIOESD::setParam(AudioParam p, int& value)
+{
+	switch(p)
+	{
+	case channels:
+	case format:
+	case direction:
+	case samplingRate:
+		param(p) = value;
+		close();
+		open();
+		return;
+
+	default:
+		param(p) = value;
+		return;
+	}
+}
+
+int AudioIOESD::getParam(AudioParam p)
+{
+	switch(p)
+	{
+	case selectReadFD:
+		return read_fd;
+
+	case selectWriteFD:
+		return write_fd;
+
+	case canRead:
+		return ESD_BUF_SIZE;
+
+	case canWrite:
+		return ESD_BUF_SIZE;
+
+		// ESD handles are actually socket descriptors, and I know not
+		// of any portable way to peek at the socket's send or receive
+		// buffers.
+
+	case autoDetect:
+		return 12;
+
+	default:
+		return param(p);
+	}
+}
+
+int AudioIOESD::read(void *buffer, int size)
+{
+	return ::read(read_fd, buffer, size);
+}
+
+int AudioIOESD::write(void *buffer, int size)
+{
+	return ::write(write_fd, buffer, size);
+}
+
+#endif
--- flow/audioiooss.cc	29 Oct 2002 02:31:12 -0000	1.1.1.3
+++ flow/audioiooss.cc	7 Nov 2002 00:16:37 -0000	1.6
@@ -28,10 +28,30 @@
 
 #if defined(HAVE_SYS_SOUNDCARD_H)
 	#include <sys/soundcard.h>
+	#include <sys/ioctl.h>
 	#define COMPILE_AUDIOIO_OSS 1
+	#define OSS_OPEN open
+	#define OSS_CLOSE close
+	#define OSS_IOCTL ioctl
+	#define OSS_WRITE write
 #elif defined(HAVE_SOUNDCARD_H)
 	#include <soundcard.h>
+	#include <sys/ioctl.h>
 	#define COMPILE_AUDIOIO_OSS 1
+	#define OSS_OPEN open
+	#define OSS_CLOSE close
+	#define OSS_IOCTL ioctl
+	#define OSS_WRITE write
+#endif
+
+#ifdef HAVE_LIBOSS
+	#define LIBOSS_IOCTL OSS_IOCTL
+	#define LIBOSS_OPEN  OSS_OPEN
+	#define LIBOSS_CLOSE OSS_CLOSE
+	#define LIBOSS_WRITE OSS_WRITE
+	#define COMPILE_AUDIOIO_OSS 1
+	#include <liboss/soundcard.h>
+	#include <sys/ioctl.h>
 #endif
 
 /**
@@ -40,7 +60,6 @@
 #ifdef COMPILE_AUDIOIO_OSS
 
 #include <sys/types.h>
-#include <sys/ioctl.h>
 #include <sys/time.h>
 #include <sys/stat.h>
 
@@ -159,7 +178,7 @@
 		return false;
 	}
 
-	audio_fd = ::open(_deviceName.c_str(), mode, 0);
+	audio_fd = ::OSS_OPEN(_deviceName.c_str(), mode, 0);
 
 	if(audio_fd == -1)
 	{
@@ -174,7 +193,7 @@
 	 * check device capabilities
 	 */
 	int device_caps;
-	if(ioctl(audio_fd,SNDCTL_DSP_GETCAPS,&device_caps) == -1)
+	if(OSS_IOCTL(audio_fd,SNDCTL_DSP_GETCAPS,&device_caps) == -1)
             device_caps=0;
 
 	string caps = "";
@@ -189,7 +208,7 @@
 
 	int requestedFormat = (_format == 8)?AFMT_U8:AFMT_S16_LE;
 	int gotFormat = requestedFormat;
-	if (ioctl(audio_fd, SNDCTL_DSP_SETFMT, &gotFormat)==-1)  
+	if (OSS_IOCTL(audio_fd, SNDCTL_DSP_SETFMT, &gotFormat)==-1)  
 	{
 		_error = "SNDCTL_DSP_SETFMT failed - ";
 		_error += strerror(errno);
@@ -252,7 +271,7 @@
 
 	int requeststereo = stereo;
 
-	if (ioctl(audio_fd, SNDCTL_DSP_STEREO, &stereo)==-1)
+	if (OSS_IOCTL(audio_fd, SNDCTL_DSP_STEREO, &stereo)==-1)
 	{
 		_error = "SNDCTL_DSP_STEREO failed - ";
 		_error += strerror(errno);
@@ -271,7 +290,7 @@
 
 	int speed = _samplingRate;
 
-	if (ioctl(audio_fd, SNDCTL_DSP_SPEED, &speed)==-1)  
+	if (OSS_IOCTL(audio_fd, SNDCTL_DSP_SPEED, &speed)==-1)  
 	{
 		_error = "SNDCTL_DSP_SPEED failed - ";
 		_error += strerror(errno);
@@ -322,7 +341,7 @@
 	int size = _fragmentSize;
 	while(size > 1) { size /= 2; frag_arg++; }
 	frag_arg += (_fragmentCount << 16);
-	if(ioctl(audio_fd, SNDCTL_DSP_SETFRAGMENT, &frag_arg) == -1)
+	if(OSS_IOCTL(audio_fd, SNDCTL_DSP_SETFRAGMENT, &frag_arg) == -1)
 	{
 		char buffer[1024];
 		_error = "can't set requested fragments settings";
@@ -336,7 +355,7 @@
 	 * we asked for
 	 */
 	audio_buf_info info;
-	if(ioctl(audio_fd,SNDCTL_DSP_GETOSPACE, &info) == -1)
+	if(OSS_IOCTL(audio_fd,SNDCTL_DSP_GETOSPACE, &info) == -1)
 	{
 		_error = "can't retrieve fragment settings";
 		close();
@@ -393,7 +412,7 @@
 		if(param(direction) & 1) enable_bits |= PCM_ENABLE_INPUT;
 		if(param(direction) & 2) enable_bits |= PCM_ENABLE_OUTPUT;
 
-		if(ioctl(audio_fd,SNDCTL_DSP_SETTRIGGER, &enable_bits) == -1)
+		if(OSS_IOCTL(audio_fd,SNDCTL_DSP_SETTRIGGER, &enable_bits) == -1)
 		{
 			_error = "can't start sound i/o";
 
@@ -406,7 +425,7 @@
 
 void AudioIOOSS::close()
 {
-	::close(audio_fd);
+	::OSS_CLOSE(audio_fd);
 }
 
 void AudioIOOSS::setParam(AudioParam p, int& value)
@@ -431,12 +450,12 @@
 	switch(p)
 	{
 		case canRead:
-				ioctl(audio_fd, SNDCTL_DSP_GETISPACE, &info);
+				OSS_IOCTL(audio_fd, SNDCTL_DSP_GETISPACE, &info);
 				return info.bytes;
 			break;
 
 		case canWrite:
-				ioctl(audio_fd, SNDCTL_DSP_GETOSPACE, &info);
+				OSS_IOCTL(audio_fd, SNDCTL_DSP_GETOSPACE, &info);
 				return info.bytes;
 			break;
 
@@ -477,7 +496,7 @@
 
 	int result;
 	do {
-		result = ::write(audio_fd,buffer,size);
+		result = ::OSS_WRITE(audio_fd,buffer,size);
 	} while(result == -1 && errno == EINTR);
 
 	return result;
--- flow/gsl/gsldatahandle-vorbis.c	14 Aug 2002 13:21:17 -0000	1.1.1.3
+++ flow/gsl/gsldatahandle-vorbis.c	15 Dec 2002 07:26:39 -0000	1.4
@@ -225,7 +225,8 @@
       if (err || vhandle->pcm_pos < 0)  /* urg, we're completely screwed */
 	vhandle->pcm_pos = 0;
       vhandle->pcm_length = 0;
-    }
+    }  
+if (0) 
   g_printerr ("OggS-SEEK: at %lu want %lu got %lu (diff-requested %ld)\n",
 	      opos, pos, vhandle->pcm_pos, pos - opos);
 
--- libltdl/ltdl.c	10 Jul 2002 02:52:29 -0000	1.1.1.2
+++ libltdl/ltdl.c	26 Nov 2002 21:00:47 -0000	1.5
@@ -1544,11 +1544,14 @@
   /* try to open the old library first; if it was dlpreopened,
      we want the preopened version of it, even if a dlopenable
      module is available */
+/*	HACKALERT: Why? Mac OS/Darwin can't open static libs, it is
+	a waste to even try. Disabled for kde.	*/
+#if 0
   if (old_name && tryall_dlopen(handle, old_name) == 0)
     {
       return 0;
     }
-
+#endif
   /* try to open the dynamic library */
   if (dlname)
     {
--- libltdl/ltdl.m4	10 Jul 2002 02:52:29 -0000	1.1.1.2
+++ libltdl/ltdl.m4	22 Jan 2003 02:54:19 -0000	1.4
@@ -103,6 +103,9 @@
 	osf*)
 	  libltdl_cv_sys_dlopen_deplibs=yes
 	  ;;
+	darwin*)
+	  libltdl_cv_sys_dlopen_deplibs=yes
+	  ;;
 	esac
 ])
 if test "$libltdl_cv_sys_dlopen_deplibs" != yes; then
@@ -442,6 +445,8 @@
 if test x"$ac_cv_sys_symbol_underscore" = xyes; then
   if test x"$ac_cv_func_dlopen" = xyes ||
      test x"$ac_cv_lib_dl_dlopen" = xyes ; then
+        ac_save_LIBS="$LIBS"
+        LIBS="$LIBS $LIBADD_DL"
 	AC_CACHE_CHECK([whether we have to add an underscore for dlsym],
 		libltdl_cv_need_uscore, [dnl
 		AC_TRY_RUN([
@@ -495,6 +500,7 @@
 fi
 
 if test x"$libltdl_cv_need_uscore" = xyes; then
+  LIBS="$ac_save_LIBS"
   AC_DEFINE(NEED_USCORE, 1,
     [Define if dlsym() requires a leading underscode in symbol names. ])
 fi
--- soundserver/Makefile.am	14 Aug 2002 13:21:26 -0000	1.1.1.4
+++ soundserver/Makefile.am	25 Mar 2003 18:16:37 -0000	1.12
@@ -38,13 +38,13 @@
 libartswavplayobject_la_SOURCES = wavplayobject_impl.cc
 libartswavplayobject_la_LIBADD  = $(top_builddir)/mcop/libmcop.la \
                                   libsoundserver_idl.la $(FLOWLIBS)
-libartswavplayobject_la_LDFLAGS = -no-undefined -module
+libartswavplayobject_la_LDFLAGS = -no-undefined -module -avoid-version
 libartswavplayobject_la_COMPILE_FIRST = soundserver.h ../flow/artsflow.h
 
 libartsgslplayobject_la_SOURCES = gslplayobject_impl.cc
 libartsgslplayobject_la_LIBADD  = $(top_builddir)/mcop/libmcop.la \
                                   libsoundserver_idl.la $(FLOWLIBS)
-libartsgslplayobject_la_LDFLAGS = -no-undefined -module
+libartsgslplayobject_la_LDFLAGS = -no-undefined -module -avoid-version
 libartsgslplayobject_la_COMPILE_FIRST = soundserver.h ../flow/artsflow.h
 
 ###### "real" programs
--- soundserver/artsd.cc	10 Jul 2002 02:52:33 -0000	1.1.1.2
+++ soundserver/artsd.cc	20 Oct 2002 19:11:01 -0000	1.4
@@ -35,6 +35,13 @@
 #include "debug.h"
 #include "artsversion.h"
 
+#ifdef HAVE_MACH_REALTIME_SCHED
+  #include <mach/mach.h>
+  #include <mach/thread_policy.h>
+  #include <sys/param.h>
+  #include <sys/sysctl.h>
+#endif
+
 using namespace std;
 using namespace Arts;
 
@@ -232,6 +239,29 @@
 	cerr << endl;
 }
 
+#ifdef HAVE_MACH_REALTIME_SCHED
+static void mach_get_realtime_priority()
+{
+	struct thread_time_constraint_policy ttcpolicy;
+	int bus_speed, mib [2] = { CTL_HW, HW_BUS_FREQ };
+	size_t len;   
+
+	len = sizeof (bus_speed);
+	sysctl (mib, 2, &bus_speed, &len, NULL, 0);
+
+	/* Is it enough? */
+	ttcpolicy.period = bus_speed / 120;
+	ttcpolicy.computation = bus_speed / 2400;
+	ttcpolicy.constraint = bus_speed / 1200;
+	ttcpolicy.preemptible = 1;
+
+	thread_policy_set (mach_thread_self (),
+			   THREAD_TIME_CONSTRAINT_POLICY,
+			   (int*)&ttcpolicy,
+			   THREAD_TIME_CONSTRAINT_POLICY_COUNT);
+}
+#endif
+
 int main(int argc, char **argv)
 {
 	handleArgs(argc, argv);
@@ -244,7 +274,9 @@
 
 	if(cfgPort)			 TCPServer::setPort(cfgPort);
 
+#ifndef ARTS_NO_ALARM
 	CPUUsage	cpuUsage;
+#endif
 	Dispatcher	dispatcher(0,cfgServers);
 
 	initSignals();
@@ -298,6 +330,10 @@
 		cleanUnusedReferences();
 		if(!publishReferences(server,audioManager,false)) return 1;
 	}
+
+#ifdef HAVE_MACH_REALTIME_SCHED
+	mach_get_realtime_priority();
+#endif
 
 	/* warn if there was a problem with artswrapper */
 	char *wrapper = getenv("STARTED_THROUGH_ARTSWRAPPER");
--- soundserver/soundserverv2_impl.cc	25 Jun 2002 01:45:59 -0000	1.1.1.1
+++ soundserver/soundserverv2_impl.cc	25 Jun 2002 01:46:40 -0000	1.2
@@ -374,9 +374,12 @@
 
 float SoundServerV2_impl::cpuUsage()
 {
+#ifndef ARTS_NO_ALARM
 	return CPUUsage::the()->usage() * 100.0;
+#else
+	return 5.0;
+#endif
 }
-
 
 #ifndef __SUNPRO_CC
 /* See bottom of simplesoundserver_impl.cc for the reason this is here.  */
