diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/docs/LibTooling.rst cfe-3.5.0.src.omp/docs/LibTooling.rst
--- cfe-3.5.0.src/docs/LibTooling.rst	2014-05-01 16:04:39.000000000 -0400
+++ cfe-3.5.0.src.omp/docs/LibTooling.rst	2014-11-28 10:49:29.000000000 -0500
@@ -185,7 +185,7 @@
 
 Clang tools need their builtin headers and search for them the same way Clang
 does.  Thus, the default location to look for builtin headers is in a path
-``$(dirname /path/to/tool)/../lib/clang/3.3/include`` relative to the tool
+``$(dirname /path/to/tool)/../lib/clang/3.4/include`` relative to the tool
 binary.  This works out-of-the-box for tools running from llvm's toplevel
 binary directory after building clang-headers, or if the tool is running from
 the binary directory of a clang install next to the clang binary.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/docs/ReleaseNotes.rst cfe-3.5.0.src.omp/docs/ReleaseNotes.rst
--- cfe-3.5.0.src/docs/ReleaseNotes.rst	2014-09-02 17:29:19.000000000 -0400
+++ cfe-3.5.0.src.omp/docs/ReleaseNotes.rst	2014-11-28 10:49:29.000000000 -0500
@@ -1,6 +1,6 @@
-=====================================
-Clang 3.5 (In-Progress) Release Notes
-=====================================
+=======================
+Clang 3.5 Release Notes
+=======================
 
 .. contents::
    :local:
@@ -8,12 +8,6 @@
 
 Written by the `LLVM Team <http://llvm.org/>`_
 
-.. warning::
-
-   These are in-progress notes for the upcoming Clang 3.5 release. You may
-   prefer the `Clang 3.4 Release Notes
-   <http://llvm.org/releases/3.4/tools/clang/docs/ReleaseNotes.html>`_.
-
 Introduction
 ============
 
@@ -26,23 +20,22 @@
 releases may be downloaded from the `LLVM releases web
 site <http://llvm.org/releases/>`_.
 
-For more information about Clang or LLVM, including information about
-the latest release, please check out the main please see the `Clang Web
-Site <http://clang.llvm.org>`_ or the `LLVM Web
-Site <http://llvm.org>`_.
-
-Note that if you are reading this file from a Subversion checkout or the
-main Clang web page, this document applies to the *next* release, not
-the current one. To see the release notes for a specific release, please
-see the `releases page <http://llvm.org/releases/>`_.
+For more information about Clang or LLVM, including information about the
+latest release, please check out the main `Clang Web Site
+<http://clang.llvm.org>`_ or the `LLVM Web Site <http://llvm.org>`_.
+
+Note that if you are reading this file from a Subversion checkout or the main
+Clang web page, this document applies to the *next* release, not the current
+one. To see the release notes for a specific release, please see the `releases
+page <http://llvm.org/releases/>`_.
 
 What's New in Clang 3.5?
 ========================
 
-Some of the major new features and improvements to Clang are listed
-here. Generic improvements to Clang as a whole or to its underlying
-infrastructure are described first, followed by language-specific
-sections with improvements to Clang's support for those languages.
+Some of the major new features and improvements to Clang are listed here.
+Generic improvements to Clang as a whole or to its underlying infrastructure
+are described first, followed by language-specific sections with improvements
+to Clang's support for those languages.
 
 Major New Features
 ------------------
@@ -144,7 +137,53 @@
   returns
   `warning: reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to always evaluate to false [-Wtautological-undefined-compare]`
 
--  ...
+    void foo(char *a, char *b, unsigned c) {
+	  for (unsigned i = 0; i < c; ++i) {
+		a[i] = b[i];
+		++i;
+	  }
+    }
+
+  returns
+  `warning: variable 'i' is incremented both in the loop header and in the loop body [-Wloop-analysis]`
+
+- -Wuninitialized now performs checking across field initializers to detect
+  when one field in used uninitialized in another field initialization.
+
+  .. code-block:: c++
+
+    class A {
+      int x;
+      int y;
+      A() : x(y) {}
+    };
+
+  returns
+  `warning: field 'y' is uninitialized when used here [-Wuninitialized]`
+
+- Clang can detect initializer list use inside a macro and suggest parentheses
+  if possible to fix.
+- Many improvements to Clang's typo correction facilities, such as:
+
+  + Adding global namespace qualifiers so that corrections can refer to shadowed
+    or otherwise ambiguous or unreachable namespaces.
+  + Including accessible class members in the set of typo correction candidates,
+    so that corrections requiring a class name in the name specifier are now
+    possible.
+  + Allowing typo corrections that involve removing a name specifier.
+  + In some situations, correcting function names when a function was given the
+    wrong number of arguments, including situations where the original function
+    name was correct but was shadowed by a lexically closer function with the
+    same name yet took a different number of arguments.
+  + Offering typo suggestions for 'using' declarations.
+  + Providing better diagnostics and fixit suggestions in more situations when
+    a '->' was used instead of '.' or vice versa.
+  + Providing more relevant suggestions for typos followed by '.' or '='.
+  + Various performance improvements when searching for typo correction
+    candidates.
+
+- `LeakSanitizer <LeakSanitizer.html>`_ is an experimental memory leak detector
+  which can be combined with AddressSanitizer.
 
 New Compiler Flags
 ------------------
@@ -188,16 +227,6 @@
 interleaving to be enabled or disabled. Vector width as well as interleave count
 can be manually specified.  See :ref:`langext-pragma-loop` for details.
 
-C Language Changes in Clang
----------------------------
-
-...
-
-C11 Feature Support
-^^^^^^^^^^^^^^^^^^^
-
-...
-
 C++ Language Changes in Clang
 -----------------------------
 
@@ -207,8 +236,6 @@
   references, and `-fsanitize=null` can be used to detect null references
   being formed at runtime.
 
-- ...
-
 C++17 Feature Support
 ^^^^^^^^^^^^^^^^^^^^^
 
@@ -227,16 +254,6 @@
 Note that these features may be changed or removed in future Clang releases
 without notice.
 
-Objective-C Language Changes in Clang
--------------------------------------
-
-...
-
-OpenCL C Language Changes in Clang
-----------------------------------
-
-...
-
 OpenMP C/C++ Language Changes in Clang
 --------------------------------------
 
@@ -254,11 +271,6 @@
 - Clang uses `std::unique_ptr<T>` in many places where it used to use
   raw `T *` pointers.
 
-libclang
---------
-
-...
-
 Static Analyzer
 ---------------
 
@@ -282,25 +294,6 @@
 
 List the function/method name in the index page of scan-build.
 
-...
-
-Core Analysis Improvements
-==========================
-
-- ...
-
-New Issues Found
-================
-
-- ...
-
-Python Binding Changes
-----------------------
-
-The following methods have been added:
-
--  ...
-
 Significant Known Problems
 ==========================
 
@@ -309,11 +302,10 @@
 
 A wide variety of additional information is available on the `Clang web
 page <http://clang.llvm.org/>`_. The web page contains versions of the
-API documentation which are up-to-date with the Subversion version of
+API documentation which are up-to-date with the Subversion revision of
 the source code. You can access versions of these documents specific to
 this release by going into the "``clang/docs/``" directory in the Clang
 tree.
 
-If you have any questions or comments about Clang, please feel free to
-contact us via the `mailing
-list <http://lists.cs.uiuc.edu/mailman/listinfo/cfe-dev>`_.
+If you have any questions or comments about Clang, please feel free to contact
+us via the `mailing list <http://lists.cs.uiuc.edu/mailman/listinfo/cfe-dev>`_.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/AST/DataRecursiveASTVisitor.h cfe-3.5.0.src.omp/include/clang/AST/DataRecursiveASTVisitor.h
--- cfe-3.5.0.src/include/clang/AST/DataRecursiveASTVisitor.h	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/AST/DataRecursiveASTVisitor.h	2014-11-28 10:49:29.000000000 -0500
@@ -1347,11 +1347,31 @@
 DEF_TRAVERSE_DECL(UsingShadowDecl, {})
 
 DEF_TRAVERSE_DECL(OMPThreadPrivateDecl, {
-  for (auto *I : D->varlists()) {
-    TRY_TO(TraverseStmt(I));
+  for (OMPThreadPrivateDecl::varlist_iterator I = D->varlist_begin(),
+                                              E = D->varlist_end();
+       I != E; ++I) {
+    TRY_TO(TraverseStmt(*I));
   }
 })
 
+DEF_TRAVERSE_DECL(OMPDeclareSimdDecl, {
+  if (D->getFunction()) {
+    TRY_TO(TraverseDecl(D->getFunction()));
+  }
+})
+
+DEF_TRAVERSE_DECL(OMPDeclareReductionDecl, {
+  for (OMPDeclareReductionDecl::datalist_iterator I = D->datalist_begin(),
+                                                  E = D->datalist_end();
+       I != E; ++I) {
+    TRY_TO(TraverseType(I->QTy));
+    TRY_TO(TraverseStmt(I->CombinerFunction));
+    TRY_TO(TraverseStmt(I->InitFunction));
+  }
+})
+
+DEF_TRAVERSE_DECL(OMPDeclareTargetDecl, {})
+
 // A helper method for TemplateDecl's children.
 template <typename Derived>
 bool RecursiveASTVisitor<Derived>::TraverseTemplateParameterListHelper(
@@ -2158,6 +2178,7 @@
 // over the children.
 DEF_TRAVERSE_STMT(AddrLabelExpr, {})
 DEF_TRAVERSE_STMT(ArraySubscriptExpr, {})
+DEF_TRAVERSE_STMT(CEANIndexExpr, { })
 DEF_TRAVERSE_STMT(BlockExpr, {
   TRY_TO(TraverseDecl(S->getBlockDecl()));
   return true; // no child statements to loop through.
@@ -2269,227 +2290,192 @@
 // Traverse OpenCL: AsType, Convert.
 DEF_TRAVERSE_STMT(AsTypeExpr, {})
 
-// OpenMP directives.
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::TraverseOMPExecutableDirective(
-    OMPExecutableDirective *S) {
-  for (auto *C : S->clauses()) {
-    TRY_TO(TraverseOMPClause(C));
+// OpenMP directives
+namespace {
+template <class T>
+class DataRecursiveOMPClauseVisitor
+    : public OMPClauseVisitor<DataRecursiveOMPClauseVisitor<T>, bool> {
+  DataRecursiveASTVisitor<T> *Visitor;
+  DataRecursiveASTVisitor<T> &getDerived() { return *Visitor; }
+
+public:
+  DataRecursiveOMPClauseVisitor(DataRecursiveASTVisitor<T> *V) : Visitor(V) {}
+#define OPENMP_CLAUSE(Name, Class)                                             \
+  bool Visit##Class(Class *S) {                                                \
+    for (Stmt::child_range Range = S->children(); Range; ++Range) {            \
+      if (!Visitor->TraverseStmt(*Range))                                      \
+        return false;                                                          \
+    }                                                                          \
+    return true;                                                               \
   }
-  return true;
+#include "clang/Basic/OpenMPKinds.def"
+};
 }
 
-DEF_TRAVERSE_STMT(OMPParallelDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPExecutableDirective, {
+  DataRecursiveOMPClauseVisitor<Derived> V(this);
+  ArrayRef<OMPClause *> Clauses = S->clauses();
+  for (ArrayRef<OMPClause *>::iterator I = Clauses.begin(), E = Clauses.end();
+       I != E; ++I)
+    if (!V.Visit(*I)) return false;
+})
 
-DEF_TRAVERSE_STMT(OMPSimdDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPParallelDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPForDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPTeamsDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPSectionsDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPDistributeDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPSectionDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPForDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPSingleDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPParallelForDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPMasterDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPParallelForSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPCriticalDirective, {
-  TRY_TO(TraverseDeclarationNameInfo(S->getDirectiveName()));
-  TRY_TO(TraverseOMPExecutableDirective(S));
+DEF_TRAVERSE_STMT(OMPSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
 })
 
-DEF_TRAVERSE_STMT(OMPParallelForDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPForSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPParallelSectionsDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPDistributeSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPTaskDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPDistributeParallelForDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPTaskyieldDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPDistributeParallelForSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPBarrierDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPTeamsDistributeDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPTaskwaitDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPTeamsDistributeSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPFlushDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPTargetTeamsDistributeDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-// OpenMP clauses.
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::TraverseOMPClause(OMPClause *C) {
-  if (!C)
-    return true;
-  switch (C->getClauseKind()) {
-#define OPENMP_CLAUSE(Name, Class)                                             \
-  case OMPC_##Name:                                                            \
-    TRY_TO(Visit##Class(static_cast<Class *>(C)));                             \
-    break;
-#include "clang/Basic/OpenMPKinds.def"
-  case OMPC_threadprivate:
-  case OMPC_unknown:
-    break;
-  }
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTargetTeamsDistributeSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPIfClause(OMPIfClause *C) {
-  TRY_TO(TraverseStmt(C->getCondition()));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPSectionsDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPFinalClause(OMPFinalClause *C) {
-  TRY_TO(TraverseStmt(C->getCondition()));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPParallelSectionsDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool
-RecursiveASTVisitor<Derived>::VisitOMPNumThreadsClause(OMPNumThreadsClause *C) {
-  TRY_TO(TraverseStmt(C->getNumThreads()));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPSectionDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPSafelenClause(OMPSafelenClause *C) {
-  TRY_TO(TraverseStmt(C->getSafelen()));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPSingleDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool
-RecursiveASTVisitor<Derived>::VisitOMPCollapseClause(OMPCollapseClause *C) {
-  TRY_TO(TraverseStmt(C->getNumForLoops()));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTaskDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPDefaultClause(OMPDefaultClause *) {
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTaskyieldDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPProcBindClause(OMPProcBindClause *) {
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPMasterDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool
-RecursiveASTVisitor<Derived>::VisitOMPScheduleClause(OMPScheduleClause *C) {
-  TRY_TO(TraverseStmt(C->getChunkSize()));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPCriticalDirective, {
+  TRY_TO(TraverseDeclarationNameInfo(S->getDirectiveName()));
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPOrderedClause(OMPOrderedClause *) {
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPBarrierDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPNowaitClause(OMPNowaitClause *) {
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTaskwaitDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPUntiedClause(OMPUntiedClause *) {
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTaskgroupDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool
-RecursiveASTVisitor<Derived>::VisitOMPMergeableClause(OMPMergeableClause *) {
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPAtomicDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-template <typename T>
-bool RecursiveASTVisitor<Derived>::VisitOMPClauseList(T *Node) {
-  for (auto *E : Node->varlists()) {
-    TRY_TO(TraverseStmt(E));
-  }
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPFlushDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPPrivateClause(OMPPrivateClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPOrderedDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPFirstprivateClause(
-    OMPFirstprivateClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPCancelDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPLastprivateClause(
-    OMPLastprivateClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPCancellationPointDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPSharedClause(OMPSharedClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTargetDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPLinearClause(OMPLinearClause *C) {
-  TRY_TO(TraverseStmt(C->getStep()));
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTargetDataDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPAlignedClause(OMPAlignedClause *C) {
-  TRY_TO(TraverseStmt(C->getAlignment()));
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTargetUpdateDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPCopyinClause(OMPCopyinClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTargetTeamsDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPCopyprivateClause(
-    OMPCopyprivateClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTeamsDistributeParallelForDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool
-RecursiveASTVisitor<Derived>::VisitOMPReductionClause(OMPReductionClause *C) {
-  TRY_TO(TraverseNestedNameSpecifierLoc(C->getQualifierLoc()));
-  TRY_TO(TraverseDeclarationNameInfo(C->getNameInfo()));
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTeamsDistributeParallelForSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPFlushClause(OMPFlushClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTargetTeamsDistributeParallelForDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
+
+DEF_TRAVERSE_STMT(OMPTargetTeamsDistributeParallelForSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
 // FIXME: look at the following tricky-seeming exprs to see if we
 // need to recurse on anything.  These are ones that have methods
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/AST/DeclBase.h cfe-3.5.0.src.omp/include/clang/AST/DeclBase.h
--- cfe-3.5.0.src/include/clang/AST/DeclBase.h	2014-06-28 19:22:33.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/AST/DeclBase.h	2014-11-28 10:49:29.000000000 -0500
@@ -152,7 +152,9 @@
     /// This declaration is a function-local extern declaration of a
     /// variable or function. This may also be IDNS_Ordinary if it
     /// has been declared outside any function.
-    IDNS_LocalExtern         = 0x0800
+    IDNS_LocalExtern         = 0x0800,
+    /// For OpenMP declare reduction constructs.
+    IDNS_OMPDeclareReduction = 0x1000
   };
 
   /// ObjCDeclQualifier - 'Qualifiers' written next to the return and
@@ -277,7 +279,7 @@
   unsigned Hidden : 1;
   
   /// IdentifierNamespace - This specifies what IDNS_* namespace this lives in.
-  unsigned IdentifierNamespace : 12;
+  unsigned IdentifierNamespace : 13;
 
   /// \brief If 0, we have not computed the linkage of this declaration.
   /// Otherwise, it is the linkage + 1.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/AST/DeclCXX.h cfe-3.5.0.src.omp/include/clang/AST/DeclCXX.h
--- cfe-3.5.0.src/include/clang/AST/DeclCXX.h	2014-06-13 02:43:46.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/AST/DeclCXX.h	2014-11-28 10:49:29.000000000 -0500
@@ -1558,6 +1558,15 @@
                                             CXXBasePath &Path,
                                             void *UserData);
 
+  /// \brief Base-class lookup callback that determines whether there exists
+  /// a member with the given name.
+  ///
+  /// This callback can be used with \c lookupInBases() to find members
+  /// of the given name within a C++ class hierarchy. The user data pointer
+  /// is an opaque \c DeclarationName pointer.
+  static bool FindOMPDeclareReductionMember(const CXXBaseSpecifier *Specifier,
+                                            CXXBasePath &Path, void *Name);
+
   /// \brief Retrieve the final overriders for each virtual member
   /// function in the class hierarchy where this class is the
   /// most-derived class in the class hierarchy.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/AST/DeclOpenMP.h cfe-3.5.0.src.omp/include/clang/AST/DeclOpenMP.h
--- cfe-3.5.0.src/include/clang/AST/DeclOpenMP.h	2014-06-28 19:22:33.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/AST/DeclOpenMP.h	2014-11-28 10:49:29.000000000 -0500
@@ -1,4 +1,4 @@
-//===- DeclOpenMP.h - Classes for representing OpenMP directives -*- C++ -*-===//
+//===- DeclOpenMP.h - Classes for representing OpenMP directives -*- C++-*-===//
 //
 //                     The LLVM Compiler Infrastructure
 //
@@ -15,7 +15,8 @@
 #ifndef LLVM_CLANG_AST_OPENMP_H
 #define LLVM_CLANG_AST_OPENMP_H
 
-#include "clang/AST/DeclBase.h"
+#include "clang/AST/Decl.h"
+#include "clang/AST/OpenMPClause.h"
 #include "llvm/ADT/ArrayRef.h"
 
 namespace clang {
@@ -38,44 +39,32 @@
 
   virtual void anchor();
 
-  OMPThreadPrivateDecl(Kind DK, DeclContext *DC, SourceLocation L) :
-    Decl(DK, DC, L), NumVars(0) { }
+  OMPThreadPrivateDecl(Kind DK, DeclContext *DC, SourceLocation L)
+      : Decl(DK, DC, L), NumVars(0) {}
 
   ArrayRef<const Expr *> getVars() const {
     return ArrayRef<const Expr *>(
-                   reinterpret_cast<const Expr * const *>(this + 1),
-                   NumVars);
+        reinterpret_cast<const Expr *const *>(this + 1), NumVars);
   }
 
-  MutableArrayRef<Expr *> getVars() {
-    return MutableArrayRef<Expr *>(
-                           reinterpret_cast<Expr **>(this + 1),
-                           NumVars);
+  llvm::MutableArrayRef<Expr *> getVars() {
+    return llvm::MutableArrayRef<Expr *>(reinterpret_cast<Expr **>(this + 1),
+                                         NumVars);
   }
 
   void setVars(ArrayRef<Expr *> VL);
 
 public:
   static OMPThreadPrivateDecl *Create(ASTContext &C, DeclContext *DC,
-                                      SourceLocation L,
-                                      ArrayRef<Expr *> VL);
-  static OMPThreadPrivateDecl *CreateDeserialized(ASTContext &C,
-                                                  unsigned ID, unsigned N);
+                                      SourceLocation L, ArrayRef<Expr *> VL);
+  static OMPThreadPrivateDecl *CreateDeserialized(ASTContext &C, unsigned ID,
+                                                  unsigned N);
 
-  typedef MutableArrayRef<Expr *>::iterator varlist_iterator;
+  typedef llvm::MutableArrayRef<Expr *>::iterator varlist_iterator;
   typedef ArrayRef<const Expr *>::iterator varlist_const_iterator;
-  typedef llvm::iterator_range<varlist_iterator> varlist_range;
-  typedef llvm::iterator_range<varlist_const_iterator> varlist_const_range;
 
   unsigned varlist_size() const { return NumVars; }
   bool varlist_empty() const { return NumVars == 0; }
-
-  varlist_range varlists() {
-    return varlist_range(varlist_begin(), varlist_end());
-  }
-  varlist_const_range varlists() const {
-    return varlist_const_range(varlist_begin(), varlist_end());
-  }
   varlist_iterator varlist_begin() { return getVars().begin(); }
   varlist_iterator varlist_end() { return getVars().end(); }
   varlist_const_iterator varlist_begin() const { return getVars().begin(); }
@@ -85,6 +74,230 @@
   static bool classofKind(Kind K) { return K == OMPThreadPrivate; }
 };
 
-}  // end namespace clang
+/// \brief This represents '#pragma omp declare reduction ...' directive.
+/// For example, in the following, declared reduction 'foo':
+///
+/// \code
+/// #pragma omp declare reduction (foo : int,float : omp_out += omp_in)
+/// initializer (omp_priv = 0)
+/// \endcode
+///
+class OMPDeclareReductionDecl : public NamedDecl, public DeclContext {
+public:
+  struct ReductionData {
+    ReductionData(QualType QTy, SourceRange TyRange, Expr *Combiner, Expr *Init)
+        : QTy(QTy), TyRange(TyRange), CombinerFunction(Combiner),
+          InitFunction(Init) {}
+    ReductionData() : QTy(), TyRange(), CombinerFunction(0), InitFunction(0) {}
+    QualType QTy;
+    SourceRange TyRange;
+    Expr *CombinerFunction;
+    Expr *InitFunction;
+  };
+
+private:
+  friend class ASTDeclReader;
+  unsigned NumTypes;
+
+  virtual void anchor();
+
+  OMPDeclareReductionDecl(Kind DK, DeclContext *DC, SourceLocation L,
+                          DeclarationName Name)
+      : NamedDecl(DK, DC, L, Name), DeclContext(DK), NumTypes(0) {
+    setModulePrivate();
+  }
+
+  static unsigned getFirstElementOffset();
+
+  ArrayRef<ReductionData> getData() const {
+    return ArrayRef<ReductionData>(
+        reinterpret_cast<const ReductionData *>(
+            reinterpret_cast<const char *>(this) + getFirstElementOffset()),
+        NumTypes);
+  }
+
+  llvm::MutableArrayRef<ReductionData> getData() {
+    return llvm::MutableArrayRef<ReductionData>(
+        reinterpret_cast<ReductionData *>(reinterpret_cast<char *>(this) +
+                                          getFirstElementOffset()),
+        NumTypes);
+  }
+
+public:
+  static OMPDeclareReductionDecl *Create(ASTContext &C, DeclContext *DC,
+                                         SourceLocation L, DeclarationName Name,
+                                         unsigned N);
+  static OMPDeclareReductionDecl *CreateDeserialized(ASTContext &C, unsigned ID,
+                                                     unsigned N);
+
+  void setData(ArrayRef<ReductionData> RD);
+
+  typedef llvm::MutableArrayRef<ReductionData>::iterator datalist_iterator;
+  typedef ArrayRef<ReductionData>::iterator datalist_const_iterator;
+
+  unsigned datalist_size() const { return NumTypes; }
+  bool datalist_empty() const { return NumTypes == 0; }
+  datalist_iterator datalist_begin() { return getData().begin(); }
+  datalist_iterator datalist_end() { return getData().end(); }
+  datalist_const_iterator datalist_begin() const { return getData().begin(); }
+  datalist_const_iterator datalist_end() const { return getData().end(); }
+
+  static bool classof(const Decl *D) { return classofKind(D->getKind()); }
+  static bool classofKind(Kind K) { return K == OMPDeclareReduction; }
+  static DeclContext *castToDeclContext(const OMPDeclareReductionDecl *D) {
+    return static_cast<DeclContext *>(const_cast<OMPDeclareReductionDecl *>(D));
+  }
+  static OMPDeclareReductionDecl *castFromDeclContext(const DeclContext *DC) {
+    return static_cast<OMPDeclareReductionDecl *>(
+        const_cast<DeclContext *>(DC));
+  }
+};
+
+/// \brief This represents '#pragma omp declare simd ...' directive.
+/// Here is an example, where two simd-variants are declared for a function:
+///
+/// #pragma omp declare simd inbranch uniform(a) linear(b:4) simdlen(8)
+/// #pragma omp declare simd inbranch uniform(a) linear(b:4) simdlen(16)
+/// void func(float *a, float *b);
+///
+class OMPDeclareSimdDecl : public Decl {
+public:
+  /// \brief SimdVariant refers to a list of clauses which describe some
+  ///        variant of the function that will need to be instantiated.
+  struct SimdVariant {
+    SimdVariant(SourceRange SR, unsigned BI, unsigned EI)
+        : SrcRange(SR), BeginIdx(BI), EndIdx(EI) {}
+    SourceRange SrcRange;
+    unsigned BeginIdx;
+    unsigned EndIdx;
+  };
+
+private:
+  friend class ASTDeclReader;
+  unsigned NumVariants;
+  unsigned NumClauses;
+  Decl *FuncDecl;
+
+  virtual void anchor();
+
+  OMPDeclareSimdDecl(Kind DK, DeclContext *DC, SourceLocation L, unsigned NV,
+                     unsigned NC)
+      : Decl(DK, DC, L), NumVariants(NV), NumClauses(NC), FuncDecl(0) {}
+
+  static unsigned getFirstVariantOffset();
+  static unsigned getFirstClauseOffset(unsigned NV);
+  static unsigned getTotalSize(unsigned NV, unsigned NC);
+
+public:
+  // Getters for the array of simd variants.
+  ArrayRef<SimdVariant> getVariants() const {
+    return ArrayRef<SimdVariant>(
+        reinterpret_cast<const SimdVariant *>(
+            reinterpret_cast<const char *>(this) + getFirstVariantOffset()),
+        NumVariants);
+  }
+
+  llvm::MutableArrayRef<SimdVariant> getVariants() {
+    return llvm::MutableArrayRef<SimdVariant>(
+        reinterpret_cast<SimdVariant *>(reinterpret_cast<char *>(this) +
+                                        getFirstVariantOffset()),
+        NumVariants);
+  }
+
+  // Getters for the array of clauses.
+  ArrayRef<OMPClause *> getClauses() const {
+    return ArrayRef<OMPClause *>(reinterpret_cast<OMPClause *const *>(
+                                     reinterpret_cast<const char *>(this) +
+                                     getFirstClauseOffset(NumVariants)),
+                                 NumClauses);
+  }
+
+  llvm::MutableArrayRef<OMPClause *> getClauses() {
+    return llvm::MutableArrayRef<OMPClause *>(
+        reinterpret_cast<OMPClause **>(reinterpret_cast<char *>(this) +
+                                       getFirstClauseOffset(NumVariants)),
+        NumClauses);
+  }
+
+public:
+  static OMPDeclareSimdDecl *Create(ASTContext &C, DeclContext *DC,
+                                    SourceLocation L, Decl *FuncDecl,
+                                    unsigned NV, ArrayRef<OMPClause *> CL);
+  static OMPDeclareSimdDecl *CreateDeserialized(ASTContext &C, unsigned ID,
+                                                unsigned NV, unsigned NC);
+
+  Decl *getFunction() const { return FuncDecl; }
+  void setFunction(Decl *FD) { FuncDecl = FD; }
+  unsigned getNumVariants() const { return NumVariants; }
+  unsigned getNumClauses() const { return NumClauses; }
+
+  // Stuff to work with variants
+  void setVariants(ArrayRef<SimdVariant> SV);
+
+  typedef llvm::MutableArrayRef<SimdVariant>::iterator simd_variants_iterator;
+  typedef ArrayRef<SimdVariant>::iterator simd_variants_const_iterator;
+
+  unsigned simd_variants_size() const { return NumVariants; }
+  bool simds_variant_empty() const { return NumVariants == 0; }
+  simd_variants_iterator simd_variants_begin() { return getVariants().begin(); }
+  simd_variants_iterator simd_variants_end() { return getVariants().end(); }
+  simd_variants_const_iterator simd_variants_begin() const {
+    return getVariants().begin();
+  }
+  simd_variants_const_iterator simd_variants_end() const {
+    return getVariants().end();
+  }
+
+  // Stuff to work with clauses
+  void setClauses(ArrayRef<OMPClause *> CL);
+
+  typedef llvm::MutableArrayRef<OMPClause *>::iterator clauses_iterator;
+  typedef ArrayRef<OMPClause *>::iterator clauses_const_iterator;
+
+  unsigned clauses_size() const { return NumClauses; }
+  bool clauses_empty() const { return NumClauses == 0; }
+  clauses_iterator clauses_begin() { return getClauses().begin(); }
+  clauses_iterator clauses_end() { return getClauses().end(); }
+  clauses_const_iterator clauses_begin() const { return getClauses().begin(); }
+  clauses_const_iterator clauses_end() const { return getClauses().end(); }
+
+  static bool classof(const Decl *D) { return classofKind(D->getKind()); }
+  static bool classofKind(Kind K) { return K == OMPDeclareSimd; }
+};
+
+/// For example, in the following, declared target variable 'foo':
+///
+/// \code
+/// #pragma omp declare target
+/// int foo;
+/// #pragma omp end declare target
+/// \endcode
+///
+class OMPDeclareTargetDecl : public Decl, public DeclContext {
+  friend class ASTDeclReader;
+
+  virtual void anchor();
+
+  OMPDeclareTargetDecl(Kind DK, DeclContext *DC, SourceLocation L)
+      : Decl(DK, DC, L), DeclContext(DK) {
+    setModulePrivate();
+  }
+
+public:
+  static OMPDeclareTargetDecl *Create(ASTContext &C, DeclContext *DC,
+                                      SourceLocation L);
+  static OMPDeclareTargetDecl *CreateDeserialized(ASTContext &C, unsigned ID);
+
+  static bool classof(const Decl *D) { return classofKind(D->getKind()); }
+  static bool classofKind(Kind K) { return K == OMPDeclareTarget; }
+  static DeclContext *castToDeclContext(const OMPDeclareTargetDecl *D) {
+    return static_cast<DeclContext *>(const_cast<OMPDeclareTargetDecl *>(D));
+  }
+  static OMPDeclareTargetDecl *castFromDeclContext(const DeclContext *DC) {
+    return static_cast<OMPDeclareTargetDecl *>(const_cast<DeclContext *>(DC));
+  }
+};
+
+} // end namespace clang
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/AST/Expr.h cfe-3.5.0.src.omp/include/clang/AST/Expr.h
--- cfe-3.5.0.src/include/clang/AST/Expr.h	2014-07-21 02:03:12.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/AST/Expr.h	2014-11-28 10:49:29.000000000 -0500
@@ -4841,6 +4841,89 @@
     return child_range(SubExprs, SubExprs+NumSubExprs);
   }
 };
+
+/// CEANIndexExpr - CEAN index triplet.
+class CEANIndexExpr : public Expr {
+  enum { BASE, LOWER_BOUND, LENGTH, INDEX_EXPR, END_EXPR };
+  Stmt* SubExprs[END_EXPR];
+  SourceLocation ColonLoc;
+public:
+  CEANIndexExpr(Expr *Base, Expr *LowerBound, SourceLocation ColonLoc,
+                Expr *Length, QualType QTy)
+  : Expr(CEANIndexExprClass, QTy, VK_RValue, OK_Ordinary,
+         (Base && Base->isTypeDependent()) ||
+         (LowerBound && LowerBound->isTypeDependent()) ||
+         (Length && Length->isTypeDependent()),
+         (Base && Base->isValueDependent()) ||
+         (LowerBound && LowerBound->isValueDependent()) ||
+         (Length && Length->isValueDependent()),
+         ((Base && Base->isInstantiationDependent()) ||
+          (LowerBound && LowerBound->isInstantiationDependent()) ||
+          (Length && Length->isInstantiationDependent())),
+         ((Base && Base->containsUnexpandedParameterPack()) ||
+          (LowerBound && LowerBound->containsUnexpandedParameterPack()) ||
+          (Length && Length->containsUnexpandedParameterPack()))),
+    ColonLoc(ColonLoc) {
+    SubExprs[BASE] = Base;
+    SubExprs[LOWER_BOUND] = LowerBound;
+    SubExprs[LENGTH] = Length;
+    SubExprs[INDEX_EXPR] = 0;
+  }
+
+  /// \brief Create an empty CEAN index expression.
+  explicit CEANIndexExpr(EmptyShell Shell)
+    : Expr(CEANIndexExprClass, Shell), ColonLoc() { }
+
+  Expr *getBase() { return dyn_cast_or_null<Expr>(SubExprs[BASE]); }
+  const Expr *getBase() const { return dyn_cast_or_null<Expr>(SubExprs[BASE]); }
+  void setBase(Expr *E) { SubExprs[BASE] = E; }
+
+  Expr *getLowerBound() {
+    return dyn_cast_or_null<Expr>(SubExprs[LOWER_BOUND]);
+  }
+  const Expr *getLowerBound() const {
+    return dyn_cast_or_null<Expr>(SubExprs[LOWER_BOUND]);
+  }
+  void setLowerBound(Expr *E) { SubExprs[LOWER_BOUND] = E; }
+
+  Expr *getLength() { return dyn_cast_or_null<Expr>(SubExprs[LENGTH]); }
+  const Expr *getLength() const {
+    return dyn_cast_or_null<Expr>(SubExprs[LENGTH]);
+  }
+  void setLength(Expr *E) { SubExprs[LENGTH] = E; }
+
+  Expr *getIndexExpr() {
+    return SubExprs[INDEX_EXPR] ? cast<Expr>(SubExprs[INDEX_EXPR]) : 0;
+  }
+  Expr *getIndexExpr() const {
+    return SubExprs[INDEX_EXPR] ? cast<Expr>(SubExprs[INDEX_EXPR]) : 0;
+  }
+  void setIndexExpr(Expr *E) { SubExprs[INDEX_EXPR] = E; }
+
+  SourceLocation getLocStart() const LLVM_READONLY {
+    return getLowerBound()->getLocStart();
+  }
+  SourceLocation getLocEnd() const LLVM_READONLY {
+    return getLength()->getLocEnd();
+  }
+
+  SourceLocation getColonLoc() const LLVM_READONLY { return ColonLoc; }
+  void setColonLoc(SourceLocation L) { ColonLoc = L; }
+
+  SourceLocation getExprLoc() const LLVM_READONLY {
+    return getLocStart();
+  }
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == CEANIndexExprClass;
+  }
+
+  // Iterators
+  child_range children() {
+    return child_range(&SubExprs[LOWER_BOUND], &SubExprs[END_EXPR]);
+  }
+};
+
 }  // end namespace clang
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/AST/OpenMPClause.h cfe-3.5.0.src.omp/include/clang/AST/OpenMPClause.h
--- cfe-3.5.0.src/include/clang/AST/OpenMPClause.h	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/AST/OpenMPClause.h	2014-11-28 10:49:29.000000000 -0500
@@ -17,6 +17,7 @@
 #define LLVM_CLANG_AST_OPENMPCLAUSE_H
 
 #include "clang/AST/Expr.h"
+#include "clang/AST/PrettyPrinter.h"
 #include "clang/AST/Stmt.h"
 #include "clang/Basic/OpenMPKinds.h"
 #include "clang/Basic/SourceLocation.h"
@@ -30,7 +31,7 @@
 /// \brief This is a basic class for representing single OpenMP clause.
 ///
 class OMPClause {
-  /// \brief Starting location of the clause (the clause keyword).
+  /// \brief Starting location of the clause.
   SourceLocation StartLoc;
   /// \brief Ending location of the clause.
   SourceLocation EndLoc;
@@ -42,9 +43,9 @@
       : StartLoc(StartLoc), EndLoc(EndLoc), Kind(K) {}
 
 public:
-  /// \brief Returns the starting location of the clause.
+  /// \brief Fetches the starting location of the clause.
   SourceLocation getLocStart() const { return StartLoc; }
-  /// \brief Returns the ending location of the clause.
+  /// \brief Fetches the ending location of the clause.
   SourceLocation getLocEnd() const { return EndLoc; }
 
   /// \brief Sets the starting location of the clause.
@@ -52,63 +53,62 @@
   /// \brief Sets the ending location of the clause.
   void setLocEnd(SourceLocation Loc) { EndLoc = Loc; }
 
-  /// \brief Returns kind of OpenMP clause (private, shared, reduction, etc.).
+  /// \brief Fetches kind of OpenMP clause (private, shared, reduction, etc.).
   OpenMPClauseKind getClauseKind() const { return Kind; }
 
-  bool isImplicit() const { return StartLoc.isInvalid(); }
+  static bool classof(const OMPClause *) { return true; }
+
+  bool isImplicit() { return StartLoc.isInvalid(); }
 
   StmtRange children();
   ConstStmtRange children() const {
     return const_cast<OMPClause *>(this)->children();
   }
-  static bool classof(const OMPClause *T) { return true; }
+
+  /// \brief Prints the clause using OMPClausePrinter
+  void printPretty(raw_ostream &OS, PrinterHelper *Helper,
+                   const PrintingPolicy &Policy, unsigned Indentation) const;
 };
 
 /// \brief This represents clauses with the list of variables like 'private',
-/// 'firstprivate', 'copyin', 'shared', or 'reduction' clauses in the
+/// 'firstprivate', 'copyin', 'shared', 'reduction' or 'flush' clauses in the
 /// '#pragma omp ...' directives.
 template <class T> class OMPVarListClause : public OMPClause {
   friend class OMPClauseReader;
-  /// \brief Location of '('.
-  SourceLocation LParenLoc;
+  friend class TemplateDeclInstantiator;
   /// \brief Number of variables in the list.
   unsigned NumVars;
 
 protected:
-  /// \brief Fetches list of variables associated with this clause.
-  MutableArrayRef<Expr *> getVarRefs() {
-    return MutableArrayRef<Expr *>(
+  /// \brief Fetches the list of variables associated with this clause.
+  llvm::MutableArrayRef<Expr *> getVars() {
+    return llvm::MutableArrayRef<Expr *>(
         reinterpret_cast<Expr **>(
             reinterpret_cast<char *>(this) +
-            llvm::RoundUpToAlignment(sizeof(T), llvm::alignOf<Expr *>())),
+            llvm::RoundUpToAlignment(sizeof(T), sizeof(Expr *))),
         NumVars);
   }
 
   /// \brief Sets the list of variables for this clause.
-  void setVarRefs(ArrayRef<Expr *> VL) {
+  void setVars(ArrayRef<Expr *> VL) {
     assert(VL.size() == NumVars &&
            "Number of variables is not the same as the preallocated buffer");
-    std::copy(
-        VL.begin(), VL.end(),
-        reinterpret_cast<Expr **>(
-            reinterpret_cast<char *>(this) +
-            llvm::RoundUpToAlignment(sizeof(T), llvm::alignOf<Expr *>())));
+    std::copy(VL.begin(), VL.end(),
+              reinterpret_cast<Expr **>(
+                  reinterpret_cast<char *>(this) +
+                  llvm::RoundUpToAlignment(sizeof(T), sizeof(Expr *))));
   }
 
-  /// \brief Build a clause with \a N variables
+  /// \brief Build clause with number of variables \a N.
   ///
-  /// \param K Kind of the clause.
-  /// \param StartLoc Starting location of the clause (the clause keyword).
-  /// \param LParenLoc Location of '('.
-  /// \param EndLoc Ending location of the clause.
   /// \param N Number of the variables in the clause.
   ///
   OMPVarListClause(OpenMPClauseKind K, SourceLocation StartLoc,
-                   SourceLocation LParenLoc, SourceLocation EndLoc, unsigned N)
-      : OMPClause(K, StartLoc, EndLoc), LParenLoc(LParenLoc), NumVars(N) {}
+                   SourceLocation EndLoc, unsigned N)
+      : OMPClause(K, StartLoc, EndLoc), NumVars(N) {}
 
 public:
-  typedef MutableArrayRef<Expr *>::iterator varlist_iterator;
+  typedef llvm::MutableArrayRef<Expr *>::iterator varlist_iterator;
   typedef ArrayRef<const Expr *>::iterator varlist_const_iterator;
   typedef llvm::iterator_range<varlist_iterator> varlist_range;
   typedef llvm::iterator_range<varlist_const_iterator> varlist_const_range;
@@ -116,6 +116,7 @@
   unsigned varlist_size() const { return NumVars; }
   bool varlist_empty() const { return NumVars == 0; }
 
+  varlist_iterator varlist_begin() { return getVars().begin(); }
   varlist_range varlists() {
     return varlist_range(varlist_begin(), varlist_end());
   }
@@ -123,22 +124,17 @@
     return varlist_const_range(varlist_begin(), varlist_end());
   }
 
-  varlist_iterator varlist_begin() { return getVarRefs().begin(); }
-  varlist_iterator varlist_end() { return getVarRefs().end(); }
-  varlist_const_iterator varlist_begin() const { return getVarRefs().begin(); }
-  varlist_const_iterator varlist_end() const { return getVarRefs().end(); }
-
-  /// \brief Sets the location of '('.
-  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }
-  /// \brief Returns the location of '('.
-  SourceLocation getLParenLoc() const { return LParenLoc; }
+  varlist_iterator varlist_end() { return getVars().end(); }
+  varlist_const_iterator varlist_begin() const { return getVars().begin(); }
+  varlist_const_iterator varlist_end() const { return getVars().end(); }
+  unsigned numberOfVariables() const { return NumVars; }
 
-  /// \brief Fetches list of all variables in the clause.
-  ArrayRef<const Expr *> getVarRefs() const {
+  /// \brief Return the list of all variables in the clause.
+  ArrayRef<const Expr *> getVars() const {
     return ArrayRef<const Expr *>(
         reinterpret_cast<const Expr *const *>(
             reinterpret_cast<const char *>(this) +
-            llvm::RoundUpToAlignment(sizeof(T), llvm::alignOf<Expr *>())),
+            llvm::RoundUpToAlignment(sizeof(T), sizeof(Expr *))),
         NumVars);
   }
 };
@@ -146,48 +142,41 @@
 /// \brief This represents 'if' clause in the '#pragma omp ...' directive.
 ///
 /// \code
-/// #pragma omp parallel if(a > 5)
+/// #pragma omp parallel if(a)
 /// \endcode
-/// In this example directive '#pragma omp parallel' has simple 'if'
-/// clause with condition 'a > 5'.
+/// In this example directive '#pragma omp parallel' has clause 'if' with
+/// single expression 'a'.
 ///
 class OMPIfClause : public OMPClause {
   friend class OMPClauseReader;
-  /// \brief Location of '('.
-  SourceLocation LParenLoc;
-  /// \brief Condition of the 'if' clause.
+  /// \brief Clause condition.
   Stmt *Condition;
-
-  /// \brief Set condition.
+  /// \brief Set the condition.
   ///
-  void setCondition(Expr *Cond) { Condition = Cond; }
+  /// \param E New condition.
+  ///
+  void setCondition(Expr *E) { Condition = E; }
 
 public:
-  /// \brief Build 'if' clause with condition \a Cond.
+  /// \brief Build 'if' clause.
   ///
+  /// \param E Expression associated with this clause.
   /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param Cond Condition of the clause.
   /// \param EndLoc Ending location of the clause.
   ///
-  OMPIfClause(Expr *Cond, SourceLocation StartLoc, SourceLocation LParenLoc,
-              SourceLocation EndLoc)
-      : OMPClause(OMPC_if, StartLoc, EndLoc), LParenLoc(LParenLoc),
-        Condition(Cond) {}
+  OMPIfClause(Expr *E, SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_if, StartLoc, EndLoc), Condition(E) {}
 
   /// \brief Build an empty clause.
   ///
-  OMPIfClause()
-      : OMPClause(OMPC_if, SourceLocation(), SourceLocation()),
-        LParenLoc(SourceLocation()), Condition(nullptr) {}
+  explicit OMPIfClause()
+      : OMPClause(OMPC_if, SourceLocation(), SourceLocation()), Condition(0) {}
 
-  /// \brief Sets the location of '('.
-  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }
-  /// \brief Returns the location of '('.
-  SourceLocation getLParenLoc() const { return LParenLoc; }
+  /// \brief Return condition.
+  Expr *getCondition() { return dyn_cast_or_null<Expr>(Condition); }
 
-  /// \brief Returns condition.
-  Expr *getCondition() const { return cast_or_null<Expr>(Condition); }
+  /// \brief Return condition.
+  Expr *getCondition() const { return dyn_cast_or_null<Expr>(Condition); }
 
   static bool classof(const OMPClause *T) {
     return T->getClauseKind() == OMPC_if;
@@ -199,48 +188,41 @@
 /// \brief This represents 'final' clause in the '#pragma omp ...' directive.
 ///
 /// \code
-/// #pragma omp task final(a > 5)
+/// #pragma omp task final(a)
 /// \endcode
-/// In this example directive '#pragma omp task' has simple 'final'
-/// clause with condition 'a > 5'.
+/// In this example directive '#pragma omp task' has clause 'final' with
+/// single expression 'a'.
 ///
 class OMPFinalClause : public OMPClause {
   friend class OMPClauseReader;
-  /// \brief Location of '('.
-  SourceLocation LParenLoc;
-  /// \brief Condition of the 'if' clause.
+  /// \brief Clause condition.
   Stmt *Condition;
-
-  /// \brief Set condition.
+  /// \brief Set the condition.
   ///
-  void setCondition(Expr *Cond) { Condition = Cond; }
+  /// \param E New condition.
+  ///
+  void setCondition(Expr *E) { Condition = E; }
 
 public:
-  /// \brief Build 'final' clause with condition \a Cond.
+  /// \brief Build 'if' clause.
   ///
+  /// \param E Expression associated with this clause.
   /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param Cond Condition of the clause.
   /// \param EndLoc Ending location of the clause.
   ///
-  OMPFinalClause(Expr *Cond, SourceLocation StartLoc, SourceLocation LParenLoc,
-                 SourceLocation EndLoc)
-      : OMPClause(OMPC_final, StartLoc, EndLoc), LParenLoc(LParenLoc),
-        Condition(Cond) {}
+  OMPFinalClause(Expr *E, SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_final, StartLoc, EndLoc), Condition(E) {}
 
   /// \brief Build an empty clause.
   ///
-  OMPFinalClause()
+  explicit OMPFinalClause()
       : OMPClause(OMPC_final, SourceLocation(), SourceLocation()),
-        LParenLoc(SourceLocation()), Condition(nullptr) {}
-
-  /// \brief Sets the location of '('.
-  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }
-  /// \brief Returns the location of '('.
-  SourceLocation getLParenLoc() const { return LParenLoc; }
+        Condition(0) {}
 
-  /// \brief Returns condition.
-  Expr *getCondition() const { return cast_or_null<Expr>(Condition); }
+  /// \brief Return condition.
+  Expr *getCondition() { return dyn_cast_or_null<Expr>(Condition); }
+  /// \brief Return condition.
+  Expr *getCondition() const { return dyn_cast_or_null<Expr>(Condition); }
 
   static bool classof(const OMPClause *T) {
     return T->getClauseKind() == OMPC_final;
@@ -253,48 +235,42 @@
 /// directive.
 ///
 /// \code
-/// #pragma omp parallel num_threads(6)
+/// #pragma omp parallel num_threads(a)
 /// \endcode
-/// In this example directive '#pragma omp parallel' has simple 'num_threads'
-/// clause with number of threads '6'.
+/// In this example directive '#pragma omp parallel' has clause 'num_threads'
+/// with single expression 'a'.
 ///
 class OMPNumThreadsClause : public OMPClause {
   friend class OMPClauseReader;
-  /// \brief Location of '('.
-  SourceLocation LParenLoc;
-  /// \brief Condition of the 'num_threads' clause.
+  /// \brief Number of threads.
   Stmt *NumThreads;
-
-  /// \brief Set condition.
+  /// \brief Set the number of threads.
+  ///
+  /// \param E Number of threads.
   ///
-  void setNumThreads(Expr *NThreads) { NumThreads = NThreads; }
+  void setNumThreads(Expr *E) { NumThreads = E; }
 
 public:
-  /// \brief Build 'num_threads' clause with condition \a NumThreads.
+  /// \brief Build 'num_threads' clause.
   ///
-  /// \param NumThreads Number of threads for the construct.
+  /// \param E Expression associated with this clause.
   /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
   /// \param EndLoc Ending location of the clause.
   ///
-  OMPNumThreadsClause(Expr *NumThreads, SourceLocation StartLoc,
-                      SourceLocation LParenLoc, SourceLocation EndLoc)
-      : OMPClause(OMPC_num_threads, StartLoc, EndLoc), LParenLoc(LParenLoc),
-        NumThreads(NumThreads) {}
+  OMPNumThreadsClause(Expr *E, SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_num_threads, StartLoc, EndLoc), NumThreads(E) {}
 
   /// \brief Build an empty clause.
   ///
-  OMPNumThreadsClause()
+  explicit OMPNumThreadsClause()
       : OMPClause(OMPC_num_threads, SourceLocation(), SourceLocation()),
-        LParenLoc(SourceLocation()), NumThreads(nullptr) {}
+        NumThreads(0) {}
 
-  /// \brief Sets the location of '('.
-  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }
-  /// \brief Returns the location of '('.
-  SourceLocation getLParenLoc() const { return LParenLoc; }
+  /// \brief Return number of threads.
+  Expr *getNumThreads() { return dyn_cast_or_null<Expr>(NumThreads); }
 
-  /// \brief Returns number of threads.
-  Expr *getNumThreads() const { return cast_or_null<Expr>(NumThreads); }
+  /// \brief Return number of threads.
+  Expr *getNumThreads() const { return dyn_cast_or_null<Expr>(NumThreads); }
 
   static bool classof(const OMPClause *T) {
     return T->getClauseKind() == OMPC_num_threads;
@@ -303,116 +279,97 @@
   StmtRange children() { return StmtRange(&NumThreads, &NumThreads + 1); }
 };
 
-/// \brief This represents 'safelen' clause in the '#pragma omp ...'
+/// \brief This represents 'collapse' clause in the '#pragma omp ...'
 /// directive.
 ///
 /// \code
-/// #pragma omp simd safelen(4)
+/// #pragma omp for collapse(3)
 /// \endcode
-/// In this example directive '#pragma omp simd' has clause 'safelen'
-/// with single expression '4'.
-/// If the safelen clause is used then no two iterations executed
-/// concurrently with SIMD instructions can have a greater distance
-/// in the logical iteration space than its value. The parameter of
-/// the safelen clause must be a constant positive integer expression.
+/// In this example directive '#pragma omp for' has clause 'collapse'
+/// with single expression '3'.
 ///
-class OMPSafelenClause : public OMPClause {
+class OMPCollapseClause : public OMPClause {
   friend class OMPClauseReader;
-  /// \brief Location of '('.
-  SourceLocation LParenLoc;
-  /// \brief Safe iteration space distance.
-  Stmt *Safelen;
-
-  /// \brief Set safelen.
-  void setSafelen(Expr *Len) { Safelen = Len; }
+  /// \brief Number of for-loops.
+  Stmt *NumForLoops;
+  /// \brief Set the number of associated for-loops.
+  ///
+  /// \param E Number of for-loops.
+  ///
+  void setNumForLoops(Expr *E) { NumForLoops = E; }
 
 public:
-  /// \brief Build 'safelen' clause.
+  /// \brief Build 'collapse' clause.
   ///
-  /// \param Len Expression associated with this clause.
+  /// \param E Expression associated with this clause.
   /// \param StartLoc Starting location of the clause.
   /// \param EndLoc Ending location of the clause.
   ///
-  OMPSafelenClause(Expr *Len, SourceLocation StartLoc, SourceLocation LParenLoc,
-                   SourceLocation EndLoc)
-      : OMPClause(OMPC_safelen, StartLoc, EndLoc), LParenLoc(LParenLoc),
-        Safelen(Len) {}
+  OMPCollapseClause(Expr *E, SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_collapse, StartLoc, EndLoc), NumForLoops(E) {}
 
   /// \brief Build an empty clause.
   ///
-  explicit OMPSafelenClause()
-      : OMPClause(OMPC_safelen, SourceLocation(), SourceLocation()),
-        LParenLoc(SourceLocation()), Safelen(nullptr) {}
-
-  /// \brief Sets the location of '('.
-  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }
-  /// \brief Returns the location of '('.
-  SourceLocation getLParenLoc() const { return LParenLoc; }
+  explicit OMPCollapseClause()
+      : OMPClause(OMPC_collapse, SourceLocation(), SourceLocation()),
+        NumForLoops(0) {}
 
-  /// \brief Return safe iteration space distance.
-  Expr *getSafelen() const { return cast_or_null<Expr>(Safelen); }
+  /// \brief Return number of associated for-loops.
+  ///
+  Expr *getNumForLoops() { return dyn_cast_or_null<Expr>(NumForLoops); }
 
   static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_safelen;
+    return T->getClauseKind() == OMPC_collapse;
   }
 
-  StmtRange children() { return StmtRange(&Safelen, &Safelen + 1); }
+  StmtRange children() { return StmtRange(&NumForLoops, &NumForLoops + 1); }
 };
 
-/// \brief This represents 'collapse' clause in the '#pragma omp ...'
+/// \brief This represents 'device' clause in the '#pragma omp ...'
 /// directive.
 ///
 /// \code
-/// #pragma omp simd collapse(3)
+/// #pragma omp target device(a)
 /// \endcode
-/// In this example directive '#pragma omp simd' has clause 'collapse'
-/// with single expression '3'.
-/// The parameter must be a constant positive integer expression, it specifies
-/// the number of nested loops that should be collapsed into a single iteration
-/// space.
+/// In this example directive '#pragma omp target' has clause 'device'
+/// with single expression 'a'.
 ///
-class OMPCollapseClause : public OMPClause {
+class OMPDeviceClause : public OMPClause {
   friend class OMPClauseReader;
-  /// \brief Location of '('.
-  SourceLocation LParenLoc;
-  /// \brief Number of for-loops.
-  Stmt *NumForLoops;
-
-  /// \brief Set the number of associated for-loops.
-  void setNumForLoops(Expr *Num) { NumForLoops = Num; }
+  /// \brief Device number.
+  Stmt *Device;
+  /// \brief Set the device number.
+  ///
+  /// \param E Device number.
+  ///
+  void setDevice(Expr *E) { Device = E; }
 
 public:
-  /// \brief Build 'collapse' clause.
+  /// \brief Build 'device' clause.
   ///
-  /// \param Num Expression associated with this clause.
+  /// \param E Expression associated with this clause.
   /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
   /// \param EndLoc Ending location of the clause.
   ///
-  OMPCollapseClause(Expr *Num, SourceLocation StartLoc,
-                    SourceLocation LParenLoc, SourceLocation EndLoc)
-      : OMPClause(OMPC_collapse, StartLoc, EndLoc), LParenLoc(LParenLoc),
-        NumForLoops(Num) {}
+  OMPDeviceClause(Expr *E, SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_device, StartLoc, EndLoc), Device(E) {}
 
   /// \brief Build an empty clause.
   ///
-  explicit OMPCollapseClause()
-      : OMPClause(OMPC_collapse, SourceLocation(), SourceLocation()),
-        LParenLoc(SourceLocation()), NumForLoops(nullptr) {}
+  OMPDeviceClause()
+      : OMPClause(OMPC_device, SourceLocation(), SourceLocation()), Device(0) {}
 
-  /// \brief Sets the location of '('.
-  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }
-  /// \brief Returns the location of '('.
-  SourceLocation getLParenLoc() const { return LParenLoc; }
+  /// \brief Return device number.
+  Expr *getDevice() { return dyn_cast_or_null<Expr>(Device); }
 
-  /// \brief Return the number of associated for-loops.
-  Expr *getNumForLoops() const { return cast_or_null<Expr>(NumForLoops); }
+  /// \brief Return device number.
+  Expr *getDevice() const { return dyn_cast_or_null<Expr>(Device); }
 
   static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_collapse;
+    return T->getClauseKind() == OMPC_device;
   }
 
-  StmtRange children() { return StmtRange(&NumForLoops, &NumForLoops + 1); }
+  StmtRange children() { return StmtRange(&Device, &Device + 1); }
 };
 
 /// \brief This represents 'default' clause in the '#pragma omp ...' directive.
@@ -425,12 +382,10 @@
 ///
 class OMPDefaultClause : public OMPClause {
   friend class OMPClauseReader;
-  /// \brief Location of '('.
-  SourceLocation LParenLoc;
   /// \brief A kind of the 'default' clause.
   OpenMPDefaultClauseKind Kind;
-  /// \brief Start location of the kind in source code.
-  SourceLocation KindKwLoc;
+  /// \brief Start location of the kind in cource code.
+  SourceLocation KindLoc;
 
   /// \brief Set kind of the clauses.
   ///
@@ -442,40 +397,33 @@
   ///
   /// \param KLoc Argument location.
   ///
-  void setDefaultKindKwLoc(SourceLocation KLoc) { KindKwLoc = KLoc; }
+  void setDefaultKindLoc(SourceLocation KLoc) { KindLoc = KLoc; }
 
 public:
   /// \brief Build 'default' clause with argument \a A ('none' or 'shared').
   ///
-  /// \param A Argument of the clause ('none' or 'shared').
-  /// \param ALoc Starting location of the argument.
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param EndLoc Ending location of the clause.
+  /// \brief A Argument of the clause ('none' or 'shared').
+  /// \brief ALoc Starting location of the argument.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
   ///
   OMPDefaultClause(OpenMPDefaultClauseKind A, SourceLocation ALoc,
-                   SourceLocation StartLoc, SourceLocation LParenLoc,
-                   SourceLocation EndLoc)
-      : OMPClause(OMPC_default, StartLoc, EndLoc), LParenLoc(LParenLoc),
-        Kind(A), KindKwLoc(ALoc) {}
+                   SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_default, StartLoc, EndLoc), Kind(A), KindLoc(ALoc) {}
 
   /// \brief Build an empty clause.
   ///
-  OMPDefaultClause()
+  explicit OMPDefaultClause()
       : OMPClause(OMPC_default, SourceLocation(), SourceLocation()),
-        LParenLoc(SourceLocation()), Kind(OMPC_DEFAULT_unknown),
-        KindKwLoc(SourceLocation()) {}
+        Kind(OMPC_DEFAULT_unknown), KindLoc(SourceLocation()) {}
 
-  /// \brief Sets the location of '('.
-  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }
-  /// \brief Returns the location of '('.
-  SourceLocation getLParenLoc() const { return LParenLoc; }
-
-  /// \brief Returns kind of the clause.
+  /// \brief Fetches kind of the clause.
+  ///
   OpenMPDefaultClauseKind getDefaultKind() const { return Kind; }
 
-  /// \brief Returns location of clause kind.
-  SourceLocation getDefaultKindKwLoc() const { return KindKwLoc; }
+  /// \brief Fetches location of clause kind.
+  ///
+  SourceLocation getDefaultKindLoc() const { return KindLoc; }
 
   static bool classof(const OMPClause *T) {
     return T->getClauseKind() == OMPC_default;
@@ -491,62 +439,55 @@
 /// #pragma omp parallel proc_bind(master)
 /// \endcode
 /// In this example directive '#pragma omp parallel' has simple 'proc_bind'
-/// clause with kind 'master'.
+/// clause with thread affinity 'master'.
 ///
 class OMPProcBindClause : public OMPClause {
   friend class OMPClauseReader;
-  /// \brief Location of '('.
-  SourceLocation LParenLoc;
-  /// \brief A kind of the 'proc_bind' clause.
-  OpenMPProcBindClauseKind Kind;
-  /// \brief Start location of the kind in source code.
-  SourceLocation KindKwLoc;
+  /// \brief Thread affinity defined in 'proc_bind' clause.
+  OpenMPProcBindClauseKind ThreadAffinity;
+  /// \brief Start location of the thread affinity in source code.
+  SourceLocation ThreadAffinityLoc;
 
-  /// \brief Set kind of the clause.
+  /// \brief Set thread affinity of the clauses.
   ///
-  /// \param K Kind of clause.
+  /// \param K Argument of clause.
   ///
-  void setProcBindKind(OpenMPProcBindClauseKind K) { Kind = K; }
+  void setThreadAffinity(OpenMPProcBindClauseKind K) { ThreadAffinity = K; }
 
-  /// \brief Set clause kind location.
+  /// \brief Set argument location.
   ///
-  /// \param KLoc Kind location.
+  /// \param KLoc Argument location.
   ///
-  void setProcBindKindKwLoc(SourceLocation KLoc) { KindKwLoc = KLoc; }
+  void setThreadAffinityLoc(SourceLocation KLoc) { ThreadAffinityLoc = KLoc; }
 
 public:
   /// \brief Build 'proc_bind' clause with argument \a A ('master', 'close' or
-  ///        'spread').
+  /// 'spread').
   ///
-  /// \param A Argument of the clause ('master', 'close' or 'spread').
-  /// \param ALoc Starting location of the argument.
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param EndLoc Ending location of the clause.
+  /// \brief A Argument of the clause ('master', 'close' or 'spread').
+  /// \brief ALoc Starting location of the argument.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
   ///
   OMPProcBindClause(OpenMPProcBindClauseKind A, SourceLocation ALoc,
-                    SourceLocation StartLoc, SourceLocation LParenLoc,
-                    SourceLocation EndLoc)
-      : OMPClause(OMPC_proc_bind, StartLoc, EndLoc), LParenLoc(LParenLoc),
-        Kind(A), KindKwLoc(ALoc) {}
+                    SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_proc_bind, StartLoc, EndLoc), ThreadAffinity(A),
+        ThreadAffinityLoc(ALoc) {}
 
   /// \brief Build an empty clause.
   ///
-  OMPProcBindClause()
+  explicit OMPProcBindClause()
       : OMPClause(OMPC_proc_bind, SourceLocation(), SourceLocation()),
-        LParenLoc(SourceLocation()), Kind(OMPC_PROC_BIND_unknown),
-        KindKwLoc(SourceLocation()) {}
-
-  /// \brief Sets the location of '('.
-  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }
-  /// \brief Returns the location of '('.
-  SourceLocation getLParenLoc() const { return LParenLoc; }
+        ThreadAffinity(OMPC_PROC_BIND_unknown),
+        ThreadAffinityLoc(SourceLocation()) {}
 
-  /// \brief Returns kind of the clause.
-  OpenMPProcBindClauseKind getProcBindKind() const { return Kind; }
+  /// \brief Fetches thread affinity.
+  ///
+  OpenMPProcBindClauseKind getThreadAffinity() const { return ThreadAffinity; }
 
-  /// \brief Returns location of clause kind.
-  SourceLocation getProcBindKindKwLoc() const { return KindKwLoc; }
+  /// \brief Fetches location of clause kind.
+  ///
+  SourceLocation getThreadAffinityLoc() const { return ThreadAffinityLoc; }
 
   static bool classof(const OMPClause *T) {
     return T->getClauseKind() == OMPC_proc_bind;
@@ -555,456 +496,527 @@
   StmtRange children() { return StmtRange(); }
 };
 
-/// \brief This represents 'schedule' clause in the '#pragma omp ...' directive.
+/// \brief This represents clause 'private' in the '#pragma omp ...' directives.
 ///
 /// \code
-/// #pragma omp for schedule(static, 3)
+/// #pragma omp parallel private(a,b)
 /// \endcode
-/// In this example directive '#pragma omp for' has 'schedule' clause with
-/// arguments 'static' and '3'.
+/// In this example directive '#pragma omp parallel' has clause 'private'
+/// with the variables 'a' and 'b'.
 ///
-class OMPScheduleClause : public OMPClause {
+class OMPPrivateClause : public OMPVarListClause<OMPPrivateClause> {
   friend class OMPClauseReader;
-  /// \brief Location of '('.
-  SourceLocation LParenLoc;
-  /// \brief A kind of the 'schedule' clause.
-  OpenMPScheduleClauseKind Kind;
-  /// \brief Start location of the schedule ind in source code.
-  SourceLocation KindLoc;
-  /// \brief Location of ',' (if any).
-  SourceLocation CommaLoc;
-  /// \brief Chunk size.
-  Stmt *ChunkSize;
-
-  /// \brief Set schedule kind.
-  ///
-  /// \param K Schedule kind.
-  ///
-  void setScheduleKind(OpenMPScheduleClauseKind K) { Kind = K; }
-  /// \brief Sets the location of '('.
-  ///
-  /// \param Loc Location of '('.
-  ///
-  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }
-  /// \brief Set schedule kind start location.
-  ///
-  /// \param KLoc Schedule kind location.
-  ///
-  void setScheduleKindLoc(SourceLocation KLoc) { KindLoc = KLoc; }
-  /// \brief Set location of ','.
+  friend class OMPClauseWriter;
+  /// \brief Build clause with number of variables \a N.
   ///
-  /// \param Loc Location of ','.
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  /// \param N Number of the variables in the clause.
   ///
-  void setCommaLoc(SourceLocation Loc) { CommaLoc = Loc; }
-  /// \brief Set chunk size.
+  OMPPrivateClause(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N)
+      : OMPVarListClause<OMPPrivateClause>(OMPC_private, StartLoc, EndLoc, N) {}
+
+  /// \brief Build an empty clause.
   ///
-  /// \param E Chunk size.
+  /// \param N Number of variables.
   ///
-  void setChunkSize(Expr *E) { ChunkSize = E; }
+  explicit OMPPrivateClause(unsigned N)
+      : OMPVarListClause<OMPPrivateClause>(OMPC_private, SourceLocation(),
+                                           SourceLocation(), N) {}
 
-public:
-  /// \brief Build 'schedule' clause with schedule kind \a Kind and chunk size
-  /// expression \a ChunkSize.
-  ///
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param KLoc Starting location of the argument.
-  /// \param CommaLoc Location of ','.
-  /// \param EndLoc Ending location of the clause.
-  /// \param Kind Schedule kind.
-  /// \param ChunkSize Chunk size.
-  ///
-  OMPScheduleClause(SourceLocation StartLoc, SourceLocation LParenLoc,
-                    SourceLocation KLoc, SourceLocation CommaLoc,
-                    SourceLocation EndLoc, OpenMPScheduleClauseKind Kind,
-                    Expr *ChunkSize)
-      : OMPClause(OMPC_schedule, StartLoc, EndLoc), LParenLoc(LParenLoc),
-        Kind(Kind), KindLoc(KLoc), CommaLoc(CommaLoc), ChunkSize(ChunkSize) {}
+  /// \brief Sets the list of generated default inits.
+  void setDefaultInits(ArrayRef<Expr *> DefaultInits);
 
-  /// \brief Build an empty clause.
-  ///
-  explicit OMPScheduleClause()
-      : OMPClause(OMPC_schedule, SourceLocation(), SourceLocation()),
-        Kind(OMPC_SCHEDULE_unknown), ChunkSize(nullptr) {}
+  /// \brief Return the list of all generated expressions.
+  llvm::MutableArrayRef<Expr *> getDefaultInits() {
+    return llvm::MutableArrayRef<Expr *>(varlist_end(), numberOfVariables());
+  }
 
-  /// \brief Get kind of the clause.
-  ///
-  OpenMPScheduleClauseKind getScheduleKind() const { return Kind; }
-  /// \brief Get location of '('.
-  ///
-  SourceLocation getLParenLoc() { return LParenLoc; }
-  /// \brief Get kind location.
+public:
+  /// \brief Creates clause with a list of variables \a VL.
   ///
-  SourceLocation getScheduleKindLoc() { return KindLoc; }
-  /// \brief Get location of ','.
+  /// \param C AST context.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
+  /// \param VL List of references to the variables.
   ///
-  SourceLocation getCommaLoc() { return CommaLoc; }
-  /// \brief Get chunk size.
+  static OMPPrivateClause *Create(const ASTContext &C, SourceLocation StartLoc,
+                                  SourceLocation EndLoc, ArrayRef<Expr *> VL,
+                                  ArrayRef<Expr *> DefaultInits);
+  /// \brief Creates an empty clause with the place for \a N variables.
   ///
-  Expr *getChunkSize() { return dyn_cast_or_null<Expr>(ChunkSize); }
-  /// \brief Get chunk size.
+  /// \param C AST context.
+  /// \param N The number of variables.
   ///
-  Expr *getChunkSize() const { return dyn_cast_or_null<Expr>(ChunkSize); }
+  static OMPPrivateClause *CreateEmpty(const ASTContext &C, unsigned N);
 
   static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_schedule;
+    return T->getClauseKind() == OMPC_private;
   }
 
-  StmtRange children() { return StmtRange(&ChunkSize, &ChunkSize + 1); }
+  /// \brief Return the list of all default initializations.
+  ArrayRef<const Expr *> getDefaultInits() const {
+    return llvm::makeArrayRef(varlist_end(), numberOfVariables());
+  }
+
+  StmtRange children() {
+    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
+                     reinterpret_cast<Stmt **>(getDefaultInits().end()));
+  }
 };
 
-/// \brief This represents 'ordered' clause in the '#pragma omp ...' directive.
+/// \brief This represents clause 'firstprivate' in the '#pragma omp ...'
+/// directives.
 ///
 /// \code
-/// #pragma omp for ordered
+/// #pragma omp parallel firstprivate(a,b)
 /// \endcode
-/// In this example directive '#pragma omp for' has 'ordered' clause.
+/// In this example directive '#pragma omp parallel' has clause 'firstprivate'
+/// with the variables 'a' and 'b'.
 ///
-class OMPOrderedClause : public OMPClause {
-public:
-  /// \brief Build 'ordered' clause.
+class OMPFirstPrivateClause : public OMPVarListClause<OMPFirstPrivateClause> {
+  friend class OMPClauseReader;
+  friend class OMPClauseWriter;
+  /// \brief Build clause with number of variables \a N.
   ///
   /// \param StartLoc Starting location of the clause.
   /// \param EndLoc Ending location of the clause.
+  /// \param N Number of the variables in the clause.
   ///
-  OMPOrderedClause(SourceLocation StartLoc, SourceLocation EndLoc)
-      : OMPClause(OMPC_ordered, StartLoc, EndLoc) {}
+  OMPFirstPrivateClause(SourceLocation StartLoc, SourceLocation EndLoc,
+                        unsigned N)
+      : OMPVarListClause<OMPFirstPrivateClause>(OMPC_firstprivate, StartLoc,
+                                                EndLoc, N) {}
 
   /// \brief Build an empty clause.
   ///
-  OMPOrderedClause()
-      : OMPClause(OMPC_ordered, SourceLocation(), SourceLocation()) {}
+  /// \param N Number of variables.
+  ///
+  explicit OMPFirstPrivateClause(unsigned N)
+      : OMPVarListClause<OMPFirstPrivateClause>(
+            OMPC_firstprivate, SourceLocation(), SourceLocation(), N) {}
 
-  static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_ordered;
+  /// \brief Sets the list of pseudo vars.
+  void setPseudoVars(ArrayRef<DeclRefExpr *> PseudoVars);
+
+  /// \brief Return the list of pseudo vars.
+  llvm::MutableArrayRef<Expr *> getPseudoVars() {
+    return llvm::MutableArrayRef<Expr *>(varlist_end(), numberOfVariables());
   }
 
-  StmtRange children() { return StmtRange(); }
-};
+  /// \brief Sets the list of generated inits.
+  void setInits(ArrayRef<Expr *> Inits);
+
+  /// \brief Return the list of all inits.
+  llvm::MutableArrayRef<Expr *> getInits() {
+    return llvm::MutableArrayRef<Expr *>(getPseudoVars().end(),
+                                         numberOfVariables());
+  }
 
-/// \brief This represents 'nowait' clause in the '#pragma omp ...' directive.
-///
-/// \code
-/// #pragma omp for nowait
-/// \endcode
-/// In this example directive '#pragma omp for' has 'nowait' clause.
-///
-class OMPNowaitClause : public OMPClause {
 public:
-  /// \brief Build 'nowait' clause.
+  /// \brief Creates clause with a list of variables \a VL.
   ///
-  /// \param StartLoc Starting location of the clause.
-  /// \param EndLoc Ending location of the clause.
+  /// \param C AST context.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
+  /// \param VL List of references to the variables.
   ///
-  OMPNowaitClause(SourceLocation StartLoc, SourceLocation EndLoc)
-      : OMPClause(OMPC_nowait, StartLoc, EndLoc) {}
-
-  /// \brief Build an empty clause.
+  static OMPFirstPrivateClause *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<Expr *> VL, ArrayRef<DeclRefExpr *> PseudoVars,
+         ArrayRef<Expr *> Inits);
+  /// \brief Creates an empty clause with the place for \a N variables.
   ///
-  OMPNowaitClause()
-      : OMPClause(OMPC_nowait, SourceLocation(), SourceLocation()) {}
+  /// \param C AST context.
+  /// \param N The number of variables.
+  ///
+  static OMPFirstPrivateClause *CreateEmpty(const ASTContext &C, unsigned N);
 
   static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_nowait;
+    return T->getClauseKind() == OMPC_firstprivate;
   }
 
-  StmtRange children() { return StmtRange(); }
+  /// \brief Return the list of pseudo vars.
+  ArrayRef<const Expr *> getPseudoVars() const {
+    return llvm::makeArrayRef(varlist_end(), numberOfVariables());
+  }
+
+  /// \brief Return the list of all initializations.
+  ArrayRef<const Expr *> getInits() const {
+    return llvm::makeArrayRef(getPseudoVars().end(), numberOfVariables());
+  }
+
+  StmtRange children() {
+    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
+                     reinterpret_cast<Stmt **>(getInits().end()));
+  }
 };
 
-/// \brief This represents 'untied' clause in the '#pragma omp ...' directive.
+/// \brief This represents clause 'lastprivate' in the '#pragma omp ...'
+/// directives.
 ///
 /// \code
-/// #pragma omp task untied
+/// #pragma omp for lastprivate(a,b)
 /// \endcode
-/// In this example directive '#pragma omp task' has 'untied' clause.
+/// In this example directive '#pragma omp for' has clause 'lastprivate'
+/// with the variables 'a' and 'b'.
 ///
-class OMPUntiedClause : public OMPClause {
-public:
-  /// \brief Build 'untied' clause.
+class OMPLastPrivateClause : public OMPVarListClause<OMPLastPrivateClause> {
+  friend class OMPClauseReader;
+  friend class OMPClauseWriter;
+  friend class Sema;
+  /// \brief Build clause with number of variables \a N.
   ///
   /// \param StartLoc Starting location of the clause.
   /// \param EndLoc Ending location of the clause.
+  /// \param N Number of the variables in the clause.
   ///
-  OMPUntiedClause(SourceLocation StartLoc, SourceLocation EndLoc)
-      : OMPClause(OMPC_untied, StartLoc, EndLoc) {}
+  explicit OMPLastPrivateClause(SourceLocation StartLoc, SourceLocation EndLoc,
+                                unsigned N)
+      : OMPVarListClause<OMPLastPrivateClause>(OMPC_lastprivate, StartLoc,
+                                               EndLoc, N) {}
 
   /// \brief Build an empty clause.
   ///
-  OMPUntiedClause()
-      : OMPClause(OMPC_untied, SourceLocation(), SourceLocation()) {}
+  /// \param N Number of variables.
+  ///
+  explicit OMPLastPrivateClause(unsigned N)
+      : OMPVarListClause<OMPLastPrivateClause>(
+            OMPC_lastprivate, SourceLocation(), SourceLocation(), N) {}
 
-  static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_untied;
+  /// \brief Sets the list of pseudo vars.
+  void setPseudoVars1(ArrayRef<DeclRefExpr *> PseudoVars);
+
+  /// \brief Return the list of pseudo vars.
+  llvm::MutableArrayRef<Expr *> getPseudoVars1() {
+    return llvm::MutableArrayRef<Expr *>(varlist_end(), numberOfVariables());
   }
 
-  StmtRange children() { return StmtRange(); }
-};
+  /// \brief Sets the list of pseudo vars.
+  void setPseudoVars2(ArrayRef<DeclRefExpr *> PseudoVars);
+
+  /// \brief Return the list of pseudo vars.
+  llvm::MutableArrayRef<Expr *> getPseudoVars2() {
+    return llvm::MutableArrayRef<Expr *>(getPseudoVars1().end(),
+                                         numberOfVariables());
+  }
+
+  /// \brief Sets the list of generated default inits.
+  void setDefaultInits(ArrayRef<Expr *> DefaultInits);
+
+  /// \brief Return the list of all generated expressions.
+  llvm::MutableArrayRef<Expr *> getDefaultInits() {
+    return llvm::MutableArrayRef<Expr *>(getPseudoVars2().end(),
+                                         numberOfVariables());
+  }
+  /// \brief Sets the list of generated inits.
+  void setAssignments(ArrayRef<Expr *> Assignments);
+
+  /// \brief Return the list of all inits.
+  llvm::MutableArrayRef<Expr *> getAssignments() {
+    return llvm::MutableArrayRef<Expr *>(getDefaultInits().end(),
+                                         numberOfVariables());
+  }
 
-/// \brief This represents 'mergeable' clause in the '#pragma omp ...'
-/// directive.
-///
-/// \code
-/// #pragma omp task mergeable
-/// \endcode
-/// In this example directive '#pragma omp task' has 'mergeable' clause.
-///
-class OMPMergeableClause : public OMPClause {
 public:
-  /// \brief Build 'mergeable' clause.
+  /// \brief Creates clause with a list of variables \a VL.
   ///
-  /// \param StartLoc Starting location of the clause.
-  /// \param EndLoc Ending location of the clause.
+  /// \param C AST context.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
+  /// \param VL List of references to the variables.
   ///
-  OMPMergeableClause(SourceLocation StartLoc, SourceLocation EndLoc)
-      : OMPClause(OMPC_mergeable, StartLoc, EndLoc) {}
-
-  /// \brief Build an empty clause.
+  static OMPLastPrivateClause *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<Expr *> VL, ArrayRef<DeclRefExpr *> PseudoVars1,
+         ArrayRef<DeclRefExpr *> PseudoVars2, ArrayRef<Expr *> Assignments);
+  /// \brief Creates an empty clause with the place for \a N variables.
   ///
-  OMPMergeableClause()
-      : OMPClause(OMPC_mergeable, SourceLocation(), SourceLocation()) {}
+  /// \param C AST context.
+  /// \param N The number of variables.
+  ///
+  static OMPLastPrivateClause *CreateEmpty(const ASTContext &C, unsigned N);
 
-  static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_mergeable;
+  /// \brief Return the list of pseudo vars.
+  ArrayRef<const Expr *> getPseudoVars1() const {
+    return llvm::makeArrayRef(varlist_end(), numberOfVariables());
   }
 
-  StmtRange children() { return StmtRange(); }
-};
+  /// \brief Return the list of pseudo vars.
+  ArrayRef<const Expr *> getPseudoVars2() const {
+    return llvm::makeArrayRef(getPseudoVars1().end(), numberOfVariables());
+  }
 
-/// \brief This represents clause 'private' in the '#pragma omp ...' directives.
-///
-/// \code
-/// #pragma omp parallel private(a,b)
-/// \endcode
-/// In this example directive '#pragma omp parallel' has clause 'private'
-/// with the variables 'a' and 'b'.
-///
-class OMPPrivateClause : public OMPVarListClause<OMPPrivateClause> {
-  /// \brief Build clause with number of variables \a N.
-  ///
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param EndLoc Ending location of the clause.
-  /// \param N Number of the variables in the clause.
-  ///
-  OMPPrivateClause(SourceLocation StartLoc, SourceLocation LParenLoc,
-                   SourceLocation EndLoc, unsigned N)
-      : OMPVarListClause<OMPPrivateClause>(OMPC_private, StartLoc, LParenLoc,
-                                           EndLoc, N) {}
+  /// \brief Return the list of all default initializations.
+  ArrayRef<const Expr *> getDefaultInits() const {
+    return llvm::makeArrayRef(getPseudoVars2().end(), numberOfVariables());
+  }
 
-  /// \brief Build an empty clause.
-  ///
-  /// \param N Number of variables.
-  ///
-  explicit OMPPrivateClause(unsigned N)
-      : OMPVarListClause<OMPPrivateClause>(OMPC_private, SourceLocation(),
-                                           SourceLocation(), SourceLocation(),
-                                           N) {}
+  /// \brief Return the list of all initializations.
+  ArrayRef<const Expr *> getAssignments() const {
+    return llvm::makeArrayRef(getDefaultInits().end(), numberOfVariables());
+  }
 
-public:
-  /// \brief Creates clause with a list of variables \a VL.
-  ///
-  /// \param C AST context.
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param EndLoc Ending location of the clause.
-  /// \param VL List of references to the variables.
-  ///
-  static OMPPrivateClause *Create(const ASTContext &C, SourceLocation StartLoc,
-                                  SourceLocation LParenLoc,
-                                  SourceLocation EndLoc, ArrayRef<Expr *> VL);
-  /// \brief Creates an empty clause with the place for \a N variables.
-  ///
-  /// \param C AST context.
-  /// \param N The number of variables.
-  ///
-  static OMPPrivateClause *CreateEmpty(const ASTContext &C, unsigned N);
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_lastprivate;
+  }
 
   StmtRange children() {
     return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
-                     reinterpret_cast<Stmt **>(varlist_end()));
-  }
-
-  static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_private;
+                     reinterpret_cast<Stmt **>(getAssignments().end()));
   }
 };
 
-/// \brief This represents clause 'firstprivate' in the '#pragma omp ...'
-/// directives.
+/// \brief This represents clause 'shared' in the '#pragma omp ...' directives.
 ///
 /// \code
-/// #pragma omp parallel firstprivate(a,b)
+/// #pragma omp parallel shared(a,b)
 /// \endcode
-/// In this example directive '#pragma omp parallel' has clause 'firstprivate'
+/// In this example directive '#pragma omp parallel' has clause 'shared'
 /// with the variables 'a' and 'b'.
 ///
-class OMPFirstprivateClause : public OMPVarListClause<OMPFirstprivateClause> {
+class OMPSharedClause : public OMPVarListClause<OMPSharedClause> {
   /// \brief Build clause with number of variables \a N.
   ///
   /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
   /// \param EndLoc Ending location of the clause.
   /// \param N Number of the variables in the clause.
   ///
-  OMPFirstprivateClause(SourceLocation StartLoc, SourceLocation LParenLoc,
-                        SourceLocation EndLoc, unsigned N)
-      : OMPVarListClause<OMPFirstprivateClause>(OMPC_firstprivate, StartLoc,
-                                                LParenLoc, EndLoc, N) {}
+  OMPSharedClause(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N)
+      : OMPVarListClause<OMPSharedClause>(OMPC_shared, StartLoc, EndLoc, N) {}
 
   /// \brief Build an empty clause.
   ///
   /// \param N Number of variables.
   ///
-  explicit OMPFirstprivateClause(unsigned N)
-      : OMPVarListClause<OMPFirstprivateClause>(
-            OMPC_firstprivate, SourceLocation(), SourceLocation(),
-            SourceLocation(), N) {}
+  explicit OMPSharedClause(unsigned N)
+      : OMPVarListClause<OMPSharedClause>(OMPC_shared, SourceLocation(),
+                                          SourceLocation(), N) {}
 
 public:
   /// \brief Creates clause with a list of variables \a VL.
   ///
   /// \param C AST context.
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param EndLoc Ending location of the clause.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
   /// \param VL List of references to the variables.
   ///
-  static OMPFirstprivateClause *
-  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,
-         SourceLocation EndLoc, ArrayRef<Expr *> VL);
+  static OMPSharedClause *Create(const ASTContext &C, SourceLocation StartLoc,
+                                 SourceLocation EndLoc, ArrayRef<Expr *> VL);
   /// \brief Creates an empty clause with the place for \a N variables.
   ///
   /// \param C AST context.
   /// \param N The number of variables.
   ///
-  static OMPFirstprivateClause *CreateEmpty(const ASTContext &C, unsigned N);
+  static OMPSharedClause *CreateEmpty(const ASTContext &C, unsigned N);
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_shared;
+  }
 
   StmtRange children() {
     return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
                      reinterpret_cast<Stmt **>(varlist_end()));
   }
-
-  static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_firstprivate;
-  }
 };
 
-/// \brief This represents clause 'lastprivate' in the '#pragma omp ...'
-/// directives.
+/// \brief This represents clause 'copyin' in the '#pragma omp ...' directives.
 ///
 /// \code
-/// #pragma omp simd lastprivate(a,b)
+/// #pragma omp parallel copyin(a,b)
 /// \endcode
-/// In this example directive '#pragma omp simd' has clause 'lastprivate'
+/// In this example directive '#pragma omp parallel' has clause 'copyin'
 /// with the variables 'a' and 'b'.
 ///
-class OMPLastprivateClause : public OMPVarListClause<OMPLastprivateClause> {
+class OMPCopyinClause : public OMPVarListClause<OMPCopyinClause> {
+  friend class OMPClauseReader;
+  friend class OMPClauseWriter;
   /// \brief Build clause with number of variables \a N.
   ///
   /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
   /// \param EndLoc Ending location of the clause.
   /// \param N Number of the variables in the clause.
   ///
-  OMPLastprivateClause(SourceLocation StartLoc, SourceLocation LParenLoc,
-                       SourceLocation EndLoc, unsigned N)
-      : OMPVarListClause<OMPLastprivateClause>(OMPC_lastprivate, StartLoc,
-                                               LParenLoc, EndLoc, N) {}
+  OMPCopyinClause(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N)
+      : OMPVarListClause<OMPCopyinClause>(OMPC_copyin, StartLoc, EndLoc, N) {}
 
   /// \brief Build an empty clause.
   ///
   /// \param N Number of variables.
   ///
-  explicit OMPLastprivateClause(unsigned N)
-      : OMPVarListClause<OMPLastprivateClause>(
-            OMPC_lastprivate, SourceLocation(), SourceLocation(),
-            SourceLocation(), N) {}
+  explicit OMPCopyinClause(unsigned N)
+      : OMPVarListClause<OMPCopyinClause>(OMPC_copyin, SourceLocation(),
+                                          SourceLocation(), N) {}
+
+  /// \brief Sets the list of pseudo vars.
+  void setPseudoVars1(ArrayRef<DeclRefExpr *> PseudoVars);
+
+  /// \brief Return the list of pseudo vars.
+  llvm::MutableArrayRef<Expr *> getPseudoVars1() {
+    return llvm::MutableArrayRef<Expr *>(varlist_end(), numberOfVariables());
+  }
+
+  /// \brief Sets the list of pseudo vars.
+  void setPseudoVars2(ArrayRef<DeclRefExpr *> PseudoVars);
+
+  /// \brief Return the list of pseudo vars.
+  llvm::MutableArrayRef<Expr *> getPseudoVars2() {
+    return llvm::MutableArrayRef<Expr *>(getPseudoVars1().end(),
+                                         numberOfVariables());
+  }
+
+  /// \brief Sets the list of generated inits.
+  void setAssignments(ArrayRef<Expr *> Assignments);
+
+  /// \brief Return the list of all inits.
+  llvm::MutableArrayRef<Expr *> getAssignments() {
+    return llvm::MutableArrayRef<Expr *>(getPseudoVars2().end(),
+                                         numberOfVariables());
+  }
 
 public:
   /// \brief Creates clause with a list of variables \a VL.
   ///
   /// \param C AST context.
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param EndLoc Ending location of the clause.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
   /// \param VL List of references to the variables.
   ///
-  static OMPLastprivateClause *
-  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,
-         SourceLocation EndLoc, ArrayRef<Expr *> VL);
+  static OMPCopyinClause *Create(const ASTContext &C, SourceLocation StartLoc,
+                                 SourceLocation EndLoc, ArrayRef<Expr *> VL,
+                                 ArrayRef<DeclRefExpr *> PseudoVars1,
+                                 ArrayRef<DeclRefExpr *> PseudoVars2,
+                                 ArrayRef<Expr *> Assignments);
   /// \brief Creates an empty clause with the place for \a N variables.
   ///
   /// \param C AST context.
   /// \param N The number of variables.
   ///
-  static OMPLastprivateClause *CreateEmpty(const ASTContext &C, unsigned N);
+  static OMPCopyinClause *CreateEmpty(const ASTContext &C, unsigned N);
 
-  StmtRange children() {
-    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
-                     reinterpret_cast<Stmt **>(varlist_end()));
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_copyin;
   }
 
-  static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_lastprivate;
+  /// \brief Return the list of pseudo vars.
+  ArrayRef<const Expr *> getPseudoVars1() const {
+    return llvm::makeArrayRef(varlist_end(), numberOfVariables());
+  }
+
+  /// \brief Return the list of pseudo vars.
+  ArrayRef<const Expr *> getPseudoVars2() const {
+    return llvm::makeArrayRef(getPseudoVars1().end(), numberOfVariables());
+  }
+
+  /// \brief Return the list of all initializations.
+  ArrayRef<const Expr *> getAssignments() const {
+    return llvm::makeArrayRef(getPseudoVars2().end(), numberOfVariables());
+  }
+
+  StmtRange children() {
+    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
+                     reinterpret_cast<Stmt **>(getAssignments().end()));
   }
 };
 
-/// \brief This represents clause 'shared' in the '#pragma omp ...' directives.
+/// \brief This represents clause 'copyprivate' in the '#pragma omp ...'
+/// directives.
 ///
 /// \code
-/// #pragma omp parallel shared(a,b)
+/// #pragma omp single copyprivate(a,b)
 /// \endcode
-/// In this example directive '#pragma omp parallel' has clause 'shared'
+/// In this example directive '#pragma omp single' has clause 'copyprivate'
 /// with the variables 'a' and 'b'.
 ///
-class OMPSharedClause : public OMPVarListClause<OMPSharedClause> {
+class OMPCopyPrivateClause : public OMPVarListClause<OMPCopyPrivateClause> {
+  friend class OMPClauseReader;
+  friend class OMPClauseWriter;
   /// \brief Build clause with number of variables \a N.
   ///
   /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
   /// \param EndLoc Ending location of the clause.
   /// \param N Number of the variables in the clause.
   ///
-  OMPSharedClause(SourceLocation StartLoc, SourceLocation LParenLoc,
-                  SourceLocation EndLoc, unsigned N)
-      : OMPVarListClause<OMPSharedClause>(OMPC_shared, StartLoc, LParenLoc,
-                                          EndLoc, N) {}
+  OMPCopyPrivateClause(SourceLocation StartLoc, SourceLocation EndLoc,
+                       unsigned N)
+      : OMPVarListClause<OMPCopyPrivateClause>(OMPC_copyprivate, StartLoc,
+                                               EndLoc, N) {}
 
   /// \brief Build an empty clause.
   ///
   /// \param N Number of variables.
   ///
-  explicit OMPSharedClause(unsigned N)
-      : OMPVarListClause<OMPSharedClause>(OMPC_shared, SourceLocation(),
-                                          SourceLocation(), SourceLocation(),
-                                          N) {}
+  explicit OMPCopyPrivateClause(unsigned N)
+      : OMPVarListClause<OMPCopyPrivateClause>(
+            OMPC_copyprivate, SourceLocation(), SourceLocation(), N) {}
+
+  /// \brief Sets the list of pseudo vars.
+  void setPseudoVars1(ArrayRef<DeclRefExpr *> PseudoVars);
+
+  /// \brief Return the list of pseudo vars.
+  llvm::MutableArrayRef<Expr *> getPseudoVars1() {
+    return llvm::MutableArrayRef<Expr *>(varlist_end(), numberOfVariables());
+  }
+
+  /// \brief Sets the list of pseudo vars.
+  void setPseudoVars2(ArrayRef<DeclRefExpr *> PseudoVars);
+
+  /// \brief Return the list of pseudo vars.
+  llvm::MutableArrayRef<Expr *> getPseudoVars2() {
+    return llvm::MutableArrayRef<Expr *>(getPseudoVars1().end(),
+                                         numberOfVariables());
+  }
+
+  /// \brief Sets the list of generated inits.
+  void setAssignments(ArrayRef<Expr *> Assignments);
+
+  /// \brief Return the list of all inits.
+  llvm::MutableArrayRef<Expr *> getAssignments() {
+    return llvm::MutableArrayRef<Expr *>(getPseudoVars2().end(),
+                                         numberOfVariables());
+  }
 
 public:
   /// \brief Creates clause with a list of variables \a VL.
   ///
   /// \param C AST context.
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param EndLoc Ending location of the clause.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
   /// \param VL List of references to the variables.
   ///
-  static OMPSharedClause *Create(const ASTContext &C, SourceLocation StartLoc,
-                                 SourceLocation LParenLoc,
-                                 SourceLocation EndLoc, ArrayRef<Expr *> VL);
-  /// \brief Creates an empty clause with \a N variables.
+  static OMPCopyPrivateClause *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<Expr *> VL, ArrayRef<DeclRefExpr *> PseudoVars1,
+         ArrayRef<DeclRefExpr *> PseudoVars2, ArrayRef<Expr *> Assignments);
+  /// \brief Creates an empty clause with the place for \a N variables.
   ///
   /// \param C AST context.
   /// \param N The number of variables.
   ///
-  static OMPSharedClause *CreateEmpty(const ASTContext &C, unsigned N);
+  static OMPCopyPrivateClause *CreateEmpty(const ASTContext &C, unsigned N);
 
-  StmtRange children() {
-    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
-                     reinterpret_cast<Stmt **>(varlist_end()));
+  /// \brief Return the list of pseudo vars.
+  ArrayRef<const Expr *> getPseudoVars1() const {
+    return llvm::makeArrayRef(varlist_end(), numberOfVariables());
+  }
+
+  /// \brief Return the list of pseudo vars.
+  ArrayRef<const Expr *> getPseudoVars2() const {
+    return llvm::makeArrayRef(getPseudoVars1().end(), numberOfVariables());
+  }
+
+  /// \brief Return the list of all initializations.
+  ArrayRef<const Expr *> getAssignments() const {
+    return llvm::makeArrayRef(getPseudoVars2().end(), numberOfVariables());
   }
 
   static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_shared;
+    return T->getClauseKind() == OMPC_copyprivate;
+  }
+
+  StmtRange children() {
+    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
+                     reinterpret_cast<Stmt **>(getAssignments().end()));
   }
 };
 
@@ -1012,37 +1024,51 @@
 /// directives.
 ///
 /// \code
-/// #pragma omp parallel reduction(+:a,b)
+/// #pragma omp parallel reduction(+ : a,b)
 /// \endcode
 /// In this example directive '#pragma omp parallel' has clause 'reduction'
-/// with operator '+' and the variables 'a' and 'b'.
+/// with operator '+' and variables 'a' and 'b'.
 ///
 class OMPReductionClause : public OMPVarListClause<OMPReductionClause> {
   friend class OMPClauseReader;
-  /// \brief Location of ':'.
-  SourceLocation ColonLoc;
+  friend class OMPClauseWriter;
+  /// \brief An operator for the 'reduction' clause.
+  OpenMPReductionClauseOperator Operator;
   /// \brief Nested name specifier for C++.
-  NestedNameSpecifierLoc QualifierLoc;
+  NestedNameSpecifierLoc Spec;
   /// \brief Name of custom operator.
-  DeclarationNameInfo NameInfo;
+  DeclarationNameInfo OperatorName;
 
-  /// \brief Build clause with number of variables \a N.
+  /// \brief Set operator for the clause.
+  ///
+  /// \param Op Operator for the clause.
+  ///
+  void setOperator(OpenMPReductionClauseOperator Op) { Operator = Op; }
+
+  /// \brief Set operator name for the clause.
+  ///
+  /// \param S Nested name specifier.
+  /// \param Op Operator name for the clause.
+  ///
+  void setOpName(NestedNameSpecifierLoc S, DeclarationNameInfo OpName) {
+    Spec = S;
+    OperatorName = OpName;
+  }
+
+  /// \brief Build clause with number of variables \a N and an operator \a Op.
   ///
   /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
   /// \param EndLoc Ending location of the clause.
-  /// \param ColonLoc Location of ':'.
   /// \param N Number of the variables in the clause.
-  /// \param QualifierLoc The nested-name qualifier with location information
-  /// \param NameInfo The full name info for reduction identifier.
+  /// \param Op reduction operator.
+  /// \param OpLoc Location of the operator.
   ///
-  OMPReductionClause(SourceLocation StartLoc, SourceLocation LParenLoc,
-                     SourceLocation ColonLoc, SourceLocation EndLoc, unsigned N,
-                     NestedNameSpecifierLoc QualifierLoc,
-                     const DeclarationNameInfo &NameInfo)
-      : OMPVarListClause<OMPReductionClause>(OMPC_reduction, StartLoc,
-                                             LParenLoc, EndLoc, N),
-        ColonLoc(ColonLoc), QualifierLoc(QualifierLoc), NameInfo(NameInfo) {}
+  OMPReductionClause(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N,
+                     OpenMPReductionClauseOperator Op,
+                     NestedNameSpecifierLoc Spec, DeclarationNameInfo OpName)
+      : OMPVarListClause<OMPReductionClause>(OMPC_reduction, StartLoc, EndLoc,
+                                             N),
+        Operator(Op), Spec(Spec), OperatorName(OpName) {}
 
   /// \brief Build an empty clause.
   ///
@@ -1050,33 +1076,60 @@
   ///
   explicit OMPReductionClause(unsigned N)
       : OMPVarListClause<OMPReductionClause>(OMPC_reduction, SourceLocation(),
-                                             SourceLocation(), SourceLocation(),
-                                             N),
-        ColonLoc(), QualifierLoc(), NameInfo() {}
+                                             SourceLocation(), N),
+        Operator(OMPC_REDUCTION_unknown), Spec(), OperatorName() {}
+
+  /// \brief Sets the list of generated expresssions.
+  void setOpExprs(ArrayRef<Expr *> OpExprs);
+  /// \brief Sets the list of 1st helper parameters.
+  void setHelperParameters1st(ArrayRef<Expr *> HelperParams);
+  /// \brief Sets the list of 1st helper parameters.
+  void setHelperParameters2nd(ArrayRef<Expr *> HelperParams);
+
+  /// \brief Return the list of all generated expressions.
+  llvm::MutableArrayRef<Expr *> getOpExprs() {
+    return llvm::MutableArrayRef<Expr *>(varlist_end(), numberOfVariables());
+  }
 
-  /// \brief Sets location of ':' symbol in clause.
-  void setColonLoc(SourceLocation CL) { ColonLoc = CL; }
-  /// \brief Sets the name info for specified reduction identifier.
-  void setNameInfo(DeclarationNameInfo DNI) { NameInfo = DNI; }
-  /// \brief Sets the nested name specifier.
-  void setQualifierLoc(NestedNameSpecifierLoc NSL) { QualifierLoc = NSL; }
+  /// \brief Return the list of 1st helper parameters.
+  llvm::MutableArrayRef<Expr *> getHelperParameters1st() {
+    return llvm::MutableArrayRef<Expr *>(getOpExprs().end(),
+                                         numberOfVariables());
+  }
+
+  /// \brief Return the list of 2nd helper parameters.
+  llvm::MutableArrayRef<Expr *> getHelperParameters2nd() {
+    return llvm::MutableArrayRef<Expr *>(getHelperParameters1st().end(),
+                                         numberOfVariables());
+  }
+
+  /// \brief Sets the list of generated default inits.
+  void setDefaultInits(ArrayRef<Expr *> DefaultInits);
+
+  /// \brief Return the list of all generated expressions.
+  llvm::MutableArrayRef<Expr *> getDefaultInits() {
+    return llvm::MutableArrayRef<Expr *>(getHelperParameters2nd().end(),
+                                         numberOfVariables());
+  }
 
 public:
-  /// \brief Creates clause with a list of variables \a VL.
+  /// \brief Creates clause with a list of variables \a VL and an operator
+  /// \a Op.
   ///
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param ColonLoc Location of ':'.
-  /// \param EndLoc Ending location of the clause.
-  /// \param VL The variables in the clause.
-  /// \param QualifierLoc The nested-name qualifier with location information
-  /// \param NameInfo The full name info for reduction identifier.
+  /// \param C AST context.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
+  /// \param VL List of references to the variables.
+  /// \param Op reduction operator.
+  /// \param S nested name specifier.
+  /// \param OpName Reduction identifier.
   ///
   static OMPReductionClause *
-  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,
-         SourceLocation ColonLoc, SourceLocation EndLoc, ArrayRef<Expr *> VL,
-         NestedNameSpecifierLoc QualifierLoc,
-         const DeclarationNameInfo &NameInfo);
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<Expr *> VL, ArrayRef<Expr *> OpExprs,
+         ArrayRef<Expr *> HelperParams1, ArrayRef<Expr *> HelperParams2,
+         ArrayRef<Expr *> DefaultInits, OpenMPReductionClauseOperator Op,
+         NestedNameSpecifierLoc S, DeclarationNameInfo OpName);
   /// \brief Creates an empty clause with the place for \a N variables.
   ///
   /// \param C AST context.
@@ -1084,371 +1137,1543 @@
   ///
   static OMPReductionClause *CreateEmpty(const ASTContext &C, unsigned N);
 
-  /// \brief Gets location of ':' symbol in clause.
-  SourceLocation getColonLoc() const { return ColonLoc; }
-  /// \brief Gets the name info for specified reduction identifier.
-  const DeclarationNameInfo &getNameInfo() const { return NameInfo; }
-  /// \brief Gets the nested name specifier.
-  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }
+  /// \brief Fetches operator for the clause.
+  OpenMPReductionClauseOperator getOperator() const { return Operator; }
 
-  StmtRange children() {
-    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
-                     reinterpret_cast<Stmt **>(varlist_end()));
-  }
+  /// \brief Fetches nested name specifier for the clause.
+  NestedNameSpecifierLoc getSpec() const { return Spec; }
+
+  /// \brief Fetches operator name for the clause.
+  DeclarationNameInfo getOpName() const { return OperatorName; }
 
   static bool classof(const OMPClause *T) {
     return T->getClauseKind() == OMPC_reduction;
   }
+
+  /// \brief Return the list of all generated expressions.
+  ArrayRef<const Expr *> getOpExprs() const {
+    return llvm::makeArrayRef(getVars().end(), numberOfVariables());
+  }
+  /// \brief Return the list of 1st helper parameters.
+  ArrayRef<const Expr *> getHelperParameters1st() const {
+    return llvm::makeArrayRef(getOpExprs().end(), numberOfVariables());
+  }
+  /// \brief Return the list of 2nd helper parameters.
+  ArrayRef<const Expr *> getHelperParameters2nd() const {
+    return llvm::makeArrayRef(getHelperParameters1st().end(),
+                              numberOfVariables());
+  }
+
+  /// \brief Return the list of all default initializations.
+  ArrayRef<const Expr *> getDefaultInits() const {
+    return llvm::makeArrayRef(getHelperParameters2nd().end(),
+                              numberOfVariables());
+  }
+
+  StmtRange children() {
+    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
+                     reinterpret_cast<Stmt **>(getDefaultInits().end()));
+  }
 };
 
-/// \brief This represents clause 'linear' in the '#pragma omp ...'
+/// \brief This represents clause 'map' in the '#pragma omp ...'
 /// directives.
 ///
 /// \code
-/// #pragma omp simd linear(a,b : 2)
+/// #pragma omp target map(a,b)
 /// \endcode
-/// In this example directive '#pragma omp simd' has clause 'linear'
-/// with variables 'a', 'b' and linear step '2'.
+/// In this example directive '#pragma omp target' has clause 'map'
+/// with the variables 'a' and 'b'.
 ///
-class OMPLinearClause : public OMPVarListClause<OMPLinearClause> {
+class OMPMapClause : public OMPVarListClause<OMPMapClause> {
   friend class OMPClauseReader;
-  /// \brief Location of ':'.
-  SourceLocation ColonLoc;
+  friend class OMPClauseWriter;
+  friend class Sema;
+
+  /// \brief Mapping kind for the 'map' clause.
+  OpenMPMapClauseKind Kind;
+  /// \brief Location of the mapping kind.
+  SourceLocation KindLoc;
+
+  /// \brief Set Kind for the clause.
+  ///
+  /// \param K Kind for the clause.
+  ///
+  void setKind(OpenMPMapClauseKind K) { Kind = K; }
 
-  /// \brief Sets the linear step for clause.
-  void setStep(Expr *Step) { *varlist_end() = Step; }
+  /// \brief Set kind location.
+  ///
+  /// \param KLoc Kind location.
+  ///
+  void setKindLoc(SourceLocation KLoc) { KindLoc = KLoc; }
 
-  /// \brief Build 'linear' clause with given number of variables \a NumVars.
+  /// \brief Build clause with number of variables \a N.
   ///
   /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param ColonLoc Location of ':'.
   /// \param EndLoc Ending location of the clause.
-  /// \param NumVars Number of variables.
+  /// \param N Number of the variables in the clause.
   ///
-  OMPLinearClause(SourceLocation StartLoc, SourceLocation LParenLoc,
-                  SourceLocation ColonLoc, SourceLocation EndLoc,
-                  unsigned NumVars)
-      : OMPVarListClause<OMPLinearClause>(OMPC_linear, StartLoc, LParenLoc,
-                                          EndLoc, NumVars),
-        ColonLoc(ColonLoc) {}
+  explicit OMPMapClause(SourceLocation StartLoc, SourceLocation EndLoc,
+                        unsigned N, OpenMPMapClauseKind K, SourceLocation KLoc)
+      : OMPVarListClause<OMPMapClause>(OMPC_map, StartLoc, EndLoc, N), Kind(K),
+        KindLoc(KLoc) {}
 
   /// \brief Build an empty clause.
   ///
-  /// \param NumVars Number of variables.
+  /// \param N Number of variables.
   ///
-  explicit OMPLinearClause(unsigned NumVars)
-      : OMPVarListClause<OMPLinearClause>(OMPC_linear, SourceLocation(),
-                                          SourceLocation(), SourceLocation(),
-                                          NumVars),
-        ColonLoc(SourceLocation()) {}
+  explicit OMPMapClause(unsigned N)
+      : OMPVarListClause<OMPMapClause>(OMPC_map, SourceLocation(),
+                                       SourceLocation(), N),
+        Kind(OMPC_MAP_unknown), KindLoc() {}
+
+  /// \brief Sets whole starting addresses for the items.
+  void setWholeStartAddresses(ArrayRef<Expr *> WholeStartAddresses);
+
+  /// \brief Return the list of whole starting addresses.
+  llvm::MutableArrayRef<Expr *> getWholeStartAddresses() {
+    return llvm::MutableArrayRef<Expr *>(varlist_end(), numberOfVariables());
+  }
+
+  /// \brief Sets whole sizes/ending addresses for the items.
+  void setWholeSizesEndAddresses(ArrayRef<Expr *> WholeSizesEndAddresses);
+
+  /// \brief Return whole sizes/ending addresses for the items.
+  llvm::MutableArrayRef<Expr *> getWholeSizesEndAddresses() {
+    return llvm::MutableArrayRef<Expr *>(getWholeStartAddresses().end(),
+                                         numberOfVariables());
+  }
+
+  /// \brief Sets starting addresses for the items to be copied.
+  void setCopyingStartAddresses(ArrayRef<Expr *> CopyingStartAddresses);
+
+  /// \brief Return the list of copied starting addresses.
+  llvm::MutableArrayRef<Expr *> getCopyingStartAddresses() {
+    return llvm::MutableArrayRef<Expr *>(getWholeSizesEndAddresses().end(),
+                                         numberOfVariables());
+  }
+
+  /// \brief Sets sizes/ending addresses for the copied items.
+  void setCopyingSizesEndAddresses(ArrayRef<Expr *> CopyingSizesEndAddresses);
+
+  /// \brief Return sizes/ending addresses for the copied items.
+  llvm::MutableArrayRef<Expr *> getCopyingSizesEndAddresses() {
+    return llvm::MutableArrayRef<Expr *>(getCopyingStartAddresses().end(),
+                                         numberOfVariables());
+  }
 
 public:
-  /// \brief Creates clause with a list of variables \a VL and a linear step
-  /// \a Step.
+  /// \brief Creates clause with a list of variables \a VL.
   ///
-  /// \param C AST Context.
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param ColonLoc Location of ':'.
-  /// \param EndLoc Ending location of the clause.
+  /// \param C AST context.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
   /// \param VL List of references to the variables.
-  /// \param Step Linear step.
-  static OMPLinearClause *Create(const ASTContext &C, SourceLocation StartLoc,
-                                 SourceLocation LParenLoc,
-                                 SourceLocation ColonLoc, SourceLocation EndLoc,
-                                 ArrayRef<Expr *> VL, Expr *Step);
-
-  /// \brief Creates an empty clause with the place for \a NumVars variables.
+  ///
+  static OMPMapClause *Create(const ASTContext &C, SourceLocation StartLoc,
+                              SourceLocation EndLoc, ArrayRef<Expr *> VL,
+                              ArrayRef<Expr *> WholeStartAddresses,
+                              ArrayRef<Expr *> WholeSizesEndAddresses,
+                              ArrayRef<Expr *> CopyingStartAddresses,
+                              ArrayRef<Expr *> CopyingSizesEndAddresses,
+                              OpenMPMapClauseKind Kind, SourceLocation KindLoc);
+  /// \brief Creates an empty clause with the place for \a N variables.
   ///
   /// \param C AST context.
-  /// \param NumVars Number of variables.
+  /// \param N The number of variables.
   ///
-  static OMPLinearClause *CreateEmpty(const ASTContext &C, unsigned NumVars);
+  static OMPMapClause *CreateEmpty(const ASTContext &C, unsigned N);
 
-  /// \brief Sets the location of ':'.
-  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }
-  /// \brief Returns the location of '('.
-  SourceLocation getColonLoc() const { return ColonLoc; }
+  /// \brief Fetches mapping kind for the clause.
+  OpenMPMapClauseKind getKind() const LLVM_READONLY { return Kind; }
 
-  /// \brief Returns linear step.
-  Expr *getStep() { return *varlist_end(); }
-  /// \brief Returns linear step.
-  const Expr *getStep() const { return *varlist_end(); }
+  /// \brief Fetches location of clause mapping kind.
+  SourceLocation getKindLoc() const LLVM_READONLY { return KindLoc; }
 
-  StmtRange children() {
-    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
-                     reinterpret_cast<Stmt **>(varlist_end() + 1));
+  /// \brief Return the list of whole starting addresses.
+  ArrayRef<const Expr *> getWholeStartAddresses() const {
+    return ArrayRef<const Expr *>(varlist_end(), numberOfVariables());
+  }
+
+  /// \brief Return whole sizes/ending addresses for the items.
+  ArrayRef<const Expr *> getWholeSizesEndAddresses() const {
+    return ArrayRef<const Expr *>(getWholeStartAddresses().end(),
+                                  numberOfVariables());
+  }
+
+  /// \brief Return the list of copied starting addresses.
+  ArrayRef<const Expr *> getCopyingStartAddresses() const {
+    return ArrayRef<const Expr *>(getWholeSizesEndAddresses().end(),
+                                  numberOfVariables());
+  }
+
+  /// \brief Return sizes/ending addresses for the copied items.
+  ArrayRef<const Expr *> getCopyingSizesEndAddresses() const {
+    return ArrayRef<const Expr *>(getCopyingStartAddresses().end(),
+                                  numberOfVariables());
   }
 
   static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_linear;
+    return T->getClauseKind() == OMPC_map;
+  }
+
+  StmtRange children() {
+    return StmtRange(
+        reinterpret_cast<Stmt **>(varlist_begin()),
+        reinterpret_cast<Stmt **>(getCopyingSizesEndAddresses().end()));
   }
 };
 
-/// \brief This represents clause 'aligned' in the '#pragma omp ...'
+/// \brief This represents clause 'to' in the '#pragma omp ...'
 /// directives.
 ///
 /// \code
-/// #pragma omp simd aligned(a,b : 8)
+/// #pragma omp target update to(a,b)
 /// \endcode
-/// In this example directive '#pragma omp simd' has clause 'aligned'
-/// with variables 'a', 'b' and alignment '8'.
+/// In this example directive '#pragma omp target update' has clause 'to'
+/// with the variables 'a' and 'b'.
 ///
-class OMPAlignedClause : public OMPVarListClause<OMPAlignedClause> {
+class OMPToClause : public OMPVarListClause<OMPToClause> {
   friend class OMPClauseReader;
-  /// \brief Location of ':'.
-  SourceLocation ColonLoc;
+  friend class OMPClauseWriter;
+  friend class Sema;
 
-  /// \brief Sets the alignment for clause.
-  void setAlignment(Expr *A) { *varlist_end() = A; }
-
-  /// \brief Build 'aligned' clause with given number of variables \a NumVars.
+  /// \brief Build clause with number of variables \a N.
   ///
   /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param ColonLoc Location of ':'.
   /// \param EndLoc Ending location of the clause.
-  /// \param NumVars Number of variables.
+  /// \param N Number of the variables in the clause.
   ///
-  OMPAlignedClause(SourceLocation StartLoc, SourceLocation LParenLoc,
-                   SourceLocation ColonLoc, SourceLocation EndLoc,
-                   unsigned NumVars)
-      : OMPVarListClause<OMPAlignedClause>(OMPC_aligned, StartLoc, LParenLoc,
-                                           EndLoc, NumVars),
-        ColonLoc(ColonLoc) {}
+  explicit OMPToClause(SourceLocation StartLoc, SourceLocation EndLoc,
+                       unsigned N)
+      : OMPVarListClause<OMPToClause>(OMPC_to, StartLoc, EndLoc, N) {}
 
   /// \brief Build an empty clause.
   ///
-  /// \param NumVars Number of variables.
+  /// \param N Number of variables.
   ///
-  explicit OMPAlignedClause(unsigned NumVars)
-      : OMPVarListClause<OMPAlignedClause>(OMPC_aligned, SourceLocation(),
-                                           SourceLocation(), SourceLocation(),
-                                           NumVars),
-        ColonLoc(SourceLocation()) {}
+  explicit OMPToClause(unsigned N)
+      : OMPVarListClause<OMPToClause>(OMPC_to, SourceLocation(),
+                                      SourceLocation(), N) {}
 
-public:
-  /// \brief Creates clause with a list of variables \a VL and alignment \a A.
-  ///
-  /// \param C AST Context.
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param ColonLoc Location of ':'.
-  /// \param EndLoc Ending location of the clause.
-  /// \param VL List of references to the variables.
-  /// \param A Alignment.
-  static OMPAlignedClause *Create(const ASTContext &C, SourceLocation StartLoc,
-                                  SourceLocation LParenLoc,
-                                  SourceLocation ColonLoc,
-                                  SourceLocation EndLoc, ArrayRef<Expr *> VL,
-                                  Expr *A);
+  /// \brief Sets whole starting addresses for the items.
+  void setWholeStartAddresses(ArrayRef<Expr *> WholeStartAddresses);
 
-  /// \brief Creates an empty clause with the place for \a NumVars variables.
-  ///
-  /// \param C AST context.
-  /// \param NumVars Number of variables.
-  ///
-  static OMPAlignedClause *CreateEmpty(const ASTContext &C, unsigned NumVars);
+  /// \brief Return the list of whole starting addresses.
+  llvm::MutableArrayRef<Expr *> getWholeStartAddresses() {
+    return llvm::MutableArrayRef<Expr *>(varlist_end(), numberOfVariables());
+  }
+
+  /// \brief Sets whole sizes/ending addresses for the items.
+  void setWholeSizesEndAddresses(ArrayRef<Expr *> WholeSizesEndAddresses);
+
+  /// \brief Return whole sizes/ending addresses for the items.
+  llvm::MutableArrayRef<Expr *> getWholeSizesEndAddresses() {
+    return llvm::MutableArrayRef<Expr *>(getWholeStartAddresses().end(),
+                                         numberOfVariables());
+  }
+
+  /// \brief Sets starting addresses for the items to be copied.
+  void setCopyingStartAddresses(ArrayRef<Expr *> CopyingStartAddresses);
+
+  /// \brief Return the list of copied starting addresses.
+  llvm::MutableArrayRef<Expr *> getCopyingStartAddresses() {
+    return llvm::MutableArrayRef<Expr *>(getWholeSizesEndAddresses().end(),
+                                         numberOfVariables());
+  }
+
+  /// \brief Sets sizes/ending addresses for the copied items.
+  void setCopyingSizesEndAddresses(ArrayRef<Expr *> CopyingSizesEndAddresses);
+
+  /// \brief Return sizes/ending addresses for the copied items.
+  llvm::MutableArrayRef<Expr *> getCopyingSizesEndAddresses() {
+    return llvm::MutableArrayRef<Expr *>(getCopyingStartAddresses().end(),
+                                         numberOfVariables());
+  }
+
+public:
+  /// \brief Creates clause with a list of variables \a VL.
+  ///
+  /// \param C AST context.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
+  /// \param VL List of references to the variables.
+  ///
+  static OMPToClause *Create(const ASTContext &C, SourceLocation StartLoc,
+                             SourceLocation EndLoc, ArrayRef<Expr *> VL,
+                             ArrayRef<Expr *> WholeStartAddresses,
+                             ArrayRef<Expr *> WholeSizesEndAddresses,
+                             ArrayRef<Expr *> CopyingStartAddresses,
+                             ArrayRef<Expr *> CopyingSizesEndAddresses);
+  /// \brief Creates an empty clause with the place for \a N variables.
+  ///
+  /// \param C AST context.
+  /// \param N The number of variables.
+  ///
+  static OMPToClause *CreateEmpty(const ASTContext &C, unsigned N);
+
+  /// \brief Return the list of whole starting addresses.
+  ArrayRef<const Expr *> getWholeStartAddresses() const {
+    return ArrayRef<const Expr *>(varlist_end(), numberOfVariables());
+  }
+
+  /// \brief Return whole sizes/ending addresses for the items.
+  ArrayRef<const Expr *> getWholeSizesEndAddresses() const {
+    return ArrayRef<const Expr *>(getWholeStartAddresses().end(),
+                                  numberOfVariables());
+  }
+
+  /// \brief Return the list of copied starting addresses.
+  ArrayRef<const Expr *> getCopyingStartAddresses() const {
+    return ArrayRef<const Expr *>(getWholeSizesEndAddresses().end(),
+                                  numberOfVariables());
+  }
+
+  /// \brief Return sizes/ending addresses for the copied items.
+  ArrayRef<const Expr *> getCopyingSizesEndAddresses() const {
+    return ArrayRef<const Expr *>(getCopyingStartAddresses().end(),
+                                  numberOfVariables());
+  }
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_to;
+  }
+
+  StmtRange children() {
+    return StmtRange(
+        reinterpret_cast<Stmt **>(varlist_begin()),
+        reinterpret_cast<Stmt **>(getCopyingSizesEndAddresses().end()));
+  }
+};
+
+/// \brief This represents clause 'from' in the '#pragma omp ...'
+/// directives.
+///
+/// \code
+/// #pragma omp target update from(a,b)
+/// \endcode
+/// In this example directive '#pragma omp target update' has clause 'from'
+/// with the variables 'a' and 'b'.
+///
+class OMPFromClause : public OMPVarListClause<OMPFromClause> {
+  friend class OMPClauseReader;
+  friend class OMPClauseWriter;
+  friend class Sema;
+
+  /// \brief Build clause with number of variables \a N.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  /// \param N Number of the variables in the clause.
+  ///
+  explicit OMPFromClause(SourceLocation StartLoc, SourceLocation EndLoc,
+                         unsigned N)
+      : OMPVarListClause<OMPFromClause>(OMPC_from, StartLoc, EndLoc, N) {}
+
+  /// \brief Build an empty clause.
+  ///
+  /// \param N Number of variables.
+  ///
+  explicit OMPFromClause(unsigned N)
+      : OMPVarListClause<OMPFromClause>(OMPC_from, SourceLocation(),
+                                        SourceLocation(), N) {}
+
+  /// \brief Sets whole starting addresses for the items.
+  void setWholeStartAddresses(ArrayRef<Expr *> WholeStartAddresses);
+
+  /// \brief Return the list of whole starting addresses.
+  llvm::MutableArrayRef<Expr *> getWholeStartAddresses() {
+    return llvm::MutableArrayRef<Expr *>(varlist_end(), numberOfVariables());
+  }
+
+  /// \brief Sets whole sizes/ending addresses for the items.
+  void setWholeSizesEndAddresses(ArrayRef<Expr *> WholeSizesEndAddresses);
+
+  /// \brief Return whole sizes/ending addresses for the items.
+  llvm::MutableArrayRef<Expr *> getWholeSizesEndAddresses() {
+    return llvm::MutableArrayRef<Expr *>(getWholeStartAddresses().end(),
+                                         numberOfVariables());
+  }
+
+  /// \brief Sets starting addresses for the items to be copied.
+  void setCopyingStartAddresses(ArrayRef<Expr *> CopyingStartAddresses);
+
+  /// \brief Return the list of copied starting addresses.
+  llvm::MutableArrayRef<Expr *> getCopyingStartAddresses() {
+    return llvm::MutableArrayRef<Expr *>(getWholeSizesEndAddresses().end(),
+                                         numberOfVariables());
+  }
+
+  /// \brief Sets sizes/ending addresses for the copied items.
+  void setCopyingSizesEndAddresses(ArrayRef<Expr *> CopyingSizesEndAddresses);
+
+  /// \brief Return sizes/ending addresses for the copied items.
+  llvm::MutableArrayRef<Expr *> getCopyingSizesEndAddresses() {
+    return llvm::MutableArrayRef<Expr *>(getCopyingStartAddresses().end(),
+                                         numberOfVariables());
+  }
+
+public:
+  /// \brief Creates clause with a list of variables \a VL.
+  ///
+  /// \param C AST context.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
+  /// \param VL List of references to the variables.
+  ///
+  static OMPFromClause *Create(const ASTContext &C, SourceLocation StartLoc,
+                               SourceLocation EndLoc, ArrayRef<Expr *> VL,
+                               ArrayRef<Expr *> WholeStartAddresses,
+                               ArrayRef<Expr *> WholeSizesEndAddresses,
+                               ArrayRef<Expr *> CopyingStartAddresses,
+                               ArrayRef<Expr *> CopyingSizesEndAddresses);
+  /// \brief Creates an empty clause with the place for \a N variables.
+  ///
+  /// \param C AST context.
+  /// \param N The number of variables.
+  ///
+  static OMPFromClause *CreateEmpty(const ASTContext &C, unsigned N);
+
+  /// \brief Return the list of whole starting addresses.
+  ArrayRef<const Expr *> getWholeStartAddresses() const {
+    return ArrayRef<const Expr *>(varlist_end(), numberOfVariables());
+  }
+
+  /// \brief Return whole sizes/ending addresses for the items.
+  ArrayRef<const Expr *> getWholeSizesEndAddresses() const {
+    return ArrayRef<const Expr *>(getWholeStartAddresses().end(),
+                                  numberOfVariables());
+  }
+
+  /// \brief Return the list of copied starting addresses.
+  ArrayRef<const Expr *> getCopyingStartAddresses() const {
+    return ArrayRef<const Expr *>(getWholeSizesEndAddresses().end(),
+                                  numberOfVariables());
+  }
+
+  /// \brief Return sizes/ending addresses for the copied items.
+  ArrayRef<const Expr *> getCopyingSizesEndAddresses() const {
+    return ArrayRef<const Expr *>(getCopyingStartAddresses().end(),
+                                  numberOfVariables());
+  }
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_from;
+  }
+
+  StmtRange children() {
+    return StmtRange(
+        reinterpret_cast<Stmt **>(varlist_begin()),
+        reinterpret_cast<Stmt **>(getCopyingSizesEndAddresses().end()));
+  }
+};
+
+/// \brief This represents 'schedule' clause in the '#pragma omp ...' directive.
+///
+/// \code
+/// #pragma omp for schedule(static, 3)
+/// \endcode
+/// In this example directive '#pragma omp for' has 'schedule'
+/// clause with arguments 'static' and '3'.
+///
+class OMPScheduleClause : public OMPClause {
+  friend class OMPClauseReader;
+  /// \brief A kind of the 'schedule' clause.
+  OpenMPScheduleClauseKind Kind;
+  /// \brief Start location of the kind in cource code.
+  SourceLocation KindLoc;
+  /// \brief Chunk size.
+  Stmt *ChunkSize;
+
+  /// \brief Set kind of the clauses.
+  ///
+  /// \param K Argument of clause.
+  ///
+  void setScheduleKind(OpenMPScheduleClauseKind K) { Kind = K; }
+  /// \brief Set kind location.
+  ///
+  /// \param KLoc Kind location.
+  ///
+  void setScheduleKindLoc(SourceLocation KLoc) { KindLoc = KLoc; }
+  /// \brief Set chunk size.
+  ///
+  /// \param E Chunk size.
+  ///
+  void setChunkSize(Expr *E) { ChunkSize = E; }
+
+public:
+  /// \brief Build 'schedule' clause with argument \a Kind and
+  /// an expression \a E.
+  ///
+  /// \brief K Argument of the clause.
+  /// \brief KLoc Starting location of the argument.
+  /// \brief E Chunk size.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
+  ///
+  OMPScheduleClause(OpenMPScheduleClauseKind K, SourceLocation KLoc, Expr *E,
+                    SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_schedule, StartLoc, EndLoc), Kind(K), KindLoc(KLoc),
+        ChunkSize(E) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPScheduleClause()
+      : OMPClause(OMPC_schedule, SourceLocation(), SourceLocation()),
+        Kind(OMPC_SCHEDULE_unknown), KindLoc(SourceLocation()), ChunkSize(0) {}
+
+  /// \brief Get kind of the clause.
+  ///
+  OpenMPScheduleClauseKind getScheduleKind() const { return Kind; }
+  /// \brief Get kind location.
+  ///
+  SourceLocation getScheduleKindLoc() { return KindLoc; }
+  /// \brief Get chunk size.
+  ///
+  Expr *getChunkSize() { return dyn_cast_or_null<Expr>(ChunkSize); }
+  /// \brief Get chunk size.
+  ///
+  Expr *getChunkSize() const { return dyn_cast_or_null<Expr>(ChunkSize); }
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_schedule;
+  }
+
+  StmtRange children() { return StmtRange(&ChunkSize, &ChunkSize + 1); }
+};
+
+/// \brief This represents 'dist_schedule' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp distribute dist_schedule(static, 3)
+/// \endcode
+/// In this example directive '#pragma omp distribute' has 'dist_schedule'
+/// clause with arguments 'static' and '3'.
+///
+class OMPDistScheduleClause : public OMPClause {
+  friend class OMPClauseReader;
+  /// \brief A kind of the 'dist_schedule' clause.
+  OpenMPDistScheduleClauseKind Kind;
+  /// \brief Start location of the kind in cource code.
+  SourceLocation KindLoc;
+  /// \brief Chunk size.
+  Stmt *ChunkSize;
+
+  /// \brief Set kind of the clauses.
+  ///
+  /// \param K Argument of clause.
+  ///
+  void setDistScheduleKind(OpenMPDistScheduleClauseKind K) { Kind = K; }
+  /// \brief Set kind location.
+  ///
+  /// \param KLoc Kind location.
+  ///
+  void setDistScheduleKindLoc(SourceLocation KLoc) { KindLoc = KLoc; }
+  /// \brief Set chunk size.
+  ///
+  /// \param E Chunk size.
+  ///
+  void setDistChunkSize(Expr *E) { ChunkSize = E; }
+
+public:
+  /// \brief Build 'dist_schedule' clause with argument \a Kind and
+  /// an expression \a E.
+  ///
+  /// \brief K Argument of the clause.
+  /// \brief KLoc Starting location of the argument.
+  /// \brief E Chunk size.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
+  ///
+  OMPDistScheduleClause(OpenMPDistScheduleClauseKind K, SourceLocation KLoc,
+                        Expr *E, SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_dist_schedule, StartLoc, EndLoc), Kind(K), KindLoc(KLoc),
+        ChunkSize(E) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPDistScheduleClause()
+      : OMPClause(OMPC_dist_schedule, SourceLocation(), SourceLocation()),
+        Kind(OMPC_DIST_SCHEDULE_unknown), KindLoc(SourceLocation()),
+        ChunkSize(0) {}
+
+  /// \brief Get kind of the clause.
+  ///
+  OpenMPDistScheduleClauseKind getDistScheduleKind() const { return Kind; }
+  /// \brief Get kind location.
+  ///
+  SourceLocation getDistScheduleKindLoc() { return KindLoc; }
+  /// \brief Get chunk size.
+  ///
+  Expr *getDistChunkSize() { return dyn_cast_or_null<Expr>(ChunkSize); }
+  /// \brief Get chunk size.
+  ///
+  Expr *getDistChunkSize() const { return dyn_cast_or_null<Expr>(ChunkSize); }
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_dist_schedule;
+  }
+
+  StmtRange children() { return StmtRange(&ChunkSize, &ChunkSize + 1); }
+};
+
+/// \brief This represents 'ordered' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp for ordered
+/// \endcode
+/// In this example directive '#pragma omp for' has clause 'ordered'.
+///
+class OMPOrderedClause : public OMPClause {
+public:
+  /// \brief Build 'ordered' clause.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPOrderedClause(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_ordered, StartLoc, EndLoc) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPOrderedClause()
+      : OMPClause(OMPC_ordered, SourceLocation(), SourceLocation()) {}
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_ordered;
+  }
+
+  StmtRange children() { return StmtRange(); }
+};
+
+/// \brief This represents 'nowait' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp for nowait
+/// \endcode
+/// In this example directive '#pragma omp for' has clause 'nowait'.
+///
+class OMPNowaitClause : public OMPClause {
+public:
+  /// \brief Build 'nowait' clause.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPNowaitClause(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_nowait, StartLoc, EndLoc) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPNowaitClause()
+      : OMPClause(OMPC_nowait, SourceLocation(), SourceLocation()) {}
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_nowait;
+  }
+
+  StmtRange children() { return StmtRange(); }
+};
+
+/// \brief This represents 'untied' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp task untied
+/// \endcode
+/// In this example directive '#pragma omp task' has clause 'untied'.
+///
+class OMPUntiedClause : public OMPClause {
+public:
+  /// \brief Build 'untied' clause.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPUntiedClause(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_untied, StartLoc, EndLoc) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPUntiedClause()
+      : OMPClause(OMPC_untied, SourceLocation(), SourceLocation()) {}
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_untied;
+  }
+
+  StmtRange children() { return StmtRange(); }
+};
+
+/// \brief This represents 'mergeable' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp task mergeable
+/// \endcode
+/// In this example directive '#pragma omp task' has clause 'mergeable'.
+///
+class OMPMergeableClause : public OMPClause {
+public:
+  /// \brief Build 'mergeable' clause.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPMergeableClause(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_mergeable, StartLoc, EndLoc) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPMergeableClause()
+      : OMPClause(OMPC_mergeable, SourceLocation(), SourceLocation()) {}
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_mergeable;
+  }
+
+  StmtRange children() { return StmtRange(); }
+};
+
+/// \brief This represents 'read' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp atomic read
+/// \endcode
+/// In this example directive '#pragma omp atomic' has clause 'read'.
+///
+class OMPReadClause : public OMPClause {
+public:
+  /// \brief Build 'read' clause.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPReadClause(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_read, StartLoc, EndLoc) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPReadClause()
+      : OMPClause(OMPC_read, SourceLocation(), SourceLocation()) {}
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_read;
+  }
+
+  StmtRange children() { return StmtRange(); }
+};
+
+/// \brief This represents 'write' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp atomic write
+/// \endcode
+/// In this example directive '#pragma omp atomic' has clause 'write'.
+///
+class OMPWriteClause : public OMPClause {
+public:
+  /// \brief Build 'write' clause.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPWriteClause(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_write, StartLoc, EndLoc) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPWriteClause()
+      : OMPClause(OMPC_write, SourceLocation(), SourceLocation()) {}
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_write;
+  }
+
+  StmtRange children() { return StmtRange(); }
+};
+
+/// \brief This represents 'update' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp atomic update
+/// \endcode
+/// In this example directive '#pragma omp atomic' has clause 'update'.
+///
+class OMPUpdateClause : public OMPClause {
+public:
+  /// \brief Build 'update' clause.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPUpdateClause(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_update, StartLoc, EndLoc) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPUpdateClause()
+      : OMPClause(OMPC_update, SourceLocation(), SourceLocation()) {}
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_update;
+  }
+
+  StmtRange children() { return StmtRange(); }
+};
+
+/// \brief This represents 'capture' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp atomic capture
+/// \endcode
+/// In this example directive '#pragma omp atomic' has clause 'capture'.
+///
+class OMPCaptureClause : public OMPClause {
+public:
+  /// \brief Build 'write' clause.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPCaptureClause(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_capture, StartLoc, EndLoc) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPCaptureClause()
+      : OMPClause(OMPC_capture, SourceLocation(), SourceLocation()) {}
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_capture;
+  }
+
+  StmtRange children() { return StmtRange(); }
+};
+
+/// \brief This represents 'seq_cst' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp atomic capture seq_cst
+/// \endcode
+/// In this example directive '#pragma omp atomic' has clauses 'capture' and
+/// 'seq_cst'.
+///
+class OMPSeqCstClause : public OMPClause {
+public:
+  /// \brief Build 'seq_cst' clause.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPSeqCstClause(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_seq_cst, StartLoc, EndLoc) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPSeqCstClause()
+      : OMPClause(OMPC_seq_cst, SourceLocation(), SourceLocation()) {}
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_seq_cst;
+  }
+
+  StmtRange children() { return StmtRange(); }
+};
+
+/// \brief This represents 'inbranch' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp declare simd inbranch
+/// \endcode
+/// In this example directive '#pragma omp declare simd' has clause 'inbranch'.
+///
+class OMPInBranchClause : public OMPClause {
+public:
+  /// \brief Build 'inbranch' clause.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPInBranchClause(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_inbranch, StartLoc, EndLoc) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPInBranchClause()
+      : OMPClause(OMPC_inbranch, SourceLocation(), SourceLocation()) {}
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_inbranch;
+  }
+
+  StmtRange children() { return StmtRange(); }
+};
+
+/// \brief This represents 'notinbranch' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp declare simd notinbranch
+/// \endcode
+/// In this example directive '#pragma omp declare simd' has
+/// clause 'notinbranch'.
+///
+class OMPNotInBranchClause : public OMPClause {
+public:
+  /// \brief Build 'notinbranch' clause.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPNotInBranchClause(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_notinbranch, StartLoc, EndLoc) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPNotInBranchClause()
+      : OMPClause(OMPC_notinbranch, SourceLocation(), SourceLocation()) {}
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_notinbranch;
+  }
+
+  StmtRange children() { return StmtRange(); }
+};
+
+/// \brief This represents clause 'flush' in the '#pragma omp ...' directives.
+///
+/// \code
+/// #pragma omp flush(a,b)
+/// \endcode
+/// In this example directive '#pragma omp flush' has pseudo clause 'flush'
+/// with the variables 'a' and 'b'.
+///
+class OMPFlushClause : public OMPVarListClause<OMPFlushClause> {
+  /// \brief Build clause with number of variables \a N.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  /// \param N Number of the variables in the clause.
+  ///
+  OMPFlushClause(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N)
+      : OMPVarListClause<OMPFlushClause>(OMPC_flush, StartLoc, EndLoc, N) {}
+
+  /// \brief Build an empty clause.
+  ///
+  /// \param N Number of variables.
+  ///
+  explicit OMPFlushClause(unsigned N)
+      : OMPVarListClause<OMPFlushClause>(OMPC_flush, SourceLocation(),
+                                         SourceLocation(), N) {}
+
+public:
+  /// \brief Creates clause with a list of variables \a VL.
+  ///
+  /// \param C AST context.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
+  /// \param VL List of references to the variables.
+  ///
+  static OMPFlushClause *Create(const ASTContext &C, SourceLocation StartLoc,
+                                SourceLocation EndLoc, ArrayRef<Expr *> VL);
+  /// \brief Creates an empty clause with the place for \a N variables.
+  ///
+  /// \param C AST context.
+  /// \param N The number of variables.
+  ///
+  static OMPFlushClause *CreateEmpty(const ASTContext &C, unsigned N);
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_flush;
+  }
+
+  StmtRange children() {
+    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
+                     reinterpret_cast<Stmt **>(varlist_end()));
+  }
+};
+
+/// \brief This represents clause 'depend' in the '#pragma omp ...'
+/// directives.
+///
+/// \code
+/// #pragma omp task depend(in : a,b[:])
+/// \endcode
+/// In this example directive '#pragma omp task' has clause 'depend'
+/// with dependence type 'in' and variables 'a' and 'b[:]'.
+///
+class OMPDependClause : public OMPVarListClause<OMPDependClause> {
+  friend class OMPClauseReader;
+  friend class OMPClauseWriter;
+  /// \brief Dependence type for the 'depend' clause.
+  OpenMPDependClauseType Type;
+  /// \brief Location of the dependence type.
+  SourceLocation TypeLoc;
+
+  /// \brief Set Type for the clause.
+  ///
+  /// \param Ty Type for the clause.
+  ///
+  void setType(OpenMPDependClauseType Ty) { Type = Ty; }
 
-  /// \brief Sets the location of ':'.
-  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }
-  /// \brief Returns the location of ':'.
-  SourceLocation getColonLoc() const { return ColonLoc; }
+  /// \brief Set type location.
+  ///
+  /// \param TyLoc Type location.
+  ///
+  void setTypeLoc(SourceLocation TyLoc) { TypeLoc = TyLoc; }
 
-  /// \brief Returns alignment.
-  Expr *getAlignment() { return *varlist_end(); }
-  /// \brief Returns alignment.
-  const Expr *getAlignment() const { return *varlist_end(); }
+  /// \brief Build clause with number of variables \a N and type \a Ty.
+  ///
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  /// \param N Number of the variables in the clause.
+  /// \param Ty Dependence type.
+  /// \param TyLoc Location of the type.
+  ///
+  OMPDependClause(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N,
+                  OpenMPDependClauseType Ty, SourceLocation TyLoc)
+      : OMPVarListClause<OMPDependClause>(OMPC_depend, StartLoc, EndLoc, N),
+        Type(Ty), TypeLoc(TyLoc) {}
 
-  StmtRange children() {
-    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
-                     reinterpret_cast<Stmt **>(varlist_end() + 1));
+  /// \brief Build an empty clause.
+  ///
+  /// \param N Number of variables.
+  ///
+  explicit OMPDependClause(unsigned N)
+      : OMPVarListClause<OMPDependClause>(OMPC_depend, SourceLocation(),
+                                          SourceLocation(), N),
+        Type(OMPC_DEPEND_unknown), TypeLoc(SourceLocation()) {}
+
+  /// \brief Sets begins for the clause.
+  void setBegins(ArrayRef<Expr *> Begins);
+  /// \brief Sets size in bytes for the clause.
+  void setSizeInBytes(ArrayRef<Expr *> SizeInBytes);
+
+public:
+  /// \brief Creates clause with a list of variables \a VL and type \a Ty.
+  ///
+  /// \param C AST context.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
+  /// \param VL List of references to the variables.
+  /// \param Ty reduction operator.
+  /// \param TyLoc Location of the operator.
+  ///
+  static OMPDependClause *Create(const ASTContext &C, SourceLocation StartLoc,
+                                 SourceLocation EndLoc, ArrayRef<Expr *> VL,
+                                 ArrayRef<Expr *> Begins,
+                                 ArrayRef<Expr *> SizeInBytes,
+                                 OpenMPDependClauseType Ty,
+                                 SourceLocation TyLoc);
+  /// \brief Creates an empty clause with the place for \a N variables.
+  ///
+  /// \param C AST context.
+  /// \param N The number of variables.
+  ///
+  static OMPDependClause *CreateEmpty(const ASTContext &C, unsigned N);
+
+  /// \brief Fetches dependence type for the clause.
+  OpenMPDependClauseType getType() const LLVM_READONLY { return Type; }
+
+  /// \brief Fetches location of clause dependence type.
+  SourceLocation getTypeLoc() const LLVM_READONLY { return TypeLoc; }
+
+  /// \brief Fetches begins for the specified index.
+  Expr *getBegins(unsigned Index) LLVM_READONLY;
+  Expr *getBegins(unsigned Index) const LLVM_READONLY {
+    return const_cast<OMPDependClause *>(this)->getBegins(Index);
+  }
+  /// \brief Fetches the size in bytes for the specified index.
+  Expr *getSizeInBytes(unsigned Index) LLVM_READONLY;
+  Expr *getSizeInBytes(unsigned Index) const LLVM_READONLY {
+    return const_cast<OMPDependClause *>(this)->getSizeInBytes(Index);
   }
 
   static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_aligned;
+    return T->getClauseKind() == OMPC_depend;
+  }
+
+  StmtRange children() {
+    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
+                     reinterpret_cast<Stmt **>(varlist_end()) +
+                         2 * varlist_size());
   }
 };
 
-/// \brief This represents clause 'copyin' in the '#pragma omp ...' directives.
+/// \brief This represents clause 'uniform' in the '#pragma omp ...' directives.
 ///
 /// \code
-/// #pragma omp parallel copyin(a,b)
+/// #pragma omp declare simd uniform(a,b)
 /// \endcode
-/// In this example directive '#pragma omp parallel' has clause 'copyin'
+/// In this example directive '#pragma omp declare simd' has clause 'uniform'
 /// with the variables 'a' and 'b'.
 ///
-class OMPCopyinClause : public OMPVarListClause<OMPCopyinClause> {
+class OMPUniformClause : public OMPVarListClause<OMPUniformClause> {
   /// \brief Build clause with number of variables \a N.
   ///
   /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
   /// \param EndLoc Ending location of the clause.
   /// \param N Number of the variables in the clause.
   ///
-  OMPCopyinClause(SourceLocation StartLoc, SourceLocation LParenLoc,
-                  SourceLocation EndLoc, unsigned N)
-      : OMPVarListClause<OMPCopyinClause>(OMPC_copyin, StartLoc, LParenLoc,
-                                          EndLoc, N) {}
+  OMPUniformClause(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N)
+      : OMPVarListClause<OMPUniformClause>(OMPC_uniform, StartLoc, EndLoc, N) {}
 
   /// \brief Build an empty clause.
   ///
   /// \param N Number of variables.
   ///
-  explicit OMPCopyinClause(unsigned N)
-      : OMPVarListClause<OMPCopyinClause>(OMPC_copyin, SourceLocation(),
-                                          SourceLocation(), SourceLocation(),
-                                          N) {}
+  explicit OMPUniformClause(unsigned N)
+      : OMPVarListClause<OMPUniformClause>(OMPC_uniform, SourceLocation(),
+                                           SourceLocation(), N) {}
 
 public:
   /// \brief Creates clause with a list of variables \a VL.
   ///
   /// \param C AST context.
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param EndLoc Ending location of the clause.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
   /// \param VL List of references to the variables.
   ///
-  static OMPCopyinClause *Create(const ASTContext &C, SourceLocation StartLoc,
-                                 SourceLocation LParenLoc,
-                                 SourceLocation EndLoc, ArrayRef<Expr *> VL);
-  /// \brief Creates an empty clause with \a N variables.
+  static OMPUniformClause *Create(const ASTContext &C, SourceLocation StartLoc,
+                                  SourceLocation EndLoc, ArrayRef<Expr *> VL);
+  /// \brief Creates an empty clause with the place for \a N variables.
   ///
   /// \param C AST context.
   /// \param N The number of variables.
   ///
-  static OMPCopyinClause *CreateEmpty(const ASTContext &C, unsigned N);
+  static OMPUniformClause *CreateEmpty(const ASTContext &C, unsigned N);
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_uniform;
+  }
 
   StmtRange children() {
     return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
                      reinterpret_cast<Stmt **>(varlist_end()));
   }
+};
+
+/// \brief This represents 'safelen' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp simd safelen(4)
+/// \endcode
+/// In this example directive '#pragma omp simd' has clause 'safelen'
+/// with single expression '4'.
+/// If the safelen clause is used then no two iterations executed
+/// concurrently with SIMD instructions can have a greater distance
+/// in the logical iteration space than its value. The parameter of
+/// the safelen clause must be a constant positive integer expression.
+///
+class OMPSafelenClause : public OMPClause {
+  friend class OMPClauseReader;
+  /// \brief Safe iteration space distance.
+  Stmt *Safelen;
+  /// \brief Set the safe iteration space distance.
+  ///
+  /// \param E safe iteration space distance.
+  ///
+  void setSafelen(Expr *E) { Safelen = E; }
+
+public:
+  /// \brief Build 'safelen' clause.
+  ///
+  /// \param E Expression associated with this clause.
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPSafelenClause(Expr *E, SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_safelen, StartLoc, EndLoc), Safelen(E) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPSafelenClause()
+      : OMPClause(OMPC_safelen, SourceLocation(), SourceLocation()),
+        Safelen(0) {}
+
+  /// \brief Return safe iteration space distance.
+  ///
+  Expr *getSafelen() { return dyn_cast_or_null<Expr>(Safelen); }
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_safelen;
+  }
+
+  StmtRange children() { return StmtRange(&Safelen, &Safelen + 1); }
+};
+
+/// \brief This represents 'simdlen' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp declare simd simdlen(4)
+/// \endcode
+/// In this example directive '#pragma omp declare simd' has clause 'simdlen'
+/// with single expression '4'.
+///
+class OMPSimdlenClause : public OMPClause {
+  friend class OMPClauseReader;
+  /// \brief Safe iteration space distance.
+  Stmt *Simdlen;
+  /// \brief Set the safe iteration space distance.
+  ///
+  /// \param E safe iteration space distance.
+  ///
+  void setSimdlen(Expr *E) { Simdlen = E; }
+
+public:
+  /// \brief Build 'simdlen' clause.
+  ///
+  /// \param E Expression associated with this clause.
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPSimdlenClause(Expr *E, SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_simdlen, StartLoc, EndLoc), Simdlen(E) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPSimdlenClause()
+      : OMPClause(OMPC_simdlen, SourceLocation(), SourceLocation()),
+        Simdlen(0) {}
+
+  /// \brief Return safe iteration space distance.
+  ///
+  Expr *getSimdlen() const { return dyn_cast_or_null<Expr>(Simdlen); }
 
   static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_copyin;
+    return T->getClauseKind() == OMPC_simdlen;
   }
+
+  StmtRange children() { return StmtRange(&Simdlen, &Simdlen + 1); }
 };
 
-/// \brief This represents clause 'copyprivate' in the '#pragma omp ...'
+/// \brief This represents 'num_teams' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp teams num_teams(4)
+/// \endcode
+/// In this example directive '#pragma omp teams' has clause 'num_teams'
+/// with single expression '4'.
+///
+class OMPNumTeamsClause : public OMPClause {
+  friend class OMPClauseReader;
+  /// \brief Number of teams.
+  Stmt *NumTeams;
+  /// \brief Set the number of teams.
+  ///
+  /// \param E number of teams.
+  ///
+  void setNumTeams(Expr *E) { NumTeams = E; }
+
+public:
+  /// \brief Build 'num_teams' clause.
+  ///
+  /// \param E Expression associated with this clause.
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPNumTeamsClause(Expr *E, SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_num_teams, StartLoc, EndLoc), NumTeams(E) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPNumTeamsClause()
+      : OMPClause(OMPC_num_teams, SourceLocation(), SourceLocation()),
+        NumTeams(0) {}
+
+  /// \brief Return the number of teams.
+  ///
+  Expr *getNumTeams() const { return dyn_cast_or_null<Expr>(NumTeams); }
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_num_teams;
+  }
+
+  StmtRange children() { return StmtRange(&NumTeams, &NumTeams + 1); }
+};
+
+/// \brief This represents 'thread_limit' clause in the '#pragma omp ...'
+/// directive.
+///
+/// \code
+/// #pragma omp teams thread_limit(4)
+/// \endcode
+/// In this example directive '#pragma omp teams' has clause 'thread_limit'
+/// with single expression '4'.
+///
+class OMPThreadLimitClause : public OMPClause {
+  friend class OMPClauseReader;
+  /// \brief Thread limit.
+  Stmt *ThreadLimit;
+  /// \brief Set the thread limit.
+  ///
+  /// \param E thread limit.
+  ///
+  void setThreadLimit(Expr *E) { ThreadLimit = E; }
+
+public:
+  /// \brief Build 'thread_limit' clause.
+  ///
+  /// \param E Expression associated with this clause.
+  /// \param StartLoc Starting location of the clause.
+  /// \param EndLoc Ending location of the clause.
+  ///
+  OMPThreadLimitClause(Expr *E, SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPClause(OMPC_thread_limit, StartLoc, EndLoc), ThreadLimit(E) {}
+
+  /// \brief Build an empty clause.
+  ///
+  explicit OMPThreadLimitClause()
+      : OMPClause(OMPC_thread_limit, SourceLocation(), SourceLocation()),
+        ThreadLimit(0) {}
+
+  /// \brief Return the number of teams.
+  ///
+  Expr *getThreadLimit() const { return dyn_cast_or_null<Expr>(ThreadLimit); }
+
+  static bool classof(const OMPClause *T) {
+    return T->getClauseKind() == OMPC_thread_limit;
+  }
+
+  StmtRange children() { return StmtRange(&ThreadLimit, &ThreadLimit + 1); }
+};
+
+/// \brief This represents clause 'linear' in the '#pragma omp ...'
 /// directives.
 ///
 /// \code
-/// #pragma omp single copyprivate(a,b)
+/// #pragma omp simd linear(a,b : 2)
 /// \endcode
-/// In this example directive '#pragma omp single' has clause 'copyprivate'
-/// with the variables 'a' and 'b'.
+/// In this example directive '#pragma omp simd' has clause 'linear'
+/// with variables 'a', 'b' and linear step '2'.
 ///
-class OMPCopyprivateClause : public OMPVarListClause<OMPCopyprivateClause> {
-  /// \brief Build clause with number of variables \a N.
+class OMPLinearClause : public OMPVarListClause<OMPLinearClause> {
+  friend class OMPClauseReader;
+  friend class OMPClauseWriter;
+
+  /// \brief Start location of the linear step in cource code.
+  SourceLocation StepLoc;
+
+  /// \brief Set step for the clause.
+  ///
+  /// \param E step for the clause.
+  ///
+  void setStep(Expr *E) {
+    *(reinterpret_cast<Stmt **>(varlist_end())) = cast_or_null<Stmt>(E);
+  }
+
+  /// \brief Set step location.
+  ///
+  /// \param StLoc step location.
+  ///
+  void setStepLoc(SourceLocation StLoc) { StepLoc = StLoc; }
+
+  /// \brief Build clause with number of variables \a N and a step \a St.
   ///
   /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
   /// \param EndLoc Ending location of the clause.
   /// \param N Number of the variables in the clause.
+  /// \param StLoc Location of the linear step.
   ///
-  OMPCopyprivateClause(SourceLocation StartLoc, SourceLocation LParenLoc,
-                       SourceLocation EndLoc, unsigned N)
-      : OMPVarListClause<OMPCopyprivateClause>(OMPC_copyprivate, StartLoc,
-                                               LParenLoc, EndLoc, N) {}
+  OMPLinearClause(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N,
+                  SourceLocation StLoc)
+      : OMPVarListClause<OMPLinearClause>(OMPC_linear, StartLoc, EndLoc, N),
+        StepLoc(StLoc) {}
 
   /// \brief Build an empty clause.
   ///
   /// \param N Number of variables.
   ///
-  explicit OMPCopyprivateClause(unsigned N)
-      : OMPVarListClause<OMPCopyprivateClause>(
-            OMPC_copyprivate, SourceLocation(), SourceLocation(),
-            SourceLocation(), N) {}
+  explicit OMPLinearClause(unsigned N)
+      : OMPVarListClause<OMPLinearClause>(OMPC_linear, SourceLocation(),
+                                          SourceLocation(), N),
+        StepLoc(SourceLocation()) {}
 
 public:
-  /// \brief Creates clause with a list of variables \a VL.
+  /// \brief Creates clause with a list of variables \a VL and a step
+  /// \a St.
   ///
   /// \param C AST context.
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param EndLoc Ending location of the clause.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
   /// \param VL List of references to the variables.
+  /// \param St Linear step.
+  /// \param StLoc Location of the linear step.
   ///
-  static OMPCopyprivateClause *
-  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,
-         SourceLocation EndLoc, ArrayRef<Expr *> VL);
-  /// \brief Creates an empty clause with \a N variables.
+  static OMPLinearClause *Create(const ASTContext &C, SourceLocation StartLoc,
+                                 SourceLocation EndLoc, ArrayRef<Expr *> VL,
+                                 Expr *St, SourceLocation StLoc);
+  /// \brief Creates an empty clause with the place for \a N variables.
   ///
   /// \param C AST context.
   /// \param N The number of variables.
   ///
-  static OMPCopyprivateClause *CreateEmpty(const ASTContext &C, unsigned N);
+  static OMPLinearClause *CreateEmpty(const ASTContext &C, unsigned N);
 
-  StmtRange children() {
-    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
-                     reinterpret_cast<Stmt **>(varlist_end()));
+  /// \brief Fetches the linear step.
+  Expr *getStep() {
+    return dyn_cast_or_null<Expr>(*(reinterpret_cast<Stmt **>(varlist_end())));
   }
 
+  /// \brief Fetches location of linear step.
+  SourceLocation getStepLoc() const { return StepLoc; }
+
   static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_copyprivate;
+    return T->getClauseKind() == OMPC_linear;
+  }
+
+  StmtRange children() {
+    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
+                     reinterpret_cast<Stmt **>(varlist_end() + 1));
   }
 };
 
-/// \brief This represents pseudo clause 'flush' for the '#pragma omp flush'
-/// directive.
+/// \brief This represents clause 'aligned' in the '#pragma omp ...'
+/// directives.
 ///
 /// \code
-/// #pragma omp flush(a,b)
+/// #pragma omp simd aligned(a,b : 8)
 /// \endcode
-/// In this example directive '#pragma omp flush' has pseudo clause 'flush'
-/// with the variables 'a' and 'b'.
+/// In this example directive '#pragma omp simd' has clause 'aligned'
+/// with variables 'a', 'b' and alignment '8'.
 ///
-class OMPFlushClause : public OMPVarListClause<OMPFlushClause> {
+class OMPAlignedClause : public OMPVarListClause<OMPAlignedClause> {
+  friend class OMPClauseReader;
+  friend class OMPClauseWriter;
+
+  /// \brief Start location of the alignment in cource code.
+  SourceLocation AlignmentLoc;
+
+  /// \brief Set alignment for the clause.
+  ///
+  /// \param E alignment for the clause.
+  ///
+  void setAlignment(Expr *E) {
+    *(reinterpret_cast<Stmt **>(varlist_end())) = cast_or_null<Stmt>(E);
+  }
+
+  /// \brief Set alignment location.
+  ///
+  /// \param ALoc alignment location.
+  ///
+  void setAlignmentLoc(SourceLocation ALoc) { AlignmentLoc = ALoc; }
+
   /// \brief Build clause with number of variables \a N.
   ///
   /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
   /// \param EndLoc Ending location of the clause.
   /// \param N Number of the variables in the clause.
+  /// \param ALoc Location of the alignment.
   ///
-  OMPFlushClause(SourceLocation StartLoc, SourceLocation LParenLoc,
-                 SourceLocation EndLoc, unsigned N)
-      : OMPVarListClause<OMPFlushClause>(OMPC_flush, StartLoc, LParenLoc,
-                                         EndLoc, N) {}
+  OMPAlignedClause(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N,
+                   SourceLocation ALoc)
+      : OMPVarListClause<OMPAlignedClause>(OMPC_aligned, StartLoc, EndLoc, N),
+        AlignmentLoc(ALoc) {}
 
   /// \brief Build an empty clause.
   ///
   /// \param N Number of variables.
   ///
-  explicit OMPFlushClause(unsigned N)
-      : OMPVarListClause<OMPFlushClause>(OMPC_flush, SourceLocation(),
-                                         SourceLocation(), SourceLocation(),
-                                         N) {}
+  explicit OMPAlignedClause(unsigned N)
+      : OMPVarListClause<OMPAlignedClause>(OMPC_aligned, SourceLocation(),
+                                           SourceLocation(), N),
+        AlignmentLoc(SourceLocation()) {}
 
 public:
-  /// \brief Creates clause with a list of variables \a VL.
+  /// \brief Creates clause with a list of variables \a VL and an alignment
+  /// \a A.
   ///
   /// \param C AST context.
-  /// \param StartLoc Starting location of the clause.
-  /// \param LParenLoc Location of '('.
-  /// \param EndLoc Ending location of the clause.
+  /// \brief StartLoc Starting location of the clause.
+  /// \brief EndLoc Ending location of the clause.
   /// \param VL List of references to the variables.
+  /// \param A Alignment.
+  /// \param ALoc Location of the alignment.
   ///
-  static OMPFlushClause *Create(const ASTContext &C, SourceLocation StartLoc,
-                                SourceLocation LParenLoc, SourceLocation EndLoc,
-                                ArrayRef<Expr *> VL);
-  /// \brief Creates an empty clause with \a N variables.
+  static OMPAlignedClause *Create(const ASTContext &C, SourceLocation StartLoc,
+                                  SourceLocation EndLoc, ArrayRef<Expr *> VL,
+                                  Expr *A, SourceLocation ALoc);
+  /// \brief Creates an empty clause with the place for \a N variables.
   ///
   /// \param C AST context.
   /// \param N The number of variables.
   ///
-  static OMPFlushClause *CreateEmpty(const ASTContext &C, unsigned N);
+  static OMPAlignedClause *CreateEmpty(const ASTContext &C, unsigned N);
 
-  StmtRange children() {
-    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
-                     reinterpret_cast<Stmt **>(varlist_end()));
+  /// \brief Fetches the alignment.
+  Expr *getAlignment() {
+    return dyn_cast_or_null<Expr>(*(reinterpret_cast<Stmt **>(varlist_end())));
   }
 
+  /// \brief Fetches location of the alignment.
+  SourceLocation getAlignmentLoc() const { return AlignmentLoc; }
+
   static bool classof(const OMPClause *T) {
-    return T->getClauseKind() == OMPC_flush;
+    return T->getClauseKind() == OMPC_aligned;
   }
+
+  StmtRange children() {
+    return StmtRange(reinterpret_cast<Stmt **>(varlist_begin()),
+                     reinterpret_cast<Stmt **>(varlist_end() + 1));
+  }
+};
+
+template <typename T> struct make_ptr_clause {
+  typedef T *type;
+};
+template <typename T> struct make_const_ptr_clause {
+  typedef const T *type;
 };
+/// \brief This class implements a simple visitor for OMPClause
+/// subclasses.
+template <class ImplClass, template <typename> class Ptr, typename RetTy>
+class OMPClauseVisitorBase {
+public:
+#define PTR(CLASS) typename Ptr<CLASS>::type
+#define DISPATCH(CLASS)                                                        \
+  return static_cast<ImplClass *>(this)                                        \
+      ->Visit##CLASS(static_cast<PTR(CLASS)>(S))
+
+#define OPENMP_CLAUSE(Name, Class)                                             \
+  RetTy Visit##Class(PTR(Class) S) { DISPATCH(Class); }
+#include "clang/Basic/OpenMPKinds.def"
+
+  RetTy Visit(PTR(OMPClause) S) {
+    // Top switch clause: visit each OMPClause.
+    switch (S->getClauseKind()) {
+    default:
+      llvm_unreachable("Unknown stmt kind!");
+#define OPENMP_CLAUSE(Name, Class)                                             \
+  case OMPC_##Name:                                                            \
+    return Visit##Class(static_cast<PTR(Class)>(S));
+#include "clang/Basic/OpenMPKinds.def"
+    }
+  }
+  // Base case, ignore it. :)
+  RetTy VisitOMPClause(PTR(OMPClause)) { return RetTy(); }
+#undef PTR
+#undef DISPATCH
+};
+
+template <class ImplClass, typename RetTy = void>
+class OMPClauseVisitor
+    : public OMPClauseVisitorBase<ImplClass, make_ptr_clause, RetTy> {};
+template <class ImplClass, typename RetTy = void>
+class ConstOMPClauseVisitor
+    : public OMPClauseVisitorBase<ImplClass, make_const_ptr_clause, RetTy> {};
 
 } // end namespace clang
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/AST/RecursiveASTVisitor.h cfe-3.5.0.src.omp/include/clang/AST/RecursiveASTVisitor.h
--- cfe-3.5.0.src/include/clang/AST/RecursiveASTVisitor.h	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/AST/RecursiveASTVisitor.h	2014-11-28 10:49:29.000000000 -0500
@@ -1419,11 +1419,29 @@
 DEF_TRAVERSE_DECL(UsingShadowDecl, {})
 
 DEF_TRAVERSE_DECL(OMPThreadPrivateDecl, {
-  for (auto *I : D->varlists()) {
-    TRY_TO(TraverseStmt(I));
+  for (OMPThreadPrivateDecl::varlist_iterator I = D->varlist_begin(),
+                                              E = D->varlist_end();
+       I != E; ++I) {
+    TRY_TO(TraverseStmt(*I));
   }
 })
 
+DEF_TRAVERSE_DECL(OMPDeclareSimdDecl, {
+    if (D->getFunction()) { TRY_TO(TraverseDecl(D->getFunction())); }
+  })
+
+DEF_TRAVERSE_DECL(OMPDeclareReductionDecl, {
+    for (OMPDeclareReductionDecl::datalist_iterator I = D->datalist_begin(),
+                                                    E = D->datalist_end();
+         I != E; ++I) {
+      TRY_TO(TraverseType(I->QTy));
+      TRY_TO(TraverseStmt(I->CombinerFunction));
+      TRY_TO(TraverseStmt(I->InitFunction));
+    }
+  })
+
+DEF_TRAVERSE_DECL(OMPDeclareTargetDecl, { })
+
 // A helper method for TemplateDecl's children.
 template <typename Derived>
 bool RecursiveASTVisitor<Derived>::TraverseTemplateParameterListHelper(
@@ -2178,8 +2196,9 @@
 
 // These exprs (most of them), do not need any action except iterating
 // over the children.
-DEF_TRAVERSE_STMT(AddrLabelExpr, {})
-DEF_TRAVERSE_STMT(ArraySubscriptExpr, {})
+DEF_TRAVERSE_STMT(AddrLabelExpr, { })
+DEF_TRAVERSE_STMT(ArraySubscriptExpr, { })
+DEF_TRAVERSE_STMT(CEANIndexExpr, { })
 DEF_TRAVERSE_STMT(BlockExpr, {
   TRY_TO(TraverseDecl(S->getBlockDecl()));
   return true; // no child statements to loop through.
@@ -2291,227 +2310,190 @@
 // Traverse OpenCL: AsType, Convert.
 DEF_TRAVERSE_STMT(AsTypeExpr, {})
 
-// OpenMP directives.
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::TraverseOMPExecutableDirective(
-    OMPExecutableDirective *S) {
-  for (auto *C : S->clauses()) {
-    TRY_TO(TraverseOMPClause(C));
+// OpenMP directives
+namespace {
+template <class T>
+class RecursiveOMPClauseVisitor :
+          public OMPClauseVisitor<RecursiveOMPClauseVisitor<T>, bool> {
+  RecursiveASTVisitor<T> *Visitor;
+  RecursiveASTVisitor<T> &getDerived() { return *Visitor; }
+public:
+  RecursiveOMPClauseVisitor(RecursiveASTVisitor<T> *V) : Visitor(V) { }
+#define OPENMP_CLAUSE(Name, Class)                                      \
+  bool Visit##Class(Class *S) {                                         \
+    for (Stmt::child_range Range = S->children(); Range; ++Range) {     \
+      if (!Visitor->TraverseStmt(*Range)) return false;                 \
+    }                                                                   \
+    return true;                                                        \
   }
-  return true;
+#include "clang/Basic/OpenMPKinds.def"
+};
 }
 
-DEF_TRAVERSE_STMT(OMPParallelDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPExecutableDirective, {
+  RecursiveOMPClauseVisitor<Derived> V(this);
+  ArrayRef<OMPClause *> Clauses = S->clauses();
+  for (ArrayRef<OMPClause *>::iterator I = Clauses.begin(), E = Clauses.end();
+       I != E; ++I)
+    if (!V.Visit(*I)) return false;
+})
 
-DEF_TRAVERSE_STMT(OMPSimdDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPParallelDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPForDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPTeamsDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPSectionsDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPDistributeDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPSectionDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPForDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPSingleDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPParallelForDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPMasterDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPParallelForSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPCriticalDirective, {
-  TRY_TO(TraverseDeclarationNameInfo(S->getDirectiveName()));
-  TRY_TO(TraverseOMPExecutableDirective(S));
+DEF_TRAVERSE_STMT(OMPSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
 })
 
-DEF_TRAVERSE_STMT(OMPParallelForDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPForSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPParallelSectionsDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPDistributeSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPTaskDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPDistributeParallelForDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPTaskyieldDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPDistributeParallelForSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPBarrierDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPTeamsDistributeDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPTaskwaitDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPTeamsDistributeSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-DEF_TRAVERSE_STMT(OMPFlushDirective,
-                  { TRY_TO(TraverseOMPExecutableDirective(S)); })
+DEF_TRAVERSE_STMT(OMPTargetTeamsDistributeDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-// OpenMP clauses.
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::TraverseOMPClause(OMPClause *C) {
-  if (!C)
-    return true;
-  switch (C->getClauseKind()) {
-#define OPENMP_CLAUSE(Name, Class)                                             \
-  case OMPC_##Name:                                                            \
-    TRY_TO(Visit##Class(static_cast<Class *>(C)));                             \
-    break;
-#include "clang/Basic/OpenMPKinds.def"
-  case OMPC_threadprivate:
-  case OMPC_unknown:
-    break;
-  }
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTargetTeamsDistributeSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPIfClause(OMPIfClause *C) {
-  TRY_TO(TraverseStmt(C->getCondition()));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPSectionsDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPFinalClause(OMPFinalClause *C) {
-  TRY_TO(TraverseStmt(C->getCondition()));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPParallelSectionsDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool
-RecursiveASTVisitor<Derived>::VisitOMPNumThreadsClause(OMPNumThreadsClause *C) {
-  TRY_TO(TraverseStmt(C->getNumThreads()));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPSectionDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPSafelenClause(OMPSafelenClause *C) {
-  TRY_TO(TraverseStmt(C->getSafelen()));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPSingleDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool
-RecursiveASTVisitor<Derived>::VisitOMPCollapseClause(OMPCollapseClause *C) {
-  TRY_TO(TraverseStmt(C->getNumForLoops()));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTaskDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPDefaultClause(OMPDefaultClause *) {
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTaskyieldDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPProcBindClause(OMPProcBindClause *) {
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPMasterDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool
-RecursiveASTVisitor<Derived>::VisitOMPScheduleClause(OMPScheduleClause *C) {
-  TRY_TO(TraverseStmt(C->getChunkSize()));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPCriticalDirective, {
+  TRY_TO(TraverseDeclarationNameInfo(S->getDirectiveName()));
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPOrderedClause(OMPOrderedClause *) {
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPBarrierDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPNowaitClause(OMPNowaitClause *) {
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTaskwaitDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPUntiedClause(OMPUntiedClause *) {
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTaskgroupDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool
-RecursiveASTVisitor<Derived>::VisitOMPMergeableClause(OMPMergeableClause *) {
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPAtomicDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-template <typename T>
-bool RecursiveASTVisitor<Derived>::VisitOMPClauseList(T *Node) {
-  for (auto *E : Node->varlists()) {
-    TRY_TO(TraverseStmt(E));
-  }
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPFlushDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPPrivateClause(OMPPrivateClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPOrderedDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPFirstprivateClause(
-    OMPFirstprivateClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPCancelDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPLastprivateClause(
-    OMPLastprivateClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPCancellationPointDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPSharedClause(OMPSharedClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTargetDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPLinearClause(OMPLinearClause *C) {
-  TRY_TO(TraverseStmt(C->getStep()));
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTargetDataDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPAlignedClause(OMPAlignedClause *C) {
-  TRY_TO(TraverseStmt(C->getAlignment()));
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTargetUpdateDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPCopyinClause(OMPCopyinClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTargetTeamsDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPCopyprivateClause(
-    OMPCopyprivateClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTeamsDistributeParallelForDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool
-RecursiveASTVisitor<Derived>::VisitOMPReductionClause(OMPReductionClause *C) {
-  TRY_TO(TraverseNestedNameSpecifierLoc(C->getQualifierLoc()));
-  TRY_TO(TraverseDeclarationNameInfo(C->getNameInfo()));
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTeamsDistributeParallelForSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
-template <typename Derived>
-bool RecursiveASTVisitor<Derived>::VisitOMPFlushClause(OMPFlushClause *C) {
-  TRY_TO(VisitOMPClauseList(C));
-  return true;
-}
+DEF_TRAVERSE_STMT(OMPTargetTeamsDistributeParallelForDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
+
+DEF_TRAVERSE_STMT(OMPTargetTeamsDistributeParallelForSimdDirective, {
+  return TraverseOMPExecutableDirective(S);
+})
 
 // FIXME: look at the following tricky-seeming exprs to see if we
 // need to recurse on anything.  These are ones that have methods
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/AST/Stmt.h cfe-3.5.0.src.omp/include/clang/AST/Stmt.h
--- cfe-3.5.0.src/include/clang/AST/Stmt.h	2014-07-18 20:45:07.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/AST/Stmt.h	2014-11-28 10:49:29.000000000 -0500
@@ -2037,9 +2037,11 @@
   /// \brief The number of variable captured, including 'this'.
   unsigned NumCaptures;
 
-  /// \brief The pointer part is the implicit the outlined function and the 
-  /// int part is the captured region kind, 'CR_Default' etc.
-  llvm::PointerIntPair<CapturedDecl *, 1, CapturedRegionKind> CapDeclAndKind;
+  /// \brief The implicit outlined function.
+  CapturedDecl *TheCapturedDecl;
+
+  /// \brief The kind of this statement, including 'CR_Default', etc.
+  CapturedRegionKind RegionKind;
 
   /// \brief The record for captured variables, a RecordDecl or CXXRecordDecl.
   RecordDecl *TheRecordDecl;
@@ -2076,7 +2078,7 @@
   }
 
   /// \brief Retrieve the outlined function declaration.
-  CapturedDecl *getCapturedDecl() { return CapDeclAndKind.getPointer(); }
+  CapturedDecl *getCapturedDecl() { return TheCapturedDecl; }
   const CapturedDecl *getCapturedDecl() const {
     return const_cast<CapturedStmt *>(this)->getCapturedDecl();
   }
@@ -2084,17 +2086,17 @@
   /// \brief Set the outlined function declaration.
   void setCapturedDecl(CapturedDecl *D) {
     assert(D && "null CapturedDecl");
-    CapDeclAndKind.setPointer(D);
+    TheCapturedDecl = D;
   }
 
   /// \brief Retrieve the captured region kind.
   CapturedRegionKind getCapturedRegionKind() const {
-    return CapDeclAndKind.getInt();
+    return RegionKind;
   }
 
   /// \brief Set the captured region kind.
   void setCapturedRegionKind(CapturedRegionKind Kind) {
-    CapDeclAndKind.setInt(Kind);
+    RegionKind = Kind;
   }
 
   /// \brief Retrieve the record declaration for captured variables.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/AST/StmtOpenMP.h cfe-3.5.0.src.omp/include/clang/AST/StmtOpenMP.h
--- cfe-3.5.0.src/include/clang/AST/StmtOpenMP.h	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/AST/StmtOpenMP.h	2014-11-28 10:49:29.000000000 -0500
@@ -1,4 +1,4 @@
-//===- StmtOpenMP.h - Classes for OpenMP directives  ------------*- C++ -*-===//
+//===- StmtOpenMP.h - Classes for OpenMP directives and clauses -*- C++ -*-===//
 //
 //                     The LLVM Compiler Infrastructure
 //
@@ -15,11 +15,11 @@
 #ifndef LLVM_CLANG_AST_STMTOPENMP_H
 #define LLVM_CLANG_AST_STMTOPENMP_H
 
+#include "clang/Basic/SourceLocation.h"
+#include "clang/Basic/OpenMPKinds.h"
+#include "clang/AST/Stmt.h"
 #include "clang/AST/Expr.h"
 #include "clang/AST/OpenMPClause.h"
-#include "clang/AST/Stmt.h"
-#include "clang/Basic/OpenMPKinds.h"
-#include "clang/Basic/SourceLocation.h"
 
 namespace clang {
 
@@ -34,134 +34,113 @@
   friend class ASTStmtReader;
   /// \brief Kind of the directive.
   OpenMPDirectiveKind Kind;
-  /// \brief Starting location of the directive (directive keyword).
+  /// \brief Starting location of the directive kind.
   SourceLocation StartLoc;
   /// \brief Ending location of the directive.
   SourceLocation EndLoc;
-  /// \brief Numbers of clauses.
-  const unsigned NumClauses;
-  /// \brief Number of child expressions/stmts.
-  const unsigned NumChildren;
-  /// \brief Offset from this to the start of clauses.
-  /// There are NumClauses pointers to clauses, they are followed by
-  /// NumChildren pointers to child stmts/exprs (if the directive type
-  /// requires an associated stmt, then it has to be the first of them).
-  const unsigned ClausesOffset;
-
-  /// \brief Get the clauses storage.
-  MutableArrayRef<OMPClause *> getClauses() {
-    OMPClause **ClauseStorage = reinterpret_cast<OMPClause **>(
-        reinterpret_cast<char *>(this) + ClausesOffset);
-    return MutableArrayRef<OMPClause *>(ClauseStorage, NumClauses);
-  }
+  /// \brief Number of clauses.
+  unsigned NumClauses;
+  /// \brief Pointer to the list of clauses.
+  OMPClause **const Clauses;
+  /// \brief Number of associated expressions and statements.
+  unsigned NumStmts;
+  /// \brief Has associated statement.
+  bool AStmt;
 
 protected:
   /// \brief Build instance of directive of class \a K.
   ///
   /// \param SC Statement class.
   /// \param K Kind of OpenMP directive.
-  /// \param StartLoc Starting location of the directive (directive keyword).
-  /// \param EndLoc Ending location of the directive.
+  /// \param SL Starting location of the directive kind.
+  /// \param EL Ending location of the directive.
+  /// \param N Number of clauses.
+  /// \param ClausesAndStmt A pointer to the buffer for clauses.
   ///
-  template <typename T>
-  OMPExecutableDirective(const T *, StmtClass SC, OpenMPDirectiveKind K,
+  OMPExecutableDirective(StmtClass SC, OpenMPDirectiveKind K,
                          SourceLocation StartLoc, SourceLocation EndLoc,
-                         unsigned NumClauses, unsigned NumChildren)
-      : Stmt(SC), Kind(K), StartLoc(std::move(StartLoc)),
-        EndLoc(std::move(EndLoc)), NumClauses(NumClauses),
-        NumChildren(NumChildren),
-        ClausesOffset(llvm::RoundUpToAlignment(sizeof(T),
-                                               llvm::alignOf<OMPClause *>())) {}
+                         unsigned N, OMPClause **CL, bool AStmt,
+                         unsigned NumStmts)
+      : Stmt(SC), Kind(K), StartLoc(StartLoc), EndLoc(EndLoc), NumClauses(N),
+        Clauses(CL), NumStmts(NumStmts), AStmt(AStmt) {}
+
+  /// \brief Fetches the list of clauses associated with this directive.
+  llvm::MutableArrayRef<OMPClause *> getClauses() {
+    return llvm::MutableArrayRef<OMPClause *>(Clauses, NumClauses);
+  }
+
+  /// \brief Fetches the list of clauses associated with this directive.
+  ArrayRef<OMPClause *> getClauses() const {
+    return ArrayRef<OMPClause *>(Clauses, NumClauses);
+  }
 
   /// \brief Sets the list of variables for this clause.
   ///
-  /// \param Clauses The list of clauses for the directive.
+  /// \brief Clauses The list of clauses for the directive.
   ///
-  void setClauses(ArrayRef<OMPClause *> Clauses);
+  void setClauses(ArrayRef<OMPClause *> CL);
 
   /// \brief Set the associated statement for the directive.
   ///
   /// /param S Associated statement.
   ///
   void setAssociatedStmt(Stmt *S) {
-    assert(hasAssociatedStmt() && "no associated statement.");
-    *child_begin() = S;
+    assert(AStmt && "No associated stmt allowed.");
+    *reinterpret_cast<Stmt **>(&Clauses[NumClauses]) = S;
   }
 
-public:
-  /// \brief Iterates over a filtered subrange of clauses applied to a
-  /// directive.
-  ///
-  /// This iterator visits only those declarations that meet some run-time
-  /// criteria.
-  template <class FilterPredicate> class filtered_clause_iterator {
-    ArrayRef<OMPClause *>::const_iterator Current;
-    ArrayRef<OMPClause *>::const_iterator End;
-    FilterPredicate Pred;
-    void SkipToNextClause() {
-      while (Current != End && !Pred(*Current))
-        ++Current;
-    }
-
-  public:
-    typedef const OMPClause *value_type;
-    filtered_clause_iterator() : Current(), End() {}
-    filtered_clause_iterator(ArrayRef<OMPClause *> Arr, FilterPredicate Pred)
-        : Current(Arr.begin()), End(Arr.end()), Pred(Pred) {
-      SkipToNextClause();
-    }
-    value_type operator*() const { return *Current; }
-    value_type operator->() const { return *Current; }
-    filtered_clause_iterator &operator++() {
-      ++Current;
-      SkipToNextClause();
-      return *this;
-    }
-
-    filtered_clause_iterator operator++(int) {
-      filtered_clause_iterator tmp(*this);
-      ++(*this);
-      return tmp;
-    }
-
-    bool operator!() { return Current == End; }
-    operator bool() { return Current != End; }
-  };
+  OMPClause **getClausesStorage() const { return Clauses; }
 
-  /// \brief Returns starting location of directive kind.
+public:
+  /// \brief Return starting location of directive kind.
   SourceLocation getLocStart() const { return StartLoc; }
-  /// \brief Returns ending location of directive.
+  /// \brief Return ending location of directive.
   SourceLocation getLocEnd() const { return EndLoc; }
 
   /// \brief Set starting location of directive kind.
   ///
-  /// \param Loc New starting location of directive.
+  /// \brief Loc New starting location of directive.
   ///
   void setLocStart(SourceLocation Loc) { StartLoc = Loc; }
   /// \brief Set ending location of directive.
   ///
-  /// \param Loc New ending location of directive.
+  /// \brief Loc New ending location of directive.
   ///
   void setLocEnd(SourceLocation Loc) { EndLoc = Loc; }
 
   /// \brief Get number of clauses.
   unsigned getNumClauses() const { return NumClauses; }
 
-  /// \brief Returns specified clause.
+  /// \brief Fetches specified clause.
+  ///
+  /// \param i Number of clause.
+  ///
+  OMPClause *getClause(unsigned i) {
+    assert(i < NumClauses && "Wrong number of clause!");
+    return getClauses()[i];
+  }
+
+  /// \brief Fetches specified clause.
   ///
   /// \param i Number of clause.
   ///
-  OMPClause *getClause(unsigned i) const { return clauses()[i]; }
+  OMPClause *getClause(unsigned i) const {
+    assert(i < NumClauses && "Wrong number of clause!");
+    return getClauses()[i];
+  }
 
-  /// \brief Returns true if directive has associated statement.
-  bool hasAssociatedStmt() const { return NumChildren > 0; }
+  /// \brief Return statement associated with the directive.
+  Stmt *getAssociatedStmt() {
+    return AStmt ? *reinterpret_cast<Stmt **>(&Clauses[NumClauses]) : 0;
+  }
 
-  /// \brief Returns statement associated with the directive.
+  /// \brief Return statement associated with the directive.
   Stmt *getAssociatedStmt() const {
-    assert(hasAssociatedStmt() && "no associated statement.");
-    return const_cast<Stmt *>(*child_begin());
+    return AStmt ? *reinterpret_cast<Stmt **>(&Clauses[NumClauses]) : 0;
   }
 
+  bool hasAssociatedStmt() const { return AStmt; }
+
   OpenMPDirectiveKind getDirectiveKind() const { return Kind; }
 
   static bool classof(const Stmt *S) {
@@ -170,17 +149,13 @@
   }
 
   child_range children() {
-    if (!hasAssociatedStmt())
-      return child_range();
-    Stmt **ChildStorage = reinterpret_cast<Stmt **>(getClauses().end());
-    return child_range(ChildStorage, ChildStorage + NumChildren);
+    return child_range(reinterpret_cast<Stmt **>(&Clauses[NumClauses]),
+                       reinterpret_cast<Stmt **>(&Clauses[NumClauses]) +
+                           NumStmts);
   }
 
   ArrayRef<OMPClause *> clauses() { return getClauses(); }
-
-  ArrayRef<OMPClause *> clauses() const {
-    return const_cast<OMPExecutableDirective *>(this)->getClauses();
-  }
+  ArrayRef<OMPClause *> clauses() const { return getClauses(); }
 };
 
 /// \brief This represents '#pragma omp parallel' directive.
@@ -195,22 +170,33 @@
 class OMPParallelDirective : public OMPExecutableDirective {
   /// \brief Build directive with the given start and end location.
   ///
-  /// \param StartLoc Starting location of the directive (directive keyword).
+  /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
   ///
   OMPParallelDirective(SourceLocation StartLoc, SourceLocation EndLoc,
-                       unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPParallelDirectiveClass, OMPD_parallel,
-                               StartLoc, EndLoc, NumClauses, 1) {}
+                       unsigned N)
+      : OMPExecutableDirective(
+            OMPParallelDirectiveClass, OMPD_parallel, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPParallelDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
 
   /// \brief Build an empty directive.
   ///
-  /// \param NumClauses Number of clauses.
+  /// \param N Number of clauses.
   ///
-  explicit OMPParallelDirective(unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPParallelDirectiveClass, OMPD_parallel,
-                               SourceLocation(), SourceLocation(), NumClauses,
-                               1) {}
+  explicit OMPParallelDirective(unsigned N)
+      : OMPExecutableDirective(
+            OMPParallelDirectiveClass, OMPD_parallel, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPParallelDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
 
 public:
   /// \brief Creates directive with a list of \a Clauses.
@@ -219,7 +205,7 @@
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending Location of the directive.
   /// \param Clauses List of clauses.
-  /// \param AssociatedStmt Statement associated with the directive.
+  /// \param AssociatedStmt Statement, associated with the directive.
   ///
   static OMPParallelDirective *
   Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
@@ -228,52 +214,79 @@
   /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  static OMPParallelDirective *CreateEmpty(const ASTContext &C,
-                                           unsigned NumClauses, EmptyShell);
+  static OMPParallelDirective *CreateEmpty(const ASTContext &C, unsigned N,
+                                           EmptyShell);
 
   static bool classof(const Stmt *T) {
     return T->getStmtClass() == OMPParallelDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp simd' directive.
+/// \brief This represents '#pragma omp for' directive.
 ///
 /// \code
-/// #pragma omp simd private(a,b) linear(i,j:s) reduction(+:c,d)
+/// #pragma omp for private(a,b) reduction(+: c,d) ordered
 /// \endcode
-/// In this example directive '#pragma omp simd' has clauses 'private'
-/// with the variables 'a' and 'b', 'linear' with variables 'i', 'j' and
-/// linear step 's', 'reduction' with operator '+' and variables 'c' and 'd'.
+/// In this example directive '#pragma omp for' has clauses 'private'
+/// with the variables 'a' and 'b', 'reduction' with operator '+' and
+/// variables 'c' and 'd' and 'ordered'.
 ///
-class OMPSimdDirective : public OMPExecutableDirective {
+class OMPForDirective : public OMPExecutableDirective {
   friend class ASTStmtReader;
-  /// \brief Number of collapsed loops as specified by 'collapse' clause.
   unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
   /// \param StartLoc Starting location of the directive kind.
-  /// \param EndLoc Ending location of the directive.
-  /// \param CollapsedNum Number of collapsed nested loops.
-  /// \param NumClauses Number of clauses.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
   ///
-  OMPSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,
-                   unsigned CollapsedNum, unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPSimdDirectiveClass, OMPD_simd, StartLoc,
-                               EndLoc, NumClauses, 1),
+  OMPForDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                  unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPForDirectiveClass, OMPD_for, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPForDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
         CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  /// \param CollapsedNum Number of collapsed nested loops.
-  /// \param NumClauses Number of clauses.
+  /// \param N Number of clauses.
   ///
-  explicit OMPSimdDirective(unsigned CollapsedNum, unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPSimdDirectiveClass, OMPD_simd,
-                               SourceLocation(), SourceLocation(), NumClauses,
-                               1),
+  explicit OMPForDirective(unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPForDirectiveClass, OMPD_for, SourceLocation(), SourceLocation(),
+            N, reinterpret_cast<OMPClause **>(
+                   reinterpret_cast<char *>(this) +
+                   llvm::RoundUpToAlignment(sizeof(OMPForDirective),
+                                            llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
         CollapsedNum(CollapsedNum) {}
+  // 5 is for AssociatedStmt, NewIterVar, NewIterEnd, Init, Final
+  // and CollapsedNum is for Counters.
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]));
+  }
 
 public:
   /// \brief Creates directive with a list of \a Clauses.
@@ -281,68 +294,132 @@
   /// \param C AST context.
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending Location of the directive.
-  /// \param CollapsedNum Number of collapsed loops.
   /// \param Clauses List of clauses.
   /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPSimdDirective *Create(const ASTContext &C, SourceLocation StartLoc,
-                                  SourceLocation EndLoc, unsigned CollapsedNum,
-                                  ArrayRef<OMPClause *> Clauses,
-                                  Stmt *AssociatedStmt);
+  static OMPForDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts);
 
-  /// \brief Creates an empty directive with the place
-  /// for \a NumClauses clauses.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
-  /// \param CollapsedNum Number of collapsed nested loops.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  static OMPSimdDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,
-                                       unsigned CollapsedNum, EmptyShell);
-
+  static OMPForDirective *CreateEmpty(const ASTContext &C,
+                                      unsigned CollapsedNum, unsigned N,
+                                      EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[4]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(&(reinterpret_cast<Stmt *const *>(
+            &getClausesStorage()[getNumClauses()])[5])),
+        CollapsedNum);
+  }
   unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPSimdDirectiveClass;
+    return T->getStmtClass() == OMPForDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp for' directive.
+/// \brief This represents '#pragma omp parallel for' directive.
 ///
 /// \code
-/// #pragma omp for private(a,b) reduction(+:c,d)
+/// #pragma omp parallel for private(a,b) reduction(+: c,d) ordered
 /// \endcode
-/// In this example directive '#pragma omp for' has clauses 'private' with the
-/// variables 'a' and 'b' and 'reduction' with operator '+' and variables 'c'
-/// and 'd'.
+/// In this example directive '#pragma omp parallel for' has clauses 'private'
+/// with the variables 'a' and 'b', 'reduction' with operator '+' and
+/// variables 'c' and 'd' and 'ordered'.
 ///
-class OMPForDirective : public OMPExecutableDirective {
+class OMPParallelForDirective : public OMPExecutableDirective {
   friend class ASTStmtReader;
-  /// \brief Number of collapsed loops as specified by 'collapse' clause.
   unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
   /// \param StartLoc Starting location of the directive kind.
-  /// \param EndLoc Ending location of the directive.
-  /// \param CollapsedNum Number of collapsed nested loops.
-  /// \param NumClauses Number of clauses.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
   ///
-  OMPForDirective(SourceLocation StartLoc, SourceLocation EndLoc,
-                  unsigned CollapsedNum, unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPForDirectiveClass, OMPD_for, StartLoc,
-                               EndLoc, NumClauses, 1),
+  OMPParallelForDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                          unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPParallelForDirectiveClass, OMPD_parallel_for, StartLoc, EndLoc,
+            N, reinterpret_cast<OMPClause **>(
+                   reinterpret_cast<char *>(this) +
+                   llvm::RoundUpToAlignment(sizeof(OMPParallelForDirective),
+                                            llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
         CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  /// \param CollapsedNum Number of collapsed nested loops.
-  /// \param NumClauses Number of clauses.
+  /// \param N Number of clauses.
   ///
-  explicit OMPForDirective(unsigned CollapsedNum, unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPForDirectiveClass, OMPD_for,
-                               SourceLocation(), SourceLocation(), NumClauses,
-                               1),
+  explicit OMPParallelForDirective(unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPParallelForDirectiveClass, OMPD_parallel_for, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPParallelForDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
         CollapsedNum(CollapsedNum) {}
+  // 5 is for AssociatedStmt, NewIterVar, NewIterEnd, Init, Final
+  // and CollapsedNum is for Counters.
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]));
+  }
 
 public:
   /// \brief Creates directive with a list of \a Clauses.
@@ -350,62 +427,130 @@
   /// \param C AST context.
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending Location of the directive.
-  /// \param CollapsedNum Number of collapsed loops.
   /// \param Clauses List of clauses.
   /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPForDirective *Create(const ASTContext &C, SourceLocation StartLoc,
-                                 SourceLocation EndLoc, unsigned CollapsedNum,
-                                 ArrayRef<OMPClause *> Clauses,
-                                 Stmt *AssociatedStmt);
+  static OMPParallelForDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts);
 
-  /// \brief Creates an empty directive with the place
-  /// for \a NumClauses clauses.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
-  /// \param CollapsedNum Number of collapsed nested loops.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  static OMPForDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,
-                                      unsigned CollapsedNum, EmptyShell);
+  static OMPParallelForDirective *CreateEmpty(const ASTContext &C,
+                                              unsigned CollapsedNum, unsigned N,
+                                              EmptyShell);
 
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[4]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(&(reinterpret_cast<Stmt *const *>(
+            &getClausesStorage()[getNumClauses()])[5])),
+        CollapsedNum);
+  }
   unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPForDirectiveClass;
+    return T->getStmtClass() == OMPParallelForDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp sections' directive.
+/// \brief This represents '#pragma omp simd' directive.
 ///
 /// \code
-/// #pragma omp sections private(a,b) reduction(+:c,d)
+/// #pragma omp simd private(a,b) linear(i,j:s) reduction(+:c,d)
 /// \endcode
-/// In this example directive '#pragma omp sections' has clauses 'private' with
-/// the variables 'a' and 'b' and 'reduction' with operator '+' and variables
-/// 'c' and 'd'.
+/// In this example directive '#pragma omp simd' has clauses 'private'
+/// with the variables 'a' and 'b', 'linear' with variables 'i', 'j' and
+/// linear step 's', 'reduction' with operator '+' and variables 'c' and 'd'.
 ///
-class OMPSectionsDirective : public OMPExecutableDirective {
+class OMPSimdDirective : public OMPExecutableDirective {
   friend class ASTStmtReader;
+  unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending location of the directive.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  OMPSectionsDirective(SourceLocation StartLoc, SourceLocation EndLoc,
-                       unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPSectionsDirectiveClass, OMPD_sections,
-                               StartLoc, EndLoc, NumClauses, 1) {}
+  OMPSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                   unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPSimdDirectiveClass, OMPD_simd, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPSimdDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  /// \param NumClauses Number of clauses.
+  /// \param N Number of clauses.
   ///
-  explicit OMPSectionsDirective(unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPSectionsDirectiveClass, OMPD_sections,
-                               SourceLocation(), SourceLocation(), NumClauses,
-                               1) {}
+  explicit OMPSimdDirective(unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPSimdDirectiveClass, OMPD_simd, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPSimdDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]));
+  }
 
 public:
   /// \brief Creates directive with a list of \a Clauses.
@@ -416,100 +561,262 @@
   /// \param Clauses List of clauses.
   /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPSectionsDirective *
+  static OMPSimdDirective *
   Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
-         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts);
 
-  /// \brief Creates an empty directive with the place for \a NumClauses
-  /// clauses.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  static OMPSectionsDirective *CreateEmpty(const ASTContext &C,
-                                           unsigned NumClauses, EmptyShell);
+  static OMPSimdDirective *CreateEmpty(const ASTContext &C,
+                                       unsigned CollapsedNum, unsigned N,
+                                       EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[4]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(&(reinterpret_cast<Stmt *const *>(
+            &reinterpret_cast<OMPClause *const *>(this +
+                                                  1)[getNumClauses()])[5])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPSectionsDirectiveClass;
+    return T->getStmtClass() == OMPSimdDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp section' directive.
+/// \brief This represents '#pragma omp for simd' directive.
 ///
 /// \code
-/// #pragma omp section
+/// #pragma omp for simd private(a,b) linear(i,j:s) reduction(+:c,d)
 /// \endcode
+/// In this example directive '#pragma omp for simd' has clauses 'private'
+/// with the variables 'a' and 'b', 'linear' with variables 'i', 'j' and
+/// linear step 's', 'reduction' with operator '+' and variables 'c' and 'd'.
 ///
-class OMPSectionDirective : public OMPExecutableDirective {
+class OMPForSimdDirective : public OMPExecutableDirective {
   friend class ASTStmtReader;
+  unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending location of the directive.
+  /// \param N The number of clauses.
   ///
-  OMPSectionDirective(SourceLocation StartLoc, SourceLocation EndLoc)
-      : OMPExecutableDirective(this, OMPSectionDirectiveClass, OMPD_section,
-                               StartLoc, EndLoc, 0, 1) {}
+  OMPForSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                      unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPForSimdDirectiveClass, OMPD_for_simd, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPForSimdDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  explicit OMPSectionDirective()
-      : OMPExecutableDirective(this, OMPSectionDirectiveClass, OMPD_section,
-                               SourceLocation(), SourceLocation(), 0, 1) {}
+  /// \param N Number of clauses.
+  ///
+  explicit OMPForSimdDirective(unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPForSimdDirectiveClass, OMPD_for_simd, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPForSimdDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]));
+  }
 
 public:
-  /// \brief Creates directive.
+  /// \brief Creates directive with a list of \a Clauses.
   ///
   /// \param C AST context.
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
   /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPSectionDirective *Create(const ASTContext &C,
-                                     SourceLocation StartLoc,
-                                     SourceLocation EndLoc,
-                                     Stmt *AssociatedStmt);
+  static OMPForSimdDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts);
 
-  /// \brief Creates an empty directive.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
+  /// \param N The number of clauses.
   ///
-  static OMPSectionDirective *CreateEmpty(const ASTContext &C, EmptyShell);
+  static OMPForSimdDirective *CreateEmpty(const ASTContext &C,
+                                          unsigned CollapsedNum, unsigned N,
+                                          EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[4]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(&(reinterpret_cast<Stmt *const *>(
+            &reinterpret_cast<OMPClause *const *>(this +
+                                                  1)[getNumClauses()])[5])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPSectionDirectiveClass;
+    return T->getStmtClass() == OMPForSimdDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp single' directive.
+/// \brief This represents '#pragma omp parallel for simd' directive.
 ///
 /// \code
-/// #pragma omp single private(a,b) copyprivate(c,d)
+/// #pragma omp parallel for simd private(a,b) linear(i,j:s) reduction(+:c,d)
 /// \endcode
-/// In this example directive '#pragma omp single' has clauses 'private' with
-/// the variables 'a' and 'b' and 'copyprivate' with variables 'c' and 'd'.
+/// In this example directive '#pragma omp parallel for simd' has clauses
+/// 'private' with the variables 'a' and 'b', 'linear' with variables 'i', 'j'
+/// and linear step 's', 'reduction' with operator '+' and variables 'c' and
+/// 'd'.
 ///
-class OMPSingleDirective : public OMPExecutableDirective {
+class OMPParallelForSimdDirective : public OMPExecutableDirective {
   friend class ASTStmtReader;
+  unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending location of the directive.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  OMPSingleDirective(SourceLocation StartLoc, SourceLocation EndLoc,
-                     unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPSingleDirectiveClass, OMPD_single,
-                               StartLoc, EndLoc, NumClauses, 1) {}
+  OMPParallelForSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                              unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPParallelForSimdDirectiveClass, OMPD_parallel_for_simd, StartLoc,
+            EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPParallelForSimdDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  /// \param NumClauses Number of clauses.
+  /// \param N Number of clauses.
   ///
-  explicit OMPSingleDirective(unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPSingleDirectiveClass, OMPD_single,
-                               SourceLocation(), SourceLocation(), NumClauses,
-                               1) {}
+  explicit OMPParallelForSimdDirective(unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPParallelForSimdDirectiveClass, OMPD_parallel_for_simd,
+            SourceLocation(), SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPParallelForSimdDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]));
+  }
 
 public:
   /// \brief Creates directive with a list of \a Clauses.
@@ -520,171 +827,434 @@
   /// \param Clauses List of clauses.
   /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPSingleDirective *
+  static OMPParallelForSimdDirective *
   Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
-         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts);
 
-  /// \brief Creates an empty directive with the place for \a NumClauses
-  /// clauses.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  static OMPSingleDirective *CreateEmpty(const ASTContext &C,
-                                         unsigned NumClauses, EmptyShell);
+  static OMPParallelForSimdDirective *CreateEmpty(const ASTContext &C,
+                                                  unsigned CollapsedNum,
+                                                  unsigned N, EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[4]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(&(reinterpret_cast<Stmt *const *>(
+            &reinterpret_cast<OMPClause *const *>(this +
+                                                  1)[getNumClauses()])[5])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPSingleDirectiveClass;
+    return T->getStmtClass() == OMPParallelForSimdDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp master' directive.
+/// \brief This represents '#pragma omp distribute simd' directive.
 ///
 /// \code
-/// #pragma omp master
+/// #pragma omp distribute simd private(a,b) linear(i,j:s) reduction(+:c,d)
 /// \endcode
+/// In this example directive '#pragma omp distribute simd' has clauses
+/// 'private' with the variables 'a' and 'b', 'linear' with variables 'i', 'j'
+/// and linear step 's', 'reduction' with operator '+' and variables 'c' and
+/// 'd'.
 ///
-class OMPMasterDirective : public OMPExecutableDirective {
+class OMPDistributeSimdDirective : public OMPExecutableDirective {
   friend class ASTStmtReader;
+  unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending location of the directive.
+  /// \param N The number of clauses.
   ///
-  OMPMasterDirective(SourceLocation StartLoc, SourceLocation EndLoc)
-      : OMPExecutableDirective(this, OMPMasterDirectiveClass, OMPD_master,
-                               StartLoc, EndLoc, 0, 1) {}
+  OMPDistributeSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                             unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPDistributeSimdDirectiveClass, OMPD_distribute_simd, StartLoc,
+            EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPDistributeSimdDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  explicit OMPMasterDirective()
-      : OMPExecutableDirective(this, OMPMasterDirectiveClass, OMPD_master,
-                               SourceLocation(), SourceLocation(), 0, 1) {}
+  /// \param N Number of clauses.
+  ///
+  explicit OMPDistributeSimdDirective(unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPDistributeSimdDirectiveClass, OMPD_distribute_simd,
+            SourceLocation(), SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPDistributeSimdDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]));
+  }
 
 public:
-  /// \brief Creates directive.
+  /// \brief Creates directive with a list of \a Clauses.
   ///
   /// \param C AST context.
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
   /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPMasterDirective *Create(const ASTContext &C,
-                                    SourceLocation StartLoc,
-                                    SourceLocation EndLoc,
-                                    Stmt *AssociatedStmt);
+  static OMPDistributeSimdDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts);
 
-  /// \brief Creates an empty directive.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
+  /// \param N The number of clauses.
   ///
-  static OMPMasterDirective *CreateEmpty(const ASTContext &C, EmptyShell);
+  static OMPDistributeSimdDirective *CreateEmpty(const ASTContext &C,
+                                                 unsigned CollapsedNum,
+                                                 unsigned N, EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[4]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(&(reinterpret_cast<Stmt *const *>(
+            &reinterpret_cast<OMPClause *const *>(this +
+                                                  1)[getNumClauses()])[5])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPMasterDirectiveClass;
+    return T->getStmtClass() == OMPDistributeSimdDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp critical' directive.
+/// \brief This represents '#pragma omp distribute parallel for' directive.
 ///
 /// \code
-/// #pragma omp critical
+/// #pragma omp distribute parallel for private(a,b) reduction(+:c,d)
 /// \endcode
+/// In this example directive '#pragma omp distribute parallel for' has clauses
+/// 'private'
+/// with the variables 'a' and 'b' and
+/// 'reduction' with operator '+' and variables 'c' and 'd'.
 ///
-class OMPCriticalDirective : public OMPExecutableDirective {
+class OMPDistributeParallelForDirective : public OMPExecutableDirective {
   friend class ASTStmtReader;
-  /// \brief Name of the directive.
-  DeclarationNameInfo DirName;
+  unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
-  /// \param Name Name of the directive.
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending location of the directive.
+  /// \param N The number of clauses.
   ///
-  OMPCriticalDirective(const DeclarationNameInfo &Name, SourceLocation StartLoc,
-                       SourceLocation EndLoc)
-      : OMPExecutableDirective(this, OMPCriticalDirectiveClass, OMPD_critical,
-                               StartLoc, EndLoc, 0, 1),
-        DirName(Name) {}
+  OMPDistributeParallelForDirective(SourceLocation StartLoc,
+                                    SourceLocation EndLoc,
+                                    unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPDistributeParallelForDirectiveClass,
+            OMPD_distribute_parallel_for, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPDistributeParallelForDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 7 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  explicit OMPCriticalDirective()
-      : OMPExecutableDirective(this, OMPCriticalDirectiveClass, OMPD_critical,
-                               SourceLocation(), SourceLocation(), 0, 1),
-        DirName() {}
-
-  /// \brief Set name of the directive.
-  ///
-  /// \param Name Name of the directive.
+  /// \param N Number of clauses.
   ///
-  void setDirectiveName(const DeclarationNameInfo &Name) { DirName = Name; }
+  explicit OMPDistributeParallelForDirective(unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPDistributeParallelForDirectiveClass,
+            OMPD_distribute_parallel_for, SourceLocation(), SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPDistributeParallelForDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 7 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setLowerBound(Expr *LB) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5] = LB;
+  }
+  void setUpperBound(Expr *UB) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[6] = UB;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[7]));
+  }
 
 public:
-  /// \brief Creates directive.
+  /// \brief Creates directive with a list of \a Clauses.
   ///
   /// \param C AST context.
-  /// \param Name Name of the directive.
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
   /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPCriticalDirective *
-  Create(const ASTContext &C, const DeclarationNameInfo &Name,
-         SourceLocation StartLoc, SourceLocation EndLoc, Stmt *AssociatedStmt);
+  static OMPDistributeParallelForDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, Expr *LowerBound,
+         Expr *UpperBound, ArrayRef<Expr *> VarCnts);
 
-  /// \brief Creates an empty directive.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
+  /// \param N The number of clauses.
   ///
-  static OMPCriticalDirective *CreateEmpty(const ASTContext &C, EmptyShell);
-
-  /// \brief Return name of the directive.
-  ///
-  DeclarationNameInfo getDirectiveName() const { return DirName; }
+  static OMPDistributeParallelForDirective *CreateEmpty(const ASTContext &C,
+                                                        unsigned CollapsedNum,
+                                                        unsigned N, EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[4]);
+  }
+  Expr *getLowerBound() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[5]);
+  }
+  Expr *getUpperBound() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[6]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(&(reinterpret_cast<Stmt *const *>(
+            &reinterpret_cast<OMPClause *const *>(this +
+                                                  1)[getNumClauses()])[7])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
+  Expr *getLowerBound() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]);
+  }
+  Expr *getUpperBound() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[6]);
+  }
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPCriticalDirectiveClass;
+    return T->getStmtClass() == OMPDistributeParallelForDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp parallel for' directive.
+/// \brief This represents '#pragma omp distribute parallel for simd' directive.
 ///
 /// \code
-/// #pragma omp parallel for private(a,b) reduction(+:c,d)
+/// #pragma omp distribute parallel for simd private(a,b) reduction(+:c,d)
 /// \endcode
-/// In this example directive '#pragma omp parallel for' has clauses 'private'
-/// with the variables 'a' and 'b' and 'reduction' with operator '+' and
-/// variables 'c' and 'd'.
+/// In this example directive '#pragma omp distribute parallel for simd' has
+/// clauses 'private' with the variables 'a' and 'b' and 'reduction' with
+/// operator '+' and variables 'c' and 'd'.
 ///
-class OMPParallelForDirective : public OMPExecutableDirective {
+class OMPDistributeParallelForSimdDirective : public OMPExecutableDirective {
   friend class ASTStmtReader;
-  /// \brief Number of collapsed loops as specified by 'collapse' clause.
   unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending location of the directive.
-  /// \param CollapsedNum Number of collapsed nested loops.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  OMPParallelForDirective(SourceLocation StartLoc, SourceLocation EndLoc,
-                          unsigned CollapsedNum, unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPParallelForDirectiveClass,
-                               OMPD_parallel_for, StartLoc, EndLoc, NumClauses,
-                               1),
+  OMPDistributeParallelForSimdDirective(SourceLocation StartLoc,
+                                        SourceLocation EndLoc,
+                                        unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPDistributeParallelForSimdDirectiveClass,
+            OMPD_distribute_parallel_for_simd, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPDistributeParallelForSimdDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 7 + CollapsedNum),
         CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  /// \param CollapsedNum Number of collapsed nested loops.
-  /// \param NumClauses Number of clauses.
+  /// \param N Number of clauses.
   ///
-  explicit OMPParallelForDirective(unsigned CollapsedNum, unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPParallelForDirectiveClass,
-                               OMPD_parallel_for, SourceLocation(),
-                               SourceLocation(), NumClauses, 1),
+  explicit OMPDistributeParallelForSimdDirective(unsigned CollapsedNum,
+                                                 unsigned N)
+      : OMPExecutableDirective(
+            OMPDistributeParallelForSimdDirectiveClass,
+            OMPD_distribute_parallel_for_simd, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPDistributeParallelForSimdDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 7 + CollapsedNum),
         CollapsedNum(CollapsedNum) {}
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setLowerBound(Expr *LB) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5] = LB;
+  }
+  void setUpperBound(Expr *UB) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[6] = UB;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[7]));
+  }
 
 public:
   /// \brief Creates directive with a list of \a Clauses.
@@ -692,65 +1262,161 @@
   /// \param C AST context.
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending Location of the directive.
-  /// \param CollapsedNum Number of collapsed loops.
   /// \param Clauses List of clauses.
   /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPParallelForDirective *
+  static OMPDistributeParallelForSimdDirective *
   Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
-         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,
-         Stmt *AssociatedStmt);
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, Expr *LowerBound,
+         Expr *UpperBound, ArrayRef<Expr *> VarCnts);
 
-  /// \brief Creates an empty directive with the place
-  /// for \a NumClauses clauses.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
-  /// \param CollapsedNum Number of collapsed nested loops.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  static OMPParallelForDirective *CreateEmpty(const ASTContext &C,
-                                              unsigned NumClauses,
-                                              unsigned CollapsedNum,
-                                              EmptyShell);
-
+  static OMPDistributeParallelForSimdDirective *
+  CreateEmpty(const ASTContext &C, unsigned CollapsedNum, unsigned N,
+              EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[4]);
+  }
+  Expr *getLowerBound() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[5]);
+  }
+  Expr *getUpperBound() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[6]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(&(reinterpret_cast<Stmt *const *>(
+            &reinterpret_cast<OMPClause *const *>(this +
+                                                  1)[getNumClauses()])[7])),
+        CollapsedNum);
+  }
   unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
+  Expr *getLowerBound() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]);
+  }
+  Expr *getUpperBound() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[6]);
+  }
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPParallelForDirectiveClass;
+    return T->getStmtClass() == OMPDistributeParallelForSimdDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp parallel sections' directive.
+/// \brief This represents '#pragma omp teams distribute parallel for'
+/// directive.
 ///
 /// \code
-/// #pragma omp parallel sections private(a,b) reduction(+:c,d)
+/// #pragma omp teams distribute parallel for private(a,b) reduction(+:c,d)
 /// \endcode
-/// In this example directive '#pragma omp parallel sections' has clauses
-/// 'private' with the variables 'a' and 'b' and 'reduction' with operator '+'
-/// and variables 'c' and 'd'.
+/// In this example directive '#pragma omp teams distribute parallel for' has
+/// clauses 'private' with the variables 'a' and 'b' and 'reduction' with
+/// operator '+' and variables 'c' and 'd'.
 ///
-class OMPParallelSectionsDirective : public OMPExecutableDirective {
+class OMPTeamsDistributeParallelForDirective : public OMPExecutableDirective {
   friend class ASTStmtReader;
+  unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending location of the directive.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  OMPParallelSectionsDirective(SourceLocation StartLoc, SourceLocation EndLoc,
-                               unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPParallelSectionsDirectiveClass,
-                               OMPD_parallel_sections, StartLoc, EndLoc,
-                               NumClauses, 1) {}
+  OMPTeamsDistributeParallelForDirective(SourceLocation StartLoc,
+                                         SourceLocation EndLoc,
+                                         unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPTeamsDistributeParallelForDirectiveClass,
+            OMPD_teams_distribute_parallel_for, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPTeamsDistributeParallelForDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 7 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  /// \param NumClauses Number of clauses.
+  /// \param N Number of clauses.
   ///
-  explicit OMPParallelSectionsDirective(unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPParallelSectionsDirectiveClass,
-                               OMPD_parallel_sections, SourceLocation(),
-                               SourceLocation(), NumClauses, 1) {}
+  explicit OMPTeamsDistributeParallelForDirective(unsigned CollapsedNum,
+                                                  unsigned N)
+      : OMPExecutableDirective(
+            OMPTeamsDistributeParallelForDirectiveClass,
+            OMPD_teams_distribute_parallel_for, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPTeamsDistributeParallelForDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 7 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setLowerBound(Expr *LB) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5] = LB;
+  }
+  void setUpperBound(Expr *UB) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[6] = UB;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[7]));
+  }
 
 public:
   /// \brief Creates directive with a list of \a Clauses.
@@ -761,56 +1427,1846 @@
   /// \param Clauses List of clauses.
   /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPParallelSectionsDirective *
+  static OMPTeamsDistributeParallelForDirective *
   Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
-         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, Expr *LowerBound,
+         Expr *UpperBound, ArrayRef<Expr *> VarCnts);
 
-  /// \brief Creates an empty directive with the place for \a NumClauses
-  /// clauses.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  static OMPParallelSectionsDirective *
-  CreateEmpty(const ASTContext &C, unsigned NumClauses, EmptyShell);
+  static OMPTeamsDistributeParallelForDirective *
+  CreateEmpty(const ASTContext &C, unsigned CollapsedNum, unsigned N,
+              EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[4]);
+  }
+  Expr *getLowerBound() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[5]);
+  }
+  Expr *getUpperBound() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[6]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(&(reinterpret_cast<Stmt *const *>(
+            &reinterpret_cast<OMPClause *const *>(this +
+                                                  1)[getNumClauses()])[7])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
+  Expr *getLowerBound() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]);
+  }
+  Expr *getUpperBound() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[6]);
+  }
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPParallelSectionsDirectiveClass;
+    return T->getStmtClass() == OMPTeamsDistributeParallelForDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp task' directive.
+/// \brief This represents '#pragma omp teams distribute parallel for simd'
+/// directive.
 ///
 /// \code
-/// #pragma omp task private(a,b) final(d)
+/// #pragma omp teams distribute parallel for simd private(a,b) reduction(+:c,d)
 /// \endcode
-/// In this example directive '#pragma omp task' has clauses 'private' with the
-/// variables 'a' and 'b' and 'final' with condition 'd'.
+/// In this example directive '#pragma omp teams distribute parallel for simd'
+/// has clauses 'private' with the variables 'a' and 'b' and 'reduction' with
+/// operator '+' and variables 'c' and 'd'.
 ///
-class OMPTaskDirective : public OMPExecutableDirective {
+class OMPTeamsDistributeParallelForSimdDirective
+    : public OMPExecutableDirective {
   friend class ASTStmtReader;
+  unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending location of the directive.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  OMPTaskDirective(SourceLocation StartLoc, SourceLocation EndLoc,
-                   unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPTaskDirectiveClass, OMPD_task, StartLoc,
-                               EndLoc, NumClauses, 1) {}
+  OMPTeamsDistributeParallelForSimdDirective(SourceLocation StartLoc,
+                                             SourceLocation EndLoc,
+                                             unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPTeamsDistributeParallelForSimdDirectiveClass,
+            OMPD_teams_distribute_parallel_for_simd, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPTeamsDistributeParallelForSimdDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 7 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  /// \param NumClauses Number of clauses.
+  /// \param N Number of clauses.
   ///
-  explicit OMPTaskDirective(unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPTaskDirectiveClass, OMPD_task,
-                               SourceLocation(), SourceLocation(), NumClauses,
-                               1) {}
-
-public:
-  /// \brief Creates directive with a list of \a Clauses.
+  explicit OMPTeamsDistributeParallelForSimdDirective(unsigned CollapsedNum,
+                                                      unsigned N)
+      : OMPExecutableDirective(
+            OMPTeamsDistributeParallelForSimdDirectiveClass,
+            OMPD_teams_distribute_parallel_for_simd, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPTeamsDistributeParallelForSimdDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 7 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setLowerBound(Expr *LB) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5] = LB;
+  }
+  void setUpperBound(Expr *UB) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[6] = UB;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[7]));
+  }
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPTeamsDistributeParallelForSimdDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, Expr *LowerBound,
+         Expr *UpperBound, ArrayRef<Expr *> VarCnts);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPTeamsDistributeParallelForSimdDirective *
+  CreateEmpty(const ASTContext &C, unsigned CollapsedNum, unsigned N,
+              EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[4]);
+  }
+  Expr *getLowerBound() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[5]);
+  }
+  Expr *getUpperBound() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[6]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(&(reinterpret_cast<Stmt *const *>(
+            &reinterpret_cast<OMPClause *const *>(this +
+                                                  1)[getNumClauses()])[7])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
+  Expr *getLowerBound() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]);
+  }
+  Expr *getUpperBound() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[6]);
+  }
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPTeamsDistributeParallelForSimdDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp target teams distribute parallel for'
+/// directive.
+///
+/// \code
+/// #pragma omp target teams distribute parallel for private(a,b)
+/// reduction(+:c,d)
+/// \endcode
+/// In this example directive '#pragma omp target teams distribute parallel for'
+/// has clauses 'private' with the variables 'a' and 'b' and 'reduction' with
+/// operator '+' and variables 'c' and 'd'.
+///
+class OMPTargetTeamsDistributeParallelForDirective
+    : public OMPExecutableDirective {
+  friend class ASTStmtReader;
+  unsigned CollapsedNum;
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPTargetTeamsDistributeParallelForDirective(SourceLocation StartLoc,
+                                               SourceLocation EndLoc,
+                                               unsigned CollapsedNum,
+                                               unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetTeamsDistributeParallelForDirectiveClass,
+            OMPD_target_teams_distribute_parallel_for, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPTargetTeamsDistributeParallelForDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 7 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPTargetTeamsDistributeParallelForDirective(unsigned CollapsedNum,
+                                                        unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetTeamsDistributeParallelForDirectiveClass,
+            OMPD_target_teams_distribute_parallel_for, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPTargetTeamsDistributeParallelForDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 7 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setLowerBound(Expr *LB) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5] = LB;
+  }
+  void setUpperBound(Expr *UB) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[6] = UB;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[7]));
+  }
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPTargetTeamsDistributeParallelForDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, Expr *LowerBound,
+         Expr *UpperBound, ArrayRef<Expr *> VarCnts);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPTargetTeamsDistributeParallelForDirective *
+  CreateEmpty(const ASTContext &C, unsigned CollapsedNum, unsigned N,
+              EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[4]);
+  }
+  Expr *getLowerBound() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[5]);
+  }
+  Expr *getUpperBound() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[6]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(&(reinterpret_cast<Stmt *const *>(
+            &reinterpret_cast<OMPClause *const *>(this +
+                                                  1)[getNumClauses()])[7])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
+  Expr *getLowerBound() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]);
+  }
+  Expr *getUpperBound() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[6]);
+  }
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() ==
+           OMPTargetTeamsDistributeParallelForDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp target teams distribute parallel for
+/// simd' directive.
+///
+/// \code
+/// #pragma omp target teams distribute parallel for simd private(a,b)
+/// reduction(+:c,d)
+/// \endcode
+/// In this example directive '#pragma omp target teams distribute parallel for
+/// simd' has clauses 'private' with the variables 'a' and 'b' and 'reduction'
+/// with operator '+' and variables 'c' and 'd'.
+///
+class OMPTargetTeamsDistributeParallelForSimdDirective
+    : public OMPExecutableDirective {
+  friend class ASTStmtReader;
+  unsigned CollapsedNum;
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPTargetTeamsDistributeParallelForSimdDirective(SourceLocation StartLoc,
+                                                   SourceLocation EndLoc,
+                                                   unsigned CollapsedNum,
+                                                   unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetTeamsDistributeParallelForSimdDirectiveClass,
+            OMPD_target_teams_distribute_parallel_for_simd, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPTargetTeamsDistributeParallelForSimdDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 7 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPTargetTeamsDistributeParallelForSimdDirective(
+      unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetTeamsDistributeParallelForSimdDirectiveClass,
+            OMPD_target_teams_distribute_parallel_for_simd, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPTargetTeamsDistributeParallelForSimdDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 7 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setLowerBound(Expr *LB) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5] = LB;
+  }
+  void setUpperBound(Expr *UB) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[6] = UB;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[7]));
+  }
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPTargetTeamsDistributeParallelForSimdDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, Expr *LowerBound,
+         Expr *UpperBound, ArrayRef<Expr *> VarCnts);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPTargetTeamsDistributeParallelForSimdDirective *
+  CreateEmpty(const ASTContext &C, unsigned CollapsedNum, unsigned N,
+              EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[4]);
+  }
+  Expr *getLowerBound() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[5]);
+  }
+  Expr *getUpperBound() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[6]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(&(reinterpret_cast<Stmt *const *>(
+            &reinterpret_cast<OMPClause *const *>(this +
+                                                  1)[getNumClauses()])[7])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
+  Expr *getLowerBound() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]);
+  }
+  Expr *getUpperBound() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[6]);
+  }
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() ==
+           OMPTargetTeamsDistributeParallelForSimdDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp sections' directive.
+///
+/// \code
+/// #pragma omp sections private(a,b) reduction(+: c,d) nowait
+/// \endcode
+/// In this example directive '#pragma omp sections' has clauses 'private'
+/// with the variables 'a' and 'b', 'reduction' with operator '+' and
+/// variables 'c' and 'd' and 'nowait'.
+///
+class OMPSectionsDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPSectionsDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                       unsigned N)
+      : OMPExecutableDirective(
+            OMPSectionsDirectiveClass, OMPD_sections, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPSectionsDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPSectionsDirective(unsigned N)
+      : OMPExecutableDirective(
+            OMPSectionsDirectiveClass, OMPD_sections, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPSectionsDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPSectionsDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPSectionsDirective *CreateEmpty(const ASTContext &C, unsigned N,
+                                           EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPSectionsDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp parallel sections' directive.
+///
+/// \code
+/// #pragma omp parallel sections private(a,b) reduction(+: c,d)
+/// \endcode
+/// In this example directive '#pragma omp parallel sections' has clauses
+/// 'private'
+/// with the variables 'a' and 'b', 'reduction' with operator '+' and
+/// variables 'c' and 'd'.
+///
+class OMPParallelSectionsDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPParallelSectionsDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                               unsigned N)
+      : OMPExecutableDirective(
+            OMPParallelSectionsDirectiveClass, OMPD_parallel_sections, StartLoc,
+            EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPParallelSectionsDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPParallelSectionsDirective(unsigned N)
+      : OMPExecutableDirective(
+            OMPParallelSectionsDirectiveClass, OMPD_parallel_sections,
+            SourceLocation(), SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPParallelSectionsDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPParallelSectionsDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPParallelSectionsDirective *CreateEmpty(const ASTContext &C,
+                                                   unsigned N, EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPParallelSectionsDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp section' directive.
+///
+/// \code
+/// #pragma omp section
+/// \endcode
+/// In this example directive '#pragma omp section' is used.
+///
+class OMPSectionDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  ///
+  OMPSectionDirective(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPExecutableDirective(
+            OMPSectionDirectiveClass, OMPD_section, StartLoc, EndLoc, 0,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPSectionDirective),
+                                         sizeof(Stmt *))),
+            true, 1) {}
+
+  /// \brief Build an empty directive.
+  ///
+  explicit OMPSectionDirective()
+      : OMPExecutableDirective(
+            OMPSectionDirectiveClass, OMPD_section, SourceLocation(),
+            SourceLocation(), 0,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPSectionDirective),
+                                         sizeof(Stmt *))),
+            true, 1) {}
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPSectionDirective *Create(const ASTContext &C,
+                                     SourceLocation StartLoc,
+                                     SourceLocation EndLoc,
+                                     Stmt *AssociatedStmt);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  ///
+  static OMPSectionDirective *CreateEmpty(const ASTContext &C, EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPSectionDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp single' directive.
+///
+/// \code
+/// #pragma omp single private(a,b) copyprivate(c,d)
+/// \endcode
+/// In this example directive '#pragma omp single' has clauses 'private'
+/// with the variables 'a' and 'b', 'copyprivate' with variables 'c' and 'd'.
+///
+class OMPSingleDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPSingleDirective(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N)
+      : OMPExecutableDirective(
+            OMPSingleDirectiveClass, OMPD_single, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPSingleDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPSingleDirective(unsigned N)
+      : OMPExecutableDirective(
+            OMPSingleDirectiveClass, OMPD_single, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPSingleDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPSingleDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPSingleDirective *CreateEmpty(const ASTContext &C, unsigned N,
+                                         EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPSingleDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp task' directive.
+///
+/// \code
+/// #pragma omp task private(a,b) firstprivate(c,d)
+/// \endcode
+/// In this example directive '#pragma omp task' has clauses 'private'
+/// with the variables 'a' and 'b', 'firstprivate' with variables 'c' and 'd'.
+///
+class OMPTaskDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPTaskDirective(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N)
+      : OMPExecutableDirective(
+            OMPTaskDirectiveClass, OMPD_task, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTaskDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPTaskDirective(unsigned N)
+      : OMPExecutableDirective(
+            OMPTaskDirectiveClass, OMPD_task, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTaskDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPTaskDirective *Create(const ASTContext &C, SourceLocation StartLoc,
+                                  SourceLocation EndLoc,
+                                  ArrayRef<OMPClause *> Clauses,
+                                  Stmt *AssociatedStmt);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPTaskDirective *CreateEmpty(const ASTContext &C, unsigned N,
+                                       EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPTaskDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp taskyield' directive.
+///
+/// \code
+/// #pragma omp taskyield
+/// \endcode
+/// In this example directive '#pragma omp taskyield' is used.
+///
+class OMPTaskyieldDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  ///
+  OMPTaskyieldDirective(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPExecutableDirective(OMPTaskyieldDirectiveClass, OMPD_taskyield,
+                               StartLoc, EndLoc, 0, 0, false, 0) {}
+
+  /// \brief Build an empty directive.
+  ///
+  explicit OMPTaskyieldDirective()
+      : OMPExecutableDirective(OMPTaskyieldDirectiveClass, OMPD_taskyield,
+                               SourceLocation(), SourceLocation(), 0, 0, false,
+                               0) {}
+
+public:
+  /// \brief Creates directive.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  ///
+  static OMPTaskyieldDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);
+
+  /// \brief Creates an empty directive.
+  ///
+  /// \param C AST context.
+  ///
+  static OMPTaskyieldDirective *CreateEmpty(const ASTContext &C, EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPTaskyieldDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp master' directive.
+///
+/// \code
+/// #pragma omp master
+/// \endcode
+/// In this example directive '#pragma omp master' is used.
+///
+class OMPMasterDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  ///
+  OMPMasterDirective(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPExecutableDirective(
+            OMPMasterDirectiveClass, OMPD_master, StartLoc, EndLoc, 0,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPMasterDirective),
+                                         sizeof(Stmt *))),
+            true, 1) {}
+
+  /// \brief Build an empty directive.
+  ///
+  explicit OMPMasterDirective()
+      : OMPExecutableDirective(
+            OMPMasterDirectiveClass, OMPD_master, SourceLocation(),
+            SourceLocation(), 0,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPMasterDirective),
+                                         sizeof(Stmt *))),
+            true, 1) {}
+
+public:
+  /// \brief Creates directive.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPMasterDirective *Create(const ASTContext &C,
+                                    SourceLocation StartLoc,
+                                    SourceLocation EndLoc,
+                                    Stmt *AssociatedStmt);
+
+  /// \brief Creates an empty directive.
+  ///
+  /// \param C AST context.
+  ///
+  static OMPMasterDirective *CreateEmpty(const ASTContext &C, EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPMasterDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp critical' directive.
+///
+/// \code
+/// #pragma omp critical
+/// \endcode
+/// In this example directive '#pragma omp critical' is used.
+///
+class OMPCriticalDirective : public OMPExecutableDirective {
+  friend class ASTStmtReader;
+  /// \brief Name of thee directive.
+  DeclarationNameInfo DirName;
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  ///
+  OMPCriticalDirective(DeclarationNameInfo Name, SourceLocation StartLoc,
+                       SourceLocation EndLoc)
+      : OMPExecutableDirective(
+            OMPCriticalDirectiveClass, OMPD_critical, StartLoc, EndLoc, 0,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPCriticalDirective),
+                                         sizeof(Stmt *))),
+            true, 1),
+        DirName(Name) {}
+
+  /// \brief Build an empty directive.
+  ///
+  explicit OMPCriticalDirective()
+      : OMPExecutableDirective(
+            OMPCriticalDirectiveClass, OMPD_critical, SourceLocation(),
+            SourceLocation(), 0,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPCriticalDirective),
+                                         sizeof(Stmt *))),
+            true, 1),
+        DirName() {}
+  /// \brief Set name of the directive.
+  ///
+  /// \param Name Name of the directive.
+  ///
+  void setDirectiveName(const DeclarationNameInfo &Name) { DirName = Name; }
+
+public:
+  /// \brief Creates directive.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPCriticalDirective *
+  Create(const ASTContext &C, DeclarationNameInfo DirName,
+         SourceLocation StartLoc, SourceLocation EndLoc, Stmt *AssociatedStmt);
+
+  /// \brief Creates an empty directive.
+  ///
+  /// \param C AST context.
+  ///
+  static OMPCriticalDirective *CreateEmpty(const ASTContext &C, EmptyShell);
+
+  /// \brief Return name of the directive.
+  ///
+  DeclarationNameInfo getDirectiveName() const { return DirName; }
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPCriticalDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp barrier' directive.
+///
+/// \code
+/// #pragma omp barrier
+/// \endcode
+/// In this example directive '#pragma omp barrier' is used.
+///
+class OMPBarrierDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  ///
+  OMPBarrierDirective(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPExecutableDirective(OMPBarrierDirectiveClass, OMPD_barrier, StartLoc,
+                               EndLoc, 0, 0, false, 0) {}
+
+  /// \brief Build an empty directive.
+  ///
+  explicit OMPBarrierDirective()
+      : OMPExecutableDirective(OMPBarrierDirectiveClass, OMPD_barrier,
+                               SourceLocation(), SourceLocation(), 0, 0, false,
+                               0) {}
+
+public:
+  /// \brief Creates directive.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  ///
+  static OMPBarrierDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);
+
+  /// \brief Creates an empty directive.
+  ///
+  /// \param C AST context.
+  ///
+  static OMPBarrierDirective *CreateEmpty(const ASTContext &C, EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPBarrierDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp taskwait' directive.
+///
+/// \code
+/// #pragma omp taskwait
+/// \endcode
+/// In this example directive '#pragma omp taskwait' is used.
+///
+class OMPTaskwaitDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  ///
+  OMPTaskwaitDirective(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPExecutableDirective(OMPTaskwaitDirectiveClass, OMPD_taskwait,
+                               StartLoc, EndLoc, 0, 0, false, 0) {}
+
+  /// \brief Build an empty directive.
+  ///
+  explicit OMPTaskwaitDirective()
+      : OMPExecutableDirective(OMPTaskwaitDirectiveClass, OMPD_taskwait,
+                               SourceLocation(), SourceLocation(), 0, 0, false,
+                               0) {}
+
+public:
+  /// \brief Creates directive.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  ///
+  static OMPTaskwaitDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);
+
+  /// \brief Creates an empty directive.
+  ///
+  /// \param C AST context.
+  ///
+  static OMPTaskwaitDirective *CreateEmpty(const ASTContext &C, EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPTaskwaitDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp taskgroup' directive.
+///
+/// \code
+/// #pragma omp taskgroup
+/// \endcode
+/// In this example directive '#pragma omp taskgroup' is used.
+///
+class OMPTaskgroupDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  ///
+  OMPTaskgroupDirective(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPExecutableDirective(
+            OMPTaskgroupDirectiveClass, OMPD_taskgroup, StartLoc, EndLoc, 0,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTaskgroupDirective),
+                                         sizeof(Stmt *))),
+            true, 1) {}
+
+  /// \brief Build an empty directive.
+  ///
+  explicit OMPTaskgroupDirective()
+      : OMPExecutableDirective(
+            OMPTaskgroupDirectiveClass, OMPD_taskgroup, SourceLocation(),
+            SourceLocation(), 0,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTaskgroupDirective),
+                                         sizeof(Stmt *))),
+            true, 1) {}
+
+public:
+  /// \brief Creates directive.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPTaskgroupDirective *Create(const ASTContext &C,
+                                       SourceLocation StartLoc,
+                                       SourceLocation EndLoc,
+                                       Stmt *AssociatedStmt);
+
+  /// \brief Creates an empty directive.
+  ///
+  /// \param C AST context.
+  ///
+  static OMPTaskgroupDirective *CreateEmpty(const ASTContext &C, EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPTaskgroupDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp atomic' directive.
+///
+/// \code
+/// #pragma omp atomic capture seq_cst
+/// \endcode
+/// In this example directive '#pragma omp atomic' has clauses 'capture' and
+/// 'seq_cst'.
+///
+class OMPAtomicDirective : public OMPExecutableDirective {
+  friend class ASTStmtReader;
+  /// \brief Binary operator for atomic.
+  BinaryOperatorKind BinOp;
+  /// \brief Capture kind - true, if after expr, false, if before.
+  bool CaptureAfter;
+  /// \brief true, if operator for 'x' is reversed, false - otherwise.
+  bool Reversed;
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPAtomicDirective(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N)
+      : OMPExecutableDirective(
+            OMPAtomicDirectiveClass, OMPD_atomic, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPAtomicDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 4),
+        BinOp(BO_Assign), CaptureAfter(false), Reversed(false) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPAtomicDirective(unsigned N)
+      : OMPExecutableDirective(
+            OMPAtomicDirectiveClass, OMPD_atomic, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPAtomicDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 4),
+        BinOp(BO_Assign), CaptureAfter(false), Reversed(false) {}
+
+  /// \brief Sets binary operator for atomic.
+  void setOperator(BinaryOperatorKind Op) { BinOp = Op; }
+
+  /// \brief Sets 'v' parameter for atomic.
+  void setV(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+
+  /// \brief Sets 'x' parameter for atomic.
+  void setX(Expr *X) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = X;
+  }
+
+  /// \brief Sets 'expr' parameter for atomic.
+  void setExpr(Expr *OpExpr) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] =
+        OpExpr;
+  }
+
+  /// \brief Sets capture kind parameter for atomic.
+  void setCaptureAfter(bool CaptureKind) { CaptureAfter = CaptureKind; }
+
+  /// \brief Sets update rules for 'x' parameter for atomic.
+  void setReversed(bool IsReversed) { Reversed = IsReversed; }
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPAtomicDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *V, Expr *X,
+         Expr *OpExpr, BinaryOperatorKind Op, bool CaptureAfter, bool Reversed);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPAtomicDirective *CreateEmpty(const ASTContext &C, unsigned N,
+                                         EmptyShell);
+
+  /// \brief Returns binary operator for atomic.
+  BinaryOperatorKind getOperator() const { return BinOp; }
+
+  /// \brief Returns 'v' parameter for atomic.
+  Expr *getV() const {
+    return reinterpret_cast<Expr *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[1];
+  }
+
+  /// \brief Returns 'x' parameter for atomic.
+  Expr *getX() const {
+    return reinterpret_cast<Expr *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[2];
+  }
+
+  /// \brief Returns 'expr' parameter for atomic.
+  Expr *getExpr() const {
+    return reinterpret_cast<Expr *const *>(
+        &reinterpret_cast<OMPClause *const *>(this + 1)[getNumClauses()])[3];
+  }
+
+  /// \brief Returns capture kind parameter for atomic.
+  bool isCaptureAfter() const { return CaptureAfter; }
+
+  /// \brief Returns update kind of 'x' parameter for atomic.
+  bool isReversed() const { return Reversed; }
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPAtomicDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp flush' directive.
+///
+/// \code
+/// #pragma omp flush(a,b)
+/// \endcode
+/// In this example directive '#pragma omp flush' has list of variables 'a' and
+/// 'b'.
+///
+class OMPFlushDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPFlushDirective(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N)
+      : OMPExecutableDirective(
+            OMPFlushDirectiveClass, OMPD_flush, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPFlushDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            false, 0) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPFlushDirective(unsigned N)
+      : OMPExecutableDirective(
+            OMPFlushDirectiveClass, OMPD_flush, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPFlushDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            false, 0) {}
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  ///
+  static OMPFlushDirective *Create(const ASTContext &C, SourceLocation StartLoc,
+                                   SourceLocation EndLoc,
+                                   ArrayRef<OMPClause *> Clauses);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPFlushDirective *CreateEmpty(const ASTContext &C, unsigned N,
+                                        EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPFlushDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp ordered' directive.
+///
+/// \code
+/// #pragma omp ordered
+/// \endcode
+/// In this example directive '#pragma omp ordered' is used.
+///
+class OMPOrderedDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  ///
+  OMPOrderedDirective(SourceLocation StartLoc, SourceLocation EndLoc)
+      : OMPExecutableDirective(
+            OMPOrderedDirectiveClass, OMPD_ordered, StartLoc, EndLoc, 0,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPOrderedDirective),
+                                         sizeof(Stmt *))),
+            true, 1) {}
+
+  /// \brief Build an empty directive.
+  ///
+  explicit OMPOrderedDirective()
+      : OMPExecutableDirective(
+            OMPOrderedDirectiveClass, OMPD_ordered, SourceLocation(),
+            SourceLocation(), 0,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPOrderedDirective),
+                                         sizeof(Stmt *))),
+            true, 1) {}
+
+public:
+  /// \brief Creates directive.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPOrderedDirective *Create(const ASTContext &C,
+                                     SourceLocation StartLoc,
+                                     SourceLocation EndLoc,
+                                     Stmt *AssociatedStmt);
+
+  /// \brief Creates an empty directive.
+  ///
+  /// \param C AST context.
+  ///
+  static OMPOrderedDirective *CreateEmpty(const ASTContext &C, EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPOrderedDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp teams' directive.
+///
+/// \code
+/// #pragma omp teams private(a,b) reduction(+: c,d)
+/// \endcode
+/// In this example directive '#pragma omp teams' has clauses 'private'
+/// with the variables 'a' and 'b' and 'reduction' with operator '+' and
+/// variables 'c' and 'd'.
+///
+class OMPTeamsDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPTeamsDirective(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N)
+      : OMPExecutableDirective(
+            OMPTeamsDirectiveClass, OMPD_teams, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTeamsDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPTeamsDirective(unsigned N)
+      : OMPExecutableDirective(
+            OMPTeamsDirectiveClass, OMPD_teams, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTeamsDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPTeamsDirective *Create(const ASTContext &C, SourceLocation StartLoc,
+                                   SourceLocation EndLoc,
+                                   ArrayRef<OMPClause *> Clauses,
+                                   Stmt *AssociatedStmt);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPTeamsDirective *CreateEmpty(const ASTContext &C, unsigned N,
+                                        EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPTeamsDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp distribute' directive.
+///
+/// \code
+/// #pragma omp distribute private(a,b) collapse(2)
+/// \endcode
+/// In this example directive '#pragma omp distribute' has clauses 'private'
+/// with the variables 'a' and 'b', and 'collapse' with number '2' of loops to
+/// be collapsed.
+///
+class OMPDistributeDirective : public OMPExecutableDirective {
+  friend class ASTStmtReader;
+  unsigned CollapsedNum;
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPDistributeDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                         unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPDistributeDirectiveClass, OMPD_distribute, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPDistributeDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPDistributeDirective(unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPDistributeDirectiveClass, OMPD_distribute, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPDistributeDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  // 5 is for AssociatedStmt, NewIterVar, NewIterEnd, Init, Final
+  // and CollapsedNum is for Counters.
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]));
+  }
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPDistributeDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPDistributeDirective *CreateEmpty(const ASTContext &C,
+                                             unsigned CollapsedNum, unsigned N,
+                                             EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[4]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(&(reinterpret_cast<Stmt *const *>(
+            &getClausesStorage()[getNumClauses()])[5])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPDistributeDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp cancel' directive.
+///
+/// \code
+/// #pragma omp cancel parallel
+/// \endcode
+/// In this example directive '#pragma omp cancel' has construct type
+/// 'parallel'.
+///
+class OMPCancelDirective : public OMPExecutableDirective {
+  OpenMPDirectiveKind ConstructType;
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
+  /// \param ConstructType Construct type.
+  ///
+  OMPCancelDirective(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N,
+                     OpenMPDirectiveKind ConstructType)
+      : OMPExecutableDirective(
+            OMPCancelDirectiveClass, OMPD_cancel, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPCancelDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            false, 0),
+        ConstructType(ConstructType) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  /// \param ConstructType Construct type.
+  ///
+  explicit OMPCancelDirective(unsigned N, OpenMPDirectiveKind ConstructType)
+      : OMPExecutableDirective(
+            OMPCancelDirectiveClass, OMPD_cancel, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPCancelDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            false, 0),
+        ConstructType(ConstructType) {}
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param ConstructType Construct type.
+  ///
+  static OMPCancelDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, OpenMPDirectiveKind ConstructType);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  /// \param ConstructType Construct type.
+  ///
+  static OMPCancelDirective *CreateEmpty(const ASTContext &C, unsigned N,
+                                         OpenMPDirectiveKind ConstructType,
+                                         EmptyShell);
+
+  /// \brief Fetches construct type.
+  OpenMPDirectiveKind getConstructType() const { return ConstructType; }
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPCancelDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp cancellation point' directive.
+///
+/// \code
+/// #pragma omp cancellation point parallel
+/// \endcode
+/// In this example directive '#pragma omp cancellation point' has construct
+/// type 'parallel'.
+///
+class OMPCancellationPointDirective : public OMPExecutableDirective {
+  OpenMPDirectiveKind ConstructType;
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param ConstructType Construct type.
+  ///
+  OMPCancellationPointDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                                OpenMPDirectiveKind ConstructType)
+      : OMPExecutableDirective(OMPCancellationPointDirectiveClass,
+                               OMPD_cancellation_point, StartLoc, EndLoc, 0, 0,
+                               false, 0),
+        ConstructType(ConstructType) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param ConstructType Construct type.
+  ///
+  explicit OMPCancellationPointDirective(OpenMPDirectiveKind ConstructType)
+      : OMPExecutableDirective(OMPCancellationPointDirectiveClass,
+                               OMPD_cancellation_point, SourceLocation(),
+                               SourceLocation(), 0, 0, false, 0),
+        ConstructType(ConstructType) {}
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param ConstructType Construct type.
+  ///
+  static OMPCancellationPointDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         OpenMPDirectiveKind ConstructType);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param ConstructType Construct type.
+  ///
+  static OMPCancellationPointDirective *
+  CreateEmpty(const ASTContext &C, OpenMPDirectiveKind ConstructType,
+              EmptyShell);
+
+  /// \brief Fetches construct type.
+  OpenMPDirectiveKind getConstructType() const { return ConstructType; }
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPCancellationPointDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp target' directive.
+///
+/// \code
+/// #pragma omp target device(0) if(a) map(b[:])
+/// \endcode
+/// In this example directive '#pragma omp target' has clauses 'device'
+/// with the value '0', 'if' with condition 'a' and 'map' with array
+/// section 'b[:]'.
+///
+class OMPTargetDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPTargetDirective(SourceLocation StartLoc, SourceLocation EndLoc, unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetDirectiveClass, OMPD_target, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTargetDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPTargetDirective(unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetDirectiveClass, OMPD_target, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTargetDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
   ///
   /// \param C AST context.
   /// \param StartLoc Starting location of the directive kind.
@@ -818,188 +3274,701 @@
   /// \param Clauses List of clauses.
   /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPTaskDirective *Create(const ASTContext &C, SourceLocation StartLoc,
-                                  SourceLocation EndLoc,
-                                  ArrayRef<OMPClause *> Clauses,
-                                  Stmt *AssociatedStmt);
+  static OMPTargetDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);
 
-  /// \brief Creates an empty directive with the place for \a NumClauses
-  /// clauses.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  static OMPTaskDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,
-                                       EmptyShell);
+  static OMPTargetDirective *CreateEmpty(const ASTContext &C, unsigned N,
+                                         EmptyShell);
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPTaskDirectiveClass;
+    return T->getStmtClass() == OMPTargetDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp taskyield' directive.
+/// \brief This represents '#pragma omp target teams' directive.
 ///
 /// \code
-/// #pragma omp taskyield
+/// #pragma omp target teams device(0) if(a) map(b[:]) num_teams(10)
 /// \endcode
+/// In this example directive '#pragma omp target teams' has clauses 'device'
+/// with the value '0', 'if' with condition 'a', 'map' with array
+/// section 'b[:]' and 'num_teams' with number of teams '10'.
 ///
-class OMPTaskyieldDirective : public OMPExecutableDirective {
+class OMPTargetTeamsDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPTargetTeamsDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                          unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetTeamsDirectiveClass, OMPD_target_teams, StartLoc, EndLoc,
+            N, reinterpret_cast<OMPClause **>(
+                   reinterpret_cast<char *>(this) +
+                   llvm::RoundUpToAlignment(sizeof(OMPTargetTeamsDirective),
+                                            llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPTargetTeamsDirective(unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetTeamsDirectiveClass, OMPD_target_teams, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTargetTeamsDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPTargetTeamsDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPTargetTeamsDirective *CreateEmpty(const ASTContext &C, unsigned N,
+                                              EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPTargetTeamsDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp target data' directive.
+///
+/// \code
+/// #pragma omp target data device(0) if(a) map(b[:])
+/// \endcode
+/// In this example directive '#pragma omp target data' has clauses 'device'
+/// with the value '0', 'if' with condition 'a' and 'map' with array
+/// section 'b[:]'.
+///
+class OMPTargetDataDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPTargetDataDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                         unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetDataDirectiveClass, OMPD_target_data, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTargetDataDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPTargetDataDirective(unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetDataDirectiveClass, OMPD_target_data, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTargetDataDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 1) {}
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
+  ///
+  static OMPTargetDataDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPTargetDataDirective *CreateEmpty(const ASTContext &C, unsigned N,
+                                             EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPTargetDataDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp target update' directive.
+///
+/// \code
+/// #pragma omp target update to(a) from(b) device(1)
+/// \endcode
+/// In this example directive '#pragma omp target update' has clause 'to' with
+/// argument 'a', clause 'from' with argument 'b' and clause 'device' with
+/// argument '1'.
+///
+class OMPTargetUpdateDirective : public OMPExecutableDirective {
+  /// \brief Build directive with the given start and end location.
+  ///
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
+  ///
+  OMPTargetUpdateDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                           unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetUpdateDirectiveClass, OMPD_target_update, StartLoc, EndLoc,
+            N, reinterpret_cast<OMPClause **>(
+                   reinterpret_cast<char *>(this) +
+                   llvm::RoundUpToAlignment(sizeof(OMPTargetUpdateDirective),
+                                            llvm::alignOf<OMPClause *>())),
+            false, 0) {}
+
+  /// \brief Build an empty directive.
+  ///
+  /// \param N Number of clauses.
+  ///
+  explicit OMPTargetUpdateDirective(unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetUpdateDirectiveClass, OMPD_target_update, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTargetUpdateDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            false, 0) {}
+
+public:
+  /// \brief Creates directive with a list of \a Clauses.
+  ///
+  /// \param C AST context.
+  /// \param StartLoc Starting location of the directive kind.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  ///
+  static OMPTargetUpdateDirective *Create(const ASTContext &C,
+                                          SourceLocation StartLoc,
+                                          SourceLocation EndLoc,
+                                          ArrayRef<OMPClause *> Clauses);
+
+  /// \brief Creates an empty directive with the place for \a N clauses.
+  ///
+  /// \param C AST context.
+  /// \param N The number of clauses.
+  ///
+  static OMPTargetUpdateDirective *CreateEmpty(const ASTContext &C, unsigned N,
+                                               EmptyShell);
+
+  static bool classof(const Stmt *T) {
+    return T->getStmtClass() == OMPTargetUpdateDirectiveClass;
+  }
+};
+
+/// \brief This represents '#pragma omp teams distribute' directive.
+///
+/// \code
+/// #pragma omp teams distribute private(a,b) collapse(2)
+/// \endcode
+/// In this example directive '#pragma omp teams distribute' has clauses
+/// 'private' with the variables 'a' and 'b', and 'collapse' with number '2' of
+/// loops to be collapsed.
+///
+class OMPTeamsDistributeDirective : public OMPExecutableDirective {
   friend class ASTStmtReader;
+  unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
   /// \param StartLoc Starting location of the directive kind.
-  /// \param EndLoc Ending location of the directive.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
   ///
-  OMPTaskyieldDirective(SourceLocation StartLoc, SourceLocation EndLoc)
-      : OMPExecutableDirective(this, OMPTaskyieldDirectiveClass, OMPD_taskyield,
-                               StartLoc, EndLoc, 0, 0) {}
+  OMPTeamsDistributeDirective(SourceLocation StartLoc, SourceLocation EndLoc,
+                              unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPTeamsDistributeDirectiveClass, OMPD_teams_distribute, StartLoc,
+            EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTeamsDistributeDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  explicit OMPTaskyieldDirective()
-      : OMPExecutableDirective(this, OMPTaskyieldDirectiveClass, OMPD_taskyield,
-                               SourceLocation(), SourceLocation(), 0, 0) {}
+  /// \param N Number of clauses.
+  ///
+  explicit OMPTeamsDistributeDirective(unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPTeamsDistributeDirectiveClass, OMPD_teams_distribute,
+            SourceLocation(), SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(sizeof(OMPTeamsDistributeDirective),
+                                         llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  // 5 is for AssociatedStmt, NewIterVar, NewIterEnd, Init, Final
+  // and CollapsedNum is for Counters.
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]));
+  }
 
 public:
-  /// \brief Creates directive.
+  /// \brief Creates directive with a list of \a Clauses.
   ///
   /// \param C AST context.
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPTaskyieldDirective *
-  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);
+  static OMPTeamsDistributeDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts);
 
-  /// \brief Creates an empty directive.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
+  /// \param N The number of clauses.
   ///
-  static OMPTaskyieldDirective *CreateEmpty(const ASTContext &C, EmptyShell);
+  static OMPTeamsDistributeDirective *CreateEmpty(const ASTContext &C,
+                                                  unsigned CollapsedNum,
+                                                  unsigned N, EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[4]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(
+            &(reinterpret_cast<Stmt *const *>(
+                 &getClausesStorage()[getNumClauses()])[5])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPTaskyieldDirectiveClass;
+    return T->getStmtClass() == OMPTeamsDistributeDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp barrier' directive.
+/// \brief This represents '#pragma omp teams distribute simd' directive.
 ///
 /// \code
-/// #pragma omp barrier
+/// #pragma omp teams simd distribute private(a,b) collapse(2)
 /// \endcode
+/// In this example directive '#pragma omp teams distribute simd' has clauses
+/// 'private' with the variables 'a' and 'b', and 'collapse' with number '2' of
+/// loops to be collapsed.
 ///
-class OMPBarrierDirective : public OMPExecutableDirective {
+class OMPTeamsDistributeSimdDirective : public OMPExecutableDirective {
   friend class ASTStmtReader;
+  unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
   /// \param StartLoc Starting location of the directive kind.
-  /// \param EndLoc Ending location of the directive.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
   ///
-  OMPBarrierDirective(SourceLocation StartLoc, SourceLocation EndLoc)
-      : OMPExecutableDirective(this, OMPBarrierDirectiveClass, OMPD_barrier,
-                               StartLoc, EndLoc, 0, 0) {}
+  OMPTeamsDistributeSimdDirective(SourceLocation StartLoc,
+                                  SourceLocation EndLoc, unsigned CollapsedNum,
+                                  unsigned N)
+      : OMPExecutableDirective(OMPTeamsDistributeSimdDirectiveClass,
+                               OMPD_teams_distribute_simd, StartLoc, EndLoc, N,
+                               reinterpret_cast<OMPClause **>(
+                                   reinterpret_cast<char *>(this) +
+                                   llvm::RoundUpToAlignment(
+                                       sizeof(OMPTeamsDistributeSimdDirective),
+                                       llvm::alignOf<OMPClause *>())),
+                               true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  explicit OMPBarrierDirective()
-      : OMPExecutableDirective(this, OMPBarrierDirectiveClass, OMPD_barrier,
-                               SourceLocation(), SourceLocation(), 0, 0) {}
+  /// \param N Number of clauses.
+  ///
+  explicit OMPTeamsDistributeSimdDirective(unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(OMPTeamsDistributeSimdDirectiveClass,
+                               OMPD_teams_distribute_simd, SourceLocation(),
+                               SourceLocation(), N,
+                               reinterpret_cast<OMPClause **>(
+                                   reinterpret_cast<char *>(this) +
+                                   llvm::RoundUpToAlignment(
+                                       sizeof(OMPTeamsDistributeSimdDirective),
+                                       llvm::alignOf<OMPClause *>())),
+                               true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  // 5 is for AssociatedStmt, NewIterVar, NewIterEnd, Init, Final
+  // and CollapsedNum is for Counters.
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]));
+  }
 
 public:
-  /// \brief Creates directive.
+  /// \brief Creates directive with a list of \a Clauses.
   ///
   /// \param C AST context.
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPBarrierDirective *
-  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);
+  static OMPTeamsDistributeSimdDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts);
 
-  /// \brief Creates an empty directive.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
+  /// \param N The number of clauses.
   ///
-  static OMPBarrierDirective *CreateEmpty(const ASTContext &C, EmptyShell);
+  static OMPTeamsDistributeSimdDirective *CreateEmpty(const ASTContext &C,
+                                                      unsigned CollapsedNum,
+                                                      unsigned N, EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[4]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(
+            &(reinterpret_cast<Stmt *const *>(
+                 &getClausesStorage()[getNumClauses()])[5])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPBarrierDirectiveClass;
+    return T->getStmtClass() == OMPTeamsDistributeSimdDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp taskwait' directive.
+/// \brief This represents '#pragma omp target teams distribute' directive.
 ///
 /// \code
-/// #pragma omp taskwait
+/// #pragma omp target teams distribute private(a,b) collapse(2)
 /// \endcode
+/// In this example directive '#pragma omp target teams distribute' has clauses
+/// 'private' with the variables 'a' and 'b', and 'collapse' with number '2' of
+/// loops to be collapsed.
 ///
-class OMPTaskwaitDirective : public OMPExecutableDirective {
+class OMPTargetTeamsDistributeDirective : public OMPExecutableDirective {
   friend class ASTStmtReader;
+  unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
   /// \param StartLoc Starting location of the directive kind.
-  /// \param EndLoc Ending location of the directive.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
   ///
-  OMPTaskwaitDirective(SourceLocation StartLoc, SourceLocation EndLoc)
-      : OMPExecutableDirective(this, OMPTaskwaitDirectiveClass, OMPD_taskwait,
-                               StartLoc, EndLoc, 0, 0) {}
+  OMPTargetTeamsDistributeDirective(SourceLocation StartLoc,
+                                    SourceLocation EndLoc,
+                                    unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetTeamsDistributeDirectiveClass,
+            OMPD_target_teams_distribute, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPTargetTeamsDistributeDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  explicit OMPTaskwaitDirective()
-      : OMPExecutableDirective(this, OMPTaskwaitDirectiveClass, OMPD_taskwait,
-                               SourceLocation(), SourceLocation(), 0, 0) {}
+  /// \param N Number of clauses.
+  ///
+  explicit OMPTargetTeamsDistributeDirective(unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetTeamsDistributeDirectiveClass,
+            OMPD_target_teams_distribute, SourceLocation(), SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPTargetTeamsDistributeDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  // 5 is for AssociatedStmt, NewIterVar, NewIterEnd, Init, Final
+  // and CollapsedNum is for Counters.
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]));
+  }
 
 public:
-  /// \brief Creates directive.
+  /// \brief Creates directive with a list of \a Clauses.
   ///
   /// \param C AST context.
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending Location of the directive.
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPTaskwaitDirective *
-  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);
+  static OMPTargetTeamsDistributeDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts);
 
-  /// \brief Creates an empty directive.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
+  /// \param N The number of clauses.
   ///
-  static OMPTaskwaitDirective *CreateEmpty(const ASTContext &C, EmptyShell);
+  static OMPTargetTeamsDistributeDirective *CreateEmpty(const ASTContext &C,
+                                                        unsigned CollapsedNum,
+                                                        unsigned N, EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[4]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(
+            &(reinterpret_cast<Stmt *const *>(
+                 &getClausesStorage()[getNumClauses()])[5])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPTaskwaitDirectiveClass;
+    return T->getStmtClass() == OMPTargetTeamsDistributeDirectiveClass;
   }
 };
 
-/// \brief This represents '#pragma omp flush' directive.
+/// \brief This represents '#pragma omp target teams distribute simd' directive.
 ///
 /// \code
-/// #pragma omp flush(a,b)
+/// #pragma omp target teams simd distribute private(a,b) collapse(2)
 /// \endcode
-/// In this example directive '#pragma omp flush' has 2 arguments- variables 'a'
-/// and 'b'.
-/// 'omp flush' directive does not have clauses but have an optional list of
-/// variables to flush. This list of variables is stored within some fake clause
-/// FlushClause.
-class OMPFlushDirective : public OMPExecutableDirective {
+/// In this example directive '#pragma omp teams distribute simd' has clauses
+/// 'private' with the variables 'a' and 'b', and 'collapse' with number '2' of
+/// loops to be collapsed.
+///
+class OMPTargetTeamsDistributeSimdDirective : public OMPExecutableDirective {
   friend class ASTStmtReader;
+  unsigned CollapsedNum;
   /// \brief Build directive with the given start and end location.
   ///
   /// \param StartLoc Starting location of the directive kind.
-  /// \param EndLoc Ending location of the directive.
-  /// \param NumClauses Number of clauses.
+  /// \param EndLoc Ending Location of the directive.
+  /// \param N The number of clauses.
   ///
-  OMPFlushDirective(SourceLocation StartLoc, SourceLocation EndLoc,
-                    unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPFlushDirectiveClass, OMPD_flush,
-                               StartLoc, EndLoc, NumClauses, 0) {}
+  OMPTargetTeamsDistributeSimdDirective(SourceLocation StartLoc,
+                                        SourceLocation EndLoc,
+                                        unsigned CollapsedNum, unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetTeamsDistributeSimdDirectiveClass,
+            OMPD_target_teams_distribute_simd, StartLoc, EndLoc, N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPTargetTeamsDistributeSimdDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
 
   /// \brief Build an empty directive.
   ///
-  /// \param NumClauses Number of clauses.
+  /// \param N Number of clauses.
   ///
-  explicit OMPFlushDirective(unsigned NumClauses)
-      : OMPExecutableDirective(this, OMPFlushDirectiveClass, OMPD_flush,
-                               SourceLocation(), SourceLocation(), NumClauses,
-                               0) {}
+  explicit OMPTargetTeamsDistributeSimdDirective(unsigned CollapsedNum,
+                                                 unsigned N)
+      : OMPExecutableDirective(
+            OMPTargetTeamsDistributeSimdDirectiveClass,
+            OMPD_target_teams_distribute_simd, SourceLocation(),
+            SourceLocation(), N,
+            reinterpret_cast<OMPClause **>(
+                reinterpret_cast<char *>(this) +
+                llvm::RoundUpToAlignment(
+                    sizeof(OMPTargetTeamsDistributeSimdDirective),
+                    llvm::alignOf<OMPClause *>())),
+            true, 5 + CollapsedNum),
+        CollapsedNum(CollapsedNum) {}
+  // 5 is for AssociatedStmt, NewIterVar, NewIterEnd, Init, Final
+  // and CollapsedNum is for Counters.
+  void setNewIterVar(Expr *V) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1] = V;
+  }
+  void setNewIterEnd(Expr *E) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2] = E;
+  }
+  void setInit(Expr *I) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3] = I;
+  }
+  void setFinal(Expr *F) {
+    reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4] = F;
+  }
+  void setCounters(ArrayRef<Expr *> VL) {
+    assert(VL.size() == CollapsedNum && "Number of variables is not the same "
+                                        "as the number of collapsed loops.");
+    std::copy(
+        VL.begin(), VL.end(),
+        &(reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[5]));
+  }
 
 public:
   /// \brief Creates directive with a list of \a Clauses.
@@ -1007,24 +3976,66 @@
   /// \param C AST context.
   /// \param StartLoc Starting location of the directive kind.
   /// \param EndLoc Ending Location of the directive.
-  /// \param Clauses List of clauses (only single OMPFlushClause clause is
-  /// allowed).
+  /// \param Clauses List of clauses.
+  /// \param AssociatedStmt Statement, associated with the directive.
   ///
-  static OMPFlushDirective *Create(const ASTContext &C, SourceLocation StartLoc,
-                                   SourceLocation EndLoc,
-                                   ArrayRef<OMPClause *> Clauses);
+  static OMPTargetTeamsDistributeSimdDirective *
+  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+         Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts);
 
-  /// \brief Creates an empty directive with the place for \a NumClauses
-  /// clauses.
+  /// \brief Creates an empty directive with the place for \a N clauses.
   ///
   /// \param C AST context.
-  /// \param NumClauses Number of clauses.
+  /// \param N The number of clauses.
   ///
-  static OMPFlushDirective *CreateEmpty(const ASTContext &C,
-                                        unsigned NumClauses, EmptyShell);
+  static OMPTargetTeamsDistributeSimdDirective *
+  CreateEmpty(const ASTContext &C, unsigned CollapsedNum, unsigned N,
+              EmptyShell);
+
+  Expr *getNewIterVar() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() const {
+    return cast_or_null<Expr>(reinterpret_cast<Stmt *const *>(
+        &getClausesStorage()[getNumClauses()])[4]);
+  }
+  ArrayRef<Expr *> getCounters() const {
+    return llvm::makeArrayRef(
+        reinterpret_cast<Expr *const *>(
+            &(reinterpret_cast<Stmt *const *>(
+                 &getClausesStorage()[getNumClauses()])[5])),
+        CollapsedNum);
+  }
+  unsigned getCollapsedNumber() const { return CollapsedNum; }
+  Expr *getNewIterVar() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[1]);
+  }
+  Expr *getNewIterEnd() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[2]);
+  }
+  Expr *getInit() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[3]);
+  }
+  Expr *getFinal() {
+    return cast_or_null<Expr>(
+        reinterpret_cast<Stmt **>(&getClausesStorage()[getNumClauses()])[4]);
+  }
 
   static bool classof(const Stmt *T) {
-    return T->getStmtClass() == OMPFlushDirectiveClass;
+    return T->getStmtClass() == OMPTargetTeamsDistributeSimdDirectiveClass;
   }
 };
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/AST/StmtVisitor.h cfe-3.5.0.src.omp/include/clang/AST/StmtVisitor.h
--- cfe-3.5.0.src/include/clang/AST/StmtVisitor.h	2013-07-18 23:13:43.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/AST/StmtVisitor.h	2014-11-28 10:49:29.000000000 -0500
@@ -185,41 +185,6 @@
 class ConstStmtVisitor
  : public StmtVisitorBase<make_const_ptr, ImplClass, RetTy> {};
 
-/// \brief This class implements a simple visitor for OMPClause
-/// subclasses.
-template<class ImplClass, template <typename> class Ptr, typename RetTy>
-class OMPClauseVisitorBase {
-public:
-#define PTR(CLASS) typename Ptr<CLASS>::type
-#define DISPATCH(CLASS) \
-  return static_cast<ImplClass*>(this)->Visit##CLASS(static_cast<PTR(CLASS)>(S))
-
-#define OPENMP_CLAUSE(Name, Class)                              \
-  RetTy Visit ## Class (PTR(Class) S) { DISPATCH(Class); }
-#include "clang/Basic/OpenMPKinds.def"
-
-  RetTy Visit(PTR(OMPClause) S) {
-    // Top switch clause: visit each OMPClause.
-    switch (S->getClauseKind()) {
-    default: llvm_unreachable("Unknown clause kind!");
-#define OPENMP_CLAUSE(Name, Class)                              \
-    case OMPC_ ## Name : return Visit ## Class(static_cast<PTR(Class)>(S));
-#include "clang/Basic/OpenMPKinds.def"
-    }
-  }
-  // Base case, ignore it. :)
-  RetTy VisitOMPClause(PTR(OMPClause) Node) { return RetTy(); }
-#undef PTR
-#undef DISPATCH
-};
-
-template<class ImplClass, typename RetTy = void>
-class OMPClauseVisitor :
-      public OMPClauseVisitorBase <ImplClass, make_ptr, RetTy> {};
-template<class ImplClass, typename RetTy = void>
-class ConstOMPClauseVisitor :
-      public OMPClauseVisitorBase <ImplClass, make_const_ptr, RetTy> {};
-
 }  // end namespace clang
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Basic/Attr.td cfe-3.5.0.src.omp/include/clang/Basic/Attr.td
--- cfe-3.5.0.src/include/clang/Basic/Attr.td	2014-07-21 20:53:05.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Basic/Attr.td	2014-11-28 10:49:29.000000000 -0500
@@ -1783,6 +1783,13 @@
   let Spellings = [Keyword<"__unaligned">];
 }
 
+def OMPLocal : InheritableAttr {
+  let Spellings = [];
+  let SemaHandler = 0;
+  let HasCustomParsing = 1;
+  let Documentation = [Undocumented];
+}
+
 def LoopHint : Attr {
   /// vectorize: vectorizes loop operations if 'value != 0'.
   /// vectorize_width: vectorize loop operations with width 'value'.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Basic/CapturedStmt.h cfe-3.5.0.src.omp/include/clang/Basic/CapturedStmt.h
--- cfe-3.5.0.src/include/clang/Basic/CapturedStmt.h	2013-09-06 14:03:48.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Basic/CapturedStmt.h	2014-11-28 10:49:29.000000000 -0500
@@ -16,6 +16,7 @@
 /// \brief The different kinds of captured statement.
 enum CapturedRegionKind {
   CR_Default,
+  CR_SIMDFor,
   CR_OpenMP
 };
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Basic/DeclNodes.td cfe-3.5.0.src.omp/include/clang/Basic/DeclNodes.td
--- cfe-3.5.0.src/include/clang/Basic/DeclNodes.td	2013-08-05 21:03:05.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Basic/DeclNodes.td	2014-11-28 10:49:29.000000000 -0500
@@ -69,6 +69,7 @@
       def ObjCImplementation : DDecl<ObjCImpl>;
   def ObjCProperty : DDecl<Named>;
   def ObjCCompatibleAlias : DDecl<Named>;
+  def OMPDeclareReduction : DDecl<Named>, DeclContext;
 def LinkageSpec : Decl, DeclContext;
 def ObjCPropertyImpl : Decl;
 def FileScopeAsm : Decl;
@@ -81,5 +82,7 @@
 def ClassScopeFunctionSpecialization : Decl;
 def Import : Decl;
 def OMPThreadPrivate : Decl;
+def OMPDeclareSimd : Decl;
+def OMPDeclareTarget : Decl, DeclContext;
 def Empty : Decl;
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Basic/DiagnosticDriverKinds.td cfe-3.5.0.src.omp/include/clang/Basic/DiagnosticDriverKinds.td
--- cfe-3.5.0.src/include/clang/Basic/DiagnosticDriverKinds.td	2014-07-18 03:03:22.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Basic/DiagnosticDriverKinds.td	2014-11-28 10:49:29.000000000 -0500
@@ -119,6 +119,18 @@
 def err_drv_optimization_remark_pattern : Error<
   "%0 in '%1'">;
 def err_drv_no_neon_modifier : Error<"[no]neon is not accepted as modifier, please use [no]simd instead">;
+def err_drv_unknown_toolchain : Error<
+  "cannot recognize the type of the toolchain">;
+def err_drv_invalid_omp_target : Error<
+  "OpenMP target is invalid: '%0'">;
+def err_drv_omp_target_requires_main_file_path : Error<
+  "Main-file path is required to generate code for OpenMP target regions. Use -omp-main-file-path 'path'.">;
+def err_drv_omp_module_id_required : Error<
+  "Unable to generate module ID from input file '%0' for OpenMP target code generation. Make sure the file exists in the file system.">;
+def err_drv_omp_target_translation_not_available : Error<
+  "OpenMP target '%0' arguments translation is not supported.">;
+def err_drv_omp_target_toolchain_not_available : Error<
+  "Toolchain for target '%0' is not supporting OpenMP offloading.">;
 
 def warn_O4_is_O3 : Warning<"-O4 is equivalent to -O3">, InGroup<Deprecated>;
 def warn_drv_optimization_value : Warning<"optimization level '%0' is not supported; using '%1%2' instead">,
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Basic/DiagnosticParseKinds.td cfe-3.5.0.src.omp/include/clang/Basic/DiagnosticParseKinds.td
--- cfe-3.5.0.src/include/clang/Basic/DiagnosticParseKinds.td	2014-08-18 01:18:12.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Basic/DiagnosticParseKinds.td	2014-11-28 10:49:29.000000000 -0500
@@ -902,6 +902,12 @@
   "%0 only allowed in __finally block">;
 
 // OpenMP support.
+def err_expected_ident : Error<"expected identifier">;
+def err_expected_rparen : Error<"expected ')'">;
+def err_expected_colon : Error<"expected ':'">;
+def err_expected_comma : Error<"expected ','">;
+def err_expected_equal_after : Error<"expected '=' after %0">;
+
 def warn_pragma_omp_ignored : Warning<
   "unexpected '#pragma omp ...' in program">, InGroup<SourceUsesOpenMP>, DefaultIgnore;
 def warn_omp_extra_tokens_at_eol : Warning<
@@ -911,16 +917,30 @@
   "expected an OpenMP directive">;
 def err_omp_unexpected_directive : Error<
   "unexpected OpenMP directive '#pragma omp %0'">;
+def err_omp_expected_var : Error<
+  "expected '#pragma omp %0' argument to be a variable name">;
 def err_omp_expected_punc : Error<
-  "expected ',' or ')' in '%0' %select{clause|directive}1">;
+  "expected ',' or ')' in %select{'#pragma omp %1'|'%1' clause}0">;
+def err_omp_unknown_clause : Error<
+  "expected OpenMP clause for directive '#pragma omp %0' or end of directive">;
 def err_omp_unexpected_clause : Error<
   "unexpected OpenMP clause '%0' in directive '#pragma omp %1'">;
 def err_omp_more_one_clause : Error<
   "directive '#pragma omp %0' cannot contain more than one '%1' clause">;
+def err_omp_expected_colon : Error<
+  "expected ':' in '%0' clause">;
+def err_omp_unknown_reduction_op : Error<
+  "expected reduction identifier">;
 def err_omp_immediate_directive : Error<
-  "'#pragma omp %0' cannot be an immediate substatement">;
-def err_omp_expected_identifier_for_critical : Error<
-  "expected identifier specifying the name of the 'omp critical' directive">;
+  "'#pragma omp %0' cannot be immediate substatement">;
+def err_omp_expected_reduction_identifier : Error<
+  "expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&' and '||'">;
+def err_omp_unknown_dependence_type : Error<
+  "expected dependence type 'in', 'out' or 'inout'">;
+def err_omp_expected_cancel_construct_type : Error<
+  "expected 'parallel', 'sections', 'for' or 'taskgroup' construct type">;
+def err_expected_end_declare_target : Error<
+  "expected '#pragma omp end declare target'">;
 
 // Pragma loop support.
 def err_pragma_loop_invalid_option : Error<
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Basic/DiagnosticSemaKinds.td cfe-3.5.0.src.omp/include/clang/Basic/DiagnosticSemaKinds.td
--- cfe-3.5.0.src/include/clang/Basic/DiagnosticSemaKinds.td	2014-07-21 14:08:34.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Basic/DiagnosticSemaKinds.td	2014-11-28 10:49:29.000000000 -0500
@@ -739,7 +739,7 @@
   InGroup<ObjCPropertyNoAttribute>;
 def warn_property_attr_mismatch : Warning<
   "property attribute in class extension does not match the primary class">;
-def warn_property_implicitly_mismatched : Warning <
+def warn_property_implicitly_mismatched : Warning<
   "primary property declaration is implicitly strong while redeclaration "
   "in class extension is weak">,
   InGroup<DiagGroup<"objc-property-implicit-mismatch">>;
@@ -769,7 +769,7 @@
   "auto property synthesis will not synthesize property %0"
   " declared in protocol %1">,
   InGroup<DiagGroup<"objc-protocol-property-synthesis">>;
-def warn_no_autosynthesis_shared_ivar_property : Warning <
+def warn_no_autosynthesis_shared_ivar_property : Warning<
   "auto property synthesis will not synthesize property "
   "%0 because it cannot share an ivar with another synthesized property">,
   InGroup<ObjCNoPropertyAutoSynthesis>;
@@ -782,7 +782,7 @@
   "autosynthesized property %0 will use %select{|synthesized}1 instance variable "
   "%2, not existing instance variable %3">,
   InGroup<DiagGroup<"objc-autosynthesis-property-ivar-name-match">>;
-def warn_missing_explicit_synthesis : Warning <
+def warn_missing_explicit_synthesis : Warning<
   "auto property synthesis is synthesizing property not explicitly synthesized">,
   InGroup<DiagGroup<"objc-missing-property-synthesis">>, DefaultIgnore;
 def warn_property_getter_owning_mismatch : Warning<
@@ -848,23 +848,23 @@
 InGroup<DeallocInCategory>;
 def err_gc_weak_property_strong_type : Error<
   "weak attribute declared on a __strong type property in GC mode">;
-def warn_receiver_is_weak : Warning <
+def warn_receiver_is_weak : Warning<
   "weak %select{receiver|property|implicit property}0 may be "
   "unpredictably set to nil">,
   InGroup<DiagGroup<"receiver-is-weak">>, DefaultIgnore;
 def note_arc_assign_to_strong : Note<
   "assign the value to a strong variable to keep the object alive during use">;
-def warn_arc_repeated_use_of_weak : Warning <
+def warn_arc_repeated_use_of_weak : Warning<
   "weak %select{variable|property|implicit property|instance variable}0 %1 is "
   "accessed multiple times in this %select{function|method|block|lambda}2 "
   "but may be unpredictably set to nil; assign to a strong variable to keep "
   "the object alive">,
   InGroup<ARCRepeatedUseOfWeak>, DefaultIgnore;
-def warn_implicitly_retains_self : Warning <
+def warn_implicitly_retains_self : Warning<
   "block implicitly retains 'self'; explicitly mention 'self' to indicate "
   "this is intended behavior">,
   InGroup<DiagGroup<"implicit-retain-self">>, DefaultIgnore;
-def warn_arc_possible_repeated_use_of_weak : Warning <
+def warn_arc_possible_repeated_use_of_weak : Warning<
   "weak %select{variable|property|implicit property|instance variable}0 %1 may "
   "be accessed multiple times in this %select{function|method|block|lambda}2 "
   "and may be unpredictably set to nil; assign to a strong variable to keep "
@@ -1736,7 +1736,7 @@
 def err_for_range_dereference : Error<
   "invalid range expression of type %0; did you mean to dereference it "
   "with '*'?">;
-def note_for_range_invalid_iterator : Note <
+def note_for_range_invalid_iterator : Note<
   "in implicit call to 'operator%select{!=|*|++}0' for iterator of type %1">;
 def note_for_range_begin_end : Note<
   "selected '%select{begin|end}0' %select{function|template }1%2 with iterator type %3">;
@@ -3728,7 +3728,7 @@
 def warn_not_enough_argument : Warning<
   "not enough variable arguments in %0 declaration to fit a sentinel">,
   InGroup<Sentinel>;
-def warn_missing_sentinel : Warning <
+def warn_missing_sentinel : Warning<
   "missing sentinel in %select{function call|method dispatch|block call}0">,
   InGroup<Sentinel>;
 def note_sentinel_here : Note<
@@ -3830,7 +3830,7 @@
   "conflicts with declaration %select{in global scope|with C language linkage}0">;
 def note_extern_c_global_conflict : Note<
   "declared %select{in global scope|with C language linkage}0 here">;
-def warn_weak_import : Warning <
+def warn_weak_import : Warning<
   "an already-declared variable is made a weak_import declaration %0">;
 def ext_static_non_static : Extension<
   "redeclaring non-static %0 as static is a Microsoft extension">, InGroup<Microsoft>;
@@ -4808,7 +4808,7 @@
   InGroup<CompareDistinctPointerType>;
 def ext_typecheck_cond_incompatible_operands : ExtWarn<
   "incompatible operand types (%0 and %1)">;
-def err_cond_voidptr_arc : Error <
+def err_cond_voidptr_arc : Error<
   "operands to conditional of types%diff{ $ and $|}0,1 are incompatible "
   "in ARC mode">;
 def err_typecheck_comparison_of_distinct_pointers : Error<
@@ -6031,11 +6031,11 @@
 def err_only_constructors_take_base_inits : Error<
   "only constructors take base initializers">;
 
-def err_multiple_mem_initialization : Error <
+def err_multiple_mem_initialization : Error<
   "multiple initializations given for non-static member %0">;
-def err_multiple_mem_union_initialization : Error <
+def err_multiple_mem_union_initialization : Error<
   "initializing multiple members of union">;
-def err_multiple_base_initialization : Error <
+def err_multiple_base_initialization : Error<
   "multiple initializations given for base %0">;
 
 def err_mem_init_not_member_or_class : Error<
@@ -6373,7 +6373,7 @@
   "%select{values of type|enum values with underlying type}2 '%0' should not "
   "be used as format arguments; add an explicit cast to %1 instead">,
   InGroup<Format>;
-def warn_printf_positional_arg_exceeds_data_args : Warning <
+def warn_printf_positional_arg_exceeds_data_args : Warning<
   "data argument position '%0' exceeds the number of data arguments (%1)">,
   InGroup<Format>;
 def warn_format_zero_positional_specifier : Warning<
@@ -6998,151 +6998,186 @@
   "'#pragma omp %0' must precede all references to variable %q1">;
 def err_omp_var_thread_local : Error<
   "variable %0 cannot be threadprivate because it is thread-local">;
+def err_omp_threadprivate_incomplete_type : Error<
+  "a threadprivate variable with incomplete type %0">;
 def err_omp_private_incomplete_type : Error<
   "a private variable with incomplete type %0">;
 def err_omp_firstprivate_incomplete_type : Error<
   "a firstprivate variable with incomplete type %0">;
-def err_omp_lastprivate_incomplete_type : Error<
-  "a lastprivate variable with incomplete type %0">;
 def err_omp_reduction_incomplete_type : Error<
   "a reduction variable with incomplete type %0">;
+def err_omp_lastprivate_incomplete_type : Error<
+  "a lastprivate variable with incomplete type %0">;
+def err_omp_linear_incomplete_type : Error<
+  "a linear variable with incomplete type %0">;
+def err_omp_directive_nonblock : Error<
+  "directive '#pragma omp %0' bound to nonblock statement">;
+def err_incomplete_class_type : Error<
+  "expression has incomplete type %0">;
+def err_multiple_conversions : Error<
+  "multiple conversions from expression type %0 to an integral "
+  "or enumeration type">;
+def err_explicit_conversion : Error<
+  "expression type %0 requires explicit conversion to %1">;
+def note_conversion : Note<
+  "conversion to %select{integral|enumeration}0 type %1">;
+def err_negative_expression_in_clause : Error<
+  "expression is not a positive integer value">;
+def err_zero_step_in_linear_clause : Error<
+  "zero is not linear enough to be a linear step">;
 def err_omp_unexpected_clause_value : Error<
   "expected %0 in OpenMP clause '%1'">;
 def err_omp_expected_var_name : Error<
   "expected variable name">;
 def err_omp_required_method : Error<
   "%0 variable must have an accessible, unambiguous %select{default constructor|copy constructor|copy assignment operator|'%2'|destructor}1">;
-def err_omp_task_predetermined_firstprivate_required_method : Error<
-  "predetermined as a firstprivate in a task construct variable must have an accessible, unambiguous %select{copy constructor|destructor}0">;
+def note_omp_marked_here : Note<
+  "marked as %0 here">;
 def err_omp_clause_ref_type_arg : Error<
-  "arguments of OpenMP clause '%0' cannot be of reference type %1">;
-def err_omp_task_predetermined_firstprivate_ref_type_arg : Error<
-  "predetermined as a firstprivate in a task construct variable cannot be of reference type %0">;
-def err_omp_threadprivate_incomplete_type : Error<
-  "threadprivate variable with incomplete type %0">;
-def err_omp_no_dsa_for_variable : Error<
-  "variable %0 must have explicitly specified data sharing attributes">;
-def err_omp_wrong_dsa : Error<
-  "%0 variable cannot be %1">;
-def note_omp_explicit_dsa : Note<
-  "defined as %0">;
-def note_omp_predetermined_dsa : Note<
-  "%select{static data member is predetermined as shared|"
-  "variable with static storage duration is predetermined as shared|"
-  "loop iteration variable is predetermined as private|"
-  "loop iteration variable is predetermined as linear|"
-  "loop iteration variable is predetermined as lastprivate|"
-  "constant variable is predetermined as shared|"
-  "global variable is predetermined as shared|"
-  "non-shared variable in a task construct is predetermined as firstprivate|"
-  "variable with automatic storage duration is predetermined as private}0"
-  "%select{|; perhaps you forget to enclose 'omp %2' directive into a parallel or another task region?}1">;
-def note_omp_implicit_dsa : Note<
-  "implicitly determined as %0">;
-def err_omp_loop_var_dsa : Error<
-  "loop iteration variable in the associated loop of 'omp %1' directive may not be %0, predetermined as %2">;
-def err_omp_not_for : Error<
-  "%select{statement after '#pragma omp %1' must be a for loop|"
-  "expected %2 for loops after '#pragma omp %1'%select{|, but found only %4}3}0">;
-def note_omp_collapse_expr : Note<
-  "as specified in 'collapse' clause">;
-def err_omp_negative_expression_in_clause : Error<
-  "argument to '%0' clause must be a positive integer value">;
-def err_omp_not_integral : Error<
-  "expression must have integral or unscoped enumeration "
-  "type, not %0">;
-def err_omp_incomplete_type : Error<
-  "expression has incomplete class type %0">;
-def err_omp_explicit_conversion : Error<
-  "expression requires explicit conversion from %0 to %1">;
-def note_omp_conversion_here : Note<
-  "conversion to %select{integral|enumeration}0 type %1 declared here">;
-def err_omp_ambiguous_conversion : Error<
-  "ambiguous conversion from type %0 to an integral or unscoped "
-  "enumeration type">;
+  "arguments of OpenMP clause '%0' cannot be of reference type">;
+def err_omp_expected_int_or_ptr : Error<
+  "argument of a linear clause should be of integral or pointer type">;
+def err_omp_expected_array_or_ptr : Error<
+  "argument of an aligned clause should be array, pointer, reference to array or reference to pointer">;
 def err_omp_required_access : Error<
   "%0 variable must be %1">;
-def err_omp_const_variable : Error<
-  "const-qualified variable cannot be %0">;
-def err_omp_linear_incomplete_type : Error<
-  "a linear variable with incomplete type %0">;
-def err_omp_linear_expected_int_or_ptr : Error<
-  "argument of a linear clause should be of integral or pointer "
-  "type, not %0">;
-def warn_omp_linear_step_zero : Warning<
-  "zero linear step (%0 %select{|and other variables in clause }1should probably be const)">,
-  InGroup<OpenMPClauses>;
-def err_omp_aligned_expected_array_or_ptr : Error<
-  "argument of aligned clause should be array"
-  "%select{ or pointer|, pointer, reference to array or reference to pointer}1"
-  ", not %0">;
-def err_omp_aligned_twice : Error<
-  "a variable cannot appear in more than one aligned clause">;
-def err_omp_local_var_in_threadprivate_init : Error<
-  "variable with local storage in initial value of threadprivate variable">;
-def err_omp_loop_not_canonical_init : Error<
-  "initialization clause of OpenMP for loop must be of the form "
-  "'var = init' or 'T var = init'">;
-def ext_omp_loop_not_canonical_init : ExtWarn<
-  "initialization clause of OpenMP for loop is not in canonical form "
-  "('var = init' or 'T var = init')">, InGroup<OpenMPLoopForm>;
-def err_omp_loop_not_canonical_cond : Error<
-  "condition of OpenMP for loop must be a relational comparison "
-  "('<', '<=', '>', or '>=') of loop variable %0">;
-def err_omp_loop_not_canonical_incr : Error<
-  "increment clause of OpenMP for loop must perform simple addition "
-  "or subtraction on loop variable %0">;
-def err_omp_loop_variable_type : Error<
-  "variable must be of integer or %select{pointer|random access iterator}0 type">;
-def err_omp_loop_incr_not_compatible : Error<
-  "increment expression must cause %0 to %select{decrease|increase}1 "
-  "on each iteration of OpenMP for loop">;
-def note_omp_loop_cond_requres_compatible_incr : Note<
-  "loop step is expected to be %select{negative|positive}0 due to this condition">;
-def err_omp_loop_cannot_use_stmt : Error<
-  "'%0' statement cannot be used in OpenMP for loop">;
-def err_omp_simd_region_cannot_use_stmt : Error<
-  "'%0' statement cannot be used in OpenMP simd region">;
-def err_omp_unknown_reduction_identifier : Error<
-  "incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max'">;
-def err_omp_reduction_type_array : Error<
-  "a reduction variable with array type %0">;
-def err_omp_reduction_ref_type_arg : Error<
-  "argument of OpenMP clause 'reduction' must reference the same object in all threads">;
 def err_omp_clause_not_arithmetic_type_arg : Error<
-  "arguments of OpenMP clause 'reduction' for 'min' or 'max' must be of %select{scalar|arithmetic}0 type">;
+  "arguments of OpenMP clause '%0'%select{| for 'min' and 'max'}1 must be of %select{scalar|arithmetic}1 type">;
 def err_omp_clause_floating_type_arg : Error<
   "arguments of OpenMP clause 'reduction' with bitwise operators cannot be of floating type">;
+def err_omp_clause_array_type_arg : Error<
+  "arguments of OpenMP clause '%0' cannot be of array type">;
+def err_omp_reduction_ref_type_arg : Error<
+  "argument of OpenMP clause 'reduction' must reference the same object in all threads">;
+def err_omp_wrong_dsa : Error<
+  "%0 variable cannot be %1">;
+def err_omp_at_most_one_uniform_or_linear : Error<
+  "each argument may be in at most one uniform or linear clause">;
+def err_omp_at_most_one_aligned : Error<
+  "each argument may be in at most one aligned clause">;
+def err_omp_inbranch : Error<
+  "declare simd variant cannot be inbranch and notinbranch at the same time">;
+def err_omp_arg_not_found : Error<
+  "cannot find the function argument with the name requested in the openmp clause">;
+def err_omp_reduction_in_task : Error<
+  "reduction variables may not be accessed in an explicit task">;
 def err_omp_once_referenced : Error<
   "variable can appear only once in OpenMP '%0' clause">;
+def err_omp_once_referenced_in_target_update : Error<
+  "variable can appear only once in OpenMP 'target update' construct">;
+def err_omp_const_variable : Error<
+  "const-qualified variable cannot be %0">;
+def note_omp_explicit_dsa : Note<
+  "defined as %0">;
+def note_omp_predetermined_dsa : Note<
+  "predetermined as %0">;
 def note_omp_referenced : Note<
   "previously referenced here">;
-def err_omp_reduction_in_task : Error<
-  "reduction variables may not be accessed in an explicit task">;
-def err_omp_reduction_id_not_compatible : Error<
-  "variable of type %0 is not valid for specified reduction operation">;
-def err_omp_prohibited_region : Error<
-  "region cannot be%select{| closely}0 nested inside '%1' region"
-  "%select{|; perhaps you forget to enclose 'omp %3' directive into a parallel region?}2">;
-def err_omp_prohibited_region_simd : Error<
-  "OpenMP constructs may not be nested inside a simd region">;
-def err_omp_prohibited_region_critical_same_name : Error<
-  "cannot nest 'critical' regions having the same name %0">;
-def note_omp_previous_critical_region : Note<
-  "previous 'critical' region starts here">;
+def note_omp_specified : Note<
+  "previously specified here">;
+def err_omp_dsa_with_directives : Error<
+  "%0 variable in '#pragma omp %1' cannot be %2 in '#pragma omp %3'">;
+def err_omp_not_for : Error<
+  "only for-loops are allowed for '#pragma omp %0'">;
+def err_omp_for_variable : Error<
+  "variable must be of integer or %select{pointer|random access iterator}0 type">;
+def err_omp_not_canonical_for : Error<
+  "%select{initialization|condition|increment}0 of for-loop does not have canonical form">;
+def err_omp_for_incr_not_integer : Error<
+  "increment expression of for-loop must be of an integer type">;
+def err_omp_for_incr_not_compatible : Error<
+  "increment expression must cause %q0 to %select{decrease|increase}1 on each iteration of the loop">;
+def err_omp_for_type_not_compatible : Error<
+  "expression of type %0 is not compatible with variable %1 of type %2">;
+def err_omp_for_wrong_count : Error<
+  "unable to calculate number of iterations of the for-loop">;
+def err_omp_type_not_rai : Error<
+  "iteration variable is not of a random access iterator type">;
+def err_omp_for_loop_var_dsa : Error<
+  "loop iteration variable may not be %0">;
+def err_omp_sections_not_section : Error<
+  "the statement for '#pragma omp %0' must be '#pragma omp section'">;
+def err_omp_section_orphaned : Error<
+  "orphaned '#pragma omp section' is prohibited">;
 def err_omp_sections_not_compound_stmt : Error<
-  "the statement for '#pragma omp sections' must be a compound statement">;
-def err_omp_parallel_sections_not_compound_stmt : Error<
-  "the statement for '#pragma omp parallel sections' must be a compound statement">;
-def err_omp_orphaned_section_directive : Error<
-  "%select{orphaned 'omp section' directives are prohibited, it|'omp section' directive}0"
-  " must be closely nested to a sections region%select{|, not a %1 region}0">;
-def err_omp_sections_substmt_not_section : Error<
-  "statement in 'omp sections' directive must be enclosed into a section region">;
-def err_omp_parallel_sections_substmt_not_section : Error<
-  "statement in 'omp parallel sections' directive must be enclosed into a section region">;
-def err_omp_parallel_reduction_in_task_firstprivate : Error<
-  "argument of a reduction clause of a %0 construct must not appear in a firstprivate clause on a task construct">;
+  "the statement for '#pragma omp %0' must be compound statement">;
+def err_omp_prohibited_region : Error<
+  "region cannot be%select{| closely}0 nested inside %1 region%select{| with name %3}2">;
+def err_omp_prohibited_ordered_region : Error<
+  "region must be closely nested inside loop or parallel loop region with 'ordered' clause">;
+def err_omp_prohibited_cancel_region : Error<
+  "region must be nested inside a taskgroup region">;
+def err_omp_prohibited_cancel_region_nowait : Error<
+  "region cannot be nested inside region with 'nowait' clause">;
+def err_omp_prohibited_cancel_region_ordered : Error<
+  "region cannot be nested inside region with 'ordered' clause">;
+def err_omp_prohibited_distribute_region : Error<
+  "region must be closely nested inside a teams region">;
+def err_omp_prohibited_teams_region : Error<
+  "region must be closely nested inside a target region">;
+def err_omp_atomic_more_one_clause : Error<
+  "directive '#pragma omp atomic' cannot contain more than one 'read', 'write', 'update' or 'capture' clause">;
+def err_omp_atomic_not_expression : Error<
+  "expected expression statement for '#pragma omp atomic %0'">;
+def err_omp_atomic_wrong_statement : Error<
+  "statement form is not allowed for '#pragma omp atomic %0'">;
+def err_omp_no_dsa_for_variable : Error<
+  "variable %q0 must have explicitly specified data sharing attributes">;
+def err_omp_for_cannot_break: Error<
+  "cannot break from a '#pragma omp %0' loop">;
+def err_omp_for_cannot_have_eh: Error<
+  "exception handling is not allowed in a '#pragma omp %0' loop">;
+def err_capture_vm_type : Error<
+  "variable %q0 with variably modified type cannot be captured">;
+def err_omp_wrong_var_in_combiner : Error<
+  "variable %q0 is not allowed in combiner expression for '#pragma omp declare reduction', only 'omp_in' or 'omp_out' are allowed">;
+def err_omp_wrong_var_in_initializer : Error<
+  "variable %q0 is not allowed in initializer expression for '#pragma omp declare reduction', only 'omp_priv' or 'omp_orig' are allowed">;
+def err_omp_reduction_qualified_type : Error<
+  "a type name cannot be qualified with 'const', 'volatile' or 'restrict'">;
+def err_omp_reduction_function_type : Error<
+  "a type name cannot be a function type">;
+def err_omp_reduction_reference_type : Error<
+  "a type name cannot be a reference type">;
+def err_omp_reduction_array_type : Error<
+  "a type name cannot be an array type">;
+def err_omp_reduction_redeclared : Error<
+  "previous declaration with type %0 is found">;
+def err_omp_reduction_non_function_init : Error<
+  "expected function call">;
+def err_setjmp_longjmp_in_omp_simd : Error<
+  "The simd region cannot contain calls to the longjmp/setjmp functions">;
+def err_cean_not_in_statement : Error<
+  "extended array notation is not allowed">;
+def err_cean_lower_bound_not_integer : Error<
+  "lower bound expression has non-integer type %0">;
+def err_cean_length_not_integer : Error<
+  "length expression has non-integer type %0">;
+def err_cean_no_length_for_non_array : Error<
+  "cannot define default length for non-array type %0">;
+def err_omp_array_section_length_not_greater_zero : Error<
+  "length of the array section must be greater than 0">;
+def err_omp_expected_var_name_or_array_item : Error<
+  "expected variable name or an array item">;
+def err_omp_depend_arg_not_lvalue : Error<
+  "argument expression must be an l-value">;
+def err_omp_teams_not_single_in_target : Error<
+  "the teams construct must be the only construct inside of target region">;
+def err_omp_region_not_file_context : Error<
+  "directive must be at file or namespace scope">;
+def warn_omp_not_in_target_context : Warning<
+  "declaration is not declared in any declare target region">,
+  InGroup<SourceUsesOpenMP>, DefaultWarn;
+def err_omp_threadprivate_in_target : Error<
+  "threadprivate variables cannot be used in target constructs">;
+def err_omp_map_shared_storage : Error<
+  "variable already marked as mapped in current construct">;
+def err_omp_not_mappable_type : Error<
+  "type %0 is not mappable to target">;
+def note_omp_polymorphic_in_target : Note<
+  "mappable type cannot be polymorphic">;
+def note_omp_static_member_in_target : Note<
+  "mappable type cannot contain static members">;
 } // end of OpenMP category
 
 let CategoryName = "Related Result Type Issue" in {
@@ -7213,3 +7248,4 @@
 } // end of instrumentation issue category
 
 } // end of sema component.
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Basic/LangOptions.def cfe-3.5.0.src.omp/include/clang/Basic/LangOptions.def
--- cfe-3.5.0.src/include/clang/Basic/LangOptions.def	2014-07-15 23:13:50.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Basic/LangOptions.def	2014-11-28 10:49:29.000000000 -0500
@@ -128,6 +128,7 @@
 LANGOPT(NativeHalfType    , 1, 0, "Native half type support")
 LANGOPT(CUDA              , 1, 0, "CUDA")
 LANGOPT(OpenMP            , 1, 0, "OpenMP support")
+LANGOPT(OpenMPTargetMode  , 1, 0, "OpenMP codegen for target only")
 
 LANGOPT(AssumeSaneOperatorNew , 1, 1, "implicit __attribute__((malloc)) for C++'s new operators")
 LANGOPT(SizedDeallocation , 1, 0, "enable sized deallocation functions")
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Basic/LangOptions.h cfe-3.5.0.src.omp/include/clang/Basic/LangOptions.h
--- cfe-3.5.0.src/include/clang/Basic/LangOptions.h	2014-07-06 01:26:07.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Basic/LangOptions.h	2014-11-28 10:49:29.000000000 -0500
@@ -91,6 +91,16 @@
   /// \brief Options for parsing comments.
   CommentOptions CommentOpts;
   
+  /// \brief ID passed to the frontend that identifies the module.
+  /// The same ID must be passed for all targets for a given compilation
+  /// unit.
+  std::string OMPModuleUniqueID;
+
+  /// \brief Triples of the OpenMP targets that the host code
+  /// codegen should take into account in order to generate
+  /// accurate offloading translation tables
+  std::vector<llvm::Triple> OMPTargetTriples;
+
   LangOptions();
 
   // Define accessors/mutators for language options of enumeration type.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Basic/OpenMPKinds.def cfe-3.5.0.src.omp/include/clang/Basic/OpenMPKinds.def
--- cfe-3.5.0.src/include/clang/Basic/OpenMPKinds.def	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Basic/OpenMPKinds.def	2014-11-28 10:49:29.000000000 -0500
@@ -13,89 +13,222 @@
 //===----------------------------------------------------------------------===//
 
 #ifndef OPENMP_DIRECTIVE
-#  define OPENMP_DIRECTIVE(Name)
+#define OPENMP_DIRECTIVE(Name)
 #endif
 #ifndef OPENMP_DIRECTIVE_EXT
 #define OPENMP_DIRECTIVE_EXT(Name, Str)
 #endif
 #ifndef OPENMP_CLAUSE
-#  define OPENMP_CLAUSE(Name, Class)
+#define OPENMP_CLAUSE(Name, Class)
 #endif
 #ifndef OPENMP_PARALLEL_CLAUSE
-#  define OPENMP_PARALLEL_CLAUSE(Name)
+#define OPENMP_PARALLEL_CLAUSE(Name)
 #endif
-#ifndef OPENMP_SIMD_CLAUSE
-#  define OPENMP_SIMD_CLAUSE(Name)
+#ifndef OPENMP_TEAMS_CLAUSE
+#define OPENMP_TEAMS_CLAUSE(Name)
+#endif
+#ifndef OPENMP_DISTRIBUTE_CLAUSE
+#define OPENMP_DISTRIBUTE_CLAUSE(Name)
 #endif
 #ifndef OPENMP_FOR_CLAUSE
-#  define OPENMP_FOR_CLAUSE(Name)
+#define OPENMP_FOR_CLAUSE(Name)
 #endif
-#ifndef OPENMP_SECTIONS_CLAUSE
-#  define OPENMP_SECTIONS_CLAUSE(Name)
+#ifndef OPENMP_SIMD_CLAUSE
+#define OPENMP_SIMD_CLAUSE(Name)
 #endif
-#ifndef OPENMP_SINGLE_CLAUSE
-#  define OPENMP_SINGLE_CLAUSE(Name)
+#ifndef OPENMP_PARALLEL_FOR_SIMD_CLAUSE
+#define OPENMP_PARALLEL_FOR_SIMD_CLAUSE(Name)
+#endif
+#ifndef OPENMP_FOR_SIMD_CLAUSE
+#define OPENMP_FOR_SIMD_CLAUSE(Name)
+#endif
+#ifndef OPENMP_DISTRIBUTE_SIMD_CLAUSE
+#define OPENMP_DISTRIBUTE_SIMD_CLAUSE(Name)
+#endif
+#ifndef OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE
+#define OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(Name)
+#endif
+#ifndef OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE
+#define OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(Name)
+#endif
+#ifndef OPENMP_DECLARE_SIMD_CLAUSE
+#define OPENMP_DECLARE_SIMD_CLAUSE(Name)
 #endif
 #ifndef OPENMP_PARALLEL_FOR_CLAUSE
-#  define OPENMP_PARALLEL_FOR_CLAUSE(Name)
+#define OPENMP_PARALLEL_FOR_CLAUSE(Name)
+#endif
+#ifndef OPENMP_SECTIONS_CLAUSE
+#define OPENMP_SECTIONS_CLAUSE(Name)
 #endif
 #ifndef OPENMP_PARALLEL_SECTIONS_CLAUSE
-#  define OPENMP_PARALLEL_SECTIONS_CLAUSE(Name)
+#define OPENMP_PARALLEL_SECTIONS_CLAUSE(Name)
+#endif
+#ifndef OPENMP_SINGLE_CLAUSE
+#define OPENMP_SINGLE_CLAUSE(Name)
 #endif
 #ifndef OPENMP_TASK_CLAUSE
-#  define OPENMP_TASK_CLAUSE(Name)
+#define OPENMP_TASK_CLAUSE(Name)
+#endif
+#ifndef OPENMP_ATOMIC_CLAUSE
+#define OPENMP_ATOMIC_CLAUSE(Name)
+#endif
+#ifndef OPENMP_FLUSH_CLAUSE
+#define OPENMP_FLUSH_CLAUSE(Name)
+#endif
+#ifndef OPENMP_CANCEL_CLAUSE
+#define OPENMP_CANCEL_CLAUSE(Name)
+#endif
+#ifndef OPENMP_TARGET_CLAUSE
+#define OPENMP_TARGET_CLAUSE(Name)
+#endif
+#ifndef OPENMP_TARGET_DATA_CLAUSE
+#define OPENMP_TARGET_DATA_CLAUSE(Name)
+#endif
+#ifndef OPENMP_TARGET_UPDATE_CLAUSE
+#define OPENMP_TARGET_UPDATE_CLAUSE(Name)
+#endif
+#ifndef OPENMP_TARGET_TEAMS_CLAUSE
+#define OPENMP_TARGET_TEAMS_CLAUSE(Name)
 #endif
 #ifndef OPENMP_DEFAULT_KIND
-#  define OPENMP_DEFAULT_KIND(Name)
+#define OPENMP_DEFAULT_KIND(Name)
 #endif
 #ifndef OPENMP_PROC_BIND_KIND
-#  define OPENMP_PROC_BIND_KIND(Name)
+#define OPENMP_PROC_BIND_KIND(Name)
+#endif
+#ifndef OPENMP_REDUCTION_OPERATOR
+#define OPENMP_REDUCTION_OPERATOR(Name, Symbol)
+#endif
+#ifndef OPENMP_MAP_KIND
+#define OPENMP_MAP_KIND(Name, Kind)
+#endif
+#ifndef OPENMP_DEPENDENCE_TYPE
+#define OPENMP_DEPENDENCE_TYPE(Name, Type)
 #endif
 #ifndef OPENMP_SCHEDULE_KIND
 #define OPENMP_SCHEDULE_KIND(Name)
 #endif
+#ifndef OPENMP_DIST_SCHEDULE_KIND
+#define OPENMP_DIST_SCHEDULE_KIND(Name)
+#endif
+#ifndef OPENMP_TEAMS_DISTRIBUTE_CLAUSE
+#define OPENMP_TEAMS_DISTRIBUTE_CLAUSE(Name)
+#endif
+#ifndef OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE
+#define OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(Name)
+#endif
+#ifndef OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE
+#define OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(Name)
+#endif
+#ifndef OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE
+#define OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(Name)
+#endif
+#ifndef OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE
+#define OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(Name)
+#endif
+#ifndef OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE
+#define OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(Name)
+#endif
+#ifndef OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE
+#define OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(Name)
+#endif
+#ifndef OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE
+#define OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(Name)
+#endif
 
 // OpenMP directives.
 OPENMP_DIRECTIVE(threadprivate)
 OPENMP_DIRECTIVE(parallel)
 OPENMP_DIRECTIVE(task)
-OPENMP_DIRECTIVE(simd)
 OPENMP_DIRECTIVE(for)
+OPENMP_DIRECTIVE(simd)
 OPENMP_DIRECTIVE(sections)
 OPENMP_DIRECTIVE(section)
 OPENMP_DIRECTIVE(single)
+OPENMP_DIRECTIVE(taskyield)
 OPENMP_DIRECTIVE(master)
 OPENMP_DIRECTIVE(critical)
-OPENMP_DIRECTIVE(taskyield)
 OPENMP_DIRECTIVE(barrier)
 OPENMP_DIRECTIVE(taskwait)
+OPENMP_DIRECTIVE(taskgroup)
+OPENMP_DIRECTIVE(atomic)
 OPENMP_DIRECTIVE(flush)
+OPENMP_DIRECTIVE(ordered)
+OPENMP_DIRECTIVE(declare)
+OPENMP_DIRECTIVE(teams)
+OPENMP_DIRECTIVE(distribute)
+OPENMP_DIRECTIVE(cancel)
+OPENMP_DIRECTIVE(target)
+OPENMP_DIRECTIVE_EXT(target_data, "target data")
+OPENMP_DIRECTIVE_EXT(target_update, "target update")
 OPENMP_DIRECTIVE_EXT(parallel_for, "parallel for")
 OPENMP_DIRECTIVE_EXT(parallel_sections, "parallel sections")
+OPENMP_DIRECTIVE_EXT(declare_reduction, "declare reduction")
+OPENMP_DIRECTIVE_EXT(declare_simd, "declare simd")
+OPENMP_DIRECTIVE_EXT(declare_target, "declare target")
+OPENMP_DIRECTIVE_EXT(end_declare_target, "end declare target")
+OPENMP_DIRECTIVE_EXT(for_simd, "for simd")
+OPENMP_DIRECTIVE_EXT(cancellation_point, "cancellation point")
+OPENMP_DIRECTIVE_EXT(parallel_for_simd, "parallel for simd")
+OPENMP_DIRECTIVE_EXT(distribute_simd, "distribute simd")
+OPENMP_DIRECTIVE_EXT(distribute_parallel_for, "distribute parallel for")
+OPENMP_DIRECTIVE_EXT(distribute_parallel_for_simd,
+                     "distribute parallel for simd")
+OPENMP_DIRECTIVE_EXT(target_teams, "target teams")
+OPENMP_DIRECTIVE_EXT(teams_distribute, "teams distribute")
+OPENMP_DIRECTIVE_EXT(teams_distribute_simd, "teams distribute simd")
+OPENMP_DIRECTIVE_EXT(target_teams_distribute, "target teams distribute")
+OPENMP_DIRECTIVE_EXT(target_teams_distribute_simd,
+                     "target teams distribute simd")
+OPENMP_DIRECTIVE_EXT(teams_distribute_parallel_for,
+                     "teams distribute parallel for")
+OPENMP_DIRECTIVE_EXT(teams_distribute_parallel_for_simd,
+                     "teams distribute parallel for simd")
+OPENMP_DIRECTIVE_EXT(target_teams_distribute_parallel_for,
+                     "target teams distribute parallel for")
+OPENMP_DIRECTIVE_EXT(target_teams_distribute_parallel_for_simd,
+                     "target teams distribute parallel for simd")
 
 // OpenMP clauses.
 OPENMP_CLAUSE(if, OMPIfClause)
-OPENMP_CLAUSE(final, OMPFinalClause)
 OPENMP_CLAUSE(num_threads, OMPNumThreadsClause)
-OPENMP_CLAUSE(safelen, OMPSafelenClause)
-OPENMP_CLAUSE(collapse, OMPCollapseClause)
+OPENMP_CLAUSE(device, OMPDeviceClause)
+OPENMP_CLAUSE(final, OMPFinalClause)
 OPENMP_CLAUSE(default, OMPDefaultClause)
-OPENMP_CLAUSE(private, OMPPrivateClause)
-OPENMP_CLAUSE(firstprivate, OMPFirstprivateClause)
-OPENMP_CLAUSE(lastprivate, OMPLastprivateClause)
-OPENMP_CLAUSE(shared,  OMPSharedClause)
-OPENMP_CLAUSE(reduction,  OMPReductionClause)
-OPENMP_CLAUSE(linear,  OMPLinearClause)
-OPENMP_CLAUSE(aligned, OMPAlignedClause)
-OPENMP_CLAUSE(copyin,  OMPCopyinClause)
-OPENMP_CLAUSE(copyprivate,  OMPCopyprivateClause)
 OPENMP_CLAUSE(proc_bind, OMPProcBindClause)
+OPENMP_CLAUSE(private, OMPPrivateClause)
+OPENMP_CLAUSE(firstprivate, OMPFirstPrivateClause)
+OPENMP_CLAUSE(shared, OMPSharedClause)
+OPENMP_CLAUSE(copyin, OMPCopyinClause)
+OPENMP_CLAUSE(reduction, OMPReductionClause)
+OPENMP_CLAUSE(lastprivate, OMPLastPrivateClause)
+OPENMP_CLAUSE(copyprivate, OMPCopyPrivateClause)
+OPENMP_CLAUSE(map, OMPMapClause)
+OPENMP_CLAUSE(to, OMPToClause)
+OPENMP_CLAUSE(from, OMPFromClause)
 OPENMP_CLAUSE(schedule, OMPScheduleClause)
+OPENMP_CLAUSE(dist_schedule, OMPDistScheduleClause)
+OPENMP_CLAUSE(collapse, OMPCollapseClause)
 OPENMP_CLAUSE(ordered, OMPOrderedClause)
 OPENMP_CLAUSE(nowait, OMPNowaitClause)
 OPENMP_CLAUSE(untied, OMPUntiedClause)
 OPENMP_CLAUSE(mergeable, OMPMergeableClause)
+OPENMP_CLAUSE(read, OMPReadClause)
+OPENMP_CLAUSE(write, OMPWriteClause)
+OPENMP_CLAUSE(update, OMPUpdateClause)
+OPENMP_CLAUSE(capture, OMPCaptureClause)
+OPENMP_CLAUSE(seq_cst, OMPSeqCstClause)
 OPENMP_CLAUSE(flush, OMPFlushClause)
+OPENMP_CLAUSE(depend, OMPDependClause)
+OPENMP_CLAUSE(safelen, OMPSafelenClause)
+OPENMP_CLAUSE(linear, OMPLinearClause)
+OPENMP_CLAUSE(aligned, OMPAlignedClause)
+OPENMP_CLAUSE(simdlen, OMPSimdlenClause)
+OPENMP_CLAUSE(uniform, OMPUniformClause)
+OPENMP_CLAUSE(inbranch, OMPInBranchClause)
+OPENMP_CLAUSE(notinbranch, OMPNotInBranchClause)
+OPENMP_CLAUSE(num_teams, OMPNumTeamsClause)
+OPENMP_CLAUSE(thread_limit, OMPThreadLimitClause)
 
 // Clauses allowed for OpenMP directive 'parallel'.
 OPENMP_PARALLEL_CLAUSE(if)
@@ -105,56 +238,111 @@
 OPENMP_PARALLEL_CLAUSE(private)
 OPENMP_PARALLEL_CLAUSE(firstprivate)
 OPENMP_PARALLEL_CLAUSE(shared)
-OPENMP_PARALLEL_CLAUSE(reduction)
 OPENMP_PARALLEL_CLAUSE(copyin)
+OPENMP_PARALLEL_CLAUSE(reduction)
 
-// Clauses allowed for directive 'omp simd'.
-OPENMP_SIMD_CLAUSE(private)
-OPENMP_SIMD_CLAUSE(lastprivate)
-OPENMP_SIMD_CLAUSE(linear)
-OPENMP_SIMD_CLAUSE(aligned)
-OPENMP_SIMD_CLAUSE(safelen)
-OPENMP_SIMD_CLAUSE(collapse)
-OPENMP_SIMD_CLAUSE(reduction)
-
-// Clauses allowed for directive 'omp for'.
+// Clauses allowed for OpenMP directive 'for'.
 OPENMP_FOR_CLAUSE(private)
-OPENMP_FOR_CLAUSE(lastprivate)
 OPENMP_FOR_CLAUSE(firstprivate)
+OPENMP_FOR_CLAUSE(lastprivate)
 OPENMP_FOR_CLAUSE(reduction)
-OPENMP_FOR_CLAUSE(collapse)
 OPENMP_FOR_CLAUSE(schedule)
+OPENMP_FOR_CLAUSE(collapse)
 OPENMP_FOR_CLAUSE(ordered)
 OPENMP_FOR_CLAUSE(nowait)
 
-// Clauses allowed for OpenMP directive 'omp sections'.
-OPENMP_SECTIONS_CLAUSE(private)
-OPENMP_SECTIONS_CLAUSE(lastprivate)
-OPENMP_SECTIONS_CLAUSE(firstprivate)
-OPENMP_SECTIONS_CLAUSE(reduction)
-OPENMP_SECTIONS_CLAUSE(nowait)
-
-// Clauses allowed for directive 'omp single'.
-OPENMP_SINGLE_CLAUSE(private)
-OPENMP_SINGLE_CLAUSE(firstprivate)
-OPENMP_SINGLE_CLAUSE(copyprivate)
-OPENMP_SINGLE_CLAUSE(nowait)
-
-// Static attributes for 'default' clause.
-OPENMP_DEFAULT_KIND(none)
-OPENMP_DEFAULT_KIND(shared)
-
-// Static attributes for 'proc_bind' clause.
-OPENMP_PROC_BIND_KIND(master)
-OPENMP_PROC_BIND_KIND(close)
-OPENMP_PROC_BIND_KIND(spread)
+// Clauses allowed for OpenMP directive 'simd'.
+OPENMP_SIMD_CLAUSE(safelen)
+OPENMP_SIMD_CLAUSE(linear)
+OPENMP_SIMD_CLAUSE(aligned)
+OPENMP_SIMD_CLAUSE(private)
+OPENMP_SIMD_CLAUSE(lastprivate)
+OPENMP_SIMD_CLAUSE(reduction)
+OPENMP_SIMD_CLAUSE(collapse)
 
-// Static attributes for 'schedule' clause.
-OPENMP_SCHEDULE_KIND(static)
-OPENMP_SCHEDULE_KIND(dynamic)
-OPENMP_SCHEDULE_KIND(guided)
-OPENMP_SCHEDULE_KIND(auto)
-OPENMP_SCHEDULE_KIND(runtime)
+// Clauses allowed for OpenMP directive 'for simd'.
+OPENMP_FOR_SIMD_CLAUSE(private)
+OPENMP_FOR_SIMD_CLAUSE(firstprivate)
+OPENMP_FOR_SIMD_CLAUSE(lastprivate)
+OPENMP_FOR_SIMD_CLAUSE(reduction)
+OPENMP_FOR_SIMD_CLAUSE(schedule)
+OPENMP_FOR_SIMD_CLAUSE(collapse)
+OPENMP_FOR_SIMD_CLAUSE(nowait)
+OPENMP_FOR_SIMD_CLAUSE(safelen)
+OPENMP_FOR_SIMD_CLAUSE(linear)
+OPENMP_FOR_SIMD_CLAUSE(aligned)
+
+// Clauses allowed for OpenMP directive 'distribute simd'.
+OPENMP_DISTRIBUTE_SIMD_CLAUSE(private)
+OPENMP_DISTRIBUTE_SIMD_CLAUSE(lastprivate)
+OPENMP_DISTRIBUTE_SIMD_CLAUSE(firstprivate)
+OPENMP_DISTRIBUTE_SIMD_CLAUSE(reduction)
+OPENMP_DISTRIBUTE_SIMD_CLAUSE(collapse)
+OPENMP_DISTRIBUTE_SIMD_CLAUSE(safelen)
+OPENMP_DISTRIBUTE_SIMD_CLAUSE(linear)
+OPENMP_DISTRIBUTE_SIMD_CLAUSE(aligned)
+OPENMP_DISTRIBUTE_SIMD_CLAUSE(dist_schedule)
+
+// Clauses allowed for OpenMP directive 'distribute parallel for'.
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(if)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(num_threads)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(default)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(proc_bind)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(private)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(firstprivate)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(shared)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(copyin)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(reduction)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(lastprivate)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(schedule)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(collapse)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(ordered)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(dist_schedule)
+
+// Clauses allowed for OpenMP directive 'distribute parallel for simd'.
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(if)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(num_threads)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(default)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(proc_bind)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(private)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(firstprivate)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(shared)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(copyin)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(reduction)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(lastprivate)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(schedule)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(collapse)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(ordered)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(dist_schedule)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(safelen)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(linear)
+OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(aligned)
+
+// Clauses allowed for OpenMP directive 'parallel for simd'.
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(if)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(num_threads)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(default)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(proc_bind)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(shared)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(copyin)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(private)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(firstprivate)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(lastprivate)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(reduction)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(schedule)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(collapse)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(nowait)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(safelen)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(linear)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(aligned)
+
+// Clauses allowed for OpenMP directive 'declare simd'.
+OPENMP_DECLARE_SIMD_CLAUSE(simdlen)
+OPENMP_DECLARE_SIMD_CLAUSE(linear)
+OPENMP_DECLARE_SIMD_CLAUSE(aligned)
+OPENMP_DECLARE_SIMD_CLAUSE(uniform)
+OPENMP_DECLARE_SIMD_CLAUSE(inbranch)
+OPENMP_DECLARE_SIMD_CLAUSE(notinbranch)
 
 // Clauses allowed for OpenMP directive 'parallel for'.
 OPENMP_PARALLEL_FOR_CLAUSE(if)
@@ -164,13 +352,20 @@
 OPENMP_PARALLEL_FOR_CLAUSE(private)
 OPENMP_PARALLEL_FOR_CLAUSE(firstprivate)
 OPENMP_PARALLEL_FOR_CLAUSE(shared)
-OPENMP_PARALLEL_FOR_CLAUSE(reduction)
 OPENMP_PARALLEL_FOR_CLAUSE(copyin)
+OPENMP_PARALLEL_FOR_CLAUSE(reduction)
 OPENMP_PARALLEL_FOR_CLAUSE(lastprivate)
-OPENMP_PARALLEL_FOR_CLAUSE(collapse)
 OPENMP_PARALLEL_FOR_CLAUSE(schedule)
+OPENMP_PARALLEL_FOR_CLAUSE(collapse)
 OPENMP_PARALLEL_FOR_CLAUSE(ordered)
 
+// Clauses allowed for OpenMP directive 'sections'.
+OPENMP_SECTIONS_CLAUSE(private)
+OPENMP_SECTIONS_CLAUSE(firstprivate)
+OPENMP_SECTIONS_CLAUSE(lastprivate)
+OPENMP_SECTIONS_CLAUSE(reduction)
+OPENMP_SECTIONS_CLAUSE(nowait)
+
 // Clauses allowed for OpenMP directive 'parallel sections'.
 OPENMP_PARALLEL_SECTIONS_CLAUSE(if)
 OPENMP_PARALLEL_SECTIONS_CLAUSE(num_threads)
@@ -178,33 +373,306 @@
 OPENMP_PARALLEL_SECTIONS_CLAUSE(proc_bind)
 OPENMP_PARALLEL_SECTIONS_CLAUSE(private)
 OPENMP_PARALLEL_SECTIONS_CLAUSE(firstprivate)
+OPENMP_PARALLEL_SECTIONS_CLAUSE(lastprivate)
 OPENMP_PARALLEL_SECTIONS_CLAUSE(shared)
-OPENMP_PARALLEL_SECTIONS_CLAUSE(reduction)
 OPENMP_PARALLEL_SECTIONS_CLAUSE(copyin)
-OPENMP_PARALLEL_SECTIONS_CLAUSE(lastprivate)
+OPENMP_PARALLEL_SECTIONS_CLAUSE(reduction)
+
+// Clauses allowed for OpenMP directive 'single'.
+OPENMP_SINGLE_CLAUSE(private)
+OPENMP_SINGLE_CLAUSE(firstprivate)
+OPENMP_SINGLE_CLAUSE(copyprivate)
+OPENMP_SINGLE_CLAUSE(nowait)
 
 // Clauses allowed for OpenMP directive 'task'.
 OPENMP_TASK_CLAUSE(if)
 OPENMP_TASK_CLAUSE(final)
+OPENMP_TASK_CLAUSE(untied)
 OPENMP_TASK_CLAUSE(default)
+OPENMP_TASK_CLAUSE(mergeable)
 OPENMP_TASK_CLAUSE(private)
 OPENMP_TASK_CLAUSE(firstprivate)
 OPENMP_TASK_CLAUSE(shared)
-OPENMP_TASK_CLAUSE(untied)
-OPENMP_TASK_CLAUSE(mergeable)
+OPENMP_TASK_CLAUSE(depend)
 
-#undef OPENMP_SCHEDULE_KIND
-#undef OPENMP_PROC_BIND_KIND
+// Static attributes for 'default' clause.
+OPENMP_DEFAULT_KIND(none)
+OPENMP_DEFAULT_KIND(shared)
+
+// Static attributes for 'proc_bind' clause.
+OPENMP_PROC_BIND_KIND(master)
+OPENMP_PROC_BIND_KIND(close)
+OPENMP_PROC_BIND_KIND(spread)
+
+// Possible operators for 'reduction' clause.
+OPENMP_REDUCTION_OPERATOR(add, "+")
+OPENMP_REDUCTION_OPERATOR(mult, "*")
+OPENMP_REDUCTION_OPERATOR(sub, "-")
+OPENMP_REDUCTION_OPERATOR(bitand, "&")
+OPENMP_REDUCTION_OPERATOR(bitor, "|")
+OPENMP_REDUCTION_OPERATOR(bitxor, "^")
+OPENMP_REDUCTION_OPERATOR(and, "&&")
+OPENMP_REDUCTION_OPERATOR(or, "||")
+OPENMP_REDUCTION_OPERATOR(min, "min")
+OPENMP_REDUCTION_OPERATOR(max, "max")
+OPENMP_REDUCTION_OPERATOR(custom, "/*custom*/")
+
+// Possible dependence types for 'depend' clause.
+OPENMP_DEPENDENCE_TYPE(in, "in")
+OPENMP_DEPENDENCE_TYPE(out, "out")
+OPENMP_DEPENDENCE_TYPE(inout, "inout")
+
+// Static attributes for 'schedule' clause.
+OPENMP_SCHEDULE_KIND(static)
+OPENMP_SCHEDULE_KIND(dynamic)
+OPENMP_SCHEDULE_KIND(guided)
+OPENMP_SCHEDULE_KIND(auto)
+OPENMP_SCHEDULE_KIND(runtime)
+
+// Static attributes for 'dist_schedule' clause.
+OPENMP_DIST_SCHEDULE_KIND(static)
+
+// Clauses allowed for OpenMP directive 'atomic'.
+OPENMP_ATOMIC_CLAUSE(read)
+OPENMP_ATOMIC_CLAUSE(write)
+OPENMP_ATOMIC_CLAUSE(update)
+OPENMP_ATOMIC_CLAUSE(capture)
+OPENMP_ATOMIC_CLAUSE(seq_cst)
+
+// Clauses allowed for OpenMP directive 'flush'.
+OPENMP_FLUSH_CLAUSE(flush)
+
+// Clauses allowed for OpenMP directive 'teams'.
+OPENMP_TEAMS_CLAUSE(num_teams)
+OPENMP_TEAMS_CLAUSE(thread_limit)
+OPENMP_TEAMS_CLAUSE(default)
+OPENMP_TEAMS_CLAUSE(private)
+OPENMP_TEAMS_CLAUSE(firstprivate)
+OPENMP_TEAMS_CLAUSE(shared)
+OPENMP_TEAMS_CLAUSE(reduction)
+
+// Clauses allowed for OpenMP directive 'distribute'.
+OPENMP_DISTRIBUTE_CLAUSE(private)
+OPENMP_DISTRIBUTE_CLAUSE(firstprivate)
+OPENMP_DISTRIBUTE_CLAUSE(collapse)
+OPENMP_DISTRIBUTE_CLAUSE(dist_schedule)
+
+// Clauses allowed for OpenMP directive 'cancel'.
+OPENMP_CANCEL_CLAUSE(if)
+
+// Clauses allowed for OpenMP directive 'target'.
+OPENMP_TARGET_CLAUSE(if)
+OPENMP_TARGET_CLAUSE(device)
+OPENMP_TARGET_CLAUSE(map)
+
+// Clauses allowed for OpenMP directive 'target data'.
+OPENMP_TARGET_DATA_CLAUSE(if)
+OPENMP_TARGET_DATA_CLAUSE(device)
+OPENMP_TARGET_DATA_CLAUSE(map)
+
+// Clauses allowed for OpenMP directive 'target update'.
+OPENMP_TARGET_UPDATE_CLAUSE(if)
+OPENMP_TARGET_UPDATE_CLAUSE(device)
+OPENMP_TARGET_UPDATE_CLAUSE(to)
+OPENMP_TARGET_UPDATE_CLAUSE(from)
+
+// Possible mapping types for 'map' clause.
+OPENMP_MAP_KIND(alloc, "alloc")
+OPENMP_MAP_KIND(to, "to")
+OPENMP_MAP_KIND(from, "from")
+OPENMP_MAP_KIND(tofrom, "tofrom")
+
+// Clauses allowed for OpenMP directive 'target teams'.
+OPENMP_TARGET_TEAMS_CLAUSE(if)
+OPENMP_TARGET_TEAMS_CLAUSE(device)
+OPENMP_TARGET_TEAMS_CLAUSE(map)
+OPENMP_TARGET_TEAMS_CLAUSE(num_teams)
+OPENMP_TARGET_TEAMS_CLAUSE(thread_limit)
+OPENMP_TARGET_TEAMS_CLAUSE(default)
+OPENMP_TARGET_TEAMS_CLAUSE(private)
+OPENMP_TARGET_TEAMS_CLAUSE(firstprivate)
+OPENMP_TARGET_TEAMS_CLAUSE(shared)
+OPENMP_TARGET_TEAMS_CLAUSE(reduction)
+
+// Clauses allowed for OpenMP directive 'teams distribute'.
+OPENMP_TEAMS_DISTRIBUTE_CLAUSE(num_teams)
+OPENMP_TEAMS_DISTRIBUTE_CLAUSE(thread_limit)
+OPENMP_TEAMS_DISTRIBUTE_CLAUSE(default)
+OPENMP_TEAMS_DISTRIBUTE_CLAUSE(private)
+OPENMP_TEAMS_DISTRIBUTE_CLAUSE(firstprivate)
+OPENMP_TEAMS_DISTRIBUTE_CLAUSE(shared)
+OPENMP_TEAMS_DISTRIBUTE_CLAUSE(reduction)
+OPENMP_TEAMS_DISTRIBUTE_CLAUSE(collapse)
+OPENMP_TEAMS_DISTRIBUTE_CLAUSE(dist_schedule)
+
+// Clauses allowed for OpenMP directive 'teams distribute simd'.
+OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(num_teams)
+OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(thread_limit)
+OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(default)
+OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(private)
+OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(firstprivate)
+OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(shared)
+OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(reduction)
+OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(collapse)
+OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(dist_schedule)
+OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(safelen)
+OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(linear)
+OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(aligned)
+OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(lastprivate)
+
+// Clauses allowed for OpenMP directive 'target teams distribute'.
+OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(num_teams)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(thread_limit)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(default)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(private)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(firstprivate)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(shared)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(reduction)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(collapse)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(dist_schedule)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(if)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(device)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(map)
+
+// Clauses allowed for OpenMP directive 'target teams distribute simd'.
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(num_teams)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(thread_limit)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(default)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(private)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(firstprivate)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(shared)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(reduction)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(collapse)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(dist_schedule)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(safelen)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(linear)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(aligned)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(lastprivate)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(if)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(device)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(map)
+
+// Clauses allowed for OpenMP directive 'teams distribute parallel for'.
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(if)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(num_threads)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(default)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(proc_bind)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(private)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(firstprivate)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(shared)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(copyin)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(reduction)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(lastprivate)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(schedule)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(collapse)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(ordered)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(dist_schedule)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(num_teams)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(thread_limit)
+
+// Clauses allowed for OpenMP directive 'teams distribute parallel for simd'.
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(if)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(num_threads)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(default)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(proc_bind)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(private)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(firstprivate)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(shared)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(copyin)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(reduction)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(lastprivate)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(schedule)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(collapse)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(ordered)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(dist_schedule)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(safelen)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(linear)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(aligned)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(num_teams)
+OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(thread_limit)
+
+// Clauses allowed for OpenMP directive 'target teams distribute parallel for'.
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(if)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(num_threads)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(default)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(proc_bind)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(private)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(firstprivate)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(shared)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(copyin)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(reduction)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(lastprivate)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(schedule)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(collapse)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(ordered)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(dist_schedule)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(num_teams)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(thread_limit)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(device)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(map)
+
+// Clauses allowed for OpenMP directive 'target teams distribute parallel for
+// simd'.
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(if)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(num_threads)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(default)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(proc_bind)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(private)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(firstprivate)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(shared)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(copyin)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(reduction)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(lastprivate)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(schedule)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(collapse)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(ordered)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(dist_schedule)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(safelen)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(linear)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(aligned)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(num_teams)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(thread_limit)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(device)
+OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(map)
+
+#undef OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE
+#undef OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE
+#undef OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE
+#undef OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE
+#undef OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE
+#undef OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE
+#undef OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE
+#undef OPENMP_TEAMS_DISTRIBUTE_CLAUSE
+#undef OPENMP_TARGET_CLAUSE
+#undef OPENMP_TARGET_UPDATE_CLAUSE
+#undef OPENMP_TARGET_TEAMS_CLAUSE
+#undef OPENMP_TARGET_DATA_CLAUSE
+#undef OPENMP_REDUCTION_OPERATOR
+#undef OPENMP_MAP_KIND
+#undef OPENMP_DEPENDENCE_TYPE
 #undef OPENMP_DEFAULT_KIND
+#undef OPENMP_PROC_BIND_KIND
 #undef OPENMP_DIRECTIVE
 #undef OPENMP_DIRECTIVE_EXT
 #undef OPENMP_CLAUSE
-#undef OPENMP_SINGLE_CLAUSE
+#undef OPENMP_CANCEL_CLAUSE
+#undef OPENMP_ATOMIC_CLAUSE
+#undef OPENMP_FLUSH_CLAUSE
 #undef OPENMP_SECTIONS_CLAUSE
-#undef OPENMP_PARALLEL_CLAUSE
-#undef OPENMP_PARALLEL_FOR_CLAUSE
 #undef OPENMP_PARALLEL_SECTIONS_CLAUSE
+#undef OPENMP_SINGLE_CLAUSE
 #undef OPENMP_TASK_CLAUSE
-#undef OPENMP_SIMD_CLAUSE
+#undef OPENMP_PARALLEL_CLAUSE
+#undef OPENMP_TEAMS_CLAUSE
+#undef OPENMP_DISTRIBUTE_CLAUSE
+#undef OPENMP_PARALLEL_FOR_CLAUSE
+#undef OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE
+#undef OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE
 #undef OPENMP_FOR_CLAUSE
-
+#undef OPENMP_SIMD_CLAUSE
+#undef OPENMP_FOR_SIMD_CLAUSE
+#undef OPENMP_DISTRIBUTE_SIMD_CLAUSE
+#undef OPENMP_PARALLEL_FOR_SIMD_CLAUSE
+#undef OPENMP_DECLARE_SIMD_CLAUSE
+#undef OPENMP_SCHEDULE_KIND
+#undef OPENMP_DIST_SCHEDULE_KIND
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Basic/OpenMPKinds.h cfe-3.5.0.src.omp/include/clang/Basic/OpenMPKinds.h
--- cfe-3.5.0.src/include/clang/Basic/OpenMPKinds.h	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Basic/OpenMPKinds.h	2014-11-28 10:49:29.000000000 -0500
@@ -21,45 +21,86 @@
 
 /// \brief OpenMP directives.
 enum OpenMPDirectiveKind {
+  OMPD_unknown = 0,
 #define OPENMP_DIRECTIVE(Name) \
   OMPD_##Name,
 #define OPENMP_DIRECTIVE_EXT(Name, Str) \
   OMPD_##Name,
 #include "clang/Basic/OpenMPKinds.def"
-  OMPD_unknown
+  NUM_OPENMP_DIRECTIVES
 };
 
 /// \brief OpenMP clauses.
 enum OpenMPClauseKind {
+  OMPC_unknown = 0,
 #define OPENMP_CLAUSE(Name, Class) \
   OMPC_##Name,
 #include "clang/Basic/OpenMPKinds.def"
   OMPC_threadprivate,
-  OMPC_unknown
+  NUM_OPENMP_CLAUSES
 };
 
 /// \brief OpenMP attributes for 'default' clause.
 enum OpenMPDefaultClauseKind {
+  OMPC_DEFAULT_unknown = 0,
 #define OPENMP_DEFAULT_KIND(Name) \
   OMPC_DEFAULT_##Name,
 #include "clang/Basic/OpenMPKinds.def"
-  OMPC_DEFAULT_unknown
+  NUM_OPENMP_DEFAULT_KINDS
 };
 
 /// \brief OpenMP attributes for 'proc_bind' clause.
 enum OpenMPProcBindClauseKind {
+  OMPC_PROC_BIND_unknown = 0,
 #define OPENMP_PROC_BIND_KIND(Name) \
   OMPC_PROC_BIND_##Name,
 #include "clang/Basic/OpenMPKinds.def"
-  OMPC_PROC_BIND_unknown
+  NUM_OPENMP_PROC_BIND_KINDS
+};
+
+/// \brief OpenMP operators for 'reduction' clause.
+enum OpenMPReductionClauseOperator {
+  OMPC_REDUCTION_unknown = 0,
+#define OPENMP_REDUCTION_OPERATOR(Name, Symbol) \
+  OMPC_REDUCTION_##Name,
+#include "clang/Basic/OpenMPKinds.def"
+  NUM_OPENMP_REDUCTION_OPERATORS
+};
+
+/// \brief OpenMP dependence types for 'depend' clause.
+enum OpenMPDependClauseType {
+  OMPC_DEPEND_unknown = 0,
+#define OPENMP_DEPENDENCE_TYPE(Name, Type) \
+  OMPC_DEPEND_##Name,
+#include "clang/Basic/OpenMPKinds.def"
+  NUM_OPENMP_DEPENDENCE_TYPE
+};
+
+/// \brief OpenMP mapping kind for 'map' clause.
+enum OpenMPMapClauseKind {
+  OMPC_MAP_unknown = 0,
+#define OPENMP_MAP_KIND(Name, Kind) \
+  OMPC_MAP_##Name,
+#include "clang/Basic/OpenMPKinds.def"
+  NUM_OPENMP_MAP_KIND
 };
 
 /// \brief OpenMP attributes for 'schedule' clause.
 enum OpenMPScheduleClauseKind {
+  OMPC_SCHEDULE_unknown = 0,
 #define OPENMP_SCHEDULE_KIND(Name) \
   OMPC_SCHEDULE_##Name,
 #include "clang/Basic/OpenMPKinds.def"
-  OMPC_SCHEDULE_unknown
+  NUM_OPENMP_SCHEDULE_KINDS
+};
+
+/// \brief OpenMP attributes for 'dist_schedule' clause.
+enum OpenMPDistScheduleClauseKind {
+  OMPC_DIST_SCHEDULE_unknown = 0,
+#define OPENMP_DIST_SCHEDULE_KIND(Name) \
+  OMPC_DIST_SCHEDULE_##Name,
+#include "clang/Basic/OpenMPKinds.def"
+  NUM_OPENMP_DIST_SCHEDULE_KINDS
 };
 
 OpenMPDirectiveKind getOpenMPDirectiveKind(llvm::StringRef Str);
@@ -74,44 +115,6 @@
 bool isAllowedClauseForDirective(OpenMPDirectiveKind DKind,
                                  OpenMPClauseKind CKind);
 
-/// \brief Checks if the specified directive is a directive with an associated
-/// loop construct.
-/// \param DKind Specified directive.
-/// \return true - the directive is a loop-associated directive like 'omp simd'
-/// or 'omp for' directive, otherwise - false.
-bool isOpenMPLoopDirective(OpenMPDirectiveKind DKind);
-
-/// \brief Checks if the specified directive is a worksharing directive.
-/// \param DKind Specified directive.
-/// \return true - the directive is a worksharing directive like 'omp for',
-/// otherwise - false.
-bool isOpenMPWorksharingDirective(OpenMPDirectiveKind DKind);
-
-/// \brief Checks if the specified directive is a parallel-kind directive.
-/// \param DKind Specified directive.
-/// \return true - the directive is a parallel-like directive like 'omp
-/// parallel', otherwise - false.
-bool isOpenMPParallelDirective(OpenMPDirectiveKind DKind);
-
-/// \brief Checks if the specified directive is a simd directive.
-/// \param DKind Specified directive.
-/// \return true - the directive is a simd directive like 'omp simd',
-/// otherwise - false.
-bool isOpenMPSimdDirective(OpenMPDirectiveKind DKind);
-
-/// \brief Checks if the specified clause is one of private clauses like
-/// 'private', 'firstprivate', 'reduction' etc..
-/// \param Kind Clause kind.
-/// \return true - the clause is a private clause, otherwise - false.
-bool isOpenMPPrivate(OpenMPClauseKind Kind);
-
-/// \brief Checks if the specified clause is one of threadprivate clauses like
-/// 'threadprivate', 'copyin' or 'copyprivate'.
-/// \param Kind Clause kind.
-/// \return true - the clause is a threadprivate clause, otherwise - false.
-bool isOpenMPThreadPrivate(OpenMPClauseKind Kind);
-
 }
 
 #endif
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Basic/StmtNodes.td cfe-3.5.0.src.omp/include/clang/Basic/StmtNodes.td
--- cfe-3.5.0.src/include/clang/Basic/StmtNodes.td	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Basic/StmtNodes.td	2014-11-28 10:49:29.000000000 -0500
@@ -176,20 +176,48 @@
 // OpenCL Extensions.
 def AsTypeExpr : DStmt<Expr>;
 
+// Extended array notation index for OpenMP.
+def CEANIndexExpr : DStmt<Expr>;
+
 // OpenMP Directives.
 def OMPExecutableDirective : Stmt<1>;
 def OMPParallelDirective : DStmt<OMPExecutableDirective>;
-def OMPSimdDirective : DStmt<OMPExecutableDirective>;
+def OMPParallelForDirective : DStmt<OMPExecutableDirective>;
+def OMPParallelForSimdDirective : DStmt<OMPExecutableDirective>;
 def OMPForDirective : DStmt<OMPExecutableDirective>;
+def OMPSimdDirective : DStmt<OMPExecutableDirective>;
+def OMPForSimdDirective : DStmt<OMPExecutableDirective>;
+def OMPDistributeSimdDirective : DStmt<OMPExecutableDirective>;
+def OMPDistributeParallelForDirective : DStmt<OMPExecutableDirective>;
+def OMPDistributeParallelForSimdDirective : DStmt<OMPExecutableDirective>;
 def OMPSectionsDirective : DStmt<OMPExecutableDirective>;
+def OMPParallelSectionsDirective : DStmt<OMPExecutableDirective>;
 def OMPSectionDirective : DStmt<OMPExecutableDirective>;
 def OMPSingleDirective : DStmt<OMPExecutableDirective>;
-def OMPMasterDirective : DStmt<OMPExecutableDirective>;
-def OMPCriticalDirective : DStmt<OMPExecutableDirective>;
-def OMPParallelForDirective : DStmt<OMPExecutableDirective>;
-def OMPParallelSectionsDirective : DStmt<OMPExecutableDirective>;
 def OMPTaskDirective : DStmt<OMPExecutableDirective>;
 def OMPTaskyieldDirective : DStmt<OMPExecutableDirective>;
+def OMPMasterDirective : DStmt<OMPExecutableDirective>;
+def OMPCriticalDirective : DStmt<OMPExecutableDirective>;
 def OMPBarrierDirective : DStmt<OMPExecutableDirective>;
 def OMPTaskwaitDirective : DStmt<OMPExecutableDirective>;
+def OMPTaskgroupDirective : DStmt<OMPExecutableDirective>;
+def OMPAtomicDirective : DStmt<OMPExecutableDirective>;
 def OMPFlushDirective : DStmt<OMPExecutableDirective>;
+def OMPOrderedDirective : DStmt<OMPExecutableDirective>;
+def OMPTeamsDirective : DStmt<OMPExecutableDirective>;
+def OMPDistributeDirective : DStmt<OMPExecutableDirective>;
+def OMPCancelDirective : DStmt<OMPExecutableDirective>;
+def OMPCancellationPointDirective : DStmt<OMPExecutableDirective>;
+def OMPTargetDirective : DStmt<OMPExecutableDirective>;
+def OMPTargetDataDirective : DStmt<OMPExecutableDirective>;
+def OMPTargetUpdateDirective : DStmt<OMPExecutableDirective>;
+def OMPTargetTeamsDirective : DStmt<OMPExecutableDirective>;
+def OMPTeamsDistributeDirective : DStmt<OMPExecutableDirective>;
+def OMPTeamsDistributeSimdDirective : DStmt<OMPExecutableDirective>;
+def OMPTargetTeamsDistributeDirective : DStmt<OMPExecutableDirective>;
+def OMPTargetTeamsDistributeSimdDirective : DStmt<OMPExecutableDirective>;
+def OMPTeamsDistributeParallelForDirective : DStmt<OMPExecutableDirective>;
+def OMPTeamsDistributeParallelForSimdDirective : DStmt<OMPExecutableDirective>;
+def OMPTargetTeamsDistributeParallelForDirective : DStmt<OMPExecutableDirective>;
+def OMPTargetTeamsDistributeParallelForSimdDirective : DStmt<OMPExecutableDirective>;
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Driver/Action.h cfe-3.5.0.src.omp/include/clang/Driver/Action.h
--- cfe-3.5.0.src/include/clang/Driver/Action.h	2014-03-14 02:02:07.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Driver/Action.h	2014-11-28 10:49:29.000000000 -0500
@@ -41,6 +41,7 @@
   enum ActionClass {
     InputClass = 0,
     BindArchClass,
+    BindTargetClass,
     PreprocessJobClass,
     PrecompileJobClass,
     AnalyzeJobClass,
@@ -69,21 +70,27 @@
 
   unsigned OwnsInputs : 1;
 
+  /// Is this action referring to the main host or an OpenMP offloading device
+  const char* OffloadingDevice;
+
 protected:
   Action(ActionClass _Kind, types::ID _Type)
-    : Kind(_Kind), Type(_Type), OwnsInputs(true)  {}
+    : Kind(_Kind), Type(_Type), OwnsInputs(true), OffloadingDevice(0)  {}
   Action(ActionClass _Kind, Action *Input, types::ID _Type)
-    : Kind(_Kind), Type(_Type), Inputs(&Input, &Input + 1), OwnsInputs(true) {}
+    : Kind(_Kind), Type(_Type), Inputs(&Input, &Input + 1), OwnsInputs(true), OffloadingDevice(0) {}
   Action(ActionClass _Kind, const ActionList &_Inputs, types::ID _Type)
-    : Kind(_Kind), Type(_Type), Inputs(_Inputs), OwnsInputs(true) {}
+    : Kind(_Kind), Type(_Type), Inputs(_Inputs), OwnsInputs(true), OffloadingDevice(0) {}
 public:
   virtual ~Action();
 
   const char *getClassName() const { return Action::getClassName(getKind()); }
 
-  bool getOwnsInputs() { return OwnsInputs; }
+  bool getOwnsInputs() const { return OwnsInputs; }
   void setOwnsInputs(bool Value) { OwnsInputs = Value; }
 
+  const char *getOffloadingDevice() const { return OffloadingDevice; }
+  void setOffloadingDevice(const char *Value) { OffloadingDevice = Value; }
+
   ActionClass getKind() const { return Kind; }
   types::ID getType() const { return Type; }
 
@@ -128,6 +135,22 @@
   }
 };
 
+class BindTargetAction : public Action {
+  virtual void anchor();
+  /// The architecture to bind, or 0 if the default architecture
+  /// should be bound.
+  const char *TargetName;
+
+public:
+  BindTargetAction(Action *Input, const char *_TargetName);
+
+  const char *getTargetName() const { return TargetName; }
+
+  static bool classof(const Action *A) {
+    return A->getKind() == BindTargetClass;
+  }
+};
+
 class JobAction : public Action {
   virtual void anchor();
 protected:
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Driver/CC1Options.td cfe-3.5.0.src.omp/include/clang/Driver/CC1Options.td
--- cfe-3.5.0.src/include/clang/Driver/CC1Options.td	2014-07-09 10:05:11.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Driver/CC1Options.td	2014-11-28 10:49:29.000000000 -0500
@@ -577,8 +577,15 @@
 def fcuda_is_device : Flag<["-"], "fcuda-is-device">,
   HelpText<"Generate code for CUDA device">;
 
-} // let Flags = [CC1Option]
+//===----------------------------------------------------------------------===//
+// OpenMP Options
+//===----------------------------------------------------------------------===//
 
+def omp_target_mode : Flag<["-"], "omp-target-mode">,
+  HelpText<"Generate code for an OpenMP target">;
+def omp_main_file_path : Separate<["-"], "omp-main-file-path">,
+  HelpText<"Path to the original source file that requires OpenMP code generation">;
+} // let Flags = [CC1Option]
 
 //===----------------------------------------------------------------------===//
 // cc1as-only Options
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Driver/Compilation.h cfe-3.5.0.src.omp/include/clang/Driver/Compilation.h
--- cfe-3.5.0.src/include/clang/Driver/Compilation.h	2014-06-20 18:16:00.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Driver/Compilation.h	2014-11-28 10:49:29.000000000 -0500
@@ -53,7 +53,8 @@
 
   /// Cache of translated arguments for a particular tool chain and bound
   /// architecture.
-  llvm::DenseMap<std::pair<const ToolChain *, const char *>,
+  typedef std::pair<const ToolChain*,int> ToolChainWithTargetInfo;
+  llvm::DenseMap<std::pair<ToolChainWithTargetInfo, const char*>,
                  llvm::opt::DerivedArgList *> TCArgs;
 
   /// Temporary files which should be removed on exit.
@@ -111,8 +112,12 @@
   /// tool chain \p TC (or the default tool chain, if TC is not specified).
   ///
   /// \param BoundArch - The bound architecture name, or 0.
+  /// \param isOpenMPTarget - True if this tool chain refer to an OpenMP target
+  /// \param isSuccess - set to true if the arguments were successfully obtained
   const llvm::opt::DerivedArgList &getArgsForToolChain(const ToolChain *TC,
-                                                       const char *BoundArch);
+                                                       const char *BoundArch,
+                                                       bool isOpenMPTarget,
+                                                       bool &isSuccess);
 
   /// addTempFile - Add a file to remove on exit, and returns its
   /// argument.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Driver/Driver.h cfe-3.5.0.src.omp/include/clang/Driver/Driver.h
--- cfe-3.5.0.src/include/clang/Driver/Driver.h	2014-05-15 18:26:36.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Driver/Driver.h	2014-11-28 10:49:29.000000000 -0500
@@ -178,6 +178,18 @@
   /// created targeting that triple. The driver owns all the ToolChain objects
   /// stored in it, and will clean them up when torn down.
   mutable llvm::StringMap<ToolChain *> ToolChains;
+  mutable llvm::StringMap<ToolChain *> OpenMPTargetToolChains;
+
+  /// Type of the map used to trace the result information for a given action.
+  /// This is useful to avoid recomputing the action results and allow the same
+  /// result to be used by different actions, as required by OpenMP offloading.
+  /// This has to take into account that the same action may produce different
+  /// results for different toolchains.
+  typedef llvm::SmallDenseMap<const ToolChain*, InputInfo*>
+                                                       ResultInfoMapPerActionTy;
+  typedef llvm::SmallDenseMap<const Action*, ResultInfoMapPerActionTy>
+                                                                ResultInfoMapTy;
+  mutable ResultInfoMapTy ResultInfoMap;
 
 private:
   /// TranslateInputArgs - Create a new derived argument list from the input
@@ -190,6 +202,18 @@
   phases::ID getFinalPhase(const llvm::opt::DerivedArgList &DAL,
                            llvm::opt::Arg **FinalPhaseArg = nullptr) const;
 
+  // registerResultInfo - Register the result information obtained for a given
+  // action in a given toolchain.
+  void registerResultInfo(const ToolChain *TC, const Action *A, InputInfo Res)
+                                                                          const;
+  // getResultInfo - Returns the results obtained for an action in a compatible
+  // toolchain. Offloading implementation can use results from other toolchains,
+  // thus this procedure does the proper checks for compatibility.
+  InputInfo *getResultInfo(const ToolChain *TC, const Action *A) const;
+
+  // clearResultInfo - Clear the contents of the result info map.
+  void clearResultInfo() const;
+
 public:
   Driver(StringRef _ClangExecutable,
          StringRef _DefaultTargetTriple,
@@ -391,9 +415,10 @@
   /// \brief Retrieves a ToolChain for a particular target triple.
   ///
   /// Will cache ToolChains for the life of the driver object, and create them
-  /// on-demand.
+  /// on-demand. If TripleString is provided, the triple is obtained exclusively from it
   const ToolChain &getToolChain(const llvm::opt::ArgList &Args,
-                                StringRef DarwinArchName = "") const;
+                                StringRef DarwinArchName = "",
+                                const char *OpenMPTripleString = nullptr) const;
 
   /// @}
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Driver/Options.td cfe-3.5.0.src.omp/include/clang/Driver/Options.td
--- cfe-3.5.0.src/include/clang/Driver/Options.td	2014-08-07 00:51:51.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Driver/Options.td	2014-11-28 10:49:29.000000000 -0500
@@ -1306,6 +1306,7 @@
 def object : Flag<["-"], "object">;
 def o : JoinedOrSeparate<["-"], "o">, Flags<[DriverOption, RenderAsInput, CC1Option, CC1AsOption]>,
   HelpText<"Write output to <file>">, MetaVarName<"<file>">;
+def omptargets_EQ : CommaJoined<["-"], "omptargets=">, Flags<[DriverOption, CC1Option]>;
 def pagezero__size : JoinedOrSeparate<["-"], "pagezero_size">;
 def pass_exit_codes : Flag<["-", "--"], "pass-exit-codes">, Flags<[Unsupported]>;
 def pedantic_errors : Flag<["-", "--"], "pedantic-errors">, Group<pedantic_Group>, Flags<[CC1Option]>;
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Driver/ToolChain.h cfe-3.5.0.src.omp/include/clang/Driver/ToolChain.h
--- cfe-3.5.0.src/include/clang/Driver/ToolChain.h	2014-07-29 19:48:32.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Driver/ToolChain.h	2014-11-28 10:49:29.000000000 -0500
@@ -12,6 +12,8 @@
 
 #include "clang/Driver/Action.h"
 #include "clang/Driver/Multilib.h"
+#include "clang/Driver/DriverDiagnostic.h"
+#include "clang/Driver/Driver.h"
 #include "clang/Driver/Types.h"
 #include "clang/Driver/Util.h"
 #include "llvm/ADT/SmallVector.h"
@@ -76,11 +78,16 @@
 
   mutable std::unique_ptr<SanitizerArgs> SanitizerArguments;
 
+  /// This is set to true when the toolchain is created if it refers to an
+  /// OpenMP target toolchain
+  bool IsOpenMPTargetToolchain;
+
 protected:
   MultilibSet Multilibs;
 
   ToolChain(const Driver &D, const llvm::Triple &T,
-            const llvm::opt::ArgList &Args);
+            const llvm::opt::ArgList &Args,
+            bool IsOpenMPTargetToolchain = false);
 
   virtual Tool *buildAssembler() const;
   virtual Tool *buildLinker() const;
@@ -110,6 +117,7 @@
 
   const Driver &getDriver() const;
   const llvm::Triple &getTriple() const { return Triple; }
+  bool isOpenMPTargetToolchain() const { return IsOpenMPTargetToolchain; }
 
   llvm::Triple::ArchType getArch() const { return Triple.getArch(); }
   StringRef getArchName() const { return Triple.getArchName(); }
@@ -141,9 +149,25 @@
   /// specific translations are needed.
   ///
   /// \param BoundArch - The bound architecture name, or 0.
+  /// \param isOpenMPTarget - True if this toolchain is an OpenMP target.
+  /// \param isSuccess - set to True if the arguments were successfully
+  /// translated.
   virtual llvm::opt::DerivedArgList *
   TranslateArgs(const llvm::opt::DerivedArgList &Args,
-                const char *BoundArch) const {
+                const char *BoundArch,
+                bool isOpenMPTarget,
+                bool &isSuccess) const {
+
+    if (isOpenMPTarget){
+      isSuccess = false;
+
+      D.Diag(diag::err_drv_omp_target_translation_not_available)
+          << BoundArch;
+
+      return nullptr;
+    }
+
+    isSuccess = true;
     return nullptr;
   }
 
@@ -323,6 +347,7 @@
   virtual bool
   AddFastMathRuntimeIfAvailable(const llvm::opt::ArgList &Args,
                                 llvm::opt::ArgStringList &CmdArgs) const;
+
 };
 
 } // end namespace driver
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Driver/Types.def cfe-3.5.0.src.omp/include/clang/Driver/Types.def
--- cfe-3.5.0.src/include/clang/Driver/Types.def	2014-05-06 02:48:52.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Driver/Types.def	2014-11-28 10:49:29.000000000 -0500
@@ -87,6 +87,7 @@
 TYPE("remap",                    Remap,        INVALID,         "remap", "")
 TYPE("precompiled-header",       PCH,          INVALID,         "gch",   "A")
 TYPE("object",                   Object,       INVALID,         "o",     "")
+TYPE("shared-object",            SObject,      INVALID,         "so",    "")
 TYPE("treelang",                 Treelang,     INVALID,         nullptr, "u")
 TYPE("image",                    Image,        INVALID,         "out",   "")
 TYPE("dSYM",                     dSYM,         INVALID,         "dSYM",  "A")
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Parse/Parser.h cfe-3.5.0.src.omp/include/clang/Parse/Parser.h
--- cfe-3.5.0.src/include/clang/Parse/Parser.h	2014-07-21 20:53:05.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Parse/Parser.h	2014-11-28 10:49:29.000000000 -0500
@@ -58,6 +58,7 @@
   friend class ObjCDeclContextSwitch;
   friend class ParenBraceBracketBalancer;
   friend class BalancedDelimiterTracker;
+  friend class AllowCEANExpressions;
 
   Preprocessor &PP;
 
@@ -233,6 +234,8 @@
 
   bool SkipFunctionBodies;
 
+  bool IsCEANAllowed;
+
 public:
   Parser(Preprocessor &PP, Sema &Actions, bool SkipFunctionBodies);
   ~Parser();
@@ -1015,6 +1018,21 @@
     CachedTokens *ExceptionSpecTokens;
   };
 
+  /// LateParsedOpenMPDeclaration - An OpenMP declaration inside a class.
+  struct LateParsedOpenMPDeclaration : public LateParsedDeclaration {
+    explicit LateParsedOpenMPDeclaration(Parser *P, AccessSpecifier AS)
+      : Self(P), AS(AS) { }
+
+    virtual void ParseLexedMethodDeclarations();
+
+    Parser* Self;
+    AccessSpecifier AS;
+
+    /// \brief The set of tokens that make up an exception-specification that
+    /// has not yet been parsed.
+    CachedTokens Tokens;
+  };
+
   /// LateParsedMemberInitializer - An initializer for a non-static class data
   /// member whose parsing must to be delayed until the class is completely
   /// defined (C++11 [class.mem]p2).
@@ -2327,8 +2345,13 @@
 
   //===--------------------------------------------------------------------===//
   // OpenMP: Directives and clauses.
+  /// \brief Parses OpenMP directive.
+  OpenMPDirectiveKind ParseOpenMPDirective();
   /// \brief Parses declarative OpenMP directives.
-  DeclGroupPtrTy ParseOpenMPDeclarativeDirective();
+  DeclGroupPtrTy ParseOpenMPDeclarativeDirective(AccessSpecifier AS);
+  /// \brief Late parsing of declarative OpenMP directives.
+  void LateParseOpenMPDeclarativeDirective(AccessSpecifier AS);
+
   /// \brief Parses simple list of variables.
   ///
   /// \param Kind Kind of the directive.
@@ -2339,13 +2362,22 @@
   bool ParseOpenMPSimpleVarList(OpenMPDirectiveKind Kind,
                                 SmallVectorImpl<Expr *> &VarList,
                                 bool AllowScopeSpecifier);
+  /// \param [out] Inits List of inits.
+  ///
+  Decl *ParseOpenMPDeclareReduction(SmallVectorImpl<QualType> &Types,
+                                    SmallVectorImpl<SourceRange> &TyRanges,
+                                    SmallVectorImpl<Expr *> &Combiners,
+                                    SmallVectorImpl<Expr *> &Inits,
+                                    AccessSpecifier AS);
+
   /// \brief Parses declarative or executable directive.
   ///
   /// \param StandAloneAllowed true if allowed stand-alone directives,
   /// false - otherwise
   ///
-  StmtResult
-  ParseOpenMPDeclarativeOrExecutableDirective(bool StandAloneAllowed);
+  StmtResult ParseOpenMPDeclarativeOrExecutableDirective(
+                                                bool StandAloneAllowed);
+
   /// \brief Parses clause of kind \a CKind for directive of a kind \a Kind.
   ///
   /// \param DKind Kind of current directive.
@@ -2354,7 +2386,8 @@
   /// in current directive.
   ///
   OMPClause *ParseOpenMPClause(OpenMPDirectiveKind DKind,
-                               OpenMPClauseKind CKind, bool FirstClause);
+                               OpenMPClauseKind CKind,
+                               bool FirstClause);
   /// \brief Parses clause with a single expression of a kind \a Kind.
   ///
   /// \param Kind Kind of current clause.
@@ -2381,6 +2414,40 @@
   /// \param Kind Kind of current clause.
   ///
   OMPClause *ParseOpenMPVarListClause(OpenMPClauseKind Kind);
+  typedef SmallVector<DeclarationNameInfo, 4> DeclarationNameInfoList;
+  /// \brief The following is temporary info about a clause used later to
+  /// build it (after we have access to the function's arguments scope).
+  struct OmpDeclareSimdVariantInfo {
+    unsigned Idx;             // index in the CL (array of clauses)
+    OpenMPClauseKind CKind;   // clause kind
+    DeclarationNameInfoList NameInfos;
+    SourceLocation StartLoc;
+    SourceLocation EndLoc;
+    Expr *TailExpr;
+    SourceLocation TailLoc;
+    OmpDeclareSimdVariantInfo(OpenMPClauseKind CK, unsigned I)
+      :Idx(I), CKind(CK), TailExpr(0) { }
+  };
+  /// \brief Parses clause with the list of variables of a kind \a Kind in
+  ///        a declarative Varlist-parsing mode for the case when the vars
+  ///        are not declared yet (e.g. arguments in 'declare simd').
+  /// \param CKind Kind of current clause (for now, only OMPD_declare_simd).
+  /// \param pam pam.
+  ///
+  bool ParseOpenMPDeclarativeVarListClause(
+      OpenMPDirectiveKind DKind,
+      OpenMPClauseKind CKind,
+      DeclarationNameInfoList &NameInfos,
+      SourceLocation &StartLoc,
+      SourceLocation &EndLoc,
+      Expr *&TailExpr,
+      SourceLocation &TailLoc);
+  /// \brief Parses clause with a single expression and a type of a kind
+  /// \a Kind.
+  ///
+  /// \param Kind Kind of current clause.
+  ///
+  OMPClause *ParseOpenMPSingleExprWithTypeClause(OpenMPClauseKind Kind);
 public:
   bool ParseUnqualifiedId(CXXScopeSpec &SS, bool EnteringContext,
                           bool AllowDestructorName,
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Sema/Scope.h cfe-3.5.0.src.omp/include/clang/Sema/Scope.h
--- cfe-3.5.0.src/include/clang/Sema/Scope.h	2014-07-18 20:45:07.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Sema/Scope.h	2014-11-28 10:49:29.000000000 -0500
@@ -388,33 +388,13 @@
 
   /// \brief Determines whether this scope is the OpenMP directive scope
   bool isOpenMPDirectiveScope() const {
-    return (getFlags() & Scope::OpenMPDirectiveScope);
-  }
-
-  /// \brief Determine whether this scope is some OpenMP loop directive scope
-  /// (for example, 'omp for', 'omp simd').
-  bool isOpenMPLoopDirectiveScope() const {
-    if (getFlags() & Scope::OpenMPLoopDirectiveScope) {
-      assert(isOpenMPDirectiveScope() &&
-             "OpenMP loop directive scope is not a directive scope");
-      return true;
+    for (const Scope *S = this; S; S = S->getParent()) {
+      if (S->getFlags() & Scope::OpenMPDirectiveScope)
+        return true;
     }
     return false;
   }
-
-  /// \brief Determine whether this scope is (or is nested into) some OpenMP
-  /// loop simd directive scope (for example, 'omp simd', 'omp for simd').
-  bool isOpenMPSimdDirectiveScope() const {
-    return getFlags() & Scope::OpenMPSimdDirectiveScope;
-  }
-
-  /// \brief Determine whether this scope is a loop having OpenMP loop
-  /// directive attached.
-  bool isOpenMPLoopScope() const {
-    const Scope *P = getParent();
-    return P && P->isOpenMPLoopDirectiveScope();
-  }
-
+  
   /// \brief Determine whether this scope is a C++ 'try' block.
   bool isTryScope() const { return getFlags() & Scope::TryScope; }
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Sema/ScopeInfo.h cfe-3.5.0.src.omp/include/clang/Sema/ScopeInfo.h
--- cfe-3.5.0.src/include/clang/Sema/ScopeInfo.h	2014-05-06 02:48:52.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Sema/ScopeInfo.h	2014-11-28 10:49:29.000000000 -0500
@@ -571,6 +571,8 @@
   /// \brief A descriptive name for the kind of captured region this is.
   StringRef getRegionName() const {
     switch (CapRegionKind) {
+    case CR_SIMDFor:
+      return "simd for - like captured statement";
     case CR_Default:
       return "default captured statement";
     case CR_OpenMP:
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Sema/Sema.h cfe-3.5.0.src.omp/include/clang/Sema/Sema.h
--- cfe-3.5.0.src/include/clang/Sema/Sema.h	2014-07-21 22:01:04.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Sema/Sema.h	2014-11-28 10:49:29.000000000 -0500
@@ -145,6 +145,9 @@
   class ObjCProtocolDecl;
   class OMPThreadPrivateDecl;
   class OMPClause;
+  class OMPDeclareReductionDecl;
+  class OMPDeclareSimdDecl;
+  class OMPDeclareTargetDecl;
   class OverloadCandidateSet;
   class OverloadExpr;
   class ParenListExpr;
@@ -1053,12 +1056,9 @@
   void RecordParsingTemplateParameterDepth(unsigned Depth);
   
   void PushCapturedRegionScope(Scope *RegionScope, CapturedDecl *CD,
-                               RecordDecl *RD,
-                               CapturedRegionKind K);
-  void
-  PopFunctionScopeInfo(const sema::AnalysisBasedWarnings::Policy *WP = nullptr,
-                       const Decl *D = nullptr,
-                       const BlockExpr *blkExpr = nullptr);
+                               RecordDecl *RD, CapturedRegionKind K);
+  void PopFunctionScopeInfo(const sema::AnalysisBasedWarnings::Policy *WP =0,
+                            const Decl *D = 0, const BlockExpr *blkExpr = 0);
 
   sema::FunctionScopeInfo *getCurFunction() const {
     return FunctionScopes.back();
@@ -2519,6 +2519,8 @@
     LookupObjCProtocolName,
     /// Look up implicit 'self' parameter of an objective-c method.
     LookupObjCImplicitSelfParam,
+    // Look up OpenMP declare reduction constructs only.
+    LookupOMPDeclareReduction,
     /// \brief Look up any declaration with any name.
     LookupAnyName
   };
@@ -3443,7 +3445,7 @@
                       TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr);
 
   ExprResult BuildPredefinedExpr(SourceLocation Loc,
-                                 PredefinedExpr::IdentType IT);
+                                 PredefinedExpr::IdentType Kind);
   ExprResult ActOnPredefinedExpr(SourceLocation Loc, tok::TokenKind Kind);
   ExprResult ActOnIntegerConstant(SourceLocation Loc, uint64_t Val);
   ExprResult ActOnNumericConstant(const Token &Tok, Scope *UDLScope = nullptr);
@@ -3513,6 +3515,8 @@
                                      Expr *Idx, SourceLocation RLoc);
   ExprResult CreateBuiltinArraySubscriptExpr(Expr *Base, SourceLocation LLoc,
                                              Expr *Idx, SourceLocation RLoc);
+  ExprResult ActOnCEANIndexExpr(Scope *S, Expr *Base, Expr *LowerBound,
+                                SourceLocation ColonLoc, Expr *Length);
 
   // This struct is for use by ActOnMemberAccess to allow
   // BuildMemberReferenceExpr to be able to reinvoke ActOnMemberAccess after
@@ -6557,6 +6561,11 @@
   /// types, static variables, enumerators, etc.
   std::deque<PendingImplicitInstantiation> PendingLocalImplicitInstantiations;
 
+  /// \brief We store OpenMP declarative pragmas that will need to be
+  /// instantiated together with the templated functions.
+  typedef llvm::DenseMap<Decl *, OMPDeclareSimdDecl *> PendingOMPInstMap;
+  PendingOMPInstMap PendingOMP;
+
   class SavePendingLocalImplicitInstantiationsRAII {
   public:
     SavePendingLocalImplicitInstantiationsRAII(Sema &S): S(S) {
@@ -7289,254 +7298,611 @@
   /// \brief Initialization of data-sharing attributes stack.
   void InitDataSharingAttributesStack();
   void DestroyDataSharingAttributesStack();
-  ExprResult VerifyPositiveIntegerConstantInClause(Expr *Op,
-                                                   OpenMPClauseKind CKind);
+  /// \brief Check if \a S ia for-loop in canonical form for OpenMP.
+  ///
+  /// \param S A statement to check.
+  /// \param Kind A directive for which the verification is performed.
+  ///
+  /// \return true if not canonical form, false otherwise.
+  ///
+  bool isNotOpenMPCanonicalLoopForm(Stmt *S, OpenMPDirectiveKind Kind,
+                                    Expr *&NewEnd, Expr *&NewIncr,
+                                    Expr *&InitVal, Expr *&VarCnt,
+                                    BinaryOperatorKind &OpKind);
+
+  /// \brief A helper routine for OpenMP loops collapsing.
+  bool CollapseOpenMPLoop(OpenMPDirectiveKind Kind,
+                          ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+                          SourceLocation StartLoc, SourceLocation EndLoc,
+                          Expr *&NewEnd, Expr *&NewVar, Expr *&NewVarCntExpr,
+                          Expr *&NewFinal, SmallVector<Expr *, 4> &VarCnts);
+
+  /// \brief A helper to rebuild a constant positive integer expression.
+  Expr *ActOnConstantPositiveSubExpressionInClause(Expr *E);
+
+  /// \brief A helper to rebuild a linear step for linear clause.
+  Expr *ActOnConstantLinearStep(Expr *E);
+
+  /// \brief A helper to add two simd-specific arguments into captured stmt.
+  CapturedStmt *AddSimdArgsIntoCapturedStmt(CapturedStmt *Cap, Expr *NewVar);
+
+  /// \brief A helper to add two distribute parallel-specific arguments into
+  /// captured stmt.
+  Stmt *AddDistributedParallelArgsIntoCapturedStmt(CapturedStmt *Cap,
+                                                   Expr *NewVar,
+                                                   Expr *&LowerBound,
+                                                   Expr *&UpperBound);
+
+  bool HasOpenMPRegion(OpenMPDirectiveKind Kind);
+
+  bool HasOpenMPSimdRegion();
+
 public:
-  ExprResult PerformOpenMPImplicitIntegerConversion(SourceLocation OpLoc,
-                                                    Expr *Op);
+  DeclContext *GetOpenMPFunctionRegion();
+
+  bool IsDeclContextInOpenMPTarget(DeclContext *DC);
+
   /// \brief Called on start of new data sharing attribute block.
   void StartOpenMPDSABlock(OpenMPDirectiveKind K,
-                           const DeclarationNameInfo &DirName, Scope *CurScope,
-                           SourceLocation Loc);
+                           const DeclarationNameInfo &DirName, Scope *CurScope);
   /// \brief Called on end of data sharing attribute block.
   void EndOpenMPDSABlock(Stmt *CurDirective);
 
-  // OpenMP directives and clauses.
+  typedef llvm::DenseMap<FunctionTemplateDecl *, OMPDeclareSimdDecl *>
+  OMPDeclareSimdMap;
+  OMPDeclareSimdMap OMPDSimdMap;
+
   /// \brief Called on correct id-expression from the '#pragma omp
   /// threadprivate'.
-  ExprResult ActOnOpenMPIdExpression(Scope *CurScope,
-                                     CXXScopeSpec &ScopeSpec,
+  ExprResult ActOnOpenMPIdExpression(Scope *CurScope, CXXScopeSpec &ScopeSpec,
                                      const DeclarationNameInfo &Id);
   /// \brief Called on well-formed '#pragma omp threadprivate'.
-  DeclGroupPtrTy ActOnOpenMPThreadprivateDirective(
-                                     SourceLocation Loc,
-                                     ArrayRef<Expr *> VarList);
-  /// \brief Builds a new OpenMPThreadPrivateDecl and checks its correctness.
-  OMPThreadPrivateDecl *CheckOMPThreadPrivateDecl(
-                                     SourceLocation Loc,
-                                     ArrayRef<Expr *> VarList);
-
-  /// \brief Initialization of captured region for OpenMP region.
-  void ActOnOpenMPRegionStart(OpenMPDirectiveKind DKind, Scope *CurScope);
-  StmtResult ActOnOpenMPExecutableDirective(OpenMPDirectiveKind Kind,
-                                            const DeclarationNameInfo &DirName,
-                                            ArrayRef<OMPClause *> Clauses,
-                                            Stmt *AStmt,
-                                            SourceLocation StartLoc,
-                                            SourceLocation EndLoc);
+  DeclGroupPtrTy ActOnOpenMPThreadprivateDirective(SourceLocation Loc,
+                                                   ArrayRef<Expr *> VarList);
+  /// \brief Builds a new OMPThreadPrivateDecl and checks its correctness.
+  OMPThreadPrivateDecl *CheckOMPThreadPrivateDecl(SourceLocation Loc,
+                                                  ArrayRef<Expr *> VarList);
+  /// \brief Called on well-formed '#pragma omp declare simd'.
+  DeclGroupPtrTy ActOnOpenMPDeclareSimdDirective(
+      SourceLocation Loc, Decl *FuncDecl, ArrayRef<SourceRange> SrcRanges,
+      ArrayRef<unsigned> BeginIdx, ArrayRef<unsigned> EndIdx,
+      ArrayRef<OMPClause *> CL);
+  /// \brief Builds a new OMPDeclareSimdDecl and checks its correctness.
+  OMPDeclareSimdDecl *CheckOMPDeclareSimdDecl(
+      SourceLocation Loc, Decl *FuncDecl, ArrayRef<SourceRange> SrcRanges,
+      ArrayRef<unsigned> BeginIdx, ArrayRef<unsigned> EndIdx,
+      ArrayRef<OMPClause *> CL, DeclContext *CurDC);
+  /// \brief Transforms arrays into array of SimdVariant structures and
+  ///        stores it into D.
+  void CompleteOMPDeclareSimdDecl(OMPDeclareSimdDecl *D,
+                                  ArrayRef<SourceRange> SrcRanges,
+                                  ArrayRef<unsigned> BeginIdx,
+                                  ArrayRef<unsigned> EndIdx);
+  /// \brief A RAII object to enter scope of a declare reduction.
+  class OMPDeclareReductionRAII {
+  public:
+    OMPDeclareReductionRAII(Sema &S, Scope *CS, DeclContext *DC,
+                            SourceLocation Loc, DeclarationName DN,
+                            unsigned NumTypes, AccessSpecifier AS);
+
+    Decl *getDecl();
+
+  private:
+    /// \brief Called on well-formed '#pragma omp declare reduction'.
+    OMPDeclareReductionDecl *InitDeclareReduction(Scope *CS, DeclContext *DC,
+                                                  SourceLocation Loc,
+                                                  DeclarationName Name,
+                                                  unsigned NumTypes,
+                                                  AccessSpecifier AS);
+    Sema &S;
+    OMPDeclareReductionDecl *D;
+    ContextRAII SavedContext;
+  };
+
+  class OMPDeclareReductionFunctionScope {
+  public:
+    OMPDeclareReductionFunctionScope(Sema &S, SourceLocation Loc,
+                                     DeclarationName Name, QualType QTy)
+        : S(S), FD(ActOnOMPDeclareReductionFunction(S, Loc, Name, QTy)) {}
+
+    ~OMPDeclareReductionFunctionScope() {
+      if (S.CurContext) {
+        S.DiscardCleanupsInEvaluationContext();
+        S.PopExpressionEvaluationContext();
+        S.PopFunctionScopeInfo();
+        S.PopDeclContext();
+      }
+    }
+
+    void setBody(Expr *E);
+    Expr *getCombiner();
+
+  private:
+    FunctionDecl *ActOnOMPDeclareReductionFunction(Sema &S, SourceLocation Loc,
+                                                   DeclarationName Name,
+                                                   QualType QTy);
+
+    Sema &S;
+    FunctionDecl *FD;
+    ParmVarDecl *ParLHS, *ParRHS;
+    VarDecl *OmpOut, *OmpIn;
+  };
+
+  void CreateDefaultDeclareReductionInitFunctionBody(FunctionDecl *FD,
+                                                     VarDecl *OmpPriv,
+                                                     ParmVarDecl *ParLHS);
+  class OMPDeclareReductionInitFunctionScope {
+  public:
+    OMPDeclareReductionInitFunctionScope(Sema &S, SourceLocation Loc,
+                                         DeclarationName Name, QualType QTy,
+                                         SourceLocation OmpPrivLoc, bool IsInit)
+        : S(S), OmpPrivLoc(OmpPrivLoc), IsInit(IsInit),
+          FD(ActOnOMPDeclareReductionInitFunction(S, Loc, Name, QTy)) {}
+
+    ~OMPDeclareReductionInitFunctionScope() {
+      if (S.CurContext) {
+        S.DiscardCleanupsInEvaluationContext();
+        S.PopExpressionEvaluationContext();
+        S.PopFunctionScopeInfo();
+        S.PopDeclContext();
+      }
+    }
+
+    void setInit(Expr *E = 0);
+    Expr *getInitializer();
+
+  private:
+    FunctionDecl *ActOnOMPDeclareReductionInitFunction(Sema &S,
+                                                       SourceLocation Loc,
+                                                       DeclarationName Name,
+                                                       QualType QTy);
+
+    Sema &S;
+    SourceLocation OmpPrivLoc;
+    bool IsInit;
+    FunctionDecl *FD;
+    ParmVarDecl *ParLHS, *ParRHS;
+    VarDecl *OmpPriv, *OmpOrig;
+  };
+
+  llvm::SmallDenseMap<Decl *, Decl *> OMPInstantiatedDecls;
+
+  bool IsOMPDeclareReductionTypeAllowed(SourceRange Range, QualType QTy,
+                                        ArrayRef<QualType> Types,
+                                        ArrayRef<SourceRange> TyRanges);
+
+  DeclGroupPtrTy ActOnOpenMPDeclareReductionDirective(
+      Decl *D, ArrayRef<QualType> Types, ArrayRef<SourceRange> TyRanges,
+      ArrayRef<Expr *> Combiners, ArrayRef<Expr *> Inits);
+  bool ActOnStartOpenMPDeclareTargetDirective(Scope *S, SourceLocation Loc);
+  void ActOnOpenMPDeclareTargetDecls(DeclGroupPtrTy Decls);
+  DeclGroupPtrTy ActOnFinishOpenMPDeclareTargetDirective();
+  void ActOnOpenMPDeclareTargetDirectiveError();
+  void CheckDeclIsAllowedInOpenMPTarget(Expr *E, Decl *D);
+
+  /// \brief Builds a new OMPDeclareReductionDecl and checks its correctness.
+  void CompleteOMPDeclareReductionDecl(OMPDeclareReductionDecl *D,
+                                       ArrayRef<QualType> Types,
+                                       ArrayRef<SourceRange> TyRanges,
+                                       ArrayRef<Expr *> Combiners,
+                                       ArrayRef<Expr *> Inits);
+
+  StmtResult ActOnOpenMPExecutableDirective(
+      OpenMPDirectiveKind Kind, const DeclarationNameInfo &DirName,
+      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,
+      SourceLocation EndLoc, OpenMPDirectiveKind ConstructType);
   /// \brief Called on well-formed '\#pragma omp parallel' after parsing
   /// of the  associated statement.
   StmtResult ActOnOpenMPParallelDirective(ArrayRef<OMPClause *> Clauses,
-                                          Stmt *AStmt,
-                                          SourceLocation StartLoc,
+                                          Stmt *AStmt, SourceLocation StartLoc,
                                           SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp for' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPForDirective(OpenMPDirectiveKind Kind,
+                                     ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+                                     SourceLocation StartLoc,
+                                     SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp parallel for' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPParallelForDirective(OpenMPDirectiveKind Kind,
+                                             ArrayRef<OMPClause *> Clauses,
+                                             Stmt *AStmt,
+                                             SourceLocation StartLoc,
+                                             SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp parallel for simd' after
+  /// parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPParallelForSimdDirective(OpenMPDirectiveKind Kind,
+                                                 ArrayRef<OMPClause *> Clauses,
+                                                 Stmt *AStmt,
+                                                 SourceLocation StartLoc,
+                                                 SourceLocation EndLoc);
   /// \brief Called on well-formed '\#pragma omp simd' after parsing
   /// of the associated statement.
-  StmtResult ActOnOpenMPSimdDirective(
-      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,
-      SourceLocation EndLoc,
-      llvm::DenseMap<VarDecl *, Expr *> &VarsWithImplicitDSA);
-  /// \brief Called on well-formed '\#pragma omp for' after parsing
+  StmtResult ActOnOpenMPSimdDirective(OpenMPDirectiveKind Kind,
+                                      ArrayRef<OMPClause *> Clauses,
+                                      Stmt *AStmt, SourceLocation StartLoc,
+                                      SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp for simd' after parsing
   /// of the associated statement.
-  StmtResult ActOnOpenMPForDirective(
-      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,
-      SourceLocation EndLoc,
-      llvm::DenseMap<VarDecl *, Expr *> &VarsWithImplicitDSA);
-  /// \brief Called on well-formed '\#pragma omp sections' after parsing
+  StmtResult ActOnOpenMPForSimdDirective(OpenMPDirectiveKind Kind,
+                                         ArrayRef<OMPClause *> Clauses,
+                                         Stmt *AStmt, SourceLocation StartLoc,
+                                         SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp distribute simd' after parsing
   /// of the associated statement.
-  StmtResult ActOnOpenMPSectionsDirective(ArrayRef<OMPClause *> Clauses,
+  StmtResult ActOnOpenMPDistributeSimdDirective(OpenMPDirectiveKind Kind,
+                                                ArrayRef<OMPClause *> Clauses,
+                                                Stmt *AStmt,
+                                                SourceLocation StartLoc,
+                                                SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp distribute parallel for' after
+  /// parsing of the associated statement.
+  StmtResult ActOnOpenMPDistributeParallelForDirective(
+      OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+      SourceLocation StartLoc, SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp distribute parallel for simd'
+  /// after parsing of the associated statement.
+  StmtResult ActOnOpenMPDistributeParallelForSimdDirective(
+      OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+      SourceLocation StartLoc, SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp teams distribute parallel for'
+  /// after parsing of the associated statement.
+  StmtResult ActOnOpenMPTeamsDistributeParallelForDirective(
+      OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+      SourceLocation StartLoc, SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp teams distribute parallel for
+  /// simd' after parsing of the associated statement.
+  StmtResult ActOnOpenMPTeamsDistributeParallelForSimdDirective(
+      OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+      SourceLocation StartLoc, SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp target teams distribute
+  /// parallel for' after parsing of the associated statement.
+  StmtResult ActOnOpenMPTargetTeamsDistributeParallelForDirective(
+      OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+      SourceLocation StartLoc, SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp target teams distribute
+  /// parallel for simd' after parsing of the associated statement.
+  StmtResult ActOnOpenMPTargetTeamsDistributeParallelForSimdDirective(
+      OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+      SourceLocation StartLoc, SourceLocation EndLoc);
+
+  /// \brief Called on well-formed '\#pragma omp sections' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPSectionsDirective(OpenMPDirectiveKind Kind,
+                                          ArrayRef<OMPClause *> Clauses,
                                           Stmt *AStmt, SourceLocation StartLoc,
                                           SourceLocation EndLoc);
-  /// \brief Called on well-formed '\#pragma omp section' after parsing of the
-  /// associated statement.
+  /// \brief Called on well-formed '\#pragma omp parallel sections' after
+  /// parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPParallelSectionsDirective(OpenMPDirectiveKind Kind,
+                                                  ArrayRef<OMPClause *> Clauses,
+                                                  Stmt *AStmt,
+                                                  SourceLocation StartLoc,
+                                                  SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp section' after parsing
+  /// of the  associated statement.
   StmtResult ActOnOpenMPSectionDirective(Stmt *AStmt, SourceLocation StartLoc,
                                          SourceLocation EndLoc);
-  /// \brief Called on well-formed '\#pragma omp single' after parsing of the
-  /// associated statement.
+  /// \brief Called on well-formed '\#pragma omp single' after parsing
+  /// of the  associated statement.
   StmtResult ActOnOpenMPSingleDirective(ArrayRef<OMPClause *> Clauses,
                                         Stmt *AStmt, SourceLocation StartLoc,
                                         SourceLocation EndLoc);
-  /// \brief Called on well-formed '\#pragma omp master' after parsing of the
-  /// associated statement.
-  StmtResult ActOnOpenMPMasterDirective(Stmt *AStmt, SourceLocation StartLoc,
-                                        SourceLocation EndLoc);
-  /// \brief Called on well-formed '\#pragma omp critical' after parsing of the
-  /// associated statement.
-  StmtResult ActOnOpenMPCriticalDirective(const DeclarationNameInfo &DirName,
-                                          Stmt *AStmt, SourceLocation StartLoc,
-                                          SourceLocation EndLoc);
-  /// \brief Called on well-formed '\#pragma omp parallel for' after parsing
+  /// \brief Called on well-formed '\#pragma omp task' after parsing
   /// of the  associated statement.
-  StmtResult ActOnOpenMPParallelForDirective(
-      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,
-      SourceLocation EndLoc,
-      llvm::DenseMap<VarDecl *, Expr *> &VarsWithImplicitDSA);
-  /// \brief Called on well-formed '\#pragma omp parallel sections' after
-  /// parsing of the  associated statement.
-  StmtResult ActOnOpenMPParallelSectionsDirective(ArrayRef<OMPClause *> Clauses,
-                                                  Stmt *AStmt,
-                                                  SourceLocation StartLoc,
-                                                  SourceLocation EndLoc);
-  /// \brief Called on well-formed '\#pragma omp task' after parsing of the
-  /// associated statement.
   StmtResult ActOnOpenMPTaskDirective(ArrayRef<OMPClause *> Clauses,
                                       Stmt *AStmt, SourceLocation StartLoc,
                                       SourceLocation EndLoc);
-  /// \brief Called on well-formed '\#pragma omp taskyield'.
+  /// \brief Called on well-formed '\#pragma omp taskyield' after parsing
+  /// of the  associated statement.
   StmtResult ActOnOpenMPTaskyieldDirective(SourceLocation StartLoc,
                                            SourceLocation EndLoc);
-  /// \brief Called on well-formed '\#pragma omp barrier'.
+  /// \brief Called on well-formed '\#pragma omp master' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPMasterDirective(Stmt *AStmt, SourceLocation StartLoc,
+                                        SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp critical' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPCriticalDirective(const DeclarationNameInfo &DirName,
+                                          Stmt *AStmt, SourceLocation StartLoc,
+                                          SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp barrier' after parsing
+  /// of the  associated statement.
   StmtResult ActOnOpenMPBarrierDirective(SourceLocation StartLoc,
                                          SourceLocation EndLoc);
-  /// \brief Called on well-formed '\#pragma omp taskwait'.
+  /// \brief Called on well-formed '\#pragma omp taskwait' after parsing
+  /// of the  associated statement.
   StmtResult ActOnOpenMPTaskwaitDirective(SourceLocation StartLoc,
                                           SourceLocation EndLoc);
-  /// \brief Called on well-formed '\#pragma omp flush'.
+  /// \brief Called on well-formed '\#pragma omp taskgroup' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPTaskgroupDirective(Stmt *AStmt, SourceLocation StartLoc,
+                                           SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp atomic' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPAtomicDirective(ArrayRef<OMPClause *> Clauses,
+                                        Stmt *AStmt, SourceLocation StartLoc,
+                                        SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp flush' after parsing
+  /// of the  associated statement.
   StmtResult ActOnOpenMPFlushDirective(ArrayRef<OMPClause *> Clauses,
                                        SourceLocation StartLoc,
                                        SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp ordered' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPOrderedDirective(Stmt *AStmt, SourceLocation StartLoc,
+                                         SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp teams' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPTeamsDirective(ArrayRef<OMPClause *> Clauses,
+                                       Stmt *AStmt, SourceLocation StartLoc,
+                                       SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp distribute' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPDistributeDirective(ArrayRef<OMPClause *> Clauses,
+                                            Stmt *AStmt,
+                                            SourceLocation StartLoc,
+                                            SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp cancel' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPCancelDirective(ArrayRef<OMPClause *> Clauses,
+                                        SourceLocation StartLoc,
+                                        SourceLocation EndLoc,
+                                        OpenMPDirectiveKind ConstructType);
+
+  /// \brief Called on well-formed '\#pragma omp cancellation point' after
+  /// parsing of the  associated statement.
+  StmtResult
+  ActOnOpenMPCancellationPointDirective(SourceLocation StartLoc,
+                                        SourceLocation EndLoc,
+                                        OpenMPDirectiveKind ConstructType);
+  /// \brief Called on well-formed '\#pragma omp target' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPTargetDirective(ArrayRef<OMPClause *> Clauses,
+                                        Stmt *AStmt, SourceLocation StartLoc,
+                                        SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp target data' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPTargetDataDirective(ArrayRef<OMPClause *> Clauses,
+                                            Stmt *AStmt,
+                                            SourceLocation StartLoc,
+                                            SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp target update' after parsing.
+  StmtResult ActOnOpenMPTargetUpdateDirective(ArrayRef<OMPClause *> Clauses,
+                                              SourceLocation StartLoc,
+                                              SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp target teams' after parsing
+  /// of the  associated statement.
+  StmtResult ActOnOpenMPTargetTeamsDirective(ArrayRef<OMPClause *> Clauses,
+                                             Stmt *AStmt,
+                                             SourceLocation StartLoc,
+                                             SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp teams distribute' after parsing
+  /// of the associated statement.
+  StmtResult ActOnOpenMPTeamsDistributeDirective(ArrayRef<OMPClause *> Clauses,
+                                                 Stmt *AStmt,
+                                                 SourceLocation StartLoc,
+                                                 SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp teams distribute simd' after
+  /// parsing of the associated statement.
+  StmtResult ActOnOpenMPTeamsDistributeSimdDirective(
+      OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+      SourceLocation StartLoc, SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp target teams distribute' after
+  /// parsing of the associated statement.
+  StmtResult ActOnOpenMPTargetTeamsDistributeDirective(
+      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,
+      SourceLocation EndLoc);
+  /// \brief Called on well-formed '\#pragma omp target teams distribute simd'
+  /// after parsing of the associated statement.
+  StmtResult ActOnOpenMPTargetTeamsDistributeSimdDirective(
+      OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+      SourceLocation StartLoc, SourceLocation EndLoc);
 
-  OMPClause *ActOnOpenMPSingleExprClause(OpenMPClauseKind Kind,
-                                         Expr *Expr,
+  OMPClause *ActOnOpenMPSingleExprClause(OpenMPClauseKind Kind, Expr *Expr,
                                          SourceLocation StartLoc,
-                                         SourceLocation LParenLoc,
                                          SourceLocation EndLoc);
   /// \brief Called on well-formed 'if' clause.
   OMPClause *ActOnOpenMPIfClause(Expr *Condition, SourceLocation StartLoc,
-                                 SourceLocation LParenLoc,
                                  SourceLocation EndLoc);
   /// \brief Called on well-formed 'final' clause.
   OMPClause *ActOnOpenMPFinalClause(Expr *Condition, SourceLocation StartLoc,
-                                    SourceLocation LParenLoc,
                                     SourceLocation EndLoc);
   /// \brief Called on well-formed 'num_threads' clause.
   OMPClause *ActOnOpenMPNumThreadsClause(Expr *NumThreads,
                                          SourceLocation StartLoc,
-                                         SourceLocation LParenLoc,
                                          SourceLocation EndLoc);
-  /// \brief Called on well-formed 'safelen' clause.
-  OMPClause *ActOnOpenMPSafelenClause(Expr *Length,
-                                      SourceLocation StartLoc,
-                                      SourceLocation LParenLoc,
-                                      SourceLocation EndLoc);
+  /// \brief Called on well-formed 'device' clause.
+  OMPClause *ActOnOpenMPDeviceClause(Expr *Device, SourceLocation StartLoc,
+                                     SourceLocation EndLoc);
   /// \brief Called on well-formed 'collapse' clause.
-  OMPClause *ActOnOpenMPCollapseClause(Expr *NumForLoops,
-                                       SourceLocation StartLoc,
-                                       SourceLocation LParenLoc,
+  OMPClause *ActOnOpenMPCollapseClause(Expr *NumLoops, SourceLocation StartLoc,
                                        SourceLocation EndLoc);
 
-  OMPClause *ActOnOpenMPSimpleClause(OpenMPClauseKind Kind,
-                                     unsigned Argument,
+  OMPClause *ActOnOpenMPSimpleClause(OpenMPClauseKind Kind, unsigned Argument,
                                      SourceLocation ArgumentLoc,
                                      SourceLocation StartLoc,
-                                     SourceLocation LParenLoc,
                                      SourceLocation EndLoc);
   /// \brief Called on well-formed 'default' clause.
   OMPClause *ActOnOpenMPDefaultClause(OpenMPDefaultClauseKind Kind,
                                       SourceLocation KindLoc,
                                       SourceLocation StartLoc,
-                                      SourceLocation LParenLoc,
                                       SourceLocation EndLoc);
   /// \brief Called on well-formed 'proc_bind' clause.
   OMPClause *ActOnOpenMPProcBindClause(OpenMPProcBindClauseKind Kind,
                                        SourceLocation KindLoc,
                                        SourceLocation StartLoc,
-                                       SourceLocation LParenLoc,
-                                       SourceLocation EndLoc);
-
-  OMPClause *ActOnOpenMPSingleExprWithArgClause(OpenMPClauseKind Kind,
-                                                unsigned Argument, Expr *Expr,
-                                                SourceLocation StartLoc,
-                                                SourceLocation LParenLoc,
-                                                SourceLocation ArgumentLoc,
-                                                SourceLocation CommaLoc,
-                                                SourceLocation EndLoc);
-  /// \brief Called on well-formed 'schedule' clause.
-  OMPClause *ActOnOpenMPScheduleClause(OpenMPScheduleClauseKind Kind,
-                                       Expr *ChunkSize, SourceLocation StartLoc,
-                                       SourceLocation LParenLoc,
-                                       SourceLocation KindLoc,
-                                       SourceLocation CommaLoc,
                                        SourceLocation EndLoc);
-
-  OMPClause *ActOnOpenMPClause(OpenMPClauseKind Kind, SourceLocation StartLoc,
-                               SourceLocation EndLoc);
-  /// \brief Called on well-formed 'ordered' clause.
-  OMPClause *ActOnOpenMPOrderedClause(SourceLocation StartLoc,
-                                      SourceLocation EndLoc);
-  /// \brief Called on well-formed 'nowait' clause.
-  OMPClause *ActOnOpenMPNowaitClause(SourceLocation StartLoc,
-                                     SourceLocation EndLoc);
-  /// \brief Called on well-formed 'untied' clause.
-  OMPClause *ActOnOpenMPUntiedClause(SourceLocation StartLoc,
-                                     SourceLocation EndLoc);
-  /// \brief Called on well-formed 'mergeable' clause.
-  OMPClause *ActOnOpenMPMergeableClause(SourceLocation StartLoc,
-                                        SourceLocation EndLoc);
-
+  /// \brief Helper for all clauses with varlists.
   OMPClause *
   ActOnOpenMPVarListClause(OpenMPClauseKind Kind, ArrayRef<Expr *> Vars,
-                           Expr *TailExpr, SourceLocation StartLoc,
-                           SourceLocation LParenLoc, SourceLocation ColonLoc,
-                           SourceLocation EndLoc,
-                           CXXScopeSpec &ReductionIdScopeSpec,
-                           const DeclarationNameInfo &ReductionId);
+                           SourceLocation StartLoc, SourceLocation EndLoc,
+                           unsigned Op, Expr *TailExpr, CXXScopeSpec &SS,
+                           const UnqualifiedId &OpName, SourceLocation OpLoc);
+  /// \brief Helper to build DeclRefExpr for declarative clause.
+  Expr *ActOnOpenMPParameterInDeclarativeVarListClause(SourceLocation Loc,
+                                                       ParmVarDecl *Param);
+  /// \brief Helper to find paremeter with given name in function.
+  Expr *FindOpenMPDeclarativeClauseParameter(StringRef Name, SourceLocation Loc,
+                                             Decl *FuncDecl);
+  /// \brief Helper for all declarative clauses with varlists
+  ///        (i.e. for declarative form of linear, aligned and uniform).
+  OMPClause *ActOnOpenMPDeclarativeVarListClause(
+      OpenMPClauseKind CKind, ArrayRef<DeclarationNameInfo> NameInfos,
+      SourceLocation StartLoc, SourceLocation EndLoc, Expr *TailExpr,
+      SourceLocation TailLoc, Decl *FuncDecl);
+
   /// \brief Called on well-formed 'private' clause.
   OMPClause *ActOnOpenMPPrivateClause(ArrayRef<Expr *> VarList,
                                       SourceLocation StartLoc,
-                                      SourceLocation LParenLoc,
                                       SourceLocation EndLoc);
   /// \brief Called on well-formed 'firstprivate' clause.
-  OMPClause *ActOnOpenMPFirstprivateClause(ArrayRef<Expr *> VarList,
+  OMPClause *ActOnOpenMPFirstPrivateClause(ArrayRef<Expr *> VarList,
                                            SourceLocation StartLoc,
-                                           SourceLocation LParenLoc,
                                            SourceLocation EndLoc);
   /// \brief Called on well-formed 'lastprivate' clause.
-  OMPClause *ActOnOpenMPLastprivateClause(ArrayRef<Expr *> VarList,
+  OMPClause *ActOnOpenMPLastPrivateClause(ArrayRef<Expr *> VarList,
                                           SourceLocation StartLoc,
-                                          SourceLocation LParenLoc,
                                           SourceLocation EndLoc);
   /// \brief Called on well-formed 'shared' clause.
   OMPClause *ActOnOpenMPSharedClause(ArrayRef<Expr *> VarList,
                                      SourceLocation StartLoc,
-                                     SourceLocation LParenLoc,
                                      SourceLocation EndLoc);
-  /// \brief Called on well-formed 'reduction' clause.
-  OMPClause *
-  ActOnOpenMPReductionClause(ArrayRef<Expr *> VarList, SourceLocation StartLoc,
-                             SourceLocation LParenLoc, SourceLocation ColonLoc,
-                             SourceLocation EndLoc,
-                             CXXScopeSpec &ReductionIdScopeSpec,
-                             const DeclarationNameInfo &ReductionId);
-  /// \brief Called on well-formed 'linear' clause.
-  OMPClause *ActOnOpenMPLinearClause(ArrayRef<Expr *> VarList,
-                                     Expr *Step,
-                                     SourceLocation StartLoc,
-                                     SourceLocation LParenLoc,
-                                     SourceLocation ColonLoc,
-                                     SourceLocation EndLoc);
-  /// \brief Called on well-formed 'aligned' clause.
-  OMPClause *ActOnOpenMPAlignedClause(ArrayRef<Expr *> VarList,
-                                      Expr *Alignment,
-                                      SourceLocation StartLoc,
-                                      SourceLocation LParenLoc,
-                                      SourceLocation ColonLoc,
-                                      SourceLocation EndLoc);
   /// \brief Called on well-formed 'copyin' clause.
   OMPClause *ActOnOpenMPCopyinClause(ArrayRef<Expr *> VarList,
                                      SourceLocation StartLoc,
-                                     SourceLocation LParenLoc,
                                      SourceLocation EndLoc);
   /// \brief Called on well-formed 'copyprivate' clause.
-  OMPClause *ActOnOpenMPCopyprivateClause(ArrayRef<Expr *> VarList,
+  OMPClause *ActOnOpenMPCopyPrivateClause(ArrayRef<Expr *> VarList,
                                           SourceLocation StartLoc,
-                                          SourceLocation LParenLoc,
                                           SourceLocation EndLoc);
-  /// \brief Called on well-formed 'flush' pseudo clause.
+  /// \brief Called on well-formed 'reduction' clause.
+  OMPClause *ActOnOpenMPReductionClause(ArrayRef<Expr *> VarList,
+                                        SourceLocation StartLoc,
+                                        SourceLocation EndLoc,
+                                        OpenMPReductionClauseOperator Op,
+                                        CXXScopeSpec &SS,
+                                        DeclarationNameInfo OpName);
+  /// \brief Called on well-formed 'map' clause.
+  OMPClause *ActOnOpenMPMapClause(ArrayRef<Expr *> VarList,
+                                  SourceLocation StartLoc,
+                                  SourceLocation EndLoc,
+                                  OpenMPMapClauseKind Kind,
+                                  SourceLocation KindLoc);
+  /// \brief Called on well-formed 'to' clause.
+  OMPClause *ActOnOpenMPToClause(ArrayRef<Expr *> VarList,
+                                 SourceLocation StartLoc,
+                                 SourceLocation EndLoc);
+  /// \brief Called on well-formed 'from' clause.
+  OMPClause *ActOnOpenMPFromClause(ArrayRef<Expr *> VarList,
+                                   SourceLocation StartLoc,
+                                   SourceLocation EndLoc);
+  /// \brief Called on well-formed 'flush' clause.
   OMPClause *ActOnOpenMPFlushClause(ArrayRef<Expr *> VarList,
                                     SourceLocation StartLoc,
-                                    SourceLocation LParenLoc,
                                     SourceLocation EndLoc);
+  /// \brief Called on well-formed 'uniform' clause.
+  OMPClause *ActOnOpenMPUniformClause(ArrayRef<Expr *> VarList,
+                                      SourceLocation StartLoc,
+                                      SourceLocation EndLoc);
+  OMPClause *ActOnOpenMPClause(OpenMPClauseKind Kind, SourceLocation StartLoc,
+                               SourceLocation EndLoc);
+  /// \brief Called on well-formed 'ordered' clause.
+  OMPClause *ActOnOpenMPOrderedClause(SourceLocation StartLoc,
+                                      SourceLocation EndLoc);
+  /// \brief Called on well-formed 'nowait' clause.
+  OMPClause *ActOnOpenMPNowaitClause(SourceLocation StartLoc,
+                                     SourceLocation EndLoc);
+  /// \brief Called on well-formed 'untied' clause.
+  OMPClause *ActOnOpenMPUntiedClause(SourceLocation StartLoc,
+                                     SourceLocation EndLoc);
+  /// \brief Called on well-formed 'mergeable' clause.
+  OMPClause *ActOnOpenMPMergeableClause(SourceLocation StartLoc,
+                                        SourceLocation EndLoc);
+  /// \brief Called on well-formed 'read' clause.
+  OMPClause *ActOnOpenMPReadClause(SourceLocation StartLoc,
+                                   SourceLocation EndLoc);
+  /// \brief Called on well-formed 'write' clause.
+  OMPClause *ActOnOpenMPWriteClause(SourceLocation StartLoc,
+                                    SourceLocation EndLoc);
+  /// \brief Called on well-formed 'update' clause.
+  OMPClause *ActOnOpenMPUpdateClause(SourceLocation StartLoc,
+                                     SourceLocation EndLoc);
+  /// \brief Called on well-formed 'capture' clause.
+  OMPClause *ActOnOpenMPCaptureClause(SourceLocation StartLoc,
+                                      SourceLocation EndLoc);
+  /// \brief Called on well-formed 'seq_cst' clause.
+  OMPClause *ActOnOpenMPSeqCstClause(SourceLocation StartLoc,
+                                     SourceLocation EndLoc);
+  /// \brief Called on well-formed 'depend' clause.
+  OMPClause *ActOnOpenMPDependClause(ArrayRef<Expr *> VarList,
+                                     SourceLocation StartLoc,
+                                     SourceLocation EndLoc,
+                                     OpenMPDependClauseType Ty,
+                                     SourceLocation TyLoc);
+  /// \brief Called on well-formed 'inbranch' clause.
+  OMPClause *ActOnOpenMPInBranchClause(SourceLocation StartLoc,
+                                       SourceLocation EndLoc);
+  /// \brief Called on well-formed 'notinbranch' clause.
+  OMPClause *ActOnOpenMPNotInBranchClause(SourceLocation StartLoc,
+                                          SourceLocation EndLoc);
+  /// \brief Called on well-formed 'safelen' clause.
+  OMPClause *ActOnOpenMPSafelenClause(Expr *Length, SourceLocation StartLoc,
+                                      SourceLocation EndLoc);
+  /// \brief Called on well-formed 'simdlen' clause.
+  OMPClause *ActOnOpenMPSimdlenClause(Expr *Length, SourceLocation StartLoc,
+                                      SourceLocation EndLoc);
+  /// \brief Called on well-formed 'num_teams' clause.
+  OMPClause *ActOnOpenMPNumTeamsClause(Expr *NumTeams, SourceLocation StartLoc,
+                                       SourceLocation EndLoc);
+  /// \brief Called on well-formed 'thread_limit' clause.
+  OMPClause *ActOnOpenMPThreadLimitClause(Expr *ThreadLimit,
+                                          SourceLocation StartLoc,
+                                          SourceLocation EndLoc);
+  /// \brief Called on well-formed 'linear' clause.
+  OMPClause *ActOnOpenMPLinearClause(ArrayRef<Expr *> VarList,
+                                     SourceLocation StartLoc,
+                                     SourceLocation EndLoc, Expr *Step,
+                                     SourceLocation StepLoc);
+  /// \brief Called on well-formed 'aligned' clause.
+  OMPClause *ActOnOpenMPAlignedClause(ArrayRef<Expr *> VarList,
+                                      SourceLocation StartLoc,
+                                      SourceLocation EndLoc, Expr *Alignment,
+                                      SourceLocation AlignmentLoc);
+  /// \brief Called on well-formed 'linear' clause (declarative form).
+  OMPClause *ActOnOpenMPDeclarativeLinearClause(ArrayRef<Expr *> VarList,
+                                                SourceLocation StartLoc,
+                                                SourceLocation EndLoc,
+                                                Expr *Step,
+                                                SourceLocation StepLoc);
+  /// \brief Called on well-formed 'aligned' clause (declarative form).
+  OMPClause *ActOnOpenMPDeclarativeAlignedClause(ArrayRef<Expr *> VarList,
+                                                 SourceLocation StartLoc,
+                                                 SourceLocation EndLoc,
+                                                 Expr *Alignment,
+                                                 SourceLocation AlignmentLoc);
+  /// \brief Called on well-formed 'uniform' clause (declarative form).
+  OMPClause *ActOnOpenMPDeclarativeUniformClause(ArrayRef<Expr *> VarList,
+                                                 SourceLocation StartLoc,
+                                                 SourceLocation EndLoc);
+  OMPClause *ActOnOpenMPSingleExprWithTypeClause(
+      OpenMPClauseKind Kind, unsigned Argument, SourceLocation ArgumentLoc,
+      Expr *Expr, SourceLocation StartLoc, SourceLocation EndLoc);
+  /// \brief Called on well-formed 'schedule' clause.
+  OMPClause *ActOnOpenMPScheduleClause(OpenMPScheduleClauseKind Argument,
+                                       SourceLocation ArgumentLoc,
+                                       Expr *ChunkSize, SourceLocation StartLoc,
+                                       SourceLocation EndLoc);
+  /// \brief Called on well-formed 'dist_schedule' clause.
+  OMPClause *
+  ActOnOpenMPDistScheduleClause(OpenMPDistScheduleClauseKind Argument,
+                                SourceLocation ArgumentLoc, Expr *ChunkSize,
+                                SourceLocation StartLoc, SourceLocation EndLoc);
+
+  /// \brief Marks all decls as used in associated captured statement.
+  void MarkOpenMPClauses(ArrayRef<OMPClause *> Clauses);
 
   /// \brief The kind of conversion being performed.
   enum CheckedConversionKind {
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Sema/Template.h cfe-3.5.0.src.omp/include/clang/Sema/Template.h
--- cfe-3.5.0.src/include/clang/Sema/Template.h	2014-07-06 13:32:10.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Sema/Template.h	2014-11-28 10:49:29.000000000 -0500
@@ -426,6 +426,11 @@
                             TemplateParameterList *TemplateParams);
     Decl *VisitDecl(Decl *D);
     Decl *VisitVarDecl(VarDecl *D, bool InstantiatingVarTemplate);
+    void TouchOMPVarlist(llvm::MutableArrayRef<clang::Expr*> VL,
+                         SmallVector<Expr *, 4> &NewVL,
+                         Decl *FuncDecl);
+    Decl *TouchOMPDeclareSimdDecl(OMPDeclareSimdDecl *D,
+                                  Decl *NewFunc, DeclContext *DC);
 
     // Enable late instantiation of attributes.  Late instantiated attributes
     // will be stored in LA.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Serialization/ASTBitCodes.h cfe-3.5.0.src.omp/include/clang/Serialization/ASTBitCodes.h
--- cfe-3.5.0.src/include/clang/Serialization/ASTBitCodes.h	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Serialization/ASTBitCodes.h	2014-11-28 10:49:29.000000000 -0500
@@ -1074,6 +1074,12 @@
       DECL_IMPORT,
       /// \brief An OMPThreadPrivateDecl record.
       DECL_OMP_THREADPRIVATE,
+      /// \brief An OMPDeclareReductionDecl record.
+      DECL_OMP_DECLAREREDUCTION,
+      /// \brief An OMPDeclareSimdDecl record.
+      DECL_OMP_DECLARESIMD,
+      /// \brief An OMPDeclareTargetDecl record.
+      DECL_OMP_DECLARETARGET,
       /// \brief An EmptyDecl record.
       DECL_EMPTY
     };
@@ -1159,6 +1165,8 @@
       EXPR_SIZEOF_ALIGN_OF,
       /// \brief An ArraySubscriptExpr record.
       EXPR_ARRAY_SUBSCRIPT,
+      /// \brief A CEAN index expr.
+      EXPR_CEAN_INDEX,
       /// \brief A CallExpr record.
       EXPR_CALL,
       /// \brief A MemberExpr record.
@@ -1339,22 +1347,46 @@
       STMT_SEH_FINALLY,           // SEHFinallyStmt
       STMT_SEH_TRY,               // SEHTryStmt
 
-      // OpenMP drectives
+      // OpenMP directives
       STMT_OMP_PARALLEL_DIRECTIVE,
-      STMT_OMP_SIMD_DIRECTIVE,
       STMT_OMP_FOR_DIRECTIVE,
+      STMT_OMP_PARALLEL_FOR_DIRECTIVE,
+      STMT_OMP_PARALLEL_FOR_SIMD_DIRECTIVE,
+      STMT_OMP_SIMD_DIRECTIVE,
+      STMT_OMP_FOR_SIMD_DIRECTIVE,
+      STMT_OMP_DISTRIBUTE_SIMD_DIRECTIVE,
+      STMT_OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,
+      STMT_OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,
       STMT_OMP_SECTIONS_DIRECTIVE,
+      STMT_OMP_PARALLEL_SECTIONS_DIRECTIVE,
       STMT_OMP_SECTION_DIRECTIVE,
       STMT_OMP_SINGLE_DIRECTIVE,
-      STMT_OMP_MASTER_DIRECTIVE,
-      STMT_OMP_CRITICAL_DIRECTIVE,
-      STMT_OMP_PARALLEL_FOR_DIRECTIVE,
-      STMT_OMP_PARALLEL_SECTIONS_DIRECTIVE,
       STMT_OMP_TASK_DIRECTIVE,
       STMT_OMP_TASKYIELD_DIRECTIVE,
+      STMT_OMP_MASTER_DIRECTIVE,
+      STMT_OMP_CRITICAL_DIRECTIVE,
       STMT_OMP_BARRIER_DIRECTIVE,
       STMT_OMP_TASKWAIT_DIRECTIVE,
+      STMT_OMP_TASKGROUP_DIRECTIVE,
+      STMT_OMP_ATOMIC_DIRECTIVE,
       STMT_OMP_FLUSH_DIRECTIVE,
+      STMT_OMP_ORDERED_DIRECTIVE,
+      STMT_OMP_TEAMS_DIRECTIVE,
+      STMT_OMP_DISTRIBUTE_DIRECTIVE,
+      STMT_OMP_CANCEL_DIRECTIVE,
+      STMT_OMP_CANCELLATION_POINT_DIRECTIVE,
+      STMT_OMP_TARGET_DIRECTIVE,
+      STMT_OMP_TARGET_DATA_DIRECTIVE,
+      STMT_OMP_TARGET_UPDATE_DIRECTIVE,
+      STMT_OMP_TARGET_TEAMS_DIRECTIVE,
+      STMT_OMP_TEAMS_DISTRIBUTE_DIRECTIVE,
+      STMT_OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE,
+      STMT_OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE,
+      STMT_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE,
+      STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,
+      STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,
+      STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,
+      STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,
 
       // ARC
       EXPR_OBJC_BRIDGED_CAST,     // ObjCBridgedCastExpr
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Serialization/ASTReader.h cfe-3.5.0.src.omp/include/clang/Serialization/ASTReader.h
--- cfe-3.5.0.src/include/clang/Serialization/ASTReader.h	2014-07-18 18:13:40.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Serialization/ASTReader.h	2014-11-28 10:49:29.000000000 -0500
@@ -16,6 +16,7 @@
 
 #include "clang/AST/DeclObjC.h"
 #include "clang/AST/DeclarationName.h"
+#include "clang/AST/OpenMPClause.h"
 #include "clang/AST/TemplateBase.h"
 #include "clang/Basic/Diagnostic.h"
 #include "clang/Basic/FileManager.h"
@@ -2080,6 +2081,33 @@
   void ReadComments() override;
 };
 
+/// \brief AST Reader for OpenMP clauses, used for both clauses-stmts
+///        (e.g. omp parallel) and clauses-decls (e.g. omp declare simd).
+class OMPClauseReader : public OMPClauseVisitor<OMPClauseReader> {
+  ASTReader &Reader;
+  ASTContext &Context;
+  const ASTReader::RecordData &Record;
+  unsigned &Idx;
+  serialization::ModuleFile &MFile;
+public:
+  OMPClauseReader(ASTReader &R, ASTContext &C,
+                  const ASTReader::RecordData &Record, unsigned &Idx,
+                  serialization::ModuleFile &MF)
+    : Reader(R), Context(C), Record(Record), Idx(Idx), MFile(MF) { }
+#define OPENMP_CLAUSE(Name, Class)    \
+  void Visit##Class(Class *S);
+#include "clang/Basic/OpenMPKinds.def"
+  OMPClause *readClause();
+  SourceLocation ReadSourceLocation(const ASTReader::RecordData &R,
+                                    unsigned &I) {
+    return Reader.ReadSourceLocation(MFile, R, I);
+  }
+
+  SourceRange ReadSourceRange(const ASTReader::RecordData &R, unsigned &I) {
+    return Reader.ReadSourceRange(MFile, R, I);
+  }
+};
+
 /// \brief Helper class that saves the current stream position and
 /// then restores it when destroyed.
 struct SavedStreamPosition {
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang/Serialization/ASTWriter.h cfe-3.5.0.src.omp/include/clang/Serialization/ASTWriter.h
--- cfe-3.5.0.src/include/clang/Serialization/ASTWriter.h	2014-05-23 08:13:25.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang/Serialization/ASTWriter.h	2014-11-28 10:49:29.000000000 -0500
@@ -17,6 +17,7 @@
 #include "clang/AST/ASTMutationListener.h"
 #include "clang/AST/Decl.h"
 #include "clang/AST/DeclarationName.h"
+#include "clang/AST/OpenMPClause.h"
 #include "clang/AST/TemplateBase.h"
 #include "clang/Sema/SemaConsumer.h"
 #include "clang/Serialization/ASTBitCodes.h"
@@ -777,6 +778,20 @@
   void DeclarationMarkedUsed(const Decl *D) override;
 };
 
+/// \brief AST Writer for OpenMP clauses, used for both clauses-stmts
+///        (e.g. omp parallel) and clauses-decls (e.g. omp declare simd).
+class OMPClauseWriter : public OMPClauseVisitor<OMPClauseWriter> {
+  ASTWriter &Writer;
+  ASTWriter::RecordData &Record;
+public:
+  OMPClauseWriter(ASTWriter &W, ASTWriter::RecordData &Record)
+    : Writer(W), Record(Record) { }
+#define OPENMP_CLAUSE(Name, Class)    \
+  void Visit##Class(Class *S);
+#include "clang/Basic/OpenMPKinds.def"
+  void writeClause(OMPClause *C);
+};
+
 /// \brief AST and semantic-analysis consumer that generates a
 /// precompiled header from the parsed source code.
 class PCHGenerator : public SemaConsumer {
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/include/clang-c/Index.h cfe-3.5.0.src.omp/include/clang-c/Index.h
--- cfe-3.5.0.src/include/clang-c/Index.h	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/include/clang-c/Index.h	2014-11-28 10:49:29.000000000 -0500
@@ -2131,69 +2131,51 @@
    */
   CXCursor_DeclStmt                      = 231,
 
-  /** \brief OpenMP parallel directive.
+  /** \brief OpenMP directives.
    */
   CXCursor_OMPParallelDirective          = 232,
-
-  /** \brief OpenMP simd directive.
-   */
-  CXCursor_OMPSimdDirective              = 233,
-
-  /** \brief OpenMP for directive.
-   */
-  CXCursor_OMPForDirective               = 234,
-
-  /** \brief OpenMP sections directive.
-   */
-  CXCursor_OMPSectionsDirective          = 235,
-
-  /** \brief OpenMP section directive.
-   */
-  CXCursor_OMPSectionDirective           = 236,
-
-  /** \brief OpenMP single directive.
-   */
-  CXCursor_OMPSingleDirective            = 237,
-
-  /** \brief OpenMP parallel for directive.
-   */
-  CXCursor_OMPParallelForDirective       = 238,
-
-  /** \brief OpenMP parallel sections directive.
-   */
-  CXCursor_OMPParallelSectionsDirective  = 239,
-
-  /** \brief OpenMP task directive.
-   */
-  CXCursor_OMPTaskDirective              = 240,
-
-  /** \brief OpenMP master directive.
-   */
-  CXCursor_OMPMasterDirective            = 241,
-
-  /** \brief OpenMP critical directive.
-   */
-  CXCursor_OMPCriticalDirective          = 242,
-
-  /** \brief OpenMP taskyield directive.
-   */
-  CXCursor_OMPTaskyieldDirective         = 243,
-
-  /** \brief OpenMP barrier directive.
-   */
-  CXCursor_OMPBarrierDirective           = 244,
-
-  /** \brief OpenMP taskwait directive.
-   */
-  CXCursor_OMPTaskwaitDirective          = 245,
-
-  /** \brief OpenMP flush directive.
-   */
-  CXCursor_OMPFlushDirective             = 246,
+  CXCursor_OMPForDirective               = 233,
+  CXCursor_OMPSectionsDirective          = 234,
+  CXCursor_OMPSectionDirective           = 235,
+  CXCursor_OMPSingleDirective            = 236,
+  CXCursor_OMPTaskDirective              = 237,
+  CXCursor_OMPTaskyieldDirective         = 238,
+  CXCursor_OMPMasterDirective            = 239,
+  CXCursor_OMPCriticalDirective          = 240,
+  CXCursor_OMPBarrierDirective           = 241,
+  CXCursor_OMPTaskwaitDirective          = 242,
+  CXCursor_OMPTaskgroupDirective         = 243,
+  CXCursor_OMPAtomicDirective            = 244,
+  CXCursor_OMPFlushDirective             = 245,
+  CXCursor_OMPOrderedDirective           = 246,
+  CXCursor_OMPSimdDirective              = 247,
+  CXCursor_OMPForSimdDirective           = 248,
+  CXCursor_OMPTeamsDirective             = 249,
+  CXCursor_OMPCancelDirective            = 250,
+  CXCursor_OMPCancellationPointDirective = 251,
+  CXCursor_OMPDistributeDirective        = 252,
+  CXCursor_OMPDistributeSimdDirective    = 253,
+  CXCursor_OMPParallelForDirective       = 254,
+  CXCursor_OMPParallelForSimdDirective   = 255,
+  CXCursor_OMPParallelSectionsDirective  = 256,
+  CXCursor_OMPDistributeParallelForDirective = 257,
+  CXCursor_OMPDistributeParallelForSimdDirective = 258,
+  CXCursor_OMPTargetDirective            = 259,
+  CXCursor_OMPTargetDataDirective        = 260,
+  CXCursor_OMPTargetUpdateDirective      = 261,
+  CXCursor_OMPTargetTeamsDirective       = 262,
+  CXCursor_OMPTeamsDistributeDirective   = 263,
+  CXCursor_OMPTeamsDistributeSimdDirective = 264,
+  CXCursor_OMPTargetTeamsDistributeDirective = 265,
+  CXCursor_OMPTargetTeamsDistributeSimdDirective = 266,
+  CXCursor_OMPTeamsDistributeParallelForDirective = 267,
+  CXCursor_OMPTeamsDistributeParallelForSimdDirective = 268,
+  CXCursor_OMPTargetTeamsDistributeParallelForDirective = 269,
+  CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective = 270,
 
   /** \brief Windows Structured Exception Handling's leave statement.
    */
-  CXCursor_SEHLeaveStmt                  = 247,
+  CXCursor_SEHLeaveStmt                  = 271,
 
   CXCursor_LastStmt                      = CXCursor_SEHLeaveStmt,
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/ASTContext.cpp cfe-3.5.0.src.omp/lib/AST/ASTContext.cpp
--- cfe-3.5.0.src/lib/AST/ASTContext.cpp	2014-07-17 16:25:23.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/ASTContext.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -7895,7 +7895,10 @@
     // We never need to emit an uninstantiated function template.
     if (FD->getTemplatedKind() == FunctionDecl::TK_FunctionTemplate)
       return false;
-  } else
+  } else if (isa<OMPThreadPrivateDecl>(D) || isa<OMPDeclareSimdDecl>(D) ||
+             isa<OMPDeclareReductionDecl>(D) || isa<OMPDeclareTargetDecl>(D))
+    return true;
+  else
     return false;
 
   // If this is a member of a class template, we do not need to emit it.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/ASTDumper.cpp cfe-3.5.0.src.omp/lib/AST/ASTDumper.cpp
--- cfe-3.5.0.src/lib/AST/ASTDumper.cpp	2014-07-10 18:54:03.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/ASTDumper.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -304,6 +304,7 @@
     void VisitAttributedStmt(const AttributedStmt *Node);
     void VisitLabelStmt(const LabelStmt *Node);
     void VisitGotoStmt(const GotoStmt *Node);
+    void VisitCapturedStmt(const CapturedStmt *Node);
     void VisitCXXCatchStmt(const CXXCatchStmt *Node);
 
     // Exprs
@@ -1523,6 +1524,9 @@
       lastChild();
     dumpStmt(*CI);
   }
+  if (const CapturedStmt *CS = dyn_cast<CapturedStmt>(S)) {
+    dumpStmt(CS->getCapturedStmt());
+  }
 }
 
 void ASTDumper::VisitStmt(const Stmt *Node) {
@@ -1567,6 +1571,26 @@
   dumpPointer(Node->getLabel());
 }
 
+void ASTDumper::VisitCapturedStmt(const CapturedStmt *Node) {
+  VisitStmt(Node);
+  for (CapturedStmt::const_capture_iterator I = Node->capture_begin(),
+                                            E = Node->capture_end();
+                                            I != E; ++I) {
+    IndentScope Indent(*this);
+    OS << "Capture ";
+    switch (I->getCaptureKind()) {
+    case CapturedStmt::VCK_This:
+      OS << "this";
+      break;
+    case CapturedStmt::VCK_ByRef:
+      OS << "byref ";
+      dumpBareDeclRef(I->getCapturedVar());
+      break;
+    }
+  }
+  dumpDecl(Node->getCapturedDecl());
+}
+
 void ASTDumper::VisitCXXCatchStmt(const CXXCatchStmt *Node) {
   VisitStmt(Node);
   dumpDecl(Node->getExceptionDecl());
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/CXXInheritance.cpp cfe-3.5.0.src.omp/lib/AST/CXXInheritance.cpp
--- cfe-3.5.0.src/lib/AST/CXXInheritance.cpp	2014-05-12 01:36:57.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/CXXInheritance.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -437,6 +437,24 @@
   return false;
 }
 
+bool CXXRecordDecl::FindOMPDeclareReductionMember(const CXXBaseSpecifier *Specifier, 
+                                                  CXXBasePath &Path,
+                                                  void *Name) {
+  RecordDecl *BaseRecord =
+    Specifier->getType()->castAs<RecordType>()->getDecl();
+  
+  const unsigned IDNS = IDNS_OMPDeclareReduction;
+  DeclarationName N = DeclarationName::getFromOpaquePtr(Name);
+  for (Path.Decls = BaseRecord->lookup(N);
+       !Path.Decls.empty();
+       Path.Decls = Path.Decls.slice(1)) {
+    if (Path.Decls.front()->isInIdentifierNamespace(IDNS))
+      return true;
+  }
+  
+  return false;
+}
+
 void OverridingMethods::add(unsigned OverriddenSubobject, 
                             UniqueVirtualMethod Overriding) {
   SmallVectorImpl<UniqueVirtualMethod> &SubobjectOverrides
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/Decl.cpp cfe-3.5.0.src.omp/lib/AST/Decl.cpp
--- cfe-3.5.0.src/lib/AST/Decl.cpp	2014-07-02 19:08:34.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/Decl.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -18,6 +18,7 @@
 #include "clang/AST/Attr.h"
 #include "clang/AST/DeclCXX.h"
 #include "clang/AST/DeclObjC.h"
+#include "clang/AST/DeclOpenMP.h"
 #include "clang/AST/DeclTemplate.h"
 #include "clang/AST/Expr.h"
 #include "clang/AST/ExprCXX.h"
@@ -1449,6 +1450,9 @@
   if (isa<ObjCMethodDecl>(this))
     return false;
 
+  if (isa<OMPDeclareReductionDecl>(this))
+    return false;
+
   // FIXME: Is this correct if one of the decls comes from an inline namespace?
   if (isa<ObjCInterfaceDecl>(this) && isa<ObjCCompatibleAliasDecl>(OldD))
     return true;
@@ -3713,14 +3717,20 @@
 
 CapturedDecl *CapturedDecl::Create(ASTContext &C, DeclContext *DC,
                                    unsigned NumParams) {
-  return new (C, DC, NumParams * sizeof(ImplicitParamDecl *))
-      CapturedDecl(DC, NumParams);
+  unsigned Size = sizeof(CapturedDecl) + NumParams * sizeof(ImplicitParamDecl*);
+  CapturedDecl *CD = new (C, DC, Size) CapturedDecl(DC, NumParams);
+  for (unsigned i = 0; i < NumParams; ++i)
+    CD->setParam(i, 0);
+  return CD;
 }
 
 CapturedDecl *CapturedDecl::CreateDeserialized(ASTContext &C, unsigned ID,
-                                               unsigned NumParams) {
-  return new (C, ID, NumParams * sizeof(ImplicitParamDecl *))
-      CapturedDecl(nullptr, NumParams);
+                                   unsigned NumParams) {
+  unsigned Size = sizeof(CapturedDecl) + NumParams * sizeof(ImplicitParamDecl*);
+  CapturedDecl *CD = new (C, ID, Size) CapturedDecl(0, NumParams);
+  for (unsigned i = 0; i < NumParams; ++i)
+    CD->setParam(i, 0);
+  return CD;
 }
 
 EnumConstantDecl *EnumConstantDecl::Create(ASTContext &C, EnumDecl *CD,
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/DeclBase.cpp cfe-3.5.0.src.omp/lib/AST/DeclBase.cpp
--- cfe-3.5.0.src/lib/AST/DeclBase.cpp	2014-05-27 22:16:01.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/DeclBase.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -566,6 +566,9 @@
     case TemplateTemplateParm:
       return IDNS_Ordinary | IDNS_Tag | IDNS_Type;
 
+    case OMPDeclareReduction:
+      return IDNS_OMPDeclareReduction;
+
     // Never have names.
     case Friend:
     case FriendTemplate:
@@ -589,6 +592,8 @@
     case ObjCCategoryImpl:
     case Import:
     case OMPThreadPrivate:
+    case OMPDeclareSimd:
+    case OMPDeclareTarget:
     case Empty:
       // Never looked up by name.
       return 0;
@@ -848,6 +853,8 @@
     return !cast<EnumDecl>(this)->isScoped();
   else if (DeclKind == Decl::LinkageSpec)
     return true;
+  else if (DeclKind == Decl::OMPDeclareTarget)
+    return true;
 
   return false;
 }
@@ -886,6 +893,8 @@
   case Decl::LinkageSpec:
   case Decl::Block:
   case Decl::Captured:
+  case Decl::OMPDeclareReduction:
+  case Decl::OMPDeclareTarget:
     // There is only one DeclContext for these entities.
     return this;
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/DeclOpenMP.cpp cfe-3.5.0.src.omp/lib/AST/DeclOpenMP.cpp
--- cfe-3.5.0.src/lib/AST/DeclOpenMP.cpp	2014-05-12 01:36:57.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/DeclOpenMP.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -7,7 +7,8 @@
 //
 //===----------------------------------------------------------------------===//
 /// \file
-/// \brief This file implements OMPThreadPrivateDecl class.
+/// \brief This file implements OMPThreadPrivateDecl, OMPDeclareReduction,
+/// OMPDeclareTarget classes.
 ///
 //===----------------------------------------------------------------------===//
 
@@ -23,7 +24,7 @@
 // OMPThreadPrivateDecl Implementation.
 //===----------------------------------------------------------------------===//
 
-void OMPThreadPrivateDecl::anchor() { }
+void OMPThreadPrivateDecl::anchor() {}
 
 OMPThreadPrivateDecl *OMPThreadPrivateDecl::Create(ASTContext &C,
                                                    DeclContext *DC,
@@ -40,7 +41,7 @@
                                                                unsigned ID,
                                                                unsigned N) {
   OMPThreadPrivateDecl *D = new (C, ID, N * sizeof(Expr *))
-      OMPThreadPrivateDecl(OMPThreadPrivate, nullptr, SourceLocation());
+      OMPThreadPrivateDecl(OMPThreadPrivate, 0, SourceLocation());
   D->NumVars = N;
   return D;
 }
@@ -52,3 +53,155 @@
   std::copy(VL.begin(), VL.end(), Vars);
 }
 
+//===----------------------------------------------------------------------===//
+// OMPDeclareSimd Implementation.
+//===----------------------------------------------------------------------===//
+
+void OMPDeclareSimdDecl::anchor() {}
+
+unsigned OMPDeclareSimdDecl::getFirstVariantOffset() {
+  unsigned Size = sizeof(OMPDeclareSimdDecl);
+  Size = llvm::RoundUpToAlignment(
+      Size, llvm::alignOf<OMPDeclareSimdDecl::SimdVariant>());
+  return Size;
+}
+
+unsigned OMPDeclareSimdDecl::getFirstClauseOffset(unsigned NV) {
+  unsigned ESize = llvm::RoundUpToAlignment(
+      sizeof(OMPDeclareSimdDecl::SimdVariant),
+      llvm::alignOf<OMPDeclareSimdDecl::SimdVariant>());
+  unsigned Size = getFirstVariantOffset() + ESize * NV;
+  Size = llvm::RoundUpToAlignment(Size, llvm::alignOf<OMPClause *>());
+  return Size;
+}
+
+unsigned OMPDeclareSimdDecl::getTotalSize(unsigned NV, unsigned NC) {
+  unsigned ESize = llvm::RoundUpToAlignment(sizeof(OMPClause *),
+                                            llvm::alignOf<OMPClause *>());
+  unsigned Size = getFirstClauseOffset(NV) + ESize * NC;
+  Size = llvm::RoundUpToAlignment(Size, llvm::alignOf<OMPDeclareSimdDecl>());
+  return Size;
+}
+
+void
+OMPDeclareSimdDecl::setVariants(ArrayRef<OMPDeclareSimdDecl::SimdVariant> SV) {
+  assert(SV.size() == NumVariants &&
+         "Number of variants is not the same as the preallocated buffer");
+  unsigned Offset = getFirstVariantOffset();
+  OMPDeclareSimdDecl::SimdVariant *Data =
+      reinterpret_cast<OMPDeclareSimdDecl::SimdVariant *>(
+          reinterpret_cast<char *>(this) + Offset);
+  for (unsigned i = 0; i < NumVariants; ++i)
+    Data[i] = SV[i];
+}
+
+void OMPDeclareSimdDecl::setClauses(ArrayRef<OMPClause *> CL) {
+  assert(CL.size() == NumClauses &&
+         "Number of clauses is not the same as the preallocated buffer");
+  unsigned Offset = getFirstClauseOffset(NumVariants);
+  OMPClause **Data =
+      reinterpret_cast<OMPClause **>(reinterpret_cast<char *>(this) + Offset);
+  for (unsigned i = 0; i < NumClauses; ++i)
+    Data[i] = CL[i];
+}
+
+OMPDeclareSimdDecl *OMPDeclareSimdDecl::Create(ASTContext &C, DeclContext *DC,
+                                               SourceLocation L, Decl *FuncDecl,
+                                               unsigned NV,
+                                               ArrayRef<OMPClause *> CL) {
+  unsigned NC = CL.size();
+  unsigned Size = getTotalSize(NV, NC);
+  OMPDeclareSimdDecl *D = new (C, DC, Size - sizeof(OMPDeclareSimdDecl))
+      OMPDeclareSimdDecl(OMPDeclareSimd, DC, L, NV, NC);
+  D->FuncDecl = FuncDecl;
+  D->setClauses(CL);
+  return D;
+}
+
+OMPDeclareSimdDecl *OMPDeclareSimdDecl::CreateDeserialized(ASTContext &C,
+                                                           unsigned ID,
+                                                           unsigned NV,
+                                                           unsigned NC) {
+  unsigned Size = getTotalSize(NV, NC);
+  OMPDeclareSimdDecl *D = new (C, ID, Size - sizeof(OMPDeclareSimdDecl))
+      OMPDeclareSimdDecl(OMPDeclareSimd, 0, SourceLocation(), NV, NC);
+  D->FuncDecl = 0;
+  return D;
+}
+
+//===----------------------------------------------------------------------===//
+// OMPDeclareReductionDecl Implementation.
+//===----------------------------------------------------------------------===//
+
+void OMPDeclareReductionDecl::anchor() {}
+
+unsigned OMPDeclareReductionDecl::getFirstElementOffset() {
+  unsigned Size = sizeof(OMPDeclareReductionDecl);
+  // Realign
+  Size = llvm::RoundUpToAlignment(
+      Size, llvm::alignOf<OMPDeclareReductionDecl::ReductionData>());
+  return Size;
+}
+
+OMPDeclareReductionDecl *OMPDeclareReductionDecl::Create(ASTContext &C,
+                                                         DeclContext *DC,
+                                                         SourceLocation L,
+                                                         DeclarationName Name,
+                                                         unsigned N) {
+  unsigned Size = getFirstElementOffset() +
+                  N * sizeof(OMPDeclareReductionDecl::ReductionData);
+
+  OMPDeclareReductionDecl *D =
+      new (C, DC, Size - sizeof(OMPDeclareReductionDecl))
+          OMPDeclareReductionDecl(OMPDeclareReduction, DC, L, Name);
+  D->NumTypes = N;
+  return D;
+}
+
+OMPDeclareReductionDecl *
+OMPDeclareReductionDecl::CreateDeserialized(ASTContext &C, unsigned ID,
+                                            unsigned N) {
+  unsigned Size = getFirstElementOffset() +
+                  N * sizeof(OMPDeclareReductionDecl::ReductionData);
+
+  OMPDeclareReductionDecl *D =
+      new (C, ID, Size - sizeof(OMPDeclareReductionDecl))
+          OMPDeclareReductionDecl(OMPDeclareReduction, 0, SourceLocation(),
+                                  DeclarationName());
+  D->NumTypes = N;
+  return D;
+}
+
+void OMPDeclareReductionDecl::setData(
+    ArrayRef<OMPDeclareReductionDecl::ReductionData> RD) {
+  assert(RD.size() == NumTypes &&
+         "Number of inits is not the same as the preallocated buffer");
+  unsigned Size = getFirstElementOffset();
+  OMPDeclareReductionDecl::ReductionData *Data =
+      reinterpret_cast<OMPDeclareReductionDecl::ReductionData *>(
+          reinterpret_cast<char *>(this) + Size);
+  for (unsigned i = 0; i < NumTypes; ++i)
+    Data[i] = RD[i];
+  // std::copy(RD.begin(), RD.end(), Data);
+}
+
+//===----------------------------------------------------------------------===//
+// OMPDeclareTargetDecl Implementation.
+//===----------------------------------------------------------------------===//
+
+void OMPDeclareTargetDecl::anchor() {}
+
+OMPDeclareTargetDecl *
+OMPDeclareTargetDecl::Create(ASTContext &C, DeclContext *DC, SourceLocation L) {
+  OMPDeclareTargetDecl *D =
+      new (C, DC) OMPDeclareTargetDecl(OMPDeclareTarget, DC, L);
+  return D;
+}
+
+OMPDeclareTargetDecl *OMPDeclareTargetDecl::CreateDeserialized(ASTContext &C,
+                                                               unsigned ID) {
+  // Realign
+  OMPDeclareTargetDecl *D =
+      new (C, ID) OMPDeclareTargetDecl(OMPDeclareTarget, 0, SourceLocation());
+  return D;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/DeclPrinter.cpp cfe-3.5.0.src.omp/lib/AST/DeclPrinter.cpp
--- cfe-3.5.0.src/lib/AST/DeclPrinter.cpp	2014-06-09 18:53:25.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/DeclPrinter.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -83,6 +83,9 @@
     void VisitUsingDecl(UsingDecl *D);
     void VisitUsingShadowDecl(UsingShadowDecl *D);
     void VisitOMPThreadPrivateDecl(OMPThreadPrivateDecl *D);
+    void VisitOMPDeclareSimdDecl(OMPDeclareSimdDecl *D);
+    void VisitOMPDeclareReductionDecl(OMPDeclareReductionDecl *D);
+    void VisitOMPDeclareTargetDecl(OMPDeclareTargetDecl *D);
 
     void PrintTemplateParameters(const TemplateParameterList *Params,
                                  const TemplateArgumentList *Args = nullptr);
@@ -283,8 +286,21 @@
 
     // FIXME: Need to be able to tell the DeclPrinter when
     const char *Terminator = nullptr;
-    if (isa<OMPThreadPrivateDecl>(*D))
+    if (isa<OMPThreadPrivateDecl>(*D) || isa<OMPDeclareReductionDecl>(*D) ||
+        isa<OMPDeclareTargetDecl>(*D))
       Terminator = nullptr;
+    else if (isa<OMPDeclareSimdDecl>(*D)) {
+      if (FunctionDecl *Func = dyn_cast_or_null<FunctionDecl>(
+            cast<OMPDeclareSimdDecl>(*D)->getFunction())) {
+        if (Func->isThisDeclarationADefinition())
+          Terminator = nullptr;
+        else
+          Terminator = ";";
+      }
+      else {
+        Terminator = nullptr;
+      }
+    }
     else if (isa<FunctionDecl>(*D) &&
              cast<FunctionDecl>(*D)->isThisDeclarationADefinition())
       Terminator = nullptr;
@@ -1196,3 +1212,86 @@
   }
 }
 
+void DeclPrinter::VisitOMPDeclareSimdDecl(OMPDeclareSimdDecl *D) {
+  for (OMPDeclareSimdDecl::simd_variants_iterator
+        I = D->simd_variants_begin(),
+        E = D->simd_variants_end();
+        I != E; ++I) {
+    Out << "#pragma omp declare simd";
+    for (unsigned J = I->BeginIdx, F = I->EndIdx; J != F; ++J) {
+      Out << " ";
+      if (*(D->clauses_begin() + J) &&
+        !(*(D->clauses_begin() + J))->isImplicit()) {
+        const OMPClause *CurCL = cast_or_null<OMPClause>(
+                                   *(D->clauses_begin() + J));
+        CurCL->printPretty(Out, 0, Policy, Indentation);
+      }
+    }
+    Out << "\n";
+  }
+  Decl *FuncDecl = D->getFunction();
+  assert(FuncDecl && "Pragma has no function declaration (omp declare simd)");
+  Visit(FuncDecl);
+}
+
+
+void DeclPrinter::VisitOMPDeclareReductionDecl(OMPDeclareReductionDecl *D) {
+  if (!D->isInvalidDecl() && !D->datalist_empty()) {
+    for (OMPDeclareReductionDecl::datalist_iterator I = D->datalist_begin(),
+                                                    E = D->datalist_end();
+         I != E; ++I) {
+      Out << "#pragma omp declare reduction (";
+      D->printName(Out);
+      Out << " : ";
+      I->QTy.print(Out, Policy);
+      Out << " : ";
+      FunctionDecl *CF =
+        cast<FunctionDecl>(cast<DeclRefExpr>(I->CombinerFunction)->getDecl());
+      CompoundStmt::body_iterator BI =
+        cast<CompoundStmt>(CF->getBody())->body_begin();
+      // Skip first 2 DeclStmts;
+      ++BI;
+      ++BI;
+      (*BI)->printPretty(Out, 0, Policy, 0);
+      Out << ")";
+      FunctionDecl *IF =
+        cast<FunctionDecl>(cast<DeclRefExpr>(I->InitFunction)->getDecl());
+      if (IF->getBody() == 0) continue;
+      BI = cast<CompoundStmt>(IF->getBody())->body_begin();
+      // Skip first 2 DeclStmts;
+      ++BI;
+      if (DeclStmt *DS = dyn_cast<DeclStmt>(*BI)) {
+        if (VarDecl *VD =
+              dyn_cast_or_null<VarDecl>(DS->getSingleDecl())) {
+          if (VD->hasInit() && VD->getInit()->getLocStart().isValid()) {
+            Out << " initializer(omp_priv ";
+            if (!Policy.LangOpts.CPlusPlus) {
+              Out << "= ";
+            }
+            VD->getInit()->printPretty(Out, 0, Policy, 0);
+            Out << ")\n";
+            return;
+          }
+        }
+        ++BI;
+      }
+      // Skip DeclStmt.
+      // Check if next stmt is explicit function call.
+      if (CallExpr *CE = dyn_cast_or_null<CallExpr>((*BI)->IgnoreImplicit())) {
+        if (CE->getLocStart().isValid()) {
+          Out << " initializer(";
+          CE->printPretty(Out, 0, Policy, 0);
+          Out << ")";
+        }
+      }
+      Out << "\n";
+    }
+  }
+}
+
+void DeclPrinter::VisitOMPDeclareTargetDecl(OMPDeclareTargetDecl *D) {
+  Out << "#pragma omp declare target\n";
+  VisitDeclContext(D);
+  Out << "#pragma omp end declare target\n";
+}
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/Expr.cpp cfe-3.5.0.src.omp/lib/AST/Expr.cpp
--- cfe-3.5.0.src/lib/AST/Expr.cpp	2014-07-18 18:59:10.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/Expr.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -2049,6 +2049,7 @@
   case CompoundAssignOperatorClass:
   case VAArgExprClass:
   case AtomicExprClass:
+  case CEANIndexExprClass:
     return false;
 
   case ConditionalOperatorClass: {
@@ -2898,6 +2899,7 @@
   case CXXBindTemporaryExprClass:
   case BlockExprClass:
   case CUDAKernelCallExprClass:
+  case CEANIndexExprClass:
     // These always have a side-effect.
     return true;
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/ExprClassification.cpp cfe-3.5.0.src.omp/lib/AST/ExprClassification.cpp
--- cfe-3.5.0.src/lib/AST/ExprClassification.cpp	2014-05-12 01:36:57.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/ExprClassification.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -181,6 +181,7 @@
   case Expr::AsTypeExprClass:
   case Expr::ObjCIndirectCopyRestoreExprClass:
   case Expr::AtomicExprClass:
+  case Expr::CEANIndexExprClass:
     return Cl::CL_PRValue;
 
     // Next come the complicated cases.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/ExprConstant.cpp cfe-3.5.0.src.omp/lib/AST/ExprConstant.cpp
--- cfe-3.5.0.src/lib/AST/ExprConstant.cpp	2014-08-04 14:31:55.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/ExprConstant.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -8373,6 +8373,7 @@
   case Expr::PseudoObjectExprClass:
   case Expr::AtomicExprClass:
   case Expr::LambdaExprClass:
+  case Expr::CEANIndexExprClass:
     return ICEDiag(IK_NotICE, E->getLocStart());
 
   case Expr::InitListExprClass: {
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/ItaniumMangle.cpp cfe-3.5.0.src.omp/lib/AST/ItaniumMangle.cpp
--- cfe-3.5.0.src/lib/AST/ItaniumMangle.cpp	2014-07-15 17:32:31.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/ItaniumMangle.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -20,6 +20,7 @@
 #include "clang/AST/Decl.h"
 #include "clang/AST/DeclCXX.h"
 #include "clang/AST/DeclObjC.h"
+#include "clang/AST/DeclOpenMP.h"
 #include "clang/AST/DeclTemplate.h"
 #include "clang/AST/Expr.h"
 #include "clang/AST/ExprCXX.h"
@@ -68,6 +69,8 @@
   const DeclContext *DC = D->getDeclContext();
   if (const CapturedDecl *CD = dyn_cast<CapturedDecl>(DC))
     return getEffectiveDeclContext(CD);
+  if (auto *DR = dyn_cast<OMPDeclareReductionDecl>(DC))
+    return getEffectiveDeclContext(DR);
 
   return DC;
 }
@@ -2648,6 +2651,7 @@
   case Expr::AsTypeExprClass:
   case Expr::PseudoObjectExprClass:
   case Expr::AtomicExprClass:
+  case Expr::CEANIndexExprClass:
   {
     // As bad as this diagnostic is, it's better than crashing.
     DiagnosticsEngine &Diags = Context.getDiags();
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/MicrosoftMangle.cpp cfe-3.5.0.src.omp/lib/AST/MicrosoftMangle.cpp
--- cfe-3.5.0.src/lib/AST/MicrosoftMangle.cpp	2014-06-28 19:22:33.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/MicrosoftMangle.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -19,6 +19,7 @@
 #include "clang/AST/Decl.h"
 #include "clang/AST/DeclCXX.h"
 #include "clang/AST/DeclObjC.h"
+#include "clang/AST/DeclOpenMP.h"
 #include "clang/AST/DeclTemplate.h"
 #include "clang/AST/Expr.h"
 #include "clang/AST/ExprCXX.h"
@@ -60,6 +61,8 @@
   const DeclContext *DC = D->getDeclContext();
   if (const CapturedDecl *CD = dyn_cast<CapturedDecl>(DC))
     return getEffectiveDeclContext(CD);
+  if (auto *RD = dyn_cast<OMPDeclareReductionDecl>(DC))
+    return getEffectiveDeclContext(RD);
 
   return DC;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/Stmt.cpp cfe-3.5.0.src.omp/lib/AST/Stmt.cpp
--- cfe-3.5.0.src/lib/AST/Stmt.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/Stmt.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -31,7 +31,7 @@
   const char *Name;
   unsigned Counter;
   unsigned Size;
-} StmtClassInfo[Stmt::lastStmtConstant+1];
+} StmtClassInfo[Stmt::lastStmtConstant + 1];
 
 static StmtClassNameTable &getStmtInfoTableEntry(Stmt::StmtClass E) {
   static bool Initialized = false;
@@ -41,21 +41,21 @@
   // Intialize the table on the first use.
   Initialized = true;
 #define ABSTRACT_STMT(STMT)
-#define STMT(CLASS, PARENT) \
-  StmtClassInfo[(unsigned)Stmt::CLASS##Class].Name = #CLASS;    \
+#define STMT(CLASS, PARENT)                                                    \
+  StmtClassInfo[(unsigned)Stmt::CLASS##Class].Name = #CLASS;                   \
   StmtClassInfo[(unsigned)Stmt::CLASS##Class].Size = sizeof(CLASS);
 #include "clang/AST/StmtNodes.inc"
 
   return StmtClassInfo[E];
 }
 
-void *Stmt::operator new(size_t bytes, const ASTContext& C,
+void *Stmt::operator new(size_t bytes, const ASTContext &C,
                          unsigned alignment) {
   return ::operator new(bytes, C, alignment);
 }
 
 const char *Stmt::getStmtClassName() const {
-  return getStmtInfoTableEntry((StmtClass) StmtBits.sClass).Name;
+  return getStmtInfoTableEntry((StmtClass)StmtBits.sClass).Name;
 }
 
 void Stmt::PrintStats() {
@@ -75,22 +75,19 @@
     if (StmtClassInfo[i].Counter == 0) continue;
     llvm::errs() << "    " << StmtClassInfo[i].Counter << " "
                  << StmtClassInfo[i].Name << ", " << StmtClassInfo[i].Size
-                 << " each (" << StmtClassInfo[i].Counter*StmtClassInfo[i].Size
+                 << " each ("
+                 << StmtClassInfo[i].Counter * StmtClassInfo[i].Size
                  << " bytes)\n";
-    sum += StmtClassInfo[i].Counter*StmtClassInfo[i].Size;
+    sum += StmtClassInfo[i].Counter * StmtClassInfo[i].Size;
   }
 
   llvm::errs() << "Total bytes = " << sum << "\n";
 }
 
-void Stmt::addStmtClass(StmtClass s) {
-  ++getStmtInfoTableEntry(s).Counter;
-}
+void Stmt::addStmtClass(StmtClass s) { ++getStmtInfoTableEntry(s).Counter; }
 
 bool Stmt::StatisticsEnabled = false;
-void Stmt::EnableStatistics() {
-  StatisticsEnabled = true;
-}
+void Stmt::EnableStatistics() { StatisticsEnabled = true; }
 
 Stmt *Stmt::IgnoreImplicit() {
   Stmt *s = this;
@@ -123,46 +120,40 @@
 }
 
 namespace {
-  struct good {};
-  struct bad {};
+struct good {};
+struct bad {};
 
-  // These silly little functions have to be static inline to suppress
-  // unused warnings, and they have to be defined to suppress other
-  // warnings.
-  static inline good is_good(good) { return good(); }
+// These silly little functions have to be static inline to suppress
+// unused warnings, and they have to be defined to suppress other
+// warnings.
+static inline good is_good(good) { return good(); }
 
-  typedef Stmt::child_range children_t();
-  template <class T> good implements_children(children_t T::*) {
-    return good();
-  }
-  LLVM_ATTRIBUTE_UNUSED
-  static inline bad implements_children(children_t Stmt::*) {
-    return bad();
-  }
+typedef Stmt::child_range children_t();
+template <class T> good implements_children(children_t T::*) { return good(); }
+LLVM_ATTRIBUTE_UNUSED
+static inline bad implements_children(children_t Stmt::*) { return bad(); }
 
-  typedef SourceLocation getLocStart_t() const;
-  template <class T> good implements_getLocStart(getLocStart_t T::*) {
-    return good();
-  }
-  LLVM_ATTRIBUTE_UNUSED
-  static inline bad implements_getLocStart(getLocStart_t Stmt::*) {
-    return bad();
-  }
+typedef SourceLocation getLocStart_t() const;
+template <class T> good implements_getLocStart(getLocStart_t T::*) {
+  return good();
+}
+LLVM_ATTRIBUTE_UNUSED
+static inline bad implements_getLocStart(getLocStart_t Stmt::*) {
+  return bad();
+}
 
-  typedef SourceLocation getLocEnd_t() const;
-  template <class T> good implements_getLocEnd(getLocEnd_t T::*) {
-    return good();
-  }
-  LLVM_ATTRIBUTE_UNUSED
-  static inline bad implements_getLocEnd(getLocEnd_t Stmt::*) {
-    return bad();
-  }
+typedef SourceLocation getLocEnd_t() const;
+template <class T> good implements_getLocEnd(getLocEnd_t T::*) {
+  return good();
+}
+LLVM_ATTRIBUTE_UNUSED
+static inline bad implements_getLocEnd(getLocEnd_t Stmt::*) { return bad(); }
 
-#define ASSERT_IMPLEMENTS_children(type) \
+#define ASSERT_IMPLEMENTS_children(type)                                       \
   (void) is_good(implements_children(&type::children))
-#define ASSERT_IMPLEMENTS_getLocStart(type) \
+#define ASSERT_IMPLEMENTS_getLocStart(type)                                    \
   (void) is_good(implements_getLocStart(&type::getLocStart))
-#define ASSERT_IMPLEMENTS_getLocEnd(type) \
+#define ASSERT_IMPLEMENTS_getLocEnd(type)                                      \
   (void) is_good(implements_getLocEnd(&type::getLocEnd))
 }
 
@@ -171,20 +162,21 @@
 LLVM_ATTRIBUTE_UNUSED
 static inline void check_implementations() {
 #define ABSTRACT_STMT(type)
-#define STMT(type, base) \
-  ASSERT_IMPLEMENTS_children(type); \
-  ASSERT_IMPLEMENTS_getLocStart(type); \
+#define STMT(type, base)                                                       \
+  ASSERT_IMPLEMENTS_children(type);                                            \
+  ASSERT_IMPLEMENTS_getLocStart(type);                                         \
   ASSERT_IMPLEMENTS_getLocEnd(type);
 #include "clang/AST/StmtNodes.inc"
 }
 
 Stmt::child_range Stmt::children() {
   switch (getStmtClass()) {
-  case Stmt::NoStmtClass: llvm_unreachable("statement without class");
+  case Stmt::NoStmtClass:
+    llvm_unreachable("statement without class");
 #define ABSTRACT_STMT(type)
-#define STMT(type, base) \
-  case Stmt::type##Class: \
-    return static_cast<type*>(this)->children();
+#define STMT(type, base)                                                       \
+  case Stmt::type##Class:                                                      \
+    return static_cast<type *>(this)->children();
 #include "clang/AST/StmtNodes.inc"
   }
   llvm_unreachable("unknown statement kind!");
@@ -195,32 +187,32 @@
 //
 // See also Expr.cpp:getExprLoc().
 namespace {
-  /// This implementation is used when a class provides a custom
-  /// implementation of getSourceRange.
-  template <class S, class T>
-  SourceRange getSourceRangeImpl(const Stmt *stmt,
-                                 SourceRange (T::*v)() const) {
-    return static_cast<const S*>(stmt)->getSourceRange();
-  }
-
-  /// This implementation is used when a class doesn't provide a custom
-  /// implementation of getSourceRange.  Overload resolution should pick it over
-  /// the implementation above because it's more specialized according to
-  /// function template partial ordering.
-  template <class S>
-  SourceRange getSourceRangeImpl(const Stmt *stmt,
-                                 SourceRange (Stmt::*v)() const) {
-    return SourceRange(static_cast<const S*>(stmt)->getLocStart(),
-                       static_cast<const S*>(stmt)->getLocEnd());
-  }
+/// This implementation is used when a class provides a custom
+/// implementation of getSourceRange.
+template <class S, class T>
+SourceRange getSourceRangeImpl(const Stmt *stmt, SourceRange (T::*v)() const) {
+  return static_cast<const S *>(stmt)->getSourceRange();
+}
+
+/// This implementation is used when a class doesn't provide a custom
+/// implementation of getSourceRange.  Overload resolution should pick it over
+/// the implementation above because it's more specialized according to
+/// function template partial ordering.
+template <class S>
+SourceRange getSourceRangeImpl(const Stmt *stmt,
+                               SourceRange (Stmt::*v)() const) {
+  return SourceRange(static_cast<const S *>(stmt)->getLocStart(),
+                     static_cast<const S *>(stmt)->getLocEnd());
+}
 }
 
 SourceRange Stmt::getSourceRange() const {
   switch (getStmtClass()) {
-  case Stmt::NoStmtClass: llvm_unreachable("statement without class");
+  case Stmt::NoStmtClass:
+    llvm_unreachable("statement without class");
 #define ABSTRACT_STMT(type)
-#define STMT(type, base) \
-  case Stmt::type##Class: \
+#define STMT(type, base)                                                       \
+  case Stmt::type##Class:                                                      \
     return getSourceRangeImpl<type>(this, &type::getSourceRange);
 #include "clang/AST/StmtNodes.inc"
   }
@@ -228,13 +220,14 @@
 }
 
 SourceLocation Stmt::getLocStart() const {
-//  llvm::errs() << "getLocStart() for " << getStmtClassName() << "\n";
+  //  llvm::errs() << "getLocStart() for " << getStmtClassName() << "\n";
   switch (getStmtClass()) {
-  case Stmt::NoStmtClass: llvm_unreachable("statement without class");
+  case Stmt::NoStmtClass:
+    llvm_unreachable("statement without class");
 #define ABSTRACT_STMT(type)
-#define STMT(type, base) \
-  case Stmt::type##Class: \
-    return static_cast<const type*>(this)->getLocStart();
+#define STMT(type, base)                                                       \
+  case Stmt::type##Class:                                                      \
+    return static_cast<const type *>(this)->getLocStart();
 #include "clang/AST/StmtNodes.inc"
   }
   llvm_unreachable("unknown statement kind");
@@ -242,19 +235,20 @@
 
 SourceLocation Stmt::getLocEnd() const {
   switch (getStmtClass()) {
-  case Stmt::NoStmtClass: llvm_unreachable("statement without class");
+  case Stmt::NoStmtClass:
+    llvm_unreachable("statement without class");
 #define ABSTRACT_STMT(type)
-#define STMT(type, base) \
-  case Stmt::type##Class: \
-    return static_cast<const type*>(this)->getLocEnd();
+#define STMT(type, base)                                                       \
+  case Stmt::type##Class:                                                      \
+    return static_cast<const type *>(this)->getLocEnd();
 #include "clang/AST/StmtNodes.inc"
   }
   llvm_unreachable("unknown statement kind");
 }
 
-CompoundStmt::CompoundStmt(const ASTContext &C, ArrayRef<Stmt*> Stmts,
+CompoundStmt::CompoundStmt(const ASTContext &C, ArrayRef<Stmt *> Stmts,
                            SourceLocation LB, SourceLocation RB)
-  : Stmt(CompoundStmtClass), LBracLoc(LB), RBracLoc(RB) {
+    : Stmt(CompoundStmtClass), LBracLoc(LB), RBracLoc(RB) {
   CompoundStmtBits.NumStmts = Stmts.size();
   assert(CompoundStmtBits.NumStmts == Stmts.size() &&
          "NumStmts doesn't fit in bits of CompoundStmtBits.NumStmts!");
@@ -264,7 +258,7 @@
     return;
   }
 
-  Body = new (C) Stmt*[Stmts.size()];
+  Body = new (C) Stmt *[Stmts.size()];
   std::copy(Stmts.begin(), Stmts.end(), Body);
 }
 
@@ -274,7 +268,7 @@
     C.Deallocate(Body);
   this->CompoundStmtBits.NumStmts = NumStmts;
 
-  Body = new (C) Stmt*[NumStmts];
+  Body = new (C) Stmt *[NumStmts];
   memcpy(Body, Stmts, sizeof(Stmt *) * NumStmts);
 }
 
@@ -283,7 +277,7 @@
 }
 
 AttributedStmt *AttributedStmt::Create(const ASTContext &C, SourceLocation Loc,
-                                       ArrayRef<const Attr*> Attrs,
+                                       ArrayRef<const Attr *> Attrs,
                                        Stmt *SubStmt) {
   assert(!Attrs.empty() && "Attrs should not be empty");
   void *Mem = C.Allocate(sizeof(AttributedStmt) + sizeof(Attr *) * Attrs.size(),
@@ -361,9 +355,7 @@
   return getClobberStringLiteral(i)->getString();
 }
 
-Expr *GCCAsmStmt::getOutputExpr(unsigned i) {
-  return cast<Expr>(Exprs[i]);
-}
+Expr *GCCAsmStmt::getOutputExpr(unsigned i) { return cast<Expr>(Exprs[i]); }
 
 /// getOutputConstraint - Return the constraint string for the specified
 /// output operand.  All output constraints are known to be non-empty (either
@@ -385,14 +377,10 @@
   return getInputConstraintLiteral(i)->getString();
 }
 
-void GCCAsmStmt::setOutputsAndInputsAndClobbers(const ASTContext &C,
-                                                IdentifierInfo **Names,
-                                                StringLiteral **Constraints,
-                                                Stmt **Exprs,
-                                                unsigned NumOutputs,
-                                                unsigned NumInputs,
-                                                StringLiteral **Clobbers,
-                                                unsigned NumClobbers) {
+void GCCAsmStmt::setOutputsAndInputsAndClobbers(
+    const ASTContext &C, IdentifierInfo **Names, StringLiteral **Constraints,
+    Stmt **Exprs, unsigned NumOutputs, unsigned NumInputs,
+    StringLiteral **Clobbers, unsigned NumClobbers) {
   this->NumOutputs = NumOutputs;
   this->NumInputs = NumInputs;
   this->NumClobbers = NumClobbers;
@@ -400,19 +388,19 @@
   unsigned NumExprs = NumOutputs + NumInputs;
 
   C.Deallocate(this->Names);
-  this->Names = new (C) IdentifierInfo*[NumExprs];
+  this->Names = new (C) IdentifierInfo *[NumExprs];
   std::copy(Names, Names + NumExprs, this->Names);
 
   C.Deallocate(this->Exprs);
-  this->Exprs = new (C) Stmt*[NumExprs];
+  this->Exprs = new (C) Stmt *[NumExprs];
   std::copy(Exprs, Exprs + NumExprs, this->Exprs);
 
   C.Deallocate(this->Constraints);
-  this->Constraints = new (C) StringLiteral*[NumExprs];
+  this->Constraints = new (C) StringLiteral *[NumExprs];
   std::copy(Constraints, Constraints + NumExprs, this->Constraints);
 
   C.Deallocate(this->Clobbers);
-  this->Clobbers = new (C) StringLiteral*[NumClobbers];
+  this->Clobbers = new (C) StringLiteral *[NumClobbers];
   std::copy(Clobbers, Clobbers + NumClobbers, this->Clobbers);
 }
 
@@ -439,8 +427,9 @@
 /// AnalyzeAsmString - Analyze the asm string of the current asm, decomposing
 /// it into pieces.  If the asm string is erroneous, emit errors and return
 /// true, otherwise return false.
-unsigned GCCAsmStmt::AnalyzeAsmString(SmallVectorImpl<AsmStringPiece>&Pieces,
-                                const ASTContext &C, unsigned &DiagOffs) const {
+unsigned GCCAsmStmt::AnalyzeAsmString(SmallVectorImpl<AsmStringPiece> &Pieces,
+                                      const ASTContext &C,
+                                      unsigned &DiagOffs) const {
   StringRef Str = getAsmString()->getString();
   const char *StrStart = Str.begin();
   const char *StrEnd = Str.end();
@@ -480,10 +469,18 @@
 
     char CurChar = *CurPtr++;
     switch (CurChar) {
-    case '$': CurStringPiece += "$$"; continue;
-    case '{': CurStringPiece += (HasVariants ? "$(" : "{"); continue;
-    case '|': CurStringPiece += (HasVariants ? "$|" : "|"); continue;
-    case '}': CurStringPiece += (HasVariants ? "$)" : "}"); continue;
+    case '$':
+      CurStringPiece += "$$";
+      continue;
+    case '{':
+      CurStringPiece += (HasVariants ? "$(" : "{");
+      continue;
+    case '|':
+      CurStringPiece += (HasVariants ? "$|" : "|");
+      continue;
+    case '}':
+      CurStringPiece += (HasVariants ? "$)" : "}");
+      continue;
     case '%':
       break;
     default:
@@ -494,18 +491,18 @@
     // Escaped "%" character in asm string.
     if (CurPtr == StrEnd) {
       // % at end of string is invalid (no escape).
-      DiagOffs = CurPtr-StrStart-1;
+      DiagOffs = CurPtr - StrStart - 1;
       return diag::err_asm_invalid_escape;
     }
 
     char EscapedChar = *CurPtr++;
-    if (EscapedChar == '%') {  // %% -> %
+    if (EscapedChar == '%') { // %% -> %
       // Escaped percentage sign.
       CurStringPiece += '%';
       continue;
     }
 
-    if (EscapedChar == '=') {  // %= -> Generate an unique ID.
+    if (EscapedChar == '=') { // %= -> Generate an unique ID.
       CurStringPiece += "${:uid}";
       continue;
     }
@@ -521,7 +518,7 @@
     char Modifier = '\0';
     if (isLetter(EscapedChar)) {
       if (CurPtr == StrEnd) { // Premature end.
-        DiagOffs = CurPtr-StrStart-1;
+        DiagOffs = CurPtr - StrStart - 1;
         return diag::err_asm_invalid_escape;
       }
       Modifier = EscapedChar;
@@ -534,12 +531,12 @@
 
       --CurPtr;
       while (CurPtr != StrEnd && isDigit(*CurPtr))
-        N = N*10 + ((*CurPtr++)-'0');
+        N = N * 10 + ((*CurPtr++) - '0');
 
       unsigned NumOperands =
-        getNumOutputs() + getNumPlusOperands() + getNumInputs();
+          getNumOutputs() + getNumPlusOperands() + getNumInputs();
       if (N >= NumOperands) {
-        DiagOffs = CurPtr-StrStart-1;
+        DiagOffs = CurPtr - StrStart - 1;
         return diag::err_asm_invalid_operand_number;
       }
 
@@ -549,7 +546,7 @@
 
     // Handle %[foo], a symbolic operand reference.
     if (EscapedChar == '[') {
-      DiagOffs = CurPtr-StrStart-1;
+      DiagOffs = CurPtr - StrStart - 1;
 
       // Find the ']'.
       const char *NameEnd = (const char*)memchr(CurPtr, ']', StrEnd-CurPtr);
@@ -563,16 +560,16 @@
       int N = getNamedOperand(SymbolicName);
       if (N == -1) {
         // Verify that an operand with that name exists.
-        DiagOffs = CurPtr-StrStart;
+        DiagOffs = CurPtr - StrStart;
         return diag::err_asm_unknown_symbolic_operand_name;
       }
       Pieces.push_back(AsmStringPiece(N, Modifier));
 
-      CurPtr = NameEnd+1;
+      CurPtr = NameEnd + 1;
       continue;
     }
 
-    DiagOffs = CurPtr-StrStart-1;
+    DiagOffs = CurPtr - StrStart - 1;
     return diag::err_asm_invalid_escape;
   }
 }
@@ -604,16 +601,12 @@
   return AsmStr;
 }
 
-Expr *MSAsmStmt::getOutputExpr(unsigned i) {
-  return cast<Expr>(Exprs[i]);
-}
+Expr *MSAsmStmt::getOutputExpr(unsigned i) { return cast<Expr>(Exprs[i]); }
 
 Expr *MSAsmStmt::getInputExpr(unsigned i) {
   return cast<Expr>(Exprs[i + NumOutputs]);
 }
-void MSAsmStmt::setInputExpr(unsigned i, Expr *E) {
-  Exprs[i + NumOutputs] = E;
-}
+void MSAsmStmt::setInputExpr(unsigned i, Expr *E) { Exprs[i + NumOutputs] = E; }
 
 QualType CXXCatchStmt::getCaughtType() const {
   if (ExceptionDecl)
@@ -631,34 +624,34 @@
                        StringLiteral **constraints, Expr **exprs,
                        StringLiteral *asmstr, unsigned numclobbers,
                        StringLiteral **clobbers, SourceLocation rparenloc)
-  : AsmStmt(GCCAsmStmtClass, asmloc, issimple, isvolatile, numoutputs,
-            numinputs, numclobbers), RParenLoc(rparenloc), AsmStr(asmstr) {
+    : AsmStmt(GCCAsmStmtClass, asmloc, issimple, isvolatile, numoutputs,
+              numinputs, numclobbers),
+      RParenLoc(rparenloc), AsmStr(asmstr) {
 
   unsigned NumExprs = NumOutputs + NumInputs;
 
-  Names = new (C) IdentifierInfo*[NumExprs];
+  Names = new (C) IdentifierInfo *[NumExprs];
   std::copy(names, names + NumExprs, Names);
 
-  Exprs = new (C) Stmt*[NumExprs];
+  Exprs = new (C) Stmt *[NumExprs];
   std::copy(exprs, exprs + NumExprs, Exprs);
 
-  Constraints = new (C) StringLiteral*[NumExprs];
+  Constraints = new (C) StringLiteral *[NumExprs];
   std::copy(constraints, constraints + NumExprs, Constraints);
 
-  Clobbers = new (C) StringLiteral*[NumClobbers];
+  Clobbers = new (C) StringLiteral *[NumClobbers];
   std::copy(clobbers, clobbers + NumClobbers, Clobbers);
 }
 
 MSAsmStmt::MSAsmStmt(const ASTContext &C, SourceLocation asmloc,
                      SourceLocation lbraceloc, bool issimple, bool isvolatile,
                      ArrayRef<Token> asmtoks, unsigned numoutputs,
-                     unsigned numinputs,
-                     ArrayRef<StringRef> constraints, ArrayRef<Expr*> exprs,
-                     StringRef asmstr, ArrayRef<StringRef> clobbers,
-                     SourceLocation endloc)
-  : AsmStmt(MSAsmStmtClass, asmloc, issimple, isvolatile, numoutputs,
-            numinputs, clobbers.size()), LBraceLoc(lbraceloc),
-            EndLoc(endloc), NumAsmToks(asmtoks.size()) {
+                     unsigned numinputs, ArrayRef<StringRef> constraints,
+                     ArrayRef<Expr *> exprs, StringRef asmstr,
+                     ArrayRef<StringRef> clobbers, SourceLocation endloc)
+    : AsmStmt(MSAsmStmtClass, asmloc, issimple, isvolatile, numoutputs,
+              numinputs, clobbers.size()),
+      LBraceLoc(lbraceloc), EndLoc(endloc), NumAsmToks(asmtoks.size()) {
 
   initialize(C, asmstr, asmtoks, constraints, exprs, clobbers);
 }
@@ -673,7 +666,7 @@
 void MSAsmStmt::initialize(const ASTContext &C, StringRef asmstr,
                            ArrayRef<Token> asmtoks,
                            ArrayRef<StringRef> constraints,
-                           ArrayRef<Expr*> exprs,
+                           ArrayRef<Expr *> exprs,
                            ArrayRef<StringRef> clobbers) {
   assert(NumAsmToks == asmtoks.size());
   assert(NumClobbers == clobbers.size());
@@ -684,7 +677,7 @@
 
   AsmStr = copyIntoContext(C, asmstr);
 
-  Exprs = new (C) Stmt*[NumExprs];
+  Exprs = new (C) Stmt *[NumExprs];
   for (unsigned i = 0, e = NumExprs; i != e; ++i)
     Exprs[i] = exprs[i];
 
@@ -705,9 +698,9 @@
 }
 
 ObjCForCollectionStmt::ObjCForCollectionStmt(Stmt *Elem, Expr *Collect,
-                                             Stmt *Body,  SourceLocation FCL,
+                                             Stmt *Body, SourceLocation FCL,
                                              SourceLocation RPL)
-: Stmt(ObjCForCollectionStmtClass) {
+    : Stmt(ObjCForCollectionStmtClass) {
   SubExprs[ELEM] = Elem;
   SubExprs[COLLECTION] = Collect;
   SubExprs[BODY] = Body;
@@ -730,10 +723,8 @@
 }
 
 ObjCAtTryStmt *ObjCAtTryStmt::Create(const ASTContext &Context,
-                                     SourceLocation atTryLoc,
-                                     Stmt *atTryStmt,
-                                     Stmt **CatchStmts,
-                                     unsigned NumCatchStmts,
+                                     SourceLocation atTryLoc, Stmt *atTryStmt,
+                                     Stmt **CatchStmts, unsigned NumCatchStmts,
                                      Stmt *atFinallyStmt) {
   unsigned Size = sizeof(ObjCAtTryStmt) +
     (1 + NumCatchStmts + (atFinallyStmt != nullptr)) * sizeof(Stmt *);
@@ -745,8 +736,8 @@
 ObjCAtTryStmt *ObjCAtTryStmt::CreateEmpty(const ASTContext &Context,
                                           unsigned NumCatchStmts,
                                           bool HasFinally) {
-  unsigned Size = sizeof(ObjCAtTryStmt) +
-    (1 + NumCatchStmts + HasFinally) * sizeof(Stmt *);
+  unsigned Size =
+      sizeof(ObjCAtTryStmt) + (1 + NumCatchStmts + HasFinally) * sizeof(Stmt *);
   void *Mem = Context.Allocate(Size, llvm::alignOf<ObjCAtTryStmt>());
   return new (Mem) ObjCAtTryStmt(EmptyShell(), NumCatchStmts, HasFinally);
 }
@@ -760,7 +751,7 @@
 }
 
 CXXTryStmt *CXXTryStmt::Create(const ASTContext &C, SourceLocation tryLoc,
-                               Stmt *tryBlock, ArrayRef<Stmt*> handlers) {
+                               Stmt *tryBlock, ArrayRef<Stmt *> handlers) {
   std::size_t Size = sizeof(CXXTryStmt);
   Size += ((handlers.size() + 1) * sizeof(Stmt));
 
@@ -778,8 +769,8 @@
 }
 
 CXXTryStmt::CXXTryStmt(SourceLocation tryLoc, Stmt *tryBlock,
-                       ArrayRef<Stmt*> handlers)
-  : Stmt(CXXTryStmtClass), TryLoc(tryLoc), NumHandlers(handlers.size()) {
+                       ArrayRef<Stmt *> handlers)
+    : Stmt(CXXTryStmtClass), TryLoc(tryLoc), NumHandlers(handlers.size()) {
   Stmt **Stmts = reinterpret_cast<Stmt **>(this + 1);
   Stmts[0] = tryBlock;
   std::copy(handlers.begin(), handlers.end(), Stmts + 1);
@@ -789,7 +780,7 @@
                                  Expr *Cond, Expr *Inc, DeclStmt *LoopVar,
                                  Stmt *Body, SourceLocation FL,
                                  SourceLocation CL, SourceLocation RPL)
-  : Stmt(CXXForRangeStmtClass), ForLoc(FL), ColonLoc(CL), RParenLoc(RPL) {
+    : Stmt(CXXForRangeStmtClass), ForLoc(FL), ColonLoc(CL), RParenLoc(RPL) {
   SubExprs[RANGE] = Range;
   SubExprs[BEGINEND] = BeginEndStmt;
   SubExprs[COND] = Cond;
@@ -806,7 +797,7 @@
 }
 
 const Expr *CXXForRangeStmt::getRangeInit() const {
-  return const_cast<CXXForRangeStmt*>(this)->getRangeInit();
+  return const_cast<CXXForRangeStmt *>(this)->getRangeInit();
 }
 
 VarDecl *CXXForRangeStmt::getLoopVariable() {
@@ -816,13 +807,12 @@
 }
 
 const VarDecl *CXXForRangeStmt::getLoopVariable() const {
-  return const_cast<CXXForRangeStmt*>(this)->getLoopVariable();
+  return const_cast<CXXForRangeStmt *>(this)->getLoopVariable();
 }
 
 IfStmt::IfStmt(const ASTContext &C, SourceLocation IL, VarDecl *var, Expr *cond,
                Stmt *then, SourceLocation EL, Stmt *elsev)
-  : Stmt(IfStmtClass), IfLoc(IL), ElseLoc(EL)
-{
+    : Stmt(IfStmtClass), IfLoc(IL), ElseLoc(EL) {
   setConditionVariable(C, var);
   SubExprs[COND] = cond;
   SubExprs[THEN] = then;
@@ -844,15 +834,14 @@
   }
 
   SourceRange VarRange = V->getSourceRange();
-  SubExprs[VAR] = new (C) DeclStmt(DeclGroupRef(V), VarRange.getBegin(),
-                                   VarRange.getEnd());
+  SubExprs[VAR] =
+      new (C) DeclStmt(DeclGroupRef(V), VarRange.getBegin(), VarRange.getEnd());
 }
 
 ForStmt::ForStmt(const ASTContext &C, Stmt *Init, Expr *Cond, VarDecl *condVar,
                  Expr *Inc, Stmt *Body, SourceLocation FL, SourceLocation LP,
                  SourceLocation RP)
-  : Stmt(ForStmtClass), ForLoc(FL), LParenLoc(LP), RParenLoc(RP)
-{
+    : Stmt(ForStmtClass), ForLoc(FL), LParenLoc(LP), RParenLoc(RP) {
   SubExprs[INIT] = Init;
   setConditionVariable(C, condVar);
   SubExprs[COND] = Cond;
@@ -875,8 +864,8 @@
   }
 
   SourceRange VarRange = V->getSourceRange();
-  SubExprs[CONDVAR] = new (C) DeclStmt(DeclGroupRef(V), VarRange.getBegin(),
-                                       VarRange.getEnd());
+  SubExprs[CONDVAR] =
+      new (C) DeclStmt(DeclGroupRef(V), VarRange.getBegin(), VarRange.getEnd());
 }
 
 SwitchStmt::SwitchStmt(const ASTContext &C, VarDecl *Var, Expr *cond)
@@ -902,8 +891,8 @@
   }
 
   SourceRange VarRange = V->getSourceRange();
-  SubExprs[VAR] = new (C) DeclStmt(DeclGroupRef(V), VarRange.getBegin(),
-                                   VarRange.getEnd());
+  SubExprs[VAR] =
+      new (C) DeclStmt(DeclGroupRef(V), VarRange.getBegin(), VarRange.getEnd());
 }
 
 Stmt *SwitchCase::getSubStmt() {
@@ -914,7 +903,7 @@
 
 WhileStmt::WhileStmt(const ASTContext &C, VarDecl *Var, Expr *cond, Stmt *body,
                      SourceLocation WL)
-  : Stmt(WhileStmtClass) {
+    : Stmt(WhileStmtClass) {
   setConditionVariable(C, Var);
   SubExprs[COND] = cond;
   SubExprs[BODY] = body;
@@ -1007,109 +996,6 @@
   return new(C)SEHFinallyStmt(Loc,Block);
 }
 
-CapturedStmt::Capture *CapturedStmt::getStoredCaptures() const {
-  unsigned Size = sizeof(CapturedStmt) + sizeof(Stmt *) * (NumCaptures + 1);
-
-  // Offset of the first Capture object.
-  unsigned FirstCaptureOffset =
-    llvm::RoundUpToAlignment(Size, llvm::alignOf<Capture>());
-
-  return reinterpret_cast<Capture *>(
-      reinterpret_cast<char *>(const_cast<CapturedStmt *>(this))
-      + FirstCaptureOffset);
-}
-
-CapturedStmt::CapturedStmt(Stmt *S, CapturedRegionKind Kind,
-                           ArrayRef<Capture> Captures,
-                           ArrayRef<Expr *> CaptureInits,
-                           CapturedDecl *CD,
-                           RecordDecl *RD)
-  : Stmt(CapturedStmtClass), NumCaptures(Captures.size()),
-    CapDeclAndKind(CD, Kind), TheRecordDecl(RD) {
-  assert( S && "null captured statement");
-  assert(CD && "null captured declaration for captured statement");
-  assert(RD && "null record declaration for captured statement");
-
-  // Copy initialization expressions.
-  Stmt **Stored = getStoredStmts();
-  for (unsigned I = 0, N = NumCaptures; I != N; ++I)
-    *Stored++ = CaptureInits[I];
-
-  // Copy the statement being captured.
-  *Stored = S;
-
-  // Copy all Capture objects.
-  Capture *Buffer = getStoredCaptures();
-  std::copy(Captures.begin(), Captures.end(), Buffer);
-}
-
-CapturedStmt::CapturedStmt(EmptyShell Empty, unsigned NumCaptures)
-  : Stmt(CapturedStmtClass, Empty), NumCaptures(NumCaptures),
-    CapDeclAndKind(nullptr, CR_Default), TheRecordDecl(nullptr) {
-  getStoredStmts()[NumCaptures] = nullptr;
-}
-
-CapturedStmt *CapturedStmt::Create(const ASTContext &Context, Stmt *S,
-                                   CapturedRegionKind Kind,
-                                   ArrayRef<Capture> Captures,
-                                   ArrayRef<Expr *> CaptureInits,
-                                   CapturedDecl *CD,
-                                   RecordDecl *RD) {
-  // The layout is
-  //
-  // -----------------------------------------------------------
-  // | CapturedStmt, Init, ..., Init, S, Capture, ..., Capture |
-  // ----------------^-------------------^----------------------
-  //                 getStoredStmts()    getStoredCaptures()
-  //
-  // where S is the statement being captured.
-  //
-  assert(CaptureInits.size() == Captures.size() && "wrong number of arguments");
-
-  unsigned Size = sizeof(CapturedStmt) + sizeof(Stmt *) * (Captures.size() + 1);
-  if (!Captures.empty()) {
-    // Realign for the following Capture array.
-    Size = llvm::RoundUpToAlignment(Size, llvm::alignOf<Capture>());
-    Size += sizeof(Capture) * Captures.size();
-  }
-
-  void *Mem = Context.Allocate(Size);
-  return new (Mem) CapturedStmt(S, Kind, Captures, CaptureInits, CD, RD);
-}
-
-CapturedStmt *CapturedStmt::CreateDeserialized(const ASTContext &Context,
-                                               unsigned NumCaptures) {
-  unsigned Size = sizeof(CapturedStmt) + sizeof(Stmt *) * (NumCaptures + 1);
-  if (NumCaptures > 0) {
-    // Realign for the following Capture array.
-    Size = llvm::RoundUpToAlignment(Size, llvm::alignOf<Capture>());
-    Size += sizeof(Capture) * NumCaptures;
-  }
-
-  void *Mem = Context.Allocate(Size);
-  return new (Mem) CapturedStmt(EmptyShell(), NumCaptures);
-}
-
-Stmt::child_range CapturedStmt::children() {
-  // Children are captured field initilizers.
-  return child_range(getStoredStmts(), getStoredStmts() + NumCaptures);
-}
-
-bool CapturedStmt::capturesVariable(const VarDecl *Var) const {
-  for (const auto &I : captures()) {
-    if (!I.capturesVariable())
-      continue;
-
-    // This does not handle variable redeclarations. This should be
-    // extended to capture variables with redeclarations, for example
-    // a thread-private variable in OpenMP.
-    if (I.getCapturedVar() == Var)
-      return true;
-  }
-
-  return false;
-}
-
 StmtRange OMPClause::children() {
   switch(getClauseKind()) {
   default : break;
@@ -1120,17 +1006,24 @@
   llvm_unreachable("unknown OMPClause");
 }
 
+void OMPPrivateClause::setDefaultInits(ArrayRef<Expr *> DefaultInits) {
+  assert(DefaultInits.size() == varlist_size() &&
+         "Number of inits is not the same as the preallocated buffer");
+  std::copy(DefaultInits.begin(), DefaultInits.end(), varlist_end());
+}
+
 OMPPrivateClause *OMPPrivateClause::Create(const ASTContext &C,
                                            SourceLocation StartLoc,
-                                           SourceLocation LParenLoc,
                                            SourceLocation EndLoc,
-                                           ArrayRef<Expr *> VL) {
+                                           ArrayRef<Expr *> VL,
+                                           ArrayRef<Expr *> DefaultInits) {
   void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPPrivateClause),
                                                   llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * VL.size());
-  OMPPrivateClause *Clause = new (Mem) OMPPrivateClause(StartLoc, LParenLoc,
-                                                        EndLoc, VL.size());
-  Clause->setVarRefs(VL);
+                         sizeof(Expr *) * 2 * VL.size());
+  OMPPrivateClause *Clause =
+      new (Mem) OMPPrivateClause(StartLoc, EndLoc, VL.size());
+  Clause->setVars(VL);
+  Clause->setDefaultInits(DefaultInits);
   return Clause;
 }
 
@@ -1138,184 +1031,220 @@
                                                 unsigned N) {
   void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPPrivateClause),
                                                   llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * N);
+                         sizeof(Expr *) * 2 * N);
   return new (Mem) OMPPrivateClause(N);
 }
 
-OMPFirstprivateClause *OMPFirstprivateClause::Create(const ASTContext &C,
-                                                     SourceLocation StartLoc,
-                                                     SourceLocation LParenLoc,
-                                                     SourceLocation EndLoc,
-                                                     ArrayRef<Expr *> VL) {
-  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPFirstprivateClause),
+void OMPFirstPrivateClause::setPseudoVars(ArrayRef<DeclRefExpr *> PseudoVars) {
+  assert(PseudoVars.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(PseudoVars.begin(), PseudoVars.end(), varlist_end());
+}
+
+void OMPFirstPrivateClause::setInits(ArrayRef<Expr *> Inits) {
+  assert(Inits.size() == varlist_size() &&
+         "Number of inits is not the same as the preallocated buffer");
+  std::copy(Inits.begin(), Inits.end(), getPseudoVars().end());
+}
+
+OMPFirstPrivateClause *
+OMPFirstPrivateClause::Create(const ASTContext &C, SourceLocation StartLoc,
+                              SourceLocation EndLoc, ArrayRef<Expr *> VL,
+                              ArrayRef<DeclRefExpr *> PseudoVars,
+                              ArrayRef<Expr *> Inits) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPFirstPrivateClause),
                                                   llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * VL.size());
-  OMPFirstprivateClause *Clause = new (Mem) OMPFirstprivateClause(StartLoc,
-                                                                  LParenLoc,
-                                                                  EndLoc,
-                                                                  VL.size());
-  Clause->setVarRefs(VL);
+                         sizeof(Expr *) * VL.size() * 3);
+  OMPFirstPrivateClause *Clause =
+      new (Mem) OMPFirstPrivateClause(StartLoc, EndLoc, VL.size());
+  Clause->setVars(VL);
+  Clause->setPseudoVars(PseudoVars);
+  Clause->setInits(Inits);
   return Clause;
 }
 
-OMPFirstprivateClause *OMPFirstprivateClause::CreateEmpty(const ASTContext &C,
+OMPFirstPrivateClause *OMPFirstPrivateClause::CreateEmpty(const ASTContext &C,
                                                           unsigned N) {
-  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPFirstprivateClause),
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPFirstPrivateClause),
                                                   llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * N);
-  return new (Mem) OMPFirstprivateClause(N);
+                         sizeof(Expr *) * N * 3);
+  return new (Mem) OMPFirstPrivateClause(N);
 }
 
-OMPLastprivateClause *OMPLastprivateClause::Create(const ASTContext &C,
-                                                   SourceLocation StartLoc,
-                                                   SourceLocation LParenLoc,
-                                                   SourceLocation EndLoc,
-                                                   ArrayRef<Expr *> VL) {
-  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPLastprivateClause),
+void OMPLastPrivateClause::setPseudoVars1(ArrayRef<DeclRefExpr *> PseudoVars) {
+  assert(PseudoVars.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(PseudoVars.begin(), PseudoVars.end(), varlist_end());
+}
+
+void OMPLastPrivateClause::setPseudoVars2(ArrayRef<DeclRefExpr *> PseudoVars) {
+  assert(PseudoVars.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(PseudoVars.begin(), PseudoVars.end(), getPseudoVars1().end());
+}
+
+void OMPLastPrivateClause::setDefaultInits(ArrayRef<Expr *> DefaultInits) {
+  assert(DefaultInits.size() == varlist_size() &&
+         "Number of inits is not the same as the preallocated buffer");
+  std::copy(DefaultInits.begin(), DefaultInits.end(), getPseudoVars2().end());
+}
+
+void OMPLastPrivateClause::setAssignments(ArrayRef<Expr *> Assignments) {
+  assert(Assignments.size() == varlist_size() &&
+         "Number of inits is not the same as the preallocated buffer");
+  std::copy(Assignments.begin(), Assignments.end(), getDefaultInits().end());
+}
+
+OMPLastPrivateClause *OMPLastPrivateClause::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<Expr *> VL, ArrayRef<DeclRefExpr *> PseudoVars1,
+    ArrayRef<DeclRefExpr *> PseudoVars2, ArrayRef<Expr *> Assignments) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPLastPrivateClause),
                                                   llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * VL.size());
-  OMPLastprivateClause *Clause =
-      new (Mem) OMPLastprivateClause(StartLoc, LParenLoc, EndLoc, VL.size());
-  Clause->setVarRefs(VL);
+                         sizeof(Expr *) * VL.size() * 5);
+  OMPLastPrivateClause *Clause =
+      new (Mem) OMPLastPrivateClause(StartLoc, EndLoc, VL.size());
+  Clause->setVars(VL);
+  Clause->setPseudoVars1(PseudoVars1);
+  Clause->setPseudoVars2(PseudoVars2);
+  Clause->setAssignments(Assignments);
+  llvm::SmallVector<Expr *, 8> DefaultInits(VL.size(), 0);
+  Clause->setDefaultInits(DefaultInits);
   return Clause;
 }
 
-OMPLastprivateClause *OMPLastprivateClause::CreateEmpty(const ASTContext &C,
+OMPLastPrivateClause *OMPLastPrivateClause::CreateEmpty(const ASTContext &C,
                                                         unsigned N) {
-  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPLastprivateClause),
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPLastPrivateClause),
                                                   llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * N);
-  return new (Mem) OMPLastprivateClause(N);
+                         sizeof(Expr *) * N * 5);
+  return new (Mem) OMPLastPrivateClause(N);
 }
 
 OMPSharedClause *OMPSharedClause::Create(const ASTContext &C,
                                          SourceLocation StartLoc,
-                                         SourceLocation LParenLoc,
                                          SourceLocation EndLoc,
                                          ArrayRef<Expr *> VL) {
   void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPSharedClause),
                                                   llvm::alignOf<Expr *>()) +
                          sizeof(Expr *) * VL.size());
-  OMPSharedClause *Clause = new (Mem) OMPSharedClause(StartLoc, LParenLoc,
-                                                      EndLoc, VL.size());
-  Clause->setVarRefs(VL);
+  OMPSharedClause *Clause =
+      new (Mem) OMPSharedClause(StartLoc, EndLoc, VL.size());
+  Clause->setVars(VL);
   return Clause;
 }
 
-OMPSharedClause *OMPSharedClause::CreateEmpty(const ASTContext &C,
-                                              unsigned N) {
+OMPSharedClause *OMPSharedClause::CreateEmpty(const ASTContext &C, unsigned N) {
   void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPSharedClause),
                                                   llvm::alignOf<Expr *>()) +
                          sizeof(Expr *) * N);
   return new (Mem) OMPSharedClause(N);
 }
 
-OMPLinearClause *OMPLinearClause::Create(const ASTContext &C,
-                                         SourceLocation StartLoc,
-                                         SourceLocation LParenLoc,
-                                         SourceLocation ColonLoc,
-                                         SourceLocation EndLoc,
-                                         ArrayRef<Expr *> VL, Expr *Step) {
-  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPLinearClause),
-                                                  llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * (VL.size() + 1));
-  OMPLinearClause *Clause = new (Mem)
-      OMPLinearClause(StartLoc, LParenLoc, ColonLoc, EndLoc, VL.size());
-  Clause->setVarRefs(VL);
-  Clause->setStep(Step);
-  return Clause;
-}
-
-OMPLinearClause *OMPLinearClause::CreateEmpty(const ASTContext &C,
-                                              unsigned NumVars) {
-  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPLinearClause),
-                                                  llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * (NumVars + 1));
-  return new (Mem) OMPLinearClause(NumVars);
+void OMPCopyinClause::setPseudoVars1(ArrayRef<DeclRefExpr *> PseudoVars) {
+  assert(PseudoVars.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(PseudoVars.begin(), PseudoVars.end(), varlist_end());
 }
 
-OMPAlignedClause *
-OMPAlignedClause::Create(const ASTContext &C, SourceLocation StartLoc,
-                         SourceLocation LParenLoc, SourceLocation ColonLoc,
-                         SourceLocation EndLoc, ArrayRef<Expr *> VL, Expr *A) {
-  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPAlignedClause),
-                                                  llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * (VL.size() + 1));
-  OMPAlignedClause *Clause = new (Mem)
-      OMPAlignedClause(StartLoc, LParenLoc, ColonLoc, EndLoc, VL.size());
-  Clause->setVarRefs(VL);
-  Clause->setAlignment(A);
-  return Clause;
+void OMPCopyinClause::setPseudoVars2(ArrayRef<DeclRefExpr *> PseudoVars) {
+  assert(PseudoVars.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(PseudoVars.begin(), PseudoVars.end(), getPseudoVars1().end());
 }
 
-OMPAlignedClause *OMPAlignedClause::CreateEmpty(const ASTContext &C,
-                                                unsigned NumVars) {
-  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPAlignedClause),
-                                                  llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * (NumVars + 1));
-  return new (Mem) OMPAlignedClause(NumVars);
+void OMPCopyinClause::setAssignments(ArrayRef<Expr *> Assignments) {
+  assert(Assignments.size() == varlist_size() &&
+         "Number of inits is not the same as the preallocated buffer");
+  std::copy(Assignments.begin(), Assignments.end(), getPseudoVars2().end());
 }
 
-OMPCopyinClause *OMPCopyinClause::Create(const ASTContext &C,
-                                         SourceLocation StartLoc,
-                                         SourceLocation LParenLoc,
-                                         SourceLocation EndLoc,
-                                         ArrayRef<Expr *> VL) {
+OMPCopyinClause *OMPCopyinClause::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<Expr *> VL, ArrayRef<DeclRefExpr *> PseudoVars1,
+    ArrayRef<DeclRefExpr *> PseudoVars2, ArrayRef<Expr *> Assignments) {
   void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPCopyinClause),
                                                   llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * VL.size());
-  OMPCopyinClause *Clause = new (Mem) OMPCopyinClause(StartLoc, LParenLoc,
-                                                      EndLoc, VL.size());
-  Clause->setVarRefs(VL);
+                         sizeof(Expr *) * VL.size() * 4);
+  OMPCopyinClause *Clause =
+      new (Mem) OMPCopyinClause(StartLoc, EndLoc, VL.size());
+  Clause->setVars(VL);
+  Clause->setPseudoVars1(PseudoVars1);
+  Clause->setPseudoVars2(PseudoVars2);
+  Clause->setAssignments(Assignments);
   return Clause;
 }
 
-OMPCopyinClause *OMPCopyinClause::CreateEmpty(const ASTContext &C,
-                                              unsigned N) {
+OMPCopyinClause *OMPCopyinClause::CreateEmpty(const ASTContext &C, unsigned N) {
   void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPCopyinClause),
                                                   llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * N);
+                         sizeof(Expr *) * N * 4);
   return new (Mem) OMPCopyinClause(N);
 }
 
-OMPCopyprivateClause *OMPCopyprivateClause::Create(const ASTContext &C,
-                                                   SourceLocation StartLoc,
-                                                   SourceLocation LParenLoc,
-                                                   SourceLocation EndLoc,
-                                                   ArrayRef<Expr *> VL) {
-  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPCopyprivateClause),
+void OMPCopyPrivateClause::setPseudoVars1(ArrayRef<DeclRefExpr *> PseudoVars) {
+  assert(PseudoVars.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(PseudoVars.begin(), PseudoVars.end(),
+            varlist_end());
+}
+
+void OMPCopyPrivateClause::setPseudoVars2(ArrayRef<DeclRefExpr *> PseudoVars) {
+  assert(PseudoVars.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(PseudoVars.begin(), PseudoVars.end(),
+            getPseudoVars1().end());
+}
+
+void OMPCopyPrivateClause::setAssignments(ArrayRef<Expr *> Assignments) {
+  assert(Assignments.size() == varlist_size() &&
+         "Number of inits is not the same as the preallocated buffer");
+  std::copy(Assignments.begin(), Assignments.end(),
+            getPseudoVars2().end());
+}
+
+OMPCopyPrivateClause *OMPCopyPrivateClause::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<Expr *> VL, ArrayRef<DeclRefExpr *> PseudoVars1,
+    ArrayRef<DeclRefExpr *> PseudoVars2, ArrayRef<Expr *> Assignments) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPCopyPrivateClause),
                                                   llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * VL.size());
-  OMPCopyprivateClause *Clause =
-      new (Mem) OMPCopyprivateClause(StartLoc, LParenLoc, EndLoc, VL.size());
-  Clause->setVarRefs(VL);
+                         sizeof(Expr *) * VL.size() * 4);
+  OMPCopyPrivateClause *Clause =
+      new (Mem) OMPCopyPrivateClause(StartLoc, EndLoc, VL.size());
+  Clause->setVars(VL);
+  Clause->setPseudoVars1(PseudoVars1);
+  Clause->setPseudoVars2(PseudoVars2);
+  Clause->setAssignments(Assignments);
   return Clause;
 }
 
-OMPCopyprivateClause *OMPCopyprivateClause::CreateEmpty(const ASTContext &C,
+OMPCopyPrivateClause *OMPCopyPrivateClause::CreateEmpty(const ASTContext &C,
                                                         unsigned N) {
-  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPCopyprivateClause),
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPCopyPrivateClause),
                                                   llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * N);
-  return new (Mem) OMPCopyprivateClause(N);
-}
-
-void OMPExecutableDirective::setClauses(ArrayRef<OMPClause *> Clauses) {
-  assert(Clauses.size() == getNumClauses() &&
-         "Number of clauses is not the same as the preallocated buffer");
-  std::copy(Clauses.begin(), Clauses.end(), getClauses().begin());
+                         sizeof(Expr *) * N * 4);
+  return new (Mem) OMPCopyPrivateClause(N);
 }
 
 OMPReductionClause *OMPReductionClause::Create(
-    const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,
-    SourceLocation EndLoc, SourceLocation ColonLoc, ArrayRef<Expr *> VL,
-    NestedNameSpecifierLoc QualifierLoc, const DeclarationNameInfo &NameInfo) {
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<Expr *> VL, ArrayRef<Expr *> OpExprs,
+    ArrayRef<Expr *> HelperParams1, ArrayRef<Expr *> HelperParams2,
+    ArrayRef<Expr *> DefaultInits, OpenMPReductionClauseOperator Op,
+    NestedNameSpecifierLoc S, DeclarationNameInfo OpName) {
+  assert(VL.size() == OpExprs.size() &&
+         "Number of expressions is not the same as number of variables!");
   void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPReductionClause),
                                                   llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * VL.size());
-  OMPReductionClause *Clause = new (Mem) OMPReductionClause(
-      StartLoc, LParenLoc, EndLoc, ColonLoc, VL.size(), QualifierLoc, NameInfo);
-  Clause->setVarRefs(VL);
+                         5 * sizeof(Expr *) * VL.size());
+  OMPReductionClause *Clause =
+      new (Mem) OMPReductionClause(StartLoc, EndLoc, VL.size(), Op, S, OpName);
+  Clause->setVars(VL);
+  Clause->setOpExprs(OpExprs);
+  Clause->setHelperParameters1st(HelperParams1);
+  Clause->setHelperParameters2nd(HelperParams2);
+  Clause->setDefaultInits(DefaultInits);
   return Clause;
 }
 
@@ -1323,21 +1252,222 @@
                                                     unsigned N) {
   void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPReductionClause),
                                                   llvm::alignOf<Expr *>()) +
-                         sizeof(Expr *) * N);
+                         5 * sizeof(Expr *) * N);
   return new (Mem) OMPReductionClause(N);
 }
 
+void OMPReductionClause::setOpExprs(ArrayRef<Expr *> OpExprs) {
+  assert(OpExprs.size() == numberOfVariables() &&
+         "Number of expressions is not the same as the number of variables.");
+  std::copy(OpExprs.begin(), OpExprs.end(), varlist_end());
+}
+
+void OMPReductionClause::setHelperParameters1st(ArrayRef<Expr *> HelperParams) {
+  assert(HelperParams.size() == numberOfVariables() &&
+         "Number of expressions is not the same as the number of variables.");
+  std::copy(HelperParams.begin(), HelperParams.end(), getOpExprs().end());
+}
+
+void OMPReductionClause::setHelperParameters2nd(ArrayRef<Expr *> HelperParams) {
+  assert(HelperParams.size() == numberOfVariables() &&
+         "Number of expressions is not the same as the number of variables.");
+  std::copy(HelperParams.begin(), HelperParams.end(),
+            getHelperParameters1st().end());
+}
+
+void OMPReductionClause::setDefaultInits(ArrayRef<Expr *> DefaultInits) {
+  assert(DefaultInits.size() == varlist_size() &&
+         "Number of inits is not the same as the preallocated buffer");
+  std::copy(DefaultInits.begin(), DefaultInits.end(),
+            getHelperParameters2nd().end());
+}
+
+void
+OMPMapClause::setWholeStartAddresses(ArrayRef<Expr *> WholeStartAddresses) {
+  assert(WholeStartAddresses.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(WholeStartAddresses.begin(), WholeStartAddresses.end(),
+            varlist_end());
+}
+
+void OMPMapClause::setWholeSizesEndAddresses(
+    ArrayRef<Expr *> WholeSizesEndAddresses) {
+  assert(WholeSizesEndAddresses.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(WholeSizesEndAddresses.begin(), WholeSizesEndAddresses.end(),
+            getWholeStartAddresses().end());
+}
+
+void
+OMPMapClause::setCopyingStartAddresses(ArrayRef<Expr *> CopyingStartAddresses) {
+  assert(CopyingStartAddresses.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(CopyingStartAddresses.begin(), CopyingStartAddresses.end(),
+            getWholeSizesEndAddresses().end());
+}
+
+void OMPMapClause::setCopyingSizesEndAddresses(
+    ArrayRef<Expr *> CopyingSizesEndAddresses) {
+  assert(CopyingSizesEndAddresses.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(CopyingSizesEndAddresses.begin(), CopyingSizesEndAddresses.end(),
+            getCopyingStartAddresses().end());
+}
+
+OMPMapClause *OMPMapClause::Create(const ASTContext &C, SourceLocation StartLoc,
+                                   SourceLocation EndLoc, ArrayRef<Expr *> VL,
+                                   ArrayRef<Expr *> WholeStartAddresses,
+                                   ArrayRef<Expr *> WholeSizesEndAddresses,
+                                   ArrayRef<Expr *> CopyingStartAddresses,
+                                   ArrayRef<Expr *> CopyingSizesEndAddresses,
+                                   OpenMPMapClauseKind Kind,
+                                   SourceLocation KindLoc) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPMapClause), llvm::alignOf<Expr *>()) +
+      sizeof(Expr *) * VL.size() * 5);
+  OMPMapClause *Clause =
+      new (Mem) OMPMapClause(StartLoc, EndLoc, VL.size(), Kind, KindLoc);
+  Clause->setVars(VL);
+  Clause->setWholeStartAddresses(WholeStartAddresses);
+  Clause->setWholeSizesEndAddresses(WholeSizesEndAddresses);
+  Clause->setCopyingStartAddresses(CopyingStartAddresses);
+  Clause->setCopyingSizesEndAddresses(CopyingSizesEndAddresses);
+  Clause->setKind(Kind);
+  Clause->setKindLoc(KindLoc);
+  return Clause;
+}
+
+OMPMapClause *OMPMapClause::CreateEmpty(const ASTContext &C, unsigned N) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPMapClause), llvm::alignOf<Expr *>()) +
+      sizeof(Expr *) * N * 5);
+  return new (Mem) OMPMapClause(N);
+}
+
+void OMPToClause::setWholeStartAddresses(ArrayRef<Expr *> WholeStartAddresses) {
+  assert(WholeStartAddresses.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(WholeStartAddresses.begin(), WholeStartAddresses.end(),
+            varlist_end());
+}
+
+void OMPToClause::setWholeSizesEndAddresses(
+    ArrayRef<Expr *> WholeSizesEndAddresses) {
+  assert(WholeSizesEndAddresses.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(WholeSizesEndAddresses.begin(), WholeSizesEndAddresses.end(),
+            getWholeStartAddresses().end());
+}
+
+void
+OMPToClause::setCopyingStartAddresses(ArrayRef<Expr *> CopyingStartAddresses) {
+  assert(CopyingStartAddresses.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(CopyingStartAddresses.begin(), CopyingStartAddresses.end(),
+            getWholeSizesEndAddresses().end());
+}
+
+void OMPToClause::setCopyingSizesEndAddresses(
+    ArrayRef<Expr *> CopyingSizesEndAddresses) {
+  assert(CopyingSizesEndAddresses.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(CopyingSizesEndAddresses.begin(), CopyingSizesEndAddresses.end(),
+            getCopyingStartAddresses().end());
+}
+
+OMPToClause *OMPToClause::Create(const ASTContext &C, SourceLocation StartLoc,
+                                 SourceLocation EndLoc, ArrayRef<Expr *> VL,
+                                 ArrayRef<Expr *> WholeStartAddresses,
+                                 ArrayRef<Expr *> WholeSizesEndAddresses,
+                                 ArrayRef<Expr *> CopyingStartAddresses,
+                                 ArrayRef<Expr *> CopyingSizesEndAddresses) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPToClause), llvm::alignOf<Expr *>()) +
+      sizeof(Expr *) * VL.size() * 5);
+  OMPToClause *Clause = new (Mem) OMPToClause(StartLoc, EndLoc, VL.size());
+  Clause->setVars(VL);
+  Clause->setWholeStartAddresses(WholeStartAddresses);
+  Clause->setWholeSizesEndAddresses(WholeSizesEndAddresses);
+  Clause->setCopyingStartAddresses(CopyingStartAddresses);
+  Clause->setCopyingSizesEndAddresses(CopyingSizesEndAddresses);
+  return Clause;
+}
+
+OMPToClause *OMPToClause::CreateEmpty(const ASTContext &C, unsigned N) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPToClause), llvm::alignOf<Expr *>()) +
+      sizeof(Expr *) * N * 5);
+  return new (Mem) OMPToClause(N);
+}
+
+void
+OMPFromClause::setWholeStartAddresses(ArrayRef<Expr *> WholeStartAddresses) {
+  assert(WholeStartAddresses.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(WholeStartAddresses.begin(), WholeStartAddresses.end(),
+            varlist_end());
+}
+
+void OMPFromClause::setWholeSizesEndAddresses(
+    ArrayRef<Expr *> WholeSizesEndAddresses) {
+  assert(WholeSizesEndAddresses.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(WholeSizesEndAddresses.begin(), WholeSizesEndAddresses.end(),
+            getWholeStartAddresses().end());
+}
+
+void OMPFromClause::setCopyingStartAddresses(
+    ArrayRef<Expr *> CopyingStartAddresses) {
+  assert(CopyingStartAddresses.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(CopyingStartAddresses.begin(), CopyingStartAddresses.end(),
+            getWholeSizesEndAddresses().end());
+}
+
+void OMPFromClause::setCopyingSizesEndAddresses(
+    ArrayRef<Expr *> CopyingSizesEndAddresses) {
+  assert(CopyingSizesEndAddresses.size() == varlist_size() &&
+         "Number of vars is not the same as the preallocated buffer");
+  std::copy(CopyingSizesEndAddresses.begin(), CopyingSizesEndAddresses.end(),
+            getCopyingStartAddresses().end());
+}
+
+OMPFromClause *
+OMPFromClause::Create(const ASTContext &C, SourceLocation StartLoc,
+                      SourceLocation EndLoc, ArrayRef<Expr *> VL,
+                      ArrayRef<Expr *> WholeStartAddresses,
+                      ArrayRef<Expr *> WholeSizesEndAddresses,
+                      ArrayRef<Expr *> CopyingStartAddresses,
+                      ArrayRef<Expr *> CopyingSizesEndAddresses) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPFromClause), llvm::alignOf<Expr *>()) +
+      sizeof(Expr *) * VL.size() * 5);
+  OMPFromClause *Clause = new (Mem) OMPFromClause(StartLoc, EndLoc, VL.size());
+  Clause->setVars(VL);
+  Clause->setWholeStartAddresses(WholeStartAddresses);
+  Clause->setWholeSizesEndAddresses(WholeSizesEndAddresses);
+  Clause->setCopyingStartAddresses(CopyingStartAddresses);
+  Clause->setCopyingSizesEndAddresses(CopyingSizesEndAddresses);
+  return Clause;
+}
+
+OMPFromClause *OMPFromClause::CreateEmpty(const ASTContext &C, unsigned N) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPFromClause), llvm::alignOf<Expr *>()) +
+      sizeof(Expr *) * N * 5);
+  return new (Mem) OMPFromClause(N);
+}
+
 OMPFlushClause *OMPFlushClause::Create(const ASTContext &C,
                                        SourceLocation StartLoc,
-                                       SourceLocation LParenLoc,
                                        SourceLocation EndLoc,
                                        ArrayRef<Expr *> VL) {
   void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPFlushClause),
                                                   llvm::alignOf<Expr *>()) +
                          sizeof(Expr *) * VL.size());
   OMPFlushClause *Clause =
-      new (Mem) OMPFlushClause(StartLoc, LParenLoc, EndLoc, VL.size());
-  Clause->setVarRefs(VL);
+      new (Mem) OMPFlushClause(StartLoc, EndLoc, VL.size());
+  Clause->setVars(VL);
   return Clause;
 }
 
@@ -1348,228 +1478,616 @@
   return new (Mem) OMPFlushClause(N);
 }
 
-OMPParallelDirective *OMPParallelDirective::Create(
-                                              const ASTContext &C,
-                                              SourceLocation StartLoc,
-                                              SourceLocation EndLoc,
-                                              ArrayRef<OMPClause *> Clauses,
-                                              Stmt *AssociatedStmt) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPParallelDirective),
-                                           llvm::alignOf<OMPClause *>());
-  void *Mem = C.Allocate(Size + sizeof(OMPClause *) * Clauses.size() +
-                         sizeof(Stmt *));
-  OMPParallelDirective *Dir = new (Mem) OMPParallelDirective(StartLoc, EndLoc,
-                                                             Clauses.size());
-  Dir->setClauses(Clauses);
-  Dir->setAssociatedStmt(AssociatedStmt);
-  return Dir;
+OMPDependClause *
+OMPDependClause::Create(const ASTContext &C, SourceLocation StartLoc,
+                        SourceLocation EndLoc, ArrayRef<Expr *> VL,
+                        ArrayRef<Expr *> Begins, ArrayRef<Expr *> SizeInBytes,
+                        OpenMPDependClauseType Ty, SourceLocation TyLoc) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPDependClause),
+                                                  llvm::alignOf<Expr *>()) +
+                         sizeof(Expr *) * VL.size() * 3);
+  OMPDependClause *Clause =
+      new (Mem) OMPDependClause(StartLoc, EndLoc, VL.size(), Ty, TyLoc);
+  Clause->setVars(VL);
+  Clause->setBegins(Begins);
+  Clause->setSizeInBytes(SizeInBytes);
+  return Clause;
 }
 
-OMPParallelDirective *OMPParallelDirective::CreateEmpty(const ASTContext &C,
-                                                        unsigned NumClauses,
-                                                        EmptyShell) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPParallelDirective),
-                                           llvm::alignOf<OMPClause *>());
-  void *Mem = C.Allocate(Size + sizeof(OMPClause *) * NumClauses +
-                         sizeof(Stmt *));
-  return new (Mem) OMPParallelDirective(NumClauses);
+OMPDependClause *OMPDependClause::CreateEmpty(const ASTContext &C, unsigned N) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPDependClause),
+                                                  llvm::alignOf<Expr *>()) +
+                         sizeof(Expr *) * N * 3);
+  OMPDependClause *Clause = new (Mem) OMPDependClause(N);
+  return Clause;
 }
 
-OMPSimdDirective *
-OMPSimdDirective::Create(const ASTContext &C, SourceLocation StartLoc,
-                         SourceLocation EndLoc, unsigned CollapsedNum,
-                         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPSimdDirective),
-                                           llvm::alignOf<OMPClause *>());
-  void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
-  OMPSimdDirective *Dir = new (Mem)
-      OMPSimdDirective(StartLoc, EndLoc, CollapsedNum, Clauses.size());
-  Dir->setClauses(Clauses);
-  Dir->setAssociatedStmt(AssociatedStmt);
-  return Dir;
+void OMPDependClause::setBegins(ArrayRef<Expr *> Begins) {
+  assert(Begins.size() == varlist_size() &&
+         "Number of exprs is not the same as the preallocated buffer");
+  std::copy(Begins.begin(), Begins.end(), varlist_end());
 }
 
-OMPSimdDirective *OMPSimdDirective::CreateEmpty(const ASTContext &C,
-                                                unsigned NumClauses,
-                                                unsigned CollapsedNum,
-                                                EmptyShell) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPSimdDirective),
-                                           llvm::alignOf<OMPClause *>());
-  void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * NumClauses + sizeof(Stmt *));
-  return new (Mem) OMPSimdDirective(CollapsedNum, NumClauses);
+void OMPDependClause::setSizeInBytes(ArrayRef<Expr *> SizeInBytes) {
+  assert(SizeInBytes.size() == varlist_size() &&
+         "Number of exprs is not the same as the preallocated buffer");
+  std::copy(SizeInBytes.begin(), SizeInBytes.end(),
+            varlist_end() + varlist_size());
 }
 
-OMPForDirective *
-OMPForDirective::Create(const ASTContext &C, SourceLocation StartLoc,
-                        SourceLocation EndLoc, unsigned CollapsedNum,
-                        ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPForDirective),
-                                           llvm::alignOf<OMPClause *>());
-  void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
-  OMPForDirective *Dir =
-      new (Mem) OMPForDirective(StartLoc, EndLoc, CollapsedNum, Clauses.size());
-  Dir->setClauses(Clauses);
-  Dir->setAssociatedStmt(AssociatedStmt);
-  return Dir;
+Expr *OMPDependClause::getBegins(unsigned Index) {
+  assert(Index < varlist_size() &&
+         "Index greter or equal maximum number of expressions.");
+  return varlist_end()[Index];
 }
 
-OMPForDirective *OMPForDirective::CreateEmpty(const ASTContext &C,
-                                              unsigned NumClauses,
-                                              unsigned CollapsedNum,
-                                              EmptyShell) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPForDirective),
-                                           llvm::alignOf<OMPClause *>());
-  void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * NumClauses + sizeof(Stmt *));
-  return new (Mem) OMPForDirective(CollapsedNum, NumClauses);
+Expr *OMPDependClause::getSizeInBytes(unsigned Index) {
+  assert(Index < varlist_size() &&
+         "Index greter or equal maximum number of expressions.");
+  return varlist_end()[varlist_size() + Index];
 }
 
-OMPSectionsDirective *OMPSectionsDirective::Create(
-    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
-    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPSectionsDirective),
-                                           llvm::alignOf<OMPClause *>());
-  void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
-  OMPSectionsDirective *Dir =
-      new (Mem) OMPSectionsDirective(StartLoc, EndLoc, Clauses.size());
-  Dir->setClauses(Clauses);
-  Dir->setAssociatedStmt(AssociatedStmt);
-  return Dir;
+OMPUniformClause *OMPUniformClause::Create(const ASTContext &C,
+                                           SourceLocation StartLoc,
+                                           SourceLocation EndLoc,
+                                           ArrayRef<Expr *> VL) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPUniformClause),
+                                                  llvm::alignOf<Expr *>()) +
+                         sizeof(Expr *) * VL.size());
+  OMPUniformClause *Clause = new (Mem) OMPUniformClause(StartLoc,
+                                                        EndLoc,
+                                                        VL.size());
+  Clause->setVars(VL);
+  return Clause;
 }
 
-OMPSectionsDirective *OMPSectionsDirective::CreateEmpty(const ASTContext &C,
-                                                        unsigned NumClauses,
-                                                        EmptyShell) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPSectionsDirective),
-                                           llvm::alignOf<OMPClause *>());
-  void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * NumClauses + sizeof(Stmt *));
-  return new (Mem) OMPSectionsDirective(NumClauses);
+OMPUniformClause *
+OMPUniformClause::CreateEmpty(const ASTContext &C, unsigned N) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPUniformClause),
+                                                  llvm::alignOf<Expr *>()) +
+                         sizeof(Expr *) * N);
+  return new (Mem) OMPUniformClause(N);
 }
 
-OMPSectionDirective *OMPSectionDirective::Create(const ASTContext &C,
-                                                 SourceLocation StartLoc,
-                                                 SourceLocation EndLoc,
-                                                 Stmt *AssociatedStmt) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPSectionsDirective),
-                                           llvm::alignOf<Stmt *>());
-  void *Mem = C.Allocate(Size + sizeof(Stmt *));
-  OMPSectionDirective *Dir = new (Mem) OMPSectionDirective(StartLoc, EndLoc);
-  Dir->setAssociatedStmt(AssociatedStmt);
-  return Dir;
-}
+OMPLinearClause *OMPLinearClause::Create(const ASTContext &C,
+                                         SourceLocation StartLoc,
+                                         SourceLocation EndLoc,
+                                         ArrayRef<Expr *> VL, Expr *St,
+                                         SourceLocation StLoc) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPLinearClause),
+                                                  llvm::alignOf<Expr *>()) +
+                         sizeof(Expr *) * VL.size() + sizeof(Expr *));
+  OMPLinearClause *Clause =
+      new (Mem) OMPLinearClause(StartLoc, EndLoc, VL.size(), StLoc);
+  Clause->setVars(VL);
+  Clause->setStep(St);
+  return Clause;
+}
 
-OMPSectionDirective *OMPSectionDirective::CreateEmpty(const ASTContext &C,
+OMPLinearClause *OMPLinearClause::CreateEmpty(const ASTContext &C, unsigned N) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPLinearClause),
+                                                  llvm::alignOf<Expr *>()) +
+                         sizeof(Expr *) * (N + 1));
+  return new (Mem) OMPLinearClause(N);
+}
+
+OMPAlignedClause *OMPAlignedClause::Create(const ASTContext &C,
+                                           SourceLocation StartLoc,
+                                           SourceLocation EndLoc,
+                                           ArrayRef<Expr *> VL,
+                                           Expr *A,
+                                           SourceLocation ALoc) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPAlignedClause),
+                                                  llvm::alignOf<Expr *>()) +
+                         sizeof(Expr *) * VL.size() +
+                         sizeof(Expr *));
+  OMPAlignedClause *Clause = new (Mem) OMPAlignedClause(StartLoc,
+                                                        EndLoc,
+                                                        VL.size(),
+                                                        ALoc);
+  Clause->setVars(VL);
+  Clause->setAlignment(A);
+  return Clause;
+}
+
+OMPAlignedClause *
+OMPAlignedClause::CreateEmpty(const ASTContext &C, unsigned N) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPAlignedClause),
+                                                  llvm::alignOf<Expr *>()) +
+                         sizeof(Expr *) * (N + 1));
+  return new (Mem) OMPAlignedClause(N);
+}
+
+void OMPExecutableDirective::setClauses(ArrayRef<OMPClause *> CL) {
+  assert(CL.size() == NumClauses &&
+         "Number of clauses is not the same as the preallocated buffer");
+  std::copy(CL.begin(), CL.end(), Clauses);
+}
+
+OMPParallelDirective *OMPParallelDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPParallelDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
+  OMPParallelDirective *Dir =
+      new (Mem) OMPParallelDirective(StartLoc, EndLoc, Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  return Dir;
+}
+
+OMPParallelDirective *
+OMPParallelDirective::CreateEmpty(const ASTContext &C, unsigned N, EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPParallelDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *));
+  return new (Mem) OMPParallelDirective(N);
+}
+
+OMPForDirective *OMPForDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPForDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * VarCnts.size());
+  OMPForDirective *Dir = new (Mem)
+      OMPForDirective(StartLoc, EndLoc, VarCnts.size(), Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setCounters(VarCnts);
+  return Dir;
+}
+
+OMPForDirective *OMPForDirective::CreateEmpty(const ASTContext &C, unsigned N,
+                                              unsigned CollapsedNum,
+                                              EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPForDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPForDirective(CollapsedNum, N);
+}
+
+OMPParallelForDirective *OMPParallelForDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPParallelForDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * VarCnts.size());
+  OMPParallelForDirective *Dir = new (Mem)
+      OMPParallelForDirective(StartLoc, EndLoc, VarCnts.size(), Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setCounters(VarCnts);
+  return Dir;
+}
+
+OMPParallelForDirective *
+OMPParallelForDirective::CreateEmpty(const ASTContext &C, unsigned N,
+                                     unsigned CollapsedNum, EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPParallelForDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPParallelForDirective(CollapsedNum, N);
+}
+
+OMPSimdDirective *OMPSimdDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPSimdDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * VarCnts.size());
+  OMPSimdDirective *Dir = new (Mem)
+      OMPSimdDirective(StartLoc, EndLoc, VarCnts.size(), Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setCounters(VarCnts);
+  return Dir;
+}
+
+OMPSimdDirective *OMPSimdDirective::CreateEmpty(const ASTContext &C, unsigned N,
+                                                unsigned CollapsedNum,
+                                                EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPSimdDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                     sizeof(OMPClause *) * N + sizeof(Stmt *) * 5 +
+                     sizeof(Stmt *) * CollapsedNum,
+                 llvm::alignOf<OMPSimdDirective>());
+  return new (Mem) OMPSimdDirective(CollapsedNum, N);
+}
+
+OMPForSimdDirective *OMPForSimdDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPForSimdDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * VarCnts.size());
+  OMPForSimdDirective *Dir = new (Mem)
+      OMPForSimdDirective(StartLoc, EndLoc, VarCnts.size(), Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setCounters(VarCnts);
+  return Dir;
+}
+
+OMPForSimdDirective *OMPForSimdDirective::CreateEmpty(const ASTContext &C,
+                                                      unsigned N,
+                                                      unsigned CollapsedNum,
                                                       EmptyShell) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPSectionDirective),
-                                           llvm::alignOf<Stmt *>());
-  void *Mem = C.Allocate(Size + sizeof(Stmt *));
-  return new (Mem) OMPSectionDirective();
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPForSimdDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPForSimdDirective(CollapsedNum, N);
 }
 
-OMPSingleDirective *OMPSingleDirective::Create(const ASTContext &C,
-                                               SourceLocation StartLoc,
-                                               SourceLocation EndLoc,
-                                               ArrayRef<OMPClause *> Clauses,
-                                               Stmt *AssociatedStmt) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPSingleDirective),
-                                           llvm::alignOf<OMPClause *>());
+OMPParallelForSimdDirective *OMPParallelForSimdDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts) {
   void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
-  OMPSingleDirective *Dir =
-      new (Mem) OMPSingleDirective(StartLoc, EndLoc, Clauses.size());
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPParallelForSimdDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * VarCnts.size());
+  OMPParallelForSimdDirective *Dir = new (Mem) OMPParallelForSimdDirective(
+      StartLoc, EndLoc, VarCnts.size(), Clauses.size());
   Dir->setClauses(Clauses);
   Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setCounters(VarCnts);
   return Dir;
 }
 
-OMPSingleDirective *OMPSingleDirective::CreateEmpty(const ASTContext &C,
-                                                    unsigned NumClauses,
-                                                    EmptyShell) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPSingleDirective),
-                                           llvm::alignOf<OMPClause *>());
+OMPParallelForSimdDirective *
+OMPParallelForSimdDirective::CreateEmpty(const ASTContext &C, unsigned N,
+                                         unsigned CollapsedNum, EmptyShell) {
   void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * NumClauses + sizeof(Stmt *));
-  return new (Mem) OMPSingleDirective(NumClauses);
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPParallelForSimdDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPParallelForSimdDirective(CollapsedNum, N);
 }
 
-OMPMasterDirective *OMPMasterDirective::Create(const ASTContext &C,
-                                               SourceLocation StartLoc,
-                                               SourceLocation EndLoc,
-                                               Stmt *AssociatedStmt) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPMasterDirective),
-                                           llvm::alignOf<Stmt *>());
-  void *Mem = C.Allocate(Size + sizeof(Stmt *));
-  OMPMasterDirective *Dir = new (Mem) OMPMasterDirective(StartLoc, EndLoc);
+OMPDistributeSimdDirective *OMPDistributeSimdDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPDistributeSimdDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * VarCnts.size());
+  OMPDistributeSimdDirective *Dir = new (Mem) OMPDistributeSimdDirective(
+      StartLoc, EndLoc, VarCnts.size(), Clauses.size());
+  Dir->setClauses(Clauses);
   Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setCounters(VarCnts);
   return Dir;
 }
 
-OMPMasterDirective *OMPMasterDirective::CreateEmpty(const ASTContext &C,
+OMPDistributeSimdDirective *
+OMPDistributeSimdDirective::CreateEmpty(const ASTContext &C, unsigned N,
+                                        unsigned CollapsedNum, EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPDistributeSimdDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPDistributeSimdDirective(CollapsedNum, N);
+}
+
+OMPDistributeParallelForDirective *OMPDistributeParallelForDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, Expr *LowerBound,
+    Expr *UpperBound, ArrayRef<Expr *> VarCnts) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPDistributeParallelForDirective),
+                               llvm::alignOf<OMPClause *>()) +
+      sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 7 +
+      sizeof(Stmt *) * VarCnts.size() + 2);
+  OMPDistributeParallelForDirective *Dir = new (Mem)
+      OMPDistributeParallelForDirective(StartLoc, EndLoc, VarCnts.size(),
+                                        Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setLowerBound(LowerBound);
+  Dir->setUpperBound(UpperBound);
+  Dir->setCounters(VarCnts);
+  return Dir;
+}
+
+OMPDistributeParallelForDirective *
+OMPDistributeParallelForDirective::CreateEmpty(const ASTContext &C, unsigned N,
+                                               unsigned CollapsedNum,
+                                               EmptyShell) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPDistributeParallelForDirective),
+                               llvm::alignOf<OMPClause *>()) +
+      sizeof(OMPClause *) * N + sizeof(Stmt *) * 7 +
+      sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPDistributeParallelForDirective(CollapsedNum, N);
+}
+
+OMPDistributeParallelForSimdDirective *
+OMPDistributeParallelForSimdDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, Expr *LowerBound,
+    Expr *UpperBound, ArrayRef<Expr *> VarCnts) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPDistributeParallelForSimdDirective),
+                               llvm::alignOf<OMPClause *>()) +
+      sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 7 +
+      sizeof(Stmt *) * VarCnts.size() + 2);
+  OMPDistributeParallelForSimdDirective *Dir = new (Mem)
+      OMPDistributeParallelForSimdDirective(StartLoc, EndLoc, VarCnts.size(),
+                                            Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setLowerBound(LowerBound);
+  Dir->setUpperBound(UpperBound);
+  Dir->setCounters(VarCnts);
+  return Dir;
+}
+
+OMPDistributeParallelForSimdDirective *
+OMPDistributeParallelForSimdDirective::CreateEmpty(const ASTContext &C,
+                                                   unsigned N,
+                                                   unsigned CollapsedNum,
+                                                   EmptyShell) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPDistributeParallelForSimdDirective),
+                               llvm::alignOf<OMPClause *>()) +
+      sizeof(OMPClause *) * N + sizeof(Stmt *) * 7 +
+      sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPDistributeParallelForSimdDirective(CollapsedNum, N);
+}
+
+OMPTeamsDistributeParallelForDirective *
+OMPTeamsDistributeParallelForDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, Expr *LowerBound,
+    Expr *UpperBound, ArrayRef<Expr *> VarCnts) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPTeamsDistributeParallelForDirective),
+                               llvm::alignOf<OMPClause *>()) +
+      sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 7 +
+      sizeof(Stmt *) * VarCnts.size() + 2);
+  OMPTeamsDistributeParallelForDirective *Dir = new (Mem)
+      OMPTeamsDistributeParallelForDirective(StartLoc, EndLoc, VarCnts.size(),
+                                             Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setLowerBound(LowerBound);
+  Dir->setUpperBound(UpperBound);
+  Dir->setCounters(VarCnts);
+  return Dir;
+}
+
+OMPTeamsDistributeParallelForDirective *
+OMPTeamsDistributeParallelForDirective::CreateEmpty(const ASTContext &C,
+                                                    unsigned N,
+                                                    unsigned CollapsedNum,
                                                     EmptyShell) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPMasterDirective),
-                                           llvm::alignOf<Stmt *>());
-  void *Mem = C.Allocate(Size + sizeof(Stmt *));
-  return new (Mem) OMPMasterDirective();
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPTeamsDistributeParallelForDirective),
+                               llvm::alignOf<OMPClause *>()) +
+      sizeof(OMPClause *) * N + sizeof(Stmt *) * 7 +
+      sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPTeamsDistributeParallelForDirective(CollapsedNum, N);
 }
 
-OMPCriticalDirective *OMPCriticalDirective::Create(
-    const ASTContext &C, const DeclarationNameInfo &Name,
-    SourceLocation StartLoc, SourceLocation EndLoc, Stmt *AssociatedStmt) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPCriticalDirective),
-                                           llvm::alignOf<Stmt *>());
-  void *Mem = C.Allocate(Size + sizeof(Stmt *));
-  OMPCriticalDirective *Dir =
-      new (Mem) OMPCriticalDirective(Name, StartLoc, EndLoc);
+OMPTeamsDistributeParallelForSimdDirective *
+OMPTeamsDistributeParallelForSimdDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, Expr *LowerBound,
+    Expr *UpperBound, ArrayRef<Expr *> VarCnts) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(
+                     sizeof(OMPTeamsDistributeParallelForSimdDirective),
+                     llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 7 +
+                 sizeof(Stmt *) * VarCnts.size() + 2);
+  OMPTeamsDistributeParallelForSimdDirective *Dir =
+      new (Mem) OMPTeamsDistributeParallelForSimdDirective(
+          StartLoc, EndLoc, VarCnts.size(), Clauses.size());
+  Dir->setClauses(Clauses);
   Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setLowerBound(LowerBound);
+  Dir->setUpperBound(UpperBound);
+  Dir->setCounters(VarCnts);
   return Dir;
 }
 
-OMPCriticalDirective *OMPCriticalDirective::CreateEmpty(const ASTContext &C,
+OMPTeamsDistributeParallelForSimdDirective *
+OMPTeamsDistributeParallelForSimdDirective::CreateEmpty(const ASTContext &C,
+                                                        unsigned N,
+                                                        unsigned CollapsedNum,
                                                         EmptyShell) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPCriticalDirective),
-                                           llvm::alignOf<Stmt *>());
-  void *Mem = C.Allocate(Size + sizeof(Stmt *));
-  return new (Mem) OMPCriticalDirective();
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(
+                             sizeof(OMPTeamsDistributeParallelForSimdDirective),
+                             llvm::alignOf<OMPClause *>()) +
+                         sizeof(OMPClause *) * N + sizeof(Stmt *) * 7 +
+                         sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPTeamsDistributeParallelForSimdDirective(CollapsedNum, N);
 }
 
-OMPParallelForDirective *
-OMPParallelForDirective::Create(const ASTContext &C, SourceLocation StartLoc,
-                                SourceLocation EndLoc, unsigned CollapsedNum,
-                                ArrayRef<OMPClause *> Clauses,
-                                Stmt *AssociatedStmt) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPParallelForDirective),
-                                           llvm::alignOf<OMPClause *>());
+OMPTargetTeamsDistributeParallelForDirective *
+OMPTargetTeamsDistributeParallelForDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, Expr *LowerBound,
+    Expr *UpperBound, ArrayRef<Expr *> VarCnts) {
   void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
-  OMPParallelForDirective *Dir = new (Mem)
-      OMPParallelForDirective(StartLoc, EndLoc, CollapsedNum, Clauses.size());
+      C.Allocate(llvm::RoundUpToAlignment(
+                     sizeof(OMPTargetTeamsDistributeParallelForDirective),
+                     llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 7 +
+                 sizeof(Stmt *) * VarCnts.size() + 2);
+  OMPTargetTeamsDistributeParallelForDirective *Dir =
+      new (Mem) OMPTargetTeamsDistributeParallelForDirective(
+          StartLoc, EndLoc, VarCnts.size(), Clauses.size());
   Dir->setClauses(Clauses);
   Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setLowerBound(LowerBound);
+  Dir->setUpperBound(UpperBound);
+  Dir->setCounters(VarCnts);
   return Dir;
 }
 
-OMPParallelForDirective *
-OMPParallelForDirective::CreateEmpty(const ASTContext &C, unsigned NumClauses,
-                                     unsigned CollapsedNum, EmptyShell) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPParallelForDirective),
-                                           llvm::alignOf<OMPClause *>());
+OMPTargetTeamsDistributeParallelForDirective *
+OMPTargetTeamsDistributeParallelForDirective::CreateEmpty(const ASTContext &C,
+                                                          unsigned N,
+                                                          unsigned CollapsedNum,
+                                                          EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(
+                     sizeof(OMPTargetTeamsDistributeParallelForDirective),
+                     llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *) * 7 +
+                 sizeof(Stmt *) * CollapsedNum);
+  return new (Mem)
+      OMPTargetTeamsDistributeParallelForDirective(CollapsedNum, N);
+}
+
+OMPTargetTeamsDistributeParallelForSimdDirective *
+OMPTargetTeamsDistributeParallelForSimdDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, Expr *LowerBound,
+    Expr *UpperBound, ArrayRef<Expr *> VarCnts) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(
+                     sizeof(OMPTargetTeamsDistributeParallelForSimdDirective),
+                     llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 7 +
+                 sizeof(Stmt *) * VarCnts.size() + 2);
+  OMPTargetTeamsDistributeParallelForSimdDirective *Dir =
+      new (Mem) OMPTargetTeamsDistributeParallelForSimdDirective(
+          StartLoc, EndLoc, VarCnts.size(), Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setLowerBound(LowerBound);
+  Dir->setUpperBound(UpperBound);
+  Dir->setCounters(VarCnts);
+  return Dir;
+}
+
+OMPTargetTeamsDistributeParallelForSimdDirective *
+OMPTargetTeamsDistributeParallelForSimdDirective::CreateEmpty(
+    const ASTContext &C, unsigned N, unsigned CollapsedNum, EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(
+                     sizeof(OMPTargetTeamsDistributeParallelForSimdDirective),
+                     llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *) * 7 +
+                 sizeof(Stmt *) * CollapsedNum);
+  return new (Mem)
+      OMPTargetTeamsDistributeParallelForSimdDirective(CollapsedNum, N);
+}
+
+OMPSectionsDirective *OMPSectionsDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPSectionsDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
+  OMPSectionsDirective *Dir =
+      new (Mem) OMPSectionsDirective(StartLoc, EndLoc, Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  return Dir;
+}
+
+OMPSectionsDirective *
+OMPSectionsDirective::CreateEmpty(const ASTContext &C, unsigned N, EmptyShell) {
   void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * NumClauses + sizeof(Stmt *));
-  return new (Mem) OMPParallelForDirective(CollapsedNum, NumClauses);
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPSectionsDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *));
+  return new (Mem) OMPSectionsDirective(N);
 }
 
 OMPParallelSectionsDirective *OMPParallelSectionsDirective::Create(
     const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
     ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPParallelSectionsDirective),
-                                           llvm::alignOf<OMPClause *>());
   void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPParallelSectionsDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
   OMPParallelSectionsDirective *Dir =
       new (Mem) OMPParallelSectionsDirective(StartLoc, EndLoc, Clauses.size());
   Dir->setClauses(Clauses);
@@ -1578,13 +2096,58 @@
 }
 
 OMPParallelSectionsDirective *
-OMPParallelSectionsDirective::CreateEmpty(const ASTContext &C,
-                                          unsigned NumClauses, EmptyShell) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPParallelSectionsDirective),
-                                           llvm::alignOf<OMPClause *>());
+OMPParallelSectionsDirective::CreateEmpty(const ASTContext &C, unsigned N,
+                                          EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPParallelSectionsDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *));
+  return new (Mem) OMPParallelSectionsDirective(N);
+}
+
+OMPSectionDirective *OMPSectionDirective::Create(const ASTContext &C,
+                                                 SourceLocation StartLoc,
+                                                 SourceLocation EndLoc,
+                                                 Stmt *AssociatedStmt) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPSectionDirective),
+                                                  llvm::alignOf<Stmt *>()) +
+                         sizeof(Stmt *));
+  OMPSectionDirective *Dir = new (Mem) OMPSectionDirective(StartLoc, EndLoc);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  return Dir;
+}
+
+OMPSectionDirective *OMPSectionDirective::CreateEmpty(const ASTContext &C,
+                                                      EmptyShell) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPSectionDirective),
+                                                  llvm::alignOf<Stmt *>()) +
+                         sizeof(Stmt *));
+  return new (Mem) OMPSectionDirective();
+}
+
+OMPSingleDirective *OMPSingleDirective::Create(const ASTContext &C,
+                                               SourceLocation StartLoc,
+                                               SourceLocation EndLoc,
+                                               ArrayRef<OMPClause *> Clauses,
+                                               Stmt *AssociatedStmt) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPSingleDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
+  OMPSingleDirective *Dir =
+      new (Mem) OMPSingleDirective(StartLoc, EndLoc, Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  return Dir;
+}
+
+OMPSingleDirective *OMPSingleDirective::CreateEmpty(const ASTContext &C,
+                                                    unsigned N, EmptyShell) {
   void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * NumClauses + sizeof(Stmt *));
-  return new (Mem) OMPParallelSectionsDirective(NumClauses);
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPSingleDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *));
+  return new (Mem) OMPSingleDirective(N);
 }
 
 OMPTaskDirective *OMPTaskDirective::Create(const ASTContext &C,
@@ -1592,10 +2155,10 @@
                                            SourceLocation EndLoc,
                                            ArrayRef<OMPClause *> Clauses,
                                            Stmt *AssociatedStmt) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPTaskDirective),
-                                           llvm::alignOf<OMPClause *>());
   void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTaskDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
   OMPTaskDirective *Dir =
       new (Mem) OMPTaskDirective(StartLoc, EndLoc, Clauses.size());
   Dir->setClauses(Clauses);
@@ -1603,66 +2166,163 @@
   return Dir;
 }
 
-OMPTaskDirective *OMPTaskDirective::CreateEmpty(const ASTContext &C,
-                                                unsigned NumClauses,
+OMPTaskDirective *OMPTaskDirective::CreateEmpty(const ASTContext &C, unsigned N,
                                                 EmptyShell) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPTaskDirective),
-                                           llvm::alignOf<OMPClause *>());
   void *Mem =
-      C.Allocate(Size + sizeof(OMPClause *) * NumClauses + sizeof(Stmt *));
-  return new (Mem) OMPTaskDirective(NumClauses);
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTaskDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *));
+  return new (Mem) OMPTaskDirective(N);
 }
 
 OMPTaskyieldDirective *OMPTaskyieldDirective::Create(const ASTContext &C,
                                                      SourceLocation StartLoc,
                                                      SourceLocation EndLoc) {
-  void *Mem = C.Allocate(sizeof(OMPTaskyieldDirective));
-  OMPTaskyieldDirective *Dir =
-      new (Mem) OMPTaskyieldDirective(StartLoc, EndLoc);
-  return Dir;
+  void *Mem = C.Allocate(sizeof(OMPTaskyieldDirective),
+                         llvm::alignOf<OMPTaskyieldDirective>());
+  return new (Mem) OMPTaskyieldDirective(StartLoc, EndLoc);
 }
 
 OMPTaskyieldDirective *OMPTaskyieldDirective::CreateEmpty(const ASTContext &C,
                                                           EmptyShell) {
-  void *Mem = C.Allocate(sizeof(OMPTaskyieldDirective));
+  void *Mem = C.Allocate(sizeof(OMPTaskyieldDirective),
+                         llvm::alignOf<OMPTaskyieldDirective>());
   return new (Mem) OMPTaskyieldDirective();
 }
 
+OMPMasterDirective *OMPMasterDirective::Create(const ASTContext &C,
+                                               SourceLocation StartLoc,
+                                               SourceLocation EndLoc,
+                                               Stmt *AssociatedStmt) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPMasterDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(Stmt *));
+  OMPMasterDirective *Dir = new (Mem) OMPMasterDirective(StartLoc, EndLoc);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  return Dir;
+}
+
+OMPMasterDirective *OMPMasterDirective::CreateEmpty(const ASTContext &C,
+                                                    EmptyShell) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPMasterDirective),
+                                                  llvm::alignOf<Stmt *>()) +
+                         sizeof(Stmt *));
+  return new (Mem) OMPMasterDirective();
+}
+
+OMPCriticalDirective *OMPCriticalDirective::Create(const ASTContext &C,
+                                                   DeclarationNameInfo Name,
+                                                   SourceLocation StartLoc,
+                                                   SourceLocation EndLoc,
+                                                   Stmt *AssociatedStmt) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPCriticalDirective),
+                                                  llvm::alignOf<Stmt *>()) +
+                         sizeof(Stmt *));
+  OMPCriticalDirective *Dir =
+      new (Mem) OMPCriticalDirective(Name, StartLoc, EndLoc);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setDirectiveName(Name);
+  return Dir;
+}
+
+OMPCriticalDirective *OMPCriticalDirective::CreateEmpty(const ASTContext &C,
+                                                        EmptyShell) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPCriticalDirective),
+                                                  llvm::alignOf<Stmt *>()) +
+                         sizeof(Stmt *));
+  return new (Mem) OMPCriticalDirective();
+}
+
 OMPBarrierDirective *OMPBarrierDirective::Create(const ASTContext &C,
                                                  SourceLocation StartLoc,
                                                  SourceLocation EndLoc) {
-  void *Mem = C.Allocate(sizeof(OMPBarrierDirective));
-  OMPBarrierDirective *Dir = new (Mem) OMPBarrierDirective(StartLoc, EndLoc);
-  return Dir;
+  void *Mem = C.Allocate(sizeof(OMPBarrierDirective),
+                         llvm::alignOf<OMPBarrierDirective>());
+  return new (Mem) OMPBarrierDirective(StartLoc, EndLoc);
 }
 
 OMPBarrierDirective *OMPBarrierDirective::CreateEmpty(const ASTContext &C,
                                                       EmptyShell) {
-  void *Mem = C.Allocate(sizeof(OMPBarrierDirective));
+  void *Mem = C.Allocate(sizeof(OMPBarrierDirective),
+                         llvm::alignOf<OMPBarrierDirective>());
   return new (Mem) OMPBarrierDirective();
 }
 
 OMPTaskwaitDirective *OMPTaskwaitDirective::Create(const ASTContext &C,
                                                    SourceLocation StartLoc,
                                                    SourceLocation EndLoc) {
-  void *Mem = C.Allocate(sizeof(OMPTaskwaitDirective));
-  OMPTaskwaitDirective *Dir = new (Mem) OMPTaskwaitDirective(StartLoc, EndLoc);
-  return Dir;
+  void *Mem = C.Allocate(sizeof(OMPTaskwaitDirective),
+                         llvm::alignOf<OMPTaskwaitDirective>());
+  return new (Mem) OMPTaskwaitDirective(StartLoc, EndLoc);
 }
 
 OMPTaskwaitDirective *OMPTaskwaitDirective::CreateEmpty(const ASTContext &C,
                                                         EmptyShell) {
-  void *Mem = C.Allocate(sizeof(OMPTaskwaitDirective));
+  void *Mem = C.Allocate(sizeof(OMPTaskwaitDirective),
+                         llvm::alignOf<OMPTaskwaitDirective>());
   return new (Mem) OMPTaskwaitDirective();
 }
 
+OMPTaskgroupDirective *OMPTaskgroupDirective::Create(const ASTContext &C,
+                                                     SourceLocation StartLoc,
+                                                     SourceLocation EndLoc,
+                                                     Stmt *AssociatedStmt) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTaskgroupDirective),
+                                                  llvm::alignOf<Stmt *>()) +
+                         sizeof(Stmt *));
+  OMPTaskgroupDirective *Dir =
+      new (Mem) OMPTaskgroupDirective(StartLoc, EndLoc);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  return Dir;
+}
+
+OMPTaskgroupDirective *OMPTaskgroupDirective::CreateEmpty(const ASTContext &C,
+                                                          EmptyShell) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTaskgroupDirective),
+                                                  llvm::alignOf<Stmt *>()) +
+                         sizeof(Stmt *));
+  return new (Mem) OMPTaskgroupDirective();
+}
+
+OMPAtomicDirective *OMPAtomicDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *V, Expr *X,
+    Expr *OpExpr, BinaryOperatorKind Op, bool CaptureAfter, bool Reversed) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPAtomicDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 4);
+  OMPAtomicDirective *Dir =
+      new (Mem) OMPAtomicDirective(StartLoc, EndLoc, Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setOperator(Op);
+  Dir->setV(V);
+  Dir->setX(X);
+  Dir->setExpr(OpExpr);
+  Dir->setCaptureAfter(CaptureAfter);
+  Dir->setReversed(Reversed);
+  return Dir;
+}
+
+OMPAtomicDirective *OMPAtomicDirective::CreateEmpty(const ASTContext &C,
+                                                    unsigned N, EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPAtomicDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *) * 4);
+  return new (Mem) OMPAtomicDirective(N);
+}
+
 OMPFlushDirective *OMPFlushDirective::Create(const ASTContext &C,
                                              SourceLocation StartLoc,
                                              SourceLocation EndLoc,
                                              ArrayRef<OMPClause *> Clauses) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPFlushDirective),
-                                           llvm::alignOf<OMPClause *>());
-  void *Mem = C.Allocate(Size + sizeof(OMPClause *) * Clauses.size());
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPFlushDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size());
   OMPFlushDirective *Dir =
       new (Mem) OMPFlushDirective(StartLoc, EndLoc, Clauses.size());
   Dir->setClauses(Clauses);
@@ -1670,11 +2330,462 @@
 }
 
 OMPFlushDirective *OMPFlushDirective::CreateEmpty(const ASTContext &C,
-                                                  unsigned NumClauses,
-                                                  EmptyShell) {
-  unsigned Size = llvm::RoundUpToAlignment(sizeof(OMPFlushDirective),
-                                           llvm::alignOf<OMPClause *>());
-  void *Mem = C.Allocate(Size + sizeof(OMPClause *) * NumClauses);
-  return new (Mem) OMPFlushDirective(NumClauses);
+                                                  unsigned N, EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPFlushDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N);
+  return new (Mem) OMPFlushDirective(N);
+}
+
+OMPOrderedDirective *OMPOrderedDirective::Create(const ASTContext &C,
+                                                 SourceLocation StartLoc,
+                                                 SourceLocation EndLoc,
+                                                 Stmt *AssociatedStmt) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPOrderedDirective),
+                                                  llvm::alignOf<Stmt *>()) +
+                         sizeof(Stmt *));
+  OMPOrderedDirective *Dir = new (Mem) OMPOrderedDirective(StartLoc, EndLoc);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  return Dir;
+}
+
+OMPOrderedDirective *OMPOrderedDirective::CreateEmpty(const ASTContext &C,
+                                                      EmptyShell) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPOrderedDirective),
+                                                  llvm::alignOf<Stmt *>()) +
+                         sizeof(Stmt *));
+  return new (Mem) OMPOrderedDirective();
+}
+
+OMPTeamsDirective *OMPTeamsDirective::Create(const ASTContext &C,
+                                             SourceLocation StartLoc,
+                                             SourceLocation EndLoc,
+                                             ArrayRef<OMPClause *> Clauses,
+                                             Stmt *AssociatedStmt) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTeamsDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
+  OMPTeamsDirective *Dir =
+      new (Mem) OMPTeamsDirective(StartLoc, EndLoc, Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  return Dir;
+}
+
+OMPTeamsDirective *OMPTeamsDirective::CreateEmpty(const ASTContext &C,
+                                                  unsigned N, EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTeamsDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *));
+  return new (Mem) OMPTeamsDirective(N);
+}
+
+OMPDistributeDirective *OMPDistributeDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPDistributeDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * VarCnts.size());
+  OMPDistributeDirective *Dir = new (Mem)
+      OMPDistributeDirective(StartLoc, EndLoc, VarCnts.size(), Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setCounters(VarCnts);
+  return Dir;
+}
+
+OMPDistributeDirective *
+OMPDistributeDirective::CreateEmpty(const ASTContext &C, unsigned N,
+                                    unsigned CollapsedNum, EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPDistributeDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPDistributeDirective(CollapsedNum, N);
+}
+
+OMPCancelDirective *
+OMPCancelDirective::Create(const ASTContext &C, SourceLocation StartLoc,
+                           SourceLocation EndLoc, ArrayRef<OMPClause *> Clauses,
+                           OpenMPDirectiveKind ConstructType) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPCancelDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size());
+  OMPCancelDirective *Dir = new (Mem)
+      OMPCancelDirective(StartLoc, EndLoc, Clauses.size(), ConstructType);
+  Dir->setClauses(Clauses);
+  return Dir;
+}
+
+OMPCancelDirective *
+OMPCancelDirective::CreateEmpty(const ASTContext &C, unsigned N,
+                                OpenMPDirectiveKind ConstructType, EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPCancelDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N);
+  return new (Mem) OMPCancelDirective(N, ConstructType);
+}
+
+OMPCancellationPointDirective *OMPCancellationPointDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    OpenMPDirectiveKind ConstructType) {
+  void *Mem = C.Allocate(sizeof(OMPCancellationPointDirective),
+                         llvm::alignOf<OMPCancellationPointDirective>());
+  OMPCancellationPointDirective *Dir =
+      new (Mem) OMPCancellationPointDirective(StartLoc, EndLoc, ConstructType);
+  return Dir;
+}
+
+OMPCancellationPointDirective *OMPCancellationPointDirective::CreateEmpty(
+    const ASTContext &C, OpenMPDirectiveKind ConstructType, EmptyShell) {
+  void *Mem = C.Allocate(sizeof(OMPCancellationPointDirective),
+                         llvm::alignOf<OMPCancellationPointDirective>());
+  return new (Mem) OMPCancellationPointDirective(ConstructType);
+}
+
+OMPTargetDirective *OMPTargetDirective::Create(const ASTContext &C,
+                                               SourceLocation StartLoc,
+                                               SourceLocation EndLoc,
+                                               ArrayRef<OMPClause *> Clauses,
+                                               Stmt *AssociatedStmt) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTargetDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
+  OMPTargetDirective *Dir =
+      new (Mem) OMPTargetDirective(StartLoc, EndLoc, Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  return Dir;
+}
+
+OMPTargetDirective *OMPTargetDirective::CreateEmpty(const ASTContext &C,
+                                                    unsigned N, EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTargetDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *));
+  return new (Mem) OMPTargetDirective(N);
+}
+
+OMPTargetDataDirective *OMPTargetDataDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTargetDataDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
+  OMPTargetDataDirective *Dir =
+      new (Mem) OMPTargetDataDirective(StartLoc, EndLoc, Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  return Dir;
+}
+
+OMPTargetDataDirective *OMPTargetDataDirective::CreateEmpty(const ASTContext &C,
+                                                            unsigned N,
+                                                            EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTargetDataDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *));
+  return new (Mem) OMPTargetDataDirective(N);
+}
+
+OMPTeamsDistributeDirective *OMPTeamsDistributeDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTeamsDistributeDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * VarCnts.size());
+  OMPTeamsDistributeDirective *Dir = new (Mem) OMPTeamsDistributeDirective(
+      StartLoc, EndLoc, VarCnts.size(), Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setCounters(VarCnts);
+  return Dir;
+}
+
+OMPTeamsDistributeDirective *
+OMPTeamsDistributeDirective::CreateEmpty(const ASTContext &C, unsigned N,
+                                         unsigned CollapsedNum, EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTeamsDistributeDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *) * 5 +
+                 sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPTeamsDistributeDirective(CollapsedNum, N);
+}
+
+OMPTeamsDistributeSimdDirective *OMPTeamsDistributeSimdDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPTeamsDistributeSimdDirective),
+                               llvm::alignOf<OMPClause *>()) +
+      sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 5 +
+      sizeof(Stmt *) * VarCnts.size());
+  OMPTeamsDistributeSimdDirective *Dir =
+      new (Mem) OMPTeamsDistributeSimdDirective(StartLoc, EndLoc,
+                                                VarCnts.size(), Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setCounters(VarCnts);
+  return Dir;
+}
+
+OMPTeamsDistributeSimdDirective *OMPTeamsDistributeSimdDirective::CreateEmpty(
+    const ASTContext &C, unsigned N, unsigned CollapsedNum, EmptyShell) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPTeamsDistributeSimdDirective),
+                               llvm::alignOf<OMPClause *>()) +
+      sizeof(OMPClause *) * N + sizeof(Stmt *) * 5 +
+      sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPTeamsDistributeSimdDirective(CollapsedNum, N);
+}
+
+OMPTargetTeamsDistributeDirective *OMPTargetTeamsDistributeDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPTargetTeamsDistributeDirective),
+                               llvm::alignOf<OMPClause *>()) +
+      sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 5 +
+      sizeof(Stmt *) * VarCnts.size());
+  OMPTargetTeamsDistributeDirective *Dir = new (Mem)
+      OMPTargetTeamsDistributeDirective(StartLoc, EndLoc, VarCnts.size(),
+                                        Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setCounters(VarCnts);
+  return Dir;
+}
+
+OMPTargetTeamsDistributeDirective *
+OMPTargetTeamsDistributeDirective::CreateEmpty(const ASTContext &C, unsigned N,
+                                               unsigned CollapsedNum,
+                                               EmptyShell) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPTargetTeamsDistributeDirective),
+                               llvm::alignOf<OMPClause *>()) +
+      sizeof(OMPClause *) * N + sizeof(Stmt *) * 5 +
+      sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPTargetTeamsDistributeDirective(CollapsedNum, N);
+}
+
+OMPTargetTeamsDistributeSimdDirective *
+OMPTargetTeamsDistributeSimdDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *NewIterVar,
+    Expr *NewIterEnd, Expr *Init, Expr *Final, ArrayRef<Expr *> VarCnts) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPTargetTeamsDistributeSimdDirective),
+                               llvm::alignOf<OMPClause *>()) +
+      sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *) * 5 +
+      sizeof(Stmt *) * VarCnts.size());
+  OMPTargetTeamsDistributeSimdDirective *Dir = new (Mem)
+      OMPTargetTeamsDistributeSimdDirective(StartLoc, EndLoc, VarCnts.size(),
+                                            Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  Dir->setNewIterVar(NewIterVar);
+  Dir->setNewIterEnd(NewIterEnd);
+  Dir->setInit(Init);
+  Dir->setFinal(Final);
+  Dir->setCounters(VarCnts);
+  return Dir;
+}
+
+OMPTargetTeamsDistributeSimdDirective *
+OMPTargetTeamsDistributeSimdDirective::CreateEmpty(const ASTContext &C,
+                                                   unsigned N,
+                                                   unsigned CollapsedNum,
+                                                   EmptyShell) {
+  void *Mem = C.Allocate(
+      llvm::RoundUpToAlignment(sizeof(OMPTargetTeamsDistributeSimdDirective),
+                               llvm::alignOf<OMPClause *>()) +
+      sizeof(OMPClause *) * N + sizeof(Stmt *) * 5 +
+      sizeof(Stmt *) * CollapsedNum);
+  return new (Mem) OMPTargetTeamsDistributeSimdDirective(CollapsedNum, N);
+}
+
+CapturedStmt::Capture *CapturedStmt::getStoredCaptures() const {
+  unsigned Size = sizeof(CapturedStmt) + sizeof(Stmt *) * (NumCaptures + 1);
+
+  // Offset of the first Capture object.
+  unsigned FirstCaptureOffset =
+    llvm::RoundUpToAlignment(Size, llvm::alignOf<Capture>());
+
+  return reinterpret_cast<Capture *>(
+      reinterpret_cast<char *>(const_cast<CapturedStmt *>(this))
+      + FirstCaptureOffset);
+}
+
+OMPTargetUpdateDirective *
+OMPTargetUpdateDirective::Create(const ASTContext &C, SourceLocation StartLoc,
+                                 SourceLocation EndLoc,
+                                 ArrayRef<OMPClause *> Clauses) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTargetUpdateDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size());
+  OMPTargetUpdateDirective *Dir =
+      new (Mem) OMPTargetUpdateDirective(StartLoc, EndLoc, Clauses.size());
+  Dir->setClauses(Clauses);
+  return Dir;
+}
+
+OMPTargetUpdateDirective *
+OMPTargetUpdateDirective::CreateEmpty(const ASTContext &C, unsigned N,
+                                      EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTargetUpdateDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N);
+  return new (Mem) OMPTargetUpdateDirective(N);
+}
+
+OMPTargetTeamsDirective *OMPTargetTeamsDirective::Create(
+    const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,
+    ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTargetTeamsDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * Clauses.size() + sizeof(Stmt *));
+  OMPTargetTeamsDirective *Dir =
+      new (Mem) OMPTargetTeamsDirective(StartLoc, EndLoc, Clauses.size());
+  Dir->setClauses(Clauses);
+  Dir->setAssociatedStmt(AssociatedStmt);
+  return Dir;
+}
+
+OMPTargetTeamsDirective *
+OMPTargetTeamsDirective::CreateEmpty(const ASTContext &C, unsigned N,
+                                     EmptyShell) {
+  void *Mem =
+      C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPTargetTeamsDirective),
+                                          llvm::alignOf<OMPClause *>()) +
+                 sizeof(OMPClause *) * N + sizeof(Stmt *));
+  return new (Mem) OMPTargetTeamsDirective(N);
+}
+
+CapturedStmt::CapturedStmt(Stmt *S, CapturedRegionKind Kind,
+                           ArrayRef<Capture> Captures,
+                           ArrayRef<Expr *> CaptureInits,
+                           CapturedDecl *CD,
+                           RecordDecl *RD)
+  : Stmt(CapturedStmtClass), NumCaptures(Captures.size()),
+    TheCapturedDecl(CD), RegionKind(Kind), TheRecordDecl(RD) {
+  assert( S && "null captured statement");
+  assert(CD && "null captured declaration for captured statement");
+  assert(RD && "null record declaration for captured statement");
+
+  // Copy initialization expressions.
+  Stmt **Stored = getStoredStmts();
+  for (unsigned I = 0, N = NumCaptures; I != N; ++I)
+    *Stored++ = CaptureInits[I];
+
+  // Copy the statement being captured.
+  *Stored = S;
+
+  // Copy all Capture objects.
+  Capture *Buffer = getStoredCaptures();
+  std::copy(Captures.begin(), Captures.end(), Buffer);
+}
+
+CapturedStmt::CapturedStmt(EmptyShell Empty, unsigned NumCaptures)
+  : Stmt(CapturedStmtClass, Empty), NumCaptures(NumCaptures),
+    TheCapturedDecl(0), RegionKind(CR_Default), TheRecordDecl(nullptr) {
+  getStoredStmts()[NumCaptures] = nullptr;
+}
+
+CapturedStmt *CapturedStmt::Create(const ASTContext &Context, Stmt *S,
+                                   CapturedRegionKind Kind,
+                                   ArrayRef<Capture> Captures,
+                                   ArrayRef<Expr *> CaptureInits,
+                                   CapturedDecl *CD, RecordDecl *RD) {
+  // The layout is
+  //
+  // -----------------------------------------------------------
+  // | CapturedStmt, Init, ..., Init, S, Capture, ..., Capture |
+  // ----------------^-------------------^----------------------
+  //                 getStoredStmts()    getStoredCaptures()
+  //
+  // where S is the statement being captured.
+  //
+  assert(CaptureInits.size() == Captures.size() && "wrong number of arguments");
+
+  unsigned Size = sizeof(CapturedStmt) + sizeof(Stmt *) * (Captures.size() + 1);
+  if (!Captures.empty()) {
+    // Realign for the following Capture array.
+    Size = llvm::RoundUpToAlignment(Size, llvm::alignOf<Capture>());
+    Size += sizeof(Capture) * Captures.size();
+  }
+
+  void *Mem = Context.Allocate(Size);
+  return new (Mem) CapturedStmt(S, Kind, Captures, CaptureInits, CD, RD);
+}
+
+CapturedStmt *CapturedStmt::CreateDeserialized(const ASTContext &Context,
+                                               unsigned NumCaptures) {
+  unsigned Size = sizeof(CapturedStmt) + sizeof(Stmt *) * (NumCaptures + 1);
+  if (NumCaptures > 0) {
+    // Realign for the following Capture array.
+    Size = llvm::RoundUpToAlignment(Size, llvm::alignOf<Capture>());
+    Size += sizeof(Capture) * NumCaptures;
+  }
+
+  void *Mem = Context.Allocate(Size);
+  return new (Mem) CapturedStmt(EmptyShell(), NumCaptures);
+}
+
+Stmt::child_range CapturedStmt::children() {
+  // Children are captured field initilizers.
+  return child_range(getStoredStmts(), getStoredStmts() + NumCaptures);
+}
+
+bool CapturedStmt::capturesVariable(const VarDecl *Var) const {
+  for (const auto &I : captures()) {
+    if (!I.capturesVariable())
+      continue;
+
+    // This does not handle variable redeclarations. This should be
+    // extended to capture variables with redeclarations, for example
+    // a thread-private variable in OpenMP.
+    if (I.getCapturedVar() == Var)
+      return true;
+  }
+
+  return false;
 }
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/StmtPrinter.cpp cfe-3.5.0.src.omp/lib/AST/StmtPrinter.cpp
--- cfe-3.5.0.src/lib/AST/StmtPrinter.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/StmtPrinter.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -32,6 +32,7 @@
 
 namespace  {
   class StmtPrinter : public StmtVisitor<StmtPrinter> {
+    friend class OMPClausePrinter;
     raw_ostream &OS;
     unsigned IndentLevel;
     clang::PrinterHelper* Helper;
@@ -103,6 +104,7 @@
 #define STMT(CLASS, PARENT) \
     void Visit##CLASS(CLASS *Node);
 #include "clang/AST/StmtNodes.inc"
+    void VisitOMPExecutableDirective(OMPExecutableDirective *Node);
   };
 }
 
@@ -583,47 +585,47 @@
 //===----------------------------------------------------------------------===//
 
 namespace {
+
+/// \brief OMPClausePrinter class implements clause printing.
+///        It is used by OMPClause::printPretty().
 class OMPClausePrinter : public OMPClauseVisitor<OMPClausePrinter> {
   raw_ostream &OS;
   const PrintingPolicy &Policy;
-  /// \brief Process clauses with list of variables.
-  template <typename T>
-  void VisitOMPClauseList(T *Node, char StartSym);
+
 public:
-  OMPClausePrinter(raw_ostream &OS, const PrintingPolicy &Policy)
-    : OS(OS), Policy(Policy) { }
-#define OPENMP_CLAUSE(Name, Class)                              \
-  void Visit##Class(Class *S);
+  OMPClausePrinter(raw_ostream &OS, const PrintingPolicy &P)
+      : OS(OS), Policy(P) {}
+#define OPENMP_CLAUSE(Name, Class) void Visit##Class(Class *S);
 #include "clang/Basic/OpenMPKinds.def"
 };
 
 void OMPClausePrinter::VisitOMPIfClause(OMPIfClause *Node) {
   OS << "if(";
-  Node->getCondition()->printPretty(OS, nullptr, Policy, 0);
-  OS << ")";
-}
-
-void OMPClausePrinter::VisitOMPFinalClause(OMPFinalClause *Node) {
-  OS << "final(";
-  Node->getCondition()->printPretty(OS, nullptr, Policy, 0);
+  Node->getCondition()->printPretty(OS, 0, Policy, 0);
   OS << ")";
 }
 
 void OMPClausePrinter::VisitOMPNumThreadsClause(OMPNumThreadsClause *Node) {
   OS << "num_threads(";
-  Node->getNumThreads()->printPretty(OS, nullptr, Policy, 0);
+  Node->getNumThreads()->printPretty(OS, 0, Policy, 0);
   OS << ")";
 }
 
-void OMPClausePrinter::VisitOMPSafelenClause(OMPSafelenClause *Node) {
-  OS << "safelen(";
-  Node->getSafelen()->printPretty(OS, nullptr, Policy, 0);
+void OMPClausePrinter::VisitOMPFinalClause(OMPFinalClause *Node) {
+  OS << "final(";
+  Node->getCondition()->printPretty(OS, 0, Policy, 0);
   OS << ")";
 }
 
 void OMPClausePrinter::VisitOMPCollapseClause(OMPCollapseClause *Node) {
   OS << "collapse(";
-  Node->getNumForLoops()->printPretty(OS, nullptr, Policy, 0);
+  Node->getNumForLoops()->printPretty(OS, 0, Policy, 0);
+  OS << ")";
+}
+
+void OMPClausePrinter::VisitOMPDeviceClause(OMPDeviceClause *Node) {
+  OS << "device(";
+  Node->getDevice()->printPretty(OS, 0, Policy, 0);
   OS << ")";
 }
 
@@ -635,209 +637,401 @@
 
 void OMPClausePrinter::VisitOMPProcBindClause(OMPProcBindClause *Node) {
   OS << "proc_bind("
-     << getOpenMPSimpleClauseTypeName(OMPC_proc_bind, Node->getProcBindKind())
+     << getOpenMPSimpleClauseTypeName(OMPC_proc_bind, Node->getThreadAffinity())
      << ")";
 }
 
-void OMPClausePrinter::VisitOMPScheduleClause(OMPScheduleClause *Node) {
-  OS << "schedule("
-     << getOpenMPSimpleClauseTypeName(OMPC_schedule, Node->getScheduleKind());
-  if (Node->getChunkSize()) {
-    OS << ", ";
-    Node->getChunkSize()->printPretty(OS, nullptr, Policy);
+void OMPClausePrinter::VisitOMPPrivateClause(OMPPrivateClause *Node) {
+  if (!Node->varlist_empty()) {
+    OS << "private";
+    for (OMPPrivateClause::varlist_iterator I = Node->varlist_begin(),
+                                            E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? '(' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    }
+    OS << ")";
   }
-  OS << ")";
 }
 
-void OMPClausePrinter::VisitOMPOrderedClause(OMPOrderedClause *) {
-  OS << "ordered";
-}
-
-void OMPClausePrinter::VisitOMPNowaitClause(OMPNowaitClause *) {
-  OS << "nowait";
+void OMPClausePrinter::VisitOMPFirstPrivateClause(OMPFirstPrivateClause *Node) {
+  if (!Node->varlist_empty()) {
+    OS << "firstprivate";
+    for (OMPFirstPrivateClause::varlist_iterator I = Node->varlist_begin(),
+                                                 E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? '(' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    }
+    OS << ")";
+  }
 }
 
-void OMPClausePrinter::VisitOMPUntiedClause(OMPUntiedClause *) {
-  OS << "untied";
+void OMPClausePrinter::VisitOMPSharedClause(OMPSharedClause *Node) {
+  if (!Node->varlist_empty()) {
+    OS << "shared";
+    for (OMPSharedClause::varlist_iterator I = Node->varlist_begin(),
+                                           E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? '(' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    }
+    OS << ")";
+  }
 }
 
-void OMPClausePrinter::VisitOMPMergeableClause(OMPMergeableClause *) {
-  OS << "mergeable";
+void OMPClausePrinter::VisitOMPCopyinClause(OMPCopyinClause *Node) {
+  if (!Node->varlist_empty()) {
+    OS << "copyin";
+    for (OMPCopyinClause::varlist_iterator I = Node->varlist_begin(),
+                                           E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? '(' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    }
+    OS << ")";
+  }
 }
 
-template<typename T>
-void OMPClausePrinter::VisitOMPClauseList(T *Node, char StartSym) {
-  for (typename T::varlist_iterator I = Node->varlist_begin(),
-                                    E = Node->varlist_end();
+void OMPClausePrinter::VisitOMPCopyPrivateClause(OMPCopyPrivateClause *Node) {
+  if (!Node->varlist_empty()) {
+    OS << "copyprivate";
+    for (OMPCopyinClause::varlist_iterator I = Node->varlist_begin(),
+                                           E = Node->varlist_end();
          I != E; ++I) {
-    assert(*I && "Expected non-null Stmt");
-    if (DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(*I)) {
-      OS << (I == Node->varlist_begin() ? StartSym : ',');
-      cast<NamedDecl>(DRE->getDecl())->printQualifiedName(OS);
-    } else {
-      OS << (I == Node->varlist_begin() ? StartSym : ',');
-      (*I)->printPretty(OS, nullptr, Policy, 0);
+      OS << (I == Node->varlist_begin() ? '(' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
     }
+    OS << ")";
   }
 }
 
-void OMPClausePrinter::VisitOMPPrivateClause(OMPPrivateClause *Node) {
+void OMPClausePrinter::VisitOMPReductionClause(OMPReductionClause *Node) {
   if (!Node->varlist_empty()) {
-    OS << "private";
-    VisitOMPClauseList(Node, '(');
+    OS << "reduction(";
+    if (Node->getOperator() == OMPC_REDUCTION_custom) {
+      if (NestedNameSpecifier *Qual = Node->getSpec().getNestedNameSpecifier())
+        Qual->print(OS, Policy);
+      OS << Node->getOpName();
+    } else {
+      OS << getOpenMPSimpleClauseTypeName(OMPC_reduction, Node->getOperator());
+    }
+    OS << ':';
+
+    for (OMPReductionClause::varlist_iterator I = Node->varlist_begin(),
+                                              E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? ' ' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    }
     OS << ")";
   }
 }
 
-void OMPClausePrinter::VisitOMPFirstprivateClause(OMPFirstprivateClause *Node) {
+void OMPClausePrinter::VisitOMPLastPrivateClause(OMPLastPrivateClause *Node) {
   if (!Node->varlist_empty()) {
-    OS << "firstprivate";
-    VisitOMPClauseList(Node, '(');
+    OS << "lastprivate";
+    for (OMPLastPrivateClause::varlist_iterator I = Node->varlist_begin(),
+                                                E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? '(' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    }
     OS << ")";
   }
 }
 
-void OMPClausePrinter::VisitOMPLastprivateClause(OMPLastprivateClause *Node) {
+void OMPClausePrinter::VisitOMPMapClause(OMPMapClause *Node) {
   if (!Node->varlist_empty()) {
-    OS << "lastprivate";
-    VisitOMPClauseList(Node, '(');
+    OS << "map(";
+    OS << getOpenMPSimpleClauseTypeName(OMPC_map, Node->getKind());
+    OS << ':';
+
+    for (OMPMapClause::varlist_iterator I = Node->varlist_begin(),
+                                        E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? ' ' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    }
     OS << ")";
   }
 }
 
-void OMPClausePrinter::VisitOMPSharedClause(OMPSharedClause *Node) {
+void OMPClausePrinter::VisitOMPToClause(OMPToClause *Node) {
   if (!Node->varlist_empty()) {
-    OS << "shared";
-    VisitOMPClauseList(Node, '(');
+    OS << "to";
+    for (OMPToClause::varlist_iterator I = Node->varlist_begin(),
+                                       E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? '(' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    }
     OS << ")";
   }
 }
 
-void OMPClausePrinter::VisitOMPReductionClause(OMPReductionClause *Node) {
+void OMPClausePrinter::VisitOMPFromClause(OMPFromClause *Node) {
   if (!Node->varlist_empty()) {
-    OS << "reduction(";
-    NestedNameSpecifier *QualifierLoc =
-        Node->getQualifierLoc().getNestedNameSpecifier();
-    OverloadedOperatorKind OOK =
-        Node->getNameInfo().getName().getCXXOverloadedOperator();
-    if (QualifierLoc == nullptr && OOK != OO_None) {
-      // Print reduction identifier in C format
-      OS << getOperatorSpelling(OOK);
-    } else {
-      // Use C++ format
-      if (QualifierLoc != nullptr)
-        QualifierLoc->print(OS, Policy);
-      OS << Node->getNameInfo();
+    OS << "from";
+    for (OMPFromClause::varlist_iterator I = Node->varlist_begin(),
+                                         E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? '(' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
     }
-    OS << ":";
-    VisitOMPClauseList(Node, ' ');
     OS << ")";
   }
 }
 
-void OMPClausePrinter::VisitOMPLinearClause(OMPLinearClause *Node) {
+void OMPClausePrinter::VisitOMPScheduleClause(OMPScheduleClause *Node) {
+  OS << "schedule("
+     << getOpenMPSimpleClauseTypeName(OMPC_schedule, Node->getScheduleKind());
+  if (Node->getChunkSize()) {
+    OS << ", ";
+    Node->getChunkSize()->printPretty(OS, 0, Policy, 0);
+  }
+  OS << ")";
+}
+
+void OMPClausePrinter::VisitOMPDistScheduleClause(OMPDistScheduleClause *Node) {
+  OS << "dist_schedule("
+     << getOpenMPSimpleClauseTypeName(OMPC_dist_schedule,
+                                      Node->getDistScheduleKind());
+  if (Node->getDistChunkSize()) {
+    OS << ", ";
+    Node->getDistChunkSize()->printPretty(OS, 0, Policy, 0);
+  }
+  OS << ")";
+}
+
+void OMPClausePrinter::VisitOMPOrderedClause(OMPOrderedClause *Node) {
+  OS << "ordered";
+}
+
+void OMPClausePrinter::VisitOMPNowaitClause(OMPNowaitClause *Node) {
+  OS << "nowait";
+}
+
+void OMPClausePrinter::VisitOMPUntiedClause(OMPUntiedClause *Node) {
+  OS << "untied";
+}
+
+void OMPClausePrinter::VisitOMPMergeableClause(OMPMergeableClause *Node) {
+  OS << "mergeable";
+}
+
+void OMPClausePrinter::VisitOMPReadClause(OMPReadClause *Node) { OS << "read"; }
+
+void OMPClausePrinter::VisitOMPWriteClause(OMPWriteClause *Node) {
+  OS << "write";
+}
+
+void OMPClausePrinter::VisitOMPUpdateClause(OMPUpdateClause *Node) {
+  OS << "update";
+}
+
+void OMPClausePrinter::VisitOMPCaptureClause(OMPCaptureClause *Node) {
+  OS << "capture";
+}
+
+void OMPClausePrinter::VisitOMPSeqCstClause(OMPSeqCstClause *Node) {
+  OS << "seq_cst";
+}
+
+void OMPClausePrinter::VisitOMPInBranchClause(OMPInBranchClause *Node) {
+  OS << "inbranch";
+}
+
+void OMPClausePrinter::VisitOMPNotInBranchClause(OMPNotInBranchClause *Node) {
+  OS << "notinbranch";
+}
+
+void OMPClausePrinter::VisitOMPFlushClause(OMPFlushClause *Node) {
   if (!Node->varlist_empty()) {
-    OS << "linear";
-    VisitOMPClauseList(Node, '(');
-    if (Node->getStep() != nullptr) {
-      OS << ": ";
-      Node->getStep()->printPretty(OS, nullptr, Policy, 0);
+    for (OMPFlushClause::varlist_iterator I = Node->varlist_begin(),
+                                          E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? '(' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
     }
     OS << ")";
   }
 }
 
-void OMPClausePrinter::VisitOMPAlignedClause(OMPAlignedClause *Node) {
+void OMPClausePrinter::VisitOMPDependClause(OMPDependClause *Node) {
   if (!Node->varlist_empty()) {
-    OS << "aligned";
-    VisitOMPClauseList(Node, '(');
-    if (Node->getAlignment() != nullptr) {
-      OS << ": ";
-      Node->getAlignment()->printPretty(OS, nullptr, Policy, 0);
+    OS << "depend(";
+    OS << getOpenMPSimpleClauseTypeName(OMPC_depend, Node->getType());
+    OS << ':';
+
+    for (OMPDependClause::varlist_iterator I = Node->varlist_begin(),
+                                           E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? ' ' : ',');
+      /// static_cast<StmtPrinter*>(Printer)->PrintExpr(*I);
+      (*I)->printPretty(OS, 0, Policy, 0);
     }
     OS << ")";
   }
 }
 
-void OMPClausePrinter::VisitOMPCopyinClause(OMPCopyinClause *Node) {
+void OMPClausePrinter::VisitOMPUniformClause(OMPUniformClause *Node) {
   if (!Node->varlist_empty()) {
-    OS << "copyin";
-    VisitOMPClauseList(Node, '(');
+    OS << "uniform";
+    for (OMPUniformClause::varlist_iterator I = Node->varlist_begin(),
+                                            E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? '(' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    }
     OS << ")";
   }
 }
 
-void OMPClausePrinter::VisitOMPCopyprivateClause(OMPCopyprivateClause *Node) {
+void OMPClausePrinter::VisitOMPSafelenClause(OMPSafelenClause *Node) {
+  OS << "safelen(";
+  Node->getSafelen()->printPretty(OS, 0, Policy, 0);
+  OS << ")";
+}
+
+void OMPClausePrinter::VisitOMPSimdlenClause(OMPSimdlenClause *Node) {
+  OS << "simdlen(";
+  Node->getSimdlen()->printPretty(OS, 0, Policy, 0);
+  OS << ")";
+}
+
+void OMPClausePrinter::VisitOMPNumTeamsClause(OMPNumTeamsClause *Node) {
+  OS << "num_teams(";
+  Node->getNumTeams()->printPretty(OS, 0, Policy, 0);
+  OS << ")";
+}
+
+void OMPClausePrinter::VisitOMPThreadLimitClause(OMPThreadLimitClause *Node) {
+  OS << "thread_limit(";
+  Node->getThreadLimit()->printPretty(OS, 0, Policy, 0);
+  OS << ")";
+}
+
+void OMPClausePrinter::VisitOMPLinearClause(OMPLinearClause *Node) {
   if (!Node->varlist_empty()) {
-    OS << "copyprivate";
-    VisitOMPClauseList(Node, '(');
+    OS << "linear";
+    for (OMPLinearClause::varlist_iterator I = Node->varlist_begin(),
+                                           E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? '(' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    }
+    if (Node->getStep() != 0) {
+      OS << ": ";
+      Node->getStep()->printPretty(OS, 0, Policy, 0);
+    }
     OS << ")";
   }
 }
 
-void OMPClausePrinter::VisitOMPFlushClause(OMPFlushClause *Node) {
+void OMPClausePrinter::VisitOMPAlignedClause(OMPAlignedClause *Node) {
   if (!Node->varlist_empty()) {
-    VisitOMPClauseList(Node, '(');
+    OS << "aligned";
+    for (OMPAlignedClause::varlist_iterator I = Node->varlist_begin(),
+                                            E = Node->varlist_end();
+         I != E; ++I) {
+      OS << (I == Node->varlist_begin() ? '(' : ',')
+         << *cast<NamedDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    }
+    if (Node->getAlignment() != 0) {
+      OS << ": ";
+      Node->getAlignment()->printPretty(OS, 0, Policy, 0);
+    }
     OS << ")";
   }
 }
 }
 
+void OMPClause::printPretty(raw_ostream &OS, PrinterHelper *Helper,
+                            const PrintingPolicy &Policy,
+                            unsigned Indentation) const {
+
+  OMPClausePrinter P(OS, Policy);
+  P.Visit(const_cast<OMPClause *>(this));
+}
+
 //===----------------------------------------------------------------------===//
 //  OpenMP directives printing methods
 //===----------------------------------------------------------------------===//
 
-void StmtPrinter::PrintOMPExecutableDirective(OMPExecutableDirective *S) {
-  OMPClausePrinter Printer(OS, Policy);
-  ArrayRef<OMPClause *> Clauses = S->clauses();
+void StmtPrinter::VisitOMPExecutableDirective(OMPExecutableDirective *Node) {
+  ArrayRef<OMPClause *> Clauses = Node->clauses();
   for (ArrayRef<OMPClause *>::iterator I = Clauses.begin(), E = Clauses.end();
        I != E; ++I)
     if (*I && !(*I)->isImplicit()) {
-      Printer.Visit(*I);
+      const OMPClause *CurCL = cast_or_null<OMPClause>(*I);
+      CurCL->printPretty(OS, Helper, Policy, IndentLevel);
       OS << ' ';
     }
   OS << "\n";
-  if (S->hasAssociatedStmt() && S->getAssociatedStmt()) {
-    assert(isa<CapturedStmt>(S->getAssociatedStmt()) &&
+  if (Node->hasAssociatedStmt() && Node->getAssociatedStmt()) {
+    assert(isa<CapturedStmt>(Node->getAssociatedStmt()) &&
            "Expected captured statement!");
-    Stmt *CS = cast<CapturedStmt>(S->getAssociatedStmt())->getCapturedStmt();
+    Stmt *CS = cast<CapturedStmt>(Node->getAssociatedStmt())->getCapturedStmt();
     PrintStmt(CS);
   }
 }
 
 void StmtPrinter::VisitOMPParallelDirective(OMPParallelDirective *Node) {
   Indent() << "#pragma omp parallel ";
-  PrintOMPExecutableDirective(Node);
+  VisitOMPExecutableDirective(Node);
 }
 
-void StmtPrinter::VisitOMPSimdDirective(OMPSimdDirective *Node) {
-  Indent() << "#pragma omp simd ";
-  PrintOMPExecutableDirective(Node);
+void StmtPrinter::VisitOMPParallelForDirective(OMPParallelForDirective *Node) {
+  Indent() << "#pragma omp parallel for ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPParallelForSimdDirective(
+    OMPParallelForSimdDirective *Node) {
+  Indent() << "#pragma omp parallel for simd ";
+  VisitOMPExecutableDirective(Node);
 }
 
 void StmtPrinter::VisitOMPForDirective(OMPForDirective *Node) {
   Indent() << "#pragma omp for ";
-  PrintOMPExecutableDirective(Node);
+  VisitOMPExecutableDirective(Node);
 }
 
 void StmtPrinter::VisitOMPSectionsDirective(OMPSectionsDirective *Node) {
   Indent() << "#pragma omp sections ";
-  PrintOMPExecutableDirective(Node);
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPParallelSectionsDirective(
+    OMPParallelSectionsDirective *Node) {
+  Indent() << "#pragma omp parallel sections ";
+  VisitOMPExecutableDirective(Node);
 }
 
 void StmtPrinter::VisitOMPSectionDirective(OMPSectionDirective *Node) {
   Indent() << "#pragma omp section";
-  PrintOMPExecutableDirective(Node);
+  VisitOMPExecutableDirective(Node);
 }
 
 void StmtPrinter::VisitOMPSingleDirective(OMPSingleDirective *Node) {
   Indent() << "#pragma omp single ";
-  PrintOMPExecutableDirective(Node);
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTaskDirective(OMPTaskDirective *Node) {
+  Indent() << "#pragma omp task ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTaskyieldDirective(OMPTaskyieldDirective *Node) {
+  Indent() << "#pragma omp taskyield";
+  VisitOMPExecutableDirective(Node);
 }
 
 void StmtPrinter::VisitOMPMasterDirective(OMPMasterDirective *Node) {
   Indent() << "#pragma omp master";
-  PrintOMPExecutableDirective(Node);
+  VisitOMPExecutableDirective(Node);
 }
 
 void StmtPrinter::VisitOMPCriticalDirective(OMPCriticalDirective *Node) {
@@ -847,43 +1041,156 @@
     Node->getDirectiveName().printName(OS);
     OS << ")";
   }
-  PrintOMPExecutableDirective(Node);
+  VisitOMPExecutableDirective(Node);
 }
 
-void StmtPrinter::VisitOMPParallelForDirective(OMPParallelForDirective *Node) {
-  Indent() << "#pragma omp parallel for ";
-  PrintOMPExecutableDirective(Node);
+void StmtPrinter::VisitOMPBarrierDirective(OMPBarrierDirective *Node) {
+  Indent() << "#pragma omp barrier";
+  VisitOMPExecutableDirective(Node);
 }
 
-void StmtPrinter::VisitOMPParallelSectionsDirective(
-    OMPParallelSectionsDirective *Node) {
-  Indent() << "#pragma omp parallel sections ";
-  PrintOMPExecutableDirective(Node);
+void StmtPrinter::VisitOMPTaskwaitDirective(OMPTaskwaitDirective *Node) {
+  Indent() << "#pragma omp taskwait";
+  VisitOMPExecutableDirective(Node);
 }
 
-void StmtPrinter::VisitOMPTaskDirective(OMPTaskDirective *Node) {
-  Indent() << "#pragma omp task ";
-  PrintOMPExecutableDirective(Node);
+void StmtPrinter::VisitOMPTaskgroupDirective(OMPTaskgroupDirective *Node) {
+  Indent() << "#pragma omp taskgroup";
+  VisitOMPExecutableDirective(Node);
 }
 
-void StmtPrinter::VisitOMPTaskyieldDirective(OMPTaskyieldDirective *Node) {
-  Indent() << "#pragma omp taskyield";
-  PrintOMPExecutableDirective(Node);
+void StmtPrinter::VisitOMPAtomicDirective(OMPAtomicDirective *Node) {
+  Indent() << "#pragma omp atomic ";
+  VisitOMPExecutableDirective(Node);
 }
 
-void StmtPrinter::VisitOMPBarrierDirective(OMPBarrierDirective *Node) {
-  Indent() << "#pragma omp barrier";
-  PrintOMPExecutableDirective(Node);
+void StmtPrinter::VisitOMPFlushDirective(OMPFlushDirective *Node) {
+  Indent() << "#pragma omp flush";
+  VisitOMPExecutableDirective(Node);
 }
 
-void StmtPrinter::VisitOMPTaskwaitDirective(OMPTaskwaitDirective *Node) {
-  Indent() << "#pragma omp taskwait";
-  PrintOMPExecutableDirective(Node);
+void StmtPrinter::VisitOMPOrderedDirective(OMPOrderedDirective *Node) {
+  Indent() << "#pragma omp ordered";
+  VisitOMPExecutableDirective(Node);
 }
 
-void StmtPrinter::VisitOMPFlushDirective(OMPFlushDirective *Node) {
-  Indent() << "#pragma omp flush ";
-  PrintOMPExecutableDirective(Node);
+void StmtPrinter::VisitOMPSimdDirective(OMPSimdDirective *Node) {
+  Indent() << "#pragma omp simd ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPForSimdDirective(OMPForSimdDirective *Node) {
+  Indent() << "#pragma omp for simd ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void
+StmtPrinter::VisitOMPDistributeSimdDirective(OMPDistributeSimdDirective *Node) {
+  Indent() << "#pragma omp distribute simd ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPDistributeParallelForDirective(
+    OMPDistributeParallelForDirective *Node) {
+  Indent() << "#pragma omp distribute parallel for ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPDistributeParallelForSimdDirective(
+    OMPDistributeParallelForSimdDirective *Node) {
+  Indent() << "#pragma omp distribute parallel for simd ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTeamsDistributeParallelForDirective(
+    OMPTeamsDistributeParallelForDirective *Node) {
+  Indent() << "#pragma omp teams distribute parallel for ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTeamsDistributeParallelForSimdDirective(
+    OMPTeamsDistributeParallelForSimdDirective *Node) {
+  Indent() << "#pragma omp teams distribute parallel for simd ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTargetTeamsDistributeParallelForDirective(
+    OMPTargetTeamsDistributeParallelForDirective *Node) {
+  Indent() << "#pragma omp target teams distribute parallel for ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTargetTeamsDistributeParallelForSimdDirective(
+    OMPTargetTeamsDistributeParallelForSimdDirective *Node) {
+  Indent() << "#pragma omp target teams distribute parallel for simd ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTeamsDirective(OMPTeamsDirective *Node) {
+  Indent() << "#pragma omp teams ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPDistributeDirective(OMPDistributeDirective *Node) {
+  Indent() << "#pragma omp distribute ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPCancelDirective(OMPCancelDirective *Node) {
+  Indent() << "#pragma omp cancel "
+           << getOpenMPDirectiveName(Node->getConstructType()) << " ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPCancellationPointDirective(
+    OMPCancellationPointDirective *Node) {
+  Indent() << "#pragma omp cancellation point "
+           << getOpenMPDirectiveName(Node->getConstructType());
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTargetDirective(OMPTargetDirective *Node) {
+  Indent() << "#pragma omp target ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTargetDataDirective(OMPTargetDataDirective *Node) {
+  Indent() << "#pragma omp target data ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTargetUpdateDirective(OMPTargetUpdateDirective *Node) {
+  Indent() << "#pragma omp target update ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTargetTeamsDirective(OMPTargetTeamsDirective *Node) {
+  Indent() << "#pragma omp target teams ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTeamsDistributeDirective(
+    OMPTeamsDistributeDirective *Node) {
+  Indent() << "#pragma omp teams distribute ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTeamsDistributeSimdDirective(
+    OMPTeamsDistributeSimdDirective *Node) {
+  Indent() << "#pragma omp teams distribute simd ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTargetTeamsDistributeDirective(
+    OMPTargetTeamsDistributeDirective *Node) {
+  Indent() << "#pragma omp target teams distribute ";
+  VisitOMPExecutableDirective(Node);
+}
+
+void StmtPrinter::VisitOMPTargetTeamsDistributeSimdDirective(
+    OMPTargetTeamsDistributeSimdDirective *Node) {
+  Indent() << "#pragma omp target teams distribute simd ";
+  VisitOMPExecutableDirective(Node);
 }
 
 //===----------------------------------------------------------------------===//
@@ -1206,6 +1513,14 @@
   OS << "]";
 }
 
+void StmtPrinter::VisitCEANIndexExpr(CEANIndexExpr *Node) {
+  if (Node->getLowerBound() && Node->getLowerBound()->getLocStart().isValid())
+    PrintExpr(Node->getLowerBound());
+  OS << ":";
+  if (Node->getLength() && Node->getLength()->getLocStart().isValid())
+    PrintExpr(Node->getLength());
+}
+
 void StmtPrinter::PrintCallArgs(CallExpr *Call) {
   for (unsigned i = 0, e = Call->getNumArgs(); i != e; ++i) {
     if (isa<CXXDefaultArgExpr>(Call->getArg(i))) {
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/AST/StmtProfile.cpp cfe-3.5.0.src.omp/lib/AST/StmtProfile.cpp
--- cfe-3.5.0.src/lib/AST/StmtProfile.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/AST/StmtProfile.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -258,176 +258,201 @@
 namespace {
 class OMPClauseProfiler : public ConstOMPClauseVisitor<OMPClauseProfiler> {
   StmtProfiler *Profiler;
-  /// \brief Process clauses with list of variables.
-  template <typename T>
-  void VisitOMPClauseList(T *Node);
 public:
   OMPClauseProfiler(StmtProfiler *P) : Profiler(P) { }
 #define OPENMP_CLAUSE(Name, Class)                                             \
-  void Visit##Class(const Class *C);
+  void Visit##Class(const Class *S) {                                          \
+    for (ConstStmtRange Range = static_cast<const OMPClause *>(S)->children(); \
+         Range; ++Range)                                                       \
+      Profiler->VisitStmt(*Range);                                             \
+  }
 #include "clang/Basic/OpenMPKinds.def"
 };
+}
 
-void OMPClauseProfiler::VisitOMPIfClause(const OMPIfClause *C) {
-  if (C->getCondition())
-    Profiler->VisitStmt(C->getCondition());
+void
+StmtProfiler::VisitOMPExecutableDirective(const OMPExecutableDirective *S) {
+  VisitStmt(S);
+  OMPClauseProfiler P(this);
+  ArrayRef<OMPClause *> Clauses = S->clauses();
+  for (ArrayRef<OMPClause *>::iterator I = Clauses.begin(), E = Clauses.end();
+       I != E; ++I)
+    if (*I)
+      P.Visit(*I);
 }
 
-void OMPClauseProfiler::VisitOMPFinalClause(const OMPFinalClause *C) {
-  if (C->getCondition())
-    Profiler->VisitStmt(C->getCondition());
+void StmtProfiler::VisitOMPParallelDirective(const OMPParallelDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
 
-void OMPClauseProfiler::VisitOMPNumThreadsClause(const OMPNumThreadsClause *C) {
-  if (C->getNumThreads())
-    Profiler->VisitStmt(C->getNumThreads());
+void
+StmtProfiler::VisitOMPParallelForDirective(const OMPParallelForDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
 
-void OMPClauseProfiler::VisitOMPSafelenClause(const OMPSafelenClause *C) {
-  if (C->getSafelen())
-    Profiler->VisitStmt(C->getSafelen());
+void StmtProfiler::VisitOMPParallelForSimdDirective(
+    const OMPParallelForSimdDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
 
-void OMPClauseProfiler::VisitOMPCollapseClause(const OMPCollapseClause *C) {
-  if (C->getNumForLoops())
-    Profiler->VisitStmt(C->getNumForLoops());
+void StmtProfiler::VisitOMPForDirective(const OMPForDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
 
-void OMPClauseProfiler::VisitOMPDefaultClause(const OMPDefaultClause *C) { }
+void StmtProfiler::VisitOMPSimdDirective(const OMPSimdDirective *S) {
+  VisitOMPExecutableDirective(S);
+}
 
-void OMPClauseProfiler::VisitOMPProcBindClause(const OMPProcBindClause *C) { }
+void StmtProfiler::VisitOMPForSimdDirective(const OMPForSimdDirective *S) {
+  VisitOMPExecutableDirective(S);
+}
 
-void OMPClauseProfiler::VisitOMPScheduleClause(const OMPScheduleClause *C) {
-  if (C->getChunkSize())
-    Profiler->VisitStmt(C->getChunkSize());
+void StmtProfiler::VisitOMPDistributeSimdDirective(
+    const OMPDistributeSimdDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
 
-void OMPClauseProfiler::VisitOMPOrderedClause(const OMPOrderedClause *) {}
+void StmtProfiler::VisitOMPDistributeParallelForDirective(
+    const OMPDistributeParallelForDirective *S) {
+  VisitOMPExecutableDirective(S);
+}
 
-void OMPClauseProfiler::VisitOMPNowaitClause(const OMPNowaitClause *) {}
+void StmtProfiler::VisitOMPDistributeParallelForSimdDirective(
+    const OMPDistributeParallelForSimdDirective *S) {
+  VisitOMPExecutableDirective(S);
+}
 
-void OMPClauseProfiler::VisitOMPUntiedClause(const OMPUntiedClause *) {}
+void StmtProfiler::VisitOMPTeamsDistributeParallelForDirective(
+    const OMPTeamsDistributeParallelForDirective *S) {
+  VisitOMPExecutableDirective(S);
+}
 
-void OMPClauseProfiler::VisitOMPMergeableClause(const OMPMergeableClause *) {}
+void StmtProfiler::VisitOMPTeamsDistributeParallelForSimdDirective(
+    const OMPTeamsDistributeParallelForSimdDirective *S) {
+  VisitOMPExecutableDirective(S);
+}
 
-template<typename T>
-void OMPClauseProfiler::VisitOMPClauseList(T *Node) {
-  for (auto *I : Node->varlists())
-    Profiler->VisitStmt(I);
+void StmtProfiler::VisitOMPTargetTeamsDistributeParallelForDirective(
+    const OMPTargetTeamsDistributeParallelForDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
 
-void OMPClauseProfiler::VisitOMPPrivateClause(const OMPPrivateClause *C) {
-  VisitOMPClauseList(C);
+void StmtProfiler::VisitOMPTargetTeamsDistributeParallelForSimdDirective(
+    const OMPTargetTeamsDistributeParallelForSimdDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
-void OMPClauseProfiler::VisitOMPFirstprivateClause(
-                                         const OMPFirstprivateClause *C) {
-  VisitOMPClauseList(C);
+
+void StmtProfiler::VisitOMPSectionsDirective(const OMPSectionsDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
-void
-OMPClauseProfiler::VisitOMPLastprivateClause(const OMPLastprivateClause *C) {
-  VisitOMPClauseList(C);
+
+void StmtProfiler::VisitOMPParallelSectionsDirective(
+    const OMPParallelSectionsDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
-void OMPClauseProfiler::VisitOMPSharedClause(const OMPSharedClause *C) {
-  VisitOMPClauseList(C);
+
+void StmtProfiler::VisitOMPSectionDirective(const OMPSectionDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
-void OMPClauseProfiler::VisitOMPReductionClause(
-                                         const OMPReductionClause *C) {
-  Profiler->VisitNestedNameSpecifier(
-      C->getQualifierLoc().getNestedNameSpecifier());
-  Profiler->VisitName(C->getNameInfo().getName());
-  VisitOMPClauseList(C);
-}
-void OMPClauseProfiler::VisitOMPLinearClause(const OMPLinearClause *C) {
-  VisitOMPClauseList(C);
-  Profiler->VisitStmt(C->getStep());
-}
-void OMPClauseProfiler::VisitOMPAlignedClause(const OMPAlignedClause *C) {
-  VisitOMPClauseList(C);
-  Profiler->VisitStmt(C->getAlignment());
+
+void StmtProfiler::VisitOMPSingleDirective(const OMPSingleDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
-void OMPClauseProfiler::VisitOMPCopyinClause(const OMPCopyinClause *C) {
-  VisitOMPClauseList(C);
+
+void StmtProfiler::VisitOMPTaskDirective(const OMPTaskDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
-void
-OMPClauseProfiler::VisitOMPCopyprivateClause(const OMPCopyprivateClause *C) {
-  VisitOMPClauseList(C);
+
+void StmtProfiler::VisitOMPTaskyieldDirective(const OMPTaskyieldDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
-void OMPClauseProfiler::VisitOMPFlushClause(const OMPFlushClause *C) {
-  VisitOMPClauseList(C);
+
+void StmtProfiler::VisitOMPMasterDirective(const OMPMasterDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
+
+void StmtProfiler::VisitOMPCriticalDirective(const OMPCriticalDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
 
-void
-StmtProfiler::VisitOMPExecutableDirective(const OMPExecutableDirective *S) {
-  VisitStmt(S);
-  OMPClauseProfiler P(this);
-  ArrayRef<OMPClause *> Clauses = S->clauses();
-  for (ArrayRef<OMPClause *>::iterator I = Clauses.begin(), E = Clauses.end();
-       I != E; ++I)
-    if (*I)
-      P.Visit(*I);
+void StmtProfiler::VisitOMPBarrierDirective(const OMPBarrierDirective *S) {
+  VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPParallelDirective(const OMPParallelDirective *S) {
+void StmtProfiler::VisitOMPTaskwaitDirective(const OMPTaskwaitDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPSimdDirective(const OMPSimdDirective *S) {
+void StmtProfiler::VisitOMPTaskgroupDirective(const OMPTaskgroupDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPForDirective(const OMPForDirective *S) {
+void StmtProfiler::VisitOMPAtomicDirective(const OMPAtomicDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPSectionsDirective(const OMPSectionsDirective *S) {
+void StmtProfiler::VisitOMPFlushDirective(const OMPFlushDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPSectionDirective(const OMPSectionDirective *S) {
+void StmtProfiler::VisitOMPCancelDirective(const OMPCancelDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPSingleDirective(const OMPSingleDirective *S) {
+void StmtProfiler::VisitOMPCancellationPointDirective(
+    const OMPCancellationPointDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPMasterDirective(const OMPMasterDirective *S) {
+void StmtProfiler::VisitOMPOrderedDirective(const OMPOrderedDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPCriticalDirective(const OMPCriticalDirective *S) {
+void StmtProfiler::VisitOMPTeamsDirective(const OMPTeamsDirective *S) {
   VisitOMPExecutableDirective(S);
-  VisitName(S->getDirectiveName().getName());
 }
 
 void
-StmtProfiler::VisitOMPParallelForDirective(const OMPParallelForDirective *S) {
+StmtProfiler::VisitOMPDistributeDirective(const OMPDistributeDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPParallelSectionsDirective(
-    const OMPParallelSectionsDirective *S) {
+void StmtProfiler::VisitOMPTargetDirective(const OMPTargetDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPTaskDirective(const OMPTaskDirective *S) {
+void
+StmtProfiler::VisitOMPTargetDataDirective(const OMPTargetDataDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPTaskyieldDirective(const OMPTaskyieldDirective *S) {
+void
+StmtProfiler::VisitOMPTargetUpdateDirective(const OMPTargetUpdateDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPBarrierDirective(const OMPBarrierDirective *S) {
+void
+StmtProfiler::VisitOMPTargetTeamsDirective(const OMPTargetTeamsDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPTaskwaitDirective(const OMPTaskwaitDirective *S) {
+void StmtProfiler::VisitOMPTeamsDistributeDirective(
+    const OMPTeamsDistributeDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
-void StmtProfiler::VisitOMPFlushDirective(const OMPFlushDirective *S) {
+void StmtProfiler::VisitOMPTeamsDistributeSimdDirective(
+    const OMPTeamsDistributeSimdDirective *S) {
+  VisitOMPExecutableDirective(S);
+}
+
+void StmtProfiler::VisitOMPTargetTeamsDistributeDirective(
+    const OMPTargetTeamsDistributeDirective *S) {
+  VisitOMPExecutableDirective(S);
+}
+
+void StmtProfiler::VisitOMPTargetTeamsDistributeSimdDirective(
+    const OMPTargetTeamsDistributeSimdDirective *S) {
   VisitOMPExecutableDirective(S);
 }
 
@@ -529,6 +554,10 @@
   VisitExpr(S);
 }
 
+void StmtProfiler::VisitCEANIndexExpr(const CEANIndexExpr *S) {
+  VisitExpr(S);
+}
+
 void StmtProfiler::VisitCallExpr(const CallExpr *S) {
   VisitExpr(S);
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Basic/OpenMPKinds.cpp cfe-3.5.0.src.omp/lib/Basic/OpenMPKinds.cpp
--- cfe-3.5.0.src/lib/Basic/OpenMPKinds.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Basic/OpenMPKinds.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -29,7 +29,7 @@
 }
 
 const char *clang::getOpenMPDirectiveName(OpenMPDirectiveKind Kind) {
-  assert(Kind <= OMPD_unknown);
+  assert(Kind < NUM_OPENMP_DIRECTIVES);
   switch (Kind) {
   case OMPD_unknown:
     return "unknown";
@@ -40,14 +40,13 @@
   case OMPD_##Name:                                                            \
     return Str;
 #include "clang/Basic/OpenMPKinds.def"
+  default:
     break;
   }
   llvm_unreachable("Invalid OpenMP directive kind");
 }
 
 OpenMPClauseKind clang::getOpenMPClauseKind(StringRef Str) {
-  if (Str == "flush")
-    return OMPC_unknown;
   return llvm::StringSwitch<OpenMPClauseKind>(Str)
 #define OPENMP_CLAUSE(Name, Class) .Case(#Name, OMPC_##Name)
 #include "clang/Basic/OpenMPKinds.def"
@@ -55,7 +54,7 @@
 }
 
 const char *clang::getOpenMPClauseName(OpenMPClauseKind Kind) {
-  assert(Kind <= OMPC_unknown);
+  assert(Kind < NUM_OPENMP_CLAUSES);
   switch (Kind) {
   case OMPC_unknown:
     return "unknown";
@@ -65,6 +64,8 @@
 #include "clang/Basic/OpenMPKinds.def"
   case OMPC_threadprivate:
     return "threadprivate or thread local";
+  default:
+    break;
   }
   llvm_unreachable("Invalid OpenMP clause kind");
 }
@@ -82,32 +83,33 @@
 #define OPENMP_PROC_BIND_KIND(Name) .Case(#Name, OMPC_PROC_BIND_##Name)
 #include "clang/Basic/OpenMPKinds.def"
         .Default(OMPC_PROC_BIND_unknown);
+  case OMPC_reduction:
+    return llvm::StringSwitch<OpenMPReductionClauseOperator>(Str)
+#define OPENMP_REDUCTION_OPERATOR(Name, Symbol)                                \
+  .Case(Symbol, OMPC_REDUCTION_##Name)
+#include "clang/Basic/OpenMPKinds.def"
+        .Default(OMPC_REDUCTION_unknown);
+  case OMPC_depend:
+    return llvm::StringSwitch<OpenMPDependClauseType>(Str)
+#define OPENMP_DEPENDENCE_TYPE(Name, Type) .Case(Type, OMPC_DEPEND_##Name)
+#include "clang/Basic/OpenMPKinds.def"
+        .Default(OMPC_DEPEND_unknown);
+  case OMPC_map:
+    return llvm::StringSwitch<OpenMPMapClauseKind>(Str)
+#define OPENMP_MAP_KIND(Name, Kind) .Case(Kind, OMPC_MAP_##Name)
+#include "clang/Basic/OpenMPKinds.def"
+        .Default(OMPC_MAP_unknown);
   case OMPC_schedule:
     return llvm::StringSwitch<OpenMPScheduleClauseKind>(Str)
 #define OPENMP_SCHEDULE_KIND(Name) .Case(#Name, OMPC_SCHEDULE_##Name)
 #include "clang/Basic/OpenMPKinds.def"
         .Default(OMPC_SCHEDULE_unknown);
-  case OMPC_unknown:
-  case OMPC_threadprivate:
-  case OMPC_if:
-  case OMPC_final:
-  case OMPC_num_threads:
-  case OMPC_safelen:
-  case OMPC_collapse:
-  case OMPC_private:
-  case OMPC_firstprivate:
-  case OMPC_lastprivate:
-  case OMPC_shared:
-  case OMPC_reduction:
-  case OMPC_linear:
-  case OMPC_aligned:
-  case OMPC_copyin:
-  case OMPC_copyprivate:
-  case OMPC_ordered:
-  case OMPC_nowait:
-  case OMPC_untied:
-  case OMPC_mergeable:
-  case OMPC_flush:
+  case OMPC_dist_schedule:
+    return llvm::StringSwitch<OpenMPDistScheduleClauseKind>(Str)
+#define OPENMP_DIST_SCHEDULE_KIND(Name) .Case(#Name, OMPC_DIST_SCHEDULE_##Name)
+#include "clang/Basic/OpenMPKinds.def"
+        .Default(OMPC_DIST_SCHEDULE_unknown);
+  default:
     break;
   }
   llvm_unreachable("Invalid OpenMP simple clause kind");
@@ -124,6 +126,8 @@
   case OMPC_DEFAULT_##Name:                                                    \
     return #Name;
 #include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
     }
     llvm_unreachable("Invalid OpenMP 'default' clause type");
   case OMPC_proc_bind:
@@ -134,8 +138,46 @@
   case OMPC_PROC_BIND_##Name:                                                  \
     return #Name;
 #include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
     }
     llvm_unreachable("Invalid OpenMP 'proc_bind' clause type");
+  case OMPC_reduction:
+    switch (Type) {
+    case OMPC_REDUCTION_unknown:
+      return "unknown";
+#define OPENMP_REDUCTION_OPERATOR(Name, Symbol)                                \
+  case OMPC_REDUCTION_##Name:                                                  \
+    return Symbol;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    llvm_unreachable("Invalid OpenMP 'reduction' clause operator");
+  case OMPC_depend:
+    switch (Type) {
+    case OMPC_DEPEND_unknown:
+      return "unknown";
+#define OPENMP_DEPENDENCE_TYPE(Name, Type)                                     \
+  case OMPC_DEPEND_##Name:                                                     \
+    return Type;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    llvm_unreachable("Invalid OpenMP 'depend' clause dependence type");
+  case OMPC_map:
+    switch (Type) {
+    case OMPC_MAP_unknown:
+      return "unknown";
+#define OPENMP_MAP_KIND(Name, Kind)                                            \
+  case OMPC_MAP_##Name:                                                        \
+    return Kind;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    llvm_unreachable("Invalid OpenMP 'map' clause mapping kind");
   case OMPC_schedule:
     switch (Type) {
     case OMPC_SCHEDULE_unknown:
@@ -144,29 +186,23 @@
   case OMPC_SCHEDULE_##Name:                                                   \
     return #Name;
 #include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
     }
-    llvm_unreachable("Invalid OpenMP 'schedule' clause type");
-  case OMPC_unknown:
-  case OMPC_threadprivate:
-  case OMPC_if:
-  case OMPC_final:
-  case OMPC_num_threads:
-  case OMPC_safelen:
-  case OMPC_collapse:
-  case OMPC_private:
-  case OMPC_firstprivate:
-  case OMPC_lastprivate:
-  case OMPC_shared:
-  case OMPC_reduction:
-  case OMPC_linear:
-  case OMPC_aligned:
-  case OMPC_copyin:
-  case OMPC_copyprivate:
-  case OMPC_ordered:
-  case OMPC_nowait:
-  case OMPC_untied:
-  case OMPC_mergeable:
-  case OMPC_flush:
+    llvm_unreachable("Invalid OpenMP 'schedule' clause operator");
+  case OMPC_dist_schedule:
+    switch (Type) {
+    case OMPC_DIST_SCHEDULE_unknown:
+      return "unknown";
+#define OPENMP_DIST_SCHEDULE_KIND(Name)                                        \
+  case OMPC_DIST_SCHEDULE_##Name:                                              \
+    return #Name;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    llvm_unreachable("Invalid OpenMP 'dist_schedule' clause operator");
+  default:
     break;
   }
   llvm_unreachable("Invalid OpenMP simple clause kind");
@@ -174,8 +210,8 @@
 
 bool clang::isAllowedClauseForDirective(OpenMPDirectiveKind DKind,
                                         OpenMPClauseKind CKind) {
-  assert(DKind <= OMPD_unknown);
-  assert(CKind <= OMPC_unknown);
+  assert(DKind < NUM_OPENMP_DIRECTIVES);
+  assert(CKind < NUM_OPENMP_CLAUSES);
   switch (DKind) {
   case OMPD_parallel:
     switch (CKind) {
@@ -187,6 +223,16 @@
       break;
     }
     break;
+  case OMPD_for:
+    switch (CKind) {
+#define OPENMP_FOR_CLAUSE(Name)                                                \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
   case OMPD_simd:
     switch (CKind) {
 #define OPENMP_SIMD_CLAUSE(Name)                                               \
@@ -197,9 +243,9 @@
       break;
     }
     break;
-  case OMPD_for:
+  case OMPD_for_simd:
     switch (CKind) {
-#define OPENMP_FOR_CLAUSE(Name)                                                \
+#define OPENMP_FOR_SIMD_CLAUSE(Name)                                           \
   case OMPC_##Name:                                                            \
     return true;
 #include "clang/Basic/OpenMPKinds.def"
@@ -207,6 +253,100 @@
       break;
     }
     break;
+  case OMPD_distribute_simd:
+    switch (CKind) {
+#define OPENMP_DISTRIBUTE_SIMD_CLAUSE(Name)                                    \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_distribute_parallel_for:
+    switch (CKind) {
+#define OPENMP_DISTRIBUTE_PARALLEL_FOR_CLAUSE(Name)                            \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_distribute_parallel_for_simd:
+    switch (CKind) {
+#define OPENMP_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(Name)                       \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_teams_distribute_parallel_for:
+    switch (CKind) {
+#define OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(Name)                      \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_teams_distribute_parallel_for_simd:
+    switch (CKind) {
+#define OPENMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(Name)                 \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_target_teams_distribute_parallel_for:
+    switch (CKind) {
+#define OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_CLAUSE(Name)               \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_target_teams_distribute_parallel_for_simd:
+    switch (CKind) {
+#define OPENMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_CLAUSE(Name)          \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_parallel_for_simd:
+    switch (CKind) {
+#define OPENMP_PARALLEL_FOR_SIMD_CLAUSE(Name)                                  \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_declare_simd:
+    switch (CKind) {
+#define OPENMP_DECLARE_SIMD_CLAUSE(Name)                                       \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  // No clauses allowed for 'omp [end] declare target' constructs.
+  case OMPD_declare_target:
+  case OMPD_end_declare_target:
+    break;
   case OMPD_sections:
     switch (CKind) {
 #define OPENMP_SECTIONS_CLAUSE(Name)                                           \
@@ -227,6 +367,36 @@
       break;
     }
     break;
+  case OMPD_task:
+    switch (CKind) {
+#define OPENMP_TASK_CLAUSE(Name)                                               \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_atomic:
+    switch (CKind) {
+#define OPENMP_ATOMIC_CLAUSE(Name)                                             \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_flush:
+    switch (CKind) {
+#define OPENMP_FLUSH_CLAUSE(Name)                                              \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
   case OMPD_parallel_for:
     switch (CKind) {
 #define OPENMP_PARALLEL_FOR_CLAUSE(Name)                                       \
@@ -247,9 +417,9 @@
       break;
     }
     break;
-  case OMPD_task:
+  case OMPD_teams:
     switch (CKind) {
-#define OPENMP_TASK_CLAUSE(Name)                                               \
+#define OPENMP_TEAMS_CLAUSE(Name)                                              \
   case OMPC_##Name:                                                            \
     return true;
 #include "clang/Basic/OpenMPKinds.def"
@@ -257,50 +427,111 @@
       break;
     }
     break;
-  case OMPD_flush:
-    return CKind == OMPC_flush;
+  case OMPD_distribute:
+    switch (CKind) {
+#define OPENMP_DISTRIBUTE_CLAUSE(Name)                                         \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
     break;
-  case OMPD_unknown:
-  case OMPD_threadprivate:
-  case OMPD_section:
-  case OMPD_master:
-  case OMPD_critical:
-  case OMPD_taskyield:
-  case OMPD_barrier:
-  case OMPD_taskwait:
+  case OMPD_cancel:
+    switch (CKind) {
+#define OPENMP_CANCEL_CLAUSE(Name)                                             \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_cancellation_point:
+    return false;
+  case OMPD_target:
+    switch (CKind) {
+#define OPENMP_TARGET_CLAUSE(Name)                                             \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_target_data:
+    switch (CKind) {
+#define OPENMP_TARGET_DATA_CLAUSE(Name)                                        \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_target_update:
+    switch (CKind) {
+#define OPENMP_TARGET_UPDATE_CLAUSE(Name)                                      \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_target_teams:
+    switch (CKind) {
+#define OPENMP_TARGET_TEAMS_CLAUSE(Name)                                       \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_teams_distribute:
+    switch (CKind) {
+#define OPENMP_TEAMS_DISTRIBUTE_CLAUSE(Name)                            \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_teams_distribute_simd:
+    switch (CKind) {
+#define OPENMP_TEAMS_DISTRIBUTE_SIMD_CLAUSE(Name)                            \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_target_teams_distribute:
+    switch (CKind) {
+#define OPENMP_TARGET_TEAMS_DISTRIBUTE_CLAUSE(Name)                            \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  case OMPD_target_teams_distribute_simd:
+    switch (CKind) {
+#define OPENMP_TARGET_TEAMS_DISTRIBUTE_SIMD_CLAUSE(Name)                            \
+  case OMPC_##Name:                                                            \
+    return true;
+#include "clang/Basic/OpenMPKinds.def"
+    default:
+      break;
+    }
+    break;
+  default:
     break;
   }
   return false;
 }
 
-bool clang::isOpenMPLoopDirective(OpenMPDirectiveKind DKind) {
-  return DKind == OMPD_simd || DKind == OMPD_for ||
-         DKind == OMPD_parallel_for; // TODO add next directives.
-}
-
-bool clang::isOpenMPWorksharingDirective(OpenMPDirectiveKind DKind) {
-  return DKind == OMPD_for || DKind == OMPD_sections || DKind == OMPD_section ||
-         DKind == OMPD_single || DKind == OMPD_parallel_for ||
-         DKind == OMPD_parallel_sections; // TODO add next directives.
-}
-
-bool clang::isOpenMPParallelDirective(OpenMPDirectiveKind DKind) {
-  return DKind == OMPD_parallel || DKind == OMPD_parallel_for ||
-         DKind == OMPD_parallel_sections; // TODO add next directives.
-}
-
-bool clang::isOpenMPSimdDirective(OpenMPDirectiveKind DKind) {
-  return DKind == OMPD_simd; // TODO || DKind == OMPD_for_simd || ...
-}
-
-bool clang::isOpenMPPrivate(OpenMPClauseKind Kind) {
-  return Kind == OMPC_private || Kind == OMPC_firstprivate ||
-         Kind == OMPC_lastprivate || Kind == OMPC_linear ||
-         Kind == OMPC_reduction; // TODO add next clauses like 'reduction'.
-}
-
-bool clang::isOpenMPThreadPrivate(OpenMPClauseKind Kind) {
-  return Kind == OMPC_threadprivate ||
-         Kind == OMPC_copyin; // TODO add next clauses like 'copyprivate'.
-}
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Basic/Version.cpp cfe-3.5.0.src.omp/lib/Basic/Version.cpp
--- cfe-3.5.0.src/lib/Basic/Version.cpp	2014-06-06 06:36:22.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Basic/Version.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -36,7 +36,7 @@
 
   // If the SVN_REPOSITORY is empty, try to use the SVN keyword. This helps us
   // pick up a tag in an SVN export, for example.
-  StringRef SVNRepository("$URL: https://llvm.org/svn/llvm-project/cfe/tags/RELEASE_350/final/lib/Basic/Version.cpp $");
+  StringRef SVNRepository("$URL$");
   if (URL.empty()) {
     URL = SVNRepository.slice(SVNRepository.find(':'),
                               SVNRepository.find("/lib/Basic"));
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGCXXABI.h cfe-3.5.0.src.omp/lib/CodeGen/CGCXXABI.h
--- cfe-3.5.0.src/lib/CodeGen/CGCXXABI.h	2014-07-17 16:25:23.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGCXXABI.h	2014-11-28 10:49:29.000000000 -0500
@@ -403,6 +403,10 @@
   /// Gets the deleted virtual member call name.
   virtual StringRef GetDeletedVirtualCallName() = 0;
 
+  /// \brief Returns true iff static data members that are initialized in the
+  /// class definition should have linkonce linkage.
+  virtual bool isInlineInitializedStaticDataMemberLinkOnce() { return false; }
+
   /**************************** Array cookies ******************************/
 
   /// Returns the extra size required in order to store the array
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGClass.cpp cfe-3.5.0.src.omp/lib/CodeGen/CGClass.cpp
--- cfe-3.5.0.src/lib/CodeGen/CGClass.cpp	2014-06-26 00:58:53.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGClass.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -590,7 +590,7 @@
   CGF.EmitInitializerForField(Field, LHS, MemberInit->getInit(), ArrayIndexes);
 }
 
-void CodeGenFunction::EmitInitializerForField(FieldDecl *Field,
+void CodeGenFunction::EmitInitializerForField(const FieldDecl *Field,
                                               LValue LHS, Expr *Init,
                                              ArrayRef<VarDecl *> ArrayIndexes) {
   QualType FieldType = Field->getType();
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGDecl.cpp cfe-3.5.0.src.omp/lib/CodeGen/CGDecl.cpp
--- cfe-3.5.0.src/lib/CodeGen/CGDecl.cpp	2014-07-21 15:47:02.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGDecl.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -19,6 +19,7 @@
 #include "clang/AST/CharUnits.h"
 #include "clang/AST/Decl.h"
 #include "clang/AST/DeclObjC.h"
+#include "clang/AST/DeclOpenMP.h"
 #include "clang/Basic/SourceManager.h"
 #include "clang/Basic/TargetInfo.h"
 #include "clang/CodeGen/CGFunctionInfo.h"
@@ -77,6 +78,7 @@
   case Decl::Captured:
   case Decl::ClassScopeFunctionSpecialization:
   case Decl::UsingShadow:
+  case Decl::OMPDeclareTarget:
     llvm_unreachable("Declaration should not be in declstmts!");
   case Decl::Function:  // void X();
   case Decl::Record:    // struct/union/class X;
@@ -86,7 +88,6 @@
   case Decl::StaticAssert: // static_assert(X, ""); [C++0x]
   case Decl::Label:        // __label__ x;
   case Decl::Import:
-  case Decl::OMPThreadPrivate:
   case Decl::Empty:
     // None of these decls require codegen support.
     return;
@@ -99,6 +100,15 @@
     if (CGDebugInfo *DI = getDebugInfo())
         DI->EmitUsingDecl(cast<UsingDecl>(D));
     return;
+  case Decl::OMPThreadPrivate:
+    CGM.EmitOMPThreadPrivate(cast<OMPThreadPrivateDecl>(&D));
+    break;
+  case Decl::OMPDeclareReduction:
+    CGM.EmitOMPDeclareReduction(cast<OMPDeclareReductionDecl>(&D));
+    break;
+  case Decl::OMPDeclareSimd:
+    CGM.EmitOMPDeclareSimd(cast<OMPDeclareSimdDecl>(&D));
+    break;
   case Decl::UsingDirective: // using namespace X; [C++]
     if (CGDebugInfo *DI = getDebugInfo())
       DI->EmitUsingDirective(cast<UsingDirectiveDecl>(D));
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGDeclCXX.cpp cfe-3.5.0.src.omp/lib/CodeGen/CGDeclCXX.cpp
--- cfe-3.5.0.src/lib/CodeGen/CGDeclCXX.cpp	2014-07-21 20:53:05.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGDeclCXX.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -572,3 +572,355 @@
   
   return fn;
 }
+
+void CodeGenModule::CreateOpenMPCXXInit(const VarDecl *Var,
+                                        CXXRecordDecl *Ty,
+                                        llvm::Function *&InitFunction,
+                                        llvm::Value *&Ctor,
+                                        llvm::Value *&CCtor,
+                                        llvm::Value *&Dtor) {
+  // Find default constructor, copy constructor and destructor.
+  Ctor = 0;
+  CCtor = 0;
+  Dtor = 0;
+  InitFunction = 0;
+//  CXXConstructorDecl *CtorDecl = 0;//, *CCtorDecl = 0;
+//  CXXDestructorDecl *DtorDecl = 0;
+/*  for (CXXRecordDecl::ctor_iterator CI = Ty->ctor_begin(),
+                                    CE = Ty->ctor_end();
+       CI != CE; ++CI) {
+    unsigned Quals;
+    if ((*CI)->isDefaultConstructor())
+      CtorDecl = *CI;
+//    else if ((*CI)->isCopyConstructor(Quals) &&
+//             ((Quals & Qualifiers::Const) == Qualifiers::Const))
+//      CCtorDecl = *CI;
+  }*/
+//  if (CXXDestructorDecl *D = Ty->getDestructor())
+//    DtorDecl = D;
+  // Generate wrapper for default constructor.
+  const Expr *Init = Var->getAnyInitializer();
+  if (Init) {
+    CodeGenFunction CGF(*this);
+    FunctionArgList Args;
+    ImplicitParamDecl Dst(getContext(), 0, SourceLocation(), 0,
+                          getContext().VoidPtrTy);
+    Args.push_back(&Dst);
+
+    const CGFunctionInfo &FI = getTypes().arrangeFreeFunctionDeclaration(
+        getContext().VoidPtrTy, Args, FunctionType::ExtInfo(), false);
+    llvm::FunctionType *FTy = getTypes().GetFunctionType(FI);
+    llvm::Function *Fn =
+           CreateGlobalInitOrDestructFunction(*this, FTy,
+                                              Twine("__kmpc_ctor_",
+                                                    getMangledName(Var)));
+    CGF.StartFunction(GlobalDecl(), getContext().VoidPtrTy, Fn, FI,
+                      Args, SourceLocation());
+//    CGF.EmitCXXConstructExpr(cast<CXXConstructExpr>(Var->getInit()),
+//                             AggValueSlot::forAddr(Fn->arg_begin(),
+//                                                   CGF.getContext().getTypeAlignInChars(Var->getType()),
+//                                                   Var->getType().getQualifiers(),
+//                                                   AggValueSlot::IsNotDestructed,
+//                                                   AggValueSlot::DoesNotNeedGCBarriers,
+//                                                   AggValueSlot::IsNotAliased));
+//    //CGF.EmitCXXConstructorCall(CtorDecl, Ctor_Complete, false, false,
+//    //                           Fn->arg_begin(), 0, 0);
+    llvm::Value *Arg = CGF.EmitScalarConversion(Fn->arg_begin(), getContext().VoidPtrTy, getContext().getPointerType(Var->getType()));
+    CGF.EmitAnyExprToMem(Init, Arg, Init->getType().getQualifiers(), true);
+    CGF.Builder.CreateStore(Fn->arg_begin(), CGF.ReturnValue);
+    CGF.FinishFunction();
+    Ctor = Fn;
+  }
+/*  if (CCtorDecl) {
+    FunctionArgList Args;
+    if (!OpenMPCCtorHelperDecl) {
+      llvm::SmallVector<QualType, 2> TArgs(2, getContext().VoidPtrTy);
+      FunctionProtoType::ExtProtoInfo EPI;
+      OpenMPCCtorHelperDecl =
+        FunctionDecl::Create(getContext(), Ty->getTranslationUnitDecl(),
+                             SourceLocation(), SourceLocation(),
+                             DeclarationName(),
+                             getContext().getFunctionType(
+                                            getContext().VoidPtrTy,
+                                            TArgs, EPI),
+                             0, SC_None, SC_None, false, false);
+    }
+    ImplicitParamDecl Dst1(OpenMPCCtorHelperDecl, SourceLocation(), 0,
+                           getContext().VoidPtrTy);
+    ImplicitParamDecl Dst2(OpenMPCCtorHelperDecl, SourceLocation(), 0,
+                           getContext().VoidPtrTy);
+    DeclRefExpr E(&Dst2, true, getContext().VoidPtrTy, VK_LValue,
+                  SourceLocation());
+    ImplicitCastExpr ECast(ImplicitCastExpr::OnStack,
+                           CCtorDecl->getThisType(getContext()), CK_BitCast,
+                           &E, VK_LValue);
+    UnaryOperator EUn(&ECast, UO_Deref, getContext().getRecordType(Ty),
+                      VK_LValue, OK_Ordinary, SourceLocation());
+    Stmt *S = &EUn;
+    CallExpr::const_arg_iterator EI(&S);
+    Args.push_back(&Dst1);
+    Args.push_back(&Dst2);
+
+    const CGFunctionInfo &FI =
+          getTypes().arrangeFunctionDeclaration(getContext().VoidPtrTy, Args,
+                                                FunctionType::ExtInfo(), false);
+    llvm::FunctionType *FTy = getTypes().GetFunctionType(FI);
+    llvm::Function *Fn =
+            CreateGlobalInitOrDestructFunction(*this, FTy,
+                                               Twine("__kmpc_cctor_",
+                                                     Var->getName()));
+    CGF.StartFunction(GlobalDecl(), getContext().VoidPtrTy, Fn, FI,
+                      Args, SourceLocation());
+    CGF.EmitCXXConstructorCall(CCtorDecl, Ctor_Complete, false, false,
+                               Fn->arg_begin(), EI, EI + 1);
+    CGF.Builder.CreateStore(&Fn->getArgumentList().back(), CGF.ReturnValue);
+    CGF.FinishFunction();
+    CCtor = Fn;
+  }*/
+  QualType QTy = Var->getType();
+  QualType::DestructionKind DtorKind = QTy.isDestructedType();
+  if (DtorKind != QualType::DK_none && !Ty->hasTrivialDestructor()) {
+    CodeGenFunction CGF(*this);
+    FunctionArgList Args;
+    ImplicitParamDecl Dst(getContext(), 0, SourceLocation(), 0,
+                          getContext().VoidPtrTy);
+    Args.push_back(&Dst);
+
+    const CGFunctionInfo &FI = getTypes().arrangeFreeFunctionDeclaration(
+        getContext().VoidPtrTy, Args, FunctionType::ExtInfo(), false);
+    llvm::FunctionType *FTy = getTypes().GetFunctionType(FI);
+    llvm::Function *Fn =
+           CreateGlobalInitOrDestructFunction(*this, FTy,
+                                              Twine("__kmpc_dtor_",
+                                                    getMangledName(Var)));
+    CGF.StartFunction(GlobalDecl(), getContext().VoidPtrTy, Fn, FI,
+                      Args, SourceLocation());
+    //CGF.EmitCXXDestructorCall(DtorDecl, Dtor_Complete, false, false,
+    //                          Fn->arg_begin());
+    CGF.emitDestroy(Fn->arg_begin(), QTy, CGF.getDestroyer(DtorKind), CGF.needsEHCleanup(DtorKind));
+    CGF.Builder.CreateStore(Fn->arg_begin(), CGF.ReturnValue);
+    CGF.FinishFunction();
+    Dtor = Fn;
+  }// else {
+    //DtorDecl = 0;
+  //}
+
+  if (Init || (DtorKind != QualType::DK_none && !Ty->hasTrivialDestructor())) {
+    if (!Ctor) {
+      FunctionArgList Args;
+      ImplicitParamDecl Dst(getContext(), 0, SourceLocation(), 0,
+                            getContext().VoidPtrTy);
+      Args.push_back(&Dst);
+
+      const CGFunctionInfo &FI = getTypes().arrangeFreeFunctionDeclaration(
+          getContext().VoidPtrTy, Args, FunctionType::ExtInfo(), false);
+      llvm::FunctionType *FTy = getTypes().GetFunctionType(FI);
+      Ctor = llvm::Constant::getNullValue(FTy->getPointerTo());
+    }
+    if (!CCtor) {
+      FunctionArgList Args;
+      ImplicitParamDecl Dst1(getContext(), 0, SourceLocation(), 0,
+                             getContext().VoidPtrTy);
+      ImplicitParamDecl Dst2(getContext(), 0, SourceLocation(), 0,
+                             getContext().VoidPtrTy);
+      Args.push_back(&Dst1);
+      Args.push_back(&Dst2);
+      const CGFunctionInfo &FI = getTypes().arrangeFreeFunctionDeclaration(
+          getContext().VoidPtrTy, Args, FunctionType::ExtInfo(), false);
+      llvm::FunctionType *FTy = getTypes().GetFunctionType(FI);
+      CCtor = llvm::Constant::getNullValue(FTy->getPointerTo());
+    }
+    if (DtorKind == QualType::DK_none || Ty->hasTrivialDestructor()) {
+      FunctionArgList Args;
+      ImplicitParamDecl Dst(getContext(), 0, SourceLocation(), 0,
+                            getContext().VoidPtrTy);
+      Args.push_back(&Dst);
+
+      const CGFunctionInfo &FI = getTypes().arrangeFreeFunctionDeclaration(
+          getContext().VoidPtrTy, Args, FunctionType::ExtInfo(), false);
+      llvm::FunctionType *FTy = getTypes().GetFunctionType(FI);
+      Dtor = llvm::Constant::getNullValue(FTy->getPointerTo());
+    }
+    llvm::FunctionType *FTy = llvm::FunctionType::get(VoidTy, false);
+    InitFunction =
+              CreateGlobalInitOrDestructFunction(*this, FTy,
+                                                 Twine("__omp_threadprivate_",
+                                                       getMangledName(Var)));
+  }
+}
+
+void CodeGenModule::CreateOpenMPArrCXXInit(const VarDecl *Var,
+                                           CXXRecordDecl *Ty,
+                                           llvm::Function *&InitFunction,
+                                           llvm::Value *&Ctor,
+                                           llvm::Value *&CCtor,
+                                           llvm::Value *&Dtor) {
+  // Find default constructor, copy constructor and destructor.
+  Ctor = 0;
+  CCtor = 0;
+  Dtor = 0;
+  InitFunction = 0;
+  //CXXConstructorDecl *CtorDecl = 0, *CCtorDecl = 0;
+  CXXDestructorDecl *DtorDecl = 0;
+/*  for (CXXRecordDecl::ctor_iterator CI = Ty->ctor_begin(),
+                                    CE = Ty->ctor_end();
+       CI != CE; ++CI) {
+    unsigned Quals;
+    if ((*CI)->isDefaultConstructor())
+      CtorDecl = *CI;
+    else if ((*CI)->isCopyConstructor(Quals) &&
+             ((Quals & Qualifiers::Const) == Qualifiers::Const))
+      CCtorDecl = *CI;
+  }
+*/
+  if (CXXDestructorDecl *D = Ty->getDestructor())
+    DtorDecl = D;
+  // Generate wrapper for default constructor.
+  const Expr *Init = Var->getAnyInitializer();
+  if (Init) {
+    FunctionArgList Args;
+    ImplicitParamDecl Dst(getContext(), 0, SourceLocation(), 0,
+                          getContext().VoidPtrTy);
+    Args.push_back(&Dst);
+
+    const CGFunctionInfo &FI = getTypes().arrangeFreeFunctionDeclaration(
+        getContext().VoidPtrTy, Args, FunctionType::ExtInfo(), false);
+    llvm::FunctionType *FTy = getTypes().GetFunctionType(FI);
+    llvm::Function *Fn =
+           CreateGlobalInitOrDestructFunction(*this, FTy,
+                                              Twine("__kmpc_ctor_vec_",
+                                                    getMangledName(Var)));
+    CodeGenFunction CGF(*this);
+    CGF.StartFunction(GlobalDecl(), getContext().VoidPtrTy, Fn, FI,
+                      Args, SourceLocation());
+//    CGF.EmitAggExpr(Var->getInit(),
+//                    AggValueSlot::forAddr(Fn->arg_begin(),
+//                                          CGF.getContext().getTypeAlignInChars(Var->getType()),
+//                                          Var->getType().getQualifiers(),
+//                                          AggValueSlot::IsNotDestructed,
+//                                          AggValueSlot::DoesNotNeedGCBarriers,
+//                                          AggValueSlot::IsNotAliased));
+//    CGF.Builder.CreateStore(Fn->arg_begin(), CGF.ReturnValue);
+    llvm::Value *Arg = CGF.EmitScalarConversion(Fn->arg_begin(), getContext().VoidPtrTy, getContext().getPointerType(Var->getType()));
+    CGF.EmitAnyExprToMem(Init, Arg, Init->getType().getQualifiers(), true);
+    CGF.Builder.CreateStore(Fn->arg_begin(), CGF.ReturnValue);
+    CGF.FinishFunction();
+    Ctor = Fn;
+  }
+/*  if (CCtorDecl) {
+    FunctionArgList Args;
+    if (!OpenMPCCtorHelperDecl) {
+      llvm::SmallVector<QualType, 2> TArgs(2, getContext().VoidPtrTy);
+      FunctionProtoType::ExtProtoInfo EPI;
+      OpenMPCCtorHelperDecl =
+        FunctionDecl::Create(getContext(), Ty->getTranslationUnitDecl(),
+                             SourceLocation(), SourceLocation(),
+                             DeclarationName(),
+                             getContext().getFunctionType(
+                                            getContext().VoidPtrTy,
+                                            TArgs, EPI),
+                             0, SC_None, SC_None, false, false);
+    }
+    ImplicitParamDecl Dst1(OpenMPCCtorHelperDecl, SourceLocation(), 0,
+                           getContext().VoidPtrTy);
+    ImplicitParamDecl Dst2(OpenMPCCtorHelperDecl, SourceLocation(), 0,
+                           getContext().VoidPtrTy);
+    DeclRefExpr E(&Dst2, true, getContext().VoidPtrTy, VK_LValue,
+                  SourceLocation());
+    ImplicitCastExpr ECast(ImplicitCastExpr::OnStack,
+                           CCtorDecl->getThisType(getContext()), CK_BitCast,
+                           &E, VK_LValue);
+    UnaryOperator EUn(&ECast, UO_Deref, getContext().getRecordType(Ty),
+                      VK_LValue, OK_Ordinary, SourceLocation());
+    Stmt *S = &EUn;
+    CallExpr::const_arg_iterator EI(&S);
+    Args.push_back(&Dst1);
+    Args.push_back(&Dst2);
+
+    const CGFunctionInfo &FI =
+          getTypes().arrangeFunctionDeclaration(getContext().VoidPtrTy, Args,
+                                                FunctionType::ExtInfo(), false);
+    llvm::FunctionType *FTy = getTypes().GetFunctionType(FI);
+    llvm::Function *Fn =
+            CreateGlobalInitOrDestructFunction(*this, FTy,
+                                               Twine("__kmpc_cctor_",
+                                                     Var->getName()));
+    CGF.StartFunction(GlobalDecl(), getContext().VoidPtrTy, Fn, FI,
+                      Args, SourceLocation());
+    CGF.EmitCXXConstructorCall(CCtorDecl, Ctor_Complete, false, false,
+                               Fn->arg_begin(), EI, EI + 1);
+    CGF.Builder.CreateStore(&Fn->getArgumentList().back(), CGF.ReturnValue);
+    CGF.FinishFunction();
+    CCtor = Fn;
+  }*/
+  if (DtorDecl && !DtorDecl->isTrivial()) {
+    FunctionArgList Args;
+    ImplicitParamDecl Dst(getContext(), 0, SourceLocation(), 0,
+                          getContext().VoidPtrTy);
+    Args.push_back(&Dst);
+
+    const CGFunctionInfo &FI = getTypes().arrangeFreeFunctionDeclaration(
+        getContext().VoidPtrTy, Args, FunctionType::ExtInfo(), false);
+    llvm::FunctionType *FTy = getTypes().GetFunctionType(FI);
+    llvm::Function *Fn =
+           CreateGlobalInitOrDestructFunction(*this, FTy,
+                                              Twine("__kmpc_dtor_vec_",
+                                                    getMangledName(Var)));
+    CodeGenFunction CGF(*this);
+    CGF.StartFunction(GlobalDecl(), getContext().VoidPtrTy, Fn, FI,
+                      Args, SourceLocation());
+    CGF.emitDestroy(Fn->arg_begin(), Var->getType(),
+                    CGF.getDestroyer(QualType::DK_cxx_destructor),
+                    false
+                    /*CGF.needsEHCleanup(QualType::DK_cxx_destructor)*/);
+    CGF.Builder.CreateStore(Fn->arg_begin(), CGF.ReturnValue);
+    CGF.FinishFunction();
+    Dtor = Fn;
+  } else {
+    DtorDecl = 0;
+  }
+
+  if (Init || DtorDecl) {
+    if (!Ctor) {
+      FunctionArgList Args;
+      ImplicitParamDecl Dst(getContext(), 0, SourceLocation(), 0,
+                            getContext().VoidPtrTy);
+      Args.push_back(&Dst);
+
+      const CGFunctionInfo &FI = getTypes().arrangeFreeFunctionDeclaration(
+          getContext().VoidPtrTy, Args, FunctionType::ExtInfo(), false);
+      llvm::FunctionType *FTy = getTypes().GetFunctionType(FI);
+      Ctor = llvm::Constant::getNullValue(FTy->getPointerTo());
+    }
+    if (!CCtor) {
+      FunctionArgList Args;
+      ImplicitParamDecl Dst1(getContext(), 0, SourceLocation(), 0,
+                             getContext().VoidPtrTy);
+      ImplicitParamDecl Dst2(getContext(), 0, SourceLocation(), 0,
+                             getContext().VoidPtrTy);
+      Args.push_back(&Dst1);
+      Args.push_back(&Dst2);
+      const CGFunctionInfo &FI = getTypes().arrangeFreeFunctionDeclaration(
+          getContext().VoidPtrTy, Args, FunctionType::ExtInfo(), false);
+      llvm::FunctionType *FTy = getTypes().GetFunctionType(FI);
+      CCtor = llvm::Constant::getNullValue(FTy->getPointerTo());
+    }
+    if (!Dtor) {
+      FunctionArgList Args;
+      ImplicitParamDecl Dst(getContext(), 0, SourceLocation(), 0,
+                            getContext().VoidPtrTy);
+      Args.push_back(&Dst);
+
+      const CGFunctionInfo &FI = getTypes().arrangeFreeFunctionDeclaration(
+          getContext().VoidPtrTy, Args, FunctionType::ExtInfo(), false);
+      llvm::FunctionType *FTy = getTypes().GetFunctionType(FI);
+      Dtor = llvm::Constant::getNullValue(FTy->getPointerTo());
+    }
+    llvm::FunctionType *FTy = llvm::FunctionType::get(VoidTy, false);
+    InitFunction =
+              CreateGlobalInitOrDestructFunction(*this, FTy,
+                                                 Twine("__omp_threadprivate_vec_",
+                                                       getMangledName(Var)));
+  }
+}
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGDeclOpenMP.cpp cfe-3.5.0.src.omp/lib/CodeGen/CGDeclOpenMP.cpp
--- cfe-3.5.0.src/lib/CodeGen/CGDeclOpenMP.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGDeclOpenMP.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -0,0 +1,249 @@
+//===--- CGDecl.cpp - Emit LLVM Code for declarations ---------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This contains code to emit Decl nodes as LLVM code.
+//
+//===----------------------------------------------------------------------===//
+
+#include "CodeGenFunction.h"
+#include "CGDebugInfo.h"
+#include "CGOpenCLRuntime.h"
+#include "CGOpenMPRuntimeTypes.h"
+#include "CGOpenMPRuntime.h"
+#include "CodeGenModule.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/CharUnits.h"
+#include "clang/AST/Decl.h"
+#include "clang/AST/DeclObjC.h"
+#include "clang/AST/DeclOpenMP.h"
+#include "clang/Basic/SourceManager.h"
+#include "clang/Basic/TargetInfo.h"
+#include "clang/Frontend/CodeGenOptions.h"
+#include "llvm/ADT/StringExtras.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/GlobalVariable.h"
+#include "llvm/IR/Intrinsics.h"
+#include "llvm/IR/Type.h"
+#include "llvm/IR/TypeBuilder.h"
+using namespace clang;
+using namespace CodeGen;
+
+#define OPENMPRTL_FUNC(name) OpenMPRuntime->Get_##name()
+
+void CodeGenModule::EmitOMPThreadPrivate(const VarDecl *VD, const Expr *TPE) {
+  // Create cache memory for threadprivate variable void **Var.cache;
+  std::string VarCache = getMangledName(VD).str() + ".cache.";
+  llvm::GlobalVariable *GV;
+  if (!(GV =
+            dyn_cast_or_null<llvm::GlobalVariable>(GetGlobalValue(VarCache)))) {
+    llvm::GlobalVariable *GV = cast<llvm::GlobalVariable>(
+        CreateRuntimeVariable(Int8PtrPtrTy, VarCache));
+    GV->setInitializer(llvm::Constant::getNullValue(Int8PtrPtrTy));
+    GV->setLinkage(llvm::GlobalValue::CommonLinkage);
+  }
+  // Do not define constructors/destructors for declaration, they are defined
+  // for definitions.
+  if (!VD->isLocalVarDecl() && !getContext().DeclMustBeEmitted(VD))
+    return;
+  llvm::Value *Val =
+      VD->isStaticLocal() ? getStaticLocalDeclAddress(VD) : GetAddrOfGlobal(VD);
+  bool isArray = false;
+  const Type *TypePtr = VD->getType().getCanonicalType().getTypePtr();
+  while (TypePtr->isArrayType()) {
+    isArray = true;
+    TypePtr = TypePtr->getArrayElementTypeNoTypeQual();
+  }
+  CXXRecordDecl *Ty = TypePtr->getAsCXXRecordDecl();
+  if (isArray && Ty) {
+    // void __omp_threadprivate_Var();
+    llvm::Value *Ctor, *CCtor, *Dtor;
+    llvm::Function *InitFn;
+    CreateOpenMPArrCXXInit(VD, Ty, InitFn, Ctor, CCtor, Dtor);
+    if (InitFn) {
+      CodeGenFunction CGF(*this);
+      FunctionArgList ArgList;
+      CGF.StartFunction(GlobalDecl(), getContext().VoidPtrTy, InitFn,
+                        getTypes().arrangeNullaryFunction(), ArgList,
+                        SourceLocation());
+      // ident_t tmp;
+      llvm::Value *Tmp = OpenMPRuntime->CreateIntelOpenMPRTLLoc(TPE->getExprLoc(), CGF);
+      llvm::Value *Args1[] = { Tmp };
+      // __kmpc_global_thread_num(&tmp);
+      CGF.EmitRuntimeCall(OPENMPRTL_FUNC(global_thread_num), Args1);
+      llvm::Value *Args[5] = { Tmp, CGF.Builder.CreateBitCast(
+                                        Val, CGF.Builder.getInt8PtrTy()),
+                               Ctor, CCtor, Dtor };
+      // __kmpc_threadprivate_register(&tmp, &var, ctor, cctor, dtor);
+      CGF.EmitRuntimeCall(OPENMPRTL_FUNC(threadprivate_register), Args);
+      CGF.FinishFunction();
+      CXXGlobalInits.push_back(InitFn);
+    }
+  } else if (Ty) {
+    // void __omp_threadprivate_Var();
+    llvm::Value *Ctor, *CCtor, *Dtor;
+    llvm::Function *InitFn;
+    CreateOpenMPCXXInit(VD, Ty, InitFn, Ctor, CCtor, Dtor);
+    if (InitFn) {
+      CodeGenFunction CGF(*this);
+      FunctionArgList ArgList;
+      CGF.StartFunction(GlobalDecl(), getContext().VoidPtrTy, InitFn,
+                        getTypes().arrangeNullaryFunction(), ArgList,
+                        SourceLocation());
+      // ident_t tmp;
+      llvm::Value *Tmp = OpenMPRuntime->CreateIntelOpenMPRTLLoc(TPE->getExprLoc(), CGF);
+      llvm::Value *Args1[] = { Tmp };
+      // __kmpc_global_thread_num(&tmp);
+      CGF.EmitRuntimeCall(OPENMPRTL_FUNC(global_thread_num), Args1);
+      llvm::Value *Args[5] = { Tmp, CGF.Builder.CreateBitCast(
+                                        Val, CGF.Builder.getInt8PtrTy()),
+                               Ctor, CCtor, Dtor };
+      // __kmpc_threadprivate_register(&tmp, &var, ctor, cctor, dtor);
+      CGF.EmitRuntimeCall(OPENMPRTL_FUNC(threadprivate_register), Args);
+      CGF.FinishFunction();
+      CXXGlobalInits.push_back(InitFn);
+    }
+  }
+}
+
+void CodeGenModule::EmitOMPThreadPrivate(const OMPThreadPrivateDecl *D) {
+  for (OMPThreadPrivateDecl::varlist_const_iterator I = D->varlist_begin(),
+                                                    E = D->varlist_end();
+       I != E; ++I) {
+    const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    OpenMPSupport.addThreadPrivateVar(VD, *I);
+    EmitOMPThreadPrivate(VD, *I);
+  }
+}
+
+void CodeGenModule::EmitOMPDeclareReduction(const OMPDeclareReductionDecl *D) {
+  for (OMPDeclareReductionDecl::datalist_const_iterator I = D->datalist_begin(),
+                                                        E = D->datalist_end();
+       I != E; ++I) {
+    if (!I->CombinerFunction || !I->InitFunction)
+      continue;
+    Decl *D = cast<DeclRefExpr>(I->CombinerFunction)->getDecl();
+    EmitGlobal(cast<FunctionDecl>(D));
+    D = cast<DeclRefExpr>(I->InitFunction)->getDecl();
+    EmitGlobal(cast<FunctionDecl>(D));
+  }
+}
+
+void CodeGenModule::EmitOMPDeclareSimd(const OMPDeclareSimdDecl *D) {
+  // 1) Emit function, extract FunctionDecl, Function, CGFunctionInfo.
+  // 2) Prepare input (Groups) for metadata generation.
+  // 3) Do the metadata generation -- call EmitVectorVariantsMetadata.
+
+  // Make sure that the function is emitted.
+  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D->getFunction());
+
+  if (!FD) {
+    return;
+  }
+
+  EmitGlobal(FD);
+
+  const CGFunctionInfo &FI = getTypes().arrangeGlobalDeclaration(FD);
+  llvm::FunctionType *Ty = getTypes().GetFunctionType(FI);
+  llvm::Function *Fn = cast<llvm::Function>(GetAddrOfFunction(FD, Ty));
+
+  if (FD->isVariadic())
+    return;
+
+  if (!Fn)
+    return;
+
+  // Prepare input for the metadata emission.
+  GroupMap Groups;
+  static unsigned key = 0;
+
+  for (OMPDeclareSimdDecl::simd_variants_const_iterator
+           I = D->simd_variants_begin(),
+           E = D->simd_variants_end();
+       I != E; ++I) {
+    Groups.FindAndConstruct(++key);
+    unsigned BeginIdx = I->BeginIdx;
+    unsigned EndIdx = I->EndIdx;
+    for (unsigned Idx = BeginIdx; Idx < EndIdx; ++Idx) {
+      OMPDeclareSimdDecl::clauses_const_iterator J = D->clauses_begin() + Idx;
+      if (!*J)
+        continue;
+      if (isa<OMPInBranchClause>(*J)) {
+        Groups[key].Mask.push_back(1);
+      } else if (isa<OMPNotInBranchClause>(*J)) {
+        Groups[key].Mask.push_back(0);
+      } else if (OMPSimdlenClause *C = dyn_cast<OMPSimdlenClause>(*J)) {
+        const Expr *LengthExpr = C->getSimdlen();
+        assert(isa<IntegerLiteral>(LengthExpr) && "integer literal expected");
+        unsigned VLen =
+            cast<IntegerLiteral>(LengthExpr)->getValue().getZExtValue();
+        Groups[key].VecLength.push_back(VLen);
+      } else if (OMPLinearClause *C = dyn_cast<OMPLinearClause>(*J)) {
+        const Expr *StepExpr = C->getStep();
+        int Step = 0;
+        if (const IntegerLiteral *IL =
+                dyn_cast_or_null<IntegerLiteral>(StepExpr)) {
+          Step = IL->getValue().getZExtValue();
+        } else {
+          Step = 1;
+        }
+        for (OMPLinearClause::varlist_const_iterator I = C->varlist_begin(),
+                                                     E = C->varlist_end();
+             I != E; ++I) {
+          const DeclRefExpr *DRE = cast<DeclRefExpr>(*I);
+          const std::string Name = DRE->getDecl()->getDeclName().getAsString();
+          Groups[key].setLinear(Name, "", Step);
+        }
+      } else if (OMPAlignedClause *C = dyn_cast<OMPAlignedClause>(*J)) {
+        const Expr *AlignExpr = C->getAlignment();
+        int Align = 0;
+        if (const IntegerLiteral *IL =
+                dyn_cast_or_null<IntegerLiteral>(AlignExpr)) {
+          Align = IL->getValue().getZExtValue();
+        }
+        for (OMPAlignedClause::varlist_const_iterator I = C->varlist_begin(),
+                                                      E = C->varlist_end();
+             I != E; ++I) {
+          const DeclRefExpr *DRE = cast<DeclRefExpr>(*I);
+          const std::string Name = DRE->getDecl()->getDeclName().getAsString();
+          Groups[key].setAligned(Name, Align);
+        }
+      } else if (OMPUniformClause *C = dyn_cast<OMPUniformClause>(*J)) {
+        for (OMPUniformClause::varlist_const_iterator I = C->varlist_begin(),
+                                                      E = C->varlist_end();
+             I != E; ++I) {
+          const DeclRefExpr *DRE = cast<DeclRefExpr>(*I);
+          Groups[key].setUniform(DRE->getDecl()->getDeclName().getAsString());
+        }
+      } else {
+        llvm_unreachable("Unknown clause on 'omp declare simd' directive");
+      }
+    }
+  }
+
+  EmitVectorVariantsMetadata(FI, FD, Fn, Groups);
+}
+
+void CodeGenModule::EmitOMPDeclareTarget(const OMPDeclareTargetDecl *D) {
+
+  // Create a region for the declare target so the the codegen knows
+  // that is a valid region for a target
+  OpenMPSupport.startOpenMPRegion(false);
+  OpenMPSupport.setTargetDeclare(true);
+
+  for (DeclContext::decl_iterator I = D->decls_begin(), E = D->decls_end();
+       I != E; ++I) {
+    if (const VarDecl *VD = dyn_cast<VarDecl>(*I))
+      if (VD->getTemplateSpecializationKind() != TSK_ExplicitSpecialization &&
+          VD->getTemplateSpecializationKind() != TSK_Undeclared)
+        continue;
+    EmitTopLevelDecl(*I);
+  }
+
+  OpenMPSupport.endOpenMPRegion();
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGElementalFunction.cpp cfe-3.5.0.src.omp/lib/CodeGen/CGElementalFunction.cpp
--- cfe-3.5.0.src/lib/CodeGen/CGElementalFunction.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGElementalFunction.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -0,0 +1,824 @@
+//===----- CGElementalFunction.cpp - CodeGen for Elemental Functions ------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+/// \file
+/// \brief This files implements code generation for Cilk Plus elemental
+/// functions.
+///
+//===----------------------------------------------------------------------===//
+
+#include "CodeGenModule.h"
+#include "clang/Basic/TargetInfo.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/Support/Debug.h"
+
+#define DEBUG_TYPE "elemental-codegen"
+
+using namespace clang;
+using namespace CodeGen;
+typedef CodeGenModule::CilkElementalGroup CilkElementalGroup;
+
+static llvm::MDNode *MakeVecLengthMetadata(CodeGenModule &CGM, StringRef Name,
+                                           QualType T, uint64_t VL) {
+  llvm::LLVMContext &Context = CGM.getLLVMContext();
+  llvm::Value *attrMDArgs[] = {
+    llvm::MDString::get(Context, Name),
+    llvm::UndefValue::get(CGM.getTypes().ConvertType(T)),
+    llvm::ConstantInt::get(CGM.Int32Ty, VL)
+  };
+  return llvm::MDNode::get(Context, attrMDArgs);
+}
+
+static bool CheckElementalArguments(CodeGenModule &CGM, const FunctionDecl *FD,
+                                    llvm::Function *Fn, bool &HasThis) {
+  // Check the return type.
+  QualType RetTy = FD->getReturnType();
+  if (RetTy->isAggregateType()) {
+    CGM.Error(FD->getLocation(), "the return type for this elemental "
+                                 "function is not supported yet");
+    return false;
+  }
+
+  // Check each parameter type.
+  for (unsigned I = 0, E = FD->param_size(); I < E; ++I) {
+    const ParmVarDecl *VD = FD->getParamDecl(I);
+    QualType Ty = VD->getType();
+    assert(!Ty->isIncompleteType() && "incomplete type");
+    if (Ty->isAggregateType()) {
+      CGM.Error(VD->getLocation(), "the parameter type for this elemental "
+                                   "function is not supported yet");
+      return false;
+    }
+  }
+
+  HasThis = isa<CXXMethodDecl>(FD) && cast<CXXMethodDecl>(FD)->isInstance();
+
+  // At this point, no passing struct arguments by value.
+  unsigned NumArgs = FD->param_size();
+  unsigned NumLLVMArgs = Fn->arg_size();
+
+  // There is a single implicit 'this' parameter.
+  if (HasThis && (NumArgs + 1 == NumLLVMArgs))
+    return true;
+
+  return NumArgs == NumLLVMArgs;
+}
+
+/// \brief Generates a properstep argument for each function parameter.
+/// Returns true if this is a non-linear and non-uniform variable.
+/// Otherwise returns false.
+static bool handleParameter(CodeGenModule &CGM, CilkElementalGroup &G,
+                            StringRef ParmName,
+                            SmallVectorImpl<llvm::Value *> &StepArgs,
+                            SmallVectorImpl<llvm::Value *> &AligArgs) {
+  // Update the alignment args.
+  unsigned Alignment;
+  if (G.getAlignedAttr(ParmName, &Alignment)) {
+    AligArgs.push_back(llvm::ConstantInt::get(CGM.IntTy, Alignment));
+  }
+  else {
+    AligArgs.push_back(llvm::UndefValue::get(CGM.IntTy));
+  }
+  // Update the step args.
+  std::pair<int,std::string> LinStep;
+  if (G.getUniformAttr(ParmName)) {
+    // If this is uniform, then use step 0 as placeholder.
+    StepArgs.push_back(llvm::ConstantInt::get(CGM.IntTy, 0));
+    return false;
+  }
+  else if (G.getLinearAttr(ParmName, &LinStep)) {
+    if (LinStep.first != 0) {
+      StepArgs.push_back(llvm::ConstantInt::get(CGM.IntTy, LinStep.first));
+    }
+    else {
+      StepArgs.push_back(llvm::MDString::get(CGM.getLLVMContext(),
+                                             LinStep.second));
+    }
+    return false;
+  }
+  // If this is non-linear and non-uniform, use undefined step as placeholder.
+  StepArgs.push_back(llvm::UndefValue::get(CGM.IntTy));
+  return true;
+}
+
+// The following is common part for 'cilk vector functions' and
+// 'omp declare simd' functions metadata generation.
+//
+void CodeGenModule::EmitVectorVariantsMetadata(const CGFunctionInfo &FnInfo,
+                                               const FunctionDecl *FD,
+                                               llvm::Function *Fn,
+                                               GroupMap &Groups) {
+
+  // Do not emit any vector variant if there is an unsupported feature.
+  bool HasImplicitThis = false;
+  if (!CheckElementalArguments(*this, FD, Fn, HasImplicitThis))
+    return;
+
+  llvm::LLVMContext &Context = getLLVMContext();
+  ASTContext &C = getContext();
+
+  // Common metadata nodes.
+  llvm::NamedMDNode *CilkElementalMetadata =
+    getModule().getOrInsertNamedMetadata("cilk.functions");
+  llvm::Value *ElementalMDArgs[] = {
+    llvm::MDString::get(Context, "elemental")
+  };
+  llvm::MDNode *ElementalNode = llvm::MDNode::get(Context, ElementalMDArgs);
+  llvm::Value *MaskMDArgs[] = {
+    llvm::MDString::get(Context, "mask"),
+    llvm::ConstantInt::get(llvm::IntegerType::getInt1Ty(Context), 1)
+  };
+  llvm::MDNode *MaskNode = llvm::MDNode::get(Context, MaskMDArgs);
+  MaskMDArgs[1] = llvm::ConstantInt::get(llvm::IntegerType::getInt1Ty(Context), 0);
+  llvm::MDNode *NoMaskNode = llvm::MDNode::get(Context, MaskMDArgs);
+  SmallVector<llvm::Value*, 8> ParameterNameArgs;
+  ParameterNameArgs.push_back(llvm::MDString::get(Context, "arg_name"));
+  llvm::MDNode *ParameterNameNode = 0;
+
+//  // Vector variant metadata.
+//  llvm::Value *VariantMDArgs[] = {
+//    llvm::MDString::get(Context, "variant"),
+//    llvm::UndefValue::get(llvm::Type::getVoidTy(Context))
+//  };
+//  llvm::MDNode *VariantNode = llvm::MDNode::get(Context, VariantMDArgs);
+
+  for (GroupMap::iterator GI = Groups.begin(), GE = Groups.end();
+       GI != GE;
+       ++GI) {
+    CilkElementalGroup &G = GI->second;
+
+    // Parameter information.
+    QualType FirstNonStepParmType;
+    SmallVector<llvm::Value *, 8> AligArgs;
+    SmallVector<llvm::Value *, 8> StepArgs;
+    AligArgs.push_back(llvm::MDString::get(Context, "arg_alig"));
+    StepArgs.push_back(llvm::MDString::get(Context, "arg_step"));
+
+    // Handle implicit 'this' parameter if necessary.
+    if (HasImplicitThis) {
+      ParameterNameArgs.push_back(llvm::MDString::get(Context, "this"));
+      bool IsNonStepParm = handleParameter(*this, G, "this",
+                                           StepArgs, AligArgs);
+      if (IsNonStepParm)
+        FirstNonStepParmType = cast<CXXMethodDecl>(FD)->getThisType(C);
+    }
+
+    // Handle explicit paramenters.
+    for (unsigned I = 0; I != FD->getNumParams(); ++I) {
+      const ParmVarDecl *Parm = FD->getParamDecl(I);
+      StringRef ParmName = Parm->getName();
+      if (!ParameterNameNode)
+        ParameterNameArgs.push_back(llvm::MDString::get(Context, ParmName));
+      bool IsNonStepParm = handleParameter(*this, G, ParmName,
+                                           StepArgs, AligArgs);
+      if (IsNonStepParm && FirstNonStepParmType.isNull())
+        FirstNonStepParmType = Parm->getType();
+    }
+
+    llvm::MDNode *StepNode = llvm::MDNode::get(Context, StepArgs);
+    llvm::MDNode *AligNode = llvm::MDNode::get(Context, AligArgs);
+    if (!ParameterNameNode)
+      ParameterNameNode = llvm::MDNode::get(Context, ParameterNameArgs);
+
+    // If there is no vectorlengthfor() in this group, determine the
+    // characteristic type. This can depend on the linear/uniform attributes,
+    // so it can differ between groups.
+    //
+    // The rules for computing the characteristic type are:
+    //
+    // a) For a non-void function, the characteristic data type is the
+    //    return type.
+    //
+    // b) If the function has any non-uniform, non-linear parameters, the
+    //    the characteristic data type is the type of the first such parameter.
+    //
+    // c) If the characteristic data type determined by a) or b) above is
+    //    struct, union, or class type which is pass-by-value (except fo
+    //    the type that maps to the built-in complex data type)
+    //    the characteristic data type is int.
+    //
+    // d) If none of the above three cases is applicable,
+    //    the characteristic data type is int.
+    //
+    // e) For Intel Xeon Phi native and offload compilation, if the resulting
+    //    characteristic data type is 8-bit or 16-bit integer data type
+    //    the characteristic data type is int.
+    //
+    // These rules missed the reference types and we use their pointer types.
+    //
+    if (G.VecLengthFor.empty()) {
+      QualType FnRetTy = FD->getReturnType();
+      QualType CharacteristicType;
+      if (!FnRetTy->isVoidType())
+        CharacteristicType = FnRetTy;
+      else if (!FirstNonStepParmType.isNull())
+        CharacteristicType = FirstNonStepParmType.getCanonicalType();
+      else
+        CharacteristicType = C.IntTy;
+
+      if (CharacteristicType->isReferenceType()) {
+        QualType BaseTy = CharacteristicType.getNonReferenceType();
+        CharacteristicType = C.getPointerType(BaseTy);
+      } else if (CharacteristicType->isAggregateType())
+        CharacteristicType = C.IntTy;
+      // FIXME: handle Xeon Phi targets.
+      G.VecLengthFor.push_back(CharacteristicType);
+    }
+
+//    // If no mask variants are specified, generate both.
+//    if (G.Mask.empty()) {
+//      G.Mask.push_back(1);
+//      G.Mask.push_back(0);
+//    }
+
+    // If no vector length is specified, push a dummy value to iterate over.
+    if (G.VecLength.empty())
+      G.VecLength.push_back(0);
+
+    for (CilkElementalGroup::VecLengthForVector::iterator
+          TI = G.VecLengthFor.begin(),
+          TE = G.VecLengthFor.end();
+          TI != TE;
+          ++TI) {
+
+
+        uint64_t VectorRegisterBytes = 0;
+        // Inspect the current target features to determine the
+        // appropriate vector size.
+        // This is currently X86 specific.
+        if (Target.hasFeature("avx2"))
+          VectorRegisterBytes = 64;
+        else if (Target.hasFeature("avx"))
+          VectorRegisterBytes = 32;
+        else if (Target.hasFeature("sse2"))
+          VectorRegisterBytes = 16;
+        else if (Target.hasFeature("sse") &&
+                (*TI)->isFloatingType() &&
+                C.getTypeSizeInChars(*TI).getQuantity() == 4)
+          VectorRegisterBytes = 16;
+        else if (Target.hasFeature("mmx") && (*TI)->isIntegerType())
+          VectorRegisterBytes = 8;
+        for (CilkElementalGroup::VecLengthVector::iterator
+              LI = G.VecLength.begin(),
+              LE = G.VecLength.end();
+             LI != LE;
+             ++LI) {
+
+          uint64_t VL = *LI ? *LI :
+            (CharUnits::fromQuantity(VectorRegisterBytes)
+             / C.getTypeSizeInChars(*TI));
+
+          llvm::MDNode *VecTypeNode
+            = MakeVecLengthMetadata(*this, "vec_length", *TI, VL);
+
+          {
+            SmallVector <llvm::Value*, 7> kernelMDArgs;
+            kernelMDArgs.push_back(Fn);
+            kernelMDArgs.push_back(ElementalNode);
+            kernelMDArgs.push_back(ParameterNameNode);
+            kernelMDArgs.push_back(StepNode);
+            kernelMDArgs.push_back(AligNode);
+            kernelMDArgs.push_back(VecTypeNode);
+            if (!G.Mask.empty())
+              kernelMDArgs.push_back((G.Mask.back()==0)?(NoMaskNode):(MaskNode));
+            llvm::MDNode *KernelMD = llvm::MDNode::get(Context, kernelMDArgs);
+            CilkElementalMetadata->addOperand(KernelMD);
+          }
+//          for (CilkElementalGroup::MaskVector::iterator
+//                MI = G.Mask.begin(),
+//                ME = G.Mask.end();
+//               MI != ME;
+//               ++MI) {
+//
+//            SmallVector <llvm::Value*, 7> kernelMDArgs;
+//            kernelMDArgs.push_back(Fn);
+//            kernelMDArgs.push_back(ElementalNode);
+//            kernelMDArgs.push_back(ParameterNameNode);
+//            kernelMDArgs.push_back(StepNode);
+//            kernelMDArgs.push_back(AligNode);
+//            kernelMDArgs.push_back(VecTypeNode);
+//            kernelMDArgs.push_back((*MI==0)?(NoMaskNode):(MaskNode));
+//            if (ProcessorNode)
+//              kernelMDArgs.push_back(ProcessorNode);
+//            kernelMDArgs.push_back(VariantNode);
+//            llvm::MDNode *KernelMD = llvm::MDNode::get(Context, kernelMDArgs);
+//            CilkElementalMetadata->addOperand(KernelMD);
+//            ElementalVariantToEmit.push_back(
+//                ElementalVariantInfo(&FnInfo, FD, Fn, KernelMD));
+//          }
+        }
+      }
+  }
+}
+
+
+
+// Vector variants CodeGen for elemental functions.
+namespace {
+
+enum ISAClass {
+  IC_XMM,
+  IC_YMM1,
+  IC_YMM2,
+  IC_ZMM,
+  IC_Unknown
+};
+
+enum ParamKind {
+  PK_Vector,
+  PK_LinearConst,
+  PK_Linear,
+  PK_Uniform
+};
+
+struct ParamInfo {
+  ParamKind Kind;
+  llvm::Value *Step;
+
+  ParamInfo(ParamKind Kind)
+  : Kind(Kind), Step(0)
+  {}
+
+  ParamInfo(ParamKind Kind, llvm::Value *Step)
+  : Kind(Kind), Step(Step)
+  {}
+};
+
+} // end anonymous namespace
+
+static ISAClass getISAClass(StringRef Processor) {
+  return llvm::StringSwitch<ISAClass>(Processor)
+    // SSE2
+    .Case("pentium_4", IC_XMM)
+    .Case("pentium_4_sse3", IC_XMM)
+    .Case("core_2_duo_ssse3", IC_XMM)
+    .Case("core_2_duo_sse4_1", IC_XMM)
+    .Case("core_i7_sse4_2", IC_XMM)
+    // AVX
+    .Case("core_2nd_gen_avx", IC_YMM1)
+    .Case("core_3rd_gen_avx", IC_YMM1)
+    // AVX2
+    .Case("core_4th_gen_avx", IC_YMM2)
+    // MIC
+    .Case("mic", IC_ZMM)
+    .Default(IC_Unknown);
+}
+
+static char encodeISAClass(ISAClass ISA) {
+  switch (ISA) {
+  case IC_XMM: return 'x';
+  case IC_YMM1: return 'y';
+  case IC_YMM2: return 'Y';
+  case IC_ZMM: return 'z';
+  case IC_Unknown: llvm_unreachable("ISA unknwon");
+  }
+  llvm_unreachable("unknown isa");
+  return 0;
+}
+
+// Return a constant vector <0, 1, ..., N - 1>
+static llvm::Constant *getIndicesVector(llvm::Type *Ty, unsigned N) {
+  SmallVector<llvm::Constant*, 4> Indices;
+  for (unsigned i = 0; i < N; ++i)
+    Indices.push_back(llvm::ConstantInt::get(Ty, i));
+  return llvm::ConstantVector::get(Indices);
+}
+
+// Return a value representing:
+//   <Arg, Arg, ..., Arg> + <Step, Step, ..., Step> * <0, 1, ..., VLen - 1>
+static llvm::Value *buildLinearArg(llvm::IRBuilder<> &B, unsigned VLen,
+                                   llvm::Value *Arg, llvm::Value *Step) {
+  llvm::Type *Ty = Arg->getType();
+  llvm::Value *Base = B.CreateVectorSplat(VLen, Arg);
+  llvm::Value *Offset = B.CreateMul(getIndicesVector(Step->getType(), VLen),
+                                    B.CreateVectorSplat(VLen, Step));
+  if (Ty->isPointerTy())
+    return B.CreateGEP(Base, Offset);
+  assert(Ty->isIntegerTy() && "expected an integer type");
+  return B.CreateAdd(Base, B.CreateIntCast(Offset, Base->getType(), false));
+}
+
+static llvm::Value *buildMask(llvm::IRBuilder<> &B, unsigned VL,
+                              llvm::Value *Mask) {
+  llvm::Type *Ty = Mask->getType()->getVectorElementType();
+  if (Ty->isFloatTy())
+    Mask = B.CreateBitCast(Mask, llvm::VectorType::get(B.getInt32Ty(), VL));
+  else if (Ty->isDoubleTy())
+    Mask = B.CreateBitCast(Mask, llvm::VectorType::get(B.getInt64Ty(), VL));
+  else
+    assert((Ty->isIntegerTy()|| Ty->isPointerTy()) && "unexpected type");
+
+  return B.CreateICmpNE(Mask, llvm::Constant::getNullValue(Mask->getType()));
+}
+
+static llvm::FunctionType *encodeParameters(llvm::Function *Func,
+                                            llvm::MDNode *ArgName,
+                                            llvm::MDNode *ArgStep,
+                                            bool Mask,
+                                            llvm::Type *VectorDataTy,
+                                            SmallVectorImpl<ParamInfo> &Info,
+                                     llvm::raw_svector_ostream &MangledParams) {
+  assert(Func && "Func is null");
+  unsigned ArgSize = Func->arg_size();
+
+  assert((ArgName->getNumOperands() == 1 + ArgSize) && "invalid metadata");
+  assert((ArgStep->getNumOperands() == 1 + ArgSize) && "invalid metadata");
+
+  SmallVector<llvm::Type*, 4> Tys;
+  llvm::Function::const_arg_iterator Arg = Func->arg_begin();
+  for (unsigned i = 1, ie = 1 + ArgSize; i < ie; ++i, ++Arg) {
+    llvm::Value *Step = ArgStep->getOperand(i);
+    if (isa<llvm::UndefValue>(Step)) {
+      MangledParams << "v";
+      unsigned VL = VectorDataTy->getVectorNumElements();
+      Tys.push_back(llvm::VectorType::get(Arg->getType(), VL));
+      Info.push_back(ParamInfo(PK_Vector));
+    } else if (llvm::ConstantInt *C = dyn_cast<llvm::ConstantInt>(Step)) {
+      if (C->isZero()) {
+        MangledParams << "u";
+        Tys.push_back(Arg->getType());
+        Info.push_back(ParamInfo(PK_Uniform));
+      } else {
+        MangledParams << "l";
+        if (!C->isOne())
+          MangledParams << C->getZExtValue();
+        Tys.push_back(Arg->getType());
+        Info.push_back(ParamInfo(PK_LinearConst, C));
+      }
+    } else if (llvm::MDString *StepName = dyn_cast<llvm::MDString>(Step)) {
+      // Search parameter names for StepName to determine the index.
+      unsigned Idx = 0, NumParams = ArgName->getNumOperands() - 1;
+      for (; Idx < NumParams; ++Idx) {
+        // The first operand is the argument name kind metadata.
+        llvm::Value *V = ArgName->getOperand(Idx + 1);
+        assert(isa<llvm::MDString>(V) && "invalid metadata");
+        llvm::MDString *MS = cast<llvm::MDString>(V);
+        if (MS->getString().equals(StepName->getString()))
+          break;
+      }
+      assert((Idx < NumParams) && "step parameter not found");
+
+      MangledParams << "s" << Idx;
+      Tys.push_back(Arg->getType());
+      llvm::LLVMContext &Context = Func->getContext();
+      Step = llvm::ConstantInt::get(llvm::Type::getInt32Ty(Context), Idx);
+      Info.push_back(ParamInfo(PK_Linear, Step));
+    } else
+      llvm_unreachable("invalid step metadata");
+  }
+
+  if (Mask)
+    Tys.push_back(VectorDataTy);
+
+  llvm::Type *RetTy = Func->getReturnType();
+  RetTy = RetTy->isVoidTy() ? RetTy : VectorDataTy;
+  return llvm::FunctionType::get(RetTy, Tys, false);
+}
+
+static void setVectorVariantAttributes(llvm::Function *Func,
+                                       llvm::Function *NewFunc,
+                                       const std::string &Processor) {
+  llvm::AttrBuilder NewFuncAttrs(Func->getAttributes(),
+                                 llvm::AttributeSet::FunctionIndex);
+
+  std::string CPU = llvm::StringSwitch<std::string>(Processor)
+    .Case("pentium_4",         "pentium4")
+    .Case("pentium_4_sse3",    "yonah")
+    .Case("core_2_duo_ssse3",  "core2")
+    .Case("core_2_duo_sse4_1", "penryn")
+    .Case("core_i7_sse4_2",    "corei7")
+    .Case("core_2nd_gen_avx",  "corei7-avx")
+    .Case("core_3rd_gen_avx",  "core-avx-i")
+    .Case("core_4th_gen_avx",  "core-avx2")
+    .Case("mic",               "")
+    .Default("");
+
+  if (!CPU.empty())
+    NewFuncAttrs.addAttribute("cpu", CPU);
+
+  if (NewFuncAttrs.hasAttributes())
+    NewFunc->setAttributes(
+        llvm::AttributeSet::get(NewFunc->getContext(),
+                                llvm::AttributeSet::FunctionIndex,
+                                NewFuncAttrs));
+}
+
+static void createVectorVariantWrapper(llvm::Function *ScalarFunc,
+                                       llvm::Function *VectorFunc,
+                                       unsigned VLen,
+                                       const SmallVectorImpl<ParamInfo> &Info) {
+  assert(ScalarFunc->arg_size() == Info.size() &&
+         "Wrong number of parameter infos");
+  assert((VLen & (VLen - 1)) == 0 && "VLen must be a power-of-2");
+
+  bool IsMasked = VectorFunc->arg_size() == ScalarFunc->arg_size() + 1;
+  llvm::LLVMContext &Context = ScalarFunc->getContext();
+  llvm::BasicBlock *Entry
+    = llvm::BasicBlock::Create(Context, "entry", VectorFunc);
+  llvm::BasicBlock *LoopCond
+    = llvm::BasicBlock::Create(Context, "loop.cond", VectorFunc);
+  llvm::BasicBlock *LoopBody
+    = llvm::BasicBlock::Create(Context, "loop.body", VectorFunc);
+  llvm::BasicBlock *MaskOn
+    = IsMasked ? llvm::BasicBlock::Create(Context, "mask_on", VectorFunc) : 0;
+  llvm::BasicBlock *MaskOff
+    = IsMasked ? llvm::BasicBlock::Create(Context, "mask_off", VectorFunc) : 0;
+  llvm::BasicBlock *LoopStep
+    = llvm::BasicBlock::Create(Context, "loop.step", VectorFunc);
+  llvm::BasicBlock *LoopEnd
+    = llvm::BasicBlock::Create(Context, "loop.end", VectorFunc);
+
+  llvm::Value *VectorRet = 0;
+  SmallVector<llvm::Value*, 4> VectorArgs;
+
+  // The loop counter.
+  llvm::Type *IndexTy = llvm::Type::getInt32Ty(Context);
+  llvm::Value *Index = 0;
+  llvm::Value *Mask = 0;
+
+  // Copy the names from the scalar args to the vector args.
+  {
+    llvm::Function::arg_iterator SI = ScalarFunc->arg_begin(),
+                                 SE = ScalarFunc->arg_end(),
+                                 VI = VectorFunc->arg_begin();
+    for ( ; SI != SE; ++SI, ++VI)
+      VI->setName(SI->getName());
+    if (IsMasked)
+      VI->setName("mask");
+  }
+
+  llvm::IRBuilder<> Builder(Entry);
+  {
+    if (!VectorFunc->getReturnType()->isVoidTy())
+      VectorRet = Builder.CreateAlloca(VectorFunc->getReturnType());
+
+    Index = Builder.CreateAlloca(IndexTy, 0, "index");
+    Builder.CreateStore(llvm::ConstantInt::get(IndexTy, 0), Index);
+
+    llvm::Function::arg_iterator VI = VectorFunc->arg_begin();
+    for (SmallVectorImpl<ParamInfo>::const_iterator I = Info.begin(),
+         IE = Info.end(); I != IE; ++I, ++VI) {
+      llvm::Value *Arg = VI;
+      switch (I->Kind) {
+      case PK_Vector:
+        assert(Arg->getType()->isVectorTy() && "Not a vector");
+        assert(VLen == Arg->getType()->getVectorNumElements() &&
+               "Wrong number of elements");
+        break;
+      case PK_LinearConst:
+        Arg = buildLinearArg(Builder, VLen, Arg, I->Step);
+        Arg->setName(VI->getName() + ".linear");
+        break;
+      case PK_Linear: {
+        unsigned Number = cast<llvm::ConstantInt>(I->Step)->getZExtValue();
+        llvm::Function::arg_iterator ArgI = VectorFunc->arg_begin();
+        std::advance(ArgI, Number);
+        llvm::Value *Step = ArgI;
+        Arg = buildLinearArg(Builder, VLen, Arg, Step);
+        Arg->setName(VI->getName() + ".linear");
+      } break;
+      case PK_Uniform:
+        Arg = Builder.CreateVectorSplat(VLen, Arg);
+        Arg->setName(VI->getName() + ".uniform");
+        break;
+      }
+      VectorArgs.push_back(Arg);
+    }
+
+    if (IsMasked)
+      Mask = buildMask(Builder, VLen, VI);
+
+    Builder.CreateBr(LoopCond);
+  }
+
+  Builder.SetInsertPoint(LoopCond);
+  {
+    llvm::Value *Cond = Builder.CreateICmpULT(
+        Builder.CreateLoad(Index), llvm::ConstantInt::get(IndexTy, VLen));
+    Builder.CreateCondBr(Cond, LoopBody, LoopEnd);
+  }
+
+  llvm::Value *VecIndex = 0;
+
+  Builder.SetInsertPoint(LoopBody);
+  {
+    VecIndex = Builder.CreateLoad(Index);
+    if (IsMasked) {
+      llvm::Value *ScalarMask = Builder.CreateExtractElement(Mask, VecIndex);
+      Builder.CreateCondBr(ScalarMask, MaskOn, MaskOff);
+    }
+  }
+
+  Builder.SetInsertPoint(IsMasked ? MaskOn : LoopBody);
+  {
+    // Build the argument list for the scalar function by extracting element
+    // 'VecIndex' from the vector arguments.
+    SmallVector<llvm::Value*, 4> ScalarArgs;
+    for (SmallVectorImpl<llvm::Value*>::iterator VI = VectorArgs.begin(),
+         VE = VectorArgs.end(); VI != VE; ++VI) {
+      assert((*VI)->getType()->isVectorTy() && "Not a vector");
+      ScalarArgs.push_back(Builder.CreateExtractElement(*VI, VecIndex));
+    }
+
+    // Call the scalar function with the extracted scalar arguments.
+    llvm::Value *ScalarRet = Builder.CreateCall(ScalarFunc, ScalarArgs);
+
+    // If the function returns a value insert the scalar return value into the
+    // vector return value.
+    if (VectorRet) {
+      llvm::Value *V = Builder.CreateLoad(VectorRet);
+      V = Builder.CreateInsertElement(V, ScalarRet, VecIndex);
+      Builder.CreateStore(V, VectorRet);
+    }
+
+    Builder.CreateBr(LoopStep);
+  }
+
+  if (IsMasked) {
+    Builder.SetInsertPoint(MaskOff);
+    if (VectorRet) {
+      llvm::Value *V = Builder.CreateLoad(VectorRet);
+      llvm::Value *Zero
+        = llvm::Constant::getNullValue(ScalarFunc->getReturnType());
+      V = Builder.CreateInsertElement(V, Zero, VecIndex);
+      Builder.CreateStore(V, VectorRet);
+    }
+    Builder.CreateBr(LoopStep);
+  }
+
+  Builder.SetInsertPoint(LoopStep);
+  {
+    // Index = Index + 1
+    VecIndex = Builder.CreateAdd(VecIndex, llvm::ConstantInt::get(IndexTy, 1));
+    Builder.CreateStore(VecIndex, Index);
+    Builder.CreateBr(LoopCond);
+  }
+
+  Builder.SetInsertPoint(LoopEnd);
+  {
+    if (VectorRet)
+      Builder.CreateRet(Builder.CreateLoad(VectorRet));
+    else
+      Builder.CreateRetVoid();
+  }
+}
+
+static bool createVectorVariant(llvm::MDNode *Root,
+                                const FunctionDecl *FD,
+                                llvm::Function *F) {
+  llvm::Module &M = *F->getParent();
+
+  if (Root->getNumOperands() == 0)
+    return false;
+  llvm::Function *Func = dyn_cast<llvm::Function>(Root->getOperand(0));
+  if (Func != F)
+    return false;
+
+  bool Elemental = false;
+
+  unsigned VariantIndex = 0;
+  llvm::MDNode *ArgName = 0,
+               *ArgStep = 0,
+               *VecLength = 0,
+               *Processor = 0,
+               *Mask = 0,
+               *Variant = 0;
+
+  for (unsigned i = 1, ie = Root->getNumOperands(); i < ie; ++i) {
+    llvm::MDNode *Node = dyn_cast<llvm::MDNode>(Root->getOperand(i));
+    if (!Node || Node->getNumOperands() < 1)
+      return false;
+    llvm::MDString *Name = dyn_cast<llvm::MDString>(Node->getOperand(0));
+    if (!Name)
+      return false;
+
+    if (Name->getString() == "elemental") {
+      Elemental = true;
+    } else if (Name->getString() == "arg_name") {
+      ArgName = Node;
+    } else if (Name->getString() == "arg_step") {
+      ArgStep = Node;
+    } else if (Name->getString() == "vec_length") {
+      VecLength = Node;
+    } else if (Name->getString() == "processor") {
+      Processor = Node;
+    } else if (Name->getString() == "mask") {
+      Mask = Node;
+    } else if (Name->getString() == "variant") {
+      VariantIndex = i;
+      Variant = Node;
+    } else {
+      DEBUG(llvm::dbgs() << "Unknown metadata " << Name->getString() << "\n");
+      return false;
+    }
+  }
+
+  if (!Elemental || !ArgName || !ArgStep || !VecLength || !Variant) {
+    DEBUG(llvm::dbgs() << "Missing necessary metadata node" << "\n");
+    return false;
+  }
+
+  if (llvm::Value *V = Variant->getOperand(1))
+    if (!V->getType()->isVoidTy())
+      return false;
+
+  // The default processor is pentium_4.
+  std::string ProcessorName = "pentium_4";
+  if (Processor) {
+    if (Processor->getNumOperands() != 2)
+      return false;
+    llvm::MDString *Name = dyn_cast<llvm::MDString>(Processor->getOperand(1));
+    if (!Name)
+      return false;
+    ProcessorName = Name->getString().str();
+  }
+  ISAClass ISA = getISAClass(ProcessorName);
+  if (ISA == IC_Unknown)
+    return false;
+
+  bool IsMasked = true;
+  if (Mask) {
+    if (Mask->getNumOperands() != 2)
+      return false;
+    llvm::ConstantInt *C = dyn_cast<llvm::ConstantInt>(Mask->getOperand(1));
+    if (!C)
+      return false;
+    IsMasked = C->isOne();
+  }
+
+  llvm::Type *VectorDataTy = 0;
+  uint64_t VLen = 0;
+  {
+    if (VecLength->getNumOperands() != 3)
+      return false;
+    llvm::Type *Ty = VecLength->getOperand(1)->getType();
+    if (!llvm::VectorType::isValidElementType(Ty))
+      return false;
+
+    llvm::Value *VL = VecLength->getOperand(2);
+    assert(isa<llvm::ConstantInt>(VL) && "vector length constant expected");
+    VLen = cast<llvm::ConstantInt>(VL)->getZExtValue();
+    VectorDataTy = llvm::VectorType::get(Ty, VLen);
+  }
+
+  SmallVector<ParamInfo, 4> Info;
+  SmallString<16> ParamStr;
+  llvm::raw_svector_ostream MangledParams(ParamStr);
+  llvm::FunctionType *NewFuncTy = encodeParameters(Func, ArgName, ArgStep,
+                                                   IsMasked, VectorDataTy,
+                                                   Info, MangledParams);
+  if (!NewFuncTy)
+    return false;
+
+  // Generate the mangled name.
+  SmallString<32> NameStr;
+  llvm::raw_svector_ostream MangledName(NameStr);
+  MangledName << "_ZGV" // Magic prefix
+              << encodeISAClass(ISA)
+              << (IsMasked ? 'M' : 'N')
+              << VLen
+              << MangledParams.str()
+              << "_"
+              << Func->getName();
+
+  DEBUG(llvm::dbgs() << "Creating elemental function "
+                     << MangledName.str() << "\n");
+
+  // Declare the vector variant function in to the module.
+  llvm::Function *NewFunc =
+    dyn_cast<llvm::Function>(M.getOrInsertFunction(MangledName.str(), NewFuncTy));
+  if (!NewFunc || !NewFunc->empty())
+    return false;
+
+  setVectorVariantAttributes(Func, NewFunc, ProcessorName);
+
+  // Define the vector variant if the scalar function is not a declaration.
+  if (FD->hasBody())
+    createVectorVariantWrapper(Func, NewFunc, VLen, Info);
+
+  // Update the vector variant metadata.
+  {
+    assert(VariantIndex && "invalid variant index");
+    llvm::LLVMContext &Context = Func->getContext();
+    llvm::Value *VariantMDArgs[] = {
+      llvm::MDString::get(Context, "variant"),
+      NewFunc
+    };
+    llvm::MDNode *VariantNode = llvm::MDNode::get(Context, VariantMDArgs);
+    Root->replaceOperandWith(VariantIndex, VariantNode);
+  }
+
+  return true;
+}
+
+void CodeGenModule::EmitCilkElementalVariants() {
+  for (SmallVectorImpl<ElementalVariantInfo>::iterator
+      I = ElementalVariantToEmit.begin(),
+      E = ElementalVariantToEmit.end(); I != E; ++I)
+    createVectorVariant(I->KernelMD, I->FD, I->Fn);
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGExpr.cpp cfe-3.5.0.src.omp/lib/CodeGen/CGExpr.cpp
--- cfe-3.5.0.src/lib/CodeGen/CGExpr.cpp	2014-07-21 15:47:02.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGExpr.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -16,6 +16,7 @@
 #include "CGCall.h"
 #include "CGDebugInfo.h"
 #include "CGObjCRuntime.h"
+#include "CGOpenMPRuntime.h"
 #include "CGRecordLayout.h"
 #include "CodeGenModule.h"
 #include "TargetInfo.h"
@@ -1832,7 +1833,23 @@
   CharUnits Alignment = getContext().getDeclAlign(ND);
   QualType T = E->getType();
 
-  if (const auto *VD = dyn_cast<VarDecl>(ND)) {
+  // A DeclRefExpr for a reference initialized by a constant expression can
+  // appear without being odr-used. Directly emit the constant initializer.
+  if (const VarDecl *VD = dyn_cast<VarDecl>(ND)) {
+
+    // CodeGen for threadprivate variables.
+    if (getLangOpts().OpenMP) {
+      if (llvm::Value *Val =
+               CGM.getOpenMPRuntime().CreateOpenMPThreadPrivateCached(VD, E->getExprLoc(), *this))
+        return MakeAddrLValue(Val, T, Alignment);
+      // CodeGen for OpenMP private variables - works only in CapturedStmt.
+      else if (llvm::Value *Val = CGM.OpenMPSupport.getOpenMPPrivateVar(VD))
+        return MakeAddrLValue(Val, T, Alignment);
+      else if (CapturedStmtInfo)
+        if (llvm::Value *Val = CapturedStmtInfo->getCachedVar(VD))
+          return MakeAddrLValue(Val, T, Alignment);
+    }
+
     // Global Named registers access via intrinsics only
     if (VD->getStorageClass() == SC_Register &&
         VD->hasAttr<AsmLabelAttr>() && !VD->isLocalVarDecl())
@@ -2044,8 +2061,9 @@
     GVName += FnName;
 
     // If this is outside of a function use the top level decl.
-    const Decl *CurDecl = CurCodeDecl;
-    if (!CurDecl || isa<VarDecl>(CurDecl))
+    const Decl *CurDecl =
+      OpenMPRoot ? OpenMPRoot->CurCodeDecl : CurCodeDecl;
+    if (CurDecl == 0 || isa<VarDecl>(CurDecl))
       CurDecl = getContext().getTranslationUnitDecl();
 
     const Type *ElemType = E->getType()->getArrayElementTypeNoTypeQual();
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGExprScalar.cpp cfe-3.5.0.src.omp/lib/CodeGen/CGExprScalar.cpp
--- cfe-3.5.0.src/lib/CodeGen/CGExprScalar.cpp	2014-07-17 14:46:27.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGExprScalar.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -224,6 +224,11 @@
     return CGF.getOpaqueRValueMapping(E).getScalarVal();
   }
 
+  Value *VisitCEANIndexExpr(CEANIndexExpr *E) {
+    assert (E->getIndexExpr() && "Index expr is not set");
+    return CGF.EmitScalarExpr(E->getIndexExpr());
+  }
+
   // l-values.
   Value *VisitDeclRefExpr(DeclRefExpr *E) {
     if (CodeGenFunction::ConstantEmission result = CGF.tryEmitAsConstant(E)) {
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGLoopInfo.cpp cfe-3.5.0.src.omp/lib/CodeGen/CGLoopInfo.cpp
--- cfe-3.5.0.src/lib/CodeGen/CGLoopInfo.cpp	2014-07-21 19:10:56.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGLoopInfo.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -15,14 +15,15 @@
 #include "llvm/IR/Metadata.h"
 using namespace clang;
 using namespace CodeGen;
-using namespace llvm;
 
-static MDNode *createMetadata(LLVMContext &Ctx, const LoopAttributes &Attrs) {
-
-  if (!Attrs.IsParallel && Attrs.VectorizerWidth == 0 &&
-      Attrs.VectorizerUnroll == 0 &&
-      Attrs.VectorizerEnable == LoopAttributes::VecUnspecified)
-    return nullptr;
+static llvm::MDNode *CreateMetadata(llvm::LLVMContext &Ctx,
+                                    const LoopAttributes &Attrs) {
+  using namespace llvm;
+
+  if (!Attrs.IsParallel &&
+      Attrs.VectorizerWidth == 0 &&
+      Attrs.VectorizerEnable == LoopAttributes::LVEC_UNSPECIFIED)
+    return 0;
 
   SmallVector<Value *, 4> Args;
   // Reserve operand 0 for loop id self reference.
@@ -30,28 +31,31 @@
   Args.push_back(TempNode);
 
   // Setting vectorizer.width
+  // TODO: For a correct implementation of 'safelen' clause
+  // we need to update the value somewhere (based on target info).
   if (Attrs.VectorizerWidth > 0) {
-    Value *Vals[] = { MDString::get(Ctx, "llvm.loop.vectorize.width"),
-                      ConstantInt::get(Type::getInt32Ty(Ctx),
-                                       Attrs.VectorizerWidth) };
-    Args.push_back(MDNode::get(Ctx, Vals));
-  }
-
-  // Setting vectorizer.unroll
-  if (Attrs.VectorizerUnroll > 0) {
-    Value *Vals[] = { MDString::get(Ctx, "llvm.loop.interleave.count"),
-                      ConstantInt::get(Type::getInt32Ty(Ctx),
-                                       Attrs.VectorizerUnroll) };
+    Value *Vals[] = {
+      MDString::get(Ctx, "llvm.vectorizer.width"),
+      ConstantInt::get(Type::getInt32Ty(Ctx), Attrs.VectorizerWidth)
+    };
     Args.push_back(MDNode::get(Ctx, Vals));
   }
 
   // Setting vectorizer.enable
-  if (Attrs.VectorizerEnable != LoopAttributes::VecUnspecified) {
-    Value *Vals[] = { MDString::get(Ctx, "llvm.loop.vectorize.enable"),
-                      ConstantInt::get(Type::getInt1Ty(Ctx),
-                                       (Attrs.VectorizerEnable ==
-                                        LoopAttributes::VecEnable)) };
-    Args.push_back(MDNode::get(Ctx, Vals));
+  int EnableLoopVectorizer = 0;
+  switch (Attrs.VectorizerEnable) {
+    case LoopAttributes::LVEC_UNSPECIFIED:
+      break;
+    case LoopAttributes::LVEC_ENABLE:
+      EnableLoopVectorizer = 1;
+      // Fall-through
+    case LoopAttributes::LVEC_DISABLE:
+      Value *Vals[] = {
+        MDString::get(Ctx, "llvm.vectorizer.enable"),
+        ConstantInt::get(Type::getInt1Ty(Ctx), EnableLoopVectorizer)
+      };
+      Args.push_back(MDNode::get(Ctx, Vals));
+      break;
   }
 
   MDNode *LoopID = MDNode::get(Ctx, Args);
@@ -64,49 +68,89 @@
 }
 
 LoopAttributes::LoopAttributes(bool IsParallel)
-    : IsParallel(IsParallel), VectorizerEnable(LoopAttributes::VecUnspecified),
-      VectorizerWidth(0), VectorizerUnroll(0) {}
+  : IsParallel(IsParallel),
+    VectorizerEnable(LoopAttributes::LVEC_UNSPECIFIED),
+    VectorizerWidth(0) { }
 
-void LoopAttributes::clear() {
+void LoopAttributes::Clear() {
   IsParallel = false;
   VectorizerWidth = 0;
-  VectorizerUnroll = 0;
-  VectorizerEnable = LoopAttributes::VecUnspecified;
+  VectorizerEnable = LoopAttributes::LVEC_UNSPECIFIED;
 }
 
-LoopInfo::LoopInfo(BasicBlock *Header, const LoopAttributes &Attrs)
-    : LoopID(nullptr), Header(Header), Attrs(Attrs) {
-  LoopID = createMetadata(Header->getContext(), Attrs);
+LoopInfo::LoopInfo(llvm::BasicBlock *Header, const LoopAttributes &Attrs)
+  : LoopID(0), Header(Header), Attrs(Attrs) {
+  LoopID = CreateMetadata(Header->getContext(), Attrs);
 }
 
-void LoopInfoStack::push(BasicBlock *Header) {
+LoopInfo::LoopInfo(llvm::MDNode *LoopID, const LoopAttributes &Attrs)
+  : LoopID(LoopID), Header(0), Attrs(Attrs) { }
+
+void LoopInfoStack::Push(llvm::BasicBlock *Header) {
   Active.push_back(LoopInfo(Header, StagedAttrs));
   // Clear the attributes so nested loops do not inherit them.
-  StagedAttrs.clear();
+  StagedAttrs.Clear();
 }
 
-void LoopInfoStack::pop() {
-  assert(!Active.empty() && "No active loops to pop");
+void LoopInfoStack::Pop() {
+  assert(!Active.empty());
   Active.pop_back();
 }
 
-void LoopInfoStack::InsertHelper(Instruction *I) const {
-  if (!hasInfo())
+void LoopInfoStack::AddAligned(const llvm::Value *Val, int Align) {
+  // The following restriction should be enforced by Sema, so
+  // check it with assertion.
+  assert(Aligneds.find(Val) == Aligneds.end() ||
+         Aligneds.find(Val)->second == Align);
+  Aligneds.insert(std::make_pair(Val, Align));
+}
+
+int LoopInfoStack::GetAligned(const llvm::Value *Val) const {
+  llvm::DenseMap<const llvm::Value *, int>::const_iterator It =
+    Aligneds.find(Val);
+  if (It == Aligneds.end()) return 0;
+  return It->second;
+}
+
+void LoopInfoStack::InsertHelper(llvm::Instruction *I) const {
+  if (!HasInfo())
     return;
 
-  const LoopInfo &L = getInfo();
-  if (!L.getLoopID())
+  const LoopInfo &L = GetInfo();
+
+  if (!L.GetLoopID())
     return;
 
-  if (TerminatorInst *TI = dyn_cast<TerminatorInst>(I)) {
+  if (llvm::TerminatorInst *TI = llvm::dyn_cast<llvm::TerminatorInst>(I)) {
     for (unsigned i = 0, ie = TI->getNumSuccessors(); i < ie; ++i)
-      if (TI->getSuccessor(i) == L.getHeader()) {
-        TI->setMetadata("llvm.loop", L.getLoopID());
+      if (TI->getSuccessor(i) == L.GetHeader()) {
+        TI->setMetadata("llvm.loop", L.GetLoopID());
         break;
       }
     return;
   }
 
-  if (L.getAttributes().IsParallel && I->mayReadOrWriteMemory())
-    I->setMetadata("llvm.mem.parallel_loop_access", L.getLoopID());
+  if (L.GetAttributes().IsParallel) {
+    if (llvm::StoreInst *SI = llvm::dyn_cast<llvm::StoreInst>(I)) {
+      SI->setMetadata("llvm.mem.parallel_loop_access", L.GetLoopID());
+    }
+    else if (llvm::LoadInst *LI = llvm::dyn_cast<llvm::LoadInst>(I)) {
+      LI->setMetadata("llvm.mem.parallel_loop_access", L.GetLoopID());
+      if (int Align = GetAligned(LI->getOperand(0))) {
+        llvm::Value *AlignVal = llvm::ConstantInt::get(
+            llvm::Type::getInt32Ty(LI->getContext()), Align);
+        llvm::SmallVector<llvm::Value *, 4> Args;
+        Args.push_back(AlignVal);
+        llvm::MDNode *Node = llvm::MDNode::get(LI->getContext(), Args);
+        LI->setMetadata("llvm.mem.aligned", Node);
+      }
+    }
+  }
 }
+
+void LoopInfoStack::Push(llvm::MDNode *LoopID, bool IsParallel) {
+  assert(Active.empty() && "cannot have an active loop");
+  Active.push_back(LoopInfo(LoopID, LoopAttributes(IsParallel)));
+  StagedAttrs.Clear();
+}
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGLoopInfo.h cfe-3.5.0.src.omp/lib/CodeGen/CGLoopInfo.h
--- cfe-3.5.0.src/lib/CodeGen/CGLoopInfo.h	2014-07-21 19:10:56.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGLoopInfo.h	2014-11-28 10:49:29.000000000 -0500
@@ -15,10 +15,10 @@
 #ifndef CLANG_CODEGEN_CGLOOPINFO_H
 #define CLANG_CODEGEN_CGLOOPINFO_H
 
-#include "llvm/ADT/DenseMap.h"
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/IR/Value.h"
+#include "llvm/ADT/DenseMap.h"
 #include "llvm/Support/Compiler.h"
+#include "llvm/IR/Value.h"
 
 namespace llvm {
 class BasicBlock;
@@ -29,105 +29,116 @@
 namespace clang {
 namespace CodeGen {
 
-/// \brief Attributes that may be specified on loops.
+/// LoopAttributes - Per loop attributes.
 struct LoopAttributes {
   explicit LoopAttributes(bool IsParallel = false);
-  void clear();
+  void Clear();
 
-  /// \brief Generate llvm.loop.parallel metadata for loads and stores.
+  /// llvm.loop.parallel metadata generation for loads and stores.
   bool IsParallel;
 
-  /// \brief Values of llvm.loop.vectorize.enable metadata.
-  enum LVEnableState { VecUnspecified, VecEnable, VecDisable };
+  /// llvm.vectorizer.enable value:
+  enum LVEnableState {
+    LVEC_UNSPECIFIED,
+    LVEC_ENABLE,
+    LVEC_DISABLE
+  };
 
-  /// \brief llvm.loop.vectorize.enable
   LVEnableState VectorizerEnable;
 
-  /// \brief llvm.loop.vectorize.width
+  /// llvm.vectorizer.width value
   unsigned VectorizerWidth;
-
-  /// \brief llvm.loop.interleave.count
-  unsigned VectorizerUnroll;
 };
 
-/// \brief Information used when generating a structured loop.
+/// LoopInfo - Information used when generating a structured loop.
 class LoopInfo {
 public:
-  /// \brief Construct a new LoopInfo for the loop with entry Header.
+  /// Construct a new LoopInfo for the loop with entry Header.
   LoopInfo(llvm::BasicBlock *Header, const LoopAttributes &Attrs);
 
-  /// \brief Get the loop id metadata for this loop.
-  llvm::MDNode *getLoopID() const { return LoopID; }
+  /// Construct a new LoopInfo with a given loop id metadata.
+  LoopInfo(llvm::MDNode *LoopID, const LoopAttributes &Attrs);
+
+  /// Get the loop id metadata for this loop.
+  llvm::MDNode *GetLoopID() const { return LoopID; }
 
-  /// \brief Get the header block of this loop.
-  llvm::BasicBlock *getHeader() const { return Header; }
+  /// Get the header block of this loop.
+  llvm::BasicBlock *GetHeader() const { return Header; }
 
-  /// \brief Get the set of attributes active for this loop.
-  const LoopAttributes &getAttributes() const { return Attrs; }
+  /// Get the set of attributes active for this loop.
+  const LoopAttributes &GetAttributes() const { return Attrs; }
 
 private:
-  /// \brief Loop ID metadata.
-  llvm::MDNode *LoopID;
-  /// \brief Header block of this loop.
+  /// Loop ID metadata.
+  mutable llvm::MDNode *LoopID;
+  /// Header block of this loop.
   llvm::BasicBlock *Header;
-  /// \brief The attributes for this loop.
+  /// The attributes for this loop.
   LoopAttributes Attrs;
 };
 
-/// \brief A stack of loop information corresponding to loop nesting levels.
-/// This stack can be used to prepare attributes which are applied when a loop
-/// is emitted.
+/// LoopInfoStack - A stack of loop information corresponding to loop
+/// nesting levels. This stack can be used to prepare attributes which are
+/// applied when a loop is emitted.
 class LoopInfoStack {
   LoopInfoStack(const LoopInfoStack &) LLVM_DELETED_FUNCTION;
   void operator=(const LoopInfoStack &) LLVM_DELETED_FUNCTION;
-
 public:
   LoopInfoStack() {}
 
-  /// \brief Begin a new structured loop. The set of staged attributes will be
-  /// applied to the loop and then cleared.
-  void push(llvm::BasicBlock *Header);
-
-  /// \brief End the current loop.
-  void pop();
-
-  /// \brief Return the top loop id metadata.
-  llvm::MDNode *getCurLoopID() const { return getInfo().getLoopID(); }
-
-  /// \brief Return true if the top loop is parallel.
-  bool getCurLoopParallel() const {
-    return hasInfo() ? getInfo().getAttributes().IsParallel : false;
+  /// Begin a new structured loop. The set of applied attributes will be applied
+  /// to the loop and the attributes will be cleared.
+  void Push(llvm::BasicBlock *Header);
+
+  /// Extend the code region as part of a parallel loop which might be inside
+  /// another llvm function.
+  void Push(llvm::MDNode *LoopID, bool IsParallel);
+
+  /// End the current loop.
+  void Pop();
+
+  /// Return the top loop id metadata.
+  llvm::MDNode *GetCurLoopID() const { return GetInfo().GetLoopID(); }
+
+  /// Return true if the top loop is parallel.
+  bool GetCurLoopParallel() const {
+    return HasInfo() ?
+           GetInfo().GetAttributes().IsParallel : false;
   }
 
-  /// \brief Function called by the CodeGenFunction when an instruction is
-  /// created.
+  /// Function called by the CodeGenFunction when an instruction is created.
   void InsertHelper(llvm::Instruction *I) const;
 
-  /// \brief Set the next pushed loop as parallel.
-  void setParallel(bool Enable = true) { StagedAttrs.IsParallel = Enable; }
+  /// Set the next pushed loop as parallel.
+  void SetParallel(bool Enable = true) { StagedAttrs.IsParallel = Enable; }
 
-  /// \brief Set the next pushed loop 'vectorizer.enable'
-  void setVectorizerEnable(bool Enable = true) {
-    StagedAttrs.VectorizerEnable =
-        Enable ? LoopAttributes::VecEnable : LoopAttributes::VecDisable;
+  /// Set the next pushed loop 'vectorizer.enable'
+  void SetVectorizerEnable(bool Enable = true) {
+    StagedAttrs.VectorizerEnable = Enable ? LoopAttributes::LVEC_ENABLE :
+                                            LoopAttributes::LVEC_DISABLE;
   }
 
-  /// \brief Set the vectorizer width for the next loop pushed.
-  void setVectorizerWidth(unsigned W) { StagedAttrs.VectorizerWidth = W; }
+  /// Set the vectorizer width for the next loop pushed.
+  void SetVectorizerWidth(unsigned W) { StagedAttrs.VectorizerWidth = W; }
+
+  /// Add an aligned variable for 'aligned' clause.
+  void AddAligned(const llvm::Value *Val, int Align);
 
-  /// \brief Set the vectorizer unroll for the next loop pushed.
-  void setVectorizerUnroll(unsigned U) { StagedAttrs.VectorizerUnroll = U; }
+  /// Get alignment of given pointer based on 'aligned' clause.
+  int GetAligned(const llvm::Value *Val) const;
 
 private:
-  /// \brief Returns true if there is LoopInfo on the stack.
-  bool hasInfo() const { return !Active.empty(); }
-  /// \brief Return the LoopInfo for the current loop. HasInfo should be called
-  /// first to ensure LoopInfo is present.
-  const LoopInfo &getInfo() const { return Active.back(); }
-  /// \brief The set of attributes that will be applied to the next pushed loop.
+  /// Returns true if there is LoopInfo on the stack.
+  bool HasInfo() const { return !Active.empty(); }
+  /// Return the LoopInfo for the current loop. HasInfo should be called first
+  /// to ensure LoopInfo is present.
+  const LoopInfo &GetInfo() const { return Active.back(); }
+  /// The set of attributes that will be applied to the next pushed loop.
   LoopAttributes StagedAttrs;
-  /// \brief Stack of active loops.
+  /// Stack of active loops.
   llvm::SmallVector<LoopInfo, 4> Active;
+  // 'Aligned' information.
+  llvm::DenseMap<const llvm::Value *, int> Aligneds;
 };
 
 } // end namespace CodeGen
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGOpenMPRuntime.cpp cfe-3.5.0.src.omp/lib/CodeGen/CGOpenMPRuntime.cpp
--- cfe-3.5.0.src/lib/CodeGen/CGOpenMPRuntime.cpp	2014-06-18 03:08:49.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGOpenMPRuntime.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -1,4 +1,4 @@
-//===----- CGOpenMPRuntime.cpp - Interface to OpenMP Runtimes -------------===//
+//===----- CGOpenMPRuntime.h - Interface to OpenMP Runtimes ---------*- C++ -*-===//
 //
 //                     The LLVM Compiler Infrastructure
 //
@@ -7,17 +7,30 @@
 //
 //===----------------------------------------------------------------------===//
 //
-// This provides a class for OpenMP runtime code generation.
+// This provides an abstract class for OpenMP code generation.  Concrete
+// subclasses of this implement code generation for specific OpenMP
+// runtime libraries.
 //
 //===----------------------------------------------------------------------===//
 
+#include "CGOpenMPRuntimeTypes.h"
 #include "CGOpenMPRuntime.h"
 #include "CodeGenFunction.h"
 #include "clang/AST/Decl.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/IR/DerivedTypes.h"
 #include "llvm/IR/GlobalValue.h"
+#include "llvm/IR/Intrinsics.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/Constant.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/Type.h"
+#include "llvm/IR/TypeBuilder.h"
 #include "llvm/IR/Value.h"
+#include "llvm/ADT/StringExtras.h"
+#include "llvm/Support/Casting.h"
+#include "llvm/Support/Format.h"
 #include "llvm/Support/raw_ostream.h"
 #include <cassert>
 
@@ -25,7 +38,8 @@
 using namespace CodeGen;
 
 CGOpenMPRuntime::CGOpenMPRuntime(CodeGenModule &CGM)
-    : CGM(CGM), DefaultOpenMPPSource(nullptr) {
+    : CGM(CGM), DefaultOpenMPPSource(nullptr), NumTargetRegions(0),
+      TargetRegionsDescriptor(nullptr) {
   IdentTy = llvm::StructType::create(
       "ident_t", CGM.Int32Ty /* reserved_1 */, CGM.Int32Ty /* flags */,
       CGM.Int32Ty /* reserved_2 */, CGM.Int32Ty /* reserved_3 */,
@@ -180,3 +194,918 @@
   }
   return RTLFn;
 }
+
+#define OPENMPRTL_FUNC(name) Get_##name()
+#define OPENMPRTL_ATOMIC_FUNC(QTy, Op) GetAtomicFunc(CGF, QTy, Op)
+#define OPENMPRTL_ATOMIC_FUNC_GENERAL(QTyRes, QTyIn, Aop, Capture, Reverse)    \
+  GetAtomicFuncGeneral(CGF, QTyRes, QTyIn, Aop, Capture, Reverse)
+
+#define DEFAULT_EMIT_OPENMP_FUNC(name) \
+  llvm::Constant* CGOpenMPRuntime::Get_##name(){                                    \
+    return CGM.CreateRuntimeFunction(                                               \
+            llvm::TypeBuilder<__kmpc_##name, false>::get(CGM.getLLVMContext()),     \
+            "__kmpc_" #name);                                                       \
+  }
+
+// Convenience macro to overload the default kmpc call with something more
+// appropriate for a target
+#define TARGET_EMIT_OPENMP_FUNC(name, body)                                         \
+  llvm::Constant* Get_##name(){                                                     \
+    llvm::Function *Fn = cast<llvm::Function>(CGM.CreateRuntimeFunction(            \
+            llvm::TypeBuilder<__kmpc_##name, false>::get(CGM.getLLVMContext()),     \
+            (Twine("__kmpc_",ArchName) + Twine(#name)).str()));    \
+    llvm::BasicBlock *EntryBB = llvm::BasicBlock::Create(CGM.getLLVMContext(), "entry", Fn); \
+    CGBuilderTy Bld(EntryBB); \
+    {             \
+      body        \
+    }             \
+    return Fn;    \
+  }               \
+
+
+///===---------------
+///
+/// Default OpenMP Runtime Implementation
+///
+///===---------------
+
+DEFAULT_EMIT_OPENMP_FUNC(fork_call)
+DEFAULT_EMIT_OPENMP_FUNC(push_num_threads)
+DEFAULT_EMIT_OPENMP_FUNC(push_proc_bind)
+DEFAULT_EMIT_OPENMP_FUNC(fork_teams)
+DEFAULT_EMIT_OPENMP_FUNC(push_num_teams)
+DEFAULT_EMIT_OPENMP_FUNC(cancel_barrier)
+DEFAULT_EMIT_OPENMP_FUNC(barrier)
+DEFAULT_EMIT_OPENMP_FUNC(cancellationpoint)
+DEFAULT_EMIT_OPENMP_FUNC(cancel)
+DEFAULT_EMIT_OPENMP_FUNC(omp_taskyield)
+DEFAULT_EMIT_OPENMP_FUNC(omp_taskwait)
+DEFAULT_EMIT_OPENMP_FUNC(flush)
+DEFAULT_EMIT_OPENMP_FUNC(master)
+DEFAULT_EMIT_OPENMP_FUNC(end_master)
+DEFAULT_EMIT_OPENMP_FUNC(single)
+DEFAULT_EMIT_OPENMP_FUNC(end_single)
+DEFAULT_EMIT_OPENMP_FUNC(critical)
+DEFAULT_EMIT_OPENMP_FUNC(end_critical)
+DEFAULT_EMIT_OPENMP_FUNC(ordered)
+DEFAULT_EMIT_OPENMP_FUNC(end_ordered)
+DEFAULT_EMIT_OPENMP_FUNC(end_reduce_nowait)
+DEFAULT_EMIT_OPENMP_FUNC(end_reduce)
+DEFAULT_EMIT_OPENMP_FUNC(atomic_start)
+DEFAULT_EMIT_OPENMP_FUNC(atomic_end)
+DEFAULT_EMIT_OPENMP_FUNC(dispatch_init_4)
+DEFAULT_EMIT_OPENMP_FUNC(dispatch_init_4u)
+DEFAULT_EMIT_OPENMP_FUNC(dispatch_init_8)
+DEFAULT_EMIT_OPENMP_FUNC(dispatch_init_8u)
+DEFAULT_EMIT_OPENMP_FUNC(dispatch_next_4)
+DEFAULT_EMIT_OPENMP_FUNC(dispatch_next_4u)
+DEFAULT_EMIT_OPENMP_FUNC(dispatch_next_8)
+DEFAULT_EMIT_OPENMP_FUNC(dispatch_next_8u)
+DEFAULT_EMIT_OPENMP_FUNC(dispatch_fini_4)
+DEFAULT_EMIT_OPENMP_FUNC(dispatch_fini_4u)
+DEFAULT_EMIT_OPENMP_FUNC(dispatch_fini_8)
+DEFAULT_EMIT_OPENMP_FUNC(dispatch_fini_8u)
+DEFAULT_EMIT_OPENMP_FUNC(for_static_init_4)
+DEFAULT_EMIT_OPENMP_FUNC(for_static_init_4u)
+DEFAULT_EMIT_OPENMP_FUNC(for_static_init_8)
+DEFAULT_EMIT_OPENMP_FUNC(for_static_init_8u)
+DEFAULT_EMIT_OPENMP_FUNC(for_static_fini)
+DEFAULT_EMIT_OPENMP_FUNC(omp_task_begin_if0)
+DEFAULT_EMIT_OPENMP_FUNC(omp_task_complete_if0)
+DEFAULT_EMIT_OPENMP_FUNC(omp_task_parts)
+DEFAULT_EMIT_OPENMP_FUNC(taskgroup)
+DEFAULT_EMIT_OPENMP_FUNC(end_taskgroup)
+DEFAULT_EMIT_OPENMP_FUNC(register_lib)
+DEFAULT_EMIT_OPENMP_FUNC(target)
+DEFAULT_EMIT_OPENMP_FUNC(target_data_begin)
+DEFAULT_EMIT_OPENMP_FUNC(target_data_end)
+
+DEFAULT_EMIT_OPENMP_FUNC(threadprivate_register)
+DEFAULT_EMIT_OPENMP_FUNC(global_thread_num)
+
+// Special processing for __kmpc_copyprivate
+// DEFAULT_GET_OPENMP_FUNC(copyprivate)
+llvm::Constant *CGOpenMPRuntime::Get_copyprivate() {
+  llvm::LLVMContext &C = CGM.getLLVMContext();
+  llvm::Type *Params[] = { llvm::TypeBuilder<ident_t *, false>::get(C),
+      llvm::TypeBuilder<int32_t, false>::get(C), CGM.SizeTy, llvm::TypeBuilder<
+          void *, false>::get(C),
+      llvm::TypeBuilder<kmp_reduce_func, false>::get(C), llvm::TypeBuilder<
+          int32_t, false>::get(C) };
+
+  llvm::FunctionType *FT = llvm::FunctionType::get(
+      llvm::TypeBuilder<void, false>::get(C), Params, false);
+  return CGM.CreateRuntimeFunction(FT, "__kmpc_copyprivate");
+}
+// Special processing for __kmpc_reduce_nowait
+// DEFAULT_GET_OPENMP_FUNC(reduce_nowait)
+llvm::Constant *CGOpenMPRuntime::Get_reduce_nowait() {
+  llvm::LLVMContext &C = CGM.getLLVMContext();
+  llvm::Type *Params[] = { llvm::TypeBuilder<ident_t *, false>::get(C),
+      llvm::TypeBuilder<int32_t, false>::get(C), llvm::TypeBuilder<int32_t,
+          false>::get(C), CGM.SizeTy, llvm::TypeBuilder<void *, false>::get(C),
+      llvm::TypeBuilder<kmp_copy_func, false>::get(C), llvm::TypeBuilder<
+          kmp_critical_name *, false>::get(C) };
+
+  llvm::FunctionType *FT = llvm::FunctionType::get(
+      llvm::TypeBuilder<int32_t, false>::get(C), Params, false);
+  return CGM.CreateRuntimeFunction(FT, "__kmpc_reduce_nowait");
+}
+// Special processing for __kmpc_reduce
+// DEFAULT_GET_OPENMP_FUNC(reduce)
+llvm::Constant *CGOpenMPRuntime::Get_reduce() {
+  llvm::LLVMContext &C = CGM.getLLVMContext();
+  llvm::Type *Params[] = { llvm::TypeBuilder<ident_t *, false>::get(C),
+      llvm::TypeBuilder<int32_t, false>::get(C), llvm::TypeBuilder<int32_t,
+          false>::get(C), CGM.SizeTy, llvm::TypeBuilder<void *, false>::get(C),
+      llvm::TypeBuilder<kmp_copy_func, false>::get(C), llvm::TypeBuilder<
+          kmp_critical_name *, false>::get(C) };
+
+  llvm::FunctionType *FT = llvm::FunctionType::get(
+      llvm::TypeBuilder<int32_t, false>::get(C), Params, false);
+  return CGM.CreateRuntimeFunction(FT, "__kmpc_reduce");
+}
+// Special processing for __kmpc_omp_task_alloc
+// DEFAULT_GET_OPENMP_FUNC(omp_task_alloc)
+llvm::Constant *CGOpenMPRuntime::Get_omp_task_alloc() {
+  llvm::LLVMContext &C = CGM.getLLVMContext();
+  llvm::Type *Params[] = { llvm::TypeBuilder<ident_t *, false>::get(C),
+      llvm::TypeBuilder<int32_t, false>::get(C), llvm::TypeBuilder<int32_t,
+          false>::get(C), CGM.SizeTy, CGM.SizeTy, llvm::TypeBuilder<
+          kmp_routine_entry_t, false>::get(C) };
+
+  llvm::FunctionType *FT = llvm::FunctionType::get(
+      llvm::TypeBuilder<kmp_task_t *, false>::get(C), Params, false);
+  return CGM.CreateRuntimeFunction(FT, "__kmpc_omp_task_alloc");
+}
+llvm::Type *CGOpenMPRuntime::getKMPDependInfoType() {
+  llvm::Type *Ty = CGM.OpenMPSupport.getKMPDependInfoType();
+  if (Ty)
+    return Ty;
+  IdentifierInfo *II = &CGM.getContext().Idents.get("__kmp_depend_info_t");
+  DeclContext *DC = CGM.getContext().getTranslationUnitDecl();
+  RecordDecl *RD = RecordDecl::Create(CGM.getContext(), TTK_Struct, DC,
+      SourceLocation(), SourceLocation(), II);
+  RD->startDefinition();
+  DC->addHiddenDecl(RD);
+  II = &CGM.getContext().Idents.get("base_addr");
+  FieldDecl *FD = FieldDecl::Create(CGM.getContext(), RD, SourceLocation(),
+      SourceLocation(), II, CGM.getContext().getIntPtrType(),
+      CGM.getContext().getTrivialTypeSourceInfo(
+          CGM.getContext().getIntPtrType(), SourceLocation()), 0, false,
+      ICIS_NoInit);
+  FD->setAccess(AS_public);
+  RD->addDecl(FD);
+  II = &CGM.getContext().Idents.get("len");
+  FD = FieldDecl::Create(CGM.getContext(), RD, SourceLocation(),
+      SourceLocation(), II, CGM.getContext().getSizeType(),
+      CGM.getContext().getTrivialTypeSourceInfo(CGM.getContext().getSizeType(),
+          SourceLocation()), 0, false, ICIS_NoInit);
+  FD->setAccess(AS_public);
+  RD->addDecl(FD);
+  II = &CGM.getContext().Idents.get("flags");
+  FD = FieldDecl::Create(CGM.getContext(), RD, SourceLocation(),
+      SourceLocation(), II, CGM.getContext().BoolTy,
+      CGM.getContext().getTrivialTypeSourceInfo(CGM.getContext().BoolTy,
+          SourceLocation()), 0, false, ICIS_NoInit);
+  FD->setAccess(AS_public);
+  RD->addDecl(FD);
+  RD->completeDefinition();
+  QualType QTy = CGM.getContext().getRecordType(RD);
+  Ty = CGM.getTypes().ConvertTypeForMem(QTy);
+  CGM.OpenMPSupport.setKMPDependInfoType(Ty,
+      CGM.getContext().getTypeAlignInChars(QTy).getQuantity());
+  return Ty;
+}
+// Special processing for __kmpc_omp_task_with_deps
+// DEFAULT_GET_OPENMP_FUNC(omp_task_with_deps)
+llvm::Constant *CGOpenMPRuntime::Get_omp_task_with_deps() {
+  llvm::LLVMContext &C = CGM.getLLVMContext();
+  llvm::Type *Params[] = { llvm::TypeBuilder<ident_t *, false>::get(C),
+      llvm::TypeBuilder<int32_t, false>::get(C), llvm::TypeBuilder<kmp_task_t *,
+          false>::get(C), llvm::TypeBuilder<int32_t, false>::get(C),
+      getKMPDependInfoType()->getPointerTo(),
+      llvm::TypeBuilder<int32_t, false>::get(C),
+      getKMPDependInfoType()->getPointerTo() };
+
+  llvm::FunctionType *FT = llvm::FunctionType::get(
+      llvm::TypeBuilder<int32_t, false>::get(C), Params, false);
+  return CGM.CreateRuntimeFunction(FT, "__kmpc_omp_task_with_deps");
+}
+// Special processing for __kmpc_omp_wait_deps
+// DEFAULT_GET_OPENMP_FUNC(omp_wait_deps)
+llvm::Constant *CGOpenMPRuntime::Get_omp_wait_deps() {
+  llvm::LLVMContext &C = CGM.getLLVMContext();
+  llvm::Type *Params[] = { llvm::TypeBuilder<ident_t *, false>::get(C),
+      llvm::TypeBuilder<int32_t, false>::get(C), llvm::TypeBuilder<int32_t,
+          false>::get(C), getKMPDependInfoType()->getPointerTo(),
+      llvm::TypeBuilder<int32_t, false>::get(C),
+      getKMPDependInfoType()->getPointerTo() };
+
+  llvm::FunctionType *FT = llvm::FunctionType::get(
+      llvm::TypeBuilder<void, false>::get(C), Params, false);
+  return CGM.CreateRuntimeFunction(FT, "__kmpc_omp_wait_deps");
+}
+
+// Special processing for __kmpc_threadprivate_cached
+// DEFAULT_GET_OPENMP_FUNC(threadprivate_cached)
+llvm::Constant *CGOpenMPRuntime::Get_threadprivate_cached() {
+  llvm::LLVMContext &C = CGM.getLLVMContext();
+  llvm::Type *Params[] = { llvm::TypeBuilder<ident_t *, false>::get(C),
+      llvm::TypeBuilder<int32_t, false>::get(C),
+      llvm::TypeBuilder<void *, false>::get(C), CGM.SizeTy, llvm::TypeBuilder<
+          void ***, false>::get(C) };
+
+  llvm::FunctionType *FT = llvm::FunctionType::get(
+      llvm::TypeBuilder<void *, false>::get(C), Params, false);
+  return CGM.CreateRuntimeFunction(FT, "__kmpc_threadprivate_cached");
+}
+
+QualType CGOpenMPRuntime::GetAtomicType(CodeGenFunction &CGF, QualType QTy) {
+  if (!QTy->isArithmeticType())
+    return QualType();
+  if (QTy->isRealFloatingType())
+    return QTy->getCanonicalTypeUnqualified(); // CGF.ConvertTypeForMem(QTy->getCanonicalTypeUnqualified());
+  uint64_t TySize = CGF.getContext().getTypeSize(QTy);
+  if (CGF.getContext().getTypeSize(CGF.getContext().CharTy) == TySize)
+    return
+        QTy->isUnsignedIntegerOrEnumerationType() ?
+            CGF.getContext().UnsignedCharTy : CGF.getContext().SignedCharTy;
+  else if (CGF.getContext().getTypeSize(CGF.getContext().ShortTy) == TySize)
+    return
+        QTy->isUnsignedIntegerOrEnumerationType() ?
+            CGF.getContext().UnsignedShortTy : CGF.getContext().ShortTy;
+  else if (CGF.getContext().getTypeSize(CGF.getContext().IntTy) == TySize)
+    return
+        QTy->isUnsignedIntegerOrEnumerationType() ?
+            CGF.getContext().UnsignedIntTy : CGF.getContext().IntTy;
+  else if (CGF.getContext().getTypeSize(CGF.getContext().LongTy) == TySize)
+    return
+        QTy->isUnsignedIntegerOrEnumerationType() ?
+            CGF.getContext().UnsignedLongTy : CGF.getContext().LongTy;
+  else if (CGF.getContext().getTypeSize(CGF.getContext().LongLongTy) == TySize)
+    return
+        QTy->isUnsignedIntegerOrEnumerationType() ?
+            CGF.getContext().UnsignedLongLongTy : CGF.getContext().LongLongTy;
+  else if (CGF.getContext().getTypeSize(CGF.getContext().Int128Ty) == TySize)
+    return
+        QTy->isUnsignedIntegerOrEnumerationType() ?
+            CGF.getContext().UnsignedInt128Ty : CGF.getContext().Int128Ty;
+  return QualType();
+}
+
+llvm::Value *CGOpenMPRuntime::GetAtomicFuncGeneral(CodeGenFunction &CGF,
+    QualType QTyRes, QualType QTyIn, CGOpenMPRuntime::EAtomicOperation Aop,
+    bool Capture, bool Reverse) {
+  SmallString<40> Str;
+  llvm::raw_svector_ostream OS(Str);
+
+  if (QTyRes.isVolatileQualified() || QTyIn.isVolatileQualified())
+    return 0;
+
+  int64_t TySize =
+      CGF.CGM.GetTargetTypeStoreSize(CGF.ConvertTypeForMem(QTyRes)).getQuantity();
+  if (QTyRes->isRealFloatingType()) {
+    OS << "__kmpc_atomic_float";
+    if (TySize != 4 && TySize != 8 && TySize != 10 && TySize != 16)
+      return 0;
+  } else if (QTyRes->isScalarType()) {
+    OS << "__kmpc_atomic_fixed";
+    if (TySize != 1 && TySize != 2 && TySize != 4 && TySize != 8)
+      return 0;
+  } else
+    return 0;
+  OS << TySize;
+  switch (Aop) {
+  case OMP_Atomic_orl:
+    OS << "_orl";
+    break;
+  case OMP_Atomic_orb:
+    OS << "_orb";
+    break;
+  case OMP_Atomic_andl:
+    OS << "_andl";
+    break;
+  case OMP_Atomic_andb:
+    OS << "_andb";
+    break;
+  case OMP_Atomic_xor:
+    OS << "_xor";
+    break;
+  case OMP_Atomic_sub:
+    OS << "_sub";
+    break;
+  case OMP_Atomic_add:
+    OS << "_add";
+    break;
+  case OMP_Atomic_mul:
+    OS << "_mul";
+    break;
+  case OMP_Atomic_div:
+    if (QTyRes->hasUnsignedIntegerRepresentation() || QTyRes->isPointerType()) {
+      if (!CGF.getContext().hasSameType(QTyIn, QTyRes))
+        return 0;
+      OS << "u";
+    }
+    OS << "_div";
+    break;
+  case OMP_Atomic_min:
+    OS << "_min";
+    break;
+  case OMP_Atomic_max:
+    OS << "_max";
+    break;
+  case OMP_Atomic_shl:
+    OS << "_shl";
+    break;
+  case OMP_Atomic_shr:
+    if (QTyRes->hasUnsignedIntegerRepresentation() || QTyRes->isPointerType()) {
+      if (!CGF.getContext().hasSameType(QTyIn, QTyRes))
+        return 0;
+      OS << "u";
+    }
+    OS << "_shr";
+    break;
+  case OMP_Atomic_wr:
+    OS << "_wr";
+    break;
+  case OMP_Atomic_rd:
+    OS << "_rd";
+    break;
+  case OMP_Atomic_assign:
+    return 0;
+  case OMP_Atomic_invalid:
+  default:
+    llvm_unreachable("Unknown atomic operation.");
+  }
+  if (Capture) {
+    OS << "_cpt";
+    if (!CGF.getContext().hasSameType(QTyIn, QTyRes))
+      return 0;
+  }
+  if (Reverse
+      && (Aop == OMP_Atomic_sub || Aop == OMP_Atomic_div
+          || Aop == OMP_Atomic_shr || Aop == OMP_Atomic_shl)) {
+    OS << "_rev";
+    if (!CGF.getContext().hasSameType(QTyIn, QTyRes))
+      return 0;
+  }
+  int64_t TyInSize = CGF.CGM.GetTargetTypeStoreSize(
+      CGF.ConvertTypeForMem(QTyIn)).getQuantity();
+  if (!CGF.getContext().hasSameType(QTyIn, QTyRes)) {
+    if (QTyRes->isScalarType() && QTyIn->isRealFloatingType() && TyInSize == 8)
+      OS << "_float8";
+    else
+      return 0;
+  }
+  SmallVector<llvm::Type *, 5> Params;
+  Params.push_back(
+      llvm::TypeBuilder<ident_t, false>::get(CGF.CGM.getLLVMContext())->getPointerTo());
+  Params.push_back(CGF.Int32Ty);
+  llvm::Type *Ty = CGF.ConvertTypeForMem(GetAtomicType(CGF, QTyRes));
+  Params.push_back(Ty->getPointerTo());
+  if (Aop != OMP_Atomic_rd)
+    Params.push_back(CGF.ConvertTypeForMem(GetAtomicType(CGF, QTyIn)));
+  if (Capture) {
+    Params.push_back(CGF.Int32Ty);
+  }
+  llvm::Type *RetTy = CGF.VoidTy;
+  if (Capture || Aop == OMP_Atomic_rd)
+    RetTy = Ty;
+  llvm::FunctionType *FunTy = llvm::FunctionType::get(RetTy, Params, false);
+  return CGF.CGM.CreateRuntimeFunction(FunTy, OS.str());
+}
+
+llvm::Value *CGOpenMPRuntime::GetAtomicFunc(CodeGenFunction &CGF, QualType QTy,
+    OpenMPReductionClauseOperator Op) {
+
+  if (QTy.isVolatileQualified())
+    return 0;
+
+  EAtomicOperation Aop = OMP_Atomic_invalid;
+  switch (Op) {
+  case OMPC_REDUCTION_or:
+    Aop = OMP_Atomic_orl;
+    break;
+  case OMPC_REDUCTION_bitor:
+    Aop = OMP_Atomic_orb;
+    break;
+  case OMPC_REDUCTION_and:
+    Aop = OMP_Atomic_andl;
+    break;
+  case OMPC_REDUCTION_bitand:
+    Aop = OMP_Atomic_andb;
+    break;
+  case OMPC_REDUCTION_bitxor:
+    Aop = OMP_Atomic_xor;
+    break;
+  case OMPC_REDUCTION_sub:
+    Aop = OMP_Atomic_add;
+    break;
+  case OMPC_REDUCTION_add:
+    Aop = OMP_Atomic_add;
+    break;
+  case OMPC_REDUCTION_mult:
+    Aop = OMP_Atomic_mul;
+    break;
+  case OMPC_REDUCTION_min:
+    Aop = OMP_Atomic_min;
+    break;
+  case OMPC_REDUCTION_max:
+    Aop = OMP_Atomic_max;
+    break;
+  case OMPC_REDUCTION_custom:
+    return 0;
+  case OMPC_REDUCTION_unknown:
+  case NUM_OPENMP_REDUCTION_OPERATORS:
+    llvm_unreachable("Unknown reduction operation.");
+  }
+  return GetAtomicFuncGeneral(CGF, QTy, QTy, Aop, false, false);
+}
+
+void CGOpenMPRuntime::PostProcessTargetFunction(const Decl *D,
+                                        llvm::Function *F,
+                                        const CGFunctionInfo &FI){
+  CGM.SetInternalFunctionAttributes(D, F, FI);
+
+}
+
+static llvm::Value *GEP(CGBuilderTy &B, llvm::Value *Base, int field) {
+  return B.CreateConstInBoundsGEP2_32(Base, 0, field);
+}
+
+static void StoreField(CGBuilderTy &B, llvm::Value *Val, llvm::Value *Dst,
+    int field) {
+  B.CreateStore(Val, GEP(B, Dst, field));
+}
+
+llvm::Value *CGOpenMPRuntime::CreateIntelOpenMPRTLLoc(SourceLocation Loc,
+    CodeGenFunction &CGF, unsigned Flags) {
+  llvm::Value *Tmp;
+  // ident_t tmp;
+  llvm::AllocaInst *AI = 0;
+  llvm::BasicBlock &EntryBB = CGF.CurFn->getEntryBlock();
+  std::string VarName = ".__kmpc_ident_t." + llvm::utostr(Flags) + ".";
+  std::string DefaultLoc = ".omp.default.loc.";
+  std::string DefaultConstName = DefaultLoc + llvm::utostr(Flags) + ".";
+  llvm::Value *DefaultString;
+  if (!(DefaultString = CGM.getModule().getNamedValue(DefaultLoc))) {
+    DefaultString = CGF.Builder.CreateGlobalString(";unknown;unknown;0;0;;",
+        DefaultLoc);
+  }
+  for (llvm::BasicBlock::iterator I = EntryBB.begin(), E = EntryBB.end();
+      I != E; ++I)
+    if (I->getName().startswith(VarName)) {
+      AI = cast<llvm::AllocaInst>(I);
+      break;
+    }
+  if (!AI) {
+    llvm::StructType *StTy = llvm::IdentTBuilder::get(CGM.getLLVMContext());
+    AI = CGF.CreateTempAlloca(StTy, VarName);
+    AI->setAlignment(CGM.PointerAlignInBytes);
+    CGBuilderTy::InsertPoint SavedIP = CGF.Builder.saveIP();
+    assert(SavedIP.isSet() && "No insertion point is set!");
+    CGF.Builder.SetInsertPoint(CGF.AllocaInsertPt);
+    llvm::Value *DefaultVal;
+    if (!(DefaultVal = CGM.getModule().getNamedValue(DefaultConstName))) {
+      llvm::Constant *Zero = CGF.Builder.getInt32(0);
+      llvm::Value *Args[] = { Zero, Zero };
+      llvm::Constant *Values[] = { Zero, CGF.Builder.getInt32(Flags), Zero,
+          Zero, cast<llvm::Constant>(
+              CGF.Builder.CreateInBoundsGEP(DefaultString, Args)) };
+      llvm::Constant *Init = llvm::ConstantStruct::get(StTy,
+          llvm::makeArrayRef(Values));
+      llvm::GlobalVariable *ConstVar = new llvm::GlobalVariable(CGM.getModule(),
+          StTy, true, llvm::GlobalValue::PrivateLinkage, Init,
+          DefaultConstName);
+      ConstVar->setUnnamedAddr(true);
+      DefaultVal = ConstVar;
+    }
+    CGF.Builder.CreateMemCpy(AI, DefaultVal,
+        llvm::ConstantExpr::getSizeOf(StTy), CGM.PointerAlignInBytes);
+    CGF.Builder.restoreIP(SavedIP);
+  }
+  Tmp = AI;
+  if (CGM.getCodeGenOpts().getDebugInfo() != CodeGenOptions::NoDebugInfo
+      && Loc.isValid()) {
+    PresumedLoc PLoc = CGM.getContext().getSourceManager().getPresumedLoc(Loc);
+    std::string Res = ";";
+    Res += PLoc.getFilename();
+    Res += ";";
+    if (const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(
+        CGF.CurFuncDecl)) {
+      Res += FD->getQualifiedNameAsString();
+    }
+    Res += ";";
+    Res += llvm::utostr(PLoc.getLine()) + ";" + llvm::utostr(PLoc.getColumn())
+        + ";;";
+    // tmp.psource = ";file;func;line;col;;";
+    StoreField(CGF.Builder, CGF.Builder.CreateGlobalStringPtr(Res), Tmp,
+        llvm::IdentTBuilder::psource);
+  } else if (CGM.getCodeGenOpts().getDebugInfo()
+      != CodeGenOptions::NoDebugInfo) {
+    llvm::Value *Zero = CGF.Builder.getInt32(0);
+    llvm::Value *Args[] = { Zero, Zero };
+    StoreField(CGF.Builder, CGF.Builder.CreateInBoundsGEP(DefaultString, Args),
+        Tmp, llvm::IdentTBuilder::psource);
+  }
+  return Tmp;
+}
+
+llvm::Value *CGOpenMPRuntime::CreateOpenMPGlobalThreadNum(SourceLocation Loc,
+    CodeGenFunction &CGF) {
+  llvm::BasicBlock &EntryBB = CGF.CurFn->getEntryBlock();
+  for (llvm::BasicBlock::iterator I = EntryBB.begin(), E = EntryBB.end();
+      I != E; ++I)
+    if (I->getName().startswith(".__kmpc_global_thread_num."))
+      return CGF.Builder.CreateLoad(I, ".gtid.");
+  llvm::AllocaInst *AI = CGF.CreateTempAlloca(CGM.Int32Ty,
+      ".__kmpc_global_thread_num.");
+  AI->setAlignment(4);
+  CGBuilderTy::InsertPoint SavedIP = CGF.Builder.saveIP();
+  assert(SavedIP.isSet() && "No insertion point is set!");
+  CGF.Builder.SetInsertPoint(CGF.AllocaInsertPt);
+  llvm::Value *IdentT = CreateIntelOpenMPRTLLoc(Loc, CGF);
+  llvm::Value *Res = CGF.EmitRuntimeCall(OPENMPRTL_FUNC(global_thread_num),
+      llvm::makeArrayRef<llvm::Value *>(&IdentT, 1));
+  CGF.Builder.CreateStore(Res, AI);
+  CGF.Builder.restoreIP(SavedIP);
+  return CGF.Builder.CreateLoad(AI, ".gtid.");
+}
+
+llvm::Value *CGOpenMPRuntime::CreateOpenMPThreadPrivateCached(const VarDecl *VD,
+    SourceLocation Loc, CodeGenFunction &CGF, bool NoCast) {
+  if (CGM.OpenMPSupport.hasThreadPrivateVar(VD)) {
+    llvm::Type *VDTy = CGM.getTypes().ConvertTypeForMem(VD->getType());
+    llvm::PointerType *PTy = llvm::PointerType::get(VDTy,
+        CGM.getContext().getTargetAddressSpace(VD->getType()));
+    CharUnits SZ = CGM.GetTargetTypeStoreSize(VDTy);
+    std::string VarCache = CGM.getMangledName(VD).str() + ".cache.";
+
+    llvm::Value *Args[] = { CreateIntelOpenMPRTLLoc(Loc, CGF),
+        CreateOpenMPGlobalThreadNum(Loc, CGF), CGF.Builder.CreateBitCast(
+            VD->isStaticLocal() ?
+                CGM.getStaticLocalDeclAddress(VD) : CGM.GetAddrOfGlobal(VD),
+            CGM.Int8PtrTy), llvm::ConstantInt::get(CGF.SizeTy,
+            SZ.getQuantity()), CGM.getModule().getNamedValue(VarCache) };
+    llvm::Value *Call = CGF.EmitRuntimeCall(
+        OPENMPRTL_FUNC(threadprivate_cached), Args);
+    if (NoCast)
+      return Call;
+    return CGF.Builder.CreateBitCast(Call, PTy);
+  }
+  return 0;
+}
+
+/// Remove dashes and other strange characters from the target triple
+/// as they may cause some problems for the external symbols
+static std::string LegalizeTripleString(llvm::Triple TargetTriple) {
+
+  const std::string &TS = TargetTriple.getTriple();
+  std::string S;
+  llvm::raw_string_ostream OS(S);
+
+  for (unsigned i = 0; i < TS.size(); ++i) {
+    unsigned char c = (unsigned char) TS[i];
+
+    if (c >= 'a' && c <= 'z') {
+      OS << c;
+      continue;
+    }
+    if (c >= 'A' && c <= 'Z') {
+      OS << c;
+      continue;
+    }
+    if (c >= '0' && c <= '9') {
+      OS << c;
+      continue;
+    }
+    if (c == '_' || c == '-') {
+      OS << '_';
+      continue;
+    }
+
+    OS << llvm::format("%02x", (unsigned) c);
+  }
+
+  return OS.str();
+}
+
+///===---------------
+///
+/// NVPTX OpenMP Runtime Implementation
+///
+///===---------------
+
+/// Target specific runtime hacks
+class CGOpenMPRuntime_NVPTX: public CGOpenMPRuntime {
+
+  StringRef ArchName;
+
+  llvm::Function * Get_num_teams() {
+    return llvm::Intrinsic::getDeclaration(&CGM.getModule(),
+        llvm::Intrinsic::nvvm_read_ptx_sreg_nctaid_x);
+  }
+  llvm::Function * Get_team_num() {
+    return llvm::Intrinsic::getDeclaration(&CGM.getModule(),
+        llvm::Intrinsic::nvvm_read_ptx_sreg_ctaid_x);
+  }
+  llvm::Function * Get_num_threads() {
+    return llvm::Intrinsic::getDeclaration(&CGM.getModule(),
+        llvm::Intrinsic::nvvm_read_ptx_sreg_ntid_x);
+  }
+  llvm::Function * Get_thread_num() {
+    return llvm::Intrinsic::getDeclaration(&CGM.getModule(),
+        llvm::Intrinsic::nvvm_read_ptx_sreg_tid_x);
+  }
+
+public:
+  CGOpenMPRuntime_NVPTX(CodeGenModule &CGM) :
+      CGOpenMPRuntime(CGM), ArchName(CGM.getTarget().getTriple().getArchName()) {
+  }
+
+  /// Implement some target dependent transformation for the target region
+  /// outlined function
+  ///
+  virtual void PostProcessTargetFunction(const Decl *D,
+                                          llvm::Function *F,
+                                          const CGFunctionInfo &FI){
+
+    CGOpenMPRuntime::PostProcessTargetFunction(D, F, FI);
+
+    // No further post processing required if we are not in target mode
+    if (!CGM.getLangOpts().OpenMPTargetMode)
+      return;
+
+    llvm::Module &M = CGM.getModule();
+    llvm::LLVMContext &C = M.getContext();
+
+    // Get "nvvm.annotations" metadata node
+    llvm::NamedMDNode *MD = M.getOrInsertNamedMetadata("nvvm.annotations");
+
+    // Create !{<func-ref>, metadata !"kernel", i32 1} node
+    llvm::SmallVector<llvm::Value *, 3> MDVals;
+    MDVals.push_back(F);
+    MDVals.push_back(llvm::MDString::get(C, "kernel"));
+    MDVals.push_back(llvm::ConstantInt::get(llvm::Type::getInt32Ty(C), 1));
+
+    // Append metadata to nvvm.annotations
+    MD->addOperand(llvm::MDNode::get(C, MDVals));
+
+  }
+
+  virtual llvm::Value *CreateIntelOpenMPRTLLoc(SourceLocation Loc,
+      CodeGenFunction &CGF, unsigned Flags) {
+    //The Loc struct is not used by the target therefore we do not perfrom
+    //any initialization
+    return CGF.Builder.CreateAlloca(
+        llvm::IdentTBuilder::get(CGM.getLLVMContext()), CGF.Builder.getInt32(1));
+  }
+
+  virtual llvm::Value *CreateOpenMPGlobalThreadNum(SourceLocation Loc,
+      CodeGenFunction &CGF) {
+
+    //FIXME: Not sure this is what we want, I am computing global thread ID
+    //as blockID*BlockSize * threadID
+
+    llvm::Value *BId = CGF.Builder.CreateCall(Get_team_num(), "blockid");
+    llvm::Value *BSz = CGF.Builder.CreateCall(Get_num_threads(), "blocksize");
+    llvm::Value *TId = CGF.Builder.CreateCall(Get_thread_num(), "threadid");
+
+    return CGF.Builder.CreateAdd(CGF.Builder.CreateMul(BId, BSz), TId, "gid");
+  }
+
+  // Insert the overload of the default kmpc calls' implementation here, e.g.:
+  //
+  // TARGET_EMIT_OPENMP_FUNC(
+  //    <name of the kmpc call> ,
+  //    <body of the function generation - Fn is the current function and Bld
+  //    is the builder for the the entry basic block>
+};
+
+///===---------------
+///
+/// Generate target regions descriptor
+///
+///===---------------
+
+/// Return a pointer to the device image begin.
+///
+llvm::Constant* CGOpenMPRuntime::GetDeviceImageBeginPointer(
+                                                    llvm::Triple TargetTriple){
+  return new llvm::GlobalVariable(
+          CGM.getModule(),
+          CGM.Int8Ty,
+          true,
+          llvm::GlobalValue::ExternalLinkage,
+          0,
+          Twine("__omptgt__img_start_")
+          + Twine(LegalizeTripleString(TargetTriple)));
+}
+
+/// Return a pointer to the device image end.
+///
+llvm::Constant* CGOpenMPRuntime::GetDeviceImageEndPointer(
+                                                    llvm::Triple TargetTriple){
+  return new llvm::GlobalVariable(
+          CGM.getModule(),
+          CGM.Int8Ty,
+          true,
+          llvm::GlobalValue::ExternalLinkage,
+          0,
+          Twine("__omptgt__img_end_")
+          + Twine(LegalizeTripleString(TargetTriple)));
+}
+
+/// Return a string with the mangled name of a target region for the given module
+/// and target region index
+///
+std::string CGOpenMPRuntime::GetOffloadEntryMangledName(
+    llvm::Triple TargetTriple) {
+
+  std::string S;
+  llvm::raw_string_ostream OS(S);
+
+  // append the module unique region index
+  OS << "__omptgt__"
+     << NumTargetRegions << '_'
+     << CGM.getLangOpts().OMPModuleUniqueID << '_';
+
+  // if we are in target mode append the target triple to the mangled name
+  if (!TargetTriple.getTriple().empty())
+    OS << LegalizeTripleString(TargetTriple);
+
+  return OS.str();
+}
+
+/// Return the target regions descriptor or a create a new
+/// one if if does not exist
+///
+llvm::Constant* CGOpenMPRuntime::GetTargetRegionsDescriptor(){
+
+  // If we created the target regions descriptor before, just return it
+  if (TargetRegionsDescriptor)
+    return TargetRegionsDescriptor;
+
+  assert(!CGM.getLangOpts().OpenMPTargetMode
+      && "Generating offload descriptor for target code??");
+
+  llvm::LLVMContext &C = CGM.getModule().getContext();
+  llvm::Module &M = CGM.getModule();
+
+  //Get list of devices we care about
+  const std::vector<llvm::Triple> &Devices = CGM.getLangOpts().OMPTargetTriples;
+
+  assert(Devices.size()
+      && "No devices specified while running in target mode??");
+
+  //Type of target regions descriptor
+  llvm::StructType *DescTy = llvm::TypeBuilder<__tgt_bin_desc, true>::get(C);
+  //Type of device image
+  llvm::StructType *DevTy = llvm::TypeBuilder<__tgt_device_image, true>::get(C);
+  //Type of offload entry
+  llvm::StructType *EntryTy = llvm::TypeBuilder<__tgt_offload_entry, true>::get(C);
+
+  //No devices: return a null pointer
+  if (Devices.empty())
+    return llvm::ConstantExpr::getBitCast(
+        llvm::Constant::getNullValue(llvm::Type::getInt8PtrTy(C)),
+        DescTy->getPointerTo());
+
+  //Create all device images
+  llvm::SmallVector<llvm::Constant*,4> DeviceImagesEntires;
+
+  for (unsigned i=0; i<Devices.size(); ++i){
+    llvm::Constant *Dev = llvm::ConstantStruct::get(DevTy,
+        CGM.getOpenMPRuntime().GetDeviceImageBeginPointer(Devices[i]),
+        CGM.getOpenMPRuntime().GetDeviceImageEndPointer(Devices[i]),NULL);
+    DeviceImagesEntires.push_back(Dev);
+  }
+
+  //Create device images global array
+  llvm::ArrayType *DeviceImagesInitTy =
+      llvm::ArrayType::get(DevTy,DeviceImagesEntires.size());
+  llvm::Constant *DeviceImagesInit = llvm::ConstantArray::get(
+      DeviceImagesInitTy,DeviceImagesEntires);
+
+  llvm::GlobalVariable *DeviceImages = new llvm::GlobalVariable(
+      M,
+      DeviceImagesInitTy,
+      true,
+      llvm::GlobalValue::InternalLinkage,
+      DeviceImagesInit,
+      "__omptgt__device_images");
+
+  //Create the external vars that will point to the begin and end of the
+  //host entries section.
+  //
+  // FIXME: The names of these globals need to be consistent with the linker.
+  // Maybe make the runtime class to return these strings
+
+  llvm::GlobalVariable *HostEntriesBegin = new llvm::GlobalVariable(
+      M, EntryTy, true, llvm::GlobalValue::ExternalLinkage, 0,
+      "__omptgt__host_entries_begin");
+  llvm::GlobalVariable *HostEntriesEnd = new llvm::GlobalVariable(
+      M, EntryTy, true, llvm::GlobalValue::ExternalLinkage, 0,
+      "__omptgt__host_entries_end");
+
+  //This is a Zero array to be used in the creation of the constant expressions
+  llvm::Constant *Index[] = { llvm::Constant::getNullValue(CGM.Int32Ty),
+                              llvm::Constant::getNullValue(CGM.Int32Ty)};
+
+  //Create the target region descriptor:
+  // - number of devices
+  // - pointer to the devices array
+  // - begin of host entries point
+  // - end of host entries point
+  llvm::Constant *TargetRegionsDescriptorInit = llvm::ConstantStruct::get(
+      DescTy,
+      llvm::ConstantInt::get(CGM.Int32Ty, Devices.size()),
+      llvm::ConstantExpr::getGetElementPtr(DeviceImages,Index),
+      HostEntriesBegin, HostEntriesEnd, NULL);
+
+  TargetRegionsDescriptor = new llvm::GlobalVariable(
+        M,
+        DescTy,
+        true,
+        llvm::GlobalValue::InternalLinkage,
+        TargetRegionsDescriptorInit,
+        "__omptgt__target_regions_descriptor");
+
+  return TargetRegionsDescriptor;
+
+}
+
+/// Return host pointer for the current target regions. This creates
+/// the offload entry for the target region.
+///
+llvm::Constant* CGOpenMPRuntime::GetHostPtrForCurrentTargetRegion(){
+
+  llvm::LLVMContext &C = CGM.getModule().getContext();
+  llvm::Module &M = CGM.getModule();
+
+  // Create the unique host pointer for a target region. We do not use the
+  // outlined function address so that it can be inlined by the optimizer if
+  // appropriate.
+  // In the offloading scheme, the content being pointed by this pointer is not
+  // relevant. Nevertheless, we fill this content with a string that
+  // correspond to the entries' name. This information can be
+  // useful for some targets to expedite the runtime look-up of the entries
+  // in the target image. In order to use this information the target OpenMP
+  // codegen class should encode the host entries in his image.
+
+  llvm::Constant *HostPtrInit = llvm::ConstantDataArray::getString(C,
+                                    GetOffloadEntryMangledName(llvm::Triple()));
+
+  llvm::Constant *HostPtrStr = new llvm::GlobalVariable(
+      M,
+      HostPtrInit->getType(),
+      true,
+      llvm::GlobalValue::InternalLinkage,
+      HostPtrInit,
+      Twine("__omptgt__host_ptr_") + Twine(NumTargetRegions) );
+
+  llvm::Constant *HostPtr = llvm::ConstantExpr::getBitCast(HostPtrStr,
+                                                           CGM.VoidPtrTy);
+
+  // Create the entry struct
+  // - pointer
+  // - size - we assume size zero for functions
+
+  // Type of the entry
+  llvm::StructType *EntryTy = llvm::TypeBuilder<__tgt_offload_entry, true>::get(C);
+
+  llvm::Constant *EntryInit = llvm::ConstantStruct::get(EntryTy, HostPtr,
+          llvm::ConstantInt::get(CGM.Int32Ty, 0), NULL);
+
+  llvm::GlobalVariable *Entry = new llvm::GlobalVariable(
+      M,
+      EntryTy,
+      true,
+      llvm::GlobalValue::ExternalLinkage,
+      EntryInit,
+      Twine(GetOffloadEntryMangledName(llvm::Triple())) + Twine("_hst_entry"));
+
+  // The entry has to be created in the section the linker expects it to be
+  Entry->setSection(".openmptgt_host_entries");
+
+  return HostPtr;
+}
+
+///===---------------
+///
+/// Create runtime for the target used in the Module
+///
+///===---------------
+
+CGOpenMPRuntime *CodeGen::CreateOpenMPRuntime(CodeGenModule &CGM) {
+
+  switch (CGM.getTarget().getTriple().getArch()) {
+  default:
+    return new CGOpenMPRuntime(CGM);
+  case llvm::Triple::nvptx:
+  case llvm::Triple::nvptx64:
+    return new CGOpenMPRuntime_NVPTX(CGM);
+  }
+
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGOpenMPRuntime.h cfe-3.5.0.src.omp/lib/CodeGen/CGOpenMPRuntime.h
--- cfe-3.5.0.src/lib/CodeGen/CGOpenMPRuntime.h	2014-06-18 03:08:49.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGOpenMPRuntime.h	2014-11-28 10:49:29.000000000 -0500
@@ -1,4 +1,4 @@
-//===----- CGOpenMPRuntime.h - Interface to OpenMP Runtimes -----*- C++ -*-===//
+//===---- CGOpenMPRuntime.h - Interface to OpenMP Runtimes ------*- C++ -*-===//
 //
 //                     The LLVM Compiler Infrastructure
 //
@@ -7,7 +7,9 @@
 //
 //===----------------------------------------------------------------------===//
 //
-// This provides a class for OpenMP runtime code generation.
+// This provides an abstract class for OpenMP code generation.  Concrete
+// subclasses of this implement code generation for specific OpenMP
+// runtime libraries.
 //
 //===----------------------------------------------------------------------===//
 
@@ -18,6 +20,8 @@
 #include "llvm/ADT/DenseMap.h"
 #include "llvm/IR/Type.h"
 #include "llvm/IR/Value.h"
+#include "CodeGenModule.h"
+#include "CodeGenFunction.h"
 
 namespace llvm {
 class AllocaInst;
@@ -34,12 +38,15 @@
 } // namespace llvm
 
 namespace clang {
-
 namespace CodeGen {
 
 class CodeGenFunction;
 class CodeGenModule;
 
+#define DEFAULT_EMIT_OPENMP_DECL(name)       \
+  virtual llvm::Constant* Get_##name();
+
+/// Implements runtime-specific code generation functions.
 class CGOpenMPRuntime {
 public:
   /// \brief Values for bit flags used in the ident_t to describe the fields.
@@ -71,8 +78,9 @@
     OMPRTL__kmpc_global_thread_num
   };
 
-private:
+protected:
   CodeGenModule &CGM;
+
   /// \brief Default const ident_t object used for initialization of all other
   /// ident_t objects.
   llvm::Constant *DefaultOpenMPPSource;
@@ -135,9 +143,62 @@
   typedef llvm::DenseMap<llvm::Function *, llvm::Value *> OpenMPGtidMapTy;
   OpenMPGtidMapTy OpenMPGtidMap;
 
+  // Number of target regions processed so far
+  unsigned NumTargetRegions;
+
+  // Set of all functions that register target libraries
+  llvm::SmallSet<const llvm::Function*, 32> FunctionsWithTargetRegistry;
+
+  // Target regions descriptor for the current compilation unit
+  llvm::Constant *TargetRegionsDescriptor;
+
 public:
+
+  // Returns the number of target regions processed so far
+  unsigned getNumOfProcessedTargetRegions(){ return NumTargetRegions; }
+
+  // Incremented number of processed target regions
+  void incNumOfProcessedTargetRegions(){ ++NumTargetRegions; }
+
+  // Get and Incremented number of processed target regions
+  unsigned getAndIncNumOfProcessedTargetRegions(){ return NumTargetRegions++; }
+
+  // Mark function as using target registry
+  void setFunctionRegisterTarget(const llvm::Function *F){
+    FunctionsWithTargetRegistry.insert(F);
+  }
+
+  // Return true if the function registers a target
+  bool getFunctionRegisterTarget(const llvm::Function *F){
+    return FunctionsWithTargetRegistry.count(F);
+  }
+
+
+  enum EAtomicOperation {
+    OMP_Atomic_add,
+    OMP_Atomic_sub,
+    OMP_Atomic_mul,
+    OMP_Atomic_div,
+    OMP_Atomic_andb,
+    OMP_Atomic_shl,
+    OMP_Atomic_shr,
+    OMP_Atomic_orb,
+    OMP_Atomic_xor,
+    OMP_Atomic_andl,
+    OMP_Atomic_orl,
+    OMP_Atomic_max,
+    OMP_Atomic_min,
+    OMP_Atomic_eqv,
+    OMP_Atomic_neqv,
+    OMP_Atomic_rd,
+    OMP_Atomic_wr,
+    OMP_Atomic_swp,
+    OMP_Atomic_assign,
+    OMP_Atomic_invalid
+  };
+  
   explicit CGOpenMPRuntime(CodeGenModule &CGM);
-  ~CGOpenMPRuntime() {}
+  virtual ~CGOpenMPRuntime() {}
 
   /// \brief Cleans up references to the objects in finished function.
   /// \param CGF Reference to finished CodeGenFunction.
@@ -170,7 +231,144 @@
   /// \param Function OpenMP runtime function.
   /// \return Specified function.
   llvm::Constant *CreateRuntimeFunction(OpenMPRTLFunction Function);
+
+  DEFAULT_EMIT_OPENMP_DECL(fork_call)
+  DEFAULT_EMIT_OPENMP_DECL(push_num_threads)
+  DEFAULT_EMIT_OPENMP_DECL(push_proc_bind)
+  DEFAULT_EMIT_OPENMP_DECL(fork_teams)
+  DEFAULT_EMIT_OPENMP_DECL(push_num_teams)
+  DEFAULT_EMIT_OPENMP_DECL(cancel_barrier)
+  DEFAULT_EMIT_OPENMP_DECL(barrier)
+  DEFAULT_EMIT_OPENMP_DECL(cancellationpoint)
+  DEFAULT_EMIT_OPENMP_DECL(cancel)
+  DEFAULT_EMIT_OPENMP_DECL(omp_taskyield)
+  DEFAULT_EMIT_OPENMP_DECL(omp_taskwait)
+  DEFAULT_EMIT_OPENMP_DECL(flush)
+  DEFAULT_EMIT_OPENMP_DECL(master)
+  DEFAULT_EMIT_OPENMP_DECL(end_master)
+  DEFAULT_EMIT_OPENMP_DECL(single)
+  DEFAULT_EMIT_OPENMP_DECL(end_single)
+  DEFAULT_EMIT_OPENMP_DECL(critical)
+  DEFAULT_EMIT_OPENMP_DECL(end_critical)
+  DEFAULT_EMIT_OPENMP_DECL(ordered)
+  DEFAULT_EMIT_OPENMP_DECL(end_ordered)
+  DEFAULT_EMIT_OPENMP_DECL(end_reduce_nowait)
+  DEFAULT_EMIT_OPENMP_DECL(end_reduce)
+  DEFAULT_EMIT_OPENMP_DECL(atomic_start)
+  DEFAULT_EMIT_OPENMP_DECL(atomic_end)
+  DEFAULT_EMIT_OPENMP_DECL(dispatch_init_4)
+  DEFAULT_EMIT_OPENMP_DECL(dispatch_init_4u)
+  DEFAULT_EMIT_OPENMP_DECL(dispatch_init_8)
+  DEFAULT_EMIT_OPENMP_DECL(dispatch_init_8u)
+  DEFAULT_EMIT_OPENMP_DECL(dispatch_next_4)
+  DEFAULT_EMIT_OPENMP_DECL(dispatch_next_4u)
+  DEFAULT_EMIT_OPENMP_DECL(dispatch_next_8)
+  DEFAULT_EMIT_OPENMP_DECL(dispatch_next_8u)
+  DEFAULT_EMIT_OPENMP_DECL(dispatch_fini_4)
+  DEFAULT_EMIT_OPENMP_DECL(dispatch_fini_4u)
+  DEFAULT_EMIT_OPENMP_DECL(dispatch_fini_8)
+  DEFAULT_EMIT_OPENMP_DECL(dispatch_fini_8u)
+  DEFAULT_EMIT_OPENMP_DECL(for_static_init_4)
+  DEFAULT_EMIT_OPENMP_DECL(for_static_init_4u)
+  DEFAULT_EMIT_OPENMP_DECL(for_static_init_8)
+  DEFAULT_EMIT_OPENMP_DECL(for_static_init_8u)
+  DEFAULT_EMIT_OPENMP_DECL(for_static_fini)
+  DEFAULT_EMIT_OPENMP_DECL(omp_task_begin_if0)
+  DEFAULT_EMIT_OPENMP_DECL(omp_task_complete_if0)
+  DEFAULT_EMIT_OPENMP_DECL(omp_task_parts)
+  DEFAULT_EMIT_OPENMP_DECL(taskgroup)
+  DEFAULT_EMIT_OPENMP_DECL(end_taskgroup)
+  DEFAULT_EMIT_OPENMP_DECL(register_lib)
+  DEFAULT_EMIT_OPENMP_DECL(target)
+  DEFAULT_EMIT_OPENMP_DECL(target_data_begin)
+  DEFAULT_EMIT_OPENMP_DECL(target_data_end)
+
+  DEFAULT_EMIT_OPENMP_DECL(threadprivate_register)
+  DEFAULT_EMIT_OPENMP_DECL(global_thread_num)
+
+  virtual llvm::Type *getKMPDependInfoType();
+
+  // Special processing for __kmpc_copyprivate
+  // DEFAULT_GET_OPENMP_FUNC(copyprivate)
+  virtual llvm::Constant *Get_copyprivate();
+  // Special processing for __kmpc_reduce_nowait
+  // DEFAULT_GET_OPENMP_FUNC(reduce_nowait)
+  virtual llvm::Constant * Get_reduce_nowait();
+  // Special processing for __kmpc_reduce
+  // DEFAULT_GET_OPENMP_FUNC(reduce)
+  virtual llvm::Constant *Get_reduce();
+  // Special processing for __kmpc_omp_task_alloc
+  // DEFAULT_GET_OPENMP_FUNC(omp_task_alloc)
+  virtual llvm::Constant * Get_omp_task_alloc();
+  // Special processing for __kmpc_omp_task_with_deps
+  // DEFAULT_GET_OPENMP_FUNC(omp_task_with_deps)
+  virtual llvm::Constant * Get_omp_task_with_deps();
+  // Special processing for __kmpc_omp_wait_deps
+  // DEFAULT_GET_OPENMP_FUNC(omp_wait_deps)
+  virtual llvm::Constant * Get_omp_wait_deps();
+
+  // Special processing for __kmpc_threadprivate_cached
+  // DEFAULT_GET_OPENMP_FUNC(threadprivate_cached)
+  virtual llvm::Constant *  Get_threadprivate_cached();
+
+
+  virtual QualType GetAtomicType(CodeGenFunction &CGF, QualType QTy);
+  virtual llvm::Value *GetAtomicFuncGeneral(CodeGenFunction &CGF, QualType QTyRes,
+                                           QualType QTyIn, EAtomicOperation Aop,
+                                           bool Capture, bool Reverse);
+  virtual llvm::Value *GetAtomicFunc(CodeGenFunction &CGF, QualType QTy,
+      OpenMPReductionClauseOperator Op);
+
+
+  /// Implement some target dependent transformation for the target region
+  /// outlined function
+  ///
+  virtual void PostProcessTargetFunction(const Decl *D,
+                                          llvm::Function *F,
+                                          const CGFunctionInfo &FI);
+
+  /// \brief Creates a structure with the location info for Intel OpenMP RTL.
+  virtual llvm::Value *CreateIntelOpenMPRTLLoc(SourceLocation Loc,
+      CodeGenFunction &CGF, unsigned Flags = 0x02);
+  /// \brief Creates call to "__kmpc_global_thread_num(ident_t *loc)" OpenMP
+  /// RTL function.
+  virtual llvm::Value *CreateOpenMPGlobalThreadNum(SourceLocation Loc,
+      CodeGenFunction &CGF);
+  /// \brief Checks if the variable is OpenMP threadprivate and generates code
+  /// for threadprivate variables.
+  /// \return 0 if the variable is not threadprivate, or new address otherwise.
+  virtual llvm::Value *CreateOpenMPThreadPrivateCached(const VarDecl *VD,
+                                               SourceLocation Loc,
+                                               CodeGenFunction &CGF,
+                                               bool NoCast = false);
+
+  /// \brief  Return a string with the mangled name of a target region for
+  /// the given module
+  ///
+  std::string GetOffloadEntryMangledName(llvm::Triple TargetTriple);
+
+  /// \brief  Return the target regions descriptor or a create a new
+  /// one if if does not exist
+  ///
+  llvm::Constant* GetTargetRegionsDescriptor();
+
+  /// \brief  Return host pointer for the current target regions. This creates
+  /// the offload entry for the target region
+  ///
+  llvm::Constant* GetHostPtrForCurrentTargetRegion();
+
+  /// \brief Return a pointer to the device image begin
+  ///
+  llvm::Constant* GetDeviceImageBeginPointer(llvm::Triple TargetTriple);
+
+  /// \brief Return a pointer to the device image end
+  ///
+  llvm::Constant* GetDeviceImageEndPointer(llvm::Triple TargetTriple);
 };
+
+/// \brief Returns an implementation of the OpenMP RT for a given target
+CGOpenMPRuntime *CreateOpenMPRuntime(CodeGenModule &CGM);
+
 } // namespace CodeGen
 } // namespace clang
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGOpenMPRuntimeTypes.h cfe-3.5.0.src.omp/lib/CodeGen/CGOpenMPRuntimeTypes.h
--- cfe-3.5.0.src/lib/CodeGen/CGOpenMPRuntimeTypes.h	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGOpenMPRuntimeTypes.h	2014-11-28 10:49:29.000000000 -0500
@@ -0,0 +1,433 @@
+//===- CGOpenMPRuntimeTypes.h - Interface to OpenMP Runtime Types - C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This provides the set of types used by the OpenMP runtime
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CLANG_CODEGEN_OPENMPRUNTIMETYPES_H
+#define CLANG_CODEGEN_OPENMPRUNTIMETYPES_H
+
+#include "CodeGenModule.h"
+#include "CodeGenFunction.h"
+#include "llvm/IR/Type.h"
+#include "llvm/IR/TypeBuilder.h"
+
+namespace {
+struct ident_t {};
+enum sched_type {};
+enum kmp_proc_bind_t {};
+enum target_size_t {};
+enum target_intptr_t {};
+typedef void (*kmpc_micro)(int32_t *global_tid, int32_t *bound_tid, ...);
+typedef void(__kmpc_fork_call)(ident_t *loc, int32_t argc, kmpc_micro microtask,
+                               void *);
+typedef void(__kmpc_push_num_threads)(ident_t *loc, int32_t global_tid,
+                                      int32_t num_threads);
+typedef void(__kmpc_push_proc_bind)(ident_t *loc, int32_t global_tid,
+                                    kmp_proc_bind_t proc_bind);
+typedef void(__kmpc_push_num_teams)(ident_t *loc, int32_t global_tid,
+                                    int32_t num_teams, int32_t num_threads);
+typedef void(__kmpc_fork_teams)(ident_t *loc, int32_t argc,
+                                kmpc_micro microtask, ...);
+// const int KMP_PROC_BIND_FALSE = 0;
+// const int KMP_PROC_BIND_TRUE = 1;
+const int KMP_PROC_BIND_MASTER = 2;
+const int KMP_PROC_BIND_CLOSE = 3;
+const int KMP_PROC_BIND_SPREAD = 4;
+// const int KMP_PROC_BIND_DISABLED = 5;
+// const int KMP_PROC_BIND_INTEL = 6;
+// const int KMP_PROC_BIND_DEFAULT = 7;
+const int KMP_IDENT_BARRIER_EXPL = 0x20;
+const int KMP_IDENT_BARRIER_IMPL = 0x0040;
+const int KMP_IDENT_BARRIER_IMPL_FOR = 0x0040;
+const int KMP_IDENT_BARRIER_IMPL_SECTIONS = 0x00C0;
+const int KMP_IDENT_BARRIER_IMPL_SINGLE = 0x0140;
+typedef int32_t(__kmpc_cancel_barrier)(ident_t *loc, int32_t global_tid);
+typedef void(__kmpc_barrier)(ident_t *loc, int32_t global_tid);
+const int KMP_CANCEL_NOREQ = 0;
+const int KMP_CANCEL_PARALLEL = 1;
+const int KMP_CANCEL_LOOP = 2;
+const int KMP_CANCEL_SECTIONS = 3;
+const int KMP_CANCEL_TASKGROUP = 4;
+typedef int32_t(__kmpc_cancellationpoint)(ident_t *loc, int32_t global_tid,
+                                          int32_t cncl_kind);
+typedef int32_t(__kmpc_cancel)(ident_t *loc, int32_t global_tid,
+                               int32_t cncl_kind);
+typedef int32_t kmp_critical_name[8];
+typedef int32_t(__kmpc_omp_taskyield)(ident_t *loc, int32_t global_tid,
+                                      int32_t end_part);
+typedef int32_t(__kmpc_omp_taskwait)(ident_t *loc, int32_t global_tid);
+typedef void(__kmpc_flush)(ident_t *loc, ...);
+typedef int32_t(__kmpc_master)(ident_t *loc, int32_t global_tid);
+typedef void(__kmpc_end_master)(ident_t *loc, int32_t global_tid);
+typedef int32_t(__kmpc_single)(ident_t *loc, int32_t global_tid);
+typedef void(__kmpc_end_single)(ident_t *loc, int32_t global_tid);
+typedef void(__kmpc_critical)(ident_t *loc, int32_t global_tid,
+                              kmp_critical_name *lck);
+typedef void(__kmpc_end_critical)(ident_t *loc, int32_t global_tid,
+                                  kmp_critical_name *lck);
+typedef void(__kmpc_ordered)(ident_t *loc, int32_t global_tid);
+typedef void(__kmpc_end_ordered)(ident_t *loc, int32_t global_tid);
+typedef void (*kmp_copy_func)(void *lhs_data, void *rhs_data);
+typedef void(__kmpc_copyprivate)(ident_t *loc, int32_t global_tid,
+                                 target_size_t cpy_size, void *cpy_data,
+                                 kmp_copy_func cpy_func, int32_t didit);
+typedef void (*kmp_reduce_func)(void *lhs_data, void *rhs_data);
+typedef int32_t(__kmpc_reduce_nowait)(ident_t *loc, int32_t global_tid,
+                                      int32_t num_vars,
+                                      target_size_t reduce_size,
+                                      void *reduce_data,
+                                      kmp_reduce_func reduce_func,
+                                      kmp_critical_name *lck);
+typedef void(__kmpc_end_reduce_nowait)(ident_t *loc, int32_t global_tid,
+                                       kmp_critical_name *lck);
+typedef int32_t(__kmpc_reduce)(ident_t *loc, int32_t global_tid,
+                               int32_t num_vars, target_size_t reduce_size,
+                               void *reduce_data, kmp_reduce_func reduce_func,
+                               kmp_critical_name *lck);
+typedef void(__kmpc_end_reduce)(ident_t *loc, int32_t global_tid,
+                                kmp_critical_name *lck);
+const int KMP_IDENT_ATOMIC_REDUCE = 0x10;
+typedef void(__kmpc_atomic_start)();
+typedef void(__kmpc_atomic_end)();
+typedef void(__kmpc_dispatch_init_4)(ident_t *loc, int32_t global_tid,
+                                     sched_type schedule, int32_t lb,
+                                     int32_t ub, int32_t st, int32_t chunk);
+typedef void(__kmpc_dispatch_init_4u)(ident_t *loc, int32_t global_tid,
+                                      sched_type schedule, uint32_t lb,
+                                      uint32_t ub, uint32_t st, uint32_t chunk);
+typedef void(__kmpc_dispatch_init_8)(ident_t *loc, int32_t global_tid,
+                                     sched_type schedule, int64_t lb,
+                                     int64_t ub, int64_t st, int64_t chunk);
+typedef void(__kmpc_dispatch_init_8u)(ident_t *loc, int32_t global_tid,
+                                      sched_type schedule, uint64_t lb,
+                                      uint64_t ub, uint64_t st, uint64_t chunk);
+typedef int(__kmpc_dispatch_next_4)(ident_t *loc, int32_t global_tid,
+                                    int32_t *p_last, int32_t *p_lb,
+                                    int32_t *p_ub, int32_t *p_st);
+typedef int(__kmpc_dispatch_next_4u)(ident_t *loc, int32_t global_tid,
+                                     int32_t *p_last, uint32_t *p_lb,
+                                     uint32_t *p_ub, int32_t *p_st);
+typedef int(__kmpc_dispatch_next_8)(ident_t *loc, int32_t global_tid,
+                                    int32_t *p_last, int64_t *p_lb,
+                                    int64_t *p_ub, int64_t *p_st);
+typedef int(__kmpc_dispatch_next_8u)(ident_t *loc, int32_t global_tid,
+                                     int32_t *p_last, uint64_t *p_lb,
+                                     uint64_t *p_ub, int64_t *p_st);
+typedef void(__kmpc_dispatch_fini_4)(ident_t *loc, int32_t global_tid);
+typedef void(__kmpc_dispatch_fini_4u)(ident_t *loc, int32_t global_tid);
+typedef void(__kmpc_dispatch_fini_8)(ident_t *loc, int32_t global_tid);
+typedef void(__kmpc_dispatch_fini_8u)(ident_t *loc, int32_t global_tid);
+typedef void(__kmpc_for_static_init_4)(ident_t *loc, int32_t global_tid,
+                                       int32_t schedule, int32_t *pliter,
+                                       int32_t *plb, int32_t *pub, int32_t *pst,
+                                       int32_t incr, int32_t chunk);
+typedef void(__kmpc_for_static_init_4u)(ident_t *loc, int32_t global_tid,
+                                        int32_t schedule, int32_t *pliter,
+                                        int32_t *plb, int32_t *pub,
+                                        int32_t *pst, int32_t incr,
+                                        int32_t chunk);
+typedef void(__kmpc_for_static_init_8)(ident_t *loc, int32_t global_tid,
+                                       int32_t schedule, int32_t *pliter,
+                                       int64_t *plb, int64_t *pub, int64_t *pst,
+                                       int64_t incr, int64_t chunk);
+typedef void(__kmpc_for_static_init_8u)(ident_t *loc, int32_t global_tid,
+                                        int32_t schedule, int32_t *pliter,
+                                        int64_t *plb, int64_t *pub,
+                                        int64_t *pst, int64_t incr,
+                                        int64_t chunk);
+typedef void(__kmpc_for_static_fini)(ident_t *loc, int32_t global_tid);
+const int KMP_SCH_STATIC_CHUNKED = 33;
+const int KMP_SCH_STATIC = 34;
+const int KMP_SCH_DYNAMIC_CHUNKED = 35;
+const int KMP_SCH_GUIDED_CHUNKED = 36;
+const int KMP_SCH_RUNTIME = 37;
+const int KMP_SCH_AUTO = 38;
+const int KMP_ORD_STATIC_CHUNKED = 65;
+// const int KMP_ORD_STATIC = 66;
+// const int KMP_ORD_DYNAMIC_CHUNKED = 67;
+// const int KMP_ORD_GUIDED_CHUNKED = 68;
+// const int KMP_ORD_RUNTIME = 69;
+// const int KMP_ORD_AUTO = 70;
+const int KMP_NM_STATIC_CHUNKED = 161;
+// const int KMP_NM_STATIC = 162;
+// const int KMP_NM_DYNAMIC_CHUNKED = 163;
+// const int KMP_NM_GUIDED_CHUNKED = 164;
+// const int KMP_NM_RUNTIME = 165;
+// const int KMP_NM_AUTO = 166;
+const int KMP_NM_ORD_STATIC_CHUNKED = 193;
+// const int KMP_NM_ORD_STATIC = 194;
+// const int KMP_NM_ORD_DYNAMIC_CHUNKED = 195;
+// const int KMP_NM_ORD_GUIDED_CHUNKED = 196;
+// const int KMP_NM_ORD_RUNTIME = 197;
+// const int KMP_NM_ORD_AUTO = 198;
+const int KMP_SCH_DEFAULT = KMP_SCH_STATIC;
+const int SCH_ORD = KMP_ORD_STATIC_CHUNKED - KMP_SCH_STATIC_CHUNKED;
+const int SCH_NM = KMP_NM_STATIC_CHUNKED - KMP_SCH_STATIC_CHUNKED;
+const int SCH_NM_ORD = KMP_NM_ORD_STATIC_CHUNKED - KMP_SCH_STATIC_CHUNKED;
+const int KMP_SCH_DISTRIBUTE_STATIC_CHUNKED = 91;
+const int KMP_SCH_DISTRIBUTE_STATIC = 92;
+typedef int32_t (*kmp_routine_entry_t)(int32_t, void *);
+struct kmp_task_t {};
+const int OMP_TASK_UNTIED = 0;
+const int OMP_TASK_TIED = 1;
+const int OMP_TASK_FINAL = 2;
+const int OMP_TASK_DESTRUCTORS_THUNK = 8;
+const int OMP_TASK_CURRENT_QUEUED = 1;
+struct kmp_depend_info_t {};
+const unsigned char IN = 1;
+const unsigned char OUT = 2;
+const unsigned char INOUT = 3;
+typedef int32_t(__kmpc_omp_task_with_deps)(ident_t *loc, int32_t gtid,
+                                           kmp_task_t *task, int32_t ndeps,
+                                           kmp_depend_info_t *dep_list,
+                                           int32_t ndeps_noalias,
+                                           kmp_depend_info_t *noalias_dep_list);
+typedef void(__kmpc_omp_wait_deps)(ident_t *loc, int32_t gtid, int32_t ndeps,
+                                   kmp_depend_info_t *dep_list,
+                                   int32_t ndeps_noalias,
+                                   kmp_depend_info_t *noalias_dep_list);
+typedef kmp_task_t *(__kmpc_omp_task_alloc)(ident_t *loc, int32_t gtid,
+                                            int32_t flags,
+                                            target_size_t sizeof_kmp_task_t,
+                                            target_size_t sizeof_shareds,
+                                            kmp_routine_entry_t task_entry);
+typedef void(__kmpc_omp_task_begin_if0)(ident_t *loc, int32_t gtid,
+                                        kmp_task_t *task);
+typedef void(__kmpc_omp_task_complete_if0)(ident_t *loc, int32_t gtid,
+                                           kmp_task_t *task);
+typedef int32_t(__kmpc_omp_task_parts)(ident_t *loc, int32_t gtid,
+                                       kmp_task_t *task);
+typedef void(__kmpc_taskgroup)(ident_t *loc, int32_t global_tid);
+typedef void(__kmpc_end_taskgroup)(ident_t *loc, int32_t global_tid);
+
+
+//struct target_size_t {};
+typedef void *(*kmpc_ctor)(void *);
+typedef void *(*kmpc_cctor)(void *, void *);
+typedef void *(*kmpc_dtor)(void *);
+typedef void(__kmpc_threadprivate_register)(ident_t *loc, void *data,
+                                            kmpc_ctor ctor, kmpc_cctor cctor,
+                                            kmpc_dtor dtor);
+typedef int32_t(__kmpc_global_thread_num)(ident_t *loc);
+typedef void *(__kmpc_threadprivate_cached)(ident_t *loc, int32_t global_tid,
+                                            void *data, target_size_t size,
+                                            void ***cache);
+
+const unsigned OMP_TGT_MAPTYPE_ALLOC   = 0;
+const unsigned OMP_TGT_MAPTYPE_TO      = 1;
+const unsigned OMP_TGT_MAPTYPE_FROM    = 2;
+const unsigned OMP_TGT_MAPTYPE_TOFROM  = 3;
+
+struct __tgt_device_image{
+  void   *ImageStart;       // Pointer to the target code start
+  void   *ImageEnd;         // Pointer to the target code end
+};
+struct __tgt_offload_entry{
+  void      *addr;       // Pointer to the offload entry info (function or global)
+  int32_t    size;        // Size of the entry info (0 if it a function)
+};
+struct __tgt_bin_desc{
+  int32_t              NumDevices;     // Number of devices supported
+  __tgt_device_image   *DeviceImages;   // Arrays of device images (one per device)
+  __tgt_offload_entry  *EntriesBegin;   // Begin of the table with all the entries
+  __tgt_offload_entry  *EntriesEnd;     // End of the table with all the entries (non inclusive)
+};
+
+typedef void(__kmpc_register_lib)(__tgt_bin_desc* desc);
+
+typedef int32_t(__kmpc_target)(int32_t device_id, void *host_addr,
+    int32_t num_args, void** args, int32_t *args_size, int32_t *args_maptype);
+
+typedef void(__kmpc_target_data_begin)(int32_t device_id, int32_t num_args,
+    void** args, int32_t *args_size, int32_t *args_maptype);
+
+typedef void(__kmpc_target_data_end)(int32_t device_id, int32_t num_args,
+    void** args, int32_t *args_size, int32_t *args_maptype);
+}
+
+namespace llvm {
+/// Specializations of llvm::TypeBuilder for:
+///   ident_t
+template <bool X> class TypeBuilder<ident_t, X> {
+public:
+  static StructType *get(LLVMContext &C) {
+    return StructType::get(
+        TypeBuilder<llvm::types::i<32>, X>::get(C),  // reserved_1
+        TypeBuilder<llvm::types::i<32>, X>::get(C),  // flags
+        TypeBuilder<llvm::types::i<32>, X>::get(C),  // reserved_2
+        TypeBuilder<llvm::types::i<32>, X>::get(C),  // reserved_3
+        TypeBuilder<llvm::types::i<8> *, X>::get(C), // psource
+        NULL);
+  }
+  enum { reserved_1, flags, reserved_2, reserved_3, psource };
+};
+///   ident_t
+template <bool X> class TypeBuilder<kmp_task_t, X> {
+public:
+  static StructType *get(LLVMContext &C) {
+    return StructType::get(
+        TypeBuilder<void *, X>::get(C),              // shareds
+        TypeBuilder<kmp_routine_entry_t, X>::get(C), // routine
+        TypeBuilder<llvm::types::i<32>, X>::get(C),  // part_id
+        TypeBuilder<kmp_routine_entry_t, X>::get(C), // destructors
+        TypeBuilder<llvm::types::i<32>, X>::get(C),  // firstprivate_locker
+        NULL);
+  }
+  enum { shareds, routine, part_id, destructors, firstprivate_locker };
+};
+template <typename R, typename A1, typename A2, typename A3, typename A4,
+          typename A5, typename A6, typename A7, bool cross>
+class TypeBuilder<R(A1, A2, A3, A4, A5, A6, A7), cross> {
+public:
+  static FunctionType *get(LLVMContext &Context) {
+    Type *params[] = {
+        TypeBuilder<A1, cross>::get(Context),
+        TypeBuilder<A2, cross>::get(Context),
+        TypeBuilder<A3, cross>::get(Context),
+        TypeBuilder<A4, cross>::get(Context),
+        TypeBuilder<A5, cross>::get(Context),
+        TypeBuilder<A6, cross>::get(Context),
+        TypeBuilder<A7, cross>::get(Context),
+    };
+    return FunctionType::get(TypeBuilder<R, cross>::get(Context), params,
+                             false);
+  }
+};
+template <typename R, typename A1, typename A2, typename A3, typename A4,
+          typename A5, typename A6, typename A7, typename A8, typename A9,
+          bool cross>
+class TypeBuilder<R(A1, A2, A3, A4, A5, A6, A7, A8, A9), cross> {
+public:
+  static FunctionType *get(LLVMContext &Context) {
+    Type *params[] = {
+        TypeBuilder<A1, cross>::get(Context),
+        TypeBuilder<A2, cross>::get(Context),
+        TypeBuilder<A3, cross>::get(Context),
+        TypeBuilder<A4, cross>::get(Context),
+        TypeBuilder<A5, cross>::get(Context),
+        TypeBuilder<A6, cross>::get(Context),
+        TypeBuilder<A7, cross>::get(Context),
+        TypeBuilder<A8, cross>::get(Context),
+        TypeBuilder<A9, cross>::get(Context),
+    };
+    return FunctionType::get(TypeBuilder<R, cross>::get(Context), params,
+                             false);
+  }
+};
+template <typename R, typename A1, typename A2, typename A3, typename A4,
+          typename A5, typename A6, bool cross>
+class TypeBuilder<R(A1, A2, A3, A4, A5, A6), cross> {
+public:
+  static FunctionType *get(LLVMContext &Context) {
+    Type *params[] = {
+        TypeBuilder<A1, cross>::get(Context),
+        TypeBuilder<A2, cross>::get(Context),
+        TypeBuilder<A3, cross>::get(Context),
+        TypeBuilder<A4, cross>::get(Context),
+        TypeBuilder<A5, cross>::get(Context),
+        TypeBuilder<A6, cross>::get(Context),
+    };
+    return FunctionType::get(TypeBuilder<R, cross>::get(Context), params,
+                             false);
+  }
+};
+template <bool X> class TypeBuilder<sched_type, X> {
+public:
+  static IntegerType *get(LLVMContext &C) {
+    return TypeBuilder<llvm::types::i<32>, X>::get(C);
+  }
+};
+template <bool X> class TypeBuilder<kmp_proc_bind_t, X> {
+public:
+  static IntegerType *get(LLVMContext &C) {
+    return TypeBuilder<llvm::types::i<32>, X>::get(C);
+  }
+};
+
+//struct LLVContextCGM {
+//  llvm::LLVMContext &VMContext;
+//  CodeGenModule *CGM;
+//  LLVContextCGM(llvm::LLVMContext &VMContext, CodeGenModule *CGM)
+//      : VMContext(VMContext), CGM(CGM) {}
+//};
+
+typedef llvm::TypeBuilder<kmp_task_t, false> TaskTBuilder;
+typedef llvm::TypeBuilder<kmp_proc_bind_t, false> ProcBindTBuilder;
+typedef llvm::TypeBuilder<ident_t, false> IdentTBuilder;
+
+///// Specializations of llvm::TypeBuilder for:
+/////   ident_t
+//template <bool X> class TypeBuilder<ident_t, X> {
+//public:
+//  static StructType *get(LLVMContext &C) {
+//    return StructType::get(
+//        TypeBuilder<llvm::types::i<32>, X>::get(C),  // reserved_1
+//        TypeBuilder<llvm::types::i<32>, X>::get(C),  // flags
+//        TypeBuilder<llvm::types::i<32>, X>::get(C),  // reserved_2
+//        TypeBuilder<llvm::types::i<32>, X>::get(C),  // reserved_3
+//        TypeBuilder<llvm::types::i<8> *, X>::get(C), // psource
+//        NULL);
+//  }
+//  enum {
+//    reserved_1,
+//    flags,
+//    reserved_2,
+//    reserved_3,
+//    psource
+//  };
+//};
+
+template <bool X> class TypeBuilder<__tgt_device_image, X> {
+public:
+  static StructType *get(LLVMContext &C) {
+    return StructType::get(
+        TypeBuilder<llvm::types::i<8>*, X>::get(C), // Pointer to the target code start
+        TypeBuilder<llvm::types::i<8>*, X>::get(C), // Pointer to the target code end
+        NULL);
+  }
+  enum {
+    image_start,
+    image_end
+  };
+};
+template <bool X> class TypeBuilder<__tgt_offload_entry, X> {
+public:
+  static StructType *get(LLVMContext &C) {
+    return StructType::get(
+        TypeBuilder<llvm::types::i<8>*, X>::get(C),  // Pointer to the offload entry info (function or global)
+        TypeBuilder<llvm::types::i<32>, X>::get(C),  // Size of the entry info (0 if it a function)
+        NULL);
+  }
+  enum {
+    address,
+    size
+  };
+};
+template <bool X> class TypeBuilder<__tgt_bin_desc, X> {
+public:
+  static StructType *get(LLVMContext &C) {
+    return StructType::get(
+        TypeBuilder<llvm::types::i<32>,   X>::get(C), // Number of devices supported
+        TypeBuilder<__tgt_device_image*,  X>::get(C), // Arrays of device images (one per device)
+        TypeBuilder<__tgt_offload_entry*, X>::get(C), // Begin of the table with all the entries
+        TypeBuilder<__tgt_offload_entry*, X>::get(C), // End of the table with all the entries (non inclusive)
+        NULL);
+  }
+  enum {
+    num_devices,
+    device_images,
+    entries_begin,
+    entries_end
+  };
+};
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGStmt.cpp cfe-3.5.0.src.omp/lib/CodeGen/CGStmt.cpp
--- cfe-3.5.0.src/lib/CodeGen/CGStmt.cpp	2014-07-21 19:10:56.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGStmt.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -16,6 +16,8 @@
 #include "CodeGenModule.h"
 #include "TargetInfo.h"
 #include "clang/AST/StmtVisitor.h"
+#include "clang/Basic/CapturedStmt.h"
+#include "clang/Sema/SemaDiagnostic.h"
 #include "clang/Basic/PrettyStackTrace.h"
 #include "clang/Basic/TargetInfo.h"
 #include "clang/Sema/LoopHint.h"
@@ -25,6 +27,8 @@
 #include "llvm/IR/DataLayout.h"
 #include "llvm/IR/InlineAsm.h"
 #include "llvm/IR/Intrinsics.h"
+#include "llvm/IR/TypeBuilder.h"
+#include "llvm/IR/CallSite.h"
 using namespace clang;
 using namespace CodeGen;
 
@@ -142,6 +146,137 @@
     EmitCapturedStmt(*CS, CS->getCapturedRegionKind());
     }
     break;
+    // "One-call" OMP Directives
+    case Stmt::OMPBarrierDirectiveClass:
+      EmitOMPBarrierDirective(cast<OMPBarrierDirective>(*S));
+      break;
+    case Stmt::OMPTaskyieldDirectiveClass:
+      EmitOMPTaskyieldDirective(cast<OMPTaskyieldDirective>(*S));
+      break;
+    case Stmt::OMPTaskwaitDirectiveClass:
+      EmitOMPTaskwaitDirective(cast<OMPTaskwaitDirective>(*S));
+      break;
+    case Stmt::OMPFlushDirectiveClass:
+      EmitOMPFlushDirective(cast<OMPFlushDirective>(*S));
+      break;
+    // Atomic OMP Directive -- pattern match and emit one call
+    case Stmt::OMPAtomicDirectiveClass:
+      EmitOMPAtomicDirective(cast<OMPAtomicDirective>(*S));
+      break;
+    // "Two-calls" OMP Directives
+    case Stmt::OMPMasterDirectiveClass:
+      EmitOMPMasterDirective(cast<OMPMasterDirective>(*S));
+      break;
+    case Stmt::OMPSingleDirectiveClass:
+      EmitOMPSingleDirective(cast<OMPSingleDirective>(*S));
+      break;
+    case Stmt::OMPCriticalDirectiveClass:
+      EmitOMPCriticalDirective(cast<OMPCriticalDirective>(*S));
+      break;
+    case Stmt::OMPOrderedDirectiveClass:
+      EmitOMPOrderedDirective(cast<OMPOrderedDirective>(*S));
+      break;
+    // A more advanced stuff
+    case Stmt::OMPParallelDirectiveClass:
+      EmitOMPParallelDirective(cast<OMPParallelDirective>(*S));
+      break;
+    case Stmt::OMPParallelForDirectiveClass:
+      EmitOMPParallelForDirective(cast<OMPParallelForDirective>(*S));
+      break;
+    case Stmt::OMPSimdDirectiveClass:
+      EmitOMPSimdDirective(cast<OMPSimdDirective>(*S));
+      break;
+    case Stmt::OMPForSimdDirectiveClass:
+      EmitOMPForSimdDirective(cast<OMPForSimdDirective>(*S));
+      break;
+    case Stmt::OMPParallelForSimdDirectiveClass:
+      EmitOMPParallelForSimdDirective(cast<OMPParallelForSimdDirective>(*S));
+      break;
+    case Stmt::OMPDistributeSimdDirectiveClass:
+      EmitOMPDistributeSimdDirective(cast<OMPDistributeSimdDirective>(*S));
+      break;
+    case Stmt::OMPDistributeParallelForDirectiveClass:
+      EmitOMPDistributeParallelForDirective(
+          cast<OMPDistributeParallelForDirective>(*S));
+      break;
+    case Stmt::OMPDistributeParallelForSimdDirectiveClass:
+      EmitOMPDistributeParallelForSimdDirective(
+          cast<OMPDistributeParallelForSimdDirective>(*S));
+      break;
+    case Stmt::OMPTeamsDistributeParallelForDirectiveClass:
+      EmitOMPTeamsDistributeParallelForDirective(
+          cast<OMPTeamsDistributeParallelForDirective>(*S));
+      break;
+    case Stmt::OMPTeamsDistributeParallelForSimdDirectiveClass:
+      EmitOMPTeamsDistributeParallelForSimdDirective(
+          cast<OMPTeamsDistributeParallelForSimdDirective>(*S));
+      break;
+    case Stmt::OMPTargetTeamsDistributeParallelForDirectiveClass:
+      EmitOMPTargetTeamsDistributeParallelForDirective(
+          cast<OMPTargetTeamsDistributeParallelForDirective>(*S));
+      break;
+    case Stmt::OMPTargetTeamsDistributeParallelForSimdDirectiveClass:
+      EmitOMPTargetTeamsDistributeParallelForSimdDirective(
+          cast<OMPTargetTeamsDistributeParallelForSimdDirective>(*S));
+      break;
+    case Stmt::OMPTaskDirectiveClass:
+      EmitOMPTaskDirective(cast<OMPTaskDirective>(*S));
+      break;
+    case Stmt::OMPForDirectiveClass:
+      EmitOMPForDirective(cast<OMPForDirective>(*S));
+      break;
+    case Stmt::OMPSectionsDirectiveClass:
+      EmitOMPSectionsDirective(cast<OMPSectionsDirective>(*S));
+      break;
+    case Stmt::OMPParallelSectionsDirectiveClass:
+      EmitOMPParallelSectionsDirective(cast<OMPParallelSectionsDirective>(*S));
+      break;
+    case Stmt::OMPSectionDirectiveClass:
+      EmitOMPSectionDirective(cast<OMPSectionDirective>(*S));
+      break;
+    case Stmt::OMPTaskgroupDirectiveClass:
+      EmitOMPTaskgroupDirective(cast<OMPTaskgroupDirective>(*S));
+      break;
+    case Stmt::OMPTeamsDirectiveClass:
+      EmitOMPTeamsDirective(cast<OMPTeamsDirective>(*S));
+      break;
+    case Stmt::OMPDistributeDirectiveClass:
+      EmitOMPDistributeDirective(cast<OMPDistributeDirective>(*S));
+      break;
+    case Stmt::OMPCancelDirectiveClass:
+      EmitOMPCancelDirective(cast<OMPCancelDirective>(*S));
+      break;
+    case Stmt::OMPCancellationPointDirectiveClass:
+      EmitOMPCancellationPointDirective(
+          cast<OMPCancellationPointDirective>(*S));
+      break;
+    case Stmt::OMPTargetDirectiveClass:
+      EmitOMPTargetDirective(cast<OMPTargetDirective>(*S));
+      break;
+  case Stmt::OMPTargetDataDirectiveClass:
+    EmitOMPTargetDataDirective(cast<OMPTargetDataDirective>(*S));
+    break;
+  case Stmt::OMPTargetUpdateDirectiveClass:
+    EmitOMPTargetUpdateDirective(cast<OMPTargetUpdateDirective>(*S));
+    break;
+  case Stmt::OMPTargetTeamsDirectiveClass:
+    EmitOMPTargetTeamsDirective(cast<OMPTargetTeamsDirective>(*S));
+    break;
+  case Stmt::OMPTeamsDistributeDirectiveClass:
+    EmitOMPTeamsDistributeDirective(cast<OMPTeamsDistributeDirective>(*S));
+    break;
+  case Stmt::OMPTeamsDistributeSimdDirectiveClass:
+    EmitOMPTeamsDistributeSimdDirective(
+        cast<OMPTeamsDistributeSimdDirective>(*S));
+    break;
+  case Stmt::OMPTargetTeamsDistributeDirectiveClass:
+    EmitOMPTargetTeamsDistributeDirective(
+        cast<OMPTargetTeamsDistributeDirective>(*S));
+    break;
+  case Stmt::OMPTargetTeamsDistributeSimdDirectiveClass:
+    EmitOMPTargetTeamsDistributeSimdDirective(
+        cast<OMPTargetTeamsDistributeSimdDirective>(*S));
+    break;
   case Stmt::ObjCAtTryStmtClass:
     EmitObjCAtTryStmt(cast<ObjCAtTryStmt>(*S));
     break;
@@ -176,51 +311,6 @@
   case Stmt::SEHLeaveStmtClass:
     EmitSEHLeaveStmt(cast<SEHLeaveStmt>(*S));
     break;
-  case Stmt::OMPParallelDirectiveClass:
-    EmitOMPParallelDirective(cast<OMPParallelDirective>(*S));
-    break;
-  case Stmt::OMPSimdDirectiveClass:
-    EmitOMPSimdDirective(cast<OMPSimdDirective>(*S));
-    break;
-  case Stmt::OMPForDirectiveClass:
-    EmitOMPForDirective(cast<OMPForDirective>(*S));
-    break;
-  case Stmt::OMPSectionsDirectiveClass:
-    EmitOMPSectionsDirective(cast<OMPSectionsDirective>(*S));
-    break;
-  case Stmt::OMPSectionDirectiveClass:
-    EmitOMPSectionDirective(cast<OMPSectionDirective>(*S));
-    break;
-  case Stmt::OMPSingleDirectiveClass:
-    EmitOMPSingleDirective(cast<OMPSingleDirective>(*S));
-    break;
-  case Stmt::OMPMasterDirectiveClass:
-    EmitOMPMasterDirective(cast<OMPMasterDirective>(*S));
-    break;
-  case Stmt::OMPCriticalDirectiveClass:
-    EmitOMPCriticalDirective(cast<OMPCriticalDirective>(*S));
-    break;
-  case Stmt::OMPParallelForDirectiveClass:
-    EmitOMPParallelForDirective(cast<OMPParallelForDirective>(*S));
-    break;
-  case Stmt::OMPParallelSectionsDirectiveClass:
-    EmitOMPParallelSectionsDirective(cast<OMPParallelSectionsDirective>(*S));
-    break;
-  case Stmt::OMPTaskDirectiveClass:
-    EmitOMPTaskDirective(cast<OMPTaskDirective>(*S));
-    break;
-  case Stmt::OMPTaskyieldDirectiveClass:
-    EmitOMPTaskyieldDirective(cast<OMPTaskyieldDirective>(*S));
-    break;
-  case Stmt::OMPBarrierDirectiveClass:
-    EmitOMPBarrierDirective(cast<OMPBarrierDirective>(*S));
-    break;
-  case Stmt::OMPTaskwaitDirectiveClass:
-    EmitOMPTaskwaitDirective(cast<OMPTaskwaitDirective>(*S));
-    break;
-  case Stmt::OMPFlushDirectiveClass:
-    EmitOMPFlushDirective(cast<OMPFlushDirective>(*S));
-    break;
   }
 }
 
@@ -657,8 +747,7 @@
   // the continue target.
   JumpDest LoopHeader = getJumpDestInCurrentScope("while.cond");
   EmitBlock(LoopHeader.getBlock());
-
-  LoopStack.push(LoopHeader.getBlock());
+  LoopStack.Push(LoopHeader.getBlock());
 
   // Create an exit block for when the condition fails, which will
   // also become the break target.
@@ -727,7 +816,7 @@
   // Branch to the loop header again.
   EmitBranch(LoopHeader.getBlock());
 
-  LoopStack.pop();
+  LoopStack.Pop();
 
   // Emit the exit block.
   EmitBlock(LoopExit.getBlock(), true);
@@ -750,8 +839,7 @@
 
   // Emit the body of the loop.
   llvm::BasicBlock *LoopBody = createBasicBlock("do.body");
-
-  LoopStack.push(LoopBody);
+  LoopStack.Push(LoopBody);
 
   EmitBlockWithFallThrough(LoopBody, Cnt);
   {
@@ -788,7 +876,7 @@
     EmitCondBrHints(LoopBody->getContext(), CondBr, DoAttrs);
   }
 
-  LoopStack.pop();
+  LoopStack.Pop();
 
   // Emit the exit block.
   EmitBlock(LoopExit.getBlock());
@@ -821,8 +909,7 @@
   JumpDest Continue = getJumpDestInCurrentScope("for.cond");
   llvm::BasicBlock *CondBlock = Continue.getBlock();
   EmitBlock(CondBlock);
-
-  LoopStack.push(CondBlock);
+  LoopStack.Push(CondBlock);
 
   // If the for loop doesn't have an increment we can just use the
   // condition as the continue block.  Otherwise we'll need to create
@@ -898,7 +985,7 @@
   if (DI)
     DI->EmitLexicalBlockEnd(Builder, S.getSourceRange().getEnd());
 
-  LoopStack.pop();
+  LoopStack.Pop();
 
   // Emit the fall-through block.
   EmitBlock(LoopExit.getBlock(), true);
@@ -927,7 +1014,7 @@
   llvm::BasicBlock *CondBlock = createBasicBlock("for.cond");
   EmitBlock(CondBlock);
 
-  LoopStack.push(CondBlock);
+  LoopStack.Push(CondBlock);
 
   // If there are any cleanups between here and the loop-exit scope,
   // create a block to stage a loop exit along.
@@ -981,7 +1068,7 @@
   if (DI)
     DI->EmitLexicalBlockEnd(Builder, S.getSourceRange().getEnd());
 
-  LoopStack.pop();
+  LoopStack.Pop();
 
   // Emit the fall-through block.
   EmitBlock(LoopExit.getBlock(), true);
@@ -2067,20 +2154,24 @@
   }
 }
 
-static LValue InitCapturedStruct(CodeGenFunction &CGF, const CapturedStmt &S) {
+LValue CodeGenFunction::InitCapturedStruct(const CapturedStmt &S) {
   const RecordDecl *RD = S.getCapturedRecordDecl();
-  QualType RecordTy = CGF.getContext().getRecordType(RD);
+  QualType RecordTy = getContext().getRecordType(RD);
 
   // Initialize the captured struct.
-  LValue SlotLV = CGF.MakeNaturalAlignAddrLValue(
-                    CGF.CreateMemTemp(RecordTy, "agg.captured"), RecordTy);
+  LValue SlotLV = MakeNaturalAlignAddrLValue(
+                    CreateMemTemp(RecordTy, "agg.captured"), RecordTy);
 
   RecordDecl::field_iterator CurField = RD->field_begin();
+  CapturedStmt::const_capture_iterator C = S.capture_begin();
   for (CapturedStmt::capture_init_iterator I = S.capture_init_begin(),
                                            E = S.capture_init_end();
-       I != E; ++I, ++CurField) {
-    LValue LV = CGF.EmitLValueForFieldInitialization(SlotLV, *CurField);
-    CGF.EmitInitializerForField(*CurField, LV, *I, ArrayRef<VarDecl *>());
+       I != E; ++I, ++C, ++CurField) {
+    if ((*CurField)->getType()->isVariablyModifiedType()) {
+      EmitVariablyModifiedType((*CurField)->getType());
+    }
+    LValue LV = EmitLValueForFieldInitialization(SlotLV, *CurField);
+    EmitInitializerForField(*CurField, LV, *I, ArrayRef<VarDecl *>());
   }
 
   return SlotLV;
@@ -2106,7 +2197,7 @@
 /// captured variables into the captured struct, and call the outlined function.
 llvm::Function *
 CodeGenFunction::EmitCapturedStmt(const CapturedStmt &S, CapturedRegionKind K) {
-  LValue CapStruct = InitCapturedStruct(*this, S);
+  LValue CapStruct = InitCapturedStruct(S);
 
   // Emit the CapturedDecl
   CodeGenFunction CGF(CGM, true);
@@ -2122,13 +2213,15 @@
 
 llvm::Value *
 CodeGenFunction::GenerateCapturedStmtArgument(const CapturedStmt &S) {
-  LValue CapStruct = InitCapturedStruct(*this, S);
+  LValue CapStruct = InitCapturedStruct(S);
   return CapStruct.getAddress();
 }
 
 /// Creates the outlined function for a CapturedStmt.
 llvm::Function *
 CodeGenFunction::GenerateCapturedStmtFunction(const CapturedStmt &S) {
+  CGM.OpenMPSupport.startOpenMPRegion(true);
+
   assert(CapturedStmtInfo &&
     "CapturedStmtInfo should be set when generating the captured function");
   const CapturedDecl *CD = S.getCapturedDecl();
@@ -2174,11 +2267,359 @@
     CXXThisValue = EmitLoadOfLValue(ThisLValue, Loc).getScalarVal();
   }
 
+  for (RecordDecl::field_iterator I = RD->field_begin(),
+                                  E = RD->field_end();
+       I != E; ++I) {
+    if ((*I)->getType()->isVariablyModifiedType()) {
+      EmitVariablyModifiedType((*I)->getType());
+    }
+  }
+
   PGO.assignRegionCounters(CD, F);
   CapturedStmtInfo->EmitBody(*this, CD->getBody());
   FinishFunction(CD->getBodyRBrace());
   PGO.emitInstrumentationData();
   PGO.destroyRegionCounters();
 
+  CGM.OpenMPSupport.endOpenMPRegion();
+
   return F;
 }
+
+void CodeGenFunction::EmitSIMDForHelperCall(llvm::Function *BodyFunc,
+                                            LValue CapStruct,
+                                            llvm::Value *LoopIndex,
+                                            bool IsLastIter) {
+  // Emit call to the helper function.
+  SmallVector<llvm::Value *, 3> HelperArgs;
+  HelperArgs.push_back(CapStruct.getAddress());
+  HelperArgs.push_back(Builder.CreateLoad(LoopIndex));
+
+  llvm::Value *LastIter = 0;
+  if (IsLastIter)
+    LastIter = llvm::ConstantInt::getTrue(BodyFunc->getContext());
+  else
+    LastIter = llvm::ConstantInt::getFalse(BodyFunc->getContext());
+  HelperArgs.push_back(LastIter);
+
+  disableExceptions();
+  EmitCallOrInvoke(BodyFunc, HelperArgs);
+  enableExceptions();
+}
+
+llvm::Function *CodeGenFunction::EmitSimdFunction(CGPragmaSimdWrapper &W) {
+  const CapturedStmt &CS = *W.getAssociatedStmt();
+
+  CGSIMDForStmtInfo CSInfo(W, LoopStack.GetCurLoopID(),
+                              LoopStack.GetCurLoopParallel());
+  CodeGenFunction CGF(CGM, true);
+  CGF.CapturedStmtInfo = &CSInfo;
+
+  CGF.disableExceptions();
+  llvm::Function *BodyFunction = CGF.GenerateCapturedStmtFunction(CS);
+  CGF.enableExceptions();
+
+  // Always inline this function back to the call site.
+  BodyFunction->addFnAttr(llvm::Attribute::AlwaysInline);
+  return BodyFunction;
+}
+
+void CodeGenFunction::EmitPragmaSimd(CodeGenFunction::CGPragmaSimdWrapper &W) {
+  if (W.isOmp()) {
+    // Start a region for loop index and loops' counters
+    // (there will be another one region inside __simd_helper routine).
+    CGM.OpenMPSupport.startOpenMPRegion(false);
+    CGM.OpenMPSupport.setNoWait(false);
+    CGM.OpenMPSupport.setMergeable(true);
+    CGM.OpenMPSupport.setOrdered(false);
+  }
+  RunCleanupsScope SIMDForScope(*this);
+  RegionCounter Cnt =
+      getPGORegionCounter(W.getAssociatedStmt()->getCapturedStmt());
+
+  // Emit 'safelen' clause and decide if we want to separate last iteration.
+  bool SeparateLastIter = W.emitSafelen(this);
+
+  // Update debug info.
+  CGDebugInfo *DI = getDebugInfo();
+  if (DI)
+    DI->EmitLexicalBlockStart(Builder, W.getForLoc());
+
+  // Emit the for-loop.
+  llvm::Value *LoopIndex = 0;
+  llvm::Value *LoopCount = 0;
+
+  // Emit the loop control variable and cache its initial value and the
+  // stride value.
+  // Also emit loop index and loop count, depending on stmt.
+
+  W.emitInit(*this, LoopIndex, LoopCount);
+
+  // Only run the SIMD loop if the loop condition is true
+  llvm::BasicBlock *ContBlock = createBasicBlock("if.end");
+  llvm::BasicBlock *ThenBlock = createBasicBlock("if.then");
+
+  // The following condition is zero trip test to skip last iteration if
+  // the loopcount is zero.
+  // In the 'omp simd' we may have more than one loop counter due to
+  // 'collapse', so we check loopcount instead of loop counter.
+  if (!W.isOmp()) {
+    EmitBranchOnBoolExpr(W.getCond(), ThenBlock, ContBlock, Cnt.getCount());
+    EmitBlock(ThenBlock);
+  }
+  else {
+    llvm::Value *BoolCondVal = Builder.CreateICmpSLT(
+      llvm::ConstantInt::get(LoopCount->getType(), 0), LoopCount);
+    Builder.CreateCondBr(BoolCondVal, ThenBlock, ContBlock);
+    EmitBlock(ThenBlock);
+  }
+
+  // Initialize the captured struct.
+  LValue CapStruct = InitCapturedStruct(*W.getAssociatedStmt());
+
+  {
+    JumpDest LoopExit = getJumpDestInCurrentScope("for.end");
+    RunCleanupsScope ForScope(*this);
+
+    Builder.CreateStore(llvm::ConstantInt::get(LoopCount->getType(), 0),
+                        LoopIndex);
+
+    if (SeparateLastIter)
+      // Lastprivate or linear variable present, remove last iteration.
+      LoopCount = Builder.CreateSub(
+          LoopCount, llvm::ConstantInt::get(LoopCount->getType(), 1));
+
+    // Start the loop with a block that tests the condition.
+    // If there's an increment, the continue scope will be overwritten
+    // later.
+    JumpDest Continue = getJumpDestInCurrentScope("for.cond");
+    llvm::BasicBlock *CondBlock = Continue.getBlock();
+    LoopStack.Push(CondBlock);
+
+    EmitBlock(CondBlock);
+
+    llvm::Value *BoolCondVal = 0;
+    {
+      // If the for statement has a condition scope, emit the local variable
+      // declaration.
+      llvm::BasicBlock *ExitBlock = LoopExit.getBlock();
+
+      // If there are any cleanups between here and the loop-exit scope,
+      // create a block to stage a loop exit along.
+      if (ForScope.requiresCleanups())
+        ExitBlock = createBasicBlock("for.cond.cleanup");
+
+      // As long as the condition is true, iterate the loop.
+      llvm::BasicBlock *ForBody = createBasicBlock("for.body");
+
+      // Use LoopCount and LoopIndex for iteration.
+      BoolCondVal = Builder.CreateICmpULT(Builder.CreateLoad(LoopIndex),
+                                          LoopCount);
+
+      // C99 6.8.5p2/p4: The first substatement is executed if the expression
+      // compares unequal to 0.  The condition must be a scalar type.
+      Builder.CreateCondBr(BoolCondVal, ForBody, ExitBlock);
+
+      if (ExitBlock != LoopExit.getBlock()) {
+        EmitBlock(ExitBlock);
+        EmitBranchThroughCleanup(LoopExit);
+      }
+
+      EmitBlock(ForBody);
+    }
+
+    Continue = getJumpDestInCurrentScope("for.inc");
+
+    // Store the blocks to use for break and continue.
+    BreakContinueStack.push_back(BreakContinue(LoopExit, Continue));
+
+    W.emitIncrement(*this, LoopIndex);
+
+    // Emit the call to the loop body.
+    llvm::Function *BodyFunction = EmitSimdFunction(W);
+    EmitSIMDForHelperCall(BodyFunction, CapStruct, LoopIndex, false);
+
+    // Emit the increment block.
+    EmitBlock(Continue.getBlock());
+
+    {
+      llvm::Value *NewLoopIndex =
+        Builder.CreateAdd(Builder.CreateLoad(LoopIndex),
+                          llvm::ConstantInt::get(LoopCount->getType(), 1));
+      Builder.CreateStore(NewLoopIndex, LoopIndex);
+    }
+
+    BreakContinueStack.pop_back();
+
+    EmitBranch(CondBlock);
+
+    ForScope.ForceCleanup();
+
+    if (DI)
+      DI->EmitLexicalBlockEnd(Builder, W.getSourceRange().getEnd());
+
+    LoopStack.Pop();
+
+    // Emit the fall-through block.
+    EmitBlock(LoopExit.getBlock(), true);
+
+    // Increment again, for last iteration.
+    W.emitIncrement(*this, LoopIndex);
+
+    if (SeparateLastIter) {
+      // This helper call makes updates to linear or lastprivate variables.
+      // In the case of openmp, only for lastprivate ones.
+      EmitSIMDForHelperCall(BodyFunction, CapStruct, LoopIndex, true);
+    }
+
+    W.emitLinearFinal(*this);
+  }
+
+  EmitBlock(ContBlock, true);
+
+  if (W.isOmp())
+    CGM.OpenMPSupport.endOpenMPRegion();
+}
+void CodeGenFunction::EmitSIMDForHelperBody(const Stmt *S) {
+  assert(CapturedStmtInfo && "Should be only called inside a CapturedStmt");
+  CGSIMDForStmtInfo *Info = cast<CGSIMDForStmtInfo>(CapturedStmtInfo);
+
+  // Mark the loop body as an extended region of this SIMD loop.
+  LoopStack.Push(Info->getLoopID(), Info->getLoopParallel());
+  {
+    RunCleanupsScope Scope(*this);
+
+    // Emit all SIMD local variables and update the codegen info.
+    Info->walkLocalVariablesToEmit(this);
+
+    // Emit the SIMD for loop body.
+    {
+      RunCleanupsScope BodyScope(*this);
+      // It is not allowed to have return or break in a SIMD loop body.
+      // Continue statements are allowed and updates to the data
+      // privatization variables will be emitted in a unified continue block.
+      JumpDest LoopContinue = getJumpDestInCurrentScope("for.continue");
+      BreakContinueStack.push_back(BreakContinue(JumpDest(), LoopContinue));
+
+      EmitStmt(S);
+
+      EmitBlock(LoopContinue.getBlock());
+
+      // If an update is required, emit those update expressions to be run on
+      // the last iteration of the loop.
+      //
+      // if (IsLastIter) {
+      //   [[ Update Expressions ]]
+      // }
+      //
+      // IsLastIter will only be true if this is a second output of the helper
+      // body, after the intial for-loop.
+      // Since IsLastIter is constant, it will be optimized out, and the if
+      // statement will not be a part of the SIMD For loop, thus allowing
+      // vectorization.
+
+      // Note that the final values of linear variables are to be calculated
+      // outside of __simd_helper function (together with loop indices).
+      if (Info->isOmp()) {
+        const OMPExecutableDirective *SimdOmp = cast<OMPExecutableDirective>(
+                                                        Info->getStmt());
+        const CapturedDecl *CD = cast<CapturedStmt>(
+            SimdOmp->getAssociatedStmt())->getCapturedDecl();
+        llvm::Value *IsLastIter = LocalDeclMap.lookup(CD->getParam(2));
+        // Save the 'last-iteration' flag for 'lastprivate'.
+        CGM.OpenMPSupport.setLastIterVar(IsLastIter);
+
+        // Emit destructors/required copyings for private/lastprivate.
+        for (ArrayRef<OMPClause *>::iterator I = SimdOmp->clauses().begin(),
+            E = SimdOmp->clauses().end(); I != E; ++I) {
+          assert(*I);
+          if (isa<OMPPrivateClause>(*I) || isa<OMPLastPrivateClause>(*I)) {
+            EmitPostOMPClause(*(*I), *SimdOmp);
+          }
+        }
+        // Emit closure of lastprivate clauses.
+        for (ArrayRef<OMPClause *>::iterator I = SimdOmp->clauses().begin(),
+            E = SimdOmp->clauses().end(); I != E; ++I) {
+          assert(*I);
+          if (isa<OMPLastPrivateClause>(*I)) {
+            EmitCloseOMPClause(*(*I), *SimdOmp);
+          }
+        }
+        // Clean up the OpenMP local vars stack
+        CGM.OpenMPSupport.endOpenMPRegion();
+      }
+      BreakContinueStack.pop_back();
+    }
+  }
+
+  // Leave the loop body.
+  LoopStack.Pop();
+}
+
+void CodeGenFunction::InitOpenMPFunction(llvm::Value *Context,
+                                         const CapturedStmt &S) {
+  CapturedStmtInfo =
+      new CGOpenMPCapturedStmtInfo(Context, S, CGM, S.getCapturedRegionKind());
+
+  const RecordDecl *RD = S.getCapturedRecordDecl();
+
+  QualType TagType = getContext().getTagDeclType(RD);
+  LValue Base = MakeNaturalAlignAddrLValue(Context, TagType);
+  RecordDecl::field_iterator CurField = RD->field_begin();
+  CapturedStmt::const_capture_iterator C = S.capture_begin();
+  for (CapturedStmt::capture_init_iterator I = S.capture_init_begin(),
+                                           E = S.capture_init_end();
+       I != E; ++I, ++C, ++CurField) {
+    QualType QTy = (*CurField)->getType();
+    if (QTy->isVariablyModifiedType()) {
+      EmitVariablyModifiedType(QTy);
+    }
+    if (C->capturesVariable()) {
+      const VarDecl *VD = C->getCapturedVar();
+      LValue LV = EmitLValueForField(Base, CapturedStmtInfo->lookup(VD));
+      CapturedStmtInfo->addCachedVar(VD, LV.getAddress());
+    }
+  }
+
+  // If 'this' is captured, load it into CXXThisValue.
+  if (CapturedStmtInfo->isCXXThisExprCaptured()) {
+    FieldDecl *FD = CapturedStmtInfo->getThisFieldDecl();
+    LValue LV = MakeNaturalAlignAddrLValue(CapturedStmtInfo->getContextValue(),
+                                           getContext().getTagDeclType(RD));
+    LValue ThisLValue = EmitLValueForField(LV, FD);
+    CXXThisValue = EmitLoadOfLValue(ThisLValue, FD->getLocStart()).getScalarVal();
+  }
+}
+
+void CodeGenFunction::InitOpenMPTargetFunction(const CapturedStmt &S) {
+  CapturedStmtInfo =
+      new CGOpenMPCapturedStmtInfo(0, S, CGM, S.getCapturedRegionKind());
+
+  const RecordDecl *RD = S.getCapturedRecordDecl();
+
+  llvm::Function::arg_iterator Arg = this->CurFn->arg_begin();
+  RecordDecl::field_iterator CurField = RD->field_begin();
+  CapturedStmt::const_capture_iterator C = S.capture_begin();
+  for (CapturedStmt::capture_init_iterator I = S.capture_init_begin(),
+                                           E = S.capture_init_end();
+       I != E; ++I, ++C, ++CurField, ++Arg) {
+
+    QualType QTy = (*CurField)->getType();
+    if (QTy->isVariablyModifiedType()) {
+      EmitVariablyModifiedType(QTy);
+    }
+    if (C->capturesVariable()) {
+      const VarDecl *VD = C->getCapturedVar();
+      CapturedStmtInfo->addCachedVar(VD, Arg);
+    }
+  }
+
+  // If 'this' is captured, load it into CXXThisValue.
+  if (CapturedStmtInfo->isCXXThisExprCaptured()) {
+    FieldDecl *FD = CapturedStmtInfo->getThisFieldDecl();
+    LValue LV = MakeNaturalAlignAddrLValue(CapturedStmtInfo->getContextValue(),
+                                           getContext().getTagDeclType(RD));
+    LValue ThisLValue = EmitLValueForField(LV, FD);
+    CXXThisValue = EmitLoadOfLValue(ThisLValue, FD->getLocStart()).getScalarVal();
+  }
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CGStmtOpenMP.cpp cfe-3.5.0.src.omp/lib/CodeGen/CGStmtOpenMP.cpp
--- cfe-3.5.0.src/lib/CodeGen/CGStmtOpenMP.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CGStmtOpenMP.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -1,4 +1,4 @@
-//===--- CGStmtOpenMP.cpp - Emit LLVM Code from Statements ----------------===//
+//===--- CGStmtOpenMP.cpp - Emit LLVM Code for declarations ---------------===//
 //
 //                     The LLVM Compiler Infrastructure
 //
@@ -7,63 +7,4895 @@
 //
 //===----------------------------------------------------------------------===//
 //
-// This contains code to emit OpenMP nodes as LLVM code.
+// This contains code to emit Decl nodes as LLVM code.
 //
 //===----------------------------------------------------------------------===//
 
-#include "CGOpenMPRuntime.h"
 #include "CodeGenFunction.h"
+#include "CGDebugInfo.h"
+#include "CGOpenCLRuntime.h"
+#include "CGOpenMPRuntimeTypes.h"
+#include "CGOpenMPRuntime.h"
 #include "CodeGenModule.h"
-#include "clang/AST/Stmt.h"
-#include "clang/AST/StmtOpenMP.h"
+#include "TargetInfo.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Decl.h"
+#include "clang/AST/DeclObjC.h"
+#include "clang/AST/DeclOpenMP.h"
+#include "clang/Basic/OpenMPKinds.h"
+#include "clang/Basic/SourceManager.h"
+#include "clang/Basic/TargetInfo.h"
+#include "clang/Frontend/CodeGenOptions.h"
+#include "llvm/ADT/StringExtras.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/GlobalVariable.h"
+#include "llvm/IR/Intrinsics.h"
+#include "llvm/IR/Type.h"
+#include "llvm/IR/TypeBuilder.h"
+#include "llvm/IR/CallSite.h"
+#include "llvm/Support/Format.h"
+#include "llvm/Support/raw_ostream.h"
+#include <string>
 using namespace clang;
 using namespace CodeGen;
 
-//===----------------------------------------------------------------------===//
-//                              OpenMP Directive Emission
-//===----------------------------------------------------------------------===//
+namespace {
+// Getters for fields of the loop-like directives. We may want to add a
+// common parent to all the loop-like directives to get rid of these.
+//
+
+static bool isLoopDirective(const OMPExecutableDirective *ED) {
+  return isa<OMPForDirective>(ED) || isa<OMPParallelForDirective>(ED) ||
+         isa<OMPParallelForSimdDirective>(ED) || isa<OMPSimdDirective>(ED) ||
+         isa<OMPForSimdDirective>(ED) || isa<OMPDistributeDirective>(ED) ||
+         isa<OMPDistributeSimdDirective>(ED) ||
+         isa<OMPDistributeParallelForDirective>(ED) ||
+         isa<OMPDistributeParallelForSimdDirective>(ED) ||
+         isa<OMPTeamsDistributeParallelForDirective>(ED) ||
+         isa<OMPTeamsDistributeParallelForSimdDirective>(ED) ||
+         isa<OMPTargetTeamsDistributeParallelForDirective>(ED) ||
+         isa<OMPTargetTeamsDistributeParallelForSimdDirective>(ED) ||
+         isa<OMPTeamsDistributeDirective>(ED) ||
+         isa<OMPTeamsDistributeSimdDirective>(ED) ||
+         isa<OMPTargetTeamsDistributeDirective>(ED) ||
+         isa<OMPTargetTeamsDistributeSimdDirective>(ED);
+}
+
+static const Expr *getInitFromLoopDirective(const OMPExecutableDirective *ED) {
+  if (const OMPForDirective *D = dyn_cast<OMPForDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPParallelForDirective *D = dyn_cast<OMPParallelForDirective>(
+      ED)) {
+    return D->getInit();
+  }
+  if (const OMPParallelForSimdDirective *D = dyn_cast<
+      OMPParallelForSimdDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPSimdDirective *D = dyn_cast<OMPSimdDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPForSimdDirective *D = dyn_cast<OMPForSimdDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPDistributeDirective *D = dyn_cast<OMPDistributeDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPDistributeSimdDirective *D =
+      dyn_cast<OMPDistributeSimdDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPDistributeParallelForDirective *D = dyn_cast<
+      OMPDistributeParallelForDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPDistributeParallelForSimdDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPTargetTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPTargetTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPTeamsDistributeDirective *D =
+          dyn_cast<OMPTeamsDistributeDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPTeamsDistributeSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeSimdDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPTargetTeamsDistributeDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeDirective>(ED)) {
+    return D->getInit();
+  }
+  if (const OMPTargetTeamsDistributeSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeSimdDirective>(ED)) {
+    return D->getInit();
+  }
+  assert(0 && "bad loop directive");
+  return 0;
+}
+
+static const Expr *getFinalFromLoopDirective(const OMPExecutableDirective *ED) {
+  if (const OMPForDirective *D = dyn_cast<OMPForDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPParallelForDirective *D = dyn_cast<OMPParallelForDirective>(
+      ED)) {
+    return D->getFinal();
+  }
+  if (const OMPParallelForSimdDirective *D = dyn_cast<
+      OMPParallelForSimdDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPSimdDirective *D = dyn_cast<OMPSimdDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPForSimdDirective *D = dyn_cast<OMPForSimdDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPDistributeDirective *D = dyn_cast<OMPDistributeDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPDistributeSimdDirective *D =
+      dyn_cast<OMPDistributeSimdDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPDistributeParallelForDirective *D = dyn_cast<
+      OMPDistributeParallelForDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPDistributeParallelForSimdDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPTargetTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPTargetTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPTeamsDistributeDirective *D =
+          dyn_cast<OMPTeamsDistributeDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPTeamsDistributeSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeSimdDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPTargetTeamsDistributeDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeDirective>(ED)) {
+    return D->getFinal();
+  }
+  if (const OMPTargetTeamsDistributeSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeSimdDirective>(ED)) {
+    return D->getFinal();
+  }
+  assert(0 && "bad loop directive");
+  return 0;
+}
+
+static const Expr *
+getNewIterVarFromLoopDirective(const OMPExecutableDirective *ED) {
+  if (const OMPForDirective *D = dyn_cast<OMPForDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPParallelForDirective *D = dyn_cast<OMPParallelForDirective>(
+      ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPParallelForSimdDirective *D = dyn_cast<
+      OMPParallelForSimdDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPSimdDirective *D = dyn_cast<OMPSimdDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPForSimdDirective *D = dyn_cast<OMPForSimdDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPDistributeDirective *D = dyn_cast<OMPDistributeDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPDistributeSimdDirective *D =
+      dyn_cast<OMPDistributeSimdDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPDistributeParallelForDirective *D = dyn_cast<
+      OMPDistributeParallelForDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPDistributeParallelForSimdDirective *D = dyn_cast<
+      OMPDistributeParallelForSimdDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPTargetTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPTargetTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPTeamsDistributeDirective *D =
+          dyn_cast<OMPTeamsDistributeDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPTeamsDistributeSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeSimdDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPTargetTeamsDistributeDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  if (const OMPTargetTeamsDistributeSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeSimdDirective>(ED)) {
+    return D->getNewIterVar();
+  }
+  assert(0 && "bad loop directive");
+  return 0;
+}
+
+static const Expr *
+getNewIterEndFromLoopDirective(const OMPExecutableDirective *ED) {
+  if (const OMPForDirective *D = dyn_cast<OMPForDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPParallelForDirective *D = dyn_cast<OMPParallelForDirective>(
+      ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPParallelForSimdDirective *D = dyn_cast<
+      OMPParallelForSimdDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPSimdDirective *D = dyn_cast<OMPSimdDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPForSimdDirective *D = dyn_cast<OMPForSimdDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPDistributeDirective *D = dyn_cast<OMPDistributeDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPDistributeSimdDirective *D =
+      dyn_cast<OMPDistributeSimdDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPDistributeParallelForDirective *D = dyn_cast<
+      OMPDistributeParallelForDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPDistributeParallelForSimdDirective *D = dyn_cast<
+      OMPDistributeParallelForSimdDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPTargetTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPTargetTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPTeamsDistributeDirective *D =
+          dyn_cast<OMPTeamsDistributeDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPTeamsDistributeSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeSimdDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPTargetTeamsDistributeDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  if (const OMPTargetTeamsDistributeSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeSimdDirective>(ED)) {
+    return D->getNewIterEnd();
+  }
+  assert(0 && "bad loop directive");
+  return 0;
+}
+
+static const Expr *
+getLowerBoundFromLoopDirective(const OMPExecutableDirective *ED) {
+  if (const OMPDistributeParallelForDirective *D = dyn_cast<
+      OMPDistributeParallelForDirective>(ED)) {
+    return D->getLowerBound();
+  }
+  if (const OMPDistributeParallelForSimdDirective *D = dyn_cast<
+      OMPDistributeParallelForSimdDirective>(ED)) {
+    return D->getLowerBound();
+  }
+  if (const OMPTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForDirective>(ED)) {
+    return D->getLowerBound();
+  }
+  if (const OMPTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getLowerBound();
+  }
+  if (const OMPTargetTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForDirective>(ED)) {
+    return D->getLowerBound();
+  }
+  if (const OMPTargetTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getLowerBound();
+  }
+  assert(0 && "bad loop directive");
+  return 0;
+}
+
+static const Expr *
+getUpperBoundFromLoopDirective(const OMPExecutableDirective *ED) {
+  if (const OMPDistributeParallelForDirective *D = dyn_cast<
+      OMPDistributeParallelForDirective>(ED)) {
+    return D->getUpperBound();
+  }
+  if (const OMPDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPDistributeParallelForSimdDirective>(ED)) {
+    return D->getUpperBound();
+  }
+  if (const OMPTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForDirective>(ED)) {
+    return D->getUpperBound();
+  }
+  if (const OMPTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getUpperBound();
+  }
+  if (const OMPTargetTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForDirective>(ED)) {
+    return D->getUpperBound();
+  }
+  if (const OMPTargetTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getUpperBound();
+  }
+  assert(0 && "bad loop directive");
+  return 0;
+}
+
+static const ArrayRef<Expr *> getCountersFromLoopDirective(
+    const OMPExecutableDirective *ED) {
+  if (const OMPForDirective *D = dyn_cast<OMPForDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPParallelForDirective *D = dyn_cast<OMPParallelForDirective>(
+      ED)) {
+    return D->getCounters();
+  }
+  if (const OMPParallelForSimdDirective *D = dyn_cast<
+      OMPParallelForSimdDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPSimdDirective *D = dyn_cast<OMPSimdDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPForSimdDirective *D = dyn_cast<OMPForSimdDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPDistributeDirective *D = dyn_cast<OMPDistributeDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPDistributeSimdDirective *D =
+      dyn_cast<OMPDistributeSimdDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPDistributeParallelForDirective *D = dyn_cast<
+      OMPDistributeParallelForDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPDistributeParallelForSimdDirective *D = dyn_cast<
+      OMPDistributeParallelForSimdDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPTargetTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPTargetTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPTeamsDistributeDirective *D =
+          dyn_cast<OMPTeamsDistributeDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPTeamsDistributeSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeSimdDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPTargetTeamsDistributeDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeDirective>(ED)) {
+    return D->getCounters();
+  }
+  if (const OMPTargetTeamsDistributeSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeSimdDirective>(ED)) {
+    return D->getCounters();
+  }
+  assert(0 && "bad loop directive");
+  return 0;
+}
+
+static unsigned getCollapsedNumberFromLoopDirective(
+    const OMPExecutableDirective *ED) {
+  if (const OMPForDirective *D = dyn_cast<OMPForDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPParallelForDirective *D = dyn_cast<OMPParallelForDirective>(
+      ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPParallelForSimdDirective *D = dyn_cast<
+      OMPParallelForSimdDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPSimdDirective *D = dyn_cast<OMPSimdDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPForSimdDirective *D = dyn_cast<OMPForSimdDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPDistributeDirective *D = dyn_cast<OMPDistributeDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPDistributeSimdDirective *D =
+      dyn_cast<OMPDistributeSimdDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPDistributeParallelForDirective *D = dyn_cast<
+      OMPDistributeParallelForDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPDistributeParallelForSimdDirective *D = dyn_cast<
+      OMPDistributeParallelForSimdDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPTargetTeamsDistributeParallelForDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPTargetTeamsDistributeParallelForSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeParallelForSimdDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPTeamsDistributeDirective *D =
+          dyn_cast<OMPTeamsDistributeDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPTeamsDistributeSimdDirective *D =
+          dyn_cast<OMPTeamsDistributeSimdDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPTargetTeamsDistributeDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  if (const OMPTargetTeamsDistributeSimdDirective *D =
+          dyn_cast<OMPTargetTeamsDistributeSimdDirective>(ED)) {
+    return D->getCollapsedNumber();
+  }
+  assert(0 && "bad loop directive");
+  return 0;
+}
+
+static bool IsAllowedClause(OpenMPClauseKind CKind,
+                            ArrayRef<OpenMPDirectiveKind> DKinds) {
+  for (ArrayRef<OpenMPDirectiveKind>::const_iterator I = DKinds.begin(),
+                                                     E = DKinds.end();
+       I != E; ++I) {
+    if (isAllowedClauseForDirective(*I, CKind))
+      return true;
+  }
+  return false;
+}
+}
+
+#define OPENMPRTL_FUNC(name) CGM.getOpenMPRuntime().Get_##name()
+#define OPENMPRTL_ATOMIC_FUNC(QTy, Op) CGM.getOpenMPRuntime().GetAtomicFunc(*this, QTy, Op)
+#define OPENMPRTL_ATOMIC_FUNC_GENERAL(QTyRes, QTyIn, Aop, Capture, Reverse)    \
+    CGM.getOpenMPRuntime().GetAtomicFuncGeneral(*this, QTyRes, QTyIn, Aop, Capture, Reverse)
+#define OPENMPRTL_ATOMICTYPE(CGF, QTy) \
+    CGM.getOpenMPRuntime().GetAtomicType(CGF, QTy)
+#define OPENMPRTL_LOC(SLoc, CGF)    \
+    CGM.getOpenMPRuntime().CreateIntelOpenMPRTLLoc(SLoc, CGF)
+#define OPENMPRTL_LOCFLAGS(SLoc, CGF, Flags)    \
+    CGM.getOpenMPRuntime().CreateIntelOpenMPRTLLoc(SLoc, CGF, Flags)
+#define OPENMPRTL_THREADNUM(SLoc, CGF)    \
+    CGM.getOpenMPRuntime().CreateOpenMPGlobalThreadNum(SLoc, CGF)
+#define OPENMPRTL_THREADPVTCACHED(VD, Loc, CGF, NoCast) \
+    CGM.getOpenMPRuntime().CreateOpenMPThreadPrivateCached(VD,Loc,CGF,NoCast)
+#define OPENMPRTL_DINFOTY \
+    CGM.getOpenMPRuntime().getKMPDependInfoType()
+
+static void EmitCancelArgs(CodeGenFunction &CGF,
+    OpenMPDirectiveKind ConstructType, SourceLocation SLoc, llvm::Value *&Loc,
+    llvm::Value *&GTid, llvm::Value *&Kind) {
+  Loc = CGF.OPENMPRTL_LOC(SLoc, CGF);
+  GTid = CGF.OPENMPRTL_THREADNUM(SLoc, CGF);
+  int CKind = KMP_CANCEL_NOREQ;
+  switch (ConstructType) {
+  case OMPD_parallel:
+    CKind = KMP_CANCEL_PARALLEL;
+    break;
+  case OMPD_for:
+    CKind = KMP_CANCEL_LOOP;
+    break;
+  case OMPD_sections:
+    CKind = KMP_CANCEL_SECTIONS;
+    break;
+  case OMPD_taskgroup:
+    CKind = KMP_CANCEL_TASKGROUP;
+    break;
+  default:
+    llvm_unreachable("Unknown construct type in cancel directive");
+    break;
+  }
+  Kind = CGF.Builder.getInt32(CKind);
+}
+
+static void EmitCancellationPoint(
+    CodeGenFunction &CGF, SourceLocation Loc, ArrayRef<llvm::Value *> Args,
+    llvm::BasicBlock *ExitBB, llvm::BasicBlock *ContBB,
+    CodeGenFunction::JumpDest FinalBB = CodeGenFunction::JumpDest()) {
+  CodeGenModule &CGM = CGF.CGM;
+  llvm::Value *CallRes = CGF.Builder.CreateIsNotNull(
+      CGF.EmitRuntimeCall(OPENMPRTL_FUNC(cancellationpoint), Args));
+  CGF.Builder.CreateCondBr(CallRes, ExitBB, ContBB);
+  if (FinalBB.isValid()) {
+    CGF.EmitBlock(ExitBB);
+    CGF.EmitOMPCancelBarrier(Loc, KMP_IDENT_BARRIER_IMPL, true);
+    CGF.EmitBranchThroughCleanup(FinalBB);
+    CGF.EmitBlock(ContBB);
+  }
+}
+
+namespace {
+/// \brief RAII object that save current insert position and then restores it.
+class BuilderInsertPositionRAII {
+  CGBuilderTy &Builder;
+  CGBuilderTy::InsertPoint SavedIP;
+
+public:
+  BuilderInsertPositionRAII(CGBuilderTy &Builder,
+      llvm::Instruction *NewInsertPoint) :
+      Builder(Builder), SavedIP(Builder.saveIP()) {
+    assert(SavedIP.isSet() && "No insertion point is set!");
+    Builder.SetInsertPoint(NewInsertPoint);
+  }
+  ~BuilderInsertPositionRAII() {
+    Builder.restoreIP(SavedIP);
+  }
+};
+
+/// \brief RAII object for OpenMP region.
+class OpenMPRegionRAII {
+  CodeGenFunction &CGF;
+
+public:
+  OpenMPRegionRAII(CodeGenFunction &CGF, llvm::Value *Context,
+      const CapturedStmt &CS) :
+      CGF(CGF) {
+    CGF.InitOpenMPFunction(Context, CS);
+  }
+  // Version without context to be used for target region, which take the input data
+  // directly from the function arguments
+  OpenMPRegionRAII(CodeGenFunction &CGF, const CapturedStmt &CS) :
+      CGF(CGF) {
+    CGF.InitOpenMPTargetFunction(CS);
+  }
+  ~OpenMPRegionRAII() {
+    delete CGF.CapturedStmtInfo;
+  }
+};
+
+static void SetFirstprivateInsertPt(CodeGenFunction &CGF) {
+  if (CGF.FirstprivateInsertPt) {
+    llvm::Instruction *Ptr = CGF.FirstprivateInsertPt;
+    CGF.FirstprivateInsertPt = 0;
+    Ptr->eraseFromParent();
+  }
+  llvm::Value *Undef = llvm::UndefValue::get(CGF.Int32Ty);
+  CGF.FirstprivateInsertPt = new llvm::BitCastInst(Undef, CGF.Int32Ty, "",
+      CGF.Builder.GetInsertBlock());
+
+}
+
+static void EmitFirstprivateInsert(CodeGenFunction &CGF, SourceLocation Loc) {
+  if (CGF.FirstprivateInsertPt) {
+    BuilderInsertPositionRAII PosRAII(CGF.Builder, CGF.FirstprivateInsertPt);
+    CGF.EmitOMPBarrier(Loc, KMP_IDENT_BARRIER_IMPL);
+  }
+}
+}
+
+static llvm::GlobalVariable *CreateRuntimeVariable(CodeGenModule &CGM,
+    StringRef MangledName, llvm::Type *Ty) {
+  llvm::PointerType *PtrTy = llvm::PointerType::getUnqual(Ty);
+  unsigned AddrSpace = PtrTy->getAddressSpace();
+  return new llvm::GlobalVariable(CGM.getModule(), Ty, false,
+      llvm::GlobalValue::PrivateLinkage, llvm::Constant::getNullValue(Ty),
+      MangledName, 0, llvm::GlobalVariable::NotThreadLocal, AddrSpace);
+}
+
+void CodeGenFunction::EmitOMPBarrier(SourceLocation L, unsigned Flags) {
+  EmitOMPCallWithLocAndTidHelper(OPENMPRTL_FUNC(barrier), L, Flags);
+}
+
+void CodeGenFunction::EmitOMPCancelBarrier(SourceLocation L, unsigned Flags,
+    bool IgnoreResult) {
+  if (OMPCancelMap.empty()) {
+    EmitOMPBarrier(L, Flags);
+  } else {
+    llvm::Value *CallRes = EmitOMPCallWithLocAndTidHelper(
+        OPENMPRTL_FUNC(cancel_barrier), L, Flags);
+    if (!IgnoreResult) {
+      JumpDest FinalBB;
+      if (OMPCancelMap.count(OMPD_for))
+        FinalBB = OMPCancelMap[OMPD_for];
+      else if (OMPCancelMap.count(OMPD_sections))
+        FinalBB = OMPCancelMap[OMPD_sections];
+      else if (OMPCancelMap.count(OMPD_parallel))
+        FinalBB = OMPCancelMap[OMPD_parallel];
+      else
+        FinalBB = OMPCancelMap[OMPD_taskgroup];
+
+      llvm::BasicBlock *ExitBB = createBasicBlock("omp.cancel_barrier.exit");
+      llvm::BasicBlock *ContBB = createBasicBlock(
+          "omp.cancel_barrier.continue");
+      llvm::Value *Cond = Builder.CreateIsNotNull(CallRes);
+      Builder.CreateCondBr(Cond, ExitBB, ContBB);
+      EmitBlock(ExitBB);
+      EmitBranchThroughCleanup(FinalBB);
+      EmitBlock(ContBB);
+    }
+  }
+}
+
+void CodeGenFunction::EmitOMPDirectiveWithParallel(
+    OpenMPDirectiveKind DKind, ArrayRef<OpenMPDirectiveKind> SKinds,
+    const OMPExecutableDirective &S) {
+  // Generate shared args for captured stmt.
+  CapturedStmt *CS = cast<CapturedStmt>(S.getAssociatedStmt());
+  llvm::Value *Arg = GenerateCapturedStmtArgument(*CS);
+
+  // Init list of private globals in the stack.
+  CGM.OpenMPSupport.startOpenMPRegion(true);
+  CGM.OpenMPSupport.setMergeable(false);
+  CGM.OpenMPSupport.setOrdered(false);
+  CGM.OpenMPSupport.setScheduleChunkSize(KMP_SCH_DEFAULT, 0);
+
+  // CodeGen for clauses (task init).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                       E = S.clauses().end();
+       I != E; ++I)
+    if (*I && !IsAllowedClause((*I)->getClauseKind(), SKinds))
+      EmitInitOMPClause(*(*I), S);
+
+  // CodeGen for clauses (task init).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                       E = S.clauses().end();
+       I != E; ++I)
+    if (*I && !IsAllowedClause((*I)->getClauseKind(), SKinds))
+      EmitAfterInitOMPClause(*(*I), S);
+
+  // Generate microtask.
+  // void .omp_microtask.(int32_t *, int32_t *, void */*AutoGenRecord **/arg3) {
+  //  captured_stmt(arg3);
+  // }
+  IdentifierInfo *Id = &getContext().Idents.get(".omp_microtask.");
+  QualType PtrIntTy = getContext().getPointerType(getContext().IntTy);
+  SmallVector<QualType, 4> FnArgTypes;
+  FnArgTypes.push_back(PtrIntTy);
+  FnArgTypes.push_back(PtrIntTy);
+  FnArgTypes.push_back(getContext().VoidPtrTy);
+  FunctionProtoType::ExtProtoInfo EPI;
+  EPI.ExceptionSpecType = EST_BasicNoexcept;
+  QualType FnTy = getContext().getFunctionType(getContext().VoidTy, FnArgTypes,
+      EPI);
+  TypeSourceInfo *TI = getContext().getTrivialTypeSourceInfo(FnTy,
+      SourceLocation());
+  FunctionDecl *FD = FunctionDecl::Create(getContext(),
+      getContext().getTranslationUnitDecl(), CS->getLocStart(),
+      SourceLocation(), Id, FnTy, TI, SC_Static, false, false, false);
+  TypeSourceInfo *PtrIntTI = getContext().getTrivialTypeSourceInfo(PtrIntTy,
+      SourceLocation());
+  TypeSourceInfo *PtrVoidTI = getContext().getTrivialTypeSourceInfo(
+      getContext().VoidPtrTy, SourceLocation());
+  ParmVarDecl *Arg1 = ParmVarDecl::Create(getContext(), FD, SourceLocation(),
+      SourceLocation(), 0, PtrIntTy, PtrIntTI, SC_Auto, 0);
+  ParmVarDecl *Arg2 = ParmVarDecl::Create(getContext(), FD, SourceLocation(),
+      SourceLocation(), 0, PtrIntTy, PtrIntTI, SC_Auto, 0);
+  ParmVarDecl *Arg3 = ParmVarDecl::Create(getContext(), FD, SourceLocation(),
+      SourceLocation(), 0, getContext().VoidPtrTy, PtrVoidTI, SC_Auto, 0);
+  CodeGenFunction CGF(CGM, true);
+  const CGFunctionInfo &FI = getTypes().arrangeFunctionDeclaration(FD);
+  llvm::Function *Fn = llvm::Function::Create(getTypes().GetFunctionType(FI),
+      llvm::GlobalValue::PrivateLinkage, FD->getName(), &CGM.getModule());
+  CGM.SetInternalFunctionAttributes(CurFuncDecl, Fn, FI);
+  FunctionArgList FnArgs;
+  FnArgs.push_back(Arg1);
+  FnArgs.push_back(Arg2);
+  FnArgs.push_back(Arg3);
+  CGF.OpenMPRoot = OpenMPRoot ? OpenMPRoot : this;
+  CGF.StartFunction(FD, getContext().VoidTy, Fn, FI, FnArgs, SourceLocation());
+
+  CGF.OMPCancelMap[OMPD_parallel] = CGF.ReturnBlock;
+
+  CGF.Builder.CreateLoad(CGF.GetAddrOfLocalVar(Arg1),
+      ".__kmpc_global_thread_num.");
+
+  // Emit call to the helper function.
+  llvm::Value *Arg3Val = CGF.Builder.CreateLoad(CGF.GetAddrOfLocalVar(Arg3),
+      "arg3");
+  QualType QTy = getContext().getRecordType(CS->getCapturedRecordDecl());
+  llvm::Type *ConvertedType =
+      CGF.getTypes().ConvertTypeForMem(QTy)->getPointerTo();
+  llvm::Value *RecArg = CGF.Builder.CreatePointerCast(Arg3Val, ConvertedType,
+      "(anon)arg3");
+
+  // CodeGen for clauses (call start).
+  {
+    OpenMPRegionRAII OMPRegion(CGF, RecArg, *CS);
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                         E = S.clauses().end();
+         I != E; ++I)
+      if (*I && (!IsAllowedClause((*I)->getClauseKind(), SKinds) ||
+                 (*I)->getClauseKind() == OMPC_firstprivate))
+        CGF.EmitPreOMPClause(*(*I), S);
+
+    switch (DKind) {
+    case OMPD_parallel:
+      CGF.EmitStmt(CS->getCapturedStmt());
+      break;
+    case OMPD_parallel_sections:
+      CGF.EmitOMPSectionsDirective(DKind, OMPD_sections, S);
+      break;
+    case OMPD_parallel_for:
+      CGF.EmitOMPDirectiveWithLoop(DKind, OMPD_for, S);
+      break;
+    case OMPD_parallel_for_simd:
+      CGF.EmitOMPDirectiveWithLoop(DKind, OMPD_for_simd, S);
+      break;
+    default:
+      break;
+    }
+    CGF.EnsureInsertPoint();
+
+    // CodeGen for clauses (call end).
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                         E = S.clauses().end();
+         I != E; ++I)
+      if (*I && !IsAllowedClause((*I)->getClauseKind(), SKinds))
+        CGF.EmitPostOMPClause(*(*I), S);
+
+    // CodeGen for clauses (closing steps).
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                         E = S.clauses().end();
+         I != E; ++I)
+      if (*I && !IsAllowedClause((*I)->getClauseKind(), SKinds))
+        CGF.EmitCloseOMPClause(*(*I), S);
+  }
+
+  CGF.EnsureInsertPoint();
+  // Implicit barrier for simple parallel region only.
+  // Others (combined) directives already has implicit barriers.
+  if (DKind == OMPD_parallel) {
+    CGF.EmitOMPCancelBarrier(S.getLocEnd(), KMP_IDENT_BARRIER_IMPL);
+  }
+
+  EmitFirstprivateInsert(CGF, S.getLocStart());
+
+  CGF.FinishFunction();
+
+  // CodeGen for "omp parallel {Associated statement}".
+  {
+    RunCleanupsScope MainBlock(*this);
+
+    llvm::Value *Loc = OPENMPRTL_LOC(S.getLocStart(), *this);
+    llvm::Type *KmpcMicroTy =
+        llvm::TypeBuilder<kmpc_micro, false>::get(getLLVMContext());
+    llvm::Value *RealArgs[] = {
+        Loc, Builder.getInt32(2),
+        CGF.Builder.CreateBitCast(Fn, KmpcMicroTy, "(kmpc_micro_ty)helper"),
+        Builder.CreateBitCast(Arg, CGM.VoidPtrTy)};
+    // __kmpc_fork_call(&loc, argc/*2*/, microtask, arg);
+    EmitRuntimeCall(OPENMPRTL_FUNC(fork_call), makeArrayRef(RealArgs));
+  }
+
+  // CodeGen for clauses (task finalize).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                       E = S.clauses().end();
+       I != E; ++I)
+    if (*I && !IsAllowedClause((*I)->getClauseKind(), SKinds))
+      EmitFinalOMPClause(*(*I), S);
+
+  // Remove list of private globals from the stack.
+  CGM.OpenMPSupport.endOpenMPRegion();
+}
+
+/// Generate an instructions for '#pragma omp parallel' directive.
+void CodeGenFunction::EmitOMPParallelDirective(const OMPParallelDirective &S) {
+  EmitOMPDirectiveWithParallel(OMPD_parallel, OMPD_unknown, S);
+}
+
+/// Generate an instructions for '#pragma omp parallel for' directive.
+void CodeGenFunction::EmitOMPParallelForDirective(
+    const OMPParallelForDirective &S) {
+  EmitOMPDirectiveWithParallel(OMPD_parallel_for, OMPD_for, S);
+}
+
+/// Generate an instructions for '#pragma omp parallel for simd' directive.
+void CodeGenFunction::EmitOMPParallelForSimdDirective(
+    const OMPParallelForSimdDirective &S) {
+  EmitOMPDirectiveWithParallel(OMPD_parallel_for_simd, OMPD_for_simd, S);
+}
+
+/// Generate an instructions for '#pragma omp parallel sections' directive.
+void CodeGenFunction::EmitOMPParallelSectionsDirective(
+    const OMPParallelSectionsDirective &S) {
+  EmitOMPDirectiveWithParallel(OMPD_parallel_sections, OMPD_sections, S);
+}
+
+/// Generate instruction for OpenMP loop-like directives.
+void CodeGenFunction::EmitOMPDirectiveWithLoop(OpenMPDirectiveKind DKind,
+    OpenMPDirectiveKind SKind, const OMPExecutableDirective &S) {
+
+  // Several Simd-specific vars are declared here.
+  // OMPD_distribute_parallel_for_simd is not included because it separates to
+  // OMPD_distribute and OMPD_parallel_for_simd directives intentionally and
+  // HasSimd is processed for OMPD_parallel_for_simd part.
+  bool HasSimd = DKind == OMPD_parallel_for_simd || DKind == OMPD_for_simd ||
+                 DKind == OMPD_distribute_simd ||
+                 DKind == OMPD_teams_distribute_simd ||
+                 DKind == OMPD_target_teams_distribute_simd;
+  CGPragmaOmpSimd SimdWrapper(&S);
+  llvm::Function *BodyFunction = 0;
+  bool SeparateLastIter = false;
+  LValue CapStruct;
+
+  // Init list of private globals in the stack.
+  CGM.OpenMPSupport.startOpenMPRegion(false);
+  CGM.OpenMPSupport.setNoWait(false);
+  CGM.OpenMPSupport.setMergeable(true);
+  CGM.OpenMPSupport.setOrdered(false);
+
+  // CodeGen for clauses (task init).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+      S.clauses().end(); I != E; ++I)
+    if (*I && isAllowedClauseForDirective(SKind, (*I)->getClauseKind()))
+      EmitInitOMPClause(*(*I), S);
+
+  // CodeGen for clauses (task init).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+      S.clauses().end(); I != E; ++I)
+    if (*I && isAllowedClauseForDirective(SKind, (*I)->getClauseKind()))
+      EmitAfterInitOMPClause(*(*I), S);
+
+  bool IsDistributeLoop = DKind == OMPD_distribute ||
+                          DKind == OMPD_distribute_simd ||
+                          DKind == OMPD_distribute_parallel_for ||
+                          DKind == OMPD_distribute_parallel_for_simd ||
+                          DKind == OMPD_teams_distribute_parallel_for ||
+                          DKind == OMPD_teams_distribute_parallel_for_simd ||
+                          DKind == OMPD_target_teams_distribute_parallel_for ||
+                          DKind == OMPD_target_teams_distribute_parallel_for_simd ||
+                          DKind == OMPD_teams_distribute ||
+                          DKind == OMPD_teams_distribute_simd ||
+                          DKind == OMPD_target_teams_distribute ||
+                          DKind == OMPD_target_teams_distribute_simd;
+  int Schedule = KMP_SCH_DEFAULT;
+  if (!IsDistributeLoop) {
+    bool Ordered = CGM.OpenMPSupport.getOrdered();
+    bool Merge = CGM.OpenMPSupport.getMergeable();
+    int Offset = 0;
+    if (Ordered && Merge)
+      Offset = SCH_ORD;
+    else if (!Ordered && !Merge)
+      Offset = SCH_NM;
+    else if (Ordered && !Merge)
+      Offset = SCH_NM_ORD;
+    Schedule += Offset;
+  } else {
+    Schedule = KMP_SCH_DISTRIBUTE_STATIC;
+  }
+  CGM.OpenMPSupport.setScheduleChunkSize(Schedule, 0);
+
+  {
+    RunCleanupsScope ExecutedScope(*this);
+    // CodeGen for clauses (call start).
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                         E = S.clauses().end();
+         I != E; ++I)
+      if (*I && isAllowedClauseForDirective(SKind, (*I)->getClauseKind()))
+        EmitPreOMPClause(*(*I), S);
+
+    const Expr *ChunkSize;
+    CGM.OpenMPSupport.getScheduleChunkSize(Schedule, ChunkSize);
+    OpenMPDirectiveKind Kind = S.getDirectiveKind();
+    bool IsComplexParallelLoop =
+        Kind == OMPD_distribute_parallel_for ||
+        Kind == OMPD_distribute_parallel_for_simd ||
+        Kind == OMPD_teams_distribute_parallel_for ||
+        Kind == OMPD_teams_distribute_parallel_for_simd ||
+        Kind == OMPD_target_teams_distribute_parallel_for ||
+        Kind == OMPD_target_teams_distribute_parallel_for_simd;
+    bool IsInnerLoopGen = IsComplexParallelLoop && DKind != Kind;
+    bool IsStaticSchedule = Schedule == KMP_SCH_STATIC_CHUNKED ||
+                            Schedule == KMP_SCH_STATIC ||
+                            Schedule == KMP_SCH_DISTRIBUTE_STATIC_CHUNKED ||
+                            Schedule == KMP_SCH_DISTRIBUTE_STATIC;
+    // CodeGen for "omp for {Associated statement}".
+    {
+      llvm::Value *Loc = OPENMPRTL_LOC(S.getLocStart(), *this);
+      llvm::Value *GTid =
+          OPENMPRTL_THREADNUM(S.getLocStart(), *this);
+      const Expr *IterVar = getNewIterVarFromLoopDirective(&S);
+      QualType QTy = IterVar->getType();
+      uint64_t TypeSize = 32;
+      if (getContext().getTypeSize(QTy) > TypeSize)
+        TypeSize = 64;
+      bool isSigned = true;
+      if (QTy->hasUnsignedIntegerRepresentation())
+        isSigned = false;
+      llvm::Type *VarTy = TypeSize == 32 ? Int32Ty : Int64Ty;
+      llvm::Value *LB = 0;
+      llvm::Value *UB = 0;
+      llvm::Value *GlobalUB = 0;
+      // Generate loop for inner 'for' directive
+      if (IsInnerLoopGen) {
+        LB = EmitScalarExpr(getLowerBoundFromLoopDirective(&S));
+        UB = EmitScalarExpr(getUpperBoundFromLoopDirective(&S));
+      } else {
+        LB = llvm::Constant::getNullValue(VarTy);
+        UB = EmitScalarExpr(getNewIterEndFromLoopDirective(&S));
+      }
+      GlobalUB = UB;
+#ifdef DEBUG
+      llvm::AllocaInst *DebugUB = CreateMemTemp(
+          getNewIterEndFromLoopDirective(&S)->getType(), "debug.ub");
+      Builder.CreateStore(UB, DebugUB);
+#endif
+      UB = Builder.CreateIntCast(UB, VarTy, isSigned);
+      llvm::Value *Chunk;
+      if (ChunkSize) {
+        Chunk = EmitScalarExpr(ChunkSize);
+        Chunk = Builder.CreateIntCast(Chunk, VarTy, true);
+      } else {
+        Chunk = llvm::Constant::getNullValue(VarTy);
+      }
+      llvm::BasicBlock *EndBB = createBasicBlock("omp.loop.end");
+      llvm::BasicBlock *OMPLoopBB = 0; // createBasicBlock("omp.loop.begin");
+      llvm::AllocaInst *PLast = CreateTempAlloca(Int32Ty, "last");
+      PLast->setAlignment(CGM.getDataLayout().getPrefTypeAlignment(Int32Ty));
+      InitTempAlloca(PLast, IsStaticSchedule ? Builder.getInt32(1)
+                                             : Builder.getInt32(0));
+      llvm::AllocaInst *PLB = CreateTempAlloca(VarTy, "lb");
+      PLB->setAlignment(CGM.getDataLayout().getPrefTypeAlignment(VarTy));
+      Builder.CreateStore(LB, PLB);
+      llvm::AllocaInst *PUB = CreateTempAlloca(VarTy, "ub");
+      PUB->setAlignment(CGM.getDataLayout().getPrefTypeAlignment(VarTy));
+      Builder.CreateStore(UB, PUB);
+      llvm::AllocaInst *PSt = CreateTempAlloca(VarTy, "st");
+      PSt->setAlignment(CGM.getDataLayout().getPrefTypeAlignment(VarTy));
+      InitTempAlloca(PSt, TypeSize == 32 ? Builder.getInt32(1)
+                                         : Builder.getInt64(1));
+      llvm::AllocaInst *Private = CreateMemTemp(QTy, ".idx.");
+      llvm::Type *IdxTy =
+          cast<llvm::PointerType>(Private->getType())->getElementType();
+      llvm::BasicBlock *MainBB;
+      llvm::BasicBlock *FiniBB = 0;
+
+      const Stmt *Body = S.getAssociatedStmt();
+      ArrayRef<Expr *> Arr = getCountersFromLoopDirective(&S);
+      if (const CapturedStmt *CS = dyn_cast_or_null<CapturedStmt>(Body))
+        Body = CS->getCapturedStmt();
+      for (unsigned I = 0; I < getCollapsedNumberFromLoopDirective(&S); ++I) {
+        const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(Arr[I])->getDecl());
+        bool SkippedContainers = false;
+        while (!SkippedContainers) {
+          if (const AttributedStmt *AS = dyn_cast_or_null<AttributedStmt>(Body))
+            Body = AS->getSubStmt();
+          else if (const CompoundStmt *CS =
+                       dyn_cast_or_null<CompoundStmt>(Body)) {
+            if (CS->size() != 1) {
+              SkippedContainers = true;
+            } else {
+              Body = CS->body_back();
+            }
+          } else
+            SkippedContainers = true;
+        }
+        const ForStmt *For = dyn_cast_or_null<ForStmt>(Body);
+        Body = For->getBody();
+        if (CGM.OpenMPSupport.getTopOpenMPPrivateVar(VD))
+          continue;
+        QualType QTy = Arr[I]->getType();
+        llvm::AllocaInst *Private =
+            CreateMemTemp(QTy, CGM.getMangledName(VD) + ".private.");
+        CGM.OpenMPSupport.addOpenMPPrivateVar(VD, Private);
+      }
+      while (const CapturedStmt *CS = dyn_cast_or_null<CapturedStmt>(Body))
+        Body = CS->getCapturedStmt();
+      const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(IterVar)->getDecl());
+      CGM.OpenMPSupport.addOpenMPPrivateVar(VD, Private);
+
+      if (IsStaticSchedule) {
+        llvm::Value *RealArgs[] = {
+            Loc,
+            GTid,
+            Builder.getInt32(Schedule),
+            PLast,
+            PLB,
+            PUB,
+            PSt,
+            TypeSize == 32 ? Builder.getInt32(1) : Builder.getInt64(1),
+            Chunk};
+        if (TypeSize == 32 && isSigned)
+          EmitRuntimeCall(OPENMPRTL_FUNC(for_static_init_4), RealArgs);
+        else if (TypeSize == 32 && !isSigned)
+          EmitRuntimeCall(OPENMPRTL_FUNC(for_static_init_4u), RealArgs);
+        else if (TypeSize == 64 && isSigned)
+          EmitRuntimeCall(OPENMPRTL_FUNC(for_static_init_8), RealArgs);
+        else
+          EmitRuntimeCall(OPENMPRTL_FUNC(for_static_init_8u), RealArgs);
+        OMPLoopBB = createBasicBlock("omp.loop.begin");
+        EmitBlock(OMPLoopBB);
+        LB = Builder.CreateLoad(PLB);
+        Builder.CreateStore(LB, Private);
+        UB = Builder.CreateLoad(PUB);
+        llvm::Value *Cond = Builder.CreateICmp(
+            isSigned ? llvm::CmpInst::ICMP_SLT : llvm::CmpInst::ICMP_ULT, UB,
+            GlobalUB);
+        UB = Builder.CreateSelect(Cond, UB, GlobalUB);
+        Builder.CreateStore(UB, PUB);
+        MainBB = createBasicBlock("omp.loop.main");
+        FiniBB = createBasicBlock("omp.loop.fini");
+      } else {
+        llvm::IntegerType *SchedTy =
+            llvm::TypeBuilder<sched_type, false>::get(getLLVMContext());
+        llvm::Value *RealArgs[] = {
+            Loc,
+            GTid,
+            llvm::ConstantInt::get(SchedTy, Schedule),
+            LB,
+            UB,
+            TypeSize == 32 ? Builder.getInt32(1) : Builder.getInt64(1),
+            Chunk};
+        // __kmpc_dispatch_init{4, 8}(&loc, gtid, sched_type, lb, ub, st,
+        // chunk);
+        if (TypeSize == 32 && isSigned)
+          EmitRuntimeCall(OPENMPRTL_FUNC(dispatch_init_4), RealArgs);
+        else if (TypeSize == 32 && !isSigned)
+          EmitRuntimeCall(OPENMPRTL_FUNC(dispatch_init_4u), RealArgs);
+        else if (TypeSize == 64 && isSigned)
+          EmitRuntimeCall(OPENMPRTL_FUNC(dispatch_init_8), RealArgs);
+        else
+          EmitRuntimeCall(OPENMPRTL_FUNC(dispatch_init_8u), RealArgs);
+        llvm::Value *RealArgsNext[] = {Loc, GTid, PLast, PLB, PUB, PSt};
+        OMPLoopBB = createBasicBlock("omp.loop.begin");
+        EmitBlock(OMPLoopBB);
+        llvm::Value *CallRes;
+        if (TypeSize == 32 && isSigned)
+          CallRes =
+              EmitRuntimeCall(OPENMPRTL_FUNC(dispatch_next_4), RealArgsNext);
+        else if (TypeSize == 32 && !isSigned)
+          CallRes =
+              EmitRuntimeCall(OPENMPRTL_FUNC(dispatch_next_4u), RealArgsNext);
+        else if (TypeSize == 64 && isSigned)
+          CallRes =
+              EmitRuntimeCall(OPENMPRTL_FUNC(dispatch_next_8), RealArgsNext);
+        else
+          CallRes =
+              EmitRuntimeCall(OPENMPRTL_FUNC(dispatch_next_8u), RealArgsNext);
+        llvm::BasicBlock *OMPInitBB = createBasicBlock("omp.loop.init");
+        llvm::SwitchInst *Switch = Builder.CreateSwitch(
+            Builder.CreateIntCast(CallRes, Int32Ty, false), EndBB, 1);
+        Switch->addCase(llvm::ConstantInt::get(Int32Ty, 1), OMPInitBB);
+        EmitBranch(OMPInitBB);
+        EmitBlock(OMPInitBB);
+        LB = Builder.CreateLoad(PLB);
+        UB = Builder.CreateLoad(PUB);
+        Builder.CreateStore(LB, Private);
+        MainBB = createBasicBlock("omp.loop.main");
+        FiniBB = createBasicBlock("omp.loop.fini");
+      }
+      if (HasSimd) {
+        // Update vectorizer width on the loop stack.
+        SeparateLastIter = SimdWrapper.emitSafelen(this);
+
+        if (SeparateLastIter) {
+          // Emit the following for the lastprivate vars update:
+          //   --UB;
+          // It is unclear if putting it under "if (*PLast)" will be
+          // more or less efficient, this needs to be investigated.
+          UB = Builder.CreateSub(UB, llvm::ConstantInt::get(UB->getType(), 1));
+          Builder.CreateStore(UB, PUB);
+        }
+
+        // Initialize the captured struct.
+        CapStruct = InitCapturedStruct(*SimdWrapper.getAssociatedStmt());
+      }
+
+      EmitBranch(MainBB);
+      EmitBlock(MainBB);
+
+      if (IsStaticSchedule) {
+        llvm::Value *Cond = Builder.CreateICmp(
+            isSigned ? llvm::CmpInst::ICMP_SLE : llvm::CmpInst::ICMP_ULE, LB,
+            GlobalUB);
+        llvm::BasicBlock *ContBB = createBasicBlock("omp.lb.le.global_ub.");
+        Builder.CreateCondBr(Cond, ContBB, EndBB);
+        EmitBlock(ContBB);
+      }
+
+      if (HasSimd) {
+        // Push current LoopInfo onto the LoopStack.
+        LoopStack.Push(MainBB);
+      }
+
+      {
+        RunCleanupsScope ThenScope(*this);
+        EmitStmt(getInitFromLoopDirective(&S));
+#ifdef DEBUG
+        // CodeGen for clauses (call start).
+        for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                             E = S.clauses().end();
+             I != E; ++I)
+          if (const OMPLastPrivateClause *Clause =
+                  dyn_cast_or_null<OMPLastPrivateClause>(*I)) {
+            for (OMPLastPrivateClause::varlist_const_iterator
+                     I1 = Clause->varlist_begin(),
+                     E1 = Clause->varlist_end();
+                 I1 != E1; ++I1) {
+              const VarDecl *VD =
+                  cast<VarDecl>(cast<DeclRefExpr>(*I1)->getDecl());
+              if (VD->getName() == "IDX")
+                CGM.OpenMPSupport.addOpenMPPrivateVar(VD, Private);
+              else if (VD->getName() == "UB")
+                CGM.OpenMPSupport.addOpenMPPrivateVar(VD, DebugUB);
+              else if (VD->getName() == "LUB")
+                CGM.OpenMPSupport.addOpenMPPrivateVar(VD, PUB);
+              else if (VD->getName() == "LLB")
+                CGM.OpenMPSupport.addOpenMPPrivateVar(VD, PLB);
+            }
+          }
+#endif
+        llvm::Value *Idx = Builder.CreateLoad(Private, ".idx.");
+        llvm::BasicBlock *UBLBCheckBB =
+            createBasicBlock("omp.lb_ub.check_pass");
+        UB = Builder.CreateLoad(PUB);
+        llvm::Value *UBLBCheck =
+            isSigned ? Builder.CreateICmpSLE(Idx, UB, "omp.idx.le.ub")
+                     : Builder.CreateICmpULE(Idx, UB, "omp.idx.le.ub");
+        // llvm::BasicBlock *PrevBB = Builder.GetInsertBlock();
+        Builder.CreateCondBr(UBLBCheck, UBLBCheckBB, FiniBB);
+        EmitBlock(UBLBCheckBB);
+        llvm::BasicBlock *ContBlock = createBasicBlock("omp.cont.block");
+
+        BreakContinueStack.push_back(
+            BreakContinue(getJumpDestInCurrentScope(EndBB),
+                          getJumpDestInCurrentScope(ContBlock)));
+        if (HasSimd) {
+          RunCleanupsScope Scope(*this);
+          BodyFunction = EmitSimdFunction(SimdWrapper);
+          EmitSIMDForHelperCall(BodyFunction, CapStruct, Private, false);
+        } else {
+          RunCleanupsScope Scope(*this);
+          if (IsInnerLoopGen || !IsComplexParallelLoop) {
+            if (SKind == OMPD_for)
+              OMPCancelMap[OMPD_for] = getJumpDestInCurrentScope(EndBB);
+            EmitStmt(Body);
+            OMPCancelMap.erase(OMPD_for);
+          } else {
+            const Expr *LowerBound = getLowerBoundFromLoopDirective(&S);
+            const Expr *UpperBound = getUpperBoundFromLoopDirective(&S);
+            EmitStoreOfScalar(Builder.CreateLoad(PLB), EmitLValue(LowerBound));
+            EmitStoreOfScalar(Builder.CreateLoad(PUB), EmitLValue(UpperBound));
+            // Special codegen for distribute parallel for [simd] constructs
+            if (Kind == OMPD_distribute_parallel_for ||
+                Kind == OMPD_teams_distribute_parallel_for ||
+                Kind == OMPD_target_teams_distribute_parallel_for)
+              EmitOMPDirectiveWithParallel(OMPD_parallel_for, OMPD_for, S);
+            else if (Kind == OMPD_distribute_parallel_for_simd ||
+                     Kind == OMPD_teams_distribute_parallel_for_simd ||
+                     Kind == OMPD_target_teams_distribute_parallel_for_simd)
+              EmitOMPDirectiveWithParallel(OMPD_parallel_for_simd,
+                                           OMPD_for_simd, S);
+          }
+        }
+        BreakContinueStack.pop_back();
+        EnsureInsertPoint();
+        EmitBranch(ContBlock);
+        EmitBlock(ContBlock);
+        Idx = Builder.CreateLoad(Private, ".idx.");
+        llvm::Value *NextIdx = Builder.CreateAdd(
+            Idx, llvm::ConstantInt::get(IdxTy, 1), ".next.idx.", false,
+            QTy->isSignedIntegerOrEnumerationType());
+        Builder.CreateStore(NextIdx, Private);
+        if (!IsStaticSchedule && CGM.OpenMPSupport.getOrdered()) {
+          // Emit _dispatch_fini for ordered loops
+          llvm::Value *RealArgsFini[] = {Loc, GTid};
+          if (TypeSize == 32 && isSigned)
+            EmitRuntimeCall(OPENMPRTL_FUNC(dispatch_fini_4), RealArgsFini);
+          else if (TypeSize == 32 && !isSigned)
+            EmitRuntimeCall(OPENMPRTL_FUNC(dispatch_fini_4u), RealArgsFini);
+          else if (TypeSize == 64 && isSigned)
+            EmitRuntimeCall(OPENMPRTL_FUNC(dispatch_fini_8), RealArgsFini);
+          else
+            EmitRuntimeCall(OPENMPRTL_FUNC(dispatch_fini_8u), RealArgsFini);
+        }
+
+        //      for(llvm::SmallVector<const Expr *, 16>::const_iterator II =
+        // Incs.begin(),
+        //                                                              EE =
+        // Incs.end();
+        //          II != EE; ++II) {
+        //        EmitIgnoredExpr(*II);
+        //        EnsureInsertPoint();
+        //      }
+        EmitBranch(MainBB);
+        if (HasSimd) {
+          LoopStack.Pop();
+        }
+        EmitBlock(FiniBB);
+        if (IsStaticSchedule && ChunkSize != 0) {
+          llvm::Value *St = Builder.CreateLoad(PSt);
+          LB = Builder.CreateLoad(PLB);
+          LB = Builder.CreateAdd(LB, St);
+          Builder.CreateStore(LB, PLB);
+          UB = Builder.CreateLoad(PUB);
+          UB = Builder.CreateAdd(UB, St);
+          Builder.CreateStore(UB, PUB);
+        }
+        if (SeparateLastIter) {
+          // Emit the following for the lastprivate vars update:
+          //   call __simd_helper(cs, idx, 1)
+          //
+          EmitSIMDForHelperCall(BodyFunction, CapStruct, Private, true);
+        }
+        EmitBranch(!IsStaticSchedule || ChunkSize != 0 ? OMPLoopBB : EndBB);
+        // EmitStmt(getInitFromLoopDirective(&S));
+        // EnsureInsertPoint();
+        // UBLBCheck = isSigned ?
+        //                     Builder.CreateICmpSLE(NextIdx, UB,
+        // "omp.idx.le.ub")
+        // :
+        //                     Builder.CreateICmpULE(NextIdx, UB,
+        // "omp.idx.le.ub");
+        // PrevBB = Builder.GetInsertBlock();
+        // Builder.CreateCondBr(UBLBCheck, UBLBCheckBB, OMPLoopBB);
+      }
+      EmitBlock(EndBB, true);
+      if (IsStaticSchedule) {
+        llvm::Value *RealArgsFini[] = {Loc, GTid};
+        EmitRuntimeCall(OPENMPRTL_FUNC(for_static_fini), RealArgsFini);
+      }
+      CGM.OpenMPSupport.setLastIterVar(PLast);
+    }
+
+    if (!IsDistributeLoop &&
+        (CGM.OpenMPSupport.hasLastPrivate() || !CGM.OpenMPSupport.getNoWait()))
+      EmitOMPCancelBarrier(S.getLocEnd(), KMP_IDENT_BARRIER_IMPL_FOR);
+    // CodeGen for clauses (call end).
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                         E = S.clauses().end();
+         I != E; ++I)
+      if (*I && isAllowedClauseForDirective(SKind, (*I)->getClauseKind()))
+        EmitPostOMPClause(*(*I), S);
+  }
+
+  // CodeGen for clauses (closing steps).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+      S.clauses().end(); I != E; ++I)
+    if (*I && isAllowedClauseForDirective(SKind, (*I)->getClauseKind()))
+      EmitCloseOMPClause(*(*I), S);
+
+  // CodeGen for clauses (task finalize).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+      S.clauses().end(); I != E; ++I)
+    if (*I && isAllowedClauseForDirective(SKind, (*I)->getClauseKind()))
+      EmitFinalOMPClause(*(*I), S);
+
+  EnsureInsertPoint();
+
+  // Remove list of private globals from the stack.
+  CGM.OpenMPSupport.endOpenMPRegion();
+
+  if (HasSimd) {
+    // Emit the final values of 'linear' variables.
+    SimdWrapper.emitLinearFinal(*this);
+  }
+}
+
+/// Generate an instructions for '#pragma omp for' directive.
+void CodeGenFunction::EmitOMPForDirective(const OMPForDirective &S) {
+  EmitOMPDirectiveWithLoop(OMPD_for, OMPD_for, S);
+}
+
+/// Generate an instructions for '#pragma omp distribute' directive.
+void CodeGenFunction::EmitOMPDistributeDirective(
+    const OMPDistributeDirective &S) {
+  CGM.OpenMPSupport.setDistribute(true);
+  EmitOMPDirectiveWithLoop(OMPD_distribute, OMPD_distribute, S);
+}
+
+/// Generate an instructions for directive with 'teams' region.
+void
+CodeGenFunction::EmitOMPDirectiveWithTeams(OpenMPDirectiveKind DKind,
+                                           ArrayRef<OpenMPDirectiveKind> SKinds,
+                                           const OMPExecutableDirective &S) {
+
+  // Generate shared args for captured stmt.
+  CapturedStmt *CS = cast<CapturedStmt>(S.getAssociatedStmt());
+  llvm::Value *Arg = GenerateCapturedStmtArgument(*CS);
+
+  // Init list of private globals in the stack.
+  CGM.OpenMPSupport.startOpenMPRegion(true);
+  CGM.OpenMPSupport.setMergeable(false);
+  CGM.OpenMPSupport.setOrdered(false);
+  CGM.OpenMPSupport.setNoWait(true);
+  CGM.OpenMPSupport.setScheduleChunkSize(KMP_SCH_DEFAULT, 0);
+
+  // CodeGen for clauses (task init).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                       E = S.clauses().end();
+       I != E; ++I)
+    if (*I && !IsAllowedClause((*I)->getClauseKind(), SKinds))
+      EmitInitOMPClause(*(*I), S);
+  llvm::Value *NumTeams = CGM.OpenMPSupport.getNumTeams();
+  llvm::Value *ThreadLimit = CGM.OpenMPSupport.getThreadLimit();
+  if (NumTeams && ThreadLimit) {
+    // __kmpc_push_num_teams(&loc, global_tid, num_threads, thread_limit);
+    // ident_t loc = {...};
+    llvm::Value *Loc = OPENMPRTL_LOC(S.getLocStart(), *this);
+    // global_tid = __kmpc_global_thread_num(...);
+    llvm::Value *GTid = OPENMPRTL_THREADNUM(S.getLocStart(), *this);
+    llvm::Value *RealArgs[] = {Loc, GTid,
+                               NumTeams ? NumTeams : Builder.getInt32(0),
+                               ThreadLimit ? ThreadLimit : Builder.getInt32(0)};
+    EmitRuntimeCall(OPENMPRTL_FUNC(push_num_teams), RealArgs);
+  }
+
+  // CodeGen for clauses (task init).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                       E = S.clauses().end();
+       I != E; ++I)
+    if (*I && !IsAllowedClause((*I)->getClauseKind(), SKinds))
+      EmitAfterInitOMPClause(*(*I), S);
+
+  // Generate microtask.
+  // void .omp_microtask.(int32_t *, int32_t *, void */*AutoGenRecord **/arg3) {
+  //  captured_stmt(arg3);
+  // }
+  IdentifierInfo *Id = &getContext().Idents.get(".omp_microtask.");
+  QualType PtrIntTy = getContext().getPointerType(getContext().IntTy);
+  SmallVector<QualType, 4> FnArgTypes;
+  FnArgTypes.push_back(PtrIntTy);
+  FnArgTypes.push_back(PtrIntTy);
+  FnArgTypes.push_back(getContext().VoidPtrTy);
+  FunctionProtoType::ExtProtoInfo EPI;
+  EPI.ExceptionSpecType = EST_BasicNoexcept;
+  QualType FnTy =
+      getContext().getFunctionType(getContext().VoidTy, FnArgTypes, EPI);
+  TypeSourceInfo *TI =
+      getContext().getTrivialTypeSourceInfo(FnTy, SourceLocation());
+  FunctionDecl *FD = FunctionDecl::Create(
+      getContext(), getContext().getTranslationUnitDecl(), CS->getLocStart(),
+      SourceLocation(), Id, FnTy, TI, SC_Static, false, false, false);
+  TypeSourceInfo *PtrIntTI =
+      getContext().getTrivialTypeSourceInfo(PtrIntTy, SourceLocation());
+  TypeSourceInfo *PtrVoidTI = getContext().getTrivialTypeSourceInfo(
+      getContext().VoidPtrTy, SourceLocation());
+  ParmVarDecl *Arg1 =
+      ParmVarDecl::Create(getContext(), FD, SourceLocation(), SourceLocation(),
+                          0, PtrIntTy, PtrIntTI, SC_Auto, 0);
+  ParmVarDecl *Arg2 =
+      ParmVarDecl::Create(getContext(), FD, SourceLocation(), SourceLocation(),
+                          0, PtrIntTy, PtrIntTI, SC_Auto, 0);
+  ParmVarDecl *Arg3 =
+      ParmVarDecl::Create(getContext(), FD, SourceLocation(), SourceLocation(),
+                          0, getContext().VoidPtrTy, PtrVoidTI, SC_Auto, 0);
+  CodeGenFunction CGF(CGM, true);
+  const CGFunctionInfo &FI = getTypes().arrangeFunctionDeclaration(FD);
+  llvm::Function *Fn = llvm::Function::Create(getTypes().GetFunctionType(FI),
+                                              llvm::GlobalValue::PrivateLinkage,
+                                              FD->getName(), &CGM.getModule());
+  CGM.SetInternalFunctionAttributes(CurFuncDecl, Fn, FI);
+  llvm::AttributeSet Set = CurFn->getAttributes();
+  for (unsigned i = 0; i < Set.getNumSlots(); ++i) {
+    if (Set.getSlotIndex(i) == llvm::AttributeSet::FunctionIndex) {
+      for (llvm::AttributeSet::iterator I = Set.begin(i), E = Set.end(i);
+           I != E; ++I) {
+        if (I->isStringAttribute() && I->getKindAsString().startswith("INTEL:"))
+          Fn->addFnAttr(I->getKindAsString());
+      }
+    }
+  }
+ FunctionArgList FnArgs;
+  FnArgs.push_back(Arg1);
+  FnArgs.push_back(Arg2);
+  FnArgs.push_back(Arg3);
+  CGF.OpenMPRoot = OpenMPRoot ? OpenMPRoot : this;
+  CGF.StartFunction(FD, getContext().VoidTy, Fn, FI, FnArgs, SourceLocation());
+  CGF.Builder.CreateLoad(CGF.GetAddrOfLocalVar(Arg1),
+                         ".__kmpc_global_thread_num.");
+
+  // Emit call to the helper function.
+  llvm::Value *Arg3Val =
+      CGF.Builder.CreateLoad(CGF.GetAddrOfLocalVar(Arg3), "arg3");
+  QualType QTy = getContext().getRecordType(CS->getCapturedRecordDecl());
+  llvm::Type *ConvertedType =
+      CGF.getTypes().ConvertTypeForMem(QTy)->getPointerTo();
+  llvm::Value *RecArg =
+      CGF.Builder.CreatePointerCast(Arg3Val, ConvertedType, "(anon)arg3");
+
+  // CodeGen for clauses (call start).
+  {
+    OpenMPRegionRAII OMPRegion(CGF, RecArg, *CS);
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                         E = S.clauses().end();
+         I != E; ++I)
+      if (*I && !IsAllowedClause((*I)->getClauseKind(), SKinds))
+        CGF.EmitPreOMPClause(*(*I), S);
+
+    switch (DKind) {
+    case OMPD_target_teams:
+    case OMPD_teams:
+      CGF.EmitStmt(CS->getCapturedStmt());
+      break;
+    case OMPD_teams_distribute:
+    case OMPD_target_teams_distribute:
+      EmitOMPDirectiveWithLoop(OMPD_teams_distribute, OMPD_distribute, S);
+      break;
+    case OMPD_teams_distribute_simd:
+    case OMPD_target_teams_distribute_simd:
+      EmitOMPDirectiveWithLoop(OMPD_teams_distribute_simd, OMPD_distribute_simd,
+                               S);
+      break;
+    case OMPD_teams_distribute_parallel_for: {
+      const OMPTeamsDistributeParallelForDirective &D =
+          cast<OMPTeamsDistributeParallelForDirective>(S);
+      assert(D.getLowerBound() && "No lower bound");
+      assert(D.getUpperBound() && "No upper bound");
+      EmitAutoVarDecl(
+          *cast<VarDecl>(cast<DeclRefExpr>(D.getLowerBound())->getDecl()));
+      EmitAutoVarDecl(
+          *cast<VarDecl>(cast<DeclRefExpr>(D.getUpperBound())->getDecl()));
+      EmitOMPDirectiveWithLoop(OMPD_teams_distribute_parallel_for,
+                               OMPD_distribute, S);
+      break;
+    }
+    case OMPD_teams_distribute_parallel_for_simd: {
+      const OMPTeamsDistributeParallelForSimdDirective &D =
+          cast<OMPTeamsDistributeParallelForSimdDirective>(S);
+      assert(D.getLowerBound() && "No lower bound");
+      assert(D.getUpperBound() && "No upper bound");
+      EmitAutoVarDecl(
+          *cast<VarDecl>(cast<DeclRefExpr>(D.getLowerBound())->getDecl()));
+      EmitAutoVarDecl(
+          *cast<VarDecl>(cast<DeclRefExpr>(D.getUpperBound())->getDecl()));
+      EmitOMPDirectiveWithLoop(OMPD_teams_distribute_parallel_for_simd,
+                               OMPD_distribute, S);
+      break;
+    }
+    case OMPD_target_teams_distribute_parallel_for: {
+      const OMPTargetTeamsDistributeParallelForDirective &D =
+          cast<OMPTargetTeamsDistributeParallelForDirective>(S);
+      assert(D.getLowerBound() && "No lower bound");
+      assert(D.getUpperBound() && "No upper bound");
+      EmitAutoVarDecl(
+          *cast<VarDecl>(cast<DeclRefExpr>(D.getLowerBound())->getDecl()));
+      EmitAutoVarDecl(
+          *cast<VarDecl>(cast<DeclRefExpr>(D.getUpperBound())->getDecl()));
+      EmitOMPDirectiveWithLoop(OMPD_target_teams_distribute_parallel_for,
+                               OMPD_distribute, S);
+      break;
+    }
+    case OMPD_target_teams_distribute_parallel_for_simd: {
+      const OMPTargetTeamsDistributeParallelForSimdDirective &D =
+          cast<OMPTargetTeamsDistributeParallelForSimdDirective>(S);
+      assert(D.getLowerBound() && "No lower bound");
+      assert(D.getUpperBound() && "No upper bound");
+      EmitAutoVarDecl(
+          *cast<VarDecl>(cast<DeclRefExpr>(D.getLowerBound())->getDecl()));
+      EmitAutoVarDecl(
+          *cast<VarDecl>(cast<DeclRefExpr>(D.getUpperBound())->getDecl()));
+      EmitOMPDirectiveWithLoop(OMPD_target_teams_distribute_parallel_for_simd,
+                               OMPD_distribute, S);
+      break;
+    }
+    default:
+      break;
+    }
+    CGF.EnsureInsertPoint();
+
+    // CodeGen for clauses (call end).
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                         E = S.clauses().end();
+         I != E; ++I)
+      if (*I && !IsAllowedClause((*I)->getClauseKind(), SKinds))
+        CGF.EmitPostOMPClause(*(*I), S);
+
+    // CodeGen for clauses (closing steps).
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                         E = S.clauses().end();
+         I != E; ++I)
+      if (*I && !IsAllowedClause((*I)->getClauseKind(), SKinds))
+        CGF.EmitCloseOMPClause(*(*I), S);
+  }
+
+  CGF.FinishFunction();
+
+  // CodeGen for "omp parallel {Associated statement}".
+  {
+    RunCleanupsScope MainBlock(*this);
+
+    llvm::Value *Loc = OPENMPRTL_LOC(S.getLocStart(), *this);
+    llvm::Type *KmpcMicroTy =
+        llvm::TypeBuilder<kmpc_micro, false>::get(getLLVMContext());
+    llvm::Value *RealArgs[] = {
+        Loc, Builder.getInt32(2),
+        CGF.Builder.CreateBitCast(Fn, KmpcMicroTy, "(kmpc_micro_ty)helper"),
+        Arg};
+    // __kmpc_fork_teams(&loc, argc/*2*/, microtask, arg);
+    EmitRuntimeCall(OPENMPRTL_FUNC(fork_teams), makeArrayRef(RealArgs));
+  }
+
+  // CodeGen for clauses (task finalize).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                       E = S.clauses().end();
+       I != E; ++I)
+    if (*I && !IsAllowedClause((*I)->getClauseKind(), SKinds))
+      EmitFinalOMPClause(*(*I), S);
+
+  // Remove list of private globals from the stack.
+  CGM.OpenMPSupport.endOpenMPRegion();
+}
+
+
+
+static void EmitUntiedPartIdInc(CodeGenFunction &CGF) {
+  if (CGF.CGM.OpenMPSupport.getUntied()) {
+    llvm::Value *PartIdAddr;
+    llvm::Value *UntiedSwitch;
+    llvm::BasicBlock *UntiedEnd;
+    unsigned UntiedCounter;
+    CGF.CGM.OpenMPSupport.getUntiedData(PartIdAddr, UntiedSwitch, UntiedEnd,
+        UntiedCounter);
+    ++UntiedCounter;
+    CGF.Builder.CreateStore(CGF.Builder.getInt32(UntiedCounter), PartIdAddr);
+    CGF.CGM.OpenMPSupport.setUntiedData(PartIdAddr, UntiedSwitch, UntiedEnd,
+        UntiedCounter, &CGF);
+  }
+}
+
+static void EmitUntiedBranchEnd(CodeGenFunction &CGF) {
+  if (CGF.CGM.OpenMPSupport.getUntied()) {
+    llvm::Value *PartIdAddr;
+    llvm::Value *UntiedSwitch;
+    llvm::BasicBlock *UntiedEnd;
+    unsigned UntiedCounter;
+    CGF.CGM.OpenMPSupport.getUntiedData(PartIdAddr, UntiedSwitch, UntiedEnd,
+        UntiedCounter);
+    CGF.EmitBranch(UntiedEnd);
+  }
+}
+
+static void EmitUntiedTaskSwitch(CodeGenFunction &CGF, bool EmitBranch) {
+  if (CGF.CGM.OpenMPSupport.getUntied()) {
+    llvm::Value *PartIdAddr;
+    llvm::Value *UntiedSwitch;
+    llvm::BasicBlock *UntiedEnd;
+    unsigned UntiedCounter;
+    CGF.CGM.OpenMPSupport.getUntiedData(PartIdAddr, UntiedSwitch, UntiedEnd,
+        UntiedCounter);
+    llvm::BasicBlock *NextBlock = CGF.createBasicBlock("untied.sw.next");
+    cast<llvm::SwitchInst>(UntiedSwitch)->addCase(
+        CGF.Builder.getInt32(UntiedCounter), NextBlock);
+    if (EmitBranch)
+      CGF.EmitBranch(NextBlock);
+    CGF.EmitBlock(NextBlock);
+  }
+}
+
+static std::pair<llvm::Value *, unsigned> ProcessDependAddresses(
+    CodeGenFunction &CGF, const OMPTaskDirective &S) {
+  CodeGenModule &CGM = CGF.CGM;
+
+  llvm::Value *DependenceAddresses = 0;
+  unsigned ArraySize = 0;
+
+  SmallVector<const OMPDependClause *, 16> DependClauses;
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+      S.clauses().end(); I != E; ++I) {
+    if (OMPDependClause *ODC = dyn_cast_or_null<OMPDependClause>(*I)) {
+      ArraySize += ODC->varlist_size();
+      DependClauses.push_back(ODC);
+    }
+  }
+  if (ArraySize > 0) {
+    llvm::Type *IntPtrTy = CGF.ConvertTypeForMem(
+        CGF.getContext().getIntPtrType());
+    llvm::Type *BoolTy = CGF.ConvertTypeForMem(CGF.getContext().BoolTy);
+    llvm::Type *DepTy = OPENMPRTL_DINFOTY;
+    llvm::ArrayType *DepListTy = llvm::ArrayType::get(DepTy, ArraySize);
+
+    llvm::AllocaInst *Addresses = CGF.CreateTempAlloca(DepListTy, ".dep.list.");
+    Addresses->setAlignment(CGM.OpenMPSupport.getKMPDependInfoTypeAlign());
+    DependenceAddresses = CGF.Builder.CreateConstInBoundsGEP2_32(Addresses, 0,
+        0);
+
+    unsigned FieldCounter = 0;
+    for (SmallVectorImpl<const OMPDependClause *>::iterator I =
+        DependClauses.begin(), E = DependClauses.end(); I != E; ++I) {
+      unsigned DepType = IN;
+      switch ((*I)->getType()) {
+      case OMPC_DEPEND_in:
+        DepType = IN;
+        break;
+      case OMPC_DEPEND_out:
+        DepType = OUT;
+        break;
+      case OMPC_DEPEND_inout:
+        DepType = INOUT;
+        break;
+      case OMPC_DEPEND_unknown:
+      case NUM_OPENMP_DEPENDENCE_TYPE:
+        llvm_unreachable("Unknown kind of dependency");
+        break;
+      }
+      for (unsigned i = 0, e = (*I)->varlist_size(); i < e;
+          ++i, ++FieldCounter) {
+        llvm::Value *DepElPtr = CGF.Builder.CreateConstInBoundsGEP2_32(
+            Addresses, 0, FieldCounter);
+        // [CounterVal].base_addr = &expr;
+        llvm::Value *DepBaseAddr = CGF.Builder.CreateConstGEP2_32(DepElPtr, 0,
+            0);
+        llvm::Value *BaseAddr =
+            CGF.EmitAnyExpr((*I)->getBegins(i)).getScalarVal();
+        BaseAddr = CGF.Builder.CreatePointerCast(BaseAddr, IntPtrTy);
+        CGF.Builder.CreateStore(BaseAddr, DepBaseAddr);
+        // [CounterVal].len = size;
+        llvm::Value *DepLen = CGF.Builder.CreateConstGEP2_32(DepElPtr, 0, 1);
+        const Expr *Size = (*I)->getSizeInBytes(i);
+        if (Size->getType()->isAnyPointerType()) {
+          // Size is not a size, but the ending pointer
+          // Calculate the real size
+          llvm::Value *EndAddr = CGF.EmitScalarExpr(Size);
+          llvm::Value *BaseVal = CGF.Builder.CreatePtrToInt(BaseAddr,
+              CGF.SizeTy);
+          llvm::Value *EndVal = CGF.Builder.CreatePtrToInt(EndAddr, CGF.SizeTy);
+          llvm::Value *Cond = CGF.Builder.CreateICmpUGT(EndVal, BaseVal);
+          llvm::Value *Res = CGF.Builder.CreateSelect(Cond,
+              CGF.Builder.CreateSub(EndVal, BaseVal),
+              llvm::Constant::getNullValue(CGF.SizeTy));
+          CGF.Builder.CreateStore(Res, DepLen);
+        } else {
+          CGF.Builder.CreateStore(CGF.EmitScalarExpr(Size), DepLen);
+        }
+        // [CounterVal].flags = size;
+        llvm::Value *DepFlags = CGF.Builder.CreateConstGEP2_32(DepElPtr, 0, 2);
+        CGF.Builder.CreateStore(llvm::ConstantInt::get(BoolTy, DepType),
+            DepFlags);
+      }
+    }
+  } else {
+    llvm::Type *DepTy = OPENMPRTL_DINFOTY;
+    DependenceAddresses = llvm::Constant::getNullValue(DepTy->getPointerTo());
+  }
+  return std::make_pair(DependenceAddresses, ArraySize);
+}
+
+/// Generate an instructions for '#pragma omp task' directive.
+void CodeGenFunction::EmitOMPTaskDirective(const OMPTaskDirective &S) {
+  // Generate shared args for captured stmt.
+  CapturedStmt *CS = cast<CapturedStmt>(S.getAssociatedStmt());
+  llvm::Value *Arg = GenerateCapturedStmtArgument(*CS);
+
+  // Init list of private globals in the stack.
+  CGM.OpenMPSupport.startOpenMPRegion(true);
+  CGM.OpenMPSupport.setMergeable(false);
+  CGM.OpenMPSupport.setOrdered(false);
+  CGM.OpenMPSupport.setUntied(false);
+  CGM.OpenMPSupport.setScheduleChunkSize(KMP_SCH_DEFAULT, 0);
+
+  RecordDecl *RD;
+  if (!getContext().getLangOpts().CPlusPlus)
+    RD = RecordDecl::Create(getContext(), TTK_Struct,
+        getContext().getTranslationUnitDecl(), SourceLocation(),
+        SourceLocation(), &getContext().Idents.get(".omp.task.priv."));
+  else
+    RD = CXXRecordDecl::Create(getContext(), TTK_Struct,
+        getContext().getTranslationUnitDecl(), SourceLocation(),
+        SourceLocation(), &getContext().Idents.get(".omp.task.priv."));
+  RD->startDefinition();
+  SmallVector<FieldDecl *, 16> FieldsWithDestructors;
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                       E = S.clauses().end();
+       I != E; ++I) {
+    if (OMPPrivateClause *C = dyn_cast_or_null<OMPPrivateClause>(*I)) {
+      for (OMPPrivateClause::varlist_const_iterator II = C->varlist_begin(),
+          EE = C->varlist_end(); II != EE; ++II) {
+        const ValueDecl *D = cast<DeclRefExpr>(*II)->getDecl();
+        FieldDecl *FD = FieldDecl::Create(getContext(), RD, SourceLocation(),
+            SourceLocation(), D->getIdentifier(), (*II)->getType(), 0, 0, false,
+            ICIS_NoInit);
+        FD->setAccess(AS_public);
+        RD->addDecl(FD);
+        CGM.OpenMPSupport.getTaskFields()[D] = FD;
+        QualType ASTType = D->getType();
+        if (CXXRecordDecl *RD =
+                ASTType->getBaseElementTypeUnsafe()->getAsCXXRecordDecl()) {
+          if (!RD->hasTrivialDestructor())
+            FieldsWithDestructors.push_back(FD);
+        }
+      }
+    } else if (OMPFirstPrivateClause *C =
+        dyn_cast_or_null<OMPFirstPrivateClause>(*I)) {
+      for (OMPFirstPrivateClause::varlist_const_iterator II =
+          C->varlist_begin(), EE = C->varlist_end(); II != EE; ++II) {
+        const ValueDecl *D = cast<DeclRefExpr>(*II)->getDecl();
+        FieldDecl *FD = FieldDecl::Create(getContext(), RD, SourceLocation(),
+            SourceLocation(), D->getIdentifier(), (*II)->getType(), 0, 0, false,
+            ICIS_NoInit);
+        FD->setAccess(AS_public);
+        RD->addDecl(FD);
+        CGM.OpenMPSupport.getTaskFields()[D] = FD;
+        QualType ASTType = D->getType();
+        if (CXXRecordDecl *RD =
+                ASTType->getBaseElementTypeUnsafe()->getAsCXXRecordDecl()) {
+          if (!RD->hasTrivialDestructor())
+            FieldsWithDestructors.push_back(FD);
+        }
+      }
+    }
+  }
+  RD->completeDefinition();
+  QualType PrivateRecord = getContext().getRecordType(RD);
+  llvm::Type *LPrivateTy = getTypes().ConvertTypeForMem(PrivateRecord);
+
+  llvm::Function *Destructors = 0;
+  if (!FieldsWithDestructors.empty()) {
+    IdentifierInfo *Id = &getContext().Idents.get(".omp_ptask_destructors.");
+    SmallVector<QualType, 2> FnArgTypes;
+    FnArgTypes.push_back(getContext().getIntTypeForBitwidth(32, 1));
+    FnArgTypes.push_back(getContext().VoidPtrTy);
+    FunctionProtoType::ExtProtoInfo EPI;
+    EPI.ExceptionSpecType = EST_BasicNoexcept;
+    QualType FnTy = getContext().getFunctionType(
+        getContext().getIntTypeForBitwidth(32, 1), FnArgTypes, EPI);
+    TypeSourceInfo *TI =
+        getContext().getTrivialTypeSourceInfo(FnTy, SourceLocation());
+    FunctionDecl *FD = FunctionDecl::Create(
+        getContext(), getContext().getTranslationUnitDecl(), CS->getLocStart(),
+        SourceLocation(), Id, FnTy, TI, SC_Static, false, false, false);
+    TypeSourceInfo *IntTI = getContext().getTrivialTypeSourceInfo(
+        getContext().getIntTypeForBitwidth(32, 1), SourceLocation());
+    TypeSourceInfo *PtrVoidTI = getContext().getTrivialTypeSourceInfo(
+        getContext().VoidPtrTy, SourceLocation());
+    ParmVarDecl *Arg1 = ParmVarDecl::Create(
+        getContext(), FD, SourceLocation(), SourceLocation(), 0,
+        getContext().getIntTypeForBitwidth(32, 1), IntTI, SC_Auto, 0);
+    ParmVarDecl *Arg2 = ParmVarDecl::Create(
+        getContext(), FD, SourceLocation(), SourceLocation(), 0,
+        getContext().VoidPtrTy, PtrVoidTI, SC_Auto, 0);
+    CodeGenFunction CGF(CGM);
+    const CGFunctionInfo &FI = getTypes().arrangeFunctionDeclaration(FD);
+    Destructors = llvm::Function::Create(getTypes().GetFunctionType(FI),
+                                         llvm::GlobalValue::PrivateLinkage,
+                                         FD->getName(), &CGM.getModule());
+    FunctionArgList FnArgs;
+    FnArgs.push_back(Arg1);
+    FnArgs.push_back(Arg2);
+    CGF.StartFunction(FD, getContext().getIntTypeForBitwidth(32, 1),
+                      Destructors, FI, FnArgs, SourceLocation());
+    llvm::Type *TaskTTy = llvm::TaskTBuilder::get(getLLVMContext());
+    llvm::Value *TaskTPtr = CGF.Builder.CreatePointerCast(
+        CGF.GetAddrOfLocalVar(Arg2), TaskTTy->getPointerTo()->getPointerTo());
+    // Emit call to the helper function.
+    llvm::Value *Locker =
+        CGF.Builder.CreateConstGEP1_32(CGF.Builder.CreateLoad(TaskTPtr), 1);
+    Locker = CGF.Builder.CreatePointerCast(Locker, LPrivateTy->getPointerTo());
+    for (ArrayRef<FieldDecl *>::iterator I = FieldsWithDestructors.begin(),
+                                         E = FieldsWithDestructors.end();
+         I != E; ++I) {
+      QualType ASTType = (*I)->getType();
+      if (CXXRecordDecl *RD =
+              ASTType->getBaseElementTypeUnsafe()->getAsCXXRecordDecl()) {
+        if (!RD->hasTrivialDestructor()) {
+          llvm::Value *Private =
+              CGF.EmitLValueForField(
+                      CGF.MakeNaturalAlignAddrLValue(Locker, PrivateRecord), *I)
+                  .getAddress();
+          QualType::DestructionKind DtorKind = ASTType.isDestructedType();
+          CGF.emitDestroy(Private, ASTType, CGF.getDestroyer(DtorKind),
+                          CGF.needsEHCleanup(DtorKind));
+        }
+      }
+    }
+    CGF.FinishFunction(SourceLocation());
+  }
+
+  //  llvm::Type *PTaskFnTy = llvm::TypeBuilder<kmp_routine_entry_t,
+  // false>::get(getLLVMContext());
+  //  llvm::AllocaInst *FnPtr = CreateTempAlloca(PTaskFnTy);
+  //  FnPtr->setAlignment(llvm::ConstantExpr::getAlignOf(PTaskFnTy));
+
+  // CodeGen for clauses (task init).
+  llvm::AllocaInst *Flags =
+      CreateMemTemp(getContext().getIntTypeForBitwidth(32, 1), ".flags.addr");
+  CGM.OpenMPSupport.setTaskFlags(Flags);
+
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+      S.clauses().end(); I != E; ++I)
+    if (*I)
+      EmitInitOMPClause(*(*I), S);
+
+  uint64_t InitFlags =
+      CGM.OpenMPSupport.getUntied() ? OMP_TASK_UNTIED : OMP_TASK_TIED;
+  if (Destructors) {
+    InitFlags |= OMP_TASK_DESTRUCTORS_THUNK;
+  }
+  InitTempAlloca(Flags, Builder.getInt32(InitFlags));
+
+  // Generate microtask.
+  // int32 .omp_ptask.(int32_t arg1, void */*kmp_task_t **/arg2) {
+  //  captured_stmt(arg2->shareds);
+  // }
+  IdentifierInfo *Id = &getContext().Idents.get(".omp_ptask.");
+  SmallVector<QualType, 2> FnArgTypes;
+  FnArgTypes.push_back(getContext().getIntTypeForBitwidth(32, 1));
+  FnArgTypes.push_back(getContext().VoidPtrTy);
+  FunctionProtoType::ExtProtoInfo EPI;
+  EPI.ExceptionSpecType = EST_BasicNoexcept;
+  QualType FnTy = getContext().getFunctionType(
+      getContext().getIntTypeForBitwidth(32, 1), FnArgTypes, EPI);
+  TypeSourceInfo *TI =
+      getContext().getTrivialTypeSourceInfo(FnTy, SourceLocation());
+  FunctionDecl *FD = FunctionDecl::Create(
+      getContext(), getContext().getTranslationUnitDecl(), CS->getLocStart(),
+      SourceLocation(), Id, FnTy, TI, SC_Static, false, false, false);
+  TypeSourceInfo *IntTI = getContext().getTrivialTypeSourceInfo(
+      getContext().getIntTypeForBitwidth(32, 1), SourceLocation());
+  TypeSourceInfo *PtrVoidTI = getContext().getTrivialTypeSourceInfo(
+      getContext().VoidPtrTy, SourceLocation());
+  ParmVarDecl *Arg1 = ParmVarDecl::Create(
+      getContext(), FD, SourceLocation(), SourceLocation(), 0,
+      getContext().getIntTypeForBitwidth(32, 1), IntTI, SC_Auto, 0);
+  ParmVarDecl *Arg2 =
+      ParmVarDecl::Create(getContext(), FD, SourceLocation(), SourceLocation(),
+                          0, getContext().VoidPtrTy, PtrVoidTI, SC_Auto, 0);
+  CodeGenFunction CGF(CGM, true);
+  const CGFunctionInfo &FI = getTypes().arrangeFunctionDeclaration(FD);
+  llvm::Function *Fn = llvm::Function::Create(getTypes().GetFunctionType(FI),
+      llvm::GlobalValue::PrivateLinkage, FD->getName(), &CGM.getModule());
+  CGM.SetInternalFunctionAttributes(CurFuncDecl, Fn, FI);
+  FunctionArgList FnArgs;
+  FnArgs.push_back(Arg1);
+  FnArgs.push_back(Arg2);
+  CGF.OpenMPRoot = OpenMPRoot ? OpenMPRoot : this;
+  CGF.StartFunction(FD, getContext().getIntTypeForBitwidth(32, 1), Fn, FI,
+                    FnArgs, SourceLocation());
+
+  CGF.OMPCancelMap[OMPD_taskgroup] = CGF.ReturnBlock;
+
+  llvm::AllocaInst *GTid = CGF.CreateMemTemp(
+      getContext().getIntTypeForBitwidth(32, 1), ".__kmpc_global_thread_num.");
+  CGF.EmitStoreOfScalar(CGF.Builder.CreateLoad(CGF.GetAddrOfLocalVar(Arg1)),
+                        MakeNaturalAlignAddrLValue(
+                            GTid, getContext().getIntTypeForBitwidth(32, 1)),
+                        false);
+  llvm::Type *TaskTTy = llvm::TaskTBuilder::get(getLLVMContext());
+  llvm::Value *TaskTPtr = CGF.Builder.CreatePointerCast(
+      CGF.GetAddrOfLocalVar(Arg2), TaskTTy->getPointerTo()->getPointerTo());
+
+  // Emit call to the helper function.
+  llvm::Value *Addr = CGF.Builder.CreateConstInBoundsGEP2_32(
+      CGF.Builder.CreateLoad(TaskTPtr, ".arg2.shareds"), 0,
+      llvm::TaskTBuilder::shareds, ".arg2.shareds.addr");
+  llvm::Value *Arg2Val = CGF.Builder.CreateLoad(Addr, ".arg2.shareds.");
+  QualType QTy = getContext().getRecordType(CS->getCapturedRecordDecl());
+  llvm::Type *ConvertedType =
+      CGF.getTypes().ConvertTypeForMem(QTy)->getPointerTo();
+  llvm::Value *RecArg = CGF.Builder.CreatePointerCast(Arg2Val, ConvertedType,
+      "(anon)shared");
+
+  llvm::Value *Locker = CGF.Builder.CreateConstGEP1_32(
+      CGF.Builder.CreateLoad(TaskTPtr), 1);
+  CGM.OpenMPSupport.setPTask(Fn, Arg2Val, LPrivateTy, PrivateRecord, Locker);
+
+  // CodeGen for clauses (call start).
+  {
+    OpenMPRegionRAII OMPRegion(CGF, RecArg, *CS);
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+        S.clauses().end(); I != E; ++I)
+      if (*I)
+        CGF.EmitPreOMPClause(*(*I), S);
+
+    llvm::BasicBlock *UntiedEnd = 0;
+    if (CGM.OpenMPSupport.getUntied()) {
+      llvm::Value *Addr = CGF.Builder.CreateConstInBoundsGEP2_32(
+          CGF.Builder.CreateLoad(TaskTPtr, ".arg2.part_id."), 0,
+          llvm::TaskTBuilder::part_id, ".part_id.addr");
+      llvm::Value *PartId = CGF.Builder.CreateLoad(Addr, ".part_id.");
+      UntiedEnd = CGF.createBasicBlock("untied.sw.end");
+      llvm::SwitchInst *UntiedSwitch = CGF.Builder.CreateSwitch(PartId,
+          UntiedEnd);
+      llvm::BasicBlock *InitBlock = CGF.createBasicBlock("untied.sw.init");
+      CGF.EmitBlock(InitBlock);
+      UntiedSwitch->addCase(CGF.Builder.getInt32(0), InitBlock);
+      CGM.OpenMPSupport.setUntiedData(Addr, UntiedSwitch, UntiedEnd, 0, &CGF);
+    }
+    CGF.EmitStmt(CS->getCapturedStmt());
+    CGF.EnsureInsertPoint();
+    if (UntiedEnd)
+      CGF.EmitBlock(UntiedEnd);
+
+    // CodeGen for clauses (call end).
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+        S.clauses().end(); I != E; ++I)
+      if (*I)
+        CGF.EmitPostOMPClause(*(*I), S);
+
+    // CodeGen for clauses (closing steps).
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+        S.clauses().end(); I != E; ++I)
+      if (*I)
+        CGF.EmitCloseOMPClause(*(*I), S);
+  }
+
+  CGF.FinishFunction();
+
+  llvm::DenseMap<const ValueDecl *, FieldDecl *> SavedFields =
+      CGM.OpenMPSupport.getTaskFields();
+  CGM.OpenMPSupport.endOpenMPRegion();
+
+  // CodeGen for 'depend' clause.
+  llvm::Value *DependenceAddresses = 0;
+  unsigned ArraySize = 0;
+  if (!CGM.OpenMPSupport.getUntied()) {
+    std::tie(DependenceAddresses, ArraySize) =
+        ProcessDependAddresses(*this, S);
+  }
+  // CodeGen for "omp task {Associated statement}".
+  CGM.OpenMPSupport.startOpenMPRegion(false);
+  CGM.OpenMPSupport.getTaskFields() = SavedFields;
+  {
+    RunCleanupsScope MainBlock(*this);
+
+    EmitUntiedPartIdInc(*this);
+
+    llvm::Value *Loc = OPENMPRTL_LOC(S.getLocStart(), *this);
+    llvm::Value *GTid = OPENMPRTL_THREADNUM(S.getLocStart(), *this);
+    llvm::Value *RealArgs[] = {
+        Loc, GTid, Builder.CreateLoad(Flags, ".flags."),
+        Builder.CreateAdd(
+            Builder.CreateIntCast(llvm::ConstantExpr::getSizeOf(TaskTTy),
+                                  SizeTy, false),
+            llvm::ConstantInt::get(
+                SizeTy,
+                getContext().getTypeSizeInChars(PrivateRecord).getQuantity())),
+        llvm::ConstantInt::get(
+            SizeTy, getContext().getTypeSizeInChars(QTy).getQuantity()),
+        Fn};
+    // kmpc_task_t val = __kmpc_omp_task_alloc(&loc, gtid, flags,
+    // sizeof(kmpc_task_t), sizeof(shareds), task_entry);
+    llvm::Value *TaskTVal = EmitRuntimeCall(OPENMPRTL_FUNC(omp_task_alloc),
+        makeArrayRef(RealArgs), ".task_t.val.addr");
+    llvm::Value *SharedAddr = Builder.CreateConstInBoundsGEP2_32(TaskTVal, 0,
+        llvm::TaskTBuilder::shareds, ".shared.addr");
+    EmitAggregateAssign(Builder.CreateLoad(SharedAddr), Arg, QTy);
+    if (Destructors) {
+      llvm::Value *DestructorsAddr = Builder.CreateConstInBoundsGEP2_32(
+          TaskTVal, 0, llvm::TaskTBuilder::destructors, ".destructors.addr");
+      Builder.CreateStore(Destructors, DestructorsAddr);
+    }
+    llvm::Value *Locker = Builder.CreateConstGEP1_32(TaskTVal, 1);
+    CGM.OpenMPSupport.setPTask(Fn, TaskTVal, LPrivateTy, PrivateRecord, Locker);
+    {
+      RunCleanupsScope ExecutedScope(*this);
+      // Skip firstprivate sync for tasks.
+      for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                           E = S.clauses().end();
+           I != E; ++I)
+        if (*I && (isa<OMPPrivateClause>(*I) || isa<OMPFirstPrivateClause>(*I)))
+          EmitPreOMPClause(*(*I), S);
+
+      for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                           E = S.clauses().end();
+           I != E; ++I)
+        if (*I)
+          EmitAfterInitOMPClause(*(*I), S);
+
+      if (CGM.OpenMPSupport.getUntied()) {
+        llvm::Value *RealArgs1[] = {Loc, GTid, TaskTVal};
+        llvm::Value *Res = EmitRuntimeCall(OPENMPRTL_FUNC(omp_task_parts),
+                                           RealArgs1, ".task.res.");
+        llvm::Value *Cond = Builder.CreateICmpEQ(
+            Res, Builder.getInt32(OMP_TASK_CURRENT_QUEUED));
+        llvm::BasicBlock *ThenBB = createBasicBlock("task.parts.then");
+        llvm::BasicBlock *EndBB = createBasicBlock("task.parts.end");
+        Builder.CreateCondBr(Cond, ThenBB, EndBB);
+        EmitBlock(ThenBB);
+        EmitUntiedBranchEnd(*this);
+        EmitBlock(EndBB, true);
+      } else {
+        llvm::Type *PtrDepTy = OPENMPRTL_DINFOTY->getPointerTo();
+        llvm::Value *RealArgs1[] = {Loc,
+                                    GTid,
+                                    TaskTVal,
+                                    llvm::ConstantInt::get(Int32Ty, ArraySize),
+                                    DependenceAddresses,
+                                    llvm::ConstantInt::get(Int32Ty, 0),
+                                    llvm::Constant::getNullValue(PtrDepTy)};
+        EmitRuntimeCall(OPENMPRTL_FUNC(omp_task_with_deps), RealArgs1,
+                        ".task.res.");
+        llvm::Value *WaitDepsArgs[] = {
+            Loc,
+            GTid,
+            llvm::ConstantInt::get(Int32Ty, ArraySize),
+            DependenceAddresses,
+            llvm::ConstantInt::get(Int32Ty, 0),
+            llvm::Constant::getNullValue(PtrDepTy)};
+        CGM.OpenMPSupport.setWaitDepsArgs(WaitDepsArgs);
+      }
+      EmitUntiedTaskSwitch(*this, true);
+    }
+  }
+
+  // CodeGen for clauses (task finalize).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+      S.clauses().end(); I != E; ++I)
+    if (*I)
+      EmitFinalOMPClause(*(*I), S);
+
+  // Remove list of private globals from the stack.
+  CGM.OpenMPSupport.endOpenMPRegion();
+}
+
+/// Generate an instructions for '#pragma omp sections' directive.
+void
+CodeGenFunction::EmitOMPSectionsDirective(OpenMPDirectiveKind,
+                                          OpenMPDirectiveKind SKind,
+                                          const OMPExecutableDirective &S) {
+  // Init list of private globals in the stack.
+  CGM.OpenMPSupport.startOpenMPRegion(false);
+  CGM.OpenMPSupport.setNoWait(false);
+  CGM.OpenMPSupport.setMergeable(true);
+  CGM.OpenMPSupport.setOrdered(false);
+
+  // Generate shared args for captured stmt.
+  // CapturedStmt *CS = cast<CapturedStmt>(S.getAssociatedStmt());
+  // llvm::Value *Arg = GenerateCapturedStmtArgument(*CS);
+
+  // CodeGen for clauses (task init).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+      S.clauses().end(); I != E; ++I)
+    if (*I && isAllowedClauseForDirective(SKind, (*I)->getClauseKind()))
+      EmitInitOMPClause(*(*I), S);
+
+  // CodeGen for clauses (task init).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+      S.clauses().end(); I != E; ++I)
+    if (*I && isAllowedClauseForDirective(SKind, (*I)->getClauseKind()))
+      EmitAfterInitOMPClause(*(*I), S);
+
+  int Schedule = KMP_SCH_DEFAULT;
+  bool Ordered = CGM.OpenMPSupport.getOrdered();
+  bool Merge = CGM.OpenMPSupport.getMergeable();
+  int Offset = 0;
+  if (Ordered && Merge)
+    Offset = SCH_ORD;
+  else if (!Ordered && !Merge)
+    Offset = SCH_NM;
+  else if (Ordered && !Merge)
+    Offset = SCH_NM_ORD;
+  Schedule += Offset;
+  CGM.OpenMPSupport.setScheduleChunkSize(Schedule, 0);
+
+  {
+    RunCleanupsScope ExecutedScope(*this);
+    // CodeGen for clauses (call start).
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                         E = S.clauses().end();
+         I != E; ++I)
+      if (*I && isAllowedClauseForDirective(SKind, (*I)->getClauseKind()))
+        EmitPreOMPClause(*(*I), S);
+
+    // CodeGen for "omp sections {Associated statement}".
+    // Calculate number of sections.
+    CompoundStmt *AStmt = cast<CompoundStmt>(
+        cast<CapturedStmt>(S.getAssociatedStmt())->getCapturedStmt());
+    unsigned NumberOfSections = AStmt->size() - 1;
+    llvm::Value *Loc = OPENMPRTL_LOC(S.getLocStart(), *this);
+    llvm::Value *GTid = OPENMPRTL_THREADNUM(S.getLocStart(), *this);
+    uint64_t TypeSize = getContext().getTypeSize(getContext().UnsignedIntTy);
+    llvm::IntegerType *UnsignedTy =
+        cast<llvm::IntegerType>(ConvertTypeForMem(getContext().UnsignedIntTy));
+    llvm::AllocaInst *IterVar =
+        CreateMemTemp(getContext().UnsignedIntTy, ".idx.addr");
+    InitTempAlloca(IterVar, llvm::Constant::getNullValue(UnsignedTy));
+    const Expr *ChunkSize;
+    CGM.OpenMPSupport.getScheduleChunkSize(Schedule, ChunkSize);
+    llvm::Value *Chunk;
+    if (ChunkSize) {
+      Chunk = EmitScalarExpr(ChunkSize);
+      Chunk = Builder.CreateIntCast(
+          Chunk, TypeSize == 32 ? Builder.getInt32Ty() : Builder.getInt64Ty(),
+          true);
+    } else {
+      Chunk = (TypeSize == 32) ? Builder.getInt32(0) : Builder.getInt64(0);
+    }
+    llvm::Value *UBVal = llvm::ConstantInt::get(UnsignedTy, NumberOfSections);
+    llvm::AllocaInst *PLast = CreateTempAlloca(Int32Ty, "last");
+    PLast->setAlignment(CGM.getDataLayout().getPrefTypeAlignment(Int32Ty));
+    InitTempAlloca(PLast, Builder.getInt32(0));
+    llvm::AllocaInst *PLB = CreateMemTemp(getContext().UnsignedIntTy, "lb");
+    InitTempAlloca(PLB, llvm::ConstantInt::get(UnsignedTy, 0));
+    llvm::AllocaInst *PUB = CreateMemTemp(getContext().UnsignedIntTy, "ub");
+    InitTempAlloca(PUB, UBVal);
+    llvm::AllocaInst *PSt = CreateMemTemp(getContext().UnsignedIntTy, "st");
+    InitTempAlloca(PSt, llvm::ConstantInt::get(UnsignedTy, 1));
+
+    llvm::Value *RealArgs[] = {
+        Loc,
+        GTid,
+        Builder.getInt32(Schedule),
+        PLast,
+        PLB,
+        PUB,
+        PSt,
+        TypeSize == 32 ? Builder.getInt32(1) : Builder.getInt64(1),
+        Chunk};
+    if (TypeSize == 32)
+      EmitRuntimeCall(OPENMPRTL_FUNC(for_static_init_4u), RealArgs);
+    else
+      EmitRuntimeCall(OPENMPRTL_FUNC(for_static_init_8u), RealArgs);
+
+    llvm::BasicBlock *OMPSectionsBB = createBasicBlock("omp.sections.begin");
+    EmitBranch(OMPSectionsBB);
+    EmitBlock(OMPSectionsBB);
+    llvm::Value *UB = Builder.CreateLoad(PUB);
+    llvm::Value *Cond = Builder.CreateICmpULT(UB, UBVal);
+    UB = Builder.CreateSelect(Cond, UB, UBVal);
+    Builder.CreateStore(UB, PUB);
+
+    llvm::BasicBlock *EndBB = createBasicBlock("omp.sections.end");
+    llvm::Value *LB = Builder.CreateLoad(PLB);
+    Builder.CreateStore(LB, IterVar);
+    llvm::BasicBlock *UBLBCheckBB = createBasicBlock("omp.lb_ub.check_pass");
+    llvm::Value *UBLBCheck = Builder.CreateICmpULE(LB, UB, "omp.lb.le.ub");
+    Builder.CreateCondBr(UBLBCheck, UBLBCheckBB, EndBB);
+    EmitBlock(UBLBCheckBB);
+
+    llvm::Value *Idx = Builder.CreateLoad(IterVar, ".idx.");
+    llvm::BasicBlock *SectionEndBB = createBasicBlock("omp.section.fini");
+    llvm::SwitchInst *SectionSwitch =
+        Builder.CreateSwitch(Idx, SectionEndBB, NumberOfSections + 1);
+    if (SKind == OMPD_sections)
+      OMPCancelMap[OMPD_sections] = getJumpDestInCurrentScope(EndBB);
+    CompoundStmt::const_body_iterator I = AStmt->body_begin();
+    for (unsigned i = 0; i <= NumberOfSections; ++i, ++I) {
+      RunCleanupsScope ThenScope(*this);
+      llvm::BasicBlock *SectionBB = createBasicBlock("omp.section");
+      SectionSwitch->addCase(llvm::ConstantInt::get(UnsignedTy, i), SectionBB);
+      EmitBlock(SectionBB);
+      EmitStmt(*I);
+      EnsureInsertPoint();
+      EmitBranch(SectionEndBB);
+    }
+    EmitBlock(SectionEndBB, true);
+    OMPCancelMap.erase(SKind);
+
+    llvm::Value *NextIdx = Builder.CreateAdd(
+        Idx, llvm::ConstantInt::get(UnsignedTy, 1), ".next.idx.");
+    Builder.CreateStore(NextIdx, IterVar);
+    UBLBCheck = Builder.CreateICmpULE(NextIdx, UB, "omp.idx.le.ub");
+    if (ChunkSize != 0) {
+      llvm::BasicBlock *OMPSectionsNB = createBasicBlock("omp.sections.next");
+      Builder.CreateCondBr(UBLBCheck, UBLBCheckBB, OMPSectionsNB);
+      EmitBlock(OMPSectionsNB);
+      llvm::Value *St = Builder.CreateLoad(PSt);
+      LB = Builder.CreateAdd(LB, St);
+      Builder.CreateStore(LB, PLB);
+      UB = Builder.CreateAdd(UB, St);
+      Builder.CreateStore(UB, PUB);
+      EmitBranch(OMPSectionsBB);
+    } else {
+      Builder.CreateCondBr(UBLBCheck, UBLBCheckBB, EndBB);
+    }
+    EmitBlock(EndBB);
+    llvm::Value *RealArgsFini[] = {Loc, GTid};
+    EmitRuntimeCall(OPENMPRTL_FUNC(for_static_fini), RealArgsFini);
+    CGM.OpenMPSupport.setLastIterVar(PLast);
+
+    if (CGM.OpenMPSupport.hasLastPrivate() || !CGM.OpenMPSupport.getNoWait())
+      EmitOMPCancelBarrier(S.getLocEnd(), KMP_IDENT_BARRIER_IMPL_SECTIONS);
+
+    // CodeGen for clauses (call end).
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(),
+                                         E = S.clauses().end();
+         I != E; ++I)
+      if (*I && isAllowedClauseForDirective(SKind, (*I)->getClauseKind()))
+        EmitPostOMPClause(*(*I), S);
+  }
+
+  // CodeGen for clauses (closing steps).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+      S.clauses().end(); I != E; ++I)
+    if (*I && isAllowedClauseForDirective(SKind, (*I)->getClauseKind()))
+      EmitCloseOMPClause(*(*I), S);
+
+  // CodeGen for clauses (task finalize).
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+      S.clauses().end(); I != E; ++I)
+    if (*I && isAllowedClauseForDirective(SKind, (*I)->getClauseKind()))
+      EmitFinalOMPClause(*(*I), S);
+
+  EnsureInsertPoint();
+
+  // Remove list of private globals from the stack.
+  CGM.OpenMPSupport.endOpenMPRegion();
+}
+
+/// Generate an instructions for '#pragma omp sections' directive.
+void CodeGenFunction::EmitOMPSectionsDirective(const OMPSectionsDirective &S) {
+  EmitOMPSectionsDirective(OMPD_sections, OMPD_sections, S);
+}
+
+/// Generate an instructions for '#pragma omp section' directive.
+void CodeGenFunction::EmitOMPSectionDirective(const OMPSectionDirective &S) {
+  EmitStmt(cast<CapturedStmt>(S.getAssociatedStmt())->getCapturedStmt());
+}
+
+void CodeGenFunction::EmitInitOMPClause(const OMPClause &C,
+    const OMPExecutableDirective &S) {
+  switch (C.getClauseKind()) {
+  default:
+    llvm_unreachable("Unknown clause kind!");
+  case OMPC_num_threads:
+    EmitInitOMPNumThreadsClause(cast<OMPNumThreadsClause>(C), S);
+    break;
+  case OMPC_num_teams:
+    EmitInitOMPNumTeamsClause(cast<OMPNumTeamsClause>(C), S);
+    break;
+  case OMPC_thread_limit:
+    EmitInitOMPThreadLimitClause(cast<OMPThreadLimitClause>(C), S);
+    break;
+  case OMPC_proc_bind:
+    EmitInitOMPProcBindClause(cast<OMPProcBindClause>(C), S);
+    break;
+  case OMPC_reduction:
+    EmitInitOMPReductionClause(cast<OMPReductionClause>(C), S);
+    break;
+  case OMPC_nowait:
+    EmitInitOMPNowaitClause(cast<OMPNowaitClause>(C), S);
+    break;
+  case OMPC_ordered:
+    EmitInitOMPOrderedClause(cast<OMPOrderedClause>(C), S);
+    break;
+  case OMPC_untied:
+    EmitInitOMPUntiedClause(cast<OMPUntiedClause>(C), S);
+    break;
+  case OMPC_final:
+    EmitInitOMPFinalClause(cast<OMPFinalClause>(C), S);
+    break;
+  case OMPC_mergeable:
+    EmitInitOMPMergeableClause(cast<OMPMergeableClause>(C), S);
+    break;
+  case OMPC_map:
+    EmitInitOMPMapClause(cast<OMPMapClause>(C), S);
+    break;
+  case OMPC_device:
+    EmitInitOMPDeviceClause(cast<OMPDeviceClause>(C), S);
+    break;
+  case OMPC_default:
+  case OMPC_schedule:
+  case OMPC_dist_schedule:
+  case OMPC_copyin:
+  case OMPC_copyprivate:
+  case OMPC_shared:
+  case OMPC_private:
+  case OMPC_firstprivate:
+  case OMPC_lastprivate:
+  case OMPC_collapse:
+  case OMPC_if:
+  case OMPC_read:
+  case OMPC_write:
+  case OMPC_capture:
+  case OMPC_update:
+  case OMPC_seq_cst:
+  case OMPC_depend:
+  case OMPC_linear:
+  case OMPC_aligned:
+  case OMPC_safelen:
+    break;
+  }
+}
+
+void CodeGenFunction::EmitAfterInitOMPClause(const OMPClause &C,
+    const OMPExecutableDirective &S) {
+  switch (C.getClauseKind()) {
+  default:
+    llvm_unreachable("Unknown clause kind!");
+  case OMPC_if:
+    EmitAfterInitOMPIfClause(cast<OMPIfClause>(C), S);
+    break;
+  case OMPC_map:
+  case OMPC_reduction:
+  case OMPC_nowait:
+  case OMPC_ordered:
+  case OMPC_untied:
+  case OMPC_final:
+  case OMPC_mergeable:
+  case OMPC_default:
+  case OMPC_proc_bind:
+  case OMPC_num_threads:
+  case OMPC_num_teams:
+  case OMPC_thread_limit:
+  case OMPC_schedule:
+  case OMPC_dist_schedule:
+  case OMPC_device:
+  case OMPC_copyin:
+  case OMPC_shared:
+  case OMPC_private:
+  case OMPC_firstprivate:
+  case OMPC_lastprivate:
+  case OMPC_collapse:
+  case OMPC_read:
+  case OMPC_write:
+  case OMPC_capture:
+  case OMPC_update:
+  case OMPC_seq_cst:
+  case OMPC_depend:
+  case OMPC_linear:
+  case OMPC_aligned:
+  case OMPC_safelen:
+    break;
+  }
+}
+
+void CodeGenFunction::EmitPreOMPClause(const OMPClause &C,
+    const OMPExecutableDirective &S) {
+  switch (C.getClauseKind()) {
+  default:
+    llvm_unreachable("Unknown clause kind!");
+  case OMPC_num_threads:
+  case OMPC_num_teams:
+  case OMPC_thread_limit:
+  case OMPC_device:
+  case OMPC_if:
+  case OMPC_default:
+  case OMPC_proc_bind:
+  case OMPC_shared:
+  case OMPC_collapse:
+  case OMPC_nowait:
+  case OMPC_ordered:
+  case OMPC_copyprivate:
+  case OMPC_untied:
+  case OMPC_final:
+  case OMPC_mergeable:
+  case OMPC_read:
+  case OMPC_write:
+  case OMPC_capture:
+  case OMPC_update:
+  case OMPC_seq_cst:
+  case OMPC_depend:
+  case OMPC_linear:
+  case OMPC_aligned:
+  case OMPC_safelen:
+  case OMPC_map:
+    break;
+  case OMPC_copyin:
+    EmitPreOMPCopyinClause(cast<OMPCopyinClause>(C), S);
+    break;
+  case OMPC_private:
+    EmitPreOMPPrivateClause(cast<OMPPrivateClause>(C), S);
+    break;
+  case OMPC_firstprivate:
+    EmitPreOMPFirstPrivateClause(cast<OMPFirstPrivateClause>(C), S);
+    break;
+  case OMPC_lastprivate:
+    EmitPreOMPLastPrivateClause(cast<OMPLastPrivateClause>(C), S);
+    break;
+  case OMPC_reduction:
+    EmitPreOMPReductionClause(cast<OMPReductionClause>(C), S);
+    break;
+  case OMPC_schedule:
+    EmitPreOMPScheduleClause(cast<OMPScheduleClause>(C), S);
+    break;
+  case OMPC_dist_schedule:
+    EmitPreOMPDistScheduleClause(cast<OMPDistScheduleClause>(C), S);
+    break;
+  }
+}
+
+void CodeGenFunction::EmitPostOMPClause(const OMPClause &C,
+    const OMPExecutableDirective &S) {
+  switch (C.getClauseKind()) {
+  default:
+    llvm_unreachable("Unknown clause kind!");
+  case OMPC_num_threads:
+  case OMPC_num_teams:
+  case OMPC_thread_limit:
+  case OMPC_device:
+  case OMPC_if:
+  case OMPC_copyin:
+  case OMPC_copyprivate:
+  case OMPC_default:
+  case OMPC_proc_bind:
+  case OMPC_shared:
+  case OMPC_collapse:
+  case OMPC_nowait:
+  case OMPC_ordered:
+  case OMPC_schedule:
+  case OMPC_dist_schedule:
+  case OMPC_untied:
+  case OMPC_final:
+  case OMPC_mergeable:
+  case OMPC_read:
+  case OMPC_write:
+  case OMPC_capture:
+  case OMPC_update:
+  case OMPC_seq_cst:
+  case OMPC_depend:
+  case OMPC_linear:
+  case OMPC_aligned:
+  case OMPC_safelen:
+  case OMPC_private:
+  case OMPC_firstprivate:
+  case OMPC_map:
+    break;
+  case OMPC_lastprivate:
+    EmitPostOMPLastPrivateClause(cast<OMPLastPrivateClause>(C), S);
+    break;
+  case OMPC_reduction:
+    EmitPostOMPReductionClause(cast<OMPReductionClause>(C), S);
+    break;
+  }
+}
+
+void CodeGenFunction::EmitCloseOMPClause(const OMPClause &C,
+    const OMPExecutableDirective &S) {
+  switch (C.getClauseKind()) {
+  default:
+    llvm_unreachable("Unknown clause kind!");
+  case OMPC_num_threads:
+  case OMPC_num_teams:
+  case OMPC_thread_limit:
+  case OMPC_device:
+  case OMPC_if:
+  case OMPC_copyin:
+  case OMPC_copyprivate:
+  case OMPC_default:
+  case OMPC_proc_bind:
+  case OMPC_shared:
+  case OMPC_private:
+  case OMPC_firstprivate:
+  case OMPC_collapse:
+  case OMPC_nowait:
+  case OMPC_ordered:
+  case OMPC_schedule:
+  case OMPC_dist_schedule:
+  case OMPC_untied:
+  case OMPC_final:
+  case OMPC_mergeable:
+  case OMPC_read:
+  case OMPC_write:
+  case OMPC_capture:
+  case OMPC_update:
+  case OMPC_seq_cst:
+  case OMPC_depend:
+  case OMPC_linear:
+  case OMPC_aligned:
+  case OMPC_safelen:
+  case OMPC_map:
+    break;
+  case OMPC_lastprivate:
+    EmitCloseOMPLastPrivateClause(cast<OMPLastPrivateClause>(C), S);
+    break;
+  case OMPC_reduction:
+    EmitCloseOMPReductionClause(cast<OMPReductionClause>(C), S);
+    break;
+  }
+}
+
+void CodeGenFunction::EmitFinalOMPClause(const OMPClause &C,
+    const OMPExecutableDirective &S) {
+  switch (C.getClauseKind()) {
+  default:
+    llvm_unreachable("Unknown clause kind!");
+  case OMPC_num_threads:
+  case OMPC_num_teams:
+  case OMPC_thread_limit:
+  case OMPC_device:
+  case OMPC_copyin:
+  case OMPC_copyprivate:
+  case OMPC_default:
+  case OMPC_proc_bind:
+  case OMPC_shared:
+  case OMPC_private:
+  case OMPC_firstprivate:
+  case OMPC_lastprivate:
+  case OMPC_map:
+  case OMPC_collapse:
+  case OMPC_nowait:
+  case OMPC_ordered:
+  case OMPC_schedule:
+  case OMPC_dist_schedule:
+  case OMPC_untied:
+  case OMPC_final:
+  case OMPC_mergeable:
+  case OMPC_read:
+  case OMPC_write:
+  case OMPC_capture:
+  case OMPC_update:
+  case OMPC_seq_cst:
+  case OMPC_depend:
+  case OMPC_linear:
+  case OMPC_aligned:
+  case OMPC_safelen:
+    break;
+  case OMPC_if:
+    EmitFinalOMPIfClause(cast<OMPIfClause>(C), S);
+    break;
+  case OMPC_reduction:
+    EmitFinalOMPReductionClause(cast<OMPReductionClause>(C), S);
+    break;
+  }
+}
+
+void CodeGenFunction::EmitInitOMPNowaitClause(const OMPNowaitClause &,
+                                              const OMPExecutableDirective &) {
+  CGM.OpenMPSupport.setNoWait(true);
+}
+
+void
+CodeGenFunction::EmitInitOMPOrderedClause(const OMPOrderedClause &,
+                                          const OMPExecutableDirective &) {
+  CGM.OpenMPSupport.setOrdered(true);
+}
+
+void CodeGenFunction::EmitInitOMPUntiedClause(const OMPUntiedClause &,
+                                              const OMPExecutableDirective &) {
+  CGM.OpenMPSupport.setUntied(true);
+}
+
+void
+CodeGenFunction::EmitInitOMPMergeableClause(const OMPMergeableClause &,
+                                            const OMPExecutableDirective &) {
+  CGM.OpenMPSupport.setMergeable(true);
+}
+
+void CodeGenFunction::EmitInitOMPFinalClause(const OMPFinalClause &C,
+                                             const OMPExecutableDirective &) {
+  llvm::Value *Flags = CGM.OpenMPSupport.getTaskFlags();
+  llvm::BasicBlock *ThenBlock = createBasicBlock("task.final.then");
+  llvm::BasicBlock *EndBlock = createBasicBlock("task.final.end");
+  EmitBranchOnBoolExpr(C.getCondition(), ThenBlock, EndBlock, 0);
+  EmitBlock(ThenBlock);
+  llvm::Value *Val = Builder.CreateOr(Builder.CreateLoad(Flags, ".flags."),
+      OMP_TASK_FINAL);
+  Builder.CreateStore(Val, Flags);
+  EmitBranch(EndBlock);
+  EmitBlock(EndBlock, true);
+}
+
+void
+CodeGenFunction::EmitInitOMPNumThreadsClause(const OMPNumThreadsClause &C,
+                                             const OMPExecutableDirective &) {
+  // __kmpc_push_num_threads(&loc, global_tid, num_threads);
+  // ident_t loc = {...};
+  llvm::Value *Loc = OPENMPRTL_LOC(C.getLocStart(), *this);
+  // global_tid = __kmpc_global_thread_num(...);
+  llvm::Value *GTid = OPENMPRTL_THREADNUM(C.getLocStart(), *this);
+  // num_threads = num_threads...;
+  llvm::Value *NumThreads = EmitScalarExpr(C.getNumThreads(), true);
+  llvm::Value *RealArgs[] = {Loc, GTid, NumThreads};
+  EmitRuntimeCall(OPENMPRTL_FUNC(push_num_threads), RealArgs);
+}
+
+void
+CodeGenFunction::EmitInitOMPNumTeamsClause(const OMPNumTeamsClause &C,
+                                           const OMPExecutableDirective &) {
+  // num_teams = num_teams...;
+  llvm::Value *NumTeams = EmitScalarExpr(C.getNumTeams(), true);
+  CGM.OpenMPSupport.setNumTeams(NumTeams);
+}
+
+void
+CodeGenFunction::EmitInitOMPThreadLimitClause(const OMPThreadLimitClause &C,
+                                              const OMPExecutableDirective &) {
+  // thread_limit = thread_limit...;
+  llvm::Value *ThreadLimit = EmitScalarExpr(C.getThreadLimit(), true);
+  CGM.OpenMPSupport.setThreadLimit(ThreadLimit);
+}
+
+void
+CodeGenFunction::EmitInitOMPProcBindClause(const OMPProcBindClause &C,
+                                           const OMPExecutableDirective &) {
+  // __kmpc_push_proc_bind(&loc, global_tid, proc_bind);
+  // ident_t loc = {...};
+  llvm::Value *Loc = OPENMPRTL_LOC(C.getLocStart(), *this);
+  // global_tid = __kmpc_global_thread_num(...);
+  llvm::Value *GTid = OPENMPRTL_THREADNUM(C.getLocStart(), *this);
+  // proc_bind = proc_bind...;
+  llvm::Value *ProcBind = 0;
+  switch (C.getThreadAffinity()) {
+  case OMPC_PROC_BIND_master:
+    ProcBind = llvm::ConstantInt::get(
+        llvm::ProcBindTBuilder::get(CGM.getLLVMContext()),
+        KMP_PROC_BIND_MASTER);
+    break;
+  case OMPC_PROC_BIND_close:
+    ProcBind = llvm::ConstantInt::get(
+        llvm::ProcBindTBuilder::get(CGM.getLLVMContext()), KMP_PROC_BIND_CLOSE);
+    break;
+  case OMPC_PROC_BIND_spread:
+    ProcBind = llvm::ConstantInt::get(
+        llvm::ProcBindTBuilder::get(CGM.getLLVMContext()),
+        KMP_PROC_BIND_SPREAD);
+    break;
+  case OMPC_PROC_BIND_unknown:
+  case NUM_OPENMP_PROC_BIND_KINDS:
+    llvm_unreachable("Unknown thread affinity");
+  }
+  llvm::Value *RealArgs[] = {Loc, GTid, ProcBind};
+  EmitRuntimeCall(OPENMPRTL_FUNC(push_proc_bind), RealArgs);
+}
+
+void
+CodeGenFunction::EmitInitOMPDeviceClause(const OMPDeviceClause &C,
+                                           const OMPExecutableDirective &) {
+
+  RValue Tmp = EmitAnyExprToTemp(C.getDevice());
+  llvm::Value *DeviceID =
+      Builder.CreateIntCast(Tmp.getScalarVal(),CGM.Int32Ty,false);
+
+  CGM.OpenMPSupport.setOffloadingDevice(DeviceID);
+}
+
+void
+CodeGenFunction::EmitInitOMPMapClause(const OMPMapClause &C,
+                                           const OMPExecutableDirective &) {
+
+  ArrayRef<const Expr*> RangeBegin = C.getCopyingStartAddresses();
+  ArrayRef<const Expr*> RangeEnd = C.getCopyingSizesEndAddresses();
+
+
+  assert( RangeBegin.size() == RangeEnd.size()
+      && "Vars addresses mismatch!");
+
+  for (unsigned i=0; i<RangeBegin.size(); ++i){
+    llvm::Value * RB = EmitAnyExprToTemp(RangeBegin[i]).getScalarVal();
+    llvm::Value * RE = EmitAnyExprToTemp(RangeEnd[i]).getScalarVal();
+
+    // Subtract the two pointers to obtain the size or
+    // use the value directly if it is a constant
+    llvm::Value *Size = RE;
+
+    if (!isa<llvm::ConstantInt>(RE)){
+      llvm::Type *LongTy = ConvertType(CGM.getContext().LongTy);
+      llvm::Value *RBI = Builder.CreatePtrToInt(RB, LongTy);
+      llvm::Value *REI = Builder.CreatePtrToInt(RE, LongTy);
+      Size = Builder.CreateSub(REI,RBI);
+    }
+
+    llvm::Value *VP = Builder.CreateBitCast(RB,CGM.VoidPtrTy);
+    llvm::Value *VS =
+        Builder.CreateIntCast(Size,CGM.Int32Ty, false);
+
+    //Obtain the map clause type
+    int VT;
+
+    switch(C.getKind()){
+    default:
+      llvm_unreachable("Unknown map clause type!");
+      break;
+    case OMPC_MAP_unknown:
+    case OMPC_MAP_tofrom:
+      VT = OMP_TGT_MAPTYPE_TOFROM;
+      break;
+    case OMPC_MAP_to:
+      VT = OMP_TGT_MAPTYPE_TO;
+      break;
+    case OMPC_MAP_from:
+      VT = OMP_TGT_MAPTYPE_FROM;
+      break;
+    case OMPC_MAP_alloc:
+      VT = OMP_TGT_MAPTYPE_ALLOC;
+      break;
+    }
+
+    // Store the map data into the stack. After all map clauses are codegen,
+    // the afterinit emission is going to allocate the arrays in the program
+    // stack
+    CGM.OpenMPSupport.addMapData(VP,VS,VT);
+  }
+}
+
+void CodeGenFunction::EmitAfterInitOMPIfClause(const OMPIfClause &C,
+    const OMPExecutableDirective &S) {
+  if (isa<OMPTaskDirective>(&S)) {
+    llvm::BasicBlock *ThenBlock = createBasicBlock("omp.if.then");
+    llvm::BasicBlock *ElseBlock = createBasicBlock("omp.if.else");
+    EmitBranchOnBoolExpr(C.getCondition(), ThenBlock, ElseBlock, 0);
+    EmitBlock(ThenBlock);
+    CGM.OpenMPSupport.setIfDest(ElseBlock);
+  } else {
+    // if (Cond) {
+    llvm::BasicBlock *ThenBlock = createBasicBlock("omp.if.then");
+    llvm::BasicBlock *ElseBlock = createBasicBlock("omp.if.else");
+    llvm::BasicBlock *ContBlock = createBasicBlock("omp.if.end");
+    EmitBranchOnBoolExpr(C.getCondition(), ThenBlock, ElseBlock, 0);
+    EmitBlock(ElseBlock);
+    {
+      RunCleanupsScope ElseScope(*this);
+      EmitStmt(cast<CapturedStmt>(S.getAssociatedStmt())->getCapturedStmt());
+      EnsureInsertPoint();
+    }
+    EmitBranch(ContBlock);
+    EmitBlock(ThenBlock);
+    CGM.OpenMPSupport.setIfDest(ContBlock);
+  }
+}
+
+void CodeGenFunction::EmitFinalOMPIfClause(const OMPIfClause &,
+                                           const OMPExecutableDirective &S) {
+  if (isa<OMPTaskDirective>(&S)) {
+    llvm::BasicBlock *ContBlock = createBasicBlock("omp.if.end");
+    EmitBranch(ContBlock);
+    EmitBlock(CGM.OpenMPSupport.takeIfDest());
+    {
+      if (CGM.OpenMPSupport.getWaitDepsArgs()) {
+        EmitRuntimeCall(OPENMPRTL_FUNC(omp_wait_deps),
+                        makeArrayRef(CGM.OpenMPSupport.getWaitDepsArgs(), 6));
+      }
+      llvm::Value *PTask;
+      llvm::Value *TaskTVal;
+      llvm::Type *PrivateTy;
+      QualType PrivateQTy;
+      llvm::Value *Base;
+      CGM.OpenMPSupport.getPTask(PTask, TaskTVal, PrivateTy, PrivateQTy, Base);
+      llvm::Value *Loc = OPENMPRTL_LOC(S.getLocStart(), *this);
+      llvm::Value *GTid =
+          OPENMPRTL_THREADNUM(S.getLocStart(), *this);
+      llvm::Value *RealArgs[] = {Loc, GTid, TaskTVal};
+      EmitRuntimeCall(OPENMPRTL_FUNC(omp_task_begin_if0),
+                      makeArrayRef(RealArgs));
+      llvm::Value *RealArgs1[] = {
+          GTid, Builder.CreatePointerCast(TaskTVal, VoidPtrTy)};
+      EmitCallOrInvoke(PTask, makeArrayRef(RealArgs1));
+      EmitRuntimeCall(OPENMPRTL_FUNC(omp_task_complete_if0),
+          makeArrayRef(RealArgs));
+    }
+    EmitBranch(ContBlock);
+    EmitBlock(ContBlock, true);
+  } else {
+    llvm::BasicBlock *ContBlock = CGM.OpenMPSupport.takeIfDest();
+    EmitBranch(ContBlock);
+    EmitBlock(ContBlock, true);
+  }
+}
+
+void
+CodeGenFunction::EmitPreOMPScheduleClause(const OMPScheduleClause &C,
+                                          const OMPExecutableDirective &) {
+  int Schedule = KMP_SCH_DEFAULT;
+  bool Ordered = CGM.OpenMPSupport.getOrdered();
+  bool Merge = CGM.OpenMPSupport.getMergeable();
+  int Offset = 0;
+  if (Ordered && Merge)
+    Offset = SCH_ORD;
+  else if (!Ordered && !Merge)
+    Offset = SCH_NM;
+  else if (Ordered && !Merge)
+    Offset = SCH_NM_ORD;
+  const Expr *ChunkSize = C.getChunkSize();
+
+  switch (C.getScheduleKind()) {
+  case OMPC_SCHEDULE_static:
+    Schedule = ChunkSize ? KMP_SCH_STATIC_CHUNKED : KMP_SCH_STATIC;
+    break;
+  case OMPC_SCHEDULE_dynamic:
+    Schedule = KMP_SCH_DYNAMIC_CHUNKED;
+    break;
+  case OMPC_SCHEDULE_guided:
+    Schedule = KMP_SCH_GUIDED_CHUNKED;
+    break;
+  case OMPC_SCHEDULE_auto:
+    Schedule = KMP_SCH_AUTO;
+    break;
+  case OMPC_SCHEDULE_runtime:
+    Schedule = KMP_SCH_RUNTIME;
+    break;
+  case OMPC_SCHEDULE_unknown:
+  case NUM_OPENMP_SCHEDULE_KINDS:
+    llvm_unreachable("Unknown schedule kind.");
+  }
+  Schedule += Offset;
+  CGM.OpenMPSupport.setScheduleChunkSize(Schedule, ChunkSize);
+}
+
+void
+CodeGenFunction::EmitPreOMPDistScheduleClause(const OMPDistScheduleClause &C,
+                                              const OMPExecutableDirective &) {
+  int Schedule = KMP_SCH_DEFAULT;
+  const Expr *ChunkSize = C.getDistChunkSize();
+
+  switch (C.getDistScheduleKind()) {
+  case OMPC_DIST_SCHEDULE_static:
+    Schedule =
+        ChunkSize ?
+            KMP_SCH_DISTRIBUTE_STATIC_CHUNKED : KMP_SCH_DISTRIBUTE_STATIC;
+    break;
+  case OMPC_DIST_SCHEDULE_unknown:
+  case NUM_OPENMP_DIST_SCHEDULE_KINDS:
+    llvm_unreachable("Unknown dist_schedule kind.");
+  }
+  CGM.OpenMPSupport.setScheduleChunkSize(Schedule, ChunkSize);
+}
+
+void CodeGenFunction::EmitUniversalStore(LValue Dst, llvm::Value *Src,
+    QualType ExprTy) {
+  switch (getEvaluationKind(ExprTy)) {
+  case TEK_Complex: {
+    RValue Val = convertTempToRValue(Src, ExprTy, SourceLocation());
+    EmitStoreOfComplex(Val.getComplexVal(), Dst, false);
+    break;
+  }
+  case TEK_Aggregate:
+    EmitAggregateAssign(Dst.getAddress(), Src, ExprTy);
+    break;
+  case TEK_Scalar:
+    RValue Val = convertTempToRValue(Src, ExprTy, SourceLocation());
+    EmitStoreThroughLValue(Val, Dst, false);
+    break;
+  }
+}
+
+void CodeGenFunction::EmitUniversalStore(llvm::Value *Dst, llvm::Value *Src,
+    QualType ExprTy) {
+  EmitUniversalStore(MakeNaturalAlignAddrLValue(Dst, ExprTy), Src, ExprTy);
+}
+
+// This helper is used for emitting copy-assignments for copyin clause and
+// for copy_function generated for copyprivate clause.
+void CodeGenFunction::EmitCopyAssignment(ArrayRef<const Expr *>::iterator I,
+    ArrayRef<const Expr *>::iterator AssignIter,
+    ArrayRef<const Expr *>::iterator VarIter1,
+    ArrayRef<const Expr *>::iterator VarIter2, llvm::Value *Dst,
+    llvm::Value *Src) {
+  // This is called at each iteration of the loop through the clauses.
+  {
+    // Get element type.
+    QualType QTy = (*I)->getType();
+    const Type *MainTy = QTy.getTypePtr();
+    // const Type *Ty = MainTy->getArrayElementTypeNoTypeQual();
+    // const Type *PrevTy = MainTy;
+    // while (Ty != 0) {
+    //  PrevTy = Ty;
+    //  Ty = Ty->getArrayElementTypeNoTypeQual();
+    //}
+    // Ty = PrevTy;
+
+    if (!*AssignIter) {
+      // For trivial assignment operator copy by memcpy.
+      llvm::Value *VDAddr = Src;
+      EmitUniversalStore(Builder.CreatePointerCast(Dst, VDAddr->getType()),
+          VDAddr, QTy);
+    } else {
+      RunCleanupsScope InitBlock(*this);
+      // Copy elements one by one.
+      if (const ArrayType *ArrayTy = MainTy->getAsArrayTypeUnsafe()) {
+        // Copy array.
+        QualType ElementTy;
+        llvm::Value *SharedVar = Dst;
+        llvm::Value *NumElements = emitArrayLength(ArrayTy, ElementTy,
+            SharedVar);
+        llvm::Value *ArrayEnd = Builder.CreateGEP(SharedVar, NumElements);
+        llvm::Value *MasterArray = Src;
+        unsigned AddrSpace = MasterArray->getType()->getPointerAddressSpace();
+        llvm::Type *BaseType = ConvertType(ElementTy)->getPointerTo(AddrSpace);
+        llvm::Value *MasterArrayBegin = Builder.CreatePointerCast(MasterArray,
+            BaseType, "master.array.begin");
+        llvm::Value *MasterArrayEnd = Builder.CreateGEP(MasterArrayBegin,
+            NumElements);
+        // The basic structure here is a do-while loop, because we don't
+        // need to check for the zero-element case.
+        llvm::BasicBlock *BodyBB = createBasicBlock("omp.arraycpy.body");
+        llvm::BasicBlock *DoneBB = createBasicBlock("omp.arraycpy.done");
+        llvm::Value *IsEmpty = Builder.CreateICmpEQ(SharedVar, ArrayEnd,
+            "omp.arraycpy.isempty");
+        Builder.CreateCondBr(IsEmpty, DoneBB, BodyBB);
+
+        // Enter the loop body, making that address the current address.
+        llvm::BasicBlock *EntryBB = Builder.GetInsertBlock();
+        EmitBlock(BodyBB);
+        llvm::PHINode *ElementPast = Builder.CreatePHI(SharedVar->getType(), 2,
+            "omp.arraycpy.elementPast");
+        ElementPast->addIncoming(ArrayEnd, EntryBB);
+        llvm::PHINode *MasterElementPast = Builder.CreatePHI(
+            MasterArrayBegin->getType(), 2, "omp.arraycpy.masterElementPast");
+        MasterElementPast->addIncoming(MasterArrayEnd, EntryBB);
+
+        // Shift the address back by one element.
+        llvm::Value *NegativeOne = llvm::ConstantInt::get(SizeTy, -1, true);
+        llvm::Value *Element = Builder.CreateGEP(ElementPast, NegativeOne,
+            "omp.arraycpy.element");
+        llvm::Value *MasterElement = Builder.CreateGEP(MasterElementPast,
+            NegativeOne, "omp.arraycpy.master.element");
+
+        const VarDecl *PseudoVar1 = cast<VarDecl>(
+            cast<DeclRefExpr>(*VarIter1)->getDecl());
+        const VarDecl *PseudoVar2 = cast<VarDecl>(
+            cast<DeclRefExpr>(*VarIter2)->getDecl());
+        CGM.OpenMPSupport.addOpenMPPrivateVar(PseudoVar1, Element);
+        CGM.OpenMPSupport.addOpenMPPrivateVar(PseudoVar2, MasterElement);
+        EmitIgnoredExpr(*AssignIter);
+        CGM.OpenMPSupport.delOpenMPPrivateVar(PseudoVar1);
+        CGM.OpenMPSupport.delOpenMPPrivateVar(PseudoVar2);
+
+        // Check whether we've reached the end.
+        llvm::Value *Done = Builder.CreateICmpEQ(Element, SharedVar,
+            "omp.arraycpy.done");
+        Builder.CreateCondBr(Done, DoneBB, BodyBB);
+        ElementPast->addIncoming(Element, Builder.GetInsertBlock());
+        MasterElementPast->addIncoming(MasterElement, Builder.GetInsertBlock());
+
+        // Done.
+        EmitBlock(DoneBB, true);
+      } else {
+        // Copy single object.
+        const VarDecl *PseudoVar1 = cast<VarDecl>(
+            cast<DeclRefExpr>(*VarIter1)->getDecl());
+        const VarDecl *PseudoVar2 = cast<VarDecl>(
+            cast<DeclRefExpr>(*VarIter2)->getDecl());
+        CGM.OpenMPSupport.addOpenMPPrivateVar(PseudoVar1, Dst);
+        CGM.OpenMPSupport.addOpenMPPrivateVar(PseudoVar2, Src);
+        EmitIgnoredExpr(*AssignIter);
+        CGM.OpenMPSupport.delOpenMPPrivateVar(PseudoVar1);
+        CGM.OpenMPSupport.delOpenMPPrivateVar(PseudoVar2);
+      }
+    }
+  }
+}
+
+void CodeGenFunction::EmitPreOMPCopyinClause(const OMPCopyinClause &C,
+                                             const OMPExecutableDirective &) {
+  // copy_data(var1);
+  // copy_data(var2);
+  // ...
+  // __kmpc_barrier(&loc, global_tid);
+  ArrayRef<const Expr *>::iterator AssignIter = C.getAssignments().begin();
+  ArrayRef<const Expr *>::iterator VarIter1 = C.getPseudoVars1().begin();
+  ArrayRef<const Expr *>::iterator VarIter2 = C.getPseudoVars2().begin();
+
+  for (OMPCopyinClause::varlist_const_iterator I = C.varlist_begin(), E =
+      C.varlist_end(); I != E; ++I, ++AssignIter, ++VarIter1, ++VarIter2) {
+    const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    EmitCopyAssignment(I, AssignIter, VarIter1, VarIter2,
+        OPENMPRTL_THREADPVTCACHED(VD, (*I)->getExprLoc(), *this, true),
+        VD->isStaticLocal() ?
+            CGM.getStaticLocalDeclAddress(VD) : CGM.GetAddrOfGlobal(VD));
+  }
+  SetFirstprivateInsertPt(*this);
+}
+
+/// \brief Determine whether the given initializer is trivial in the sense
+/// that it requires no code to be generated.
+static bool isTrivialInitializer(const Expr *Init) {
+  if (!Init)
+    return true;
+
+  if (const CXXConstructExpr *Construct = dyn_cast<CXXConstructExpr>(Init))
+    if (CXXConstructorDecl *Constructor = Construct->getConstructor())
+      if (Constructor->isTrivial() && Constructor->isDefaultConstructor()
+          && !Construct->requiresZeroInitialization())
+        return true;
+
+  return false;
+}
+
+void CodeGenFunction::EmitPreOMPPrivateClause(const OMPPrivateClause &C,
+                                              const OMPExecutableDirective &) {
+  // Type1 tmp1;
+  // anon.field1 = &tmp1;
+  // Type2 tmp2;
+  // anon.field2 = &tmp2;
+  // ...
+  //
+  ArrayRef<const Expr *>::iterator InitIter = C.getDefaultInits().begin();
+  for (OMPPrivateClause::varlist_const_iterator I = C.varlist_begin(), E =
+      C.varlist_end(); I != E; ++I, ++InitIter) {
+    // Get element type.
+    const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    if (CGM.OpenMPSupport.getTopOpenMPPrivateVar(VD))
+      continue;
+    // if (VD->hasLocalStorage() &&
+    //    (!CapturedStmtInfo ||
+    //     !CapturedStmtInfo->lookup(VD))) {
+    //  LocalDeclMap[VD] = CreateMemTemp(VD->getType(), CGM.getMangledName(VD));
+    //}
+    QualType QTy = (*I)->getType();
+    const Type *MainTy = QTy.getTypePtr();
+    // const Type *Ty = MainTy->getArrayElementTypeNoTypeQual();
+    // const Type *PrevTy = MainTy;
+    // while (Ty != 0) {
+    //  PrevTy = Ty;
+    //  Ty = Ty->getArrayElementTypeNoTypeQual();
+    //}
+    // Ty = PrevTy;
+    llvm::Value *Private;
+    llvm::Value *PTask;
+    llvm::Value *TaskTVal;
+    llvm::Type *PrivateTy;
+    QualType PrivateQTy;
+    llvm::Value *Base;
+    CGM.OpenMPSupport.getPTask(PTask, TaskTVal, PrivateTy, PrivateQTy, Base);
+    if (PTask) {
+      Base = Builder.CreatePointerCast(Base, PrivateTy->getPointerTo());
+      Private = EmitLValueForField(MakeNaturalAlignAddrLValue(Base, PrivateQTy),
+          CGM.OpenMPSupport.getTaskFields()[VD]).getAddress();
+    } else {
+      LocalVarsDeclGuard Grd(*this, true);
+      AutoVarEmission Emission = EmitAutoVarAlloca(*VD);
+      Private = Emission.getAllocatedAddress();
+      EmitAutoVarCleanups(Emission);
+    }
+    // CodeGen for classes with the default constructor.
+    if (((!PTask || CurFn != PTask) && !isTrivialInitializer(*InitIter))
+        || (MainTy->isVariablyModifiedType() && !MainTy->isPointerType())) {
+      RunCleanupsScope InitBlock(*this);
+      if (const ArrayType *ArrayTy = MainTy->getAsArrayTypeUnsafe()) {
+        // Create array.
+        QualType ElementTy;
+        llvm::Value *ArrayBeg = Private;
+        llvm::Value *NumElements = emitArrayLength(ArrayTy, ElementTy,
+            ArrayBeg);
+        llvm::Value *ArrayEnd = Builder.CreateGEP(ArrayBeg, NumElements,
+            "omp.arrayctor.end");
+        // The basic structure here is a do-while loop, because we don't
+        // need to check for the zero-element case.
+        llvm::BasicBlock *BodyBB = createBasicBlock("omp.arrayctor.body");
+        llvm::BasicBlock *DoneBB = createBasicBlock("omp.arrayctor.done");
+        llvm::Value *IsEmpty = Builder.CreateICmpEQ(ArrayBeg, ArrayEnd,
+            "omp.arrayctor.isempty");
+        Builder.CreateCondBr(IsEmpty, DoneBB, BodyBB);
+
+        // Enter the loop body, making that address the current address.
+        llvm::BasicBlock *EntryBB = Builder.GetInsertBlock();
+        EmitBlock(BodyBB);
+        llvm::PHINode *ElementPast = Builder.CreatePHI(ArrayBeg->getType(), 2,
+            "omp.arrayctor.elementPast");
+        ElementPast->addIncoming(ArrayEnd, EntryBB);
+
+        // Shift the address back by one element.
+        llvm::Value *NegativeOne = llvm::ConstantInt::get(SizeTy, -1, true);
+        llvm::Value *Element = Builder.CreateGEP(ElementPast, NegativeOne,
+            "omp.arrayctor.element");
+        EmitAnyExprToMem(*InitIter, Element,
+            (*InitIter)->getType().getQualifiers(), false);
+        //// Check whether we've reached the end.
+        llvm::Value *Done = Builder.CreateICmpEQ(Element, ArrayBeg,
+            "omp.arrayctor.done");
+        Builder.CreateCondBr(Done, DoneBB, BodyBB);
+        ElementPast->addIncoming(Element, Builder.GetInsertBlock());
+
+        // Done.
+        EmitBlock(DoneBB, true);
+      } else {
+        EmitAnyExprToMem(*InitIter, Private,
+            (*InitIter)->getType().getQualifiers(), false);
+      }
+    }
+    CGM.OpenMPSupport.addOpenMPPrivateVar(VD, Private);
+  }
+}
+
+void
+CodeGenFunction::EmitPreOMPFirstPrivateClause(const OMPFirstPrivateClause &C,
+                                              const OMPExecutableDirective &) {
+  // Type1 tmp1(var1);
+  // anon.field1 = &tmp1;
+  // Type2 tmp2(var2);
+  // anon.field2 = &tmp2;
+  // ...
+  //
+  llvm::Value *PTask;
+  llvm::Value *TaskTVal;
+  llvm::Type *PrivateTy;
+  QualType PrivateQTy;
+  llvm::Value *Base;
+  CGM.OpenMPSupport.getPTask(PTask, TaskTVal, PrivateTy, PrivateQTy, Base);
+
+  ArrayRef<const Expr *>::iterator InitIter = C.getInits().begin();
+  ArrayRef<const Expr *>::iterator VarIter = C.getPseudoVars().begin();
+  for (OMPFirstPrivateClause::varlist_const_iterator I = C.varlist_begin(), E =
+      C.varlist_end(); I != E; ++I, ++InitIter, ++VarIter) {
+    // Get element type.
+    const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    if (CGM.OpenMPSupport.getTopOpenMPPrivateVar(VD))
+      continue;
+    // if (VD->hasLocalStorage() &&
+    //    (!CapturedStmtInfo ||
+    //     !CapturedStmtInfo->lookup(VD))) {
+    //  LocalDeclMap[VD] = CreateMemTemp(VD->getType(), CGM.getMangledName(VD));
+    //}
+    QualType QTy = (*I)->getType();
+    const Type *MainTy = QTy.getTypePtr();
+    // const Type *Ty = MainTy->getArrayElementTypeNoTypeQual();
+    // const Type *PrevTy = MainTy;
+    // while (Ty != 0) {
+    //  PrevTy = Ty;
+    //  Ty = Ty->getArrayElementTypeNoTypeQual();
+    //}
+    llvm::Value *Private = 0;
+    if (!CGM.OpenMPSupport.isNewTask() && !PTask) {
+      if (llvm::AllocaInst *Val = dyn_cast_or_null<llvm::AllocaInst>(
+          CGM.OpenMPSupport.getPrevOpenMPPrivateVar(VD))) {
+        Private = Val;
+        CGM.OpenMPSupport.delPrevOpenMPPrivateVar(VD);
+        CGM.OpenMPSupport.addOpenMPPrivateVar(VD, Private);
+        continue;
+      }
+    }
+    if (PTask) {
+      Base = Builder.CreatePointerCast(Base, PrivateTy->getPointerTo());
+      Private = EmitLValueForField(MakeNaturalAlignAddrLValue(Base, PrivateQTy),
+          CGM.OpenMPSupport.getTaskFields()[VD]).getAddress();
+    } else {
+      LocalVarsDeclGuard Grd(*this, true);
+      AutoVarEmission Emission = EmitAutoVarAlloca(*VD);
+      Private = Emission.getAllocatedAddress();
+      EmitAutoVarCleanups(Emission);
+    }
+    // CodeGen for classes with the copy constructor.
+    RunCleanupsScope InitBlock(*this);
+    if (((!PTask || CurFn != PTask) && !isTrivialInitializer(*InitIter))
+        || (MainTy->isVariablyModifiedType() && !MainTy->isPointerType())) {
+      if (const ArrayType *ArrayTy = MainTy->getAsArrayTypeUnsafe()) {
+        // Create array.
+        QualType ElementTy;
+        llvm::Value *ArrayBeg = Private;
+        llvm::Value *NumElements = emitArrayLength(ArrayTy, ElementTy,
+            ArrayBeg);
+        llvm::Value *ArrayEnd = Builder.CreateGEP(ArrayBeg, NumElements);
+        llvm::Value *MasterArray = EmitLValue(*I).getAddress();
+        unsigned AddrSpace = MasterArray->getType()->getPointerAddressSpace();
+        llvm::Type *BaseType = ConvertType(ElementTy)->getPointerTo(AddrSpace);
+        llvm::Value *MasterArrayBegin = Builder.CreatePointerCast(MasterArray,
+            BaseType, "master.array.begin");
+        llvm::Value *MasterArrayEnd = Builder.CreateGEP(MasterArrayBegin,
+            NumElements);
+        // The basic structure here is a do-while loop, because we don't
+        // need to check for the zero-element case.
+        llvm::BasicBlock *BodyBB = createBasicBlock("omp.arraycpy.body");
+        llvm::BasicBlock *DoneBB = createBasicBlock("omp.arraycpy.done");
+        llvm::Value *IsEmpty = Builder.CreateICmpEQ(ArrayBeg, ArrayEnd,
+            "omp.arraycpy.isempty");
+        Builder.CreateCondBr(IsEmpty, DoneBB, BodyBB);
+
+        // Enter the loop body, making that address the current address.
+        llvm::BasicBlock *EntryBB = Builder.GetInsertBlock();
+        EmitBlock(BodyBB);
+        llvm::PHINode *MasterElementPast = Builder.CreatePHI(
+            MasterArrayBegin->getType(), 2, "omp.arraycpy.masterElementPast");
+        MasterElementPast->addIncoming(MasterArrayEnd, EntryBB);
+        llvm::PHINode *ElementPast = Builder.CreatePHI(ArrayBeg->getType(), 2,
+            "omp.arraycpy.elementPast");
+        ElementPast->addIncoming(ArrayEnd, EntryBB);
+
+        // Shift the address back by one element.
+        llvm::Value *NegativeOne = llvm::ConstantInt::get(SizeTy, -1, true);
+        llvm::Value *Element = Builder.CreateGEP(ElementPast, NegativeOne,
+            "omp.arraycpy.element");
+        llvm::Value *MasterElement = Builder.CreateGEP(MasterElementPast,
+            NegativeOne, "omp.arraycpy.master.element");
+
+        const VarDecl *PseudoVar = cast<VarDecl>(
+            cast<DeclRefExpr>(*VarIter)->getDecl());
+        CGM.OpenMPSupport.addOpenMPPrivateVar(PseudoVar, MasterElement);
+        EmitAnyExprToMem(*InitIter, Element,
+            (*InitIter)->getType().getQualifiers(), false);
+        CGM.OpenMPSupport.delOpenMPPrivateVar(PseudoVar);
+
+        // Check whether we've reached the end.
+        llvm::Value *Done = Builder.CreateICmpEQ(Element, ArrayBeg,
+            "omp.arraycpy.done");
+        Builder.CreateCondBr(Done, DoneBB, BodyBB);
+        ElementPast->addIncoming(Element, Builder.GetInsertBlock());
+        MasterElementPast->addIncoming(MasterElement, Builder.GetInsertBlock());
+
+        // Done.
+        EmitBlock(DoneBB, true);
+      } else {
+        // Create single object.
+        llvm::Value *RealAddr = EmitLValue(*I).getAddress();
+        const VarDecl *PseudoVar = cast<VarDecl>(
+            cast<DeclRefExpr>(*VarIter)->getDecl());
+        CGM.OpenMPSupport.addOpenMPPrivateVar(PseudoVar, RealAddr);
+        EmitAnyExprToMem(*InitIter, Private,
+            (*InitIter)->getType().getQualifiers(), false);
+        CGM.OpenMPSupport.delOpenMPPrivateVar(PseudoVar);
+      }
+    } else if (!PTask || CurFn != PTask) {
+      EmitAnyExprToMem(*I, Private, QTy.getQualifiers(), false);
+    }
+    CGM.OpenMPSupport.addOpenMPPrivateVar(VD, Private);
+  }
+  // Disable marking for tasks.
+  if (!PTask || PTask == CurFn)
+    SetFirstprivateInsertPt(*this);
+}
+
+void CodeGenFunction::EmitPreOMPLastPrivateClause(const OMPLastPrivateClause &C,
+    const OMPExecutableDirective &S) {
+  // Type1 tmp1;
+  // Type2 tmp2;
+  // ...
+  //
+  CGM.OpenMPSupport.setHasLastPrivate(true);
+  ArrayRef<const Expr *>::iterator InitIter = C.getDefaultInits().begin();
+  for (OMPLastPrivateClause::varlist_const_iterator I = C.varlist_begin(), E =
+      C.varlist_end(); I != E; ++I, ++InitIter) {
+    // Get element type.
+    const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    bool FirstPrivateFound = false;
+    for (ArrayRef<OMPClause *>::iterator FI = S.clauses().begin(), FE =
+        S.clauses().end(); FI != FE; ++FI) {
+      if (const OMPFirstPrivateClause *FC = dyn_cast<OMPFirstPrivateClause>(
+          *FI)) {
+        for (OMPFirstPrivateClause::varlist_const_iterator VI =
+            FC->varlist_begin(), VE = FC->varlist_end(); VI != VE; ++VI) {
+          if (VD == cast<DeclRefExpr>(*VI)->getDecl()) {
+            FirstPrivateFound = true;
+            break;
+          }
+        }
+      }
+      if (FirstPrivateFound)
+        break;
+    }
+    // Lastprivate init is processed by firstprivate clause.
+    if (FirstPrivateFound || CGM.OpenMPSupport.getTopOpenMPPrivateVar(VD))
+      continue;
+    // if (VD->hasLocalStorage() &&
+    //    (!CapturedStmtInfo ||
+    //     !CapturedStmtInfo->lookup(VD))) {
+    //  LocalDeclMap[VD] = CreateMemTemp(VD->getType(), CGM.getMangledName(VD));
+    //}
+    QualType QTy = (*I)->getType();
+    const Type *MainTy = QTy.getTypePtr();
+    // const Type *Ty = MainTy->getArrayElementTypeNoTypeQual();
+    // const Type *PrevTy = MainTy;
+    // while (Ty != 0) {
+    //  PrevTy = Ty;
+    //  Ty = Ty->getArrayElementTypeNoTypeQual();
+    //}
+    // Ty = PrevTy;
+    llvm::Value *Private = 0;
+    {
+      LocalVarsDeclGuard Grd(*this, true);
+      AutoVarEmission Emission = EmitAutoVarAlloca(*VD);
+      Private = Emission.getAllocatedAddress();
+      EmitAutoVarCleanups(Emission);
+    }
+    // CodeGen for classes with the default constructor.
+    if (!isTrivialInitializer(*InitIter)
+        || (MainTy->isVariablyModifiedType() && !MainTy->isPointerType())) {
+      RunCleanupsScope InitBlock(*this);
+      if (const ArrayType *ArrayTy = MainTy->getAsArrayTypeUnsafe()) {
+        // Create array.
+        QualType ElementTy;
+        llvm::Value *ArrayBeg = Private;
+        llvm::Value *NumElements = emitArrayLength(ArrayTy, ElementTy,
+            ArrayBeg);
+        llvm::Value *ArrayEnd = Builder.CreateGEP(ArrayBeg, NumElements,
+            "omp.arrayctor.end");
+        // The basic structure here is a do-while loop, because we don't
+        // need to check for the zero-element case.
+        llvm::BasicBlock *BodyBB = createBasicBlock("omp.arrayctor.body");
+        llvm::BasicBlock *DoneBB = createBasicBlock("omp.arrayctor.done");
+        llvm::Value *IsEmpty = Builder.CreateICmpEQ(ArrayBeg, ArrayEnd,
+            "omp.arrayctor.isempty");
+        Builder.CreateCondBr(IsEmpty, DoneBB, BodyBB);
+
+        // Enter the loop body, making that address the current address.
+        llvm::BasicBlock *EntryBB = Builder.GetInsertBlock();
+        EmitBlock(BodyBB);
+        llvm::PHINode *ElementPast = Builder.CreatePHI(ArrayBeg->getType(), 2,
+            "omp.arrayctor.elementPast");
+        ElementPast->addIncoming(ArrayEnd, EntryBB);
+
+        // Shift the address back by one element.
+        llvm::Value *NegativeOne = llvm::ConstantInt::get(SizeTy, -1, true);
+        llvm::Value *Element = Builder.CreateGEP(ElementPast, NegativeOne,
+            "omp.arrayctor.element");
+        EmitAnyExprToMem(*InitIter, Element,
+            (*InitIter)->getType().getQualifiers(), false);
+        //// Check whether we've reached the end.
+        llvm::Value *Done = Builder.CreateICmpEQ(Element, ArrayBeg,
+            "omp.arrayctor.done");
+        Builder.CreateCondBr(Done, DoneBB, BodyBB);
+        ElementPast->addIncoming(Element, Builder.GetInsertBlock());
+
+        // Done.
+        EmitBlock(DoneBB, true);
+      } else {
+        EmitAnyExprToMem(*InitIter, Private,
+            (*InitIter)->getType().getQualifiers(), false);
+      }
+    }
+    CGM.OpenMPSupport.addOpenMPPrivateVar(VD, Private);
+  }
+}
+
+void CodeGenFunction::EmitPostOMPLastPrivateClause(
+    const OMPLastPrivateClause &C, const OMPExecutableDirective &S) {
+  // ~Type1(tmp1);
+  // ~Type2(tmp2);
+  // ...
+  //
+
+  llvm::BasicBlock *LPBB, *LPEndBB;
+  llvm::Instruction *LPIP;
+  CGM.OpenMPSupport.getLastprivateIP(LPBB, LPIP, LPEndBB);
+  if (!LPBB && !LPIP && !LPEndBB) {
+    LPBB = createBasicBlock("omp.if.liter.start", CurFn);
+    LPEndBB = createBasicBlock("omp.if.liter.end", CurFn);
+    llvm::Value *LiterVal = Builder.CreateLoad(
+        CGM.OpenMPSupport.getLastIterVar(), "liter");
+    Builder.CreateCondBr(Builder.CreateIsNull(LiterVal), LPEndBB, LPBB);
+    LPIP = LPBB->end();
+    if (isLoopDirective(&S)) {
+      Builder.SetInsertPoint(LPBB);
+      EmitStmt(getFinalFromLoopDirective(&S));
+      EnsureInsertPoint();
+      LPBB = Builder.GetInsertBlock();
+      LPIP = Builder.GetInsertPoint();
+    }
+    Builder.SetInsertPoint(LPEndBB);
+    if (!CGM.OpenMPSupport.getNoWait())
+      EmitOMPCancelBarrier(S.getLocEnd(), KMP_IDENT_BARRIER_IMPL);
+  }
+  ArrayRef<const Expr *>::iterator AssignIter = C.getAssignments().begin();
+  ArrayRef<const Expr *>::iterator VarIter1 = C.getPseudoVars1().begin();
+  ArrayRef<const Expr *>::iterator VarIter2 = C.getPseudoVars2().begin();
+  for (OMPLastPrivateClause::varlist_const_iterator I = C.varlist_begin(), E =
+      C.varlist_end(); I != E; ++I, ++AssignIter, ++VarIter1, ++VarIter2) {
+    // Get element type.
+    const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    llvm::Value *Private = CGM.OpenMPSupport.getTopOpenMPPrivateVar(VD);
+    if (!Private)
+      continue;
+    QualType QTy = (*I)->getType();
+    const Type *MainTy = QTy.getTypePtr();
+    const Type *Ty = MainTy->getArrayElementTypeNoTypeQual();
+    const Type *PrevTy = MainTy;
+    while (Ty != 0) {
+      PrevTy = Ty;
+      Ty = Ty->getArrayElementTypeNoTypeQual();
+    }
+    Ty = PrevTy;
+    CGM.OpenMPSupport.delOpenMPPrivateVar(VD);
+    CGBuilderTy::InsertPoint SavedIP = Builder.saveIP();
+    Builder.SetInsertPoint(LPBB, LPIP);
+    // CodeGen for classes with the copy assignment operator.
+    if (!*AssignIter) {
+      // For trivial assignment operator copy by memcpy.
+      // EmitAnyExprToMem(*I, Private, QTy.getQualifiers(), false);
+      // EmitAggregateAssign(EmitLValue(*I).getAddress(), Private,
+      // VD->getType());
+      EmitUniversalStore(EmitLValue(*I), Private, QTy);
+    } else {
+      RunCleanupsScope InitBlock(*this);
+      // Copy elements one by one.
+      if (const ArrayType *ArrayTy = MainTy->getAsArrayTypeUnsafe()) {
+        // Copy array.
+        QualType ElementTy;
+        llvm::Value *SharedVar = EmitLValue(*I).getAddress();
+        llvm::Value *NumElements = emitArrayLength(ArrayTy, ElementTy,
+            SharedVar);
+        llvm::Value *ArrayEnd = Builder.CreateGEP(SharedVar, NumElements);
+        llvm::Value *MasterArray = Private;
+        unsigned AddrSpace = MasterArray->getType()->getPointerAddressSpace();
+        llvm::Type *BaseType = ConvertType(ElementTy)->getPointerTo(AddrSpace);
+        llvm::Value *MasterArrayBegin = Builder.CreatePointerCast(MasterArray,
+            BaseType, "master.array.begin");
+        llvm::Value *MasterArrayEnd = Builder.CreateGEP(MasterArrayBegin,
+            NumElements);
+        // The basic structure here is a do-while loop, because we don't
+        // need to check for the zero-element case.
+        llvm::BasicBlock *BodyBB = createBasicBlock("omp.arraycpy.body");
+        llvm::BasicBlock *DoneBB = createBasicBlock("omp.arraycpy.done");
+        llvm::Value *IsEmpty = Builder.CreateICmpEQ(SharedVar, ArrayEnd,
+            "omp.arraycpy.isempty");
+        Builder.CreateCondBr(IsEmpty, DoneBB, BodyBB);
+
+        // Enter the loop body, making that address the current address.
+        llvm::BasicBlock *EntryBB = Builder.GetInsertBlock();
+        EmitBlock(BodyBB);
+        llvm::PHINode *ElementPast = Builder.CreatePHI(SharedVar->getType(), 2,
+            "omp.arraycpy.elementPast");
+        ElementPast->addIncoming(ArrayEnd, EntryBB);
+        llvm::PHINode *MasterElementPast = Builder.CreatePHI(
+            MasterArrayBegin->getType(), 2, "omp.arraycpy.masterElementPast");
+        MasterElementPast->addIncoming(MasterArrayEnd, EntryBB);
+
+        // Shift the address back by one element.
+        llvm::Value *NegativeOne = llvm::ConstantInt::get(SizeTy, -1, true);
+        llvm::Value *Element = Builder.CreateGEP(ElementPast, NegativeOne,
+            "omp.arraycpy.element");
+        llvm::Value *MasterElement = Builder.CreateGEP(MasterElementPast,
+            NegativeOne, "omp.arraycpy.master.element");
+
+        const VarDecl *PseudoVar1 = cast<VarDecl>(
+            cast<DeclRefExpr>(*VarIter1)->getDecl());
+        const VarDecl *PseudoVar2 = cast<VarDecl>(
+            cast<DeclRefExpr>(*VarIter2)->getDecl());
+        CGM.OpenMPSupport.addOpenMPPrivateVar(PseudoVar1, MasterElement);
+        CGM.OpenMPSupport.addOpenMPPrivateVar(PseudoVar2, Element);
+        EmitIgnoredExpr(*AssignIter);
+        CGM.OpenMPSupport.delOpenMPPrivateVar(PseudoVar1);
+        CGM.OpenMPSupport.delOpenMPPrivateVar(PseudoVar2);
+
+        // Check whether we've reached the end.
+        llvm::Value *Done = Builder.CreateICmpEQ(Element, SharedVar,
+            "omp.arraycpy.done");
+        Builder.CreateCondBr(Done, DoneBB, BodyBB);
+        ElementPast->addIncoming(Element, Builder.GetInsertBlock());
+        MasterElementPast->addIncoming(MasterElement, Builder.GetInsertBlock());
+
+        // Done.
+        EmitBlock(DoneBB, true);
+      } else {
+        // Copy single object.
+        const VarDecl *PseudoVar1 = cast<VarDecl>(
+            cast<DeclRefExpr>(*VarIter1)->getDecl());
+        const VarDecl *PseudoVar2 = cast<VarDecl>(
+            cast<DeclRefExpr>(*VarIter2)->getDecl());
+        CGM.OpenMPSupport.addOpenMPPrivateVar(PseudoVar1,
+            EmitLValue(*I).getAddress());
+        CGM.OpenMPSupport.addOpenMPPrivateVar(PseudoVar2, Private);
+        EmitIgnoredExpr(*AssignIter);
+        CGM.OpenMPSupport.delOpenMPPrivateVar(PseudoVar1);
+        CGM.OpenMPSupport.delOpenMPPrivateVar(PseudoVar2);
+      }
+    }
+    LPBB = Builder.GetInsertBlock();
+    LPIP = Builder.GetInsertPoint();
+    Builder.restoreIP(SavedIP);
+  }
+  CGM.OpenMPSupport.setLastprivateIP(LPBB, LPIP, LPEndBB);
+}
+
+void CodeGenFunction::EmitCloseOMPLastPrivateClause(
+    const OMPLastPrivateClause &, const OMPExecutableDirective &) {
+  // ~Type1(tmp1);
+  // ~Type2(tmp2);
+  // ...
+  //
+
+  llvm::BasicBlock *LPBB, *LPEndBB;
+  llvm::Instruction *LPIP;
+  CGM.OpenMPSupport.getLastprivateIP(LPBB, LPIP, LPEndBB);
+  if (LPBB || LPIP || LPEndBB) {
+    CGBuilderTy::InsertPoint SavedIP = Builder.saveIP();
+    Builder.SetInsertPoint(LPBB, LPIP);
+    EmitBranch(LPEndBB);
+    Builder.restoreIP(SavedIP);
+    CGM.OpenMPSupport.setLastprivateIP(0, 0, 0);
+  }
+}
+
+void
+CodeGenFunction::EmitInitOMPReductionClause(const OMPReductionClause &C,
+                                            const OMPExecutableDirective &S) {
+  (void)S;
+  assert(!isa<OMPSimdDirective>(S)); // Not yet supported
+  // Type1 tmp1(var1);
+  // anon.field1 = &tmp1;
+  // Type2 tmp2(var2);
+  // anon.field2 = &tmp2;
+  // ...
+  //
+  // CodeGen for reduction clause.
+  CodeGenFunction &CGF = CGM.OpenMPSupport.getCGFForReductionFunction();
+  llvm::Function *ReductionFunc = CGF.CurFn;
+  if (!ReductionFunc) {
+    FunctionArgList Args;
+    ImplicitParamDecl Arg1(getContext(), 0, SourceLocation(), 0,
+                           getContext().VoidPtrTy);
+    ImplicitParamDecl Arg2(getContext(), 0, SourceLocation(), 0,
+                           getContext().VoidPtrTy);
+    Args.push_back(&Arg1);
+    Args.push_back(&Arg2);
+    const CGFunctionInfo &FI = CGF.getTypes().arrangeFreeFunctionDeclaration(
+        getContext().VoidTy, Args, FunctionType::ExtInfo(), false);
+    llvm::FunctionType *FTy = CGF.getTypes().GetFunctionType(FI);
+    llvm::Function *Fn = llvm::Function::Create(FTy,
+        llvm::GlobalValue::InternalLinkage, StringRef(".omp_reduction_op."),
+        &CGM.getModule());
+    CGM.SetInternalFunctionAttributes(CurFuncDecl, Fn, FI);
+    CGF.StartFunction(GlobalDecl(), getContext().VoidTy, Fn, FI, Args,
+        SourceLocation());
+    ReductionFunc = CGF.CurFn;
+  }
+
+  for (OMPReductionClause::varlist_const_iterator I = C.varlist_begin(), E =
+      C.varlist_end(); I != E; ++I) {
+    // Get element type.
+    const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    QualType QTy = (*I)->getType();
+    // if (!QTy->isScalarType())
+    //  llvm_unreachable("Reduction variables with aggregate"
+    //                   "types are not supported yet!");
+    llvm::Type *PtrType = ConvertType(getContext().getPointerType(QTy));
+    CGM.OpenMPSupport.registerReductionVar(VD, PtrType);
+  }
+}
+
+void
+CodeGenFunction::EmitPreOMPReductionClause(const OMPReductionClause &C,
+                                           const OMPExecutableDirective &S) {
+  (void)S;
+  assert(!isa<OMPSimdDirective>(S)); // Not yet supported
+  // Type1 tmp1(var1);
+  // anon.field1 = &tmp1;
+  // Type2 tmp2(var2);
+  // anon.field2 = &tmp2;
+  // ...
+  //
+  llvm::Value *ReductionRecVar = CGM.OpenMPSupport.getReductionRecVar(*this);
+  ArrayRef<const Expr *>::iterator InitIter = C.getDefaultInits().begin();
+  for (OMPReductionClause::varlist_const_iterator I = C.varlist_begin(), E =
+      C.varlist_end(); I != E; ++I, ++InitIter) {
+    // Get element type.
+    const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    // if (VD->hasLocalStorage() &&
+    //    (!CapturedStmtInfo ||
+    //     !CapturedStmtInfo->lookup(VD))) {
+    //  LocalDeclMap[VD] = CreateMemTemp(VD->getType(), CGM.getMangledName(VD));
+    //}
+    QualType QTy = (*I)->getType();
+    llvm::AllocaInst *Private = 0;
+    {
+      LocalVarsDeclGuard Grd(*this, true);
+      AutoVarEmission Emission = EmitAutoVarAlloca(*VD);
+      Private = cast<llvm::AllocaInst>(Emission.getAllocatedAddress());
+      EmitAutoVarCleanups(Emission);
+    }
+    //         CreateMemTemp(QTy, CGM.getMangledName(VD) + ".reduction.");
+
+    // CodeGen for classes with the constructor.
+    // const Type *Ty = QTy.getTypePtr();
+    if (!isTrivialInitializer(*InitIter)) {
+      RunCleanupsScope InitBlock(*this);
+      const FunctionDecl *FD = 0;
+      if (const DeclRefExpr *DRE = dyn_cast_or_null<DeclRefExpr>(*InitIter)) {
+        if (const FunctionDecl *D = dyn_cast_or_null<FunctionDecl>(
+            DRE->getDecl()))
+          FD = D;
+      }
+      if (FD && isa<OMPDeclareReductionDecl>(FD->getDeclContext())) {
+        llvm::Value *RegularAddr = EmitLValue(*I).getAddress();
+        llvm::Value *Args[] = {Private, RegularAddr};
+        EmitCallOrInvoke(CGM.GetAddrOfGlobal(FD), Args);
+        SetFirstprivateInsertPt(*this);
+      } else {
+        EmitAnyExprToMem(*InitIter, Private,
+            (*InitIter)->getType().getQualifiers(), false);
+      }
+    } else if (*InitIter) {
+      switch (C.getOperator()) {
+      case OMPC_REDUCTION_or:
+      case OMPC_REDUCTION_bitxor:
+      case OMPC_REDUCTION_bitor:
+      case OMPC_REDUCTION_sub:
+      case OMPC_REDUCTION_add: {
+        llvm::Value *Zero = llvm::Constant::getNullValue(
+            Private->getAllocatedType());
+        InitTempAlloca(Private, Zero);
+        break;
+      }
+      case OMPC_REDUCTION_and:
+      case OMPC_REDUCTION_mult:
+      case OMPC_REDUCTION_bitand: {
+        llvm::Value *AllOnes = llvm::Constant::getAllOnesValue(
+            Private->getAllocatedType());
+        InitTempAlloca(Private, AllOnes);
+        break;
+      }
+      case OMPC_REDUCTION_min:
+      case OMPC_REDUCTION_max:
+      case OMPC_REDUCTION_custom:
+        llvm_unreachable("Operator kind not allowed.");
+      case OMPC_REDUCTION_unknown:
+      case NUM_OPENMP_REDUCTION_OPERATORS:
+        llvm_unreachable("Unknown operator kind.");
+      }
+    } else {
+      llvm::Type *Ty = ConvertTypeForMem(QTy);
+      switch (C.getOperator()) {
+      case OMPC_REDUCTION_or:
+      case OMPC_REDUCTION_bitxor:
+      case OMPC_REDUCTION_bitor:
+      case OMPC_REDUCTION_sub:
+      case OMPC_REDUCTION_add: {
+        if (QTy->isIntegralOrEnumerationType()) {
+          llvm::APInt InitVal = llvm::APInt::getNullValue(
+              CGM.getDataLayout().getTypeStoreSizeInBits(Ty));
+          llvm::Value *Init = llvm::ConstantInt::get(CGM.getLLVMContext(),
+              InitVal);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isRealFloatingType()) {
+          const llvm::fltSemantics &FS = Ty->getFltSemantics();
+          llvm::APFloat InitVal = llvm::APFloat::getZero(FS);
+          llvm::Value *Init = llvm::ConstantFP::get(CGM.getLLVMContext(),
+              InitVal);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isPointerType()) {
+          InitTempAlloca(Private,
+              llvm::ConstantPointerNull::get(cast<llvm::PointerType>(Ty)));
+        } else if (QTy->isAnyComplexType()) {
+          const ComplexType *CmplxTy = QTy->castAs<ComplexType>();
+          QualType ElTy = CmplxTy->getElementType();
+          Ty = ConvertTypeForMem(ElTy);
+          llvm::Value *Init;
+          if (ElTy->isIntegralOrEnumerationType()) {
+            llvm::APInt InitVal = llvm::APInt::getNullValue(
+                CGM.getDataLayout().getTypeStoreSizeInBits(Ty));
+            Init = llvm::ConstantInt::get(CGM.getLLVMContext(), InitVal);
+          } else {
+            const llvm::fltSemantics &FS = Ty->getFltSemantics();
+            llvm::APFloat InitVal = llvm::APFloat::getZero(FS);
+            Init = llvm::ConstantFP::get(CGM.getLLVMContext(), InitVal);
+          }
+          ComplexPairTy Value(Init, Init);
+          LValue Dst = MakeNaturalAlignAddrLValue(Private, QTy);
+          EmitStoreOfComplex(Value, Dst, true);
+        }
+        break;
+      }
+      case OMPC_REDUCTION_and:
+      case OMPC_REDUCTION_mult: {
+        if (QTy->isIntegralOrEnumerationType()) {
+          llvm::APInt InitVal(CGM.getDataLayout().getTypeStoreSizeInBits(Ty),
+              1);
+          llvm::Value *Init = llvm::ConstantInt::get(CGM.getLLVMContext(),
+              InitVal);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isRealFloatingType()) {
+          const llvm::fltSemantics &FS = Ty->getFltSemantics();
+          llvm::APFloat InitVal(FS, 1);
+          llvm::Value *Init = llvm::ConstantFP::get(CGM.getLLVMContext(),
+              InitVal);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isPointerType()) {
+          llvm::APInt InitVal(CGM.getDataLayout().getTypeStoreSizeInBits(Ty),
+              1);
+          llvm::Constant *Init = llvm::ConstantInt::get(CGM.getLLVMContext(),
+              InitVal);
+          Init = llvm::ConstantExpr::getCast(llvm::Instruction::IntToPtr, Init,
+              Ty);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isAnyComplexType()) {
+          const ComplexType *CmplxTy = QTy->castAs<ComplexType>();
+          QualType ElTy = CmplxTy->getElementType();
+          Ty = ConvertTypeForMem(ElTy);
+          llvm::Value *Init;
+          if (ElTy->isIntegralOrEnumerationType()) {
+            llvm::APInt InitVal(CGM.getDataLayout().getTypeStoreSizeInBits(Ty),
+                1);
+            Init = llvm::ConstantInt::get(CGM.getLLVMContext(), InitVal);
+          } else {
+            const llvm::fltSemantics &FS = Ty->getFltSemantics();
+            llvm::APFloat InitVal(FS, 1);
+            Init = llvm::ConstantFP::get(CGM.getLLVMContext(), InitVal);
+          }
+          ComplexPairTy Value(Init, Init);
+          LValue Dst = MakeNaturalAlignAddrLValue(Private, QTy);
+          EmitStoreOfComplex(Value, Dst, true);
+        }
+        break;
+      }
+      case OMPC_REDUCTION_bitand: {
+        if (QTy->isIntegralOrEnumerationType()) {
+          llvm::APInt InitVal = llvm::APInt::getAllOnesValue(
+              CGM.getDataLayout().getTypeStoreSizeInBits(Ty));
+          llvm::Value *Init = llvm::ConstantInt::get(CGM.getLLVMContext(),
+              InitVal);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isRealFloatingType()) {
+          llvm::APFloat InitVal = llvm::APFloat::getAllOnesValue(
+              CGM.getDataLayout().getTypeStoreSizeInBits(Ty));
+          llvm::Value *Init = llvm::ConstantFP::get(CGM.getLLVMContext(),
+              InitVal);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isPointerType()) {
+          llvm::Value *Init = llvm::Constant::getAllOnesValue(Ty);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isAnyComplexType()) {
+          const ComplexType *CmplxTy = QTy->castAs<ComplexType>();
+          QualType ElTy = CmplxTy->getElementType();
+          Ty = ConvertTypeForMem(ElTy);
+          llvm::Value *Init;
+          if (ElTy->isIntegralOrEnumerationType()) {
+            llvm::APInt InitVal = llvm::APInt::getAllOnesValue(
+                CGM.getDataLayout().getTypeStoreSizeInBits(Ty));
+            Init = llvm::ConstantInt::get(CGM.getLLVMContext(), InitVal);
+          } else {
+            llvm::APFloat InitVal = llvm::APFloat::getAllOnesValue(
+                CGM.getDataLayout().getTypeStoreSizeInBits(Ty));
+            Init = llvm::ConstantFP::get(CGM.getLLVMContext(), InitVal);
+          }
+          ComplexPairTy Value(Init, Init);
+          LValue Dst = MakeNaturalAlignAddrLValue(Private, QTy);
+          EmitStoreOfComplex(Value, Dst, true);
+        }
+        break;
+      }
+      case OMPC_REDUCTION_min: {
+        if (QTy->isSignedIntegerOrEnumerationType()) {
+          llvm::APInt InitVal = llvm::APInt::getSignedMaxValue(
+              CGM.getDataLayout().getTypeStoreSizeInBits(Ty));
+          llvm::Value *Init = llvm::ConstantInt::get(CGM.getLLVMContext(),
+              InitVal);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isUnsignedIntegerOrEnumerationType()) {
+          llvm::APInt InitVal = llvm::APInt::getMaxValue(
+              CGM.getDataLayout().getTypeStoreSizeInBits(Ty));
+          llvm::Value *Init = llvm::ConstantInt::get(CGM.getLLVMContext(),
+              InitVal);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isRealFloatingType()) {
+          const llvm::fltSemantics &FS = Ty->getFltSemantics();
+          llvm::APFloat InitVal = llvm::APFloat::getLargest(FS);
+          llvm::Value *Init = llvm::ConstantFP::get(CGM.getLLVMContext(),
+              InitVal);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isPointerType()) {
+          llvm::APInt InitVal = llvm::APInt::getMaxValue(
+              CGM.getDataLayout().getTypeStoreSizeInBits(Ty));
+          llvm::Constant *Init = llvm::ConstantInt::get(CGM.getLLVMContext(),
+              InitVal);
+          Init = llvm::ConstantExpr::getCast(llvm::Instruction::IntToPtr, Init,
+              Ty);
+          InitTempAlloca(Private, Init);
+        }
+        break;
+      }
+      case OMPC_REDUCTION_max: {
+        if (QTy->isSignedIntegerOrEnumerationType()) {
+          llvm::APInt InitVal = llvm::APInt::getSignedMinValue(
+              CGM.getDataLayout().getTypeStoreSizeInBits(Ty));
+          llvm::Value *Init = llvm::ConstantInt::get(CGM.getLLVMContext(),
+              InitVal);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isUnsignedIntegerOrEnumerationType()) {
+          llvm::APInt InitVal = llvm::APInt::getMinValue(
+              CGM.getDataLayout().getTypeStoreSizeInBits(Ty));
+          llvm::Value *Init = llvm::ConstantInt::get(CGM.getLLVMContext(),
+              InitVal);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isRealFloatingType()) {
+          const llvm::fltSemantics &FS = Ty->getFltSemantics();
+          llvm::APFloat InitVal = llvm::APFloat::getLargest(FS, true);
+          llvm::Value *Init = llvm::ConstantFP::get(CGM.getLLVMContext(),
+              InitVal);
+          InitTempAlloca(Private, Init);
+        } else if (QTy->isPointerType()) {
+          llvm::APInt InitVal = llvm::APInt::getMinValue(
+              CGM.getDataLayout().getTypeStoreSizeInBits(Ty));
+          llvm::Constant *Init = llvm::ConstantInt::get(CGM.getLLVMContext(),
+              InitVal);
+          Init = llvm::ConstantExpr::getCast(llvm::Instruction::IntToPtr, Init,
+              Ty);
+          InitTempAlloca(Private, Init);
+        }
+        break;
+      }
+      case OMPC_REDUCTION_custom:
+        llvm_unreachable("Custom initialization cannot be NULLed.");
+      case OMPC_REDUCTION_unknown:
+      case NUM_OPENMP_REDUCTION_OPERATORS:
+        llvm_unreachable("Unkonwn operator kind.");
+      }
+    }
+    llvm::Value *Addr = Builder.CreateConstGEP2_32(ReductionRecVar, 0,
+        CGM.OpenMPSupport.getReductionVarIdx(VD),
+        CGM.getMangledName(VD) + ".addr");
+    Builder.CreateStore(Private, Addr);
+    // llvm::Value *Var = Builder.CreateLoad(Addr, CGM.getMangledName(VD));
+    CGM.OpenMPSupport.addOpenMPPrivateVar(VD, Private);
+  }
+}
+
+void
+CodeGenFunction::EmitPostOMPReductionClause(const OMPReductionClause &C,
+                                            const OMPExecutableDirective &S) {
+  (void)S;
+  assert(!isa<OMPSimdDirective>(S)); // Not yet supported
+  CodeGenFunction &CGF = CGM.OpenMPSupport.getCGFForReductionFunction();
+  llvm::Function *ReduceFunc = CGF.CurFn;
+  llvm::SwitchInst *Switch = dyn_cast_or_null<llvm::SwitchInst>(
+      CGM.OpenMPSupport.getReductionSwitch());
+  llvm::BasicBlock *RedBB1;
+  llvm::BasicBlock *RedBB2;
+  llvm::Instruction *IP1;
+  llvm::Instruction *IP2;
+  if (!Switch) {
+    // __kmpc_reduce[_nowait](ident_t *loc, int32_t global_tid, int32_t
+    // num_vars,
+    //                      size_t reduce_size, void *reduce_data,
+    //                     kmp_reduce_func reduce_func, kmp_critical_name *lck);
+    // ident_t loc = {...};
+    llvm::Value *Loc = OPENMPRTL_LOCFLAGS(C.getLocStart(), *this,
+        KMP_IDENT_ATOMIC_REDUCE);
+    // global_tid = __kmpc_global_thread_num(...);
+    llvm::Value *GTid = OPENMPRTL_THREADNUM(C.getLocStart(), *this);
+    // int num_vars = c;
+    unsigned NumVars = CGM.OpenMPSupport.getNumberOfReductionVars();
+    llvm::Value *NumVarsVal = llvm::ConstantInt::get(Int32Ty, NumVars);
+    // size_t reduce_size = sizeof(rec);
+    uint64_t ReduceSize = CGM.getDataLayout().getTypeAllocSize(
+        CGM.OpenMPSupport.getReductionRec());
+    llvm::Value *ReduceSizeVal = llvm::ConstantInt::get(SizeTy, ReduceSize);
+    // void *reduce_data = (void *)rec;
+    llvm::Value *ReduceData = Builder.CreatePointerCast(
+        CGM.OpenMPSupport.getReductionRecVar(*this), VoidPtrTy,
+        "(void*)reductionrec");
+    // kmpc_reduce_func reduce_func = reduce_func;
+    // kmp_critical_name lck;
+    llvm::Type *LckTy = llvm::TypeBuilder<kmp_critical_name, false>::get(
+        CGM.getLLVMContext());
+
+    llvm::GlobalVariable *Lck = CreateRuntimeVariable(CGM, ".lck.", LckTy);
+    CGM.OpenMPSupport.setReductionLockVar(Lck);
+    llvm::Value *RealArgs[] = {
+        Loc, GTid, NumVarsVal, ReduceSizeVal, ReduceData, ReduceFunc, Lck};
+    llvm::CallInst *Res = EmitRuntimeCall(CGM.OpenMPSupport.getNoWait()
+                                              ? OPENMPRTL_FUNC(reduce_nowait)
+                                              : OPENMPRTL_FUNC(reduce),
+                                          RealArgs);
+    RedBB1 = createBasicBlock("reduction.case1", CurFn);
+    RedBB2 = createBasicBlock("reduction.case2", CurFn);
+    llvm::BasicBlock *DefaultBlock = createBasicBlock("reduction.continue",
+        CurFn);
+    Switch = Builder.CreateSwitch(Res, DefaultBlock, 2);
+    Switch->addCase(llvm::ConstantInt::get(Int32Ty, 1), RedBB1);
+    Switch->addCase(llvm::ConstantInt::get(Int32Ty, 2), RedBB2);
+    IP1 = RedBB1->end();
+    IP2 = RedBB2->end();
+    Builder.SetInsertPoint(DefaultBlock);
+    CGM.OpenMPSupport.setReductionSwitch(Switch);
+  } else {
+    CGM.OpenMPSupport.getReductionIPs(RedBB1, IP1, RedBB2, IP2);
+  }
+  llvm::Value *ReductionRecVar = CGM.OpenMPSupport.getReductionRecVar(*this);
+  ArrayRef<const Expr *>::iterator Par1I = C.getHelperParameters1st().begin();
+  ArrayRef<const Expr *>::iterator Par2I = C.getHelperParameters2nd().begin();
+  ArrayRef<const Expr *>::iterator OpI = C.getOpExprs().begin();
+  for (OMPReductionClause::varlist_const_iterator I = C.varlist_begin(), E =
+      C.varlist_end(); I != E; ++I, ++Par1I, ++Par2I, ++OpI) {
+    // Get element type.
+    const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    QualType QTy = (*I)->getType();
+    llvm::Value *Private = CGM.OpenMPSupport.getTopOpenMPPrivateVar(VD);
+    if (!Private)
+      continue;
+    CGM.OpenMPSupport.delOpenMPPrivateVar(VD);
+
+    CGBuilderTy::InsertPoint SavedIP = Builder.saveIP();
+    Builder.SetInsertPoint(RedBB1, IP1);
+    const VarDecl *Par1 = cast<VarDecl>(cast<DeclRefExpr>(*Par1I)->getDecl());
+    const VarDecl *Par2 = cast<VarDecl>(cast<DeclRefExpr>(*Par2I)->getDecl());
+    QualType PtrQTy = getContext().getPointerType(QTy);
+    llvm::AllocaInst *AI = CreateMemTemp(PtrQTy,
+        CGM.getMangledName(VD) + ".addr.lhs.");
+    LValue LVal = MakeNaturalAlignAddrLValue(AI, PtrQTy);
+    UnaryOperator UOp(const_cast<Expr *>(*I), UO_AddrOf, PtrQTy, VK_LValue,
+        OK_Ordinary, SourceLocation());
+    // EmitExprAsInit(&UOp, VD, LVal, false);
+    EmitAnyExprToMem(&UOp, AI, UOp.getType().getQualifiers(), false);
+    llvm::Value *Addr2 = Builder.CreateConstGEP2_32(ReductionRecVar, 0,
+        CGM.OpenMPSupport.getReductionVarIdx(VD),
+        CGM.getMangledName(VD) + ".addr.rhs");
+    CGM.OpenMPSupport.addOpenMPPrivateVar(Par1, AI);
+    CGM.OpenMPSupport.addOpenMPPrivateVar(Par2, Addr2);
+    EmitIgnoredExpr(*OpI);
+    CGM.OpenMPSupport.delOpenMPPrivateVar(Par1);
+    CGM.OpenMPSupport.delOpenMPPrivateVar(Par2);
+    IP1 = Builder.GetInsertPoint();
+    RedBB1 = Builder.GetInsertBlock();
+    Builder.SetInsertPoint(RedBB2, IP2);
+    llvm::Value *AtomicFunc = OPENMPRTL_ATOMIC_FUNC(QTy, C.getOperator());
+    if (isa<BinaryOperator>((*OpI)->IgnoreImpCasts()) && AtomicFunc) {
+      // __kmpc_atomic_...(&loc, global_tid, &glob, &reduction);
+      // ident_t loc = {...};
+      llvm::Value *Loc = OPENMPRTL_LOC(C.getLocStart(), *this);
+      // global_tid = __kmpc_global_thread_num(...);
+      llvm::Value *GTid = OPENMPRTL_THREADNUM(C.getLocStart(), *this);
+      Addr2 = Builder.CreateConstGEP2_32(ReductionRecVar, 0,
+          CGM.OpenMPSupport.getReductionVarIdx(VD),
+          CGM.getMangledName(VD) + ".addr.rhs");
+      llvm::Type *ArgTy = ConvertTypeForMem(OPENMPRTL_ATOMICTYPE(*this, QTy));
+      llvm::Type *PtrArgTy = ArgTy->getPointerTo();
+      llvm::Value *RealArgs[] = {
+          Loc, GTid, Builder.CreatePointerCast(EmitScalarExpr(&UOp), PtrArgTy),
+          Builder.CreateLoad(Builder.CreatePointerCast(
+              Builder.CreateLoad(Addr2, CGM.getMangledName(VD) + ".rhs"),
+              PtrArgTy))};
+      EmitRuntimeCall(AtomicFunc, RealArgs);
+    } else {
+      // __kmpc_atomic_start();
+      EmitRuntimeCall(OPENMPRTL_FUNC(atomic_start));
+      AI = CreateMemTemp(PtrQTy, CGM.getMangledName(VD) + ".addr.lhs.");
+      LVal = MakeNaturalAlignAddrLValue(AI, PtrQTy);
+      EmitAnyExprToMem(&UOp, AI, UOp.getType().getQualifiers(), false);
+      // EmitExprAsInit(&UOp, VD, LVal, false);
+      Addr2 = Builder.CreateConstGEP2_32(ReductionRecVar, 0,
+          CGM.OpenMPSupport.getReductionVarIdx(VD),
+          CGM.getMangledName(VD) + "addr.rhs");
+      CGM.OpenMPSupport.addOpenMPPrivateVar(Par1, AI);
+      CGM.OpenMPSupport.addOpenMPPrivateVar(Par2, Addr2);
+      EmitIgnoredExpr(*OpI);
+      CGM.OpenMPSupport.delOpenMPPrivateVar(Par1);
+      CGM.OpenMPSupport.delOpenMPPrivateVar(Par2);
+      // __kmpc_atomic_end();
+      EmitRuntimeCall(OPENMPRTL_FUNC(atomic_end));
+    }
+    IP2 = Builder.GetInsertPoint();
+    RedBB2 = Builder.GetInsertBlock();
+    Builder.restoreIP(SavedIP);
+  }
+  CGM.OpenMPSupport.setReductionIPs(RedBB1, IP1, RedBB2, IP2);
+}
+
+llvm::CallInst *CodeGenFunction::EmitOMPCallWithLocAndTidHelper(llvm::Value *F,
+    SourceLocation L, unsigned Flags) {
+  llvm::Value *Loc = OPENMPRTL_LOCFLAGS(L, *this, Flags);
+  llvm::Value *GTid = OPENMPRTL_THREADNUM(L, *this);
+  llvm::Value *RealArgs[] = {Loc, GTid};
+  return EmitRuntimeCall(F, RealArgs);
+}
+
+void CodeGenFunction::EmitOMPCapturedBodyHelper(
+    const OMPExecutableDirective &S) {
+  // TODO: We may inline instead of calling it...
+  RunCleanupsScope MyScope(*this);
+  EmitStmt(cast<CapturedStmt>(S.getAssociatedStmt())->getCapturedStmt());
+  EnsureInsertPoint();
+}
+
+void CodeGenFunction::EmitOMPConditionalIfHelper(
+    const OMPExecutableDirective &S, llvm::Value *Func, SourceLocation Loc,
+    llvm::Value *EndFunc, SourceLocation EndLoc, bool HasClauses,
+    llvm::AllocaInst *DidIt, const std::string &NameStr) {
 
-void CodeGenFunction::EmitOMPParallelDirective(const OMPParallelDirective &S) {
-  const CapturedStmt *CS = cast<CapturedStmt>(S.getAssociatedStmt());
-  llvm::Value *CapturedStruct = GenerateCapturedStmtArgument(*CS);
+  // This is for master and single directives:
+  // if (__kmpc_Call()) {
+  //   <captured_body>
+  //   __kmpc_EndCall();
+  // }
+  //
+  RunCleanupsScope ExecutedScope(*this);
+  if (HasClauses) {
+    // Pre-process private and firstprivate clauses
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+        S.clauses().end(); I != E; ++I) {
+      if (*I)
+        EmitPreOMPClause(*(*I), S);
+    }
+  }
 
-  llvm::Value *OutlinedFn;
-  {
-    CodeGenFunction CGF(CGM, true);
-    CGCapturedStmtInfo CGInfo(*CS, CS->getCapturedRegionKind());
-    CGF.CapturedStmtInfo = &CGInfo;
-    OutlinedFn = CGF.GenerateCapturedStmtFunction(*CS);
-  }
-
-  // Build call __kmpc_fork_call(loc, 1, microtask, captured_struct/*context*/)
-  llvm::Value *Args[] = {
-      CGM.getOpenMPRuntime().EmitOpenMPUpdateLocation(*this, S.getLocStart()),
-      Builder.getInt32(1), // Number of arguments after 'microtask' argument
-      // (there is only one additional argument - 'context')
-      Builder.CreateBitCast(OutlinedFn,
-                            CGM.getOpenMPRuntime().getKmpc_MicroPointerTy()),
-      EmitCastToVoidPtr(CapturedStruct)};
-  llvm::Constant *RTLFn = CGM.getOpenMPRuntime().CreateRuntimeFunction(
-      CGOpenMPRuntime::OMPRTL__kmpc_fork_call);
-  EmitRuntimeCall(RTLFn, Args);
+  if (DidIt) {
+    // Store 0 into .did_it. flag
+    llvm::Value *Zero = llvm::Constant::getNullValue(
+        ConvertTypeForMem(getContext().IntTy));
+    EmitStoreOfScalar(Zero, DidIt, false,
+        CGM.getDataLayout().getPrefTypeAlignment(
+            ConvertTypeForMem(getContext().IntTy)), getContext().IntTy);
+  }
+
+  // Start with emission of __kmpc_Call()
+  llvm::CallInst *Call = EmitOMPCallWithLocAndTidHelper(Func, Loc);
+  // Convert Call's result to bool, to use in IF-stmt
+  llvm::Value *CallBool = EmitScalarConversion(Call, getContext().IntTy,
+      getContext().BoolTy);
+  // Generate the basic blocks
+  llvm::BasicBlock *ThenBlock = createBasicBlock((NameStr + ".then").c_str());
+  llvm::BasicBlock *ContBlock = createBasicBlock((NameStr + ".end").c_str());
+  // Generate the branch (If-stmt)
+  Builder.CreateCondBr(CallBool, ThenBlock, ContBlock);
+  EmitBlock(ThenBlock);
+  // Here we are on Then-branch -- emit captured body and __kmpc_EndCall()
+  EmitOMPCapturedBodyHelper(S);
+  if (DidIt) {
+    // Store 1 into .did_it. flag
+    llvm::Value *One = llvm::ConstantInt::get(CGM.getLLVMContext(),
+        llvm::APInt::getLowBitsSet(
+            CGM.getDataLayout().getTypeStoreSizeInBits(
+                ConvertTypeForMem(getContext().IntTy)), 1));
+    EmitStoreOfScalar(One, DidIt, false,
+        CGM.getDataLayout().getPrefTypeAlignment(
+            DidIt->getType()->getSequentialElementType()), getContext().IntTy);
+  }
+  EmitOMPCallWithLocAndTidHelper(EndFunc, EndLoc);
+  // Emit the rest of bblocks/branches
+  EmitBranch(ContBlock);
+  EmitBlock(ContBlock, true);
+
+  if (HasClauses) {
+    // Post-process private and firstprivate clauses
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+        S.clauses().end(); I != E; ++I) {
+      if (*I)
+        EmitPostOMPClause(*(*I), S);
+    }
+  }
 }
 
-void CodeGenFunction::EmitOMPSimdDirective(const OMPSimdDirective &S) {
-  const CapturedStmt *CS = cast<CapturedStmt>(S.getAssociatedStmt());
-  const Stmt *Body = CS->getCapturedStmt();
-  LoopStack.setParallel();
-  LoopStack.setVectorizerEnable(true);
-  for (auto C : S.clauses()) {
+/// "One-call" OMP Directives (barrier, taskyield, taskwait, flush).
+/// '#pragma omp barrier' directive.
+void CodeGenFunction::EmitOMPBarrierDirective(const OMPBarrierDirective &S) {
+  // EmitUntiedPartIdInc(*this);
+  EmitOMPCancelBarrier(S.getLocStart(), KMP_IDENT_BARRIER_EXPL);
+  // EmitUntiedBranchEnd(*this);
+  // EmitUntiedTaskSwitch(*this, false);
+}
+
+/// '#pragma omp taskyield' directive.
+void CodeGenFunction::EmitOMPTaskyieldDirective(
+    const OMPTaskyieldDirective &S) {
+  // EmitUntiedPartIdInc(*this);
+  llvm::Value *Loc = OPENMPRTL_LOC(S.getLocStart(), *this);
+  llvm::Value *GTid = OPENMPRTL_THREADNUM(S.getLocStart(), *this);
+  llvm::Value *RealArgs[] = {Loc, GTid, Builder.getInt32(0)};
+  EmitRuntimeCall(OPENMPRTL_FUNC(omp_taskyield), RealArgs);
+  // EmitUntiedBranchEnd(*this);
+  // EmitUntiedTaskSwitch(*this, false);
+}
+
+/// '#pragma omp taskwait' directive.
+void CodeGenFunction::EmitOMPTaskwaitDirective(const OMPTaskwaitDirective &S) {
+  // If the task is untied, we may want to generate IF-stmt here:
+  // if (__kmpc_omp_taskwait(loc_task_wait, gtid) == CURRENT_TASK_QUEUED) {
+  //      T-return; // Exit t1 if it was suspended or queued
+  // }
+  // But currently RTL always returns TASK_CURRENT_NOT_QUEUED,
+  // so probably that make no sence.
+  //
+  EmitUntiedPartIdInc(*this);
+  llvm::Value *Res = EmitOMPCallWithLocAndTidHelper(
+      OPENMPRTL_FUNC(omp_taskwait), S.getLocStart());
+  if (CGM.OpenMPSupport.getUntied()) {
+    llvm::BasicBlock *ThenBB = createBasicBlock("taskwait.then");
+    llvm::BasicBlock *EndBB = createBasicBlock("taskwait.end");
+    llvm::Value *Cond = Builder.CreateICmpEQ(Res,
+        Builder.getInt32(OMP_TASK_CURRENT_QUEUED));
+    Builder.CreateCondBr(Cond, ThenBB, EndBB);
+    EmitBlock(ThenBB);
+    EmitUntiedBranchEnd(*this);
+    EmitBlock(EndBB);
+    EmitUntiedTaskSwitch(*this, true);
+  }
+}
+
+/// '#pragma omp flush' directive.
+void CodeGenFunction::EmitOMPFlushDirective(const OMPFlushDirective &S) {
+  SmallVector<llvm::Value *, 4> Args;
+  Args.push_back(OPENMPRTL_LOC(S.getLocStart(), *this));
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+      S.clauses().end(); I != E; ++I) {
+    const OMPFlushClause *C = cast<OMPFlushClause>(*I);
+    for (ArrayRef<const Expr *>::iterator J = C->varlist_begin(), F =
+        C->varlist_end(); J != F; ++J) {
+      QualType QTy = (*J)->getType();
+      QualType PtrQTy = getContext().getPointerType(QTy);
+      UnaryOperator UOp(const_cast<Expr *>(*J), UO_AddrOf, PtrQTy, VK_LValue,
+          OK_Ordinary, S.getLocStart());
+      llvm::Value *Val = EmitScalarExpr(&UOp);
+      Args.push_back(Val);
+    }
+  }
+  EmitRuntimeCall(OPENMPRTL_FUNC(flush), Args);
+}
+
+/// '#pragma omp cancel' directive.
+void CodeGenFunction::EmitOMPCancelDirective(const OMPCancelDirective &S) {
+  llvm::Value *Loc;
+  llvm::Value *GTid;
+  llvm::Value *Kind;
+  EmitCancelArgs(*this, S.getConstructType(), S.getLocStart(), Loc, GTid, Kind);
+
+  llvm::Value *RealArgs[] = {Loc, GTid, Kind};
+
+  llvm::BasicBlock *ContBB = createBasicBlock("omp.cancel.continue");
+  llvm::BasicBlock *ExitBB = createBasicBlock("omp.cancel.exit");
+  if (!S.clauses().empty()) {
+    assert(
+        S.clauses().size() == 1 && isa<OMPIfClause>(S.clauses().front())
+            && "Wrong number or type of clause in omp cancel directive");
+    const OMPIfClause *Clause = cast<OMPIfClause>(S.clauses().front());
+    llvm::BasicBlock *ThenBB = createBasicBlock("omp.cancel.then");
+    llvm::BasicBlock *ElseBB = createBasicBlock("omp.cancel.else");
+    EmitBranchOnBoolExpr(Clause->getCondition(), ThenBB, ElseBB, 0);
+    EmitBlock(ElseBB);
+    EmitCancellationPoint(*this, S.getLocStart(), RealArgs, ExitBB, ContBB);
+    EmitBlock(ThenBB);
+  }
+
+  llvm::Value *CallRes = Builder.CreateIsNotNull(
+      EmitRuntimeCall(OPENMPRTL_FUNC(cancel), RealArgs));
+  Builder.CreateCondBr(CallRes, ExitBB, ContBB);
+  EmitBlock(ExitBB);
+  assert(
+      OMPCancelMap.count(S.getConstructType()) && "No exit point for cancel");
+  EmitOMPCancelBarrier(S.getLocStart(), KMP_IDENT_BARRIER_IMPL, true);
+  EmitBranchThroughCleanup(OMPCancelMap[S.getConstructType()]);
+  EmitBlock(ContBB);
+}
+
+/// '#pragma omp cancellation point' directive.
+void CodeGenFunction::EmitOMPCancellationPointDirective(
+    const OMPCancellationPointDirective &S) {
+  llvm::Value *Loc;
+  llvm::Value *GTid;
+  llvm::Value *Kind;
+  EmitCancelArgs(*this, S.getConstructType(), S.getLocStart(), Loc, GTid, Kind);
+
+  llvm::Value *RealArgs[] = {Loc, GTid, Kind};
+
+  llvm::BasicBlock *ExitBB = createBasicBlock("omp.cancellationpoint.exit");
+  llvm::BasicBlock *ContBB = createBasicBlock("omp.cancellationpoint.continue");
+  assert(
+      OMPCancelMap.count(S.getConstructType())
+          && "No exit point for cancellation point");
+  EmitCancellationPoint(*this, S.getLocStart(), RealArgs, ExitBB, ContBB,
+      OMPCancelMap[S.getConstructType()]);
+}
+
+/// Atomic OMP Directive -- pattern match and emit one RTL call.
+/// In the future, we may want to generate some atomic llvm instruction
+/// instead of RTL call here for some atomic directives.
+void CodeGenFunction::EmitOMPAtomicDirective(const OMPAtomicDirective &S) {
+  CGM.OpenMPSupport.startOpenMPRegion(false);
+  bool IsSeqCst = false;
+  bool AtLeastOneLoopTaken = false;
+  OpenMPClauseKind Kind = OMPC_update;
+  for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+      S.clauses().end(); I != E || !AtLeastOneLoopTaken; ++I) {
+    if (I != S.clauses().end()) {
+      if ((*I)->getClauseKind() == OMPC_seq_cst) {
+        IsSeqCst = true;
+        continue;
+      }
+      Kind = (*I)->getClauseKind();
+    }
+    LValue X = EmitLValue(S.getX()->IgnoreParenLValueCasts());
+    switch (Kind) {
+    case OMPC_read: {
+      QualType QTy = S.getX()->getType();
+      QualType AQTy = OPENMPRTL_ATOMICTYPE(*this, QTy);
+      llvm::Value *AtomicFunc =
+          AQTy.isNull() ?
+              0 :
+              OPENMPRTL_ATOMIC_FUNC_GENERAL(AQTy, AQTy,
+                  CGOpenMPRuntime::OMP_Atomic_rd, false, false);
+      if (X.isSimple() && AtomicFunc) {
+        llvm::Type *ATy = ConvertTypeForMem(AQTy);
+        llvm::SmallVector<llvm::Value *, 5> Args;
+        // __kmpc_atomic_..._rd(&loc, global_tid, &x);
+        // ident_t loc = {...};
+        llvm::Value *Loc = OPENMPRTL_LOC(S.getLocStart(), *this);
+        // global_tid = __kmpc_global_thread_num(...);
+        llvm::Value *GTid = OPENMPRTL_THREADNUM(S.getLocStart(), *this);
+        Args.push_back(Loc);
+        Args.push_back(GTid);
+        Args.push_back(
+            Builder.CreatePointerCast(X.getAddress(), ATy->getPointerTo()));
+        llvm::Value *Res = EmitRuntimeCall(AtomicFunc, Args);
+        // v = x;
+        Res = EmitScalarConversion(Res, AQTy, S.getV()->getType());
+        EmitStoreOfScalar(Res, EmitLValue(S.getV()));
+      } else {
+        EmitRuntimeCall(OPENMPRTL_FUNC(atomic_start));
+        RValue Val = EmitLoadOfLValue(X, S.getX()->getExprLoc());
+        EmitRuntimeCall(OPENMPRTL_FUNC(atomic_end));
+        EmitStoreThroughLValue(Val, EmitLValue(S.getV()));
+      }
+    }
+      break;
+    case OMPC_write: {
+      QualType QTy = S.getX()->getType();
+      QualType AQTy = OPENMPRTL_ATOMICTYPE(*this, QTy);
+      QualType QTyIn = S.getExpr()->getType();
+      llvm::Value *AtomicFunc =
+          AQTy.isNull() ?
+              0 :
+              OPENMPRTL_ATOMIC_FUNC_GENERAL(AQTy, AQTy,
+                  CGOpenMPRuntime::OMP_Atomic_wr, false, false);
+      if (X.isSimple() && AtomicFunc && QTyIn->isScalarType()
+          && !QTyIn->isAnyComplexType()) {
+        llvm::Type *ATy = ConvertTypeForMem(AQTy);
+        llvm::SmallVector<llvm::Value *, 5> Args;
+        // __kmpc_atomic_..._wr(&loc, global_tid, &x, expr);
+        // ident_t loc = {...};
+        llvm::Value *Loc = OPENMPRTL_LOC(S.getLocStart(), *this);
+        // global_tid = __kmpc_global_thread_num(...);
+        llvm::Value *GTid = OPENMPRTL_THREADNUM(S.getLocStart(), *this);
+        Args.push_back(Loc);
+        Args.push_back(GTid);
+        Args.push_back(
+            Builder.CreatePointerCast(X.getAddress(), ATy->getPointerTo()));
+        Args.push_back(
+            EmitScalarConversion(EmitAnyExpr(S.getExpr()).getScalarVal(),
+                S.getExpr()->getType(), AQTy));
+        EmitRuntimeCall(AtomicFunc, Args);
+      } else {
+        RValue Val = EmitAnyExpr(S.getExpr());
+        EmitRuntimeCall(OPENMPRTL_FUNC(atomic_start));
+        EmitStoreThroughLValue(Val, X);
+        EmitRuntimeCall(OPENMPRTL_FUNC(atomic_end));
+      }
+    }
+      break;
+    case OMPC_update: {
+      QualType QTyRes = S.getX()->getType();
+      QualType AQTyRes = OPENMPRTL_ATOMICTYPE(*this, QTyRes);
+      QualType QTyIn = S.getExpr()->getType();
+      QualType AQTyIn = OPENMPRTL_ATOMICTYPE(*this, QTyIn);
+      CGOpenMPRuntime::EAtomicOperation Aop;
+      switch (S.getOperator()) {
+      case BO_Add:
+        Aop = CGOpenMPRuntime::OMP_Atomic_add;
+        break;
+      case BO_Sub:
+        Aop = CGOpenMPRuntime::OMP_Atomic_sub;
+        break;
+      case BO_Mul:
+        Aop = CGOpenMPRuntime::OMP_Atomic_mul;
+        break;
+      case BO_Div:
+        Aop = CGOpenMPRuntime::OMP_Atomic_div;
+        break;
+      case BO_And:
+        Aop = CGOpenMPRuntime::OMP_Atomic_andb;
+        break;
+      case BO_Or:
+        Aop = CGOpenMPRuntime::OMP_Atomic_orb;
+        break;
+      case BO_Xor:
+        Aop = CGOpenMPRuntime::OMP_Atomic_xor;
+        break;
+      case BO_Shl:
+        Aop = CGOpenMPRuntime::OMP_Atomic_shl;
+        break;
+      case BO_Shr:
+        Aop = CGOpenMPRuntime::OMP_Atomic_shr;
+        break;
+      default:
+        Aop = CGOpenMPRuntime::OMP_Atomic_invalid;
+        break;
+      }
+      llvm::Value *AtomicFunc =
+          (AQTyRes.isNull() || AQTyIn.isNull()) ?
+              0 :
+              OPENMPRTL_ATOMIC_FUNC_GENERAL(AQTyRes, AQTyIn, Aop, false,
+                  S.isReversed());
+      if (X.isSimple() && AtomicFunc && QTyIn->isScalarType()
+          && !QTyIn->isAnyComplexType()) {
+        llvm::Type *ATyRes = ConvertTypeForMem(AQTyRes);
+        llvm::SmallVector<llvm::Value *, 5> Args;
+        // __kmpc_atomic_..._op(&loc, global_tid, &x, expr);
+        // ident_t loc = {...};
+        llvm::Value *Loc = OPENMPRTL_LOC(S.getLocStart(), *this);
+        // global_tid = __kmpc_global_thread_num(...);
+        llvm::Value *GTid = OPENMPRTL_THREADNUM(S.getLocStart(), *this);
+        Args.push_back(Loc);
+        Args.push_back(GTid);
+        Args.push_back(
+            Builder.CreatePointerCast(X.getAddress(), ATyRes->getPointerTo()));
+        Args.push_back(EmitAnyExpr(S.getExpr()).getScalarVal());
+        EmitRuntimeCall(AtomicFunc, Args);
+      } else {
+        EmitRuntimeCall(OPENMPRTL_FUNC(atomic_start));
+        EmitStmt(cast<CapturedStmt>(S.getAssociatedStmt())->getCapturedStmt());
+        EmitRuntimeCall(OPENMPRTL_FUNC(atomic_end));
+      }
+    }
+      break;
+    case OMPC_capture: {
+      QualType QTyRes = S.getX()->getType();
+      QualType AQTyRes = OPENMPRTL_ATOMICTYPE(*this, QTyRes);
+      QualType QTyIn = S.getExpr()->getType();
+      QualType AQTyIn = OPENMPRTL_ATOMICTYPE(*this, QTyIn);
+      CGOpenMPRuntime::EAtomicOperation Aop;
+      switch (S.getOperator()) {
+      case BO_Add:
+        Aop = CGOpenMPRuntime::OMP_Atomic_add;
+        break;
+      case BO_Sub:
+        Aop = CGOpenMPRuntime::OMP_Atomic_sub;
+        break;
+      case BO_Mul:
+        Aop = CGOpenMPRuntime::OMP_Atomic_mul;
+        break;
+      case BO_Div:
+        Aop = CGOpenMPRuntime::OMP_Atomic_div;
+        break;
+      case BO_And:
+        Aop = CGOpenMPRuntime::OMP_Atomic_andb;
+        break;
+      case BO_Or:
+        Aop = CGOpenMPRuntime::OMP_Atomic_orb;
+        break;
+      case BO_Xor:
+        Aop = CGOpenMPRuntime::OMP_Atomic_xor;
+        break;
+      case BO_Shl:
+        Aop = CGOpenMPRuntime::OMP_Atomic_shl;
+        break;
+      case BO_Shr:
+        Aop = CGOpenMPRuntime::OMP_Atomic_shr;
+        break;
+      case BO_Assign:
+        Aop = CGOpenMPRuntime::OMP_Atomic_assign;
+        break;
+      default:
+        Aop = CGOpenMPRuntime::OMP_Atomic_invalid;
+        break;
+      }
+      llvm::Value *AtomicFunc =
+          (AQTyRes.isNull() || AQTyIn.isNull()) ?
+              0 :
+              OPENMPRTL_ATOMIC_FUNC_GENERAL(AQTyRes, AQTyIn, Aop, true,
+                  S.isReversed());
+      if (X.isSimple() && AtomicFunc && QTyIn->isScalarType()
+          && !QTyIn->isAnyComplexType()) {
+        llvm::Type *ATy = ConvertTypeForMem(AQTyRes);
+        llvm::SmallVector<llvm::Value *, 5> Args;
+        // __kmpc_atomic_..._op(&loc, global_tid, &x, expr);
+        // ident_t loc = {...};
+        llvm::Value *Loc = OPENMPRTL_LOC(S.getLocStart(), *this);
+        // global_tid = __kmpc_global_thread_num(...);
+        llvm::Value *GTid = OPENMPRTL_THREADNUM(S.getLocStart(), *this);
+        Args.push_back(Loc);
+        Args.push_back(GTid);
+        Args.push_back(
+            Builder.CreatePointerCast(X.getAddress(), ATy->getPointerTo()));
+        Args.push_back(EmitAnyExpr(S.getExpr()).getScalarVal());
+        Args.push_back(Builder.getInt32(S.isCaptureAfter() ? 1 : 0));
+        llvm::Value *Res = EmitRuntimeCall(AtomicFunc, Args);
+        // v = x;
+        Res = EmitScalarConversion(Res, AQTyRes, S.getV()->getType());
+        EmitStoreOfScalar(Res, EmitLValue(S.getV()));
+      } else {
+        EmitRuntimeCall(OPENMPRTL_FUNC(atomic_start));
+        EmitStmt(cast<CapturedStmt>(S.getAssociatedStmt())->getCapturedStmt());
+        EmitRuntimeCall(OPENMPRTL_FUNC(atomic_end));
+      }
+    }
+      break;
+    case OMPC_seq_cst:
+      llvm_unreachable("SEQ_CST should be processed already.");
+      break;
+    default:
+      llvm_unreachable("Not allowed operation in atomic directive.");
+    }
+    if (I == E && !AtLeastOneLoopTaken)
+      break;
+    AtLeastOneLoopTaken = true;
+  }
+  if (IsSeqCst) {
+    SmallVector<llvm::Value *, 1> Args;
+    Args.push_back(OPENMPRTL_LOC(S.getLocStart(), *this));
+    EmitRuntimeCall(OPENMPRTL_FUNC(flush), Args);
+  }
+  CGM.OpenMPSupport.endOpenMPRegion();
+}
+
+/// "Two-calls" OMP Directives (master, single, critical, ordered).
+/// '#pragma omp master' directive.
+void CodeGenFunction::EmitOMPMasterDirective(const OMPMasterDirective &S) {
+  // if (__kmpc_master()) {
+  //   <captured_body>
+  //   __kmpc_end_master();
+  // }
+  EmitOMPConditionalIfHelper(S, OPENMPRTL_FUNC(master), S.getLocStart(),
+      OPENMPRTL_FUNC(end_master), S.getLocStart(), false, // pragma has no clauses
+      0,     // has no need for "didit"
+      "omp.master");
+}
+
+/// '#pragma omp single' directive.
+void CodeGenFunction::EmitOMPSingleDirective(const OMPSingleDirective &S) {
+
+  // Init list of private globals in the stack.
+  CGM.OpenMPSupport.startOpenMPRegion(false);
+  CGM.OpenMPSupport.setNoWait(false);
+  bool HasClauses = S.getNumClauses();
+  if (HasClauses) {
+    // Set NoWait flag if the clause nowait is there
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+        S.clauses().end(); I != E; ++I) {
+      if (*I)
+        EmitInitOMPClause(*(*I), S);
+    }
+  }
+
+  // did_it = 0;
+  // if (__kmpc_single()) {
+  //   <captured_body>
+  //   did_it = 1;
+  //   __kmpc_end_single();
+  // }
+  // ... if there is copyprivate clause, call to __kmpc_copyprivate()
+  // ... if there is no nowait, call to __kmpc_barrier()
+  //
+
+  // Create a "did_it" temp for passing into copyprivate routine.
+  llvm::AllocaInst *DidIt = CreateMemTemp(getContext().IntTy, ".did_it.");
+  InitTempAlloca(DidIt,
+      llvm::Constant::getNullValue(ConvertTypeForMem(getContext().IntTy)));
+
+  EmitOMPConditionalIfHelper(S, OPENMPRTL_FUNC(single), S.getLocStart(),
+      OPENMPRTL_FUNC(end_single), S.getLocStart(), HasClauses, // pragma has clauses (private and
+                                                               // firstprivate will be processed)
+      DidIt,                       // address to store 1 for "the single" thread
+      "omp.single");
+
+  // Copyprivate clause.
+  // Restrictions to copyprivate (from standard):
+  // The items that appear in copyprivate must be either threadprivate or
+  // private in the enclosing context.
+  // A list item that appears in copyprivate clause may not appear in a private
+  // or firstprivate clause on the single construct.
+  //
+  bool HasCopyPrivate = false;
+  for (ArrayRef<OMPClause *>::iterator ICL = S.clauses().begin(), ECL =
+      S.clauses().end(); ICL != ECL; ++ICL) {
+    if (*ICL) {
+      if (const OMPCopyPrivateClause *C = dyn_cast<OMPCopyPrivateClause>(
+          *ICL)) {
+        // Begin copyprivate clause processing
+        HasCopyPrivate = true;
+        // Start a copy-function.
+        CodeGenFunction CGF(CGM, true);
+        CGF.CurFn = 0;
+        FunctionArgList Args;
+        ImplicitParamDecl Arg1(getContext(), 0, SourceLocation(), 0,
+                               getContext().VoidPtrTy);
+        ImplicitParamDecl Arg2(getContext(), 0, SourceLocation(), 0,
+                               getContext().VoidPtrTy);
+        Args.push_back(&Arg1);
+        Args.push_back(&Arg2);
+        const CGFunctionInfo &FI =
+            CGF.getTypes().arrangeFreeFunctionDeclaration(
+                getContext().VoidTy, Args, FunctionType::ExtInfo(), false);
+        llvm::FunctionType *FTy = CGF.getTypes().GetFunctionType(FI);
+        llvm::Function *Fn = llvm::Function::Create(FTy,
+            llvm::GlobalValue::InternalLinkage, StringRef(".omp_copy_func."),
+            &CGM.getModule());
+        CGM.SetInternalFunctionAttributes(CurFuncDecl, Fn, FI);
+        CGF.StartFunction(GlobalDecl(), getContext().VoidTy, Fn, FI, Args,
+            SourceLocation());
+
+        // Generate the record of pointers - cpy.var
+        llvm::SmallVector<llvm::Type *, 16> CpyFieldTypes;
+        for (OMPCopyPrivateClause::varlist_const_iterator I =
+            C->varlist_begin(), E = C->varlist_end(); I != E; ++I) {
+          // const VarDecl *VD =
+          // cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl());
+          QualType QTy = (*I)->getType();
+          llvm::Type *PtrType = ConvertType(getContext().getPointerType(QTy));
+          CpyFieldTypes.push_back(PtrType);
+        }
+        llvm::StructType *CpyType = llvm::StructType::get(CGM.getLLVMContext(),
+            CpyFieldTypes);
+        llvm::AllocaInst *CpyVar = CreateTempAlloca(CpyType, "cpy.var");
+        CpyVar->setAlignment(CGM.PointerAlignInBytes);
+
+        // Generate initializaion of our local record with addresses.
+        int32_t FieldNum = 0;
+        for (OMPCopyPrivateClause::varlist_const_iterator I =
+            C->varlist_begin(), E = C->varlist_end(); I != E; ++I, ++FieldNum) {
+          // Store the address into our record.
+          Builder.CreateStore(EmitLValue(*I).getAddress(),
+              Builder.CreateConstGEP2_32(CpyVar, 0, FieldNum));
+        }
+
+        // Generate field copying in the copy-function.
+        {
+          llvm::Function::arg_iterator ArgIt = CGF.CurFn->arg_begin();
+          llvm::Value *DstPtr = ArgIt;
+          llvm::Value *SrcPtr = ++ArgIt;
+          llvm::Value *DstBase = CGF.Builder.CreatePointerCast(DstPtr,
+              CpyType->getPointerTo(), "cpy.dst");
+          llvm::Value *SrcBase = CGF.Builder.CreatePointerCast(SrcPtr,
+              CpyType->getPointerTo(), "cpy.src");
+
+          ArrayRef<const Expr *>::iterator AssignIter =
+              C->getAssignments().begin();
+          ArrayRef<const Expr *>::iterator VarIter1 =
+              C->getPseudoVars1().begin();
+          ArrayRef<const Expr *>::iterator VarIter2 =
+              C->getPseudoVars2().begin();
+          FieldNum = 0;
+          for (OMPCopyPrivateClause::varlist_const_iterator I =
+              C->varlist_begin(), E = C->varlist_end(); I != E;
+              ++I, ++AssignIter, ++VarIter1, ++VarIter2, ++FieldNum) {
+            // const VarDecl *VD =
+            // cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl());
+            QualType QTy = (*I)->getType();
+            llvm::Value *Dst = CGF.Builder.CreateConstGEP2_32(DstBase, 0,
+                FieldNum);
+            llvm::Value *Src = CGF.Builder.CreateConstGEP2_32(SrcBase, 0,
+                FieldNum);
+            llvm::Type *PtrType = ConvertType(getContext().getPointerType(QTy));
+            llvm::Value *LoadDst = CGF.EmitLoadOfScalar(Dst, false,
+                CGM.getDataLayout().getPrefTypeAlignment(PtrType),
+                getContext().getPointerType(QTy), SourceLocation());
+            llvm::Value *LoadSrc = CGF.EmitLoadOfScalar(Src, false,
+                CGM.getDataLayout().getPrefTypeAlignment(PtrType),
+                getContext().getPointerType(QTy), SourceLocation());
+            CGF.EmitCopyAssignment(I, AssignIter, VarIter1, VarIter2, LoadDst,
+                LoadSrc);
+          }
+        }
+
+        // Generate a call to __kmpc_copyprivate.
+        {
+          // __kmpc_copyprivate(ident_t *loc, int32_t global_tid,
+          //                    size_t cpy_size, void *cpy_data,
+          //                    kmp_copy_func cpy_func, int32_t didit);
+          llvm::Value *Loc = OPENMPRTL_LOC(C->getLocStart(), *this);
+          llvm::Value *GTid = OPENMPRTL_THREADNUM(C->getLocStart(), *this);
+          int32_t CpySizeInt = CGM.getDataLayout().getTypeAllocSize(CpyType);
+          llvm::Value *CpySize = llvm::ConstantInt::get(SizeTy, CpySizeInt);
+          llvm::Value *LoadDidIt = EmitLoadOfScalar(DidIt, false,
+              CGM.getDataLayout().getPrefTypeAlignment(
+                  DidIt->getType()->getSequentialElementType()),
+              getContext().IntTy, SourceLocation());
+          llvm::Value *RealArgs[] = {
+              Loc,
+              GTid,
+              CpySize,
+              Builder.CreateBitCast(CpyVar, VoidPtrTy, "(void*)cpyrec"),
+              CGF.CurFn,
+              LoadDidIt};
+          EmitRuntimeCall(OPENMPRTL_FUNC(copyprivate), RealArgs);
+        }
+
+        // Stop the copy-function.
+        CGF.FinishFunction();
+        // End copyprivate clause processing
+      }
+    }
+  }
+
+  if (!HasCopyPrivate && !CGM.OpenMPSupport.getNoWait()) {
+    // Note: __kmpc_copyprivate already has a couple of barriers internally.
+    EmitOMPCancelBarrier(S.getLocEnd(), KMP_IDENT_BARRIER_IMPL_SINGLE);
+  }
+
+  // Remove list of private globals from the stack.
+  CGM.OpenMPSupport.endOpenMPRegion();
+}
+
+/// '#pragma omp critical' directive.
+void CodeGenFunction::EmitOMPCriticalDirective(const OMPCriticalDirective &S) {
+  // __kmpc_critical();
+  // <captured_body>
+  // __kmpc_end_critical();
+  //
+
+  // Prepare kmp_critical_name -- the name of our critical section.
+  std::string directive_name = S.getDirectiveName().getAsString();
+  std::string name = ".gomp_critical_user_" + directive_name + ".var";
+  llvm::Type *LckTy = llvm::TypeBuilder<kmp_critical_name, false>::get(
+      CGM.getLLVMContext());
+  llvm::GlobalVariable *Lck = cast<llvm::GlobalVariable>(
+      CGM.CreateRuntimeVariable(LckTy, name.c_str()));
+  Lck->setLinkage(llvm::GlobalValue::CommonLinkage);
+  Lck->setInitializer(llvm::Constant::getNullValue(LckTy));
+
+  // Prepare other arguments and build a call to __kmpc_critical
+  llvm::Value *Loc = OPENMPRTL_LOC(S.getLocStart(), *this);
+  llvm::Value *GTid = OPENMPRTL_THREADNUM(S.getLocStart(), *this);
+  llvm::Value *RealArgs[] = {Loc, GTid, Lck};
+  EmitRuntimeCall(OPENMPRTL_FUNC(critical), RealArgs);
+  EmitOMPCapturedBodyHelper(S);
+  EmitRuntimeCall(OPENMPRTL_FUNC(end_critical), RealArgs);
+}
+
+/// '#pragma omp ordered' directive.
+void CodeGenFunction::EmitOMPOrderedDirective(const OMPOrderedDirective &S) {
+  // __kmpc_ordered();
+  //   <captured_body>
+  // __kmpc_enc_ordered();
+  //
+  EmitOMPCallWithLocAndTidHelper(OPENMPRTL_FUNC(ordered), S.getLocStart());
+  EmitOMPCapturedBodyHelper(S);
+  EmitOMPCallWithLocAndTidHelper(OPENMPRTL_FUNC(end_ordered), S.getLocStart());
+}
+
+/// '#pragma omp taskgroup' directive.
+void CodeGenFunction::EmitOMPTaskgroupDirective(
+    const OMPTaskgroupDirective &S) {
+  // __kmpc_taskgroup();
+  //   <captured_body>
+  // __kmpc_enc_taskgroup();
+  //
+  EmitOMPCallWithLocAndTidHelper(OPENMPRTL_FUNC(taskgroup), S.getLocStart());
+  EmitOMPCapturedBodyHelper(S);
+  EmitOMPCallWithLocAndTidHelper(OPENMPRTL_FUNC(end_taskgroup), S.getLocEnd());
+
+  // EmitUntiedPartIdInc(*this);
+  // EmitUntiedBranchEnd(*this);
+  // EmitUntiedTaskSwitch(*this, false);
+}
+
+void
+CodeGenFunction::EmitCloseOMPReductionClause(const OMPReductionClause &C,
+                                             const OMPExecutableDirective &S) {
+  (void)S;
+  assert(!isa<OMPSimdDirective>(S)); // Not yet supported
+  llvm::BasicBlock *RedBB1;
+  llvm::BasicBlock *RedBB2;
+  llvm::Instruction *IP1;
+  llvm::Instruction *IP2;
+  CGM.OpenMPSupport.getReductionIPs(RedBB1, IP1, RedBB2, IP2);
+  llvm::SwitchInst *Switch = dyn_cast_or_null<llvm::SwitchInst>(
+      CGM.OpenMPSupport.getReductionSwitch());
+  if (Switch && (IP1 || IP2 || RedBB1 || RedBB2)) {
+    CGBuilderTy::InsertPoint SavedIP = Builder.saveIP();
+    Builder.SetInsertPoint(RedBB1, IP1);
+    // __kmpc_end_reduce[_nowait](ident_t *loc, int32_t global_tid, *lck);
+    // ident_t loc = {...};
+    llvm::Value *Loc = OPENMPRTL_LOC(C.getLocStart(), *this);
+    // global_tid = __kmpc_global_thread_num(...);
+    llvm::Value *GTid = OPENMPRTL_THREADNUM(C.getLocStart(), *this);
+    // kmp_critical_name lck;
+    llvm::Value *RealArgs[] = {Loc, GTid,
+                               CGM.OpenMPSupport.getReductionLockVar()};
+    EmitRuntimeCall(CGM.OpenMPSupport.getNoWait()
+                        ? OPENMPRTL_FUNC(end_reduce_nowait)
+                        : OPENMPRTL_FUNC(end_reduce),
+                    RealArgs);
+    Builder.CreateBr(Switch->getDefaultDest());
+    // Switch->addCase(llvm::ConstantInt::get(Int32Ty, 1), RedBB1);
+    Builder.SetInsertPoint(RedBB2, IP2);
+    // __kmpc_end_reduce[_nowait](ident_t *loc, int32_t global_tid, *lck);
+    // ident_t loc = {...};
+    Loc = OPENMPRTL_LOC(C.getLocStart(), *this);
+    // global_tid = __kmpc_global_thread_num(...);
+    GTid = OPENMPRTL_THREADNUM(C.getLocStart(), *this);
+    // kmp_critical_name lck;
+    RealArgs[0] = Loc;
+    RealArgs[1] = GTid;
+    RealArgs[2] = CGM.OpenMPSupport.getReductionLockVar();
+    EmitRuntimeCall(CGM.OpenMPSupport.getNoWait()
+                        ? OPENMPRTL_FUNC(end_reduce_nowait)
+                        : OPENMPRTL_FUNC(end_reduce),
+                    RealArgs);
+    Builder.CreateBr(Switch->getDefaultDest());
+    // Switch->addCase(llvm::ConstantInt::get(Int32Ty, 2), RedBB2);
+    Builder.restoreIP(SavedIP);
+    CGM.OpenMPSupport.setReductionIPs(0, 0, 0, 0);
+  }
+
+  CodeGenFunction &CGF = CGM.OpenMPSupport.getCGFForReductionFunction();
+  llvm::Value *Arg1;
+  llvm::Value *Arg2;
+  CGM.OpenMPSupport.getReductionFunctionArgs(Arg1, Arg2);
+  ArrayRef<const Expr *>::iterator Par1I = C.getHelperParameters1st().begin();
+  ArrayRef<const Expr *>::iterator Par2I = C.getHelperParameters2nd().begin();
+  ArrayRef<const Expr *>::iterator OpI = C.getOpExprs().begin();
+  for (OMPReductionClause::varlist_const_iterator I = C.varlist_begin(), E =
+      C.varlist_end(); I != E; ++I, ++Par1I, ++Par2I, ++OpI) {
+    // Get element type.
+    const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl());
+    if (VD->hasLocalStorage()
+        && (!CapturedStmtInfo || !CapturedStmtInfo->lookup(VD)))
+      continue;
+    const VarDecl *Par1 = cast<VarDecl>(cast<DeclRefExpr>(*Par1I)->getDecl());
+    const VarDecl *Par2 = cast<VarDecl>(cast<DeclRefExpr>(*Par2I)->getDecl());
+    llvm::Value *Addr1 = CGF.Builder.CreateConstGEP2_32(Arg1, 0,
+        CGM.OpenMPSupport.getReductionVarIdx(VD),
+        CGM.getMangledName(VD) + ".addr.lhs");
+    llvm::Value *Addr2 = CGF.Builder.CreateConstGEP2_32(Arg2, 0,
+        CGM.OpenMPSupport.getReductionVarIdx(VD),
+        CGM.getMangledName(VD) + ".addr.rhs");
+    CGM.OpenMPSupport.addOpenMPPrivateVar(Par1, Addr1);
+    CGM.OpenMPSupport.addOpenMPPrivateVar(Par2, Addr2);
+    CGF.EmitIgnoredExpr(*OpI);
+    CGM.OpenMPSupport.delOpenMPPrivateVar(Par1);
+    CGM.OpenMPSupport.delOpenMPPrivateVar(Par2);
+  }
+}
+
+void
+CodeGenFunction::EmitFinalOMPReductionClause(const OMPReductionClause &,
+                                             const OMPExecutableDirective &S) {
+  (void)S;
+  assert(!isa<OMPSimdDirective>(S)); // Not yet supported
+  CodeGenFunction &CGF = CGM.OpenMPSupport.getCGFForReductionFunction();
+  if (CGF.CurFn) {
+    CGF.FinishFunction();
+    CGF.CurFn = 0;
+  }
+}
+
+// Implementation of '#pragma omp simd'.
+//
+
+SourceLocation CodeGenFunction::CGPragmaOmpSimd::getForLoc() const {
+  const CapturedStmt *Cap = cast<CapturedStmt>(SimdOmp->getAssociatedStmt());
+  const ForStmt *For = dyn_cast<ForStmt>(Cap->getCapturedStmt());
+  if (For) {
+    return For->getSourceRange().getBegin();
+  }
+  return SimdOmp->getSourceRange().getBegin();
+}
+
+SourceRange CodeGenFunction::CGPragmaOmpSimd::getSourceRange() const {
+  return SimdOmp->getSourceRange();
+}
+
+const Stmt *CodeGenFunction::CGPragmaOmpSimd::getInit() const {
+  return getInitFromLoopDirective(SimdOmp);
+}
+
+const Expr *CodeGenFunction::CGPragmaOmpSimd::getCond() const {
+  const CapturedStmt *Cap = dyn_cast_or_null<CapturedStmt>(getAssociatedStmt());
+  if (!Cap)
+    return 0;
+  const ForStmt *For = dyn_cast_or_null<ForStmt>(Cap->getCapturedStmt());
+  if (!For)
+    return 0;
+  return For->getCond();
+}
+
+const CapturedStmt *
+CodeGenFunction::CGPragmaOmpSimd::getAssociatedStmt() const {
+  return dyn_cast_or_null<CapturedStmt>(SimdOmp->getAssociatedStmt());
+}
+
+const Expr *CodeGenFunction::CGPragmaOmpSimd::getLoopCount() const {
+  const Expr *Op = getNewIterEndFromLoopDirective(SimdOmp);
+  if (const BinaryOperator *Bop = dyn_cast<BinaryOperator>(Op)) {
+    // Expected "N-1" here, so why not eat "-1" to get "N".
+    if (Bop->getOpcode() == BO_Sub) {
+      const Expr *Op = Bop->getRHS();
+      if (const ImplicitCastExpr *Cast = dyn_cast<ImplicitCastExpr>(Op)) {
+        Op = Cast->getSubExpr();
+      }
+      if (const IntegerLiteral *One = dyn_cast<IntegerLiteral>(Op)) {
+        if (One->getValue() == 1) {
+          return Bop->getLHS();
+        }
+      }
+    }
+  }
+  assert(0 && "Unexpected loop count expression");
+  return Op;
+}
+
+Stmt *CodeGenFunction::CGPragmaOmpSimd::extractLoopBody(Stmt *S) const {
+  // '#pragma omp simd' stores the full loop nest, and now we are
+  // going to extract the loop body.
+  unsigned CollapseNum = getCollapsedNumberFromLoopDirective(SimdOmp);
+  if (CollapseNum == 0) {
+    CollapseNum = 1;
+  }
+  Stmt *Body = S;
+  while (CollapseNum > 0) {
+    if (ForStmt *For = dyn_cast<ForStmt>(Body)) {
+      Body = For->getBody();
+      --CollapseNum;
+    } else if (AttributedStmt *AS = dyn_cast<AttributedStmt>(Body)) {
+      Body = AS->getSubStmt();
+    } else if (CompoundStmt *CS = dyn_cast<CompoundStmt>(Body)) {
+      if (CS->size() == 1) {
+        Body = CS->body_back();
+      } else {
+        assert(0 && "Unexpected compound stmt in the loop nest");
+      }
+    } else {
+      assert(0 && "Unexpected stmt in the loop nest");
+    }
+  }
+  assert(Body && "Failed to extract the loop body for 'omp simd'");
+  return Body;
+}
+
+// Simd wrappers implementation for '#pragma omp simd'.
+bool CodeGenFunction::CGPragmaOmpSimd::emitSafelen(CodeGenFunction *CGF) const {
+  bool SeparateLastIter = false;
+  CGF->LoopStack.SetParallel();
+  CGF->LoopStack.SetVectorizerEnable(true);
+  for (ArrayRef<OMPClause *>::iterator I = SimdOmp->clauses().begin(), E =
+      SimdOmp->clauses().end(); I != E; ++I) {
+    OMPClause *C = dyn_cast<OMPClause>(*I);
     switch (C->getClauseKind()) {
     case OMPC_safelen: {
-      RValue Len = EmitAnyExpr(cast<OMPSafelenClause>(C)->getSafelen(),
-                               AggValueSlot::ignored(), true);
-      llvm::ConstantInt *Val = cast<llvm::ConstantInt>(Len.getScalarVal());
-      LoopStack.setVectorizerWidth(Val->getZExtValue());
+      RValue Len = CGF->EmitAnyExpr(cast<OMPSafelenClause>(C)->getSafelen(),
+          AggValueSlot::ignored(), true);
+      llvm::ConstantInt *Val = dyn_cast<llvm::ConstantInt>(Len.getScalarVal());
+      assert(Val);
+      CGF->LoopStack.SetVectorizerWidth(Val->getZExtValue());
       // In presence of finite 'safelen', it may be unsafe to mark all
       // the memory instructions parallel, because loop-carried
       // dependences of 'safelen' iterations are possible.
-      LoopStack.setParallel(false);
+      CGF->LoopStack.SetParallel(false);
+      break;
+    }
+    case OMPC_lastprivate: {
+      SeparateLastIter = true;
       break;
     }
     default:
@@ -71,60 +4903,657 @@
       ;
     }
   }
-  EmitStmt(Body);
+  return SeparateLastIter;
+}
+
+llvm::ConstantInt *
+CodeGenFunction::CGPragmaOmpSimd::emitClauseTail(CodeGenFunction *CGF,
+    Expr *E) const {
+  // Emit a constant integer for clause's tail expression.
+  // E can be an integer or NULL.
+  llvm::ConstantInt *Val = 0;
+  if (E != 0) {
+    RValue RVal = CGF->EmitAnyExpr(E, AggValueSlot::ignored(), true);
+    Val = dyn_cast<llvm::ConstantInt>(RVal.getScalarVal());
+  } else {
+    Val = cast<llvm::ConstantInt>(
+        llvm::ConstantInt::getNullValue(CGF->CGM.IntTy));
+  }
+  assert(Val);
+  return Val;
+}
+
+// Walker for '#pragma omp simd'
+bool CodeGenFunction::CGPragmaOmpSimd::walkLocalVariablesToEmit(
+    CodeGenFunction *CGF, CGSIMDForStmtInfo *) const {
+
+  // Init the OpenMP local vars stack.
+  CGF->CGM.OpenMPSupport.startOpenMPRegion(true);
+  CGF->CGM.OpenMPSupport.setMergeable(false);
+  CGF->CGM.OpenMPSupport.setOrdered(false);
+
+  // Make sure we have local vars for all the loop counters.
+  ArrayRef<Expr *> Counters = getCountersFromLoopDirective(SimdOmp);
+  for (unsigned I = 0; I < getCollapsedNumberFromLoopDirective(SimdOmp); ++I) {
+    const VarDecl *VD = cast<VarDecl>(
+        cast<DeclRefExpr>(Counters[I])->getDecl());
+    if (CGF->CGM.OpenMPSupport.getTopOpenMPPrivateVar(VD))
+      continue;
+    QualType QTy = Counters[I]->getType();
+    llvm::AllocaInst *Private = CGF->CreateMemTemp(QTy,
+        CGF->CGM.getMangledName(VD) + ".counter.");
+    CGF->CGM.OpenMPSupport.addOpenMPPrivateVar(VD, Private);
+  }
+
+  // Here we push index parameter into openmp map.
+  // It is useful for loop counters calculation.
+  const CapturedDecl *CD =
+      cast<CapturedStmt>(getAssociatedStmt())->getCapturedDecl();
+  llvm::Value *LoopIndex = CGF->LocalDeclMap.lookup(CD->getParam(1));
+  const VarDecl *IndexVD = cast<VarDecl>(
+      cast<DeclRefExpr>(getNewIterVarFromLoopDirective(SimdOmp))->getDecl());
+  CGF->CGM.OpenMPSupport.addOpenMPPrivateVar(IndexVD, LoopIndex);
+
+  for (ArrayRef<OMPClause *>::iterator I = SimdOmp->clauses().begin(), E =
+      SimdOmp->clauses().end(); I != E; ++I) {
+    OMPClause *C = dyn_cast<OMPClause>(*I);
+    switch (C->getClauseKind()) {
+    case OMPC_private: {
+      CGF->EmitPreOMPClause(*(*I), *SimdOmp);
+      break;
+    }
+    case OMPC_lastprivate: {
+      CGF->EmitPreOMPClause(*(*I), *SimdOmp);
+      break;
+    }
+    case OMPC_linear: {
+      // Linear vars are calculated from index, similar to loop indices.
+      OMPLinearClause *L = cast<OMPLinearClause>(C);
+      for (OMPLinearClause::varlist_const_iterator J = L->varlist_begin(), F =
+          L->varlist_end(); J != F; ++J) {
+        const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(*J)->getDecl());
+        if (CGF->CGM.OpenMPSupport.getTopOpenMPPrivateVar(VD)) {
+          continue;
+        }
+        QualType QTy = (*J)->getType();
+        llvm::Value *Private = CGF->CreateMemTemp(QTy,
+            CGF->CGM.getMangledName(VD) + ".linear.");
+
+        // Generate "Private = Index * Step + Start"
+        llvm::Value *Start = CGF->EmitAnyExprToTemp(*J).getScalarVal();
+        llvm::Value *Index = CGF->Builder.CreateLoad(LoopIndex);
+        llvm::Value *Result = 0;
+        if (const Expr *StepExpr = L->getStep()) {
+          Result = CGF->EmitAnyExpr(StepExpr).getScalarVal();
+          QualType IndexTy = CD->getParam(1)->getType();
+          Result = CGF->Builder.CreateIntCast(Result, Index->getType(),
+              IndexTy->hasSignedIntegerRepresentation());
+        } else
+          Result = llvm::ConstantInt::get(Index->getType(), 1);
+        Result = CGF->Builder.CreateMul(Index, Result);
+        if (Start->getType()->isPointerTy()) {
+          Result = CGF->Builder.CreateGEP(Start, Result);
+        } else {
+          Result = CGF->Builder.CreateIntCast(Result, Start->getType(), false);
+          Result = CGF->Builder.CreateAdd(Start, Result, "add", false,
+              QTy->isSignedIntegerOrEnumerationType());
+        }
+        CGF->Builder.CreateStore(Result, Private);
+
+        CGF->CGM.OpenMPSupport.addOpenMPPrivateVar(VD, Private);
+      }
+      break;
+    }
+    default:
+      break;
+    }
+  }
+
+  // Mark 'aligned' variables -- do this after all private variables are
+  // made 'omp-private' in CGM.OpenMPSupport.
+  for (ArrayRef<OMPClause *>::iterator I = SimdOmp->clauses().begin(), E =
+      SimdOmp->clauses().end(); I != E; ++I) {
+    OMPClause *C = dyn_cast<OMPClause>(*I);
+    switch (C->getClauseKind()) {
+    case OMPC_aligned: {
+      OMPAlignedClause *A = cast<OMPAlignedClause>(C);
+      // Prepare alignment expression for using it below.
+      llvm::ConstantInt *AVal = emitClauseTail(CGF, A->getAlignment());
+      // Walk the list and push each var's alignment into metadata.
+      for (OMPAlignedClause::varlist_iterator J = A->varlist_begin(), F =
+          A->varlist_end(); J != F; ++J) {
+        LValue LVal = CGF->EmitLValue(*J);
+        CGF->LoopStack.AddAligned(LVal.getAddress(),
+            (int) (AVal->getZExtValue()));
+      }
+      break;
+    }
+    default:
+      break;
+    }
+  }
+
+  // Emit initializations of loop indices.
+  CGF->EmitStmt(getInitFromLoopDirective(SimdOmp));
+  return false;
+}
+
+void CodeGenFunction::CGPragmaOmpSimd::emitInit(CodeGenFunction &CGF,
+    llvm::Value *&LoopIndex, llvm::Value *&LoopCount) {
+  // Emit loop index
+  const Expr *IterVar = getNewIterVarFromLoopDirective(SimdOmp);
+  LoopIndex = CGF.CreateMemTemp(IterVar->getType(), ".idx.");
+  const VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(IterVar)->getDecl());
+  CGF.CGM.OpenMPSupport.addOpenMPPrivateVar(VD, LoopIndex);
+
+  // Emit loop count.
+  LoopCount = CGF.EmitAnyExpr(getLoopCount()).getScalarVal();
+}
+
+// Emit the final values of the loop counters and linear vars.
+void CodeGenFunction::CGPragmaOmpSimd::emitLinearFinal(
+    CodeGenFunction &CGF) const {
+
+  // Check if we need to update the loop counters.
+  bool NeedUpdateLC = true;
+  ArrayRef<Expr *> Counters = getCountersFromLoopDirective(SimdOmp);
+  for (unsigned I = 0; I < getCollapsedNumberFromLoopDirective(SimdOmp); ++I) {
+    const DeclRefExpr *DRE = cast<DeclRefExpr>(Counters[I]);
+    if (!CGF.LocalDeclMap.lookup(DRE->getDecl())) {
+      NeedUpdateLC = false;
+    }
+  }
+
+  // Emit final values of the loop-counters.
+  if (NeedUpdateLC)
+    CGF.EmitStmt(getFinalFromLoopDirective(SimdOmp));
+
+  // Emit final values of the linear vars.
+  for (ArrayRef<OMPClause *>::iterator I = SimdOmp->clauses().begin(), E =
+      SimdOmp->clauses().end(); I != E; ++I) {
+    OMPClause *C = dyn_cast<OMPClause>(*I);
+    switch (C->getClauseKind()) {
+    case OMPC_linear: {
+      OMPLinearClause *L = cast<OMPLinearClause>(C);
+      for (OMPLinearClause::varlist_const_iterator J = L->varlist_begin(), F =
+          L->varlist_end(); J != F; ++J) {
+
+        // Generate "L = LoopCount * Step + L"
+        const Expr *CountExpr = getLoopCount();
+        llvm::Value *Index = CGF.EmitAnyExpr(CountExpr).getScalarVal();
+        llvm::Value *Result = 0;
+        if (const Expr *StepExpr = L->getStep()) {
+          Result = CGF.EmitAnyExpr(StepExpr).getScalarVal();
+          QualType IndexTy = CountExpr->getType();
+          Result = CGF.Builder.CreateIntCast(Result, Index->getType(),
+              IndexTy->hasSignedIntegerRepresentation());
+        } else
+          Result = llvm::ConstantInt::get(Index->getType(), 1);
+        Result = CGF.Builder.CreateMul(Index, Result);
+
+        // Prepare destination lvalue to store result into.
+        LValue LV = CGF.EmitLValue(*J);
+        llvm::Value *Start =
+            CGF.EmitLoadOfLValue(LV, (*J)->getExprLoc()).getScalarVal();
+
+        if (Start->getType()->isPointerTy()) {
+          Result = CGF.Builder.CreateGEP(Start, Result);
+        } else {
+          Result = CGF.Builder.CreateIntCast(Result, Start->getType(), false);
+          Result = CGF.Builder.CreateAdd(Start, Result, "add", false,
+              (*J)->getType()->isSignedIntegerOrEnumerationType());
+        }
+        CGF.EmitStoreOfScalar(Result, LV, false);
+      }
+      break;
+    }
+    default:
+      break;
+    }
+  }
+}
+
+/// Generate an instructions for '#pragma omp teams' directive.
+void CodeGenFunction::EmitOMPTeamsDirective(const OMPTeamsDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  EmitOMPDirectiveWithTeams(OMPD_teams, OMPD_unknown, S);
+}
+
+// Generate the instructions for '#pragma omp simd' directive.
+void CodeGenFunction::EmitOMPSimdDirective(const OMPSimdDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  CGPragmaOmpSimd Wrapper(&S);
+  EmitPragmaSimd(Wrapper);
+}
+
+// Generate the instructions for '#pragma omp for simd' directive.
+void CodeGenFunction::EmitOMPForSimdDirective(const OMPForSimdDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  EmitOMPDirectiveWithLoop(OMPD_for_simd, OMPD_for_simd, S);
 }
 
-void CodeGenFunction::EmitOMPForDirective(const OMPForDirective &) {
-  llvm_unreachable("CodeGen for 'omp for' is not supported yet.");
+// Generate the instructions for '#pragma omp distribute simd' directive.
+void CodeGenFunction::EmitOMPDistributeSimdDirective(
+    const OMPDistributeSimdDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  EmitOMPDirectiveWithLoop(OMPD_distribute_simd, OMPD_distribute_simd, S);
 }
 
-void CodeGenFunction::EmitOMPSectionsDirective(const OMPSectionsDirective &) {
-  llvm_unreachable("CodeGen for 'omp sections' is not supported yet.");
+// Generate the instructions for '#pragma omp distribute parallel for'
+// directive.
+void CodeGenFunction::EmitOMPDistributeParallelForDirective(
+    const OMPDistributeParallelForDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  assert(S.getLowerBound() && "No lower bound");
+  assert(S.getUpperBound() && "No upper bound");
+  EmitAutoVarDecl(
+      *cast<VarDecl>(cast<DeclRefExpr>(S.getLowerBound())->getDecl()));
+  EmitAutoVarDecl(
+      *cast<VarDecl>(cast<DeclRefExpr>(S.getUpperBound())->getDecl()));
+  EmitOMPDirectiveWithLoop(OMPD_distribute_parallel_for, OMPD_distribute, S);
 }
 
-void CodeGenFunction::EmitOMPSectionDirective(const OMPSectionDirective &) {
-  llvm_unreachable("CodeGen for 'omp section' is not supported yet.");
+// Generate the instructions for '#pragma omp distribute parallel for simd'
+// directive.
+void CodeGenFunction::EmitOMPDistributeParallelForSimdDirective(
+    const OMPDistributeParallelForSimdDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  assert(S.getLowerBound() && "No lower bound");
+  assert(S.getUpperBound() && "No upper bound");
+  EmitAutoVarDecl(
+      *cast<VarDecl>(cast<DeclRefExpr>(S.getLowerBound())->getDecl()));
+  EmitAutoVarDecl(
+      *cast<VarDecl>(cast<DeclRefExpr>(S.getUpperBound())->getDecl()));
+  EmitOMPDirectiveWithLoop(OMPD_distribute_parallel_for_simd, OMPD_distribute,
+                           S);
 }
 
-void CodeGenFunction::EmitOMPSingleDirective(const OMPSingleDirective &) {
-  llvm_unreachable("CodeGen for 'omp single' is not supported yet.");
+// Generate the instructions for '#pragma omp teams distribute parallel for'
+// directive.
+void CodeGenFunction::EmitOMPTeamsDistributeParallelForDirective(
+    const OMPTeamsDistributeParallelForDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  EmitOMPDirectiveWithTeams(OMPD_teams_distribute_parallel_for,
+                            OMPD_distribute_parallel_for, S);
 }
 
-void CodeGenFunction::EmitOMPMasterDirective(const OMPMasterDirective &) {
-  llvm_unreachable("CodeGen for 'omp master' is not supported yet.");
+// Generate the instructions for '#pragma omp teams distribute parallel for simd'
+// directive.
+void CodeGenFunction::EmitOMPTeamsDistributeParallelForSimdDirective(
+    const OMPTeamsDistributeParallelForSimdDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  EmitOMPDirectiveWithTeams(OMPD_teams_distribute_parallel_for_simd,
+                            OMPD_distribute_parallel_for_simd, S);
 }
 
-void CodeGenFunction::EmitOMPCriticalDirective(const OMPCriticalDirective &) {
-  llvm_unreachable("CodeGen for 'omp critical' is not supported yet.");
+// Generate the instructions for '#pragma omp target teams distribute parallel
+// for' directive.
+void CodeGenFunction::EmitOMPTargetTeamsDistributeParallelForDirective(
+    const OMPTargetTeamsDistributeParallelForDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  EmitOMPDirectiveWithTeams(OMPD_target_teams_distribute_parallel_for,
+                            OMPD_distribute_parallel_for, S);
+}
+
+// Generate the instructions for '#pragma omp target teams distribute parallel
+// for simd' directive.
+void CodeGenFunction::EmitOMPTargetTeamsDistributeParallelForSimdDirective(
+    const OMPTargetTeamsDistributeParallelForSimdDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  EmitOMPDirectiveWithTeams(OMPD_target_teams_distribute_parallel_for_simd,
+                            OMPD_distribute_parallel_for_simd, S);
+}
+
+// Generate the instructions for '#pragma omp target' directive.
+void CodeGenFunction::EmitOMPTargetDirective(const OMPTargetDirective &S) {
+
+  CapturedStmt *CS = cast<CapturedStmt>(S.getAssociatedStmt());
+
+  // Are we generating code for a target?
+  bool isTargetMode = CGM.getLangOpts().OpenMPTargetMode;
+
+  assert( !(isTargetMode && CGM.getLangOpts().OMPTargetTriples.empty())
+      && "Are we in target mode and no targets were specified??" );
+
+  // If there are no devices specified we ignore the target directive and just
+  // produce regular host code
+  if (CGM.getLangOpts().OMPTargetTriples.empty()){
+    EmitStmt(CS->getCapturedStmt());
+    return;
+  }
+
+  CGM.OpenMPSupport.startOpenMPRegion(true);
+
+  const RecordDecl *RD = CS->getCapturedRecordDecl();
+
+  // Create the target function
+  IdentifierInfo *Id = &getContext().Idents.get(
+      CGM.getOpenMPRuntime().GetOffloadEntryMangledName(
+          (isTargetMode) ? CGM.getTarget().getTriple() : llvm::Triple()));
+
+  SmallVector<QualType, 4> FnArgTypes;
+  FunctionArgList FnArgs;
+
+  // Get function type
+  for (RecordDecl::field_iterator fb = RD->field_begin(), fe = RD->field_end();
+      fb != fe; ++fb) {
+
+    QualType QTy = (*fb)->getType();
+    if (QTy->isVariablyModifiedType()) {
+      EmitVariablyModifiedType(QTy);
+    }
+
+    FnArgTypes.push_back(QTy);
+  }
+
+  FunctionProtoType::ExtProtoInfo EPI;
+  EPI.ExceptionSpecType = EST_BasicNoexcept;
+  QualType FnTy = getContext().getFunctionType(getContext().VoidTy, FnArgTypes,
+      EPI);
+
+  // Create function declaration
+  TypeSourceInfo *TI = getContext().getTrivialTypeSourceInfo(FnTy,
+      SourceLocation());
+  FunctionDecl *FD = FunctionDecl::Create(getContext(),
+      getContext().getTranslationUnitDecl(), CS->getLocStart(),
+      SourceLocation(), Id, FnTy, TI, SC_Static, false, false, false);
+
+  // Create function arguments
+  for (RecordDecl::field_iterator fb = RD->field_begin(), fe = RD->field_end();
+      fb != fe; ++fb) {
+    QualType QTy = (*fb)->getType();
+    TypeSourceInfo *TI = getContext().getTrivialTypeSourceInfo(QTy,
+        SourceLocation());
+    ParmVarDecl *Arg = ParmVarDecl::Create(getContext(), FD, SourceLocation(),
+        SourceLocation(), 0, QTy, TI, SC_Auto, 0);
+    FnArgs.push_back(Arg);
+  }
+
+  CodeGenFunction CGF(CGM, true);
+  const CGFunctionInfo &FI = getTypes().arrangeFunctionDeclaration(FD);
+  // The linkage here is going to be overwritten when the attributes are set
+  llvm::Function *Fn = llvm::Function::Create(getTypes().GetFunctionType(FI),
+      llvm::GlobalValue::PrivateLinkage, FD->getName(), &CGM.getModule());
+
+  // PostProcess the function definition for the target and set the function
+  // attributes based on the enclosing function
+  // but force target functions to external linkage
+  CGM.getOpenMPRuntime().PostProcessTargetFunction(CurFuncDecl, Fn, FI);
+
+  if (isTargetMode)
+    Fn->setLinkage(llvm::GlobalValue::ExternalLinkage);
+  CGF.OpenMPRoot = OpenMPRoot ? OpenMPRoot : this;
+  CGF.StartFunction(FD, getContext().VoidTy, Fn, FI, FnArgs, SourceLocation());
+
+  OpenMPRegionRAII OMPRegion(CGF, *CS);
+
+  CGF.EmitStmt(CS->getCapturedStmt());
+  CGF.FinishFunction();
+
+  // If we are generating code for the host, we need to emit the runtime calls
+  if (!isTargetMode) {
+
+
+    // If no target region registration was emitted before for the current
+    // function we have to do it now
+    if ( !CGM.getOpenMPRuntime().getFunctionRegisterTarget(CurFn) ){
+
+      llvm::Constant *TgtDesc =
+          CGM.getOpenMPRuntime().GetTargetRegionsDescriptor();
+
+      SmallVector<llvm::Value*,1> Args; Args.push_back(TgtDesc);
+
+      // Create tgt_register
+      llvm::CallInst::Create(OPENMPRTL_FUNC(register_lib),Args, "",
+          CurFn->begin()->begin());
+
+      // Register this function in the runtime as containing a target
+      // registration call
+      CGM.getOpenMPRuntime().setFunctionRegisterTarget(CurFn);
+    }
+
+    // Codegen target clauses init
+    // For now, only device and map clause is implemented
+    for (ArrayRef<OMPClause *>::iterator I = S.clauses().begin(), E =
+        S.clauses().end(); I != E; ++I)
+      if (*I && isAllowedClauseForDirective(S.getDirectiveKind(), (*I)->getClauseKind()))
+        EmitInitOMPClause(*(*I), S);
+
+    // Get or create value with the deviceID (default is zero)
+    llvm::Value *DeviceID = (CGM.OpenMPSupport.getOffloadingDevice())
+        ? CGM.OpenMPSupport.getOffloadingDevice()
+        : (llvm::Value*)Builder.getInt32(0);
+
+    // Create data begin with the results of the map clause
+
+    ArrayRef<llvm::Value*> MapClausePointerValues;
+    ArrayRef<llvm::Value*> MapClauseSizeValues;
+    ArrayRef<unsigned> MapClauseTypeValues;
+
+    CGM.OpenMPSupport.getMapData(MapClausePointerValues,
+        MapClauseSizeValues,
+        MapClauseTypeValues);
+    // Allocate arrays in the stack or internal constants to keep the map data
+    // information
+    // - Pointers (addresses)
+    // - Sizes
+    // - Types (to, from, to/from)
+
+    assert( MapClausePointerValues.size() == MapClauseSizeValues.size()
+        && MapClausePointerValues.size() == MapClauseTypeValues.size()
+        && "Map data arrays size mismatch!");
+
+    llvm::Value *MapClausePointers = 0;
+    llvm::Value *MapClauseSizes = 0;
+    llvm::Value *MapClauseTypes = 0;
+    llvm::Value *MapClauseNumElems =
+        Builder.getInt32(MapClausePointerValues.size());
+
+    // If we have pointers, lets create an array in the stack
+    if( !MapClausePointerValues.empty() ){
+      MapClausePointers = Builder.CreateAlloca(CGM.VoidPtrTy,
+          MapClauseNumElems,".mapped_ptrs");
+      MapClauseSizes = Builder.CreateAlloca(CGM.Int32Ty,
+          MapClauseNumElems,".mapped_sizes");
+
+      llvm::Constant *MapClauseTypesInit = llvm::ConstantDataArray::get(
+          Builder.getContext(),
+          MapClauseTypeValues);
+      llvm::GlobalVariable *MapClauseTypesTmp = new llvm::GlobalVariable(
+          CGM.getModule(),
+          MapClauseTypesInit->getType(),
+          true, llvm::GlobalValue::PrivateLinkage,
+          MapClauseTypesInit, ".mapped_types");
+
+      MapClauseTypes =
+          Builder.CreateConstInBoundsGEP2_32(MapClauseTypesTmp,0,0);
+
+      for(unsigned i=0; i<MapClausePointerValues.size(); ++i){
+
+        llvm::Value *P = Builder.CreateConstInBoundsGEP1_32(MapClausePointers,i);
+        llvm::Value *S = Builder.CreateConstInBoundsGEP1_32(MapClauseSizes,i);
+
+        Builder.CreateStore(MapClausePointerValues[i],P);
+        Builder.CreateStore(MapClauseSizeValues[i],S);
+      }
+
+      llvm::Value *Args[] = {DeviceID, MapClauseNumElems, MapClausePointers,
+                                    MapClauseSizes, MapClauseTypes};
+      EmitRuntimeCall(OPENMPRTL_FUNC(target_data_begin), Args);
+    }
+
+    // Obtain region arguments' references and fill the arguments ptr and size array
+    //
+    llvm::SmallVector<llvm::Value*, 8> RealArgPointerValues;
+
+    llvm::Value *RealArgNumElems = Builder.getInt32(FnArgs.size());
+    llvm::Value *RealArgPointers = 0;
+    llvm::Value *RealArgSizes = 0;
+    llvm::Value *RealArgTypes = 0;
+
+    if( !FnArgs.empty() ){
+
+      llvm::SmallVector<unsigned, 8> RealArgSizeValues;
+      llvm::SmallVector<unsigned, 8> RealArgTypeValues;
+
+      RealArgPointers = Builder.CreateAlloca(CGM.VoidPtrTy,
+          RealArgNumElems, ".tgt_ptrs");
+
+      // Add the variables captured in the target region to the map clause ones
+
+      // This is the default type
+      unsigned VT = OMP_TGT_MAPTYPE_TOFROM;
+
+      RecordDecl::field_iterator fb = RD->field_begin();
+      unsigned idx = 0;
+
+      for (CapturedStmt::capture_init_iterator ci = CS->capture_init_begin(), ce =
+          CS->capture_init_end(); ci != ce; ++ci, ++fb, ++idx) {
+
+        QualType QTy = (*fb)->getType();
+        LValue LV = MakeNaturalAlignAddrLValue(CreateMemTemp(QTy, ".tgt_arg"),
+            QTy);
+        EmitInitializerForField(*fb, LV, *ci, ArrayRef<VarDecl *>());
+
+        llvm::Value *Arg = Builder.CreateLoad(LV.getAddress());
+        llvm::PointerType *ArgTy = cast<llvm::PointerType>(Arg->getType());
+        RealArgPointerValues.push_back(Arg);
+
+        llvm::Value *VP = Builder.CreateBitCast(Arg,CGM.VoidPtrTy);
+        unsigned VS =
+            CGM.getDataLayout().getTypeSizeInBits(ArgTy->getElementType()) / 8;
+
+        llvm::Value *P = Builder.CreateConstInBoundsGEP1_32(RealArgPointers,idx);
+
+        Builder.CreateStore(VP,P);
+        RealArgSizeValues.push_back(VS);
+        RealArgTypeValues.push_back(VT);
+      }
+
+      llvm::Constant *RealArgSizesInit = llvm::ConstantDataArray::get(
+          Builder.getContext(),
+          RealArgSizeValues);
+      llvm::Constant *RealArgTypesInit = llvm::ConstantDataArray::get(
+          Builder.getContext(),
+          RealArgTypeValues);
+      llvm::GlobalVariable *RealArgSizesTmp = new llvm::GlobalVariable(
+          CGM.getModule(),
+          RealArgSizesInit->getType(),
+          true, llvm::GlobalValue::PrivateLinkage,
+          RealArgSizesInit, ".tgt_sizes");
+      llvm::GlobalVariable *RealArgTypesTmp = new llvm::GlobalVariable(
+          CGM.getModule(),
+          RealArgTypesInit->getType(),
+          true, llvm::GlobalValue::PrivateLinkage,
+          RealArgTypesInit, ".tgt_types");
+
+      RealArgSizes =
+          Builder.CreateConstInBoundsGEP2_32(RealArgSizesTmp,0,0);
+      RealArgTypes =
+          Builder.CreateConstInBoundsGEP2_32(RealArgTypesTmp,0,0);
+
+    } else {
+      RealArgPointers = llvm::Constant::getNullValue(CGM.VoidPtrPtrTy);
+      RealArgSizes = llvm::Constant::getNullValue(CGM.Int32Ty->getPointerTo());
+      RealArgTypes = llvm::Constant::getNullValue(CGM.Int32Ty->getPointerTo());
+    }
+
+    // Create call to tgt_target
+    llvm::SmallVector<llvm::Value*, 8> TgtArgs;
+    TgtArgs.push_back(DeviceID);
+    TgtArgs.push_back(CGM.getOpenMPRuntime().GetHostPtrForCurrentTargetRegion());
+    TgtArgs.push_back(RealArgNumElems);
+    TgtArgs.push_back(RealArgPointers);
+    TgtArgs.push_back(RealArgSizes);
+    TgtArgs.push_back(RealArgTypes);
+
+    llvm::Value *TgtTargetFn = OPENMPRTL_FUNC(target);
+    llvm::Value *Offload = Builder.CreateCall(TgtTargetFn,TgtArgs,"offloadret");
+
+    // Create call to host if offloading failed
+    llvm::Value *OffloadSuccess = Builder.CreateICmpEQ(Offload,
+        Builder.getInt32(0));
+
+    llvm::BasicBlock *OffloadFailedBB = this->createBasicBlock("offload_fail",
+        this->CurFn);
+    llvm::BasicBlock *AfterOffloadBB = this->createBasicBlock("after_offload",
+        this->CurFn);
+
+    Builder.CreateCondBr(OffloadSuccess, AfterOffloadBB, OffloadFailedBB);
+    Builder.SetInsertPoint(OffloadFailedBB);
+    Builder.CreateCall(Fn, RealArgPointerValues);
+    Builder.CreateBr(AfterOffloadBB);
+    Builder.SetInsertPoint(AfterOffloadBB);
+
+    // Emit data_end if required
+    if (MapClausePointers){
+      llvm::Value *Args[] = {DeviceID, MapClauseNumElems, MapClausePointers,
+                                  MapClauseSizes, MapClauseTypes};
+      EmitRuntimeCall(OPENMPRTL_FUNC(target_data_end), Args);
+    }
+  }
+
+  //Increment the counter of target regions
+  CGM.getOpenMPRuntime().incNumOfProcessedTargetRegions();
+
+  // Remove list of private globals from the stack.
+  CGM.OpenMPSupport.endOpenMPRegion();
 }
 
+// Generate the instructions for '#pragma omp target data' directive.
 void
-CodeGenFunction::EmitOMPParallelForDirective(const OMPParallelForDirective &) {
-  llvm_unreachable("CodeGen for 'omp parallel for' is not supported yet.");
+CodeGenFunction::EmitOMPTargetDataDirective(const OMPTargetDataDirective &S) {
+  // TODO Need to implement proper codegen for target oriented directives.
+  CapturedStmt *CS = cast<CapturedStmt>(S.getAssociatedStmt());
+  EmitStmt(CS->getCapturedStmt());
 }
 
-void CodeGenFunction::EmitOMPParallelSectionsDirective(
-    const OMPParallelSectionsDirective &) {
-  llvm_unreachable("CodeGen for 'omp parallel sections' is not supported yet.");
+// Generate the instructions for '#pragma omp target update' directive.
+void CodeGenFunction::EmitOMPTargetUpdateDirective(
+    const OMPTargetUpdateDirective &) {
+  // TODO Need to implement proper codegen for target oriented directives.
+  ;
 }
 
-void CodeGenFunction::EmitOMPTaskDirective(const OMPTaskDirective &) {
-  llvm_unreachable("CodeGen for 'omp task' is not supported yet.");
+// Generate the instructions for '#pragma omp target teams' directive.
+void
+CodeGenFunction::EmitOMPTargetTeamsDirective(const OMPTargetTeamsDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  EmitOMPDirectiveWithTeams(OMPD_target_teams, OMPD_target, S);
 }
 
-void CodeGenFunction::EmitOMPTaskyieldDirective(const OMPTaskyieldDirective &) {
-  llvm_unreachable("CodeGen for 'omp taskyield' is not supported yet.");
+/// Generate an instructions for '#pragma omp teams distribute' directive.
+void CodeGenFunction::EmitOMPTeamsDistributeDirective(
+    const OMPTeamsDistributeDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  EmitOMPDirectiveWithTeams(OMPD_teams_distribute, OMPD_distribute, S);
 }
 
-void CodeGenFunction::EmitOMPBarrierDirective(const OMPBarrierDirective &) {
-  llvm_unreachable("CodeGen for 'omp barrier' is not supported yet.");
+/// Generate an instructions for '#pragma omp teams distribute simd' directive.
+void CodeGenFunction::EmitOMPTeamsDistributeSimdDirective(
+    const OMPTeamsDistributeSimdDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  EmitOMPDirectiveWithTeams(OMPD_teams_distribute_simd, OMPD_distribute_simd,
+                            S);
 }
 
-void CodeGenFunction::EmitOMPTaskwaitDirective(const OMPTaskwaitDirective &) {
-  llvm_unreachable("CodeGen for 'omp taskwait' is not supported yet.");
+/// Generate an instructions for '#pragma omp target teams distribute'
+/// directive.
+void CodeGenFunction::EmitOMPTargetTeamsDistributeDirective(
+    const OMPTargetTeamsDistributeDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  OpenMPDirectiveKind Directives[] = { OMPD_target, OMPD_distribute };
+  EmitOMPDirectiveWithTeams(OMPD_target_teams_distribute, Directives,
+                            S);
 }
 
-void CodeGenFunction::EmitOMPFlushDirective(const OMPFlushDirective &) {
-  llvm_unreachable("CodeGen for 'omp flush' is not supported yet.");
+/// Generate an instructions for '#pragma omp target teams distribute simd'
+/// directive.
+void CodeGenFunction::EmitOMPTargetTeamsDistributeSimdDirective(
+    const OMPTargetTeamsDistributeSimdDirective &S) {
+  RunCleanupsScope ExecutedScope(*this);
+  OpenMPDirectiveKind Directives[] = { OMPD_target, OMPD_distribute_simd };
+  EmitOMPDirectiveWithTeams(OMPD_target_teams_distribute_simd,
+                            Directives, S);
 }
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CMakeLists.txt cfe-3.5.0.src.omp/lib/CodeGen/CMakeLists.txt
--- cfe-3.5.0.src/lib/CodeGen/CMakeLists.txt	2014-07-14 01:01:53.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CMakeLists.txt	2014-11-28 10:49:29.000000000 -0500
@@ -31,6 +31,8 @@
   CGDebugInfo.cpp
   CGDecl.cpp
   CGDeclCXX.cpp
+  CGDeclOpenMP.cpp
+  CGElementalFunction.cpp
   CGException.cpp
   CGExpr.cpp
   CGExprAgg.cpp
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CodeGenFunction.cpp cfe-3.5.0.src.omp/lib/CodeGen/CodeGenFunction.cpp
--- cfe-3.5.0.src/lib/CodeGen/CodeGenFunction.cpp	2014-07-17 14:46:27.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CodeGenFunction.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -36,7 +36,7 @@
 CodeGenFunction::CodeGenFunction(CodeGenModule &cgm, bool suppressNewContext)
     : CodeGenTypeCache(cgm), CGM(cgm), Target(cgm.getTarget()),
       Builder(cgm.getModule().getContext(), llvm::ConstantFolder(),
-              CGBuilderInserterTy(this)),
+              CGBuilderInserterTy(this)), OpenMPRoot(0),
       CapturedStmtInfo(nullptr), SanOpts(&CGM.getLangOpts().Sanitize),
       IsSanitizerScope(false), AutoreleaseResult(false), BlockInfo(nullptr),
       BlockPointer(nullptr), LambdaThisCaptureField(nullptr),
@@ -74,9 +74,6 @@
   if (FirstBlockInfo)
     destroyBlockInfos(FirstBlockInfo);
 
-  if (getLangOpts().OpenMP) {
-    CGM.getOpenMPRuntime().FunctionFinished(*this);
-  }
 }
 
 
@@ -263,6 +260,11 @@
   llvm::Instruction *Ptr = AllocaInsertPt;
   AllocaInsertPt = nullptr;
   Ptr->eraseFromParent();
+  if (FirstprivateInsertPt) {
+    Ptr = FirstprivateInsertPt;
+    FirstprivateInsertPt = 0;
+    Ptr->eraseFromParent();
+  }
 
   // If someone took the address of a label but never did an indirect goto, we
   // made a zero entry PHI node, which is illegal, zap it now.
@@ -582,6 +584,7 @@
   // folded.
   llvm::Value *Undef = llvm::UndefValue::get(Int32Ty);
   AllocaInsertPt = new llvm::BitCastInst(Undef, Int32Ty, "", EntryBB);
+  FirstprivateInsertPt = 0;
   if (Builder.isNamePreserving())
     AllocaInsertPt->setName("allocapt");
 
@@ -1537,10 +1540,14 @@
       break;
 
     case Type::Typedef:
+      type = cast<TypedefType>(ty)->desugar();
+      break;
     case Type::Decltype:
+      type = cast<DecltypeType>(ty)->desugar();
+      break;
     case Type::Auto:
-      // Stop walking: nothing to do.
-      return;
+      type = cast<AutoType>(ty)->getDeducedType();
+      break;
 
     case Type::TypeOfExpr:
       // Stop walking: emit typeof expression.
@@ -1551,7 +1558,7 @@
       type = cast<AtomicType>(ty)->getValueType();
       break;
     }
-  } while (type->isVariablyModifiedType());
+  } while (!type.isNull() && type->isVariablyModifiedType());
 }
 
 llvm::Value* CodeGenFunction::EmitVAListRef(const Expr* E) {
@@ -1650,10 +1657,11 @@
   CGF->IsSanitizerScope = false;
 }
 
-void CodeGenFunction::InsertHelper(llvm::Instruction *I,
-                                   const llvm::Twine &Name,
-                                   llvm::BasicBlock *BB,
-                                   llvm::BasicBlock::iterator InsertPt) const {
+void
+CodeGenFunction::InsertHelper(llvm::Instruction *I,
+                              const llvm::Twine &Name,
+                              llvm::BasicBlock *BB,
+                              llvm::BasicBlock::iterator InsertPt) const {
   LoopStack.InsertHelper(I);
   if (IsSanitizerScope) {
     I->setMetadata(
@@ -1663,21 +1671,26 @@
 }
 
 template <bool PreserveNames>
-void CGBuilderInserter<PreserveNames>::InsertHelper(
-    llvm::Instruction *I, const llvm::Twine &Name, llvm::BasicBlock *BB,
-    llvm::BasicBlock::iterator InsertPt) const {
+void CGBuilderInserter<PreserveNames>::
+  InsertHelper(llvm::Instruction *I,
+               const llvm::Twine &Name,
+               llvm::BasicBlock *BB,
+               llvm::BasicBlock::iterator InsertPt) const {
   llvm::IRBuilderDefaultInserter<PreserveNames>::InsertHelper(I, Name, BB,
                                                               InsertPt);
   if (CGF)
     CGF->InsertHelper(I, Name, BB, InsertPt);
 }
-
 #ifdef NDEBUG
-#define PreserveNames false
+template void CGBuilderInserter<false>::
+  InsertHelper(llvm::Instruction *I,
+               const llvm::Twine &Name,
+               llvm::BasicBlock *BB,
+               llvm::BasicBlock::iterator InsertPt) const;
 #else
-#define PreserveNames true
+template void CGBuilderInserter<true>::
+  InsertHelper(llvm::Instruction *I,
+               const llvm::Twine &Name,
+               llvm::BasicBlock *BB,
+               llvm::BasicBlock::iterator InsertPt) const;
 #endif
-template void CGBuilderInserter<PreserveNames>::InsertHelper(
-    llvm::Instruction *I, const llvm::Twine &Name, llvm::BasicBlock *BB,
-    llvm::BasicBlock::iterator InsertPt) const;
-#undef PreserveNames
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CodeGenFunction.h cfe-3.5.0.src.omp/lib/CodeGen/CodeGenFunction.h
--- cfe-3.5.0.src/lib/CodeGen/CodeGenFunction.h	2014-07-21 15:47:02.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CodeGenFunction.h	2014-11-28 10:49:29.000000000 -0500
@@ -24,6 +24,8 @@
 #include "clang/AST/CharUnits.h"
 #include "clang/AST/ExprCXX.h"
 #include "clang/AST/ExprObjC.h"
+#include "clang/AST/OpenMPClause.h"
+#include "clang/AST/StmtOpenMP.h"
 #include "clang/AST/Type.h"
 #include "clang/Basic/ABI.h"
 #include "clang/Basic/CapturedStmt.h"
@@ -146,9 +148,10 @@
   LoopInfoStack LoopStack;
   CGBuilderTy Builder;
 
-  /// \brief CGBuilder insert helper. This function is called after an
-  /// instruction is created using Builder.
-  void InsertHelper(llvm::Instruction *I, const llvm::Twine &Name,
+  /// CGBuilder insert helper. This function is called after an instruction is
+  /// created using Builder.
+  void InsertHelper(llvm::Instruction *I,
+                    const llvm::Twine &Name,
                     llvm::BasicBlock *BB,
                     llvm::BasicBlock::iterator InsertPt) const;
 
@@ -157,6 +160,9 @@
   const Decl *CurFuncDecl;
   /// CurCodeDecl - This is the inner-most code context, which includes blocks.
   const Decl *CurCodeDecl;
+  /// Root CodeGenFunction for OpenMP context in which current CodeGenFunction
+  /// was created.
+  CodeGenFunction *OpenMPRoot;
   const CGFunctionInfo *CurFnInfo;
   QualType FnRetTy;
   llvm::Function *CurFn;
@@ -178,6 +184,7 @@
   /// AllocaInsertPoint - This is an instruction in the entry block before which
   /// we prefer to insert allocas.
   llvm::AssertingVH<llvm::Instruction> AllocaInsertPt;
+  llvm::AssertingVH<llvm::Instruction> FirstprivateInsertPt;
 
   /// \brief API for captured statement code generation.
   class CGCapturedStmtInfo {
@@ -224,6 +231,11 @@
     /// \brief Get the name of the capture helper.
     virtual StringRef getHelperName() const { return "__captured_stmt"; }
 
+    static bool classof(const CGCapturedStmtInfo *) { return true; }
+
+    virtual void addCachedVar(const VarDecl *VD, llvm::Value *Addr) { }
+    virtual llvm::Value *getCachedVar(const VarDecl *VD) { return 0; }
+
   private:
     /// \brief The kind of captured statement being generated.
     CapturedRegionKind Kind;
@@ -238,8 +250,165 @@
     /// \brief Captured 'this' type.
     FieldDecl *CXXThisFieldDecl;
   };
+  /// \brief API for captured statement code generation for OpenMP regions.
+  class CGOpenMPCapturedStmtInfo : public CGCapturedStmtInfo {
+    //CodeGenModule &CGM;
+  public:
+    explicit CGOpenMPCapturedStmtInfo(llvm::Value* Context,
+                                      const CapturedStmt &S,
+                                      CodeGenModule &CGM,
+                                      CapturedRegionKind K = CR_Default)
+      : CGCapturedStmtInfo(S, K)/*, CGM(CGM)*/ { setContextValue(Context); }
+
+    virtual ~CGOpenMPCapturedStmtInfo() { };
+
+    virtual void addCachedVar(const VarDecl *VD, llvm::Value *Addr) { CachedVars[VD] = Addr; }
+    virtual llvm::Value *getCachedVar(const VarDecl *VD) { return CachedVars[VD]; }
+  private:
+
+    /// \brief Keep the map between VarDecl and FieldDecl.
+    llvm::SmallDenseMap<const VarDecl *, llvm::Value *> CachedVars;
+
+  };
+
   CGCapturedStmtInfo *CapturedStmtInfo;
 
+  class CGSIMDForStmtInfo; // Defined below, after simd wrappers.
+
+  /// \brief Wrapper for "#pragma simd" and "#pragma omp simd".
+  class CGPragmaSimdWrapper {
+    public:
+      // \brief Helper for EmitPragmaSimd - process 'safelen' clause.
+      virtual bool emitSafelen(CodeGenFunction *CGF) const = 0;
+
+      // \brief Emit updates of local variables from clauses
+      // and loop counters in the beginning of __simd_helper.
+      virtual bool walkLocalVariablesToEmit(
+                      CodeGenFunction *CGF,
+                      CGSIMDForStmtInfo *Info) const = 0;
+
+      /// \brief Emit the SIMD loop initalization, loop stride expression
+      /// as loop invariants, and cache those values.
+      virtual void emitInit(CodeGenFunction &CGF,
+          llvm::Value *&LoopIndex, llvm::Value *&LoopCount) = 0;
+
+      /// \brief Emit the loop increment.
+      virtual void emitIncrement(CodeGenFunction &CGF,
+                                 llvm::Value *IndexVar) const = 0;
+
+      // \brief Emit final values of loop counters and linear vars.
+      virtual void emitLinearFinal(CodeGenFunction &CGF) const = 0;
+
+      /// \brief Get the beginning location of for stmt.
+      virtual SourceLocation getForLoc() const = 0;
+
+      /// \brief Get the source range.
+      virtual SourceRange getSourceRange() const = 0;
+
+      /// \brief Retrieve the initialization expression.
+      virtual const Stmt *getInit() const = 0;
+
+      /// \brief Retrieve the loop condition expression.
+      virtual const Expr *getCond() const = 0;
+
+      /// \brief Retrieve the loop body.
+      virtual const CapturedStmt *getAssociatedStmt() const = 0;
+
+      /// \brief Retrieve the loop count expression.
+      virtual const Expr *getLoopCount() const = 0;
+
+      /// \brief Extract the loop body from the collapsed loop nest.
+      /// Useful for openmp (it is noop for SIMDForStmt).
+      virtual Stmt *extractLoopBody(Stmt *S) const = 0;
+
+      /// \brief Return true if it is openmp pragma.
+      virtual bool isOmp() const = 0;
+
+      /// \brief Get the wrapped SIMDForStmt or OMPSimdDirective.
+      virtual const Stmt *getStmt() const = 0;
+
+      virtual ~CGPragmaSimdWrapper() { };
+  };
+
+
+  class CGPragmaOmpSimd : public CGPragmaSimdWrapper {
+    public:
+      CGPragmaOmpSimd(const OMPExecutableDirective *S)
+        : SimdOmp(S) {}
+
+      virtual bool emitSafelen(CodeGenFunction *CGF) const;
+      virtual bool walkLocalVariablesToEmit(
+                      CodeGenFunction *CGF,
+                      CGSIMDForStmtInfo *Info) const;
+
+      virtual void emitInit(CodeGenFunction &CGF,
+          llvm::Value *&LoopIndex, llvm::Value *&LoopCount);
+
+      virtual void emitIncrement(CodeGenFunction &CGF,
+                                 llvm::Value *IndexVar) const { }
+
+      virtual void emitLinearFinal(CodeGenFunction &CGF) const;
+
+      virtual SourceLocation getForLoc() const;
+      virtual SourceRange getSourceRange() const;
+      virtual const Stmt *getInit() const;
+      virtual const Expr *getCond() const;
+      virtual const CapturedStmt *getAssociatedStmt() const;
+      virtual const Expr *getLoopCount() const;
+      virtual Stmt *extractLoopBody(Stmt *S) const;
+      virtual bool isOmp() const { return true; }
+      virtual const Stmt *getStmt() const { return SimdOmp; }
+      llvm::ConstantInt *emitClauseTail(CodeGenFunction *CGF, Expr *E) const;
+      virtual ~CGPragmaOmpSimd() { }
+
+    private:
+      const OMPExecutableDirective *SimdOmp;
+  };
+
+  /// \brief API for SIMD for statement code generation.
+  /// This class is intended to provide an interface to CG to work in the
+  /// same manner with "#pragma simd" and "#pragma omp simd", using wrapper
+  /// (CGPragmaSimdWrapper) for addressing any differences between them.
+  class CGSIMDForStmtInfo : public CGCapturedStmtInfo {
+  public:
+    CGSIMDForStmtInfo(const CGPragmaSimdWrapper &Wr, llvm::MDNode *LoopID,
+                      bool LoopParallel)
+      : CGCapturedStmtInfo(*(Wr.getAssociatedStmt()), CR_SIMDFor),
+        Wrapper(Wr), LoopID(LoopID), LoopParallel(LoopParallel) { }
+
+    virtual StringRef getHelperName() const { return "__simd_for_helper"; }
+
+    virtual void EmitBody(CodeGenFunction &CGF, Stmt *S) {
+      CGF.EmitSIMDForHelperBody(Wrapper.extractLoopBody(S));
+    }
+
+    llvm::MDNode *getLoopID() const { return LoopID; }
+    bool getLoopParallel() const { return LoopParallel; }
+
+
+    bool isOmp() const { return Wrapper.isOmp(); }
+    const Stmt *getStmt() const { return Wrapper.getStmt(); }
+
+    // \brief Emit updates of local variables from clauses
+    // and loop counters in the beginning of __simd_helper.
+    bool walkLocalVariablesToEmit(CodeGenFunction *CGF) {
+      return Wrapper.walkLocalVariablesToEmit(CGF, this);
+    }
+
+    static bool classof(const CGSIMDForStmtInfo *) { return true; }
+    static bool classof(const CGCapturedStmtInfo *I) {
+      return I->getKind() == CR_SIMDFor;
+    }
+  private:
+    /// \brief Wrapper around SIMDForStmt/OMPSimdDirective.
+    const CGPragmaSimdWrapper &Wrapper;
+    /// \brief The loop id metadata.
+    llvm::MDNode *LoopID;
+    /// \brief Is loop parallel.
+    bool LoopParallel;
+
+  };
+
   /// BoundsChecking - Emit run-time bounds checks. Higher values mean
   /// potentially higher performance penalties.
   unsigned char BoundsChecking;
@@ -857,6 +1026,7 @@
     JumpDest ContinueBlock;
   };
   SmallVector<BreakContinue, 8> BreakContinueStack;
+  llvm::DenseMap<unsigned, JumpDest> OMPCancelMap;
 
   CodeGenPGO PGO;
 
@@ -905,6 +1075,24 @@
   SourceLocation LastStopPoint;
 
 public:
+  /// This class is used for instantiation of local variables, but restores
+  /// LocalDeclMap state after instantiation. If Empty is true, the LocalDeclMap
+  /// is cleared completely and then restored to original state upon
+  /// destruction.
+  class LocalVarsDeclGuard {
+    CodeGenFunction &CGF;
+    DeclMapTy LocalDeclMap;
+    public:
+      LocalVarsDeclGuard(CodeGenFunction &CGF, bool Empty = false)
+        : CGF(CGF), LocalDeclMap() {
+          if (Empty) {
+            LocalDeclMap.swap(CGF.LocalDeclMap);
+          } else {
+            LocalDeclMap.copyFrom(CGF.LocalDeclMap);
+          }
+        }
+      ~LocalVarsDeclGuard() { CGF.LocalDeclMap.swap(LocalDeclMap); }
+  };
   /// A scope within which we are constructing the fields of an object which
   /// might use a CXXDefaultInitExpr. This stashes away a 'this' value to use
   /// if we need to evaluate a CXXDefaultInitExpr within the evaluation.
@@ -964,6 +1152,9 @@
   /// The current lexical scope.
   LexicalScope *CurLexicalScope;
 
+  /// ExceptionsDisabled - Whether exceptions are currently disabled.
+  bool ExceptionsDisabled;
+
   /// The current source location that should be used for exception
   /// handling code.
   SourceLocation CurEHLocation;
@@ -987,7 +1178,7 @@
   ///   "work_group_size_hint", and three 32-bit integers X, Y and Z.
   /// - A node for the reqd_work_group_size(X,Y,Z) qualifier contains string 
   ///   "reqd_work_group_size", and three 32-bit integers X, Y and Z.
-  void EmitOpenCLKernelMetadata(const FunctionDecl *FD, 
+  void EmitOpenCLKernelMetadata(const FunctionDecl *FD,
                                 llvm::Function *Fn);
 
 public:
@@ -1035,6 +1226,9 @@
     return getInvokeDestImpl();
   }
 
+  void disableExceptions() { ExceptionsDisabled = true; }
+  void enableExceptions() { ExceptionsDisabled = false; }
+
   const TargetInfo &getTarget() const { return Target; }
   llvm::LLVMContext &getLLVMContext() { return CGM.getLLVMContext(); }
 
@@ -1217,7 +1411,7 @@
   void EmitCtorPrologue(const CXXConstructorDecl *CD, CXXCtorType Type,
                         FunctionArgList &Args);
 
-  void EmitInitializerForField(FieldDecl *Field, LValue LHS, Expr *Init,
+  void EmitInitializerForField(const FieldDecl *Field, LValue LHS, Expr *Init,
                                ArrayRef<VarDecl *> ArrayIndexes);
 
   /// InitializeVTablePointer - Initialize the vtable pointer of the given
@@ -1917,25 +2111,170 @@
   void EmitCXXForRangeStmt(const CXXForRangeStmt &S,
                            const ArrayRef<const Attr *> &Attrs = None);
 
+  LValue InitCapturedStruct(const CapturedStmt &S);
+  void InitOpenMPFunction(llvm::Value *Context, const CapturedStmt &S);
+  void InitOpenMPTargetFunction(const CapturedStmt &S);
   llvm::Function *EmitCapturedStmt(const CapturedStmt &S, CapturedRegionKind K);
   llvm::Function *GenerateCapturedStmtFunction(const CapturedStmt &S);
   llvm::Value *GenerateCapturedStmtArgument(const CapturedStmt &S);
 
+  void EmitPragmaSimd(CGPragmaSimdWrapper &W);
+  llvm::Function *EmitSimdFunction(CGPragmaSimdWrapper &W);
+
+  void EmitSIMDForHelperCall(llvm::Function *BodyFunc,
+                             LValue CapStruct, llvm::Value *LoopIndex,
+                             bool IsLastIter);
+  void EmitSIMDForHelperBody(const Stmt *S);
+
+
+  LValue GetCapturedField(const VarDecl *VD);
+  void EmitUniversalStore(llvm::Value *Dst, llvm::Value *Src, QualType ExprTy);
+  void EmitUniversalStore(LValue Dst, llvm::Value *Src, QualType ExprTy);
+public:
   void EmitOMPParallelDirective(const OMPParallelDirective &S);
-  void EmitOMPSimdDirective(const OMPSimdDirective &S);
+  void EmitOMPParallelForDirective(const OMPParallelForDirective &S);
+  void EmitOMPParallelForSimdDirective(const OMPParallelForSimdDirective &S);
   void EmitOMPForDirective(const OMPForDirective &S);
+  void EmitOMPSimdDirective(const OMPSimdDirective &S);
+  void EmitOMPForSimdDirective(const OMPForSimdDirective &S);
+  void EmitOMPDistributeSimdDirective(const OMPDistributeSimdDirective &S);
+  void EmitOMPDistributeParallelForDirective(
+      const OMPDistributeParallelForDirective &S);
+  void EmitOMPDistributeParallelForSimdDirective(
+      const OMPDistributeParallelForSimdDirective &S);
+  void EmitOMPTeamsDistributeParallelForDirective(
+      const OMPTeamsDistributeParallelForDirective &S);
+  void EmitOMPTeamsDistributeParallelForSimdDirective(
+      const OMPTeamsDistributeParallelForSimdDirective &S);
+  void EmitOMPTargetTeamsDistributeParallelForDirective(
+      const OMPTargetTeamsDistributeParallelForDirective &S);
+  void EmitOMPTargetTeamsDistributeParallelForSimdDirective(
+      const OMPTargetTeamsDistributeParallelForSimdDirective &S);
+  void EmitOMPTaskDirective(const OMPTaskDirective &S);
   void EmitOMPSectionsDirective(const OMPSectionsDirective &S);
-  void EmitOMPSectionDirective(const OMPSectionDirective &S);
-  void EmitOMPSingleDirective(const OMPSingleDirective &S);
-  void EmitOMPMasterDirective(const OMPMasterDirective &S);
-  void EmitOMPCriticalDirective(const OMPCriticalDirective &S);
-  void EmitOMPParallelForDirective(const OMPParallelForDirective &S);
   void EmitOMPParallelSectionsDirective(const OMPParallelSectionsDirective &S);
-  void EmitOMPTaskDirective(const OMPTaskDirective &S);
-  void EmitOMPTaskyieldDirective(const OMPTaskyieldDirective &S);
+  void EmitOMPSectionDirective(const OMPSectionDirective &S);
+  void EmitOMPTeamsDirective(const OMPTeamsDirective &S);
+  void EmitOMPDistributeDirective(const OMPDistributeDirective &S);
+  void EmitOMPTargetDirective(const OMPTargetDirective &S);
+  void EmitOMPTargetDataDirective(const OMPTargetDataDirective &S);
+  void EmitOMPTargetUpdateDirective(const OMPTargetUpdateDirective &S);
+  void EmitOMPTargetTeamsDirective(const OMPTargetTeamsDirective &S);
+  void EmitOMPTeamsDistributeDirective(const OMPTeamsDistributeDirective &S);
+  void
+  EmitOMPTeamsDistributeSimdDirective(const OMPTeamsDistributeSimdDirective &S);
+  void EmitOMPTargetTeamsDistributeDirective(
+      const OMPTargetTeamsDistributeDirective &S);
+  void EmitOMPTargetTeamsDistributeSimdDirective(
+      const OMPTargetTeamsDistributeSimdDirective &S);
+  void EmitInitOMPClause(const OMPClause &C,
+                         const OMPExecutableDirective &S);
+  void EmitAfterInitOMPClause(const OMPClause &C,
+                              const OMPExecutableDirective &S);
+  void EmitPreOMPClause(const OMPClause &C,
+                        const OMPExecutableDirective &S);
+  void EmitPostOMPClause(const OMPClause &C, const OMPExecutableDirective &S);
+  void EmitCloseOMPClause(const OMPClause &C,
+                          const OMPExecutableDirective &S);
+  void EmitFinalOMPClause(const OMPClause &C, const OMPExecutableDirective &S);
+  void EmitInitOMPNumThreadsClause(const OMPNumThreadsClause &C,
+                                   const OMPExecutableDirective &S);
+  void EmitInitOMPNumTeamsClause(const OMPNumTeamsClause &C,
+                                 const OMPExecutableDirective &S);
+  void EmitInitOMPThreadLimitClause(const OMPThreadLimitClause &C,
+                                    const OMPExecutableDirective &S);
+  void EmitInitOMPProcBindClause(const OMPProcBindClause &C,
+                                 const OMPExecutableDirective &S);
+  void EmitInitOMPDeviceClause(const OMPDeviceClause &C,
+                            const OMPExecutableDirective &S);
+  void EmitInitOMPMapClause(const OMPMapClause &C,
+                            const OMPExecutableDirective &S);
+  void EmitAfterInitOMPIfClause(const OMPIfClause &C,
+                                const OMPExecutableDirective &S);
+  void EmitFinalOMPIfClause(const OMPIfClause &C,
+                            const OMPExecutableDirective &S);
+  void EmitInitOMPNowaitClause(const OMPNowaitClause &C,
+                               const OMPExecutableDirective &S);
+  void EmitInitOMPOrderedClause(const OMPOrderedClause &C,
+                                const OMPExecutableDirective &S);
+  void EmitInitOMPUntiedClause(const OMPUntiedClause &C,
+                               const OMPExecutableDirective &S);
+  void EmitInitOMPFinalClause(const OMPFinalClause &C,
+                              const OMPExecutableDirective &S);
+  void EmitInitOMPMergeableClause(const OMPMergeableClause &C,
+                                  const OMPExecutableDirective &S);
+  void EmitPreOMPScheduleClause(const OMPScheduleClause &C,
+                                const OMPExecutableDirective &S);
+  void EmitPreOMPDistScheduleClause(const OMPDistScheduleClause &C,
+                                    const OMPExecutableDirective &S);
+  void EmitPreOMPCopyinClause(const OMPCopyinClause &C,
+                              const OMPExecutableDirective &S);
+  void EmitPreOMPPrivateClause(const OMPPrivateClause &C,
+                               const OMPExecutableDirective &S);
+  void EmitPreOMPFirstPrivateClause(const OMPFirstPrivateClause &C,
+                                    const OMPExecutableDirective &S);
+  void EmitPreOMPLastPrivateClause(const OMPLastPrivateClause &C,
+                                   const OMPExecutableDirective &S);
+  void EmitPostOMPLastPrivateClause(const OMPLastPrivateClause &C,
+                                    const OMPExecutableDirective &S);
+  void EmitCloseOMPLastPrivateClause(const OMPLastPrivateClause &C,
+                                     const OMPExecutableDirective &S);
+  void EmitInitOMPReductionClause(const OMPReductionClause &C,
+                                  const OMPExecutableDirective &S);
+  void EmitPreOMPReductionClause(const OMPReductionClause &C,
+                                 const OMPExecutableDirective &S);
+  void EmitPostOMPReductionClause(const OMPReductionClause &C,
+                                  const OMPExecutableDirective &S);
+  void EmitCloseOMPReductionClause(const OMPReductionClause &C,
+                                   const OMPExecutableDirective &S);
+  void EmitFinalOMPReductionClause(const OMPReductionClause &C,
+                                   const OMPExecutableDirective &S);
   void EmitOMPBarrierDirective(const OMPBarrierDirective &S);
+  void EmitOMPTaskyieldDirective(const OMPTaskyieldDirective &S);
   void EmitOMPTaskwaitDirective(const OMPTaskwaitDirective &S);
   void EmitOMPFlushDirective(const OMPFlushDirective &S);
+  void EmitOMPCancelDirective(const OMPCancelDirective &S);
+  void EmitOMPCancellationPointDirective(
+                             const OMPCancellationPointDirective &S);
+  void EmitOMPAtomicDirective(const OMPAtomicDirective &S);
+  void EmitOMPTaskgroupDirective(const OMPTaskgroupDirective &S);
+  void EmitOMPMasterDirective(const OMPMasterDirective &S);
+  void EmitOMPSingleDirective(const OMPSingleDirective &S);
+  void EmitOMPCriticalDirective(const OMPCriticalDirective &S);
+  void EmitOMPOrderedDirective(const OMPOrderedDirective &S);
+  llvm::CallInst *EmitOMPCallWithLocAndTidHelper(llvm::Value *F,
+        SourceLocation L, unsigned Flags = 0x02);
+  void EmitOMPConditionalIfHelper(const OMPExecutableDirective &S,
+        llvm::Value *Func, SourceLocation Loc,
+        llvm::Value *EndFunc, SourceLocation EndLoc,
+        bool HasClauses, llvm::AllocaInst *DidIt,
+        const std::string &NameStr);
+  void EmitOMPCapturedBodyHelper(const OMPExecutableDirective &S);
+  void EmitCopyAssignment(
+    ArrayRef<const Expr *>::iterator I,
+    ArrayRef<const Expr *>::iterator AssignIter,
+    ArrayRef<const Expr *>::iterator VarIter1,
+    ArrayRef<const Expr *>::iterator VarIter2,
+    llvm::Value *Dst,
+    llvm::Value *Src);
+  void EmitOMPDirectiveWithLoop(
+    OpenMPDirectiveKind DKind,
+    OpenMPDirectiveKind SKind,
+    const OMPExecutableDirective &S);
+  void EmitOMPSectionsDirective(
+    OpenMPDirectiveKind DKind,
+    OpenMPDirectiveKind SKind,
+    const OMPExecutableDirective &S);
+  void EmitOMPDirectiveWithParallel(
+    OpenMPDirectiveKind DKind,
+    ArrayRef<OpenMPDirectiveKind> SKinds,
+    const OMPExecutableDirective &S);
+  void EmitOMPDirectiveWithTeams(OpenMPDirectiveKind DKind,
+                                 ArrayRef<OpenMPDirectiveKind> SKinds,
+                                 const OMPExecutableDirective &S);
+  void EmitOMPBarrier(SourceLocation L, unsigned Flags);
+  void EmitOMPCancelBarrier(SourceLocation L, unsigned Flags,
+                            bool IgnoreResult = false);
 
   //===--------------------------------------------------------------------===//
   //                         LValue Expression Emission
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CodeGenModule.cpp cfe-3.5.0.src.omp/lib/CodeGen/CodeGenModule.cpp
--- cfe-3.5.0.src/lib/CodeGen/CodeGenModule.cpp	2014-08-04 14:33:13.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CodeGenModule.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -51,6 +51,7 @@
 #include "llvm/ProfileData/InstrProfReader.h"
 #include "llvm/Support/ConvertUTF.h"
 #include "llvm/Support/ErrorHandling.h"
+#include <stack>
 
 using namespace clang;
 using namespace CodeGen;
@@ -88,7 +89,8 @@
       BlockObjectDispose(nullptr), BlockDescriptorType(nullptr),
       GenericBlockLiteralType(nullptr), LifetimeStartFn(nullptr),
       LifetimeEndFn(nullptr), SanitizerBL(llvm::SpecialCaseList::createOrDie(
-                                  CGO.SanitizerBlacklistFile)) {
+                                  CGO.SanitizerBlacklistFile)),
+      OpenMPSupport(*this) {
 
   // Initialize the type cache.
   llvm::LLVMContext &LLVMContext = M.getContext();
@@ -113,10 +115,10 @@
     createObjCRuntime();
   if (LangOpts.OpenCL)
     createOpenCLRuntime();
-  if (LangOpts.OpenMP)
-    createOpenMPRuntime();
   if (LangOpts.CUDA)
     createCUDARuntime();
+  if (LangOpts.OpenMP)
+    createOpenMPRuntime();
 
   // Enable TBAA unless it's suppressed. ThreadSanitizer needs TBAA even at O0.
   if (LangOpts.Sanitize.Thread ||
@@ -183,7 +185,7 @@
 }
 
 void CodeGenModule::createOpenMPRuntime() {
-  OpenMPRuntime = new CGOpenMPRuntime(*this);
+  OpenMPRuntime = CreateOpenMPRuntime(*this);
 }
 
 void CodeGenModule::createCUDARuntime() {
@@ -1074,6 +1076,14 @@
     // Otherwise, emit the definition and move on to the next one.
     EmitGlobalDefinition(D, GV);
   }
+
+  // Emit deferred openmp directives
+  while (!DeferredOMP.empty()) {
+    const OMPDeclareSimdDecl *DSimd = DeferredOMP.back();
+    DeferredOMP.pop_back();
+    EmitOMPDeclareSimd(DSimd);
+  }
+
 }
 
 void CodeGenModule::EmitGlobalAnnotations() {
@@ -1409,9 +1419,20 @@
     return EmitGlobalFunctionDefinition(GD, GV);
   }
 
-  if (const auto *VD = dyn_cast<VarDecl>(D))
-    return EmitGlobalVarDefinition(VD);
-  
+  if (const auto *VD = dyn_cast<VarDecl>(D)) {
+    EmitGlobalVarDefinition(VD);
+    for (VarDecl::redecl_iterator I = VD->redecls_begin(),
+                                  E = VD->redecls_end();
+         I != E; ++I) {
+      if (*I)
+        if (const Expr * TPE = OpenMPSupport.hasThreadPrivateVar(*I)) {
+          OpenMPSupport.addThreadPrivateVar(VD, TPE);
+          EmitOMPThreadPrivate(VD, TPE);
+          break;
+        }
+    }
+    return;
+  }
   llvm_unreachable("Invalid argument to EmitGlobalDefinition()");
 }
 
@@ -1809,6 +1830,12 @@
 }
 
 void CodeGenModule::EmitGlobalVarDefinition(const VarDecl *D) {
+
+  // If we are generating code for a target we only generate the var definition
+  // if it is inside a declare target region
+  if ( LangOpts.OpenMPTargetMode && !OpenMPSupport.getTargetDeclare() )
+    return;
+
   llvm::Constant *Init = nullptr;
   QualType ASTTy = D->getType();
   CXXRecordDecl *RD = ASTTy->getBaseElementTypeUnsafe()->getAsCXXRecordDecl();
@@ -2241,10 +2268,51 @@
   EmitTopLevelDecl(VD);
 }
 
+/// Recursivelly find target regions starting from the given statement
+static void FindAndProcessTargetRegions(CodeGenFunction &CGF, const Stmt *S){
+
+  if (!S)
+    return;
+
+  // If we found a OMP target directive, codegen it
+  if ( const OMPTargetDirective *D = dyn_cast<OMPTargetDirective>(S))
+    CGF.EmitOMPTargetDirective(*D);
+
+  // Keep looking for target regions recursively
+  for(Stmt::const_child_iterator ii=S->child_begin(), ie=S->child_end(); ii != ie; ++ii)
+    FindAndProcessTargetRegions(CGF,*ii);
+}
+
 void CodeGenModule::EmitGlobalFunctionDefinition(GlobalDecl GD,
                                                  llvm::GlobalValue *GV) {
   const auto *D = cast<FunctionDecl>(GD.getDecl());
 
+  // If we are generating code for a target we need to look
+  // into the function declarations for target regions instead
+  // of codegening the function
+  if ( LangOpts.OpenMPTargetMode && !OpenMPSupport.getTargetDeclare() ){
+
+    CodeGenFunction CGF(*this);
+    CGF.CurFuncDecl = D;
+
+    FindAndProcessTargetRegions(CGF, D->getBody());
+    return;
+  }
+
+  // If a method is deffered then defer its omp directive too.
+  if (const CXXMethodDecl *MD = dyn_cast_or_null<CXXMethodDecl>(D)) {
+    const CXXRecordDecl *Parent = MD->getParent();
+    for (DeclContext::decl_iterator DI = Parent->decls_begin(),
+                                    DE = Parent->decls_end();
+                                    DI != DE; ++DI) {
+      if (const OMPDeclareSimdDecl *DSimd =
+          dyn_cast_or_null<OMPDeclareSimdDecl>(*DI)) {
+        if (dyn_cast_or_null<FunctionDecl>(DSimd->getFunction()) == D) {
+          DeferredOMP.push_back(DSimd);
+        }
+      }
+    }
+  }
   // Compute the function info and LLVM type.
   const CGFunctionInfo &FI = getTypes().arrangeGlobalDeclaration(GD);
   llvm::FunctionType *Ty = getTypes().GetFunctionType(FI);
@@ -3050,6 +3118,11 @@
   if (D->getDeclContext() && D->getDeclContext()->isDependentContext())
     return;
 
+  // Ignore any declaration other than Function and OMPDeclareTarget
+  // if we are generating code for a target
+  if ( LangOpts.OpenMPTargetMode && !(D->getKind() == Decl::Function || D->getKind() == Decl::OMPDeclareTarget ))
+    return;
+
   switch (D->getKind()) {
   case Decl::CXXConversion:
   case Decl::CXXMethod:
@@ -3193,6 +3266,18 @@
     ImportedModules.insert(Import->getImportedModule());
     break;
   }
+  case Decl::OMPThreadPrivate:
+    EmitOMPThreadPrivate(cast<OMPThreadPrivateDecl>(D));
+    break;
+  case Decl::OMPDeclareReduction:
+    EmitOMPDeclareReduction(cast<OMPDeclareReductionDecl>(D));
+    break;
+  case Decl::OMPDeclareSimd:
+    EmitOMPDeclareSimd(cast<OMPDeclareSimdDecl>(D));
+    break;
+  case Decl::OMPDeclareTarget:
+    EmitOMPDeclareTarget(cast<OMPDeclareTargetDecl>(D));
+    break;
 
   case Decl::ClassTemplateSpecialization: {
     const auto *Spec = cast<ClassTemplateSpecializationDecl>(D);
@@ -3364,6 +3449,380 @@
   return llvm::ConstantStruct::getAnon(Fields);
 }
 
+CodeGenModule::OpenMPSupportStackTy::OMPStackElemTy::OMPStackElemTy(CodeGenModule &CGM)
+  : PrivateVars(), IfEnd(0), ReductionFunc(0), CGM(CGM), RedCGF(0), ReductionTypes(),
+    ReductionMap(), ReductionRec(0), ReductionRecVar(0), RedArg1(0), RedArg2(0),
+    ReduceSwitch(0), BB1(0), BB1IP(0), BB2(0), BB2IP(0), LockVar(0),
+    LastprivateBB(0), LastprivateIP(0), LastprivateEndBB(0), LastIterVar(0), TaskFlags(0),
+    PTaskTValue(0), PTask(0), UntiedPartIdAddr(0), UntiedCounter(0), UntiedSwitch(0),
+    UntiedEnd(0), ParentCGF(0),
+    NoWait(true), Mergeable(false), Schedule(0), ChunkSize(0), NewTask(false),
+    Untied(false), HasLastPrivate(false),
+    TaskPrivateTy(0), TaskPrivateQTy(), TaskPrivateBase(0), NumTeams(0), ThreadLimit(0),
+    WaitDepsArgs(0), OffloadingDevice(0) { }
+
+CodeGenFunction &CodeGenModule::OpenMPSupportStackTy::getCGFForReductionFunction() {
+  if (!OpenMPStack.back().RedCGF) {
+    OpenMPStack.back().RedCGF = new CodeGenFunction(CGM, true);
+    OpenMPStack.back().RedCGF->CurFn = 0;
+  }
+  return *OpenMPStack.back().RedCGF;
+}
+
+CodeGenModule::OpenMPSupportStackTy::OMPStackElemTy::~OMPStackElemTy() {
+  if (RedCGF) delete RedCGF;
+  RedCGF = 0;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::endOpenMPRegion() {
+  assert(!OpenMPStack.empty() &&
+         "OpenMP private variables region is not started.");
+  assert(!OpenMPStack.back().IfEnd && "If not closed.");
+  OpenMPStack.pop_back();
+}
+
+void CodeGenModule::OpenMPSupportStackTy::registerReductionVar(
+                                                  const VarDecl *VD,
+                                                  llvm::Type *Type) {
+  OpenMPStack.back().ReductionMap[VD] =
+                           OpenMPStack.back().ReductionTypes.size();
+  OpenMPStack.back().ReductionTypes.push_back(Type);
+}
+
+llvm::Value *
+CodeGenModule::OpenMPSupportStackTy::getReductionRecVar(CodeGenFunction &CGF) {
+  if (!OpenMPStack.back().ReductionRecVar) {
+    OpenMPStack.back().ReductionRec =
+                 llvm::StructType::get(CGM.getLLVMContext(),
+                                       OpenMPStack.back().ReductionTypes);
+    llvm::AllocaInst *AI = CGF.CreateTempAlloca(OpenMPStack.back().ReductionRec,
+                                                "reduction.rec.var");
+    AI->setAlignment(CGF.CGM.PointerAlignInBytes);
+    OpenMPStack.back().ReductionRecVar = AI;
+  }
+  return OpenMPStack.back().ReductionRecVar;
+}
+
+llvm::Type *
+CodeGenModule::OpenMPSupportStackTy::getReductionRec() {
+  assert(OpenMPStack.back().ReductionRec &&
+         "Type is not defined.");
+  return OpenMPStack.back().ReductionRec;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::getReductionFunctionArgs(
+                                      llvm::Value *&Arg1, llvm::Value *&Arg2) {
+  assert(OpenMPStack.back().RedCGF && OpenMPStack.back().RedCGF->CurFn &&
+         "Reduction function is closed.");
+  if (!OpenMPStack.back().RedArg1 && !OpenMPStack.back().RedArg2) {
+    CodeGenFunction &CGF = *OpenMPStack.back().RedCGF;
+    llvm::Value *Arg1 = &CGF.CurFn->getArgumentList().front();
+    llvm::Value *Arg2 = &CGF.CurFn->getArgumentList().back();
+    llvm::Type *PtrTy = OpenMPStack.back().ReductionRec->getPointerTo();
+    OpenMPStack.back().RedArg1 = CGF.Builder.CreateBitCast(Arg1, PtrTy,
+                                                           "reduction.lhs");
+    OpenMPStack.back().RedArg2 = CGF.Builder.CreateBitCast(Arg2, PtrTy,
+                                                           "reduction.rhs");
+  }
+  Arg1 = OpenMPStack.back().RedArg1;
+  Arg2 = OpenMPStack.back().RedArg2;
+}
+
+unsigned
+CodeGenModule::OpenMPSupportStackTy::getReductionVarIdx(const VarDecl *VD) {
+  assert (OpenMPStack.back().ReductionMap.count(VD) > 0 && "No reduction var.");
+  return OpenMPStack.back().ReductionMap[VD];
+}
+
+llvm::Value *CodeGenModule::OpenMPSupportStackTy::getReductionSwitch() {
+  return OpenMPStack.back().ReduceSwitch;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setReductionSwitch(
+                                                llvm::Value *Switch) {
+  OpenMPStack.back().ReduceSwitch = Switch;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setReductionIPs(
+                                                 llvm::BasicBlock *BB1,
+                                                 llvm::Instruction *IP1,
+                                                 llvm::BasicBlock *BB2,
+                                                 llvm::Instruction *IP2) {
+  OpenMPStack.back().BB1IP = IP1;
+  OpenMPStack.back().BB2IP = IP2;
+  OpenMPStack.back().BB1 = BB1;
+  OpenMPStack.back().BB2 = BB2;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::getReductionIPs(
+                                                 llvm::BasicBlock *&BB1,
+                                                 llvm::Instruction *&IP1,
+                                                 llvm::BasicBlock *&BB2,
+                                                 llvm::Instruction *&IP2) {
+  IP1 = OpenMPStack.back().BB1IP;
+  IP2 = OpenMPStack.back().BB2IP;
+  BB1 = OpenMPStack.back().BB1;
+  BB2 = OpenMPStack.back().BB2;
+}
+
+unsigned
+CodeGenModule::OpenMPSupportStackTy::getNumberOfReductionVars() {
+  return OpenMPStack.back().ReductionTypes.size();
+}
+
+llvm::Value *CodeGenModule::OpenMPSupportStackTy::getReductionLockVar() {
+  return OpenMPStack.back().LockVar;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setReductionLockVar(llvm::Value *Var) {
+  OpenMPStack.back().LockVar = Var;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setNoWait(bool Flag) {
+  OpenMPStack.back().NoWait = Flag;
+}
+
+bool CodeGenModule::OpenMPSupportStackTy::getNoWait() {
+  return OpenMPStack.back().NoWait;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setScheduleChunkSize(
+                                               int Sched,
+                                               const Expr *Size) {
+  OpenMPStack.back().Schedule = Sched;
+  OpenMPStack.back().ChunkSize = Size;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::getScheduleChunkSize(
+                                               int &Sched,
+                                               const Expr *&Size) {
+  Sched = OpenMPStack.back().Schedule;
+  Size = OpenMPStack.back().ChunkSize;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setMergeable(bool Flag) {
+  OpenMPStack.back().Mergeable = Flag;
+}
+
+bool CodeGenModule::OpenMPSupportStackTy::getMergeable() {
+  return OpenMPStack.back().Mergeable;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setOrdered(bool Flag) {
+  OpenMPStack.back().Ordered = Flag;
+}
+
+bool CodeGenModule::OpenMPSupportStackTy::getOrdered() {
+  return OpenMPStack.back().Ordered;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setHasLastPrivate(bool Flag) {
+  OpenMPStack.back().HasLastPrivate = Flag;
+}
+
+bool CodeGenModule::OpenMPSupportStackTy::hasLastPrivate() {
+  return OpenMPStack.back().HasLastPrivate;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setLastprivateIP(
+                                                 llvm::BasicBlock *BB,
+                                                 llvm::Instruction *IP,
+                                                 llvm::BasicBlock *EndBB) {
+  OpenMPStack.back().LastprivateIP = IP;
+  OpenMPStack.back().LastprivateBB = BB;
+  OpenMPStack.back().LastprivateEndBB = EndBB;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::getLastprivateIP(
+                                                 llvm::BasicBlock *&BB,
+                                                 llvm::Instruction *&IP,
+                                                 llvm::BasicBlock *&EndBB) {
+  IP = OpenMPStack.back().LastprivateIP;
+  BB = OpenMPStack.back().LastprivateBB;
+  EndBB = OpenMPStack.back().LastprivateEndBB;
+}
+
+llvm::Value *CodeGenModule::OpenMPSupportStackTy::getLastIterVar() {
+  return OpenMPStack.back().LastIterVar;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setLastIterVar(llvm::Value *Var) {
+  OpenMPStack.back().LastIterVar = Var;
+}
+
+bool CodeGenModule::OpenMPSupportStackTy::getUntied() {
+  for (OMPStackTy::reverse_iterator I = OpenMPStack.rbegin(),
+                                    E = OpenMPStack.rend();
+       I != E; ++I) {
+    if (I->NewTask) {
+      return I->Untied;
+    }
+  }
+  return false;
+}
+
+bool CodeGenModule::OpenMPSupportStackTy::getParentUntied() {
+  bool FirstTaskFound = false;
+  for (OMPStackTy::reverse_iterator I = OpenMPStack.rbegin(),
+                                    E = OpenMPStack.rend();
+       I != E; ++I) {
+    if (FirstTaskFound && I->NewTask) {
+      return I->Untied;
+    }
+    FirstTaskFound = FirstTaskFound || I->NewTask;
+  }
+  return false;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setUntied(bool Flag) {
+  OpenMPStack.back().Untied = Flag;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setTargetDeclare(bool Flag){
+  OpenMPStack.back().TargetDeclare = Flag;
+}
+bool CodeGenModule::OpenMPSupportStackTy::getTargetDeclare(){
+  for (OMPStackTy::reverse_iterator I = OpenMPStack.rbegin(),
+                                    E = OpenMPStack.rend();
+       I != E; ++I) {
+    if (I->TargetDeclare) {
+      return true;
+    }
+  }
+  return false;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setDistribute(bool Flag){
+  OpenMPStack.back().Distribute = Flag;
+}
+
+bool CodeGenModule::OpenMPSupportStackTy::getDistribute(){
+  return OpenMPStack.back().Distribute;
+}
+
+
+llvm::Value *CodeGenModule::OpenMPSupportStackTy::getTaskFlags() {
+  return OpenMPStack.back().TaskFlags;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setTaskFlags(llvm::Value *Flags) {
+  OpenMPStack.back().TaskFlags = Flags;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setPTask(llvm::Value *Task, llvm::Value *TaskT, llvm::Type *PTy, QualType PQTy, llvm::Value *PB) {
+  OpenMPStack.back().PTask = Task;
+  OpenMPStack.back().PTaskTValue = TaskT;
+  OpenMPStack.back().TaskPrivateTy = PTy;
+  OpenMPStack.back().TaskPrivateQTy = PQTy;
+  OpenMPStack.back().TaskPrivateBase = PB;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::getPTask(llvm::Value *&Task, llvm::Value *&TaskT, llvm::Type *&PTy, QualType &PQTy, llvm::Value *&PB) {
+  Task = OpenMPStack.back().PTask;
+  TaskT = OpenMPStack.back().PTaskTValue;
+  PTy = OpenMPStack.back().TaskPrivateTy;
+  PQTy = OpenMPStack.back().TaskPrivateQTy;
+  PB = OpenMPStack.back().TaskPrivateBase;
+}
+
+llvm::DenseMap<const ValueDecl *, FieldDecl *> &CodeGenModule::OpenMPSupportStackTy::getTaskFields() {
+  return OpenMPStack.back().TaskFields;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setUntiedData(llvm::Value *UntiedPartIdAddr, llvm::Value *UntiedSwitch,
+                                                        llvm::BasicBlock *UntiedEnd, unsigned UntiedCounter,
+                                                        CodeGenFunction *CGF) {
+  for (OMPStackTy::reverse_iterator I = OpenMPStack.rbegin(),
+                                    E = OpenMPStack.rend();
+       I != E; ++I) {
+    if (I->NewTask) {
+      I->UntiedPartIdAddr = UntiedPartIdAddr;
+      I->UntiedSwitch = UntiedSwitch;
+      I->UntiedEnd = UntiedEnd;
+      I->UntiedCounter = UntiedCounter;
+      I->ParentCGF = CGF;
+      return;
+    }
+  }
+}
+
+void CodeGenModule::OpenMPSupportStackTy::getUntiedData(llvm::Value *&UntiedPartIdAddr, llvm::Value *&UntiedSwitch,
+                                                        llvm::BasicBlock *&UntiedEnd, unsigned &UntiedCounter) {
+  for (OMPStackTy::reverse_iterator I = OpenMPStack.rbegin(),
+                                    E = OpenMPStack.rend();
+       I != E; ++I) {
+    if (I->NewTask) {
+      UntiedPartIdAddr = I->UntiedPartIdAddr;
+      UntiedSwitch = I->UntiedSwitch;
+      UntiedEnd = I->UntiedEnd;
+      UntiedCounter = I->UntiedCounter;
+      return;
+    }
+  }
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setParentUntiedData(llvm::Value *UntiedPartIdAddr, llvm::Value *UntiedSwitch,
+                                                              llvm::BasicBlock *UntiedEnd, unsigned UntiedCounter,
+                                                              CodeGenFunction *CGF) {
+  bool FirstTaskFound = false;
+  for (OMPStackTy::reverse_iterator I = OpenMPStack.rbegin(),
+                                    E = OpenMPStack.rend();
+       I != E; ++I) {
+    if (FirstTaskFound && I->NewTask) {
+      I->UntiedPartIdAddr = UntiedPartIdAddr;
+      I->UntiedSwitch = UntiedSwitch;
+      I->UntiedEnd = UntiedEnd;
+      I->UntiedCounter = UntiedCounter;
+      I->ParentCGF = CGF;
+      return;
+    }
+    FirstTaskFound = FirstTaskFound || I->NewTask;
+  }
+}
+
+void CodeGenModule::OpenMPSupportStackTy::getParentUntiedData(llvm::Value *&UntiedPartIdAddr, llvm::Value *&UntiedSwitch,
+                                                              llvm::BasicBlock *&UntiedEnd, unsigned &UntiedCounter,
+                                                              CodeGenFunction *&CGF) {
+  bool FirstTaskFound = false;
+  for (OMPStackTy::reverse_iterator I = OpenMPStack.rbegin(),
+                                    E = OpenMPStack.rend();
+       I != E; ++I) {
+    if (FirstTaskFound && I->NewTask) {
+      UntiedPartIdAddr = I->UntiedPartIdAddr;
+      UntiedSwitch = I->UntiedSwitch;
+      UntiedEnd = I->UntiedEnd;
+      UntiedCounter = I->UntiedCounter;
+      CGF = I->ParentCGF;
+      return;
+    }
+    FirstTaskFound = FirstTaskFound || I->NewTask;
+  }
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setNumTeams(llvm::Value *Num) {
+  OpenMPStack.back().NumTeams = Num;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setThreadLimit(llvm::Value *Num) {
+  OpenMPStack.back().ThreadLimit = Num;
+}
+
+llvm::Value *CodeGenModule::OpenMPSupportStackTy::getNumTeams() {
+  return OpenMPStack.back().NumTeams;
+}
+
+llvm::Value *CodeGenModule::OpenMPSupportStackTy::getThreadLimit() {
+  return OpenMPStack.back().ThreadLimit;
+}
+
+void CodeGenModule::OpenMPSupportStackTy::setWaitDepsArgs(llvm::Value **Args) {
+  OpenMPStack.back().WaitDepsArgs = Args;
+}
+
+llvm::Value **CodeGenModule::OpenMPSupportStackTy::getWaitDepsArgs() {
+  return OpenMPStack.back().WaitDepsArgs;
+}
+
 llvm::Constant *CodeGenModule::GetAddrOfRTTIDescriptor(QualType Ty,
                                                        bool ForEH) {
   // Return a bogus pointer if RTTI is disabled, unless it's for EH.
@@ -3379,3 +3838,19 @@
   return getCXXABI().getAddrOfRTTIDescriptor(Ty);
 }
 
+void CodeGenModule::OpenMPSupportStackTy::getMapData(ArrayRef<llvm::Value*> &MapPointers, ArrayRef<llvm::Value*> &MapSizes, ArrayRef<unsigned> &MapTypes){
+  MapPointers = OpenMPStack.back().MapPointers;
+  MapSizes = OpenMPStack.back().MapSizes;
+  MapTypes = OpenMPStack.back().MapTypes;
+}
+void CodeGenModule::OpenMPSupportStackTy::addMapData(llvm::Value *MapPointer, llvm::Value *MapSize, unsigned MapType){
+  OpenMPStack.back().MapPointers.push_back(MapPointer);
+  OpenMPStack.back().MapSizes.push_back(MapSize);
+  OpenMPStack.back().MapTypes.push_back(MapType);
+}
+void CodeGenModule::OpenMPSupportStackTy::setOffloadingDevice(llvm::Value *device){
+  OpenMPStack.back().OffloadingDevice = device;
+}
+llvm::Value *CodeGenModule::OpenMPSupportStackTy::getOffloadingDevice(){
+  return OpenMPStack.back().OffloadingDevice;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/CodeGenModule.h cfe-3.5.0.src.omp/lib/CodeGen/CodeGenModule.h
--- cfe-3.5.0.src/lib/CodeGen/CodeGenModule.h	2014-08-04 14:33:13.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/CodeGenModule.h	2014-11-28 10:49:29.000000000 -0500
@@ -302,6 +302,25 @@
   std::unique_ptr<llvm::IndexedInstrProfReader> PGOReader;
   InstrProfStats PGOStats;
 
+  struct ElementalVariantInfo {
+    /// \brief The CodeGen infomation of this function.
+    const CGFunctionInfo *FnInfo;
+    /// \brief The elemental function declaration.
+    const FunctionDecl *FD;
+    /// \brief The LLVM function of this declaration.
+    llvm::Function *Fn;
+    /// \brief The metadata describing this elemental function.
+    llvm::MDNode *KernelMD;
+
+    ElementalVariantInfo(const CGFunctionInfo *FnInfo, const FunctionDecl *FD,
+                         llvm::Function *Fn, llvm::MDNode *KernelMD)
+    : FnInfo(FnInfo), FD(FD), Fn(Fn), KernelMD(KernelMD) { }
+  };
+
+  /// ElementalVariantToEmit - This contains all Cilk Plus elemental function
+  /// variants to be emitted.
+  llvm::SmallVector<ElementalVariantInfo, 8> ElementalVariantToEmit;
+
   // A set of references that have only been seen via a weakref so far. This is
   // used to remove the weak of the reference if we ever see a direct reference
   // or a definition.
@@ -325,6 +344,9 @@
     DeferredDeclsToEmit.push_back(DeferredGlobal(GV, GD));
   }
 
+  /// DeferredOMP -- deferred OpenMP directives (e.g. #omp declare simd).
+  std::vector<const OMPDeclareSimdDecl*> DeferredOMP;
+
   /// List of alias we have emitted. Used to make sure that what they point to
   /// is defined once we get to the end of the of the translation unit.
   std::vector<GlobalDecl> Aliases;
@@ -434,7 +456,7 @@
   /// \brief The type used to describe the state of a fast enumeration in
   /// Objective-C's for..in loop.
   QualType ObjCFastEnumerationStateType;
-  
+
   /// @}
 
   /// Lazily create the Objective-C runtime
@@ -513,6 +535,75 @@
     return *CUDARuntime;
   }
 
+  // A common data structure to represent vector function attributes in
+  // cilk vector functions and 'omp declare simd' functions.
+  struct CilkElementalGroup {
+    typedef SmallVector<QualType, 1> VecLengthForVector;
+    typedef SmallVector<unsigned, 1> VecLengthVector;
+    // Masking: 0-nomask/notinbranch, 1-mask/inbranch
+    typedef SmallVector<unsigned, 2> MaskVector;
+    typedef std::map<std::string, std::pair<int,std::string> > LinearMap;
+    typedef std::map<std::string, unsigned> AlignedMap;
+    typedef std::set<std::string> UniformSet;
+
+    VecLengthVector VecLength;
+    VecLengthForVector VecLengthFor;
+    LinearMap  LinearParms;
+    AlignedMap AlignedParms;
+    UniformSet UniformParms;
+    MaskVector Mask;
+
+    bool getUniformAttr(std::string Name) const {
+      return UniformParms.count(Name) != 0;
+    }
+
+    bool getLinearAttr(std::string Name, std::pair<int,std::string> *out_step) const {
+      const LinearMap::const_iterator it = LinearParms.find(Name);
+      if (it == LinearParms.end()) return false;
+      *out_step = it->second;
+      return true;
+    }
+
+    bool getAlignedAttr(std::string Name, unsigned *out_alignment) const {
+      const AlignedMap::const_iterator I = AlignedParms.find(Name);
+      if (I == AlignedParms.end()) return false;
+      *out_alignment = I->second;
+      return true;
+    }
+
+    void setLinear(std::string Name, std::string Idname, int Step) {
+      LinearParms[Name].first = Step;
+      LinearParms[Name].second = Idname;
+    }
+
+    void setAligned(std::string Name, unsigned Alignment) {
+      AlignedParms[Name] = Alignment;
+    }
+
+    void setUniform(std::string Name) {
+      UniformParms.insert(Name);
+    }
+  };
+
+  typedef llvm::SmallDenseMap<unsigned, CilkElementalGroup, 4> GroupMap;
+
+  // The following is common part for 'cilk vector functions' and
+  // 'omp declare simd' functions metadata generation.
+  //
+  void EmitVectorVariantsMetadata(const CGFunctionInfo &FnInfo,
+                                  const FunctionDecl *FD,
+                                  llvm::Function *Fn,
+                                  GroupMap &Groups);
+
+  /// Add an elemental function metadata node to the named metadata node
+  /// 'cilk.functions'.
+  void EmitCilkElementalMetadata(const CGFunctionInfo &FnInfo,
+                                 const FunctionDecl *FD, llvm::Function *Fn);
+
+  /// Emit all elemental function vector variants in this module.
+  void EmitCilkElementalVariants();
+
+
   ARCEntrypoints &getARCEntrypoints() const {
     assert(getLangOpts().ObjCAutoRefCount && ARCData != nullptr);
     return *ARCData;
@@ -1026,6 +1117,215 @@
     DeferredVTables.push_back(RD);
   }
 
+  /// \brief Emit a code for threadprivate variables.
+  ///
+  void EmitOMPThreadPrivate(const OMPThreadPrivateDecl *D);
+  /// \brief Emit a code for threadprivate variable.
+  ///
+  void EmitOMPThreadPrivate(const VarDecl *VD, const Expr *TPE);
+  /// \brief Emit a code for declare reduction variables.
+  ///
+  void EmitOMPDeclareReduction(const OMPDeclareReductionDecl *D);
+  /// \brief Emit vector variants and metadata for 'omp declare simd'.
+  ///
+  void EmitOMPDeclareSimd(const OMPDeclareSimdDecl *D);
+  /// \brief Emit declare target decls.
+  ///
+  void EmitOMPDeclareTarget(const OMPDeclareTargetDecl *D);
+
+  class OpenMPSupportStackTy {
+    /// \brief A set of OpenMP threadprivate variables.
+    llvm::DenseMap<const Decl *, const Expr *> OpenMPThreadPrivate;
+    /// \brief A set of OpenMP private variables.
+    typedef llvm::DenseMap<const Decl *, llvm::Value *> OMPPrivateVarsTy;
+    struct OMPStackElemTy {
+      OMPPrivateVarsTy PrivateVars;
+      llvm::BasicBlock *IfEnd;
+      llvm::Function *ReductionFunc;
+      CodeGenModule &CGM;
+      CodeGenFunction *RedCGF;
+      llvm::SmallVector<llvm::Type *, 16> ReductionTypes;
+      llvm::DenseMap<const VarDecl *, unsigned> ReductionMap;
+      llvm::StructType *ReductionRec;
+      llvm::Value *ReductionRecVar;
+      llvm::Value *RedArg1;
+      llvm::Value *RedArg2;
+      llvm::Value *ReduceSwitch;
+      llvm::BasicBlock *BB1;
+      llvm::Instruction *BB1IP;
+      llvm::BasicBlock *BB2;
+      llvm::Instruction *BB2IP;
+      llvm::Value *LockVar;
+      llvm::BasicBlock *LastprivateBB;
+      llvm::Instruction *LastprivateIP;
+      llvm::BasicBlock *LastprivateEndBB;
+      llvm::Value *LastIterVar;
+      llvm::Value *TaskFlags;
+      llvm::Value *PTaskTValue;
+      llvm::Value *PTask;
+      llvm::Value *UntiedPartIdAddr;
+      unsigned     UntiedCounter;
+      llvm::Value *UntiedSwitch;
+      llvm::BasicBlock *UntiedEnd;
+      CodeGenFunction *ParentCGF;
+      bool NoWait;
+      bool Mergeable;
+      bool Ordered;
+      int Schedule;
+      const Expr *ChunkSize;
+      bool NewTask;
+      bool Untied;
+      bool TargetDeclare;
+      bool HasLastPrivate;
+      bool Distribute;
+      llvm::DenseMap<const ValueDecl *, FieldDecl *> TaskFields;
+      llvm::Type *TaskPrivateTy;
+      QualType TaskPrivateQTy;
+      llvm::Value *TaskPrivateBase;
+      llvm::Value *NumTeams;
+      llvm::Value *ThreadLimit;
+      llvm::Value **WaitDepsArgs;
+      llvm::SmallVector<llvm::Value*,16> MapPointers;
+      llvm::SmallVector<llvm::Value*,16> MapSizes;
+      llvm::SmallVector<unsigned,16> MapTypes;
+      llvm::Value* OffloadingDevice;
+      OMPStackElemTy(CodeGenModule &CGM);
+      ~OMPStackElemTy();
+    };
+    typedef llvm::SmallVector<OMPStackElemTy, 16> OMPStackTy;
+    OMPStackTy OpenMPStack;
+    CodeGenModule &CGM;
+    llvm::Type *KMPDependInfoType;
+    unsigned KMPDependInfoTypeAlign;
+  public:
+    OpenMPSupportStackTy(CodeGenModule &CGM)
+      : OpenMPThreadPrivate(), OpenMPStack(), CGM(CGM), KMPDependInfoType(0) { }
+    const Expr *hasThreadPrivateVar(const VarDecl *VD) {
+      const VarDecl *RVD = VD->getMostRecentDecl();
+      while (RVD) {
+        llvm::DenseMap<const Decl *, const Expr *>::iterator I =
+            OpenMPThreadPrivate.find(RVD);
+        if (I != OpenMPThreadPrivate.end())
+          return I->second;
+        RVD = RVD->getPreviousDecl();
+      }
+      return 0;
+    }
+    void addThreadPrivateVar(const VarDecl *VD, const Expr *TPE) {
+      OpenMPThreadPrivate[VD] = TPE;
+    }
+    /// \brief Checks, if the specified variable is currently marked as
+    /// private.
+    /// \return 0 if the variable is not private, or address of private
+    /// otherwise.
+    llvm::Value *getOpenMPPrivateVar(const VarDecl *VD) {
+      if (OpenMPStack.empty()) return 0;
+      for (OMPStackTy::reverse_iterator I = OpenMPStack.rbegin(),
+                                        E = OpenMPStack.rend();
+           I != E; ++I) {
+        if (I->PrivateVars.count(VD) > 0 && I->PrivateVars[VD])
+          return I->PrivateVars[VD];
+        if (I->NewTask) return 0;
+      }
+      return 0;
+    }
+    llvm::Value *getTopOpenMPPrivateVar(const VarDecl *VD) {
+      if (OpenMPStack.empty()) return 0;
+      return OpenMPStack.back().PrivateVars.count(VD) > 0 ? OpenMPStack.back().PrivateVars[VD] : 0;
+    }
+    llvm::Value *getPrevOpenMPPrivateVar(const VarDecl *VD) {
+      if (OpenMPStack.size()< 2) return 0;
+      return OpenMPStack[OpenMPStack.size() - 2].PrivateVars.count(VD) > 0 ? OpenMPStack[OpenMPStack.size() - 2].PrivateVars[VD] : 0;
+    }
+    void startOpenMPRegion(bool NewTask) {
+      OpenMPStack.push_back(OMPStackElemTy(CGM));
+      OpenMPStack.back().NewTask = NewTask;
+    }
+    bool isNewTask() { return OpenMPStack.back().NewTask; };
+    void endOpenMPRegion();
+    void addOpenMPPrivateVar(const VarDecl *VD, llvm::Value *Addr) {
+      assert(!OpenMPStack.empty() &&
+             "OpenMP private variables region is not started.");
+      OpenMPStack.back().PrivateVars[VD] = Addr;
+    }
+    void delOpenMPPrivateVar(const VarDecl *VD) {
+      assert(!OpenMPStack.empty() &&
+             "OpenMP private variables region is not started.");
+      OpenMPStack.back().PrivateVars[VD] = 0;
+    }
+    void delPrevOpenMPPrivateVar(const VarDecl *VD) {
+      assert(OpenMPStack.size() >= 2 &&
+             "OpenMP private variables region is not started.");
+      OpenMPStack[OpenMPStack.size() - 2].PrivateVars[VD] = 0;
+    }
+    void setIfDest(llvm::BasicBlock *EndBB) {OpenMPStack.back().IfEnd = EndBB;}
+    llvm::BasicBlock *takeIfDest() {
+      llvm::BasicBlock *BB = OpenMPStack.back().IfEnd;
+      OpenMPStack.back().IfEnd = 0;
+      return BB;
+    }
+    CodeGenFunction &getCGFForReductionFunction();
+    void getReductionFunctionArgs(llvm::Value *&Arg1, llvm::Value *&Arg2);
+    void registerReductionVar(const VarDecl *VD, llvm::Type *Type);
+    llvm::Value *getReductionRecVar(CodeGenFunction &CGF);
+    llvm::Type *getReductionRec();
+    llvm::Value *getReductionSwitch();
+    void setReductionSwitch(llvm::Value *Switch);
+    void setReductionIPs(llvm::BasicBlock *BB1, llvm::Instruction *IP1,
+                         llvm::BasicBlock *BB2, llvm::Instruction *IP2);
+    void getReductionIPs(llvm::BasicBlock *&BB1, llvm::Instruction *&IP1,
+                         llvm::BasicBlock *&BB2, llvm::Instruction *&IP2);
+    llvm::Value *getReductionLockVar();
+    void setReductionLockVar(llvm::Value *Var);
+    void setLastprivateIP(llvm::BasicBlock *BB, llvm::Instruction *IP, llvm::BasicBlock *EndBB);
+    void getLastprivateIP(llvm::BasicBlock *&BB, llvm::Instruction *&IP, llvm::BasicBlock *&EndBB);
+    llvm::Value *getLastIterVar();
+    void setLastIterVar(llvm::Value *Var);
+    unsigned getReductionVarIdx(const VarDecl *VD);
+    unsigned getNumberOfReductionVars();
+    void setNoWait(bool Flag);
+    bool getNoWait();
+    void setScheduleChunkSize(int Sched, const Expr *Size);
+    void getScheduleChunkSize(int &Sched, const Expr *&Size);
+    void setMergeable(bool Flag);
+    bool getMergeable();
+    void setOrdered(bool Flag);
+    bool getOrdered();
+    void setUntied(bool Flag);
+    bool getUntied();
+    void setTargetDeclare(bool Flag);
+    bool getTargetDeclare();
+    void setDistribute(bool Flag);
+    bool getDistribute();
+    bool getParentUntied();
+    void setHasLastPrivate(bool Flag);
+    bool hasLastPrivate();
+    llvm::Value *getTaskFlags();
+    void setTaskFlags(llvm::Value *Flags);
+    void setPTask(llvm::Value *Task, llvm::Value *TaskT, llvm::Type *PTy, QualType PQTy, llvm::Value *PB);
+    void getPTask(llvm::Value *&Task, llvm::Value *&TaskT, llvm::Type *&PTy, QualType &PQTy, llvm::Value *&PB);
+    llvm::DenseMap<const ValueDecl *, FieldDecl *> &getTaskFields();
+    void setUntiedData(llvm::Value *UntiedPartIdAddr, llvm::Value *UntiedSwitch, llvm::BasicBlock *UntiedEnd, unsigned UntiedCounter, CodeGenFunction *CGF);
+    void getUntiedData(llvm::Value *&UntiedPartIdAddr, llvm::Value *&UntiedSwitch, llvm::BasicBlock *&UntiedEnd, unsigned &UntiedCounter);
+    void setParentUntiedData(llvm::Value *UntiedPartIdAddr, llvm::Value *UntiedSwitch, llvm::BasicBlock *UntiedEnd, unsigned UntiedCounter, CodeGenFunction *CGF);
+    void getParentUntiedData(llvm::Value *&UntiedPartIdAddr, llvm::Value *&UntiedSwitch, llvm::BasicBlock *&UntiedEnd, unsigned &UntiedCounter, CodeGenFunction *&CGF);
+    void setKMPDependInfoType(llvm::Type *Ty, unsigned Align) { KMPDependInfoType = Ty; KMPDependInfoTypeAlign = Align; }
+    llvm::Type *getKMPDependInfoType() { return KMPDependInfoType; }
+    unsigned getKMPDependInfoTypeAlign() { return KMPDependInfoTypeAlign; }
+    void setNumTeams(llvm::Value *Num);
+    void setThreadLimit(llvm::Value *Num);
+    llvm::Value *getNumTeams();
+    llvm::Value *getThreadLimit();
+    void setWaitDepsArgs(llvm::Value **Args);
+    llvm::Value **getWaitDepsArgs();
+    void getMapData(ArrayRef<llvm::Value*> &MapPointers, ArrayRef<llvm::Value*> &MapSizes, ArrayRef<unsigned> &MapTypes);
+    void addMapData(llvm::Value *MapPointer, llvm::Value *MapSize, unsigned MapType);
+    void setOffloadingDevice(llvm::Value *device);
+    llvm::Value* getOffloadingDevice();
+  };
+
+  OpenMPSupportStackTy OpenMPSupport;
+
   /// Emit code for a singal global function or var decl. Forward declarations
   /// are emitted lazily.
   void EmitGlobal(GlobalDecl D);
@@ -1042,6 +1342,23 @@
                                         llvm::PointerType *PTy,
                                         const VarDecl *D);
 
+  /// \brief Creates OpenMP threadprivate function for specified variable
+  /// and returns this function and constructor, copy constructor and
+  /// destructor.
+  void CreateOpenMPCXXInit(const VarDecl *Var, CXXRecordDecl *Ty,
+                           llvm::Function *&InitFunction,
+                           llvm::Value *&Ctor,
+                           llvm::Value *&CCtor,
+                           llvm::Value *&Dtor);
+
+  /// \brief Creates OpenMP threadprivate function for specified array variable
+  /// and returns this function and constructor, copy constructor and
+  /// destructor.
+  void CreateOpenMPArrCXXInit(const VarDecl *Var, CXXRecordDecl *Ty,
+                              llvm::Function *&InitFunction,
+                              llvm::Value *&Ctor,
+                              llvm::Value *&CCtor,
+                              llvm::Value *&Dtor);
   /// Set attributes which are common to any form of a global definition (alias,
   /// Objective-C method, function, global variable).
   ///
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/MicrosoftCXXABI.cpp cfe-3.5.0.src.omp/lib/CodeGen/MicrosoftCXXABI.cpp
--- cfe-3.5.0.src/lib/CodeGen/MicrosoftCXXABI.cpp	2014-07-17 16:25:23.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/MicrosoftCXXABI.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -55,6 +55,8 @@
   // arbitrary.
   StringRef GetDeletedVirtualCallName() override { return "_purecall"; }
 
+  bool isInlineInitializedStaticDataMemberLinkOnce() { return true; }
+
   llvm::Value *adjustToCompleteObject(CodeGenFunction &CGF,
                                       llvm::Value *ptr,
                                       QualType type) override;
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/CodeGen/ModuleBuilder.cpp cfe-3.5.0.src.omp/lib/CodeGen/ModuleBuilder.cpp
--- cfe-3.5.0.src/lib/CodeGen/ModuleBuilder.cpp	2014-07-17 16:25:23.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/CodeGen/ModuleBuilder.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -16,6 +16,7 @@
 #include "CodeGenModule.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/DeclObjC.h"
+#include "clang/AST/DeclOpenMP.h"
 #include "clang/AST/Expr.h"
 #include "clang/Basic/Diagnostic.h"
 #include "clang/Basic/TargetInfo.h"
@@ -90,6 +91,7 @@
       if (Diags.hasErrorOccurred())
         return true;
 
+
       // Make sure to emit all elements of a Decl.
       for (DeclGroupRef::iterator I = DG.begin(), E = DG.end(); I != E; ++I)
         Builder->EmitTopLevelDecl(*I);
@@ -129,6 +131,14 @@
 
       Builder->UpdateCompletedType(D);
 
+      if (Ctx->getLangOpts().CPlusPlus && !D->isDependentContext()) {
+        for (DeclContext::decl_iterator M = D->decls_begin(),
+                                        MEnd = D->decls_end();
+             M != MEnd; ++M)
+          if (OMPThreadPrivateDecl *TD = dyn_cast<OMPThreadPrivateDecl>(*M))
+            Builder->EmitTopLevelDecl(TD);
+      }
+
       // For MSVC compatibility, treat declarations of static data members with
       // inline initializers as definitions.
       if (Ctx->getLangOpts().MSVCCompat) {
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Driver/Action.cpp cfe-3.5.0.src.omp/lib/Driver/Action.cpp
--- cfe-3.5.0.src/lib/Driver/Action.cpp	2014-02-06 13:53:25.000000000 -0500
+++ cfe-3.5.0.src.omp/lib/Driver/Action.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -24,6 +24,7 @@
   switch (AC) {
   case InputClass: return "input";
   case BindArchClass: return "bind-arch";
+  case BindTargetClass: return "bind-target";
   case PreprocessJobClass: return "preprocessor";
   case PrecompileJobClass: return "precompiler";
   case AnalyzeJobClass: return "analyzer";
@@ -52,6 +53,11 @@
   : Action(BindArchClass, Input, Input->getType()), ArchName(_ArchName) {
 }
 
+void BindTargetAction::anchor() {}
+
+BindTargetAction::BindTargetAction(Action *Input, const char *_TargetName)
+  : Action(BindTargetClass, Input, Input->getType()), TargetName(_TargetName) {
+}
 void JobAction::anchor() {}
 
 JobAction::JobAction(ActionClass Kind, Action *Input, types::ID Type)
@@ -144,3 +150,4 @@
 VerifyPCHJobAction::VerifyPCHJobAction(Action *Input, types::ID Type)
     : VerifyJobAction(VerifyPCHJobClass, Input, Type) {
 }
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Driver/Compilation.cpp cfe-3.5.0.src.omp/lib/Driver/Compilation.cpp
--- cfe-3.5.0.src/lib/Driver/Compilation.cpp	2014-07-07 04:37:15.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Driver/Compilation.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -33,7 +33,7 @@
   delete Args;
 
   // Free any derived arg lists.
-  for (llvm::DenseMap<std::pair<const ToolChain*, const char*>,
+  for (llvm::DenseMap<std::pair<ToolChainWithTargetInfo, const char*>,
                       DerivedArgList*>::iterator it = TCArgs.begin(),
          ie = TCArgs.end(); it != ie; ++it)
     if (it->second != TranslatedArgs)
@@ -53,16 +53,34 @@
 }
 
 const DerivedArgList &Compilation::getArgsForToolChain(const ToolChain *TC,
-                                                       const char *BoundArch) {
+                                                       const char *BoundArch,
+                                                       bool isOpenMPTarget,
+                                                       bool &isSuccess){
   if (!TC)
     TC = &DefaultToolChain;
 
-  DerivedArgList *&Entry = TCArgs[std::make_pair(TC, BoundArch)];
-  if (!Entry) {
-    Entry = TC->TranslateArgs(*TranslatedArgs, BoundArch);
-    if (!Entry)
-      Entry = TranslatedArgs;
-  }
+  // Try to locate the args in the toolchain map
+  llvm::DenseMap<std::pair<ToolChainWithTargetInfo, const char*>,
+                   llvm::opt::DerivedArgList *>::iterator it = TCArgs
+      .find(std::make_pair(std::make_pair(TC,(int)isOpenMPTarget),BoundArch));
+
+  // We have already tried to translate these args
+  if (it != TCArgs.end() ){
+    // if null, we already failed to translate
+    isSuccess = (it->second);
+    return *(it->second);
+  }
+
+  // This is the first attempt to translate these arguments
+  DerivedArgList *&Entry =TCArgs[
+       std::make_pair(std::make_pair(TC,(int)isOpenMPTarget),BoundArch)];
+
+  Entry = TC->TranslateArgs(*TranslatedArgs, BoundArch, isOpenMPTarget,
+                                                                    isSuccess);
+  // If we didn't get derived arguments but the translation is signaled as
+  // Successful, we should used the untranslated arguments
+  if (!Entry && isSuccess)
+    Entry = TranslatedArgs;
 
   return *Entry;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Driver/Driver.cpp cfe-3.5.0.src.omp/lib/Driver/Driver.cpp
--- cfe-3.5.0.src/lib/Driver/Driver.cpp	2014-07-11 10:28:45.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Driver/Driver.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -20,6 +20,7 @@
 #include "clang/Driver/Tool.h"
 #include "clang/Driver/ToolChain.h"
 #include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/SetVector.h"
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/StringExtras.h"
 #include "llvm/ADT/StringSet.h"
@@ -36,6 +37,7 @@
 #include "llvm/Support/PrettyStackTrace.h"
 #include "llvm/Support/Process.h"
 #include "llvm/Support/Program.h"
+#include "llvm/Support/TargetRegistry.h"
 #include "llvm/Support/raw_ostream.h"
 #include <map>
 #include <memory>
@@ -76,6 +78,8 @@
   delete Opts;
 
   llvm::DeleteContainerSeconds(ToolChains);
+  llvm::DeleteContainerSeconds(OpenMPTargetToolChains);
+  clearResultInfo();
 }
 
 void Driver::ParseDriverMode(ArrayRef<const char *> Args) {
@@ -130,9 +134,11 @@
       continue;
     }
 
-    // Warn about -mcpu= without an argument.
-    if (A->getOption().matches(options::OPT_mcpu_EQ) &&
-        A->containsValue("")) {
+    // Warn about -mcpu= and -omptargets= without an argument.
+    if ( (A->getOption().matches(options::OPT_mcpu_EQ)
+         && A->containsValue(""))
+         || (A->getOption().matches(options::OPT_omptargets_EQ)
+         && !A->getNumValues()) ) {
       Diag(clang::diag::warn_drv_empty_joined_argument) <<
         A->getAsString(*Args);
     }
@@ -146,6 +152,47 @@
   return Args;
 }
 
+void Driver::registerResultInfo(const ToolChain *TC, const Action *A,
+                                InputInfo Res) const{
+  assert( TC && A && "Invalid Toolchain or Action!!!");
+
+  InputInfo *R;
+  ResultInfoMap[A][TC] = R = new InputInfo();
+  *R = Res;
+}
+InputInfo *Driver::getResultInfo(const ToolChain *TC, const Action *A) const{
+
+  // If no results were ever registered for the requested action, return NULL
+  ResultInfoMapTy::const_iterator ResultsPerAction = ResultInfoMap.find(A);
+  if (ResultsPerAction == ResultInfoMap.end())
+    return nullptr;
+
+  const ResultInfoMapPerActionTy &MapPerAction = ResultsPerAction->second;
+  ResultInfoMapPerActionTy::const_iterator Result = MapPerAction.find(TC);
+
+  assert(!MapPerAction.empty() &&
+         "Action registered before without toolchain??");
+
+  // If we found results for the requested toolchain just return it
+  if ( Result != MapPerAction.end())
+    return Result->second;
+
+  // If we didn't find results for the requested toolchain but it is used for
+  // offloading, we can use whatever toolchain was registered
+  // before as long as it is not an offloading toolchain as well.
+  if (TC->isOpenMPTargetToolchain())
+    for (const auto &R : MapPerAction)
+      if (!R.first->isOpenMPTargetToolchain())
+        return R.second;
+
+  // In all other cases return null
+  return nullptr;
+}
+void Driver::clearResultInfo() const{
+  for( auto &M : ResultInfoMap)
+    llvm::DeleteContainerSeconds(M.second);
+  ResultInfoMap.clear();
+}
 // Determine which compilation mode we are in. We look for options which
 // affect the phase, starting with the earliest phases, and record which
 // option we used to determine the final phase.
@@ -805,7 +852,7 @@
   if (InputAction *IA = dyn_cast<InputAction>(A)) {
     os << "\"" << IA->getInputArg().getValue() << "\"";
   } else if (BindArchAction *BIA = dyn_cast<BindArchAction>(A)) {
-    os << '"' << BIA->getArchName() << '"'
+    os << '"' << ((BIA->getArchName())?BIA->getArchName():"default") << '"'
        << ", {" << PrintActions1(C, *BIA->begin(), Ids) << "}";
   } else {
     os << "{";
@@ -1174,9 +1221,40 @@
     }
   }
 
-  // Construct the actions to perform.
-  ActionList LinkerInputs;
+  // Determine how many compile phases need to be spawned in case we are using
+  // openmp with target regions. This is done based on the omptarget arguments.
+  // All registered targets are considered by default.
+  llvm::SmallSetVector<const char*,4> OpenMPTargets;
+
+  if (Args.hasArg(options::OPT_fopenmp)){
+
+    // check if there is any openmp target we care generating code to
+    Arg *Tgts = Args.getLastArg(options::OPT_omptargets_EQ);
+
+    // If omptargets was specified use only the required targets
+    if ( Tgts && Tgts->getNumValues() ){
+      for (unsigned v=0; v<Tgts->getNumValues(); ++v){
+        std::string error;
+        const char *val = Tgts->getValue(v);
+
+        llvm::Triple TT(val);
+
+        //If the specified target is invalid, emit error
+        if (TT.getArch() == llvm::Triple::UnknownArch)
+          Diag(clang::diag::err_drv_invalid_omp_target) << val;
+        else
+          OpenMPTargets.insert(val);
+      }
+    }
+  }
+
+  // We need an array of actions to trace the actions for the main target
+  // and each available omp target detected before
+  std::unique_ptr<Action> *ActionsForTarget =
+      new std::unique_ptr<Action>[1+OpenMPTargets.size()];
+  ActionList *LinkerInputsForTarget = new ActionList[1+OpenMPTargets.size()];
 
+  // Construct the actions to perform.
   llvm::SmallVector<phases::ID, phases::MaxNumberOfPhases> PL;
   for (unsigned i = 0, e = Inputs.size(); i != e; ++i) {
     types::ID InputType = Inputs[i].first;
@@ -1221,7 +1299,17 @@
     }
 
     // Build the pipeline for this file.
-    std::unique_ptr<Action> Current(new InputAction(*InputArg, InputType));
+
+    // Initialize with the current input
+    ActionsForTarget[0].reset(new InputAction(*InputArg, InputType));
+
+    // The number of targets we should take into account.
+    // Before the compile phase there is only one and from
+    // the compile phase on we will have N+1 targets
+    // where N is all the available omp targets
+    unsigned PreviousTotalTargets = 1;
+    unsigned TotalTargets = 1;
+
     for (SmallVectorImpl<phases::ID>::iterator
            i = PL.begin(), e = PL.end(); i != e; ++i) {
       phases::ID Phase = *i;
@@ -1230,33 +1318,120 @@
       if (Phase > FinalPhase)
         break;
 
-      // Queue linker inputs.
-      if (Phase == phases::Link) {
-        assert((i + 1) == e && "linking must be final compilation step.");
-        LinkerInputs.push_back(Current.release());
-        break;
-      }
+      bool NothingElseToDo = false;
 
-      // Some types skip the assembler phase (e.g., llvm-bc), but we can't
-      // encode this in the steps because the intermediate type depends on
-      // arguments. Just special case here.
-      if (Phase == phases::Assemble && Current->getType() != types::TY_PP_Asm)
-        continue;
+      // keep track of the number of targets in the previous phase
+      PreviousTotalTargets = TotalTargets;
+
+      // if it is past the preprocess phase, the total targets also contain the
+      // omp targets
+      if ( Phase > phases::Preprocess )
+        TotalTargets = 1+OpenMPTargets.size();
+
+      for (unsigned tgt=TotalTargets; tgt>0; --tgt){
+
+        // Get the right input action
+        Action *CurrentInput = 0;
+
+        // If we are coming from a single to multiple targets, we need to use
+        // the input file in all actions before removing it
+
+        if ( PreviousTotalTargets < TotalTargets && tgt>1 )
+          CurrentInput = ActionsForTarget[0].get();
+        else
+          CurrentInput = ActionsForTarget[tgt-1].release();
+
+        assert( CurrentInput && "Expecting an input to be defined");
+
+        // Queue linker inputs.
+        if (Phase == phases::Link) {
+          assert((i + 1) == e && "linking must be final compilation step.");
+          LinkerInputsForTarget[tgt-1].push_back(CurrentInput);
+          NothingElseToDo = true;
+          continue;
+        }
+
+        // Some types skip the assembler phase (e.g., llvm-bc), but we can't
+        // encode this in the steps because the intermediate type depends on
+        // arguments. Just special case here.
+        if (Phase == phases::Assemble &&
+            CurrentInput->getType() != types::TY_PP_Asm){
+          // Just store the current input to be used directly in the next phase
+          ActionsForTarget[tgt-1].reset(CurrentInput);
+          continue;
+        }
+
+        // Build the phase action
+        ActionsForTarget[tgt-1].reset(
+            ConstructPhaseAction(Args, Phase, CurrentInput));
+
+        if (ActionsForTarget[tgt-1]->getType() == types::TY_Nothing)
+          NothingElseToDo = true;
+
+        // If we are coming from a single to multiple target phase, set the
+        // input ownership flag to false
+        ActionsForTarget[tgt-1]->setOwnsInputs(
+            !(PreviousTotalTargets < TotalTargets));
+
+        // If we we are processing a target action, we need to bind it to the
+        // target it refers to
+        if ( tgt > 1 ){
+          ActionsForTarget[tgt-1]->setOffloadingDevice(OpenMPTargets[tgt-2]);
+          ActionsForTarget[tgt-1].reset(
+              new BindTargetAction(ActionsForTarget[tgt-1].release(),
+                                   OpenMPTargets[tgt-2]));
+        }
 
-      // Otherwise construct the appropriate action.
-      Current.reset(ConstructPhaseAction(Args, Phase, Current.release()));
-      if (Current->getType() == types::TY_Nothing)
+      }
+
+      if (NothingElseToDo)
         break;
     }
 
     // If we ended with something, add to the output list.
-    if (Current)
-      Actions.push_back(Current.release());
+    for (unsigned tgt=TotalTargets; tgt>0; --tgt){
+      if (ActionsForTarget[tgt-1])
+        Actions.push_back(ActionsForTarget[tgt-1].release());
+    }
+
+  }
+
+  // release the Actions-For-Target array
+  delete[] ActionsForTarget;
+
+  // Create link action for each target if any
+  for (unsigned tgt = OpenMPTargets.size(); tgt > 0; --tgt){
+
+    if (LinkerInputsForTarget[tgt].empty())
+      continue;
+
+    std::unique_ptr<Action> TgtLinkAction;
+    // Link target action: produces a shared library
+    TgtLinkAction.reset(
+        new LinkJobAction(LinkerInputsForTarget[tgt], types::TY_SObject));
+    TgtLinkAction.get()->setOffloadingDevice(OpenMPTargets[tgt-1]);
+
+    // if the target link phase takes an input that is not binded to it, it
+    // means it does not own it, as it may be used by other targets and host too
+    for (const auto &II : LinkerInputsForTarget[tgt]){
+      if ( !isa<BindTargetAction>(II) )
+        TgtLinkAction.get()->setOwnsInputs(false);
+    }
+
+    // Bind action to target
+    TgtLinkAction.reset(
+        new BindTargetAction(TgtLinkAction.release(), OpenMPTargets[tgt-1]));
+    // Include the resulting object as part of the host linking
+    LinkerInputsForTarget[0].push_back(TgtLinkAction.release());
   }
 
   // Add a link action if necessary.
-  if (!LinkerInputs.empty())
-    Actions.push_back(new LinkJobAction(LinkerInputs, types::TY_Image));
+  if (!LinkerInputsForTarget[0].empty())
+    Actions.push_back(
+        new LinkJobAction(LinkerInputsForTarget[0], types::TY_Image));
+
+  // Release the linking input arrays
+  delete[] LinkerInputsForTarget;
 
   // If we are linking, claim any options which are obviously only used for
   // compilation.
@@ -1373,6 +1548,9 @@
     }
   }
 
+  // Make sure the results map is cleared before starting to create jobs.
+  clearResultInfo();
+
   for (ActionList::const_iterator it = C.getActions().begin(),
          ie = C.getActions().end(); it != ie; ++it) {
     Action *A = *it;
@@ -1479,13 +1657,18 @@
 
   // See if we should use an integrated preprocessor. We do so when we have
   // exactly one input, since this is the only use case we care about
-  // (irrelevant since we don't support combine yet).
+  // (irrelevant since we don't support combine yet). If we have OpenMP
+  // offloading targets, we do not use the integrated preprocessor too as the
+  // input file needs to be preprocessed by the host and the result used by both
+  // host and targets.
   if (Inputs->size() == 1 && isa<PreprocessJobAction>(*Inputs->begin()) &&
       !C.getArgs().hasArg(options::OPT_no_integrated_cpp) &&
       !C.getArgs().hasArg(options::OPT_traditional_cpp) &&
       !C.getArgs().hasArg(options::OPT_save_temps) &&
       !C.getArgs().hasArg(options::OPT_rewrite_objc) &&
-      ToolForJob->hasIntegratedCPP())
+      !(C.getArgs().hasArg(options::OPT_fopenmp) &&
+        C.getArgs().hasArg(options::OPT_omptargets_EQ)) &&
+      ToolForJob->hasIntegratedCPP() )
     Inputs = &(*Inputs)[0]->getInputs();
 
   return ToolForJob;
@@ -1501,6 +1684,13 @@
                                 InputInfo &Result) const {
   llvm::PrettyStackTraceString CrashInfo("Building compilation jobs");
 
+  // If we already have compatible result information for this action we do not
+  // need to compute it again.
+  if (const InputInfo *PrevInfo = getResultInfo(TC,A)){
+    Result = *PrevInfo;
+    return;
+  }
+
   if (const InputAction *IA = dyn_cast<InputAction>(A)) {
     // FIXME: It would be nice to not claim this here; maybe the old scheme of
     // just using Args was better?
@@ -1508,9 +1698,11 @@
     Input.claim();
     if (Input.getOption().matches(options::OPT_INPUT)) {
       const char *Name = Input.getValue();
-      Result = InputInfo(Name, A->getType(), Name);
+      Result = InputInfo(Name, A, Name);
     } else
-      Result = InputInfo(&Input, A->getType(), "");
+      Result = InputInfo(&Input, A, "");
+
+    registerResultInfo(TC,A,Result);
     return;
   }
 
@@ -1525,6 +1717,31 @@
 
     BuildJobsForAction(C, *BAA->begin(), TC, BAA->getArchName(),
                        AtTopLevel, MultipleArchs, LinkingOutput, Result);
+
+    registerResultInfo(TC,A,Result);
+    return;
+  }
+
+  if (const BindTargetAction *BTA = dyn_cast<BindTargetAction>(A)) {
+    const ToolChain *TC;
+    const char *OpenMPTargetName = BTA->getTargetName();
+
+    assert( OpenMPTargetName && "Need to have a name for the target!" );
+
+    TC = &getToolChain(C.getArgs(), "", OpenMPTargetName);
+
+    // If the toolchain does not have isOpenMPTargetToolchain set it means
+    // there was some problem creating the toolchain
+    if ( !TC->isOpenMPTargetToolchain() ){
+      Diag(clang::diag::err_drv_omp_target_toolchain_not_available)
+          << OpenMPTargetName;
+      return;
+    }
+
+    BuildJobsForAction(C, *BTA->begin(), TC, BTA->getTargetName(),
+                       AtTopLevel, false, LinkingOutput, Result);
+
+    registerResultInfo(TC,A,Result);
     return;
   }
 
@@ -1539,6 +1756,7 @@
   InputInfoList InputInfos;
   for (ActionList::const_iterator it = Inputs->begin(), ie = Inputs->end();
        it != ie; ++it) {
+
     // Treat dsymutil and verify sub-jobs as being at the top-level too, they
     // shouldn't get temporary output names.
     // FIXME: Clean this up.
@@ -1562,11 +1780,13 @@
 
   // Determine the place to write output to, if any.
   if (JA->getType() == types::TY_Nothing)
-    Result = InputInfo(A->getType(), BaseInput);
+    Result = InputInfo(A, BaseInput);
   else
     Result = InputInfo(GetNamedOutputPath(C, *JA, BaseInput, BoundArch,
                                           AtTopLevel, MultipleArchs),
-                       A->getType(), BaseInput);
+                       A, BaseInput);
+
+  registerResultInfo(TC,A,Result);
 
   if (CCCPrintBindings && !CCGenDiagnostics) {
     llvm::errs() << "# \"" << T->getToolChain().getTripleString() << '"'
@@ -1578,8 +1798,20 @@
     }
     llvm::errs() << "], output: " << Result.getAsString() << "\n";
   } else {
-    T->ConstructJob(C, *JA, Result, InputInfos,
-                    C.getArgsForToolChain(TC, BoundArch), LinkingOutput);
+
+    bool isSuccess;
+
+    // Get the derived args for the target
+    const DerivedArgList &DArgs =
+     C.getArgsForToolChain(TC, BoundArch, JA->getOffloadingDevice(), isSuccess);
+
+    // If we were unable to successfully get the arguments we cannot create the
+    // job. This will happen if using an OpenMP target toolchain that is not
+    // prepared to translate arguments to OpenMP.
+    if (!isSuccess)
+      return;
+
+    T->ConstructJob(C, *JA, Result, InputInfos,  DArgs, LinkingOutput);
   }
 }
 
@@ -1716,6 +1948,13 @@
       Suffixed += "-";
       Suffixed.append(BoundArch);
     }
+
+    // Append OpenMP target suffix to output file
+    if ( JA.getOffloadingDevice() ){
+      Suffixed += ".tgt-";
+      Suffixed.append(BoundArch);
+    }
+
     Suffixed += '.';
     Suffixed += Suffix;
     NamedOutput = C.getArgs().MakeArgString(Suffixed.c_str());
@@ -1861,6 +2100,7 @@
 static llvm::Triple computeTargetTriple(StringRef DefaultTargetTriple,
                                         const ArgList &Args,
                                         StringRef DarwinArchName) {
+
   // FIXME: Already done in Compilation *Driver::BuildCompilation
   if (const Arg *A = Args.getLastArg(options::OPT_target))
     DefaultTargetTriple = A->getValue();
@@ -1940,100 +2180,133 @@
 }
 
 const ToolChain &Driver::getToolChain(const ArgList &Args,
-                                      StringRef DarwinArchName) const {
-  llvm::Triple Target = computeTargetTriple(DefaultTargetTriple, Args,
-                                            DarwinArchName);
+                                      StringRef DarwinArchName,
+                                      const char *OpenMPTripleString) const {
 
-  ToolChain *&TC = ToolChains[Target.str()];
-  if (!TC) {
+  llvm::Triple Target;
+  ToolChain **TC;
+  bool IsOpenMPTargetToolchain = OpenMPTripleString != nullptr;
+
+  // if a specific triple is passed, that means it was already parsed
+  // before while creating the actions for OpenMP targets, therefore we should
+  // be able to get the architecture directly from it.
+
+  if (IsOpenMPTargetToolchain){
+    Target = llvm::Triple(OpenMPTripleString);
+    assert( Target.getArch() != llvm::Triple::UnknownArch &&
+        "Target unknown - impossible to infer toolchain!");
+
+    TC = &OpenMPTargetToolChains[Target.str()];
+  }  else {
+    Target = computeTargetTriple(DefaultTargetTriple, Args, DarwinArchName);
+    TC = &ToolChains[Target.str()];
+  }
+
+  if (!*TC) {
     switch (Target.getOS()) {
     case llvm::Triple::AuroraUX:
-      TC = new toolchains::AuroraUX(*this, Target, Args);
+      *TC = new toolchains::AuroraUX(*this, Target, Args);
       break;
     case llvm::Triple::Darwin:
     case llvm::Triple::MacOSX:
     case llvm::Triple::IOS:
-      TC = new toolchains::DarwinClang(*this, Target, Args);
+      *TC = new toolchains::DarwinClang(*this, Target, Args);
       break;
     case llvm::Triple::DragonFly:
-      TC = new toolchains::DragonFly(*this, Target, Args);
+      *TC = new toolchains::DragonFly(*this, Target, Args);
       break;
     case llvm::Triple::OpenBSD:
-      TC = new toolchains::OpenBSD(*this, Target, Args);
+      *TC = new toolchains::OpenBSD(*this, Target, Args);
       break;
     case llvm::Triple::Bitrig:
-      TC = new toolchains::Bitrig(*this, Target, Args);
+      *TC = new toolchains::Bitrig(*this, Target, Args);
       break;
     case llvm::Triple::NetBSD:
-      TC = new toolchains::NetBSD(*this, Target, Args);
+      *TC = new toolchains::NetBSD(*this, Target, Args);
       break;
     case llvm::Triple::FreeBSD:
-      TC = new toolchains::FreeBSD(*this, Target, Args);
+      *TC = new toolchains::FreeBSD(*this, Target, Args);
       break;
     case llvm::Triple::Minix:
-      TC = new toolchains::Minix(*this, Target, Args);
+      *TC = new toolchains::Minix(*this, Target, Args);
       break;
     case llvm::Triple::Linux:
       if (Target.getArch() == llvm::Triple::hexagon)
-        TC = new toolchains::Hexagon_TC(*this, Target, Args);
+        *TC = new toolchains::Hexagon_TC(*this, Target, Args);
       else
-        TC = new toolchains::Linux(*this, Target, Args);
+        *TC = new toolchains::Linux(*this, Target, Args,
+                                    IsOpenMPTargetToolchain);
       break;
     case llvm::Triple::Solaris:
-      TC = new toolchains::Solaris(*this, Target, Args);
+      *TC = new toolchains::Solaris(*this, Target, Args);
       break;
     case llvm::Triple::Win32:
       switch (Target.getEnvironment()) {
       default:
         if (Target.isOSBinFormatELF())
-          TC = new toolchains::Generic_ELF(*this, Target, Args);
+          *TC = new toolchains::Generic_ELF(*this, Target, Args);
         else if (Target.isOSBinFormatMachO())
-          TC = new toolchains::MachO(*this, Target, Args);
+          *TC = new toolchains::MachO(*this, Target, Args);
         else
-          TC = new toolchains::Generic_GCC(*this, Target, Args);
+          *TC = new toolchains::Generic_GCC(*this, Target, Args);
         break;
       case llvm::Triple::GNU:
         // FIXME: We need a MinGW toolchain.  Use the default Generic_GCC
         // toolchain for now as the default case would below otherwise.
         if (Target.isOSBinFormatELF())
-          TC = new toolchains::Generic_ELF(*this, Target, Args);
+          *TC = new toolchains::Generic_ELF(*this, Target, Args);
         else
-          TC = new toolchains::Generic_GCC(*this, Target, Args);
+          *TC = new toolchains::Generic_GCC(*this, Target, Args);
         break;
       case llvm::Triple::MSVC:
       case llvm::Triple::UnknownEnvironment:
-        TC = new toolchains::Windows(*this, Target, Args);
+        *TC = new toolchains::Windows(*this, Target, Args);
         break;
       }
       break;
     default:
       // TCE is an OSless target
       if (Target.getArchName() == "tce") {
-        TC = new toolchains::TCEToolChain(*this, Target, Args);
+        *TC = new toolchains::TCEToolChain(*this, Target, Args);
         break;
       }
       // If Hexagon is configured as an OSless target
       if (Target.getArch() == llvm::Triple::hexagon) {
-        TC = new toolchains::Hexagon_TC(*this, Target, Args);
+        *TC = new toolchains::Hexagon_TC(*this, Target, Args);
         break;
       }
       if (Target.getArch() == llvm::Triple::xcore) {
-        TC = new toolchains::XCore(*this, Target, Args);
+        *TC = new toolchains::XCore(*this, Target, Args);
+        break;
+      }
+      if (Target.getArch() == llvm::Triple::nvptx ||
+          Target.getArch() == llvm::Triple::nvptx64 ) {
+        *TC = new toolchains::NVPTX_TC(*this, Target, Args,
+                                       IsOpenMPTargetToolchain);
         break;
       }
       if (Target.isOSBinFormatELF()) {
-        TC = new toolchains::Generic_ELF(*this, Target, Args);
+        *TC = new toolchains::Generic_ELF(*this, Target, Args,
+                                          IsOpenMPTargetToolchain);
         break;
       }
       if (Target.getObjectFormat() == llvm::Triple::MachO) {
-        TC = new toolchains::MachO(*this, Target, Args);
+        *TC = new toolchains::MachO(*this, Target, Args);
         break;
       }
-      TC = new toolchains::Generic_GCC(*this, Target, Args);
+      *TC = new toolchains::Generic_GCC(*this, Target, Args,
+                                        IsOpenMPTargetToolchain);
       break;
     }
   }
-  return *TC;
+
+  // If this is not an OpenMPToolchain the information in TC needs to
+  // be consistent with the flag IsOpenMPTargetToolchain
+  assert((IsOpenMPTargetToolchain ||
+          IsOpenMPTargetToolchain == (*TC)->isOpenMPTargetToolchain()) &&
+          "Unable to initialize toolchain for OpenMP offloading!!!");
+
+  return **TC;
 }
 
 bool Driver::ShouldUseClangCompiler(const JobAction &JA) const {
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Driver/InputInfo.h cfe-3.5.0.src.omp/lib/Driver/InputInfo.h
--- cfe-3.5.0.src/lib/Driver/InputInfo.h	2013-06-17 09:59:19.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Driver/InputInfo.h	2014-11-28 10:49:29.000000000 -0500
@@ -10,6 +10,7 @@
 #ifndef CLANG_LIB_DRIVER_INPUTINFO_H_
 #define CLANG_LIB_DRIVER_INPUTINFO_H_
 
+#include "clang/Driver/Action.h"
 #include "clang/Driver/Types.h"
 #include "llvm/Option/Arg.h"
 #include <cassert>
@@ -40,19 +41,24 @@
   Class Kind;
   types::ID Type;
   const char *BaseInput;
+  // Action that lead to this info
+  const Action* OrigAction;
 
 public:
   InputInfo() {}
-  InputInfo(types::ID _Type, const char *_BaseInput)
-    : Kind(Nothing), Type(_Type), BaseInput(_BaseInput) {
-  }
-  InputInfo(const char *_Filename, types::ID _Type, const char *_BaseInput)
-    : Kind(Filename), Type(_Type), BaseInput(_BaseInput) {
+  InputInfo(const Action* _OrigAction, const char *_BaseInput)
+    : Kind(Nothing), Type(_OrigAction->getType()), BaseInput(_BaseInput),
+      OrigAction(_OrigAction) {
+  }
+  InputInfo(const char *_Filename, const Action* _OrigAction, const char *_BaseInput)
+    : Kind(Filename), Type(_OrigAction->getType()), BaseInput(_BaseInput),
+      OrigAction(_OrigAction) {
     Data.Filename = _Filename;
   }
-  InputInfo(const llvm::opt::Arg *_InputArg, types::ID _Type,
+  InputInfo(const llvm::opt::Arg *_InputArg, const Action* _OrigAction,
             const char *_BaseInput)
-      : Kind(InputArg), Type(_Type), BaseInput(_BaseInput) {
+      : Kind(InputArg), Type(_OrigAction->getType()), BaseInput(_BaseInput),
+        OrigAction(_OrigAction) {
     Data.InputArg = _InputArg;
   }
 
@@ -81,6 +87,10 @@
     else
       return "(nothing)";
   }
+
+  // getOriginalAction - Return the action that produced
+  // this input info
+  const Action *getOriginalAction() const {return OrigAction;}
 };
 
 } // end namespace driver
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Driver/Job.cpp cfe-3.5.0.src.omp/lib/Driver/Job.cpp
--- cfe-3.5.0.src/lib/Driver/Job.cpp	2014-06-22 16:35:10.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Driver/Job.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -15,6 +15,7 @@
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/StringRef.h"
 #include "llvm/ADT/StringSwitch.h"
+#include "llvm/Support/Debug.h"
 #include "llvm/Support/Program.h"
 #include "llvm/Support/raw_ostream.h"
 #include <cassert>
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Driver/ToolChain.cpp cfe-3.5.0.src.omp/lib/Driver/ToolChain.cpp
--- cfe-3.5.0.src/lib/Driver/ToolChain.cpp	2014-06-26 10:23:45.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Driver/ToolChain.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -27,8 +27,8 @@
 using namespace llvm::opt;
 
 ToolChain::ToolChain(const Driver &D, const llvm::Triple &T,
-                     const ArgList &A)
-  : D(D), Triple(T), Args(A) {
+                     const ArgList &A, bool IsOpenMPTargetToolchain)
+  : D(D), Triple(T), Args(A), IsOpenMPTargetToolchain(IsOpenMPTargetToolchain) {
 }
 
 ToolChain::~ToolChain() {
@@ -113,6 +113,7 @@
 
   case Action::InputClass:
   case Action::BindArchClass:
+  case Action::BindTargetClass:
   case Action::LipoJobClass:
   case Action::DsymutilJobClass:
   case Action::VerifyDebugInfoJobClass:
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Driver/ToolChains.cpp cfe-3.5.0.src.omp/lib/Driver/ToolChains.cpp
--- cfe-3.5.0.src/lib/Driver/ToolChains.cpp	2014-08-27 16:07:31.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Driver/ToolChains.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -668,7 +668,21 @@
 }
 
 DerivedArgList *MachO::TranslateArgs(const DerivedArgList &Args,
-                                     const char *BoundArch) const {
+                                      const char *BoundArch,
+                                      bool isOpenMPTarget,
+                                      bool &isSuccess) const {
+
+  if (isOpenMPTarget){
+  	// This translation is not dealing with OpenMP target directives yet
+    isSuccess = false;
+
+    getDriver().Diag(diag::err_drv_omp_target_translation_not_available)
+        << BoundArch;
+    return 0;
+  }
+
+  isSuccess = true;
+
   DerivedArgList *DAL = new DerivedArgList(Args.getBaseArgs());
   const OptTable &Opts = getDriver().getOpts();
 
@@ -901,9 +915,22 @@
 
 
 DerivedArgList *Darwin::TranslateArgs(const DerivedArgList &Args,
-                                      const char *BoundArch) const {
+                                      const char *BoundArch,
+                                      bool isOpenMPTarget,
+                                      bool &isSuccess) const {
+
+  if (isOpenMPTarget){
+    // This translation is not dealing with OpenMP target directives yet
+    isSuccess = false;
+
+    getDriver().Diag(diag::err_drv_omp_target_translation_not_available)
+        << BoundArch;
+    return 0;
+  }
+
   // First get the generic Apple args, before moving onto Darwin-specific ones.
-  DerivedArgList *DAL = MachO::TranslateArgs(Args, BoundArch);
+  DerivedArgList *DAL = MachO::TranslateArgs(Args, BoundArch,
+                                             isOpenMPTarget, isSuccess);
   const OptTable &Opts = getDriver().getOpts();
 
   // If no architecture is bound, none of the translations here are relevant.
@@ -1214,8 +1241,9 @@
 /// necessary because the driver doesn't store the final version of the target
 /// triple.
 void
-Generic_GCC::GCCInstallationDetector::init(
-    const Driver &D, const llvm::Triple &TargetTriple, const ArgList &Args) {
+Generic_GCC::GCCInstallationDetector::init( const Driver &D,
+    const llvm::Triple &TargetTriple, const ArgList &Args,
+    bool isOpenMPTarget) {
   llvm::Triple BiarchVariantTriple =
       TargetTriple.isArch32Bit() ? TargetTriple.get64BitArchVariant()
                                  : TargetTriple.get32BitArchVariant();
@@ -1265,7 +1293,8 @@
         continue;
       for (unsigned k = 0, ke = CandidateTripleAliases.size(); k < ke; ++k)
         ScanLibDirForGCCTriple(TargetTriple, Args, LibDir,
-                               CandidateTripleAliases[k]);
+                               CandidateTripleAliases[k],
+                               isOpenMPTarget);
     }
     for (unsigned j = 0, je = CandidateBiarchLibDirs.size(); j < je; ++j) {
       const std::string LibDir = Prefixes[i] + CandidateBiarchLibDirs[j].str();
@@ -1275,6 +1304,7 @@
            ++k)
         ScanLibDirForGCCTriple(TargetTriple, Args, LibDir,
                                CandidateBiarchTripleAliases[k],
+                               isOpenMPTarget,
                                /*NeedsBiarchSuffix=*/ true);
     }
   }
@@ -1647,7 +1677,8 @@
 
 static bool findMIPSMultilibs(const llvm::Triple &TargetTriple, StringRef Path,
                               const llvm::opt::ArgList &Args,
-                              DetectedMultilibs &Result) {
+                              DetectedMultilibs &Result,
+                              bool isOpenMPTarget) {
   // Some MIPS toolchains put libraries and object files compiled
   // using different options in to the sub-directoris which names
   // reflects the flags used for compilation. For example sysroot
@@ -1884,8 +1915,8 @@
   addMultilibFlag(CPUName == "mips64r2" || CPUName == "octeon",
                   "march=mips64r2", Flags);
   addMultilibFlag(isMicroMips(Args), "mmicromips", Flags);
-  addMultilibFlag(tools::mips::isNaN2008(Args, TargetTriple), "mnan=2008",
-                  Flags);
+  addMultilibFlag(tools::mips::isNaN2008(Args, TargetTriple, isOpenMPTarget),
+                  "mnan=2008", Flags);
   addMultilibFlag(ABIName == "n32", "mabi=n32", Flags);
   addMultilibFlag(ABIName == "n64", "mabi=n64", Flags);
   addMultilibFlag(isSoftFloatABI(Args), "msoft-float", Flags);
@@ -2026,7 +2057,7 @@
 void Generic_GCC::GCCInstallationDetector::ScanLibDirForGCCTriple(
     const llvm::Triple &TargetTriple, const ArgList &Args,
     const std::string &LibDir, StringRef CandidateTriple,
-    bool NeedsBiarchSuffix) {
+    bool isOpenMPTarget, bool NeedsBiarchSuffix) {
   llvm::Triple::ArchType TargetArch = TargetTriple.getArch();
   // There are various different suffixes involving the triple we
   // check for. We also record what is necessary to walk from each back
@@ -2077,7 +2108,8 @@
       // Debian mips multilibs behave more like the rest of the biarch ones,
       // so handle them there
       if (isMipsArch(TargetArch)) {
-        if (!findMIPSMultilibs(TargetTriple, LI->path(), Args, Detected))
+        if (!findMIPSMultilibs(TargetTriple, LI->path(), Args, Detected,
+                               isOpenMPTarget))
           continue;
       } else if (!findBiarchMultilibs(TargetTriple, LI->path(), Args,
                                       NeedsBiarchSuffix, Detected)) {
@@ -2100,8 +2132,9 @@
 }
 
 Generic_GCC::Generic_GCC(const Driver &D, const llvm::Triple& Triple,
-                         const ArgList &Args)
-  : ToolChain(D, Triple, Args), GCCInstallation() {
+                         const ArgList &Args,
+                         bool IsOpenMPTargetToolchain)
+  : ToolChain(D, Triple, Args, IsOpenMPTargetToolchain), GCCInstallation() {
   getProgramPaths().push_back(getDriver().getInstalledDir());
   if (getDriver().getInstalledDir() != getDriver().Dir)
     getProgramPaths().push_back(getDriver().Dir);
@@ -2154,6 +2187,54 @@
   return false;
 }
 
+
+llvm::opt::DerivedArgList *
+Generic_GCC::TranslateArgs(const llvm::opt::DerivedArgList &Args,
+              const char *BoundArch,
+              bool isOpenMPTarget,
+              bool &isSuccess) const{
+
+  isSuccess = true;
+
+  // If not a target tool chain we can use the arguments directly without
+  // translation
+  if (!isOpenMPTarget)
+    return 0;
+
+  DerivedArgList *DAL = new DerivedArgList(Args.getBaseArgs());
+  const OptTable &Opts = getDriver().getOpts();
+
+  // FIXME: We should consider move this to each tool.
+
+  for (ArgList::const_iterator it = Args.begin(),
+         ie = Args.end(); it != ie; ++it) {
+    Arg *A = *it;
+
+    // We are forcing the compiler to create a shared library
+    DAL->AddFlagArg(0, Opts.getOption(options::OPT_shared));
+    DAL->AddFlagArg(0, Opts.getOption(options::OPT_fPIC));
+
+    switch ((options::ID) A->getOption().getID()) {
+    default:
+      DAL->append(A);
+      break;
+    case options::OPT_shared:
+    case options::OPT_static:
+    case options::OPT_fPIC:
+    case options::OPT_fno_PIC:
+    case options::OPT_fpic:
+    case options::OPT_fno_pic:
+    case options::OPT_fPIE:
+    case options::OPT_fno_PIE:
+    case options::OPT_fpie:
+    case options::OPT_fno_pie:
+      break;
+    }
+  }
+
+  return DAL;
+}
+
 bool Generic_GCC::IsIntegratedAssemblerDefault() const {
   return getTriple().getArch() == llvm::Triple::x86 ||
          getTriple().getArch() == llvm::Triple::x86_64 ||
@@ -2187,11 +2268,15 @@
 
 /// Hexagon Toolchain
 
-std::string Hexagon_TC::GetGnuDir(const std::string &InstalledDir) {
+std::string Hexagon_TC::GetGnuDir(const std::string &InstalledDir,
+                                    const ArgList &Args) {
 
   // Locate the rest of the toolchain ...
-  if (strlen(GCC_INSTALL_PREFIX))
-    return std::string(GCC_INSTALL_PREFIX);
+  const Arg *A = Args.getLastArg(options::OPT_gcc_toolchain);
+  std::string gcc_toolchain( (A) ? A->getValue() : GCC_INSTALL_PREFIX);
+
+  if ( !gcc_toolchain.empty() )
+    return gcc_toolchain;
 
   std::string InstallRelDir = InstalledDir + "/../../gnu";
   if (llvm::sys::fs::exists(InstallRelDir))
@@ -2231,7 +2316,7 @@
   const std::string MarchSuffix = "/" + MarchString;
   const std::string G0Suffix = "/G0";
   const std::string MarchG0Suffix = MarchSuffix + G0Suffix;
-  const std::string RootDir = Hexagon_TC::GetGnuDir(InstalledDir) + "/";
+  const std::string RootDir = Hexagon_TC::GetGnuDir(InstalledDir, Args) + "/";
 
   // lib/gcc/hexagon/...
   std::string LibGCCHexagonDir = RootDir + "lib/gcc/hexagon/";
@@ -2259,7 +2344,7 @@
                        const ArgList &Args)
   : Linux(D, Triple, Args) {
   const std::string InstalledDir(getDriver().getInstalledDir());
-  const std::string GnuDir = Hexagon_TC::GetGnuDir(InstalledDir);
+  const std::string GnuDir = Hexagon_TC::GetGnuDir(InstalledDir, Args);
 
   // Note: Generic_GCC::Generic_GCC adds InstalledDir and getDriver().Dir to
   // program paths
@@ -2314,7 +2399,7 @@
     return;
 
   std::string Ver(GetGCCLibAndIncVersion());
-  std::string GnuDir = Hexagon_TC::GetGnuDir(D.InstalledDir);
+  std::string GnuDir = Hexagon_TC::GetGnuDir(D.InstalledDir, DriverArgs);
   std::string HexagonDir(GnuDir + "/lib/gcc/hexagon/" + Ver);
   addExternCSystemInclude(DriverArgs, CC1Args, HexagonDir + "/include");
   addExternCSystemInclude(DriverArgs, CC1Args, HexagonDir + "/include-fixed");
@@ -2330,7 +2415,7 @@
 
   const Driver &D = getDriver();
   std::string Ver(GetGCCLibAndIncVersion());
-  SmallString<128> IncludeDir(Hexagon_TC::GetGnuDir(D.InstalledDir));
+  SmallString<128> IncludeDir(Hexagon_TC::GetGnuDir(D.InstalledDir, DriverArgs));
 
   llvm::sys::path::append(IncludeDir, "hexagon/include/c++/");
   llvm::sys::path::append(IncludeDir, Ver);
@@ -3019,9 +3104,10 @@
   return Triple.isArch32Bit() ? "lib" : "lib64";
 }
 
-Linux::Linux(const Driver &D, const llvm::Triple &Triple, const ArgList &Args)
-  : Generic_ELF(D, Triple, Args) {
-  GCCInstallation.init(D, Triple, Args);
+Linux::Linux(const Driver &D, const llvm::Triple &Triple, const ArgList &Args,
+             bool IsOpenMPTargetToolchain)
+  : Generic_ELF(D, Triple, Args, IsOpenMPTargetToolchain) {
+  GCCInstallation.init(D, Triple, Args, IsOpenMPTargetToolchain);
   Multilibs = GCCInstallation.getMultilibs();
   llvm::Triple::ArchType Arch = Triple.getArch();
   std::string SysRoot = computeSysRoot();
@@ -3601,3 +3687,50 @@
                                 ArgStringList &CmdArgs) const {
   // We don't output any lib args. This is handled by xcc.
 }
+
+/// NVPTX tool chain
+NVPTX_TC::NVPTX_TC(const Driver &D, const llvm::Triple &Triple,
+                   const ArgList &Args, bool IsOpenMPTargetToolchain)
+                 : ToolChain(D, Triple, Args, IsOpenMPTargetToolchain) {
+  // ProgramPaths are found via 'PATH' environment variable.
+}
+
+Tool *NVPTX_TC::buildAssembler() const {
+  return new tools::NVPTX::Assemble(*this);
+}
+
+Tool *NVPTX_TC::buildLinker() const {
+  return new tools::NVPTX::Link(*this);
+}
+
+bool NVPTX_TC::isPICDefault() const {
+  return false;
+}
+
+bool NVPTX_TC::isPIEDefault() const {
+  return false;
+}
+
+bool NVPTX_TC::isPICDefaultForced() const {
+  return false;
+}
+
+bool NVPTX_TC::SupportsProfiling() const {
+  return false;
+}
+
+bool NVPTX_TC::hasBlocksRuntime() const {
+  return false;
+}
+
+llvm::opt::DerivedArgList *
+NVPTX_TC::TranslateArgs(const llvm::opt::DerivedArgList &Args,
+              const char *BoundArch,
+              bool isOpenMPTarget,
+              bool &isSuccess) const {
+
+  isSuccess = true;
+
+  // We do not need any translation for this target
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Driver/ToolChains.h cfe-3.5.0.src.omp/lib/Driver/ToolChains.h
--- cfe-3.5.0.src/lib/Driver/ToolChains.h	2014-08-27 16:07:13.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Driver/ToolChains.h	2014-11-28 10:49:29.000000000 -0500
@@ -101,7 +101,8 @@
   public:
     GCCInstallationDetector() : IsValid(false) {}
     void init(const Driver &D, const llvm::Triple &TargetTriple,
-                            const llvm::opt::ArgList &Args);
+                            const llvm::opt::ArgList &Args,
+                            bool isOpenMPTarget);
 
     /// \brief Check whether we detected a valid GCC install.
     bool isValid() const { return IsValid; }
@@ -144,6 +145,7 @@
                                 const llvm::opt::ArgList &Args,
                                 const std::string &LibDir,
                                 StringRef CandidateTriple,
+                                bool isOpenMPTarget,
                                 bool NeedsBiarchSuffix = false);
   };
 
@@ -151,7 +153,8 @@
 
 public:
   Generic_GCC(const Driver &D, const llvm::Triple &Triple,
-              const llvm::opt::ArgList &Args);
+              const llvm::opt::ArgList &Args,
+              bool IsOpenMPTargetToolchain = false);
   ~Generic_GCC();
 
   void printVerboseInfo(raw_ostream &OS) const override;
@@ -162,6 +165,12 @@
   bool isPICDefaultForced() const override;
   bool IsIntegratedAssemblerDefault() const override;
 
+  virtual llvm::opt::DerivedArgList *
+  TranslateArgs(const llvm::opt::DerivedArgList &Args,
+                const char *BoundArch,
+                bool isOpenMPTarget,
+                bool &isSuccess) const;
+
 protected:
   Tool *getTool(Action::ActionClass AC) const override;
   Tool *buildAssembler() const override;
@@ -251,7 +260,9 @@
 
   llvm::opt::DerivedArgList *
   TranslateArgs(const llvm::opt::DerivedArgList &Args,
-                const char *BoundArch) const override;
+                const char *BoundArch,
+                bool isOpenMPTarget,
+                bool &isSuccess) const override;
 
   bool IsBlocksDefault() const override {
     // Always allow blocks on Apple; users interested in versioning are
@@ -434,7 +445,9 @@
 
   llvm::opt::DerivedArgList *
   TranslateArgs(const llvm::opt::DerivedArgList &Args,
-                const char *BoundArch) const override;
+                const char *BoundArch,
+                bool isOpenMPTarget,
+                bool &isSuccess) const override;
 
   ObjCRuntime getDefaultObjCRuntime(bool isNonFragile) const override;
   bool hasBlocksRuntime() const override;
@@ -499,8 +512,9 @@
   virtual void anchor();
 public:
   Generic_ELF(const Driver &D, const llvm::Triple &Triple,
-              const llvm::opt::ArgList &Args)
-      : Generic_GCC(D, Triple, Args) {}
+              const llvm::opt::ArgList &Args,
+              bool IsOpenMPTargetToolchain = false)
+      : Generic_GCC(D, Triple, Args, IsOpenMPTargetToolchain) {}
 
   void addClangTargetOptions(const llvm::opt::ArgList &DriverArgs,
                              llvm::opt::ArgStringList &CC1Args) const override;
@@ -657,7 +671,7 @@
 class LLVM_LIBRARY_VISIBILITY Linux : public Generic_ELF {
 public:
   Linux(const Driver &D, const llvm::Triple &Triple,
-        const llvm::opt::ArgList &Args);
+        const llvm::opt::ArgList &Args, bool IsOpenMPTargetToolchain = false);
 
   bool HasNativeLLVMSupport() const override;
 
@@ -709,7 +723,8 @@
 
   StringRef GetGCCLibAndIncVersion() const { return GCCLibAndIncVersion.Text; }
 
-  static std::string GetGnuDir(const std::string &InstalledDir);
+  static std::string GetGnuDir(const std::string &InstalledDir,
+                               const llvm::opt::ArgList &Args);
 
   static StringRef GetTargetCPU(const llvm::opt::ArgList &Args);
 };
@@ -775,6 +790,37 @@
                            llvm::opt::ArgStringList &CmdArgs) const override;
 };
 
+class LLVM_LIBRARY_VISIBILITY NVPTX_TC : public ToolChain {
+public:
+  NVPTX_TC(const Driver &D, const llvm::Triple &Triple,
+          const llvm::opt::ArgList &Args,
+          bool IsOpenMPTargetToolchain = false);
+protected:
+  virtual Tool *buildAssembler() const;
+  virtual Tool *buildLinker() const;
+public:
+  virtual bool isPICDefault() const;
+  virtual bool isPIEDefault() const;
+  virtual bool isPICDefaultForced() const;
+  virtual bool SupportsProfiling() const;
+  virtual bool hasBlocksRuntime() const;
+//  virtual void AddClangSystemIncludeArgs(const llvm::opt::ArgList &DriverArgs,
+//                            llvm::opt::ArgStringList &CC1Args) const;
+//  virtual void addClangTargetOptions(const llvm::opt::ArgList &DriverArgs,
+//                                     llvm::opt::ArgStringList &CC1Args) const;
+//  virtual void AddClangCXXStdlibIncludeArgs(const llvm::opt::ArgList &DriverArgs,
+//                               llvm::opt::ArgStringList &CC1Args) const;
+//  virtual void AddCXXStdlibLibArgs(const llvm::opt::ArgList &Args,
+//                                   llvm::opt::ArgStringList &CmdArgs) const;
+
+  virtual llvm::opt::DerivedArgList *
+  TranslateArgs(const llvm::opt::DerivedArgList &Args,
+                const char *BoundArch,
+                bool isOpenMPTarget,
+                bool &isSuccess) const;
+
+};
+
 } // end namespace toolchains
 } // end namespace driver
 } // end namespace clang
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Driver/Tools.cpp cfe-3.5.0.src.omp/lib/Driver/Tools.cpp
--- cfe-3.5.0.src/lib/Driver/Tools.cpp	2014-08-07 00:51:51.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Driver/Tools.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -32,7 +32,6 @@
 #include "llvm/Support/Compression.h"
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/FileSystem.h"
-#include "llvm/Support/Format.h"
 #include "llvm/Support/Host.h"
 #include "llvm/Support/Path.h"
 #include "llvm/Support/Process.h"
@@ -169,7 +168,7 @@
 
 static void AddLinkerInputs(const ToolChain &TC,
                             const InputInfoList &Inputs, const ArgList &Args,
-                            ArgStringList &CmdArgs) {
+                            ArgStringList &CmdArgs, bool isTargetLinkage) {
   const Driver &D = TC.getDriver();
 
   // Add extra linker input arguments which are not treated as inputs
@@ -187,8 +186,14 @@
           << TC.getTripleString();
     }
 
-    // Add filenames immediately.
+    // Add filenames immediately except if this is a host linker phase and the
+    // the object files (inputs) are produced by a target assembler. Those are
+    // handled by a linker script.
     if (II.isFilename()) {
+
+      if ( !isTargetLinkage && II.getOriginalAction()->getOffloadingDevice() )
+        continue;
+
       CmdArgs.push_back(II.getFilename());
       continue;
     }
@@ -216,6 +221,108 @@
     addDirectoryList(Args, CmdArgs, "-L", "LIBRARY_PATH");
 }
 
+static void AddOpenMPLinkerScript(const ToolChain &TC, Compilation &C,
+                  const JobAction &JA,
+                  const InputInfo &Output,
+                  const InputInfoList &Inputs,
+                  const ArgList &Args,
+                  ArgStringList &CmdArgs) {
+
+  if ( !Args.hasArg(options::OPT_fopenmp) )
+    return;
+
+  // This is the linkage for the target
+  if ( JA.getOffloadingDevice() )
+    return;
+
+  // Add OpenMP target arguments by employing
+
+  // FIXME: check if the toolchain supports a linker script
+
+  // Gather the pairs (target triple)-(file name)
+
+  std::vector<std::pair<const char*,const char*> > Targets;
+
+  for (InputInfoList::const_iterator
+       it = Inputs.begin(), ie = Inputs.end(); it != ie; ++it) {
+    const InputInfo &II = *it;
+
+    if ( const char *tname = II.getOriginalAction()->getOffloadingDevice()){
+      Targets.push_back(std::pair<const char*,const char*>
+                  (tname,II.getFilename()));
+
+    }
+  }
+
+  if (Targets.empty())
+    return;
+
+  // Create temporary linker script
+  StringRef Name = llvm::sys::path::filename(Output.getFilename());
+  std::pair<StringRef, StringRef> Split = Name.rsplit('.');
+  std::string TmpName = C.getDriver().GetTemporaryPath(Split.first,"lk");
+  const char *LKS = C.addTempFile(C.getArgs().MakeArgString(TmpName.c_str()));
+
+  // Open script file in order to write contents
+  std::string EC;
+  llvm::raw_fd_ostream lksf(LKS,EC,llvm::sys::fs::F_None);
+
+  if (!EC.empty()) {
+    // FIXME: maybe use a file open failure message here
+    C.getDriver().Diag(clang::diag::err_unable_to_make_temp) << EC;
+    return;
+  }
+
+  // Add commands to embed target binaries. We ensure that each section and
+  // image s 16-byte aligned. This is not mandatory, but increases the
+  // likelihood of data to be aligned with a cache block in several main host
+  // machines.
+  lksf << "TARGET(binary)\n";
+  for (unsigned i=0; i<Targets.size(); ++i)
+    lksf << "INPUT(" << Targets[i].second << ")\n";
+
+  lksf << "SECTIONS\n";
+  lksf << "{\n";
+  lksf << "  .openmptgt ALIGN(0x10) : {\n";
+
+  for (unsigned i=0; i<Targets.size(); ++i){
+    std::string tgt_name(Targets[i].first);
+    std::replace(tgt_name.begin(),tgt_name.end(),'-','_');
+    lksf << "    . = ALIGN(0x10);\n";
+    lksf << "    __omptgt__img_start_" << tgt_name << " = .;\n";
+    lksf << "    " << Targets[i].second << "\n";
+    lksf << "    __omptgt__img_end_" << tgt_name << " = .;\n";
+
+    // We append the host entries and target name associated with the target
+    // image
+
+    lksf << "    QUAD(__omptgt__host_entries_begin);\n";
+    lksf << "    QUAD(__omptgt__host_entries_end);\n";
+
+    for(const char *c = tgt_name.c_str(); *c != '\0'; ++c )
+      lksf << "    BYTE(" << (unsigned)*c  << ");\n";
+    lksf << "    BYTE(0);\n";
+
+  }
+
+  lksf << "  }\n";
+  // Add commands to define host entries begin and end
+  lksf << "  .openmptgt_host_entries ALIGN(0x10) : {\n";
+  lksf << "    __omptgt__host_entries_begin = .;\n";
+  lksf << "    *(.openmptgt_host_entries)\n";
+  lksf << "    __omptgt__host_entries_end = .;\n";
+  lksf << "  }\n";
+  lksf << "}\n";
+  lksf << "INSERT BEFORE .data\n";
+
+  lksf.close();
+
+  CmdArgs.push_back("-T");
+  CmdArgs.push_back(LKS);
+
+}
+
+
 /// \brief Determine whether Objective-C automated reference counting is
 /// enabled.
 static bool isObjCAutoRefCount(const ArgList &Args) {
@@ -1133,6 +1240,33 @@
   }
 }
 
+/// getNVPTXTargetCPU - Get the (LLVM) name of the NVPTX gpu we are targeting.
+static const char *getNVPTXTargetGPU(const ArgList &Args,
+                                   const llvm::Triple &Triple,
+                                   bool isOpenMPTarget) {
+
+  // if this is not an OpenMP target we can rely on the arch parameter
+  if ( isOpenMPTarget )
+    if (const Arg *A = Args.getLastArg(options::OPT_march_EQ))
+        return A->getValue();
+
+  StringRef ArchName = Triple.getArchName();
+
+  if (ArchName.empty())
+    return "sm_20";
+
+  return llvm::StringSwitch<const char *>(ArchName)
+      .Case("nvptxsm_20", "sm_20")
+      .Case("nvptxsm_21", "sm_21")
+      .Case("nvptxsm_30", "sm_30")
+      .Case("nvptxsm_35", "sm_35")
+      .Case("nvptx64sm_20", "sm_20")
+      .Case("nvptx64sm_21", "sm_21")
+      .Case("nvptx64sm_30", "sm_30")
+      .Case("nvptx64sm_35", "sm_35")
+      .Default("sm_20");
+}
+
 /// getPPCTargetCPU - Get the (LLVM) name of the PowerPC cpu we are targeting.
 static std::string getPPCTargetCPU(const ArgList &Args) {
   if (Arg *A = Args.getLastArg(options::OPT_mcpu_EQ)) {
@@ -1353,7 +1487,8 @@
   }
 }
 
-static std::string getCPUName(const ArgList &Args, const llvm::Triple &T) {
+static std::string getCPUName(const ArgList &Args, const llvm::Triple &T,
+                              bool isOpenMPTarget) {
   switch(T.getArch()) {
   default:
     return "";
@@ -1416,11 +1551,15 @@
 
   case llvm::Triple::r600:
     return getR600TargetGPU(Args);
+
+  case llvm::Triple::nvptx:
+  case llvm::Triple::nvptx64:
+    return getNVPTXTargetGPU(Args,T,isOpenMPTarget);
   }
 }
 
 static void AddGoldPlugin(const ToolChain &ToolChain, const ArgList &Args,
-                          ArgStringList &CmdArgs) {
+                          ArgStringList &CmdArgs, bool isOpenMPTarget) {
   // Tell the linker to load the plugin. This has to come before AddLinkerInputs
   // as gold requires -plugin to come before any -plugin-opt that -Wl might
   // forward.
@@ -1432,7 +1571,7 @@
   // the plugin.
 
   // Handle flags for selecting CPU variants.
-  std::string CPU = getCPUName(Args, ToolChain.getTriple());
+  std::string CPU = getCPUName(Args, ToolChain.getTriple(), isOpenMPTarget);
   if (!CPU.empty())
     CmdArgs.push_back(Args.MakeArgString(Twine("-plugin-opt=mcpu=") + CPU));
 }
@@ -2427,6 +2566,36 @@
   // FIXME: Implement custom jobs for internal actions.
   CmdArgs.push_back("-cc1");
 
+  if (Args.hasArg(options::OPT_fopenmp)){
+    CmdArgs.push_back("-fopenmp");
+
+    // pass the targets we are generating code to
+    if ( Arg *Tgts = Args.getLastArg(options::OPT_omptargets_EQ) ){
+
+      ArrayRef<const char *> Vals = Tgts->getValues();
+
+      if (!Vals.empty()){
+
+        std::string S("-omptargets=");
+        S += Vals[0];
+        for (unsigned i=1; i <Vals.size(); ++i ){
+          S += ',';
+          S += Vals[i];
+        }
+        CmdArgs.push_back(Args.MakeArgString(S));
+      }
+    }
+
+    // inform the frontend we are generating code for a target
+    if ( JA.getOffloadingDevice() )
+      CmdArgs.push_back("-omp-target-mode");
+
+    // the frontend components needs to know the path of the original source
+    // file given that the target functions use that to generate a unique name
+    CmdArgs.push_back("-omp-main-file-path");
+    CmdArgs.push_back(Args.MakeArgString(Inputs[0].getBaseInput()));
+  }
+
   // Add the "effective" target triple.
   CmdArgs.push_back("-triple");
   std::string TripleStr = getToolChain().ComputeEffectiveClangTriple(Args);
@@ -2989,7 +3158,7 @@
   // Add the target cpu
   std::string ETripleStr = getToolChain().ComputeEffectiveClangTriple(Args);
   llvm::Triple ETriple(ETripleStr);
-  std::string CPU = getCPUName(Args, ETriple);
+  std::string CPU = getCPUName(Args, ETriple, JA.getOffloadingDevice());
   if (!CPU.empty()) {
     CmdArgs.push_back("-target-cpu");
     CmdArgs.push_back(Args.MakeArgString(CPU));
@@ -4739,7 +4908,7 @@
 
   // Add the target cpu
   const llvm::Triple &Triple = getToolChain().getTriple();
-  std::string CPU = getCPUName(Args, Triple);
+  std::string CPU = getCPUName(Args, Triple, JA.getOffloadingDevice());
   if (!CPU.empty()) {
     CmdArgs.push_back("-target-cpu");
     CmdArgs.push_back(Args.MakeArgString(CPU));
@@ -5133,8 +5302,8 @@
   const std::string MarchSuffix = "/" + MarchString;
   const std::string G0Suffix = "/G0";
   const std::string MarchG0Suffix = MarchSuffix + G0Suffix;
-  const std::string RootDir = toolchains::Hexagon_TC::GetGnuDir(D.InstalledDir)
-                              + "/";
+  const std::string RootDir =
+      toolchains::Hexagon_TC::GetGnuDir(D.InstalledDir, Args) + "/";
   const std::string StartFilesDir = RootDir
                                     + "hexagon/lib"
                                     + (buildingLib
@@ -5189,8 +5358,7 @@
   Args.AddAllArgs(CmdArgs, options::OPT_t);
   Args.AddAllArgs(CmdArgs, options::OPT_u_Group);
 
-  AddLinkerInputs(ToolChain, Inputs, Args, CmdArgs);
-
+  AddLinkerInputs(ToolChain, Inputs, Args, CmdArgs, JA.getOffloadingDevice());
   //----------------------------------------------------------------------------
   // Libraries
   //----------------------------------------------------------------------------
@@ -5203,7 +5371,7 @@
     CmdArgs.push_back("--start-group");
 
     if (!buildingLib) {
-      for(std::vector<std::string>::iterator i = oslibs.begin(),
+      for (std::vector<std::string>::iterator i = oslibs.begin(),
             e = oslibs.end(); i != e; ++i)
         CmdArgs.push_back(Args.MakeArgString("-l" + *i));
       CmdArgs.push_back("-lc");
@@ -5221,6 +5389,8 @@
     CmdArgs.push_back(Args.MakeArgString(StartFilesDir + finiObj));
   }
 
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
+
   std::string Linker = ToolChain.GetProgramPath("hexagon-ld");
   C.addCommand(new Command(JA, *this, Args.MakeArgString(Linker), CmdArgs));
 }
@@ -5304,7 +5474,8 @@
   return A && (A->getValue() == StringRef(Value));
 }
 
-bool mips::isNaN2008(const ArgList &Args, const llvm::Triple &Triple) {
+bool mips::isNaN2008(const ArgList &Args, const llvm::Triple &Triple,
+                     bool isOpenMPTarget) {
   if (Arg *NaNArg = Args.getLastArg(options::OPT_mnan_EQ))
     return llvm::StringSwitch<bool>(NaNArg->getValue())
                .Case("2008", true)
@@ -5312,7 +5483,7 @@
                .Default(false);
 
   // NaN2008 is the default for MIPS32r6/MIPS64r6.
-  return llvm::StringSwitch<bool>(getCPUName(Args, Triple))
+  return llvm::StringSwitch<bool>(getCPUName(Args, Triple, isOpenMPTarget))
              .Cases("mips32r6", "mips64r6", true)
              .Default(false);
 
@@ -5738,30 +5909,16 @@
 
   Args.AddAllArgs(CmdArgs, options::OPT_L);
 
-  LibOpenMP UsedOpenMPLib = LibUnknown;
-  if (Args.hasArg(options::OPT_fopenmp)) {
-    UsedOpenMPLib = LibGOMP;
-  } else if (const Arg *A = Args.getLastArg(options::OPT_fopenmp_EQ)) {
-    UsedOpenMPLib = llvm::StringSwitch<LibOpenMP>(A->getValue())
-        .Case("libgomp",  LibGOMP)
-        .Case("libiomp5", LibIOMP5)
-        .Default(LibUnknown);
-    if (UsedOpenMPLib == LibUnknown)
-      getToolChain().getDriver().Diag(diag::err_drv_unsupported_option_argument)
-        << A->getOption().getName() << A->getValue();
-  }
-  switch (UsedOpenMPLib) {
-  case LibGOMP:
-    CmdArgs.push_back("-lgomp");
-    break;
-  case LibIOMP5:
+  if (Args.hasArg(options::OPT_fopenmp)){
+    // This is more complicated in gcc...
     CmdArgs.push_back("-liomp5");
-    break;
-  case LibUnknown:
-    break;
+
+    if (Args.hasArg(options::OPT_omptargets_EQ))
+      CmdArgs.push_back("-lomptarget");
   }
 
-  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs);
+  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,
+      JA.getOffloadingDevice());
   
   if (isObjCRuntimeLinked(Args) &&
       !Args.hasArg(options::OPT_nostdlib) &&
@@ -5803,6 +5960,8 @@
   Args.AddAllArgs(CmdArgs, options::OPT_T_Group);
   Args.AddAllArgs(CmdArgs, options::OPT_F);
 
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
+
   const char *Exec =
     Args.MakeArgString(getToolChain().GetLinkerPath());
   C.addCommand(new Command(JA, *this, Exec, CmdArgs));
@@ -5971,7 +6130,8 @@
   Args.AddAllArgs(CmdArgs, options::OPT_e);
   Args.AddAllArgs(CmdArgs, options::OPT_r);
 
-  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs);
+  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,
+      JA.getOffloadingDevice());
 
   if (!Args.hasArg(options::OPT_nostdlib) &&
       !Args.hasArg(options::OPT_nodefaultlibs)) {
@@ -5993,6 +6153,8 @@
 
   addProfileRT(getToolChain(), Args, CmdArgs);
 
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
+
   const char *Exec =
     Args.MakeArgString(getToolChain().GetLinkerPath());
   C.addCommand(new Command(JA, *this, Exec, CmdArgs));
@@ -6077,7 +6239,8 @@
   Args.AddAllArgs(CmdArgs, options::OPT_T_Group);
   Args.AddAllArgs(CmdArgs, options::OPT_e);
 
-  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs);
+  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,
+      JA.getOffloadingDevice());
 
   if (!Args.hasArg(options::OPT_nostdlib) &&
       !Args.hasArg(options::OPT_nodefaultlibs)) {
@@ -6101,6 +6264,8 @@
 
   addProfileRT(getToolChain(), Args, CmdArgs);
 
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
+
   const char *Exec =
     Args.MakeArgString(getToolChain().GetLinkerPath());
   C.addCommand(new Command(JA, *this, Exec, CmdArgs));
@@ -6162,6 +6327,40 @@
   if (NeedsKPIC)
     addAssemblerKPIC(Args, CmdArgs);
 
+  // When building 32-bit code on OpenBSD/amd64, we have to explicitly
+  // instruct as in the base system to assemble 32-bit code.
+  if (getToolChain().getArch() == llvm::Triple::x86)
+    CmdArgs.push_back("--32");
+  else if (getToolChain().getArch() == llvm::Triple::ppc) {
+    CmdArgs.push_back("-mppc");
+    CmdArgs.push_back("-many");
+  } else if (getToolChain().getArch() == llvm::Triple::mips64 ||
+             getToolChain().getArch() == llvm::Triple::mips64el) {
+    StringRef CPUName;
+    StringRef ABIName;
+    mips::getMipsCPUAndABI(Args, getToolChain().getTriple(), CPUName, ABIName);
+
+    CmdArgs.push_back("-mabi");
+    CmdArgs.push_back(getGnuCompatibleMipsABIName(ABIName).data());
+
+    if (getToolChain().getArch() == llvm::Triple::mips64)
+      CmdArgs.push_back("-EB");
+    else
+      CmdArgs.push_back("-EL");
+
+    Arg *LastPICArg = Args.getLastArg(options::OPT_fPIC, options::OPT_fno_PIC,
+                                      options::OPT_fpic, options::OPT_fno_pic,
+                                      options::OPT_fPIE, options::OPT_fno_PIE,
+                                      options::OPT_fpie, options::OPT_fno_pie);
+    if (LastPICArg &&
+        (LastPICArg->getOption().matches(options::OPT_fPIC) ||
+         LastPICArg->getOption().matches(options::OPT_fpic) ||
+         LastPICArg->getOption().matches(options::OPT_fPIE) ||
+         LastPICArg->getOption().matches(options::OPT_fpie))) {
+      CmdArgs.push_back("-KPIC");
+    }
+  }
+
   Args.AddAllArgValues(CmdArgs, options::OPT_Wa_COMMA,
                        options::OPT_Xassembler);
 
@@ -6259,7 +6458,8 @@
   Args.AddAllArgs(CmdArgs, options::OPT_Z_Flag);
   Args.AddAllArgs(CmdArgs, options::OPT_r);
 
-  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs);
+  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,
+      JA.getOffloadingDevice());
 
   if (!Args.hasArg(options::OPT_nostdlib) &&
       !Args.hasArg(options::OPT_nodefaultlibs)) {
@@ -6303,6 +6503,8 @@
                               getToolChain().GetFilePath("crtendS.o")));
   }
 
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
+
   const char *Exec =
     Args.MakeArgString(getToolChain().GetLinkerPath());
   C.addCommand(new Command(JA, *this, Exec, CmdArgs));
@@ -6385,7 +6587,8 @@
   Args.AddAllArgs(CmdArgs, options::OPT_T_Group);
   Args.AddAllArgs(CmdArgs, options::OPT_e);
 
-  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs);
+  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,
+      JA.getOffloadingDevice());
 
   if (!Args.hasArg(options::OPT_nostdlib) &&
       !Args.hasArg(options::OPT_nodefaultlibs)) {
@@ -6439,6 +6642,8 @@
                               getToolChain().GetFilePath("crtendS.o")));
   }
 
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
+
   const char *Exec =
     Args.MakeArgString(getToolChain().GetLinkerPath());
   C.addCommand(new Command(JA, *this, Exec, CmdArgs));
@@ -6632,9 +6837,10 @@
   Args.AddAllArgs(CmdArgs, options::OPT_r);
 
   if (D.IsUsingLTO(Args))
-    AddGoldPlugin(ToolChain, Args, CmdArgs);
+    AddGoldPlugin(ToolChain, Args, CmdArgs, JA.getOffloadingDevice());
 
-  AddLinkerInputs(ToolChain, Inputs, Args, CmdArgs);
+  AddLinkerInputs(ToolChain, Inputs, Args, CmdArgs,
+      JA.getOffloadingDevice());
 
   if (!Args.hasArg(options::OPT_nostdlib) &&
       !Args.hasArg(options::OPT_nodefaultlibs)) {
@@ -6703,6 +6909,8 @@
 
   addProfileRT(ToolChain, Args, CmdArgs);
 
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
+
   const char *Exec =
     Args.MakeArgString(getToolChain().GetLinkerPath());
   C.addCommand(new Command(JA, *this, Exec, CmdArgs));
@@ -6896,7 +7104,8 @@
   Args.AddAllArgs(CmdArgs, options::OPT_Z_Flag);
   Args.AddAllArgs(CmdArgs, options::OPT_r);
 
-  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs);
+  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,
+      JA.getOffloadingDevice());
 
   unsigned Major, Minor, Micro;
   getToolChain().getTriple().getOSVersion(Major, Minor, Micro);
@@ -6957,6 +7166,8 @@
 
   addProfileRT(getToolChain(), Args, CmdArgs);
 
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
+
   const char *Exec = Args.MakeArgString(getToolChain().GetLinkerPath());
   C.addCommand(new Command(JA, *this, Exec, CmdArgs));
 }
@@ -7176,7 +7387,8 @@
 }
 
 static StringRef getLinuxDynamicLinker(const ArgList &Args,
-                                       const toolchains::Linux &ToolChain) {
+                                       const toolchains::Linux &ToolChain,
+                                       bool isOpenMPTarget) {
   if (ToolChain.getTriple().getEnvironment() == llvm::Triple::Android) {
     if (ToolChain.getTriple().isArch64Bit())
       return "/system/bin/linker64";
@@ -7205,15 +7417,15 @@
       return "/lib/ld-linux.so.3";              /* TODO: check which dynamic linker name.  */
   } else if (ToolChain.getArch() == llvm::Triple::mips ||
              ToolChain.getArch() == llvm::Triple::mipsel) {
-    if (mips::isNaN2008(Args, ToolChain.getTriple()))
+    if (mips::isNaN2008(Args, ToolChain.getTriple(), isOpenMPTarget))
       return "/lib/ld-linux-mipsn8.so.1";
     return "/lib/ld.so.1";
   } else if (ToolChain.getArch() == llvm::Triple::mips64 ||
              ToolChain.getArch() == llvm::Triple::mips64el) {
     if (mips::hasMipsAbiArg(Args, "n32"))
-      return mips::isNaN2008(Args, ToolChain.getTriple())
+      return mips::isNaN2008(Args, ToolChain.getTriple(), isOpenMPTarget)
                  ? "/lib32/ld-linux-mipsn8.so.1" : "/lib32/ld.so.1";
-    return mips::isNaN2008(Args, ToolChain.getTriple())
+    return mips::isNaN2008(Args, ToolChain.getTriple(), isOpenMPTarget)
                ? "/lib64/ld-linux-mipsn8.so.1" : "/lib64/ld.so.1";
   } else if (ToolChain.getArch() == llvm::Triple::ppc)
     return "/lib/ld.so.1";
@@ -7251,6 +7463,7 @@
                                   const InputInfoList &Inputs,
                                   const ArgList &Args,
                                   const char *LinkingOutput) const {
+
   const toolchains::Linux& ToolChain =
     static_cast<const toolchains::Linux&>(getToolChain());
   const Driver &D = ToolChain.getDriver();
@@ -7363,7 +7576,8 @@
        !Args.hasArg(options::OPT_shared))) {
     CmdArgs.push_back("-dynamic-linker");
     CmdArgs.push_back(Args.MakeArgString(
-        D.DyldPrefix + getLinuxDynamicLinker(Args, ToolChain)));
+        D.DyldPrefix + getLinuxDynamicLinker(Args, ToolChain,
+                                             JA.getOffloadingDevice())));
   }
 
   CmdArgs.push_back("-o");
@@ -7411,12 +7625,13 @@
     CmdArgs.push_back(Args.MakeArgString(StringRef("-L") + Path));
 
   if (D.IsUsingLTO(Args))
-    AddGoldPlugin(ToolChain, Args, CmdArgs);
+    AddGoldPlugin(ToolChain, Args, CmdArgs, JA.getOffloadingDevice());
 
   if (Args.hasArg(options::OPT_Z_Xlinker__no_demangle))
     CmdArgs.push_back("--no-demangle");
 
-  AddLinkerInputs(ToolChain, Inputs, Args, CmdArgs);
+  AddLinkerInputs(ToolChain, Inputs, Args, CmdArgs,
+      JA.getOffloadingDevice());
 
   addSanitizerRuntimes(getToolChain(), Args, CmdArgs);
   // The profile runtime also needs access to system libraries.
@@ -7440,36 +7655,16 @@
       if (Args.hasArg(options::OPT_static))
         CmdArgs.push_back("--start-group");
 
-      LibOpenMP UsedOpenMPLib = LibUnknown;
-      if (Args.hasArg(options::OPT_fopenmp)) {
-        UsedOpenMPLib = LibGOMP;
-      } else if (const Arg *A = Args.getLastArg(options::OPT_fopenmp_EQ)) {
-        UsedOpenMPLib = llvm::StringSwitch<LibOpenMP>(A->getValue())
-            .Case("libgomp",  LibGOMP)
-            .Case("libiomp5", LibIOMP5)
-            .Default(LibUnknown);
-        if (UsedOpenMPLib == LibUnknown)
-          D.Diag(diag::err_drv_unsupported_option_argument)
-            << A->getOption().getName() << A->getValue();
-      }
-      switch (UsedOpenMPLib) {
-      case LibGOMP:
-        CmdArgs.push_back("-lgomp");
-
-        // FIXME: Exclude this for platforms with libgomp that don't require
-        // librt. Most modern Linux platforms require it, but some may not.
-        CmdArgs.push_back("-lrt");
-        break;
-      case LibIOMP5:
+      bool OpenMP = Args.hasArg(options::OPT_fopenmp);
+      if (OpenMP) {
         CmdArgs.push_back("-liomp5");
-        break;
-      case LibUnknown:
-        break;
+        if (Args.hasArg(options::OPT_omptargets_EQ))
+          CmdArgs.push_back("-lomptarget");
       }
       AddRunTimeLibs(ToolChain, D, CmdArgs, Args);
 
       if ((Args.hasArg(options::OPT_pthread) ||
-           Args.hasArg(options::OPT_pthreads) || UsedOpenMPLib != LibUnknown) &&
+           Args.hasArg(options::OPT_pthreads) || OpenMP) &&
           !isAndroid)
         CmdArgs.push_back("-lpthread");
 
@@ -7496,6 +7691,8 @@
     }
   }
 
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
+
   C.addCommand(new Command(JA, *this, ToolChain.Linker.c_str(), CmdArgs));
 }
 
@@ -7545,7 +7742,8 @@
   Args.AddAllArgs(CmdArgs, options::OPT_T_Group);
   Args.AddAllArgs(CmdArgs, options::OPT_e);
 
-  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs);
+  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,
+      JA.getOffloadingDevice());
 
   addProfileRT(getToolChain(), Args, CmdArgs);
 
@@ -7568,6 +7766,8 @@
          Args.MakeArgString(getToolChain().GetFilePath("crtend.o")));
   }
 
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
+
   const char *Exec = Args.MakeArgString(getToolChain().GetLinkerPath());
   C.addCommand(new Command(JA, *this, Exec, CmdArgs));
 }
@@ -7673,7 +7873,8 @@
   Args.AddAllArgs(CmdArgs, options::OPT_T_Group);
   Args.AddAllArgs(CmdArgs, options::OPT_e);
 
-  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs);
+  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,
+      JA.getOffloadingDevice());
 
   if (!Args.hasArg(options::OPT_nostdlib) &&
       !Args.hasArg(options::OPT_nodefaultlibs)) {
@@ -7746,6 +7947,8 @@
 
   addProfileRT(getToolChain(), Args, CmdArgs);
 
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
+
   const char *Exec = Args.MakeArgString(getToolChain().GetLinkerPath());
   C.addCommand(new Command(JA, *this, Exec, CmdArgs));
 }
@@ -7819,6 +8022,8 @@
     else
       Input.getInputArg().renderAsInput(Args, CmdArgs);
 
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
+
   const char *Exec =
     Args.MakeArgString(getToolChain().GetProgramPath("link.exe"));
   C.addCommand(new Command(JA, *this, Exec, CmdArgs));
@@ -8005,8 +8210,126 @@
   if (EH.ShouldUseExceptionTables)
     CmdArgs.push_back("-fexceptions");
 
-  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs);
+  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,
+      JA.getOffloadingDevice());
+
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
 
   const char *Exec = Args.MakeArgString(getToolChain().GetProgramPath("xcc"));
   C.addCommand(new Command(JA, *this, Exec, CmdArgs));
 }
+
+/// NVPTX Tools
+// We pass assemble and link construction to the ptxas and
+// nvlink tools, respectively.
+// FIXME: get the exact cpu we are assembling to nad include it
+// as part of the arguments
+
+void NVPTX::Assemble::ConstructJob(Compilation &C, const JobAction &JA,
+                                       const InputInfo &Output,
+                                       const InputInfoList &Inputs,
+                                       const ArgList &Args,
+                                       const char *LinkingOutput) const {
+  ArgStringList CmdArgs;
+
+  if (Args.hasArg(options::OPT_v))
+    CmdArgs.push_back("-v");
+
+  CmdArgs.push_back("-o");
+  CmdArgs.push_back(Output.getFilename());
+
+  CmdArgs.push_back("-c");
+
+  std::string CPU = getCPUName(Args, getToolChain().getTriple(),
+      JA.getOffloadingDevice());
+
+  if (!CPU.empty()) {
+    CmdArgs.push_back("-arch");
+    CmdArgs.push_back(Args.MakeArgString(CPU));
+  }
+
+  for (InputInfoList::const_iterator
+       it = Inputs.begin(), ie = Inputs.end(); it != ie; ++it) {
+    const InputInfo &II = *it;
+    CmdArgs.push_back(II.getFilename());
+  }
+
+  const char *Exec =
+    Args.MakeArgString(getToolChain().GetProgramPath("ptxas"));
+  C.addCommand(new Command(JA, *this, Exec, CmdArgs));
+}
+
+void NVPTX::Link::ConstructJob(Compilation &C, const JobAction &JA,
+                                   const InputInfo &Output,
+                                   const InputInfoList &Inputs,
+                                   const ArgList &Args,
+                                   const char *LinkingOutput) const {
+  ArgStringList CmdArgs;
+
+  if (Output.isFilename()) {
+    CmdArgs.push_back("-o");
+    CmdArgs.push_back(Output.getFilename());
+  } else {
+    assert(Output.isNothing() && "Invalid output.");
+  }
+
+  if (Args.hasArg(options::OPT_v))
+    CmdArgs.push_back("-v");
+
+  std::string CPU = getCPUName(Args, getToolChain().getTriple(),
+      JA.getOffloadingDevice());
+
+  if (!CPU.empty()) {
+    CmdArgs.push_back("-arch");
+    CmdArgs.push_back(Args.MakeArgString(CPU));
+  }
+
+  // nvlink relies on the extension used by the input files
+  // to decide what to do. Given that ptxas produces cubin files
+  // we need to copy the input files to a new file with the right
+  // extension.
+  // FIXME: this can be efficiently done by specifying a new
+  // output type for the assembly action, however this would expose
+  // the target details to the driver and maybe we do not want to do
+  // that
+  for (const auto &II : Inputs) {
+
+    if (II.getType() == types::TY_LLVM_IR ||
+        II.getType() == types::TY_LTO_IR ||
+        II.getType() == types::TY_LLVM_BC ||
+        II.getType() == types::TY_LTO_BC){
+      C.getDriver().Diag(diag::err_drv_no_linker_llvm_support)
+        << getToolChain().getTripleString();
+      continue;
+    }
+
+    // Currently, we only pass the input files to the linker, we do not pass
+    // any libraries that may be valid only for the host.
+    if (!II.isFilename())
+      continue;
+
+    StringRef Name = llvm::sys::path::filename(II.getFilename());
+    std::pair<StringRef, StringRef> Split = Name.rsplit('.');
+    std::string TmpName = C.getDriver().GetTemporaryPath(Split.first,"cubin");
+
+    const char *CubinF = C.addTempFile(C.getArgs().MakeArgString(TmpName.c_str()));
+
+    const char *CopyExec =
+        Args.MakeArgString(getToolChain().GetProgramPath(
+            C.getDriver().IsCLMode() ? "copy" : "cp" ));
+
+    ArgStringList CopyCmdArgs;
+    CopyCmdArgs.push_back(II.getFilename());
+    CopyCmdArgs.push_back(CubinF);
+    C.addCommand(new Command(JA, *this, CopyExec, CopyCmdArgs));
+
+    CmdArgs.push_back(CubinF);
+  }
+
+  AddOpenMPLinkerScript(getToolChain(), C, JA, Output, Inputs, Args, CmdArgs);
+
+  const char *Exec =
+    Args.MakeArgString(getToolChain().GetProgramPath("nvlink"));
+  C.addCommand(new Command(JA, *this, Exec, CmdArgs));
+
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Driver/Tools.h cfe-3.5.0.src.omp/lib/Driver/Tools.h
--- cfe-3.5.0.src/lib/Driver/Tools.h	2014-07-16 08:29:22.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Driver/Tools.h	2014-11-28 10:49:29.000000000 -0500
@@ -221,7 +221,8 @@
                         const llvm::Triple &Triple, StringRef &CPUName,
                         StringRef &ABIName);
   bool hasMipsAbiArg(const llvm::opt::ArgList &Args, const char *Value);
-  bool isNaN2008(const llvm::opt::ArgList &Args, const llvm::Triple &Triple);
+  bool isNaN2008(const llvm::opt::ArgList &Args, const llvm::Triple &Triple,
+                 bool isOpenMPTarget);
   bool isFPXXDefault(const llvm::Triple &Triple, StringRef CPUName,
                      StringRef ABIName);
 }
@@ -646,6 +647,36 @@
   };
 } // end namespace XCore.
 
+namespace NVPTX {
+  // For NVPTX, we do not need to instantiate tools for PreProcess, PreCompile and Compile.
+  // We simply use "clang -cc1" for those actions.
+  class LLVM_LIBRARY_VISIBILITY Assemble : public Tool {
+  public:
+    Assemble(const ToolChain &TC) : Tool("NVPTX::Assemble",
+      "ptxas", TC) {}
+
+    virtual bool hasIntegratedCPP() const { return false; }
+    virtual void ConstructJob(Compilation &C, const JobAction &JA,
+                              const InputInfo &Output,
+                              const InputInfoList &Inputs,
+                              const llvm::opt::ArgList &TCArgs,
+                              const char *LinkingOutput) const;
+  };
+
+  class LLVM_LIBRARY_VISIBILITY Link : public Tool {
+  public:
+    Link(const ToolChain &TC) : Tool("NVPTX::Link",
+      "nvlink", TC) {}
+
+    virtual bool hasIntegratedCPP() const { return false; }
+    virtual bool isLinkJob() const { return true; }
+    virtual void ConstructJob(Compilation &C, const JobAction &JA,
+                              const InputInfo &Output,
+                              const InputInfoList &Inputs,
+                              const llvm::opt::ArgList &TCArgs,
+                              const char *LinkingOutput) const;
+  };
+} // end namespace NVPTX.
 
 } // end namespace toolchains
 } // end namespace driver
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Frontend/ASTConsumers.cpp cfe-3.5.0.src.omp/lib/Frontend/ASTConsumers.cpp
--- cfe-3.5.0.src/lib/Frontend/ASTConsumers.cpp	2014-07-17 18:34:12.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Frontend/ASTConsumers.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -469,12 +469,17 @@
       Out << "<omp threadprivate> " << '"' << I << "\"\n";
       break;
     }
+    case Decl::OMPDeclareSimd: {
+      Out << "<omp declare simd> " << '"' << I << "\"\n";
+      break;
+    }
     default:
       Out << "DeclKind: " << DK << '"' << I << "\"\n";
       llvm_unreachable("decl unhandled");
     }
   }
 }
+
 ASTConsumer *clang::CreateDeclContextPrinter() {
   return new DeclContextPrinter();
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Frontend/CompilerInvocation.cpp cfe-3.5.0.src.omp/lib/Frontend/CompilerInvocation.cpp
--- cfe-3.5.0.src/lib/Frontend/CompilerInvocation.cpp	2014-08-07 00:51:51.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Frontend/CompilerInvocation.cpp	2014-11-28 10:49:29.000000000 -0500
@@ -31,6 +31,7 @@
 #include "llvm/Support/CodeGen.h"
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/FileSystem.h"
+#include "llvm/Support/Format.h"
 #include "llvm/Support/Host.h"
 #include "llvm/Support/Path.h"
 #include "llvm/Support/Process.h"
@@ -1534,10 +1535,48 @@
   }
 
   // Check if -fopenmp= is specified.
-  if (const Arg *A = Args.getLastArg(options::OPT_fopenmp_EQ)) {
-    Opts.OpenMP = llvm::StringSwitch<bool>(A->getValue())
-        .Case("libiomp5", true)
-        .Default(false);
+  //if (const Arg *A = Args.getLastArg(options::OPT_fopenmp_EQ)) {
+  //  Opts.OpenMP = llvm::StringSwitch<bool>(A->getValue())
+  //      .Case("libiomp5", true)
+  //      .Default(false);
+  //}
+  Opts.OpenMP = Args.hasArg(OPT_fopenmp);
+  Opts.OpenMPTargetMode = Args.hasArg(OPT_omp_target_mode);
+
+  // Get the OpenMP target triples if any
+  if ( Arg *A = Args.getLastArg(options::OPT_omptargets_EQ) ){
+
+    for (unsigned i=0; i < A->getNumValues(); ++i){
+      llvm::Triple TT(A->getValue(i));
+
+      if (TT.getArch() == llvm::Triple::UnknownArch)
+        Diags.Report(clang::diag::err_drv_invalid_omp_target) << A->getValue(i);
+      else
+        Opts.OMPTargetTriples.push_back(TT);
+    }
+  }
+
+  // Make sure that we have a module ID if we need to generate code for a target
+  if (Opts.OpenMP && (Opts.OpenMPTargetMode || Opts.OMPTargetTriples.size())){
+
+    // Obtain the main file path that is being used to generate target code
+    if ( Arg *A = Args.getLastArg(options::OPT_omp_main_file_path) ){
+      llvm::sys::fs::UniqueID ModuleID;
+      std::error_code err = llvm::sys::fs::getUniqueID(Twine(A->getValue()),
+                                                       ModuleID);
+      if ( err )
+        Diags.Report(clang::diag::err_drv_omp_module_id_required)
+          << A->getValue();
+      else {
+        Opts.OMPModuleUniqueID.clear();
+        llvm::raw_string_ostream OS(Opts.OMPModuleUniqueID);
+        OS << llvm::format("%llx",ModuleID.getFile())
+            << "_" << llvm::format("%llx",ModuleID.getDevice());
+        OS.flush();
+      }
+    }
+    else
+      Diags.Report(clang::diag::err_drv_omp_target_requires_main_file_path);
   }
 
   // Record whether the __DEPRECATED define was requested.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Frontend/Rewrite/InclusionRewriter.cpp cfe-3.5.0.src.omp/lib/Frontend/Rewrite/InclusionRewriter.cpp
--- cfe-3.5.0.src/lib/Frontend/Rewrite/InclusionRewriter.cpp	2014-07-16 12:48:33.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Frontend/Rewrite/InclusionRewriter.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -372,6 +372,11 @@
   assert(SM.getLineNumber(FileId, NextToWrite) == 1);
   int Line = 1; // The current input file line number.
 
+  // Ignore UTF-8 BOM, otherwise it'd end up somewhere else than the start
+  // of the resulting file.
+  if (FromFile.getBuffer().startswith("\xEF\xBB\xBF"))
+    NextToWrite = 3;
+
   Token RawToken;
   RawLex.LexFromRawLexer(RawToken);
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Lex/PPDirectives.cpp cfe-3.5.0.src.omp/lib/Lex/PPDirectives.cpp
--- cfe-3.5.0.src/lib/Lex/PPDirectives.cpp	2014-06-26 00:58:39.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Lex/PPDirectives.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -2043,8 +2043,6 @@
         // confused.
         if (getLangOpts().AsmPreprocessor && Tok.isNot(tok::eod)) {
           LastTok.setKind(tok::unknown);
-          MI->AddTokenToBody(LastTok);
-          continue;
         } else {
           Diag(Tok, diag::err_pp_stringize_not_parameter);
           ReleaseMacroInfo(MI);
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Parse/ParseDeclCXX.cpp cfe-3.5.0.src.omp/lib/Parse/ParseDeclCXX.cpp
--- cfe-3.5.0.src/lib/Parse/ParseDeclCXX.cpp	2014-07-16 01:16:52.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Parse/ParseDeclCXX.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -2647,7 +2647,10 @@
       }
 
       if (Tok.is(tok::annot_pragma_openmp)) {
-        ParseOpenMPDeclarativeDirective();
+        if (TagDecl)
+          LateParseOpenMPDeclarativeDirective(CurAS);
+        else
+          ParseOpenMPDeclarativeDirective(CurAS);
         continue;
       }
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Parse/ParseExpr.cpp cfe-3.5.0.src.omp/lib/Parse/ParseExpr.cpp
--- cfe-3.5.0.src/lib/Parse/ParseExpr.cpp	2014-07-14 20:11:48.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Parse/ParseExpr.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -1250,11 +1250,39 @@
       T.consumeOpen();
       Loc = T.getOpenLocation();
       ExprResult Idx;
+
+      ExprResult CEANLength;
+      bool IsCEAN = false;
+      SourceLocation ColonLoc;
       if (getLangOpts().CPlusPlus11 && Tok.is(tok::l_brace)) {
         Diag(Tok, diag::warn_cxx98_compat_generalized_initializer_lists);
         Idx = ParseBraceInitializer();
+      } else if (IsCEANAllowed && Tok.is(tok::colon)) {
+        // '[' ':'
+        IsCEAN = true;
+        ColonLoc = ConsumeToken();
+        ColonProtectionRAIIObject CPRAII(*this);
+        if (Tok.isNot(tok::r_square)) {
+          CEANLength = ParseExpression();
+        }
+      } else if (IsCEANAllowed) {
+        ColonProtectionRAIIObject CPRAII(*this);
+        Idx = ParseExpression();
+        if (IsCEANAllowed && Tok.is(tok::colon)) {
+          // '[' <expr> ':'
+          IsCEAN = true;
+          ColonLoc = ConsumeToken();
+          // <length>
+          if (Tok.isNot(tok::colon) && Tok.isNot(tok::r_square)) {
+            CEANLength = ParseExpression();
+          }
+        }
       } else
         Idx = ParseExpression();
+      if (IsCEAN && !Idx.isInvalid() && !CEANLength.isInvalid()) {
+          Idx = Actions.ActOnCEANIndexExpr(getCurScope(), LHS.get(), Idx.get(),
+                                           ColonLoc, CEANLength.get());
+      }
 
       SourceLocation RLoc = Tok.getLocation();
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Parse/ParseOpenMP.cpp cfe-3.5.0.src.omp/lib/Parse/ParseOpenMP.cpp
--- cfe-3.5.0.src/lib/Parse/ParseOpenMP.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Parse/ParseOpenMP.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -11,7 +11,6 @@
 ///
 //===----------------------------------------------------------------------===//
 
-#include "RAIIObjectsForParser.h"
 #include "clang/AST/ASTConsumer.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/StmtOpenMP.h"
@@ -19,144 +18,727 @@
 #include "clang/Parse/Parser.h"
 #include "clang/Sema/Scope.h"
 #include "llvm/ADT/PointerIntPair.h"
+#include "RAIIObjectsForParser.h"
 using namespace clang;
 
-//===----------------------------------------------------------------------===//
-// OpenMP declarative directives.
-//===----------------------------------------------------------------------===//
+OpenMPDirectiveKind Parser::ParseOpenMPDirective() {
+  OpenMPDirectiveKind DKind = Tok.isAnnotation()
+                                  ? OMPD_unknown
+                                  : getOpenMPDirectiveKind(PP.getSpelling(Tok));
 
-static OpenMPDirectiveKind ParseOpenMPDirectiveKind(Parser &P) {
-  auto Tok = P.getCurToken();
-  auto DKind =
-      Tok.isAnnotation()
-          ? OMPD_unknown
-          : getOpenMPDirectiveKind(P.getPreprocessor().getSpelling(Tok));
-  if (DKind == OMPD_parallel) {
-    Tok = P.getPreprocessor().LookAhead(0);
-    auto SDKind =
-        Tok.isAnnotation()
-            ? OMPD_unknown
-            : getOpenMPDirectiveKind(P.getPreprocessor().getSpelling(Tok));
-    if (SDKind == OMPD_for) {
-      P.ConsumeToken();
-      DKind = OMPD_parallel_for;
-    } else if (SDKind == OMPD_sections) {
-      P.ConsumeToken();
-      DKind = OMPD_parallel_sections;
+  switch (DKind) {
+  case OMPD_declare: {
+    Token SavedToken = PP.LookAhead(0);
+    if (!SavedToken.isAnnotation()) {
+      StringRef Spelling = PP.getSpelling(SavedToken);
+      if (Spelling == "reduction") {
+        DKind = OMPD_declare_reduction;
+        ConsumeAnyToken();
+      } else if (Spelling == "simd") {
+        DKind = OMPD_declare_simd;
+        ConsumeToken();
+      } else if (Spelling == "target") {
+        DKind = OMPD_declare_target;
+        ConsumeToken();
+      }
+    }
+    break;
+  }
+  case OMPD_for: {
+    // This is to get correct directive name in the error message below.
+    // This whole switch actually should be extracted into a helper routine
+    // and reused in ParseOpenMPDeclarativeOrExecutableDirective below.
+    Token SavedToken = PP.LookAhead(0);
+    if (!SavedToken.isAnnotation()) {
+      OpenMPDirectiveKind SDKind =
+          getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+      if (SDKind == OMPD_simd) {
+        DKind = OMPD_for_simd;
+        ConsumeAnyToken();
+      }
+    }
+    break;
+  }
+  case OMPD_distribute: {
+    // This is to get correct directive name in the error message below.
+    // This whole switch actually should be extracted into a helper routine
+    // and reused in ParseOpenMPDeclarativeOrExecutableDirective below.
+    Token SavedToken = PP.LookAhead(0);
+    if (!SavedToken.isAnnotation()) {
+      OpenMPDirectiveKind SDKind =
+          getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+      if (SDKind == OMPD_simd) {
+        DKind = OMPD_distribute_simd;
+        ConsumeAnyToken();
+      } else if (SDKind == OMPD_parallel) {
+        SavedToken = PP.LookAhead(1);
+        if (!SavedToken.isAnnotation()) {
+          OpenMPDirectiveKind SDKind =
+              getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+          if (SDKind == OMPD_for) {
+            DKind = OMPD_distribute_parallel_for;
+            ConsumeAnyToken();
+            ConsumeAnyToken();
+            SavedToken = PP.LookAhead(0);
+            if (!SavedToken.isAnnotation()) {
+              OpenMPDirectiveKind SDKind =
+                  getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+              if (SDKind == OMPD_simd) {
+                DKind = OMPD_distribute_parallel_for_simd;
+                ConsumeAnyToken();
+              }
+            }
+          }
+        }
+      }
+    }
+    break;
+  }
+  case OMPD_parallel: {
+    // This is to get correct directive name in the error message below.
+    // This whole switch actually should be extracted into a helper routine
+    // and reused in ParseOpenMPDeclarativeOrExecutableDirective below.
+    Token SavedToken = PP.LookAhead(0);
+    if (!SavedToken.isAnnotation()) {
+      OpenMPDirectiveKind SDKind =
+          getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+      if (SDKind == OMPD_for) {
+        DKind = OMPD_parallel_for;
+        ConsumeAnyToken();
+        SavedToken = PP.LookAhead(0);
+        if (!SavedToken.isAnnotation()) {
+          OpenMPDirectiveKind SDKind =
+              getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+          if (SDKind == OMPD_simd) {
+            DKind = OMPD_parallel_for_simd;
+            ConsumeAnyToken();
+          }
+        }
+      } else if (SDKind == OMPD_sections) {
+        DKind = OMPD_parallel_sections;
+        ConsumeAnyToken();
+      }
+    }
+    break;
+  }
+  case OMPD_target: {
+    Token SavedToken = PP.LookAhead(0);
+    if (!SavedToken.isAnnotation()) {
+      StringRef Spelling = PP.getSpelling(SavedToken);
+      if (Spelling == "data") {
+        DKind = OMPD_target_data;
+        ConsumeAnyToken();
+      } else if (Spelling == "update") {
+        DKind = OMPD_target_update;
+        ConsumeAnyToken();
+      } else if (Spelling == "teams") {
+        DKind = OMPD_target_teams;
+        ConsumeAnyToken();
+        Token SavedToken = PP.LookAhead(0);
+        if (!SavedToken.isAnnotation()) {
+          OpenMPDirectiveKind SDKind =
+              getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+          if (SDKind == OMPD_distribute) {
+            DKind = OMPD_target_teams_distribute;
+            ConsumeAnyToken();
+            Token SavedToken = PP.LookAhead(0);
+            if (!SavedToken.isAnnotation()) {
+              OpenMPDirectiveKind SDKind =
+                  getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+              if (SDKind == OMPD_simd) {
+                DKind = OMPD_target_teams_distribute_simd;
+                ConsumeAnyToken();
+              } else if (SDKind == OMPD_parallel) {
+                SavedToken = PP.LookAhead(1);
+                if (!SavedToken.isAnnotation()) {
+                  OpenMPDirectiveKind SDKind =
+                      getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+                  if (SDKind == OMPD_for) {
+                    DKind = OMPD_target_teams_distribute_parallel_for;
+                    ConsumeAnyToken();
+                    ConsumeAnyToken();
+                    SavedToken = PP.LookAhead(0);
+                    if (!SavedToken.isAnnotation()) {
+                      OpenMPDirectiveKind SDKind =
+                          getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+                      if (SDKind == OMPD_simd) {
+                        DKind = OMPD_target_teams_distribute_parallel_for_simd;
+                        ConsumeAnyToken();
+                      }
+                    }
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+    break;
+  }
+  case OMPD_teams: {
+    // This is to get correct directive name in the error message below.
+    // This whole switch actually should be extracted into a helper routine
+    // and reused in ParseOpenMPDeclarativeOrExecutableDirective below.
+    Token SavedToken = PP.LookAhead(0);
+    if (!SavedToken.isAnnotation()) {
+      OpenMPDirectiveKind SDKind =
+          getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+      if (SDKind == OMPD_distribute) {
+        DKind = OMPD_teams_distribute;
+        ConsumeAnyToken();
+        Token SavedToken = PP.LookAhead(0);
+        if (!SavedToken.isAnnotation()) {
+          OpenMPDirectiveKind SDKind =
+              getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+          if (SDKind == OMPD_simd) {
+            DKind = OMPD_teams_distribute_simd;
+            ConsumeAnyToken();
+          } else if (SDKind == OMPD_parallel) {
+            SavedToken = PP.LookAhead(1);
+            if (!SavedToken.isAnnotation()) {
+              OpenMPDirectiveKind SDKind =
+                  getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+              if (SDKind == OMPD_for) {
+                DKind = OMPD_teams_distribute_parallel_for;
+                ConsumeAnyToken();
+                ConsumeAnyToken();
+                SavedToken = PP.LookAhead(0);
+                if (!SavedToken.isAnnotation()) {
+                  OpenMPDirectiveKind SDKind =
+                      getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+                  if (SDKind == OMPD_simd) {
+                    DKind = OMPD_teams_distribute_parallel_for_simd;
+                    ConsumeAnyToken();
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+    break;
+  }
+  default:
+    if (!Tok.isAnnotation()) {
+      StringRef Spelling = PP.getSpelling(Tok);
+      if (Spelling == "end") {
+        Token SavedToken = PP.LookAhead(0);
+        if (!SavedToken.isAnnotation()) {
+          OpenMPDirectiveKind SDKind =
+              getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+          if (SDKind == OMPD_declare) {
+            Token SavedToken = PP.LookAhead(1);
+            if (!SavedToken.isAnnotation()) {
+              OpenMPDirectiveKind SDKind =
+                  getOpenMPDirectiveKind(PP.getSpelling(SavedToken));
+              if (SDKind == OMPD_target) {
+                DKind = OMPD_end_declare_target;
+                ConsumeAnyToken();
+                ConsumeAnyToken();
+              }
+            }
+          }
+        }
+      } else if (Spelling == "cancellation") {
+        Token SavedToken = PP.LookAhead(0);
+        if (!SavedToken.isAnnotation()) {
+          Spelling = PP.getSpelling(SavedToken);
+          if (Spelling == "point") {
+            DKind = OMPD_cancellation_point;
+            ConsumeToken();
+          }
+        }
+      }
     }
+    break;
   }
   return DKind;
 }
 
+//===----------------------------------------------------------------------===//
+// OpenMP declarative directives.
+//===----------------------------------------------------------------------===//
+
 /// \brief Parsing of declarative OpenMP directives.
 ///
 ///       threadprivate-directive:
 ///         annot_pragma_openmp 'threadprivate' simple-variable-list
+///         annot_pragma_openmp_end
 ///
-Parser::DeclGroupPtrTy Parser::ParseOpenMPDeclarativeDirective() {
+Parser::DeclGroupPtrTy
+Parser::ParseOpenMPDeclarativeDirective(AccessSpecifier AS) {
   assert(Tok.is(tok::annot_pragma_openmp) && "Not an OpenMP directive!");
   ParenBraceBracketBalancer BalancerRAIIObj(*this);
 
-  SourceLocation Loc = ConsumeToken();
-  SmallVector<Expr *, 5> Identifiers;
-  auto DKind = ParseOpenMPDirectiveKind(*this);
+  SourceLocation Loc = ConsumeAnyToken();
+  SmallVector<Expr *, 4> Identifiers;
+  OpenMPDirectiveKind DKind = ParseOpenMPDirective();
 
   switch (DKind) {
   case OMPD_threadprivate:
-    ConsumeToken();
+    ConsumeAnyToken();
     if (!ParseOpenMPSimpleVarList(OMPD_threadprivate, Identifiers, true)) {
       // The last seen token is annot_pragma_openmp_end - need to check for
       // extra tokens.
       if (Tok.isNot(tok::annot_pragma_openmp_end)) {
         Diag(Tok, diag::warn_omp_extra_tokens_at_eol)
             << getOpenMPDirectiveName(OMPD_threadprivate);
-        SkipUntil(tok::annot_pragma_openmp_end, StopBeforeMatch);
+        while (!SkipUntil(tok::annot_pragma_openmp_end, StopBeforeMatch))
+          ;
       }
       // Skip the last annot_pragma_openmp_end.
-      ConsumeToken();
+      ConsumeAnyToken();
       return Actions.ActOnOpenMPThreadprivateDirective(Loc, Identifiers);
     }
     break;
+  case OMPD_declare_target: {
+    SourceLocation DTLoc = ConsumeAnyToken();
+    if (Tok.isNot(tok::annot_pragma_openmp_end)) {
+      Diag(Tok, diag::warn_omp_extra_tokens_at_eol)
+          << getOpenMPDirectiveName(OMPD_declare_target);
+      while (!SkipUntil(tok::annot_pragma_openmp_end, StopBeforeMatch))
+        ;
+    }
+    // Skip the last annot_pragma_openmp_end.
+    ConsumeAnyToken();
+
+    ParseScope OMPDeclareTargetScope(this, Scope::DeclScope);
+    if (!Actions.ActOnStartOpenMPDeclareTargetDirective(getCurScope(), DTLoc))
+      return DeclGroupPtrTy();
+
+    DKind = ParseOpenMPDirective();
+    while (DKind != OMPD_end_declare_target && DKind != OMPD_declare_target &&
+           Tok.isNot(tok::eof)) {
+      ParsedAttributesWithRange attrs(AttrFactory);
+      MaybeParseCXX11Attributes(attrs);
+      MaybeParseMicrosoftAttributes(attrs);
+      Actions.ActOnOpenMPDeclareTargetDecls(ParseExternalDeclaration(attrs));
+      if (Tok.isAnnotation() && Tok.is(tok::annot_pragma_openmp)) {
+        TentativeParsingAction TPA(*this);
+        ConsumeToken();
+        DKind = ParseOpenMPDirective();
+        if (DKind != OMPD_end_declare_target) {
+          TPA.Revert();
+        } else {
+          TPA.Commit();
+        }
+      }
+    }
+    if (DKind == OMPD_end_declare_target) {
+      // Skip the last annot_pragma_openmp_end.
+      ConsumeAnyToken();
+      if (Tok.isNot(tok::annot_pragma_openmp_end)) {
+        Diag(Tok, diag::warn_omp_extra_tokens_at_eol)
+            << getOpenMPDirectiveName(OMPD_end_declare_target);
+        while (!SkipUntil(tok::annot_pragma_openmp_end, StopBeforeMatch))
+          ;
+      }
+      // Skip the last annot_pragma_openmp_end.
+      ConsumeAnyToken();
+      return Actions.ActOnFinishOpenMPDeclareTargetDirective();
+    }
+    Actions.ActOnOpenMPDeclareTargetDirectiveError();
+    Diag(Tok, diag::err_expected_end_declare_target);
+    Diag(DTLoc, diag::note_matching) << "'#pragma omp declare target'";
+    return DeclGroupPtrTy();
+  }
+  case OMPD_declare_simd: {
+    // The syntax is:
+    // #pragma omp declare simd
+    // [ #pragma omp declare simd
+    // ... ]
+    // <function-declaration-or-definition>
+    //
+    SmallVector<OmpDeclareSimdVariantInfo, 4> TI; // tempopary varlists.
+    SmallVector<SourceRange, 4> SrcRanges;        // directives' source ranges.
+    SmallVector<unsigned, 4> BeginIdx;            // first clause index in CL.
+    SmallVector<unsigned, 4> EndIdx;              // end of clauses index in CL.
+    SmallVector<OMPClause *, 4> CL;               // all the clauses.
+
+    for (;;) {
+      unsigned CurBegin = CL.size();
+      SmallVector<llvm::PointerIntPair<OMPClause *, 1, bool>, 4> FirstClauses(
+          NUM_OPENMP_CLAUSES);
+      if (Tok.isNot(tok::annot_pragma_openmp_end))
+        ConsumeAnyToken();
+
+      // Read the clauses of the current simd variant.
+      while (Tok.isNot(tok::annot_pragma_openmp_end)) {
+        OpenMPClauseKind CKind = Tok.isAnnotation()
+                                     ? OMPC_unknown
+                                     : getOpenMPClauseKind(PP.getSpelling(Tok));
+        if (CKind == OMPC_uniform || CKind == OMPC_aligned ||
+            CKind == OMPC_linear) {
+          TI.push_back(OmpDeclareSimdVariantInfo(CKind, -1));
+          bool HadError = ParseOpenMPDeclarativeVarListClause(
+              DKind, CKind, TI.back().NameInfos, // Parsed VarNames.
+              TI.back().StartLoc,                // Source loc start.
+              TI.back().EndLoc,                  // Source loc end.
+              TI.back().TailExpr,                // The expr after ':'
+              TI.back().TailLoc); // Source location of the tail expr.
+          if (!HadError) {
+            TI.back().Idx = CL.size();
+            CL.push_back(0);
+          } else {
+            TI.pop_back(); // Revert due to error.
+          }
+        } else {
+          OMPClause *Clause =
+              ParseOpenMPClause(DKind, CKind, !FirstClauses[CKind].getInt());
+          FirstClauses[CKind].setInt(true);
+          if (Clause) {
+            FirstClauses[CKind].setPointer(Clause);
+            CL.push_back(Clause);
+          }
+        }
+
+        // Skip ',' if any.
+        if (Tok.is(tok::comma))
+          ConsumeToken();
+      }
+
+      // Here we are at the end of current simd variant.
+      if (Tok.isNot(tok::annot_pragma_openmp_end)) {
+        Diag(Tok, diag::warn_omp_extra_tokens_at_eol)
+            << getOpenMPDirectiveName(OMPD_declare_simd);
+        while (!SkipUntil(tok::annot_pragma_openmp_end, StopBeforeMatch))
+          ;
+      }
+      // Skip the last annot_pragma_openmp_end.
+      ConsumeToken();
+
+      // Save the current simd variant's info.
+      {
+        SrcRanges.push_back(SourceRange());
+        BeginIdx.push_back(CurBegin);
+        EndIdx.push_back(CL.size());
+      }
+
+      // Check if we have more variants here.
+      // If not -- go ahead with parsing the function declaration.
+      if (!Tok.is(tok::annot_pragma_openmp))
+        break;
+      ConsumeToken(); // eat the annotation token
+      if (ParseOpenMPDirective() != OMPD_declare_simd) {
+        Diag(Tok, diag::warn_omp_extra_tokens_at_eol)
+            << getOpenMPDirectiveName(OMPD_declare_simd);
+        while (!SkipUntil(tok::annot_pragma_openmp_end, StopBeforeMatch))
+          ;
+        // Skip the last annot_pragma_openmp_end.
+        ConsumeToken();
+        break;
+      }
+    }
+    // Here we expect to see some function declaration.
+    // TODO What if not?
+    ParsedAttributesWithRange attrs(AttrFactory);
+    ParsingDeclSpec PDS(*this);
+    // DeclGroupPtrTy Ptr = ParseDeclarationOrFunctionDefinition(attrs);
+    DeclGroupPtrTy Ptr = ParseExternalDeclaration(attrs, &PDS);
+    if (!Ptr || !Ptr.get().isSingleDecl())
+      return Ptr;
+    Decl *FuncDecl = dyn_cast<Decl>(Ptr.get().getSingleDecl());
+    // Here we need to convert the saved name-lists to corresponding clauses.
+    // This is for 'linear', 'aligned' and 'uniform' clauses only (the
+    // rest kinds of clauses are already done in CL array).
+    for (unsigned I = 0; I < TI.size(); ++I) {
+      assert(CL[TI[I].Idx] == 0);
+      CL[TI[I].Idx] = Actions.ActOnOpenMPDeclarativeVarListClause(
+          TI[I].CKind, TI[I].NameInfos, TI[I].StartLoc, TI[I].EndLoc,
+          TI[I].TailExpr, TI[I].TailLoc, FuncDecl);
+    }
+    return Actions.ActOnOpenMPDeclareSimdDirective(Loc, FuncDecl, SrcRanges,
+                                                   BeginIdx, EndIdx, CL);
+  }
+  case OMPD_declare_reduction: {
+    SmallVector<QualType, 4> Types;
+    SmallVector<SourceRange, 4> TyRanges;
+    SmallVector<Expr *, 4> Combiners;
+    SmallVector<Expr *, 4> Inits;
+    ConsumeAnyToken();
+    if (Decl *D = ParseOpenMPDeclareReduction(Types, TyRanges, Combiners, Inits,
+                                              AS)) {
+      // The last seen token is annot_pragma_openmp_end - need to check for
+      // extra tokens.
+      if (Tok.isNot(tok::annot_pragma_openmp_end)) {
+        Diag(Tok, diag::warn_omp_extra_tokens_at_eol)
+            << getOpenMPDirectiveName(OMPD_declare_reduction);
+        while (!SkipUntil(tok::annot_pragma_openmp_end, StopBeforeMatch))
+          ;
+      }
+      // Skip the last annot_pragma_openmp_end.
+      ConsumeAnyToken();
+      return Actions.ActOnOpenMPDeclareReductionDirective(D, Types, TyRanges,
+                                                          Combiners, Inits);
+    }
+    break;
+  }
   case OMPD_unknown:
     Diag(Tok, diag::err_omp_unknown_directive);
     break;
-  case OMPD_parallel:
-  case OMPD_simd:
-  case OMPD_task:
-  case OMPD_taskyield:
-  case OMPD_barrier:
-  case OMPD_taskwait:
-  case OMPD_flush:
-  case OMPD_for:
-  case OMPD_sections:
-  case OMPD_section:
-  case OMPD_single:
-  case OMPD_master:
-  case OMPD_critical:
-  case OMPD_parallel_for:
-  case OMPD_parallel_sections:
+  default:
     Diag(Tok, diag::err_omp_unexpected_directive)
         << getOpenMPDirectiveName(DKind);
     break;
   }
-  SkipUntil(tok::annot_pragma_openmp_end);
+  while (!SkipUntil(tok::annot_pragma_openmp_end))
+    ;
   return DeclGroupPtrTy();
 }
 
+/// \brief Late parsing of declarative OpenMP directives.
+///
+///       threadprivate-directive:
+///         annot_pragma_openmp 'threadprivate' simple-variable-list
+///         annot_pragma_openmp_end
+///
+void Parser::LateParseOpenMPDeclarativeDirective(AccessSpecifier AS) {
+  assert(Tok.is(tok::annot_pragma_openmp) && "Not an OpenMP directive!");
+  LateParsedOpenMPDeclaration *Decl = new LateParsedOpenMPDeclaration(this, AS);
+  getCurrentClass().LateParsedDeclarations.push_back(Decl);
+  while (Tok.isNot(tok::annot_pragma_openmp_end) && Tok.isNot(tok::eof)) {
+    Decl->Tokens.push_back(Tok);
+    ConsumeAnyToken();
+  }
+  Decl->Tokens.push_back(Tok);
+  ConsumeAnyToken();
+
+  if (Decl->Tokens.size() > 3) {
+    Token SavedToken = Decl->Tokens[1];
+    if (!SavedToken.isAnnotation()) {
+      StringRef Spelling = PP.getSpelling(SavedToken);
+      if (Spelling == "declare") {
+        SavedToken = Decl->Tokens[2];
+        if (!SavedToken.isAnnotation()) {
+          Spelling = PP.getSpelling(SavedToken);
+          if (Spelling == "simd") {
+            if (Tok.isNot(tok::annot_pragma_openmp)) {
+              LexTemplateFunctionForLateParsing(Decl->Tokens);
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+/// \brief Actual parsing of late OpenMP declaration.
+void Parser::LateParsedOpenMPDeclaration::ParseLexedMethodDeclarations() {
+  // Save the current token position.
+  SourceLocation origLoc = Self->Tok.getLocation();
+
+  assert(!Tokens.empty() && "Empty body!");
+  // Append the current token at the end of the new token stream so that it
+  // doesn't get lost.
+  Tokens.push_back(Self->Tok);
+  Self->PP.EnterTokenStream(Tokens.data(), Tokens.size(), true, false);
+
+  // Consume the previously pushed token.
+  Self->ConsumeAnyToken(/*ConsumeCodeCompletionTok=*/true);
+
+  Self->ParseOpenMPDeclarativeDirective(this->AS);
+
+  if (Self->Tok.getLocation() != origLoc) {
+    // Due to parsing error, we either went over the cached tokens or
+    // there are still cached tokens left. If it's the latter case skip the
+    // leftover tokens.
+    // Since this is an uncommon situation that should be avoided, use the
+    // expensive isBeforeInTranslationUnit call.
+    if (Self->PP.getSourceManager().isBeforeInTranslationUnit(
+            Self->Tok.getLocation(), origLoc))
+      while (Self->Tok.getLocation() != origLoc && Self->Tok.isNot(tok::eof))
+        Self->ConsumeAnyToken();
+  }
+}
+
 /// \brief Parsing of declarative or executable OpenMP directives.
 ///
 ///       threadprivate-directive:
 ///         annot_pragma_openmp 'threadprivate' simple-variable-list
 ///         annot_pragma_openmp_end
 ///
-///       executable-directive:
-///         annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |
-///         'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |
-///         'parallel for' | 'parallel sections' | 'task' | 'taskyield' |
-///         'barrier' | 'taskwait' | 'flush' {clause} annot_pragma_openmp_end
+///       parallel-directive:
+///         annot_pragma_openmp 'parallel' {clause} annot_pragma_openmp_end
+///
+///       for-directive:
+///         annot_pragma_openmp 'for' {clause} annot_pragma_openmp_end
+///
+///       distribute-directive:
+///         annot_pragma_openmp 'distribute' {clause} annot_pragma_openmp_end
+///
+///       simd-directive:
+///         annot_pragma_openmp 'simd' {clause} annot_pragma_openmp_end
+///
+///       for-simd-directive:
+///         annot_pragma_openmp 'for simd' {clause} annot_pragma_openmp_end
+///
+///       distribute-simd-directive:
+///         annot_pragma_openmp 'distribute simd' {clause}
+/// annot_pragma_openmp_end
+///
+///       distribute-parallel-for-directive:
+///         annot_pragma_openmp 'distribute parallel for' {clause}
+/// annot_pragma_openmp_end
+///
+///       distribute-parallel-for-simd-directive:
+///         annot_pragma_openmp 'distribute parallel for simd' {clause}
+/// annot_pragma_openmp_end
+///
+///       teams-distribute-parallel-for-directive:
+///         annot_pragma_openmp 'teams distribute parallel for' {clause} annot_pragma_openmp_end
+///
+///       teams-distribute-parallel-for-simd-directive:
+///         annot_pragma_openmp 'teams distribute parallel for simd' {clause} annot_pragma_openmp_end
+///
+///       target-teams-distribute-parallel-for-directive:
+///         annot_pragma_openmp 'target teams distribute parallel for' {clause} annot_pragma_openmp_end
+///
+///       target-teams-distribute-parallel-for-simd-directive:
+///         annot_pragma_openmp 'target teams distribute parallel for simd' {clause} annot_pragma_openmp_end
+///
+///       sections-directive:
+///         annot_pragma_openmp 'sections' {clause} annot_pragma_openmp_end
+///
+///       section-directive:
+///         annot_pragma_openmp 'section' annot_pragma_openmp_end
+///
+///       single-directive:
+///         annot_pragma_openmp 'single' {clause} annot_pragma_openmp_end
+///
+///       task-directive:
+///         annot_pragma_openmp 'task' {clause} annot_pragma_openmp_end
+///
+///       taskyield-directive:
+///         annot_pragma_openmp 'taskyield' annot_pragma_openmp_end
+///
+///       master-directive:
+///         annot_pragma_openmp 'master' annot_pragma_openmp_end
+///
+///       critical-directive:
+///         annot_pragma_openmp 'critical' [ '(' <name> ')' ]
+///         annot_pragma_openmp_end
+///
+///       barrier-directive:
+///         annot_pragma_openmp 'barrier' annot_pragma_openmp_end
+///
+///       taskwait-directive:
+///         annot_pragma_openmp 'taskwait' annot_pragma_openmp_end
+///
+///       taskgroup-directive:
+///         annot_pragma_openmp 'taskgroup' annot_pragma_openmp_end
+///
+///       atomic-directive:
+///         annot_pragma_openmp 'atomic' [clause] [clause]
+///         annot_pragma_openmp_end
+///
+///       flush-directive:
+///         annot_pragma_openmp 'flush' [ '(' list ')' ]
+///         annot_pragma_openmp_end
+///
+///       ordered-directive:
+///         annot_pragma_openmp 'ordered' annot_pragma_openmp_end
+///
+///       teams-distribute-directive:
+///         annot_pragma_openmp 'teams distribute ' {clause}
+///         annot_pragma_openmp_end
+///
+///       teams-distribute-simd-directive:
+///         annot_pragma_openmp 'teams distribute simd' {clause}
+///         annot_pragma_openmp_end
+///
+///       target-teams-distribute-directive:
+///         annot_pragma_openmp 'target teams distribute ' {clause}
+///         annot_pragma_openmp_end
+///
+///       target-teams-distribute-simd-directive:
+///         annot_pragma_openmp 'target teams distribute simd' {clause}
+///         annot_pragma_openmp_end
 ///
 StmtResult
 Parser::ParseOpenMPDeclarativeOrExecutableDirective(bool StandAloneAllowed) {
   assert(Tok.is(tok::annot_pragma_openmp) && "Not an OpenMP directive!");
   ParenBraceBracketBalancer BalancerRAIIObj(*this);
-  SmallVector<Expr *, 5> Identifiers;
-  SmallVector<OMPClause *, 5> Clauses;
-  SmallVector<llvm::PointerIntPair<OMPClause *, 1, bool>, OMPC_unknown + 1>
-  FirstClauses(OMPC_unknown + 1);
-  unsigned ScopeFlags =
-      Scope::FnScope | Scope::DeclScope | Scope::OpenMPDirectiveScope;
-  SourceLocation Loc = ConsumeToken(), EndLoc;
-  auto DKind = ParseOpenMPDirectiveKind(*this);
-  // Name of critical directive.
-  DeclarationNameInfo DirName;
+  const unsigned ScopeFlags =
+      Scope::FnScope | Scope::OpenMPDirectiveScope | Scope::DeclScope;
+  SmallVector<Expr *, 4> Identifiers;
+  SmallVector<OMPClause *, 4> Clauses;
+  SmallVector<llvm::PointerIntPair<OMPClause *, 1, bool>, 4> FirstClauses(
+      NUM_OPENMP_CLAUSES);
+  SourceLocation Loc = ConsumeAnyToken(), EndLoc;
+  OpenMPDirectiveKind ConstructType = OMPD_unknown;
   StmtResult Directive = StmtError();
-  bool HasAssociatedStatement = true;
-  bool FlushHasClause = false;
+  DeclarationNameInfo DirName;
+
+  OpenMPDirectiveKind DKind = ParseOpenMPDirective();
 
   switch (DKind) {
   case OMPD_threadprivate:
-    ConsumeToken();
+    ConsumeAnyToken();
     if (!ParseOpenMPSimpleVarList(OMPD_threadprivate, Identifiers, false)) {
       // The last seen token is annot_pragma_openmp_end - need to check for
       // extra tokens.
       if (Tok.isNot(tok::annot_pragma_openmp_end)) {
         Diag(Tok, diag::warn_omp_extra_tokens_at_eol)
             << getOpenMPDirectiveName(OMPD_threadprivate);
-        SkipUntil(tok::annot_pragma_openmp_end, StopBeforeMatch);
+        while (!SkipUntil(tok::annot_pragma_openmp_end, StopBeforeMatch))
+          ;
       }
       DeclGroupPtrTy Res =
           Actions.ActOnOpenMPThreadprivateDirective(Loc, Identifiers);
       Directive = Actions.ActOnDeclStmt(Res, Loc, Tok.getLocation());
     }
-    SkipUntil(tok::annot_pragma_openmp_end);
+    while (!SkipUntil(tok::annot_pragma_openmp_end))
+      ;
+    break;
+  case OMPD_declare_reduction: {
+    SmallVector<QualType, 4> Types;
+    SmallVector<SourceRange, 4> TyRanges;
+    SmallVector<Expr *, 4> Combiners;
+    SmallVector<Expr *, 4> Inits;
+    ConsumeAnyToken();
+    if (Decl *D = ParseOpenMPDeclareReduction(Types, TyRanges, Combiners, Inits,
+                                              AS_none)) {
+      // The last seen token is annot_pragma_openmp_end - need to check for
+      // extra tokens.
+      if (Tok.isNot(tok::annot_pragma_openmp_end)) {
+        Diag(Tok, diag::warn_omp_extra_tokens_at_eol)
+            << getOpenMPDirectiveName(OMPD_declare_reduction);
+        while (!SkipUntil(tok::annot_pragma_openmp_end, StopBeforeMatch))
+          ;
+      }
+      // Skip the last annot_pragma_openmp_end.
+      DeclGroupPtrTy Res = Actions.ActOnOpenMPDeclareReductionDirective(
+          D, Types, TyRanges, Combiners, Inits);
+      Directive = Actions.ActOnDeclStmt(Res, Loc, Tok.getLocation());
+    }
+    while (!SkipUntil(tok::annot_pragma_openmp_end))
+      ;
     break;
-  case OMPD_flush:
+  }
+  case OMPD_critical:
+    // Parse name of critical if any.
     if (PP.LookAhead(0).is(tok::l_paren)) {
-      FlushHasClause = true;
-      // Push copy of the current token back to stream to properly parse
-      // pseudo-clause OMPFlushClause.
-      PP.EnterToken(Tok);
+      // Consume '('.
+      ConsumeAnyToken();
+      SourceLocation LOpen = Tok.getLocation();
+      // Parse <name>.
+      ConsumeAnyToken();
+      if (!Tok.isAnyIdentifier()) {
+        Diag(Tok, diag::err_expected_ident);
+      } else {
+        DirName =
+            DeclarationNameInfo(Tok.getIdentifierInfo(), Tok.getLocation());
+        ConsumeAnyToken();
+      }
+      // Parse ')'.
+      if (Tok.isNot(tok::r_paren)) {
+        Diag(Tok, diag::err_expected_rparen);
+        Diag(LOpen, diag::note_matching) << "'('";
+      }
     }
+    StandAloneAllowed = true;
   case OMPD_taskyield:
   case OMPD_barrier:
   case OMPD_taskwait:
@@ -164,50 +746,46 @@
       Diag(Tok, diag::err_omp_immediate_directive)
           << getOpenMPDirectiveName(DKind);
     }
-    HasAssociatedStatement = false;
-    // Fall through for further analysis.
   case OMPD_parallel:
-  case OMPD_simd:
+  case OMPD_parallel_for:
+  case OMPD_parallel_sections:
+  case OMPD_parallel_for_simd:
+  case OMPD_teams:
   case OMPD_for:
+  case OMPD_simd:
+  case OMPD_for_simd:
+  case OMPD_distribute:
+  case OMPD_distribute_simd:
+  case OMPD_distribute_parallel_for:
+  case OMPD_distribute_parallel_for_simd:
+  case OMPD_teams_distribute_parallel_for:
+  case OMPD_teams_distribute_parallel_for_simd:
+  case OMPD_target_teams_distribute_parallel_for:
+  case OMPD_target_teams_distribute_parallel_for_simd:
   case OMPD_sections:
-  case OMPD_single:
   case OMPD_section:
+  case OMPD_single:
+  case OMPD_task:
   case OMPD_master:
-  case OMPD_critical:
-  case OMPD_parallel_for:
-  case OMPD_parallel_sections:
-  case OMPD_task: {
-    ConsumeToken();
-    // Parse directive name of the 'critical' directive if any.
-    if (DKind == OMPD_critical) {
-      BalancedDelimiterTracker T(*this, tok::l_paren,
-                                 tok::annot_pragma_openmp_end);
-      if (!T.consumeOpen()) {
-        if (Tok.isAnyIdentifier()) {
-          DirName =
-              DeclarationNameInfo(Tok.getIdentifierInfo(), Tok.getLocation());
-          ConsumeAnyToken();
-        } else {
-          Diag(Tok, diag::err_omp_expected_identifier_for_critical);
-        }
-        T.consumeClose();
-      }
-    }
-
-    if (isOpenMPLoopDirective(DKind))
-      ScopeFlags |= Scope::OpenMPLoopDirectiveScope;
-    if (isOpenMPSimdDirective(DKind))
-      ScopeFlags |= Scope::OpenMPSimdDirectiveScope;
+  case OMPD_taskgroup:
+  case OMPD_atomic:
+  case OMPD_ordered:
+  case OMPD_target:
+  case OMPD_target_data:
+  case OMPD_target_teams:
+  case OMPD_teams_distribute:
+  case OMPD_teams_distribute_simd:
+  case OMPD_target_teams_distribute:
+  case OMPD_target_teams_distribute_simd: {
+    // Do not read token if the end of directive or flush directive.
+    if (Tok.isNot(tok::annot_pragma_openmp_end))
+      ConsumeAnyToken();
     ParseScope OMPDirectiveScope(this, ScopeFlags);
-    Actions.StartOpenMPDSABlock(DKind, DirName, Actions.getCurScope(), Loc);
-
+    Actions.StartOpenMPDSABlock(DKind, DirName, Actions.getCurScope());
     while (Tok.isNot(tok::annot_pragma_openmp_end)) {
-      OpenMPClauseKind CKind =
-          Tok.isAnnotation()
-              ? OMPC_unknown
-              : FlushHasClause ? OMPC_flush
-                               : getOpenMPClauseKind(PP.getSpelling(Tok));
-      FlushHasClause = false;
+      OpenMPClauseKind CKind = Tok.isAnnotation()
+                                   ? OMPC_unknown
+                                   : getOpenMPClauseKind(PP.getSpelling(Tok));
       OMPClause *Clause =
           ParseOpenMPClause(DKind, CKind, !FirstClauses[CKind].getInt());
       FirstClauses[CKind].setInt(true);
@@ -218,43 +796,144 @@
 
       // Skip ',' if any.
       if (Tok.is(tok::comma))
-        ConsumeToken();
+        ConsumeAnyToken();
     }
     // End location of the directive.
     EndLoc = Tok.getLocation();
     // Consume final annot_pragma_openmp_end.
-    ConsumeToken();
+    ConsumeAnyToken();
 
     StmtResult AssociatedStmt;
     bool CreateDirective = true;
-    if (HasAssociatedStatement) {
+    if (DKind != OMPD_taskyield && DKind != OMPD_barrier &&
+        DKind != OMPD_taskwait) {
+      // Parse statement
       // The body is a block scope like in Lambdas and Blocks.
       Sema::CompoundScopeRAII CompoundScope(Actions);
-      Actions.ActOnOpenMPRegionStart(DKind, getCurScope());
+      // Simd has two additional args -- integer index and boolean last_iter.
+      int NumArgs = (DKind == OMPD_simd || DKind == OMPD_for_simd ||
+                     DKind == OMPD_parallel_for_simd ||
+                     DKind == OMPD_distribute_parallel_for_simd ||
+                     DKind == OMPD_teams_distribute_parallel_for_simd ||
+                     DKind == OMPD_target_teams_distribute_parallel_for_simd ||
+                     DKind == OMPD_distribute_simd ||
+                     DKind == OMPD_teams_distribute_simd ||
+                     DKind == OMPD_target_teams_distribute_simd)
+                        ? 3
+                        : 1;
+      Actions.ActOnCapturedRegionStart(Loc, getCurScope(), CR_OpenMP, NumArgs);
       Actions.ActOnStartOfCompoundStmt();
-      // Parse statement
       AssociatedStmt = ParseStatement();
       Actions.ActOnFinishOfCompoundStmt();
       if (!AssociatedStmt.isUsable()) {
         Actions.ActOnCapturedRegionError();
         CreateDirective = false;
       } else {
+        Actions.MarkOpenMPClauses(Clauses);
         AssociatedStmt = Actions.ActOnCapturedRegionEnd(AssociatedStmt.get());
         CreateDirective = AssociatedStmt.isUsable();
       }
     }
-    if (CreateDirective)
+    if (CreateDirective) {
       Directive = Actions.ActOnOpenMPExecutableDirective(
-          DKind, DirName, Clauses, AssociatedStmt.get(), Loc, EndLoc);
+          DKind, DirName, Clauses, AssociatedStmt.get(), Loc, EndLoc,
+          ConstructType);
+    }
+
+    // Exit scope.
+    Actions.EndOpenMPDSABlock(Directive.get());
+    OMPDirectiveScope.Exit();
+    break;
+  }
+  case OMPD_cancel:
+  case OMPD_cancellation_point:
+  case OMPD_target_update:
+  case OMPD_flush: {
+    if (!StandAloneAllowed) {
+      Diag(Tok, diag::err_omp_immediate_directive)
+          << getOpenMPDirectiveName(DKind);
+    }
+    ParseScope OMPDirectiveScope(this, ScopeFlags);
+    Actions.StartOpenMPDSABlock(DKind, DirName, Actions.getCurScope());
+    if (DKind == OMPD_flush) {
+      if (PP.LookAhead(0).is(tok::l_paren)) {
+        // For flush directive set clause kind to pseudo flush clause.
+        OMPClause *Clause = ParseOpenMPVarListClause(OMPC_flush);
+        if (Clause)
+          Clauses.push_back(Clause);
+      } else {
+        // Consume directive name.
+        ConsumeAnyToken();
+      }
+      if (Tok.isNot(tok::annot_pragma_openmp_end))
+        ParseOpenMPClause(DKind, OMPC_unknown, true);
+    } else if (DKind == OMPD_cancel || DKind == OMPD_cancellation_point) {
+      ConsumeAnyToken();
+      ConstructType = ParseOpenMPDirective();
+      if (ConstructType != OMPD_parallel && ConstructType != OMPD_sections &&
+          ConstructType != OMPD_for && ConstructType != OMPD_taskgroup) {
+        Diag(Tok.getLocation(), diag::err_omp_expected_cancel_construct_type);
+      }
+      if (Tok.isNot(tok::annot_pragma_openmp_end)) {
+        ConsumeAnyToken();
+        // Skip ',' if any.
+        if (Tok.is(tok::comma) && DKind == OMPD_cancel)
+          ConsumeAnyToken();
+      }
+      while (Tok.isNot(tok::annot_pragma_openmp_end)) {
+        OpenMPClauseKind CKind = Tok.isAnnotation()
+                                     ? OMPC_unknown
+                                     : getOpenMPClauseKind(PP.getSpelling(Tok));
+        OMPClause *Clause =
+            ParseOpenMPClause(DKind, CKind, !FirstClauses[CKind].getInt());
+        FirstClauses[CKind].setInt(true);
+        if (Clause) {
+          FirstClauses[CKind].setPointer(Clause);
+          Clauses.push_back(Clause);
+        }
+
+        // Skip ',' if any.
+        if (Tok.is(tok::comma))
+          ConsumeAnyToken();
+      }
+    } else if (DKind == OMPD_target_update) {
+      ConsumeAnyToken();
+      while (Tok.isNot(tok::annot_pragma_openmp_end)) {
+        OpenMPClauseKind CKind = Tok.isAnnotation()
+                                     ? OMPC_unknown
+                                     : getOpenMPClauseKind(PP.getSpelling(Tok));
+        OMPClause *Clause =
+            ParseOpenMPClause(DKind, CKind, !FirstClauses[CKind].getInt());
+        FirstClauses[CKind].setInt(true);
+        if (Clause) {
+          FirstClauses[CKind].setPointer(Clause);
+          Clauses.push_back(Clause);
+        }
 
+        // Skip ',' if any.
+        if (Tok.is(tok::comma))
+          ConsumeAnyToken();
+      }
+    }
+    Directive = Actions.ActOnOpenMPExecutableDirective(
+        DKind, DirName, Clauses, 0, Loc, Tok.getLocation(), ConstructType);
     // Exit scope.
     Actions.EndOpenMPDSABlock(Directive.get());
+    // Consume final annot_pragma_openmp_end.
+    ConsumeAnyToken();
     OMPDirectiveScope.Exit();
     break;
   }
   case OMPD_unknown:
     Diag(Tok, diag::err_omp_unknown_directive);
-    SkipUntil(tok::annot_pragma_openmp_end);
+    while (!SkipUntil(tok::annot_pragma_openmp_end))
+      ;
+    break;
+  default:
+    Diag(Tok, diag::err_omp_unexpected_directive)
+        << getOpenMPDirectiveName(DKind);
+    while (!SkipUntil(tok::annot_pragma_openmp_end))
+      ;
     break;
   }
   return Directive;
@@ -264,7 +943,7 @@
 /// directive.
 ///
 ///   simple-variable-list:
-///         '(' id-expression {, id-expression} ')'
+///         '(' id-expression {',' id-expression} ')'
 ///
 bool Parser::ParseOpenMPSimpleVarList(OpenMPDirectiveKind Kind,
                                       SmallVectorImpl<Expr *> &VarList,
@@ -272,10 +951,9 @@
   VarList.clear();
   // Parse '('.
   BalancedDelimiterTracker T(*this, tok::l_paren, tok::annot_pragma_openmp_end);
-  if (T.expectAndConsume(diag::err_expected_lparen_after,
-                         getOpenMPDirectiveName(Kind)))
-    return true;
-  bool IsCorrect = true;
+  bool LParen = !T.expectAndConsume(diag::err_expected_lparen_after,
+                                    getOpenMPDirectiveName(Kind));
+  bool IsCorrect = LParen;
   bool NoIdentIsFound = true;
 
   // Read tokens while ')' or annot_pragma_openmp_end is not found.
@@ -290,21 +968,23 @@
     if (AllowScopeSpecifier && getLangOpts().CPlusPlus &&
         ParseOptionalCXXScopeSpecifier(SS, ParsedType(), false)) {
       IsCorrect = false;
-      SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_openmp_end,
-                StopBeforeMatch);
+      while (!SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_openmp_end,
+                        StopBeforeMatch))
+        ;
     } else if (ParseUnqualifiedId(SS, false, false, false, ParsedType(),
                                   TemplateKWLoc, Name)) {
       IsCorrect = false;
-      SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_openmp_end,
-                StopBeforeMatch);
+      while (!SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_openmp_end,
+                        StopBeforeMatch))
+        ;
     } else if (Tok.isNot(tok::comma) && Tok.isNot(tok::r_paren) &&
                Tok.isNot(tok::annot_pragma_openmp_end)) {
       IsCorrect = false;
-      SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_openmp_end,
-                StopBeforeMatch);
-      Diag(PrevTok.getLocation(), diag::err_expected)
-          << tok::identifier
+      Diag(PrevTok.getLocation(), diag::err_expected_ident)
           << SourceRange(PrevTok.getLocation(), PrevTokLocation);
+      while (!SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_openmp_end,
+                        StopBeforeMatch))
+        ;
     } else {
       DeclarationNameInfo NameInfo = Actions.GetNameFromUnqualifiedId(Name);
       ExprResult Res =
@@ -314,57 +994,345 @@
     }
     // Consume ','.
     if (Tok.is(tok::comma)) {
-      ConsumeToken();
+      ConsumeAnyToken();
     }
   }
 
   if (NoIdentIsFound) {
-    Diag(Tok, diag::err_expected) << tok::identifier;
+    Diag(Tok, diag::err_expected_ident);
     IsCorrect = false;
   }
 
   // Parse ')'.
-  IsCorrect = !T.consumeClose() && IsCorrect;
+  IsCorrect =
+      ((LParen || Tok.is(tok::r_paren)) && !T.consumeClose()) && IsCorrect;
 
   return !IsCorrect && VarList.empty();
 }
 
-/// \brief Parsing of OpenMP clauses.
+/// \brief Parsing of OpenMP declare reduction.
 ///
-///    clause:
-///       if-clause | final-clause | num_threads-clause | safelen-clause |
-///       default-clause | private-clause | firstprivate-clause | shared-clause
-///       | linear-clause | aligned-clause | collapse-clause |
-///       lastprivate-clause | reduction-clause | proc_bind-clause |
-///       schedule-clause | copyin-clause | copyprivate-clause | untied-clause |
-///       mergeable-clause | flush-clause
-///
-OMPClause *Parser::ParseOpenMPClause(OpenMPDirectiveKind DKind,
-                                     OpenMPClauseKind CKind, bool FirstClause) {
-  OMPClause *Clause = nullptr;
-  bool ErrorFound = false;
-  // Check if clause is allowed for the given directive.
-  if (CKind != OMPC_unknown && !isAllowedClauseForDirective(DKind, CKind)) {
-    Diag(Tok, diag::err_omp_unexpected_clause) << getOpenMPClauseName(CKind)
-                                               << getOpenMPDirectiveName(DKind);
-    ErrorFound = true;
-  }
+///    declare_reduction:
+///       '(' <identifier> ':' <typename> {',' <typename>} ':' <expr> ')'
+///       ['initializer' '(' 'omp_priv' [ '=' ] <expr> ')']
+///
+Decl *Parser::ParseOpenMPDeclareReduction(
+    SmallVectorImpl<QualType> &Types, SmallVectorImpl<SourceRange> &TyRanges,
+    SmallVectorImpl<Expr *> &Combiners, SmallVectorImpl<Expr *> &Inits,
+    AccessSpecifier AS) {
+  SourceLocation Loc = Tok.getLocation();
+  CXXScopeSpec SS;
+  SourceLocation TemplateKWLoc;
+  UnqualifiedId UI;
+  DeclarationName Name;
+  Decl *D = 0;
 
-  switch (CKind) {
-  case OMPC_if:
-  case OMPC_final:
+  // Parse '('.
+  BalancedDelimiterTracker T(*this, tok::l_paren, tok::annot_pragma_openmp_end);
+  bool LParen =
+      !T.expectAndConsume(diag::err_expected_lparen_after,
+                          getOpenMPDirectiveName(OMPD_declare_reduction));
+  bool IsCorrect = LParen;
+
+  if (!IsCorrect && Tok.is(tok::annot_pragma_openmp_end))
+    return 0;
+
+  switch (Tok.getKind()) {
+  case tok::plus: // '+'
+    Name = Actions.getASTContext().DeclarationNames.getIdentifier(
+        &Actions.Context.Idents.get("+"));
+    ConsumeAnyToken();
+    break;
+  case tok::minus: // '-'
+    Name = Actions.getASTContext().DeclarationNames.getIdentifier(
+        &Actions.Context.Idents.get("-"));
+    ConsumeAnyToken();
+    break;
+  case tok::star: // '*'
+    Name = Actions.getASTContext().DeclarationNames.getIdentifier(
+        &Actions.Context.Idents.get("*"));
+    ConsumeAnyToken();
+    break;
+  case tok::amp: // '&'
+    Name = Actions.getASTContext().DeclarationNames.getIdentifier(
+        &Actions.Context.Idents.get("&"));
+    ConsumeAnyToken();
+    break;
+  case tok::pipe: // '|'
+    Name = Actions.getASTContext().DeclarationNames.getIdentifier(
+        &Actions.Context.Idents.get("|"));
+    ConsumeAnyToken();
+    break;
+  case tok::caret: // '^'
+    Name = Actions.getASTContext().DeclarationNames.getIdentifier(
+        &Actions.Context.Idents.get("^"));
+    ConsumeAnyToken();
+    break;
+  case tok::ampamp: // '&&'
+    Name = Actions.getASTContext().DeclarationNames.getIdentifier(
+        &Actions.Context.Idents.get("&&"));
+    ConsumeAnyToken();
+    break;
+  case tok::pipepipe: // '||'
+    Name = Actions.getASTContext().DeclarationNames.getIdentifier(
+        &Actions.Context.Idents.get("||"));
+    ConsumeAnyToken();
+    break;
+  case tok::identifier: // identifier
+    Name = Actions.getASTContext().DeclarationNames.getIdentifier(
+        Tok.getIdentifierInfo());
+    ConsumeAnyToken();
+    break;
+  default:
+    IsCorrect = false;
+    Diag(Tok.getLocation(), diag::err_omp_expected_reduction_identifier);
+    while (!SkipUntil(tok::colon, tok::r_paren, tok::annot_pragma_openmp_end,
+                      StopBeforeMatch))
+      ;
+    break;
+  }
+
+  if (!IsCorrect && Tok.is(tok::annot_pragma_openmp_end))
+    return 0;
+
+  // Consume ':'.
+  if (Tok.is(tok::colon)) {
+    ConsumeAnyToken();
+  } else {
+    Diag(Tok.getLocation(), diag::err_expected_colon);
+    IsCorrect = false;
+  }
+
+  if (!IsCorrect && Tok.is(tok::annot_pragma_openmp_end))
+    return 0;
+
+  if (Tok.is(tok::colon) || Tok.is(tok::annot_pragma_openmp_end)) {
+    Diag(Tok.getLocation(), diag::err_expected_type);
+    IsCorrect = false;
+  }
+
+  if (!IsCorrect && Tok.is(tok::annot_pragma_openmp_end))
+    return 0;
+
+  bool IsCommaFound = false;
+  bool FunctionsCorrect = true;
+  while (Tok.isNot(tok::colon) && Tok.isNot(tok::annot_pragma_openmp_end)) {
+    ColonProtectionRAIIObject ColonRAII(*this);
+    IsCommaFound = false;
+    SourceRange Range;
+    TypeResult TR = ParseTypeName(&Range, Declarator::PrototypeContext);
+    if (TR.isUsable()) {
+      QualType QTy = Sema::GetTypeFromParser(TR.get());
+      if (!QTy.isNull() && Actions.IsOMPDeclareReductionTypeAllowed(
+                               Range, QTy, Types, TyRanges)) {
+        Types.push_back(QTy);
+        TyRanges.push_back(Range);
+      } else {
+        FunctionsCorrect = false;
+      }
+    } else {
+      while (!SkipUntil(tok::comma, tok::colon, tok::annot_pragma_openmp_end,
+                        StopBeforeMatch))
+        ;
+      FunctionsCorrect = false;
+    }
+
+    // Consume ','.
+    if (Tok.is(tok::comma)) {
+      ConsumeAnyToken();
+      IsCommaFound = true;
+    } else if (Tok.isNot(tok::colon) &&
+               Tok.isNot(tok::annot_pragma_openmp_end)) {
+      Diag(Tok.getLocation(), diag::err_expected_comma);
+      IsCorrect = false;
+    }
+  }
+
+  if (IsCommaFound) {
+    Diag(Tok.getLocation(), diag::err_expected_type);
+    IsCorrect = false;
+    if (Tok.is(tok::annot_pragma_openmp_end))
+      return 0;
+  }
+
+  if (Types.empty()) {
+    while (!SkipUntil(tok::annot_pragma_openmp_end, StopBeforeMatch))
+      ;
+    return 0;
+  }
+
+  if (!IsCorrect && Tok.is(tok::annot_pragma_openmp_end))
+    return 0;
+
+  // Consume ':'.
+  if (Tok.is(tok::colon)) {
+    ConsumeAnyToken();
+  } else {
+    Diag(Tok.getLocation(), diag::err_expected_colon);
+    IsCorrect = false;
+  }
+
+  if (Tok.is(tok::annot_pragma_openmp_end)) {
+    Diag(Tok.getLocation(), diag::err_expected_expression);
+    return 0;
+  }
+
+  Sema::OMPDeclareReductionRAII RAII(Actions, Actions.CurScope,
+                                     Actions.CurContext, Loc, Name,
+                                     Types.size(), AS);
+
+  ParseScope OMPDRScope(this, Scope::FnScope | Scope::DeclScope);
+
+  // Parse expression and make pseudo functions.
+  for (SmallVectorImpl<QualType>::iterator I = Types.begin(), E = Types.end();
+       I != E; ++I) {
+    TentativeParsingAction TPA(*this);
+    ParseScope FnScope(this, Scope::FnScope | Scope::DeclScope);
+    Sema::OMPDeclareReductionFunctionScope Scope(Actions, Loc, Name, *I);
+    ExprResult ER = ParseAssignmentExpression();
+    if (ER.isInvalid() && Tok.isNot(tok::r_paren) &&
+        Tok.isNot(tok::annot_pragma_openmp_end)) {
+      TPA.Commit();
+      IsCorrect = false;
+      break;
+    }
+    IsCorrect = IsCorrect && !ER.isInvalid();
+    Scope.setBody(ER.get());
+    Combiners.push_back(Scope.getCombiner());
+    if (I + 1 != E) {
+      TPA.Revert();
+    } else {
+      TPA.Commit();
+    }
+  }
+
+  if (!IsCorrect && Tok.is(tok::annot_pragma_openmp_end))
+    return 0;
+
+  D = RAII.getDecl();
+
+  // Parse ')'.
+  IsCorrect =
+      ((LParen || Tok.is(tok::r_paren)) && !T.consumeClose()) && IsCorrect;
+
+  if (Tok.isAnyIdentifier() && Tok.getIdentifierInfo()->isStr("initializer")) {
+    ConsumeAnyToken();
+    BalancedDelimiterTracker T(*this, tok::l_paren,
+                               tok::annot_pragma_openmp_end);
+    LParen =
+        !T.expectAndConsume(diag::err_expected_lparen_after, "initializer");
+    IsCorrect = IsCorrect && LParen;
+
+    bool IsInit = false;
+    SourceLocation OmpPrivLoc;
+    if (Tok.isAnyIdentifier() && Tok.getIdentifierInfo()->isStr("omp_priv")) {
+      IsInit = true;
+      OmpPrivLoc = ConsumeAnyToken();
+      if (!getLangOpts().CPlusPlus) {
+        // Expect '='
+        if (Tok.isNot(tok::equal)) {
+          Diag(Tok, diag::err_expected_equal_after) << "'omp_priv'";
+          IsCorrect = false;
+        } else
+          ConsumeAnyToken();
+      }
+    }
+
+    // Parse expression and make pseudo functions.
+    for (SmallVectorImpl<QualType>::iterator I = Types.begin(), E = Types.end();
+         I != E; ++I) {
+      TentativeParsingAction TPA(*this);
+      ParseScope FnScope(this, Scope::FnScope | Scope::DeclScope);
+      Sema::OMPDeclareReductionInitFunctionScope Scope(Actions, Loc, Name, *I,
+                                                       OmpPrivLoc, IsInit);
+      ExprResult ER = ParseAssignmentExpression();
+      if (ER.isInvalid() && Tok.isNot(tok::r_paren) &&
+          Tok.isNot(tok::annot_pragma_openmp_end)) {
+        TPA.Commit();
+        IsCorrect = false;
+        break;
+      }
+      IsCorrect = IsCorrect && !ER.isInvalid();
+      Scope.setInit(ER.get());
+      Inits.push_back(Scope.getInitializer());
+      if (I + 1 != E) {
+        TPA.Revert();
+      } else {
+        TPA.Commit();
+      }
+    }
+
+    IsCorrect =
+        ((LParen || Tok.is(tok::r_paren)) && !T.consumeClose()) && IsCorrect;
+  } else if (IsCorrect && FunctionsCorrect) {
+    // Parse expression and make pseudo functions.
+    for (SmallVectorImpl<QualType>::iterator I = Types.begin(), E = Types.end();
+         I != E; ++I) {
+      ParseScope FnScope(this, Scope::FnScope | Scope::DeclScope);
+      Sema::OMPDeclareReductionInitFunctionScope Scope(Actions, Loc, Name, *I,
+                                                       SourceLocation(), true);
+      Scope.setInit();
+      Inits.push_back(Scope.getInitializer());
+    }
+  }
+
+  if (!IsCorrect || !FunctionsCorrect)
+    D->setInvalidDecl();
+  return (IsCorrect && FunctionsCorrect) ? D : 0;
+}
+
+/// \brief Parsing of OpenMP clauses.
+///
+///    clause:
+///       if-clause | num_threads-clause | default-clause | proc_bind-clause |
+///       private-clause | firstprivate-clause | shared-clause |
+///       copyin-clause | reduction-clause | lastprivate-clause |
+///       schedule-clause | collapse-clause | ordered-clause | nowait-clause |
+///       copyprivate-clause | flush-clause | safelen-clause | linear-clause |
+///       aligned-clause | simdlen-clause | num_teams-clause |
+///       thread_limit-clause | uniform-clause | inbranch-clause |
+///       notinbranch-clause | dist_schedule-clause | depend-clause |
+///       device-clause | map-clause | to-clause | from-clause
+///
+OMPClause *Parser::ParseOpenMPClause(OpenMPDirectiveKind DKind,
+                                     OpenMPClauseKind CKind, bool FirstClause) {
+  OMPClause *Clause = 0;
+  bool ErrorFound = false;
+  // Check if clause is allowed for the given directive.
+  if (CKind != OMPC_unknown && !isAllowedClauseForDirective(DKind, CKind)) {
+    Diag(Tok, diag::err_omp_unexpected_clause) << getOpenMPClauseName(CKind)
+                                               << getOpenMPDirectiveName(DKind);
+    ErrorFound = true;
+  }
+
+  switch (CKind) {
+  case OMPC_if:
   case OMPC_num_threads:
-  case OMPC_safelen:
   case OMPC_collapse:
-    // OpenMP [2.5, Restrictions]
+  case OMPC_final:
+  case OMPC_safelen:
+  case OMPC_simdlen:
+  case OMPC_num_teams:
+  case OMPC_thread_limit:
+  case OMPC_device:
+    // OpenMP [2.5, Restrictions, p.3]
     //  At most one if clause can appear on the directive.
+    // OpenMP [2.5, Restrictions, p.5]
     //  At most one num_threads clause can appear on the directive.
-    // OpenMP [2.8.1, simd construct, Restrictions]
-    //  Only one safelen  clause can appear on a simd directive.
-    //  Only one collapse clause can appear on a simd directive.
-    // OpenMP [2.11.1, task Construct, Restrictions]
-    //  At most one if clause can appear on the directive.
+    // OpenMP [2.7.1, Restrictions, p. 4]
+    //  Only one collapse clause can appear on a loop directive.
+    // OpenMP [2.11.1, Restrictions, p. 4]
     //  At most one final clause can appear on the directive.
+    // OpenMP [2.8.1, Restrictions, p. 6]
+    //  Only one safelen clause can appear on a simd directive.
+    // OpenMP [2.8.2, Restrictions, p. 2]
+    //  At most one simdlen clause can appear in a declare simd directive.
+    // OpenMP [2.9.5, Restrictions, p. 4]
+    //  At most one num_teams clause can appear on the directive.
+    // OpenMP [2.9.5, Restrictions, p. 3]
+    //  At most one thread_limit clause can appear on the directive.
+    // OpenMP [2.9.1, Restrictions, p. 2]
+    //  At most one device clause can appear on the directive.
     if (!FirstClause) {
       Diag(Tok, diag::err_omp_more_one_clause) << getOpenMPDirectiveName(DKind)
                                                << getOpenMPClauseName(CKind);
@@ -375,9 +1343,9 @@
   case OMPC_default:
   case OMPC_proc_bind:
     // OpenMP [2.14.3.1, Restrictions]
-    //  Only a single default clause may be specified on a parallel, task or
-    //  teams directive.
-    // OpenMP [2.5, parallel Construct, Restrictions]
+    //  Only a single default clause may be specified on a parallel, task
+    //  or teams directive.
+    // OpenMP [2.5, Restrictions, p. 4]
     //  At most one proc_bind clause can appear on the directive.
     if (!FirstClause) {
       Diag(Tok, diag::err_omp_more_one_clause) << getOpenMPDirectiveName(DKind)
@@ -386,129 +1354,225 @@
 
     Clause = ParseOpenMPSimpleClause(CKind);
     break;
-  case OMPC_schedule:
-    // OpenMP [2.7.1, Restrictions, p. 3]
-    //  Only one schedule clause can appear on a loop directive.
-    if (!FirstClause) {
-      Diag(Tok, diag::err_omp_more_one_clause) << getOpenMPDirectiveName(DKind)
-                                               << getOpenMPClauseName(CKind);
-    }
-
-    Clause = ParseOpenMPSingleExprWithArgClause(CKind);
-    break;
   case OMPC_ordered:
   case OMPC_nowait:
   case OMPC_untied:
   case OMPC_mergeable:
+  case OMPC_read:
+  case OMPC_write:
+  case OMPC_update:
+  case OMPC_capture:
+  case OMPC_seq_cst:
     // OpenMP [2.7.1, Restrictions, p. 9]
     //  Only one ordered clause can appear on a loop directive.
     // OpenMP [2.7.1, Restrictions, C/C++, p. 4]
-    //  Only one nowait clause can appear on a for directive.
+    //  Only one nowait clause can appear on a loop directive.
+    // OpenMP [2.7.2, Restrictions, p. 3]
+    //  Only one nowait clause can appear on a sections directive.
     if (!FirstClause) {
       Diag(Tok, diag::err_omp_more_one_clause) << getOpenMPDirectiveName(DKind)
                                                << getOpenMPClauseName(CKind);
     }
-
+  // Fall-through...
+  // There is no restriction to have only one inbranch/only one
+  // notinbranch, only a restriction to not have them both on the
+  // same clause.
+  case OMPC_inbranch:
+  case OMPC_notinbranch:
     Clause = ParseOpenMPClause(CKind);
     break;
+  case OMPC_schedule:
+  case OMPC_dist_schedule:
+    // OpenMP [2.7.1, Restrictions, p. 3]
+    //  Only one schedule clause can appear on a loop directive.
+    if (!FirstClause) {
+      Diag(Tok, diag::err_omp_more_one_clause) << getOpenMPDirectiveName(DKind)
+                                               << getOpenMPClauseName(CKind);
+    }
+
+    Clause = ParseOpenMPSingleExprWithTypeClause(CKind);
+    break;
   case OMPC_private:
-  case OMPC_firstprivate:
   case OMPC_lastprivate:
+  case OMPC_firstprivate:
   case OMPC_shared:
+  case OMPC_copyin:
+  case OMPC_copyprivate:
   case OMPC_reduction:
+  case OMPC_depend:
   case OMPC_linear:
   case OMPC_aligned:
-  case OMPC_copyin:
-  case OMPC_copyprivate:
-  case OMPC_flush:
+  case OMPC_uniform:
+  case OMPC_map:
+  case OMPC_to:
+  case OMPC_from:
     Clause = ParseOpenMPVarListClause(CKind);
     break;
+  case OMPC_flush:
   case OMPC_unknown:
     Diag(Tok, diag::warn_omp_extra_tokens_at_eol)
         << getOpenMPDirectiveName(DKind);
-    SkipUntil(tok::annot_pragma_openmp_end, StopBeforeMatch);
+    while (!SkipUntil(tok::annot_pragma_openmp_end, StopBeforeMatch))
+      ;
     break;
-  case OMPC_threadprivate:
+  default:
     Diag(Tok, diag::err_omp_unexpected_clause) << getOpenMPClauseName(CKind)
                                                << getOpenMPDirectiveName(DKind);
-    SkipUntil(tok::comma, tok::annot_pragma_openmp_end, StopBeforeMatch);
+    while (
+        !SkipUntil(tok::comma, tok::annot_pragma_openmp_end, StopBeforeMatch))
+      ;
     break;
   }
-  return ErrorFound ? nullptr : Clause;
+  return ErrorFound ? 0 : Clause;
 }
 
 /// \brief Parsing of OpenMP clauses with single expressions like 'if',
-/// 'final', 'collapse', 'safelen', 'num_threads', 'simdlen', 'num_teams' or
-/// 'thread_limit'.
+/// 'collapse', 'safelen', 'num_threads', 'simdlen', 'num_teams' or
+/// 'thread_limit' or 'device'.
 ///
 ///    if-clause:
 ///      'if' '(' expression ')'
 ///
-///    final-clause:
-///      'final' '(' expression ')'
-///
 ///    num_threads-clause:
 ///      'num_threads' '(' expression ')'
 ///
+///    collapse-clause:
+///      'collapse' '(' expression ')'
+///
 ///    safelen-clause:
 ///      'safelen' '(' expression ')'
 ///
-///    collapse-clause:
-///      'collapse' '(' expression ')'
+///    simdlen-clause:
+///      'simdlen' '(' expression ')'
+///
+///    num_teams-clause:
+///      'num_teams' '(' expression ')'
+///
+///    thread_limit-clause:
+///      'thread_limit' '(' expression ')'
+///
+///    device-clause:
+///      'device' '(' expression ')'
 ///
 OMPClause *Parser::ParseOpenMPSingleExprClause(OpenMPClauseKind Kind) {
-  SourceLocation Loc = ConsumeToken();
-
-  BalancedDelimiterTracker T(*this, tok::l_paren, tok::annot_pragma_openmp_end);
-  if (T.expectAndConsume(diag::err_expected_lparen_after,
-                         getOpenMPClauseName(Kind)))
-    return nullptr;
+  SourceLocation Loc = Tok.getLocation();
+  SourceLocation LOpen = ConsumeAnyToken();
+  bool LParen = true;
+  if (Tok.isNot(tok::l_paren)) {
+    Diag(Tok, diag::err_expected_lparen_after) << getOpenMPClauseName(Kind);
+    LParen = false;
+  } else
+    ConsumeAnyToken();
 
   ExprResult LHS(ParseCastExpression(false, false, NotTypeCast));
   ExprResult Val(ParseRHSOfBinaryExpression(LHS, prec::Conditional));
 
-  // Parse ')'.
-  T.consumeClose();
+  if (LParen && Tok.isNot(tok::r_paren)) {
+    Diag(Tok, diag::err_expected_rparen);
+    Diag(LOpen, diag::note_matching) << "'('";
+    while (!SkipUntil(tok::r_paren, tok::comma, tok::annot_pragma_openmp_end,
+                      StopBeforeMatch))
+      ;
+  }
+  if (Tok.is(tok::r_paren))
+    ConsumeAnyToken();
 
   if (Val.isInvalid())
-    return nullptr;
+    return 0;
+
+  return Actions.ActOnOpenMPSingleExprClause(Kind, Val.get(), Loc,
+                                             Tok.getLocation());
+}
+
+/// \brief Parsing of OpenMP clauses with single expressions and some additional
+/// argument like 'schedule' or 'dist_schedule'.
+///
+///    schedule-clause:
+///      'schedule' '(' kind [',' expression ] ')'
+///
+///    dist_schedule-clause:
+///      'dist_schedule' '(' kind [',' expression] ')'
+///
+OMPClause *Parser::ParseOpenMPSingleExprWithTypeClause(OpenMPClauseKind Kind) {
+  SourceLocation Loc = Tok.getLocation();
+  SourceLocation LOpen = ConsumeAnyToken();
+  bool LParen = true;
+  if (Tok.isNot(tok::l_paren)) {
+    Diag(Tok, diag::err_expected_lparen_after) << getOpenMPClauseName(Kind);
+    LParen = false;
+  } else
+    ConsumeAnyToken();
+
+  unsigned Type = Tok.isAnnotation()
+                      ? 0
+                      : getOpenMPSimpleClauseType(Kind, PP.getSpelling(Tok));
+  SourceLocation TypeLoc = Tok.getLocation();
+  ExprResult Val = ExprError();
+  if (Tok.isNot(tok::r_paren) && Tok.isNot(tok::comma) &&
+      Tok.isNot(tok::annot_pragma_openmp_end))
+    ConsumeAnyToken();
+  if (Tok.is(tok::comma)) {
+    ConsumeAnyToken();
+    ExprResult LHS(ParseCastExpression(false, false, NotTypeCast));
+    Val = ParseRHSOfBinaryExpression(LHS, prec::Conditional);
+  }
+  if (LParen && Tok.isNot(tok::r_paren)) {
+    Diag(Tok, diag::err_expected_rparen);
+    Diag(LOpen, diag::note_matching) << "'('";
+    while (!SkipUntil(tok::r_paren, tok::comma, tok::annot_pragma_openmp_end,
+                      StopBeforeMatch))
+      ;
+  }
+  if (Tok.is(tok::r_paren))
+    ConsumeAnyToken();
 
-  return Actions.ActOnOpenMPSingleExprClause(
-      Kind, Val.get(), Loc, T.getOpenLocation(), T.getCloseLocation());
+  return Actions.ActOnOpenMPSingleExprWithTypeClause(
+      Kind, Type, TypeLoc, Val.get(), Loc, Tok.getLocation());
 }
 
 /// \brief Parsing of simple OpenMP clauses like 'default' or 'proc_bind'.
 ///
 ///    default-clause:
-///         'default' '(' 'none' | 'shared' ')
+///         'default' '(' 'none' | 'shared' ')'
 ///
 ///    proc_bind-clause:
-///         'proc_bind' '(' 'master' | 'close' | 'spread' ')
+///         'proc_bind' '(' 'master' | 'close' | 'spread' ')'
 ///
 OMPClause *Parser::ParseOpenMPSimpleClause(OpenMPClauseKind Kind) {
   SourceLocation Loc = Tok.getLocation();
-  SourceLocation LOpen = ConsumeToken();
-  // Parse '('.
-  BalancedDelimiterTracker T(*this, tok::l_paren, tok::annot_pragma_openmp_end);
-  if (T.expectAndConsume(diag::err_expected_lparen_after,
-                         getOpenMPClauseName(Kind)))
-    return nullptr;
+  SourceLocation LOpen = ConsumeAnyToken();
+  bool LParen = true;
+  if (Tok.isNot(tok::l_paren)) {
+    Diag(Tok, diag::err_expected_lparen_after) << getOpenMPClauseName(Kind);
+    LParen = false;
+  } else
+    ConsumeAnyToken();
 
-  unsigned Type = getOpenMPSimpleClauseType(
-      Kind, Tok.isAnnotation() ? "" : PP.getSpelling(Tok));
+  unsigned Type =
+      Tok.isAnnotation()
+          ? ((Kind == OMPC_default) ? (unsigned)OMPC_DEFAULT_unknown
+                                    : (unsigned)OMPC_PROC_BIND_unknown)
+          : getOpenMPSimpleClauseType(Kind, PP.getSpelling(Tok));
   SourceLocation TypeLoc = Tok.getLocation();
   if (Tok.isNot(tok::r_paren) && Tok.isNot(tok::comma) &&
       Tok.isNot(tok::annot_pragma_openmp_end))
     ConsumeAnyToken();
 
-  // Parse ')'.
-  T.consumeClose();
+  if (LParen && Tok.isNot(tok::r_paren)) {
+    Diag(Tok, diag::err_expected_rparen);
+    Diag(LOpen, diag::note_matching) << "'('";
+    while (!SkipUntil(tok::r_paren, tok::comma, tok::annot_pragma_openmp_end,
+                      StopBeforeMatch))
+      ;
+  }
+  if (Tok.is(tok::r_paren))
+    ConsumeAnyToken();
 
-  return Actions.ActOnOpenMPSimpleClause(Kind, Type, TypeLoc, LOpen, Loc,
+  return Actions.ActOnOpenMPSimpleClause(Kind, Type, TypeLoc, Loc,
                                          Tok.getLocation());
 }
 
-/// \brief Parsing of OpenMP clauses like 'ordered'.
+/// \brief Parsing of OpenMP clauses like 'ordered' or 'nowait'.
 ///
 ///    ordered-clause:
 ///         'ordered'
@@ -516,12 +1580,6 @@
 ///    nowait-clause:
 ///         'nowait'
 ///
-///    untied-clause:
-///         'untied'
-///
-///    mergeable-clause:
-///         'mergeable'
-///
 OMPClause *Parser::ParseOpenMPClause(OpenMPClauseKind Kind) {
   SourceLocation Loc = Tok.getLocation();
   ConsumeAnyToken();
@@ -529,200 +1587,334 @@
   return Actions.ActOnOpenMPClause(Kind, Loc, Tok.getLocation());
 }
 
-
-/// \brief Parsing of OpenMP clauses with single expressions and some additional
-/// argument like 'schedule' or 'dist_schedule'.
-///
-///    schedule-clause:
-///      'schedule' '(' kind [',' expression ] ')'
-///
-OMPClause *Parser::ParseOpenMPSingleExprWithArgClause(OpenMPClauseKind Kind) {
-  SourceLocation Loc = ConsumeToken();
-  SourceLocation CommaLoc;
-  // Parse '('.
-  BalancedDelimiterTracker T(*this, tok::l_paren, tok::annot_pragma_openmp_end);
-  if (T.expectAndConsume(diag::err_expected_lparen_after,
-                         getOpenMPClauseName(Kind)))
-    return nullptr;
-
-  ExprResult Val;
-  unsigned Type = getOpenMPSimpleClauseType(
-      Kind, Tok.isAnnotation() ? "" : PP.getSpelling(Tok));
-  SourceLocation KLoc = Tok.getLocation();
-  if (Tok.isNot(tok::r_paren) && Tok.isNot(tok::comma) &&
-      Tok.isNot(tok::annot_pragma_openmp_end))
-    ConsumeAnyToken();
-
-  if (Kind == OMPC_schedule &&
-      (Type == OMPC_SCHEDULE_static || Type == OMPC_SCHEDULE_dynamic ||
-       Type == OMPC_SCHEDULE_guided) &&
-      Tok.is(tok::comma)) {
-    CommaLoc = ConsumeAnyToken();
-    ExprResult LHS(ParseCastExpression(false, false, NotTypeCast));
-    Val = ParseRHSOfBinaryExpression(LHS, prec::Conditional);
-    if (Val.isInvalid())
-      return nullptr;
-  }
-
-  // Parse ')'.
-  T.consumeClose();
-
-  return Actions.ActOnOpenMPSingleExprWithArgClause(
-      Kind, Type, Val.get(), Loc, T.getOpenLocation(), KLoc, CommaLoc,
-      T.getCloseLocation());
-}
-
-static bool ParseReductionId(Parser &P, CXXScopeSpec &ReductionIdScopeSpec,
-                             UnqualifiedId &ReductionId) {
-  SourceLocation TemplateKWLoc;
-  if (ReductionIdScopeSpec.isEmpty()) {
-    auto OOK = OO_None;
-    switch (P.getCurToken().getKind()) {
-    case tok::plus:
-      OOK = OO_Plus;
-      break;
-    case tok::minus:
-      OOK = OO_Minus;
-      break;
-    case tok::star:
-      OOK = OO_Star;
-      break;
-    case tok::amp:
-      OOK = OO_Amp;
-      break;
-    case tok::pipe:
-      OOK = OO_Pipe;
-      break;
-    case tok::caret:
-      OOK = OO_Caret;
-      break;
-    case tok::ampamp:
-      OOK = OO_AmpAmp;
-      break;
-    case tok::pipepipe:
-      OOK = OO_PipePipe;
-      break;
-    default:
-      break;
-    }
-    if (OOK != OO_None) {
-      SourceLocation OpLoc = P.ConsumeToken();
-      SourceLocation SymbolLocations[] = {OpLoc, OpLoc, SourceLocation()};
-      ReductionId.setOperatorFunctionId(OpLoc, OOK, SymbolLocations);
-      return false;
-    }
-  }
-  return P.ParseUnqualifiedId(ReductionIdScopeSpec, /*EnteringContext*/ false,
-                              /*AllowDestructorName*/ false,
-                              /*AllowConstructorName*/ false, ParsedType(),
-                              TemplateKWLoc, ReductionId);
-}
-
-/// \brief Parsing of OpenMP clause 'private', 'firstprivate', 'lastprivate',
-/// 'shared', 'copyin', 'copyprivate', 'flush' or 'reduction'.
+/// \brief Parsing of OpenMP clause 'private', 'firstprivate',
+/// 'lastprivate', 'shared', 'copyin', 'reduction', 'flush',
+/// 'linear', 'aligned' or 'depend'.
 ///
 ///    private-clause:
 ///       'private' '(' list ')'
-///    firstprivate-clause:
-///       'firstprivate' '(' list ')'
+///
 ///    lastprivate-clause:
 ///       'lastprivate' '(' list ')'
+///
+///    firstprivate-clause:
+///       'firstprivate' '(' list ')'
+///
 ///    shared-clause:
 ///       'shared' '(' list ')'
+///
+///    copyin-clause:
+///       'copyin' '(' list ')'
+///
+///    copyprivate-clause:
+///       'copyprivate' '(' list ')'
+///
+///    reduction-clause:
+///       'reduction' '(' reduction-identifier ':' list ')'
+///
+///    depend-clause:
+///       'depend' '(' dependence-type ':' list ')'
+///
+///    flush-clause:
+///       '(' list ')'
+///
 ///    linear-clause:
 ///       'linear' '(' list [ ':' linear-step ] ')'
+///
 ///    aligned-clause:
 ///       'aligned' '(' list [ ':' alignment ] ')'
-///    reduction-clause:
-///       'reduction' '(' reduction-identifier ':' list ')'
-///    copyprivate-clause:
-///       'copyprivate' '(' list ')'
-///    flush-clause:
-///       'flush' '(' list ')'
+///
+///    map-clause:
+///       'map' '(' map-kind ':' list ')'
+///
+///    to-clause:
+///       'to' '(' list ')'
+///
+///    from-clause:
+///       'from' '(' list ')'
 ///
 OMPClause *Parser::ParseOpenMPVarListClause(OpenMPClauseKind Kind) {
+  assert(Kind != OMPC_uniform);
   SourceLocation Loc = Tok.getLocation();
-  SourceLocation LOpen = ConsumeToken();
-  SourceLocation ColonLoc = SourceLocation();
-  // Optional scope specifier and unqualified id for reduction identifier.
-  CXXScopeSpec ReductionIdScopeSpec;
-  UnqualifiedId ReductionId;
-  bool InvalidReductionId = false;
-  // Parse '('.
-  BalancedDelimiterTracker T(*this, tok::l_paren, tok::annot_pragma_openmp_end);
-  if (T.expectAndConsume(diag::err_expected_lparen_after,
-                         getOpenMPClauseName(Kind)))
-    return nullptr;
+  SourceLocation LOpen = ConsumeAnyToken();
+  bool LParen = true;
+  CXXScopeSpec SS;
+  UnqualifiedId OpName;
+  if (Tok.isNot(tok::l_paren)) {
+    Diag(Tok, diag::err_expected_lparen_after) << getOpenMPClauseName(Kind);
+    LParen = false;
+  } else
+    ConsumeAnyToken();
 
-  // Handle reduction-identifier for reduction clause.
+  unsigned Op = OMPC_REDUCTION_unknown;
+  // Parsing "reduction-identifier ':'" for reduction clause.
   if (Kind == OMPC_reduction) {
-    ColonProtectionRAIIObject ColonRAII(*this);
-    if (getLangOpts().CPlusPlus) {
-      ParseOptionalCXXScopeSpecifier(ReductionIdScopeSpec, ParsedType(), false);
+    Op = Tok.isAnnotation()
+             ? (unsigned)OMPC_REDUCTION_unknown
+             : getOpenMPSimpleClauseType(Kind, PP.getSpelling(Tok));
+    switch (Op) {
+    case OMPC_REDUCTION_add:
+    case OMPC_REDUCTION_mult:
+    case OMPC_REDUCTION_sub:
+    case OMPC_REDUCTION_bitand:
+    case OMPC_REDUCTION_bitor:
+    case OMPC_REDUCTION_bitxor:
+    case OMPC_REDUCTION_and:
+    case OMPC_REDUCTION_or:
+    case OMPC_REDUCTION_min:
+    case OMPC_REDUCTION_max:
+      OpName.setIdentifier(
+          &Actions.Context.Idents.get(getOpenMPSimpleClauseTypeName(Kind, Op)),
+          Tok.getLocation());
+      if (Tok.isNot(tok::r_paren) && Tok.isNot(tok::annot_pragma_openmp_end)) {
+        ConsumeAnyToken();
+      }
+      break;
+    case OMPC_REDUCTION_unknown: {
+      if (getLangOpts().CPlusPlus) {
+        ParseOptionalCXXScopeSpecifier(SS, ParsedType(), false);
+      }
+      SourceLocation TemplateKWLoc;
+      if (!ParseUnqualifiedId(SS, false, false, false, ParsedType(),
+                              TemplateKWLoc, OpName)) {
+        Op = OMPC_REDUCTION_custom;
+      }
+      break;
     }
-    InvalidReductionId =
-        ParseReductionId(*this, ReductionIdScopeSpec, ReductionId);
-    if (InvalidReductionId) {
-      SkipUntil(tok::colon, tok::r_paren, tok::annot_pragma_openmp_end,
-                StopBeforeMatch);
+    case OMPC_REDUCTION_custom:
+      llvm_unreachable("'custom' reduction kind cannot be generated directly.");
+    case NUM_OPENMP_REDUCTION_OPERATORS:
+      llvm_unreachable("unexpected reduction kind.");
     }
-    if (Tok.is(tok::colon)) {
-      ColonLoc = ConsumeToken();
+
+    if (Tok.isNot(tok::colon))
+      Diag(Tok, diag::err_omp_expected_colon) << getOpenMPClauseName(Kind);
+    else
+      ConsumeAnyToken();
+  } else if (Kind == OMPC_depend) {
+    // Parsing "dependence-type ':'" for depend clause.
+    Op = Tok.isAnnotation()
+             ? (unsigned)OMPC_DEPEND_unknown
+             : getOpenMPSimpleClauseType(Kind, PP.getSpelling(Tok));
+    switch (Op) {
+    case OMPC_DEPEND_in:
+    case OMPC_DEPEND_out:
+    case OMPC_DEPEND_inout:
+      break;
+    case OMPC_DEPEND_unknown:
+      Diag(Tok, diag::err_omp_unknown_dependence_type);
+      break;
+    case NUM_OPENMP_DEPENDENCE_TYPE:
+      llvm_unreachable("unexpected dependence type.");
+    }
+
+    if (Tok.isNot(tok::r_paren) && Tok.isNot(tok::annot_pragma_openmp_end)) {
+      ConsumeAnyToken();
+      if (Tok.isNot(tok::colon))
+        Diag(Tok, diag::err_omp_expected_colon) << getOpenMPClauseName(Kind);
+      else
+        ConsumeAnyToken();
+    }
+  } else if (Kind == OMPC_map) {
+    // Parsing "map-kind ':'" for map clause.
+    Op = Tok.isAnnotation()
+             ? (unsigned)OMPC_MAP_unknown
+             : getOpenMPSimpleClauseType(Kind, PP.getSpelling(Tok));
+    switch (Op) {
+    case OMPC_MAP_alloc:
+    case OMPC_MAP_to:
+    case OMPC_MAP_from:
+    case OMPC_MAP_tofrom:
+    case OMPC_MAP_unknown:
+      break;
+    case NUM_OPENMP_MAP_KIND:
+      llvm_unreachable("unexpected mapping_kind.");
+    }
+
+    if (Tok.isNot(tok::r_paren) && Tok.isNot(tok::annot_pragma_openmp_end) &&
+        Op != OMPC_MAP_unknown) {
+      ConsumeAnyToken();
+      if (Tok.isNot(tok::colon))
+        Diag(Tok, diag::err_omp_expected_colon) << getOpenMPClauseName(Kind);
+      else
+        ConsumeAnyToken();
     } else {
-      Diag(Tok, diag::warn_pragma_expected_colon) << "reduction identifier";
+      Op = OMPC_MAP_tofrom;
     }
   }
 
-  SmallVector<Expr *, 5> Vars;
-  bool IsComma = !InvalidReductionId;
-  const bool MayHaveTail = (Kind == OMPC_linear || Kind == OMPC_aligned);
-  while (IsComma || (Tok.isNot(tok::r_paren) && Tok.isNot(tok::colon) &&
-                     Tok.isNot(tok::annot_pragma_openmp_end))) {
-    ColonProtectionRAIIObject ColonRAII(*this, MayHaveTail);
+  SmallVector<Expr *, 4> Vars;
+  bool IsComma = (Kind != OMPC_reduction || Op != OMPC_REDUCTION_unknown) &&
+                 (Kind != OMPC_depend || Op != OMPC_DEPEND_unknown) &&
+                 (Kind != OMPC_map || Op != OMPC_MAP_unknown);
+  bool MayHaveTail = (Kind == OMPC_linear) || (Kind == OMPC_aligned);
+  while (IsComma ||
+         (Tok.isNot(tok::r_paren) && Tok.isNot(tok::annot_pragma_openmp_end) &&
+          Tok.isNot(tok::colon))) {
     // Parse variable
+    AllowCEANExpressions CEANRAII(*this,
+                                  Kind == OMPC_depend || Kind == OMPC_map ||
+                                  Kind == OMPC_from || Kind == OMPC_to);
     ExprResult VarExpr = ParseAssignmentExpression();
     if (VarExpr.isUsable()) {
       Vars.push_back(VarExpr.get());
     } else {
-      SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_openmp_end,
-                StopBeforeMatch);
+      while (!SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_openmp_end,
+                        StopBeforeMatch))
+        ;
     }
     // Skip ',' if any
     IsComma = Tok.is(tok::comma);
-    if (IsComma)
-      ConsumeToken();
-    else if (Tok.isNot(tok::r_paren) &&
-             Tok.isNot(tok::annot_pragma_openmp_end) &&
-             (!MayHaveTail || Tok.isNot(tok::colon)))
-      Diag(Tok, diag::err_omp_expected_punc)
-          << ((Kind == OMPC_flush) ? getOpenMPDirectiveName(OMPD_flush)
-                                   : getOpenMPClauseName(Kind))
-          << (Kind == OMPC_flush);
-  }
-
-  // Parse ':' linear-step (or ':' alignment).
-  Expr *TailExpr = nullptr;
-  const bool MustHaveTail = MayHaveTail && Tok.is(tok::colon);
-  if (MustHaveTail) {
-    ColonLoc = Tok.getLocation();
-    ConsumeToken();
-    ExprResult Tail = ParseAssignmentExpression();
-    if (Tail.isUsable())
-      TailExpr = Tail.get();
-    else
-      SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_openmp_end,
-                StopBeforeMatch);
+    if (IsComma) {
+      ConsumeAnyToken();
+    } else if (Tok.isNot(tok::r_paren) &&
+               Tok.isNot(tok::annot_pragma_openmp_end) &&
+               (!MayHaveTail || Tok.isNot(tok::colon))) {
+      Diag(Tok, diag::err_omp_expected_punc) << 1 << getOpenMPClauseName(Kind);
+    }
   }
 
-  // Parse ')'.
-  T.consumeClose();
-  if (Vars.empty() || (MustHaveTail && !TailExpr) || InvalidReductionId)
-    return nullptr;
+  bool MustHaveTail = false;
+  Expr *TailExpr = 0;
+  SourceLocation TailLoc;
+  if (MayHaveTail) {
+    // Parse "':' linear-step" or "':' alignment"
+    if (Tok.is(tok::colon)) {
+      MustHaveTail = true;
+      ConsumeAnyToken();
+      ColonProtectionRAIIObject ColonRAII(*this);
+      TailLoc = Tok.getLocation();
+      ExprResult Tail = ParseAssignmentExpression();
+      if (Tail.isUsable()) {
+        TailExpr = Tail.get();
+      } else {
+        while (!SkipUntil(tok::r_paren, tok::annot_pragma_openmp_end,
+                          StopBeforeMatch))
+          ;
+      }
+    }
+  }
+
+  if (LParen && Tok.isNot(tok::r_paren)) {
+    Diag(Tok, diag::err_expected_rparen);
+    Diag(LOpen, diag::note_matching) << "'('";
+    while (!SkipUntil(tok::r_paren, tok::comma, tok::annot_pragma_openmp_end,
+                      StopBeforeMatch))
+      ;
+  }
+  if (Tok.is(tok::r_paren))
+    ConsumeAnyToken();
+
+  if (Vars.empty() ||
+      (Kind == OMPC_reduction && Op == OMPC_REDUCTION_unknown) ||
+      (Kind == OMPC_depend && Op == OMPC_DEPEND_unknown) ||
+      (Kind == OMPC_map && Op == OMPC_MAP_unknown))
+    return 0;
+
+  if (MustHaveTail && !TailExpr) {
+    // The error ('expected expression') was already emitted.
+    return 0;
+  }
 
   return Actions.ActOnOpenMPVarListClause(
-      Kind, Vars, TailExpr, Loc, LOpen, ColonLoc, Tok.getLocation(),
-      ReductionIdScopeSpec,
-      ReductionId.isValid() ? Actions.GetNameFromUnqualifiedId(ReductionId)
-                            : DeclarationNameInfo());
+      Kind, Vars, Loc, Tok.getLocation(), Op, TailExpr, SS, OpName,
+      (TailExpr ? TailLoc : SourceLocation()));
 }
 
+/// \brief Parsing of OpenMP clause 'linear', 'aligned' or 'uniform' for
+/// the '#pragma omp declare simd'.
+///
+///    linear-clause:
+///       'linear' '(' list [ ':' linear-step ] ')'
+///
+///    aligned-clause:
+///       'aligned' '(' list [ ':' alignment ] ')'
+///
+///    uniform-clause:
+///       'uniform' '(' list ')'
+///
+bool Parser::ParseOpenMPDeclarativeVarListClause(
+    OpenMPDirectiveKind DKind, OpenMPClauseKind CKind,
+    DeclarationNameInfoList &NameInfos, SourceLocation &StartLoc,
+    SourceLocation &EndLoc, Expr *&TailExpr, SourceLocation &TailLoc) {
+  bool IsCorrect = true;
+  // Check if clause is allowed for the given directive.
+  if (CKind != OMPC_unknown && !isAllowedClauseForDirective(DKind, CKind)) {
+    Diag(Tok, diag::err_omp_unexpected_clause) << getOpenMPClauseName(CKind)
+                                               << getOpenMPDirectiveName(DKind);
+    IsCorrect = false;
+  }
+
+  // The following constraint should be enforced by directive-clause
+  // checks before calling this routine.
+  assert(CKind == OMPC_linear || CKind == OMPC_aligned ||
+         CKind == OMPC_uniform);
+
+  NameInfos.clear();
+
+  // Read the source location of the clause.
+  StartLoc = Tok.getLocation();
+  ConsumeToken();
+
+  // Eat '('.
+  BalancedDelimiterTracker T(*this, tok::l_paren, tok::annot_pragma_openmp_end);
+  bool LParen = !T.expectAndConsume(diag::err_expected_lparen_after,
+                                    getOpenMPClauseName(CKind));
+  IsCorrect &= LParen;
+  bool NoIdentIsFound = true;
+
+  // Parse the comma-separated identifiers list.
+  bool IsComma = true;
+  while (IsComma ||
+         (Tok.isNot(tok::r_paren) && Tok.isNot(tok::annot_pragma_openmp_end) &&
+          Tok.isNot(tok::colon))) {
+    CXXScopeSpec SS;
+    SourceLocation TemplateKWLoc;
+    UnqualifiedId Name;
+    if (ParseUnqualifiedId(SS, false, false, false, ParsedType(), TemplateKWLoc,
+                           Name)) {
+      IsCorrect = false;
+      SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_openmp_end,
+                StopBeforeMatch);
+    } else {
+      DeclarationNameInfo NameInfo = Actions.GetNameFromUnqualifiedId(Name);
+      NameInfos.push_back(NameInfo);
+      NoIdentIsFound = false;
+    }
+    // Consume ','.
+    IsComma = Tok.is(tok::comma);
+    if (IsComma) {
+      ConsumeToken();
+    }
+  }
+  bool MayHaveTail = (CKind == OMPC_linear) || (CKind == OMPC_aligned);
+  bool MustHaveTail = false;
+  TailExpr = 0;
+  if (MayHaveTail) {
+    // Parse "':' linear-step" or "':' alignment"
+    if (Tok.is(tok::colon)) {
+      MustHaveTail = true;
+      ConsumeAnyToken();
+      ColonProtectionRAIIObject ColonRAII(*this);
+      TailLoc = Tok.getLocation();
+      ExprResult Tail = ParseAssignmentExpression();
+      if (Tail.isUsable()) {
+        TailExpr = Tail.get();
+      } else {
+        SkipUntil(tok::r_paren, tok::annot_pragma_openmp_end, StopBeforeMatch);
+      }
+    }
+  }
+  if (NoIdentIsFound) {
+    Diag(Tok, diag::err_expected_ident);
+    IsCorrect = false;
+  }
+
+  EndLoc = Tok.getLocation();
+
+  // Eat ')'.
+  IsCorrect =
+      ((LParen || Tok.is(tok::r_paren)) && !T.consumeClose()) && IsCorrect;
+
+  return !IsCorrect;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Parse/Parser.cpp cfe-3.5.0.src.omp/lib/Parse/Parser.cpp
--- cfe-3.5.0.src/lib/Parse/Parser.cpp	2014-07-21 20:53:05.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Parse/Parser.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -52,7 +52,7 @@
   : PP(pp), Actions(actions), Diags(PP.getDiagnostics()),
     GreaterThanIsOperator(true), ColonIsSacred(false), 
     InMessageExpression(false), TemplateParameterDepth(0),
-    ParsingInObjCContainer(false) {
+    ParsingInObjCContainer(false), IsCEANAllowed(false) {
   SkipFunctionBodies = pp.isCodeCompletionEnabled() || skipFunctionBodies;
   Tok.startToken();
   Tok.setKind(tok::eof);
@@ -624,8 +624,7 @@
     HandlePragmaOpenCLExtension();
     return DeclGroupPtrTy();
   case tok::annot_pragma_openmp:
-    ParseOpenMPDeclarativeDirective();
-    return DeclGroupPtrTy();
+    return ParseOpenMPDeclarativeDirective(AS_none);
   case tok::annot_pragma_ms_pointers_to_members:
     HandlePragmaMSPointersToMembers();
     return DeclGroupPtrTy();
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Parse/RAIIObjectsForParser.h cfe-3.5.0.src.omp/lib/Parse/RAIIObjectsForParser.h
--- cfe-3.5.0.src/lib/Parse/RAIIObjectsForParser.h	2014-05-21 02:02:52.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Parse/RAIIObjectsForParser.h	2014-11-28 10:49:30.000000000 -0500
@@ -430,6 +430,22 @@
     void skipToEnd();
   };
 
+  /// \brief A RAII object used to temporarily allow using of CEAN expressions.
+  class AllowCEANExpressions {
+    Parser &P;
+    bool IsCEANAllowed;
+
+  public:
+    AllowCEANExpressions(Parser &P, bool IsAllowed)
+        : P(P), IsCEANAllowed(P.IsCEANAllowed) {
+      P.IsCEANAllowed = IsAllowed;
+    }
+
+    ~AllowCEANExpressions() {
+      P.IsCEANAllowed = IsCEANAllowed;
+    }
+  };
+
 } // end namespace clang
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Sema/SemaChecking.cpp cfe-3.5.0.src.omp/lib/Sema/SemaChecking.cpp
--- cfe-3.5.0.src/lib/Sema/SemaChecking.cpp	2014-07-21 22:01:04.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Sema/SemaChecking.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -115,6 +115,24 @@
 Sema::CheckBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall) {
   ExprResult TheCallResult(TheCall);
 
+  // Check that setjmp/longjmp are not allowed in omp simd.
+  switch (BuiltinID) {
+  case Builtin::BI_setjmp:
+  case Builtin::BIsetjmp:
+  case Builtin::BIsetjmp_syscall:
+  case Builtin::BIqsetjmp:
+  case Builtin::BIgetcontext:
+  case Builtin::BI__builtin_setjmp:
+  case Builtin::BI_longjmp:
+  case Builtin::BIlongjmp:
+  case Builtin::BI__builtin_longjmp:
+    if (HasOpenMPSimdRegion()) {
+      Diag(TheCall->getExprLoc(), diag::err_setjmp_longjmp_in_omp_simd)
+        << TheCall->getSourceRange();
+      return ExprError();
+    }
+    break;
+  }
   // Find out if any arguments are required to be integer constant expressions.
   unsigned ICEArguments = 0;
   ASTContext::GetBuiltinTypeError Error;
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Sema/SemaDecl.cpp cfe-3.5.0.src.omp/lib/Sema/SemaDecl.cpp
--- cfe-3.5.0.src/lib/Sema/SemaDecl.cpp	2014-07-21 20:53:05.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Sema/SemaDecl.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -4572,6 +4572,10 @@
       CurContext->addHiddenDecl(New);
   }
 
+  if (IsDeclContextInOpenMPTarget(CurContext)) {
+    CheckDeclIsAllowedInOpenMPTarget(0, New);
+  }
+
   return New;
 }
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Sema/SemaExceptionSpec.cpp cfe-3.5.0.src.omp/lib/Sema/SemaExceptionSpec.cpp
--- cfe-3.5.0.src/lib/Sema/SemaExceptionSpec.cpp	2014-07-18 21:39:17.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Sema/SemaExceptionSpec.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -1102,6 +1102,10 @@
     // These expressions can never throw.
     return CT_Cannot;
 
+  case Expr::CEANIndexExprClass: {
+    CanThrowResult CT = E->isTypeDependent() ? CT_Dependent : CT_Cannot;
+    return mergeCanThrow(CT, canSubExprsThrow(*this, E));
+  }
   case Expr::MSPropertyRefExprClass:
     llvm_unreachable("Invalid class for expression");
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Sema/SemaExpr.cpp cfe-3.5.0.src.omp/lib/Sema/SemaExpr.cpp
--- cfe-3.5.0.src/lib/Sema/SemaExpr.cpp	2014-07-18 21:39:17.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Sema/SemaExpr.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -1626,6 +1626,31 @@
   return BuildDeclRefExpr(D, Ty, VK, NameInfo, SS);
 }
 
+static bool CheckOMPDeclareReductionVar(Sema &S, ValueDecl *D,
+                                        SourceLocation Loc) {
+  if (S.CurrentInstantiationScope) return true;
+  if (!D || !isa<VarDecl>(D)) return true;
+  if (!S.getCurScope() || !S.getCurScope()->getEntity()) return true;
+  if (S.getCurScope()->getEntity() != S.CurContext) return true;
+  DeclContext *Parent =
+    static_cast<DeclContext *>(S.getCurScope()->getEntity());
+  if (FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(Parent)) {
+    Parent = FD->getDeclContext();
+    if (OMPDeclareReductionDecl *OMPDR =
+          dyn_cast_or_null<OMPDeclareReductionDecl>(Parent)) {
+      if (D->getDeclContext() != FD) {
+        S.Diag(Loc,
+               (FD->getDeclName() == OMPDR->getDeclName()) ?
+                                       diag::err_omp_wrong_var_in_combiner :
+                                       diag::err_omp_wrong_var_in_initializer)
+          << cast<NamedDecl>(D);
+        return false;
+      }
+    }
+  }
+  return true;
+}
+
 /// BuildDeclRefExpr - Build an expression that references a
 /// declaration that does not require a closure capture.
 ExprResult
@@ -1633,6 +1658,13 @@
                        const DeclarationNameInfo &NameInfo,
                        const CXXScopeSpec *SS, NamedDecl *FoundD,
                        const TemplateArgumentListInfo *TemplateArgs) {
+  // Check that only 'omp_in' and 'omp_out' can be used in
+  // 'omp declare reduction' combiner.
+  // Check that only 'omp_priv' and 'omp_orig' can be used in
+  // 'omp declare reduction' initializer.
+  if (!CheckOMPDeclareReductionVar(*this, D, NameInfo.getLoc()))
+    return ExprError();
+
   if (getLangOpts().CUDA)
     if (const FunctionDecl *Caller = dyn_cast<FunctionDecl>(CurContext))
       if (const FunctionDecl *Callee = dyn_cast<FunctionDecl>(D)) {
@@ -11653,6 +11685,8 @@
   bool IsBlock = isa<BlockScopeInfo>(CSI);
   bool IsLambda = isa<LambdaScopeInfo>(CSI);
 
+  if (Var->hasAttr<OMPLocalAttr>()) return false;
+
   // Lambdas are not allowed to capture unnamed variables
   // (e.g. anonymous unions).
   // FIXME: The C++11 rule don't actually state this explicitly, but I'm
@@ -12149,6 +12183,7 @@
       }
       return true;
     }
+
     // Certain capturing entities (lambdas, blocks etc.) are not allowed to capture 
     // certain types of variables (unnamed, variably modified types etc.)
     // so check for eligibility.
@@ -12540,6 +12575,11 @@
 
 static void MarkExprReferenced(Sema &SemaRef, SourceLocation Loc,
                                Decl *D, Expr *E, bool OdrUse) {
+
+  if (SemaRef.IsDeclContextInOpenMPTarget(SemaRef.CurContext)) {
+    SemaRef.CheckDeclIsAllowedInOpenMPTarget(E, D);
+  }
+
   if (VarDecl *Var = dyn_cast<VarDecl>(D)) {
     DoMarkVarDeclReferenced(SemaRef, Loc, Var, E);
     return;
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Sema/SemaExprCXX.cpp cfe-3.5.0.src.omp/lib/Sema/SemaExprCXX.cpp
--- cfe-3.5.0.src/lib/Sema/SemaExprCXX.cpp	2014-08-04 14:37:31.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Sema/SemaExprCXX.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -619,9 +619,6 @@
       !getSourceManager().isInSystemHeader(OpLoc))
     Diag(OpLoc, diag::err_exceptions_disabled) << "throw";
 
-  if (getCurScope() && getCurScope()->isOpenMPSimdDirectiveScope())
-    Diag(OpLoc, diag::err_omp_simd_region_cannot_use_stmt) << "throw";
-
   if (Ex && !Ex->isTypeDependent()) {
     ExprResult ExRes = CheckCXXThrowOperand(OpLoc, Ex, IsThrownVarInScope);
     if (ExRes.isInvalid())
@@ -1669,7 +1666,7 @@
       NewName = Context.DeclarationNames.getCXXOperatorName(OO_New);
       DeleteName = Context.DeclarationNames.getCXXOperatorName(OO_Delete);
       if (FindAllocationOverload(StartLoc, Range, NewName, AllocArgs, TUDecl,
-                               /*AllowMissing=*/false, OperatorNew))
+                                 /*AllowMissing=*/false, OperatorNew))
       return true;
     }
   }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Sema/SemaLookup.cpp cfe-3.5.0.src.omp/lib/Sema/SemaLookup.cpp
--- cfe-3.5.0.src/lib/Sema/SemaLookup.cpp	2014-07-15 18:03:49.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Sema/SemaLookup.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -275,6 +275,10 @@
     IDNS = Decl::IDNS_ObjCProtocol;
     break;
 
+  case Sema::LookupOMPDeclareReduction:
+    IDNS = Decl::IDNS_OMPDeclareReduction;
+    break;
+
   case Sema::LookupAnyName:
     IDNS = Decl::IDNS_Ordinary | Decl::IDNS_Tag | Decl::IDNS_Member
       | Decl::IDNS_Using | Decl::IDNS_Namespace | Decl::IDNS_ObjCProtocol
@@ -1672,6 +1676,9 @@
       BaseCallback = &LookupAnyMember;
       break;
 
+    case LookupOMPDeclareReduction:
+      BaseCallback = &CXXRecordDecl::FindOMPDeclareReductionMember;
+      break;
     case LookupUsingDeclName:
       // This lookup is for redeclarations only.
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Sema/SemaOpenMP.cpp cfe-3.5.0.src.omp/lib/Sema/SemaOpenMP.cpp
--- cfe-3.5.0.src/lib/Sema/SemaOpenMP.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Sema/SemaOpenMP.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -1,4 +1,3 @@
-//===--- SemaOpenMP.cpp - Semantic Analysis for OpenMP constructs ---------===//
 //
 //                     The LLVM Compiler Infrastructure
 //
@@ -12,20 +11,20 @@
 ///
 //===----------------------------------------------------------------------===//
 
-#include "clang/AST/ASTContext.h"
+#include "clang/Basic/OpenMPKinds.h"
+#include "clang/AST/ASTConsumer.h"
 #include "clang/AST/Decl.h"
 #include "clang/AST/DeclCXX.h"
 #include "clang/AST/DeclOpenMP.h"
-#include "clang/AST/StmtCXX.h"
 #include "clang/AST/StmtOpenMP.h"
+#include "clang/AST/StmtCXX.h"
 #include "clang/AST/StmtVisitor.h"
-#include "clang/Basic/OpenMPKinds.h"
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Sema/Initialization.h"
 #include "clang/Sema/Lookup.h"
+#include "clang/Sema/SemaInternal.h"
 #include "clang/Sema/Scope.h"
 #include "clang/Sema/ScopeInfo.h"
-#include "clang/Sema/SemaInternal.h"
 using namespace clang;
 
 //===----------------------------------------------------------------------===//
@@ -40,38 +39,13 @@
   DSA_shared = 1 << 1  /// \brief Default data sharing attribute 'shared'.
 };
 
-template <class T> struct MatchesAny {
-  explicit MatchesAny(ArrayRef<T> Arr) : Arr(std::move(Arr)) {}
-  bool operator()(T Kind) {
-    for (auto KindEl : Arr)
-      if (KindEl == Kind)
-        return true;
-    return false;
-  }
-
-private:
-  ArrayRef<T> Arr;
-};
-struct MatchesAlways {
-  MatchesAlways() {}
-  template <class T> bool operator()(T) { return true; }
-};
-
-typedef MatchesAny<OpenMPClauseKind> MatchesAnyClause;
-typedef MatchesAny<OpenMPDirectiveKind> MatchesAnyDirective;
-
 /// \brief Stack for tracking declarations used in OpenMP directives and
 /// clauses and their data-sharing attributes.
 class DSAStackTy {
 public:
-  struct DSAVarData {
-    OpenMPDirectiveKind DKind;
-    OpenMPClauseKind CKind;
-    DeclRefExpr *RefExpr;
-    SourceLocation ImplicitDSALoc;
-    DSAVarData()
-        : DKind(OMPD_unknown), CKind(OMPC_unknown), RefExpr(nullptr),
-          ImplicitDSALoc() {}
+  struct MapInfo {
+    Expr *RefExpr;
+    bool IsCEAN;
   };
 
 private:
@@ -80,89 +54,94 @@
     DeclRefExpr *RefExpr;
   };
   typedef llvm::SmallDenseMap<VarDecl *, DSAInfo, 64> DeclSAMapTy;
-  typedef llvm::SmallDenseMap<VarDecl *, DeclRefExpr *, 64> AlignedMapTy;
+  typedef llvm::SmallDenseMap<VarDecl *, MapInfo, 64> MappedDeclsTy;
 
   struct SharingMapTy {
     DeclSAMapTy SharingMap;
-    AlignedMapTy AlignedMap;
+    DeclSAMapTy AlignedMap;
+    MappedDeclsTy MappedDecls;
     DefaultDataSharingAttributes DefaultAttr;
-    SourceLocation DefaultAttrLoc;
     OpenMPDirectiveKind Directive;
     DeclarationNameInfo DirectiveName;
+    bool IsOrdered;
+    bool IsNowait;
     Scope *CurScope;
-    SourceLocation ConstructLoc;
-    SharingMapTy(OpenMPDirectiveKind DKind, DeclarationNameInfo Name,
-                 Scope *CurScope, SourceLocation Loc)
-        : SharingMap(), AlignedMap(), DefaultAttr(DSA_unspecified),
-          Directive(DKind), DirectiveName(std::move(Name)), CurScope(CurScope),
-          ConstructLoc(Loc) {}
+    SharingMapTy(OpenMPDirectiveKind DKind, const DeclarationNameInfo &Name,
+                 Scope *CurScope)
+        : SharingMap(), AlignedMap(), MappedDecls(),
+          DefaultAttr(DSA_unspecified), Directive(DKind), DirectiveName(Name),
+          IsOrdered(false), IsNowait(false), CurScope(CurScope) {}
     SharingMapTy()
-        : SharingMap(), AlignedMap(), DefaultAttr(DSA_unspecified),
-          Directive(OMPD_unknown), DirectiveName(), CurScope(nullptr),
-          ConstructLoc() {}
+        : SharingMap(), AlignedMap(), MappedDecls(),
+          DefaultAttr(DSA_unspecified), Directive(OMPD_unknown),
+          DirectiveName(), IsOrdered(false), IsNowait(false), CurScope(0) {}
   };
 
-  typedef SmallVector<SharingMapTy, 64> StackTy;
+  typedef SmallVector<SharingMapTy, 4> StackTy;
 
   /// \brief Stack of used declaration and their data-sharing attributes.
   StackTy Stack;
-  Sema &SemaRef;
+  Sema &Actions;
 
-  typedef SmallVector<SharingMapTy, 8>::reverse_iterator reverse_iterator;
+  typedef SmallVector<SharingMapTy, 4>::reverse_iterator reverse_iterator;
 
-  DSAVarData getDSA(StackTy::reverse_iterator Iter, VarDecl *D);
+  typedef llvm::DenseSet<Decl *> DeclaredTargetDeclsTy;
 
+  DeclaredTargetDeclsTy DeclaredTargetDecls;
+
+  OpenMPClauseKind getDSA(StackTy::reverse_iterator Iter, VarDecl *D,
+                          OpenMPDirectiveKind &Kind, DeclRefExpr *&E);
   /// \brief Checks if the variable is a local for OpenMP region.
   bool isOpenMPLocal(VarDecl *D, StackTy::reverse_iterator Iter);
 
 public:
-  explicit DSAStackTy(Sema &S) : Stack(1), SemaRef(S) {}
+  DSAStackTy(Sema &S) : Stack(1), Actions(S) {}
 
   void push(OpenMPDirectiveKind DKind, const DeclarationNameInfo &DirName,
-            Scope *CurScope, SourceLocation Loc) {
-    Stack.push_back(SharingMapTy(DKind, DirName, CurScope, Loc));
-    Stack.back().DefaultAttrLoc = Loc;
+            Scope *CurScope) {
+    Stack.push_back(SharingMapTy(DKind, DirName, CurScope));
   }
 
   void pop() {
-    assert(Stack.size() > 1 && "Data-sharing attributes stack is empty!");
+    assert(Stack.size() > 1 && "Stack is empty!");
     Stack.pop_back();
   }
 
-  /// \brief If 'aligned' declaration for given variable \a D was not seen yet,
-  /// add it and return NULL; otherwise return previous occurrence's expression
-  /// for diagnostics.
-  DeclRefExpr *addUniqueAligned(VarDecl *D, DeclRefExpr *NewDE);
+  /// \brief Adds unique 'aligned' declaration of a given VarDecl, or,
+  /// if it already exists, returns false.
+  bool addUniqueAligned(VarDecl *D, DeclRefExpr *&E);
 
   /// \brief Adds explicit data sharing attribute to the specified declaration.
   void addDSA(VarDecl *D, DeclRefExpr *E, OpenMPClauseKind A);
 
+  /// \brief Adds explicit data sharing attribute to the specified declaration
+  /// to parent scope.
+  void addParentDSA(VarDecl *D, DeclRefExpr *E, OpenMPClauseKind A);
+
+  bool IsThreadprivate(VarDecl *D, DeclRefExpr *&E);
+
   /// \brief Returns data sharing attributes from top of the stack for the
   /// specified declaration.
-  DSAVarData getTopDSA(VarDecl *D, bool FromParent);
+  OpenMPClauseKind getTopDSA(VarDecl *D, DeclRefExpr *&E);
   /// \brief Returns data-sharing attributes for the specified declaration.
-  DSAVarData getImplicitDSA(VarDecl *D, bool FromParent);
-  /// \brief Checks if the specified variables has data-sharing attributes which
-  /// match specified \a CPred predicate in any directive which matches \a DPred
-  /// predicate.
-  template <class ClausesPredicate, class DirectivesPredicate>
-  DSAVarData hasDSA(VarDecl *D, ClausesPredicate CPred,
-                    DirectivesPredicate DPred, bool FromParent);
-  /// \brief Checks if the specified variables has data-sharing attributes which
-  /// match specified \a CPred predicate in any innermost directive which
-  /// matches \a DPred predicate.
-  template <class ClausesPredicate, class DirectivesPredicate>
-  DSAVarData hasInnermostDSA(VarDecl *D, ClausesPredicate CPred,
-                             DirectivesPredicate DPred,
-                             bool FromParent);
-  /// \brief Finds a directive which matches specified \a DPred predicate.
-  template <class NamedDirectivesPredicate>
-  bool hasDirective(NamedDirectivesPredicate DPred, bool FromParent);
+  OpenMPClauseKind getImplicitDSA(VarDecl *D, OpenMPDirectiveKind &Kind,
+                                  DeclRefExpr *&E);
+
+  /// \brief Checks if the specified variables has \a CKind data-sharing
+  /// attribute in \a DKind directive.
+  bool hasDSA(VarDecl *D, OpenMPClauseKind CKind, OpenMPDirectiveKind DKind,
+              DeclRefExpr *&E);
+
+  /// \brief Checks if the specified variables has \a CKind data-sharing
+  /// attribute in an innermost \a DKind directive.
+  bool hasInnermostDSA(VarDecl *D, OpenMPClauseKind CKind,
+                       OpenMPDirectiveKind DKind, DeclRefExpr *&E);
 
-  /// \brief Returns currently analyzed directive.
+  /// \brief Returns currently analized directive.
   OpenMPDirectiveKind getCurrentDirective() const {
     return Stack.back().Directive;
   }
+
   /// \brief Returns parent directive.
   OpenMPDirectiveKind getParentDirective() const {
     if (Stack.size() > 2)
@@ -170,80 +149,123 @@
     return OMPD_unknown;
   }
 
-  /// \brief Set default data sharing attribute to none.
-  void setDefaultDSANone(SourceLocation Loc) {
-    Stack.back().DefaultAttr = DSA_none;
-    Stack.back().DefaultAttrLoc = Loc;
+  /// \brief Returns true if region is an ordered parallel or
+  /// worksharing region.
+  bool isRegionOrdered() const {
+    if (Stack.size() > 1)
+      return Stack[Stack.size() - 1].IsOrdered;
+    return false;
   }
-  /// \brief Set default data sharing attribute to shared.
-  void setDefaultDSAShared(SourceLocation Loc) {
-    Stack.back().DefaultAttr = DSA_shared;
-    Stack.back().DefaultAttrLoc = Loc;
+
+  /// \brief Returns true if parent region is an ordered parallel or
+  /// worksharing region.
+  bool isParentRegionOrdered() const {
+    if (Stack.size() > 2)
+      return Stack[Stack.size() - 2].IsOrdered;
+    return false;
+  }
+
+  /// \brief Marks current regions as ordered.
+  void setRegionOrdered() { Stack.back().IsOrdered = true; }
+
+  /// \brief Returns true if region has nowait clause.
+  bool isRegionNowait() const {
+    if (Stack.size() > 1)
+      return Stack[Stack.size() - 1].IsNowait;
+    return false;
   }
 
-  DefaultDataSharingAttributes getDefaultDSA() const {
+  /// \brief Marks current regions as nowait.
+  void setRegionNowait() { Stack.back().IsNowait = true; }
+
+  /// \brief Checks if the specified kind of directive with the given name
+  /// already exists.
+  bool hasDirectiveWithName(OpenMPDirectiveKind Kind,
+                            DeclarationNameInfo DirName);
+
+  /// \brief Checks if the specified kind of directive exists.
+  bool hasDirective(OpenMPDirectiveKind Kind);
+
+  /// \brief Set default data sharing attribute to none.
+  void setDefaultDSANone() { Stack.back().DefaultAttr = DSA_none; }
+  /// \brief Set default data sharing attribute to shared.
+  void setDefaultDSAShared() { Stack.back().DefaultAttr = DSA_shared; }
+  DefaultDataSharingAttributes getDefaultDSA() {
     return Stack.back().DefaultAttr;
   }
-  SourceLocation getDefaultDSALocation() const {
-    return Stack.back().DefaultAttrLoc;
+
+  Scope *getCurScope() { return Stack.back().CurScope; }
+
+  DeclContext *GetOpenMPFunctionRegion();
+
+  void addDeclareTargetDecl(Decl *D) { DeclaredTargetDecls.insert(D); }
+
+  bool isDeclareTargetDecl(Decl *D) { return DeclaredTargetDecls.count(D); }
+
+  MapInfo getMapInfoForVar(VarDecl *VD) {
+    MapInfo Tmp = {0, false};
+    for (unsigned Cnt = Stack.size() - 1; Cnt > 0; --Cnt) {
+      if (Stack[Cnt].MappedDecls.count(VD)) {
+        Tmp = Stack[Cnt].MappedDecls[VD];
+        break;
+      }
+    }
+    return Tmp;
   }
 
-  /// \brief Checks if the specified variable is a threadprivate.
-  bool isThreadPrivate(VarDecl *D) {
-    DSAVarData DVar = getTopDSA(D, false);
-    return isOpenMPThreadPrivate(DVar.CKind);
+  void addMapInfoForVar(VarDecl *VD, MapInfo MI) {
+    if (Stack.size() > 1) {
+      Stack.back().MappedDecls[VD] = MI;
+    }
   }
 
-  Scope *getCurScope() const { return Stack.back().CurScope; }
-  Scope *getCurScope() { return Stack.back().CurScope; }
-  SourceLocation getConstructLoc() { return Stack.back().ConstructLoc; }
+  MapInfo IsMappedInCurrentRegion(VarDecl *VD) {
+    assert(Stack.size() > 1 && "Target level is 0");
+    MapInfo Tmp = {0, false};
+    if (Stack.size() > 1 && Stack.back().MappedDecls.count(VD)) {
+      Tmp = Stack.back().MappedDecls[VD];
+    }
+    return Tmp;
+  }
 };
-bool isParallelOrTaskRegion(OpenMPDirectiveKind DKind) {
-  return isOpenMPParallelDirective(DKind) || DKind == OMPD_task ||
-         DKind == OMPD_unknown;
-}
-} // namespace
-
-DSAStackTy::DSAVarData DSAStackTy::getDSA(StackTy::reverse_iterator Iter,
-                                          VarDecl *D) {
-  DSAVarData DVar;
-  if (Iter == std::prev(Stack.rend())) {
+} // end anonymous namespace.
+
+OpenMPClauseKind DSAStackTy::getDSA(StackTy::reverse_iterator Iter, VarDecl *D,
+                                    OpenMPDirectiveKind &Kind,
+                                    DeclRefExpr *&E) {
+  E = 0;
+  if (Iter == Stack.rend() - 1) {
+    Kind = OMPD_unknown;
     // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
     // in a region but not in construct]
     //  File-scope or namespace-scope variables referenced in called routines
     //  in the region are shared unless they appear in a threadprivate
     //  directive.
-    if (!D->isFunctionOrMethodVarDecl())
-      DVar.CKind = OMPC_shared;
+    if (!D->isFunctionOrMethodVarDecl() && D->getKind() != Decl::ParmVar)
+      return OMPC_shared;
 
     // OpenMP [2.9.1.2, Data-sharing Attribute Rules for Variables Referenced
     // in a region but not in construct]
     //  Variables with static storage duration that are declared in called
     //  routines in the region are shared.
     if (D->hasGlobalStorage())
-      DVar.CKind = OMPC_shared;
+      return OMPC_shared;
 
-    return DVar;
+    return OMPC_unknown;
   }
-
-  DVar.DKind = Iter->Directive;
   // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
   // in a Construct, C/C++, predetermined, p.1]
   // Variables with automatic storage duration that are declared in a scope
   // inside the construct are private.
+  Kind = Iter->Directive;
   if (isOpenMPLocal(D, Iter) && D->isLocalVarDecl() &&
-      (D->getStorageClass() == SC_Auto || D->getStorageClass() == SC_None)) {
-    DVar.CKind = OMPC_private;
-    return DVar;
-  }
-
+      (D->getStorageClass() == SC_Auto || D->getStorageClass() == SC_None))
+    return OMPC_private;
   // Explicitly specified attributes and local variables with predetermined
   // attributes.
   if (Iter->SharingMap.count(D)) {
-    DVar.RefExpr = Iter->SharingMap[D].RefExpr;
-    DVar.CKind = Iter->SharingMap[D].Attributes;
-    DVar.ImplicitDSALoc = Iter->DefaultAttrLoc;
-    return DVar;
+    E = Iter->SharingMap[D].RefExpr;
+    return Iter->SharingMap[D].Attributes;
   }
 
   // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
@@ -252,31 +274,37 @@
   //  variables are determined by the default clause, if present.
   switch (Iter->DefaultAttr) {
   case DSA_shared:
-    DVar.CKind = OMPC_shared;
-    DVar.ImplicitDSALoc = Iter->DefaultAttrLoc;
-    return DVar;
+    return OMPC_shared;
   case DSA_none:
-    return DVar;
+    return OMPC_unknown;
   case DSA_unspecified:
     // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
     // in a Construct, implicitly determined, p.2]
     //  In a parallel construct, if no default clause is present, these
     //  variables are shared.
-    DVar.ImplicitDSALoc = Iter->DefaultAttrLoc;
-    if (isOpenMPParallelDirective(DVar.DKind)) {
-      DVar.CKind = OMPC_shared;
-      return DVar;
-    }
+    if (Kind == OMPD_parallel || Kind == OMPD_teams ||
+        Kind == OMPD_parallel_for || Kind == OMPD_parallel_for_simd ||
+        Kind == OMPD_parallel_sections ||
+        Kind == OMPD_distribute_parallel_for ||
+        Kind == OMPD_distribute_parallel_for_simd ||
+        Kind == OMPD_teams_distribute_parallel_for ||
+        Kind == OMPD_teams_distribute_parallel_for_simd ||
+        Kind == OMPD_target_teams_distribute_parallel_for ||
+        Kind == OMPD_target_teams_distribute_parallel_for_simd ||
+        Kind == OMPD_target_teams || Kind == OMPD_teams_distribute ||
+        Kind == OMPD_teams_distribute_simd ||
+        Kind == OMPD_target_teams_distribute ||
+        Kind == OMPD_target_teams_distribute_simd)
+      return OMPC_shared;
 
     // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
     // in a Construct, implicitly determined, p.4]
     //  In a task construct, if no default clause is present, a variable that in
     //  the enclosing context is determined to be shared by all implicit tasks
     //  bound to the current team is shared.
-    if (DVar.DKind == OMPD_task) {
-      DSAVarData DVarTemp;
-      for (StackTy::reverse_iterator I = std::next(Iter),
-                                     EE = std::prev(Stack.rend());
+    if (Kind == OMPD_task) {
+      OpenMPClauseKind CKind = OMPC_unknown;
+      for (StackTy::reverse_iterator I = Iter + 1, EE = Stack.rend() - 1;
            I != EE; ++I) {
         // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables
         // Referenced
@@ -284,20 +312,26 @@
         //  In a task construct, if no default clause is present, a variable
         //  whose data-sharing attribute is not determined by the rules above is
         //  firstprivate.
-        DVarTemp = getDSA(I, D);
-        if (DVarTemp.CKind != OMPC_shared) {
-          DVar.RefExpr = nullptr;
-          DVar.DKind = OMPD_task;
-          DVar.CKind = OMPC_firstprivate;
-          return DVar;
+        CKind = getDSA(I, D, Kind, E);
+        if (CKind != OMPC_shared) {
+          E = 0;
+          Kind = OMPD_task;
+          return OMPC_firstprivate;
         }
-        if (isParallelOrTaskRegion(I->Directive))
+        if (I->Directive == OMPD_parallel ||
+            I->Directive == OMPD_parallel_for ||
+            I->Directive == OMPD_parallel_for_simd ||
+            I->Directive == OMPD_parallel_sections ||
+            I->Directive == OMPD_distribute_parallel_for ||
+            I->Directive == OMPD_distribute_parallel_for_simd ||
+            I->Directive == OMPD_teams_distribute_parallel_for ||
+            I->Directive == OMPD_teams_distribute_parallel_for_simd ||
+            I->Directive == OMPD_target_teams_distribute_parallel_for ||
+            I->Directive == OMPD_target_teams_distribute_parallel_for_simd)
           break;
       }
-      DVar.DKind = OMPD_task;
-      DVar.CKind =
-          (DVarTemp.CKind == OMPC_unknown) ? OMPC_firstprivate : OMPC_shared;
-      return DVar;
+      Kind = OMPD_task;
+      return (CKind == OMPC_unknown) ? OMPC_firstprivate : OMPC_shared;
     }
   }
   // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
@@ -305,21 +339,21 @@
   //  For constructs other than task, if no default clause is present, these
   //  variables inherit their data-sharing attributes from the enclosing
   //  context.
-  return getDSA(std::next(Iter), D);
+  return getDSA(Iter + 1, D, Kind, E);
 }
 
-DeclRefExpr *DSAStackTy::addUniqueAligned(VarDecl *D, DeclRefExpr *NewDE) {
+bool DSAStackTy::addUniqueAligned(VarDecl *D, DeclRefExpr *&E) {
   assert(Stack.size() > 1 && "Data sharing attributes stack is empty");
-  auto It = Stack.back().AlignedMap.find(D);
+  DeclSAMapTy::iterator It = Stack.back().AlignedMap.find(D);
   if (It == Stack.back().AlignedMap.end()) {
-    assert(NewDE && "Unexpected nullptr expr to be added into aligned map");
-    Stack.back().AlignedMap[D] = NewDE;
-    return nullptr;
+    Stack.back().AlignedMap[D].Attributes = OMPC_aligned;
+    Stack.back().AlignedMap[D].RefExpr = E;
+    return true;
   } else {
-    assert(It->second && "Unexpected nullptr expr in the aligned map");
-    return It->second;
+    assert(Stack.back().AlignedMap[D].Attributes == OMPC_aligned);
+    E = Stack.back().AlignedMap[D].RefExpr;
+    return false;
   }
-  return nullptr;
 }
 
 void DSAStackTy::addDSA(VarDecl *D, DeclRefExpr *E, OpenMPClauseKind A) {
@@ -327,22 +361,44 @@
     Stack[0].SharingMap[D].Attributes = A;
     Stack[0].SharingMap[D].RefExpr = E;
   } else {
-    assert(Stack.size() > 1 && "Data-sharing attributes stack is empty");
+    assert(Stack.size() > 1 && "Data sharing attributes stack is empty");
     Stack.back().SharingMap[D].Attributes = A;
     Stack.back().SharingMap[D].RefExpr = E;
   }
 }
 
+void DSAStackTy::addParentDSA(VarDecl *D, DeclRefExpr *E, OpenMPClauseKind A) {
+  assert(Stack.size() > 2 &&
+         "Data sharing attributes stack does not have parent");
+  Stack[Stack.size() - 2].SharingMap[D].Attributes = A;
+  Stack[Stack.size() - 2].SharingMap[D].RefExpr = E;
+}
+
 bool DSAStackTy::isOpenMPLocal(VarDecl *D, StackTy::reverse_iterator Iter) {
   if (Stack.size() > 2) {
-    reverse_iterator I = Iter, E = std::prev(Stack.rend());
-    Scope *TopScope = nullptr;
-    while (I != E && !isParallelOrTaskRegion(I->Directive)) {
+    reverse_iterator I = Iter, E = Stack.rend() - 1;
+    Scope *TopScope = 0;
+    while (I != E && I->Directive != OMPD_parallel &&
+           I->Directive != OMPD_parallel_for &&
+           I->Directive != OMPD_parallel_for_simd &&
+           I->Directive != OMPD_parallel_sections &&
+           I->Directive != OMPD_distribute_parallel_for &&
+           I->Directive != OMPD_distribute_parallel_for_simd &&
+           I->Directive != OMPD_teams_distribute_parallel_for &&
+           I->Directive != OMPD_teams_distribute_parallel_for_simd &&
+           I->Directive != OMPD_target_teams_distribute_parallel_for &&
+           I->Directive != OMPD_target_teams_distribute_parallel_for_simd &&
+           I->Directive != OMPD_task && I->Directive != OMPD_teams &&
+           I->Directive != OMPD_target_teams &&
+           I->Directive != OMPD_teams_distribute &&
+           I->Directive != OMPD_teams_distribute_simd &&
+           I->Directive != OMPD_target_teams_distribute &&
+           I->Directive != OMPD_target_teams_distribute_simd) {
       ++I;
     }
     if (I == E)
       return false;
-    TopScope = I->CurScope ? I->CurScope->getParent() : nullptr;
+    TopScope = I->CurScope ? I->CurScope->getParent() : 0;
     Scope *CurScope = getCurScope();
     while (CurScope != TopScope && !CurScope->isDeclScope(D)) {
       CurScope = CurScope->getParent();
@@ -352,58 +408,63 @@
   return false;
 }
 
-DSAStackTy::DSAVarData DSAStackTy::getTopDSA(VarDecl *D, bool FromParent) {
-  DSAVarData DVar;
+bool DSAStackTy::IsThreadprivate(VarDecl *D, DeclRefExpr *&E) {
+  E = 0;
+  if (D->getTLSKind() != VarDecl::TLS_None)
+    return true;
+  if (Stack[0].SharingMap.count(D)) {
+    E = Stack[0].SharingMap[D].RefExpr;
+    return true;
+  }
+  return false;
+}
+
+OpenMPClauseKind DSAStackTy::getTopDSA(VarDecl *D, DeclRefExpr *&E) {
+  E = 0;
 
   // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
   // in a Construct, C/C++, predetermined, p.1]
   //  Variables appearing in threadprivate directives are threadprivate.
-  if (D->getTLSKind() != VarDecl::TLS_None) {
-    DVar.CKind = OMPC_threadprivate;
-    return DVar;
-  }
-  if (Stack[0].SharingMap.count(D)) {
-    DVar.RefExpr = Stack[0].SharingMap[D].RefExpr;
-    DVar.CKind = OMPC_threadprivate;
-    return DVar;
-  }
+  if (IsThreadprivate(D, E))
+    return OMPC_threadprivate;
 
   // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
   // in a Construct, C/C++, predetermined, p.1]
   // Variables with automatic storage duration that are declared in a scope
   // inside the construct are private.
-  OpenMPDirectiveKind Kind =
-      FromParent ? getParentDirective() : getCurrentDirective();
-  auto StartI = std::next(Stack.rbegin());
-  auto EndI = std::prev(Stack.rend());
-  if (FromParent && StartI != EndI) {
-    StartI = std::next(StartI);
-  }
-  if (!isParallelOrTaskRegion(Kind)) {
-    if (isOpenMPLocal(D, StartI) && D->isLocalVarDecl() &&
-        (D->getStorageClass() == SC_Auto || D->getStorageClass() == SC_None)) {
-      DVar.CKind = OMPC_private;
-      return DVar;
-    }
+  OpenMPDirectiveKind Kind = getCurrentDirective();
+  if (Kind != OMPD_parallel && Kind != OMPD_parallel_for &&
+      Kind != OMPD_parallel_for_simd && Kind != OMPD_distribute_parallel_for &&
+      Kind != OMPD_distribute_parallel_for_simd &&
+      Kind != OMPD_teams_distribute_parallel_for &&
+      Kind != OMPD_teams_distribute_parallel_for_simd &&
+      Kind != OMPD_target_teams_distribute_parallel_for &&
+      Kind != OMPD_target_teams_distribute_parallel_for_simd &&
+      Kind != OMPD_task && Kind != OMPD_teams &&
+      Kind != OMPD_parallel_sections && Kind != OMPD_target_teams &&
+      Kind != OMPD_teams_distribute && Kind != OMPD_teams_distribute_simd &&
+      Kind != OMPD_target_teams_distribute &&
+      Kind != OMPD_target_teams_distribute_simd) {
+    if (isOpenMPLocal(D, Stack.rbegin() + 1) && D->isLocalVarDecl() &&
+        (D->getStorageClass() == SC_Auto || D->getStorageClass() == SC_None))
+      return OMPC_private;
   }
 
   // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
   // in a Construct, C/C++, predetermined, p.4]
-  //  Static data members are shared.
+  //  Static data memebers are shared.
   if (D->isStaticDataMember()) {
+    DeclRefExpr *E;
     // Variables with const-qualified type having no mutable member may be
-    // listed in a firstprivate clause, even if they are static data members.
-    DSAVarData DVarTemp = hasDSA(D, MatchesAnyClause(OMPC_firstprivate),
-                                 MatchesAlways(), FromParent);
-    if (DVarTemp.CKind == OMPC_firstprivate && DVarTemp.RefExpr)
-      return DVar;
-
-    DVar.CKind = OMPC_shared;
-    return DVar;
+    // listed
+    // in a firstprivate clause, even if they are static data members.
+    if (hasDSA(D, OMPC_firstprivate, OMPD_unknown, E) && E)
+      return OMPC_unknown;
+    return OMPC_shared;
   }
 
   QualType Type = D->getType().getNonReferenceType().getCanonicalType();
-  bool IsConstant = Type.isConstant(SemaRef.getASTContext());
+  bool IsConstant = Type.isConstant(Actions.getASTContext());
   while (Type->isArrayType()) {
     QualType ElemType = cast<ArrayType>(Type.getTypePtr())->getElementType();
     Type = ElemType.getNonReferenceType().getCanonicalType();
@@ -413,103 +474,111 @@
   //  Variables with const qualified type having no mutable member are
   //  shared.
   CXXRecordDecl *RD =
-      SemaRef.getLangOpts().CPlusPlus ? Type->getAsCXXRecordDecl() : nullptr;
+      Actions.getLangOpts().CPlusPlus ? Type->getAsCXXRecordDecl() : 0;
   if (IsConstant &&
-      !(SemaRef.getLangOpts().CPlusPlus && RD && RD->hasMutableFields())) {
+      !(Actions.getLangOpts().CPlusPlus && RD && RD->hasMutableFields())) {
+    DeclRefExpr *E;
     // Variables with const-qualified type having no mutable member may be
-    // listed in a firstprivate clause, even if they are static data members.
-    DSAVarData DVarTemp = hasDSA(D, MatchesAnyClause(OMPC_firstprivate),
-                                 MatchesAlways(), FromParent);
-    if (DVarTemp.CKind == OMPC_firstprivate && DVarTemp.RefExpr)
-      return DVar;
-
-    DVar.CKind = OMPC_shared;
-    return DVar;
+    // listed
+    // in a firstprivate clause, even if they are static data members.
+    if (hasDSA(D, OMPC_firstprivate, OMPD_unknown, E) && E)
+      return OMPC_unknown;
+    return OMPC_shared;
   }
 
   // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
   // in a Construct, C/C++, predetermined, p.7]
   //  Variables with static storage duration that are declared in a scope
   //  inside the construct are shared.
-  if (D->isStaticLocal()) {
-    DVar.CKind = OMPC_shared;
-    return DVar;
-  }
+  if (D->isStaticLocal())
+    return OMPC_shared;
 
   // Explicitly specified attributes and local variables with predetermined
   // attributes.
-  auto I = std::prev(StartI);
-  if (I->SharingMap.count(D)) {
-    DVar.RefExpr = I->SharingMap[D].RefExpr;
-    DVar.CKind = I->SharingMap[D].Attributes;
-    DVar.ImplicitDSALoc = I->DefaultAttrLoc;
+  if (Stack.back().SharingMap.count(D)) {
+    E = Stack.back().SharingMap[D].RefExpr;
+    return Stack.back().SharingMap[D].Attributes;
   }
 
-  return DVar;
+  return OMPC_unknown;
 }
 
-DSAStackTy::DSAVarData DSAStackTy::getImplicitDSA(VarDecl *D, bool FromParent) {
-  auto StartI = Stack.rbegin();
-  auto EndI = std::prev(Stack.rend());
-  if (FromParent && StartI != EndI) {
-    StartI = std::next(StartI);
-  }
-  return getDSA(StartI, D);
+OpenMPClauseKind DSAStackTy::getImplicitDSA(VarDecl *D,
+                                            OpenMPDirectiveKind &Kind,
+                                            DeclRefExpr *&E) {
+  return getDSA(Stack.rbegin() + 1, D, Kind, E);
 }
 
-template <class ClausesPredicate, class DirectivesPredicate>
-DSAStackTy::DSAVarData DSAStackTy::hasDSA(VarDecl *D, ClausesPredicate CPred,
-                                          DirectivesPredicate DPred,
-                                          bool FromParent) {
-  auto StartI = std::next(Stack.rbegin());
-  auto EndI = std::prev(Stack.rend());
-  if (FromParent && StartI != EndI) {
-    StartI = std::next(StartI);
-  }
-  for (auto I = StartI, EE = EndI; I != EE; ++I) {
-    if (!DPred(I->Directive) && !isParallelOrTaskRegion(I->Directive))
+bool DSAStackTy::hasDSA(VarDecl *D, OpenMPClauseKind CKind,
+                        OpenMPDirectiveKind DKind, DeclRefExpr *&E) {
+  for (StackTy::reverse_iterator I = Stack.rbegin() + 1, EE = Stack.rend() - 1;
+       I != EE; ++I) {
+    if (DKind != OMPD_unknown && DKind != I->Directive)
       continue;
-    DSAVarData DVar = getDSA(I, D);
-    if (CPred(DVar.CKind))
-      return DVar;
+    OpenMPDirectiveKind K;
+    if (getDSA(I, D, K, E) == CKind)
+      return true;
   }
-  return DSAVarData();
+  E = 0;
+  return false;
 }
 
-template <class ClausesPredicate, class DirectivesPredicate>
-DSAStackTy::DSAVarData
-DSAStackTy::hasInnermostDSA(VarDecl *D, ClausesPredicate CPred,
-                            DirectivesPredicate DPred, bool FromParent) {
-  auto StartI = std::next(Stack.rbegin());
-  auto EndI = std::prev(Stack.rend());
-  if (FromParent && StartI != EndI) {
-    StartI = std::next(StartI);
+bool DSAStackTy::hasInnermostDSA(VarDecl *D, OpenMPClauseKind CKind,
+                                 OpenMPDirectiveKind DKind, DeclRefExpr *&E) {
+  assert(DKind != OMPD_unknown && "Directive must be specified explicitly");
+  for (StackTy::reverse_iterator I = Stack.rbegin(), EE = Stack.rend() - 1;
+       I != EE; ++I) {
+    if (DKind != I->Directive)
+      continue;
+    if (getDSA(I, D, DKind, E) == CKind)
+      return true;
+    return false;
   }
-  for (auto I = StartI, EE = EndI; I != EE; ++I) {
-    if (!DPred(I->Directive))
-      break;
-    DSAVarData DVar = getDSA(I, D);
-    if (CPred(DVar.CKind))
-      return DVar;
-    return DSAVarData();
-  }
-  return DSAVarData();
-}
-
-template <class NamedDirectivesPredicate>
-bool DSAStackTy::hasDirective(NamedDirectivesPredicate DPred, bool FromParent) {
-  auto StartI = std::next(Stack.rbegin());
-  auto EndI = std::prev(Stack.rend());
-  if (FromParent && StartI != EndI) {
-    StartI = std::next(StartI);
+  return false;
+}
+
+bool DSAStackTy::hasDirectiveWithName(OpenMPDirectiveKind Kind,
+                                      DeclarationNameInfo DirName) {
+  for (reverse_iterator I = Stack.rbegin() + 1, E = Stack.rend() - 1; I != E;
+       ++I) {
+    if (I->Directive == Kind &&
+        !DeclarationName::compare(I->DirectiveName.getName(),
+                                  DirName.getName()))
+      return true;
   }
-  for (auto I = StartI, EE = EndI; I != EE; ++I) {
-    if (DPred(I->Directive, I->DirectiveName, I->ConstructLoc))
+  return false;
+}
+
+bool DSAStackTy::hasDirective(OpenMPDirectiveKind Kind) {
+  for (reverse_iterator I = Stack.rbegin(), E = Stack.rend() - 1; I != E; ++I) {
+    if (I->Directive == Kind)
       return true;
   }
   return false;
 }
 
+DeclContext *DSAStackTy::GetOpenMPFunctionRegion() {
+  for (reverse_iterator I = Stack.rbegin(), E = Stack.rend() - 1; I != E; ++I) {
+    if (I->Directive == OMPD_parallel || I->Directive == OMPD_parallel_for ||
+        I->Directive == OMPD_parallel_for_simd ||
+        I->Directive == OMPD_distribute_parallel_for ||
+        I->Directive == OMPD_distribute_parallel_for_simd ||
+        I->Directive == OMPD_teams_distribute_parallel_for ||
+        I->Directive == OMPD_teams_distribute_parallel_for_simd ||
+        I->Directive == OMPD_target_teams_distribute_parallel_for ||
+        I->Directive == OMPD_target_teams_distribute_parallel_for_simd ||
+        I->Directive == OMPD_teams || I->Directive == OMPD_task ||
+        I->Directive == OMPD_parallel_sections ||
+        I->Directive == OMPD_target_teams ||
+        I->Directive == OMPD_teams_distribute ||
+        I->Directive == OMPD_teams_distribute_simd ||
+        I->Directive == OMPD_target_teams_distribute ||
+        I->Directive == OMPD_target_teams_distribute_simd)
+      return I->CurScope->getEntity();
+  }
+  return 0;
+}
+
 void Sema::InitDataSharingAttributesStack() {
   VarDataSharingAttributesStack = new DSAStackTy(*this);
 }
@@ -518,36 +587,79 @@
 
 void Sema::DestroyDataSharingAttributesStack() { delete DSAStack; }
 
+bool Sema::HasOpenMPRegion(OpenMPDirectiveKind Kind) {
+  return DSAStack->hasDirective(Kind);
+}
+
+bool Sema::HasOpenMPSimdRegion() {
+  return HasOpenMPRegion(OMPD_simd) || HasOpenMPRegion(OMPD_for_simd) ||
+         HasOpenMPRegion(OMPD_parallel_for_simd) ||
+         HasOpenMPRegion(OMPD_distribute_simd) ||
+         HasOpenMPRegion(OMPD_for_simd) ||
+         HasOpenMPRegion(OMPD_distribute_parallel_for_simd) ||
+         HasOpenMPRegion(OMPD_teams_distribute_parallel_for_simd) ||
+         HasOpenMPRegion(OMPD_target_teams_distribute_parallel_for_simd) ||
+         HasOpenMPRegion(OMPD_teams_distribute_simd) ||
+         HasOpenMPRegion(OMPD_target_teams_distribute_simd);
+}
+
+bool Sema::IsDeclContextInOpenMPTarget(DeclContext *DC) {
+  while (DC && !isa<OMPDeclareTargetDecl>(DC)) {
+    DC = DC->getParent();
+  }
+  return DC != 0;
+}
+
+DeclContext *Sema::GetOpenMPFunctionRegion() {
+  return DSAStack->GetOpenMPFunctionRegion();
+}
+
 void Sema::StartOpenMPDSABlock(OpenMPDirectiveKind DKind,
                                const DeclarationNameInfo &DirName,
-                               Scope *CurScope, SourceLocation Loc) {
-  DSAStack->push(DKind, DirName, CurScope, Loc);
+                               Scope *CurScope) {
+  DSAStack->push(DKind, DirName, CurScope);
+
   PushExpressionEvaluationContext(PotentiallyEvaluated);
 }
 
 void Sema::EndOpenMPDSABlock(Stmt *CurDirective) {
-  // OpenMP [2.14.3.5, Restrictions, C/C++, p.1]
+  //  if (!getCurScope()->isOpenMPDirectiveScope()) return;
+  // OpenMP [2.9.3.5, Restrictions, C/C++, p.1]
   //  A variable of class type (or array thereof) that appears in a lastprivate
   //  clause requires an accessible, unambiguous default constructor for the
   //  class type, unless the list item is also specified in a firstprivate
   //  clause.
-  if (auto D = dyn_cast_or_null<OMPExecutableDirective>(CurDirective)) {
-    for (auto C : D->clauses()) {
-      if (auto Clause = dyn_cast<OMPLastprivateClause>(C)) {
-        for (auto VarRef : Clause->varlists()) {
-          if (VarRef->isValueDependent() || VarRef->isTypeDependent())
+
+  if (OMPExecutableDirective *D =
+          dyn_cast_or_null<OMPExecutableDirective>(CurDirective)) {
+    for (ArrayRef<OMPClause *>::iterator I = D->clauses().begin(),
+                                         E = D->clauses().end();
+         I != E; ++I) {
+      if (OMPLastPrivateClause *Clause = dyn_cast<OMPLastPrivateClause>(*I)) {
+        SmallVector<Expr *, 4> DefaultInits;
+        ArrayRef<Expr *>::iterator PVIter = Clause->getPseudoVars1().begin();
+        for (OMPLastPrivateClause::varlist_iterator
+                 VI = Clause->varlist_begin(),
+                 VE = Clause->varlist_end();
+             VI != VE; ++VI, ++PVIter) {
+          if ((*VI)->isValueDependent() || (*VI)->isTypeDependent() ||
+              (*VI)->isInstantiationDependent() ||
+              (*VI)->containsUnexpandedParameterPack()) {
+            DefaultInits.push_back(0);
             continue;
-          auto VD = cast<VarDecl>(cast<DeclRefExpr>(VarRef)->getDecl());
-          auto DVar = DSAStack->getTopDSA(VD, false);
-          if (DVar.CKind == OMPC_lastprivate) {
-            SourceLocation ELoc = VarRef->getExprLoc();
-            auto Type = VarRef->getType();
-            if (Type->isArrayType())
-              Type = QualType(Type->getArrayElementTypeNoTypeQual(), 0);
+          }
+          DeclRefExpr *DE;
+          VarDecl *VD = cast<VarDecl>(cast<DeclRefExpr>(*VI)->getDecl());
+          QualType Type = (*VI)->getType().getCanonicalType();
+          if (DSAStack->getTopDSA(VD, DE) == OMPC_lastprivate) {
+            SourceLocation ELoc = (*VI)->getExprLoc();
+            while (Type->isArrayType()) {
+              QualType ElemType =
+                  cast<ArrayType>(Type.getTypePtr())->getElementType();
+              Type = ElemType.getNonReferenceType().getCanonicalType();
+            }
             CXXRecordDecl *RD =
-                getLangOpts().CPlusPlus ? Type->getAsCXXRecordDecl() : nullptr;
-            // FIXME This code must be replaced by actual constructing of the
-            // lastprivate variable.
+                getLangOpts().CPlusPlus ? Type->getAsCXXRecordDecl() : 0;
             if (RD) {
               CXXConstructorDecl *CD = LookupDefaultConstructor(RD);
               PartialDiagnostic PD =
@@ -570,8 +682,24 @@
               MarkFunctionReferenced(ELoc, CD);
               DiagnoseUseOfDecl(CD, ELoc);
             }
+            VD = cast<VarDecl>(cast<DeclRefExpr>(*PVIter)->getDecl());
+            InitializedEntity Entity =
+                InitializedEntity::InitializeVariable(VD);
+            InitializationKind InitKind =
+                InitializationKind::CreateDefault(ELoc);
+            InitializationSequence InitSeq(*this, Entity, InitKind,
+                                           MultiExprArg());
+            ExprResult Res =
+                InitSeq.Perform(*this, Entity, InitKind, MultiExprArg());
+            if (Res.isInvalid())
+              continue;
+            DefaultInits.push_back(ActOnFinishFullExpr(Res.get()).get());
+          } else {
+            DefaultInits.push_back(0);
           }
         }
+        if (DefaultInits.size() == Clause->numberOfVariables())
+          Clause->setDefaultInits(DefaultInits);
       }
     }
   }
@@ -582,24 +710,23 @@
 }
 
 namespace {
-
 class VarDeclFilterCCC : public CorrectionCandidateCallback {
 private:
-  Sema &SemaRef;
+  Sema &Actions;
 
 public:
-  explicit VarDeclFilterCCC(Sema &S) : SemaRef(S) {}
-  bool ValidateCandidate(const TypoCorrection &Candidate) override {
+  VarDeclFilterCCC(Sema &S) : Actions(S) {}
+  virtual bool ValidateCandidate(const TypoCorrection &Candidate) {
     NamedDecl *ND = Candidate.getCorrectionDecl();
     if (VarDecl *VD = dyn_cast_or_null<VarDecl>(ND)) {
       return VD->hasGlobalStorage() &&
-             SemaRef.isDeclInScope(ND, SemaRef.getCurLexicalContext(),
-                                   SemaRef.getCurScope());
+             Actions.isDeclInScope(ND, Actions.getCurLexicalContext(),
+                                   Actions.getCurScope());
     }
     return false;
   }
 };
-} // namespace
+}
 
 ExprResult Sema::ActOnOpenMPIdExpression(Scope *CurScope,
                                          CXXScopeSpec &ScopeSpec,
@@ -650,58 +777,24 @@
     return ExprError();
   }
 
-  VarDecl *CanonicalVD = VD->getCanonicalDecl();
-  NamedDecl *ND = cast<NamedDecl>(CanonicalVD);
   // OpenMP [2.9.2, Restrictions, C/C++, p.2]
   //   A threadprivate directive for file-scope variables must appear outside
   //   any definition or declaration.
-  if (CanonicalVD->getDeclContext()->isTranslationUnit() &&
-      !getCurLexicalContext()->isTranslationUnit()) {
-    Diag(Id.getLoc(), diag::err_omp_var_scope)
-        << getOpenMPDirectiveName(OMPD_threadprivate) << VD;
-    bool IsDecl =
-        VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
-    Diag(VD->getLocation(),
-         IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-        << VD;
-    return ExprError();
-  }
   // OpenMP [2.9.2, Restrictions, C/C++, p.3]
   //   A threadprivate directive for static class member variables must appear
   //   in the class definition, in the same scope in which the member
   //   variables are declared.
-  if (CanonicalVD->isStaticDataMember() &&
-      !CanonicalVD->getDeclContext()->Equals(getCurLexicalContext())) {
-    Diag(Id.getLoc(), diag::err_omp_var_scope)
-        << getOpenMPDirectiveName(OMPD_threadprivate) << VD;
-    bool IsDecl =
-        VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
-    Diag(VD->getLocation(),
-         IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-        << VD;
-    return ExprError();
-  }
   // OpenMP [2.9.2, Restrictions, C/C++, p.4]
   //   A threadprivate directive for namespace-scope variables must appear
   //   outside any definition or declaration other than the namespace
   //   definition itself.
-  if (CanonicalVD->getDeclContext()->isNamespace() &&
-      (!getCurLexicalContext()->isFileContext() ||
-       !getCurLexicalContext()->Encloses(CanonicalVD->getDeclContext()))) {
-    Diag(Id.getLoc(), diag::err_omp_var_scope)
-        << getOpenMPDirectiveName(OMPD_threadprivate) << VD;
-    bool IsDecl =
-        VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
-    Diag(VD->getLocation(),
-         IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-        << VD;
-    return ExprError();
-  }
   // OpenMP [2.9.2, Restrictions, C/C++, p.6]
   //   A threadprivate directive for static block-scope variables must appear
   //   in the scope of the variable and not in a nested scope.
-  if (CanonicalVD->isStaticLocal() && CurScope &&
-      !isDeclInScope(ND, getCurLexicalContext(), CurScope)) {
+  NamedDecl *ND = cast<NamedDecl>(VD);
+  if ((!getCurLexicalContext()->isFileContext() ||
+       !VD->getDeclContext()->isFileContext()) &&
+      !isDeclInScope(ND, getCurLexicalContext(), getCurScope())) {
     Diag(Id.getLoc(), diag::err_omp_var_scope)
         << getOpenMPDirectiveName(OMPD_threadprivate) << VD;
     bool IsDecl =
@@ -730,46 +823,19 @@
 Sema::ActOnOpenMPThreadprivateDirective(SourceLocation Loc,
                                         ArrayRef<Expr *> VarList) {
   if (OMPThreadPrivateDecl *D = CheckOMPThreadPrivateDecl(Loc, VarList)) {
+    D->setAccess(AS_public);
     CurContext->addDecl(D);
     return DeclGroupPtrTy::make(DeclGroupRef(D));
   }
   return DeclGroupPtrTy();
 }
 
-namespace {
-class LocalVarRefChecker : public ConstStmtVisitor<LocalVarRefChecker, bool> {
-  Sema &SemaRef;
-
-public:
-  bool VisitDeclRefExpr(const DeclRefExpr *E) {
-    if (auto VD = dyn_cast<VarDecl>(E->getDecl())) {
-      if (VD->hasLocalStorage()) {
-        SemaRef.Diag(E->getLocStart(),
-                     diag::err_omp_local_var_in_threadprivate_init)
-            << E->getSourceRange();
-        SemaRef.Diag(VD->getLocation(), diag::note_defined_here)
-            << VD << VD->getSourceRange();
-        return true;
-      }
-    }
-    return false;
-  }
-  bool VisitStmt(const Stmt *S) {
-    for (auto Child : S->children()) {
-      if (Child && Visit(Child))
-        return true;
-    }
-    return false;
-  }
-  explicit LocalVarRefChecker(Sema &SemaRef) : SemaRef(SemaRef) {}
-};
-} // namespace
-
 OMPThreadPrivateDecl *
 Sema::CheckOMPThreadPrivateDecl(SourceLocation Loc, ArrayRef<Expr *> VarList) {
-  SmallVector<Expr *, 8> Vars;
-  for (auto &RefExpr : VarList) {
-    DeclRefExpr *DE = cast<DeclRefExpr>(RefExpr);
+  SmallVector<Expr *, 4> Vars;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    DeclRefExpr *DE = cast<DeclRefExpr>(*I);
     VarDecl *VD = cast<VarDecl>(DE->getDecl());
     SourceLocation ILoc = DE->getExprLoc();
 
@@ -804,704 +870,1536 @@
       continue;
     }
 
-    // Check if initial value of threadprivate variable reference variable with
-    // local storage (it is not supported by runtime).
-    if (auto Init = VD->getAnyInitializer()) {
-      LocalVarRefChecker Checker(*this);
-      if (Checker.Visit(Init))
+    QualType Type = VD->getType().getNonReferenceType().getCanonicalType();
+    while (Type->isArrayType()) {
+      QualType ElemType = cast<ArrayType>(Type.getTypePtr())->getElementType();
+      Type = ElemType.getNonReferenceType().getCanonicalType();
+    }
+    CXXRecordDecl *RD =
+        getLangOpts().CPlusPlus ? Type->getAsCXXRecordDecl() : 0;
+    if (RD) {
+      SourceLocation ELoc = (*I)->getExprLoc();
+      CXXDestructorDecl *DD = RD->getDestructor();
+      PartialDiagnostic PD =
+          PartialDiagnostic(PartialDiagnostic::NullDiagnostic());
+      if (DD && (CheckDestructorAccess(ELoc, DD, PD) == AR_inaccessible ||
+                 DD->isDeleted())) {
+        Diag(ELoc, diag::err_omp_required_method)
+            << getOpenMPClauseName(OMPC_threadprivate) << 4;
+        bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
+                      VarDecl::DeclarationOnly;
+        Diag(VD->getLocation(),
+             IsDecl ? diag::note_previous_decl : diag::note_defined_here)
+            << VD;
+        Diag(RD->getLocation(), diag::note_previous_decl) << RD;
         continue;
+      } else if (DD) {
+        MarkFunctionReferenced(ELoc, DD);
+        DiagnoseUseOfDecl(DD, ELoc);
+      }
     }
 
-    Vars.push_back(RefExpr);
     DSAStack->addDSA(VD, DE, OMPC_threadprivate);
+    Vars.push_back(*I);
   }
-  OMPThreadPrivateDecl *D = nullptr;
-  if (!Vars.empty()) {
-    D = OMPThreadPrivateDecl::Create(Context, getCurLexicalContext(), Loc,
-                                     Vars);
+  return Vars.empty() ? 0 : OMPThreadPrivateDecl::Create(
+                                Context, getCurLexicalContext(), Loc, Vars);
+}
+
+Sema::DeclGroupPtrTy Sema::ActOnOpenMPDeclareSimdDirective(
+    SourceLocation Loc, Decl *FuncDecl, ArrayRef<SourceRange> SrcRanges,
+    ArrayRef<unsigned> BeginIdx, ArrayRef<unsigned> EndIdx,
+    ArrayRef<OMPClause *> CL) {
+  DeclContext *CurDC = getCurLexicalContext();
+  if (OMPDeclareSimdDecl *D = CheckOMPDeclareSimdDecl(
+          Loc, FuncDecl, SrcRanges, BeginIdx, EndIdx, CL, CurDC)) {
     D->setAccess(AS_public);
+    CurContext->addDecl(D);
+    if (FunctionTemplateDecl *FTDecl =
+            dyn_cast<FunctionTemplateDecl>(FuncDecl)) {
+      OMPDSimdMap[FTDecl] = D;
+    }
+    return DeclGroupPtrTy::make(DeclGroupRef(D));
   }
-  return D;
+  return DeclGroupPtrTy();
 }
 
-static void ReportOriginalDSA(Sema &SemaRef, DSAStackTy *Stack,
-                              const VarDecl *VD, DSAStackTy::DSAVarData DVar,
-                              bool IsLoopIterVar = false) {
-  if (DVar.RefExpr) {
-    SemaRef.Diag(DVar.RefExpr->getExprLoc(), diag::note_omp_explicit_dsa)
-        << getOpenMPClauseName(DVar.CKind);
-    return;
-  }
-  enum {
-    PDSA_StaticMemberShared,
-    PDSA_StaticLocalVarShared,
-    PDSA_LoopIterVarPrivate,
-    PDSA_LoopIterVarLinear,
-    PDSA_LoopIterVarLastprivate,
-    PDSA_ConstVarShared,
-    PDSA_GlobalVarShared,
-    PDSA_TaskVarFirstprivate,
-    PDSA_LocalVarPrivate,
-    PDSA_Implicit
-  } Reason = PDSA_Implicit;
-  bool ReportHint = false;
-  auto ReportLoc = VD->getLocation();
-  if (IsLoopIterVar) {
-    if (DVar.CKind == OMPC_private)
-      Reason = PDSA_LoopIterVarPrivate;
-    else if (DVar.CKind == OMPC_lastprivate)
-      Reason = PDSA_LoopIterVarLastprivate;
-    else
-      Reason = PDSA_LoopIterVarLinear;
-  } else if (DVar.DKind == OMPD_task && DVar.CKind == OMPC_firstprivate) {
-    Reason = PDSA_TaskVarFirstprivate;
-    ReportLoc = DVar.ImplicitDSALoc;
-  } else if (VD->isStaticLocal())
-    Reason = PDSA_StaticLocalVarShared;
-  else if (VD->isStaticDataMember())
-    Reason = PDSA_StaticMemberShared;
-  else if (VD->isFileVarDecl())
-    Reason = PDSA_GlobalVarShared;
-  else if (VD->getType().isConstant(SemaRef.getASTContext()))
-    Reason = PDSA_ConstVarShared;
-  else if (VD->isLocalVarDecl() && DVar.CKind == OMPC_private) {
-    ReportHint = true;
-    Reason = PDSA_LocalVarPrivate;
-  }
-  if (Reason != PDSA_Implicit) {
-    SemaRef.Diag(ReportLoc, diag::note_omp_predetermined_dsa)
-        << Reason << ReportHint
-        << getOpenMPDirectiveName(Stack->getCurrentDirective());
-  } else if (DVar.ImplicitDSALoc.isValid()) {
-    SemaRef.Diag(DVar.ImplicitDSALoc, diag::note_omp_implicit_dsa)
-        << getOpenMPClauseName(DVar.CKind);
+OMPDeclareSimdDecl *Sema::CheckOMPDeclareSimdDecl(
+    SourceLocation Loc, Decl *FuncDecl, ArrayRef<SourceRange> SrcRanges,
+    ArrayRef<unsigned> BeginIdx, ArrayRef<unsigned> EndIdx,
+    ArrayRef<OMPClause *> CL, DeclContext *CurDC) {
+  // Checks the clauses and their arguments.
+  //
+  typedef llvm::SmallDenseMap<VarDecl *, SourceLocation, 64> SeenVarMap;
+  SeenVarMap SeenVarsLinear, SeenVarsAligned;
+  // Build NewBeginIdx/NewEndIdx to remove the dead (NULL) clauses.
+  //
+  SmallVector<unsigned, 4> NewBeginIdx;
+  SmallVector<unsigned, 4> NewEndIdx;
+  SmallVector<OMPClause *, 4> NewCL;
+  unsigned NumDeadClauses = 0;
+  for (unsigned J = 0; J < BeginIdx.size(); ++J) {
+    unsigned BeginI = BeginIdx[J];
+    unsigned EndI = EndIdx[J];
+    SeenVarsLinear.clear();
+    SeenVarsAligned.clear();
+    bool hasInBranch = false;
+    bool hasNotInBranch = false;
+    SourceLocation PrevLocInBranch;
+    NewBeginIdx.push_back(BeginI - NumDeadClauses);
+    // Walk the current variant's clauses.
+    for (unsigned Idx = BeginI; Idx < EndI; ++Idx) {
+      OMPClause *Clause = CL[Idx];
+      if (OMPUniformClause *C = dyn_cast_or_null<OMPUniformClause>(Clause)) {
+        for (OMPUniformClause::varlist_iterator I = C->varlist_begin(),
+                                                E = C->varlist_end();
+             I != E; ++I) {
+          DeclRefExpr *DE = cast<DeclRefExpr>(*I);
+          VarDecl *VD = cast<VarDecl>(DE->getDecl());
+          SeenVarMap::iterator SVI = SeenVarsLinear.find(VD);
+          if (SVI != SeenVarsLinear.end()) {
+            Diag(DE->getLocation(),
+                 diag::err_omp_at_most_one_uniform_or_linear);
+            Diag(SVI->second, diag::note_omp_referenced);
+          } else {
+            SeenVarsLinear.insert(std::make_pair(VD, DE->getLocation()));
+          }
+        }
+      } else if (OMPLinearClause *C =
+                     dyn_cast_or_null<OMPLinearClause>(Clause)) {
+        for (OMPLinearClause::varlist_iterator I = C->varlist_begin(),
+                                               E = C->varlist_end();
+             I != E; ++I) {
+          DeclRefExpr *DE = cast<DeclRefExpr>(*I);
+          VarDecl *VD = cast<VarDecl>(DE->getDecl());
+          SeenVarMap::iterator SVI = SeenVarsLinear.find(VD);
+          if (SVI != SeenVarsLinear.end()) {
+            Diag(DE->getLocation(),
+                 diag::err_omp_at_most_one_uniform_or_linear);
+            Diag(SVI->second, diag::note_omp_referenced);
+          } else {
+            SeenVarsLinear.insert(std::make_pair(VD, DE->getLocation()));
+          }
+        }
+      } else if (OMPAlignedClause *C =
+                     dyn_cast_or_null<OMPAlignedClause>(Clause)) {
+        for (OMPAlignedClause::varlist_iterator I = C->varlist_begin(),
+                                                E = C->varlist_end();
+             I != E; ++I) {
+          DeclRefExpr *DE = cast<DeclRefExpr>(*I);
+          VarDecl *VD = cast<VarDecl>(DE->getDecl());
+          SeenVarMap::iterator SVI = SeenVarsAligned.find(VD);
+          if (SVI != SeenVarsAligned.end()) {
+            Diag(DE->getLocation(), diag::err_omp_at_most_one_aligned);
+            Diag(SVI->second, diag::note_omp_referenced);
+          } else {
+            SeenVarsAligned.insert(std::make_pair(VD, DE->getLocation()));
+          }
+        }
+      } else if (OMPInBranchClause *C =
+                     dyn_cast_or_null<OMPInBranchClause>(Clause)) {
+        if (hasNotInBranch) {
+          Diag(C->getLocStart(), diag::err_omp_inbranch);
+          Diag(PrevLocInBranch, diag::note_omp_specified);
+          Clause = 0;
+        }
+        hasInBranch = true;
+        PrevLocInBranch = C->getLocStart();
+      } else if (OMPNotInBranchClause *C =
+                     dyn_cast_or_null<OMPNotInBranchClause>(Clause)) {
+        if (hasInBranch) {
+          Diag(C->getLocStart(), diag::err_omp_inbranch);
+          Diag(PrevLocInBranch, diag::note_omp_specified);
+          Clause = 0;
+        }
+        hasNotInBranch = true;
+        PrevLocInBranch = C->getLocStart();
+      }
+      if (Clause == 0) {
+        ++NumDeadClauses;
+      } else {
+        NewCL.push_back(Clause);
+      }
+    }
+    NewEndIdx.push_back(EndI - NumDeadClauses);
   }
-}
 
-namespace {
-class DSAAttrChecker : public StmtVisitor<DSAAttrChecker, void> {
-  DSAStackTy *Stack;
-  Sema &SemaRef;
-  bool ErrorFound;
-  CapturedStmt *CS;
-  llvm::SmallVector<Expr *, 8> ImplicitFirstprivate;
-  llvm::DenseMap<VarDecl *, Expr *> VarsWithInheritedDSA;
+  OMPDeclareSimdDecl *D = OMPDeclareSimdDecl::Create(
+      Context, CurDC, Loc, FuncDecl, SrcRanges.size(), NewCL);
+  CompleteOMPDeclareSimdDecl(D, SrcRanges, NewBeginIdx, NewEndIdx);
+  return D;
+}
 
-public:
-  void VisitDeclRefExpr(DeclRefExpr *E) {
-    if (auto *VD = dyn_cast<VarDecl>(E->getDecl())) {
-      // Skip internally declared variables.
-      if (VD->isLocalVarDecl() && !CS->capturesVariable(VD))
-        return;
+void Sema::CompleteOMPDeclareSimdDecl(OMPDeclareSimdDecl *D,
+                                      ArrayRef<SourceRange> SrcRanges,
+                                      ArrayRef<unsigned> BeginIdx,
+                                      ArrayRef<unsigned> EndIdx) {
+  SmallVector<OMPDeclareSimdDecl::SimdVariant, 4> Data;
+  ArrayRef<SourceRange>::iterator IS = SrcRanges.begin();
+  ArrayRef<unsigned>::iterator IB = BeginIdx.begin();
+  ArrayRef<unsigned>::iterator IE = EndIdx.begin();
+  for (ArrayRef<SourceRange>::iterator ES = SrcRanges.end(); IS != ES;
+       ++IS, ++IB, ++IE) {
+    Data.push_back(OMPDeclareSimdDecl::SimdVariant(*IS, *IB, *IE));
+  }
+  D->setVariants(Data);
+}
+
+OMPDeclareReductionDecl *Sema::OMPDeclareReductionRAII::InitDeclareReduction(
+    Scope *CS, DeclContext *DC, SourceLocation Loc, DeclarationName Name,
+    unsigned NumTypes, AccessSpecifier AS) {
+  OMPDeclareReductionDecl *D =
+      OMPDeclareReductionDecl::Create(S.Context, DC, Loc, Name, NumTypes);
+  if (CS)
+    S.PushOnScopeChains(D, CS);
+  else
+    DC->addDecl(D);
+  D->setAccess(AS);
+  return D;
+}
 
-      auto DVar = Stack->getTopDSA(VD, false);
-      // Check if the variable has explicit DSA set and stop analysis if it so.
-      if (DVar.RefExpr) return;
+Decl *Sema::OMPDeclareReductionRAII::getDecl() { return D; }
 
-      auto ELoc = E->getExprLoc();
-      auto DKind = Stack->getCurrentDirective();
-      // The default(none) clause requires that each variable that is referenced
-      // in the construct, and does not have a predetermined data-sharing
-      // attribute, must have its data-sharing attribute explicitly determined
-      // by being listed in a data-sharing attribute clause.
-      if (DVar.CKind == OMPC_unknown && Stack->getDefaultDSA() == DSA_none &&
-          isParallelOrTaskRegion(DKind) &&
-          VarsWithInheritedDSA.count(VD) == 0) {
-        VarsWithInheritedDSA[VD] = E;
-        return;
-      }
+Sema::OMPDeclareReductionRAII::OMPDeclareReductionRAII(
+    Sema &S, Scope *CS, DeclContext *DC, SourceLocation Loc, DeclarationName DN,
+    unsigned NumTypes, AccessSpecifier AS)
+    : S(S), D(InitDeclareReduction(CS, DC, Loc, DN, NumTypes, AS)),
+      SavedContext(S, D) {}
+
+FunctionDecl *
+Sema::OMPDeclareReductionFunctionScope::ActOnOMPDeclareReductionFunction(
+    Sema &S, SourceLocation Loc, DeclarationName Name, QualType QTy) {
+  QualType PtrQTy = S.Context.getPointerType(QTy);
+  QualType Args[] = {PtrQTy, PtrQTy};
+  FunctionProtoType::ExtProtoInfo EPI;
+  QualType FuncType = S.Context.getFunctionType(S.Context.VoidTy, Args, EPI);
+  TypeSourceInfo *TI = S.Context.getTrivialTypeSourceInfo(FuncType);
+  FunctionTypeLoc FTL = TI->getTypeLoc().getAs<FunctionTypeLoc>();
+  FunctionDecl *FD =
+      FunctionDecl::Create(S.Context, S.CurContext, Loc, Loc, Name, FuncType,
+                           TI, SC_PrivateExtern, false, false);
+  FD->setImplicit();
+  S.CurContext->addDecl(FD);
+  if (S.CurContext->isDependentContext()) {
+    DeclContext *DC = S.CurContext->getParent();
+    TemplateParameterList *TPL = 0;
+    if (ClassTemplatePartialSpecializationDecl *CTPSD =
+            dyn_cast<ClassTemplatePartialSpecializationDecl>(DC)) {
+      TPL = CTPSD->getTemplateParameters();
+    } else if (CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(DC)) {
+      TPL = RD->getDescribedClassTemplate()
+                ->getCanonicalDecl()
+                ->getTemplateParameters();
+    } else if (FunctionDecl *RD = dyn_cast<FunctionDecl>(DC)) {
+      TPL = RD->getDescribedFunctionTemplate()
+                ->getCanonicalDecl()
+                ->getTemplateParameters();
+    }
+    FunctionTemplateDecl *FTD = FunctionTemplateDecl::Create(
+        S.Context, S.CurContext, Loc, Name, TPL, FD);
+    FD->setDescribedFunctionTemplate(FTD);
+  }
+  ParLHS = ParmVarDecl::Create(S.Context, FD, Loc, Loc, 0, PtrQTy,
+                               S.Context.getTrivialTypeSourceInfo(PtrQTy),
+                               SC_None, 0);
+  ParLHS->setScopeInfo(0, 0);
+  ParRHS = ParmVarDecl::Create(S.Context, FD, Loc, Loc, 0, PtrQTy,
+                               S.Context.getTrivialTypeSourceInfo(PtrQTy),
+                               SC_None, 0);
+  ParRHS->setScopeInfo(0, 1);
+  ParmVarDecl *Params[] = {ParLHS, ParRHS};
+  FD->setParams(Params);
+  FTL.setParam(0, ParLHS);
+  FTL.setParam(1, ParRHS);
+  OmpIn =
+      VarDecl::Create(S.Context, FD, Loc, Loc, &S.Context.Idents.get("omp_in"),
+                      QTy, S.Context.getTrivialTypeSourceInfo(QTy), SC_Auto);
+  OmpOut =
+      VarDecl::Create(S.Context, FD, Loc, Loc, &S.Context.Idents.get("omp_out"),
+                      QTy, S.Context.getTrivialTypeSourceInfo(QTy), SC_Auto);
+  S.AddKnownFunctionAttributes(FD);
+  if (S.CurScope) {
+    S.PushFunctionScope();
+    S.PushDeclContext(S.CurScope, FD);
+    S.PushOnScopeChains(OmpOut, S.CurScope);
+    S.PushOnScopeChains(OmpIn, S.CurScope);
+    S.PushExpressionEvaluationContext(PotentiallyEvaluated);
+  } else {
+    S.CurContext = FD;
+    FD->addDecl(OmpIn);
+    FD->addDecl(OmpOut);
+  }
+  ExprResult LHS =
+      S.BuildDeclRefExpr(ParLHS, ParLHS->getType(), VK_LValue, Loc);
+  ExprResult RHS =
+      S.BuildDeclRefExpr(ParRHS, ParRHS->getType(), VK_LValue, Loc);
+  LHS = S.DefaultLvalueConversion(LHS.get());
+  RHS = S.DefaultLvalueConversion(RHS.get());
+  LHS = S.CreateBuiltinUnaryOp(Loc, UO_Deref, LHS.get());
+  RHS = S.CreateBuiltinUnaryOp(Loc, UO_Deref, RHS.get());
+  LHS = S.ActOnFinishFullExpr(LHS.get());
+  RHS = S.ActOnFinishFullExpr(RHS.get());
+  S.AddInitializerToDecl(OmpOut, LHS.get(), true, false);
+  S.AddInitializerToDecl(OmpIn, RHS.get(), true, false);
+  return FD;
+}
+
+void Sema::OMPDeclareReductionFunctionScope::setBody(Expr *E) {
+  if (!E) {
+    FD->setBody(S.ActOnNullStmt(SourceLocation()).get());
+    FD->setInvalidDecl();
+    return;
+  }
+  StmtResult S1 = S.ActOnDeclStmt(DeclGroupPtrTy::make(DeclGroupRef(OmpIn)),
+                                  E->getExprLoc(), E->getExprLoc());
+  StmtResult S2 = S.ActOnDeclStmt(DeclGroupPtrTy::make(DeclGroupRef(OmpOut)),
+                                  E->getExprLoc(), E->getExprLoc());
+  ExprResult S3 = S.IgnoredValueConversions(E);
+  ExprResult LHS =
+      S.BuildDeclRefExpr(ParLHS, ParLHS->getType(), VK_LValue, E->getExprLoc());
+  LHS = S.DefaultLvalueConversion(LHS.get());
+  LHS = S.CreateBuiltinUnaryOp(E->getExprLoc(), UO_Deref, LHS.get());
+  ExprResult RHS =
+      S.BuildDeclRefExpr(OmpOut, OmpOut->getType(), VK_LValue, E->getExprLoc());
+  ExprResult Res =
+      S.BuildBinOp(0, E->getExprLoc(), BO_Assign, LHS.get(), RHS.get());
+  ExprResult S4 = S.IgnoredValueConversions(Res.get());
+  if (S1.isInvalid() || S2.isInvalid() || S3.isInvalid() || S4.isInvalid()) {
+    FD->setBody(S.ActOnNullStmt(SourceLocation()).get());
+    FD->setInvalidDecl();
+  } else {
+    CompoundScopeRAII CompoundScope(S);
+    Stmt *Stmts[] = {S1.get(), S2.get(), S3.get(), S4.get()};
+    StmtResult Body =
+        S.ActOnCompoundStmt(E->getExprLoc(), E->getExprLoc(), Stmts, false);
+    FD->setBody(Body.get());
+  }
+}
+
+Expr *Sema::OMPDeclareReductionFunctionScope::getCombiner() {
+  ExprResult Res =
+      S.BuildDeclRefExpr(FD, FD->getType(), VK_LValue, FD->getLocation());
+  return Res.get();
+}
+
+FunctionDecl *Sema::OMPDeclareReductionInitFunctionScope::
+    ActOnOMPDeclareReductionInitFunction(Sema &S, SourceLocation Loc,
+                                         DeclarationName Name, QualType QTy) {
+  QualType PtrQTy = S.Context.getPointerType(QTy);
+  QualType Args[] = {PtrQTy, PtrQTy};
+  FunctionProtoType::ExtProtoInfo EPI;
+  QualType FuncType = S.Context.getFunctionType(S.Context.VoidTy, Args, EPI);
+  TypeSourceInfo *TI = S.Context.getTrivialTypeSourceInfo(FuncType);
+  FunctionTypeLoc FTL = TI->getTypeLoc().getAs<FunctionTypeLoc>();
+  FunctionDecl *FD =
+      FunctionDecl::Create(S.Context, S.CurContext, Loc, Loc,
+                           DeclarationName(&S.Context.Idents.get("init")),
+                           FuncType, TI, SC_PrivateExtern, false, false);
+  FD->setImplicit();
+  S.CurContext->addDecl(FD);
+  if (S.CurContext->isDependentContext()) {
+    DeclContext *DC = S.CurContext->getParent();
+    TemplateParameterList *TPL = 0;
+    if (ClassTemplatePartialSpecializationDecl *CTPSD =
+            dyn_cast<ClassTemplatePartialSpecializationDecl>(DC)) {
+      TPL = CTPSD->getTemplateParameters();
+    } else if (CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(DC)) {
+      TPL = RD->getDescribedClassTemplate()
+                ->getCanonicalDecl()
+                ->getTemplateParameters();
+    } else if (FunctionDecl *RD = dyn_cast<FunctionDecl>(DC)) {
+      TPL = RD->getDescribedFunctionTemplate()
+                ->getCanonicalDecl()
+                ->getTemplateParameters();
+    }
+    FunctionTemplateDecl *FTD = FunctionTemplateDecl::Create(
+        S.Context, S.CurContext, Loc, Name, TPL, FD);
+    FD->setDescribedFunctionTemplate(FTD);
+  }
+  ParLHS = ParmVarDecl::Create(S.Context, FD, Loc, Loc, 0, PtrQTy,
+                               S.Context.getTrivialTypeSourceInfo(PtrQTy),
+                               SC_None, 0);
+  ParLHS->setScopeInfo(0, 0);
+  ParRHS = ParmVarDecl::Create(S.Context, FD, Loc, Loc, 0, PtrQTy,
+                               S.Context.getTrivialTypeSourceInfo(PtrQTy),
+                               SC_None, 0);
+  ParRHS->setScopeInfo(0, 1);
+  ParmVarDecl *Params[] = {ParLHS, ParRHS};
+  FD->setParams(Params);
+  FTL.setParam(0, ParLHS);
+  FTL.setParam(1, ParRHS);
+  OmpOrig = VarDecl::Create(S.Context, FD, Loc, Loc,
+                            &S.Context.Idents.get("omp_orig"), QTy,
+                            S.Context.getTrivialTypeSourceInfo(QTy), SC_Auto);
+  OmpPriv = VarDecl::Create(S.Context, FD, OmpPrivLoc, OmpPrivLoc,
+                            &S.Context.Idents.get("omp_priv"), QTy,
+                            S.Context.getTrivialTypeSourceInfo(QTy), SC_Auto);
+  S.AddKnownFunctionAttributes(FD);
+  if (S.CurScope) {
+    S.PushFunctionScope();
+    S.PushDeclContext(S.CurScope, FD);
+    S.PushOnScopeChains(OmpPriv, S.CurScope);
+    S.PushOnScopeChains(OmpOrig, S.CurScope);
+    S.PushExpressionEvaluationContext(PotentiallyEvaluated);
+  } else {
+    S.CurContext = FD;
+    FD->addDecl(OmpOrig);
+    FD->addDecl(OmpPriv);
+  }
+  ExprResult RHS =
+      S.BuildDeclRefExpr(ParRHS, ParRHS->getType(), VK_LValue, Loc);
+  RHS = S.DefaultLvalueConversion(RHS.get());
+  RHS = S.CreateBuiltinUnaryOp(Loc, UO_Deref, RHS.get());
+  RHS = S.ActOnFinishFullExpr(RHS.get());
+  S.AddInitializerToDecl(OmpOrig, RHS.get(), true, false);
+  return FD;
+}
+
+void Sema::CreateDefaultDeclareReductionInitFunctionBody(FunctionDecl *FD,
+                                                         VarDecl *OmpPriv,
+                                                         ParmVarDecl *ParLHS) {
+  ExprResult MemCall;
+  SourceLocation Loc = OmpPriv->getLocation();
+  if (!getLangOpts().CPlusPlus || OmpPriv->getType().isPODType(Context)) {
+    // Perform explicit initialization of POD types.
+    ExprResult OmpPrivDRE =
+        BuildDeclRefExpr(OmpPriv, OmpPriv->getType(), VK_LValue, Loc);
+    Expr *OmpPrivDREExpr = OmpPrivDRE.get();
+    ExprResult OmpPrivAddr =
+        CreateBuiltinUnaryOp(Loc, UO_AddrOf, OmpPrivDREExpr);
+    OmpPrivAddr = PerformImplicitConversion(OmpPrivAddr.get(),
+                                            Context.VoidPtrTy, AA_Casting);
+    ExprResult OmpPrivSizeOf;
+    {
+      EnterExpressionEvaluationContext Unevaluated(
+          *this, Sema::Unevaluated, Sema::ReuseLambdaContextDecl);
+
+      OmpPrivSizeOf =
+          CreateUnaryExprOrTypeTraitExpr(OmpPrivDREExpr, Loc, UETT_SizeOf);
+    }
+    UnqualifiedId Name;
+    CXXScopeSpec SS;
+    SourceLocation TemplateKwLoc;
+    Name.setIdentifier(PP.getIdentifierInfo("__builtin_memset"), Loc);
+    ExprResult MemSetFn =
+        ActOnIdExpression(TUScope, SS, TemplateKwLoc, Name, true, false);
+    Expr *Args[] = {OmpPrivAddr.get(), ActOnIntegerConstant(Loc, 0).get(),
+                    OmpPrivSizeOf.get()};
+    MemCall = ActOnCallExpr(0, MemSetFn.get(), Loc, Args, Loc);
+    MemCall = IgnoredValueConversions(MemCall.get());
+  } else {
+    ActOnUninitializedDecl(OmpPriv, false);
+  }
+  StmtResult S1 =
+      ActOnDeclStmt(DeclGroupPtrTy::make(DeclGroupRef(OmpPriv)), Loc, Loc);
+  ExprResult LHS = BuildDeclRefExpr(ParLHS, ParLHS->getType(), VK_LValue, Loc);
+  LHS = DefaultLvalueConversion(LHS.get());
+  LHS = CreateBuiltinUnaryOp(Loc, UO_Deref, LHS.get());
+  ExprResult RHS =
+      BuildDeclRefExpr(OmpPriv, OmpPriv->getType(), VK_LValue, Loc);
+  ExprResult Res = BuildBinOp(0, Loc, BO_Assign, LHS.get(), RHS.get());
+  ExprResult S2 = IgnoredValueConversions(ActOnFinishFullExpr(Res.get()).get());
+  if (S1.isInvalid() || S2.isInvalid()) {
+    FD->setBody(ActOnNullStmt(Loc).get());
+    FD->setInvalidDecl();
+  } else {
+    CompoundScopeRAII CompoundScope(*this);
+    SmallVector<Stmt *, 4> Stmts;
+    Stmts.push_back(S1.get());
+    if (MemCall.isUsable())
+      Stmts.push_back(MemCall.get());
+    Stmts.push_back(S2.get());
+    StmtResult Body = ActOnCompoundStmt(Loc, Loc, Stmts, false);
+    FD->setBody(Body.get());
+  }
+}
 
-      // OpenMP [2.9.3.6, Restrictions, p.2]
-      //  A list item that appears in a reduction clause of the innermost
-      //  enclosing worksharing or parallel construct may not be accessed in an
-      //  explicit task.
-      DVar = Stack->hasInnermostDSA(VD, MatchesAnyClause(OMPC_reduction),
-                                    [](OpenMPDirectiveKind K) -> bool {
-                                      return isOpenMPParallelDirective(K) ||
-                                             isOpenMPWorksharingDirective(K);
-                                    },
-                                    false);
-      if (DKind == OMPD_task && DVar.CKind == OMPC_reduction) {
-        ErrorFound = true;
-        SemaRef.Diag(ELoc, diag::err_omp_reduction_in_task);
-        ReportOriginalDSA(SemaRef, Stack, VD, DVar);
+void Sema::OMPDeclareReductionInitFunctionScope::setInit(Expr *E) {
+  ExprResult MemCall;
+  if (!E) {
+    if (OmpPriv->getType()->isDependentType() ||
+        OmpPriv->getType()->isInstantiationDependentType())
+      // It will be handled later on instantiation.
+      return;
+    S.CreateDefaultDeclareReductionInitFunctionBody(FD, OmpPriv, ParLHS);
+    return;
+  } else {
+    if (IsInit)
+      S.AddInitializerToDecl(OmpPriv, E, true, false);
+    else {
+      if (!isa<CallExpr>(E->IgnoreParenImpCasts())) {
+        FD->setInvalidDecl();
+        S.Diag(E->getExprLoc(), diag::err_omp_reduction_non_function_init)
+            << E->getSourceRange();
         return;
       }
-
-      // Define implicit data-sharing attributes for task.
-      DVar = Stack->getImplicitDSA(VD, false);
-      if (DKind == OMPD_task && DVar.CKind != OMPC_shared)
-        ImplicitFirstprivate.push_back(E);
+      MemCall = S.IgnoredValueConversions(E);
     }
   }
-  void VisitOMPExecutableDirective(OMPExecutableDirective *S) {
-    for (auto *C : S->clauses()) {
-      // Skip analysis of arguments of implicitly defined firstprivate clause
-      // for task directives.
-      if (C && (!isa<OMPFirstprivateClause>(C) || C->getLocStart().isValid()))
-        for (auto *CC : C->children()) {
-          if (CC)
-            Visit(CC);
-        }
-    }
+  SourceLocation Loc = E->getExprLoc();
+  StmtResult S1 =
+      S.ActOnDeclStmt(DeclGroupPtrTy::make(DeclGroupRef(OmpOrig)), Loc, Loc);
+  StmtResult S2 =
+      S.ActOnDeclStmt(DeclGroupPtrTy::make(DeclGroupRef(OmpPriv)), Loc, Loc);
+  ExprResult LHS =
+      S.BuildDeclRefExpr(ParLHS, ParLHS->getType(), VK_LValue, Loc);
+  LHS = S.DefaultLvalueConversion(LHS.get());
+  LHS = S.CreateBuiltinUnaryOp(Loc, UO_Deref, LHS.get());
+  ExprResult RHS =
+      S.BuildDeclRefExpr(OmpPriv, OmpPriv->getType(), VK_LValue, Loc);
+  ExprResult Res = S.BuildBinOp(0, Loc, BO_Assign, LHS.get(), RHS.get());
+  Res = S.ActOnFinishFullExpr(Res.get());
+  ExprResult S3 = S.IgnoredValueConversions(Res.get());
+  if (S1.isInvalid() || S2.isInvalid() || S3.isInvalid()) {
+    FD->setBody(S.ActOnNullStmt(Loc).get());
+    FD->setInvalidDecl();
+  } else {
+    CompoundScopeRAII CompoundScope(S);
+    SmallVector<Stmt *, 4> Stmts;
+    Stmts.push_back(S1.get());
+    Stmts.push_back(S2.get());
+    if (MemCall.isUsable())
+      Stmts.push_back(MemCall.get());
+    Stmts.push_back(S3.get());
+    StmtResult Body = S.ActOnCompoundStmt(Loc, Loc, Stmts, false);
+    FD->setBody(Body.get());
   }
-  void VisitStmt(Stmt *S) {
-    for (auto *C : S->children()) {
-      if (C && !isa<OMPExecutableDirective>(C))
-        Visit(C);
-    }
+}
+
+Expr *Sema::OMPDeclareReductionInitFunctionScope::getInitializer() {
+  ExprResult Res =
+      S.BuildDeclRefExpr(FD, FD->getType(), VK_LValue, FD->getLocation());
+  return Res.get();
+}
+
+bool Sema::IsOMPDeclareReductionTypeAllowed(SourceRange Range, QualType QTy,
+                                            ArrayRef<QualType> Types,
+                                            ArrayRef<SourceRange> TyRanges) {
+  if (QTy.isNull())
+    return false;
+
+  if (QTy.getCanonicalType().hasQualifiers()) {
+    Diag(Range.getBegin(), diag::err_omp_reduction_qualified_type) << Range;
+    return false;
   }
 
-  bool isErrorFound() { return ErrorFound; }
-  ArrayRef<Expr *> getImplicitFirstprivate() { return ImplicitFirstprivate; }
-  llvm::DenseMap<VarDecl *, Expr *> &getVarsWithInheritedDSA() {
-    return VarsWithInheritedDSA;
+  QTy = QTy.getCanonicalType();
+  if (QTy->isFunctionType() || QTy->isFunctionNoProtoType() ||
+      QTy->isFunctionProtoType() || QTy->isFunctionPointerType() ||
+      QTy->isMemberFunctionPointerType()) {
+    Diag(Range.getBegin(), diag::err_omp_reduction_function_type) << Range;
+    return false;
+  }
+  if (QTy->isReferenceType()) {
+    Diag(Range.getBegin(), diag::err_omp_reduction_reference_type) << Range;
+    return false;
+  }
+  if (QTy->isArrayType()) {
+    Diag(Range.getBegin(), diag::err_omp_reduction_array_type) << Range;
+    return false;
   }
 
-  DSAAttrChecker(DSAStackTy *S, Sema &SemaRef, CapturedStmt *CS)
-      : Stack(S), SemaRef(SemaRef), ErrorFound(false), CS(CS) {}
-};
-} // namespace
-
-void Sema::ActOnOpenMPRegionStart(OpenMPDirectiveKind DKind, Scope *CurScope) {
-  switch (DKind) {
-  case OMPD_parallel: {
-    QualType KmpInt32Ty = Context.getIntTypeForBitwidth(32, 1);
-    QualType KmpInt32PtrTy = Context.getPointerType(KmpInt32Ty);
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(".global_tid.", KmpInt32PtrTy),
-        std::make_pair(".bound_tid.", KmpInt32PtrTy),
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_simd: {
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_for: {
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_sections: {
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_section: {
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_single: {
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_master: {
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_critical: {
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_parallel_for: {
-    QualType KmpInt32Ty = Context.getIntTypeForBitwidth(32, 1);
-    QualType KmpInt32PtrTy = Context.getPointerType(KmpInt32Ty);
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(".global_tid.", KmpInt32PtrTy),
-        std::make_pair(".bound_tid.", KmpInt32PtrTy),
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_parallel_sections: {
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_task: {
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_taskyield: {
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_barrier: {
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_taskwait: {
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_flush: {
-    Sema::CapturedParamNameType Params[] = {
-        std::make_pair(StringRef(), QualType()) // __context with shared vars
-    };
-    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,
-                             Params);
-    break;
-  }
-  case OMPD_threadprivate:
-    llvm_unreachable("OpenMP Directive is not allowed");
-  case OMPD_unknown:
-    llvm_unreachable("Unknown OpenMP directive");
-  }
-}
-
-static bool CheckNestingOfRegions(Sema &SemaRef, DSAStackTy *Stack,
-                                  OpenMPDirectiveKind CurrentRegion,
-                                  const DeclarationNameInfo &CurrentName,
-                                  SourceLocation StartLoc) {
-  // Allowed nesting of constructs
-  // +------------------+-----------------+------------------------------------+
-  // | Parent directive | Child directive | Closely (!), No-Closely(+), Both(*)|
-  // +------------------+-----------------+------------------------------------+
-  // | parallel         | parallel        | *                                  |
-  // | parallel         | for             | *                                  |
-  // | parallel         | master          | *                                  |
-  // | parallel         | critical        | *                                  |
-  // | parallel         | simd            | *                                  |
-  // | parallel         | sections        | *                                  |
-  // | parallel         | section         | +                                  |
-  // | parallel         | single          | *                                  |
-  // | parallel         | parallel for    | *                                  |
-  // | parallel         |parallel sections| *                                  |
-  // | parallel         | task            | *                                  |
-  // | parallel         | taskyield       | *                                  |
-  // | parallel         | barrier         | *                                  |
-  // | parallel         | taskwait        | *                                  |
-  // | parallel         | flush           | *                                  |
-  // +------------------+-----------------+------------------------------------+
-  // | for              | parallel        | *                                  |
-  // | for              | for             | +                                  |
-  // | for              | master          | +                                  |
-  // | for              | critical        | *                                  |
-  // | for              | simd            | *                                  |
-  // | for              | sections        | +                                  |
-  // | for              | section         | +                                  |
-  // | for              | single          | +                                  |
-  // | for              | parallel for    | *                                  |
-  // | for              |parallel sections| *                                  |
-  // | for              | task            | *                                  |
-  // | for              | taskyield       | *                                  |
-  // | for              | barrier         | +                                  |
-  // | for              | taskwait        | *                                  |
-  // | for              | flush           | *                                  |
-  // +------------------+-----------------+------------------------------------+
-  // | master           | parallel        | *                                  |
-  // | master           | for             | +                                  |
-  // | master           | master          | *                                  |
-  // | master           | critical        | *                                  |
-  // | master           | simd            | *                                  |
-  // | master           | sections        | +                                  |
-  // | master           | section         | +                                  |
-  // | master           | single          | +                                  |
-  // | master           | parallel for    | *                                  |
-  // | master           |parallel sections| *                                  |
-  // | master           | task            | *                                  |
-  // | master           | taskyield       | *                                  |
-  // | master           | barrier         | +                                  |
-  // | master           | taskwait        | *                                  |
-  // | master           | flush           | *                                  |
-  // +------------------+-----------------+------------------------------------+
-  // | critical         | parallel        | *                                  |
-  // | critical         | for             | +                                  |
-  // | critical         | master          | *                                  |
-  // | critical         | critical        | * (should have dirrerent names)    |
-  // | critical         | simd            | *                                  |
-  // | critical         | sections        | +                                  |
-  // | critical         | section         | +                                  |
-  // | critical         | single          | +                                  |
-  // | critical         | parallel for    | *                                  |
-  // | critical         |parallel sections| *                                  |
-  // | critical         | task            | *                                  |
-  // | critical         | taskyield       | *                                  |
-  // | critical         | barrier         | +                                  |
-  // | critical         | taskwait        | *                                  |
-  // +------------------+-----------------+------------------------------------+
-  // | simd             | parallel        |                                    |
-  // | simd             | for             |                                    |
-  // | simd             | master          |                                    |
-  // | simd             | critical        |                                    |
-  // | simd             | simd            |                                    |
-  // | simd             | sections        |                                    |
-  // | simd             | section         |                                    |
-  // | simd             | single          |                                    |
-  // | simd             | parallel for    |                                    |
-  // | simd             |parallel sections|                                    |
-  // | simd             | task            |                                    |
-  // | simd             | taskyield       |                                    |
-  // | simd             | barrier         |                                    |
-  // | simd             | taskwait        |                                    |
-  // | simd             | flush           |                                    |
-  // +------------------+-----------------+------------------------------------+
-  // | sections         | parallel        | *                                  |
-  // | sections         | for             | +                                  |
-  // | sections         | master          | +                                  |
-  // | sections         | critical        | *                                  |
-  // | sections         | simd            | *                                  |
-  // | sections         | sections        | +                                  |
-  // | sections         | section         | *                                  |
-  // | sections         | single          | +                                  |
-  // | sections         | parallel for    | *                                  |
-  // | sections         |parallel sections| *                                  |
-  // | sections         | task            | *                                  |
-  // | sections         | taskyield       | *                                  |
-  // | sections         | barrier         | +                                  |
-  // | sections         | taskwait        | *                                  |
-  // | sections         | flush           | *                                  |
-  // +------------------+-----------------+------------------------------------+
-  // | section          | parallel        | *                                  |
-  // | section          | for             | +                                  |
-  // | section          | master          | +                                  |
-  // | section          | critical        | *                                  |
-  // | section          | simd            | *                                  |
-  // | section          | sections        | +                                  |
-  // | section          | section         | +                                  |
-  // | section          | single          | +                                  |
-  // | section          | parallel for    | *                                  |
-  // | section          |parallel sections| *                                  |
-  // | section          | task            | *                                  |
-  // | section          | taskyield       | *                                  |
-  // | section          | barrier         | +                                  |
-  // | section          | taskwait        | *                                  |
-  // | section          | flush           | *                                  |
-  // +------------------+-----------------+------------------------------------+
-  // | single           | parallel        | *                                  |
-  // | single           | for             | +                                  |
-  // | single           | master          | +                                  |
-  // | single           | critical        | *                                  |
-  // | single           | simd            | *                                  |
-  // | single           | sections        | +                                  |
-  // | single           | section         | +                                  |
-  // | single           | single          | +                                  |
-  // | single           | parallel for    | *                                  |
-  // | single           |parallel sections| *                                  |
-  // | single           | task            | *                                  |
-  // | single           | taskyield       | *                                  |
-  // | single           | barrier         | +                                  |
-  // | single           | taskwait        | *                                  |
-  // | single           | flush           | *                                  |
-  // +------------------+-----------------+------------------------------------+
-  // | parallel for     | parallel        | *                                  |
-  // | parallel for     | for             | +                                  |
-  // | parallel for     | master          | +                                  |
-  // | parallel for     | critical        | *                                  |
-  // | parallel for     | simd            | *                                  |
-  // | parallel for     | sections        | +                                  |
-  // | parallel for     | section         | +                                  |
-  // | parallel for     | single          | +                                  |
-  // | parallel for     | parallel for    | *                                  |
-  // | parallel for     |parallel sections| *                                  |
-  // | parallel for     | task            | *                                  |
-  // | parallel for     | taskyield       | *                                  |
-  // | parallel for     | barrier         | +                                  |
-  // | parallel for     | taskwait        | *                                  |
-  // | parallel for     | flush           | *                                  |
-  // +------------------+-----------------+------------------------------------+
-  // | parallel sections| parallel        | *                                  |
-  // | parallel sections| for             | +                                  |
-  // | parallel sections| master          | +                                  |
-  // | parallel sections| critical        | +                                  |
-  // | parallel sections| simd            | *                                  |
-  // | parallel sections| sections        | +                                  |
-  // | parallel sections| section         | *                                  |
-  // | parallel sections| single          | +                                  |
-  // | parallel sections| parallel for    | *                                  |
-  // | parallel sections|parallel sections| *                                  |
-  // | parallel sections| task            | *                                  |
-  // | parallel sections| taskyield       | *                                  |
-  // | parallel sections| barrier         | +                                  |
-  // | parallel sections| taskwait        | *                                  |
-  // | parallel sections| flush           | *                                  |
-  // +------------------+-----------------+------------------------------------+
-  // | task             | parallel        | *                                  |
-  // | task             | for             | +                                  |
-  // | task             | master          | +                                  |
-  // | task             | critical        | *                                  |
-  // | task             | simd            | *                                  |
-  // | task             | sections        | +                                  |
-  // | task             | section         | +                                  |
-  // | task             | single          | +                                  |
-  // | task             | parallel for    | *                                  |
-  // | task             |parallel sections| *                                  |
-  // | task             | task            | *                                  |
-  // | task             | taskyield       | *                                  |
-  // | task             | barrier         | +                                  |
-  // | task             | taskwait        | *                                  |
-  // | task             | flush           | *                                  |
-  // +------------------+-----------------+------------------------------------+
-  if (Stack->getCurScope()) {
-    auto ParentRegion = Stack->getParentDirective();
-    bool NestingProhibited = false;
-    bool CloseNesting = true;
-    bool ShouldBeInParallelRegion = false;
-    if (isOpenMPSimdDirective(ParentRegion)) {
-      // OpenMP [2.16, Nesting of Regions]
-      // OpenMP constructs may not be nested inside a simd region.
-      SemaRef.Diag(StartLoc, diag::err_omp_prohibited_region_simd);
-      return true;
+  bool IsValid = true;
+  ArrayRef<SourceRange>::iterator IR = TyRanges.begin();
+  for (ArrayRef<QualType>::iterator I = Types.begin(), E = Types.end(); I != E;
+       ++I, ++IR) {
+    if (Context.hasSameType(QTy, *I)) {
+      Diag(Range.getBegin(), diag::err_omp_reduction_redeclared) << *I << Range;
+      Diag(IR->getBegin(), diag::note_previous_declaration) << *IR;
+      IsValid = false;
+    }
+  }
+  return IsValid;
+}
+
+Sema::DeclGroupPtrTy Sema::ActOnOpenMPDeclareReductionDirective(
+    Decl *D, ArrayRef<QualType> Types, ArrayRef<SourceRange> TyRanges,
+    ArrayRef<Expr *> Combiners, ArrayRef<Expr *> Inits) {
+  OMPDeclareReductionDecl *DR = cast<OMPDeclareReductionDecl>(D);
+
+  LookupResult Found(*this, DR->getDeclName(), DR->getLocation(),
+                     LookupOMPDeclareReduction);
+  Found.suppressDiagnostics();
+  LookupName(Found, CurScope);
+  for (LookupResult::iterator I = Found.begin(), E = Found.end(); I != E; ++I) {
+    OMPDeclareReductionDecl *DRI = cast<OMPDeclareReductionDecl>(*I);
+    if (DRI == D)
+      continue;
+    for (OMPDeclareReductionDecl::datalist_iterator II = DRI->datalist_begin(),
+                                                    EE = DRI->datalist_end();
+         II != EE; ++II) {
+      ArrayRef<SourceRange>::iterator IR = TyRanges.begin();
+      for (ArrayRef<QualType>::iterator IT = Types.begin(), IE = Types.end();
+           IT != IE; ++IT, ++IR) {
+        if (!II->QTy.isNull() && !IT->isNull() &&
+            Context.hasSameType(II->QTy, *IT)) {
+          Diag(IR->getBegin(), diag::err_omp_reduction_redeclared) << II->QTy
+                                                                   << *IR;
+          Diag(II->TyRange.getBegin(), diag::note_previous_declaration)
+              << II->TyRange;
+          D->setInvalidDecl();
+        }
+      }
     }
-    if (CurrentRegion == OMPD_section) {
-      // OpenMP [2.7.2, sections Construct, Restrictions]
-      // Orphaned section directives are prohibited. That is, the section
-      // directives must appear within the sections construct and must not be
-      // encountered elsewhere in the sections region.
-      if (ParentRegion != OMPD_sections &&
-          ParentRegion != OMPD_parallel_sections) {
-        SemaRef.Diag(StartLoc, diag::err_omp_orphaned_section_directive)
-            << (ParentRegion != OMPD_unknown)
-            << getOpenMPDirectiveName(ParentRegion);
-        return true;
+  }
+
+  if (!D->isInvalidDecl()) {
+    CompleteOMPDeclareReductionDecl(DR, Types, TyRanges, Combiners, Inits);
+    PushOnScopeChains(DR, CurScope, false);
+    return DeclGroupPtrTy::make(DeclGroupRef(DR));
+  }
+  return DeclGroupPtrTy();
+}
+
+void Sema::CompleteOMPDeclareReductionDecl(OMPDeclareReductionDecl *D,
+                                           ArrayRef<QualType> Types,
+                                           ArrayRef<SourceRange> TyRanges,
+                                           ArrayRef<Expr *> Combiners,
+                                           ArrayRef<Expr *> Inits) {
+  SmallVector<OMPDeclareReductionDecl::ReductionData, 4> Data;
+  ArrayRef<Expr *>::iterator IC = Combiners.begin();
+  ArrayRef<Expr *>::iterator II = Inits.begin();
+  ArrayRef<SourceRange>::iterator IR = TyRanges.begin();
+  for (ArrayRef<QualType>::iterator IT = Types.begin(), ET = Types.end();
+       IT != ET; ++IT, ++IC, ++II, ++IR) {
+    Data.push_back(OMPDeclareReductionDecl::ReductionData(*IT, *IR, *IC, *II));
+  }
+  D->setData(Data);
+}
+
+bool Sema::ActOnStartOpenMPDeclareTargetDirective(Scope *S,
+                                                  SourceLocation Loc) {
+  if (CurContext && !CurContext->isFileContext()) {
+    Diag(Loc, diag::err_omp_region_not_file_context);
+    return false;
+  }
+  OMPDeclareTargetDecl *DT =
+      OMPDeclareTargetDecl::Create(Context, CurContext, Loc);
+  DT->setAccess(AS_public);
+  CurContext->addDecl(DT);
+  if (CurScope)
+    PushDeclContext(S, DT);
+  else
+    CurContext = DT;
+  return true;
+}
+
+void Sema::ActOnOpenMPDeclareTargetDecls(Sema::DeclGroupPtrTy Decls) {
+  if (!Decls)
+    return;
+  DeclGroupRef DGR = Decls.get();
+  if (DGR.isNull())
+    return;
+  for (DeclGroupRef::iterator I = DGR.begin(), E = DGR.end(); I != E; ++I) {
+    if (*I)
+      DSAStack->addDeclareTargetDecl(*I);
+  }
+}
+
+Sema::DeclGroupPtrTy Sema::ActOnFinishOpenMPDeclareTargetDirective() {
+  if (CurContext && isa<OMPDeclareTargetDecl>(CurContext)) {
+    OMPDeclareTargetDecl *DT = cast<OMPDeclareTargetDecl>(CurContext);
+    PopDeclContext();
+    return DeclGroupPtrTy::make(DeclGroupRef(DT));
+  }
+  return DeclGroupPtrTy();
+}
+
+void Sema::ActOnOpenMPDeclareTargetDirectiveError() {
+  if (CurContext && isa<OMPDeclareTargetDecl>(CurContext)) {
+    PopDeclContext();
+  }
+}
+
+static void CheckDeclInTargetContext(SourceLocation SL, SourceRange SR,
+                                     Sema &SemaRef, DSAStackTy *Stack,
+                                     Decl *D) {
+  if (!D)
+    return;
+  Decl *LD = 0;
+  if (isa<TagDecl>(D)) {
+    LD = cast<TagDecl>(D)->getDefinition();
+  } else if (isa<VarDecl>(D)) {
+    LD = cast<VarDecl>(D)->getDefinition();
+  } else if (isa<FunctionDecl>(D)) {
+    const FunctionDecl *FD = 0;
+    if (cast<FunctionDecl>(D)->hasBody(FD))
+      LD = const_cast<FunctionDecl *>(FD);
+  }
+  if (!LD)
+    LD = D;
+  if (LD) {
+    if (!Stack->isDeclareTargetDecl(LD)) {
+      // Outlined declaration is not declared target.
+      if (LD->isOutOfLine()) {
+        SemaRef.Diag(LD->getLocation(), diag::warn_omp_not_in_target_context);
+        SemaRef.Diag(SL, diag::note_used_here) << SR;
+      } else {
+        DeclContext *DC = LD->getDeclContext();
+        while (DC) {
+          if (isa<OMPDeclareTargetDecl>(DC))
+            break;
+          DC = DC->getParent();
+        }
+        // Is not declared in target context.
+        if (!DC) {
+          SemaRef.Diag(LD->getLocation(), diag::warn_omp_not_in_target_context);
+          SemaRef.Diag(SL, diag::note_used_here) << SR;
+        }
       }
+    }
+    // Mark decl as declared to prevent further diagnostic.
+    if (isa<VarDecl>(LD) || isa<FunctionDecl>(LD))
+      Stack->addDeclareTargetDecl(LD);
+  }
+}
+
+static bool IsCXXRecordForMappable(Sema &SemaRef, SourceLocation Loc,
+                                   DSAStackTy *Stack, CXXRecordDecl *RD);
+
+static bool CheckTypeMappable(SourceLocation SL, SourceRange SR, Sema &SemaRef,
+                              DSAStackTy *Stack, QualType QTy) {
+  NamedDecl *ND;
+  if (QTy->isIncompleteType(&ND)) {
+    SemaRef.Diag(SL, diag::err_incomplete_type) << QTy << SR;
+    return false;
+  } else if (CXXRecordDecl *RD = dyn_cast_or_null<CXXRecordDecl>(ND)) {
+    if (!RD->isInvalidDecl() &&
+        !IsCXXRecordForMappable(SemaRef, SL, Stack, RD)) {
       return false;
     }
-    if (CurrentRegion == OMPD_master) {
-      // OpenMP [2.16, Nesting of Regions]
-      // A master region may not be closely nested inside a worksharing,
-      // atomic (TODO), or explicit task region.
-      NestingProhibited = isOpenMPWorksharingDirective(ParentRegion) ||
-                          ParentRegion == OMPD_task;
-    } else if (CurrentRegion == OMPD_critical && CurrentName.getName()) {
-      // OpenMP [2.16, Nesting of Regions]
-      // A critical region may not be nested (closely or otherwise) inside a
-      // critical region with the same name. Note that this restriction is not
-      // sufficient to prevent deadlock.
-      SourceLocation PreviousCriticalLoc;
-      bool DeadLock =
-          Stack->hasDirective([CurrentName, &PreviousCriticalLoc](
-                                  OpenMPDirectiveKind K,
-                                  const DeclarationNameInfo &DNI,
-                                  SourceLocation Loc)
-                                  ->bool {
-                                if (K == OMPD_critical &&
-                                    DNI.getName() == CurrentName.getName()) {
-                                  PreviousCriticalLoc = Loc;
-                                  return true;
-                                } else
-                                  return false;
-                              },
-                              false /* skip top directive */);
-      if (DeadLock) {
-        SemaRef.Diag(StartLoc,
-                     diag::err_omp_prohibited_region_critical_same_name)
-            << CurrentName.getName();
-        if (PreviousCriticalLoc.isValid())
-          SemaRef.Diag(PreviousCriticalLoc,
-                       diag::note_omp_previous_critical_region);
-        return true;
+  }
+  return true;
+}
+
+static bool CheckValueDeclInTarget(SourceLocation SL, SourceRange SR,
+                                   Sema &SemaRef, DSAStackTy *Stack,
+                                   ValueDecl *VD) {
+  if (Stack->isDeclareTargetDecl(VD))
+    return true;
+  if (!CheckTypeMappable(SL, SR, SemaRef, Stack, VD->getType())) {
+    return false;
+  }
+  return true;
+}
+
+static bool IsCXXRecordForMappable(Sema &SemaRef, SourceLocation Loc,
+                                   DSAStackTy *Stack, CXXRecordDecl *RD) {
+  if (!RD || RD->isInvalidDecl())
+    return true;
+
+  QualType QTy = SemaRef.Context.getRecordType(RD);
+  if (RD->isDynamicClass()) {
+    SemaRef.Diag(Loc, diag::err_omp_not_mappable_type) << QTy;
+    SemaRef.Diag(RD->getLocation(), diag::note_omp_polymorphic_in_target);
+    return false;
+  }
+  DeclContext *DC = RD;
+  bool IsCorrect = true;
+  for (DeclContext::decl_iterator I = DC->noload_decls_begin(),
+                                  E = DC->noload_decls_end();
+       I != E; ++I) {
+    if (*I) {
+      if (CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(*I)) {
+        if (MD->isStatic()) {
+          SemaRef.Diag(Loc, diag::err_omp_not_mappable_type) << QTy;
+          SemaRef.Diag(MD->getLocation(),
+                       diag::note_omp_static_member_in_target);
+          IsCorrect = false;
+        }
+      } else if (VarDecl *VD = dyn_cast<VarDecl>(*I)) {
+        if (VD->isStaticDataMember()) {
+          SemaRef.Diag(Loc, diag::err_omp_not_mappable_type) << QTy;
+          SemaRef.Diag(VD->getLocation(),
+                       diag::note_omp_static_member_in_target);
+          IsCorrect = false;
+        }
       }
-    } else if (CurrentRegion == OMPD_barrier) {
-      // OpenMP [2.16, Nesting of Regions]
-      // A barrier region may not be closely nested inside a worksharing,
-      // explicit task, critical, ordered(TODO), atomic(TODO), or master
-      // region.
-      NestingProhibited = isOpenMPWorksharingDirective(ParentRegion) ||
-                          ParentRegion == OMPD_task ||
-                          ParentRegion == OMPD_master ||
-                          ParentRegion == OMPD_critical;
-    } else if (isOpenMPWorksharingDirective(CurrentRegion) &&
-               !isOpenMPParallelDirective(CurrentRegion) &&
-               !isOpenMPSimdDirective(CurrentRegion)) {
-      // OpenMP [2.16, Nesting of Regions]
-      // A worksharing region may not be closely nested inside a worksharing,
-      // explicit task, critical, ordered, atomic, or master region.
-      // TODO
-      NestingProhibited = (isOpenMPWorksharingDirective(ParentRegion) &&
-                           !isOpenMPSimdDirective(ParentRegion)) ||
-                          ParentRegion == OMPD_task ||
-                          ParentRegion == OMPD_master ||
-                          ParentRegion == OMPD_critical;
-      ShouldBeInParallelRegion = true;
     }
-    if (NestingProhibited) {
-      SemaRef.Diag(StartLoc, diag::err_omp_prohibited_region)
-          << CloseNesting << getOpenMPDirectiveName(ParentRegion)
-          << ShouldBeInParallelRegion << getOpenMPDirectiveName(CurrentRegion);
-      return true;
+  }
+  for (CXXRecordDecl::base_class_iterator I = RD->bases_begin(),
+                                          E = RD->bases_end();
+       I != E; ++I) {
+    if (!IsCXXRecordForMappable(SemaRef, I->getLocStart(), Stack,
+                                I->getType()->getAsCXXRecordDecl())) {
+      IsCorrect = false;
     }
   }
-  return false;
+  return IsCorrect;
 }
 
-StmtResult Sema::ActOnOpenMPExecutableDirective(OpenMPDirectiveKind Kind,
-                                                const DeclarationNameInfo &DirName,
-                                                ArrayRef<OMPClause *> Clauses,
-                                                Stmt *AStmt,
-                                                SourceLocation StartLoc,
-                                                SourceLocation EndLoc) {
-  StmtResult Res = StmtError();
-  if (CheckNestingOfRegions(*this, DSAStack, Kind, DirName, StartLoc))
-    return StmtError();
+void Sema::CheckDeclIsAllowedInOpenMPTarget(Expr *E, Decl *D) {
+  if (!D || D->isInvalidDecl())
+    return;
+  SourceRange SR = E ? E->getSourceRange() : D->getSourceRange();
+  SourceLocation SL = E ? E->getLocStart() : D->getLocation();
+  if (VarDecl *VD = dyn_cast<VarDecl>(D)) {
+    DeclRefExpr *DRE;
+    if (DSAStack->IsThreadprivate(VD, DRE)) {
+      SourceLocation Loc = DRE ? DRE->getLocation() : VD->getLocation();
+      Diag(Loc, diag::err_omp_threadprivate_in_target);
+      Diag(SL, diag::note_used_here) << SR;
+      D->setInvalidDecl();
+      return;
+    }
+  }
+  if (ValueDecl *VD = dyn_cast<ValueDecl>(D)) {
+    if (!CheckValueDeclInTarget(SL, SR, *this, DSAStack, VD)) {
+      VD->setInvalidDecl();
+      return;
+    }
+  }
+  if (!E) {
+    // Checking declaration.
+    if (isa<VarDecl>(D) || isa<FunctionDecl>(D))
+      DSAStack->addDeclareTargetDecl(D);
+    return;
+  }
+  CheckDeclInTargetContext(E->getExprLoc(), E->getSourceRange(), *this,
+                           DSAStack, D);
+}
 
-  llvm::SmallVector<OMPClause *, 8> ClausesWithImplicit;
-  llvm::DenseMap<VarDecl *, Expr *> VarsWithInheritedDSA;
-  bool ErrorFound = false;
-  ClausesWithImplicit.append(Clauses.begin(), Clauses.end());
-  if (AStmt) {
-    assert(isa<CapturedStmt>(AStmt) && "Captured statement expected");
+void Sema::MarkOpenMPClauses(ArrayRef<OMPClause *> Clauses) {
+  for (ArrayRef<OMPClause *>::iterator I = Clauses.begin(), E = Clauses.end();
+       I != E; ++I)
+    for (Stmt::child_range S = (*I)->children(); S; ++S) {
+      if (*S && isa<Expr>(*S))
+        MarkDeclarationsReferencedInExpr(cast<Expr>(*S));
+    }
+}
+
+namespace {
+class DSAAttrChecker : public StmtVisitor<DSAAttrChecker, void> {
+  DSAStackTy *Stack;
+  Sema &Actions;
+  llvm::SmallVector<Expr *, 2> ImplicitFirstprivate;
+  bool ErrorFound;
+  CapturedStmt *CS;
+
+public:
+  void VisitDeclRefExpr(DeclRefExpr *E) {
+    if (VarDecl *VD = dyn_cast<VarDecl>(E->getDecl())) {
+      if (VD->isImplicit() && VD->hasAttr<UnusedAttr>())
+        return;
+      // Skip internally declared variables.
+      if (VD->isLocalVarDecl() && !CS->capturesVariable(VD))
+        return;
+      // NamedDecl *ND = VD;
+      // if (
+      //    Actions.isDeclInScope(ND, Actions.CurContext,
+      //                          Stack->getCurScope())) return;
+      SourceLocation ELoc = E->getExprLoc();
+      DeclRefExpr *PrevRef;
+
+      OpenMPDirectiveKind DKind = Stack->getCurrentDirective();
+      OpenMPClauseKind Kind = Stack->getTopDSA(VD, PrevRef);
+
+      // The default(none) clause requires that each variable that is referenced
+      // in the construct, and does not have a predetermined data-sharing
+      // attribute, must have its data-sharing attribute explicitly determined
+      // by being listed in a data-sharing attribute clause.
+      if (Kind == OMPC_unknown && Stack->getDefaultDSA() == DSA_none &&
+          (DKind == OMPD_parallel || DKind == OMPD_parallel_for ||
+           DKind == OMPD_parallel_for_simd ||
+           DKind == OMPD_distribute_parallel_for ||
+           DKind == OMPD_distribute_parallel_for_simd || DKind == OMPD_task ||
+           DKind == OMPD_teams_distribute_parallel_for ||
+           DKind == OMPD_teams_distribute_parallel_for_simd ||
+           DKind == OMPD_target_teams_distribute_parallel_for ||
+           DKind == OMPD_target_teams_distribute_parallel_for_simd ||
+           DKind == OMPD_teams || DKind == OMPD_parallel_sections ||
+           DKind == OMPD_target_teams || DKind == OMPD_teams_distribute ||
+           DKind == OMPD_teams_distribute_simd ||
+           DKind == OMPD_target_teams_distribute ||
+           DKind == OMPD_target_teams_distribute_simd)) {
+        ErrorFound = true;
+        Actions.Diag(ELoc, diag::err_omp_no_dsa_for_variable) << VD;
+        return;
+      }
+
+      // OpenMP [2.9.3.6, Restrictions, p.2]
+      //  A list item that appears in a reduction clause of the innermost
+      //  enclosing worksharing or parallel construct may not be accessed in an
+      //  explicit task.
+      if (DKind == OMPD_task &&
+          (Stack->hasInnermostDSA(VD, OMPC_reduction, OMPD_for, PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction, OMPD_for_simd, PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction, OMPD_sections, PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction, OMPD_parallel, PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction, OMPD_parallel_for,
+                                  PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction, OMPD_parallel_for_simd,
+                                  PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction,
+                                  OMPD_distribute_parallel_for, PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction,
+                                  OMPD_distribute_parallel_for_simd, PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction,
+                                  OMPD_teams_distribute_parallel_for,
+                                  PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction,
+                                  OMPD_teams_distribute_parallel_for_simd,
+                                  PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction,
+                                  OMPD_target_teams_distribute_parallel_for,
+                                  PrevRef) ||
+           Stack->hasInnermostDSA(
+               VD, OMPC_reduction,
+               OMPD_target_teams_distribute_parallel_for_simd, PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction, OMPD_parallel_sections,
+                                  PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction, OMPD_teams, PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction, OMPD_target_teams,
+                                  PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction, OMPD_teams_distribute,
+                                  PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction,
+                                  OMPD_teams_distribute_simd, PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction,
+                                  OMPD_target_teams_distribute, PrevRef) ||
+           Stack->hasInnermostDSA(VD, OMPC_reduction,
+                                  OMPD_target_teams_distribute_simd,
+                                  PrevRef))) {
+        ErrorFound = true;
+        Actions.Diag(ELoc, diag::err_omp_reduction_in_task);
+        if (PrevRef) {
+          Actions.Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+              << getOpenMPClauseName(OMPC_reduction);
+        }
+        return;
+      }
+      // Define implicit data-sharing attributes for task.
+      if (DKind == OMPD_task && Kind == OMPC_unknown) {
+        Kind = Stack->getImplicitDSA(VD, DKind, PrevRef);
+        if (Kind != OMPC_shared)
+          ImplicitFirstprivate.push_back(E);
+      }
+    }
+  }
+  void VisitOMPExecutableDirective(OMPExecutableDirective *S) {
+    for (ArrayRef<OMPClause *>::iterator I = S->clauses().begin(),
+                                         E = S->clauses().end();
+         I != E; ++I) {
+      if (OMPClause *C = *I)
+        for (StmtRange R = C->children(); R; ++R) {
+          if (Stmt *Child = *R)
+            Visit(Child);
+        }
+    }
+  }
+  void VisitStmt(Stmt *S) {
+    for (Stmt::child_iterator I = S->child_begin(), E = S->child_end(); I != E;
+         ++I) {
+      if (Stmt *Child = *I) {
+        if (!isa<OMPExecutableDirective>(Child))
+          Visit(Child);
+      }
+    }
+  }
+
+  ArrayRef<Expr *> getImplicitFirstprivate() { return ImplicitFirstprivate; }
+  bool isErrorFound() { return ErrorFound; }
+
+  DSAAttrChecker(DSAStackTy *S, Sema &Actions, CapturedStmt *CS)
+      : Stack(S), Actions(Actions), ImplicitFirstprivate(), ErrorFound(false),
+        CS(CS) {}
+};
+}
 
-    // Check default data sharing attributes for referenced variables.
+StmtResult Sema::ActOnOpenMPExecutableDirective(
+    OpenMPDirectiveKind Kind, const DeclarationNameInfo &DirName,
+    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,
+    SourceLocation EndLoc, OpenMPDirectiveKind ConstructType) {
+  // OpenMP [2.16, Nesting of Regions]
+  llvm::SmallVector<OMPClause *, 4> ClausesWithImplicit;
+  bool ErrorFound = false;
+  if (DSAStack->getCurScope()) {
+    OpenMPDirectiveKind ParentKind = DSAStack->getParentDirective();
+    bool NestingProhibited = false;
+    bool CloseNesting = true;
+    bool HasNamedDirective = false;
+    StringRef Region;
+    bool ConstructTypeMatches = false;
+    if (Kind == OMPD_cancel || Kind == OMPD_cancellation_point) {
+      switch (ConstructType) {
+      case OMPD_parallel:
+        ConstructTypeMatches = ParentKind == OMPD_parallel;
+        break;
+      case OMPD_for:
+        ConstructTypeMatches =
+            ParentKind == OMPD_for || ParentKind == OMPD_parallel_for ||
+            ParentKind == OMPD_distribute_parallel_for ||
+            ParentKind == OMPD_teams_distribute_parallel_for ||
+            ParentKind == OMPD_target_teams_distribute_parallel_for;
+        break;
+      case OMPD_sections:
+        ConstructTypeMatches =
+            ParentKind == OMPD_sections || ParentKind == OMPD_parallel_sections;
+        break;
+      case OMPD_taskgroup:
+        ConstructTypeMatches = ParentKind == OMPD_task;
+        break;
+      default:
+        break;
+      }
+    }
+    switch (ParentKind) {
+    case OMPD_parallel:
+      NestingProhibited =
+          (Kind == OMPD_cancel && !ConstructTypeMatches) ||
+          (Kind == OMPD_cancellation_point && !ConstructTypeMatches);
+      Region = "a parallel";
+      break;
+    case OMPD_for:
+    case OMPD_sections:
+    case OMPD_distribute_parallel_for:
+    case OMPD_teams_distribute_parallel_for:
+    case OMPD_target_teams_distribute_parallel_for:
+    case OMPD_parallel_for:
+    case OMPD_parallel_sections:
+    case OMPD_single:
+      // Worksharing region
+      // OpenMP [2.16, Nesting of Regions, p. 1]
+      //  A worksharing region may not be closely nested inside a worksharing,
+      //  explicit task, critical, ordered, atomic, or master region.
+      // OpenMP [2.16, Nesting of Regions, p. 2]
+      //  A barrier region may not be closely nested inside a worksharing,
+      //  explicit task, critical, ordered, atomic, or master region.
+      // OpenMP [2.16, Nesting of Regions, p. 3]
+      //  A master region may not be closely nested inside a worksharing,
+      //  atomic, or explicit task region.
+      NestingProhibited =
+          Kind == OMPD_for || Kind == OMPD_sections || Kind == OMPD_for_simd ||
+          Kind == OMPD_distribute_simd || Kind == OMPD_distribute ||
+          Kind == OMPD_distribute_parallel_for ||
+          Kind == OMPD_distribute_parallel_for_simd || Kind == OMPD_single ||
+          Kind == OMPD_master || Kind == OMPD_barrier ||
+          (Kind == OMPD_cancel && !ConstructTypeMatches) ||
+          (Kind == OMPD_cancellation_point && !ConstructTypeMatches);
+      Region = "a worksharing";
+      break;
+    case OMPD_task:
+      // Task region
+      // OpenMP [2.16, Nesting of Regions, p. 1]
+      //  A worksharing region may not be closely nested inside a worksharing,
+      //  explicit task, critical, ordered, atomic, or master region.
+      // OpenMP [2.16, Nesting of Regions, p. 2]
+      //  A barrier region may not be closely nested inside a worksharing,
+      //  explicit task, critical, ordered, atomic, or master region.
+      // OpenMP [2.16, Nesting of Regions, p. 3]
+      //  A master region may not be closely nested inside a worksharing,
+      // atomic,
+      //  or explicit task region.
+      // OpenMP [2.16, Nesting of Regions, p. 4]
+      //  An ordered region may not be closely nested inside a critical, atomic,
+      //  or explicit task region.
+      NestingProhibited =
+          Kind == OMPD_for || Kind == OMPD_sections || Kind == OMPD_for_simd ||
+          Kind == OMPD_distribute_simd || Kind == OMPD_distribute ||
+          Kind == OMPD_distribute_parallel_for ||
+          Kind == OMPD_distribute_parallel_for_simd || Kind == OMPD_single ||
+          Kind == OMPD_master || Kind == OMPD_barrier || Kind == OMPD_ordered ||
+          (Kind == OMPD_cancel && !ConstructTypeMatches) ||
+          (Kind == OMPD_cancellation_point && !ConstructTypeMatches);
+      Region = "explicit task";
+      break;
+    case OMPD_master:
+      // OpenMP [2.16, Nesting of Regions, p. 1]
+      //  A worksharing region may not be closely nested inside a worksharing,
+      //  explicit task, critical, ordered, atomic, or master region.
+      // OpenMP [2.16, Nesting of Regions, p. 2]
+      //  A barrier region may not be closely nested inside a worksharing,
+      //  explicit task, critical, ordered, atomic, or master region.
+      NestingProhibited =
+          Kind == OMPD_for || Kind == OMPD_sections || Kind == OMPD_for_simd ||
+          Kind == OMPD_distribute_simd || Kind == OMPD_distribute ||
+          Kind == OMPD_distribute_parallel_for ||
+          Kind == OMPD_distribute_parallel_for_simd || Kind == OMPD_single ||
+          Kind == OMPD_barrier || Kind == OMPD_cancel ||
+          Kind == OMPD_cancellation_point;
+      Region = "a master";
+      break;
+    case OMPD_critical:
+      // OpenMP [2.16, Nesting of Regions, p. 1]
+      //  A worksharing region may not be closely nested inside a worksharing,
+      //  explicit task, critical, ordered, atomic, or master region.
+      // OpenMP [2.16, Nesting of Regions, p. 2]
+      //  A barrier region may not be closely nested inside a worksharing,
+      //  explicit task, critical, ordered, atomic, or master region.
+      // OpenMP [2.16, Nesting of Regions, p. 4]
+      //  An ordered region may not be closely nested inside a critical, atomic,
+      //  or explicit task region.
+      NestingProhibited =
+          Kind == OMPD_for || Kind == OMPD_sections || Kind == OMPD_for_simd ||
+          Kind == OMPD_distribute_simd || Kind == OMPD_distribute ||
+          Kind == OMPD_distribute_parallel_for ||
+          Kind == OMPD_distribute_parallel_for_simd || Kind == OMPD_single ||
+          HasNamedDirective || Kind == OMPD_barrier || Kind == OMPD_ordered ||
+          Kind == OMPD_cancel || Kind == OMPD_cancellation_point;
+      Region = "a critical";
+      break;
+    case OMPD_atomic:
+      // OpenMP [2.16, Nesting of Regions, p. 7]
+      //  OpenMP constructs may not be nested inside an atomic region.
+      NestingProhibited = true;
+      Region = "an atomic";
+      break;
+    case OMPD_simd:
+      // OpenMP [2.16, Nesting of Regions, p. 8]
+      //  OpenMP constructs may not be nested inside a simd region.
+      NestingProhibited = true;
+      Region = "a simd";
+      break;
+    case OMPD_for_simd:
+      // OpenMP [2.16, Nesting of Regions, p. 8]
+      //  OpenMP constructs may not be nested inside a simd region.
+      NestingProhibited = true;
+      Region = "a for simd";
+      break;
+    case OMPD_distribute_simd:
+      // OpenMP [2.16, Nesting of Regions, p. 8]
+      //  OpenMP constructs may not be nested inside a simd region.
+      NestingProhibited = true;
+      Region = "a distribute simd";
+      break;
+    case OMPD_parallel_for_simd:
+      // OpenMP [2.16, Nesting of Regions, p. 8]
+      //  OpenMP constructs may not be nested inside a simd region.
+      NestingProhibited = true;
+      Region = "a parallel for simd";
+      break;
+    case OMPD_distribute_parallel_for_simd:
+      // OpenMP [2.16, Nesting of Regions, p. 8]
+      //  OpenMP constructs may not be nested inside a simd region.
+      NestingProhibited = true;
+      Region = "a distribute parallel for simd";
+      break;
+    case OMPD_teams_distribute_parallel_for_simd:
+      // OpenMP [2.16, Nesting of Regions, p. 8]
+      //  OpenMP constructs may not be nested inside a simd region.
+      NestingProhibited = true;
+      Region = "a teams distribute parallel for simd";
+      break;
+    case OMPD_target_teams_distribute_parallel_for_simd:
+      // OpenMP [2.16, Nesting of Regions, p. 8]
+      //  OpenMP constructs may not be nested inside a simd region.
+      NestingProhibited = true;
+      Region = "a target teams distribute parallel for simd";
+      break;
+    case OMPD_ordered:
+      // OpenMP [2.16, Nesting of Regions, p. 1]
+      //  A worksharing region may not be closely nested inside a worksharing,
+      //  explicit task, critical, ordered, atomic, or master region.
+      // OpenMP [2.16, Nesting of Regions, p. 2]
+      //  A barrier region may not be closely nested inside a worksharing,
+      //  explicit task, critical, ordered, atomic, or master region.
+      // OpenMP [2.16, Nesting of Regions, p. 3]
+      //  A master region may not be closely nested inside a worksharing,
+      // atomic,
+      //  or explicit task region.
+      NestingProhibited =
+          Kind == OMPD_for || Kind == OMPD_sections || Kind == OMPD_for_simd ||
+          Kind == OMPD_distribute_simd || Kind == OMPD_distribute ||
+          Kind == OMPD_distribute_parallel_for ||
+          Kind == OMPD_distribute_parallel_for_simd || Kind == OMPD_single ||
+          Kind == OMPD_master || Kind == OMPD_barrier || Kind == OMPD_cancel ||
+          Kind == OMPD_cancellation_point;
+      Region = "an ordered";
+      break;
+    case OMPD_teams:
+      // OpenMP [2.16, Nesting of Regions, p. 11]
+      // distribute, parallel, parallel sections, parallel workshare, and
+      // the parallel loop and parallel loop SIMD constructs are the only
+      // OpenMP constructs that can be closely nested in the teams region.
+      NestingProhibited =
+          Kind == OMPD_for || Kind == OMPD_sections || Kind == OMPD_single ||
+          Kind == OMPD_for_simd || Kind == OMPD_simd || Kind == OMPD_master ||
+          Kind == OMPD_barrier || Kind == OMPD_task || Kind == OMPD_ordered ||
+          Kind == OMPD_teams || Kind == OMPD_atomic || Kind == OMPD_critical ||
+          Kind == OMPD_taskgroup || Kind == OMPD_cancel ||
+          Kind == OMPD_cancellation_point || Kind == OMPD_target_teams ||
+          Kind == OMPD_teams_distribute || Kind == OMPD_teams_distribute_simd ||
+          Kind == OMPD_target_teams_distribute ||
+          Kind == OMPD_target_teams_distribute_simd ||
+          Kind == OMPD_teams_distribute_parallel_for ||
+          Kind == OMPD_teams_distribute_parallel_for_simd ||
+          Kind == OMPD_target_teams_distribute_parallel_for ||
+          Kind == OMPD_target_teams_distribute_parallel_for_simd;
+      Region = "a teams";
+      break;
+    case OMPD_teams_distribute:
+      NestingProhibited =
+          Kind == OMPD_for || Kind == OMPD_sections || Kind == OMPD_for_simd ||
+          Kind == OMPD_distribute_simd || Kind == OMPD_distribute ||
+          Kind == OMPD_distribute_parallel_for ||
+          Kind == OMPD_distribute_parallel_for_simd || Kind == OMPD_single ||
+          Kind == OMPD_master || Kind == OMPD_barrier ||
+          (Kind == OMPD_cancel && !ConstructTypeMatches) ||
+          (Kind == OMPD_cancellation_point && !ConstructTypeMatches);
+      Region = "a teams distribute";
+      break;
+    case OMPD_target_teams_distribute:
+      NestingProhibited =
+          Kind == OMPD_for || Kind == OMPD_sections || Kind == OMPD_for_simd ||
+          Kind == OMPD_distribute_simd || Kind == OMPD_distribute ||
+          Kind == OMPD_distribute_parallel_for ||
+          Kind == OMPD_distribute_parallel_for_simd || Kind == OMPD_single ||
+          Kind == OMPD_master || Kind == OMPD_barrier ||
+          (Kind == OMPD_cancel && !ConstructTypeMatches) ||
+          (Kind == OMPD_cancellation_point && !ConstructTypeMatches);
+      Region = "a target teams distribute";
+      break;
+    case OMPD_teams_distribute_simd:
+      // OpenMP [2.16, Nesting of Regions, p. 8]
+      //  OpenMP constructs may not be nested inside a simd region.
+      NestingProhibited = true;
+      Region = "a teams distribute simd";
+      break;
+    case OMPD_target_teams_distribute_simd:
+      // OpenMP [2.16, Nesting of Regions, p. 8]
+      //  OpenMP constructs may not be nested inside a simd region.
+      NestingProhibited = true;
+      Region = "a target teams distribute simd";
+      break;
+    case OMPD_target_teams:
+      // OpenMP [2.16, Nesting of Regions, p. 11]
+      // distribute, parallel, parallel sections, parallel workshare, and
+      // the parallel loop and parallel loop SIMD constructs are the only
+      // OpenMP constructs that can be closely nested in the teams region.
+      NestingProhibited =
+          Kind == OMPD_for || Kind == OMPD_sections || Kind == OMPD_single ||
+          Kind == OMPD_for_simd || Kind == OMPD_simd || Kind == OMPD_master ||
+          Kind == OMPD_barrier || Kind == OMPD_task || Kind == OMPD_ordered ||
+          Kind == OMPD_teams || Kind == OMPD_atomic || Kind == OMPD_critical ||
+          Kind == OMPD_taskgroup || Kind == OMPD_cancel ||
+          Kind == OMPD_cancellation_point || Kind == OMPD_target_teams ||
+          Kind == OMPD_teams_distribute || Kind == OMPD_teams_distribute_simd ||
+          Kind == OMPD_target_teams_distribute ||
+          Kind == OMPD_target_teams_distribute_simd ||
+          Kind == OMPD_teams_distribute_parallel_for ||
+          Kind == OMPD_teams_distribute_parallel_for_simd ||
+          Kind == OMPD_target_teams_distribute_parallel_for ||
+          Kind == OMPD_target_teams_distribute_parallel_for_simd;
+      Region = "a target teams";
+      break;
+    case OMPD_distribute:
+      NestingProhibited =
+          Kind == OMPD_for || Kind == OMPD_sections || Kind == OMPD_for_simd ||
+          Kind == OMPD_distribute_simd || Kind == OMPD_distribute ||
+          Kind == OMPD_distribute_parallel_for ||
+          Kind == OMPD_distribute_parallel_for_simd || Kind == OMPD_single ||
+          Kind == OMPD_master || Kind == OMPD_barrier ||
+          (Kind == OMPD_cancel && !ConstructTypeMatches) ||
+          (Kind == OMPD_cancellation_point && !ConstructTypeMatches);
+      Region = "a distribute";
+      break;
+    case OMPD_taskgroup:
+      NestingProhibited =
+          (Kind == OMPD_cancel) || (Kind == OMPD_cancellation_point);
+      Region = "a taskgroup";
+      break;
+    default:
+      break;
+    }
+    // OpenMP [2.16, Nesting of Regions, p. 6]
+    //  A critical region may not be nested (closely or otherwise) inside a
+    //  critical region with the same name. Note that this restriction is not
+    //  sufficient to prevent deadlock.
+    if (DirName.getName() && Kind == OMPD_critical) {
+      HasNamedDirective = DSAStack->hasDirectiveWithName(Kind, DirName);
+      CloseNesting = false;
+      NestingProhibited = HasNamedDirective;
+      Region = "a critical";
+    }
+    if (NestingProhibited) {
+      Diag(StartLoc, diag::err_omp_prohibited_region)
+          << CloseNesting << Region << HasNamedDirective << DirName.getName();
+      return StmtError();
+    }
+    // OpenMP [2.16, Nesting of Regions, p. 5]
+    //  An ordered region must be closely nested inside a loop region (or
+    //  parallel loop region) with an ordered clause.
+    if (Kind == OMPD_ordered &&
+        (ParentKind != OMPD_unknown && !DSAStack->isParentRegionOrdered())) {
+      Diag(StartLoc, diag::err_omp_prohibited_ordered_region);
+      return StmtError();
+    }
+    if (Kind == OMPD_cancel && ParentKind != OMPD_unknown) {
+      // OpenMP [2.16, Nesting of Regions, p. 13]
+      // the cancel construct must be nested inside a taskgroup region.
+      if (ConstructType == OMPD_taskgroup &&
+          !DSAStack->hasDirective(OMPD_taskgroup)) {
+        Diag(StartLoc, diag::err_omp_prohibited_cancel_region);
+        return StmtError();
+      }
+      // OpenMP [2.13.1, cancel Construct, Restriction]
+      // A worksharing construct that is cancelled must not have a nowait
+      // clause.
+      if ((ConstructType == OMPD_for || ConstructType == OMPD_sections) &&
+          DSAStack->isRegionNowait()) {
+        Diag(StartLoc, diag::err_omp_prohibited_cancel_region_nowait);
+        return StmtError();
+      }
+      // OpenMP [2.13.1, cancel Construct, Restriction]
+      // A loop construct that is cancelled must not have an ordered clause.
+      if (ConstructType == OMPD_for && DSAStack->isRegionOrdered()) {
+        Diag(StartLoc, diag::err_omp_prohibited_cancel_region_ordered);
+        return StmtError();
+      }
+    }
+    // OpenMP [2.16, Nesting of Regions, p. 5]
+    //  A distribute construct must be closely nested in a teams region.
+    if ((Kind == OMPD_distribute || Kind == OMPD_distribute_simd ||
+         Kind == OMPD_distribute_parallel_for ||
+         Kind == OMPD_distribute_parallel_for_simd) &&
+        (ParentKind != OMPD_unknown && ParentKind != OMPD_teams &&
+         ParentKind != OMPD_target_teams)) {
+      Diag(StartLoc, diag::err_omp_prohibited_distribute_region);
+      return StmtError();
+    }
+    // OpenMP [2.16, Nesting of Regions, p. 10]
+    //  If specified, a teams construct must be contained within a target
+    // construct.
+    if ((Kind == OMPD_teams || Kind == OMPD_teams_distribute ||
+         Kind == OMPD_teams_distribute_simd ||
+         Kind == OMPD_teams_distribute_parallel_for ||
+         Kind == OMPD_teams_distribute_parallel_for_simd) &&
+        ParentKind != OMPD_target) {
+      Diag(StartLoc, diag::err_omp_prohibited_teams_region);
+      return StmtError();
+    }
+  }
+  if (Kind == OMPD_task) {
+    assert(AStmt && isa<CapturedStmt>(AStmt) && "Captured statement expected");
+    // Check default data sharing attributes for captured variables.
     DSAAttrChecker DSAChecker(DSAStack, *this, cast<CapturedStmt>(AStmt));
     DSAChecker.Visit(cast<CapturedStmt>(AStmt)->getCapturedStmt());
     if (DSAChecker.isErrorFound())
       return StmtError();
-    // Generate list of implicitly defined firstprivate variables.
-    VarsWithInheritedDSA = DSAChecker.getVarsWithInheritedDSA();
-
-    if (!DSAChecker.getImplicitFirstprivate().empty()) {
-      if (OMPClause *Implicit = ActOnOpenMPFirstprivateClause(
+    if (DSAChecker.getImplicitFirstprivate().size() > 0) {
+      if (OMPClause *Implicit = ActOnOpenMPFirstPrivateClause(
               DSAChecker.getImplicitFirstprivate(), SourceLocation(),
-              SourceLocation(), SourceLocation())) {
+              SourceLocation())) {
         ClausesWithImplicit.push_back(Implicit);
-        ErrorFound = cast<OMPFirstprivateClause>(Implicit)->varlist_size() !=
-                     DSAChecker.getImplicitFirstprivate().size();
+        if (Implicit &&
+            cast<OMPFirstPrivateClause>(Implicit)->varlist_size() !=
+                DSAChecker.getImplicitFirstprivate().size())
+          ErrorFound = true;
       } else
         ErrorFound = true;
     }
   }
+  ClausesWithImplicit.append(Clauses.begin(), Clauses.end());
 
+  StmtResult Res = StmtError();
   switch (Kind) {
   case OMPD_parallel:
     Res = ActOnOpenMPParallelDirective(ClausesWithImplicit, AStmt, StartLoc,
                                        EndLoc);
     break;
-  case OMPD_simd:
-    Res = ActOnOpenMPSimdDirective(ClausesWithImplicit, AStmt, StartLoc, EndLoc,
-                                   VarsWithInheritedDSA);
+  case OMPD_parallel_for:
+    Res = ActOnOpenMPParallelForDirective(Kind, ClausesWithImplicit, AStmt,
+                                          StartLoc, EndLoc);
     break;
   case OMPD_for:
-    Res = ActOnOpenMPForDirective(ClausesWithImplicit, AStmt, StartLoc, EndLoc,
-                                  VarsWithInheritedDSA);
+    Res = ActOnOpenMPForDirective(Kind, ClausesWithImplicit, AStmt, StartLoc,
+                                  EndLoc);
+    break;
+  case OMPD_parallel_sections:
+    Res = ActOnOpenMPParallelSectionsDirective(Kind, ClausesWithImplicit, AStmt,
+                                               StartLoc, EndLoc);
     break;
   case OMPD_sections:
-    Res = ActOnOpenMPSectionsDirective(ClausesWithImplicit, AStmt, StartLoc,
-                                       EndLoc);
+    Res = ActOnOpenMPSectionsDirective(Kind, ClausesWithImplicit, AStmt,
+                                       StartLoc, EndLoc);
     break;
   case OMPD_section:
-    assert(ClausesWithImplicit.empty() &&
-           "No clauses are allowed for 'omp section' directive");
+    assert(Clauses.empty() && "Clauses are not allowed for section");
     Res = ActOnOpenMPSectionDirective(AStmt, StartLoc, EndLoc);
     break;
   case OMPD_single:
     Res = ActOnOpenMPSingleDirective(ClausesWithImplicit, AStmt, StartLoc,
                                      EndLoc);
     break;
-  case OMPD_master:
-    assert(ClausesWithImplicit.empty() &&
-           "No clauses are allowed for 'omp master' directive");
-    Res = ActOnOpenMPMasterDirective(AStmt, StartLoc, EndLoc);
-    break;
-  case OMPD_critical:
-    assert(ClausesWithImplicit.empty() &&
-           "No clauses are allowed for 'omp critical' directive");
-    Res = ActOnOpenMPCriticalDirective(DirName, AStmt, StartLoc, EndLoc);
-    break;
-  case OMPD_parallel_for:
-    Res = ActOnOpenMPParallelForDirective(ClausesWithImplicit, AStmt, StartLoc,
-                                          EndLoc, VarsWithInheritedDSA);
-    break;
-  case OMPD_parallel_sections:
-    Res = ActOnOpenMPParallelSectionsDirective(ClausesWithImplicit, AStmt,
-                                               StartLoc, EndLoc);
-    break;
   case OMPD_task:
     Res =
         ActOnOpenMPTaskDirective(ClausesWithImplicit, AStmt, StartLoc, EndLoc);
     break;
   case OMPD_taskyield:
-    assert(ClausesWithImplicit.empty() &&
-           "No clauses are allowed for 'omp taskyield' directive");
-    assert(AStmt == nullptr &&
-           "No associated statement allowed for 'omp taskyield' directive");
+    assert(Clauses.empty() && !AStmt &&
+           "Clauses and statement are not allowed for taskyield");
     Res = ActOnOpenMPTaskyieldDirective(StartLoc, EndLoc);
     break;
+  case OMPD_master:
+    assert(Clauses.empty() && "Clauses are not allowed for master");
+    Res = ActOnOpenMPMasterDirective(AStmt, StartLoc, EndLoc);
+    break;
+  case OMPD_critical:
+    assert(Clauses.empty() && "Clauses are not allowed for critical");
+    Res = ActOnOpenMPCriticalDirective(DirName, AStmt, StartLoc, EndLoc);
+    break;
   case OMPD_barrier:
-    assert(ClausesWithImplicit.empty() &&
-           "No clauses are allowed for 'omp barrier' directive");
-    assert(AStmt == nullptr &&
-           "No associated statement allowed for 'omp barrier' directive");
+    assert(Clauses.empty() && !AStmt &&
+           "Clauses and statement are not allowed for barrier");
     Res = ActOnOpenMPBarrierDirective(StartLoc, EndLoc);
     break;
   case OMPD_taskwait:
-    assert(ClausesWithImplicit.empty() &&
-           "No clauses are allowed for 'omp taskwait' directive");
-    assert(AStmt == nullptr &&
-           "No associated statement allowed for 'omp taskwait' directive");
+    assert(Clauses.empty() && !AStmt &&
+           "Clauses and statement are not allowed for taskwait");
     Res = ActOnOpenMPTaskwaitDirective(StartLoc, EndLoc);
     break;
+  case OMPD_taskgroup:
+    assert(Clauses.empty() && "Clauses are not allowed for taskgroup");
+    Res = ActOnOpenMPTaskgroupDirective(AStmt, StartLoc, EndLoc);
+    break;
+  case OMPD_atomic:
+    Res = ActOnOpenMPAtomicDirective(ClausesWithImplicit, AStmt, StartLoc,
+                                     EndLoc);
+    break;
   case OMPD_flush:
-    assert(AStmt == nullptr &&
-           "No associated statement allowed for 'omp flush' directive");
+    assert(!AStmt && "Statement is not allowed for flush");
     Res = ActOnOpenMPFlushDirective(ClausesWithImplicit, StartLoc, EndLoc);
     break;
-  case OMPD_threadprivate:
-    llvm_unreachable("OpenMP Directive is not allowed");
-  case OMPD_unknown:
-    llvm_unreachable("Unknown OpenMP directive");
+  case OMPD_ordered:
+    assert(Clauses.empty() && "Clauses are not allowed for ordered");
+    Res = ActOnOpenMPOrderedDirective(AStmt, StartLoc, EndLoc);
+    break;
+  case OMPD_simd:
+    Res = ActOnOpenMPSimdDirective(Kind, ClausesWithImplicit, AStmt, StartLoc,
+                                   EndLoc);
+    break;
+  case OMPD_for_simd:
+    Res = ActOnOpenMPForSimdDirective(Kind, ClausesWithImplicit, AStmt,
+                                      StartLoc, EndLoc);
+    break;
+  case OMPD_parallel_for_simd:
+    Res = ActOnOpenMPParallelForSimdDirective(Kind, ClausesWithImplicit, AStmt,
+                                              StartLoc, EndLoc);
+    break;
+  case OMPD_distribute_simd:
+    Res = ActOnOpenMPDistributeSimdDirective(Kind, ClausesWithImplicit, AStmt,
+                                             StartLoc, EndLoc);
+    break;
+  case OMPD_distribute_parallel_for:
+    Res = ActOnOpenMPDistributeParallelForDirective(Kind, ClausesWithImplicit,
+                                                    AStmt, StartLoc, EndLoc);
+    break;
+  case OMPD_distribute_parallel_for_simd:
+    Res = ActOnOpenMPDistributeParallelForSimdDirective(
+        Kind, ClausesWithImplicit, AStmt, StartLoc, EndLoc);
+    break;
+  case OMPD_teams_distribute_parallel_for:
+    Res = ActOnOpenMPTeamsDistributeParallelForDirective(
+        Kind, ClausesWithImplicit, AStmt, StartLoc, EndLoc);
+    break;
+  case OMPD_teams_distribute_parallel_for_simd:
+    Res = ActOnOpenMPTeamsDistributeParallelForSimdDirective(
+        Kind, ClausesWithImplicit, AStmt, StartLoc, EndLoc);
+    break;
+  case OMPD_target_teams_distribute_parallel_for:
+    Res = ActOnOpenMPTargetTeamsDistributeParallelForDirective(
+        Kind, ClausesWithImplicit, AStmt, StartLoc, EndLoc);
+    break;
+  case OMPD_target_teams_distribute_parallel_for_simd:
+    Res = ActOnOpenMPTargetTeamsDistributeParallelForSimdDirective(
+        Kind, ClausesWithImplicit, AStmt, StartLoc, EndLoc);
+    break;
+  case OMPD_teams:
+    Res =
+        ActOnOpenMPTeamsDirective(ClausesWithImplicit, AStmt, StartLoc, EndLoc);
+    break;
+  case OMPD_target_teams:
+    Res = ActOnOpenMPTargetTeamsDirective(ClausesWithImplicit, AStmt, StartLoc,
+                                          EndLoc);
+    break;
+  case OMPD_distribute:
+    Res = ActOnOpenMPDistributeDirective(ClausesWithImplicit, AStmt, StartLoc,
+                                         EndLoc);
+    break;
+  case OMPD_target:
+    Res = ActOnOpenMPTargetDirective(ClausesWithImplicit, AStmt, StartLoc,
+                                     EndLoc);
+    break;
+  case OMPD_target_data:
+    Res = ActOnOpenMPTargetDataDirective(ClausesWithImplicit, AStmt, StartLoc,
+                                         EndLoc);
+    break;
+  case OMPD_target_update:
+    assert(!AStmt && "Statement is not allowed for target update");
+    Res =
+        ActOnOpenMPTargetUpdateDirective(ClausesWithImplicit, StartLoc, EndLoc);
+    break;
+  case OMPD_cancel:
+    assert(!AStmt && "Statement is not allowed for cancel");
+    if (ConstructType == OMPD_unknown)
+      return StmtError();
+    Res = ActOnOpenMPCancelDirective(ClausesWithImplicit, StartLoc, EndLoc,
+                                     ConstructType);
+    break;
+  case OMPD_cancellation_point:
+    assert(!AStmt && "Statement is not allowed for cancellation point");
+    assert(Clauses.empty() && "Clauses are not allowed for cancellation point");
+    if (ConstructType == OMPD_unknown)
+      return StmtError();
+    Res =
+        ActOnOpenMPCancellationPointDirective(StartLoc, EndLoc, ConstructType);
+    break;
+  case OMPD_teams_distribute:
+    Res = ActOnOpenMPTeamsDistributeDirective(ClausesWithImplicit, AStmt,
+                                              StartLoc, EndLoc);
+    break;
+  case OMPD_teams_distribute_simd:
+    Res = ActOnOpenMPTeamsDistributeSimdDirective(Kind, ClausesWithImplicit,
+                                                  AStmt, StartLoc, EndLoc);
+    break;
+  case OMPD_target_teams_distribute:
+    Res = ActOnOpenMPTargetTeamsDistributeDirective(ClausesWithImplicit, AStmt,
+                                                    StartLoc, EndLoc);
+    break;
+  case OMPD_target_teams_distribute_simd:
+    Res = ActOnOpenMPTargetTeamsDistributeSimdDirective(
+        Kind, ClausesWithImplicit, AStmt, StartLoc, EndLoc);
+    break;
+  default:
+    break;
+  }
+  // Additional analysis for all directives except for task
+  switch (Kind) {
+  case OMPD_taskyield:
+  case OMPD_barrier:
+  case OMPD_taskwait:
+  case OMPD_flush:
+  case OMPD_cancel:
+  case OMPD_cancellation_point:
+  case OMPD_target_update:
+  case OMPD_task:
+    break;
+  default: {
+    assert(AStmt && isa<CapturedStmt>(AStmt) && "Captured statement expected");
+    // Check default data sharing attributes for captured variables.
+    DSAAttrChecker DSAChecker(DSAStack, *this, cast<CapturedStmt>(AStmt));
+    DSAChecker.Visit(cast<CapturedStmt>(AStmt)->getCapturedStmt());
+    if (DSAChecker.isErrorFound())
+      return StmtError();
+    if (DSAChecker.getImplicitFirstprivate().size() > 0) {
+      if (OMPClause *Implicit = ActOnOpenMPFirstPrivateClause(
+              DSAChecker.getImplicitFirstprivate(), SourceLocation(),
+              SourceLocation())) {
+        ClausesWithImplicit.push_back(Implicit);
+        if (Implicit &&
+            cast<OMPFirstPrivateClause>(Implicit)->varlist_size() !=
+                DSAChecker.getImplicitFirstprivate().size())
+          ErrorFound = true;
+      } else
+        ErrorFound = true;
+    }
+    break;
   }
-
-  for (auto P : VarsWithInheritedDSA) {
-    Diag(P.second->getExprLoc(), diag::err_omp_no_dsa_for_variable)
-        << P.first << P.second->getSourceRange();
   }
-  if (!VarsWithInheritedDSA.empty())
-    return StmtError();
 
   if (ErrorFound)
     return StmtError();
+
   return Res;
 }
 
@@ -1509,611 +2407,848 @@
                                               Stmt *AStmt,
                                               SourceLocation StartLoc,
                                               SourceLocation EndLoc) {
-  assert(AStmt && isa<CapturedStmt>(AStmt) && "Captured statement expected");
-  CapturedStmt *CS = cast<CapturedStmt>(AStmt);
-  // 1.2.2 OpenMP Language Terminology
-  // Structured block - An executable statement with a single entry at the
-  // top and a single exit at the bottom.
-  // The point of exit cannot be a branch out of the structured block.
-  // longjmp() and throw() must not violate the entry/exit criteria.
-  CS->getCapturedDecl()->setNothrow();
 
   getCurFunction()->setHasBranchProtectedScope();
-
   return OMPParallelDirective::Create(Context, StartLoc, EndLoc, Clauses,
                                       AStmt);
 }
 
 namespace {
-/// \brief Helper class for checking canonical form of the OpenMP loops and
-/// extracting iteration space of each loop in the loop nest, that will be used
-/// for IR generation.
-class OpenMPIterationSpaceChecker {
-  /// \brief Reference to Sema.
-  Sema &SemaRef;
-  /// \brief A location for diagnostics (when there is no some better location).
-  SourceLocation DefaultLoc;
-  /// \brief A location for diagnostics (when increment is not compatible).
-  SourceLocation ConditionLoc;
-  /// \brief A source location for referring to condition later.
-  SourceRange ConditionSrcRange;
-  /// \brief Loop variable.
-  VarDecl *Var;
-  /// \brief Lower bound (initializer for the var).
-  Expr *LB;
-  /// \brief Upper bound.
-  Expr *UB;
-  /// \brief Loop step (increment).
-  Expr *Step;
-  /// \brief This flag is true when condition is one of:
-  ///   Var <  UB
-  ///   Var <= UB
-  ///   UB  >  Var
-  ///   UB  >= Var
-  bool TestIsLessOp;
-  /// \brief This flag is true when condition is strict ( < or > ).
-  bool TestIsStrictOp;
-  /// \brief This flag is true when step is subtracted on each iteration.
-  bool SubtractStep;
+class ForBreakStmtChecker : public StmtVisitor<ForBreakStmtChecker, bool> {
+  Stmt *Break;
 
 public:
-  OpenMPIterationSpaceChecker(Sema &SemaRef, SourceLocation DefaultLoc)
-      : SemaRef(SemaRef), DefaultLoc(DefaultLoc), ConditionLoc(DefaultLoc),
-        ConditionSrcRange(SourceRange()), Var(nullptr), LB(nullptr),
-        UB(nullptr), Step(nullptr), TestIsLessOp(false), TestIsStrictOp(false),
-        SubtractStep(false) {}
-  /// \brief Check init-expr for canonical loop form and save loop counter
-  /// variable - #Var and its initialization value - #LB.
-  bool CheckInit(Stmt *S);
-  /// \brief Check test-expr for canonical form, save upper-bound (#UB), flags
-  /// for less/greater and for strict/non-strict comparison.
-  bool CheckCond(Expr *S);
-  /// \brief Check incr-expr for canonical loop form and return true if it
-  /// does not conform, otherwise save loop step (#Step).
-  bool CheckInc(Expr *S);
-  /// \brief Return the loop counter variable.
-  VarDecl *GetLoopVar() const { return Var; }
-  /// \brief Return true if any expression is dependent.
-  bool Dependent() const;
-
-private:
-  /// \brief Check the right-hand side of an assignment in the increment
-  /// expression.
-  bool CheckIncRHS(Expr *RHS);
-  /// \brief Helper to set loop counter variable and its initializer.
-  bool SetVarAndLB(VarDecl *NewVar, Expr *NewLB);
-  /// \brief Helper to set upper bound.
-  bool SetUB(Expr *NewUB, bool LessOp, bool StrictOp, const SourceRange &SR,
-             const SourceLocation &SL);
-  /// \brief Helper to set loop increment.
-  bool SetStep(Expr *NewStep, bool Subtract);
-};
-
-bool OpenMPIterationSpaceChecker::Dependent() const {
-  if (!Var) {
-    assert(!LB && !UB && !Step);
+  bool VisitBreakStmt(BreakStmt *S) {
+    Break = S;
+    return true;
+  }
+  bool VisitSwitchStmt(SwitchStmt *S) { return false; }
+  bool VisitWhileStmt(WhileStmt *S) { return false; }
+  bool VisitDoStmt(DoStmt *S) { return false; }
+  bool VisitForStmt(ForStmt *S) { return false; }
+  bool VisitCXXForRangeStmt(CXXForRangeStmt *S) { return false; }
+  bool VisitStmt(Stmt *S) {
+    for (Stmt::child_iterator I = S->child_begin(), E = S->child_end(); I != E;
+         ++I) {
+      if (*I && Visit(*I))
+        return true;
+    }
     return false;
   }
-  return Var->getType()->isDependentType() || (LB && LB->isValueDependent()) ||
-         (UB && UB->isValueDependent()) || (Step && Step->isValueDependent());
+  ForBreakStmtChecker() {}
+  Stmt *getBreak() { return Break; }
+};
 }
 
-bool OpenMPIterationSpaceChecker::SetVarAndLB(VarDecl *NewVar, Expr *NewLB) {
-  // State consistency checking to ensure correct usage.
-  assert(Var == nullptr && LB == nullptr && UB == nullptr && Step == nullptr &&
-         !TestIsLessOp && !TestIsStrictOp);
-  if (!NewVar || !NewLB)
-    return true;
-  Var = NewVar;
-  LB = NewLB;
-  return false;
-}
+namespace {
+class EhChecker : public StmtVisitor<EhChecker, bool> {
+  Stmt *BadStmt;
 
-bool OpenMPIterationSpaceChecker::SetUB(Expr *NewUB, bool LessOp, bool StrictOp,
-                                        const SourceRange &SR,
-                                        const SourceLocation &SL) {
-  // State consistency checking to ensure correct usage.
-  assert(Var != nullptr && LB != nullptr && UB == nullptr && Step == nullptr &&
-         !TestIsLessOp && !TestIsStrictOp);
-  if (!NewUB)
+public:
+  bool VisitCXXCatchStmt(CXXCatchStmt *S) {
+    BadStmt = S;
     return true;
-  UB = NewUB;
-  TestIsLessOp = LessOp;
-  TestIsStrictOp = StrictOp;
-  ConditionSrcRange = SR;
-  ConditionLoc = SL;
-  return false;
-}
-
-bool OpenMPIterationSpaceChecker::SetStep(Expr *NewStep, bool Subtract) {
-  // State consistency checking to ensure correct usage.
-  assert(Var != nullptr && LB != nullptr && Step == nullptr);
-  if (!NewStep)
+  }
+  bool VisitCXXThrowExpr(CXXThrowExpr *S) {
+    BadStmt = S;
     return true;
-  if (!NewStep->isValueDependent()) {
-    // Check that the step is integer expression.
-    SourceLocation StepLoc = NewStep->getLocStart();
-    ExprResult Val =
-        SemaRef.PerformOpenMPImplicitIntegerConversion(StepLoc, NewStep);
-    if (Val.isInvalid())
-      return true;
-    NewStep = Val.get();
-
-    // OpenMP [2.6, Canonical Loop Form, Restrictions]
-    //  If test-expr is of form var relational-op b and relational-op is < or
-    //  <= then incr-expr must cause var to increase on each iteration of the
-    //  loop. If test-expr is of form var relational-op b and relational-op is
-    //  > or >= then incr-expr must cause var to decrease on each iteration of
-    //  the loop.
-    //  If test-expr is of form b relational-op var and relational-op is < or
-    //  <= then incr-expr must cause var to decrease on each iteration of the
-    //  loop. If test-expr is of form b relational-op var and relational-op is
-    //  > or >= then incr-expr must cause var to increase on each iteration of
-    //  the loop.
-    llvm::APSInt Result;
-    bool IsConstant = NewStep->isIntegerConstantExpr(Result, SemaRef.Context);
-    bool IsUnsigned = !NewStep->getType()->hasSignedIntegerRepresentation();
-    bool IsConstNeg =
-        IsConstant && Result.isSigned() && (Subtract != Result.isNegative());
-    bool IsConstZero = IsConstant && !Result.getBoolValue();
-    if (UB && (IsConstZero ||
-               (TestIsLessOp ? (IsConstNeg || (IsUnsigned && Subtract))
-                             : (!IsConstNeg || (IsUnsigned && !Subtract))))) {
-      SemaRef.Diag(NewStep->getExprLoc(),
-                   diag::err_omp_loop_incr_not_compatible)
-          << Var << TestIsLessOp << NewStep->getSourceRange();
-      SemaRef.Diag(ConditionLoc,
-                   diag::note_omp_loop_cond_requres_compatible_incr)
-          << TestIsLessOp << ConditionSrcRange;
-      return true;
+  }
+  bool VisitCXXTryStmt(CXXTryStmt *S) {
+    BadStmt = S;
+    return true;
+  }
+  bool VisitStmt(Stmt *S) {
+    for (Stmt::child_iterator I = S->child_begin(), E = S->child_end(); I != E;
+         ++I) {
+      if (*I && Visit(*I))
+        return true;
     }
+    return false;
   }
-
-  Step = NewStep;
-  SubtractStep = Subtract;
-  return false;
+  EhChecker() {}
+  Stmt *getBadStmt() { return BadStmt; }
+};
 }
 
-bool OpenMPIterationSpaceChecker::CheckInit(Stmt *S) {
-  // Check init-expr for canonical loop form and save loop counter
-  // variable - #Var and its initialization value - #LB.
-  // OpenMP [2.6] Canonical loop form. init-expr may be one of the following:
-  //   var = lb
-  //   integer-type var = lb
-  //   random-access-iterator-type var = lb
-  //   pointer-type var = lb
+bool Sema::CollapseOpenMPLoop(OpenMPDirectiveKind Kind,
+                              ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+                              SourceLocation StartLoc, SourceLocation EndLoc,
+                              Expr *&NewVar, Expr *&NewEnd,
+                              Expr *&NewVarCntExpr, Expr *&NewFinal,
+                              SmallVector<Expr *, 4> &VarCnts) {
+  // This is helper routine to process collapse clause that
+  // can be met in directives 'for', 'simd', 'for simd' and others.
   //
-  if (!S) {
-    SemaRef.Diag(DefaultLoc, diag::err_omp_loop_not_canonical_init);
+  // OpenMP [2.7.1, Loop construct, Description]
+  //  The collapse clause may be used to specify how many loops are
+  //  associated with the loop construct.
+  //
+  NewVar = 0;
+  NewEnd = 0;
+  NewVarCntExpr = 0;
+  NewFinal = 0;
+  VarCnts.clear();
+  FunctionDecl *FD = getCurFunctionDecl();
+  if (FD && FD->isDependentContext())
     return true;
+  SmallVector<Expr *, 4> Ends;
+  SmallVector<Expr *, 4> Incrs;
+  SmallVector<Expr *, 4> Inits;
+  SmallVector<BinaryOperatorKind, 4> OpKinds;
+  unsigned StmtCount = 1;
+  for (ArrayRef<OMPClause *>::iterator I = Clauses.begin(), E = Clauses.end();
+       I != E; ++I) {
+    if (OMPCollapseClause *Clause = dyn_cast_or_null<OMPCollapseClause>(*I)) {
+      IntegerLiteral *IL = cast<IntegerLiteral>(Clause->getNumForLoops());
+      StmtCount = IL->getValue().getLimitedValue();
+      break;
+    }
   }
-  if (Expr *E = dyn_cast<Expr>(S))
-    S = E->IgnoreParens();
-  if (auto BO = dyn_cast<BinaryOperator>(S)) {
-    if (BO->getOpcode() == BO_Assign)
-      if (auto DRE = dyn_cast<DeclRefExpr>(BO->getLHS()->IgnoreParens()))
-        return SetVarAndLB(dyn_cast<VarDecl>(DRE->getDecl()), BO->getLHS());
-  } else if (auto DS = dyn_cast<DeclStmt>(S)) {
-    if (DS->isSingleDecl()) {
-      if (auto Var = dyn_cast_or_null<VarDecl>(DS->getSingleDecl())) {
-        if (Var->hasInit()) {
-          // Accept non-canonical init form here but emit ext. warning.
-          if (Var->getInitStyle() != VarDecl::CInit)
-            SemaRef.Diag(S->getLocStart(),
-                         diag::ext_omp_loop_not_canonical_init)
-                << S->getSourceRange();
-          return SetVarAndLB(Var, Var->getInit());
+  Stmt *CStmt = AStmt;
+  while (CapturedStmt *CS = dyn_cast_or_null<CapturedStmt>(CStmt))
+    CStmt = CS->getCapturedStmt();
+  while (AttributedStmt *AS = dyn_cast_or_null<AttributedStmt>(CStmt))
+    CStmt = AS->getSubStmt();
+  bool SkipExprCount = false;
+  for (unsigned Cnt = 0; Cnt < StmtCount; ++Cnt) {
+    Expr *NewEnd;
+    Expr *NewIncr;
+    Expr *Init;
+    Expr *VarCnt;
+    BinaryOperatorKind OpKind;
+    if (isNotOpenMPCanonicalLoopForm(CStmt, Kind, NewEnd, NewIncr, Init, VarCnt,
+                                     OpKind))
+      return false;
+    if (NewEnd->getType()->isDependentType() ||
+        NewIncr->getType()->isDependentType() ||
+        Init->getType()->isDependentType() ||
+        VarCnt->getType()->isDependentType())
+      SkipExprCount = true;
+    Ends.push_back(NewEnd);
+    Incrs.push_back(NewIncr);
+    Inits.push_back(Init);
+    VarCnts.push_back(VarCnt);
+    OpKinds.push_back(OpKind);
+    CStmt = cast<ForStmt>(CStmt)->getBody();
+    bool SkippedContainers = false;
+    while (!SkippedContainers) {
+      if (AttributedStmt *AS = dyn_cast_or_null<AttributedStmt>(CStmt))
+        CStmt = AS->getSubStmt();
+      else if (CompoundStmt *CS = dyn_cast_or_null<CompoundStmt>(CStmt)) {
+        if (CS->size() != 1) {
+          SkippedContainers = true;
+        } else {
+          CStmt = CS->body_back();
         }
-      }
+      } else
+        SkippedContainers = true;
     }
-  } else if (auto CE = dyn_cast<CXXOperatorCallExpr>(S))
-    if (CE->getOperator() == OO_Equal)
-      if (auto DRE = dyn_cast<DeclRefExpr>(CE->getArg(0)))
-        return SetVarAndLB(dyn_cast<VarDecl>(DRE->getDecl()), CE->getArg(1));
+  }
 
-  SemaRef.Diag(S->getLocStart(), diag::err_omp_loop_not_canonical_init)
-      << S->getSourceRange();
-  return true;
-}
+  ForBreakStmtChecker Check;
+  if (CStmt && Check.Visit(CStmt)) {
+    Diag(Check.getBreak()->getLocStart(), diag::err_omp_for_cannot_break)
+        << getOpenMPDirectiveName(Kind);
+    return false;
+  }
 
-/// \brief Ignore parenthesizes, implicit casts, copy constructor and return the
-/// variable (which may be the loop variable) if possible.
-static const VarDecl *GetInitVarDecl(const Expr *E) {
-  if (!E)
-    return nullptr;
-  E = E->IgnoreParenImpCasts();
-  if (auto *CE = dyn_cast_or_null<CXXConstructExpr>(E))
-    if (const CXXConstructorDecl *Ctor = CE->getConstructor())
-      if (Ctor->isCopyConstructor() && CE->getNumArgs() == 1 &&
-          CE->getArg(0) != nullptr)
-        E = CE->getArg(0)->IgnoreParenImpCasts();
-  auto DRE = dyn_cast_or_null<DeclRefExpr>(E);
-  if (!DRE)
-    return nullptr;
-  return dyn_cast<VarDecl>(DRE->getDecl());
-}
-
-bool OpenMPIterationSpaceChecker::CheckCond(Expr *S) {
-  // Check test-expr for canonical form, save upper-bound UB, flags for
-  // less/greater and for strict/non-strict comparison.
-  // OpenMP [2.6] Canonical loop form. Test-expr may be one of the following:
-  //   var relational-op b
-  //   b relational-op var
-  //
-  if (!S) {
-    SemaRef.Diag(DefaultLoc, diag::err_omp_loop_not_canonical_cond) << Var;
-    return true;
+  if (Kind == OMPD_simd || Kind == OMPD_for_simd ||
+      Kind == OMPD_parallel_for_simd || Kind == OMPD_distribute_simd ||
+      Kind == OMPD_distribute_parallel_for_simd ||
+      Kind == OMPD_teams_distribute_simd ||
+      Kind == OMPD_target_teams_distribute_simd ||
+      Kind == OMPD_teams_distribute_parallel_for_simd ||
+      Kind == OMPD_target_teams_distribute_parallel_for_simd) {
+    // OpenMP [2.8.1] No exception can be raised in the simd region.
+    EhChecker Check;
+    if (CStmt && Check.Visit(CStmt)) {
+      Diag(Check.getBadStmt()->getLocStart(), diag::err_omp_for_cannot_have_eh)
+          << getOpenMPDirectiveName(Kind);
+      return false;
+    }
   }
-  S = S->IgnoreParenImpCasts();
-  SourceLocation CondLoc = S->getLocStart();
-  if (auto BO = dyn_cast<BinaryOperator>(S)) {
-    if (BO->isRelationalOp()) {
-      if (GetInitVarDecl(BO->getLHS()) == Var)
-        return SetUB(BO->getRHS(),
-                     (BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE),
-                     (BO->getOpcode() == BO_LT || BO->getOpcode() == BO_GT),
-                     BO->getSourceRange(), BO->getOperatorLoc());
-      if (GetInitVarDecl(BO->getRHS()) == Var)
-        return SetUB(BO->getLHS(),
-                     (BO->getOpcode() == BO_GT || BO->getOpcode() == BO_GE),
-                     (BO->getOpcode() == BO_LT || BO->getOpcode() == BO_GT),
-                     BO->getSourceRange(), BO->getOperatorLoc());
-    }
-  } else if (auto CE = dyn_cast<CXXOperatorCallExpr>(S)) {
-    if (CE->getNumArgs() == 2) {
-      auto Op = CE->getOperator();
-      switch (Op) {
-      case OO_Greater:
-      case OO_GreaterEqual:
-      case OO_Less:
-      case OO_LessEqual:
-        if (GetInitVarDecl(CE->getArg(0)) == Var)
-          return SetUB(CE->getArg(1), Op == OO_Less || Op == OO_LessEqual,
-                       Op == OO_Less || Op == OO_Greater, CE->getSourceRange(),
-                       CE->getOperatorLoc());
-        if (GetInitVarDecl(CE->getArg(1)) == Var)
-          return SetUB(CE->getArg(0), Op == OO_Greater || Op == OO_GreaterEqual,
-                       Op == OO_Less || Op == OO_Greater, CE->getSourceRange(),
-                       CE->getOperatorLoc());
-        break;
-      default:
-        break;
+
+  // Build ending for Idx var;
+  NewEnd = 0;
+  NewVar = 0;
+  NewVarCntExpr = 0;
+  NewFinal = 0;
+
+  if (!SkipExprCount) {
+    NewEnd = Ends[0];
+    for (unsigned I = 1; I < StmtCount; ++I) {
+      ExprResult Res = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Mul,
+                                  Ends[I], NewEnd);
+      if (!Res.isUsable())
+        return false;
+      NewEnd = Res.get();
+    }
+    QualType IdxTy = NewEnd->getType();
+    TypeSourceInfo *TI = Context.getTrivialTypeSourceInfo(IdxTy, StartLoc);
+    VarDecl *Idx = VarDecl::Create(Context, Context.getTranslationUnitDecl(),
+                                   StartLoc, StartLoc, 0, IdxTy, TI, SC_Static);
+    Idx->setImplicit();
+    Idx->addAttr(new (Context) UnusedAttr(SourceLocation(), Context, 0));
+    Context.getTranslationUnitDecl()->addHiddenDecl(Idx);
+    ExprResult IdxExprRes = BuildDeclRefExpr(Idx, IdxTy, VK_LValue, StartLoc);
+    NewVar = IdxExprRes.get();
+
+    // Build new values for actual indexes.
+
+    // We can go either from outer loop to inner [0, StmtCount, 1] or reverse
+    // [StmtCount-1, -1, -1] in the case of 'omp for', but in an 'omp simd'
+    // directive the reverse order is required because we may have loop-carried
+    // dependencies (as specified by 'safelen' clause).
+    // For cache locality reasons this may be also preffered for 'omp for', as
+    // usually programs walk inner array dimensions first.
+    int LoopIdBegin = StmtCount - 1;
+    int LoopIdEnd = -1;
+    int LoopIdStep = -1;
+
+    Expr *NewDiv = Ends[LoopIdBegin];
+    Expr *IdxRVal = DefaultLvalueConversion(NewVar).get();
+    if (!IdxRVal)
+      return false;
+    ExprResult Res =
+        BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Sub, NewEnd,
+                   ActOnIntegerConstant(SourceLocation(), 1).get());
+    if (!Res.isUsable())
+      return false;
+    NewEnd = Res.get();
+
+    Expr *NewIncr = IdxRVal;
+    if (StmtCount != 1) {
+      NewIncr = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Rem, IdxRVal,
+                           Ends[LoopIdBegin]).get();
+      if (!NewIncr)
+        return false;
+    }
+
+    NewIncr = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Mul, NewIncr,
+                         Incrs[LoopIdBegin]).get();
+    if (!NewIncr)
+      return false;
+    NewFinal = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Assign,
+                          VarCnts[LoopIdBegin], Inits[LoopIdBegin]).get();
+    if (!NewFinal)
+      return false;
+    NewFinal = IgnoredValueConversions(NewFinal).get();
+    if (!NewFinal)
+      return false;
+    Expr *NewFinal1 = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Mul,
+                                 Ends[LoopIdBegin], Incrs[LoopIdBegin]).get();
+    if (!NewFinal1)
+      return false;
+    NewFinal1 = BuildBinOp(DSAStack->getCurScope(), StartLoc,
+                           (OpKinds[LoopIdBegin] == BO_Add) ? BO_AddAssign
+                                                            : BO_SubAssign,
+                           VarCnts[LoopIdBegin], NewFinal1).get();
+    if (!NewFinal1)
+      return false;
+    NewFinal1 = IgnoredValueConversions(NewFinal1).get();
+    if (!NewFinal1)
+      return false;
+    NewFinal =
+        CreateBuiltinBinOp(StartLoc, BO_Comma, NewFinal, NewFinal1).get();
+    if (!NewFinal)
+      return false;
+    // Expr *NewStep = BuildBinOp(DSAStack->getCurScope(), StartLoc,
+    //                  OpKinds[LoopIdBegin], Inits[LoopIdBegin],
+    // NewIncr).get();
+    // if (!NewStep) return false;
+    // NewVarCntExpr = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Assign,
+    //                           VarCnts[LoopIdBegin], NewStep).get();
+    NewVarCntExpr = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Assign,
+                               VarCnts[LoopIdBegin], Inits[LoopIdBegin]).get();
+    if (!NewVarCntExpr)
+      return false;
+    NewVarCntExpr = IgnoredValueConversions(NewVarCntExpr).get();
+    if (!NewVarCntExpr)
+      return false;
+    Expr *NewVarCntExpr1 =
+        BuildBinOp(DSAStack->getCurScope(), StartLoc,
+                   (OpKinds[LoopIdBegin] == BO_Add) ? BO_AddAssign
+                                                    : BO_SubAssign,
+                   VarCnts[LoopIdBegin], NewIncr).get();
+    if (!NewVarCntExpr1)
+      return false;
+    NewVarCntExpr1 = IgnoredValueConversions(NewVarCntExpr1).get();
+    if (!NewVarCntExpr1)
+      return false;
+    NewVarCntExpr = CreateBuiltinBinOp(StartLoc, BO_Comma, NewVarCntExpr,
+                                       NewVarCntExpr1).get();
+    if (!NewVarCntExpr)
+      return false;
+
+    for (int I = LoopIdBegin + LoopIdStep; I != LoopIdEnd; I += LoopIdStep) {
+      NewIncr = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Div, IdxRVal,
+                           NewDiv).get();
+      if (!NewIncr)
+        return false;
+
+      if (I + LoopIdStep != LoopIdEnd) {
+        NewIncr = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Rem, NewIncr,
+                             Ends[I]).get();
+        if (!NewIncr)
+          return false;
       }
+
+      NewIncr = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Mul, NewIncr,
+                           Incrs[I]).get();
+      if (!NewIncr)
+        return false;
+      NewFinal1 = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Assign,
+                             VarCnts[I], Inits[I]).get();
+      if (!NewFinal1)
+        return false;
+      NewFinal =
+          CreateBuiltinBinOp(StartLoc, BO_Comma, NewFinal, NewFinal1).get();
+      if (!NewFinal)
+        return false;
+      NewFinal1 = IgnoredValueConversions(NewFinal1).get();
+      if (!NewFinal1)
+        return false;
+      NewFinal1 = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Mul, Ends[I],
+                             Incrs[I]).get();
+      if (!NewFinal1)
+        return false;
+      NewFinal1 =
+          BuildBinOp(DSAStack->getCurScope(), StartLoc,
+                     (OpKinds[I] == BO_Add) ? BO_AddAssign : BO_SubAssign,
+                     VarCnts[I], NewFinal1).get();
+      if (!NewFinal1)
+        return false;
+      NewFinal1 = IgnoredValueConversions(NewFinal1).get();
+      if (!NewFinal1)
+        return false;
+      NewFinal =
+          CreateBuiltinBinOp(StartLoc, BO_Comma, NewFinal, NewFinal1).get();
+      if (!NewFinal)
+        return false;
+      //      NewStep = BuildBinOp(DSAStack->getCurScope(), StartLoc,
+      // OpKinds[I],
+      //                           Inits[I], NewIncr).get();
+      //      if (!NewStep) return false;
+      //      Expr *NewVarCntExpr1 = BuildBinOp(DSAStack->getCurScope(),
+      // StartLoc, BO_Assign,
+      //                                        VarCnts[I], NewStep).get();
+      NewVarCntExpr1 = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Assign,
+                                  VarCnts[I], Inits[I]).get();
+      if (!NewVarCntExpr1)
+        return false;
+      NewVarCntExpr1 = IgnoredValueConversions(NewVarCntExpr1).get();
+      if (!NewVarCntExpr1)
+        return false;
+      NewVarCntExpr = CreateBuiltinBinOp(StartLoc, BO_Comma, NewVarCntExpr,
+                                         NewVarCntExpr1).get();
+      if (!NewVarCntExpr)
+        return false;
+      NewVarCntExpr1 =
+          BuildBinOp(DSAStack->getCurScope(), StartLoc,
+                     (OpKinds[I] == BO_Add) ? BO_AddAssign : BO_SubAssign,
+                     VarCnts[I], NewIncr).get();
+      if (!NewVarCntExpr1)
+        return false;
+      NewVarCntExpr1 = IgnoredValueConversions(NewVarCntExpr1).get();
+      if (!NewVarCntExpr1)
+        return false;
+      NewVarCntExpr = CreateBuiltinBinOp(StartLoc, BO_Comma, NewVarCntExpr,
+                                         NewVarCntExpr1).get();
+      if (!NewVarCntExpr)
+        return false;
+      NewDiv = BuildBinOp(DSAStack->getCurScope(), StartLoc, BO_Mul, NewDiv,
+                          Ends[I]).get();
+      if (!NewDiv)
+        return false;
     }
+    NewVarCntExpr = IgnoredValueConversions(NewVarCntExpr).get();
+    NewFinal = IgnoredValueConversions(NewFinal).get();
+    NewFinal = ActOnFinishFullExpr(NewFinal).get();
+    NewVarCntExpr = ActOnFinishFullExpr(NewVarCntExpr).get();
+    NewEnd = ActOnFinishFullExpr(NewEnd).get();
   }
-  SemaRef.Diag(CondLoc, diag::err_omp_loop_not_canonical_cond)
-      << S->getSourceRange() << Var;
   return true;
 }
 
-bool OpenMPIterationSpaceChecker::CheckIncRHS(Expr *RHS) {
-  // RHS of canonical loop form increment can be:
-  //   var + incr
-  //   incr + var
-  //   var - incr
-  //
-  RHS = RHS->IgnoreParenImpCasts();
-  if (auto BO = dyn_cast<BinaryOperator>(RHS)) {
-    if (BO->isAdditiveOp()) {
-      bool IsAdd = BO->getOpcode() == BO_Add;
-      if (GetInitVarDecl(BO->getLHS()) == Var)
-        return SetStep(BO->getRHS(), !IsAdd);
-      if (IsAdd && GetInitVarDecl(BO->getRHS()) == Var)
-        return SetStep(BO->getLHS(), false);
-    }
-  } else if (auto CE = dyn_cast<CXXOperatorCallExpr>(RHS)) {
-    bool IsAdd = CE->getOperator() == OO_Plus;
-    if ((IsAdd || CE->getOperator() == OO_Minus) && CE->getNumArgs() == 2) {
-      if (GetInitVarDecl(CE->getArg(0)) == Var)
-        return SetStep(CE->getArg(1), !IsAdd);
-      if (IsAdd && GetInitVarDecl(CE->getArg(1)) == Var)
-        return SetStep(CE->getArg(0), false);
-    }
+StmtResult Sema::ActOnOpenMPForDirective(OpenMPDirectiveKind Kind,
+                                         ArrayRef<OMPClause *> Clauses,
+                                         Stmt *AStmt, SourceLocation StartLoc,
+                                         SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
+    return StmtError();
   }
-  SemaRef.Diag(RHS->getLocStart(), diag::err_omp_loop_not_canonical_incr)
-      << RHS->getSourceRange() << Var;
-  return true;
-}
 
-bool OpenMPIterationSpaceChecker::CheckInc(Expr *S) {
-  // Check incr-expr for canonical loop form and return true if it
-  // does not conform.
-  // OpenMP [2.6] Canonical loop form. Test-expr may be one of the following:
-  //   ++var
-  //   var++
-  //   --var
-  //   var--
-  //   var += incr
-  //   var -= incr
-  //   var = var + incr
-  //   var = incr + var
-  //   var = var - incr
-  //
-  if (!S) {
-    SemaRef.Diag(DefaultLoc, diag::err_omp_loop_not_canonical_incr) << Var;
-    return true;
+  getCurFunction()->setHasBranchProtectedScope();
+  return OMPForDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt,
+                                 NewVar, NewEnd, NewVarCntExpr, NewFinal,
+                                 VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPParallelForDirective(OpenMPDirectiveKind Kind,
+                                                 ArrayRef<OMPClause *> Clauses,
+                                                 Stmt *AStmt,
+                                                 SourceLocation StartLoc,
+                                                 SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
+    return StmtError();
   }
-  S = S->IgnoreParens();
-  if (auto UO = dyn_cast<UnaryOperator>(S)) {
-    if (UO->isIncrementDecrementOp() && GetInitVarDecl(UO->getSubExpr()) == Var)
-      return SetStep(
-          SemaRef.ActOnIntegerConstant(UO->getLocStart(),
-                                       (UO->isDecrementOp() ? -1 : 1)).get(),
-          false);
-  } else if (auto BO = dyn_cast<BinaryOperator>(S)) {
-    switch (BO->getOpcode()) {
-    case BO_AddAssign:
-    case BO_SubAssign:
-      if (GetInitVarDecl(BO->getLHS()) == Var)
-        return SetStep(BO->getRHS(), BO->getOpcode() == BO_SubAssign);
-      break;
-    case BO_Assign:
-      if (GetInitVarDecl(BO->getLHS()) == Var)
-        return CheckIncRHS(BO->getRHS());
-      break;
-    default:
-      break;
-    }
-  } else if (auto CE = dyn_cast<CXXOperatorCallExpr>(S)) {
-    switch (CE->getOperator()) {
-    case OO_PlusPlus:
-    case OO_MinusMinus:
-      if (GetInitVarDecl(CE->getArg(0)) == Var)
-        return SetStep(
-            SemaRef.ActOnIntegerConstant(
-                        CE->getLocStart(),
-                        ((CE->getOperator() == OO_MinusMinus) ? -1 : 1)).get(),
-            false);
-      break;
-    case OO_PlusEqual:
-    case OO_MinusEqual:
-      if (GetInitVarDecl(CE->getArg(0)) == Var)
-        return SetStep(CE->getArg(1), CE->getOperator() == OO_MinusEqual);
-      break;
-    case OO_Equal:
-      if (GetInitVarDecl(CE->getArg(0)) == Var)
-        return CheckIncRHS(CE->getArg(1));
-      break;
-    default:
-      break;
-    }
+
+  getCurFunction()->setHasBranchProtectedScope();
+  return OMPParallelForDirective::Create(Context, StartLoc, EndLoc, Clauses,
+                                         AStmt, NewVar, NewEnd, NewVarCntExpr,
+                                         NewFinal, VarCnts);
+}
+
+CapturedStmt *Sema::AddSimdArgsIntoCapturedStmt(CapturedStmt *Cap,
+                                                Expr *NewVar) {
+  CapturedDecl *CD = Cap->getCapturedDecl();
+  DeclContext *DC = CapturedDecl::castToDeclContext(CD);
+  assert(CD->getNumParams() == 3);
+  if (!DC->isDependentContext()) {
+    assert(NewVar);
+    QualType IndexType = NewVar->getType();
+    ImplicitParamDecl *Index = 0, *LastIter = 0;
+    Index = ImplicitParamDecl::Create(getASTContext(), DC, SourceLocation(), 0,
+                                      IndexType);
+    DC->addDecl(Index);
+    CD->setParam(1, Index);
+    LastIter = ImplicitParamDecl::Create(getASTContext(), DC, SourceLocation(),
+                                         0, Context.BoolTy);
+    DC->addDecl(LastIter);
+    CD->setParam(2, LastIter);
+  }
+  RecordDecl *RD = const_cast<RecordDecl *>(Cap->getCapturedRecordDecl());
+
+  // Extract the captures from AStmt and insert them into CapturedBody.
+  SmallVector<CapturedStmt::Capture, 4> Captures;
+  SmallVector<Expr *, 4> CaptureInits;
+  CapturedStmt::capture_iterator I;
+  CapturedStmt::capture_init_iterator J;
+  for (I = Cap->capture_begin(), J = Cap->capture_init_begin();
+       (I != Cap->capture_end()) && (J != Cap->capture_init_end()); ++I, ++J) {
+    // Assuming that copy constructors are OK here.
+    Captures.push_back(*I);
+    CaptureInits.push_back(*J);
+  }
+  CapturedRegionKind CapKind = Cap->getCapturedRegionKind();
+  Stmt *Body = Cap->getCapturedStmt();
+  // Rebuild the captured stmt.
+  CapturedStmt *CapturedBody = CapturedStmt::Create(
+      getASTContext(), Body, CapKind, Captures, CaptureInits, CD, RD);
+  CD->setBody(Body);
+
+  return CapturedBody;
+}
+
+Stmt *Sema::AddDistributedParallelArgsIntoCapturedStmt(CapturedStmt *Cap,
+                                                       Expr *NewVar,
+                                                       Expr *&LowerBound,
+                                                       Expr *&UpperBound) {
+  CapturedDecl *CD = Cap->getCapturedDecl();
+  DeclContext *DC = CapturedDecl::castToDeclContext(CD);
+  VarDecl *LowerBoundVar = 0;
+  VarDecl *UpperBoundVar = 0;
+  if (!DC->isDependentContext()) {
+    assert(NewVar);
+    QualType VDTy = NewVar->getType();
+    uint64_t TypeSize = 32;
+    if (Context.getTypeSize(VDTy) > TypeSize)
+      TypeSize = 64;
+    VDTy = Context.getIntTypeForBitwidth(TypeSize, true);
+    TypeSourceInfo *TI =
+        Context.getTrivialTypeSourceInfo(VDTy, SourceLocation());
+    LowerBoundVar = VarDecl::Create(Context, CurContext, SourceLocation(),
+                                    SourceLocation(), 0, VDTy, TI, SC_Auto);
+    UpperBoundVar = VarDecl::Create(Context, CurContext, SourceLocation(),
+                                    SourceLocation(), 0, VDTy, TI, SC_Auto);
+    LowerBound = DeclRefExpr::Create(Context, NestedNameSpecifierLoc(),
+                                     SourceLocation(), LowerBoundVar, false,
+                                     SourceLocation(), VDTy, VK_LValue);
+    UpperBound = DeclRefExpr::Create(Context, NestedNameSpecifierLoc(),
+                                     SourceLocation(), UpperBoundVar, false,
+                                     SourceLocation(), VDTy, VK_LValue);
+  }
+
+  Stmt *Body = Cap->getCapturedStmt();
+
+  ActOnCapturedRegionStart(Cap->getLocStart(), 0, Cap->getCapturedRegionKind(),
+                           Cap->getCapturedDecl()->getNumParams());
+  MarkVariableReferenced(Cap->getLocStart(), LowerBoundVar);
+  MarkVariableReferenced(Cap->getLocStart(), UpperBoundVar);
+  for (CapturedStmt::capture_iterator I = Cap->capture_begin(),
+                                      E = Cap->capture_end();
+       I != E; ++I) {
+    if (I->capturesVariable())
+      MarkVariableReferenced(I->getLocation(), I->getCapturedVar());
+    else
+      CheckCXXThisCapture(I->getLocation(), /*explicit*/ false);
   }
-  SemaRef.Diag(S->getLocStart(), diag::err_omp_loop_not_canonical_incr)
-      << S->getSourceRange() << Var;
-  return true;
+  StmtResult CapturedBody = ActOnCapturedRegionEnd(Body);
+
+  return CapturedBody.get();
 }
-} // namespace
 
-/// \brief Called on a for stmt to check and extract its iteration space
-/// for further processing (such as collapsing).
-static bool CheckOpenMPIterationSpace(
-    OpenMPDirectiveKind DKind, Stmt *S, Sema &SemaRef, DSAStackTy &DSA,
-    unsigned CurrentNestedLoopCount, unsigned NestedLoopCount,
-    Expr *NestedLoopCountExpr,
-    llvm::DenseMap<VarDecl *, Expr *> &VarsWithImplicitDSA) {
-  // OpenMP [2.6, Canonical Loop Form]
-  //   for (init-expr; test-expr; incr-expr) structured-block
-  auto For = dyn_cast_or_null<ForStmt>(S);
-  if (!For) {
-    SemaRef.Diag(S->getLocStart(), diag::err_omp_not_for)
-        << (NestedLoopCountExpr != nullptr) << getOpenMPDirectiveName(DKind)
-        << NestedLoopCount << (CurrentNestedLoopCount > 0)
-        << CurrentNestedLoopCount;
-    if (NestedLoopCount > 1)
-      SemaRef.Diag(NestedLoopCountExpr->getExprLoc(),
-                   diag::note_omp_collapse_expr)
-          << NestedLoopCountExpr->getSourceRange();
-    return true;
+StmtResult Sema::ActOnOpenMPSimdDirective(OpenMPDirectiveKind Kind,
+                                          ArrayRef<OMPClause *> Clauses,
+                                          Stmt *AStmt, SourceLocation StartLoc,
+                                          SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
+    return StmtError();
   }
-  assert(For->getBody());
 
-  OpenMPIterationSpaceChecker ISC(SemaRef, For->getForLoc());
+  // Add two arguments into captured stmt for index and last_iter.
+  CapturedStmt *CapturedBody =
+      AddSimdArgsIntoCapturedStmt(cast<CapturedStmt>(AStmt), NewVar);
 
-  // Check init.
-  auto Init = For->getInit();
-  if (ISC.CheckInit(Init)) {
-    return true;
+  getCurFunction()->setHasBranchProtectedScope();
+
+  // Rebuild the directive.
+  return OMPSimdDirective::Create(Context, StartLoc, EndLoc, Clauses,
+                                  CapturedBody, NewVar, NewEnd, NewVarCntExpr,
+                                  NewFinal, VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPForSimdDirective(OpenMPDirectiveKind Kind,
+                                             ArrayRef<OMPClause *> Clauses,
+                                             Stmt *AStmt,
+                                             SourceLocation StartLoc,
+                                             SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
+    return StmtError();
   }
 
-  bool HasErrors = false;
+  // Add two arguments into captured stmt for index and last_iter.
+  CapturedStmt *CapturedBody =
+      AddSimdArgsIntoCapturedStmt(cast<CapturedStmt>(AStmt), NewVar);
 
-  // Check loop variable's type.
-  auto Var = ISC.GetLoopVar();
+  getCurFunction()->setHasBranchProtectedScope();
 
-  // OpenMP [2.6, Canonical Loop Form]
-  // Var is one of the following:
-  //   A variable of signed or unsigned integer type.
-  //   For C++, a variable of a random access iterator type.
-  //   For C, a variable of a pointer type.
-  auto VarType = Var->getType();
-  if (!VarType->isDependentType() && !VarType->isIntegerType() &&
-      !VarType->isPointerType() &&
-      !(SemaRef.getLangOpts().CPlusPlus && VarType->isOverloadableType())) {
-    SemaRef.Diag(Init->getLocStart(), diag::err_omp_loop_variable_type)
-        << SemaRef.getLangOpts().CPlusPlus;
-    HasErrors = true;
+  // Rebuild the directive.
+  return OMPForSimdDirective::Create(Context, StartLoc, EndLoc, Clauses,
+                                     CapturedBody, NewVar, NewEnd,
+                                     NewVarCntExpr, NewFinal, VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPParallelForSimdDirective(
+    OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+    SourceLocation StartLoc, SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
+    return StmtError();
   }
 
-  // OpenMP, 2.14.1.1 Data-sharing Attribute Rules for Variables Referenced in a
-  // Construct
-  // The loop iteration variable(s) in the associated for-loop(s) of a for or
-  // parallel for construct is (are) private.
-  // The loop iteration variable in the associated for-loop of a simd construct
-  // with just one associated for-loop is linear with a constant-linear-step
-  // that is the increment of the associated for-loop.
-  // Exclude loop var from the list of variables with implicitly defined data
-  // sharing attributes.
-  while (VarsWithImplicitDSA.count(Var) > 0)
-    VarsWithImplicitDSA.erase(Var);
-
-  // OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables Referenced in
-  // a Construct, C/C++].
-  // The loop iteration variable in the associated for-loop of a simd construct
-  // with just one associated for-loop may be listed in a linear clause with a
-  // constant-linear-step that is the increment of the associated for-loop.
-  // The loop iteration variable(s) in the associated for-loop(s) of a for or
-  // parallel for construct may be listed in a private or lastprivate clause.
-  DSAStackTy::DSAVarData DVar = DSA.getTopDSA(Var, false);
-  auto PredeterminedCKind =
-      isOpenMPSimdDirective(DKind)
-          ? ((NestedLoopCount == 1) ? OMPC_linear : OMPC_lastprivate)
-          : OMPC_private;
-  if (((isOpenMPSimdDirective(DKind) && DVar.CKind != OMPC_unknown &&
-        DVar.CKind != PredeterminedCKind) ||
-       (isOpenMPWorksharingDirective(DKind) && DVar.CKind != OMPC_unknown &&
-        DVar.CKind != OMPC_private && DVar.CKind != OMPC_lastprivate)) &&
-      (DVar.CKind != OMPC_private || DVar.RefExpr != nullptr)) {
-    SemaRef.Diag(Init->getLocStart(), diag::err_omp_loop_var_dsa)
-        << getOpenMPClauseName(DVar.CKind) << getOpenMPDirectiveName(DKind)
-        << getOpenMPClauseName(PredeterminedCKind);
-    ReportOriginalDSA(SemaRef, &DSA, Var, DVar, true);
-    HasErrors = true;
-  } else {
-    // Make the loop iteration variable private (for worksharing constructs),
-    // linear (for simd directives with the only one associated loop) or
-    // lastprivate (for simd directives with several collapsed loops).
-    DSA.addDSA(Var, nullptr, PredeterminedCKind);
-  }
-
-  assert(isOpenMPLoopDirective(DKind) && "DSA for non-loop vars");
-
-  // Check test-expr.
-  HasErrors |= ISC.CheckCond(For->getCond());
-
-  // Check incr-expr.
-  HasErrors |= ISC.CheckInc(For->getInc());
-
-  if (ISC.Dependent())
-    return HasErrors;
-
-  // FIXME: Build loop's iteration space representation.
-  return HasErrors;
-}
-
-/// \brief A helper routine to skip no-op (attributed, compound) stmts get the
-/// next nested for loop. If \a IgnoreCaptured is true, it skips captured stmt
-/// to get the first for loop.
-static Stmt *IgnoreContainerStmts(Stmt *S, bool IgnoreCaptured) {
-  if (IgnoreCaptured)
-    if (auto CapS = dyn_cast_or_null<CapturedStmt>(S))
-      S = CapS->getCapturedStmt();
-  // OpenMP [2.8.1, simd construct, Restrictions]
-  // All loops associated with the construct must be perfectly nested; that is,
-  // there must be no intervening code nor any OpenMP directive between any two
-  // loops.
-  while (true) {
-    if (auto AS = dyn_cast_or_null<AttributedStmt>(S))
-      S = AS->getSubStmt();
-    else if (auto CS = dyn_cast_or_null<CompoundStmt>(S)) {
-      if (CS->size() != 1)
-        break;
-      S = CS->body_back();
-    } else
-      break;
+  // Add two arguments into captured stmt for index and last_iter.
+  CapturedStmt *CapturedBody =
+      AddSimdArgsIntoCapturedStmt(cast<CapturedStmt>(AStmt), NewVar);
+
+  getCurFunction()->setHasBranchProtectedScope();
+
+  // Rebuild the directive.
+  return OMPParallelForSimdDirective::Create(Context, StartLoc, EndLoc, Clauses,
+                                             CapturedBody, NewVar, NewEnd,
+                                             NewVarCntExpr, NewFinal, VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPDistributeSimdDirective(
+    OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+    SourceLocation StartLoc, SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
+    return StmtError();
   }
-  return S;
-}
 
-/// \brief Called on a for stmt to check itself and nested loops (if any).
-/// \return Returns 0 if one of the collapsed stmts is not canonical for loop,
-/// number of collapsed loops otherwise.
-static unsigned
-CheckOpenMPLoop(OpenMPDirectiveKind DKind, Expr *NestedLoopCountExpr,
-                Stmt *AStmt, Sema &SemaRef, DSAStackTy &DSA,
-                llvm::DenseMap<VarDecl *, Expr *> &VarsWithImplicitDSA) {
-  unsigned NestedLoopCount = 1;
-  if (NestedLoopCountExpr) {
-    // Found 'collapse' clause - calculate collapse number.
-    llvm::APSInt Result;
-    if (NestedLoopCountExpr->EvaluateAsInt(Result, SemaRef.getASTContext()))
-      NestedLoopCount = Result.getLimitedValue();
+  // Add two arguments into captured stmt for index and last_iter.
+  CapturedStmt *CapturedBody =
+      AddSimdArgsIntoCapturedStmt(cast<CapturedStmt>(AStmt), NewVar);
+
+  getCurFunction()->setHasBranchProtectedScope();
+
+  // Rebuild the directive.
+  return OMPDistributeSimdDirective::Create(Context, StartLoc, EndLoc, Clauses,
+                                            CapturedBody, NewVar, NewEnd,
+                                            NewVarCntExpr, NewFinal, VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPDistributeParallelForDirective(
+    OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+    SourceLocation StartLoc, SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
+    return StmtError();
   }
-  // This is helper routine for loop directives (e.g., 'for', 'simd',
-  // 'for simd', etc.).
-  Stmt *CurStmt = IgnoreContainerStmts(AStmt, true);
-  for (unsigned Cnt = 0; Cnt < NestedLoopCount; ++Cnt) {
-    if (CheckOpenMPIterationSpace(DKind, CurStmt, SemaRef, DSA, Cnt,
-                                  NestedLoopCount, NestedLoopCountExpr,
-                                  VarsWithImplicitDSA))
-      return 0;
-    // Move on to the next nested for loop, or to the loop body.
-    CurStmt = IgnoreContainerStmts(cast<ForStmt>(CurStmt)->getBody(), false);
+
+  getCurFunction()->setHasBranchProtectedScope();
+
+  // Create variables for lower/upper bound
+  Expr *LowerBound = 0;
+  Expr *UpperBound = 0;
+  if (NewVar && AStmt) {
+    AStmt = AddDistributedParallelArgsIntoCapturedStmt(
+        cast<CapturedStmt>(AStmt), NewVar, LowerBound, UpperBound);
+  }
+  // Rebuild the directive.
+  return OMPDistributeParallelForDirective::Create(
+      Context, StartLoc, EndLoc, Clauses, AStmt, NewVar, NewEnd, NewVarCntExpr,
+      NewFinal, LowerBound, UpperBound, VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPDistributeParallelForSimdDirective(
+    OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+    SourceLocation StartLoc, SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
+    return StmtError();
   }
 
-  // FIXME: Build resulting iteration space for IR generation (collapsing
-  // iteration spaces when loop count > 1 ('collapse' clause)).
-  return NestedLoopCount;
-}
+  getCurFunction()->setHasBranchProtectedScope();
 
-static Expr *GetCollapseNumberExpr(ArrayRef<OMPClause *> Clauses) {
-  auto CollapseFilter = [](const OMPClause *C) -> bool {
-    return C->getClauseKind() == OMPC_collapse;
-  };
-  OMPExecutableDirective::filtered_clause_iterator<decltype(CollapseFilter)> I(
-      Clauses, CollapseFilter);
-  if (I)
-    return cast<OMPCollapseClause>(*I)->getNumForLoops();
-  return nullptr;
-}
+  // Create variables for lower/upper bound
+  Expr *LowerBound = 0;
+  Expr *UpperBound = 0;
+  if (NewVar && AStmt) {
+    AStmt = AddDistributedParallelArgsIntoCapturedStmt(
+        cast<CapturedStmt>(AStmt), NewVar, LowerBound, UpperBound);
+  }
+
+  // Add two arguments into captured stmt for index and last_iter.
+  CapturedStmt *CapturedBody =
+      AddSimdArgsIntoCapturedStmt(cast<CapturedStmt>(AStmt), NewVar);
+
+  // Rebuild the directive.
+  return OMPDistributeParallelForSimdDirective::Create(
+      Context, StartLoc, EndLoc, Clauses, CapturedBody, NewVar, NewEnd,
+      NewVarCntExpr, NewFinal, LowerBound, UpperBound, VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPTeamsDistributeParallelForDirective(
+    OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+    SourceLocation StartLoc, SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
+    return StmtError();
+  }
 
-StmtResult Sema::ActOnOpenMPSimdDirective(
-    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,
-    SourceLocation EndLoc,
-    llvm::DenseMap<VarDecl *, Expr *> &VarsWithImplicitDSA) {
-  // In presence of clause 'collapse', it will define the nested loops number.
-  unsigned NestedLoopCount =
-      CheckOpenMPLoop(OMPD_simd, GetCollapseNumberExpr(Clauses), AStmt, *this,
-                      *DSAStack, VarsWithImplicitDSA);
-  if (NestedLoopCount == 0)
+  getCurFunction()->setHasBranchProtectedScope();
+
+  // Create variables for lower/upper bound
+  Expr *LowerBound = 0;
+  Expr *UpperBound = 0;
+  if (NewVar && AStmt) {
+    AStmt = AddDistributedParallelArgsIntoCapturedStmt(
+        cast<CapturedStmt>(AStmt), NewVar, LowerBound, UpperBound);
+  }
+  // Rebuild the directive.
+  return OMPTeamsDistributeParallelForDirective::Create(
+      Context, StartLoc, EndLoc, Clauses, AStmt, NewVar, NewEnd, NewVarCntExpr,
+      NewFinal, LowerBound, UpperBound, VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPTeamsDistributeParallelForSimdDirective(
+    OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+    SourceLocation StartLoc, SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
     return StmtError();
+  }
 
   getCurFunction()->setHasBranchProtectedScope();
-  return OMPSimdDirective::Create(Context, StartLoc, EndLoc, NestedLoopCount,
-                                  Clauses, AStmt);
-}
 
-StmtResult Sema::ActOnOpenMPForDirective(
-    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,
-    SourceLocation EndLoc,
-    llvm::DenseMap<VarDecl *, Expr *> &VarsWithImplicitDSA) {
-  // In presence of clause 'collapse', it will define the nested loops number.
-  unsigned NestedLoopCount =
-      CheckOpenMPLoop(OMPD_for, GetCollapseNumberExpr(Clauses), AStmt, *this,
-                      *DSAStack, VarsWithImplicitDSA);
-  if (NestedLoopCount == 0)
+  // Create variables for lower/upper bound
+  Expr *LowerBound = 0;
+  Expr *UpperBound = 0;
+  if (NewVar && AStmt) {
+    AStmt = AddDistributedParallelArgsIntoCapturedStmt(
+        cast<CapturedStmt>(AStmt), NewVar, LowerBound, UpperBound);
+  }
+
+  // Add two arguments into captured stmt for index and last_iter.
+  CapturedStmt *CapturedBody =
+      AddSimdArgsIntoCapturedStmt(cast<CapturedStmt>(AStmt), NewVar);
+
+  // Rebuild the directive.
+  return OMPTeamsDistributeParallelForSimdDirective::Create(
+      Context, StartLoc, EndLoc, Clauses, CapturedBody, NewVar, NewEnd,
+      NewVarCntExpr, NewFinal, LowerBound, UpperBound, VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPTargetTeamsDistributeParallelForDirective(
+    OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+    SourceLocation StartLoc, SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
     return StmtError();
+  }
+
+  getCurFunction()->setHasBranchProtectedScope();
+
+  // Create variables for lower/upper bound
+  Expr *LowerBound = 0;
+  Expr *UpperBound = 0;
+  if (NewVar && AStmt) {
+    AStmt = AddDistributedParallelArgsIntoCapturedStmt(
+        cast<CapturedStmt>(AStmt), NewVar, LowerBound, UpperBound);
+  }
+  // Rebuild the directive.
+  return OMPTargetTeamsDistributeParallelForDirective::Create(
+      Context, StartLoc, EndLoc, Clauses, AStmt, NewVar, NewEnd, NewVarCntExpr,
+      NewFinal, LowerBound, UpperBound, VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPTargetTeamsDistributeParallelForSimdDirective(
+    OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+    SourceLocation StartLoc, SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
+    return StmtError();
+  }
 
   getCurFunction()->setHasBranchProtectedScope();
-  return OMPForDirective::Create(Context, StartLoc, EndLoc, NestedLoopCount,
-                                 Clauses, AStmt);
+
+  // Create variables for lower/upper bound
+  Expr *LowerBound = 0;
+  Expr *UpperBound = 0;
+  if (NewVar && AStmt) {
+    AStmt = AddDistributedParallelArgsIntoCapturedStmt(
+        cast<CapturedStmt>(AStmt), NewVar, LowerBound, UpperBound);
+  }
+
+  // Add two arguments into captured stmt for index and last_iter.
+  CapturedStmt *CapturedBody =
+      AddSimdArgsIntoCapturedStmt(cast<CapturedStmt>(AStmt), NewVar);
+
+  // Rebuild the directive.
+  return OMPTargetTeamsDistributeParallelForSimdDirective::Create(
+      Context, StartLoc, EndLoc, Clauses, CapturedBody, NewVar, NewEnd,
+      NewVarCntExpr, NewFinal, LowerBound, UpperBound, VarCnts);
 }
 
-StmtResult Sema::ActOnOpenMPSectionsDirective(ArrayRef<OMPClause *> Clauses,
+StmtResult Sema::ActOnOpenMPSectionsDirective(OpenMPDirectiveKind Kind,
+                                              ArrayRef<OMPClause *> Clauses,
                                               Stmt *AStmt,
                                               SourceLocation StartLoc,
                                               SourceLocation EndLoc) {
-  assert(AStmt && isa<CapturedStmt>(AStmt) && "Captured statement expected");
-  auto BaseStmt = AStmt;
+  Stmt *BaseStmt = AStmt;
   while (CapturedStmt *CS = dyn_cast_or_null<CapturedStmt>(BaseStmt))
     BaseStmt = CS->getCapturedStmt();
-  if (auto C = dyn_cast_or_null<CompoundStmt>(BaseStmt)) {
-    auto S = C->children();
-    if (!S)
+  CompoundStmt *C = dyn_cast_or_null<CompoundStmt>(BaseStmt);
+  if (!C) {
+    Diag(AStmt->getLocStart(), diag::err_omp_sections_not_compound_stmt)
+        << getOpenMPDirectiveName(Kind);
+    return StmtError();
+  }
+  // All associated statements must be '#pragma omp section' except for
+  // the first one.
+  Stmt::child_range S = C->children();
+  if (!S)
+    return StmtError();
+  for (++S; S; ++S) {
+    Stmt *SectionStmt = *S;
+    if (!SectionStmt || !isa<OMPSectionDirective>(SectionStmt)) {
+      if (SectionStmt)
+        Diag(SectionStmt->getLocStart(), diag::err_omp_sections_not_section)
+            << getOpenMPDirectiveName(Kind);
       return StmtError();
-    // All associated statements must be '#pragma omp section' except for
-    // the first one.
-    for (++S; S; ++S) {
-      auto SectionStmt = *S;
-      if (!SectionStmt || !isa<OMPSectionDirective>(SectionStmt)) {
-        if (SectionStmt)
-          Diag(SectionStmt->getLocStart(),
-               diag::err_omp_sections_substmt_not_section);
-        return StmtError();
-      }
     }
-  } else {
-    Diag(AStmt->getLocStart(), diag::err_omp_sections_not_compound_stmt);
-    return StmtError();
   }
 
   getCurFunction()->setHasBranchProtectedScope();
@@ -2122,10 +3257,60 @@
                                       AStmt);
 }
 
+StmtResult Sema::ActOnOpenMPParallelSectionsDirective(
+    OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+    SourceLocation StartLoc, SourceLocation EndLoc) {
+  Stmt *BaseStmt = AStmt;
+  while (CapturedStmt *CS = dyn_cast_or_null<CapturedStmt>(BaseStmt))
+    BaseStmt = CS->getCapturedStmt();
+  CompoundStmt *C = dyn_cast_or_null<CompoundStmt>(BaseStmt);
+  if (!C) {
+    Diag(AStmt->getLocStart(), diag::err_omp_sections_not_compound_stmt)
+        << getOpenMPDirectiveName(Kind);
+    return StmtError();
+  }
+  // All associated statements must be '#pragma omp section' except for
+  // the first one.
+  Stmt::child_range S = C->children();
+  if (!S)
+    return StmtError();
+  for (++S; S; ++S) {
+    Stmt *SectionStmt = *S;
+    if (!SectionStmt || !isa<OMPSectionDirective>(SectionStmt)) {
+      if (SectionStmt)
+        Diag(SectionStmt->getLocStart(), diag::err_omp_sections_not_section)
+            << getOpenMPDirectiveName(Kind);
+      return StmtError();
+    }
+  }
+
+  getCurFunction()->setHasBranchProtectedScope();
+
+  return OMPParallelSectionsDirective::Create(Context, StartLoc, EndLoc,
+                                              Clauses, AStmt);
+}
+
 StmtResult Sema::ActOnOpenMPSectionDirective(Stmt *AStmt,
                                              SourceLocation StartLoc,
                                              SourceLocation EndLoc) {
-  assert(AStmt && isa<CapturedStmt>(AStmt) && "Captured statement expected");
+  // OpenMP [2.6.2, Sections Construct, Restrictions, p.1]
+  //  Orphaned section directives are prohibited. That is, the section
+  //  directives must appear within the sections construct and must not
+  //  be encountered elsewhere in the sections region.
+  // OpenMP scope for current directive.
+  if (DSAStack->getCurScope()) {
+    Scope *ParentScope = DSAStack->getCurScope()->getParent();
+    // CompoundStmt scope for sections scope.
+    ParentScope = ParentScope ? getCurScope()->getParent() : 0;
+    // Sections scope.
+    ParentScope = ParentScope ? ParentScope->getParent() : 0;
+    if (!ParentScope || !ParentScope->isOpenMPDirectiveScope() ||
+        (DSAStack->getParentDirective() != OMPD_sections &&
+         DSAStack->getParentDirective() != OMPD_parallel_sections)) {
+      Diag(StartLoc, diag::err_omp_section_orphaned);
+      return StmtError();
+    }
+  }
 
   getCurFunction()->setHasBranchProtectedScope();
 
@@ -2136,18 +3321,29 @@
                                             Stmt *AStmt,
                                             SourceLocation StartLoc,
                                             SourceLocation EndLoc) {
-  assert(AStmt && isa<CapturedStmt>(AStmt) && "Captured statement expected");
-
   getCurFunction()->setHasBranchProtectedScope();
 
   return OMPSingleDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt);
 }
 
+StmtResult Sema::ActOnOpenMPTaskDirective(ArrayRef<OMPClause *> Clauses,
+                                          Stmt *AStmt, SourceLocation StartLoc,
+                                          SourceLocation EndLoc) {
+  getCurFunction()->setHasBranchProtectedScope();
+
+  return OMPTaskDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt);
+}
+
+StmtResult Sema::ActOnOpenMPTaskyieldDirective(SourceLocation StartLoc,
+                                               SourceLocation EndLoc) {
+  getCurFunction()->setHasBranchProtectedScope();
+
+  return OMPTaskyieldDirective::Create(Context, StartLoc, EndLoc);
+}
+
 StmtResult Sema::ActOnOpenMPMasterDirective(Stmt *AStmt,
                                             SourceLocation StartLoc,
                                             SourceLocation EndLoc) {
-  assert(AStmt && isa<CapturedStmt>(AStmt) && "Captured statement expected");
-
   getCurFunction()->setHasBranchProtectedScope();
 
   return OMPMasterDirective::Create(Context, StartLoc, EndLoc, AStmt);
@@ -2157,492 +3353,1375 @@
 Sema::ActOnOpenMPCriticalDirective(const DeclarationNameInfo &DirName,
                                    Stmt *AStmt, SourceLocation StartLoc,
                                    SourceLocation EndLoc) {
-  assert(AStmt && isa<CapturedStmt>(AStmt) && "Captured statement expected");
-
   getCurFunction()->setHasBranchProtectedScope();
 
   return OMPCriticalDirective::Create(Context, DirName, StartLoc, EndLoc,
                                       AStmt);
 }
 
-StmtResult Sema::ActOnOpenMPParallelForDirective(
-    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,
-    SourceLocation EndLoc,
-    llvm::DenseMap<VarDecl *, Expr *> &VarsWithImplicitDSA) {
-  assert(AStmt && isa<CapturedStmt>(AStmt) && "Captured statement expected");
-  CapturedStmt *CS = cast<CapturedStmt>(AStmt);
-  // 1.2.2 OpenMP Language Terminology
-  // Structured block - An executable statement with a single entry at the
-  // top and a single exit at the bottom.
-  // The point of exit cannot be a branch out of the structured block.
-  // longjmp() and throw() must not violate the entry/exit criteria.
-  CS->getCapturedDecl()->setNothrow();
-
-  // In presence of clause 'collapse', it will define the nested loops number.
-  unsigned NestedLoopCount =
-      CheckOpenMPLoop(OMPD_parallel_for, GetCollapseNumberExpr(Clauses), AStmt,
-                      *this, *DSAStack, VarsWithImplicitDSA);
-  if (NestedLoopCount == 0)
-    return StmtError();
-
+StmtResult Sema::ActOnOpenMPBarrierDirective(SourceLocation StartLoc,
+                                             SourceLocation EndLoc) {
   getCurFunction()->setHasBranchProtectedScope();
-  return OMPParallelForDirective::Create(Context, StartLoc, EndLoc,
-                                         NestedLoopCount, Clauses, AStmt);
-}
 
-StmtResult
-Sema::ActOnOpenMPParallelSectionsDirective(ArrayRef<OMPClause *> Clauses,
-                                           Stmt *AStmt, SourceLocation StartLoc,
-                                           SourceLocation EndLoc) {
-  assert(AStmt && isa<CapturedStmt>(AStmt) && "Captured statement expected");
-  auto BaseStmt = AStmt;
-  while (CapturedStmt *CS = dyn_cast_or_null<CapturedStmt>(BaseStmt))
-    BaseStmt = CS->getCapturedStmt();
-  if (auto C = dyn_cast_or_null<CompoundStmt>(BaseStmt)) {
-    auto S = C->children();
-    if (!S)
-      return StmtError();
-    // All associated statements must be '#pragma omp section' except for
-    // the first one.
-    for (++S; S; ++S) {
-      auto SectionStmt = *S;
-      if (!SectionStmt || !isa<OMPSectionDirective>(SectionStmt)) {
-        if (SectionStmt)
-          Diag(SectionStmt->getLocStart(),
-               diag::err_omp_parallel_sections_substmt_not_section);
-        return StmtError();
-      }
-    }
-  } else {
-    Diag(AStmt->getLocStart(),
-         diag::err_omp_parallel_sections_not_compound_stmt);
-    return StmtError();
-  }
+  return OMPBarrierDirective::Create(Context, StartLoc, EndLoc);
+}
 
+StmtResult Sema::ActOnOpenMPTaskwaitDirective(SourceLocation StartLoc,
+                                              SourceLocation EndLoc) {
   getCurFunction()->setHasBranchProtectedScope();
 
-  return OMPParallelSectionsDirective::Create(Context, StartLoc, EndLoc,
-                                              Clauses, AStmt);
+  return OMPTaskwaitDirective::Create(Context, StartLoc, EndLoc);
 }
 
-StmtResult Sema::ActOnOpenMPTaskDirective(ArrayRef<OMPClause *> Clauses,
-                                          Stmt *AStmt, SourceLocation StartLoc,
-                                          SourceLocation EndLoc) {
-  assert(AStmt && isa<CapturedStmt>(AStmt) && "Captured statement expected");
-  CapturedStmt *CS = cast<CapturedStmt>(AStmt);
-  // 1.2.2 OpenMP Language Terminology
-  // Structured block - An executable statement with a single entry at the
-  // top and a single exit at the bottom.
-  // The point of exit cannot be a branch out of the structured block.
-  // longjmp() and throw() must not violate the entry/exit criteria.
-  CS->getCapturedDecl()->setNothrow();
-
+StmtResult Sema::ActOnOpenMPTaskgroupDirective(Stmt *AStmt,
+                                               SourceLocation StartLoc,
+                                               SourceLocation EndLoc) {
   getCurFunction()->setHasBranchProtectedScope();
 
-  return OMPTaskDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt);
+  return OMPTaskgroupDirective::Create(Context, StartLoc, EndLoc, AStmt);
 }
 
-StmtResult Sema::ActOnOpenMPTaskyieldDirective(SourceLocation StartLoc,
-                                               SourceLocation EndLoc) {
-  return OMPTaskyieldDirective::Create(Context, StartLoc, EndLoc);
-}
+namespace {
+class ExprUseChecker : public StmtVisitor<ExprUseChecker, bool> {
+  const llvm::FoldingSetNodeID &ExprID;
+  const ASTContext &Context;
 
-StmtResult Sema::ActOnOpenMPBarrierDirective(SourceLocation StartLoc,
-                                             SourceLocation EndLoc) {
-  return OMPBarrierDirective::Create(Context, StartLoc, EndLoc);
+public:
+  bool VisitStmt(Stmt *S) {
+    if (!S)
+      return false;
+    for (Stmt::child_range R = S->children(); R; ++R) {
+      if (Visit(*R))
+        return true;
+    }
+    llvm::FoldingSetNodeID ID;
+    S->Profile(ID, Context, true);
+    return ID == ExprID;
+  }
+  ExprUseChecker(const llvm::FoldingSetNodeID &ExprID,
+                 const ASTContext &Context)
+      : ExprID(ExprID), Context(Context) {}
+};
 }
 
-StmtResult Sema::ActOnOpenMPTaskwaitDirective(SourceLocation StartLoc,
-                                              SourceLocation EndLoc) {
-  return OMPTaskwaitDirective::Create(Context, StartLoc, EndLoc);
+StmtResult Sema::ActOnOpenMPAtomicDirective(ArrayRef<OMPClause *> Clauses,
+                                            Stmt *AStmt,
+                                            SourceLocation StartLoc,
+                                            SourceLocation EndLoc) {
+  // OpenMP [2.10.6, atomic Construct, Syntax]
+  //  There should not be no more than 1 clause 'read', 'write', 'update'
+  //  or 'capture'.
+  OpenMPClauseKind Kind = OMPC_update;
+  if (!Clauses.empty()) {
+    bool FoundClauses = false;
+    for (ArrayRef<OMPClause *>::iterator I = Clauses.begin(), E = Clauses.end();
+         I != E; ++I) {
+      if ((*I)->getClauseKind() != OMPC_seq_cst) {
+        Kind = (*I)->getClauseKind();
+        bool CurFoundClauses = Kind == OMPC_read || Kind == OMPC_write ||
+                               Kind == OMPC_update || Kind == OMPC_capture;
+        if (FoundClauses && CurFoundClauses) {
+          Diag(StartLoc, diag::err_omp_atomic_more_one_clause);
+          Kind = OMPC_unknown;
+          return StmtError();
+        }
+        FoundClauses = FoundClauses || CurFoundClauses;
+      }
+    }
+  }
+
+  // OpenMP [2.10.6, atomic Construct, Syntax]
+  //  For 'read', 'write', 'update' clauses only expression statements are
+  //  allowed.
+  Stmt *BaseStmt = AStmt;
+  while (CapturedStmt *CS = dyn_cast_or_null<CapturedStmt>(BaseStmt))
+    BaseStmt = CS->getCapturedStmt();
+  while (ExprWithCleanups *EWC = dyn_cast_or_null<ExprWithCleanups>(BaseStmt))
+    BaseStmt = EWC->getSubExpr();
+  while (AttributedStmt *AS = dyn_cast_or_null<AttributedStmt>(BaseStmt))
+    BaseStmt = AS->getSubStmt();
+  bool ExprStmt = isa<Expr>(BaseStmt);
+  if (Kind != OMPC_capture && !ExprStmt) {
+    Diag(BaseStmt->getLocStart(), diag::err_omp_atomic_not_expression)
+        << getOpenMPClauseName(Kind);
+    return StmtError();
+  }
+  bool WrongStmt = false;
+  Expr *V = 0;
+  Expr *X = 0;
+  Expr *OpExpr = 0;
+  BinaryOperatorKind Op = BO_Assign;
+  bool CaptureAfter = false;
+  bool Reversed = false;
+  switch (Kind) {
+  case OMPC_read: {
+    // expr : v = x, where x and v are both l-value with scalar type.
+    BinaryOperator *BinOp = dyn_cast_or_null<BinaryOperator>(BaseStmt);
+    ImplicitCastExpr *ImpCast;
+    WrongStmt =
+        !BinOp || BinOp->getOpcode() != BO_Assign || !BinOp->getLHS() ||
+        !BinOp->getRHS() ||
+        (!BinOp->getLHS()->getType().getCanonicalType()->isScalarType() &&
+         !BinOp->getLHS()->getType().getCanonicalType()->isDependentType()) ||
+        (!BinOp->getRHS()->getType().getCanonicalType()->isScalarType() &&
+         !BinOp->getRHS()->getType().getCanonicalType()->isDependentType()) ||
+        !(ImpCast = dyn_cast_or_null<ImplicitCastExpr>(BinOp->getRHS())) ||
+        ImpCast->getCastKind() != CK_LValueToRValue;
+    if (!WrongStmt) {
+      llvm::FoldingSetNodeID ID;
+      BinOp->getLHS()->IgnoreParenCasts()->Profile(ID, Context, true);
+      ExprUseChecker UseCheck(ID, Context);
+      WrongStmt = UseCheck.Visit(BinOp->getRHS()->IgnoreParenCasts());
+      if (!WrongStmt) {
+        V = BinOp->getLHS();
+        X = BinOp->getRHS();
+      }
+    }
+    break;
+  }
+  case OMPC_write: {
+    // expr : x = expr, where x is an l-value with scalar type and expr has
+    // scalar type.
+    BinaryOperator *BinOp = dyn_cast_or_null<BinaryOperator>(BaseStmt);
+    WrongStmt =
+        !BinOp || BinOp->getOpcode() != BO_Assign || !BinOp->getLHS() ||
+        !BinOp->getRHS() ||
+        (!BinOp->getLHS()->getType().getCanonicalType()->isScalarType() &&
+         !BinOp->getLHS()->getType().getCanonicalType()->isDependentType()) ||
+        (!BinOp->getRHS()->getType().getCanonicalType()->isScalarType() &&
+         !BinOp->getRHS()->getType().getCanonicalType()->isDependentType());
+    if (!WrongStmt) {
+      llvm::FoldingSetNodeID ID;
+      BinOp->getLHS()->IgnoreParenCasts()->Profile(ID, Context, true);
+      ExprUseChecker UseCheck(ID, Context);
+      WrongStmt = UseCheck.Visit(BinOp->getRHS()->IgnoreParenCasts());
+      if (!WrongStmt) {
+        X = BinOp->getLHS();
+        OpExpr = BinOp->getRHS();
+      }
+    }
+    break;
+  }
+  case OMPC_update: {
+    // expr : x++, where x is an l-value with scalar type.
+    // expr : x--, where x is an l-value with scalar type.
+    // expr : ++x, where x is an l-value with scalar type.
+    // expr : --x, where x is an l-value with scalar type.
+    // expr : x binop= expr, where x is an l-value with scalar type and expr is
+    // scalar.
+    // expr : x = x binop expr, where x is an l-value with scalar type and expr
+    // is scalar.
+    // expr : x = expr binop x, where x is an l-value with scalar type and expr
+    // is scalar.
+    // binop : +, *, -, /, &, ^, |, << or >>.
+    UnaryOperator *UnOp = dyn_cast_or_null<UnaryOperator>(BaseStmt);
+    BinaryOperator *BinOp = dyn_cast_or_null<BinaryOperator>(BaseStmt);
+    BinaryOperator *RHSBinOp = BinOp ? dyn_cast_or_null<BinaryOperator>(
+                                           BinOp->getRHS()->IgnoreParenCasts())
+                                     : 0;
+    WrongStmt =
+        (!UnOp && !BinOp) ||
+        (UnOp && ((!UnOp->getType().getCanonicalType()->isScalarType() &&
+                   !UnOp->getType().getCanonicalType()->isDependentType()) ||
+                  !UnOp->isIncrementDecrementOp())) ||
+        (BinOp &&
+         ((!BinOp->getLHS()->getType().getCanonicalType()->isScalarType() &&
+           !BinOp->getLHS()->getType().getCanonicalType()->isDependentType()) ||
+          (!BinOp->getRHS()->getType().getCanonicalType()->isScalarType() &&
+           !BinOp->getRHS()
+                ->getType()
+                .getCanonicalType()
+                ->isDependentType()))) ||
+        (BinOp &&
+         (!BinOp->isCompoundAssignmentOp() && !BinOp->isShiftAssignOp()) &&
+         RHSBinOp &&
+         (BinOp->getOpcode() != BO_Assign ||
+          (!RHSBinOp->isAdditiveOp() && RHSBinOp->getOpcode() != BO_Mul &&
+           RHSBinOp->getOpcode() != BO_Div && !RHSBinOp->isBitwiseOp() &&
+           !RHSBinOp->isShiftOp()))) ||
+        (BinOp && !RHSBinOp &&
+         ((!BinOp->isCompoundAssignmentOp() && !BinOp->isShiftAssignOp()) ||
+          BinOp->getOpcode() == BO_RemAssign));
+    if (!WrongStmt && UnOp) {
+      X = UnOp->getSubExpr();
+      OpExpr = ActOnIntegerConstant(BaseStmt->getLocStart(), 1).get();
+      if (UnOp->isIncrementOp())
+        Op = BO_Add;
+      else
+        Op = BO_Sub;
+    } else if (!WrongStmt && BinOp &&
+               (BinOp->isCompoundAssignmentOp() || BinOp->isShiftAssignOp())) {
+      llvm::FoldingSetNodeID ID;
+      BinOp->getLHS()->IgnoreParenCasts()->Profile(ID, Context, true);
+      ExprUseChecker UseCheck(ID, Context);
+      WrongStmt = UseCheck.Visit(BinOp->getRHS()->IgnoreParenCasts());
+      if (!WrongStmt) {
+        X = BinOp->getLHS();
+        OpExpr = BinOp->getRHS();
+        switch (BinOp->getOpcode()) {
+        case BO_AddAssign:
+          Op = BO_Add;
+          break;
+        case BO_MulAssign:
+          Op = BO_Mul;
+          break;
+        case BO_SubAssign:
+          Op = BO_Sub;
+          break;
+        case BO_DivAssign:
+          Op = BO_Div;
+          break;
+        case BO_AndAssign:
+          Op = BO_And;
+          break;
+        case BO_XorAssign:
+          Op = BO_Xor;
+          break;
+        case BO_OrAssign:
+          Op = BO_Or;
+          break;
+        case BO_ShlAssign:
+          Op = BO_Shl;
+          break;
+        case BO_ShrAssign:
+          Op = BO_Shr;
+          break;
+        default:
+          WrongStmt = true;
+          break;
+        }
+      }
+    } else if (!WrongStmt && RHSBinOp) {
+      llvm::FoldingSetNodeID ID1, ID2;
+      BinOp->getLHS()->IgnoreParenCasts()->Profile(ID1, Context, true);
+      RHSBinOp->getLHS()->IgnoreParenCasts()->Profile(ID2, Context, true);
+      if (ID1 == ID2) {
+        ExprUseChecker UseCheck(ID1, Context);
+        WrongStmt = UseCheck.Visit(RHSBinOp->getRHS()->IgnoreParenCasts());
+        if (!WrongStmt) {
+          X = BinOp->getLHS();
+          OpExpr = RHSBinOp->getRHS();
+          Op = RHSBinOp->getOpcode();
+        }
+      } else {
+        ID2.clear();
+        RHSBinOp->getRHS()->IgnoreParenCasts()->Profile(ID2, Context, true);
+        if (ID1 == ID2) {
+          ExprUseChecker UseCheck(ID2, Context);
+          WrongStmt = UseCheck.Visit(RHSBinOp->getLHS()->IgnoreParenCasts());
+          if (!WrongStmt) {
+            X = BinOp->getLHS();
+            OpExpr = RHSBinOp->getLHS();
+            Op = RHSBinOp->getOpcode();
+            Reversed = true;
+          }
+        } else
+          WrongStmt = true;
+      }
+    }
+    break;
+  }
+  case OMPC_capture: {
+    // expr : v = x++, where v and x are l-values with scalar types.
+    // expr : v = x--, where v and x are l-values with scalar types.
+    // expr : v = ++x, where v and x are l-values with scalar types.
+    // expr : v = --x, where v and x are l-values with scalar types.
+    // expr : v = x binop= expr, where v and x are l-values with scalar types
+    // and expr is scalar.
+    // expr : v = x = x binop expr, where v and x are l-values with scalar type
+    // and expr is scalar.
+    // expr : v = x = expr binop x, where v and x are l-values with scalar type
+    // and expr is scalar.
+    // stmt : {v = x; x binop= expr;}
+    // stmt : {x binop= expr; v = x;}
+    // stmt : {v = x; x = x binop expr;}
+    // stmt : {v = x; x = expr binop x;}
+    // stmt : {x = x binop expr; v = x;}
+    // stmt : {x = expr binop x; v = x;}
+    // stmt : {v = x; x = expr;}
+    // stmt : {v = x; x++;}
+    // stmt : {v = x; ++x;}
+    // stmt : {x++; v = x;}
+    // stmt : {++x; v = x;}
+    // stmt : {v = x; x--;}
+    // stmt : {v = x; --x;}
+    // stmt : {x--; v = x;}
+    // stmt : {--x; v = x;}
+    // binop : +, *, -, /, &, ^, |, << or >>.
+
+    // Expr *V = 0;
+    // Expr *X = 0;
+    llvm::FoldingSetNodeID VID, XID;
+    BinaryOperator *BinOp = dyn_cast_or_null<BinaryOperator>(BaseStmt);
+    if (ExprStmt && (!BinOp || BinOp->getOpcode() != BO_Assign)) {
+      WrongStmt = true;
+      break;
+    }
+    if (ExprStmt) {
+      V = BinOp->getLHS();
+      V->IgnoreParenCasts()->Profile(VID, Context, true);
+      ExprUseChecker UseCheck(VID, Context);
+      WrongStmt =
+          (!V->getType().getCanonicalType()->isScalarType() &&
+           !V->getType().getCanonicalType()->isDependentType()) ||
+          (!BinOp->getRHS()->getType().getCanonicalType()->isScalarType() &&
+           !BinOp->getRHS()->getType().getCanonicalType()->isDependentType());
+      Expr *RHS = BinOp->getRHS()->IgnoreParenLValueCasts();
+      if (UnaryOperator *XOp = dyn_cast_or_null<UnaryOperator>(RHS)) {
+        X = XOp->getSubExpr();
+        X->IgnoreParenCasts()->Profile(XID, Context, true);
+        OpExpr = ActOnIntegerConstant(X->getLocStart(), 1).get();
+        if (XOp->isIncrementOp())
+          Op = BO_Add;
+        else
+          Op = BO_Sub;
+        CaptureAfter = XOp->isPrefix();
+      } else if (BinaryOperator *XOp = dyn_cast_or_null<BinaryOperator>(RHS)) {
+        X = XOp->getLHS();
+        X->IgnoreParenCasts()->Profile(XID, Context, true);
+        CaptureAfter = true;
+      } else
+        WrongStmt = true;
+      if (WrongStmt)
+        break;
+      BaseStmt = RHS;
+    } else if (CompoundStmt *CStmt = dyn_cast_or_null<CompoundStmt>(BaseStmt)) {
+      WrongStmt = CStmt->size() != 2;
+      if (WrongStmt)
+        break;
+      Stmt *S1 = *(CStmt->body_begin());
+      Stmt *S2 = CStmt->body_back();
+      BinaryOperator *VXOp1 = dyn_cast_or_null<BinaryOperator>(S1);
+      BinaryOperator *VXOp2 = dyn_cast_or_null<BinaryOperator>(S2);
+      UnaryOperator *XOp1 = dyn_cast_or_null<UnaryOperator>(S1);
+      UnaryOperator *XOp2 = dyn_cast_or_null<UnaryOperator>(S2);
+      if (VXOp1 && VXOp2 && VXOp1->getOpcode() == BO_Assign &&
+          VXOp2->getOpcode() == BO_Assign) {
+        V = VXOp1->getLHS();
+        X = VXOp1->getRHS()->IgnoreParenLValueCasts();
+        V->IgnoreParenCasts()->Profile(VID, Context, true);
+        X->IgnoreParenCasts()->Profile(XID, Context, true);
+        llvm::FoldingSetNodeID X2ID;
+        VXOp2->getLHS()->IgnoreParenCasts()->Profile(X2ID, Context, true);
+        if (!(XID == X2ID)) {
+          llvm::FoldingSetNodeID ExprID;
+          VXOp2->getRHS()->IgnoreParenCasts()->Profile(ExprID, Context, true);
+          if (ExprID == VID) {
+            X = VXOp1->getLHS();
+            XID = VID;
+            V = VXOp2->getLHS();
+            VID = X2ID;
+            BaseStmt = S1;
+            CaptureAfter = true;
+          } else {
+            WrongStmt = true;
+            break;
+          }
+        } else {
+          BaseStmt = S2;
+        }
+      } else if (VXOp1 && VXOp2 && VXOp1->getOpcode() == BO_Assign &&
+                 VXOp2->isCompoundAssignmentOp()) {
+        V = VXOp1->getLHS();
+        X = VXOp1->getRHS()->IgnoreParenLValueCasts();
+        V->IgnoreParenCasts()->Profile(VID, Context, true);
+        X->IgnoreParenCasts()->Profile(XID, Context, true);
+        llvm::FoldingSetNodeID X2ID;
+        VXOp2->getLHS()->IgnoreParenCasts()->Profile(X2ID, Context, true);
+        if (!(XID == X2ID)) {
+          WrongStmt = true;
+          break;
+        }
+        BaseStmt = S2;
+      } else if (VXOp1 && VXOp2 && VXOp2->getOpcode() == BO_Assign &&
+                 VXOp1->isCompoundAssignmentOp()) {
+        V = VXOp2->getLHS();
+        X = VXOp2->getRHS()->IgnoreParenLValueCasts();
+        V->IgnoreParenCasts()->Profile(VID, Context, true);
+        X->IgnoreParenCasts()->Profile(XID, Context, true);
+        llvm::FoldingSetNodeID X2ID;
+        VXOp1->getLHS()->IgnoreParenCasts()->Profile(X2ID, Context, true);
+        if (!(XID == X2ID)) {
+          WrongStmt = true;
+          break;
+        }
+        BaseStmt = S1;
+        CaptureAfter = true;
+      } else if (VXOp1 && XOp2 && VXOp1->getOpcode() == BO_Assign) {
+        V = VXOp1->getLHS();
+        X = VXOp1->getRHS()->IgnoreParenLValueCasts();
+        V->IgnoreParenCasts()->Profile(VID, Context, true);
+        X->IgnoreParenCasts()->Profile(XID, Context, true);
+        llvm::FoldingSetNodeID X2ID;
+        XOp2->getSubExpr()->IgnoreParenCasts()->Profile(X2ID, Context, true);
+        if (!(XID == X2ID)) {
+          WrongStmt = true;
+          break;
+        }
+        BaseStmt = S2;
+      } else if (VXOp2 && XOp1 && VXOp2->getOpcode() == BO_Assign) {
+        V = VXOp2->getLHS();
+        X = VXOp2->getRHS()->IgnoreParenLValueCasts();
+        V->IgnoreParenCasts()->Profile(VID, Context, true);
+        X->IgnoreParenCasts()->Profile(XID, Context, true);
+        llvm::FoldingSetNodeID X2ID;
+        XOp1->getSubExpr()->IgnoreParenCasts()->Profile(X2ID, Context, true);
+        if (!(XID == X2ID)) {
+          WrongStmt = true;
+          break;
+        }
+        BaseStmt = S1;
+        CaptureAfter = true;
+      } else {
+        WrongStmt = true;
+        break;
+      }
+      if ((!V->getType().getCanonicalType()->isScalarType() &&
+           !V->getType().getCanonicalType()->isDependentType()) ||
+          (!X->getType().getCanonicalType()->isScalarType() &&
+           !X->getType().getCanonicalType()->isDependentType())) {
+        WrongStmt = true;
+        break;
+      }
+    } else {
+      WrongStmt = true;
+      break;
+    }
+    ExprUseChecker UseCheckV(VID, Context);
+    ExprUseChecker UseCheckX(XID, Context);
+    WrongStmt = UseCheckV.Visit(X->IgnoreParenCasts()) ||
+                UseCheckX.Visit(V->IgnoreParenCasts());
+    if (WrongStmt)
+      break;
+    UnaryOperator *UnOp = dyn_cast_or_null<UnaryOperator>(BaseStmt);
+    BinOp = dyn_cast_or_null<BinaryOperator>(BaseStmt);
+    BinaryOperator *RHSBinOp = BinOp ? dyn_cast_or_null<BinaryOperator>(
+                                           BinOp->getRHS()->IgnoreParenCasts())
+                                     : 0;
+    WrongStmt =
+        (!UnOp && !BinOp) ||
+        (UnOp && ((!UnOp->getType().getCanonicalType()->isScalarType() &&
+                   !UnOp->getType().getCanonicalType()->isDependentType()) ||
+                  !UnOp->isIncrementDecrementOp())) ||
+        (BinOp &&
+         ((!BinOp->getLHS()->getType().getCanonicalType()->isScalarType() &&
+           !BinOp->getLHS()->getType().getCanonicalType()->isDependentType()) ||
+          (!BinOp->getRHS()->getType().getCanonicalType()->isScalarType() &&
+           !BinOp->getRHS()
+                ->getType()
+                .getCanonicalType()
+                ->isDependentType()))) ||
+        (BinOp &&
+         (!BinOp->isCompoundAssignmentOp() && !BinOp->isShiftAssignOp()) &&
+         RHSBinOp &&
+         (BinOp->getOpcode() != BO_Assign ||
+          (!RHSBinOp->isAdditiveOp() && RHSBinOp->getOpcode() != BO_Mul &&
+           RHSBinOp->getOpcode() != BO_Div && !RHSBinOp->isBitwiseOp() &&
+           !RHSBinOp->isShiftOp()))) ||
+        (BinOp && !RHSBinOp &&
+         ((!BinOp->isCompoundAssignmentOp() && !BinOp->isShiftAssignOp() &&
+           BinOp->getOpcode() != BO_Assign) ||
+          BinOp->getOpcode() == BO_RemAssign));
+    if (!WrongStmt && UnOp) {
+      OpExpr = ActOnIntegerConstant(BaseStmt->getLocStart(), 1).get();
+      if (UnOp->isIncrementOp())
+        Op = BO_Add;
+      else
+        Op = BO_Sub;
+    } else if (!WrongStmt && BinOp && !RHSBinOp &&
+               BinOp->getOpcode() == BO_Assign) {
+      Op = BO_Assign;
+      OpExpr = BinOp->getRHS();
+    } else if (!WrongStmt && BinOp &&
+               (BinOp->isCompoundAssignmentOp() || BinOp->isShiftAssignOp())) {
+      ExprUseChecker UseCheckX(XID, Context);
+      ExprUseChecker UseCheckV(VID, Context);
+      WrongStmt = UseCheckX.Visit(BinOp->getRHS()->IgnoreParenCasts()) ||
+                  UseCheckV.Visit(BinOp->getRHS()->IgnoreParenCasts());
+      if (!WrongStmt) {
+        OpExpr = BinOp->getRHS();
+        switch (BinOp->getOpcode()) {
+        case BO_AddAssign:
+          Op = BO_Add;
+          break;
+        case BO_MulAssign:
+          Op = BO_Mul;
+          break;
+        case BO_SubAssign:
+          Op = BO_Sub;
+          break;
+        case BO_DivAssign:
+          Op = BO_Div;
+          break;
+        case BO_AndAssign:
+          Op = BO_And;
+          break;
+        case BO_XorAssign:
+          Op = BO_Xor;
+          break;
+        case BO_OrAssign:
+          Op = BO_Or;
+          break;
+        case BO_ShlAssign:
+          Op = BO_Shl;
+          break;
+        case BO_ShrAssign:
+          Op = BO_Shr;
+          break;
+        default:
+          WrongStmt = true;
+          break;
+        }
+      }
+    } else if (!WrongStmt && RHSBinOp) {
+      llvm::FoldingSetNodeID ID;
+      RHSBinOp->getLHS()->IgnoreParenCasts()->Profile(ID, Context, true);
+      if (XID == ID) {
+        ExprUseChecker UseCheckX(XID, Context);
+        ExprUseChecker UseCheckV(VID, Context);
+        WrongStmt = UseCheckX.Visit(RHSBinOp->getRHS()->IgnoreParenCasts()) ||
+                    UseCheckV.Visit(RHSBinOp->getRHS()->IgnoreParenCasts());
+        if (!WrongStmt) {
+          OpExpr = RHSBinOp->getRHS();
+          Op = RHSBinOp->getOpcode();
+        }
+      } else {
+        ID.clear();
+        RHSBinOp->getRHS()->IgnoreParenCasts()->Profile(ID, Context, true);
+        if (XID == ID) {
+          ExprUseChecker UseCheckX(XID, Context);
+          ExprUseChecker UseCheckV(VID, Context);
+          WrongStmt = UseCheckX.Visit(RHSBinOp->getLHS()->IgnoreParenCasts()) ||
+                      UseCheckV.Visit(RHSBinOp->getLHS()->IgnoreParenCasts());
+          if (!WrongStmt) {
+            OpExpr = RHSBinOp->getLHS();
+            Op = RHSBinOp->getOpcode();
+            Reversed = true;
+          }
+        } else
+          WrongStmt = true;
+      }
+    }
+    break;
+  }
+  default:
+    break;
+  }
+  if (WrongStmt) {
+    Diag(BaseStmt->getLocStart(), diag::err_omp_atomic_wrong_statement)
+        << getOpenMPClauseName(Kind);
+    return StmtError();
+  }
+  //  if (OpExpr && !X->getType()->isDependentType() &&
+  //      !OpExpr->getType()->isDependentType()) {
+  //    ExprResult Res = OpExpr;
+  //    CastKind CK = PrepareScalarCast(Res, X->getType());
+  //    if (CK != CK_NoOp)
+  //      OpExpr = ImpCastExprToType(Res.get(), X->getType(), CK).get();
+  //  }
+  //  if (V && !V->getType()->isDependentType()) {
+  //    ExprResult Res = X;
+  //    CastKind CK = PrepareScalarCast(Res, V->getType());
+  //    if (CK != CK_NoOp)
+  //      X = ImpCastExprToType(Res.get(), V->getType(), CK).get();
+  //  }
+
+  getCurFunction()->setHasBranchProtectedScope();
+
+  return OMPAtomicDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt,
+                                    V, X, OpExpr, Op, CaptureAfter, Reversed);
 }
 
 StmtResult Sema::ActOnOpenMPFlushDirective(ArrayRef<OMPClause *> Clauses,
                                            SourceLocation StartLoc,
                                            SourceLocation EndLoc) {
-  assert(Clauses.size() <= 1 && "Extra clauses in flush directive");
+  getCurFunction()->setHasBranchProtectedScope();
+
   return OMPFlushDirective::Create(Context, StartLoc, EndLoc, Clauses);
 }
 
+StmtResult Sema::ActOnOpenMPOrderedDirective(Stmt *AStmt,
+                                             SourceLocation StartLoc,
+                                             SourceLocation EndLoc) {
+  getCurFunction()->setHasBranchProtectedScope();
+
+  return OMPOrderedDirective::Create(Context, StartLoc, EndLoc, AStmt);
+}
+
+StmtResult Sema::ActOnOpenMPTeamsDirective(ArrayRef<OMPClause *> Clauses,
+                                           Stmt *AStmt, SourceLocation StartLoc,
+                                           SourceLocation EndLoc) {
+
+  getCurFunction()->setHasBranchProtectedScope();
+  return OMPTeamsDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt);
+}
+
+StmtResult Sema::ActOnOpenMPTargetTeamsDirective(ArrayRef<OMPClause *> Clauses,
+                                                 Stmt *AStmt,
+                                                 SourceLocation StartLoc,
+                                                 SourceLocation EndLoc) {
+
+  getCurFunction()->setHasBranchProtectedScope();
+  return OMPTargetTeamsDirective::Create(Context, StartLoc, EndLoc, Clauses,
+                                         AStmt);
+}
+
+StmtResult Sema::ActOnOpenMPDistributeDirective(ArrayRef<OMPClause *> Clauses,
+                                                Stmt *AStmt,
+                                                SourceLocation StartLoc,
+                                                SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(OMPD_distribute, Clauses, AStmt, StartLoc, EndLoc,
+                          NewVar, NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
+    return StmtError();
+  }
+
+  getCurFunction()->setHasBranchProtectedScope();
+  return OMPDistributeDirective::Create(Context, StartLoc, EndLoc, Clauses,
+                                        AStmt, NewVar, NewEnd, NewVarCntExpr,
+                                        NewFinal, VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPCancelDirective(ArrayRef<OMPClause *> Clauses,
+                                            SourceLocation StartLoc,
+                                            SourceLocation EndLoc,
+                                            OpenMPDirectiveKind ConstructType) {
+  getCurFunction()->setHasBranchProtectedScope();
+  return OMPCancelDirective::Create(Context, StartLoc, EndLoc, Clauses,
+                                    ConstructType);
+}
+
+StmtResult
+Sema::ActOnOpenMPCancellationPointDirective(SourceLocation StartLoc,
+                                            SourceLocation EndLoc,
+                                            OpenMPDirectiveKind ConstructType) {
+  getCurFunction()->setHasBranchProtectedScope();
+  return OMPCancellationPointDirective::Create(Context, StartLoc, EndLoc,
+                                               ConstructType);
+}
+
+namespace {
+class TeamsChecker : public StmtVisitor<TeamsChecker, bool> {
+  Stmt *FoundTeams;
+
+public:
+  bool VisitOMPTeamsDirective(OMPTeamsDirective *D) {
+    FoundTeams = D;
+    return false;
+  }
+  bool VisitOMPTeamsDistributeDirective(OMPTeamsDistributeDirective *D) {
+    FoundTeams = D;
+    return false;
+  }
+  bool
+  VisitOMPTeamsDistributeSimdDirective(OMPTeamsDistributeSimdDirective *D) {
+    FoundTeams = D;
+    return false;
+  }
+  bool VisitOMPTeamsDistributeParallelForDirective(
+      OMPTeamsDistributeParallelForDirective *D) {
+    FoundTeams = D;
+    return false;
+  }
+  bool VisitOMPTeamsDistributeParallelForSimdDirective(
+      OMPTeamsDistributeParallelForSimdDirective *D) {
+    FoundTeams = D;
+    return false;
+  }
+  bool VisitCompoundStmt(CompoundStmt *S) {
+    bool Flag = false;
+    for (Stmt::child_range R = S->children(); R; ++R) {
+      Flag |= Visit(*R);
+      if (Flag && FoundTeams)
+        return true;
+    }
+    return Flag;
+  }
+  bool VisitNullStmt(NullStmt *) { return false; }
+  bool VisitStmt(Stmt *) { return true; }
+  TeamsChecker() : FoundTeams(0) {}
+  Stmt *getFoundTeams() { return FoundTeams; }
+};
+}
+
+StmtResult Sema::ActOnOpenMPTargetDirective(ArrayRef<OMPClause *> Clauses,
+                                            Stmt *AStmt,
+                                            SourceLocation StartLoc,
+                                            SourceLocation EndLoc) {
+  TeamsChecker Checker;
+  // If specified, a teams construct must be contained within a target
+  // construct. That target construct must contain no statements or directives
+  // outside of the teams construct.
+  if (Checker.Visit(cast<CapturedStmt>(AStmt)->getCapturedStmt())) {
+    if (Stmt *S = Checker.getFoundTeams()) {
+      Diag(S->getLocStart(), diag::err_omp_teams_not_single_in_target);
+      return StmtError();
+    }
+  }
+
+  getCurFunction()->setHasBranchProtectedScope();
+  return OMPTargetDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt);
+}
+
+StmtResult Sema::ActOnOpenMPTargetDataDirective(ArrayRef<OMPClause *> Clauses,
+                                                Stmt *AStmt,
+                                                SourceLocation StartLoc,
+                                                SourceLocation EndLoc) {
+  getCurFunction()->setHasBranchProtectedScope();
+  return OMPTargetDataDirective::Create(Context, StartLoc, EndLoc, Clauses,
+                                        AStmt);
+}
+
+StmtResult Sema::ActOnOpenMPTargetUpdateDirective(ArrayRef<OMPClause *> Clauses,
+                                                  SourceLocation StartLoc,
+                                                  SourceLocation EndLoc) {
+  // FIXME Add checking that at least one 'from' or 'to' clause is specified
+
+  getCurFunction()->setHasBranchProtectedScope();
+  return OMPTargetUpdateDirective::Create(Context, StartLoc, EndLoc, Clauses);
+}
+
+StmtResult
+Sema::ActOnOpenMPTeamsDistributeDirective(ArrayRef<OMPClause *> Clauses,
+                                          Stmt *AStmt, SourceLocation StartLoc,
+                                          SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(OMPD_teams_distribute, Clauses, AStmt, StartLoc,
+                          EndLoc, NewVar, NewEnd, NewVarCntExpr, NewFinal,
+                          VarCnts)) {
+    return StmtError();
+  }
+
+  getCurFunction()->setHasBranchProtectedScope();
+  return OMPTeamsDistributeDirective::Create(Context, StartLoc, EndLoc, Clauses,
+                                             AStmt, NewVar, NewEnd,
+                                             NewVarCntExpr, NewFinal, VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPTeamsDistributeSimdDirective(
+    OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+    SourceLocation StartLoc, SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
+    return StmtError();
+  }
+
+  // Add two arguments into captured stmt for index and last_iter.
+  CapturedStmt *CapturedBody =
+      AddSimdArgsIntoCapturedStmt(cast<CapturedStmt>(AStmt), NewVar);
+
+  getCurFunction()->setHasBranchProtectedScope();
+
+  // Rebuild the directive.
+  return OMPTeamsDistributeSimdDirective::Create(
+      Context, StartLoc, EndLoc, Clauses, CapturedBody, NewVar, NewEnd,
+      NewVarCntExpr, NewFinal, VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPTargetTeamsDistributeDirective(
+    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,
+    SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(OMPD_target_teams_distribute, Clauses, AStmt,
+                          StartLoc, EndLoc, NewVar, NewEnd, NewVarCntExpr,
+                          NewFinal, VarCnts)) {
+    return StmtError();
+  }
+
+  getCurFunction()->setHasBranchProtectedScope();
+  return OMPTargetTeamsDistributeDirective::Create(
+      Context, StartLoc, EndLoc, Clauses, AStmt, NewVar, NewEnd, NewVarCntExpr,
+      NewFinal, VarCnts);
+}
+
+StmtResult Sema::ActOnOpenMPTargetTeamsDistributeSimdDirective(
+    OpenMPDirectiveKind Kind, ArrayRef<OMPClause *> Clauses, Stmt *AStmt,
+    SourceLocation StartLoc, SourceLocation EndLoc) {
+  // Prepare the output arguments for routine CollapseOpenMPLoop
+  Expr *NewEnd = 0;
+  Expr *NewVar = 0;
+  Expr *NewVarCntExpr = 0;
+  Expr *NewFinal = 0;
+  SmallVector<Expr *, 4> VarCnts;
+
+  // Do the collapse.
+  if (!CollapseOpenMPLoop(Kind, Clauses, AStmt, StartLoc, EndLoc, NewVar,
+                          NewEnd, NewVarCntExpr, NewFinal, VarCnts)) {
+    return StmtError();
+  }
+
+  // Add two arguments into captured stmt for index and last_iter.
+  CapturedStmt *CapturedBody =
+      AddSimdArgsIntoCapturedStmt(cast<CapturedStmt>(AStmt), NewVar);
+
+  getCurFunction()->setHasBranchProtectedScope();
+
+  // Rebuild the directive.
+  return OMPTargetTeamsDistributeSimdDirective::Create(
+      Context, StartLoc, EndLoc, Clauses, CapturedBody, NewVar, NewEnd,
+      NewVarCntExpr, NewFinal, VarCnts);
+}
+
 OMPClause *Sema::ActOnOpenMPSingleExprClause(OpenMPClauseKind Kind, Expr *Expr,
                                              SourceLocation StartLoc,
-                                             SourceLocation LParenLoc,
                                              SourceLocation EndLoc) {
-  OMPClause *Res = nullptr;
+  OMPClause *Res = 0;
   switch (Kind) {
   case OMPC_if:
-    Res = ActOnOpenMPIfClause(Expr, StartLoc, LParenLoc, EndLoc);
-    break;
-  case OMPC_final:
-    Res = ActOnOpenMPFinalClause(Expr, StartLoc, LParenLoc, EndLoc);
+    Res = ActOnOpenMPIfClause(Expr, StartLoc, EndLoc);
     break;
   case OMPC_num_threads:
-    Res = ActOnOpenMPNumThreadsClause(Expr, StartLoc, LParenLoc, EndLoc);
+    Res = ActOnOpenMPNumThreadsClause(Expr, StartLoc, EndLoc);
+    break;
+  case OMPC_collapse:
+    Res = ActOnOpenMPCollapseClause(Expr, StartLoc, EndLoc);
+    break;
+  case OMPC_final:
+    Res = ActOnOpenMPFinalClause(Expr, StartLoc, EndLoc);
     break;
   case OMPC_safelen:
-    Res = ActOnOpenMPSafelenClause(Expr, StartLoc, LParenLoc, EndLoc);
+    Res = ActOnOpenMPSafelenClause(Expr, StartLoc, EndLoc);
     break;
-  case OMPC_collapse:
-    Res = ActOnOpenMPCollapseClause(Expr, StartLoc, LParenLoc, EndLoc);
+  case OMPC_simdlen:
+    Res = ActOnOpenMPSimdlenClause(Expr, StartLoc, EndLoc);
+    break;
+  case OMPC_num_teams:
+    Res = ActOnOpenMPNumTeamsClause(Expr, StartLoc, EndLoc);
+    break;
+  case OMPC_thread_limit:
+    Res = ActOnOpenMPThreadLimitClause(Expr, StartLoc, EndLoc);
+    break;
+  case OMPC_device:
+    Res = ActOnOpenMPDeviceClause(Expr, StartLoc, EndLoc);
+    break;
+  default:
     break;
-  case OMPC_default:
-  case OMPC_proc_bind:
-  case OMPC_schedule:
-  case OMPC_private:
-  case OMPC_firstprivate:
-  case OMPC_lastprivate:
-  case OMPC_shared:
-  case OMPC_reduction:
-  case OMPC_linear:
-  case OMPC_aligned:
-  case OMPC_copyin:
-  case OMPC_copyprivate:
-  case OMPC_ordered:
-  case OMPC_nowait:
-  case OMPC_untied:
-  case OMPC_mergeable:
-  case OMPC_threadprivate:
-  case OMPC_flush:
-  case OMPC_unknown:
-    llvm_unreachable("Clause is not allowed.");
   }
   return Res;
 }
 
 OMPClause *Sema::ActOnOpenMPIfClause(Expr *Condition, SourceLocation StartLoc,
-                                     SourceLocation LParenLoc,
                                      SourceLocation EndLoc) {
+  QualType Type = Condition->getType();
   Expr *ValExpr = Condition;
-  if (!Condition->isValueDependent() && !Condition->isTypeDependent() &&
-      !Condition->isInstantiationDependent() &&
-      !Condition->containsUnexpandedParameterPack()) {
+  if (!Type->isDependentType() && !Type->isInstantiationDependentType()) {
     ExprResult Val = ActOnBooleanCondition(DSAStack->getCurScope(),
                                            Condition->getExprLoc(), Condition);
     if (Val.isInvalid())
-      return nullptr;
+      return 0;
 
     ValExpr = Val.get();
   }
 
-  return new (Context) OMPIfClause(ValExpr, StartLoc, LParenLoc, EndLoc);
+  return new (Context) OMPIfClause(ValExpr, StartLoc, EndLoc);
 }
 
 OMPClause *Sema::ActOnOpenMPFinalClause(Expr *Condition,
                                         SourceLocation StartLoc,
-                                        SourceLocation LParenLoc,
                                         SourceLocation EndLoc) {
+  QualType Type = Condition->getType();
   Expr *ValExpr = Condition;
-  if (!Condition->isValueDependent() && !Condition->isTypeDependent() &&
-      !Condition->isInstantiationDependent() &&
-      !Condition->containsUnexpandedParameterPack()) {
+  if (!Type->isDependentType() && !Type->isInstantiationDependentType()) {
     ExprResult Val = ActOnBooleanCondition(DSAStack->getCurScope(),
                                            Condition->getExprLoc(), Condition);
     if (Val.isInvalid())
-      return nullptr;
+      return 0;
 
     ValExpr = Val.get();
   }
 
-  return new (Context) OMPFinalClause(ValExpr, StartLoc, LParenLoc, EndLoc);
+  return new (Context) OMPFinalClause(ValExpr, StartLoc, EndLoc);
 }
 
-ExprResult Sema::PerformOpenMPImplicitIntegerConversion(SourceLocation Loc,
-                                                        Expr *Op) {
-  if (!Op)
-    return ExprError();
-
-  class IntConvertDiagnoser : public ICEConvertDiagnoser {
+OMPClause *Sema::ActOnOpenMPNumThreadsClause(Expr *NumThreads,
+                                             SourceLocation StartLoc,
+                                             SourceLocation EndLoc) {
+  class CConvertDiagnoser : public ICEConvertDiagnoser {
   public:
-    IntConvertDiagnoser()
-        : ICEConvertDiagnoser(/*AllowScopedEnumerations*/ false, false, true) {}
-    SemaDiagnosticBuilder diagnoseNotInt(Sema &S, SourceLocation Loc,
-                                         QualType T) override {
-      return S.Diag(Loc, diag::err_omp_not_integral) << T;
-    }
-    SemaDiagnosticBuilder diagnoseIncomplete(Sema &S, SourceLocation Loc,
-                                             QualType T) override {
-      return S.Diag(Loc, diag::err_omp_incomplete_type) << T;
-    }
-    SemaDiagnosticBuilder diagnoseExplicitConv(Sema &S, SourceLocation Loc,
-                                               QualType T,
-                                               QualType ConvTy) override {
-      return S.Diag(Loc, diag::err_omp_explicit_conversion) << T << ConvTy;
-    }
-    SemaDiagnosticBuilder noteExplicitConv(Sema &S, CXXConversionDecl *Conv,
-                                           QualType ConvTy) override {
-      return S.Diag(Conv->getLocation(), diag::note_omp_conversion_here)
+    CConvertDiagnoser() : ICEConvertDiagnoser(true, false, true) {}
+    virtual SemaDiagnosticBuilder diagnoseNotInt(Sema &S, SourceLocation Loc,
+                                                 QualType T) {
+      return S.Diag(Loc, diag::err_typecheck_statement_requires_integer) << T;
+    }
+    virtual SemaDiagnosticBuilder
+    diagnoseIncomplete(Sema &S, SourceLocation Loc, QualType T) {
+      return S.Diag(Loc, diag::err_incomplete_class_type) << T;
+    }
+    virtual SemaDiagnosticBuilder diagnoseExplicitConv(Sema &S,
+                                                       SourceLocation Loc,
+                                                       QualType T,
+                                                       QualType ConvTy) {
+      return S.Diag(Loc, diag::err_explicit_conversion) << T << ConvTy;
+    }
+
+    virtual SemaDiagnosticBuilder
+    noteExplicitConv(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) {
+      return S.Diag(Conv->getLocation(), diag::note_conversion)
              << ConvTy->isEnumeralType() << ConvTy;
     }
-    SemaDiagnosticBuilder diagnoseAmbiguous(Sema &S, SourceLocation Loc,
-                                            QualType T) override {
-      return S.Diag(Loc, diag::err_omp_ambiguous_conversion) << T;
-    }
-    SemaDiagnosticBuilder noteAmbiguous(Sema &S, CXXConversionDecl *Conv,
-                                        QualType ConvTy) override {
-      return S.Diag(Conv->getLocation(), diag::note_omp_conversion_here)
+    virtual SemaDiagnosticBuilder diagnoseAmbiguous(Sema &S, SourceLocation Loc,
+                                                    QualType T) {
+      return S.Diag(Loc, diag::err_multiple_conversions) << T;
+    }
+
+    virtual SemaDiagnosticBuilder
+    noteAmbiguous(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) {
+      return S.Diag(Conv->getLocation(), diag::note_conversion)
              << ConvTy->isEnumeralType() << ConvTy;
     }
-    SemaDiagnosticBuilder diagnoseConversion(Sema &, SourceLocation, QualType,
-                                             QualType) override {
+
+    virtual SemaDiagnosticBuilder diagnoseConversion(Sema &S,
+                                                     SourceLocation Loc,
+                                                     QualType T,
+                                                     QualType ConvTy) {
       llvm_unreachable("conversion functions are permitted");
     }
   } ConvertDiagnoser;
-  return PerformContextualImplicitConversion(Loc, Op, ConvertDiagnoser);
-}
 
-OMPClause *Sema::ActOnOpenMPNumThreadsClause(Expr *NumThreads,
-                                             SourceLocation StartLoc,
-                                             SourceLocation LParenLoc,
-                                             SourceLocation EndLoc) {
-  Expr *ValExpr = NumThreads;
-  if (!NumThreads->isValueDependent() && !NumThreads->isTypeDependent() &&
-      !NumThreads->isInstantiationDependent() &&
-      !NumThreads->containsUnexpandedParameterPack()) {
-    SourceLocation NumThreadsLoc = NumThreads->getLocStart();
-    ExprResult Val =
-        PerformOpenMPImplicitIntegerConversion(NumThreadsLoc, NumThreads);
-    if (Val.isInvalid())
-      return nullptr;
+  if (!NumThreads)
+    return 0;
 
-    ValExpr = Val.get();
+  Expr *ValExpr = NumThreads;
+  if (!ValExpr->isTypeDependent() && !ValExpr->isValueDependent() &&
+      !ValExpr->isInstantiationDependent()) {
+    SourceLocation Loc = NumThreads->getExprLoc();
+    ExprResult Value =
+        PerformContextualImplicitConversion(Loc, NumThreads, ConvertDiagnoser);
+    if (Value.isInvalid() ||
+        !Value.get()->getType()->isIntegralOrUnscopedEnumerationType())
+      return 0;
 
-    // OpenMP [2.5, Restrictions]
-    //  The num_threads expression must evaluate to a positive integer value.
     llvm::APSInt Result;
-    if (ValExpr->isIntegerConstantExpr(Result, Context) && Result.isSigned() &&
+    if (Value.get()->isIntegerConstantExpr(Result, Context) &&
         !Result.isStrictlyPositive()) {
-      Diag(NumThreadsLoc, diag::err_omp_negative_expression_in_clause)
-          << "num_threads" << NumThreads->getSourceRange();
-      return nullptr;
+      Diag(Loc, diag::err_negative_expression_in_clause)
+          << NumThreads->getSourceRange();
+      return 0;
     }
+    Value = DefaultLvalueConversion(Value.get());
+    if (Value.isInvalid())
+      return 0;
+    Value = PerformImplicitConversion(
+        Value.get(), Context.getIntTypeForBitwidth(32, true), AA_Converting);
+    ValExpr = Value.get();
   }
 
-  return new (Context)
-      OMPNumThreadsClause(ValExpr, StartLoc, LParenLoc, EndLoc);
+  return new (Context) OMPNumThreadsClause(ValExpr, StartLoc, EndLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPDeviceClause(Expr *Device, SourceLocation StartLoc,
+                                         SourceLocation EndLoc) {
+  class CConvertDiagnoser : public ICEConvertDiagnoser {
+  public:
+    CConvertDiagnoser() : ICEConvertDiagnoser(true, false, true) {}
+    virtual SemaDiagnosticBuilder diagnoseNotInt(Sema &S, SourceLocation Loc,
+                                                 QualType T) {
+      return S.Diag(Loc, diag::err_typecheck_statement_requires_integer) << T;
+    }
+    virtual SemaDiagnosticBuilder
+    diagnoseIncomplete(Sema &S, SourceLocation Loc, QualType T) {
+      return S.Diag(Loc, diag::err_incomplete_class_type) << T;
+    }
+    virtual SemaDiagnosticBuilder diagnoseExplicitConv(Sema &S,
+                                                       SourceLocation Loc,
+                                                       QualType T,
+                                                       QualType ConvTy) {
+      return S.Diag(Loc, diag::err_explicit_conversion) << T << ConvTy;
+    }
+
+    virtual SemaDiagnosticBuilder
+    noteExplicitConv(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) {
+      return S.Diag(Conv->getLocation(), diag::note_conversion)
+             << ConvTy->isEnumeralType() << ConvTy;
+    }
+    virtual SemaDiagnosticBuilder diagnoseAmbiguous(Sema &S, SourceLocation Loc,
+                                                    QualType T) {
+      return S.Diag(Loc, diag::err_multiple_conversions) << T;
+    }
+
+    virtual SemaDiagnosticBuilder
+    noteAmbiguous(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) {
+      return S.Diag(Conv->getLocation(), diag::note_conversion)
+             << ConvTy->isEnumeralType() << ConvTy;
+    }
+
+    virtual SemaDiagnosticBuilder diagnoseConversion(Sema &S,
+                                                     SourceLocation Loc,
+                                                     QualType T,
+                                                     QualType ConvTy) {
+      llvm_unreachable("conversion functions are permitted");
+    }
+  } ConvertDiagnoser;
+
+  if (!Device)
+    return 0;
+
+  Expr *ValExpr = Device;
+  if (!ValExpr->isTypeDependent() && !ValExpr->isValueDependent() &&
+      !ValExpr->isInstantiationDependent()) {
+    SourceLocation Loc = ValExpr->getExprLoc();
+    ExprResult Value =
+        PerformContextualImplicitConversion(Loc, ValExpr, ConvertDiagnoser);
+    if (Value.isInvalid() ||
+        !Value.get()->getType()->isIntegralOrUnscopedEnumerationType())
+      return 0;
+
+    llvm::APSInt Result;
+    if (Value.get()->isIntegerConstantExpr(Result, Context) &&
+        Result.isNegative()) {
+      Diag(Loc, diag::err_negative_expression_in_clause)
+          << ValExpr->getSourceRange();
+      return 0;
+    }
+    Value = DefaultLvalueConversion(Value.get());
+    if (Value.isInvalid())
+      return 0;
+    Value = PerformImplicitConversion(
+        Value.get(), Context.getIntTypeForBitwidth(32, true), AA_Converting);
+    ValExpr = Value.get();
+  }
+
+  return new (Context) OMPDeviceClause(ValExpr, StartLoc, EndLoc);
 }
 
-ExprResult Sema::VerifyPositiveIntegerConstantInClause(Expr *E,
-                                                       OpenMPClauseKind CKind) {
+Expr *Sema::ActOnConstantPositiveSubExpressionInClause(Expr *E) {
   if (!E)
-    return ExprError();
-  if (E->isValueDependent() || E->isTypeDependent() ||
-      E->isInstantiationDependent() || E->containsUnexpandedParameterPack())
+    return 0;
+  if (E->isInstantiationDependent())
     return E;
   llvm::APSInt Result;
   ExprResult ICE = VerifyIntegerConstantExpression(E, &Result);
   if (ICE.isInvalid())
-    return ExprError();
+    return 0;
   if (!Result.isStrictlyPositive()) {
-    Diag(E->getExprLoc(), diag::err_omp_negative_expression_in_clause)
-        << getOpenMPClauseName(CKind) << E->getSourceRange();
-    return ExprError();
+    Diag(E->getExprLoc(), diag::err_negative_expression_in_clause)
+        << E->getSourceRange();
+    return 0;
   }
-  return ICE;
+  return IntegerLiteral::Create(Context, Result,
+                                ICE.get()->getType().getNonReferenceType(),
+                                E->getExprLoc());
+}
+
+Expr *Sema::ActOnConstantLinearStep(Expr *E) {
+  if (!E)
+    return 0;
+  if (E->isInstantiationDependent())
+    return E;
+  llvm::APSInt Result;
+  ExprResult ICE = VerifyIntegerConstantExpression(E, &Result);
+  if (ICE.isInvalid())
+    return 0;
+  if (!Result.isStrictlyPositive() && !Result.isNegative()) {
+    Diag(E->getExprLoc(), diag::err_zero_step_in_linear_clause)
+        << E->getSourceRange();
+    return 0;
+  }
+  return IntegerLiteral::Create(Context, Result,
+                                ICE.get()->getType().getNonReferenceType(),
+                                E->getExprLoc());
+}
+
+OMPClause *Sema::ActOnOpenMPCollapseClause(Expr *NumLoops,
+                                           SourceLocation StartLoc,
+                                           SourceLocation EndLoc) {
+  // OpenMP [2.7.1, Loop construct, Description]
+  // The parameter of the collapse clause must be a constant
+  // positive integer expression.
+  Expr *Val = ActOnConstantPositiveSubExpressionInClause(NumLoops);
+  if (!Val)
+    return 0;
+
+  return new (Context) OMPCollapseClause(Val, StartLoc, EndLoc);
 }
 
 OMPClause *Sema::ActOnOpenMPSafelenClause(Expr *Len, SourceLocation StartLoc,
-                                          SourceLocation LParenLoc,
                                           SourceLocation EndLoc) {
   // OpenMP [2.8.1, simd construct, Description]
   // The parameter of the safelen clause must be a constant
   // positive integer expression.
-  ExprResult Safelen = VerifyPositiveIntegerConstantInClause(Len, OMPC_safelen);
-  if (Safelen.isInvalid())
-    return nullptr;
-  return new (Context)
-      OMPSafelenClause(Safelen.get(), StartLoc, LParenLoc, EndLoc);
+  Expr *Val = ActOnConstantPositiveSubExpressionInClause(Len);
+  if (!Val)
+    return 0;
+
+  return new (Context) OMPSafelenClause(Val, StartLoc, EndLoc);
 }
 
-OMPClause *Sema::ActOnOpenMPCollapseClause(Expr *NumForLoops,
-                                           SourceLocation StartLoc,
-                                           SourceLocation LParenLoc,
-                                           SourceLocation EndLoc) {
-  // OpenMP [2.7.1, loop construct, Description]
-  // OpenMP [2.8.1, simd construct, Description]
-  // OpenMP [2.9.6, distribute construct, Description]
-  // The parameter of the collapse clause must be a constant
+OMPClause *Sema::ActOnOpenMPSimdlenClause(Expr *Len, SourceLocation StartLoc,
+                                          SourceLocation EndLoc) {
+  // OpenMP [2.8.2, declare simd construct, Description]
+  // The parameter of the simdlen clause must be a constant
   // positive integer expression.
-  ExprResult NumForLoopsResult =
-      VerifyPositiveIntegerConstantInClause(NumForLoops, OMPC_collapse);
-  if (NumForLoopsResult.isInvalid())
-    return nullptr;
-  return new (Context)
-      OMPCollapseClause(NumForLoopsResult.get(), StartLoc, LParenLoc, EndLoc);
+  Expr *Val = ActOnConstantPositiveSubExpressionInClause(Len);
+  if (!Val)
+    return 0;
+
+  return new (Context) OMPSimdlenClause(Val, StartLoc, EndLoc);
 }
 
-OMPClause *Sema::ActOnOpenMPSimpleClause(
-    OpenMPClauseKind Kind, unsigned Argument, SourceLocation ArgumentLoc,
-    SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation EndLoc) {
-  OMPClause *Res = nullptr;
+OMPClause *Sema::ActOnOpenMPNumTeamsClause(Expr *E, SourceLocation StartLoc,
+                                           SourceLocation EndLoc) {
+  class CConvertDiagnoser : public ICEConvertDiagnoser {
+  public:
+    CConvertDiagnoser() : ICEConvertDiagnoser(true, false, true) {}
+    virtual SemaDiagnosticBuilder diagnoseNotInt(Sema &S, SourceLocation Loc,
+                                                 QualType T) {
+      return S.Diag(Loc, diag::err_typecheck_statement_requires_integer) << T;
+    }
+    virtual SemaDiagnosticBuilder
+    diagnoseIncomplete(Sema &S, SourceLocation Loc, QualType T) {
+      return S.Diag(Loc, diag::err_incomplete_class_type) << T;
+    }
+    virtual SemaDiagnosticBuilder diagnoseExplicitConv(Sema &S,
+                                                       SourceLocation Loc,
+                                                       QualType T,
+                                                       QualType ConvTy) {
+      return S.Diag(Loc, diag::err_explicit_conversion) << T << ConvTy;
+    }
+
+    virtual SemaDiagnosticBuilder
+    noteExplicitConv(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) {
+      return S.Diag(Conv->getLocation(), diag::note_conversion)
+             << ConvTy->isEnumeralType() << ConvTy;
+    }
+    virtual SemaDiagnosticBuilder diagnoseAmbiguous(Sema &S, SourceLocation Loc,
+                                                    QualType T) {
+      return S.Diag(Loc, diag::err_multiple_conversions) << T;
+    }
+
+    virtual SemaDiagnosticBuilder
+    noteAmbiguous(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) {
+      return S.Diag(Conv->getLocation(), diag::note_conversion)
+             << ConvTy->isEnumeralType() << ConvTy;
+    }
+
+    virtual SemaDiagnosticBuilder diagnoseConversion(Sema &S,
+                                                     SourceLocation Loc,
+                                                     QualType T,
+                                                     QualType ConvTy) {
+      llvm_unreachable("conversion functions are permitted");
+    }
+  } ConvertDiagnoser;
+
+  if (!E)
+    return 0;
+
+  Expr *ValExpr = E;
+  if (!ValExpr->isTypeDependent() && !ValExpr->isValueDependent() &&
+      !ValExpr->isInstantiationDependent()) {
+    SourceLocation Loc = ValExpr->getExprLoc();
+    ExprResult Value =
+        PerformContextualImplicitConversion(Loc, ValExpr, ConvertDiagnoser);
+    if (Value.isInvalid() ||
+        !Value.get()->getType()->isIntegralOrUnscopedEnumerationType())
+      return 0;
+
+    llvm::APSInt Result;
+    if (Value.get()->isIntegerConstantExpr(Result, Context) &&
+        !Result.isStrictlyPositive()) {
+      Diag(Loc, diag::err_negative_expression_in_clause)
+          << ValExpr->getSourceRange();
+      return 0;
+    }
+    Value = DefaultLvalueConversion(Value.get());
+    if (Value.isInvalid())
+      return 0;
+    Value = PerformImplicitConversion(
+        Value.get(), Context.getIntTypeForBitwidth(32, true), AA_Converting);
+    if (Value.isInvalid())
+      return 0;
+    ValExpr = Value.get();
+  }
+
+  return new (Context) OMPNumTeamsClause(ValExpr, StartLoc, EndLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPThreadLimitClause(Expr *E, SourceLocation StartLoc,
+                                              SourceLocation EndLoc) {
+  class CConvertDiagnoser : public ICEConvertDiagnoser {
+  public:
+    CConvertDiagnoser() : ICEConvertDiagnoser(true, false, true) {}
+    virtual SemaDiagnosticBuilder diagnoseNotInt(Sema &S, SourceLocation Loc,
+                                                 QualType T) {
+      return S.Diag(Loc, diag::err_typecheck_statement_requires_integer) << T;
+    }
+    virtual SemaDiagnosticBuilder
+    diagnoseIncomplete(Sema &S, SourceLocation Loc, QualType T) {
+      return S.Diag(Loc, diag::err_incomplete_class_type) << T;
+    }
+    virtual SemaDiagnosticBuilder diagnoseExplicitConv(Sema &S,
+                                                       SourceLocation Loc,
+                                                       QualType T,
+                                                       QualType ConvTy) {
+      return S.Diag(Loc, diag::err_explicit_conversion) << T << ConvTy;
+    }
+
+    virtual SemaDiagnosticBuilder
+    noteExplicitConv(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) {
+      return S.Diag(Conv->getLocation(), diag::note_conversion)
+             << ConvTy->isEnumeralType() << ConvTy;
+    }
+    virtual SemaDiagnosticBuilder diagnoseAmbiguous(Sema &S, SourceLocation Loc,
+                                                    QualType T) {
+      return S.Diag(Loc, diag::err_multiple_conversions) << T;
+    }
+
+    virtual SemaDiagnosticBuilder
+    noteAmbiguous(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) {
+      return S.Diag(Conv->getLocation(), diag::note_conversion)
+             << ConvTy->isEnumeralType() << ConvTy;
+    }
+
+    virtual SemaDiagnosticBuilder diagnoseConversion(Sema &S,
+                                                     SourceLocation Loc,
+                                                     QualType T,
+                                                     QualType ConvTy) {
+      llvm_unreachable("conversion functions are permitted");
+    }
+  } ConvertDiagnoser;
+
+  if (!E)
+    return 0;
+
+  Expr *ValExpr = E;
+  if (!ValExpr->isTypeDependent() && !ValExpr->isValueDependent() &&
+      !ValExpr->isInstantiationDependent()) {
+    SourceLocation Loc = ValExpr->getExprLoc();
+    ExprResult Value =
+        PerformContextualImplicitConversion(Loc, ValExpr, ConvertDiagnoser);
+    if (Value.isInvalid() ||
+        !Value.get()->getType()->isIntegralOrUnscopedEnumerationType())
+      return 0;
+
+    llvm::APSInt Result;
+    if (Value.get()->isIntegerConstantExpr(Result, Context) &&
+        !Result.isStrictlyPositive()) {
+      Diag(Loc, diag::err_negative_expression_in_clause)
+          << ValExpr->getSourceRange();
+      return 0;
+    }
+    Value = DefaultLvalueConversion(Value.get());
+    if (Value.isInvalid())
+      return 0;
+    Value = PerformImplicitConversion(
+        Value.get(), Context.getIntTypeForBitwidth(32, true), AA_Converting);
+    if (Value.isInvalid())
+      return 0;
+    ValExpr = Value.get();
+  }
+
+  return new (Context) OMPThreadLimitClause(ValExpr, StartLoc, EndLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPSimpleClause(OpenMPClauseKind Kind,
+                                         unsigned Argument,
+                                         SourceLocation ArgumentLoc,
+                                         SourceLocation StartLoc,
+                                         SourceLocation EndLoc) {
+  OMPClause *Res = 0;
   switch (Kind) {
   case OMPC_default:
     Res =
         ActOnOpenMPDefaultClause(static_cast<OpenMPDefaultClauseKind>(Argument),
-                                 ArgumentLoc, StartLoc, LParenLoc, EndLoc);
+                                 ArgumentLoc, StartLoc, EndLoc);
     break;
   case OMPC_proc_bind:
     Res = ActOnOpenMPProcBindClause(
         static_cast<OpenMPProcBindClauseKind>(Argument), ArgumentLoc, StartLoc,
-        LParenLoc, EndLoc);
+        EndLoc);
+    break;
+  default:
     break;
-  case OMPC_if:
-  case OMPC_final:
-  case OMPC_num_threads:
-  case OMPC_safelen:
-  case OMPC_collapse:
-  case OMPC_schedule:
-  case OMPC_private:
-  case OMPC_firstprivate:
-  case OMPC_lastprivate:
-  case OMPC_shared:
-  case OMPC_reduction:
-  case OMPC_linear:
-  case OMPC_aligned:
-  case OMPC_copyin:
-  case OMPC_copyprivate:
-  case OMPC_ordered:
-  case OMPC_nowait:
-  case OMPC_untied:
-  case OMPC_mergeable:
-  case OMPC_threadprivate:
-  case OMPC_flush:
-  case OMPC_unknown:
-    llvm_unreachable("Clause is not allowed.");
   }
   return Res;
 }
 
 OMPClause *Sema::ActOnOpenMPDefaultClause(OpenMPDefaultClauseKind Kind,
-                                          SourceLocation KindKwLoc,
+                                          SourceLocation KindLoc,
                                           SourceLocation StartLoc,
-                                          SourceLocation LParenLoc,
                                           SourceLocation EndLoc) {
   if (Kind == OMPC_DEFAULT_unknown) {
     std::string Values;
-    static_assert(OMPC_DEFAULT_unknown > 0,
-                  "OMPC_DEFAULT_unknown not greater than 0");
-    std::string Sep(", ");
-    for (unsigned i = 0; i < OMPC_DEFAULT_unknown; ++i) {
+    std::string Sep(NUM_OPENMP_DEFAULT_KINDS > 1 ? ", " : "");
+    for (unsigned i = OMPC_DEFAULT_unknown + 1; i < NUM_OPENMP_DEFAULT_KINDS;
+         ++i) {
       Values += "'";
       Values += getOpenMPSimpleClauseTypeName(OMPC_default, i);
       Values += "'";
       switch (i) {
-      case OMPC_DEFAULT_unknown - 2:
+      case NUM_OPENMP_DEFAULT_KINDS - 2:
         Values += " or ";
         break;
-      case OMPC_DEFAULT_unknown - 1:
+      case NUM_OPENMP_DEFAULT_KINDS - 1:
         break;
       default:
         Values += Sep;
         break;
       }
     }
-    Diag(KindKwLoc, diag::err_omp_unexpected_clause_value)
+    Diag(KindLoc, diag::err_omp_unexpected_clause_value)
         << Values << getOpenMPClauseName(OMPC_default);
-    return nullptr;
+    return 0;
   }
   switch (Kind) {
   case OMPC_DEFAULT_none:
-    DSAStack->setDefaultDSANone(KindKwLoc);
+    DSAStack->setDefaultDSANone();
     break;
   case OMPC_DEFAULT_shared:
-    DSAStack->setDefaultDSAShared(KindKwLoc);
+    DSAStack->setDefaultDSAShared();
     break;
-  case OMPC_DEFAULT_unknown:
-    llvm_unreachable("Clause kind is not allowed.");
+  default:
     break;
   }
-  return new (Context)
-      OMPDefaultClause(Kind, KindKwLoc, StartLoc, LParenLoc, EndLoc);
+  return new (Context) OMPDefaultClause(Kind, KindLoc, StartLoc, EndLoc);
 }
 
 OMPClause *Sema::ActOnOpenMPProcBindClause(OpenMPProcBindClauseKind Kind,
-                                           SourceLocation KindKwLoc,
+                                           SourceLocation KindLoc,
                                            SourceLocation StartLoc,
-                                           SourceLocation LParenLoc,
                                            SourceLocation EndLoc) {
   if (Kind == OMPC_PROC_BIND_unknown) {
     std::string Values;
-    std::string Sep(", ");
-    for (unsigned i = 0; i < OMPC_PROC_BIND_unknown; ++i) {
+    std::string Sep(NUM_OPENMP_PROC_BIND_KINDS > 1 ? ", " : "");
+    for (unsigned i = OMPC_PROC_BIND_unknown + 1;
+         i < NUM_OPENMP_PROC_BIND_KINDS; ++i) {
       Values += "'";
       Values += getOpenMPSimpleClauseTypeName(OMPC_proc_bind, i);
       Values += "'";
       switch (i) {
-      case OMPC_PROC_BIND_unknown - 2:
-        Values += " or ";
-        break;
-      case OMPC_PROC_BIND_unknown - 1:
-        break;
-      default:
-        Values += Sep;
-        break;
-      }
-    }
-    Diag(KindKwLoc, diag::err_omp_unexpected_clause_value)
-        << Values << getOpenMPClauseName(OMPC_proc_bind);
-    return nullptr;
-  }
-  return new (Context)
-      OMPProcBindClause(Kind, KindKwLoc, StartLoc, LParenLoc, EndLoc);
-}
-
-OMPClause *Sema::ActOnOpenMPSingleExprWithArgClause(
-    OpenMPClauseKind Kind, unsigned Argument, Expr *Expr,
-    SourceLocation StartLoc, SourceLocation LParenLoc,
-    SourceLocation ArgumentLoc, SourceLocation CommaLoc,
-    SourceLocation EndLoc) {
-  OMPClause *Res = nullptr;
-  switch (Kind) {
-  case OMPC_schedule:
-    Res = ActOnOpenMPScheduleClause(
-        static_cast<OpenMPScheduleClauseKind>(Argument), Expr, StartLoc,
-        LParenLoc, ArgumentLoc, CommaLoc, EndLoc);
-    break;
-  case OMPC_if:
-  case OMPC_final:
-  case OMPC_num_threads:
-  case OMPC_safelen:
-  case OMPC_collapse:
-  case OMPC_default:
-  case OMPC_proc_bind:
-  case OMPC_private:
-  case OMPC_firstprivate:
-  case OMPC_lastprivate:
-  case OMPC_shared:
-  case OMPC_reduction:
-  case OMPC_linear:
-  case OMPC_aligned:
-  case OMPC_copyin:
-  case OMPC_copyprivate:
-  case OMPC_ordered:
-  case OMPC_nowait:
-  case OMPC_untied:
-  case OMPC_mergeable:
-  case OMPC_threadprivate:
-  case OMPC_flush:
-  case OMPC_unknown:
-    llvm_unreachable("Clause is not allowed.");
-  }
-  return Res;
-}
-
-OMPClause *Sema::ActOnOpenMPScheduleClause(
-    OpenMPScheduleClauseKind Kind, Expr *ChunkSize, SourceLocation StartLoc,
-    SourceLocation LParenLoc, SourceLocation KindLoc, SourceLocation CommaLoc,
-    SourceLocation EndLoc) {
-  if (Kind == OMPC_SCHEDULE_unknown) {
-    std::string Values;
-    std::string Sep(", ");
-    for (unsigned i = 0; i < OMPC_SCHEDULE_unknown; ++i) {
-      Values += "'";
-      Values += getOpenMPSimpleClauseTypeName(OMPC_schedule, i);
-      Values += "'";
-      switch (i) {
-      case OMPC_SCHEDULE_unknown - 2:
+      case NUM_OPENMP_PROC_BIND_KINDS - 2:
         Values += " or ";
         break;
-      case OMPC_SCHEDULE_unknown - 1:
+      case NUM_OPENMP_PROC_BIND_KINDS - 1:
         break;
       default:
         Values += Sep;
@@ -2650,43 +4729,16 @@
       }
     }
     Diag(KindLoc, diag::err_omp_unexpected_clause_value)
-        << Values << getOpenMPClauseName(OMPC_schedule);
-    return nullptr;
-  }
-  Expr *ValExpr = ChunkSize;
-  if (ChunkSize) {
-    if (!ChunkSize->isValueDependent() && !ChunkSize->isTypeDependent() &&
-        !ChunkSize->isInstantiationDependent() &&
-        !ChunkSize->containsUnexpandedParameterPack()) {
-      SourceLocation ChunkSizeLoc = ChunkSize->getLocStart();
-      ExprResult Val =
-          PerformOpenMPImplicitIntegerConversion(ChunkSizeLoc, ChunkSize);
-      if (Val.isInvalid())
-        return nullptr;
-
-      ValExpr = Val.get();
-
-      // OpenMP [2.7.1, Restrictions]
-      //  chunk_size must be a loop invariant integer expression with a positive
-      //  value.
-      llvm::APSInt Result;
-      if (ValExpr->isIntegerConstantExpr(Result, Context) &&
-          Result.isSigned() && !Result.isStrictlyPositive()) {
-        Diag(ChunkSizeLoc, diag::err_omp_negative_expression_in_clause)
-            << "schedule" << ChunkSize->getSourceRange();
-        return nullptr;
-      }
-    }
+        << Values << getOpenMPClauseName(OMPC_proc_bind);
+    return 0;
   }
-
-  return new (Context) OMPScheduleClause(StartLoc, LParenLoc, KindLoc, CommaLoc,
-                                         EndLoc, Kind, ValExpr);
+  return new (Context) OMPProcBindClause(Kind, KindLoc, StartLoc, EndLoc);
 }
 
 OMPClause *Sema::ActOnOpenMPClause(OpenMPClauseKind Kind,
                                    SourceLocation StartLoc,
                                    SourceLocation EndLoc) {
-  OMPClause *Res = nullptr;
+  OMPClause *Res = 0;
   switch (Kind) {
   case OMPC_ordered:
     Res = ActOnOpenMPOrderedClause(StartLoc, EndLoc);
@@ -2700,38 +4752,42 @@
   case OMPC_mergeable:
     Res = ActOnOpenMPMergeableClause(StartLoc, EndLoc);
     break;
-  case OMPC_if:
-  case OMPC_final:
-  case OMPC_num_threads:
-  case OMPC_safelen:
-  case OMPC_collapse:
-  case OMPC_schedule:
-  case OMPC_private:
-  case OMPC_firstprivate:
-  case OMPC_lastprivate:
-  case OMPC_shared:
-  case OMPC_reduction:
-  case OMPC_linear:
-  case OMPC_aligned:
-  case OMPC_copyin:
-  case OMPC_copyprivate:
-  case OMPC_default:
-  case OMPC_proc_bind:
-  case OMPC_threadprivate:
-  case OMPC_flush:
-  case OMPC_unknown:
-    llvm_unreachable("Clause is not allowed.");
+  case OMPC_read:
+    Res = ActOnOpenMPReadClause(StartLoc, EndLoc);
+    break;
+  case OMPC_write:
+    Res = ActOnOpenMPWriteClause(StartLoc, EndLoc);
+    break;
+  case OMPC_update:
+    Res = ActOnOpenMPUpdateClause(StartLoc, EndLoc);
+    break;
+  case OMPC_capture:
+    Res = ActOnOpenMPCaptureClause(StartLoc, EndLoc);
+    break;
+  case OMPC_seq_cst:
+    Res = ActOnOpenMPSeqCstClause(StartLoc, EndLoc);
+    break;
+  case OMPC_inbranch:
+    Res = ActOnOpenMPInBranchClause(StartLoc, EndLoc);
+    break;
+  case OMPC_notinbranch:
+    Res = ActOnOpenMPNotInBranchClause(StartLoc, EndLoc);
+    break;
+  default:
+    break;
   }
   return Res;
 }
 
 OMPClause *Sema::ActOnOpenMPOrderedClause(SourceLocation StartLoc,
                                           SourceLocation EndLoc) {
+  DSAStack->setRegionOrdered();
   return new (Context) OMPOrderedClause(StartLoc, EndLoc);
 }
 
 OMPClause *Sema::ActOnOpenMPNowaitClause(SourceLocation StartLoc,
                                          SourceLocation EndLoc) {
+  DSAStack->setRegionNowait();
   return new (Context) OMPNowaitClause(StartLoc, EndLoc);
 }
 
@@ -2745,87 +4801,478 @@
   return new (Context) OMPMergeableClause(StartLoc, EndLoc);
 }
 
-OMPClause *Sema::ActOnOpenMPVarListClause(
-    OpenMPClauseKind Kind, ArrayRef<Expr *> VarList, Expr *TailExpr,
-    SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation ColonLoc,
-    SourceLocation EndLoc, CXXScopeSpec &ReductionIdScopeSpec,
-    const DeclarationNameInfo &ReductionId) {
-  OMPClause *Res = nullptr;
+OMPClause *Sema::ActOnOpenMPSingleExprWithTypeClause(
+    OpenMPClauseKind Kind, unsigned Argument, SourceLocation ArgumentLoc,
+    Expr *Expr, SourceLocation StartLoc, SourceLocation EndLoc) {
+  OMPClause *Res = 0;
   switch (Kind) {
-  case OMPC_private:
-    Res = ActOnOpenMPPrivateClause(VarList, StartLoc, LParenLoc, EndLoc);
-    break;
-  case OMPC_firstprivate:
-    Res = ActOnOpenMPFirstprivateClause(VarList, StartLoc, LParenLoc, EndLoc);
-    break;
-  case OMPC_lastprivate:
-    Res = ActOnOpenMPLastprivateClause(VarList, StartLoc, LParenLoc, EndLoc);
-    break;
-  case OMPC_shared:
-    Res = ActOnOpenMPSharedClause(VarList, StartLoc, LParenLoc, EndLoc);
-    break;
-  case OMPC_reduction:
-    Res = ActOnOpenMPReductionClause(VarList, StartLoc, LParenLoc, ColonLoc,
-                                     EndLoc, ReductionIdScopeSpec, ReductionId);
-    break;
-  case OMPC_linear:
-    Res = ActOnOpenMPLinearClause(VarList, TailExpr, StartLoc, LParenLoc,
-                                  ColonLoc, EndLoc);
-    break;
-  case OMPC_aligned:
-    Res = ActOnOpenMPAlignedClause(VarList, TailExpr, StartLoc, LParenLoc,
-                                   ColonLoc, EndLoc);
-    break;
-  case OMPC_copyin:
-    Res = ActOnOpenMPCopyinClause(VarList, StartLoc, LParenLoc, EndLoc);
+  case OMPC_schedule:
+    Res = ActOnOpenMPScheduleClause(
+        static_cast<OpenMPScheduleClauseKind>(Argument), ArgumentLoc, Expr,
+        StartLoc, EndLoc);
     break;
-  case OMPC_copyprivate:
-    Res = ActOnOpenMPCopyprivateClause(VarList, StartLoc, LParenLoc, EndLoc);
+  case OMPC_dist_schedule:
+    Res = ActOnOpenMPDistScheduleClause(
+        static_cast<OpenMPDistScheduleClauseKind>(Argument), ArgumentLoc, Expr,
+        StartLoc, EndLoc);
     break;
-  case OMPC_flush:
-    Res = ActOnOpenMPFlushClause(VarList, StartLoc, LParenLoc, EndLoc);
+  default:
+    break;
+  }
+  return Res;
+}
+
+OMPClause *Sema::ActOnOpenMPScheduleClause(OpenMPScheduleClauseKind Kind,
+                                           SourceLocation KindLoc,
+                                           Expr *ChunkSize,
+                                           SourceLocation StartLoc,
+                                           SourceLocation EndLoc) {
+  class CConvertDiagnoser : public ICEConvertDiagnoser {
+  public:
+    CConvertDiagnoser() : ICEConvertDiagnoser(true, false, true) {}
+    virtual SemaDiagnosticBuilder diagnoseNotInt(Sema &S, SourceLocation Loc,
+                                                 QualType T) {
+      return S.Diag(Loc, diag::err_typecheck_statement_requires_integer) << T;
+    }
+    virtual SemaDiagnosticBuilder
+    diagnoseIncomplete(Sema &S, SourceLocation Loc, QualType T) {
+      return S.Diag(Loc, diag::err_incomplete_class_type) << T;
+    }
+    virtual SemaDiagnosticBuilder diagnoseExplicitConv(Sema &S,
+                                                       SourceLocation Loc,
+                                                       QualType T,
+                                                       QualType ConvTy) {
+      return S.Diag(Loc, diag::err_explicit_conversion) << T << ConvTy;
+    }
+
+    virtual SemaDiagnosticBuilder
+    noteExplicitConv(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) {
+      return S.Diag(Conv->getLocation(), diag::note_conversion)
+             << ConvTy->isEnumeralType() << ConvTy;
+    }
+    virtual SemaDiagnosticBuilder diagnoseAmbiguous(Sema &S, SourceLocation Loc,
+                                                    QualType T) {
+      return S.Diag(Loc, diag::err_multiple_conversions) << T;
+    }
+
+    virtual SemaDiagnosticBuilder
+    noteAmbiguous(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) {
+      return S.Diag(Conv->getLocation(), diag::note_conversion)
+             << ConvTy->isEnumeralType() << ConvTy;
+    }
+
+    virtual SemaDiagnosticBuilder diagnoseConversion(Sema &S,
+                                                     SourceLocation Loc,
+                                                     QualType T,
+                                                     QualType ConvTy) {
+      llvm_unreachable("conversion functions are permitted");
+    }
+  } ConvertDiagnoser;
+
+  if (Kind == OMPC_SCHEDULE_unknown) {
+    std::string Values;
+    std::string Sep(NUM_OPENMP_SCHEDULE_KINDS > 1 ? ", " : "");
+    for (int i = OMPC_SCHEDULE_unknown + 1; i < NUM_OPENMP_SCHEDULE_KINDS;
+         ++i) {
+      Values += "'";
+      Values += getOpenMPSimpleClauseTypeName(OMPC_schedule, i);
+      Values += "'";
+      switch (i) {
+      case NUM_OPENMP_SCHEDULE_KINDS - 2:
+        Values += " or ";
+        break;
+      case NUM_OPENMP_SCHEDULE_KINDS - 1:
+        break;
+      default:
+        Values += Sep;
+        break;
+      }
+    }
+    Diag(KindLoc, diag::err_omp_unexpected_clause_value)
+        << Values << getOpenMPClauseName(OMPC_schedule);
+    return 0;
+  }
+  ExprResult Value;
+  if (ChunkSize) {
+    if (!ChunkSize->isTypeDependent() && !ChunkSize->isValueDependent() &&
+        !ChunkSize->isInstantiationDependent()) {
+      SourceLocation Loc = ChunkSize->getExprLoc();
+      Value =
+          PerformContextualImplicitConversion(Loc, ChunkSize, ConvertDiagnoser);
+      if (Value.isInvalid())
+        return 0;
+
+      llvm::APSInt Result;
+      if (Value.get()->isIntegerConstantExpr(Result, Context) &&
+          !Result.isStrictlyPositive()) {
+        Diag(Loc, diag::err_negative_expression_in_clause)
+            << ChunkSize->getSourceRange();
+        return 0;
+      }
+    }
+  } else {
+    // OpenMP [2.5.1, Loop Construct, Description, Table 2-1]
+    //  dynamic       When no chunk_size is specified, it defaults to 1.
+    //  guided        When no chunk_size is specified, it defaults to 1.
+    switch (Kind) {
+    case OMPC_SCHEDULE_dynamic:
+    case OMPC_SCHEDULE_guided:
+      Value = ActOnIntegerConstant(StartLoc, 1);
+      break;
+    default:
+      break;
+    }
+  }
+  Expr *ValExpr = Value.get();
+
+  return new (Context)
+      OMPScheduleClause(Kind, KindLoc, ValExpr, StartLoc, EndLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPDistScheduleClause(
+    OpenMPDistScheduleClauseKind Kind, SourceLocation KindLoc, Expr *ChunkSize,
+    SourceLocation StartLoc, SourceLocation EndLoc) {
+  class CConvertDiagnoser : public ICEConvertDiagnoser {
+  public:
+    CConvertDiagnoser() : ICEConvertDiagnoser(true, false, true) {}
+    virtual SemaDiagnosticBuilder diagnoseNotInt(Sema &S, SourceLocation Loc,
+                                                 QualType T) {
+      return S.Diag(Loc, diag::err_typecheck_statement_requires_integer) << T;
+    }
+    virtual SemaDiagnosticBuilder
+    diagnoseIncomplete(Sema &S, SourceLocation Loc, QualType T) {
+      return S.Diag(Loc, diag::err_incomplete_class_type) << T;
+    }
+    virtual SemaDiagnosticBuilder diagnoseExplicitConv(Sema &S,
+                                                       SourceLocation Loc,
+                                                       QualType T,
+                                                       QualType ConvTy) {
+      return S.Diag(Loc, diag::err_explicit_conversion) << T << ConvTy;
+    }
+
+    virtual SemaDiagnosticBuilder
+    noteExplicitConv(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) {
+      return S.Diag(Conv->getLocation(), diag::note_conversion)
+             << ConvTy->isEnumeralType() << ConvTy;
+    }
+    virtual SemaDiagnosticBuilder diagnoseAmbiguous(Sema &S, SourceLocation Loc,
+                                                    QualType T) {
+      return S.Diag(Loc, diag::err_multiple_conversions) << T;
+    }
+
+    virtual SemaDiagnosticBuilder
+    noteAmbiguous(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) {
+      return S.Diag(Conv->getLocation(), diag::note_conversion)
+             << ConvTy->isEnumeralType() << ConvTy;
+    }
+
+    virtual SemaDiagnosticBuilder diagnoseConversion(Sema &S,
+                                                     SourceLocation Loc,
+                                                     QualType T,
+                                                     QualType ConvTy) {
+      llvm_unreachable("conversion functions are permitted");
+    }
+  } ConvertDiagnoser;
+
+  if (Kind != OMPC_DIST_SCHEDULE_static) {
+    std::string Values = "'";
+    Values += getOpenMPSimpleClauseTypeName(OMPC_dist_schedule,
+                                            OMPC_DIST_SCHEDULE_static);
+    Values += "'";
+    Diag(KindLoc, diag::err_omp_unexpected_clause_value)
+        << Values << getOpenMPClauseName(OMPC_dist_schedule);
+    return 0;
+  }
+  ExprResult Value;
+  if (ChunkSize) {
+    if (!ChunkSize->isTypeDependent() && !ChunkSize->isValueDependent() &&
+        !ChunkSize->isInstantiationDependent()) {
+      SourceLocation Loc = ChunkSize->getExprLoc();
+      Value =
+          PerformContextualImplicitConversion(Loc, ChunkSize, ConvertDiagnoser);
+      if (Value.isInvalid())
+        return 0;
+
+      llvm::APSInt Result;
+      if (Value.get()->isIntegerConstantExpr(Result, Context) &&
+          !Result.isStrictlyPositive()) {
+        Diag(Loc, diag::err_negative_expression_in_clause)
+            << ChunkSize->getSourceRange();
+        return 0;
+      }
+    }
+  } else {
+    Value = ExprEmpty();
+  }
+  Expr *ValExpr = Value.get();
+
+  return new (Context)
+      OMPDistScheduleClause(Kind, KindLoc, ValExpr, StartLoc, EndLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPVarListClause(
+    OpenMPClauseKind Kind, ArrayRef<Expr *> VarList, SourceLocation StartLoc,
+    SourceLocation EndLoc, unsigned Op, Expr *TailExpr, CXXScopeSpec &SS,
+    const UnqualifiedId &OpName, SourceLocation OpLoc) {
+  OMPClause *Res = 0;
+  switch (Kind) {
+  case OMPC_private:
+    Res = ActOnOpenMPPrivateClause(VarList, StartLoc, EndLoc);
+    break;
+  case OMPC_lastprivate:
+    Res = ActOnOpenMPLastPrivateClause(VarList, StartLoc, EndLoc);
+    break;
+  case OMPC_firstprivate:
+    Res = ActOnOpenMPFirstPrivateClause(VarList, StartLoc, EndLoc);
+    break;
+  case OMPC_shared:
+    Res = ActOnOpenMPSharedClause(VarList, StartLoc, EndLoc);
+    break;
+  case OMPC_copyin:
+    Res = ActOnOpenMPCopyinClause(VarList, StartLoc, EndLoc);
+    break;
+  case OMPC_copyprivate:
+    Res = ActOnOpenMPCopyPrivateClause(VarList, StartLoc, EndLoc);
+    break;
+  case OMPC_reduction:
+    Res = ActOnOpenMPReductionClause(
+        VarList, StartLoc, EndLoc,
+        static_cast<OpenMPReductionClauseOperator>(Op), SS,
+        GetNameFromUnqualifiedId(OpName));
+    break;
+  case OMPC_flush:
+    Res = ActOnOpenMPFlushClause(VarList, StartLoc, EndLoc);
+    break;
+  case OMPC_depend:
+    Res =
+        ActOnOpenMPDependClause(VarList, StartLoc, EndLoc,
+                                static_cast<OpenMPDependClauseType>(Op), OpLoc);
+    break;
+  case OMPC_uniform:
+    Res = ActOnOpenMPUniformClause(VarList, StartLoc, EndLoc);
+    break;
+  case OMPC_linear:
+    Res = ActOnOpenMPLinearClause(VarList, StartLoc, EndLoc, TailExpr, OpLoc);
+    break;
+  case OMPC_aligned:
+    Res = ActOnOpenMPAlignedClause(VarList, StartLoc, EndLoc, TailExpr, OpLoc);
+    break;
+  case OMPC_map:
+    Res = ActOnOpenMPMapClause(VarList, StartLoc, EndLoc,
+                               static_cast<OpenMPMapClauseKind>(Op), OpLoc);
+    break;
+  case OMPC_to:
+    Res = ActOnOpenMPToClause(VarList, StartLoc, EndLoc);
+    break;
+  case OMPC_from:
+    Res = ActOnOpenMPFromClause(VarList, StartLoc, EndLoc);
+    break;
+  default:
     break;
-  case OMPC_if:
-  case OMPC_final:
-  case OMPC_num_threads:
-  case OMPC_safelen:
-  case OMPC_collapse:
-  case OMPC_default:
-  case OMPC_proc_bind:
-  case OMPC_schedule:
-  case OMPC_ordered:
-  case OMPC_nowait:
-  case OMPC_untied:
-  case OMPC_mergeable:
-  case OMPC_threadprivate:
-  case OMPC_unknown:
-    llvm_unreachable("Clause is not allowed.");
   }
   return Res;
 }
 
+Expr *Sema::ActOnOpenMPParameterInDeclarativeVarListClause(SourceLocation Loc,
+                                                           ParmVarDecl *Param) {
+  QualType ExprType = Param->getType().getNonReferenceType();
+  DeclContext *SavedCurContext = CurContext;
+  CurContext = Param->getDeclContext();
+  ExprResult DE = BuildDeclRefExpr(Param, ExprType, VK_RValue, Loc);
+  CurContext = SavedCurContext;
+  return DE.get();
+}
+
+Expr *Sema::FindOpenMPDeclarativeClauseParameter(StringRef Name,
+                                                 SourceLocation Loc,
+                                                 Decl *FuncDecl) {
+  FunctionDecl *FDecl = dyn_cast<FunctionDecl>(FuncDecl);
+  FunctionTemplateDecl *FTDecl = dyn_cast<FunctionTemplateDecl>(FuncDecl);
+  if (FTDecl) {
+    FDecl = FTDecl->getTemplatedDecl();
+  }
+  if (!FDecl)
+    return 0;
+  for (FunctionDecl::param_iterator PI = FDecl->param_begin(),
+                                    PE = FDecl->param_end();
+       PI != PE; ++PI) {
+    ParmVarDecl *Param = *PI;
+    if (Name == Param->getName()) {
+      Expr *E = ActOnOpenMPParameterInDeclarativeVarListClause(Loc, Param);
+      if (E) {
+        return E;
+      }
+    }
+  }
+  return 0;
+}
+
+OMPClause *Sema::ActOnOpenMPDeclarativeVarListClause(
+    OpenMPClauseKind CKind, ArrayRef<DeclarationNameInfo> NameInfos,
+    SourceLocation StartLoc, SourceLocation EndLoc, Expr *TailExpr,
+    SourceLocation TailLoc, Decl *FuncDecl) {
+  // Vars for the clause.
+  SmallVector<Expr *, 4> Vars;
+  if (FuncDecl) {
+    // Find each var among the function parameters.
+    for (unsigned J = 0; J < NameInfos.size(); ++J) {
+      Expr *Param = FindOpenMPDeclarativeClauseParameter(
+          NameInfos[J].getName().getAsString(), NameInfos[J].getLoc(),
+          FuncDecl);
+      if (!Param) {
+        Diag(NameInfos[J].getLoc(), diag::err_omp_arg_not_found);
+      } else {
+        Vars.push_back(Param);
+      }
+    }
+  }
+
+  switch (CKind) {
+  case OMPC_linear:
+    return ActOnOpenMPDeclarativeLinearClause(Vars, StartLoc, EndLoc, TailExpr,
+                                              TailLoc);
+  case OMPC_aligned:
+    return ActOnOpenMPDeclarativeAlignedClause(Vars, StartLoc, EndLoc, TailExpr,
+                                               TailLoc);
+  case OMPC_uniform:
+    return ActOnOpenMPDeclarativeUniformClause(Vars, StartLoc, EndLoc);
+  default:
+    assert(0 && "bad clause kind for a declarative clause");
+  }
+  return 0;
+}
+
+OMPClause *Sema::ActOnOpenMPDeclarativeLinearClause(ArrayRef<Expr *> VarList,
+                                                    SourceLocation StartLoc,
+                                                    SourceLocation EndLoc,
+                                                    Expr *Step,
+                                                    SourceLocation StepLoc) {
+  if (VarList.empty())
+    return 0;
+  // OpenMP [2.8.2 declare simd Construct, Restrictions]
+  // When a constant-linear-step expression is specified in a linear clause
+  // it must be a constant positive integer expression
+  if (Step) {
+    Step = ActOnConstantPositiveSubExpressionInClause(Step);
+    if (!Step)
+      return 0;
+  }
+
+  // Check the vars.
+  SmallVector<Expr *, 4> Vars;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+
+    assert(*I && "Null expr in omp linear");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
+      // It will be analyzed later.
+      Vars.push_back(*I);
+      continue;
+    }
+    SourceLocation ELoc = (*I)->getExprLoc();
+    //  A list-item that appears in a linear clause must be of integral
+    //   or pointer type.
+    //
+    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(*I);
+    QualType QTy = DE->getType().getUnqualifiedType().getCanonicalType();
+    const Type *Ty = QTy.getTypePtrOrNull();
+    if (!Ty || (!Ty->isDependentType() && !Ty->isIntegerType() &&
+                !Ty->isPointerType())) {
+      Diag(ELoc, diag::err_omp_expected_int_or_ptr) << (*I)->getSourceRange();
+      continue;
+    }
+
+    Vars.push_back(DE);
+  }
+
+  if (Vars.empty())
+    return 0;
+
+  return OMPLinearClause::Create(Context, StartLoc, EndLoc, VarList, Step,
+                                 StepLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPDeclarativeAlignedClause(
+    ArrayRef<Expr *> VarList, SourceLocation StartLoc, SourceLocation EndLoc,
+    Expr *Alignment, SourceLocation AlignmentLoc) {
+  SmallVector<Expr *, 4> Vars;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+
+    assert(*I && "Null expr in omp aligned");
+    if (*I && isa<DependentScopeDeclRefExpr>(*I)) {
+      // It will be analyzed later.
+      Vars.push_back(*I);
+      continue;
+    }
+
+    SourceLocation ELoc = (*I)->getExprLoc();
+    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(*I);
+
+    // OpenMP  [2.8.2, declare simd construct, Restrictions]
+    // The type of list items appearing in the aligned clause must be
+    // array, pointer, reference to array, or reference to pointer.
+    QualType QTy = DE->getType()
+                       .getNonReferenceType()
+                       .getUnqualifiedType()
+                       .getCanonicalType();
+    const Type *Ty = QTy.getTypePtrOrNull();
+    if (!Ty || (!Ty->isDependentType() && !Ty->isArrayType() &&
+                !Ty->isPointerType())) {
+      Diag(ELoc, diag::err_omp_expected_array_or_ptr) << (*I)->getSourceRange();
+      continue;
+    }
+
+    Vars.push_back(DE);
+  }
+
+  if (Vars.empty())
+    return 0;
+
+  // OpenMP [2.8.2 declare simd Construct]
+  // The optional parameter of the aligned clause, alignment, must be
+  // a constant positive integer expression.
+  if (Alignment) {
+    Alignment = ActOnConstantPositiveSubExpressionInClause(Alignment);
+    if (!Alignment)
+      return 0;
+  }
+  return OMPAlignedClause::Create(Context, StartLoc, EndLoc, VarList, Alignment,
+                                  AlignmentLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPDeclarativeUniformClause(ArrayRef<Expr *> VarList,
+                                                     SourceLocation StartLoc,
+                                                     SourceLocation EndLoc) {
+  if (VarList.empty())
+    return 0;
+  return OMPUniformClause::Create(Context, StartLoc, EndLoc, VarList);
+}
+
 OMPClause *Sema::ActOnOpenMPPrivateClause(ArrayRef<Expr *> VarList,
                                           SourceLocation StartLoc,
-                                          SourceLocation LParenLoc,
                                           SourceLocation EndLoc) {
-  SmallVector<Expr *, 8> Vars;
-  for (auto &RefExpr : VarList) {
-    assert(RefExpr && "NULL expr in OpenMP private clause.");
-    if (isa<DependentScopeDeclRefExpr>(RefExpr)) {
+  SmallVector<Expr *, 4> Vars;
+  SmallVector<Expr *, 4> DefaultInits;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    assert(*I && "Null expr in omp private");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
       // It will be analyzed later.
-      Vars.push_back(RefExpr);
+      Vars.push_back(*I);
+      DefaultInits.push_back(0);
       continue;
     }
 
-    SourceLocation ELoc = RefExpr->getExprLoc();
+    SourceLocation ELoc = (*I)->getExprLoc();
     // OpenMP [2.1, C/C++]
     //  A list item is a variable name.
     // OpenMP  [2.9.3.3, Restrictions, p.1]
     //  A variable that is part of another variable (as an array or
     //  structure element) cannot appear in a private clause.
-    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(RefExpr);
+    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(*I);
     if (!DE || !isa<VarDecl>(DE->getDecl())) {
-      Diag(ELoc, diag::err_omp_expected_var_name) << RefExpr->getSourceRange();
+      Diag(ELoc, diag::err_omp_expected_var_name) << (*I)->getSourceRange();
       continue;
     }
     Decl *D = DE->getDecl();
@@ -2834,7 +5281,8 @@
     QualType Type = VD->getType();
     if (Type->isDependentType() || Type->isInstantiationDependentType()) {
       // It will be analyzed later.
-      Vars.push_back(DE);
+      Vars.push_back(*I);
+      DefaultInits.push_back(0);
       continue;
     }
 
@@ -2847,7 +5295,7 @@
     }
     if (Type->isReferenceType()) {
       Diag(ELoc, diag::err_omp_clause_ref_type_arg)
-          << getOpenMPClauseName(OMPC_private) << Type;
+          << getOpenMPClauseName(OMPC_private);
       bool IsDecl =
           VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
       Diag(VD->getLocation(),
@@ -2856,19 +5304,39 @@
       continue;
     }
 
+    // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
+    // in a Construct]
+    //  Variables with the predetermined data-sharing attributes may not be
+    //  listed in data-sharing attributes clauses, except for the cases
+    //  listed below. For these exceptions only, listing a predetermined
+    //  variable in a data-sharing attribute clause is allowed and overrides
+    //  the variable's predetermined data-sharing attributes.
+    DeclRefExpr *PrevRef;
+    OpenMPClauseKind Kind = DSAStack->getTopDSA(VD, PrevRef);
+    if (Kind != OMPC_unknown && Kind != OMPC_private) {
+      Diag(ELoc, diag::err_omp_wrong_dsa) << getOpenMPClauseName(Kind)
+                                          << getOpenMPClauseName(OMPC_private);
+      if (PrevRef) {
+        Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+            << getOpenMPClauseName(Kind);
+      } else {
+        Diag(VD->getLocation(), diag::note_omp_predetermined_dsa)
+            << getOpenMPClauseName(Kind);
+      }
+      continue;
+    }
+
     // OpenMP [2.9.3.3, Restrictions, C/C++, p.1]
     //  A variable of class type (or array thereof) that appears in a private
-    //  clause requires an accessible, unambiguous default constructor for the
+    //  clause requires an accesible, unambiguous default constructor for the
     //  class type.
-    while (Type.getNonReferenceType()->isArrayType()) {
-      Type = cast<ArrayType>(Type.getNonReferenceType().getTypePtr())
-                 ->getElementType();
-    }
-    CXXRecordDecl *RD = getLangOpts().CPlusPlus
-                            ? Type.getNonReferenceType()->getAsCXXRecordDecl()
-                            : nullptr;
-    // FIXME This code must be replaced by actual constructing/destructing of
-    // the private variable.
+    Type = Type.getNonReferenceType().getCanonicalType();
+    while (Type->isArrayType()) {
+      QualType ElemType = cast<ArrayType>(Type.getTypePtr())->getElementType();
+      Type = ElemType.getNonReferenceType().getCanonicalType();
+    }
+    CXXRecordDecl *RD =
+        getLangOpts().CPlusPlus ? Type->getAsCXXRecordDecl() : 0;
     if (RD) {
       CXXConstructorDecl *CD = LookupDefaultConstructor(RD);
       PartialDiagnostic PD =
@@ -2892,76 +5360,74 @@
       DiagnoseUseOfDecl(CD, ELoc);
 
       CXXDestructorDecl *DD = RD->getDestructor();
-      if (DD) {
-        if (CheckDestructorAccess(ELoc, DD, PD) == AR_inaccessible ||
-            DD->isDeleted()) {
-          Diag(ELoc, diag::err_omp_required_method)
-              << getOpenMPClauseName(OMPC_private) << 4;
-          bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
-                        VarDecl::DeclarationOnly;
-          Diag(VD->getLocation(),
-               IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-              << VD;
-          Diag(RD->getLocation(), diag::note_previous_decl) << RD;
-          continue;
-        }
+      if (DD && (CheckDestructorAccess(ELoc, DD, PD) == AR_inaccessible ||
+                 DD->isDeleted())) {
+        Diag(ELoc, diag::err_omp_required_method)
+            << getOpenMPClauseName(OMPC_private) << 4;
+        bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
+                      VarDecl::DeclarationOnly;
+        Diag(VD->getLocation(),
+             IsDecl ? diag::note_previous_decl : diag::note_defined_here)
+            << VD;
+        Diag(RD->getLocation(), diag::note_previous_decl) << RD;
+        continue;
+      } else if (DD) {
         MarkFunctionReferenced(ELoc, DD);
         DiagnoseUseOfDecl(DD, ELoc);
       }
     }
-
-    // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
-    // in a Construct]
-    //  Variables with the predetermined data-sharing attributes may not be
-    //  listed in data-sharing attributes clauses, except for the cases
-    //  listed below. For these exceptions only, listing a predetermined
-    //  variable in a data-sharing attribute clause is allowed and overrides
-    //  the variable's predetermined data-sharing attributes.
-    DSAStackTy::DSAVarData DVar = DSAStack->getTopDSA(VD, false);
-    if (DVar.CKind != OMPC_unknown && DVar.CKind != OMPC_private) {
-      Diag(ELoc, diag::err_omp_wrong_dsa) << getOpenMPClauseName(DVar.CKind)
-                                          << getOpenMPClauseName(OMPC_private);
-      ReportOriginalDSA(*this, DSAStack, VD, DVar);
+    Type = Type.getUnqualifiedType();
+    IdentifierInfo *Id = &Context.Idents.get(".private.");
+    TypeSourceInfo *TI = Context.getTrivialTypeSourceInfo(Type, ELoc);
+    VarDecl *PseudoVar = VarDecl::Create(
+        Context, Context.getTranslationUnitDecl(), SourceLocation(),
+        SourceLocation(), Id, Type, TI, SC_Static);
+    PseudoVar->setImplicit();
+    PseudoVar->addAttr(new (Context) UnusedAttr(SourceLocation(), Context, 0));
+    InitializedEntity Entity = InitializedEntity::InitializeVariable(PseudoVar);
+    InitializationKind InitKind = InitializationKind::CreateDefault(ELoc);
+    InitializationSequence InitSeq(*this, Entity, InitKind, MultiExprArg());
+    ExprResult Res = InitSeq.Perform(*this, Entity, InitKind, MultiExprArg());
+    if (Res.isInvalid())
       continue;
-    }
-
+    DefaultInits.push_back(ActOnFinishFullExpr(Res.get()).get());
     DSAStack->addDSA(VD, DE, OMPC_private);
     Vars.push_back(DE);
   }
 
   if (Vars.empty())
-    return nullptr;
+    return 0;
 
-  return OMPPrivateClause::Create(Context, StartLoc, LParenLoc, EndLoc, Vars);
+  return OMPPrivateClause::Create(Context, StartLoc, EndLoc, Vars,
+                                  DefaultInits);
 }
 
-OMPClause *Sema::ActOnOpenMPFirstprivateClause(ArrayRef<Expr *> VarList,
+OMPClause *Sema::ActOnOpenMPFirstPrivateClause(ArrayRef<Expr *> VarList,
                                                SourceLocation StartLoc,
-                                               SourceLocation LParenLoc,
                                                SourceLocation EndLoc) {
-  SmallVector<Expr *, 8> Vars;
-  bool IsImplicitClause =
-      StartLoc.isInvalid() && LParenLoc.isInvalid() && EndLoc.isInvalid();
-  auto ImplicitClauseLoc = DSAStack->getConstructLoc();
-
-  for (auto &RefExpr : VarList) {
-    assert(RefExpr && "NULL expr in OpenMP firstprivate clause.");
-    if (isa<DependentScopeDeclRefExpr>(RefExpr)) {
+  SmallVector<Expr *, 4> Vars;
+  SmallVector<DeclRefExpr *, 4> PseudoVars;
+  SmallVector<Expr *, 4> Inits;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    assert(*I && "Null expr in omp firstprivate");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
       // It will be analyzed later.
-      Vars.push_back(RefExpr);
+      Vars.push_back(*I);
+      PseudoVars.push_back(0);
+      Inits.push_back(0);
       continue;
     }
 
-    SourceLocation ELoc = IsImplicitClause ? ImplicitClauseLoc
-                                           : RefExpr->getExprLoc();
+    SourceLocation ELoc = (*I)->getExprLoc();
     // OpenMP [2.1, C/C++]
     //  A list item is a variable name.
-    // OpenMP  [2.9.3.3, Restrictions, p.1]
+    // OpenMP  [2.9.3.4, Restrictions, p.1]
     //  A variable that is part of another variable (as an array or
     //  structure element) cannot appear in a private clause.
-    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(RefExpr);
+    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(*I);
     if (!DE || !isa<VarDecl>(DE->getDecl())) {
-      Diag(ELoc, diag::err_omp_expected_var_name) << RefExpr->getSourceRange();
+      Diag(ELoc, diag::err_omp_expected_var_name) << (*I)->getSourceRange();
       continue;
     }
     Decl *D = DE->getDecl();
@@ -2970,27 +5436,22 @@
     QualType Type = VD->getType();
     if (Type->isDependentType() || Type->isInstantiationDependentType()) {
       // It will be analyzed later.
-      Vars.push_back(DE);
+      Vars.push_back(*I);
+      PseudoVars.push_back(0);
+      Inits.push_back(0);
       continue;
     }
 
-    // OpenMP [2.9.3.3, Restrictions, C/C++, p.3]
-    //  A variable that appears in a private clause must not have an incomplete
-    //  type or a reference type.
+    // OpenMP [2.9.3.4, Restrictions, C/C++, p.2]
+    //  A variable that appears in a firstprivate clause must not have an
+    //  incomplete type or a reference type.
     if (RequireCompleteType(ELoc, Type,
                             diag::err_omp_firstprivate_incomplete_type)) {
       continue;
     }
     if (Type->isReferenceType()) {
-      if (IsImplicitClause) {
-        Diag(ImplicitClauseLoc,
-             diag::err_omp_task_predetermined_firstprivate_ref_type_arg)
-            << Type;
-        Diag(RefExpr->getExprLoc(), diag::note_used_here);
-      } else {
-        Diag(ELoc, diag::err_omp_clause_ref_type_arg)
-            << getOpenMPClauseName(OMPC_firstprivate) << Type;
-      }
+      Diag(ELoc, diag::err_omp_clause_ref_type_arg)
+          << getOpenMPClauseName(OMPC_firstprivate);
       bool IsDecl =
           VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
       Diag(VD->getLocation(),
@@ -2999,192 +5460,228 @@
       continue;
     }
 
-    // OpenMP [2.9.3.4, Restrictions, C/C++, p.1]
-    //  A variable of class type (or array thereof) that appears in a private
-    //  clause requires an accessible, unambiguous copy constructor for the
-    //  class type.
-    Type = Context.getBaseElementType(Type);
-    CXXRecordDecl *RD = getLangOpts().CPlusPlus
-                            ? Type.getNonReferenceType()->getAsCXXRecordDecl()
-                            : nullptr;
-    // FIXME This code must be replaced by actual constructing/destructing of
-    // the firstprivate variable.
-    if (RD) {
-      CXXConstructorDecl *CD = LookupCopyingConstructor(RD, 0);
-      PartialDiagnostic PD =
-          PartialDiagnostic(PartialDiagnostic::NullDiagnostic());
-      if (!CD ||
-          CheckConstructorAccess(ELoc, CD,
-                                 InitializedEntity::InitializeTemporary(Type),
-                                 CD->getAccess(), PD) == AR_inaccessible ||
-          CD->isDeleted()) {
-        if (IsImplicitClause) {
-          Diag(ImplicitClauseLoc,
-               diag::err_omp_task_predetermined_firstprivate_required_method)
-              << 0;
-          Diag(RefExpr->getExprLoc(), diag::note_used_here);
+    // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
+    // in a Construct]
+    //  Variables with the predetermined data-sharing attributes may not be
+    //  listed in data-sharing attributes clauses, except for the cases
+    //  listed below. For these exceptions only, listing a predetermined
+    //  variable in a data-sharing attribute clause is allowed and overrides
+    //  the variable's predetermined data-sharing attributes.
+    // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
+    // in a Construct, C/C++, p.2]
+    //  Variables with const-qualified type having no mutable member may be
+    //  listed in a firstprivate clause, even if they are static data members.
+    // OpenMP [2.9.3.4, Description]
+    //  If a list item appears in both firstprivate and lastprivate clauses,
+    //  the update requires for lastprivate occurs after all the initializations
+    //  for firstprivate.
+    DeclRefExpr *PrevRef;
+    OpenMPDirectiveKind CurrDir = DSAStack->getCurrentDirective();
+    OpenMPClauseKind Kind = DSAStack->getTopDSA(VD, PrevRef);
+    Type = Type.getNonReferenceType().getCanonicalType();
+    bool IsConstant = Type.isConstant(Context);
+    bool IsArray = Type->isArrayType();
+    while (Type->isArrayType()) {
+      QualType ElemType = cast<ArrayType>(Type.getTypePtr())->getElementType();
+      Type = ElemType.getNonReferenceType().getCanonicalType();
+    }
+    if (Kind != OMPC_unknown && Kind != OMPC_firstprivate &&
+        Kind != OMPC_lastprivate &&
+        !(Kind == OMPC_shared && !PrevRef &&
+          (IsConstant || VD->isStaticDataMember()))) {
+      if ((CurrDir != OMPD_task || PrevRef) && StartLoc.isValid() &&
+          EndLoc.isValid()) {
+        Diag(ELoc, diag::err_omp_wrong_dsa)
+            << getOpenMPClauseName(Kind)
+            << getOpenMPClauseName(OMPC_firstprivate);
+        if (PrevRef) {
+          Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+              << getOpenMPClauseName(Kind);
         } else {
-          Diag(ELoc, diag::err_omp_required_method)
-              << getOpenMPClauseName(OMPC_firstprivate) << 1;
+          Diag(VD->getLocation(), diag::note_omp_predetermined_dsa)
+              << getOpenMPClauseName(Kind);
         }
-        bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
-                      VarDecl::DeclarationOnly;
-        Diag(VD->getLocation(),
-             IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-            << VD;
-        Diag(RD->getLocation(), diag::note_previous_decl) << RD;
         continue;
       }
-      MarkFunctionReferenced(ELoc, CD);
-      DiagnoseUseOfDecl(CD, ELoc);
+    }
 
-      CXXDestructorDecl *DD = RD->getDestructor();
-      if (DD) {
-        if (CheckDestructorAccess(ELoc, DD, PD) == AR_inaccessible ||
-            DD->isDeleted()) {
-          if (IsImplicitClause) {
-            Diag(ImplicitClauseLoc,
-                 diag::err_omp_task_predetermined_firstprivate_required_method)
-                << 1;
-            Diag(RefExpr->getExprLoc(), diag::note_used_here);
-          } else {
-            Diag(ELoc, diag::err_omp_required_method)
-                << getOpenMPClauseName(OMPC_firstprivate) << 4;
+    // OpenMP [2.9.3.4, Restrictions, p.2]
+    //  A list item that is private within a parallel region must not appear in
+    //  a firstprivate clause on a worksharing construct if any of the
+    //  worksharing regions arising from the worksharing construct ever bind to
+    //  any of the parallel regions arising from the parallel construct.
+    // OpenMP [2.9.3.4, Restrictions, p.3]
+    //  A list item that appears in a reduction clause of a parallel construct
+    //  must not appear in a firstprivate clause on a worksharing or task
+    //  construct if any of the worksharing or task regions arising from the
+    //  worksharing or task construct ever bind to any of the parallel regions
+    //  arising from the parallel construct.
+    // OpenMP [2.9.3.4, Restrictions, p.4]
+    //  A list item that appears in a reduction clause in worksharing construct
+    //  must not appear in a firstprivate clause in a task construct encountered
+    //  during execution of any of the worksharing regions arising from the
+    //  worksharing construct.
+    OpenMPDirectiveKind DKind;
+    Kind = DSAStack->getImplicitDSA(VD, DKind, PrevRef);
+    if ((Kind != OMPC_shared &&
+         (CurrDir == OMPD_for || CurrDir == OMPD_sections ||
+          CurrDir == OMPD_for_simd || CurrDir == OMPD_distribute_simd ||
+          CurrDir == OMPD_single || CurrDir == OMPD_distribute)) ||
+        (CurrDir == OMPD_task &&
+         DSAStack->hasDSA(VD, OMPC_reduction, OMPD_parallel, PrevRef))) {
+      if (Kind == OMPC_unknown) {
+        Diag(ELoc, diag::err_omp_required_access)
+            << getOpenMPClauseName(OMPC_firstprivate)
+            << getOpenMPClauseName(OMPC_shared);
+        if (PrevRef) {
+          Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+              << getOpenMPClauseName(Kind);
+        }
+        continue;
+      } else if (DKind == OMPD_unknown) {
+        Diag(ELoc, diag::err_omp_wrong_dsa)
+            << getOpenMPClauseName(Kind)
+            << getOpenMPClauseName(OMPC_firstprivate);
+        if (PrevRef) {
+          Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+              << getOpenMPClauseName(Kind);
+        }
+        continue;
+      } else {
+        // Skip template instantiations for parallel for and parallel sections.
+        if (Kind != OMPC_firstprivate || DKind != OMPD_parallel ||
+            (CurrDir != OMPD_for && CurrDir != OMPD_sections) || !PrevRef ||
+            PrevRef->getExprLoc() != ELoc) {
+          Diag(ELoc, diag::err_omp_dsa_with_directives)
+              << getOpenMPClauseName(Kind) << getOpenMPDirectiveName(DKind)
+              << getOpenMPClauseName(OMPC_firstprivate)
+              << getOpenMPDirectiveName(CurrDir);
+          if (PrevRef) {
+            Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+                << getOpenMPClauseName(Kind);
           }
-          bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
-                        VarDecl::DeclarationOnly;
-          Diag(VD->getLocation(),
-               IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-              << VD;
-          Diag(RD->getLocation(), diag::note_previous_decl) << RD;
           continue;
         }
-        MarkFunctionReferenced(ELoc, DD);
-        DiagnoseUseOfDecl(DD, ELoc);
       }
     }
 
-    // If an implicit firstprivate variable found it was checked already.
-    if (!IsImplicitClause) {
-      DSAStackTy::DSAVarData DVar = DSAStack->getTopDSA(VD, false);
-      Type = Type.getNonReferenceType().getCanonicalType();
-      bool IsConstant = Type.isConstant(Context);
-      Type = Context.getBaseElementType(Type);
-      // OpenMP [2.4.13, Data-sharing Attribute Clauses]
-      //  A list item that specifies a given variable may not appear in more
-      // than one clause on the same directive, except that a variable may be
-      //  specified in both firstprivate and lastprivate clauses.
-      if (DVar.CKind != OMPC_unknown && DVar.CKind != OMPC_firstprivate &&
-          DVar.CKind != OMPC_lastprivate && DVar.RefExpr) {
-        Diag(ELoc, diag::err_omp_wrong_dsa)
-            << getOpenMPClauseName(DVar.CKind)
-            << getOpenMPClauseName(OMPC_firstprivate);
-        ReportOriginalDSA(*this, DSAStack, VD, DVar);
+    // OpenMP [2.9.3.4, Restrictions, C/C++, p.1]
+    //  A variable of class type (or array thereof) that appears in a
+    //  firstprivate clause requires an accesible, unambiguous copy constructor
+    //  for the class type.
+    CXXRecordDecl *RD =
+        getLangOpts().CPlusPlus ? Type->getAsCXXRecordDecl() : 0;
+    if (RD) {
+      CXXConstructorDecl *CD = LookupCopyingConstructor(RD, 0);
+      PartialDiagnostic PD =
+          PartialDiagnostic(PartialDiagnostic::NullDiagnostic());
+      if (!CD ||
+          CheckConstructorAccess(ELoc, CD,
+                                 InitializedEntity::InitializeTemporary(Type),
+                                 CD->getAccess(), PD) == AR_inaccessible ||
+          CD->isDeleted()) {
+        Diag(ELoc, diag::err_omp_required_method)
+            << getOpenMPClauseName(OMPC_firstprivate) << 1;
+        bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
+                      VarDecl::DeclarationOnly;
+        Diag(VD->getLocation(),
+             IsDecl ? diag::note_previous_decl : diag::note_defined_here)
+            << VD;
+        Diag(RD->getLocation(), diag::note_previous_decl) << RD;
         continue;
       }
+      MarkFunctionReferenced(ELoc, CD);
+      DiagnoseUseOfDecl(CD, ELoc);
 
-      // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
-      // in a Construct]
-      //  Variables with the predetermined data-sharing attributes may not be
-      //  listed in data-sharing attributes clauses, except for the cases
-      //  listed below. For these exceptions only, listing a predetermined
-      //  variable in a data-sharing attribute clause is allowed and overrides
-      //  the variable's predetermined data-sharing attributes.
-      // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
-      // in a Construct, C/C++, p.2]
-      //  Variables with const-qualified type having no mutable member may be
-      //  listed in a firstprivate clause, even if they are static data members.
-      if (!(IsConstant || VD->isStaticDataMember()) && !DVar.RefExpr &&
-          DVar.CKind != OMPC_unknown && DVar.CKind != OMPC_shared) {
-        Diag(ELoc, diag::err_omp_wrong_dsa)
-            << getOpenMPClauseName(DVar.CKind)
-            << getOpenMPClauseName(OMPC_firstprivate);
-        ReportOriginalDSA(*this, DSAStack, VD, DVar);
+      CXXDestructorDecl *DD = RD->getDestructor();
+      if (DD && (CheckDestructorAccess(ELoc, DD, PD) == AR_inaccessible ||
+                 DD->isDeleted())) {
+        Diag(ELoc, diag::err_omp_required_method)
+            << getOpenMPClauseName(OMPC_firstprivate) << 4;
+        bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
+                      VarDecl::DeclarationOnly;
+        Diag(VD->getLocation(),
+             IsDecl ? diag::note_previous_decl : diag::note_defined_here)
+            << VD;
+        Diag(RD->getLocation(), diag::note_previous_decl) << RD;
         continue;
-      }
-
-      OpenMPDirectiveKind CurrDir = DSAStack->getCurrentDirective();
-      // OpenMP [2.9.3.4, Restrictions, p.2]
-      //  A list item that is private within a parallel region must not appear
-      //  in a firstprivate clause on a worksharing construct if any of the
-      //  worksharing regions arising from the worksharing construct ever bind
-      //  to any of the parallel regions arising from the parallel construct.
-      if (isOpenMPWorksharingDirective(CurrDir) &&
-          !isOpenMPParallelDirective(CurrDir)) {
-        DVar = DSAStack->getImplicitDSA(VD, true);
-        if (DVar.CKind != OMPC_shared &&
-            (isOpenMPParallelDirective(DVar.DKind) ||
-             DVar.DKind == OMPD_unknown)) {
-          Diag(ELoc, diag::err_omp_required_access)
-              << getOpenMPClauseName(OMPC_firstprivate)
-              << getOpenMPClauseName(OMPC_shared);
-          ReportOriginalDSA(*this, DSAStack, VD, DVar);
-          continue;
-        }
-      }
-      // OpenMP [2.9.3.4, Restrictions, p.3]
-      //  A list item that appears in a reduction clause of a parallel construct
-      //  must not appear in a firstprivate clause on a worksharing or task
-      //  construct if any of the worksharing or task regions arising from the
-      //  worksharing or task construct ever bind to any of the parallel regions
-      //  arising from the parallel construct.
-      // OpenMP [2.9.3.4, Restrictions, p.4]
-      //  A list item that appears in a reduction clause in worksharing
-      //  construct must not appear in a firstprivate clause in a task construct
-      //  encountered during execution of any of the worksharing regions arising
-      //  from the worksharing construct.
-      if (CurrDir == OMPD_task) {
-        DVar =
-            DSAStack->hasInnermostDSA(VD, MatchesAnyClause(OMPC_reduction),
-                                      [](OpenMPDirectiveKind K) -> bool {
-                                        return isOpenMPParallelDirective(K) ||
-                                               isOpenMPWorksharingDirective(K);
-                                      },
-                                      false);
-        if (DVar.CKind == OMPC_reduction &&
-            (isOpenMPParallelDirective(DVar.DKind) ||
-             isOpenMPWorksharingDirective(DVar.DKind))) {
-          Diag(ELoc, diag::err_omp_parallel_reduction_in_task_firstprivate)
-              << getOpenMPDirectiveName(DVar.DKind);
-          ReportOriginalDSA(*this, DSAStack, VD, DVar);
-          continue;
-        }
+      } else if (DD) {
+        MarkFunctionReferenced(ELoc, DD);
+        DiagnoseUseOfDecl(DD, ELoc);
       }
     }
 
+    Type = Type.getUnqualifiedType();
+    if ((RD && !RD->isTriviallyCopyable()) || IsArray) {
+      DeclRefExpr *PseudoDE = DE;
+      IdentifierInfo *Id = &Context.Idents.get(".firstprivate.");
+      TypeSourceInfo *TI = Context.getTrivialTypeSourceInfo(Type, ELoc);
+      VarDecl *PseudoVar = VarDecl::Create(
+          Context, Context.getTranslationUnitDecl(), SourceLocation(),
+          SourceLocation(), Id, Type, TI, SC_Static);
+      PseudoVar->setImplicit();
+      PseudoVar->addAttr(new (Context)
+                             UnusedAttr(SourceLocation(), Context, 0));
+      Context.getTranslationUnitDecl()->addHiddenDecl(PseudoVar);
+      PseudoDE = cast<DeclRefExpr>(
+          BuildDeclRefExpr(PseudoVar, Type, VK_LValue, ELoc).get());
+      InitializedEntity Entity =
+          InitializedEntity::InitializeVariable(PseudoVar);
+      InitializationKind InitKind = InitializationKind::CreateCopy(ELoc, ELoc);
+      Expr *Arg = DefaultLvalueConversion(PseudoDE).get();
+      if (!Arg)
+        continue;
+      InitializationSequence InitSeq(*this, Entity, InitKind,
+                                     MultiExprArg(&Arg, 1));
+      ExprResult Res =
+          InitSeq.Perform(*this, Entity, InitKind, MultiExprArg(&Arg, 1));
+      if (Res.isInvalid())
+        continue;
+      PseudoVars.push_back(PseudoDE);
+      Inits.push_back(ActOnFinishFullExpr(Res.get()).get());
+    } else {
+      PseudoVars.push_back(0);
+      Inits.push_back(0);
+    }
     DSAStack->addDSA(VD, DE, OMPC_firstprivate);
     Vars.push_back(DE);
   }
 
   if (Vars.empty())
-    return nullptr;
+    return 0;
 
-  return OMPFirstprivateClause::Create(Context, StartLoc, LParenLoc, EndLoc,
-                                       Vars);
+  return OMPFirstPrivateClause::Create(Context, StartLoc, EndLoc, Vars,
+                                       PseudoVars, Inits);
 }
 
-OMPClause *Sema::ActOnOpenMPLastprivateClause(ArrayRef<Expr *> VarList,
+OMPClause *Sema::ActOnOpenMPLastPrivateClause(ArrayRef<Expr *> VarList,
                                               SourceLocation StartLoc,
-                                              SourceLocation LParenLoc,
                                               SourceLocation EndLoc) {
-  SmallVector<Expr *, 8> Vars;
-  for (auto &RefExpr : VarList) {
-    assert(RefExpr && "NULL expr in OpenMP lastprivate clause.");
-    if (isa<DependentScopeDeclRefExpr>(RefExpr)) {
+  SmallVector<Expr *, 4> Vars;
+  SmallVector<DeclRefExpr *, 4> PseudoVars1;
+  SmallVector<DeclRefExpr *, 4> PseudoVars2;
+  SmallVector<Expr *, 4> Assignments;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    assert(*I && "Null expr in omp lastprivate");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
       // It will be analyzed later.
-      Vars.push_back(RefExpr);
+      Vars.push_back(*I);
+      PseudoVars1.push_back(0);
+      PseudoVars2.push_back(0);
+      Assignments.push_back(0);
       continue;
     }
 
-    SourceLocation ELoc = RefExpr->getExprLoc();
+    SourceLocation ELoc = (*I)->getExprLoc();
     // OpenMP [2.1, C/C++]
     //  A list item is a variable name.
-    // OpenMP  [2.14.3.5, Restrictions, p.1]
-    //  A variable that is part of another variable (as an array or structure
-    //  element) cannot appear in a lastprivate clause.
-    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(RefExpr);
+    // OpenMP  [2.11.3.5, Restrictions, p.1]
+    //  A variable that is part of another variable (as an array or
+    //  structure element) cannot appear in a private clause.
+    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(*I);
     if (!DE || !isa<VarDecl>(DE->getDecl())) {
-      Diag(ELoc, diag::err_omp_expected_var_name) << RefExpr->getSourceRange();
+      Diag(ELoc, diag::err_omp_expected_var_name) << (*I)->getSourceRange();
       continue;
     }
     Decl *D = DE->getDecl();
@@ -3193,12 +5690,15 @@
     QualType Type = VD->getType();
     if (Type->isDependentType() || Type->isInstantiationDependentType()) {
       // It will be analyzed later.
-      Vars.push_back(DE);
+      Vars.push_back(*I);
+      PseudoVars1.push_back(0);
+      PseudoVars2.push_back(0);
+      Assignments.push_back(0);
       continue;
     }
 
-    // OpenMP [2.14.3.5, Restrictions, C/C++, p.2]
-    //  A variable that appears in a lastprivate clause must not have an
+    // OpenMP [2.9.3.11, Restrictions, C/C++, p.4]
+    //  A variable that appears in a firstprivate clause must not have an
     //  incomplete type or a reference type.
     if (RequireCompleteType(ELoc, Type,
                             diag::err_omp_lastprivate_incomplete_type)) {
@@ -3206,7 +5706,7 @@
     }
     if (Type->isReferenceType()) {
       Diag(ELoc, diag::err_omp_clause_ref_type_arg)
-          << getOpenMPClauseName(OMPC_lastprivate) << Type;
+          << getOpenMPClauseName(OMPC_lastprivate);
       bool IsDecl =
           VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
       Diag(VD->getLocation(),
@@ -3215,132 +5715,189 @@
       continue;
     }
 
-    // OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables Referenced
+    // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
     // in a Construct]
     //  Variables with the predetermined data-sharing attributes may not be
     //  listed in data-sharing attributes clauses, except for the cases
-    //  listed below.
-    DSAStackTy::DSAVarData DVar = DSAStack->getTopDSA(VD, false);
-    if (DVar.CKind != OMPC_unknown && DVar.CKind != OMPC_lastprivate &&
-        DVar.CKind != OMPC_firstprivate &&
-        (DVar.CKind != OMPC_private || DVar.RefExpr != nullptr)) {
+    //  listed below. For these exceptions only, listing a predetermined
+    //  variable in a data-sharing attribute clause is allowed and overrides
+    //  the variable's predetermined data-sharing attributes.
+    // OpenMP [2.9.3.4, Description]
+    //  If a list item appears in both firstprivate and lastprivate clauses,
+    //  the update requires for lastprivate occurs after all the initializations
+    //  for firstprivate.
+    DeclRefExpr *PrevRef;
+    OpenMPClauseKind Kind = DSAStack->getTopDSA(VD, PrevRef);
+    Type = Type.getNonReferenceType().getCanonicalType();
+    bool IsArray = Type->isArrayType();
+    while (Type->isArrayType()) {
+      QualType ElemType = cast<ArrayType>(Type.getTypePtr())->getElementType();
+      Type = ElemType.getNonReferenceType().getCanonicalType();
+    }
+    if (Kind != OMPC_unknown && Kind != OMPC_firstprivate &&
+        Kind != OMPC_lastprivate) {
       Diag(ELoc, diag::err_omp_wrong_dsa)
-          << getOpenMPClauseName(DVar.CKind)
-          << getOpenMPClauseName(OMPC_lastprivate);
-      ReportOriginalDSA(*this, DSAStack, VD, DVar);
+          << getOpenMPClauseName(Kind) << getOpenMPClauseName(OMPC_lastprivate);
+      if (PrevRef) {
+        Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+            << getOpenMPClauseName(Kind);
+      } else {
+        Diag(VD->getLocation(), diag::note_omp_predetermined_dsa)
+            << getOpenMPClauseName(Kind);
+      }
       continue;
     }
+    bool IsNotFirstprivate = Kind != OMPC_firstprivate;
 
+    // OpenMP [2.9.3.5, Restrictions, p.2]
+    //  A list item that is private within a parallel region, or that appears
+    //  in the reduction clause of a parallel construct,  must not appear in
+    //  a lastprivate clause on a worksharing construct if any of the
+    //  worksharing regions ever bind to any of the correspponding parallel
+    //  regions.
+    OpenMPDirectiveKind DKind;
     OpenMPDirectiveKind CurrDir = DSAStack->getCurrentDirective();
-    // OpenMP [2.14.3.5, Restrictions, p.2]
-    // A list item that is private within a parallel region, or that appears in
-    // the reduction clause of a parallel construct, must not appear in a
-    // lastprivate clause on a worksharing construct if any of the corresponding
-    // worksharing regions ever binds to any of the corresponding parallel
-    // regions.
-    if (isOpenMPWorksharingDirective(CurrDir) &&
-        !isOpenMPParallelDirective(CurrDir)) {
-      DVar = DSAStack->getImplicitDSA(VD, true);
-      if (DVar.CKind != OMPC_shared) {
+    Kind = DSAStack->getImplicitDSA(VD, DKind, PrevRef);
+    if ((Kind != OMPC_shared && Kind != OMPC_unknown &&
+         DKind != OMPD_unknown) &&
+        (CurrDir == OMPD_for || CurrDir == OMPD_sections ||
+         CurrDir == OMPD_for_simd)) {
+      if (Kind == OMPC_unknown) {
         Diag(ELoc, diag::err_omp_required_access)
             << getOpenMPClauseName(OMPC_lastprivate)
             << getOpenMPClauseName(OMPC_shared);
-        ReportOriginalDSA(*this, DSAStack, VD, DVar);
-        continue;
+      } else if (DKind == OMPD_unknown) {
+        Diag(ELoc, diag::err_omp_wrong_dsa)
+            << getOpenMPClauseName(Kind)
+            << getOpenMPClauseName(OMPC_lastprivate);
+      } else {
+        Diag(ELoc, diag::err_omp_dsa_with_directives)
+            << getOpenMPClauseName(Kind) << getOpenMPDirectiveName(DKind)
+            << getOpenMPClauseName(OMPC_lastprivate)
+            << getOpenMPDirectiveName(CurrDir);
       }
+      if (PrevRef) {
+        Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+            << getOpenMPClauseName(Kind);
+      }
+      continue;
     }
-    // OpenMP [2.14.3.5, Restrictions, C++, p.1,2]
-    //  A variable of class type (or array thereof) that appears in a
-    //  lastprivate clause requires an accessible, unambiguous default
-    //  constructor for the class type, unless the list item is also specified
-    //  in a firstprivate clause.
+
+    // OpenMP [2.9.3.5, Restrictions, C/C++, p.2]
     //  A variable of class type (or array thereof) that appears in a
-    //  lastprivate clause requires an accessible, unambiguous copy assignment
+    //  lastprivate clause requires an accesible, unambiguous copy assignment
     //  operator for the class type.
-    while (Type.getNonReferenceType()->isArrayType())
-      Type = cast<ArrayType>(Type.getNonReferenceType().getTypePtr())
-                 ->getElementType();
-    CXXRecordDecl *RD = getLangOpts().CPlusPlus
-                            ? Type.getNonReferenceType()->getAsCXXRecordDecl()
-                            : nullptr;
-    // FIXME This code must be replaced by actual copying and destructing of the
-    // lastprivate variable.
+    CXXRecordDecl *RD =
+        getLangOpts().CPlusPlus ? Type->getAsCXXRecordDecl() : 0;
     if (RD) {
       CXXMethodDecl *MD = LookupCopyingAssignment(RD, 0, false, 0);
-      DeclAccessPair FoundDecl = DeclAccessPair::make(MD, MD->getAccess());
-      if (MD) {
-        if (CheckMemberAccess(ELoc, RD, FoundDecl) == AR_inaccessible ||
-            MD->isDeleted()) {
-          Diag(ELoc, diag::err_omp_required_method)
-              << getOpenMPClauseName(OMPC_lastprivate) << 2;
-          bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
-                        VarDecl::DeclarationOnly;
-          Diag(VD->getLocation(),
-               IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-              << VD;
-          Diag(RD->getLocation(), diag::note_previous_decl) << RD;
-          continue;
-        }
-        MarkFunctionReferenced(ELoc, MD);
-        DiagnoseUseOfDecl(MD, ELoc);
+      if (!MD ||
+          CheckMemberAccess(ELoc, RD,
+                            DeclAccessPair::make(MD, MD->getAccess())) ==
+              AR_inaccessible ||
+          MD->isDeleted()) {
+        Diag(ELoc, diag::err_omp_required_method)
+            << getOpenMPClauseName(OMPC_lastprivate) << 2;
+        bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
+                      VarDecl::DeclarationOnly;
+        Diag(VD->getLocation(),
+             IsDecl ? diag::note_previous_decl : diag::note_defined_here)
+            << VD;
+        Diag(RD->getLocation(), diag::note_previous_decl) << RD;
+        continue;
       }
-
+      MarkFunctionReferenced(ELoc, MD);
+      DiagnoseUseOfDecl(MD, ELoc);
+      PartialDiagnostic PD =
+          PartialDiagnostic(PartialDiagnostic::NullDiagnostic());
       CXXDestructorDecl *DD = RD->getDestructor();
-      if (DD) {
-        PartialDiagnostic PD =
-            PartialDiagnostic(PartialDiagnostic::NullDiagnostic());
-        if (CheckDestructorAccess(ELoc, DD, PD) == AR_inaccessible ||
-            DD->isDeleted()) {
-          Diag(ELoc, diag::err_omp_required_method)
-              << getOpenMPClauseName(OMPC_lastprivate) << 4;
-          bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
-                        VarDecl::DeclarationOnly;
-          Diag(VD->getLocation(),
-               IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-              << VD;
-          Diag(RD->getLocation(), diag::note_previous_decl) << RD;
-          continue;
-        }
+      if (DD && (CheckDestructorAccess(ELoc, DD, PD) == AR_inaccessible ||
+                 DD->isDeleted())) {
+        Diag(ELoc, diag::err_omp_required_method)
+            << getOpenMPClauseName(OMPC_lastprivate) << 4;
+        bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
+                      VarDecl::DeclarationOnly;
+        Diag(VD->getLocation(),
+             IsDecl ? diag::note_previous_decl : diag::note_defined_here)
+            << VD;
+        Diag(RD->getLocation(), diag::note_previous_decl) << RD;
+        continue;
+      } else if (DD) {
         MarkFunctionReferenced(ELoc, DD);
         DiagnoseUseOfDecl(DD, ELoc);
       }
     }
 
-    if (DVar.CKind != OMPC_firstprivate)
+    Type = Type.getUnqualifiedType();
+    IdentifierInfo *Id = &Context.Idents.get(".lastprivate.");
+    TypeSourceInfo *TI = Context.getTrivialTypeSourceInfo(Type, ELoc);
+    VarDecl *PseudoVar1 = VarDecl::Create(
+        Context, Context.getTranslationUnitDecl(), SourceLocation(),
+        SourceLocation(), Id, Type, TI, SC_Static);
+    PseudoVar1->setImplicit();
+    PseudoVar1->addAttr(new (Context) UnusedAttr(SourceLocation(), Context, 0));
+    Context.getTranslationUnitDecl()->addHiddenDecl(PseudoVar1);
+    DeclRefExpr *PseudoDE1 = cast<DeclRefExpr>(
+        BuildDeclRefExpr(PseudoVar1, Type, VK_LValue, ELoc).get());
+    if ((RD && !RD->isTriviallyCopyable()) || IsArray) {
+      VarDecl *PseudoVar2 = VarDecl::Create(
+          Context, Context.getTranslationUnitDecl(), SourceLocation(),
+          SourceLocation(), Id, Type, TI, SC_Static);
+      PseudoVar2->setImplicit();
+      PseudoVar2->addAttr(new (Context)
+                              UnusedAttr(SourceLocation(), Context, 0));
+      Context.getTranslationUnitDecl()->addHiddenDecl(PseudoVar2);
+      DeclRefExpr *PseudoDE2 = cast<DeclRefExpr>(
+          BuildDeclRefExpr(PseudoVar2, Type, VK_LValue, ELoc).get());
+      Expr *PseudoDE2RVal = DefaultLvalueConversion(PseudoDE2).get();
+      if (!PseudoDE2RVal)
+        continue;
+      ExprResult Res = BuildBinOp(DSAStack->getCurScope(), ELoc, BO_Assign,
+                                  PseudoDE1, PseudoDE2RVal).get();
+      if (Res.isInvalid())
+        continue;
+      PseudoVars2.push_back(PseudoDE2);
+      Assignments.push_back(
+          ActOnFinishFullExpr(IgnoredValueConversions(Res.get()).get()).get());
+    } else {
+      PseudoVars2.push_back(0);
+      Assignments.push_back(0);
+    }
+    PseudoVars1.push_back(PseudoDE1);
+    if (IsNotFirstprivate)
       DSAStack->addDSA(VD, DE, OMPC_lastprivate);
     Vars.push_back(DE);
   }
 
   if (Vars.empty())
-    return nullptr;
+    return 0;
 
-  return OMPLastprivateClause::Create(Context, StartLoc, LParenLoc, EndLoc,
-                                      Vars);
+  return OMPLastPrivateClause::Create(Context, StartLoc, EndLoc, Vars,
+                                      PseudoVars1, PseudoVars2, Assignments);
 }
 
 OMPClause *Sema::ActOnOpenMPSharedClause(ArrayRef<Expr *> VarList,
                                          SourceLocation StartLoc,
-                                         SourceLocation LParenLoc,
                                          SourceLocation EndLoc) {
-  SmallVector<Expr *, 8> Vars;
-  for (auto &RefExpr : VarList) {
-    assert(RefExpr && "NULL expr in OpenMP shared clause.");
-    if (isa<DependentScopeDeclRefExpr>(RefExpr)) {
+  SmallVector<Expr *, 4> Vars;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    assert(*I && "Null expr in omp shared");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
       // It will be analyzed later.
-      Vars.push_back(RefExpr);
+      Vars.push_back(*I);
       continue;
     }
 
-    SourceLocation ELoc = RefExpr->getExprLoc();
+    SourceLocation ELoc = (*I)->getExprLoc();
     // OpenMP [2.1, C/C++]
     //  A list item is a variable name.
-    // OpenMP  [2.14.3.2, Restrictions, p.1]
-    //  A variable that is part of another variable (as an array or structure
-    //  element) cannot appear in a shared unless it is a static data member
-    //  of a C++ class.
-    DeclRefExpr *DE = dyn_cast<DeclRefExpr>(RefExpr);
+    // OpenMP  [2.9.3.4, Restrictions, p.1]
+    //  A variable that is part of another variable (as an array or
+    //  structure element) cannot appear in a private clause.
+    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(*I);
     if (!DE || !isa<VarDecl>(DE->getDecl())) {
-      Diag(ELoc, diag::err_omp_expected_var_name) << RefExpr->getSourceRange();
+      Diag(ELoc, diag::err_omp_expected_var_name) << (*I)->getSourceRange();
       continue;
     }
     Decl *D = DE->getDecl();
@@ -3349,7 +5906,7 @@
     QualType Type = VD->getType();
     if (Type->isDependentType() || Type->isInstantiationDependentType()) {
       // It will be analyzed later.
-      Vars.push_back(DE);
+      Vars.push_back(*I);
       continue;
     }
 
@@ -3360,12 +5917,13 @@
     //  listed below. For these exceptions only, listing a predetermined
     //  variable in a data-sharing attribute clause is allowed and overrides
     //  the variable's predetermined data-sharing attributes.
-    DSAStackTy::DSAVarData DVar = DSAStack->getTopDSA(VD, false);
-    if (DVar.CKind != OMPC_unknown && DVar.CKind != OMPC_shared &&
-        DVar.RefExpr) {
-      Diag(ELoc, diag::err_omp_wrong_dsa) << getOpenMPClauseName(DVar.CKind)
+    DeclRefExpr *PrevRef;
+    OpenMPClauseKind Kind = DSAStack->getTopDSA(VD, PrevRef);
+    if (Kind != OMPC_unknown && Kind != OMPC_shared && PrevRef) {
+      Diag(ELoc, diag::err_omp_wrong_dsa) << getOpenMPClauseName(Kind)
                                           << getOpenMPClauseName(OMPC_shared);
-      ReportOriginalDSA(*this, DSAStack, VD, DVar);
+      Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+          << getOpenMPClauseName(Kind);
       continue;
     }
 
@@ -3374,9 +5932,293 @@
   }
 
   if (Vars.empty())
-    return nullptr;
+    return 0;
+
+  return OMPSharedClause::Create(Context, StartLoc, EndLoc, Vars);
+}
+
+OMPClause *Sema::ActOnOpenMPCopyinClause(ArrayRef<Expr *> VarList,
+                                         SourceLocation StartLoc,
+                                         SourceLocation EndLoc) {
+  SmallVector<Expr *, 4> Vars;
+  SmallVector<DeclRefExpr *, 4> PseudoVars1;
+  SmallVector<DeclRefExpr *, 4> PseudoVars2;
+  SmallVector<Expr *, 4> Assignments;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    assert(*I && "Null expr in omp copyin");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
+      // It will be analyzed later.
+      Vars.push_back(*I);
+      PseudoVars1.push_back(0);
+      PseudoVars2.push_back(0);
+      Assignments.push_back(0);
+      continue;
+    }
+
+    SourceLocation ELoc = (*I)->getExprLoc();
+    // OpenMP [2.1, C/C++]
+    //  A list item is a variable name.
+    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(*I);
+    if (!DE || !isa<VarDecl>(DE->getDecl())) {
+      Diag(ELoc, diag::err_omp_expected_var_name) << (*I)->getSourceRange();
+      continue;
+    }
+    Decl *D = DE->getDecl();
+    VarDecl *VD = cast<VarDecl>(D);
+
+    QualType Type = VD->getType();
+    if (Type->isDependentType() || Type->isInstantiationDependentType()) {
+      // It will be analyzed later.
+      Vars.push_back(*I);
+      PseudoVars1.push_back(0);
+      PseudoVars2.push_back(0);
+      Assignments.push_back(0);
+      continue;
+    }
+
+    // OpenMP [2.9.2, Restrictions, p.1]
+    //  A threadprivate variable must not appear in any clause except the
+    //  copyin, copyprivate, schedule, num_threads, and if clauses.
+    // OpenMP [2.9.4.1, Restrictions, C/C++, p.1]
+    //  A list item that appears in a copyin clause must be threadprivate.
+    DeclRefExpr *PrevRef;
+    OpenMPClauseKind Kind = DSAStack->getTopDSA(VD, PrevRef);
+    if (Kind != OMPC_threadprivate && Kind != OMPC_copyin) {
+      Diag(ELoc, diag::err_omp_required_access)
+          << getOpenMPClauseName(OMPC_copyin)
+          << getOpenMPDirectiveName(OMPD_threadprivate);
+      continue;
+    }
+
+    // OpenMP [2.9.3.4, Restrictions, C/C++, p.1]
+    //  A variable of class type (or array thereof) that appears in a
+    //  firstprivate clause requires an accesible, unambiguous copy assignment
+    //  operator for the class type.
+    Type = Type.getNonReferenceType().getCanonicalType();
+    bool IsArray = Type->isArrayType();
+    while (Type->isArrayType()) {
+      QualType ElemType = cast<ArrayType>(Type.getTypePtr())->getElementType();
+      Type = ElemType.getNonReferenceType().getCanonicalType();
+    }
+    CXXRecordDecl *RD =
+        getLangOpts().CPlusPlus ? Type->getAsCXXRecordDecl() : 0;
+    if (RD) {
+      CXXMethodDecl *MD = LookupCopyingAssignment(RD, 0, false, 0);
+      if (!MD ||
+          CheckMemberAccess(ELoc, RD,
+                            DeclAccessPair::make(MD, MD->getAccess())) ==
+              AR_inaccessible ||
+          MD->isDeleted()) {
+        Diag(ELoc, diag::err_omp_required_method)
+            << getOpenMPClauseName(OMPC_copyin) << 2;
+        bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
+                      VarDecl::DeclarationOnly;
+        Diag(VD->getLocation(),
+             IsDecl ? diag::note_previous_decl : diag::note_defined_here)
+            << VD;
+        Diag(RD->getLocation(), diag::note_previous_decl) << RD;
+        continue;
+      }
+      MarkFunctionReferenced(ELoc, MD);
+      DiagnoseUseOfDecl(MD, ELoc);
+    }
+
+    Type = Type.getUnqualifiedType();
+    IdentifierInfo *Id = &Context.Idents.get(".copyin.");
+    TypeSourceInfo *TI = Context.getTrivialTypeSourceInfo(Type, ELoc);
+    VarDecl *PseudoVar1 = VarDecl::Create(
+        Context, Context.getTranslationUnitDecl(), SourceLocation(),
+        SourceLocation(), Id, Type, TI, SC_Static);
+    PseudoVar1->setImplicit();
+    PseudoVar1->addAttr(new (Context) UnusedAttr(SourceLocation(), Context, 0));
+    Context.getTranslationUnitDecl()->addHiddenDecl(PseudoVar1);
+    DeclRefExpr *PseudoDE1 = cast<DeclRefExpr>(
+        BuildDeclRefExpr(PseudoVar1, Type, VK_LValue, ELoc).get());
+    if ((RD && !RD->isTriviallyCopyable()) || IsArray) {
+      VarDecl *PseudoVar2 = VarDecl::Create(
+          Context, Context.getTranslationUnitDecl(), SourceLocation(),
+          SourceLocation(), Id, Type, TI, SC_Static);
+      PseudoVar2->setImplicit();
+      PseudoVar2->addAttr(new (Context)
+                              UnusedAttr(SourceLocation(), Context, 0));
+      Context.getTranslationUnitDecl()->addHiddenDecl(PseudoVar2);
+      DeclRefExpr *PseudoDE2 = cast<DeclRefExpr>(
+          BuildDeclRefExpr(PseudoVar2, Type, VK_LValue, ELoc).get());
+      Expr *PseudoDE2RVal = DefaultLvalueConversion(PseudoDE2).get();
+      if (!PseudoDE2RVal)
+        continue;
+      ExprResult Res = BuildBinOp(DSAStack->getCurScope(), ELoc, BO_Assign,
+                                  PseudoDE1, PseudoDE2RVal).get();
+      if (Res.isInvalid())
+        continue;
+      PseudoVars2.push_back(PseudoDE2);
+      Assignments.push_back(
+          ActOnFinishFullExpr(IgnoredValueConversions(Res.get()).get()).get());
+    } else {
+      PseudoVars2.push_back(0);
+      Assignments.push_back(0);
+    }
+    PseudoVars1.push_back(PseudoDE1);
+    DSAStack->addDSA(VD, DE, OMPC_copyin);
+    Vars.push_back(DE);
+  }
+
+  if (Vars.empty())
+    return 0;
+
+  return OMPCopyinClause::Create(Context, StartLoc, EndLoc, Vars, PseudoVars1,
+                                 PseudoVars2, Assignments);
+}
+
+OMPClause *Sema::ActOnOpenMPCopyPrivateClause(ArrayRef<Expr *> VarList,
+                                              SourceLocation StartLoc,
+                                              SourceLocation EndLoc) {
+  SmallVector<Expr *, 4> Vars;
+  SmallVector<DeclRefExpr *, 4> PseudoVars1;
+  SmallVector<DeclRefExpr *, 4> PseudoVars2;
+  SmallVector<Expr *, 4> Assignments;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    assert(*I && "Null expr in omp copyprivate");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
+      // It will be analyzed later.
+      Vars.push_back(*I);
+      PseudoVars1.push_back(0);
+      PseudoVars2.push_back(0);
+      Assignments.push_back(0);
+      continue;
+    }
+
+    SourceLocation ELoc = (*I)->getExprLoc();
+    // OpenMP [2.1, C/C++]
+    //  A list item is a variable name.
+    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(*I);
+    if (!DE || !isa<VarDecl>(DE->getDecl())) {
+      Diag(ELoc, diag::err_omp_expected_var_name) << (*I)->getSourceRange();
+      continue;
+    }
+    Decl *D = DE->getDecl();
+    VarDecl *VD = cast<VarDecl>(D);
+
+    QualType Type = VD->getType();
+    if (Type->isDependentType() || Type->isInstantiationDependentType()) {
+      // It will be analyzed later.
+      Vars.push_back(*I);
+      PseudoVars1.push_back(0);
+      PseudoVars2.push_back(0);
+      Assignments.push_back(0);
+      continue;
+    }
+
+    // OpenMP [2.11.4.2, Restrictions, p.2]
+    //  A list item that appears in a copyprivate clause may not appear in
+    //  a private or firstprivate clause on the single construct.
+    DeclRefExpr *PrevRef;
+    OpenMPClauseKind Kind = DSAStack->getTopDSA(VD, PrevRef);
+    if (Kind != OMPC_threadprivate && Kind != OMPC_copyprivate &&
+        Kind != OMPC_unknown && !(Kind == OMPC_private && !PrevRef)) {
+      Diag(ELoc, diag::err_omp_wrong_dsa)
+          << getOpenMPClauseName(Kind) << getOpenMPClauseName(OMPC_copyprivate);
+      if (PrevRef) {
+        Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+            << getOpenMPClauseName(Kind);
+      } else {
+        Diag(VD->getLocation(), diag::note_omp_predetermined_dsa)
+            << getOpenMPClauseName(Kind);
+      }
+      continue;
+    }
+
+    // OpenMP [2.11.4.2, Restrictions, p.1]
+    //  All list items that appear in a copyprivate clause must be either
+    //  threadprivate or private in the enclosing context.
+    if (Kind == OMPC_unknown) {
+      OpenMPDirectiveKind DKind;
+      Kind = DSAStack->getImplicitDSA(VD, DKind, PrevRef);
+      if (Kind == OMPC_shared) {
+        Diag(ELoc, diag::err_omp_required_access)
+            << getOpenMPClauseName(OMPC_copyprivate)
+            << "threadprivate or private in the enclosing context";
+        if (PrevRef) {
+          Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+              << getOpenMPClauseName(Kind);
+        }
+        continue;
+      }
+    }
+
+    // OpenMP [2.11.4.2, Restrictions, C/C++, p.1]
+    //  A variable of class type (or array thereof) that appears in a
+    //  copytprivate clause requires an accesible, unambiguous copy assignment
+    //  operator for the class type.
+    Type = Type.getNonReferenceType().getCanonicalType();
+    while (Type->isArrayType()) {
+      QualType ElemType = cast<ArrayType>(Type.getTypePtr())->getElementType();
+      Type = ElemType.getNonReferenceType().getCanonicalType();
+    }
+    CXXRecordDecl *RD =
+        getLangOpts().CPlusPlus ? Type->getAsCXXRecordDecl() : 0;
+    if (RD) {
+      CXXMethodDecl *MD = LookupCopyingAssignment(RD, 0, false, 0);
+      if (!MD ||
+          CheckMemberAccess(ELoc, RD,
+                            DeclAccessPair::make(MD, MD->getAccess())) ==
+              AR_inaccessible ||
+          MD->isDeleted()) {
+        Diag(ELoc, diag::err_omp_required_method)
+            << getOpenMPClauseName(OMPC_copyprivate) << 2;
+        bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
+                      VarDecl::DeclarationOnly;
+        Diag(VD->getLocation(),
+             IsDecl ? diag::note_previous_decl : diag::note_defined_here)
+            << VD;
+        Diag(RD->getLocation(), diag::note_previous_decl) << RD;
+        continue;
+      }
+      MarkFunctionReferenced(ELoc, MD);
+      DiagnoseUseOfDecl(MD, ELoc);
+    }
+
+    Type = Type.getUnqualifiedType();
+    IdentifierInfo *Id = &Context.Idents.get(".copyin.");
+    TypeSourceInfo *TI = Context.getTrivialTypeSourceInfo(Type, ELoc);
+    VarDecl *PseudoVar1 = VarDecl::Create(
+        Context, Context.getTranslationUnitDecl(), SourceLocation(),
+        SourceLocation(), Id, Type, TI, SC_Static);
+    PseudoVar1->setImplicit();
+    PseudoVar1->addAttr(new (Context) UnusedAttr(SourceLocation(), Context, 0));
+    Context.getTranslationUnitDecl()->addHiddenDecl(PseudoVar1);
+    DeclRefExpr *PseudoDE1 = cast<DeclRefExpr>(
+        BuildDeclRefExpr(PseudoVar1, Type, VK_LValue, ELoc).get());
+    VarDecl *PseudoVar2 = VarDecl::Create(
+        Context, Context.getTranslationUnitDecl(), SourceLocation(),
+        SourceLocation(), Id, Type, TI, SC_Static);
+    PseudoVar2->setImplicit();
+    PseudoVar2->addAttr(new (Context) UnusedAttr(SourceLocation(), Context, 0));
+    Context.getTranslationUnitDecl()->addHiddenDecl(PseudoVar2);
+    DeclRefExpr *PseudoDE2 = cast<DeclRefExpr>(
+        BuildDeclRefExpr(PseudoVar2, Type, VK_LValue, ELoc).get());
+    Expr *PseudoDE2RVal = DefaultLvalueConversion(PseudoDE2).get();
+    if (!PseudoDE2RVal)
+      continue;
+    ExprResult Res = BuildBinOp(DSAStack->getCurScope(), ELoc, BO_Assign,
+                                PseudoDE1, PseudoDE2RVal).get();
+    if (Res.isInvalid())
+      continue;
+    PseudoVars1.push_back(PseudoDE1);
+    PseudoVars2.push_back(PseudoDE2);
+    Assignments.push_back(
+        ActOnFinishFullExpr(IgnoredValueConversions(Res.get()).get()).get());
+    DSAStack->addDSA(VD, DE, OMPC_copyprivate);
+    Vars.push_back(DE);
+  }
+
+  if (Vars.empty())
+    return 0;
 
-  return OMPSharedClause::Create(Context, StartLoc, LParenLoc, EndLoc, Vars);
+  return OMPCopyPrivateClause::Create(Context, StartLoc, EndLoc, Vars,
+                                      PseudoVars1, PseudoVars2, Assignments);
 }
 
 namespace {
@@ -3386,185 +6228,248 @@
 public:
   bool VisitDeclRefExpr(DeclRefExpr *E) {
     if (VarDecl *VD = dyn_cast<VarDecl>(E->getDecl())) {
-      DSAStackTy::DSAVarData DVar = Stack->getTopDSA(VD, false);
-      if (DVar.CKind == OMPC_shared && !DVar.RefExpr)
+      DeclRefExpr *PrevRef;
+      OpenMPClauseKind Kind = Stack->getTopDSA(VD, PrevRef);
+      if (Kind == OMPC_shared && !PrevRef)
         return false;
-      if (DVar.CKind != OMPC_unknown)
+      if (Kind != OMPC_unknown)
         return true;
-      DSAStackTy::DSAVarData DVarPrivate =
-          Stack->hasDSA(VD, isOpenMPPrivate, MatchesAlways(), false);
-      if (DVarPrivate.CKind != OMPC_unknown)
+      // OpenMPDirectiveKind DKind;
+      // Kind = Stack->getImplicitDSA(VD, DKind, PrevRef);
+      if (Stack->hasDSA(VD, OMPC_private, OMPD_unknown, PrevRef) ||
+          Stack->hasDSA(VD, OMPC_firstprivate, OMPD_unknown, PrevRef) ||
+          Stack->hasDSA(VD, OMPC_lastprivate, OMPD_unknown, PrevRef) ||
+          Stack->hasDSA(VD, OMPC_reduction, OMPD_unknown, PrevRef) ||
+          Stack->hasDSA(VD, OMPC_linear, OMPD_unknown, PrevRef))
         return true;
       return false;
+      // return Kind != OMPC_shared && Kind != OMPC_unknown;
     }
     return false;
   }
   bool VisitStmt(Stmt *S) {
-    for (auto Child : S->children()) {
-      if (Child && Visit(Child))
-        return true;
+    for (Stmt::child_iterator I = S->child_begin(), E = S->child_end(); I != E;
+         ++I) {
+      if (Stmt *Child = *I)
+        if (Visit(Child))
+          return true;
     }
     return false;
   }
-  explicit DSARefChecker(DSAStackTy *S) : Stack(S) {}
+  DSARefChecker(DSAStackTy *S) : Stack(S) {}
 };
-} // namespace
+}
 
-OMPClause *Sema::ActOnOpenMPReductionClause(
-    ArrayRef<Expr *> VarList, SourceLocation StartLoc, SourceLocation LParenLoc,
-    SourceLocation ColonLoc, SourceLocation EndLoc,
-    CXXScopeSpec &ReductionIdScopeSpec,
-    const DeclarationNameInfo &ReductionId) {
-  // TODO: Allow scope specification search when 'declare reduction' is
-  // supported.
-  assert(ReductionIdScopeSpec.isEmpty() &&
-         "No support for scoped reduction identifiers yet.");
-
-  auto DN = ReductionId.getName();
-  auto OOK = DN.getCXXOverloadedOperator();
-  BinaryOperatorKind BOK = BO_Comma;
-
-  // OpenMP [2.14.3.6, reduction clause]
-  // C
-  // reduction-identifier is either an identifier or one of the following
-  // operators: +, -, *,  &, |, ^, && and ||
-  // C++
-  // reduction-identifier is either an id-expression or one of the following
-  // operators: +, -, *, &, |, ^, && and ||
-  // FIXME: Only 'min' and 'max' identifiers are supported for now.
-  switch (OOK) {
-  case OO_Plus:
-  case OO_Minus:
-    BOK = BO_AddAssign;
-    break;
-  case OO_Star:
-    BOK = BO_MulAssign;
-    break;
-  case OO_Amp:
-    BOK = BO_AndAssign;
-    break;
-  case OO_Pipe:
-    BOK = BO_OrAssign;
+namespace {
+class RedDeclFilterCCC : public CorrectionCandidateCallback {
+private:
+  Sema &Actions;
+  QualType QTy;
+  OMPDeclareReductionDecl::ReductionData *FoundData;
+
+public:
+  RedDeclFilterCCC(Sema &S, QualType QTy)
+      : Actions(S), QTy(QTy), FoundData(0) {}
+  virtual bool ValidateCandidate(const TypoCorrection &Candidate) {
+    if (OMPDeclareReductionDecl *D = dyn_cast_or_null<OMPDeclareReductionDecl>(
+            Candidate.getCorrectionDecl())) {
+      if (D->isInvalidDecl())
+        return false;
+      bool Found = false;
+      for (OMPDeclareReductionDecl::datalist_iterator IT = D->datalist_begin(),
+                                                      ET = D->datalist_end();
+           IT != ET; ++IT) {
+        if (!IT->QTy.isNull() &&
+            (Actions.Context.hasSameUnqualifiedType(IT->QTy, QTy) ||
+             Actions.IsDerivedFrom(QTy, IT->QTy))) {
+          Found = true;
+          FoundData = IT;
+        }
+      }
+      return Found;
+    }
+    return false;
+  }
+  OMPDeclareReductionDecl::ReductionData *getFoundData() { return FoundData; }
+};
+}
+
+static OMPDeclareReductionDecl::ReductionData *
+TryToFindDeclareReductionDecl(Sema &SemaRef, CXXScopeSpec &SS,
+                              DeclarationNameInfo OpName, QualType QTy,
+                              OpenMPReductionClauseOperator Op) {
+  LookupResult Lookup(SemaRef, OpName, Sema::LookupOMPDeclareReduction);
+  if (Op != OMPC_REDUCTION_custom) {
+    Lookup.suppressDiagnostics();
+  }
+  if (SemaRef.LookupParsedName(Lookup, SemaRef.getCurScope(), &SS)) {
+    LookupResult::Filter Filter = Lookup.makeFilter();
+    SmallVector<OMPDeclareReductionDecl::ReductionData *, 4> Found;
+    SmallVector<OMPDeclareReductionDecl *, 4> FoundDecl;
+    while (Filter.hasNext()) {
+      OMPDeclareReductionDecl *D = cast<OMPDeclareReductionDecl>(Filter.next());
+      bool Remove = true;
+      if (!D->isInvalidDecl()) {
+        for (OMPDeclareReductionDecl::datalist_iterator
+                 IT = D->datalist_begin(),
+                 ET = D->datalist_end();
+             IT != ET; ++IT) {
+          if (!IT->QTy.isNull() &&
+              SemaRef.Context.hasSameUnqualifiedType(IT->QTy, QTy)) {
+            Found.push_back(IT);
+            FoundDecl.push_back(D);
+            Remove = false;
+          }
+        }
+        if (Found.empty()) {
+          for (OMPDeclareReductionDecl::datalist_iterator
+                   IT = D->datalist_begin(),
+                   ET = D->datalist_end();
+               IT != ET; ++IT) {
+            if (!IT->QTy.isNull() && SemaRef.IsDerivedFrom(QTy, IT->QTy)) {
+              Found.push_back(IT);
+              FoundDecl.push_back(D);
+              Remove = false;
+            }
+          }
+        }
+      }
+      if (Remove)
+        Filter.erase();
+    }
+    Filter.done();
+    if (Found.size() > 1) {
+      // Ambiguous declaration found.
+      SemaRef.Diag(OpName.getLoc(), diag::err_ambiguous_reference)
+          << OpName.getName();
+      SmallVectorImpl<OMPDeclareReductionDecl::ReductionData *>::iterator IT =
+          Found.begin();
+      for (SmallVectorImpl<OMPDeclareReductionDecl *>::iterator
+               IR = FoundDecl.begin(),
+               ER = FoundDecl.end();
+           IR != ER; ++IR, ++IT) {
+        SemaRef.Diag((*IR)->getLocation(), diag::note_ambiguous_candidate)
+            << *IR << (*IT)->TyRange;
+      }
+    }
+    if (!Found.empty())
+      return Found.back();
+  }
+  assert(Lookup.empty() && "Lookup is not empty.");
+  return 0;
+}
+
+OMPClause *Sema::ActOnOpenMPReductionClause(ArrayRef<Expr *> VarList,
+                                            SourceLocation StartLoc,
+                                            SourceLocation EndLoc,
+                                            OpenMPReductionClauseOperator Op,
+                                            CXXScopeSpec &SS,
+                                            DeclarationNameInfo OpName) {
+  BinaryOperatorKind NewOp = BO_Assign;
+  switch (Op) {
+  case OMPC_REDUCTION_add:
+    NewOp = BO_AddAssign;
+    break;
+  case OMPC_REDUCTION_mult:
+    NewOp = BO_MulAssign;
+    break;
+  case OMPC_REDUCTION_sub:
+    NewOp = BO_SubAssign;
+    break;
+  case OMPC_REDUCTION_bitand:
+    NewOp = BO_AndAssign;
+    break;
+  case OMPC_REDUCTION_bitor:
+    NewOp = BO_OrAssign;
+    break;
+  case OMPC_REDUCTION_bitxor:
+    NewOp = BO_XorAssign;
+    break;
+  case OMPC_REDUCTION_and:
+    NewOp = BO_LAnd;
     break;
-  case OO_Caret:
-    BOK = BO_XorAssign;
+  case OMPC_REDUCTION_or:
+    NewOp = BO_LOr;
     break;
-  case OO_AmpAmp:
-    BOK = BO_LAnd;
+  case OMPC_REDUCTION_min:
+    NewOp = BO_LT;
     break;
-  case OO_PipePipe:
-    BOK = BO_LOr;
+  case OMPC_REDUCTION_max:
+    NewOp = BO_GT;
     break;
   default:
-    if (auto II = DN.getAsIdentifierInfo()) {
-      if (II->isStr("max"))
-        BOK = BO_GT;
-      else if (II->isStr("min"))
-        BOK = BO_LT;
-    }
     break;
   }
-  SourceRange ReductionIdRange;
-  if (ReductionIdScopeSpec.isValid()) {
-    ReductionIdRange.setBegin(ReductionIdScopeSpec.getBeginLoc());
-  }
-  ReductionIdRange.setEnd(ReductionId.getEndLoc());
-  if (BOK == BO_Comma) {
-    // Not allowed reduction identifier is found.
-    Diag(ReductionId.getLocStart(), diag::err_omp_unknown_reduction_identifier)
-        << ReductionIdRange;
-    return nullptr;
-  }
-
-  SmallVector<Expr *, 8> Vars;
-  for (auto RefExpr : VarList) {
-    assert(RefExpr && "nullptr expr in OpenMP reduction clause.");
-    if (isa<DependentScopeDeclRefExpr>(RefExpr)) {
-      // It will be analyzed later.
-      Vars.push_back(RefExpr);
-      continue;
-    }
-
-    if (RefExpr->isTypeDependent() || RefExpr->isValueDependent() ||
-        RefExpr->isInstantiationDependent() ||
-        RefExpr->containsUnexpandedParameterPack()) {
+  SmallVector<Expr *, 4> Vars;
+  SmallVector<Expr *, 4> DefaultInits;
+  SmallVector<Expr *, 4> OpExprs;
+  SmallVector<Expr *, 4> HelperParams1;
+  SmallVector<Expr *, 4> HelperParams2;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    assert(*I && "Null expr in omp reduction");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
       // It will be analyzed later.
-      Vars.push_back(RefExpr);
+      Vars.push_back(*I);
+      DefaultInits.push_back(0);
+      OpExprs.push_back(0);
+      HelperParams1.push_back(0);
+      HelperParams2.push_back(0);
       continue;
     }
 
-    auto ELoc = RefExpr->getExprLoc();
-    auto ERange = RefExpr->getSourceRange();
+    SourceLocation ELoc = (*I)->getExprLoc();
     // OpenMP [2.1, C/C++]
-    //  A list item is a variable or array section, subject to the restrictions
-    //  specified in Section 2.4 on page 42 and in each of the sections
-    // describing clauses and directives for which a list appears.
-    // OpenMP  [2.14.3.3, Restrictions, p.1]
+    //  A list item is a variable name.
+    // OpenMP  [2.9.3.3, Restrictions, p.1]
     //  A variable that is part of another variable (as an array or
     //  structure element) cannot appear in a private clause.
-    auto DE = dyn_cast<DeclRefExpr>(RefExpr);
+    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(*I);
     if (!DE || !isa<VarDecl>(DE->getDecl())) {
-      Diag(ELoc, diag::err_omp_expected_var_name) << ERange;
-      continue;
-    }
-    auto D = DE->getDecl();
-    auto VD = cast<VarDecl>(D);
-    auto Type = VD->getType();
-    // OpenMP [2.9.3.3, Restrictions, C/C++, p.3]
-    //  A variable that appears in a private clause must not have an incomplete
-    //  type or a reference type.
-    if (RequireCompleteType(ELoc, Type,
-                            diag::err_omp_reduction_incomplete_type))
-      continue;
-    // OpenMP [2.14.3.6, reduction clause, Restrictions]
-    // Arrays may not appear in a reduction clause.
-    if (Type.getNonReferenceType()->isArrayType()) {
-      Diag(ELoc, diag::err_omp_reduction_type_array) << Type << ERange;
-      bool IsDecl =
-          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
-      Diag(VD->getLocation(),
-           IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-          << VD;
+      Diag(ELoc, diag::err_omp_expected_var_name) << (*I)->getSourceRange();
       continue;
     }
-    // OpenMP [2.14.3.6, reduction clause, Restrictions]
-    // A list item that appears in a reduction clause must not be
-    // const-qualified.
-    if (Type.getNonReferenceType().isConstant(Context)) {
-      Diag(ELoc, diag::err_omp_const_variable)
-          << getOpenMPClauseName(OMPC_reduction) << Type << ERange;
-      bool IsDecl =
-          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
-      Diag(VD->getLocation(),
-           IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-          << VD;
+    Decl *D = DE->getDecl();
+    VarDecl *VD = cast<VarDecl>(D);
+
+    QualType Type = VD->getType();
+    if (Type->isDependentType() || Type->isInstantiationDependentType()) {
+      // It will be analyzed later.
+      Vars.push_back(*I);
+      DefaultInits.push_back(0);
+      OpExprs.push_back(0);
+      HelperParams1.push_back(0);
+      HelperParams2.push_back(0);
       continue;
     }
+
     // OpenMP [2.9.3.6, Restrictions, C/C++, p.4]
     //  If a list-item is a reference type then it must bind to the same object
     //  for all threads of the team.
-    VarDecl *VDDef = VD->getDefinition();
-    if (Type->isReferenceType() && VDDef) {
+    if (Type.getCanonicalType()->isReferenceType() && VD->hasInit()) {
       DSARefChecker Check(DSAStack);
-      if (Check.Visit(VDDef->getInit())) {
-        Diag(ELoc, diag::err_omp_reduction_ref_type_arg) << ERange;
-        Diag(VDDef->getLocation(), diag::note_defined_here) << VDDef;
+      if (Check.Visit(VD->getInit())) {
+        Diag(ELoc, diag::err_omp_reduction_ref_type_arg)
+            << getOpenMPClauseName(OMPC_reduction);
+        bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
+                      VarDecl::DeclarationOnly;
+        Diag(VD->getLocation(),
+             IsDecl ? diag::note_previous_decl : diag::note_defined_here)
+            << VD;
         continue;
       }
     }
-    // OpenMP [2.14.3.6, reduction clause, Restrictions]
-    // The type of a list item that appears in a reduction clause must be valid
-    // for the reduction-identifier. For a max or min reduction in C, the type
-    // of the list item must be an allowed arithmetic data type: char, int,
-    // float, double, or _Bool, possibly modified with long, short, signed, or
-    // unsigned. For a max or min reduction in C++, the type of the list item
-    // must be an allowed arithmetic data type: char, wchar_t, int, float,
-    // double, or bool, possibly modified with long, short, signed, or unsigned.
-    if ((BOK == BO_GT || BOK == BO_LT) &&
-        !(Type->isScalarType() ||
-          (getLangOpts().CPlusPlus && Type->isArithmeticType()))) {
-      Diag(ELoc, diag::err_omp_clause_not_arithmetic_type_arg)
-          << getLangOpts().CPlusPlus;
+
+    // OpenMP [2.9.3.6, Restrictions, C/C++, p.2]
+    //  Aggregate types (including arrays), pointer types and reference types
+    //  may not appear in a reduction clause.
+    if (RequireCompleteType(ELoc, Type,
+                            diag::err_omp_reduction_incomplete_type))
+      continue;
+    Type = Type.getNonReferenceType().getCanonicalType();
+    if (Type->isArrayType()) {
+      Diag(ELoc, diag::err_omp_clause_array_type_arg)
+          << getOpenMPClauseName(OMPC_reduction);
       bool IsDecl =
           VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
       Diag(VD->getLocation(),
@@ -3572,9 +6477,13 @@
           << VD;
       continue;
     }
-    if ((BOK == BO_OrAssign || BOK == BO_AndAssign || BOK == BO_XorAssign) &&
-        !getLangOpts().CPlusPlus && Type->isFloatingType()) {
-      Diag(ELoc, diag::err_omp_clause_floating_type_arg);
+
+    // OpenMP [2.9.3.6, Restrictions, C/C++, p.3]
+    //  A list item that appears in a reduction clause must not be
+    //  const-qualified.
+    if (Type.isConstant(Context)) {
+      Diag(ELoc, diag::err_omp_const_variable)
+          << getOpenMPClauseName(OMPC_reduction);
       bool IsDecl =
           VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
       Diag(VD->getLocation(),
@@ -3582,15 +6491,17 @@
           << VD;
       continue;
     }
-    bool Suppress = getDiagnostics().getSuppressAllDiagnostics();
-    getDiagnostics().setSuppressAllDiagnostics(true);
-    ExprResult ReductionOp =
-        BuildBinOp(DSAStack->getCurScope(), ReductionId.getLocStart(), BOK,
-                   RefExpr, RefExpr);
-    getDiagnostics().setSuppressAllDiagnostics(Suppress);
-    if (ReductionOp.isInvalid()) {
-      Diag(ELoc, diag::err_omp_reduction_id_not_compatible) << Type
-                                                            << ReductionIdRange;
+
+    // OpenMP [2.9.3.6, Restrictions, C/C++, p.1]
+    //  The type of a list item that appears in a reduction clause must be valid
+    //  for the reduction operator. For max or min reduction in C/C++ must be an
+    //  arithmetic type.
+    if (((Op == OMPC_REDUCTION_min || Op == OMPC_REDUCTION_max) &&
+         !Type->isArithmeticType() && !Type->isDependentType()) ||
+        (!getLangOpts().CPlusPlus && !Type->isScalarType() &&
+         !Type->isDependentType())) {
+      Diag(ELoc, diag::err_omp_clause_not_arithmetic_type_arg)
+          << getOpenMPClauseName(OMPC_reduction) << getLangOpts().CPlusPlus;
       bool IsDecl =
           VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
       Diag(VD->getLocation(),
@@ -3599,80 +6510,195 @@
       continue;
     }
 
-    // OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables Referenced
+    // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced
     // in a Construct]
     //  Variables with the predetermined data-sharing attributes may not be
     //  listed in data-sharing attributes clauses, except for the cases
     //  listed below. For these exceptions only, listing a predetermined
     //  variable in a data-sharing attribute clause is allowed and overrides
     //  the variable's predetermined data-sharing attributes.
-    // OpenMP [2.14.3.6, Restrictions, p.3]
+    // OpenMP [2.9.3.6, Restrictions, p.3]
     //  Any number of reduction clauses can be specified on the directive,
     //  but a list item can appear only once in the reduction clauses for that
     //  directive.
-    DSAStackTy::DSAVarData DVar = DSAStack->getTopDSA(VD, false);
-    if (DVar.CKind == OMPC_reduction) {
+    DeclRefExpr *PrevRef;
+    OpenMPClauseKind Kind = DSAStack->getTopDSA(VD, PrevRef);
+    if (Kind == OMPC_reduction) {
       Diag(ELoc, diag::err_omp_once_referenced)
           << getOpenMPClauseName(OMPC_reduction);
-      if (DVar.RefExpr) {
-        Diag(DVar.RefExpr->getExprLoc(), diag::note_omp_referenced);
+      if (PrevRef) {
+        Diag(PrevRef->getExprLoc(), diag::note_omp_referenced);
       }
-    } else if (DVar.CKind != OMPC_unknown) {
+    } else if (Kind != OMPC_unknown) {
       Diag(ELoc, diag::err_omp_wrong_dsa)
-          << getOpenMPClauseName(DVar.CKind)
-          << getOpenMPClauseName(OMPC_reduction);
-      ReportOriginalDSA(*this, DSAStack, VD, DVar);
+          << getOpenMPClauseName(Kind) << getOpenMPClauseName(OMPC_reduction);
+      if (PrevRef) {
+        Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+            << getOpenMPClauseName(Kind);
+      } else {
+        Diag(VD->getLocation(), diag::note_omp_predetermined_dsa)
+            << getOpenMPClauseName(Kind);
+      }
       continue;
     }
 
-    // OpenMP [2.14.3.6, Restrictions, p.1]
+    // OpenMP [2.9.3.6, Restrictions, p.1]
     //  A list item that appears in a reduction clause of a worksharing
     //  construct must be shared in the parallel regions to which any of the
     //  worksharing regions arising from the worksharing construct bind.
+    OpenMPDirectiveKind DKind;
     OpenMPDirectiveKind CurrDir = DSAStack->getCurrentDirective();
-    if (isOpenMPWorksharingDirective(CurrDir) &&
-        !isOpenMPParallelDirective(CurrDir)) {
-      DVar = DSAStack->getImplicitDSA(VD, true);
-      if (DVar.CKind != OMPC_shared) {
+    Kind = DSAStack->getImplicitDSA(VD, DKind, PrevRef);
+    if ((Kind != OMPC_shared && Kind != OMPC_unknown &&
+         DKind != OMPD_unknown) &&
+        (CurrDir == OMPD_for || CurrDir == OMPD_sections ||
+         CurrDir == OMPD_for_simd)) {
+      if (Kind == OMPC_unknown) {
         Diag(ELoc, diag::err_omp_required_access)
             << getOpenMPClauseName(OMPC_reduction)
             << getOpenMPClauseName(OMPC_shared);
-        ReportOriginalDSA(*this, DSAStack, VD, DVar);
-        continue;
+      } else if (DKind == OMPD_unknown) {
+        Diag(ELoc, diag::err_omp_wrong_dsa)
+            << getOpenMPClauseName(Kind) << getOpenMPClauseName(OMPC_reduction);
+      } else {
+        Diag(ELoc, diag::err_omp_dsa_with_directives)
+            << getOpenMPClauseName(Kind) << getOpenMPDirectiveName(DKind)
+            << getOpenMPClauseName(OMPC_reduction)
+            << getOpenMPDirectiveName(CurrDir);
+      }
+      if (PrevRef) {
+        Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+            << getOpenMPClauseName(Kind);
       }
+      continue;
     }
 
-    CXXRecordDecl *RD = getLangOpts().CPlusPlus
-                            ? Type.getNonReferenceType()->getAsCXXRecordDecl()
-                            : nullptr;
-    // FIXME This code must be replaced by actual constructing/destructing of
-    // the reduction variable.
-    if (RD) {
-      CXXConstructorDecl *CD = LookupDefaultConstructor(RD);
-      PartialDiagnostic PD =
-          PartialDiagnostic(PartialDiagnostic::NullDiagnostic());
-      if (!CD ||
-          CheckConstructorAccess(ELoc, CD,
-                                 InitializedEntity::InitializeTemporary(Type),
-                                 CD->getAccess(), PD) == AR_inaccessible ||
-          CD->isDeleted()) {
-        Diag(ELoc, diag::err_omp_required_method)
-            << getOpenMPClauseName(OMPC_reduction) << 0;
+    QualType RedTy = DE->getType().getUnqualifiedType();
+    OMPDeclareReductionDecl::ReductionData *DRRD =
+        TryToFindDeclareReductionDecl(*this, SS, OpName, RedTy, Op);
+    if (Op == OMPC_REDUCTION_custom && !DRRD) {
+      RedDeclFilterCCC CCC(*this, RedTy);
+      LookupResult Lookup(*this, OpName, LookupOMPDeclareReduction);
+      if (DiagnoseEmptyLookup(getCurScope(), SS, Lookup, CCC))
+        continue;
+      DRRD = CCC.getFoundData();
+      if (!DRRD)
+        continue;
+    }
+    if (DRRD) {
+      Op = OMPC_REDUCTION_custom;
+      QualType PtrQTy = Context.getPointerType(DE->getType());
+      TypeSourceInfo *TI =
+          Context.getTrivialTypeSourceInfo(PtrQTy, SourceLocation());
+      IdentifierInfo *Id1 = &Context.Idents.get(".ptr1.");
+      VarDecl *Parameter1 = VarDecl::Create(
+          Context, Context.getTranslationUnitDecl(), SourceLocation(),
+          SourceLocation(), Id1, PtrQTy, TI, SC_Static);
+      Parameter1->setImplicit();
+      Parameter1->addAttr(new (Context)
+                              UnusedAttr(SourceLocation(), Context, 0));
+      IdentifierInfo *Id2 = &Context.Idents.get(".ptr2.");
+      VarDecl *Parameter2 = VarDecl::Create(
+          Context, Context.getTranslationUnitDecl(), SourceLocation(),
+          SourceLocation(), Id2, PtrQTy, TI, SC_Static);
+      Parameter2->setImplicit();
+      Parameter2->addAttr(new (Context)
+                              UnusedAttr(SourceLocation(), Context, 0));
+      Context.getTranslationUnitDecl()->addHiddenDecl(Parameter1);
+      Context.getTranslationUnitDecl()->addHiddenDecl(Parameter2);
+      ExprResult PtrDE1 =
+          BuildDeclRefExpr(Parameter1, PtrQTy, VK_LValue, SourceLocation());
+      ExprResult PtrDE2 =
+          BuildDeclRefExpr(Parameter2, PtrQTy, VK_LValue, SourceLocation());
+      Expr *PtrDE1Expr = PtrDE1.get();
+      Expr *PtrDE2Expr = PtrDE2.get();
+      ExprResult DE1 = DefaultLvalueConversion(PtrDE1Expr);
+      ExprResult DE2 = DefaultLvalueConversion(PtrDE2Expr);
+      Expr *Args[] = {DE1.get(), DE2.get()};
+      ExprResult Res =
+          ActOnCallExpr(DSAStack->getCurScope(), DRRD->CombinerFunction, ELoc,
+                        Args, SourceLocation());
+      if (Res.isInvalid())
+        continue;
+
+      DefaultInits.push_back(DRRD->InitFunction);
+      Vars.push_back(DE);
+      OpExprs.push_back(Res.get());
+      HelperParams1.push_back(PtrDE1Expr);
+      HelperParams2.push_back(PtrDE2Expr);
+    } else {
+      if ((Op == OMPC_REDUCTION_bitor || Op == OMPC_REDUCTION_bitand ||
+           Op == OMPC_REDUCTION_bitxor) &&
+          Type->isFloatingType()) {
+        Diag(ELoc, diag::err_omp_clause_floating_type_arg);
         bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
                       VarDecl::DeclarationOnly;
         Diag(VD->getLocation(),
              IsDecl ? diag::note_previous_decl : diag::note_defined_here)
             << VD;
-        Diag(RD->getLocation(), diag::note_previous_decl) << RD;
         continue;
       }
-      MarkFunctionReferenced(ELoc, CD);
-      DiagnoseUseOfDecl(CD, ELoc);
-
-      CXXDestructorDecl *DD = RD->getDestructor();
-      if (DD) {
-        if (CheckDestructorAccess(ELoc, DD, PD) == AR_inaccessible ||
-            DD->isDeleted()) {
+      QualType PtrQTy = Context.getPointerType(DE->getType());
+      TypeSourceInfo *TI =
+          Context.getTrivialTypeSourceInfo(PtrQTy, SourceLocation());
+      IdentifierInfo *Id1 = &Context.Idents.get(".ptr1.");
+      VarDecl *Parameter1 = VarDecl::Create(
+          Context, Context.getTranslationUnitDecl(), SourceLocation(),
+          SourceLocation(), Id1, PtrQTy, TI, SC_Static);
+      Parameter1->setImplicit();
+      Parameter1->addAttr(new (Context)
+                              UnusedAttr(SourceLocation(), Context, 0));
+      IdentifierInfo *Id2 = &Context.Idents.get(".ptr2.");
+      VarDecl *Parameter2 = VarDecl::Create(
+          Context, Context.getTranslationUnitDecl(), SourceLocation(),
+          SourceLocation(), Id2, PtrQTy, TI, SC_Static);
+      Parameter2->setImplicit();
+      Parameter2->addAttr(new (Context)
+                              UnusedAttr(SourceLocation(), Context, 0));
+      Context.getTranslationUnitDecl()->addHiddenDecl(Parameter1);
+      Context.getTranslationUnitDecl()->addHiddenDecl(Parameter2);
+      ExprResult PtrDE1 =
+          BuildDeclRefExpr(Parameter1, PtrQTy, VK_LValue, SourceLocation());
+      ExprResult PtrDE2 =
+          BuildDeclRefExpr(Parameter2, PtrQTy, VK_LValue, SourceLocation());
+      Expr *PtrDE1Expr = PtrDE1.get();
+      Expr *PtrDE2Expr = PtrDE2.get();
+      ExprResult DE1 = DefaultLvalueConversion(PtrDE1Expr);
+      ExprResult DE2 = DefaultLvalueConversion(PtrDE2Expr);
+      DE1 = CreateBuiltinUnaryOp(ELoc, UO_Deref, DE1.get());
+      DE2 = CreateBuiltinUnaryOp(ELoc, UO_Deref, DE2.get());
+      if (NewOp == BO_SubAssign) {
+        NewOp = BO_AddAssign;
+      }
+      ExprResult Res = BuildBinOp(DSAStack->getCurScope(), ELoc, NewOp,
+                                  DE1.get(), DE2.get());
+      if (Res.isInvalid())
+        continue;
+      CXXRecordDecl *RD = Type->getAsCXXRecordDecl();
+      if (RD) {
+        CXXConstructorDecl *CD = LookupDefaultConstructor(RD);
+        PartialDiagnostic PD =
+            PartialDiagnostic(PartialDiagnostic::NullDiagnostic());
+        if (!CD ||
+            CheckConstructorAccess(ELoc, CD,
+                                   InitializedEntity::InitializeTemporary(Type),
+                                   CD->getAccess(), PD) == AR_inaccessible ||
+            CD->isDeleted()) {
+          Diag(ELoc, diag::err_omp_required_method)
+              << getOpenMPClauseName(OMPC_reduction) << 0;
+          bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
+                        VarDecl::DeclarationOnly;
+          Diag(VD->getLocation(),
+               IsDecl ? diag::note_previous_decl : diag::note_defined_here)
+              << VD;
+          Diag(RD->getLocation(), diag::note_previous_decl) << RD;
+          continue;
+        }
+        MarkFunctionReferenced(ELoc, CD);
+        DiagnoseUseOfDecl(CD, ELoc);
+        CXXDestructorDecl *DD = RD->getDestructor();
+        if (DD && (CheckDestructorAccess(ELoc, DD, PD) == AR_inaccessible ||
+                   DD->isDeleted())) {
           Diag(ELoc, diag::err_omp_required_method)
               << getOpenMPClauseName(OMPC_reduction) << 4;
           bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
@@ -3682,421 +6708,1747 @@
               << VD;
           Diag(RD->getLocation(), diag::note_previous_decl) << RD;
           continue;
+        } else if (DD) {
+          MarkFunctionReferenced(ELoc, DD);
+          DiagnoseUseOfDecl(DD, ELoc);
         }
-        MarkFunctionReferenced(ELoc, DD);
-        DiagnoseUseOfDecl(DD, ELoc);
       }
-    }
+      if (NewOp == BO_LAnd || NewOp == BO_LOr) {
+        Res = BuildBinOp(DSAStack->getCurScope(), ELoc, BO_Assign, DE1.get(),
+                         Res.get());
+      } else if (NewOp == BO_LT || NewOp == BO_GT) {
+        Res = ActOnConditionalOp(ELoc, ELoc, Res.get(), DE1.get(), DE2.get());
+        if (Res.isInvalid())
+          continue;
+        Res = BuildBinOp(DSAStack->getCurScope(), ELoc, BO_Assign, DE1.get(),
+                         Res.get());
+      }
+      if (Res.isInvalid())
+        continue;
+      Res = IgnoredValueConversions(Res.get());
 
+      Type = Type.getUnqualifiedType();
+      if (RD) {
+        IdentifierInfo *Id = &Context.Idents.get(".firstprivate.");
+        TypeSourceInfo *TI1 = Context.getTrivialTypeSourceInfo(Type, ELoc);
+        VarDecl *PseudoVar = VarDecl::Create(
+            Context, Context.getTranslationUnitDecl(), SourceLocation(),
+            SourceLocation(), Id, Type, TI1, SC_Static);
+        PseudoVar->setImplicit();
+        PseudoVar->addAttr(new (Context)
+                               UnusedAttr(SourceLocation(), Context, 0));
+        InitializedEntity Entity =
+            InitializedEntity::InitializeVariable(PseudoVar);
+        InitializationKind InitKind = InitializationKind::CreateDefault(ELoc);
+        InitializationSequence InitSeq(*this, Entity, InitKind, MultiExprArg());
+        ExprResult CPRes =
+            InitSeq.Perform(*this, Entity, InitKind, MultiExprArg());
+        if (CPRes.isInvalid())
+          continue;
+        DefaultInits.push_back(ActOnFinishFullExpr(CPRes.get()).get());
+      } else {
+        DefaultInits.push_back(0);
+      }
+      Vars.push_back(DE);
+      OpExprs.push_back(ActOnFinishFullExpr(Res.get()).get());
+      HelperParams1.push_back(PtrDE1Expr);
+      HelperParams2.push_back(PtrDE2Expr);
+    }
     DSAStack->addDSA(VD, DE, OMPC_reduction);
-    Vars.push_back(DE);
   }
 
   if (Vars.empty())
-    return nullptr;
+    return 0;
 
   return OMPReductionClause::Create(
-      Context, StartLoc, LParenLoc, ColonLoc, EndLoc, Vars,
-      ReductionIdScopeSpec.getWithLocInContext(Context), ReductionId);
+      Context, StartLoc, EndLoc, Vars, OpExprs, HelperParams1, HelperParams2,
+      DefaultInits, Op, SS.getWithLocInContext(Context), OpName);
+}
+
+namespace {
+class ArrayItemChecker : public StmtVisitor<ArrayItemChecker, bool> {
+private:
+  Sema &SemaRef;
+  Expr *End;
+
+public:
+  bool VisitDeclRefExpr(DeclRefExpr *E) {
+    if (isa<VarDecl>(E->getDecl())) {
+      End = E;
+      return false;
+    }
+    return true;
+  }
+  bool VisitArraySubscriptExpr(ArraySubscriptExpr *E) {
+    Expr *Base = E->getBase()->IgnoreImplicit();
+    bool Result = Visit(Base);
+    if (!End)
+      return Result;
+    if (CEANIndexExpr *CIE = dyn_cast_or_null<CEANIndexExpr>(E->getIdx())) {
+      llvm::APSInt Value;
+      // OpenMP [2.11.1.1, Restrictions]
+      //  List items used in dependent clauses cannot be zero-length array
+      //  sections.
+      if (CIE->getLength()->EvaluateAsInt(Value, SemaRef.getASTContext()) &&
+          ((Value.isSigned() && Value.isNegative()) || !Value)) {
+        SemaRef.Diag(CIE->getExprLoc(),
+                     diag::err_omp_array_section_length_not_greater_zero)
+            << CIE->getSourceRange();
+        End = 0;
+        return Result;
+      }
+      ExprResult Idx = SemaRef.CreateBuiltinBinOp(
+          E->getExprLoc(), BO_Add, CIE->getLowerBound(), CIE->getLength());
+      if (Idx.isInvalid()) {
+        End = 0;
+        return Result;
+      }
+      Idx = SemaRef.CreateBuiltinBinOp(
+          E->getExprLoc(), BO_Sub, Idx.get(),
+          SemaRef.ActOnIntegerConstant(SourceLocation(), 1).get());
+      if (Idx.isInvalid()) {
+        End = 0;
+        return Result;
+      }
+      End = SemaRef.CreateBuiltinArraySubscriptExpr(
+                        End, E->getExprLoc(), Idx.get(), E->getExprLoc()).get();
+      CIE->setIndexExpr(CIE->getLowerBound());
+    } else if (End != Base) {
+      End = SemaRef.CreateBuiltinArraySubscriptExpr(End, E->getExprLoc(),
+                                                    E->getIdx(),
+                                                    E->getExprLoc()).get();
+    } else {
+      End = E;
+    }
+    return Result;
+  }
+  bool VisitStmt(Stmt *S) { return true; }
+
+  ArrayItemChecker(Sema &SemaRef) : SemaRef(SemaRef), End(0) {}
+
+  std::pair<Expr *, Expr *> CalculateSize(Expr *Begin) {
+    if (!Begin)
+      return std::make_pair<Expr *, Expr *>(0, 0);
+    QualType CharPtrTy =
+        SemaRef.getASTContext().getPointerType(SemaRef.getASTContext().CharTy);
+    if (!End || Begin == End) {
+      Expr *Size;
+      {
+        EnterExpressionEvaluationContext Unevaluated(
+            SemaRef, Sema::Unevaluated, Sema::ReuseLambdaContextDecl);
+
+        Size = SemaRef.CreateUnaryExprOrTypeTraitExpr(Begin, SourceLocation(),
+                                                      UETT_SizeOf).get();
+      }
+      ExprResult AddrBegin =
+          SemaRef.CreateBuiltinUnaryOp(Begin->getExprLoc(), UO_AddrOf, Begin);
+      if (AddrBegin.isInvalid())
+        return std::make_pair<Expr *, Expr *>(0, 0);
+      AddrBegin =
+          SemaRef.ImpCastExprToType(AddrBegin.get(), CharPtrTy, CK_BitCast);
+      if (AddrBegin.isInvalid())
+        return std::make_pair<Expr *, Expr *>(0, 0);
+      Expr *AB = SemaRef.DefaultLvalueConversion(AddrBegin.get()).get();
+      return std::make_pair(AB, Size);
+    }
+
+    ExprResult AddrEnd =
+        SemaRef.CreateBuiltinUnaryOp(End->getExprLoc(), UO_AddrOf, End);
+    if (AddrEnd.isInvalid())
+      return std::make_pair<Expr *, Expr *>(0, 0);
+    AddrEnd = SemaRef.CreateBuiltinBinOp(
+        End->getExprLoc(), BO_Add, AddrEnd.get(),
+        SemaRef.ActOnIntegerConstant(SourceLocation(), 1).get());
+    if (AddrEnd.isInvalid())
+      return std::make_pair<Expr *, Expr *>(0, 0);
+    ExprResult AddrBegin =
+        SemaRef.CreateBuiltinUnaryOp(Begin->getExprLoc(), UO_AddrOf, Begin);
+    if (AddrBegin.isInvalid())
+      return std::make_pair<Expr *, Expr *>(0, 0);
+    Expr *AE = SemaRef.DefaultLvalueConversion(AddrEnd.get()).get();
+    Expr *AB = SemaRef.DefaultLvalueConversion(AddrBegin.get()).get();
+    return std::make_pair(AB, AE);
+  }
+};
 }
 
-OMPClause *Sema::ActOnOpenMPLinearClause(ArrayRef<Expr *> VarList, Expr *Step,
+OMPClause *Sema::ActOnOpenMPDependClause(ArrayRef<Expr *> VarList,
                                          SourceLocation StartLoc,
-                                         SourceLocation LParenLoc,
-                                         SourceLocation ColonLoc,
-                                         SourceLocation EndLoc) {
-  SmallVector<Expr *, 8> Vars;
-  for (auto &RefExpr : VarList) {
-    assert(RefExpr && "NULL expr in OpenMP linear clause.");
-    if (isa<DependentScopeDeclRefExpr>(RefExpr)) {
+                                         SourceLocation EndLoc,
+                                         OpenMPDependClauseType Ty,
+                                         SourceLocation TyLoc) {
+  SmallVector<Expr *, 4> Vars;
+  SmallVector<Expr *, 4> Begins;
+  SmallVector<Expr *, 4> SizeInBytes;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    assert(*I && "Null expr in omp depend");
+    if ((*I)->isValueDependent() || (*I)->isTypeDependent() ||
+        (*I)->isInstantiationDependent()) {
       // It will be analyzed later.
-      Vars.push_back(RefExpr);
+      Vars.push_back(*I);
+      Begins.push_back(0);
+      SizeInBytes.push_back(0);
       continue;
     }
 
-    // OpenMP [2.14.3.7, linear clause]
-    // A list item that appears in a linear clause is subject to the private
-    // clause semantics described in Section 2.14.3.3 on page 159 except as
-    // noted. In addition, the value of the new list item on each iteration
-    // of the associated loop(s) corresponds to the value of the original
-    // list item before entering the construct plus the logical number of
-    // the iteration times linear-step.
+    SourceLocation ELoc = (*I)->getExprLoc();
 
-    SourceLocation ELoc = RefExpr->getExprLoc();
-    // OpenMP [2.1, C/C++]
-    //  A list item is a variable name.
-    // OpenMP  [2.14.3.3, Restrictions, p.1]
+    // OpenMP [2.11.1.1, Restrictions]
+    //  A variable that is part of another variable (such as field of a
+    //  structure) but is not an array element or an array section cannot appear
+    //  in a depend clause.
+    // OpenMP  [2.9.3.3, Restrictions, p.1]
     //  A variable that is part of another variable (as an array or
     //  structure element) cannot appear in a private clause.
-    DeclRefExpr *DE = dyn_cast<DeclRefExpr>(RefExpr);
-    if (!DE || !isa<VarDecl>(DE->getDecl())) {
-      Diag(ELoc, diag::err_omp_expected_var_name) << RefExpr->getSourceRange();
+    Expr *VE = (*I)->IgnoreParenLValueCasts();
+
+    if (VE->isRValue()) {
+      Diag(ELoc, diag::err_omp_depend_arg_not_lvalue) << (*I)->getSourceRange();
       continue;
     }
 
-    VarDecl *VD = cast<VarDecl>(DE->getDecl());
+    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(VE);
+    ArraySubscriptExpr *ASE = dyn_cast_or_null<ArraySubscriptExpr>(VE);
+    ArrayItemChecker Checker(*this);
+    if ((!DE || !isa<VarDecl>(DE->getDecl())) && (!ASE || Checker.Visit(ASE))) {
+      Diag(ELoc, diag::err_omp_expected_var_name_or_array_item)
+          << (*I)->getSourceRange();
+      continue;
+    }
 
-    // OpenMP [2.14.3.7, linear clause]
-    //  A list-item cannot appear in more than one linear clause.
-    //  A list-item that appears in a linear clause cannot appear in any
-    //  other data-sharing attribute clause.
-    DSAStackTy::DSAVarData DVar = DSAStack->getTopDSA(VD, false);
-    if (DVar.RefExpr) {
-      Diag(ELoc, diag::err_omp_wrong_dsa) << getOpenMPClauseName(DVar.CKind)
-                                          << getOpenMPClauseName(OMPC_linear);
-      ReportOriginalDSA(*this, DSAStack, VD, DVar);
+    std::pair<Expr *, Expr *> BeginSize = Checker.CalculateSize(VE);
+    if (!BeginSize.first || !BeginSize.second)
       continue;
+
+    Vars.push_back(VE);
+    Begins.push_back(BeginSize.first);
+    SizeInBytes.push_back(BeginSize.second);
+  }
+
+  if (Vars.empty() || Vars.size() != Begins.size())
+    return 0;
+  return OMPDependClause::Create(Context, StartLoc, EndLoc, Vars, Begins,
+                                 SizeInBytes, Ty, TyLoc);
+}
+
+namespace {
+class MapArrayItemChecker : public StmtVisitor<MapArrayItemChecker, bool> {
+private:
+  Sema &SemaRef;
+  Expr *CopyBegin;
+  Expr *CopyEnd;
+  Expr *WholeBegin;
+  Expr *WholeEnd;
+  VarDecl *VD;
+  DeclRefExpr *DRE;
+  bool IsCEAN;
+
+  std::pair<Expr *, Expr *> CalculateSize(Expr *Begin, Expr *End) {
+    if (!Begin || !End)
+      return std::make_pair<Expr *, Expr *>(0, 0);
+    QualType CharPtrTy =
+        SemaRef.getASTContext().getPointerType(SemaRef.getASTContext().CharTy);
+    if (Begin == End) {
+      Expr *Size;
+      {
+        EnterExpressionEvaluationContext Unevaluated(
+            SemaRef, Sema::Unevaluated, Sema::ReuseLambdaContextDecl);
+
+        Size = SemaRef.CreateUnaryExprOrTypeTraitExpr(Begin, SourceLocation(),
+                                                      UETT_SizeOf).get();
+      }
+      ExprResult AddrBegin =
+          SemaRef.CreateBuiltinUnaryOp(Begin->getExprLoc(), UO_AddrOf, Begin);
+      if (AddrBegin.isInvalid())
+        return std::make_pair<Expr *, Expr *>(0, 0);
+      AddrBegin =
+          SemaRef.ImpCastExprToType(AddrBegin.get(), CharPtrTy, CK_BitCast);
+      if (AddrBegin.isInvalid())
+        return std::make_pair<Expr *, Expr *>(0, 0);
+      Expr *AB = SemaRef.DefaultLvalueConversion(AddrBegin.get()).get();
+      return std::make_pair(AB, Size);
+    }
+
+    ExprResult AddrEnd =
+        SemaRef.CreateBuiltinUnaryOp(End->getExprLoc(), UO_AddrOf, End);
+    if (AddrEnd.isInvalid())
+      return std::make_pair<Expr *, Expr *>(0, 0);
+    AddrEnd = SemaRef.CreateBuiltinBinOp(
+        End->getExprLoc(), BO_Add, AddrEnd.get(),
+        SemaRef.ActOnIntegerConstant(SourceLocation(), 1).get());
+    if (AddrEnd.isInvalid())
+      return std::make_pair<Expr *, Expr *>(0, 0);
+    ExprResult AddrBegin =
+        SemaRef.CreateBuiltinUnaryOp(Begin->getExprLoc(), UO_AddrOf, Begin);
+    if (AddrBegin.isInvalid())
+      return std::make_pair<Expr *, Expr *>(0, 0);
+    Expr *AE = SemaRef.DefaultLvalueConversion(AddrEnd.get()).get();
+    Expr *AB = SemaRef.DefaultLvalueConversion(AddrBegin.get()).get();
+    return std::make_pair(AB, AE);
+  }
+
+public:
+  bool VisitDeclRefExpr(DeclRefExpr *E) {
+    if (isa<VarDecl>(E->getDecl())) {
+      CopyBegin = CopyEnd = E;
+      WholeBegin = WholeEnd = E;
+      VD = cast<VarDecl>(E->getDecl());
+      DRE = E;
+      return false;
     }
+    return true;
+  }
+  bool VisitArraySubscriptExpr(ArraySubscriptExpr *E) {
+    Expr *Base = E->getBase()->IgnoreImplicit();
+    bool Result = Visit(Base);
+    if (!CopyEnd || !CopyBegin)
+      return Result;
+    if (!WholeEnd || !WholeBegin)
+      return Result;
+    WholeBegin =
+        SemaRef.CreateBuiltinArraySubscriptExpr(
+                    WholeBegin, E->getExprLoc(),
+                    SemaRef.ActOnIntegerConstant(SourceLocation(), 0).get(),
+                    E->getExprLoc()).get();
+    QualType QTy = Base->getType();
+    Expr *Idx = 0;
+    if (const ArrayType *AT = QTy->getAsArrayTypeUnsafe()) {
+      if (const ConstantArrayType *CAT = dyn_cast<ConstantArrayType>(AT)) {
+        Idx = SemaRef.ActOnIntegerConstant(
+                          SourceLocation(),
+                          (CAT->getSize() - 1).getLimitedValue()).get();
+      } else if (const VariableArrayType *VAT =
+                     dyn_cast<VariableArrayType>(AT)) {
+        Idx = VAT->getSizeExpr();
+        Idx = SemaRef.CreateBuiltinBinOp(E->getExprLoc(), BO_Sub, Idx,
+                                         SemaRef.ActOnIntegerConstant(
+                                                     SourceLocation(), 1).get())
+                  .get();
+      } else if (const DependentSizedArrayType *DSAT =
+                     dyn_cast<DependentSizedArrayType>(AT)) {
+        Idx = DSAT->getSizeExpr();
+        Idx = SemaRef.CreateBuiltinBinOp(E->getExprLoc(), BO_Sub, Idx,
+                                         SemaRef.ActOnIntegerConstant(
+                                                     SourceLocation(), 1).get())
+                  .get();
+      }
+    }
+    Expr *LastIdx = 0;
+    if (CEANIndexExpr *CIE = dyn_cast_or_null<CEANIndexExpr>(E->getIdx())) {
+      IsCEAN = true;
+      LastIdx = SemaRef.CreateBuiltinBinOp(E->getExprLoc(), BO_Add,
+                                           CIE->getLowerBound(),
+                                           CIE->getLength()).get();
+      if (LastIdx == 0) {
+        CopyBegin = CopyEnd = 0;
+        WholeBegin = WholeEnd = 0;
+        return Result;
+      }
+      LastIdx = SemaRef.CreateBuiltinBinOp(
+                            E->getExprLoc(), BO_Sub, LastIdx,
+                            SemaRef.ActOnIntegerConstant(SourceLocation(), 1)
+                                .get()).get();
+      CopyBegin = SemaRef.CreateBuiltinArraySubscriptExpr(
+                              CopyBegin, E->getExprLoc(), CIE->getLowerBound(),
+                              E->getExprLoc()).get();
+    } else {
+      LastIdx = E->getIdx();
+      CopyBegin = SemaRef.CreateBuiltinArraySubscriptExpr(
+                              CopyBegin, E->getExprLoc(), LastIdx,
+                              E->getExprLoc()).get();
+    }
+    CopyEnd =
+        SemaRef.CreateBuiltinArraySubscriptExpr(CopyEnd, E->getExprLoc(),
+                                                LastIdx, E->getExprLoc()).get();
+    if (Idx == 0) {
+      Idx = LastIdx;
+    }
+    if (Idx == 0) {
+      CopyBegin = CopyEnd = 0;
+      WholeBegin = WholeEnd = 0;
+      return Result;
+    }
+    WholeEnd =
+        SemaRef.CreateBuiltinArraySubscriptExpr(WholeEnd, E->getExprLoc(), Idx,
+                                                E->getExprLoc()).get();
+    return Result;
+  }
+  bool VisitStmt(Stmt *S) { return true; }
+
+  MapArrayItemChecker(Sema &SemaRef)
+      : SemaRef(SemaRef), CopyBegin(0), CopyEnd(0), WholeBegin(0), WholeEnd(0),
+        VD(0), DRE(0), IsCEAN(false) {}
+
+  VarDecl *getBaseDecl() { return VD; }
+  DeclRefExpr *getDeclRefExprForBaseDecl() { return DRE; }
+  bool IsCEANExpr() const { return IsCEAN; }
+
+  std::pair<Expr *, Expr *> CalculateCopySize() {
+    return CalculateSize(CopyBegin, CopyEnd);
+  }
+  std::pair<Expr *, Expr *> CalculateWholeSize() {
+    return CalculateSize(WholeBegin, WholeEnd);
+  }
+};
+}
 
-    QualType QType = VD->getType();
-    if (QType->isDependentType() || QType->isInstantiationDependentType()) {
+OMPClause *Sema::ActOnOpenMPMapClause(ArrayRef<Expr *> VarList,
+                                      SourceLocation StartLoc,
+                                      SourceLocation EndLoc,
+                                      OpenMPMapClauseKind Kind,
+                                      SourceLocation KindLoc) {
+  SmallVector<Expr *, 4> Vars;
+  SmallVector<Expr *, 4> WholeBegins;
+  SmallVector<Expr *, 4> WholeEnds;
+  SmallVector<Expr *, 4> CopyBegins;
+  SmallVector<Expr *, 4> CopyEnds;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    assert(*I && "Null expr in omp map");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
       // It will be analyzed later.
-      Vars.push_back(DE);
+      Vars.push_back(*I);
+      WholeBegins.push_back(0);
+      WholeEnds.push_back(0);
+      CopyBegins.push_back(0);
+      CopyEnds.push_back(0);
       continue;
     }
 
-    // A variable must not have an incomplete type or a reference type.
-    if (RequireCompleteType(ELoc, QType,
-                            diag::err_omp_linear_incomplete_type)) {
+    SourceLocation ELoc = (*I)->getExprLoc();
+
+    // OpenMP [2.14.5, Restrictions]
+    //  A variable that is part of another variable (such as field of a
+    //  structure) but is not an array element or an array section cannot appear
+    //  in a map clause.
+    Expr *VE = (*I)->IgnoreParenLValueCasts();
+
+    if (VE->isValueDependent() || VE->isTypeDependent() ||
+        VE->isInstantiationDependent() ||
+        VE->containsUnexpandedParameterPack()) {
+      // It will be analyzed later.
+      Vars.push_back(*I);
+      WholeBegins.push_back(0);
+      WholeEnds.push_back(0);
+      CopyBegins.push_back(0);
+      CopyEnds.push_back(0);
+      continue;
+    }
+
+    MapArrayItemChecker Checker(*this);
+    VarDecl *VD = 0;
+    DeclRefExpr *DE = 0;
+    if (Checker.Visit(VE) || !(VD = Checker.getBaseDecl()) ||
+        !(DE = Checker.getDeclRefExprForBaseDecl())) {
+      Diag(ELoc, diag::err_omp_expected_var_name_or_array_item)
+          << (*I)->getSourceRange();
+      continue;
+    }
+
+    // OpenMP [2.14.5, Restrictions, p.8]
+    // threadprivate variables cannot appear in a map clause.
+    DeclRefExpr *DRE = 0;
+    if (DSAStack->IsThreadprivate(VD, DRE)) {
+      SourceLocation Loc = DRE ? DRE->getLocation() : VD->getLocation();
+      Diag(Loc, diag::err_omp_threadprivate_in_target);
+      Diag(DE->getLocStart(), diag::note_used_here) << DE->getSourceRange();
+      continue;
+    }
+
+    // OpenMP [2.14.5, map Clause]
+    //  If a corresponding list item of the original list item is in the
+    //  enclosing device data environment, the new device data environment uses
+    //  the corresponding list item from the enclosing device data environment.
+    //  No additional storage is allocated in the new device data environment
+    //  and neither initialization nor assignment is performed, regardless of
+    //  the map-type that is specified.
+    if (DSAStack->isDeclareTargetDecl(VD)) {
+      // Use original variable.
+      continue;
+    }
+    // OpenMP [2.14.5, Restrictions, p.2]
+    //  At most one list item can be an array item derived from a given variable
+    //  in map clauses of the same construct.
+    // OpenMP [2.14.5, Restrictions, p.3]
+    //  List items of map clauses in the same construct must not share original
+    //  storage.
+    // OpenMP [2.14.5, Restrictions, C/C++, p.2]
+    //  A variable for which the type is pointer, reference to array, or
+    //  reference to pointer and an array section derived from that variable
+    //  must not appear as list items of map clauses of the same construct.
+    DSAStackTy::MapInfo MI = DSAStack->IsMappedInCurrentRegion(VD);
+    if (MI.RefExpr) {
+      Diag(DE->getExprLoc(), diag::err_omp_map_shared_storage)
+          << DE->getSourceRange();
+      Diag(MI.RefExpr->getExprLoc(), diag::note_used_here)
+          << MI.RefExpr->getSourceRange();
+      continue;
+    }
+
+    // OpenMP [2.14.5, Restrictions, C/C++, p.3,4]
+    //  A variable for which the type is pointer, reference to array, or
+    //  reference to pointer must not appear as a list item if the enclosing
+    //  device data environment already contains an array section derived from
+    //  that variable.
+    //  An array section derived from a variable for which the type is pointer,
+    //  reference to array, or reference to pointer must not appear as a list
+    //  item if the enclosing device data environment already contains that
+    //  variable.
+    QualType Type = VD->getType();
+    MI = DSAStack->getMapInfoForVar(VD);
+    if (MI.RefExpr && (isa<DeclRefExpr>(MI.RefExpr->IgnoreParenLValueCasts()) !=
+                       isa<DeclRefExpr>(VE)) &&
+        (MI.IsCEAN || Checker.IsCEANExpr()) &&
+        (Type->isPointerType() || Type->isReferenceType())) {
+      Diag(DE->getExprLoc(), diag::err_omp_map_shared_storage)
+          << DE->getSourceRange();
+      Diag(MI.RefExpr->getExprLoc(), diag::note_used_here)
+          << MI.RefExpr->getSourceRange();
       continue;
     }
-    if (QType->isReferenceType()) {
-      Diag(ELoc, diag::err_omp_clause_ref_type_arg)
-          << getOpenMPClauseName(OMPC_linear) << QType;
-      bool IsDecl =
-          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
-      Diag(VD->getLocation(),
-           IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-          << VD;
+
+    // OpenMP [2.14.5, Restrictions, C/C++, p.7]
+    //  A list item must have a mappable type.
+    if (!CheckTypeMappable(VE->getExprLoc(), VE->getSourceRange(), *this,
+                           DSAStack, Type)) {
       continue;
     }
 
-    // A list item must not be const-qualified.
-    if (QType.isConstant(Context)) {
-      Diag(ELoc, diag::err_omp_const_variable)
-          << getOpenMPClauseName(OMPC_linear);
-      bool IsDecl =
-          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
-      Diag(VD->getLocation(),
-           IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-          << VD;
+    std::pair<Expr *, Expr *> WholeSize = Checker.CalculateWholeSize();
+    if (!WholeSize.first || !WholeSize.second) {
       continue;
     }
-
-    // A list item must be of integral or pointer type.
-    QType = QType.getUnqualifiedType().getCanonicalType();
-    const Type *Ty = QType.getTypePtrOrNull();
-    if (!Ty || (!Ty->isDependentType() && !Ty->isIntegralType(Context) &&
-                !Ty->isPointerType())) {
-      Diag(ELoc, diag::err_omp_linear_expected_int_or_ptr) << QType;
-      bool IsDecl =
-          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
-      Diag(VD->getLocation(),
-           IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-          << VD;
+    std::pair<Expr *, Expr *> CopySize = Checker.CalculateCopySize();
+    if (!CopySize.first || !CopySize.second) {
       continue;
     }
 
-    DSAStack->addDSA(VD, DE, OMPC_linear);
-    Vars.push_back(DE);
+    Vars.push_back(*I);
+    WholeBegins.push_back(WholeSize.first);
+    WholeEnds.push_back(WholeSize.second);
+    CopyBegins.push_back(CopySize.first);
+    CopyEnds.push_back(CopySize.second);
+    MI.RefExpr = *I;
+    MI.IsCEAN = Checker.IsCEANExpr();
+    DSAStack->addMapInfoForVar(VD, MI);
   }
 
   if (Vars.empty())
-    return nullptr;
+    return 0;
 
-  Expr *StepExpr = Step;
-  if (Step && !Step->isValueDependent() && !Step->isTypeDependent() &&
-      !Step->isInstantiationDependent() &&
-      !Step->containsUnexpandedParameterPack()) {
-    SourceLocation StepLoc = Step->getLocStart();
-    ExprResult Val = PerformOpenMPImplicitIntegerConversion(StepLoc, Step);
-    if (Val.isInvalid())
-      return nullptr;
-    StepExpr = Val.get();
+  return OMPMapClause::Create(Context, StartLoc, EndLoc, Vars, WholeBegins,
+                              WholeEnds, CopyBegins, CopyEnds, Kind, KindLoc);
+}
 
-    // Warn about zero linear step (it would be probably better specified as
-    // making corresponding variables 'const').
-    llvm::APSInt Result;
-    if (StepExpr->isIntegerConstantExpr(Result, Context) &&
-        !Result.isNegative() && !Result.isStrictlyPositive())
-      Diag(StepLoc, diag::warn_omp_linear_step_zero) << Vars[0]
-                                                     << (Vars.size() > 1);
-  }
+OMPClause *Sema::ActOnOpenMPToClause(ArrayRef<Expr *> VarList,
+                                     SourceLocation StartLoc,
+                                     SourceLocation EndLoc) {
+  SmallVector<Expr *, 4> Vars;
+  SmallVector<Expr *, 4> WholeBegins;
+  SmallVector<Expr *, 4> WholeEnds;
+  SmallVector<Expr *, 4> CopyBegins;
+  SmallVector<Expr *, 4> CopyEnds;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    assert(*I && "Null expr in omp to");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
+      // It will be analyzed later.
+      Vars.push_back(*I);
+      WholeBegins.push_back(0);
+      WholeEnds.push_back(0);
+      CopyBegins.push_back(0);
+      CopyEnds.push_back(0);
+      continue;
+    }
 
-  return OMPLinearClause::Create(Context, StartLoc, LParenLoc, ColonLoc, EndLoc,
-                                 Vars, StepExpr);
-}
+    SourceLocation ELoc = (*I)->getExprLoc();
 
-OMPClause *Sema::ActOnOpenMPAlignedClause(
-    ArrayRef<Expr *> VarList, Expr *Alignment, SourceLocation StartLoc,
-    SourceLocation LParenLoc, SourceLocation ColonLoc, SourceLocation EndLoc) {
+    // OpenMP [2.9.3, Restrictions]
+    //  A variable that is part of another variable (such as field of a
+    //  structure) but is not an array element or an array section cannot appear
+    //  as a list item in a clause of a target update construct.
+    Expr *VE = (*I)->IgnoreParenLValueCasts();
 
-  SmallVector<Expr *, 8> Vars;
-  for (auto &RefExpr : VarList) {
-    assert(RefExpr && "NULL expr in OpenMP aligned clause.");
-    if (isa<DependentScopeDeclRefExpr>(RefExpr)) {
+    if (VE->isValueDependent() || VE->isTypeDependent() ||
+        VE->isInstantiationDependent() ||
+        VE->containsUnexpandedParameterPack()) {
       // It will be analyzed later.
-      Vars.push_back(RefExpr);
+      Vars.push_back(*I);
+      WholeBegins.push_back(0);
+      WholeEnds.push_back(0);
+      CopyBegins.push_back(0);
+      CopyEnds.push_back(0);
       continue;
     }
 
-    SourceLocation ELoc = RefExpr->getExprLoc();
-    // OpenMP [2.1, C/C++]
-    //  A list item is a variable name.
-    DeclRefExpr *DE = dyn_cast<DeclRefExpr>(RefExpr);
-    if (!DE || !isa<VarDecl>(DE->getDecl())) {
-      Diag(ELoc, diag::err_omp_expected_var_name) << RefExpr->getSourceRange();
+    MapArrayItemChecker Checker(*this);
+    VarDecl *VD = 0;
+    DeclRefExpr *DE = 0;
+    if (Checker.Visit(VE) || !(VD = Checker.getBaseDecl()) ||
+        !(DE = Checker.getDeclRefExprForBaseDecl())) {
+      Diag(ELoc, diag::err_omp_expected_var_name_or_array_item)
+          << (*I)->getSourceRange();
       continue;
     }
 
-    VarDecl *VD = cast<VarDecl>(DE->getDecl());
+    // threadprivate variables cannot appear in a map clause.
+    DeclRefExpr *DRE = 0;
+    if (DSAStack->IsThreadprivate(VD, DRE)) {
+      SourceLocation Loc = DRE ? DRE->getLocation() : VD->getLocation();
+      Diag(Loc, diag::err_omp_threadprivate_in_target);
+      Diag(DE->getLocStart(), diag::note_used_here) << DE->getSourceRange();
+      continue;
+    }
 
-    // OpenMP  [2.8.1, simd construct, Restrictions]
-    // The type of list items appearing in the aligned clause must be
-    // array, pointer, reference to array, or reference to pointer.
-    QualType QType = DE->getType()
-                         .getNonReferenceType()
-                         .getUnqualifiedType()
-                         .getCanonicalType();
-    const Type *Ty = QType.getTypePtrOrNull();
-    if (!Ty || (!Ty->isDependentType() && !Ty->isArrayType() &&
-                !Ty->isPointerType())) {
-      Diag(ELoc, diag::err_omp_aligned_expected_array_or_ptr)
-          << QType << getLangOpts().CPlusPlus << RefExpr->getSourceRange();
-      bool IsDecl =
-          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
-      Diag(VD->getLocation(),
-           IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-          << VD;
+    // OpenMP [2.9.3, Restrictions, p.6]
+    //  A list item in a to or from clause must have a mappable type.
+    QualType Type = VD->getType();
+    if (!CheckTypeMappable(VE->getExprLoc(), VE->getSourceRange(), *this,
+                           DSAStack, Type)) {
       continue;
     }
 
-    // OpenMP  [2.8.1, simd construct, Restrictions]
-    // A list-item cannot appear in more than one aligned clause.
-    if (DeclRefExpr *PrevRef = DSAStack->addUniqueAligned(VD, DE)) {
-      Diag(ELoc, diag::err_omp_aligned_twice) << RefExpr->getSourceRange();
-      Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
-          << getOpenMPClauseName(OMPC_aligned);
+    // OpenMP [2.9.3, Restrictions, p.6]
+    // A list item can only appear in a to or from clause, but not both.
+    DSAStackTy::MapInfo MI = DSAStack->IsMappedInCurrentRegion(VD);
+    if (MI.RefExpr) {
+      Diag(DE->getExprLoc(), diag::err_omp_once_referenced_in_target_update)
+          << DE->getSourceRange();
+      Diag(MI.RefExpr->getExprLoc(), diag::note_used_here)
+          << MI.RefExpr->getSourceRange();
       continue;
     }
 
-    Vars.push_back(DE);
+    std::pair<Expr *, Expr *> WholeSize = Checker.CalculateWholeSize();
+    if (!WholeSize.first || !WholeSize.second) {
+      continue;
+    }
+    std::pair<Expr *, Expr *> CopySize = Checker.CalculateCopySize();
+    if (!CopySize.first || !CopySize.second) {
+      continue;
+    }
+
+    Vars.push_back(*I);
+    WholeBegins.push_back(WholeSize.first);
+    WholeEnds.push_back(WholeSize.second);
+    CopyBegins.push_back(CopySize.first);
+    CopyEnds.push_back(CopySize.second);
+    MI.RefExpr = *I;
+    MI.IsCEAN = Checker.IsCEANExpr();
+    DSAStack->addMapInfoForVar(VD, MI);
   }
 
-  // OpenMP [2.8.1, simd construct, Description]
-  // The parameter of the aligned clause, alignment, must be a constant
-  // positive integer expression.
-  // If no optional parameter is specified, implementation-defined default
-  // alignments for SIMD instructions on the target platforms are assumed.
-  if (Alignment != nullptr) {
-    ExprResult AlignResult =
-        VerifyPositiveIntegerConstantInClause(Alignment, OMPC_aligned);
-    if (AlignResult.isInvalid())
-      return nullptr;
-    Alignment = AlignResult.get();
+  if (Vars.empty())
+    return 0;
+
+  return OMPToClause::Create(Context, StartLoc, EndLoc, Vars, WholeBegins,
+                             WholeEnds, CopyBegins, CopyEnds);
+}
+
+OMPClause *Sema::ActOnOpenMPFromClause(ArrayRef<Expr *> VarList,
+                                       SourceLocation StartLoc,
+                                       SourceLocation EndLoc) {
+  SmallVector<Expr *, 4> Vars;
+  SmallVector<Expr *, 4> WholeBegins;
+  SmallVector<Expr *, 4> WholeEnds;
+  SmallVector<Expr *, 4> CopyBegins;
+  SmallVector<Expr *, 4> CopyEnds;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    assert(*I && "Null expr in omp from");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
+      // It will be analyzed later.
+      Vars.push_back(*I);
+      WholeBegins.push_back(0);
+      WholeEnds.push_back(0);
+      CopyBegins.push_back(0);
+      CopyEnds.push_back(0);
+      continue;
+    }
+
+    SourceLocation ELoc = (*I)->getExprLoc();
+
+    // OpenMP [2.9.3, Restrictions]
+    //  A variable that is part of another variable (such as field of a
+    //  structure) but is not an array element or an array section cannot appear
+    //  as a list item in a clause of a target update construct.
+    Expr *VE = (*I)->IgnoreParenLValueCasts();
+
+    if (VE->isValueDependent() || VE->isTypeDependent() ||
+        VE->isInstantiationDependent() ||
+        VE->containsUnexpandedParameterPack()) {
+      // It will be analyzed later.
+      Vars.push_back(*I);
+      WholeBegins.push_back(0);
+      WholeEnds.push_back(0);
+      CopyBegins.push_back(0);
+      CopyEnds.push_back(0);
+      continue;
+    }
+
+    MapArrayItemChecker Checker(*this);
+    VarDecl *VD = 0;
+    DeclRefExpr *DE = 0;
+    if (Checker.Visit(VE) || !(VD = Checker.getBaseDecl()) ||
+        !(DE = Checker.getDeclRefExprForBaseDecl())) {
+      Diag(ELoc, diag::err_omp_expected_var_name_or_array_item)
+          << (*I)->getSourceRange();
+      continue;
+    }
+
+    // threadprivate variables cannot appear in a map clause.
+    DeclRefExpr *DRE = 0;
+    if (DSAStack->IsThreadprivate(VD, DRE)) {
+      SourceLocation Loc = DRE ? DRE->getLocation() : VD->getLocation();
+      Diag(Loc, diag::err_omp_threadprivate_in_target);
+      Diag(DE->getLocStart(), diag::note_used_here) << DE->getSourceRange();
+      continue;
+    }
+
+    // OpenMP [2.9.3, Restrictions, p.6]
+    //  A list item in a to or from clause must have a mappable type.
+    QualType Type = VD->getType();
+    if (!CheckTypeMappable(VE->getExprLoc(), VE->getSourceRange(), *this,
+                           DSAStack, Type)) {
+      continue;
+    }
+
+    // OpenMP [2.9.3, Restrictions, p.6]
+    // A list item can only appear in a to or from clause, but not both.
+    DSAStackTy::MapInfo MI = DSAStack->IsMappedInCurrentRegion(VD);
+    if (MI.RefExpr) {
+      Diag(DE->getExprLoc(), diag::err_omp_once_referenced_in_target_update)
+          << DE->getSourceRange();
+      Diag(MI.RefExpr->getExprLoc(), diag::note_used_here)
+          << MI.RefExpr->getSourceRange();
+      continue;
+    }
+
+    std::pair<Expr *, Expr *> WholeSize = Checker.CalculateWholeSize();
+    if (!WholeSize.first || !WholeSize.second) {
+      continue;
+    }
+    std::pair<Expr *, Expr *> CopySize = Checker.CalculateCopySize();
+    if (!CopySize.first || !CopySize.second) {
+      continue;
+    }
+
+    Vars.push_back(*I);
+    WholeBegins.push_back(WholeSize.first);
+    WholeEnds.push_back(WholeSize.second);
+    CopyBegins.push_back(CopySize.first);
+    CopyEnds.push_back(CopySize.second);
+    MI.RefExpr = *I;
+    MI.IsCEAN = Checker.IsCEANExpr();
+    DSAStack->addMapInfoForVar(VD, MI);
   }
+
   if (Vars.empty())
-    return nullptr;
+    return 0;
 
-  return OMPAlignedClause::Create(Context, StartLoc, LParenLoc, ColonLoc,
-                                  EndLoc, Vars, Alignment);
+  return OMPFromClause::Create(Context, StartLoc, EndLoc, Vars, WholeBegins,
+                               WholeEnds, CopyBegins, CopyEnds);
 }
 
-OMPClause *Sema::ActOnOpenMPCopyinClause(ArrayRef<Expr *> VarList,
+OMPClause *Sema::ActOnOpenMPLinearClause(ArrayRef<Expr *> VarList,
                                          SourceLocation StartLoc,
-                                         SourceLocation LParenLoc,
-                                         SourceLocation EndLoc) {
-  SmallVector<Expr *, 8> Vars;
-  for (auto &RefExpr : VarList) {
-    assert(RefExpr && "NULL expr in OpenMP copyin clause.");
-    if (isa<DependentScopeDeclRefExpr>(RefExpr)) {
+                                         SourceLocation EndLoc, Expr *Step,
+                                         SourceLocation StepLoc) {
+  // Checks that apply to both private and linear variables.
+  SmallVector<Expr *, 4> Vars;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+
+    assert(*I && "Null expr in omp linear");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
       // It will be analyzed later.
-      Vars.push_back(RefExpr);
+      Vars.push_back(*I);
       continue;
     }
 
-    SourceLocation ELoc = RefExpr->getExprLoc();
+    // OpenMP [2.14.3.7, linear clause]
+    // A list item that appears in a linear clause is subject to the private
+    // clause semantics described in Section 2.14.3.3 on page 159 except as
+    // noted. In addition, the value of the new list item on each iteration
+    // of the associated loop(s) corresponds to the value of the original
+    // list item before entering the construct plus the logical number of
+    // the iteration times linear-step.
+
+    SourceLocation ELoc = (*I)->getExprLoc();
     // OpenMP [2.1, C/C++]
     //  A list item is a variable name.
-    // OpenMP  [2.14.4.1, Restrictions, p.1]
-    //  A list item that appears in a copyin clause must be threadprivate.
-    DeclRefExpr *DE = dyn_cast<DeclRefExpr>(RefExpr);
+    // OpenMP  [2.14.3.3, Restrictions, p.1]
+    //  A variable that is part of another variable (as an array or
+    //  structure element) cannot appear in a private clause.
+    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(*I);
     if (!DE || !isa<VarDecl>(DE->getDecl())) {
-      Diag(ELoc, diag::err_omp_expected_var_name) << RefExpr->getSourceRange();
+      Diag(ELoc, diag::err_omp_expected_var_name) << (*I)->getSourceRange();
       continue;
     }
 
-    Decl *D = DE->getDecl();
-    VarDecl *VD = cast<VarDecl>(D);
+    VarDecl *VD = cast<VarDecl>(DE->getDecl());
+    // OpenMP [2.14.3.7, linear clause]
+    // - A list-item cannot appear in more than one linear clause.
+    // - A list-item that appears in a linear clause cannot appear in any
+    //   other data-sharing attribute clause.
+    DeclRefExpr *PrevRef;
+    OpenMPClauseKind Kind = DSAStack->getTopDSA(VD, PrevRef);
+    if (PrevRef && (Kind == OMPC_linear || Kind == OMPC_private ||
+                    Kind == OMPC_lastprivate || Kind == OMPC_reduction)) {
+      Diag(ELoc, diag::err_omp_wrong_dsa) << getOpenMPClauseName(Kind)
+                                          << getOpenMPClauseName(OMPC_linear);
+      Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+          << getOpenMPClauseName(Kind);
+      continue;
+    }
 
-    QualType Type = VD->getType();
-    if (Type->isDependentType() || Type->isInstantiationDependentType()) {
-      // It will be analyzed later.
-      Vars.push_back(DE);
+    //  A variable that appears in a private clause must not have an incomplete
+    //  type or a reference type.
+    QualType QTy = VD->getType().getCanonicalType();
+    if (RequireCompleteType(ELoc, QTy, diag::err_omp_linear_incomplete_type)) {
+      continue;
+    }
+    if (QTy->isReferenceType()) {
+      Diag(ELoc, diag::err_omp_clause_ref_type_arg)
+          << getOpenMPClauseName(OMPC_linear);
+      bool IsDecl =
+          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
+      Diag(VD->getLocation(),
+           IsDecl ? diag::note_previous_decl : diag::note_defined_here)
+          << VD;
       continue;
     }
 
-    // OpenMP [2.14.4.1, Restrictions, C/C++, p.1]
-    //  A list item that appears in a copyin clause must be threadprivate.
-    if (!DSAStack->isThreadPrivate(VD)) {
-      Diag(ELoc, diag::err_omp_required_access)
-          << getOpenMPClauseName(OMPC_copyin)
-          << getOpenMPDirectiveName(OMPD_threadprivate);
+    //  A list item that appears in a private clause must not be
+    //  const-qualified.
+    if (QTy.isConstant(Context)) {
+      Diag(ELoc, diag::err_omp_const_variable)
+          << getOpenMPClauseName(OMPC_linear);
+      bool IsDecl =
+          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;
+      Diag(VD->getLocation(),
+           IsDecl ? diag::note_previous_decl : diag::note_defined_here)
+          << VD;
       continue;
     }
 
-    // OpenMP [2.14.4.1, Restrictions, C/C++, p.2]
-    //  A variable of class type (or array thereof) that appears in a
-    //  copyin clause requires an accessible, unambiguous copy assignment
-    //  operator for the class type.
-    Type = Context.getBaseElementType(Type);
-    CXXRecordDecl *RD =
-        getLangOpts().CPlusPlus ? Type->getAsCXXRecordDecl() : nullptr;
-    // FIXME This code must be replaced by actual assignment of the
-    // threadprivate variable.
-    if (RD) {
-      CXXMethodDecl *MD = LookupCopyingAssignment(RD, 0, false, 0);
-      DeclAccessPair FoundDecl = DeclAccessPair::make(MD, MD->getAccess());
-      if (MD) {
-        if (CheckMemberAccess(ELoc, RD, FoundDecl) == AR_inaccessible ||
-            MD->isDeleted()) {
-          Diag(ELoc, diag::err_omp_required_method)
-              << getOpenMPClauseName(OMPC_copyin) << 2;
-          bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
-                        VarDecl::DeclarationOnly;
-          Diag(VD->getLocation(),
-               IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-              << VD;
-          Diag(RD->getLocation(), diag::note_previous_decl) << RD;
-          continue;
-        }
-        MarkFunctionReferenced(ELoc, MD);
-        DiagnoseUseOfDecl(MD, ELoc);
-      }
+    // - A list-item that appears in a linear clause must be of integral
+    //   or pointer type.
+    QTy = QTy.getUnqualifiedType().getCanonicalType();
+    const Type *Ty = QTy.getTypePtrOrNull();
+    if (!Ty || (!Ty->isDependentType() && !Ty->isIntegralType(Context) &&
+                !Ty->isPointerType())) {
+      Diag(ELoc, diag::err_omp_expected_int_or_ptr) << (*I)->getSourceRange();
+      continue;
     }
 
-    DSAStack->addDSA(VD, DE, OMPC_copyin);
+    DSAStack->addDSA(VD, DE, OMPC_linear);
+
     Vars.push_back(DE);
   }
 
   if (Vars.empty())
-    return nullptr;
+    return 0;
+
+  if (Step && Step->isIntegerConstantExpr(Context)) {
+    Step = ActOnConstantLinearStep(Step);
+    if (!Step)
+      return 0;
+  }
 
-  return OMPCopyinClause::Create(Context, StartLoc, LParenLoc, EndLoc, Vars);
+  return OMPLinearClause::Create(Context, StartLoc, EndLoc, Vars, Step,
+                                 StepLoc);
 }
 
-OMPClause *Sema::ActOnOpenMPCopyprivateClause(ArrayRef<Expr *> VarList,
-                                              SourceLocation StartLoc,
-                                              SourceLocation LParenLoc,
-                                              SourceLocation EndLoc) {
-  SmallVector<Expr *, 8> Vars;
-  for (auto &RefExpr : VarList) {
-    assert(RefExpr && "NULL expr in OpenMP copyprivate clause.");
-    if (isa<DependentScopeDeclRefExpr>(RefExpr)) {
+OMPClause *Sema::ActOnOpenMPAlignedClause(ArrayRef<Expr *> VarList,
+                                          SourceLocation StartLoc,
+                                          SourceLocation EndLoc,
+                                          Expr *Alignment,
+                                          SourceLocation AlignmentLoc) {
+  SmallVector<Expr *, 4> Vars;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+
+    assert(*I && "Null expr in omp aligned");
+    if (*I && isa<DependentScopeDeclRefExpr>(*I)) {
       // It will be analyzed later.
-      Vars.push_back(RefExpr);
+      Vars.push_back(*I);
       continue;
     }
 
-    SourceLocation ELoc = RefExpr->getExprLoc();
-    // OpenMP [2.1, C/C++]
-    //  A list item is a variable name.
-    // OpenMP  [2.14.4.1, Restrictions, p.1]
-    //  A list item that appears in a copyin clause must be threadprivate.
-    DeclRefExpr *DE = dyn_cast<DeclRefExpr>(RefExpr);
+    SourceLocation ELoc = (*I)->getExprLoc();
+    DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(*I);
     if (!DE || !isa<VarDecl>(DE->getDecl())) {
-      Diag(ELoc, diag::err_omp_expected_var_name) << RefExpr->getSourceRange();
+      // OpenMP [2.1, C/C++]
+      //  A list item is a variable name.
+      Diag(ELoc, diag::err_omp_expected_var_name) << (*I)->getSourceRange();
+      continue;
+    }
+    // OpenMP  [2.8.1, simd construct, Restrictions]
+    // The type of list items appearing in the aligned clause must be
+    // array, pointer, reference to array, or reference to pointer.
+    QualType QTy = DE->getType()
+                       .getNonReferenceType()
+                       .getUnqualifiedType()
+                       .getCanonicalType();
+    const Type *Ty = QTy.getTypePtrOrNull();
+    if (!Ty || (!Ty->isDependentType() && !Ty->isArrayType() &&
+                !Ty->isPointerType())) {
+      Diag(ELoc, diag::err_omp_expected_array_or_ptr) << (*I)->getSourceRange();
+      continue;
+    }
+    // OpenMP  [2.8.1, simd construct, Restrictions]
+    // A list-item cannot appear in more than one aligned clause.
+    DeclRefExpr *PrevRef = DE;
+    if (!DSAStack->addUniqueAligned(cast<VarDecl>(DE->getDecl()), PrevRef)) {
+      Diag(ELoc, diag::err_omp_wrong_dsa) << getOpenMPClauseName(OMPC_aligned)
+                                          << getOpenMPClauseName(OMPC_aligned);
+      Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+          << getOpenMPClauseName(OMPC_aligned);
       continue;
     }
 
-    Decl *D = DE->getDecl();
-    VarDecl *VD = cast<VarDecl>(D);
+    Vars.push_back(DE);
+  }
 
-    QualType Type = VD->getType();
-    if (Type->isDependentType() || Type->isInstantiationDependentType()) {
+  if (Vars.empty())
+    return 0;
+
+  // OpenMP [2.8.1, simd construct, Description]
+  // The optional parameter of the aligned clause, alignment, must be
+  // a constant positive integer expression.
+  if (Alignment) {
+    Alignment = ActOnConstantPositiveSubExpressionInClause(Alignment);
+    if (!Alignment)
+      return 0;
+  }
+
+  return OMPAlignedClause::Create(Context, StartLoc, EndLoc, Vars, Alignment,
+                                  AlignmentLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPReadClause(SourceLocation StartLoc,
+                                       SourceLocation EndLoc) {
+  return new (Context) OMPReadClause(StartLoc, EndLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPWriteClause(SourceLocation StartLoc,
+                                        SourceLocation EndLoc) {
+  return new (Context) OMPWriteClause(StartLoc, EndLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPUpdateClause(SourceLocation StartLoc,
+                                         SourceLocation EndLoc) {
+  return new (Context) OMPUpdateClause(StartLoc, EndLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPCaptureClause(SourceLocation StartLoc,
+                                          SourceLocation EndLoc) {
+  return new (Context) OMPCaptureClause(StartLoc, EndLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPSeqCstClause(SourceLocation StartLoc,
+                                         SourceLocation EndLoc) {
+  return new (Context) OMPSeqCstClause(StartLoc, EndLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPInBranchClause(SourceLocation StartLoc,
+                                           SourceLocation EndLoc) {
+  return new (Context) OMPInBranchClause(StartLoc, EndLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPNotInBranchClause(SourceLocation StartLoc,
+                                              SourceLocation EndLoc) {
+  return new (Context) OMPNotInBranchClause(StartLoc, EndLoc);
+}
+
+OMPClause *Sema::ActOnOpenMPFlushClause(ArrayRef<Expr *> VarList,
+                                        SourceLocation StartLoc,
+                                        SourceLocation EndLoc) {
+  SmallVector<Expr *, 4> Vars;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    assert(*I && "Null expr in omp flush");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
       // It will be analyzed later.
+      Vars.push_back(*I);
+      continue;
+    }
+
+    if (DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(*I))
       Vars.push_back(DE);
+  }
+
+  if (Vars.empty())
+    return 0;
+
+  return OMPFlushClause::Create(Context, StartLoc, EndLoc, Vars);
+}
+
+OMPClause *Sema::ActOnOpenMPUniformClause(ArrayRef<Expr *> VarList,
+                                          SourceLocation StartLoc,
+                                          SourceLocation EndLoc) {
+  SmallVector<Expr *, 4> Vars;
+  for (ArrayRef<Expr *>::iterator I = VarList.begin(), E = VarList.end();
+       I != E; ++I) {
+    assert(*I && "Null expr in omp uniform");
+    if (isa<DependentScopeDeclRefExpr>(*I)) {
+      // It will be analyzed later.
+      Vars.push_back(*I);
       continue;
     }
 
-    // OpenMP [2.14.4.2, Restrictions, p.2]
-    //  A list item that appears in a copyprivate clause may not appear in a
-    //  private or firstprivate clause on the single construct.
-    if (!DSAStack->isThreadPrivate(VD)) {
-      auto DVar = DSAStack->getTopDSA(VD, false);
-      if (DVar.CKind != OMPC_copyprivate && DVar.CKind != OMPC_unknown &&
-          !(DVar.CKind == OMPC_private && !DVar.RefExpr)) {
-        Diag(ELoc, diag::err_omp_wrong_dsa)
-            << getOpenMPClauseName(DVar.CKind)
-            << getOpenMPClauseName(OMPC_copyprivate);
-        ReportOriginalDSA(*this, DSAStack, VD, DVar);
-        continue;
-      }
+    if (DeclRefExpr *DE = dyn_cast_or_null<DeclRefExpr>(*I))
+      Vars.push_back(DE);
+  }
 
-      // OpenMP [2.11.4.2, Restrictions, p.1]
-      //  All list items that appear in a copyprivate clause must be either
-      //  threadprivate or private in the enclosing context.
-      if (DVar.CKind == OMPC_unknown) {
-        DVar = DSAStack->getImplicitDSA(VD, false);
-        if (DVar.CKind == OMPC_shared) {
-          Diag(ELoc, diag::err_omp_required_access)
-              << getOpenMPClauseName(OMPC_copyprivate)
-              << "threadprivate or private in the enclosing context";
-          ReportOriginalDSA(*this, DSAStack, VD, DVar);
-          continue;
-        }
-      }
+  if (Vars.empty())
+    return 0;
+
+  return OMPUniformClause::Create(Context, StartLoc, EndLoc, Vars);
+}
+
+namespace {
+class ForInitChecker : public StmtVisitor<ForInitChecker, Decl *> {
+  class ForInitVarChecker : public StmtVisitor<ForInitVarChecker, Decl *> {
+  public:
+    VarDecl *VisitDeclRefExpr(DeclRefExpr *E) {
+      return dyn_cast_or_null<VarDecl>(E->getDecl());
     }
+    Decl *VisitStmt(Stmt *S) { return 0; }
+    ForInitVarChecker() {}
+  } VarChecker;
+  Expr *InitValue;
 
-    // OpenMP [2.14.4.1, Restrictions, C/C++, p.2]
-    //  A variable of class type (or array thereof) that appears in a
-    //  copyin clause requires an accessible, unambiguous copy assignment
-    //  operator for the class type.
-    Type = Context.getBaseElementType(Type);
-    CXXRecordDecl *RD =
-        getLangOpts().CPlusPlus ? Type->getAsCXXRecordDecl() : nullptr;
-    // FIXME This code must be replaced by actual assignment of the
-    // threadprivate variable.
-    if (RD) {
-      CXXMethodDecl *MD = LookupCopyingAssignment(RD, 0, false, 0);
-      DeclAccessPair FoundDecl = DeclAccessPair::make(MD, MD->getAccess());
-      if (MD) {
-        if (CheckMemberAccess(ELoc, RD, FoundDecl) == AR_inaccessible ||
-            MD->isDeleted()) {
-          Diag(ELoc, diag::err_omp_required_method)
-              << getOpenMPClauseName(OMPC_copyprivate) << 2;
-          bool IsDecl = VD->isThisDeclarationADefinition(Context) ==
-                        VarDecl::DeclarationOnly;
-          Diag(VD->getLocation(),
-               IsDecl ? diag::note_previous_decl : diag::note_defined_here)
-              << VD;
-          Diag(RD->getLocation(), diag::note_previous_decl) << RD;
-          continue;
+public:
+  Decl *VisitBinaryOperator(BinaryOperator *BO) {
+    if (BO->getOpcode() != BO_Assign)
+      return 0;
+
+    InitValue = BO->getRHS();
+    return VarChecker.Visit(BO->getLHS());
+  }
+  Decl *VisitDeclStmt(DeclStmt *S) {
+    if (S->isSingleDecl()) {
+      VarDecl *Var = dyn_cast_or_null<VarDecl>(S->getSingleDecl());
+      if (Var && Var->hasInit()) {
+        if (CXXConstructExpr *Init =
+                dyn_cast<CXXConstructExpr>(Var->getInit())) {
+          if (Init->getNumArgs() != 1)
+            return 0;
+          InitValue = Init->getArg(0);
+        } else {
+          InitValue = Var->getInit();
         }
-        MarkFunctionReferenced(ELoc, MD);
-        DiagnoseUseOfDecl(MD, ELoc);
+        return Var;
       }
     }
+    return 0;
+  }
+  Decl *VisitCXXOperatorCallExpr(CXXOperatorCallExpr *E) {
+    switch (E->getOperator()) {
+    case OO_Equal:
+      InitValue = E->getArg(1);
+      return VarChecker.Visit(E->getArg(0));
+    default:
+      break;
+    }
+    return 0;
+  }
+  Decl *VisitStmt(Stmt *S) { return 0; }
+  ForInitChecker() : VarChecker(), InitValue(0) {}
+  Expr *getInitValue() { return InitValue; }
+};
 
-    // No need to mark vars as copyprivate, they are already threadprivate or
-    // implicitly private.
-    Vars.push_back(DE);
+class ForVarChecker : public StmtVisitor<ForVarChecker, bool> {
+  Decl *InitVar;
+
+public:
+  bool VisitDeclRefExpr(DeclRefExpr *E) { return E->getDecl() == InitVar; }
+  bool VisitImplicitCastExpr(ImplicitCastExpr *E) {
+    return Visit(E->getSubExpr());
   }
+  bool VisitStmt(Stmt *S) { return false; }
+  ForVarChecker(Decl *D) : InitVar(D) {}
+};
 
-  if (Vars.empty())
-    return nullptr;
+class ForTestChecker : public StmtVisitor<ForTestChecker, bool> {
+  ForVarChecker VarChecker;
+  Expr *CheckValue;
+  bool IsLessOp;
+  bool IsStrictOp;
+
+public:
+  bool VisitBinaryOperator(BinaryOperator *BO) {
+    if (!BO->isRelationalOp())
+      return false;
+    if (VarChecker.Visit(BO->getLHS())) {
+      CheckValue = BO->getRHS();
+      IsLessOp = BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE;
+      IsStrictOp = BO->getOpcode() == BO_LT || BO->getOpcode() == BO_GT;
+    } else if (VarChecker.Visit(BO->getRHS())) {
+      CheckValue = BO->getLHS();
+      IsLessOp = BO->getOpcode() == BO_GT || BO->getOpcode() == BO_GE;
+      IsStrictOp = BO->getOpcode() == BO_LT || BO->getOpcode() == BO_GT;
+    }
+    return CheckValue != 0;
+  }
+  bool VisitCXXOperatorCallExpr(CXXOperatorCallExpr *E) {
+    switch (E->getOperator()) {
+    case OO_Greater:
+    case OO_GreaterEqual:
+    case OO_Less:
+    case OO_LessEqual:
+      break;
+    default:
+      return false;
+    }
+    if (E->getNumArgs() != 2)
+      return false;
+
+    if (VarChecker.Visit(E->getArg(0))) {
+      CheckValue = E->getArg(1);
+      IsLessOp =
+          E->getOperator() == OO_Less || E->getOperator() == OO_LessEqual;
+      IsStrictOp = E->getOperator() == OO_Less;
+    } else if (VarChecker.Visit(E->getArg(1))) {
+      CheckValue = E->getArg(0);
+      IsLessOp =
+          E->getOperator() == OO_Greater || E->getOperator() == OO_GreaterEqual;
+      IsStrictOp = E->getOperator() == OO_Greater;
+    }
+
+    return CheckValue != 0;
+  }
+  bool VisitStmt(Stmt *S) { return false; }
+  ForTestChecker(Decl *D)
+      : VarChecker(D), CheckValue(0), IsLessOp(false), IsStrictOp(false) {}
+  Expr *getCheckValue() { return CheckValue; }
+  bool isLessOp() const { return IsLessOp; }
+  bool isStrictOp() const { return IsStrictOp; }
+};
 
-  return OMPCopyprivateClause::Create(Context, StartLoc, LParenLoc, EndLoc, Vars);
+class ForIncrChecker : public StmtVisitor<ForIncrChecker, bool> {
+  ForVarChecker VarChecker;
+  class ForIncrExprChecker : public StmtVisitor<ForIncrExprChecker, bool> {
+    ForVarChecker VarChecker;
+    Expr *StepValue;
+    bool IsIncrement;
+
+  public:
+    bool VisitBinaryOperator(BinaryOperator *BO) {
+      if (!BO->isAdditiveOp())
+        return false;
+      if (BO->getOpcode() == BO_Add) {
+        IsIncrement = true;
+        if (VarChecker.Visit(BO->getLHS()))
+          StepValue = BO->getRHS();
+        else if (VarChecker.Visit(BO->getRHS()))
+          StepValue = BO->getLHS();
+        return StepValue != 0;
+      }
+      // BO_Sub
+      if (VarChecker.Visit(BO->getLHS()))
+        StepValue = BO->getRHS();
+      return StepValue != 0;
+    }
+    bool VisitCXXOperatorCallExpr(CXXOperatorCallExpr *E) {
+      switch (E->getOperator()) {
+      case OO_Plus:
+        IsIncrement = true;
+        if (VarChecker.Visit(E->getArg(0)))
+          StepValue = E->getArg(1);
+        else if (VarChecker.Visit(E->getArg(1)))
+          StepValue = E->getArg(0);
+        return StepValue != 0;
+      case OO_Minus:
+        if (VarChecker.Visit(E->getArg(0)))
+          StepValue = E->getArg(1);
+        return StepValue != 0;
+      default:
+        return false;
+      }
+    }
+    bool VisitStmt(Stmt *S) { return false; }
+    ForIncrExprChecker(ForVarChecker &C)
+        : VarChecker(C), StepValue(0), IsIncrement(false) {}
+    Expr *getStepValue() { return StepValue; }
+    bool isIncrement() const { return IsIncrement; }
+  } ExprChecker;
+  Expr *StepValue;
+  Sema &Actions;
+  bool IsLessOp, IsCompatibleWithTest;
+
+public:
+  bool VisitUnaryOperator(UnaryOperator *UO) {
+    if (!UO->isIncrementDecrementOp())
+      return false;
+    if (VarChecker.Visit(UO->getSubExpr())) {
+      IsCompatibleWithTest = (IsLessOp && UO->isIncrementOp()) ||
+                             (!IsLessOp && UO->isDecrementOp());
+      if (!IsCompatibleWithTest && IsLessOp)
+        StepValue = Actions.ActOnIntegerConstant(SourceLocation(), -1).get();
+      else
+        StepValue = Actions.ActOnIntegerConstant(SourceLocation(), 1).get();
+    }
+    return StepValue != 0;
+  }
+  bool VisitBinaryOperator(BinaryOperator *BO) {
+    IsCompatibleWithTest = (IsLessOp && BO->getOpcode() == BO_AddAssign) ||
+                           (!IsLessOp && BO->getOpcode() == BO_SubAssign);
+    switch (BO->getOpcode()) {
+    case BO_AddAssign:
+    case BO_SubAssign:
+      if (VarChecker.Visit(BO->getLHS())) {
+        StepValue = BO->getRHS();
+        IsCompatibleWithTest = (IsLessOp && BO->getOpcode() == BO_AddAssign) ||
+                               (!IsLessOp && BO->getOpcode() == BO_SubAssign);
+      }
+      return StepValue != 0;
+    case BO_Assign:
+      if (VarChecker.Visit(BO->getLHS()) && ExprChecker.Visit(BO->getRHS())) {
+        StepValue = ExprChecker.getStepValue();
+        IsCompatibleWithTest = IsLessOp == ExprChecker.isIncrement();
+      }
+      return StepValue != 0;
+    default:
+      break;
+    }
+    return false;
+  }
+  bool VisitCXXOperatorCallExpr(CXXOperatorCallExpr *E) {
+    switch (E->getOperator()) {
+    case OO_PlusPlus:
+    case OO_MinusMinus:
+      if (VarChecker.Visit(E->getArg(0))) {
+        IsCompatibleWithTest = (IsLessOp && E->getOperator() == OO_PlusPlus) ||
+                               (!IsLessOp && E->getOperator() == OO_MinusMinus);
+        if (!IsCompatibleWithTest && IsLessOp)
+          StepValue = Actions.ActOnIntegerConstant(SourceLocation(), -1).get();
+        else
+          StepValue = Actions.ActOnIntegerConstant(SourceLocation(), 1).get();
+      }
+      return StepValue != 0;
+    case OO_PlusEqual:
+    case OO_MinusEqual:
+      if (VarChecker.Visit(E->getArg(0))) {
+        StepValue = E->getArg(1);
+        IsCompatibleWithTest = (IsLessOp && E->getOperator() == OO_PlusEqual) ||
+                               (!IsLessOp && E->getOperator() == OO_MinusEqual);
+      }
+      return StepValue != 0;
+    case OO_Equal:
+      if (VarChecker.Visit(E->getArg(0)) && ExprChecker.Visit(E->getArg(1))) {
+        StepValue = ExprChecker.getStepValue();
+        IsCompatibleWithTest = IsLessOp == ExprChecker.isIncrement();
+      }
+      return StepValue != 0;
+    default:
+      break;
+    }
+    return false;
+  }
+  bool VisitStmt(Stmt *S) { return false; }
+  ForIncrChecker(Decl *D, Sema &S, bool LessOp)
+      : VarChecker(D), ExprChecker(VarChecker), StepValue(0), Actions(S),
+        IsLessOp(LessOp), IsCompatibleWithTest(false) {}
+  Expr *getStepValue() { return StepValue; }
+  bool isCompatibleWithTest() const { return IsCompatibleWithTest; }
+};
 }
 
-OMPClause *Sema::ActOnOpenMPFlushClause(ArrayRef<Expr *> VarList,
-                                        SourceLocation StartLoc,
-                                        SourceLocation LParenLoc,
-                                        SourceLocation EndLoc) {
-  if (VarList.empty())
-    return nullptr;
+bool Sema::isNotOpenMPCanonicalLoopForm(Stmt *S, OpenMPDirectiveKind Kind,
+                                        Expr *&NewEnd, Expr *&NewIncr,
+                                        Expr *&InitVal, Expr *&VarCnt,
+                                        BinaryOperatorKind &OpKind) {
+  // assert(S && "non-null statement must be specified");
+  // OpenMP [2.9.5, Canonical Loop Form]
+  //  for (init-expr; test-expr; incr-expr) structured-block
+  OpKind = BO_Assign;
+  ForStmt *For = dyn_cast_or_null<ForStmt>(S);
+  if (!For) {
+    Diag(S->getLocStart(), diag::err_omp_not_for)
+        << getOpenMPDirectiveName(Kind);
+    return true;
+  }
+  Stmt *Body = For->getBody();
+  if (!Body) {
+    Diag(S->getLocStart(), diag::err_omp_directive_nonblock)
+        << getOpenMPDirectiveName(Kind);
+    return true;
+  }
+
+  // OpenMP [2.9.5, Canonical Loop Form]
+  //  init-expr One of the following:
+  //  var = lb
+  //  integer-type var = lb
+  //  random-access-iterator-type var = lb
+  //  pointer-type var = lb
+  ForInitChecker InitChecker;
+  Stmt *Init = For->getInit();
+  VarDecl *Var;
+  if (!Init || !(Var = dyn_cast_or_null<VarDecl>(InitChecker.Visit(Init)))) {
+    Diag(Init ? Init->getLocStart() : For->getForLoc(),
+         diag::err_omp_not_canonical_for)
+        << 0;
+    return true;
+  }
+  SourceLocation InitLoc = Init->getLocStart();
+
+  // OpenMP [2.11.1.1, Data-sharing Attribute Rules for Variables Referenced
+  // in a Construct, C/C++]
+  // The loop iteration variable(s) in the associated for-loop(s) of a for or
+  // parallel for construct may be listed in a private or lastprivate clause.
+  bool HasErrors = false;
+  DeclRefExpr *PrevRef;
+  OpenMPDirectiveKind CurrentDir = DSAStack->getCurrentDirective();
+  OpenMPClauseKind CKind = DSAStack->getTopDSA(Var, PrevRef);
+  if (CKind == OMPC_threadprivate) {
+    //    Diag(InitLoc, diag::err_omp_for_loop_var_dsa)
+    //         << getOpenMPClauseName(CKind);
+    //    if (PrevRef)
+    //      Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+    //           << getOpenMPClauseName(CKind);
+    //    HasErrors = true;
+  } else if (CKind != OMPC_unknown && CKind != OMPC_private &&
+             CKind != OMPC_lastprivate &&
+             (CurrentDir == OMPD_for || CurrentDir == OMPD_parallel_for ||
+              CurrentDir == OMPD_distribute ||
+              CurrentDir == OMPD_distribute_parallel_for ||
+              CurrentDir == OMPD_teams_distribute ||
+              CurrentDir == OMPD_target_teams_distribute ||
+              CurrentDir == OMPD_teams_distribute_parallel_for ||
+              CurrentDir == OMPD_target_teams_distribute_parallel_for)) {
+    Diag(InitLoc, diag::err_omp_for_loop_var_dsa) << getOpenMPClauseName(CKind);
+    if (PrevRef) {
+      Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+          << getOpenMPClauseName(CKind);
+    } else {
+      Diag(Var->getLocation(), diag::note_omp_predetermined_dsa)
+          << getOpenMPClauseName(CKind);
+    }
+    HasErrors = true;
+  } else if (CKind != OMPC_unknown && CKind != OMPC_linear &&
+             CKind != OMPC_lastprivate &&
+             (CurrentDir == OMPD_simd || CurrentDir == OMPD_for_simd ||
+              CurrentDir == OMPD_parallel_for_simd ||
+              CurrentDir == OMPD_distribute_parallel_for_simd ||
+              CurrentDir == OMPD_teams_distribute_parallel_for_simd ||
+              CurrentDir == OMPD_target_teams_distribute_parallel_for_simd ||
+              CurrentDir == OMPD_distribute_simd ||
+              CurrentDir == OMPD_teams_distribute_simd ||
+              CurrentDir == OMPD_target_teams_distribute_simd)) {
+    // OpenMP [2.11.1.1, Data-sharing Attribute Rules for Variables Referenced
+    // in a Construct, C/C++]
+    // The loop iteration variable in the associated for-loop of a simd
+    // construct with just one associated for-loop may be listed in a linear
+    // clause with a constant-linear-step that is the increment of the
+    // associated for-loop.
+    Diag(InitLoc, diag::err_omp_for_loop_var_dsa) << getOpenMPClauseName(CKind);
+    if (PrevRef) {
+      Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)
+          << getOpenMPClauseName(CKind);
+    } else {
+      Diag(Var->getLocation(), diag::note_omp_predetermined_dsa)
+          << getOpenMPClauseName(CKind);
+    }
+    HasErrors = true;
+  } else {
+    // OpenMP [2.11.1.1, Data-sharing Attribute Rules for Variables Referenced
+    // in a Construct, C/C++]
+    // The loop iteration variable(s) in the associated for-loop(s)of a for or
+    // parallel for construct is (are) private.
+    DSAStack->addDSA(Var, 0, OMPC_private);
+  }
+
+  // OpenMP [2.9.5, Canonical Loop Form]
+  // Var One of the following
+  // A variable of signed or unsigned integer type
+  // For C++, a variable of a random access iterator type.
+  // For C, a variable of a pointer type.
+  QualType Type = Var->getType()
+                      .getNonReferenceType()
+                      .getCanonicalType()
+                      .getUnqualifiedType();
+  if (!Type->isIntegerType() && !Type->isPointerType() &&
+      (!getLangOpts().CPlusPlus || !Type->isOverloadableType())) {
+    Diag(Init->getLocStart(), diag::err_omp_for_variable)
+        << getLangOpts().CPlusPlus;
+    HasErrors = true;
+  }
+
+  // OpenMP [2.9.5, Canonical Loop Form]
+  //  test-expr One of the following:
+  //  var relational-op b
+  //  b relational-op var
+  ForTestChecker TestChecker(Var);
+  Stmt *Cond = For->getCond();
+  bool TestCheckCorrect = false;
+  if (!Cond || !(TestCheckCorrect = TestChecker.Visit(Cond))) {
+    Diag(Cond ? Cond->getLocStart() : For->getForLoc(),
+         diag::err_omp_not_canonical_for)
+        << 1;
+    HasErrors = true;
+  }
+
+  // OpenMP [2.9.5, Canonical Loop Form]
+  //  incr-expr One of the following:
+  //  ++var
+  //  var++
+  //  --var
+  //  var--
+  //  var += incr
+  //  var -= incr
+  //  var = var + incr
+  //  var = incr + var
+  //  var = var - incr
+  ForIncrChecker IncrChecker(Var, *this, TestChecker.isLessOp());
+  Stmt *Incr = For->getInc();
+  bool IncrCheckCorrect = false;
+  if (!Incr || !(IncrCheckCorrect = IncrChecker.Visit(Incr))) {
+    Diag(Incr ? Incr->getLocStart() : For->getForLoc(),
+         diag::err_omp_not_canonical_for)
+        << 2;
+    HasErrors = true;
+  }
+
+  // OpenMP [2.9.5, Canonical Loop Form]
+  //  lb and b Loop invariant expressions of a type compatible with the type
+  //  of var.
+  Expr *InitValue = InitChecker.getInitValue();
+  //  QualType InitTy =
+  //    InitValue ? InitValue->getType().getNonReferenceType().
+  //                                  getCanonicalType().getUnqualifiedType() :
+  //                QualType();
+  //  if (InitValue &&
+  //      Context.mergeTypes(Type, InitTy, false, true).isNull()) {
+  //    Diag(InitValue->getExprLoc(), diag::err_omp_for_type_not_compatible)
+  //      << InitValue->getType()
+  //      << Var << Var->getType();
+  //    HasErrors = true;
+  //  }
+  Expr *CheckValue = TestChecker.getCheckValue();
+  //  QualType CheckTy =
+  //    CheckValue ? CheckValue->getType().getNonReferenceType().
+  //                                  getCanonicalType().getUnqualifiedType() :
+  //                 QualType();
+  //  if (CheckValue &&
+  //      Context.mergeTypes(Type, CheckTy, false, true).isNull()) {
+  //    Diag(CheckValue->getExprLoc(), diag::err_omp_for_type_not_compatible)
+  //      << CheckValue->getType()
+  //      << Var << Var->getType();
+  //    HasErrors = true;
+  //  }
+
+  // OpenMP [2.9.5, Canonical Loop Form]
+  //  incr A loop invariant integer expression.
+  Expr *Step = IncrChecker.getStepValue();
+  if (Step && !Step->getType()->isIntegralOrEnumerationType()) {
+    Diag(Step->getExprLoc(), diag::err_omp_for_incr_not_integer);
+    HasErrors = true;
+  }
+  // llvm::APSInt Result;
+  // if (Step && Step->isIntegerConstantExpr(Result, Context) &&
+  //    !Result.isStrictlyPositive()) {
+  //  Diag(Step->getExprLoc(), diag::err_negative_expression_in_clause);
+  //  HasErrors = true;
+  //}
+
+  // OpenMP [2.9.5, Canonical Loop Form, Restrictions]
+  //  If test-expr is of form var relational-op b and relational-op is < or
+  //  <= then incr-expr must cause var to increase on each iteration of the
+  //  loop. If test-expr is of form var relational-op b and relational-op is
+  //  > or >= then incr-expr must cause var to decrease on each iteration of the
+  //  loop.
+  //  If test-expr is of form b relational-op var and relational-op is < or
+  //  <= then incr-expr must cause var to decrease on each iteration of the
+  //  loop. If test-expr is of form b relational-op var and relational-op is
+  //  > or >= then incr-expr must cause var to increase on each iteration of the
+  //  loop.
+  if (Incr && TestCheckCorrect && IncrCheckCorrect &&
+      !IncrChecker.isCompatibleWithTest()) {
+    // Additional type checking.
+    llvm::APSInt Result;
+    bool IsConst = Step->isIntegerConstantExpr(Result, getASTContext());
+    bool IsConstNeg = IsConst && Result.isSigned() && Result.isNegative();
+    bool IsSigned = Step->getType()->hasSignedIntegerRepresentation();
+    if ((TestChecker.isLessOp() && IsConst && IsConstNeg) ||
+        (!TestChecker.isLessOp() &&
+         ((IsConst && !IsConstNeg) || (!IsConst && !IsSigned)))) {
+      Diag(Incr->getLocStart(), diag::err_omp_for_incr_not_compatible)
+          << Var << TestChecker.isLessOp();
+      HasErrors = true;
+    } else {
+      Step = CreateBuiltinUnaryOp(Step->getExprLoc(), UO_Minus, Step).get();
+    }
+  }
+  if (HasErrors)
+    return true;
+
+  // Build expression for number of iterations.
+  // if (getLangOpts().CPlusPlus && !StdNamespace && !Type->isIntegerType()) {
+  //  Diag(Var->getLocation(), diag::err_omp_type_not_rai);
+  //  return true;
+  //}
+
+  ExprResult Diff;
+  assert(Step && "Null expr in Step in OMP FOR");
+  Step = Step->IgnoreParenImpCasts();
+  CheckValue = CheckValue->IgnoreParenImpCasts();
+  InitValue = InitValue->IgnoreParenImpCasts();
+  if (Step->getType()->isDependentType() ||
+      CheckValue->getType()->isDependentType() ||
+      InitValue->getType()->isDependentType()) {
+    NewEnd = CheckValue;
+    NewIncr = Step;
+    InitVal = InitValue;
+    VarCnt = CheckValue;
+    return false;
+  }
+  if (getLangOpts().CPlusPlus && !Type->isIntegerType() &&
+      !Type->isPointerType()) {
+    // Check that var type is a random access iterator, i.e.
+    // we can apply 'std::distance' to the init and test arguments
+    // of the for-loop.
+    CXXScopeSpec SS;
+    SS.Extend(Context, getOrCreateStdNamespace(), SourceLocation(),
+              SourceLocation());
+    IdentifierInfo *IIT = &Context.Idents.get("iterator_traits");
+    DeclarationNameInfo DNIIT(IIT, SourceLocation());
+    LookupResult RIT(*this, DNIIT, LookupNestedNameSpecifierName);
+    TemplateDecl *D;
+    if (!LookupParsedName(RIT, DSAStack->getCurScope(), &SS) ||
+        !RIT.isSingleResult() || !(D = RIT.getAsSingle<TemplateDecl>())) {
+      Diag(Var->getLocation(), diag::err_omp_type_not_rai);
+      return true;
+    }
 
-  return OMPFlushClause::Create(Context, StartLoc, LParenLoc, EndLoc, VarList);
+    TemplateArgumentListInfo Args;
+    TemplateArgument Arg(Type);
+    TemplateArgumentLoc ArgLoc(Arg, Context.CreateTypeSourceInfo(Type));
+    Args.addArgument(ArgLoc);
+    QualType T = CheckTemplateIdType(TemplateName(D), SourceLocation(), Args);
+    CXXRecordDecl *TRDType;
+    if (T.isNull() || RequireCompleteType(Var->getLocation(), T, 0) ||
+        !(TRDType = T->getAsCXXRecordDecl())) {
+      Diag(Var->getLocation(), diag::err_omp_type_not_rai);
+      return true;
+    }
+
+    IdentifierInfo *IIRAI = &Context.Idents.get("random_access_iterator_tag");
+    DeclarationNameInfo DNIRAI(IIRAI, SourceLocation());
+    LookupResult RRAI(*this, DNIRAI, LookupOrdinaryName);
+    TypeDecl *TDRAI;
+    CXXRecordDecl *RDType = Type->getAsCXXRecordDecl();
+    if (!LookupParsedName(RRAI, DSAStack->getCurScope(), &SS) ||
+        !RRAI.isSingleResult() || !(TDRAI = RRAI.getAsSingle<TypeDecl>()) ||
+        !RDType) {
+      Diag(Var->getLocation(), diag::err_omp_type_not_rai);
+      return true;
+    }
+
+    IdentifierInfo *IIC = &Context.Idents.get("iterator_category");
+    DeclarationNameInfo DNIIC(IIC, SourceLocation());
+    LookupResult RIC(*this, DNIIC, LookupOrdinaryName);
+    TypeDecl *TDIC;
+    if (!LookupQualifiedName(RIC, TRDType) || !RIC.isSingleResult() ||
+        !(TDIC = RIC.getAsSingle<TypeDecl>()) ||
+        !Context.hasSameType(Context.getTypeDeclType(TDRAI),
+                             Context.getTypeDeclType(TDIC))) {
+      Diag(Var->getLocation(), diag::err_omp_type_not_rai);
+      return true;
+    }
+
+    IdentifierInfo *IID = &Context.Idents.get("distance");
+    DeclarationNameInfo DNID(IID, SourceLocation());
+    ExprResult ER = BuildQualifiedTemplateIdExpr(SS, InitLoc, DNID, &Args);
+    Expr *CallArgs[2] = {TestChecker.isLessOp() ? InitValue : CheckValue,
+                         TestChecker.isLessOp() ? CheckValue : InitValue};
+    Diff = ActOnCallExpr(DSAStack->getCurScope(), ER.get(), InitLoc, CallArgs,
+                         InitLoc);
+    if (Diff.isInvalid()) {
+      Diag(Var->getLocation(), diag::err_omp_type_not_rai);
+      return true;
+    }
+  } else {
+    Diff = BuildBinOp(DSAStack->getCurScope(), InitLoc, BO_Sub,
+                      TestChecker.isLessOp() ? CheckValue : InitValue,
+                      TestChecker.isLessOp() ? InitValue : CheckValue);
+  }
+  if (Diff.isUsable() && TestChecker.isStrictOp()) {
+    Diff = BuildBinOp(DSAStack->getCurScope(), InitLoc, BO_Sub, Diff.get(),
+                      ActOnIntegerConstant(SourceLocation(), 1).get());
+  }
+  if (Diff.isUsable()) {
+    Diff =
+        BuildBinOp(DSAStack->getCurScope(), InitLoc, BO_Add, Diff.get(), Step);
+  }
+  if (Diff.isUsable()) {
+    Diff =
+        BuildBinOp(DSAStack->getCurScope(), InitLoc, BO_Div, Diff.get(), Step);
+  }
+  bool Signed = Type->hasSignedIntegerRepresentation();
+  uint64_t TypeSize = Context.getTypeSize(Type);
+  if (TypeSize < 32)
+    TypeSize = 32;
+  else if (TypeSize > 64)
+    TypeSize = 64;
+  QualType DiffType = Context.getIntTypeForBitwidth(TypeSize, Signed);
+  TypeSourceInfo *TSI = Context.getTrivialTypeSourceInfo(DiffType);
+  NewEnd = BuildCStyleCastExpr(SourceLocation(), TSI, SourceLocation(),
+                               Diff.get()).get();
+  NewIncr =
+      BuildCStyleCastExpr(SourceLocation(), TSI, SourceLocation(), Step).get();
+  InitVal =
+      PerformImplicitConversion(InitValue, Type, AA_Initializing, true).get();
+  // NamedDecl *ND = Var;
+  VarCnt =
+      DeclRefExpr::Create(Context, NestedNameSpecifierLoc(), SourceLocation(),
+                          Var, false, SourceLocation(), Type, VK_LValue);
+  // if (!isDeclInScope(ND, CurContext, DSAStack->getCurScope())) {
+  //  DeclContext *SavedCurContext = CurContext;
+  //  CurContext = Var->getDeclContext();
+  //  VarCnt = BuildDeclRefExpr(Var, Type, VK_LValue, InitLoc).get();
+  //  CurContext = SavedCurContext;
+  //}
+  OpKind = TestChecker.isLessOp() ? BO_Add : BO_Sub;
+  return false;
+}
+
+namespace {
+class CEANExprChecker : public StmtVisitor<CEANExprChecker, bool> {
+public:
+  bool VisitCEANIndexExpr(CEANIndexExpr *E) { return true; }
+  bool VisitOpaqueValueExpr(OpaqueValueExpr *E) {
+    return E->getSourceExpr() && Visit(E->getSourceExpr());
+  }
+  bool VisitCXXDefaultArgExpr(CXXDefaultArgExpr *E) {
+    return E->getExpr() && Visit(E->getExpr());
+  }
+  bool VisitCXXDefaultInitExpr(CXXDefaultInitExpr *E) {
+    return E->getExpr() && Visit(E->getExpr());
+  }
+  bool VisitExpressionTraitExpr(ExpressionTraitExpr *E) {
+    return E->getQueriedExpression() && Visit(E->getQueriedExpression());
+  }
+  unsigned VisitUnaryExprOrTypeTraitExpr(UnaryExprOrTypeTraitExpr *E) {
+    if (!E->isArgumentType())
+      return (E->getKind() == UETT_SizeOf) ? false
+                                           : Visit(E->getArgumentExpr());
+    return VisitStmt(E);
+  }
+  unsigned VisitLambdaExpr(LambdaExpr *E) { return false; }
+  bool VisitStmt(Stmt *S) {
+    for (Stmt::child_iterator I = S->child_begin(), E = S->child_end(); I != E;
+         ++I) {
+      if (*I && Visit(*I))
+        return true;
+    }
+    return false;
+  }
+  CEANExprChecker() {}
+};
 }
 
-#undef DSAStack
+ExprResult Sema::ActOnCEANIndexExpr(Scope *S, Expr *Base, Expr *LowerBound,
+                                    SourceLocation ColonLoc, Expr *Length) {
+  bool ArgsDep =
+      (Base && (Base->isTypeDependent() || Base->isValueDependent() ||
+                Base->isInstantiationDependent() ||
+                Base->containsUnexpandedParameterPack())) ||
+      (LowerBound &&
+       (LowerBound->isTypeDependent() || LowerBound->isValueDependent() ||
+        LowerBound->isInstantiationDependent() ||
+        LowerBound->containsUnexpandedParameterPack())) ||
+      (Length && (Length->isTypeDependent() || Length->isValueDependent() ||
+                  Length->isInstantiationDependent() ||
+                  Length->containsUnexpandedParameterPack()));
+
+  if (ArgsDep)
+    return new (Context)
+        CEANIndexExpr(Base, LowerBound, ColonLoc, Length, Context.IntTy);
+
+  SourceLocation SLoc;
+  if (LowerBound)
+    SLoc = LowerBound->getExprLoc();
+  else
+    SLoc = ColonLoc;
+  SourceLocation ELoc;
+  if (Length)
+    ELoc = Length->getLocEnd();
+  else
+    ELoc = ColonLoc;
+
+  QualType BaseType =
+      Base ? Base->getType().getNonReferenceType().getCanonicalType()
+           : QualType();
+  if (Base && ((Base->isGLValue() && Base->getObjectKind() != OK_Ordinary) ||
+               !BaseType->isCompoundType())) {
+    Diag(SLoc, diag::err_cean_not_in_statement) << SourceRange(SLoc, ELoc);
+    return ExprError();
+  }
+
+  if (!LowerBound)
+    LowerBound = ActOnIntegerConstant(ColonLoc, 0).get();
+  else {
+    CEANExprChecker Checker;
+    if (Checker.Visit(LowerBound)) {
+      Diag(LowerBound->getExprLoc(), diag::err_cean_not_in_statement)
+          << LowerBound->getSourceRange();
+      return ExprError();
+    }
+  }
+  if (!Length) {
+    if (!Base)
+      return ExprError();
+    QualType Type = Base->getType().getCanonicalType();
+    if (DeclRefExpr *DRE =
+            dyn_cast_or_null<DeclRefExpr>(Base->IgnoreParenLValueCasts())) {
+      if (ParmVarDecl *PVD = dyn_cast_or_null<ParmVarDecl>(DRE->getDecl())) {
+        Type = PVD->getOriginalType().getNonReferenceType().getCanonicalType();
+      }
+    }
+    if (!Type->isConstantArrayType() && !Type->isVariableArrayType()) {
+      Diag(ColonLoc, diag::err_cean_no_length_for_non_array) << Base->getType();
+      return ExprError();
+    }
+    const ArrayType *ArrType = Type->castAsArrayTypeUnsafe();
+    if (const ConstantArrayType *ConstArrType =
+            dyn_cast<ConstantArrayType>(ArrType))
+      Length = ActOnIntegerConstant(
+                   ColonLoc, ConstArrType->getSize().getZExtValue()).get();
+    else if (const VariableArrayType *VarArrType =
+                 dyn_cast<VariableArrayType>(ArrType))
+      Length = VarArrType->getSizeExpr();
+    Length = CreateBuiltinBinOp(ColonLoc, BO_Sub, Length, LowerBound).get();
+    if (!Length)
+      return ExprError();
+  } else {
+    CEANExprChecker Checker;
+    if (Checker.Visit(Length)) {
+      Diag(Length->getExprLoc(), diag::err_cean_not_in_statement)
+          << Length->getSourceRange();
+      return ExprError();
+    }
+  }
+
+  if (!LowerBound->getType()->isIntegerType()) {
+    Diag(LowerBound->getExprLoc(), diag::err_cean_lower_bound_not_integer)
+        << LowerBound->getType();
+    return ExprError();
+  }
+  if (!Length->getType()->isIntegerType()) {
+    Diag(Length->getExprLoc(), diag::err_cean_length_not_integer)
+        << Length->getType();
+    return ExprError();
+  }
+
+  ExprResult LowerBoundRes(LowerBound);
+  ExprResult LengthRes(Length);
+  QualType ResType = UsualArithmeticConversions(LowerBoundRes, LengthRes);
+  LowerBoundRes = PerformImplicitConversion(LowerBound, ResType, AA_Converting);
+  LengthRes = PerformImplicitConversion(Length, ResType, AA_Converting);
+  return new (Context) CEANIndexExpr(Base, LowerBoundRes.get(), ColonLoc,
+                                     LengthRes.get(), ResType);
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Sema/SemaOverload.cpp cfe-3.5.0.src.omp/lib/Sema/SemaOverload.cpp
--- cfe-3.5.0.src/lib/Sema/SemaOverload.cpp	2014-07-14 19:25:30.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Sema/SemaOverload.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -11002,6 +11002,7 @@
               SourceLocation(), Args[1]);
           if (Arg1.isInvalid())
             return ExprError();
+
           Args[0] = LHS = Arg0.getAs<Expr>();
           Args[1] = RHS = Arg1.getAs<Expr>();
         }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Sema/SemaStmt.cpp cfe-3.5.0.src.omp/lib/Sema/SemaStmt.cpp
--- cfe-3.5.0.src/lib/Sema/SemaStmt.cpp	2014-07-18 20:45:07.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Sema/SemaStmt.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -2419,9 +2419,6 @@
     // C99 6.8.6.3p1: A break shall appear only in or as a switch/loop body.
     return StmtError(Diag(BreakLoc, diag::err_break_not_in_loop_or_switch));
   }
-  if (S->isOpenMPLoopScope())
-    return StmtError(Diag(BreakLoc, diag::err_omp_loop_cannot_use_stmt)
-                     << "break");
 
   return new (Context) BreakStmt(BreakLoc);
 }
@@ -3193,9 +3190,6 @@
       !getSourceManager().isInSystemHeader(TryLoc))
       Diag(TryLoc, diag::err_exceptions_disabled) << "try";
 
-  if (getCurScope() && getCurScope()->isOpenMPSimdDirectiveScope())
-    Diag(TryLoc, diag::err_omp_simd_region_cannot_use_stmt) << "try";
-
   const unsigned NumHandlers = Handlers.size();
   assert(NumHandlers > 0 &&
          "The parser shouldn't call this if there are no handlers.");
@@ -3384,6 +3378,8 @@
   // Enter the capturing scope for this captured region.
   PushCapturedRegionScope(CurScope, CD, RD, Kind);
 
+  PushCompoundScope();
+
   if (CurScope)
     PushDeclContext(CurScope, CD);
   else
@@ -3436,6 +3432,8 @@
   // Enter the capturing scope for this captured region.
   PushCapturedRegionScope(CurScope, CD, RD, Kind);
 
+  PushCompoundScope();
+
   if (CurScope)
     PushDeclContext(CurScope, CD);
   else
@@ -3457,6 +3455,8 @@
               SourceLocation(), SourceLocation(), /*AttributeList=*/nullptr);
 
   PopDeclContext();
+  // Pop the compound scope we inserted implicitly.
+  PopCompoundScope();
   PopFunctionScopeInfo();
 }
 
@@ -3481,6 +3481,8 @@
   PopExpressionEvaluationContext();
 
   PopDeclContext();
+  // Pop the compound scope we inserted implicitly.
+  PopCompoundScope();
   PopFunctionScopeInfo();
 
   return Res;
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Sema/SemaTemplateInstantiateDecl.cpp cfe-3.5.0.src.omp/lib/Sema/SemaTemplateInstantiateDecl.cpp
--- cfe-3.5.0.src/lib/Sema/SemaTemplateInstantiateDecl.cpp	2014-07-10 16:53:43.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Sema/SemaTemplateInstantiateDecl.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -1491,6 +1491,14 @@
     PrincipalDecl->setNonMemberOperator();
 
   assert(!D->isDefaulted() && "only methods should be defaulted");
+  if (FunctionTemplate) {
+    OMPDeclareSimdDecl *DSimd = SemaRef.OMPDSimdMap[FunctionTemplate];
+    if (DSimd) {
+      OMPDeclareSimdDecl *TD = cast<OMPDeclareSimdDecl>(
+        TouchOMPDeclareSimdDecl(DSimd, Function, DC));
+      SemaRef.PendingOMP[Function] = TD;
+    }
+  }
   return Function;
 }
 
@@ -1759,7 +1767,20 @@
   } else if (!IsClassScopeSpecialization) {
     Owner->addDecl(Method);
   }
-
+  // Check for #omp declare simd in old record and add it into new record
+  // with our new method.
+  CXXRecordDecl *Parent = D->getParent();
+  for (DeclContext::decl_iterator DI = Parent->decls_begin(),
+                                  DE = Parent->decls_end();
+                                  DI != DE; ++DI) {
+    if (OMPDeclareSimdDecl *DSimd =
+        dyn_cast_or_null<OMPDeclareSimdDecl>(*DI)) {
+      if (dyn_cast_or_null<FunctionDecl>(DSimd->getFunction()) == D) {
+        TouchOMPDeclareSimdDecl(DSimd, Method,
+          SemaRef.CurContext);
+      }
+    }
+  }
   return Method;
 }
 
@@ -2307,8 +2328,10 @@
 Decl *TemplateDeclInstantiator::VisitOMPThreadPrivateDecl(
                                      OMPThreadPrivateDecl *D) {
   SmallVector<Expr *, 5> Vars;
-  for (auto *I : D->varlists()) {
-    Expr *Var = SemaRef.SubstExpr(I, TemplateArgs).get();
+  for (ArrayRef<Expr *>::iterator I = D->varlist_begin(),
+                                  E = D->varlist_end();
+       I != E; ++I) {
+    Expr *Var = SemaRef.SubstExpr(*I, TemplateArgs).get();
     assert(isa<DeclRefExpr>(Var) && "threadprivate arg is not a DeclRefExpr");
     Vars.push_back(Var);
   }
@@ -2322,6 +2345,218 @@
   return TD;
 }
 
+Decl *TemplateDeclInstantiator::VisitOMPDeclareSimdDecl(
+                                     OMPDeclareSimdDecl *D) {
+  return TouchOMPDeclareSimdDecl(D, D->getFunction(), Owner);
+}
+
+void TemplateDeclInstantiator::TouchOMPVarlist(
+                                     llvm::MutableArrayRef<clang::Expr*> VL,
+                                     SmallVector<Expr *, 4> &NewVL,
+                                     Decl *FuncDecl) {
+  for (llvm::MutableArrayRef<clang::Expr*>::iterator I = VL.begin(),
+                                                     E = VL.end();
+                                                     I != E; ++I) {
+    const DeclRefExpr *DRE = dyn_cast_or_null<DeclRefExpr>(*I);
+    assert(DRE);
+    DeclarationNameInfo DNI = DRE->getNameInfo();
+    Expr *NewV = SemaRef.FindOpenMPDeclarativeClauseParameter(
+                           DNI.getAsString(),
+                           DNI.getLoc(),
+                           FuncDecl);
+    assert(NewV);
+    NewVL.push_back(NewV);
+  }
+}
+
+Decl *TemplateDeclInstantiator::TouchOMPDeclareSimdDecl(
+                                     OMPDeclareSimdDecl *D,
+                                     Decl *NewFunc,
+                                     DeclContext *DC) {
+  SmallVector<SourceRange, 4> SrcRanges;
+  SmallVector<unsigned, 4> BeginIdx;
+  SmallVector<unsigned, 4> EndIdx;
+  // Perform AOS->SOA (will be done backward in CheckOMPDeclareSimdDecl).
+  for (ArrayRef<OMPDeclareSimdDecl::SimdVariant>::iterator
+      I = D->simd_variants_begin(),
+      E = D->simd_variants_end();
+      I != E; ++I) {
+    SrcRanges.push_back(I->SrcRange);
+    BeginIdx.push_back(I->BeginIdx);
+    EndIdx.push_back(I->EndIdx);
+  }
+  // Substitute the necessary stuff into the clauses.
+  SmallVector<OMPClause *, 4> CL;
+  for (OMPDeclareSimdDecl::clauses_iterator
+      J = D->clauses_begin(),
+      F = D->clauses_end();
+      J != F; ++J) {
+    if (OMPLinearClause *C = dyn_cast_or_null<OMPLinearClause>(*J)) {
+      Expr *Step = C->getStep();
+      Step = SemaRef.SubstExpr(Step, TemplateArgs).get();
+      SmallVector<Expr *, 4> NewVars;
+      TouchOMPVarlist(C->getVars(), NewVars, NewFunc);
+      OMPClause *NC = SemaRef.ActOnOpenMPDeclarativeLinearClause(
+          NewVars,
+          C->getLocStart(),
+          C->getLocEnd(),
+          Step,
+          C->getStepLoc());
+      CL.push_back(NC);
+    }
+    else if (OMPAlignedClause *C = dyn_cast_or_null<OMPAlignedClause>(*J)) {
+      Expr *Alignment = C->getAlignment();
+      Alignment = SemaRef.SubstExpr(Alignment, TemplateArgs).get();
+      SmallVector<Expr *, 4> NewVars;
+      TouchOMPVarlist(C->getVars(), NewVars, NewFunc);
+      OMPClause *NC = SemaRef.ActOnOpenMPDeclarativeAlignedClause(
+        NewVars,
+        C->getLocStart(),
+        C->getLocEnd(),
+        Alignment,
+        C->getAlignmentLoc());
+      CL.push_back(NC);
+    }
+    else if (OMPUniformClause *C = dyn_cast_or_null<OMPUniformClause>(*J)) {
+      SmallVector<Expr *, 4> NewVars;
+      TouchOMPVarlist(C->getVars(), NewVars, NewFunc);
+      OMPClause *NC = SemaRef.ActOnOpenMPDeclarativeUniformClause(
+        NewVars,
+        C->getLocStart(),
+        C->getLocEnd());
+      CL.push_back(NC);
+    }
+    else if (OMPSimdlenClause *C = dyn_cast_or_null<OMPSimdlenClause>(*J)) {
+      Expr *Length = C->getSimdlen();
+      Length = SemaRef.SubstExpr(Length, TemplateArgs).get();
+      OMPClause *NC = SemaRef.ActOnOpenMPSimdlenClause(
+          Length,
+          C->getLocStart(),
+          C->getLocEnd());
+      CL.push_back(NC);
+    }
+    else {
+      // May push NULL here -- CheckOMPDeclareSimdDecl will clean up.
+      CL.push_back(*J);
+    }
+  }
+
+  OMPDeclareSimdDecl *TD =
+    SemaRef.CheckOMPDeclareSimdDecl(D->getLocation(), NewFunc,
+              SrcRanges, BeginIdx, EndIdx, CL, DC);
+  TD->setAccess(AS_public);
+  DC->addDecl(TD);
+  return TD;
+}
+
+
+Decl *TemplateDeclInstantiator::VisitOMPDeclareReductionDecl(
+                                     OMPDeclareReductionDecl *D) {
+  if (D->isInvalidDecl()) return D;
+  SmallVector<QualType, 16> Types;
+  SmallVector<SourceRange, 16> TyRanges;
+  bool IsValid = true;
+  for (ArrayRef<OMPDeclareReductionDecl::ReductionData>::iterator
+                                               I = D->datalist_begin(),
+                                               E = D->datalist_end();
+       I != E; ++I) {
+    if (I->QTy.isNull()) {
+      Types.push_back(QualType());
+      TyRanges.push_back(SourceRange());
+      IsValid = false;
+      continue;
+    }
+    QualType ResQTy = SemaRef.SubstType(I->QTy, TemplateArgs,
+                                        D->getLocation(), DeclarationName());
+    if (!ResQTy.isNull() &&
+        SemaRef.IsOMPDeclareReductionTypeAllowed(I->TyRange, ResQTy,
+                                                 Types, TyRanges)) {
+      Types.push_back(ResQTy);
+      TyRanges.push_back(I->TyRange);
+    } else {
+      Types.push_back(QualType());
+      TyRanges.push_back(SourceRange());
+      IsValid = false;
+    }
+  }
+  if (!IsValid) return 0;
+
+  SmallVector<Expr *, 16> Combiners;
+  SmallVector<Expr *, 16> Inits;
+  Decl *NewDR;
+  {
+    Sema::OMPDeclareReductionRAII RAII(SemaRef, 0, Owner,
+                                       D->getLocation(), D->getDeclName(),
+                                       D->datalist_size(), D->getAccess());
+    NewDR = RAII.getDecl();
+    DeclContext *NewOwner = cast<DeclContext>(NewDR);
+    SemaRef.OMPInstantiatedDecls.clear();
+
+    LocalInstantiationScope Scope(SemaRef);
+    Scope.InstantiatedLocal(D, NewDR);
+    for (DeclContext::decl_iterator I = D->decls_begin(), E = D->decls_end();
+         I != E; ++I) {
+      if ((*I)->getDeclContext() != D) continue;
+      if ((*I)->isInvalidDecl()) {
+        RAII.getDecl()->setInvalidDecl();
+        continue;
+      }
+      Decl *NewD = SemaRef.SubstDecl(*I, NewOwner, TemplateArgs);
+      if (!NewD || NewD->isInvalidDecl()) {
+        NewDR->setInvalidDecl();
+        return NewDR;
+      }
+      if (FunctionDecl *FD = cast<FunctionDecl>(NewD)) {
+        if ((*I)->hasBody()) {
+          SemaRef.InstantiateFunctionDefinition(SourceLocation(),
+                                                FD, false, true);
+        } else {
+          Sema::ContextRAII S(SemaRef, FD);
+          // Only init function may have just a declaration.
+          ParmVarDecl *ParLHS = FD->getParamDecl(0);
+          // The first parameter is a pointer.
+          QualType QTy = (ParLHS->getType())->getPointeeType();
+          VarDecl *OmpPriv =
+            VarDecl::Create(SemaRef.Context, FD, SourceLocation(),
+                            SourceLocation(),
+                            &SemaRef.Context.Idents.get("omp_priv_inst"),
+                            QTy, SemaRef.Context.getTrivialTypeSourceInfo(QTy),
+                            SC_Auto);
+          FD->addDecl(OmpPriv);
+          SemaRef.CreateDefaultDeclareReductionInitFunctionBody(FD, OmpPriv,
+                                                                ParLHS);
+        }
+      }
+      NewOwner->addDecl(NewD);
+      SemaRef.OMPInstantiatedDecls[*I] = NewD;
+    }
+
+    SmallVectorImpl<QualType>::iterator IT = Types.begin();
+    for (ArrayRef<OMPDeclareReductionDecl::ReductionData>::iterator
+                                                 I = D->datalist_begin(),
+                                                 E = D->datalist_end();
+         I != E; ++I, ++IT) {
+      if (!IT->isNull()) {
+        Combiners.push_back(SemaRef.SubstExpr(I->CombinerFunction,
+                                              TemplateArgs).get());
+        Inits.push_back(SemaRef.SubstExpr(I->InitFunction, TemplateArgs).get());
+      }
+    }
+
+    SemaRef.OMPInstantiatedDecls.clear();
+  }
+
+  SemaRef.CompleteOMPDeclareReductionDecl(
+                         cast<OMPDeclareReductionDecl>(NewDR),
+                         Types, TyRanges, Combiners, Inits);
+  return NewDR;
+}
+
+Decl *
+TemplateDeclInstantiator::VisitOMPDeclareTargetDecl(OMPDeclareTargetDecl *D) {
+  llvm_unreachable("OpenMP declare target cannot be instantiated");
+}
+
 Decl *TemplateDeclInstantiator::VisitFunctionDecl(FunctionDecl *D) {
   return VisitFunctionDecl(D, nullptr);
 }
@@ -3456,6 +3691,12 @@
   DeclGroupRef DG(Function);
   Consumer.HandleTopLevelDecl(DG);
 
+  PendingOMPInstMap::iterator IOMP = PendingOMP.find(Function);
+  if (IOMP != PendingOMP.end()) {
+    DeclGroupRef DGOMP(IOMP->second);
+    Consumer.HandleTopLevelDecl(DGOMP);
+  }
+
   // This class may have local implicit instantiations that need to be
   // instantiation within this scope.
   PerformPendingInstantiations(/*LocalOnly=*/true);
@@ -4543,7 +4784,9 @@
     }
 
     NamedDecl *Result = nullptr;
-    if (D->getDeclName()) {
+    if (isa<OMPDeclareReductionDecl>(ParentDC) && isa<FunctionDecl>(D)) {
+      Result = cast<NamedDecl>(OMPInstantiatedDecls[D]);
+    } else if (D->getDeclName()) {
       DeclContext::lookup_result Found = ParentDC->lookup(D->getDeclName());
       Result = findInstantiationOf(Context, D, Found.begin(), Found.end());
     } else {
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Sema/TreeTransform.h cfe-3.5.0.src.omp/lib/Sema/TreeTransform.h
--- cfe-3.5.0.src/lib/Sema/TreeTransform.h	2014-08-04 14:37:31.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Sema/TreeTransform.h	2014-11-28 10:49:30.000000000 -0500
@@ -613,8 +613,6 @@
       ParenExpr *PE, DependentScopeDeclRefExpr *DRE, bool IsAddressOfOperand,
       TypeSourceInfo **RecoveryTSI);
 
-  StmtResult TransformOMPExecutableDirective(OMPExecutableDirective *S);
-
 // FIXME: We use LLVM_ATTRIBUTE_NOINLINE because inlining causes a ridiculous
 // amount of stack usage with clang.
 #define STMT(Node, Parent)                        \
@@ -626,6 +624,8 @@
 #define ABSTRACT_STMT(Stmt)
 #include "clang/AST/StmtNodes.inc"
 
+  StmtResult TransformOMPExecutableDirective(OMPExecutableDirective *S);
+
 #define OPENMP_CLAUSE(Name, Class)                        \
   LLVM_ATTRIBUTE_NOINLINE \
   OMPClause *Transform ## Class(Class *S);
@@ -1300,66 +1300,63 @@
   StmtResult RebuildOMPExecutableDirective(OpenMPDirectiveKind Kind,
                                            DeclarationNameInfo DirName,
                                            ArrayRef<OMPClause *> Clauses,
-                                           Stmt *AStmt, SourceLocation StartLoc,
-                                           SourceLocation EndLoc) {
+                                           Stmt *AStmt,
+                                           SourceLocation StartLoc,
+                                           SourceLocation EndLoc,
+                                           OpenMPDirectiveKind ConstructType) {
     return getSema().ActOnOpenMPExecutableDirective(Kind, DirName, Clauses,
-                                                    AStmt, StartLoc, EndLoc);
+                                                    AStmt, StartLoc, EndLoc,
+                                                    ConstructType);
   }
 
   /// \brief Build a new OpenMP 'if' clause.
   ///
-  /// By default, performs semantic analysis to build the new OpenMP clause.
+  /// By default, performs semantic analysis to build the new statement.
   /// Subclasses may override this routine to provide different behavior.
   OMPClause *RebuildOMPIfClause(Expr *Condition,
                                 SourceLocation StartLoc,
-                                SourceLocation LParenLoc,
                                 SourceLocation EndLoc) {
-    return getSema().ActOnOpenMPIfClause(Condition, StartLoc,
-                                         LParenLoc, EndLoc);
+    return getSema().ActOnOpenMPIfClause(Condition, StartLoc, EndLoc);
   }
 
   /// \brief Build a new OpenMP 'final' clause.
   ///
-  /// By default, performs semantic analysis to build the new OpenMP clause.
+  /// By default, performs semantic analysis to build the new statement.
   /// Subclasses may override this routine to provide different behavior.
-  OMPClause *RebuildOMPFinalClause(Expr *Condition, SourceLocation StartLoc,
-                                   SourceLocation LParenLoc,
+  OMPClause *RebuildOMPFinalClause(Expr *Condition,
+                                   SourceLocation StartLoc,
                                    SourceLocation EndLoc) {
-    return getSema().ActOnOpenMPFinalClause(Condition, StartLoc, LParenLoc,
-                                            EndLoc);
+    return getSema().ActOnOpenMPFinalClause(Condition, StartLoc, EndLoc);
   }
 
   /// \brief Build a new OpenMP 'num_threads' clause.
   ///
-  /// By default, performs semantic analysis to build the new OpenMP clause.
+  /// By default, performs semantic analysis to build the new statement.
   /// Subclasses may override this routine to provide different behavior.
   OMPClause *RebuildOMPNumThreadsClause(Expr *NumThreads,
                                         SourceLocation StartLoc,
-                                        SourceLocation LParenLoc,
                                         SourceLocation EndLoc) {
-    return getSema().ActOnOpenMPNumThreadsClause(NumThreads, StartLoc,
-                                                 LParenLoc, EndLoc);
+    return getSema().ActOnOpenMPNumThreadsClause(NumThreads, StartLoc, EndLoc);
   }
 
-  /// \brief Build a new OpenMP 'safelen' clause.
+  /// \brief Build a new OpenMP 'collapse' clause.
   ///
-  /// By default, performs semantic analysis to build the new OpenMP clause.
+  /// By default, performs semantic analysis to build the new statement.
   /// Subclasses may override this routine to provide different behavior.
-  OMPClause *RebuildOMPSafelenClause(Expr *Len, SourceLocation StartLoc,
-                                     SourceLocation LParenLoc,
-                                     SourceLocation EndLoc) {
-    return getSema().ActOnOpenMPSafelenClause(Len, StartLoc, LParenLoc, EndLoc);
+  OMPClause *RebuildOMPCollapseClause(Expr *NumForLoops,
+                                      SourceLocation StartLoc,
+                                      SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPCollapseClause(NumForLoops, StartLoc, EndLoc);
   }
 
-  /// \brief Build a new OpenMP 'collapse' clause.
+  /// \brief Build a new OpenMP 'device' clause.
   ///
-  /// By default, performs semantic analysis to build the new OpenMP clause.
+  /// By default, performs semantic analysis to build the new statement.
   /// Subclasses may override this routine to provide different behavior.
-  OMPClause *RebuildOMPCollapseClause(Expr *Num, SourceLocation StartLoc,
-                                      SourceLocation LParenLoc,
-                                      SourceLocation EndLoc) {
-    return getSema().ActOnOpenMPCollapseClause(Num, StartLoc, LParenLoc,
-                                               EndLoc);
+  OMPClause *RebuildOMPDeviceClause(Expr *Device,
+                                    SourceLocation StartLoc,
+                                    SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPDeviceClause(Device, StartLoc, EndLoc);
   }
 
   /// \brief Build a new OpenMP 'default' clause.
@@ -1367,12 +1364,49 @@
   /// By default, performs semantic analysis to build the new OpenMP clause.
   /// Subclasses may override this routine to provide different behavior.
   OMPClause *RebuildOMPDefaultClause(OpenMPDefaultClauseKind Kind,
-                                     SourceLocation KindKwLoc,
+                                     SourceLocation KindLoc,
                                      SourceLocation StartLoc,
-                                     SourceLocation LParenLoc,
                                      SourceLocation EndLoc) {
-    return getSema().ActOnOpenMPDefaultClause(Kind, KindKwLoc,
-                                              StartLoc, LParenLoc, EndLoc);
+    return getSema().ActOnOpenMPDefaultClause(Kind, KindLoc,
+                                              StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'proc_bind' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPProcBindClause(OpenMPProcBindClauseKind Kind,
+                                      SourceLocation KindLoc,
+                                      SourceLocation StartLoc,
+                                      SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPProcBindClause(Kind, KindLoc,
+                                               StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'schedule' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPScheduleClause(OpenMPScheduleClauseKind Kind,
+                                      SourceLocation KindLoc,
+                                      Expr *ChunkSize,
+                                      SourceLocation StartLoc,
+                                      SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPScheduleClause(Kind, KindLoc, ChunkSize,
+                                               StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'dist_schedule' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPDistScheduleClause(OpenMPDistScheduleClauseKind Kind,
+                                          SourceLocation KindLoc,
+                                          Expr *ChunkSize,
+                                          SourceLocation StartLoc,
+                                          SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPDistScheduleClause(Kind, KindLoc, ChunkSize,
+                                                   StartLoc, EndLoc);
   }
 
   /// \brief Build a new OpenMP 'proc_bind' clause.
@@ -1409,46 +1443,311 @@
   /// Subclasses may override this routine to provide different behavior.
   OMPClause *RebuildOMPPrivateClause(ArrayRef<Expr *> VarList,
                                      SourceLocation StartLoc,
-                                     SourceLocation LParenLoc,
                                      SourceLocation EndLoc) {
-    return getSema().ActOnOpenMPPrivateClause(VarList, StartLoc, LParenLoc,
-                                              EndLoc);
+    return getSema().ActOnOpenMPPrivateClause(VarList,
+                                              StartLoc, EndLoc);
   }
 
   /// \brief Build a new OpenMP 'firstprivate' clause.
   ///
   /// By default, performs semantic analysis to build the new OpenMP clause.
   /// Subclasses may override this routine to provide different behavior.
-  OMPClause *RebuildOMPFirstprivateClause(ArrayRef<Expr *> VarList,
+  OMPClause *RebuildOMPFirstPrivateClause(ArrayRef<Expr *> VarList,
                                           SourceLocation StartLoc,
-                                          SourceLocation LParenLoc,
                                           SourceLocation EndLoc) {
-    return getSema().ActOnOpenMPFirstprivateClause(VarList, StartLoc, LParenLoc,
-                                                   EndLoc);
+    return getSema().ActOnOpenMPFirstPrivateClause(VarList,
+                                                   StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'shared' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPSharedClause(ArrayRef<Expr *> VarList,
+                                    SourceLocation StartLoc,
+                                    SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPSharedClause(VarList,
+                                             StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'copyin' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPCopyinClause(ArrayRef<Expr *> VarList,
+                                    SourceLocation StartLoc,
+                                    SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPCopyinClause(VarList,
+                                             StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'copyprivate' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPCopyPrivateClause(ArrayRef<Expr *> VarList,
+                                         SourceLocation StartLoc,
+                                         SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPCopyPrivateClause(VarList,
+                                                  StartLoc, EndLoc);
   }
 
   /// \brief Build a new OpenMP 'lastprivate' clause.
   ///
-  /// By default, performs semantic analysis to build the new OpenMP clause.
+  /// By default, performs semantic analysis to build the new statement.
   /// Subclasses may override this routine to provide different behavior.
-  OMPClause *RebuildOMPLastprivateClause(ArrayRef<Expr *> VarList,
+  OMPClause *RebuildOMPLastPrivateClause(ArrayRef<Expr *> VarList,
                                          SourceLocation StartLoc,
-                                         SourceLocation LParenLoc,
                                          SourceLocation EndLoc) {
-    return getSema().ActOnOpenMPLastprivateClause(VarList, StartLoc, LParenLoc,
-                                                  EndLoc);
+    return getSema().ActOnOpenMPLastPrivateClause(VarList,
+                                                  StartLoc, EndLoc);
   }
 
-  /// \brief Build a new OpenMP 'shared' clause.
+  /// \brief Build a new OpenMP 'reduction' clause.
   ///
-  /// By default, performs semantic analysis to build the new OpenMP clause.
+  /// By default, performs semantic analysis to build the new statement.
   /// Subclasses may override this routine to provide different behavior.
-  OMPClause *RebuildOMPSharedClause(ArrayRef<Expr *> VarList,
+  OMPClause *RebuildOMPReductionClause(ArrayRef<Expr *> VarList,
+                                       SourceLocation StartLoc,
+                                       SourceLocation EndLoc,
+                                       OpenMPReductionClauseOperator Op,
+                                       CXXScopeSpec &SS,
+                                       DeclarationNameInfo OpName) {
+    return getSema().ActOnOpenMPReductionClause(VarList,
+                                                StartLoc, EndLoc, Op,
+                                                SS, OpName);
+  }
+
+  /// \brief Build a new OpenMP 'depend' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPDependClause(ArrayRef<Expr *> VarList,
                                     SourceLocation StartLoc,
-                                    SourceLocation LParenLoc,
+                                    SourceLocation EndLoc,
+                                    OpenMPDependClauseType Ty,
+                                    SourceLocation TyLoc) {
+    return getSema().ActOnOpenMPDependClause(VarList, StartLoc, EndLoc, Ty,
+                                             TyLoc);
+  }
+
+  /// \brief Build a new OpenMP 'map' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPMapClause(ArrayRef<Expr *> VarList,
+                                 SourceLocation StartLoc,
+                                 SourceLocation EndLoc,
+                                 OpenMPMapClauseKind Kind,
+                                 SourceLocation KindLoc) {
+    return getSema().ActOnOpenMPMapClause(VarList, StartLoc, EndLoc, Kind,
+                                          KindLoc);
+  }
+
+  /// \brief Build a new OpenMP 'to' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPToClause(ArrayRef<Expr *> VarList,
+                                SourceLocation StartLoc,
+                                SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPToClause(VarList, StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'from' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPFromClause(ArrayRef<Expr *> VarList,
+                                  SourceLocation StartLoc,
+                                  SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPFromClause(VarList, StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'ordered' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPOrderedClause(SourceLocation StartLoc,
+                                     SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPOrderedClause(StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'nowait' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPNowaitClause(SourceLocation StartLoc,
                                     SourceLocation EndLoc) {
-    return getSema().ActOnOpenMPSharedClause(VarList, StartLoc, LParenLoc,
-                                             EndLoc);
+    return getSema().ActOnOpenMPNowaitClause(StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'untied' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPUntiedClause(SourceLocation StartLoc,
+                                    SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPUntiedClause(StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'mergeable' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPMergeableClause(SourceLocation StartLoc,
+                                       SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPMergeableClause(StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'read' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPReadClause(SourceLocation StartLoc,
+                                  SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPReadClause(StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'write' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPWriteClause(SourceLocation StartLoc,
+                                   SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPWriteClause(StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'update' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPUpdateClause(SourceLocation StartLoc,
+                                    SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPUpdateClause(StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'capture' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPCaptureClause(SourceLocation StartLoc,
+                                     SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPCaptureClause(StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'seq_cst' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPSeqCstClause(SourceLocation StartLoc,
+                                    SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPSeqCstClause(StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'inbranch' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPInBranchClause(SourceLocation StartLoc,
+                                      SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPInBranchClause(StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'notinbranch' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPNotInBranchClause(SourceLocation StartLoc,
+                                         SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPNotInBranchClause(StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP list of vars for 'flush' directive.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPFlushClause(ArrayRef<Expr *> VarList,
+                                   SourceLocation StartLoc,
+                                   SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPFlushClause(VarList, StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP list of vars for 'uniform' directive.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPUniformClause(ArrayRef<Expr *> VarList,
+                                     SourceLocation StartLoc,
+                                     SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPUniformClause(VarList, StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'safelen' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPSafelenClause(Expr *Len,
+                                     SourceLocation StartLoc,
+                                     SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPSafelenClause(Len, StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'simdlen' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPSimdlenClause(Expr *Len,
+                                     SourceLocation StartLoc,
+                                     SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPSimdlenClause(Len, StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'num_teams' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPNumTeamsClause(Expr *NumTeams,
+                                      SourceLocation StartLoc,
+                                      SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPNumTeamsClause(NumTeams, StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'thread_limit' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPThreadLimitClause(Expr *ThreadLimit,
+                                         SourceLocation StartLoc,
+                                         SourceLocation EndLoc) {
+    return getSema().ActOnOpenMPThreadLimitClause(ThreadLimit,
+                                                  StartLoc, EndLoc);
+  }
+
+  /// \brief Build a new OpenMP 'linear' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPLinearClause(ArrayRef<Expr *> VarList,
+                                    SourceLocation StartLoc,
+                                    SourceLocation EndLoc,
+                                    Expr *Step,
+                                    SourceLocation StepLoc) {
+    return getSema().ActOnOpenMPLinearClause(VarList, StartLoc, EndLoc,
+                                             Step, StepLoc);
+  }
+
+  /// \brief Build a new OpenMP 'aligned' clause.
+  ///
+  /// By default, performs semantic analysis to build the new statement.
+  /// Subclasses may override this routine to provide different behavior.
+  OMPClause *RebuildOMPAlignedClause(ArrayRef<Expr *> VarList,
+                                     SourceLocation StartLoc,
+                                     SourceLocation EndLoc,
+                                     Expr *Alignment,
+                                     SourceLocation AlignmentLoc) {
+    return getSema().ActOnOpenMPAlignedClause(VarList, StartLoc, EndLoc,
+                                              Alignment, AlignmentLoc);
   }
 
   /// \brief Build a new OpenMP 'reduction' clause.
@@ -1793,6 +2092,17 @@
                                              RBracketLoc);
   }
 
+  /// \brief Build a new CEAN index expression.
+  ///
+  /// By default, performs semantic analysis to build the new expression.
+  /// Subclasses may override this routine to provide different behavior.
+  ExprResult RebuildCEANIndexExpr(Expr *Base, Expr *LowerBound,
+                                  SourceLocation ColonLoc,
+                                  Expr *Length) {
+    return getSema().ActOnCEANIndexExpr(0, Base, LowerBound, ColonLoc,
+                                        Length);
+  }
+
   /// \brief Build a new call expression.
   ///
   /// By default, performs semantic analysis to build the new expression.
@@ -6271,7 +6581,7 @@
   return FinishCXXForRangeStmt(NewStmt.get(), Body.get());
 }
 
-template<typename Derived>
+template <typename Derived>
 StmtResult
 TreeTransform<Derived>::TransformMSDependentExistsStmt(
                                                     MSDependentExistsStmt *S) {
@@ -6428,64 +6738,96 @@
 template <typename Derived>
 StmtResult TreeTransform<Derived>::TransformOMPExecutableDirective(
     OMPExecutableDirective *D) {
-
   // Transform the clauses
-  llvm::SmallVector<OMPClause *, 16> TClauses;
+  llvm::SmallVector<OMPClause *, 5> TClauses;
   ArrayRef<OMPClause *> Clauses = D->clauses();
   TClauses.reserve(Clauses.size());
   for (ArrayRef<OMPClause *>::iterator I = Clauses.begin(), E = Clauses.end();
        I != E; ++I) {
     if (*I) {
       OMPClause *Clause = getDerived().TransformOMPClause(*I);
-      if (Clause)
-        TClauses.push_back(Clause);
+      if (!Clause)
+        return StmtError();
+      TClauses.push_back(Clause);
     } else {
-      TClauses.push_back(nullptr);
+      TClauses.push_back(0);
     }
   }
   StmtResult AssociatedStmt;
-  if (D->hasAssociatedStmt()) {
-    if (!D->getAssociatedStmt()) {
+  if (D->hasAssociatedStmt() && D->getAssociatedStmt()) {
+    CapturedStmt *S = cast<CapturedStmt>(D->getAssociatedStmt());
+    SourceLocation Loc = S->getLocStart();
+    unsigned NumParams = S->getCapturedDecl()->getNumParams();
+    getSema().ActOnCapturedRegionStart(Loc, /*CurScope*/ 0,
+                                       S->getCapturedRegionKind(), NumParams);
+    StmtResult Body = getDerived().TransformStmt(S->getCapturedStmt());
+
+    if (Body.isInvalid()) {
+      getSema().ActOnCapturedRegionError();
       return StmtError();
     }
-    AssociatedStmt = getDerived().TransformStmt(D->getAssociatedStmt());
-    if (AssociatedStmt.isInvalid()) {
+
+    getSema().MarkOpenMPClauses(TClauses);
+    AssociatedStmt = getSema().ActOnCapturedRegionEnd(Body.get());
+    if (!AssociatedStmt.isUsable())
       return StmtError();
-    }
-  }
-  if (TClauses.size() != Clauses.size()) {
+  } else if (D->hasAssociatedStmt())
     return StmtError();
-  }
-
-  // Transform directive name for 'omp critical' directive.
+  Stmt *AStmt = AssociatedStmt.get();
   DeclarationNameInfo DirName;
   if (D->getDirectiveKind() == OMPD_critical) {
     DirName = cast<OMPCriticalDirective>(D)->getDirectiveName();
     DirName = getDerived().TransformDeclarationNameInfo(DirName);
   }
+  OpenMPDirectiveKind ConstructType = OMPD_unknown;
+  if (D->getDirectiveKind() == OMPD_cancel) {
+    ConstructType = cast<OMPCancelDirective>(D)->getConstructType();
+  } else if (D->getDirectiveKind() == OMPD_cancellation_point) {
+    ConstructType = cast<OMPCancellationPointDirective>(D)->getConstructType();
+  }
 
   return getDerived().RebuildOMPExecutableDirective(
-      D->getDirectiveKind(), DirName, TClauses, AssociatedStmt.get(),
-      D->getLocStart(), D->getLocEnd());
+      D->getDirectiveKind(), DirName, TClauses, AStmt, D->getLocStart(),
+      D->getLocEnd(), ConstructType);
 }
 
 template <typename Derived>
 StmtResult
 TreeTransform<Derived>::TransformOMPParallelDirective(OMPParallelDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_parallel, DirName, nullptr,
-                                             D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_parallel, DirName, nullptr);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
 }
 
 template <typename Derived>
-StmtResult
-TreeTransform<Derived>::TransformOMPSimdDirective(OMPSimdDirective *D) {
+StmtResult TreeTransform<Derived>::TransformOMPParallelForDirective(
+    OMPParallelForDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_parallel_for, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult TreeTransform<Derived>::TransformOMPParallelForSimdDirective(
+    OMPParallelForSimdDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_parallel_for_simd, DirName,
+                                             0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult TreeTransform<Derived>::TransformOMPParallelSectionsDirective(
+    OMPParallelSectionsDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_simd, DirName, nullptr,
-                                             D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_parallel_sections, DirName,
+                                             0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
@@ -6495,8 +6837,7 @@
 StmtResult
 TreeTransform<Derived>::TransformOMPForDirective(OMPForDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_for, DirName, nullptr,
-                                             D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_for, DirName, 0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
@@ -6504,10 +6845,9 @@
 
 template <typename Derived>
 StmtResult
-TreeTransform<Derived>::TransformOMPSectionsDirective(OMPSectionsDirective *D) {
+TreeTransform<Derived>::TransformOMPSimdDirective(OMPSimdDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_sections, DirName, nullptr,
-                                             D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_simd, DirName, 0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
@@ -6515,10 +6855,30 @@
 
 template <typename Derived>
 StmtResult
-TreeTransform<Derived>::TransformOMPSectionDirective(OMPSectionDirective *D) {
+TreeTransform<Derived>::TransformOMPForSimdDirective(OMPForSimdDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_for_simd, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult TreeTransform<Derived>::TransformOMPDistributeSimdDirective(
+    OMPDistributeSimdDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_distribute_simd, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult TreeTransform<Derived>::TransformOMPDistributeParallelForDirective(
+    OMPDistributeParallelForDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_section, DirName, nullptr,
-                                             D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_distribute_parallel_for,
+                                             DirName, 0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
@@ -6526,10 +6886,11 @@
 
 template <typename Derived>
 StmtResult
-TreeTransform<Derived>::TransformOMPSingleDirective(OMPSingleDirective *D) {
+TreeTransform<Derived>::TransformOMPDistributeParallelForSimdDirective(
+    OMPDistributeParallelForSimdDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_single, DirName, nullptr,
-                                             D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_distribute_parallel_for_simd,
+                                             DirName, 0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
@@ -6537,10 +6898,11 @@
 
 template <typename Derived>
 StmtResult
-TreeTransform<Derived>::TransformOMPMasterDirective(OMPMasterDirective *D) {
+TreeTransform<Derived>::TransformOMPTeamsDistributeParallelForDirective(
+    OMPTeamsDistributeParallelForDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_master, DirName, nullptr,
-                                             D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_teams_distribute_parallel_for,
+                                             DirName, 0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
@@ -6548,31 +6910,65 @@
 
 template <typename Derived>
 StmtResult
-TreeTransform<Derived>::TransformOMPCriticalDirective(OMPCriticalDirective *D) {
+TreeTransform<Derived>::TransformOMPTeamsDistributeParallelForSimdDirective(
+    OMPTeamsDistributeParallelForSimdDirective *D) {
+  DeclarationNameInfo DirName;
   getDerived().getSema().StartOpenMPDSABlock(
-      OMPD_critical, D->getDirectiveName(), nullptr, D->getLocStart());
+      OMPD_teams_distribute_parallel_for_simd, DirName, 0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
 }
 
 template <typename Derived>
-StmtResult TreeTransform<Derived>::TransformOMPParallelForDirective(
-    OMPParallelForDirective *D) {
+StmtResult
+TreeTransform<Derived>::TransformOMPTargetTeamsDistributeParallelForDirective(
+    OMPTargetTeamsDistributeParallelForDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_parallel_for, DirName,
-                                             nullptr, D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(
+      OMPD_target_teams_distribute_parallel_for, DirName, 0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
 }
 
 template <typename Derived>
-StmtResult TreeTransform<Derived>::TransformOMPParallelSectionsDirective(
-    OMPParallelSectionsDirective *D) {
+StmtResult TreeTransform<Derived>::
+    TransformOMPTargetTeamsDistributeParallelForSimdDirective(
+        OMPTargetTeamsDistributeParallelForSimdDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_parallel_sections, DirName,
-                                             nullptr, D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(
+      OMPD_target_teams_distribute_parallel_for_simd, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult
+TreeTransform<Derived>::TransformOMPSectionsDirective(OMPSectionsDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_sections, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult
+TreeTransform<Derived>::TransformOMPSectionDirective(OMPSectionDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_section, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult
+TreeTransform<Derived>::TransformOMPSingleDirective(OMPSingleDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_single, DirName, 0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
@@ -6582,8 +6978,7 @@
 StmtResult
 TreeTransform<Derived>::TransformOMPTaskDirective(OMPTaskDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_task, DirName, nullptr,
-                                             D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_task, DirName, 0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
@@ -6593,8 +6988,27 @@
 StmtResult TreeTransform<Derived>::TransformOMPTaskyieldDirective(
     OMPTaskyieldDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_taskyield, DirName, nullptr,
-                                             D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_taskyield, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult
+TreeTransform<Derived>::TransformOMPMasterDirective(OMPMasterDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_master, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult
+TreeTransform<Derived>::TransformOMPCriticalDirective(OMPCriticalDirective *D) {
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_critical,
+                                             D->getDirectiveName(), 0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
@@ -6604,8 +7018,7 @@
 StmtResult
 TreeTransform<Derived>::TransformOMPBarrierDirective(OMPBarrierDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_barrier, DirName, nullptr,
-                                             D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_barrier, DirName, 0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
@@ -6615,8 +7028,27 @@
 StmtResult
 TreeTransform<Derived>::TransformOMPTaskwaitDirective(OMPTaskwaitDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_taskwait, DirName, nullptr,
-                                             D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_taskwait, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult TreeTransform<Derived>::TransformOMPTaskgroupDirective(
+    OMPTaskgroupDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_taskgroup, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult
+TreeTransform<Derived>::TransformOMPAtomicDirective(OMPAtomicDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_atomic, DirName, 0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
@@ -6626,284 +7058,642 @@
 StmtResult
 TreeTransform<Derived>::TransformOMPFlushDirective(OMPFlushDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_flush, DirName, nullptr,
-                                             D->getLocStart());
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_flush, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult
+TreeTransform<Derived>::TransformOMPOrderedDirective(OMPOrderedDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_ordered, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult
+TreeTransform<Derived>::TransformOMPTeamsDirective(OMPTeamsDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_teams, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult TreeTransform<Derived>::TransformOMPDistributeDirective(
+    OMPDistributeDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_distribute, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult
+TreeTransform<Derived>::TransformOMPCancelDirective(OMPCancelDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_cancel, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult TreeTransform<Derived>::TransformOMPCancellationPointDirective(
+    OMPCancellationPointDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_cancellation_point, DirName,
+                                             0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult
+TreeTransform<Derived>::TransformOMPTargetDirective(OMPTargetDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_target, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult TreeTransform<Derived>::TransformOMPTargetDataDirective(
+    OMPTargetDataDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_target_data, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult TreeTransform<Derived>::TransformOMPTargetUpdateDirective(
+    OMPTargetUpdateDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_target_update, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult TreeTransform<Derived>::TransformOMPTargetTeamsDirective(
+    OMPTargetTeamsDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_target_teams, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult TreeTransform<Derived>::TransformOMPTeamsDistributeDirective(
+    OMPTeamsDistributeDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_teams_distribute, DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult TreeTransform<Derived>::TransformOMPTeamsDistributeSimdDirective(
+    OMPTeamsDistributeSimdDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_teams_distribute_simd,
+                                             DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult TreeTransform<Derived>::TransformOMPTargetTeamsDistributeDirective(
+    OMPTargetTeamsDistributeDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_target_teams_distribute,
+                                             DirName, 0);
+  StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
+  getDerived().getSema().EndOpenMPDSABlock(Res.get());
+  return Res;
+}
+
+template <typename Derived>
+StmtResult
+TreeTransform<Derived>::TransformOMPTargetTeamsDistributeSimdDirective(
+    OMPTargetTeamsDistributeSimdDirective *D) {
+  DeclarationNameInfo DirName;
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_target_teams_distribute_simd,
+                                             DirName, 0);
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
   return Res;
 }
 
-//===----------------------------------------------------------------------===//
-// OpenMP clause transformation
-//===----------------------------------------------------------------------===//
 template <typename Derived>
 OMPClause *TreeTransform<Derived>::TransformOMPIfClause(OMPIfClause *C) {
-  ExprResult Cond = getDerived().TransformExpr(C->getCondition());
-  if (Cond.isInvalid())
-    return nullptr;
-  return getDerived().RebuildOMPIfClause(Cond.get(), C->getLocStart(),
-                                         C->getLParenLoc(), C->getLocEnd());
+  // Transform condition.
+  ExprResult E = getDerived().TransformExpr(C->getCondition());
+
+  if (E.isInvalid())
+    return 0;
+
+  return getDerived().RebuildOMPIfClause(E.get(), C->getLocStart(),
+                                         C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *TreeTransform<Derived>::TransformOMPFinalClause(OMPFinalClause *C) {
-  ExprResult Cond = getDerived().TransformExpr(C->getCondition());
-  if (Cond.isInvalid())
-    return nullptr;
-  return getDerived().RebuildOMPFinalClause(Cond.get(), C->getLocStart(),
-                                            C->getLParenLoc(), C->getLocEnd());
+  // Transform condition.
+  ExprResult E = getDerived().TransformExpr(C->getCondition());
+
+  if (E.isInvalid())
+    return 0;
+
+  return getDerived().RebuildOMPFinalClause(E.get(), C->getLocStart(),
+                                            C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
 TreeTransform<Derived>::TransformOMPNumThreadsClause(OMPNumThreadsClause *C) {
-  ExprResult NumThreads = getDerived().TransformExpr(C->getNumThreads());
-  if (NumThreads.isInvalid())
-    return nullptr;
-  return getDerived().RebuildOMPNumThreadsClause(
-      NumThreads.get(), C->getLocStart(), C->getLParenLoc(), C->getLocEnd());
+  // Transform expression.
+  ExprResult E = getDerived().TransformExpr(C->getNumThreads());
+
+  if (E.isInvalid())
+    return 0;
+
+  return getDerived().RebuildOMPNumThreadsClause(E.get(), C->getLocStart(),
+                                                 C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
-TreeTransform<Derived>::TransformOMPSafelenClause(OMPSafelenClause *C) {
-  ExprResult E = getDerived().TransformExpr(C->getSafelen());
+TreeTransform<Derived>::TransformOMPDeviceClause(OMPDeviceClause *C) {
+  // Transform expression.
+  ExprResult E = getDerived().TransformExpr(C->getDevice());
+
   if (E.isInvalid())
-    return nullptr;
-  return getDerived().RebuildOMPSafelenClause(
-      E.get(), C->getLocStart(), C->getLParenLoc(), C->getLocEnd());
+    return 0;
+
+  return getDerived().RebuildOMPDeviceClause(E.get(), C->getLocStart(),
+                                             C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
 TreeTransform<Derived>::TransformOMPCollapseClause(OMPCollapseClause *C) {
+  // Transform expression.
   ExprResult E = getDerived().TransformExpr(C->getNumForLoops());
+
   if (E.isInvalid())
     return 0;
-  return getDerived().RebuildOMPCollapseClause(
-      E.get(), C->getLocStart(), C->getLParenLoc(), C->getLocEnd());
+
+  return getDerived().RebuildOMPCollapseClause(E.get(), C->getLocStart(),
+                                               C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
 TreeTransform<Derived>::TransformOMPDefaultClause(OMPDefaultClause *C) {
-  return getDerived().RebuildOMPDefaultClause(
-      C->getDefaultKind(), C->getDefaultKindKwLoc(), C->getLocStart(),
-      C->getLParenLoc(), C->getLocEnd());
+  return getDerived().RebuildOMPDefaultClause(C->getDefaultKind(),
+                                              C->getDefaultKindLoc(),
+                                              C->getLocStart(), C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
 TreeTransform<Derived>::TransformOMPProcBindClause(OMPProcBindClause *C) {
   return getDerived().RebuildOMPProcBindClause(
-      C->getProcBindKind(), C->getProcBindKindKwLoc(), C->getLocStart(),
-      C->getLParenLoc(), C->getLocEnd());
+      C->getThreadAffinity(), C->getThreadAffinityLoc(), C->getLocStart(),
+      C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
 TreeTransform<Derived>::TransformOMPScheduleClause(OMPScheduleClause *C) {
-  ExprResult E = getDerived().TransformExpr(C->getChunkSize());
-  if (E.isInvalid())
-    return nullptr;
+  // Transform expression.
+  ExprResult E;
+  if (C->getChunkSize()) {
+    E = getDerived().TransformExpr(C->getChunkSize());
+
+    if (E.isInvalid())
+      return 0;
+  }
+
   return getDerived().RebuildOMPScheduleClause(
-      C->getScheduleKind(), E.get(), C->getLocStart(), C->getLParenLoc(),
-      C->getScheduleKindLoc(), C->getCommaLoc(), C->getLocEnd());
+      C->getScheduleKind(), C->getScheduleKindLoc(), E.get(), C->getLocStart(),
+      C->getLocEnd());
 }
 
 template <typename Derived>
-OMPClause *
-TreeTransform<Derived>::TransformOMPOrderedClause(OMPOrderedClause *C) {
-  // No need to rebuild this clause, no template-dependent parameters.
-  return C;
+OMPClause *TreeTransform<Derived>::TransformOMPDistScheduleClause(
+    OMPDistScheduleClause *C) {
+  // Transform expression.
+  ExprResult E;
+  if (C->getDistChunkSize()) {
+    E = getDerived().TransformExpr(C->getDistChunkSize());
+
+    if (E.isInvalid())
+      return 0;
+  }
+
+  return getDerived().RebuildOMPDistScheduleClause(
+      C->getDistScheduleKind(), C->getDistScheduleKindLoc(), E.get(),
+      C->getLocStart(), C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
-TreeTransform<Derived>::TransformOMPNowaitClause(OMPNowaitClause *C) {
-  // No need to rebuild this clause, no template-dependent parameters.
-  return C;
+TreeTransform<Derived>::TransformOMPPrivateClause(OMPPrivateClause *C) {
+  llvm::SmallVector<Expr *, 5> Vars;
+  Vars.reserve(C->varlist_size());
+  for (OMPPrivateClause::varlist_iterator I = C->varlist_begin(),
+                                          E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
+    if (EVar.isInvalid())
+      return nullptr;
+    Vars.push_back(EVar.get());
+  }
+  return getDerived().RebuildOMPPrivateClause(Vars, C->getLocStart(),
+                                              C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *TreeTransform<Derived>::TransformOMPFirstPrivateClause(
+    OMPFirstPrivateClause *C) {
+  llvm::SmallVector<Expr *, 5> Vars;
+  Vars.reserve(C->varlist_size());
+  for (OMPFirstPrivateClause::varlist_iterator I = C->varlist_begin(),
+                                               E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
+    if (EVar.isInvalid())
+      return nullptr;
+    Vars.push_back(EVar.get());
+  }
+  return getDerived().RebuildOMPFirstPrivateClause(Vars, C->getLocStart(),
+                                                   C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
-TreeTransform<Derived>::TransformOMPUntiedClause(OMPUntiedClause *C) {
-  // No need to rebuild this clause, no template-dependent parameters.
-  return C;
+TreeTransform<Derived>::TransformOMPSharedClause(OMPSharedClause *C) {
+  llvm::SmallVector<Expr *, 5> Vars;
+  Vars.reserve(C->varlist_size());
+  for (OMPSharedClause::varlist_iterator I = C->varlist_begin(),
+                                         E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
+    if (EVar.isInvalid())
+      return nullptr;
+    Vars.push_back(EVar.get());
+  }
+  return getDerived().RebuildOMPSharedClause(Vars, C->getLocStart(),
+                                             C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
-TreeTransform<Derived>::TransformOMPMergeableClause(OMPMergeableClause *C) {
-  // No need to rebuild this clause, no template-dependent parameters.
-  return C;
+TreeTransform<Derived>::TransformOMPCopyinClause(OMPCopyinClause *C) {
+  llvm::SmallVector<Expr *, 5> Vars;
+  Vars.reserve(C->varlist_size());
+  for (OMPCopyinClause::varlist_iterator I = C->varlist_begin(),
+                                         E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
+    if (EVar.isInvalid())
+      return 0;
+    Vars.push_back(EVar.get());
+  }
+  return getDerived().RebuildOMPCopyinClause(Vars, C->getLocStart(),
+                                             C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
-TreeTransform<Derived>::TransformOMPPrivateClause(OMPPrivateClause *C) {
-  llvm::SmallVector<Expr *, 16> Vars;
+TreeTransform<Derived>::TransformOMPCopyPrivateClause(OMPCopyPrivateClause *C) {
+  llvm::SmallVector<Expr *, 5> Vars;
   Vars.reserve(C->varlist_size());
-  for (auto *VE : C->varlists()) {
-    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(VE));
+  for (OMPCopyPrivateClause::varlist_iterator I = C->varlist_begin(),
+                                              E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
     if (EVar.isInvalid())
-      return nullptr;
+      return 0;
     Vars.push_back(EVar.get());
   }
-  return getDerived().RebuildOMPPrivateClause(
-      Vars, C->getLocStart(), C->getLParenLoc(), C->getLocEnd());
+  return getDerived().RebuildOMPCopyPrivateClause(Vars, C->getLocStart(),
+                                                  C->getLocEnd());
 }
 
 template <typename Derived>
-OMPClause *TreeTransform<Derived>::TransformOMPFirstprivateClause(
-    OMPFirstprivateClause *C) {
-  llvm::SmallVector<Expr *, 16> Vars;
+OMPClause *
+TreeTransform<Derived>::TransformOMPLastPrivateClause(OMPLastPrivateClause *C) {
+  llvm::SmallVector<Expr *, 5> Vars;
   Vars.reserve(C->varlist_size());
-  for (auto *VE : C->varlists()) {
-    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(VE));
+  for (OMPLastPrivateClause::varlist_iterator I = C->varlist_begin(),
+                                              E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
     if (EVar.isInvalid())
-      return nullptr;
+      return 0;
     Vars.push_back(EVar.get());
   }
-  return getDerived().RebuildOMPFirstprivateClause(
-      Vars, C->getLocStart(), C->getLParenLoc(), C->getLocEnd());
+  return getDerived().RebuildOMPLastPrivateClause(Vars, C->getLocStart(),
+                                                  C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
-TreeTransform<Derived>::TransformOMPLastprivateClause(OMPLastprivateClause *C) {
+TreeTransform<Derived>::TransformOMPReductionClause(OMPReductionClause *C) {
   llvm::SmallVector<Expr *, 16> Vars;
   Vars.reserve(C->varlist_size());
-  for (auto *VE : C->varlists()) {
-    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(VE));
+  for (OMPReductionClause::varlist_iterator I = C->varlist_begin(),
+                                            E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
     if (EVar.isInvalid())
-      return nullptr;
+      return 0;
     Vars.push_back(EVar.get());
   }
-  return getDerived().RebuildOMPLastprivateClause(
-      Vars, C->getLocStart(), C->getLParenLoc(), C->getLocEnd());
+  CXXScopeSpec SS;
+  SS.Adopt(C->getSpec());
+  DeclarationNameInfo DNI =
+      getDerived().TransformDeclarationNameInfo(C->getOpName());
+  return getDerived().RebuildOMPReductionClause(
+      Vars, C->getLocStart(), C->getLocEnd(), C->getOperator(), SS, DNI);
 }
 
 template <typename Derived>
 OMPClause *
-TreeTransform<Derived>::TransformOMPSharedClause(OMPSharedClause *C) {
+TreeTransform<Derived>::TransformOMPDependClause(OMPDependClause *C) {
   llvm::SmallVector<Expr *, 16> Vars;
   Vars.reserve(C->varlist_size());
-  for (auto *VE : C->varlists()) {
-    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(VE));
+  for (OMPDependClause::varlist_iterator I = C->varlist_begin(),
+                                         E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
     if (EVar.isInvalid())
-      return nullptr;
+      return 0;
     Vars.push_back(EVar.get());
   }
-  return getDerived().RebuildOMPSharedClause(Vars, C->getLocStart(),
-                                             C->getLParenLoc(), C->getLocEnd());
+  return getDerived().RebuildOMPDependClause(
+      Vars, C->getLocStart(), C->getLocEnd(), C->getType(), C->getTypeLoc());
 }
 
 template <typename Derived>
-OMPClause *
-TreeTransform<Derived>::TransformOMPReductionClause(OMPReductionClause *C) {
+OMPClause *TreeTransform<Derived>::TransformOMPMapClause(OMPMapClause *C) {
   llvm::SmallVector<Expr *, 16> Vars;
   Vars.reserve(C->varlist_size());
-  for (auto *VE : C->varlists()) {
-    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(VE));
+  for (OMPMapClause::varlist_iterator I = C->varlist_begin(),
+                                      E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
     if (EVar.isInvalid())
-      return nullptr;
+      return 0;
     Vars.push_back(EVar.get());
   }
-  CXXScopeSpec ReductionIdScopeSpec;
-  ReductionIdScopeSpec.Adopt(C->getQualifierLoc());
+  return getDerived().RebuildOMPMapClause(
+      Vars, C->getLocStart(), C->getLocEnd(), C->getKind(), C->getKindLoc());
+}
 
-  DeclarationNameInfo NameInfo = C->getNameInfo();
-  if (NameInfo.getName()) {
-    NameInfo = getDerived().TransformDeclarationNameInfo(NameInfo);
-    if (!NameInfo.getName())
-      return nullptr;
+template <typename Derived>
+OMPClause *TreeTransform<Derived>::TransformOMPToClause(OMPToClause *C) {
+  llvm::SmallVector<Expr *, 16> Vars;
+  Vars.reserve(C->varlist_size());
+  for (OMPToClause::varlist_iterator I = C->varlist_begin(),
+                                     E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
+    if (EVar.isInvalid())
+      return 0;
+    Vars.push_back(EVar.get());
   }
-  return getDerived().RebuildOMPReductionClause(
-      Vars, C->getLocStart(), C->getLParenLoc(), C->getColonLoc(),
-      C->getLocEnd(), ReductionIdScopeSpec, NameInfo);
+  return getDerived().RebuildOMPToClause(Vars, C->getLocStart(),
+                                         C->getLocEnd());
 }
 
 template <typename Derived>
-OMPClause *
-TreeTransform<Derived>::TransformOMPLinearClause(OMPLinearClause *C) {
+OMPClause *TreeTransform<Derived>::TransformOMPFromClause(OMPFromClause *C) {
   llvm::SmallVector<Expr *, 16> Vars;
   Vars.reserve(C->varlist_size());
-  for (auto *VE : C->varlists()) {
-    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(VE));
+  for (OMPFromClause::varlist_iterator I = C->varlist_begin(),
+                                       E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
     if (EVar.isInvalid())
-      return nullptr;
+      return 0;
     Vars.push_back(EVar.get());
   }
-  ExprResult Step = getDerived().TransformExpr(C->getStep());
-  if (Step.isInvalid())
-    return nullptr;
-  return getDerived().RebuildOMPLinearClause(Vars, Step.get(), C->getLocStart(),
-                                             C->getLParenLoc(),
-                                             C->getColonLoc(), C->getLocEnd());
+  return getDerived().RebuildOMPFromClause(Vars, C->getLocStart(),
+                                           C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
-TreeTransform<Derived>::TransformOMPAlignedClause(OMPAlignedClause *C) {
-  llvm::SmallVector<Expr *, 16> Vars;
+TreeTransform<Derived>::TransformOMPOrderedClause(OMPOrderedClause *C) {
+  return getDerived().RebuildOMPOrderedClause(C->getLocStart(), C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPNowaitClause(OMPNowaitClause *C) {
+  return getDerived().RebuildOMPNowaitClause(C->getLocStart(), C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPUntiedClause(OMPUntiedClause *C) {
+  return getDerived().RebuildOMPUntiedClause(C->getLocStart(), C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPMergeableClause(OMPMergeableClause *C) {
+  return getDerived().RebuildOMPMergeableClause(C->getLocStart(),
+                                                C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *TreeTransform<Derived>::TransformOMPReadClause(OMPReadClause *C) {
+  return getDerived().RebuildOMPReadClause(C->getLocStart(), C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *TreeTransform<Derived>::TransformOMPWriteClause(OMPWriteClause *C) {
+  return getDerived().RebuildOMPWriteClause(C->getLocStart(), C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPUpdateClause(OMPUpdateClause *C) {
+  return getDerived().RebuildOMPUpdateClause(C->getLocStart(), C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPCaptureClause(OMPCaptureClause *C) {
+  return getDerived().RebuildOMPCaptureClause(C->getLocStart(), C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPSeqCstClause(OMPSeqCstClause *C) {
+  return getDerived().RebuildOMPSeqCstClause(C->getLocStart(), C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPInBranchClause(OMPInBranchClause *C) {
+  return getDerived().RebuildOMPInBranchClause(C->getLocStart(),
+                                               C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPNotInBranchClause(OMPNotInBranchClause *C) {
+  return getDerived().RebuildOMPNotInBranchClause(C->getLocStart(),
+                                                  C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *TreeTransform<Derived>::TransformOMPFlushClause(OMPFlushClause *C) {
+  llvm::SmallVector<Expr *, 5> Vars;
   Vars.reserve(C->varlist_size());
-  for (auto *VE : C->varlists()) {
-    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(VE));
+  for (OMPFlushClause::varlist_iterator I = C->varlist_begin(),
+                                        E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
     if (EVar.isInvalid())
-      return nullptr;
+      return 0;
     Vars.push_back(EVar.get());
   }
-  ExprResult Alignment = getDerived().TransformExpr(C->getAlignment());
-  if (Alignment.isInvalid())
-    return nullptr;
-  return getDerived().RebuildOMPAlignedClause(
-      Vars, Alignment.get(), C->getLocStart(), C->getLParenLoc(),
-      C->getColonLoc(), C->getLocEnd());
+  return getDerived().RebuildOMPFlushClause(Vars, C->getLocStart(),
+                                            C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
-TreeTransform<Derived>::TransformOMPCopyinClause(OMPCopyinClause *C) {
-  llvm::SmallVector<Expr *, 16> Vars;
+TreeTransform<Derived>::TransformOMPUniformClause(OMPUniformClause *C) {
+  llvm::SmallVector<Expr *, 5> Vars;
   Vars.reserve(C->varlist_size());
-  for (auto *VE : C->varlists()) {
-    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(VE));
+  for (OMPUniformClause::varlist_iterator I = C->varlist_begin(),
+                                          E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
     if (EVar.isInvalid())
-      return nullptr;
+      return 0;
     Vars.push_back(EVar.get());
   }
-  return getDerived().RebuildOMPCopyinClause(Vars, C->getLocStart(),
-                                             C->getLParenLoc(), C->getLocEnd());
+  return getDerived().RebuildOMPUniformClause(Vars, C->getLocStart(),
+                                              C->getLocEnd());
 }
 
 template <typename Derived>
 OMPClause *
-TreeTransform<Derived>::TransformOMPCopyprivateClause(OMPCopyprivateClause *C) {
-  llvm::SmallVector<Expr *, 16> Vars;
+TreeTransform<Derived>::TransformOMPSafelenClause(OMPSafelenClause *C) {
+  // Transform length expression.
+  ExprResult E = getDerived().TransformExpr(C->getSafelen());
+
+  if (E.isInvalid())
+    return 0;
+
+  return getDerived().RebuildOMPSafelenClause(E.get(), C->getLocStart(),
+                                              C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPSimdlenClause(OMPSimdlenClause *C) {
+  // Transform length expression.
+  ExprResult E = getDerived().TransformExpr(C->getSimdlen());
+
+  if (E.isInvalid())
+    return 0;
+
+  return getDerived().RebuildOMPSimdlenClause(E.get(), C->getLocStart(),
+                                              C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPNumTeamsClause(OMPNumTeamsClause *C) {
+  // Transform the number-of-teams expession.
+  ExprResult E = getDerived().TransformExpr(C->getNumTeams());
+
+  if (E.isInvalid())
+    return 0;
+
+  return getDerived().RebuildOMPNumTeamsClause(E.get(), C->getLocStart(),
+                                               C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPThreadLimitClause(OMPThreadLimitClause *C) {
+  // Transform the thread-limit expression.
+  ExprResult E = getDerived().TransformExpr(C->getThreadLimit());
+
+  if (E.isInvalid())
+    return 0;
+
+  return getDerived().RebuildOMPThreadLimitClause(E.get(), C->getLocStart(),
+                                                  C->getLocEnd());
+}
+
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPLinearClause(OMPLinearClause *C) {
+  // Transform step expression.
+  ExprResult E = getDerived().TransformExpr(C->getStep());
+  if (E.isInvalid())
+    return 0;
+
+  llvm::SmallVector<Expr *, 5> Vars;
   Vars.reserve(C->varlist_size());
-  for (auto *VE : C->varlists()) {
-    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(VE));
+  for (OMPLinearClause::varlist_iterator I = C->varlist_begin(),
+                                         E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
     if (EVar.isInvalid())
-      return nullptr;
+      return 0;
     Vars.push_back(EVar.get());
   }
-  return getDerived().RebuildOMPCopyprivateClause(
-      Vars, C->getLocStart(), C->getLParenLoc(), C->getLocEnd());
+  return getDerived().RebuildOMPLinearClause(
+      Vars, C->getLocStart(), C->getLocEnd(), E.get(), C->getStepLoc());
 }
 
 template <typename Derived>
-OMPClause *TreeTransform<Derived>::TransformOMPFlushClause(OMPFlushClause *C) {
-  llvm::SmallVector<Expr *, 16> Vars;
+OMPClause *
+TreeTransform<Derived>::TransformOMPAlignedClause(OMPAlignedClause *C) {
+  // Transform alignment expression.
+  ExprResult E = getDerived().TransformExpr(C->getAlignment());
+  if (E.isInvalid())
+    return 0;
+
+  llvm::SmallVector<Expr *, 5> Vars;
   Vars.reserve(C->varlist_size());
-  for (auto *VE : C->varlists()) {
-    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(VE));
+  for (OMPAlignedClause::varlist_iterator I = C->varlist_begin(),
+                                          E = C->varlist_end();
+       I != E; ++I) {
+    ExprResult EVar = getDerived().TransformExpr(cast<Expr>(*I));
     if (EVar.isInvalid())
-      return nullptr;
+      return 0;
     Vars.push_back(EVar.get());
   }
-  return getDerived().RebuildOMPFlushClause(Vars, C->getLocStart(),
-                                            C->getLParenLoc(), C->getLocEnd());
+  return getDerived().RebuildOMPAlignedClause(
+      Vars, C->getLocStart(), C->getLocEnd(), E.get(), C->getAlignmentLoc());
 }
 
 //===----------------------------------------------------------------------===//
@@ -7258,6 +8048,31 @@
 
 template<typename Derived>
 ExprResult
+TreeTransform<Derived>::TransformCEANIndexExpr(CEANIndexExpr *E) {
+  ExprResult Base = getDerived().TransformExpr(E->getBase());
+  if (Base.isInvalid())
+    return ExprError();
+  ExprResult LowerBound = getDerived().TransformExpr(E->getLowerBound());
+  if (LowerBound.isInvalid())
+    return ExprError();
+  ExprResult Length = getDerived().TransformExpr(E->getLength());
+  if (Length.isInvalid())
+    return ExprError();
+
+  if (!getDerived().AlwaysRebuild() &&
+      Base.get() == E->getBase() &&
+      LowerBound.get() == E->getLowerBound() &&
+      Length.get() == E->getLength())
+    return E;
+
+  return getDerived().RebuildCEANIndexExpr(Base.get(),
+                                           LowerBound.get(),
+                                           E->getColonLoc(),
+                                           Length.get());
+}
+
+template<typename Derived>
+ExprResult
 TreeTransform<Derived>::TransformCallExpr(CallExpr *E) {
   // Transform the callee.
   ExprResult Callee = getDerived().TransformExpr(E->getCallee());
@@ -10361,7 +11176,7 @@
                                             /*TemplateArgs*/ nullptr);
 }
 
-template<typename Derived>
+template <typename Derived>
 StmtResult
 TreeTransform<Derived>::TransformCapturedStmt(CapturedStmt *S) {
   SourceLocation Loc = S->getLocStart();
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Serialization/ASTCommon.cpp cfe-3.5.0.src.omp/lib/Serialization/ASTCommon.cpp
--- cfe-3.5.0.src/lib/Serialization/ASTCommon.cpp	2014-05-22 01:54:18.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Serialization/ASTCommon.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -211,6 +211,9 @@
   case Decl::ClassScopeFunctionSpecialization:
   case Decl::Import:
   case Decl::OMPThreadPrivate:
+  case Decl::OMPDeclareReduction:
+  case Decl::OMPDeclareSimd:
+  case Decl::OMPDeclareTarget:
     return false;
   }
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Serialization/ASTReaderDecl.cpp cfe-3.5.0.src.omp/lib/Serialization/ASTReaderDecl.cpp
--- cfe-3.5.0.src/lib/Serialization/ASTReaderDecl.cpp	2014-07-14 23:37:06.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Serialization/ASTReaderDecl.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -35,6 +35,7 @@
 
 namespace clang {
   class ASTDeclReader : public DeclVisitor<ASTDeclReader, void> {
+    friend class OMPClauseReader;
     ASTReader &Reader;
     ModuleFile &F;
     const DeclID ThisDeclID;
@@ -334,6 +335,9 @@
     void VisitObjCPropertyDecl(ObjCPropertyDecl *D);
     void VisitObjCPropertyImplDecl(ObjCPropertyImplDecl *D);
     void VisitOMPThreadPrivateDecl(OMPThreadPrivateDecl *D);
+    void VisitOMPDeclareReductionDecl(OMPDeclareReductionDecl *D);
+    void VisitOMPDeclareSimdDecl(OMPDeclareSimdDecl *D);
+    void VisitOMPDeclareTargetDecl(OMPDeclareTargetDecl *D);
   };
 }
 
@@ -2151,6 +2155,52 @@
   D->setVars(Vars);
 }
 
+void ASTDeclReader::VisitOMPDeclareReductionDecl(OMPDeclareReductionDecl *D) {
+  VisitDecl(D);
+  D->setDeclName(Reader.ReadDeclarationName(F, Record, Idx));
+  unsigned NumTypes = D->datalist_size();
+  SmallVector<OMPDeclareReductionDecl::ReductionData, 16> Data;
+  Data.reserve(NumTypes);
+  for (unsigned i = 0; i != NumTypes; ++i) {
+    QualType QTy = Reader.readType(F, Record, Idx);
+    SourceRange SR = Reader.ReadSourceRange(F, Record, Idx);
+    Expr *E1 = Reader.ReadExpr(F);
+    Expr *E2 = Reader.ReadExpr(F);
+    Data.push_back(OMPDeclareReductionDecl::ReductionData(QTy, SR, E1, E2));
+  }
+  D->setData(Data);
+}
+
+void ASTDeclReader::VisitOMPDeclareSimdDecl(OMPDeclareSimdDecl *D) {
+  VisitDecl(D);
+  unsigned NumVariants = D->simd_variants_size();
+  unsigned NumClauses  = D->clauses_size();
+  if (NumClauses > 0) {
+    SmallVector<OMPClause *, 8> Clauses;
+    OMPClauseReader ClauseReader(Reader, Reader.getContext(), Record, Idx, F);
+    for (unsigned i = 0; i != NumClauses; ++i) {
+      Clauses.push_back(ClauseReader.readClause());
+    }
+    D->setClauses(Clauses);
+  }
+  if (NumVariants > 0) {
+    SmallVector<OMPDeclareSimdDecl::SimdVariant, 8> SimdVariants;
+    for (unsigned i = 0; i != NumVariants; ++i) {
+      SourceRange SR = Reader.ReadSourceRange(F, Record, Idx);
+      unsigned BeginIdx = Record[Idx++];
+      unsigned EndIdx = Record[Idx++];
+      SimdVariants.push_back(OMPDeclareSimdDecl::SimdVariant(
+                                SR, BeginIdx, EndIdx));
+    }
+    D->setVariants(SimdVariants);
+  }
+  D->setFunction(ReadDeclAs<Decl>(Record, Idx));
+}
+
+void ASTDeclReader::VisitOMPDeclareTargetDecl(OMPDeclareTargetDecl *D) {
+  VisitDecl(D);
+}
+
 //===----------------------------------------------------------------------===//
 // Attribute Reading
 //===----------------------------------------------------------------------===//
@@ -2199,6 +2249,10 @@
   if (isa<FileScopeAsmDecl>(D) || 
       isa<ObjCProtocolDecl>(D) || 
       isa<ObjCImplDecl>(D) ||
+      isa<OMPThreadPrivateDecl>(D) ||
+      isa<OMPDeclareSimdDecl>(D) ||
+      isa<OMPDeclareReductionDecl>(D) ||
+      isa<OMPDeclareTargetDecl>(D) ||
       isa<ImportDecl>(D))
     return true;
   if (VarDecl *Var = dyn_cast<VarDecl>(D))
@@ -2817,6 +2871,19 @@
   case DECL_OMP_THREADPRIVATE:
     D = OMPThreadPrivateDecl::CreateDeserialized(Context, ID, Record[Idx++]);
     break;
+  case DECL_OMP_DECLAREREDUCTION:
+    D = OMPDeclareReductionDecl::CreateDeserialized(Context, ID, Record[Idx++]);
+    break;
+  case DECL_OMP_DECLARESIMD: {
+    unsigned NumVariants = Record[Idx++];
+    unsigned NumClauses  = Record[Idx++];
+    D = OMPDeclareSimdDecl::CreateDeserialized(
+                              Context, ID, NumVariants, NumClauses);
+    }
+    break;
+  case DECL_OMP_DECLARETARGET:
+    D = OMPDeclareTargetDecl::CreateDeserialized(Context, ID);
+    break;
   case DECL_EMPTY:
     D = EmptyDecl::CreateDeserialized(Context, ID);
     break;
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Serialization/ASTReaderStmt.cpp cfe-3.5.0.src.omp/lib/Serialization/ASTReaderStmt.cpp
--- cfe-3.5.0.src/lib/Serialization/ASTReaderStmt.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Serialization/ASTReaderStmt.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -586,6 +586,16 @@
   E->setLHS(Reader.ReadSubExpr());
   E->setRHS(Reader.ReadSubExpr());
   E->setRBracketLoc(ReadSourceLocation(Record, Idx));
+  if (CEANIndexExpr *CIE = dyn_cast_or_null<CEANIndexExpr>(E->getIdx()))
+    CIE->setBase(E->getBase());
+}
+
+void ASTStmtReader::VisitCEANIndexExpr(CEANIndexExpr *E) {
+  VisitExpr(E);
+  E->setBase(0);
+  E->setLowerBound(Reader.ReadSubExpr());
+  E->setColonLoc(ReadSourceLocation(Record, Idx));
+  E->setLength(Reader.ReadSubExpr());
 }
 
 void ASTStmtReader::VisitCallExpr(CallExpr *E) {
@@ -1658,24 +1668,6 @@
 //===----------------------------------------------------------------------===//
 // OpenMP Clauses.
 //===----------------------------------------------------------------------===//
-
-namespace clang {
-class OMPClauseReader : public OMPClauseVisitor<OMPClauseReader> {
-  ASTStmtReader *Reader;
-  ASTContext &Context;
-  const ASTReader::RecordData &Record;
-  unsigned &Idx;
-public:
-  OMPClauseReader(ASTStmtReader *R, ASTContext &C,
-                  const ASTReader::RecordData &Record, unsigned &Idx)
-    : Reader(R), Context(C), Record(Record), Idx(Idx) { }
-#define OPENMP_CLAUSE(Name, Class)    \
-  void Visit##Class(Class *S);
-#include "clang/Basic/OpenMPKinds.def"
-  OMPClause *readClause();
-};
-}
-
 OMPClause *OMPClauseReader::readClause() {
   OMPClause *C;
   switch (Record[Idx++]) {
@@ -1688,12 +1680,18 @@
   case OMPC_num_threads:
     C = new (Context) OMPNumThreadsClause();
     break;
-  case OMPC_safelen:
-    C = new (Context) OMPSafelenClause();
+  case OMPC_num_teams:
+    C = new (Context) OMPNumTeamsClause();
+    break;
+  case OMPC_thread_limit:
+    C = new (Context) OMPThreadLimitClause();
     break;
   case OMPC_collapse:
     C = new (Context) OMPCollapseClause();
     break;
+  case OMPC_device:
+    C = new (Context) OMPDeviceClause();
+    break;
   case OMPC_default:
     C = new (Context) OMPDefaultClause();
     break;
@@ -1703,6 +1701,30 @@
   case OMPC_schedule:
     C = new (Context) OMPScheduleClause();
     break;
+  case OMPC_dist_schedule:
+    C = new (Context) OMPDistScheduleClause();
+    break;
+  case OMPC_private:
+    C = OMPPrivateClause::CreateEmpty(Context, Record[Idx++]);
+    break;
+  case OMPC_firstprivate:
+    C = OMPFirstPrivateClause::CreateEmpty(Context, Record[Idx++]);
+    break;
+  case OMPC_lastprivate:
+    C = OMPLastPrivateClause::CreateEmpty(Context, Record[Idx++]);
+    break;
+  case OMPC_shared:
+    C = OMPSharedClause::CreateEmpty(Context, Record[Idx++]);
+    break;
+  case OMPC_copyin:
+    C = OMPCopyinClause::CreateEmpty(Context, Record[Idx++]);
+    break;
+  case OMPC_copyprivate:
+    C = OMPCopyPrivateClause::CreateEmpty(Context, Record[Idx++]);
+    break;
+  case OMPC_reduction:
+    C = OMPReductionClause::CreateEmpty(Context, Record[Idx++]);
+    break;
   case OMPC_ordered:
     C = new (Context) OMPOrderedClause();
     break;
@@ -1715,20 +1737,47 @@
   case OMPC_mergeable:
     C = new (Context) OMPMergeableClause();
     break;
-  case OMPC_private:
-    C = OMPPrivateClause::CreateEmpty(Context, Record[Idx++]);
+  case OMPC_read:
+    C = new (Context) OMPReadClause();
     break;
-  case OMPC_firstprivate:
-    C = OMPFirstprivateClause::CreateEmpty(Context, Record[Idx++]);
+  case OMPC_write:
+    C = new (Context) OMPWriteClause();
     break;
-  case OMPC_lastprivate:
-    C = OMPLastprivateClause::CreateEmpty(Context, Record[Idx++]);
+  case OMPC_update:
+    C = new (Context) OMPUpdateClause();
     break;
-  case OMPC_shared:
-    C = OMPSharedClause::CreateEmpty(Context, Record[Idx++]);
+  case OMPC_capture:
+    C = new (Context) OMPCaptureClause();
     break;
-  case OMPC_reduction:
-    C = OMPReductionClause::CreateEmpty(Context, Record[Idx++]);
+  case OMPC_seq_cst:
+    C = new (Context) OMPSeqCstClause();
+    break;
+  case OMPC_inbranch:
+    C = new (Context) OMPInBranchClause();
+    break;
+  case OMPC_notinbranch:
+    C = new (Context) OMPNotInBranchClause();
+    break;
+  case OMPC_flush:
+    C = OMPFlushClause::CreateEmpty(Context, Record[Idx++]);
+    break;
+  case OMPC_depend:
+    C = OMPDependClause::CreateEmpty(Context, Record[Idx++]);
+    break;
+  case OMPC_map:
+    C = OMPMapClause::CreateEmpty(Context, Record[Idx++]);
+    break;
+  case OMPC_to:
+    C = OMPToClause::CreateEmpty(Context, Record[Idx++]);
+    break;
+  case OMPC_from:
+    C = OMPFromClause::CreateEmpty(Context, Record[Idx++]);
+    break;
+  case OMPC_safelen:
+    C = new (Context) OMPSafelenClause();
+    break;
+  case OMPC_simdlen:
+    C = new (Context) OMPSimdlenClause();
     break;
   case OMPC_linear:
     C = OMPLinearClause::CreateEmpty(Context, Record[Idx++]);
@@ -1736,189 +1785,448 @@
   case OMPC_aligned:
     C = OMPAlignedClause::CreateEmpty(Context, Record[Idx++]);
     break;
-  case OMPC_copyin:
-    C = OMPCopyinClause::CreateEmpty(Context, Record[Idx++]);
-    break;
-  case OMPC_copyprivate:
-    C = OMPCopyprivateClause::CreateEmpty(Context, Record[Idx++]);
-    break;
-  case OMPC_flush:
-    C = OMPFlushClause::CreateEmpty(Context, Record[Idx++]);
+  case OMPC_uniform:
+    C = OMPUniformClause::CreateEmpty(Context, Record[Idx++]);
     break;
+  default:
+    assert(0 && "Unknown clause!");
+    return 0;
   }
   Visit(C);
-  C->setLocStart(Reader->ReadSourceLocation(Record, Idx));
-  C->setLocEnd(Reader->ReadSourceLocation(Record, Idx));
-
+  C->setLocStart(this->ReadSourceLocation(Record, Idx));
+  C->setLocEnd(this->ReadSourceLocation(Record, Idx));
   return C;
 }
 
 void OMPClauseReader::VisitOMPIfClause(OMPIfClause *C) {
-  C->setCondition(Reader->Reader.ReadSubExpr());
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
+  C->setCondition(Reader.ReadSubExpr());
 }
 
 void OMPClauseReader::VisitOMPFinalClause(OMPFinalClause *C) {
-  C->setCondition(Reader->Reader.ReadSubExpr());
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
+  C->setCondition(Reader.ReadSubExpr());
 }
 
 void OMPClauseReader::VisitOMPNumThreadsClause(OMPNumThreadsClause *C) {
-  C->setNumThreads(Reader->Reader.ReadSubExpr());
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
+  C->setNumThreads(Reader.ReadSubExpr());
 }
 
-void OMPClauseReader::VisitOMPSafelenClause(OMPSafelenClause *C) {
-  C->setSafelen(Reader->Reader.ReadSubExpr());
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
+void OMPClauseReader::VisitOMPCollapseClause(OMPCollapseClause *C) {
+  C->setNumForLoops(Reader.ReadSubExpr());
 }
 
-void OMPClauseReader::VisitOMPCollapseClause(OMPCollapseClause *C) {
-  C->setNumForLoops(Reader->Reader.ReadSubExpr());
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
+void OMPClauseReader::VisitOMPDeviceClause(OMPDeviceClause *C) {
+  C->setDevice(Reader.ReadSubExpr());
 }
 
 void OMPClauseReader::VisitOMPDefaultClause(OMPDefaultClause *C) {
   C->setDefaultKind(
        static_cast<OpenMPDefaultClauseKind>(Record[Idx++]));
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
-  C->setDefaultKindKwLoc(Reader->ReadSourceLocation(Record, Idx));
+  C->setDefaultKindLoc(this->ReadSourceLocation(Record, Idx));
 }
 
 void OMPClauseReader::VisitOMPProcBindClause(OMPProcBindClause *C) {
-  C->setProcBindKind(
+  C->setThreadAffinity(
        static_cast<OpenMPProcBindClauseKind>(Record[Idx++]));
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
-  C->setProcBindKindKwLoc(Reader->ReadSourceLocation(Record, Idx));
+  C->setThreadAffinityLoc(this->ReadSourceLocation(Record, Idx));
 }
 
 void OMPClauseReader::VisitOMPScheduleClause(OMPScheduleClause *C) {
   C->setScheduleKind(
        static_cast<OpenMPScheduleClauseKind>(Record[Idx++]));
-  C->setChunkSize(Reader->Reader.ReadSubExpr());
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
-  C->setScheduleKindLoc(Reader->ReadSourceLocation(Record, Idx));
-  C->setCommaLoc(Reader->ReadSourceLocation(Record, Idx));
+  C->setScheduleKindLoc(this->ReadSourceLocation(Record, Idx));
+  C->setChunkSize(Reader.ReadSubExpr());
 }
 
-void OMPClauseReader::VisitOMPOrderedClause(OMPOrderedClause *) {}
-
-void OMPClauseReader::VisitOMPNowaitClause(OMPNowaitClause *) {}
-
-void OMPClauseReader::VisitOMPUntiedClause(OMPUntiedClause *) {}
-
-void OMPClauseReader::VisitOMPMergeableClause(OMPMergeableClause *) {}
+void OMPClauseReader::VisitOMPDistScheduleClause(OMPDistScheduleClause *C) {
+  C->setDistScheduleKind(
+       static_cast<OpenMPDistScheduleClauseKind>(Record[Idx++]));
+  C->setDistScheduleKindLoc(this->ReadSourceLocation(Record, Idx));
+  C->setDistChunkSize(Reader.ReadSubExpr());
+}
 
 void OMPClauseReader::VisitOMPPrivateClause(OMPPrivateClause *C) {
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
   unsigned NumVars = C->varlist_size();
   SmallVector<Expr *, 16> Vars;
   Vars.reserve(NumVars);
   for (unsigned i = 0; i != NumVars; ++i)
-    Vars.push_back(Reader->Reader.ReadSubExpr());
-  C->setVarRefs(Vars);
+    Vars.push_back(Reader.ReadSubExpr());
+  C->setVars(Vars);
+  SmallVector<Expr *, 16> Inits;
+  Inits.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Inits.push_back(Reader.ReadSubExpr());
+  }
+  C->setDefaultInits(Inits);
 }
 
-void OMPClauseReader::VisitOMPFirstprivateClause(OMPFirstprivateClause *C) {
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
+void OMPClauseReader::VisitOMPFirstPrivateClause(OMPFirstPrivateClause *C) {
   unsigned NumVars = C->varlist_size();
   SmallVector<Expr *, 16> Vars;
   Vars.reserve(NumVars);
   for (unsigned i = 0; i != NumVars; ++i)
-    Vars.push_back(Reader->Reader.ReadSubExpr());
-  C->setVarRefs(Vars);
+    Vars.push_back(Reader.ReadSubExpr());
+  C->setVars(Vars);
+  SmallVector<DeclRefExpr *, 16> Vars1;
+  Vars1.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    if (Expr *E = Reader.ReadSubExpr())
+      Vars1.push_back(cast<DeclRefExpr>(E));
+    else
+      Vars1.push_back(0);
+  }
+  C->setPseudoVars(Vars1);
+  SmallVector<Expr *, 16> Inits;
+  Inits.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Inits.push_back(Reader.ReadSubExpr());
+  }
+  C->setInits(Inits);
 }
 
-void OMPClauseReader::VisitOMPLastprivateClause(OMPLastprivateClause *C) {
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
+void OMPClauseReader::VisitOMPLastPrivateClause(OMPLastPrivateClause *C) {
   unsigned NumVars = C->varlist_size();
   SmallVector<Expr *, 16> Vars;
   Vars.reserve(NumVars);
-  for (unsigned i = 0; i != NumVars; ++i)
-    Vars.push_back(Reader->Reader.ReadSubExpr());
-  C->setVarRefs(Vars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    if (Expr *E = Reader.ReadSubExpr())
+      Vars.push_back(cast<DeclRefExpr>(E));
+    else
+      Vars.push_back(0);
+  }
+  C->setVars(Vars);
+  SmallVector<DeclRefExpr *, 16> Vars1;
+  Vars1.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    if (Expr *E = Reader.ReadSubExpr())
+      Vars1.push_back(cast<DeclRefExpr>(E));
+    else
+      Vars1.push_back(0);
+  }
+  C->setPseudoVars1(Vars1);
+  Vars1.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    if (Expr *E = Reader.ReadSubExpr())
+      Vars1.push_back(cast<DeclRefExpr>(E));
+    else
+      Vars1.push_back(0);
+  }
+  C->setPseudoVars2(Vars1);
+  SmallVector<Expr *, 16> Inits;
+  Inits.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Inits.push_back(Reader.ReadSubExpr());
+  }
+  C->setDefaultInits(Inits);
+  SmallVector<Expr *, 16> Assignments;
+  Assignments.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Assignments.push_back(Reader.ReadSubExpr());
+  }
+  C->setAssignments(Assignments);
 }
 
 void OMPClauseReader::VisitOMPSharedClause(OMPSharedClause *C) {
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
   unsigned NumVars = C->varlist_size();
   SmallVector<Expr *, 16> Vars;
   Vars.reserve(NumVars);
   for (unsigned i = 0; i != NumVars; ++i)
-    Vars.push_back(Reader->Reader.ReadSubExpr());
-  C->setVarRefs(Vars);
+    Vars.push_back(Reader.ReadSubExpr());
+  C->setVars(Vars);
+}
+
+void OMPClauseReader::VisitOMPCopyinClause(OMPCopyinClause *C) {
+  unsigned NumVars = C->varlist_size();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  C->setVars(Vars);
+  SmallVector<DeclRefExpr *, 16> Vars1;
+  Vars1.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    if (Expr *E = Reader.ReadSubExpr())
+      Vars1.push_back(cast<DeclRefExpr>(E));
+    else
+      Vars1.push_back(0);
+  }
+  C->setPseudoVars1(Vars1);
+  Vars1.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    if (Expr *E = Reader.ReadSubExpr())
+      Vars1.push_back(cast<DeclRefExpr>(E));
+    else
+      Vars1.push_back(0);
+  }
+  C->setPseudoVars2(Vars1);
+  SmallVector<Expr *, 16> Assignments;
+  Assignments.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Assignments.push_back(Reader.ReadSubExpr());
+  }
+  C->setAssignments(Assignments);
+}
+
+void OMPClauseReader::VisitOMPCopyPrivateClause(OMPCopyPrivateClause *C) {
+  unsigned NumVars = C->varlist_size();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  C->setVars(Vars);
+  SmallVector<DeclRefExpr *, 16> Vars1;
+  Vars1.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    if (Expr *E = Reader.ReadSubExpr())
+      Vars1.push_back(cast<DeclRefExpr>(E));
+    else
+      Vars1.push_back(0);
+  }
+  C->setPseudoVars1(Vars1);
+  Vars1.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    if (Expr *E = Reader.ReadSubExpr())
+      Vars1.push_back(cast<DeclRefExpr>(E));
+    else
+      Vars1.push_back(0);
+  }
+  C->setPseudoVars2(Vars1);
+  SmallVector<Expr *, 16> Assignments;
+  Assignments.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Assignments.push_back(Reader.ReadSubExpr());
+  }
+  C->setAssignments(Assignments);
 }
 
 void OMPClauseReader::VisitOMPReductionClause(OMPReductionClause *C) {
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
-  C->setColonLoc(Reader->ReadSourceLocation(Record, Idx));
+  C->setOperator(
+     static_cast<OpenMPReductionClauseOperator>(Record[Idx++]));
   NestedNameSpecifierLoc NNSL =
-    Reader->Reader.ReadNestedNameSpecifierLoc(Reader->F, Record, Idx);
+    Reader.ReadNestedNameSpecifierLoc(this->MFile, Record, Idx);
   DeclarationNameInfo DNI;
-  Reader->ReadDeclarationNameInfo(DNI, Record, Idx);
-  C->setQualifierLoc(NNSL);
-  C->setNameInfo(DNI);
+  Reader.ReadDeclarationNameInfo(this->MFile, DNI, Record, Idx);
+  C->setOpName(NNSL, DNI);
+  unsigned NumVars = C->varlist_size();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setVars(Vars);
+  SmallVector<Expr *, 16> OpExprs;
+  OpExprs.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    OpExprs.push_back(Reader.ReadSubExpr());
+  }
+  C->setOpExprs(OpExprs);
+  OpExprs.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    OpExprs.push_back(Reader.ReadSubExpr());
+  }
+  C->setHelperParameters1st(OpExprs);
+  OpExprs.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    OpExprs.push_back(Reader.ReadSubExpr());
+  }
+  C->setHelperParameters2nd(OpExprs);
+  SmallVector<Expr *, 16> Inits;
+  Inits.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Inits.push_back(Reader.ReadSubExpr());
+  }
+  C->setDefaultInits(Inits);
+}
+
+void OMPClauseReader::VisitOMPOrderedClause(OMPOrderedClause *C) { }
+
+void OMPClauseReader::VisitOMPNowaitClause(OMPNowaitClause *C) { }
+
+void OMPClauseReader::VisitOMPUntiedClause(OMPUntiedClause *C) { }
+
+void OMPClauseReader::VisitOMPMergeableClause(OMPMergeableClause *C) { }
+
+void OMPClauseReader::VisitOMPReadClause(OMPReadClause *C) { }
 
+void OMPClauseReader::VisitOMPWriteClause(OMPWriteClause *C) { }
+
+void OMPClauseReader::VisitOMPUpdateClause(OMPUpdateClause *C) { }
+
+void OMPClauseReader::VisitOMPCaptureClause(OMPCaptureClause *C) { }
+
+void OMPClauseReader::VisitOMPSeqCstClause(OMPSeqCstClause *C) { }
+
+void OMPClauseReader::VisitOMPInBranchClause(OMPInBranchClause *C) { }
+
+void OMPClauseReader::VisitOMPNotInBranchClause(OMPNotInBranchClause *C) { }
+
+void OMPClauseReader::VisitOMPFlushClause(OMPFlushClause *C) {
   unsigned NumVars = C->varlist_size();
   SmallVector<Expr *, 16> Vars;
   Vars.reserve(NumVars);
   for (unsigned i = 0; i != NumVars; ++i)
-    Vars.push_back(Reader->Reader.ReadSubExpr());
-  C->setVarRefs(Vars);
+    Vars.push_back(Reader.ReadSubExpr());
+  C->setVars(Vars);
 }
 
-void OMPClauseReader::VisitOMPLinearClause(OMPLinearClause *C) {
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
-  C->setColonLoc(Reader->ReadSourceLocation(Record, Idx));
+void OMPClauseReader::VisitOMPDependClause(OMPDependClause *C) {
+  C->setType(
+     static_cast<OpenMPDependClauseType>(Record[Idx++]));
+  C->setTypeLoc(this->ReadSourceLocation(Record, Idx));
   unsigned NumVars = C->varlist_size();
   SmallVector<Expr *, 16> Vars;
   Vars.reserve(NumVars);
-  for (unsigned i = 0; i != NumVars; ++i)
-    Vars.push_back(Reader->Reader.ReadSubExpr());
-  C->setVarRefs(Vars);
-  C->setStep(Reader->Reader.ReadSubExpr());
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setVars(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setBegins(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setSizeInBytes(Vars);
 }
 
-void OMPClauseReader::VisitOMPAlignedClause(OMPAlignedClause *C) {
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
-  C->setColonLoc(Reader->ReadSourceLocation(Record, Idx));
+void OMPClauseReader::VisitOMPMapClause(OMPMapClause *C) {
+  C->setKind(
+     static_cast<OpenMPMapClauseKind>(Record[Idx++]));
+  C->setKindLoc(this->ReadSourceLocation(Record, Idx));
   unsigned NumVars = C->varlist_size();
   SmallVector<Expr *, 16> Vars;
   Vars.reserve(NumVars);
-  for (unsigned i = 0; i != NumVars; ++i)
-    Vars.push_back(Reader->Reader.ReadSubExpr());
-  C->setVarRefs(Vars);
-  C->setAlignment(Reader->Reader.ReadSubExpr());
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setVars(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setWholeStartAddresses(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setWholeSizesEndAddresses(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setCopyingStartAddresses(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setCopyingSizesEndAddresses(Vars);
 }
 
-void OMPClauseReader::VisitOMPCopyinClause(OMPCopyinClause *C) {
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
+void OMPClauseReader::VisitOMPToClause(OMPToClause *C) {
+  unsigned NumVars = C->varlist_size();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setVars(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setWholeStartAddresses(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setWholeSizesEndAddresses(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setCopyingStartAddresses(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setCopyingSizesEndAddresses(Vars);
+}
+
+void OMPClauseReader::VisitOMPFromClause(OMPFromClause *C) {
+  unsigned NumVars = C->varlist_size();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setVars(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setWholeStartAddresses(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setWholeSizesEndAddresses(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setCopyingStartAddresses(Vars);
+  Vars.clear();
+  for (unsigned i = 0; i != NumVars; ++i) {
+    Vars.push_back(Reader.ReadSubExpr());
+  }
+  C->setCopyingSizesEndAddresses(Vars);
+}
+
+void OMPClauseReader::VisitOMPUniformClause(OMPUniformClause *C) {
   unsigned NumVars = C->varlist_size();
   SmallVector<Expr *, 16> Vars;
   Vars.reserve(NumVars);
   for (unsigned i = 0; i != NumVars; ++i)
-    Vars.push_back(Reader->Reader.ReadSubExpr());
-  C->setVarRefs(Vars);
+    Vars.push_back(Reader.ReadExpr(MFile));
+  C->setVars(Vars);
 }
 
-void OMPClauseReader::VisitOMPCopyprivateClause(OMPCopyprivateClause *C) {
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
+void OMPClauseReader::VisitOMPSafelenClause(OMPSafelenClause *C) {
+  C->setSafelen(Reader.ReadSubExpr());
+}
+
+void OMPClauseReader::VisitOMPSimdlenClause(OMPSimdlenClause *C) {
+  C->setSimdlen(Reader.ReadExpr(MFile));
+}
+
+void OMPClauseReader::VisitOMPNumTeamsClause(OMPNumTeamsClause *C) {
+  C->setNumTeams(Reader.ReadSubExpr());
+}
+
+void OMPClauseReader::VisitOMPThreadLimitClause(OMPThreadLimitClause *C) {
+  C->setThreadLimit(Reader.ReadSubExpr());
+}
+
+void OMPClauseReader::VisitOMPLinearClause(OMPLinearClause *C) {
   unsigned NumVars = C->varlist_size();
   SmallVector<Expr *, 16> Vars;
   Vars.reserve(NumVars);
   for (unsigned i = 0; i != NumVars; ++i)
-    Vars.push_back(Reader->Reader.ReadSubExpr());
-  C->setVarRefs(Vars);
+    Vars.push_back(Reader.ReadExpr(MFile));
+  C->setVars(Vars);
+  C->setStep(Reader.ReadExpr(MFile));
 }
 
-void OMPClauseReader::VisitOMPFlushClause(OMPFlushClause *C) {
-  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
+void OMPClauseReader::VisitOMPAlignedClause(OMPAlignedClause *C) {
   unsigned NumVars = C->varlist_size();
   SmallVector<Expr *, 16> Vars;
   Vars.reserve(NumVars);
   for (unsigned i = 0; i != NumVars; ++i)
-    Vars.push_back(Reader->Reader.ReadSubExpr());
-  C->setVarRefs(Vars);
+    Vars.push_back(Reader.ReadExpr(MFile));
+  C->setVars(Vars);
+  C->setAlignment(Reader.ReadExpr(MFile));
 }
 
 //===----------------------------------------------------------------------===//
@@ -1927,110 +2235,448 @@
 void ASTStmtReader::VisitOMPExecutableDirective(OMPExecutableDirective *E) {
   E->setLocStart(ReadSourceLocation(Record, Idx));
   E->setLocEnd(ReadSourceLocation(Record, Idx));
-  OMPClauseReader ClauseReader(this, Reader.getContext(), Record, Idx);
-  SmallVector<OMPClause *, 5> Clauses;
-  for (unsigned i = 0; i < E->getNumClauses(); ++i)
+  OMPClauseReader ClauseReader(Reader, Reader.getContext(), Record, Idx, F);
+  SmallVector<OMPClause *, 16> Clauses;
+  for (unsigned i = 0, N = E->getNumClauses(); i < N; ++i)
     Clauses.push_back(ClauseReader.readClause());
-  E->setClauses(Clauses);
+  if (E->getNumClauses() > 0)
+    E->setClauses(Clauses);
   if (E->hasAssociatedStmt())
     E->setAssociatedStmt(Reader.ReadSubStmt());
 }
 
 void ASTStmtReader::VisitOMPParallelDirective(OMPParallelDirective *D) {
   VisitStmt(D);
-  // The NumClauses field was read in ReadStmtFromStream.
   ++Idx;
   VisitOMPExecutableDirective(D);
 }
 
+void ASTStmtReader::VisitOMPForDirective(OMPForDirective *D) {
+  VisitStmt(D);
+  Idx += 2;
+  VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
+}
+
+void ASTStmtReader::VisitOMPParallelForDirective(OMPParallelForDirective *D) {
+  VisitStmt(D);
+  Idx += 2;
+  VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
+}
+
 void ASTStmtReader::VisitOMPSimdDirective(OMPSimdDirective *D) {
   VisitStmt(D);
-  // Two fields (NumClauses and CollapsedNum) were read in ReadStmtFromStream.
   Idx += 2;
   VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
 }
 
-void ASTStmtReader::VisitOMPForDirective(OMPForDirective *D) {
+void ASTStmtReader::VisitOMPForSimdDirective(OMPForSimdDirective *D) {
   VisitStmt(D);
-  // Two fields (NumClauses and CollapsedNum) were read in ReadStmtFromStream.
   Idx += 2;
   VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
 }
 
-void ASTStmtReader::VisitOMPSectionsDirective(OMPSectionsDirective *D) {
+void ASTStmtReader::VisitOMPParallelForSimdDirective(
+    OMPParallelForSimdDirective *D) {
   VisitStmt(D);
-  // The NumClauses field was read in ReadStmtFromStream.
-  ++Idx;
+  Idx += 2;
   VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
 }
 
-void ASTStmtReader::VisitOMPSectionDirective(OMPSectionDirective *D) {
+void
+ASTStmtReader::VisitOMPDistributeSimdDirective(OMPDistributeSimdDirective *D) {
   VisitStmt(D);
+  Idx += 2;
   VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
 }
 
-void ASTStmtReader::VisitOMPSingleDirective(OMPSingleDirective *D) {
+void ASTStmtReader::VisitOMPDistributeParallelForDirective(
+    OMPDistributeParallelForDirective *D) {
   VisitStmt(D);
-  // The NumClauses field was read in ReadStmtFromStream.
-  ++Idx;
+  Idx += 2;
   VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  D->setLowerBound(Reader.ReadSubExpr());
+  D->setUpperBound(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
 }
 
-void ASTStmtReader::VisitOMPMasterDirective(OMPMasterDirective *D) {
+void ASTStmtReader::VisitOMPDistributeParallelForSimdDirective(
+    OMPDistributeParallelForSimdDirective *D) {
   VisitStmt(D);
+  Idx += 2;
   VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  D->setLowerBound(Reader.ReadSubExpr());
+  D->setUpperBound(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
 }
 
-void ASTStmtReader::VisitOMPCriticalDirective(OMPCriticalDirective *D) {
+void ASTStmtReader::VisitOMPTeamsDistributeParallelForDirective(
+    OMPTeamsDistributeParallelForDirective *D) {
   VisitStmt(D);
+  Idx += 2;
   VisitOMPExecutableDirective(D);
-  ReadDeclarationNameInfo(D->DirName, Record, Idx);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  D->setLowerBound(Reader.ReadSubExpr());
+  D->setUpperBound(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
 }
 
-void ASTStmtReader::VisitOMPParallelForDirective(OMPParallelForDirective *D) {
+void ASTStmtReader::VisitOMPTeamsDistributeParallelForSimdDirective(
+    OMPTeamsDistributeParallelForSimdDirective *D) {
   VisitStmt(D);
-  // Two fields (NumClauses and CollapsedNum) were read in ReadStmtFromStream.
   Idx += 2;
   VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  D->setLowerBound(Reader.ReadSubExpr());
+  D->setUpperBound(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
+}
+
+void ASTStmtReader::VisitOMPTargetTeamsDistributeParallelForDirective(
+    OMPTargetTeamsDistributeParallelForDirective *D) {
+  VisitStmt(D);
+  Idx += 2;
+  VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  D->setLowerBound(Reader.ReadSubExpr());
+  D->setUpperBound(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
+}
+
+void ASTStmtReader::VisitOMPTargetTeamsDistributeParallelForSimdDirective(
+    OMPTargetTeamsDistributeParallelForSimdDirective *D) {
+  VisitStmt(D);
+  Idx += 2;
+  VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  D->setLowerBound(Reader.ReadSubExpr());
+  D->setUpperBound(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
+}
+
+void ASTStmtReader::VisitOMPSectionsDirective(OMPSectionsDirective *D) {
+  VisitStmt(D);
+  ++Idx;
+  VisitOMPExecutableDirective(D);
 }
 
 void ASTStmtReader::VisitOMPParallelSectionsDirective(
     OMPParallelSectionsDirective *D) {
   VisitStmt(D);
-  // The NumClauses field was read in ReadStmtFromStream.
+  ++Idx;
+  VisitOMPExecutableDirective(D);
+}
+
+void ASTStmtReader::VisitOMPSectionDirective(OMPSectionDirective *D) {
+  VisitStmt(D);
+  ++Idx;
+  VisitOMPExecutableDirective(D);
+}
+
+void ASTStmtReader::VisitOMPSingleDirective(OMPSingleDirective *D) {
+  VisitStmt(D);
   ++Idx;
   VisitOMPExecutableDirective(D);
 }
 
 void ASTStmtReader::VisitOMPTaskDirective(OMPTaskDirective *D) {
   VisitStmt(D);
-  // The NumClauses field was read in ReadStmtFromStream.
   ++Idx;
   VisitOMPExecutableDirective(D);
 }
 
 void ASTStmtReader::VisitOMPTaskyieldDirective(OMPTaskyieldDirective *D) {
   VisitStmt(D);
+  ++Idx;
   VisitOMPExecutableDirective(D);
 }
 
+void ASTStmtReader::VisitOMPMasterDirective(OMPMasterDirective *D) {
+  VisitStmt(D);
+  ++Idx;
+  VisitOMPExecutableDirective(D);
+}
+
+void ASTStmtReader::VisitOMPCriticalDirective(OMPCriticalDirective *D) {
+  VisitStmt(D);
+  ++Idx;
+  VisitOMPExecutableDirective(D);
+  ReadDeclarationNameInfo(D->DirName, Record, Idx);
+}
+
 void ASTStmtReader::VisitOMPBarrierDirective(OMPBarrierDirective *D) {
   VisitStmt(D);
+  ++Idx;
   VisitOMPExecutableDirective(D);
 }
 
 void ASTStmtReader::VisitOMPTaskwaitDirective(OMPTaskwaitDirective *D) {
   VisitStmt(D);
+  ++Idx;
   VisitOMPExecutableDirective(D);
 }
 
+void ASTStmtReader::VisitOMPTaskgroupDirective(OMPTaskgroupDirective *D) {
+  VisitStmt(D);
+  ++Idx;
+  VisitOMPExecutableDirective(D);
+}
+
+void ASTStmtReader::VisitOMPAtomicDirective(OMPAtomicDirective *D) {
+  VisitStmt(D);
+  ++Idx;
+  VisitOMPExecutableDirective(D);
+  D->setV(Reader.ReadSubExpr());
+  D->setX(Reader.ReadSubExpr());
+  D->setExpr(Reader.ReadSubExpr());
+  D->setOperator(static_cast<BinaryOperatorKind>(Record[Idx++]));
+  D->setCaptureAfter(Record[Idx++] != 0);
+  D->setReversed(Record[Idx++] != 0);
+}
+
 void ASTStmtReader::VisitOMPFlushDirective(OMPFlushDirective *D) {
   VisitStmt(D);
-  // The NumClauses field was read in ReadStmtFromStream.
   ++Idx;
   VisitOMPExecutableDirective(D);
 }
 
+void ASTStmtReader::VisitOMPOrderedDirective(OMPOrderedDirective *D) {
+  VisitStmt(D);
+  ++Idx;
+  VisitOMPExecutableDirective(D);
+}
+
+void ASTStmtReader::VisitOMPTeamsDirective(OMPTeamsDirective *D) {
+  VisitStmt(D);
+  ++Idx;
+  VisitOMPExecutableDirective(D);
+}
+
+void ASTStmtReader::VisitOMPTargetTeamsDirective(OMPTargetTeamsDirective *D) {
+  VisitStmt(D);
+  ++Idx;
+  VisitOMPExecutableDirective(D);
+}
+
+void ASTStmtReader::VisitOMPDistributeDirective(OMPDistributeDirective *D) {
+  VisitStmt(D);
+  Idx += 2;
+  VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
+}
+
+void ASTStmtReader::VisitOMPCancelDirective(OMPCancelDirective *D) {
+  VisitStmt(D);
+  Idx += 2;
+  VisitOMPExecutableDirective(D);
+}
+
+void ASTStmtReader::VisitOMPCancellationPointDirective(
+                                OMPCancellationPointDirective *D) {
+  VisitStmt(D);
+  ++Idx;
+  VisitOMPExecutableDirective(D);
+}
+
+void ASTStmtReader::VisitOMPTargetDirective(OMPTargetDirective *D) {
+  VisitStmt(D);
+  ++Idx;
+  VisitOMPExecutableDirective(D);
+}
+
+void ASTStmtReader::VisitOMPTargetDataDirective(OMPTargetDataDirective *D) {
+  VisitStmt(D);
+  ++Idx;
+  VisitOMPExecutableDirective(D);
+}
+
+void ASTStmtReader::VisitOMPTargetUpdateDirective(OMPTargetUpdateDirective *D) {
+  VisitStmt(D);
+  ++Idx;
+  VisitOMPExecutableDirective(D);
+}
+
+void ASTStmtReader::VisitOMPTeamsDistributeDirective(OMPTeamsDistributeDirective *D) {
+  VisitStmt(D);
+  Idx += 2;
+  VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
+}
+
+void ASTStmtReader::VisitOMPTeamsDistributeSimdDirective(OMPTeamsDistributeSimdDirective *D) {
+  VisitStmt(D);
+  Idx += 2;
+  VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
+}
+
+void ASTStmtReader::VisitOMPTargetTeamsDistributeDirective(
+    OMPTargetTeamsDistributeDirective *D) {
+  VisitStmt(D);
+  Idx += 2;
+  VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
+}
+
+void ASTStmtReader::VisitOMPTargetTeamsDistributeSimdDirective(
+    OMPTargetTeamsDistributeSimdDirective *D) {
+  VisitStmt(D);
+  Idx += 2;
+  VisitOMPExecutableDirective(D);
+  D->setNewIterVar(Reader.ReadSubExpr());
+  D->setNewIterEnd(Reader.ReadSubExpr());
+  D->setInit(Reader.ReadSubExpr());
+  D->setFinal(Reader.ReadSubExpr());
+  unsigned NumVars = D->getCollapsedNumber();
+  SmallVector<Expr *, 16> Vars;
+  Vars.reserve(NumVars);
+  for (unsigned i = 0; i != NumVars; ++i)
+    Vars.push_back(Reader.ReadSubExpr());
+  D->setCounters(Vars);
+}
+
 //===----------------------------------------------------------------------===//
 // ASTReader Implementation
 //===----------------------------------------------------------------------===//
@@ -2262,6 +2908,10 @@
       S = new (Context) ArraySubscriptExpr(Empty);
       break;
 
+    case EXPR_CEAN_INDEX:
+      S = new (Context) CEANIndexExpr(Empty);
+      break;
+
     case EXPR_CALL:
       S = new (Context) CallExpr(Context, Stmt::CallExprClass, Empty);
       break;
@@ -2507,85 +3157,183 @@
       break;
 
     case STMT_OMP_PARALLEL_DIRECTIVE:
-      S =
-        OMPParallelDirective::CreateEmpty(Context,
-                                          Record[ASTStmtReader::NumStmtFields],
-                                          Empty);
+      S = OMPParallelDirective::CreateEmpty(
+          Context, Record[ASTStmtReader::NumStmtFields], Empty);
       break;
-
+    case STMT_OMP_FOR_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPForDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+    } break;
+    case STMT_OMP_PARALLEL_FOR_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPParallelForDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+    } break;
     case STMT_OMP_SIMD_DIRECTIVE: {
-      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
-      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
-      S = OMPSimdDirective::CreateEmpty(Context, NumClauses,
-                                        CollapsedNum, Empty);
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPSimdDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+    } break;
+    case STMT_OMP_FOR_SIMD_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPForSimdDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+    } break;
+    case STMT_OMP_PARALLEL_FOR_SIMD_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPParallelForSimdDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+    } break;
+    case STMT_OMP_DISTRIBUTE_SIMD_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPDistributeSimdDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+    } break;
+    case STMT_OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPDistributeParallelForDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+    } break;
+    case STMT_OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPDistributeParallelForSimdDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+    } break;
+    case STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPTeamsDistributeParallelForDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
       break;
     }
-
-    case STMT_OMP_FOR_DIRECTIVE: {
-      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
-      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
-      S = OMPForDirective::CreateEmpty(Context, NumClauses, CollapsedNum,
-                                       Empty);
+    case STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPTeamsDistributeParallelForSimdDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+      break;
+    }
+    case STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPTargetTeamsDistributeParallelForDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+      break;
+    }
+    case STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPTargetTeamsDistributeParallelForSimdDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
       break;
     }
-
     case STMT_OMP_SECTIONS_DIRECTIVE:
       S = OMPSectionsDirective::CreateEmpty(
           Context, Record[ASTStmtReader::NumStmtFields], Empty);
       break;
-
+    case STMT_OMP_PARALLEL_SECTIONS_DIRECTIVE:
+      S = OMPParallelSectionsDirective::CreateEmpty(
+          Context, Record[ASTStmtReader::NumStmtFields], Empty);
+      break;
     case STMT_OMP_SECTION_DIRECTIVE:
       S = OMPSectionDirective::CreateEmpty(Context, Empty);
       break;
-
     case STMT_OMP_SINGLE_DIRECTIVE:
       S = OMPSingleDirective::CreateEmpty(
           Context, Record[ASTStmtReader::NumStmtFields], Empty);
       break;
-
-    case STMT_OMP_MASTER_DIRECTIVE:
-      S = OMPMasterDirective::CreateEmpty(Context, Empty);
-      break;
-
-    case STMT_OMP_CRITICAL_DIRECTIVE:
-      S = OMPCriticalDirective::CreateEmpty(Context, Empty);
-      break;
-
-    case STMT_OMP_PARALLEL_FOR_DIRECTIVE: {
-      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
-      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
-      S = OMPParallelForDirective::CreateEmpty(Context, NumClauses,
-                                               CollapsedNum, Empty);
-      break;
-    }
-
-    case STMT_OMP_PARALLEL_SECTIONS_DIRECTIVE:
-      S = OMPParallelSectionsDirective::CreateEmpty(
-          Context, Record[ASTStmtReader::NumStmtFields], Empty);
-      break;
-
     case STMT_OMP_TASK_DIRECTIVE:
       S = OMPTaskDirective::CreateEmpty(
           Context, Record[ASTStmtReader::NumStmtFields], Empty);
       break;
-
     case STMT_OMP_TASKYIELD_DIRECTIVE:
       S = OMPTaskyieldDirective::CreateEmpty(Context, Empty);
       break;
-
+    case STMT_OMP_MASTER_DIRECTIVE:
+      S = OMPMasterDirective::CreateEmpty(Context, Empty);
+      break;
+    case STMT_OMP_CRITICAL_DIRECTIVE:
+      S = OMPCriticalDirective::CreateEmpty(Context, Empty);
+      break;
     case STMT_OMP_BARRIER_DIRECTIVE:
       S = OMPBarrierDirective::CreateEmpty(Context, Empty);
       break;
-
     case STMT_OMP_TASKWAIT_DIRECTIVE:
       S = OMPTaskwaitDirective::CreateEmpty(Context, Empty);
       break;
-
+    case STMT_OMP_TASKGROUP_DIRECTIVE:
+      S = OMPTaskgroupDirective::CreateEmpty(Context, Empty);
+      break;
+    case STMT_OMP_ATOMIC_DIRECTIVE:
+      S = OMPAtomicDirective::CreateEmpty(
+          Context, Record[ASTStmtReader::NumStmtFields], Empty);
+      break;
     case STMT_OMP_FLUSH_DIRECTIVE:
       S = OMPFlushDirective::CreateEmpty(
           Context, Record[ASTStmtReader::NumStmtFields], Empty);
       break;
-
+    case STMT_OMP_ORDERED_DIRECTIVE:
+      S = OMPOrderedDirective::CreateEmpty(Context, Empty);
+      break;
+    case STMT_OMP_TEAMS_DIRECTIVE:
+      S = OMPTeamsDirective::CreateEmpty(
+          Context, Record[ASTStmtReader::NumStmtFields], Empty);
+      break;
+    case STMT_OMP_TARGET_TEAMS_DIRECTIVE:
+      S = OMPTargetTeamsDirective::CreateEmpty(
+          Context, Record[ASTStmtReader::NumStmtFields], Empty);
+      break;
+    case STMT_OMP_DISTRIBUTE_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPDistributeDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+    } break;
+    case STMT_OMP_CANCEL_DIRECTIVE:
+      S = OMPCancelDirective::CreateEmpty(
+          Context, Record[ASTStmtReader::NumStmtFields],
+          static_cast<OpenMPDirectiveKind>(
+              Record[ASTStmtReader::NumStmtFields + 1]),
+          Empty);
+      break;
+    case STMT_OMP_CANCELLATION_POINT_DIRECTIVE:
+      S = OMPCancellationPointDirective::CreateEmpty(
+          Context, static_cast<OpenMPDirectiveKind>(
+                       Record[ASTStmtReader::NumStmtFields]),
+          Empty);
+      break;
+    case STMT_OMP_TARGET_DIRECTIVE:
+      S = OMPTargetDirective::CreateEmpty(
+          Context, Record[ASTStmtReader::NumStmtFields], Empty);
+      break;
+    case STMT_OMP_TARGET_DATA_DIRECTIVE:
+      S = OMPTargetDataDirective::CreateEmpty(
+          Context, Record[ASTStmtReader::NumStmtFields], Empty);
+      break;
+    case STMT_OMP_TARGET_UPDATE_DIRECTIVE:
+      S = OMPTargetUpdateDirective::CreateEmpty(
+          Context, Record[ASTStmtReader::NumStmtFields], Empty);
+      break;
+    case STMT_OMP_TEAMS_DISTRIBUTE_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPTeamsDistributeDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+      break;
+    }
+    case STMT_OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPTeamsDistributeSimdDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+      break;
+    }
+    case STMT_OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPTargetTeamsDistributeDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+      break;
+    }
+    case STMT_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE: {
+      unsigned Val = Record[ASTStmtReader::NumStmtFields];
+      S = OMPTargetTeamsDistributeSimdDirective::CreateEmpty(
+          Context, Val, Record[ASTStmtReader::NumStmtFields + 1], Empty);
+      break;
+    }
     case EXPR_CXX_OPERATOR_CALL:
       S = new (Context) CXXOperatorCallExpr(Context, Empty);
       break;
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Serialization/ASTWriterDecl.cpp cfe-3.5.0.src.omp/lib/Serialization/ASTWriterDecl.cpp
--- cfe-3.5.0.src/lib/Serialization/ASTWriterDecl.cpp	2014-06-21 14:16:40.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Serialization/ASTWriterDecl.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -32,7 +32,7 @@
 
 namespace clang {
   class ASTDeclWriter : public DeclVisitor<ASTDeclWriter, void> {
-
+    friend class OMPClauseWriter;
     ASTWriter &Writer;
     ASTContext &Context;
     typedef ASTWriter::RecordData RecordData;
@@ -130,6 +130,9 @@
     void VisitObjCPropertyDecl(ObjCPropertyDecl *D);
     void VisitObjCPropertyImplDecl(ObjCPropertyImplDecl *D);
     void VisitOMPThreadPrivateDecl(OMPThreadPrivateDecl *D);
+    void VisitOMPDeclareReductionDecl(OMPDeclareReductionDecl *D);
+    void VisitOMPDeclareSimdDecl(OMPDeclareSimdDecl *D);
+    void VisitOMPDeclareTargetDecl(OMPDeclareTargetDecl *D);
 
     void AddFunctionDefinition(const FunctionDecl *FD) {
       assert(FD->doesThisDeclarationHaveABody());
@@ -1440,11 +1443,54 @@
 void ASTDeclWriter::VisitOMPThreadPrivateDecl(OMPThreadPrivateDecl *D) {
   Record.push_back(D->varlist_size());
   VisitDecl(D);
-  for (auto *I : D->varlists())
-    Writer.AddStmt(I);
+  for (OMPThreadPrivateDecl::varlist_iterator I = D->varlist_begin(),
+                                              E = D->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
   Code = serialization::DECL_OMP_THREADPRIVATE;
 }
 
+void ASTDeclWriter::VisitOMPDeclareReductionDecl(OMPDeclareReductionDecl *D) {
+  Record.push_back(D->datalist_size());
+  VisitDecl(D);
+  Writer.AddDeclarationName(D->getDeclName(), Record);
+  for (OMPDeclareReductionDecl::datalist_iterator I = D->datalist_begin(),
+                                                  E = D->datalist_end();
+       I != E; ++I) {
+    Writer.AddTypeRef(I->QTy, Record);
+    Writer.AddSourceRange(I->TyRange, Record);
+    Writer.AddStmt(I->CombinerFunction);
+    Writer.AddStmt(I->InitFunction);
+  }
+  Code = serialization::DECL_OMP_DECLAREREDUCTION;
+}
+
+void ASTDeclWriter::VisitOMPDeclareSimdDecl(OMPDeclareSimdDecl *D) {
+  Record.push_back(D->simd_variants_size());
+  Record.push_back(D->clauses_size());
+  VisitDecl(D);
+  OMPClauseWriter ClauseWriter(Writer, Record);
+  for (OMPDeclareSimdDecl::clauses_iterator IC = D->clauses_begin(),
+       EC = D->clauses_end(); IC != EC; ++IC) {
+    // Save the clause.
+    ClauseWriter.writeClause(*IC);
+  }
+  for (OMPDeclareSimdDecl::simd_variants_iterator
+      IV = D->simd_variants_begin(),
+      EV = D->simd_variants_end(); IV != EV; ++IV) {
+    // Save the variant info.
+    Writer.AddSourceRange(IV->SrcRange, Record);
+    Record.push_back(IV->BeginIdx);
+    Record.push_back(IV->EndIdx);
+  }
+  Writer.AddDeclRef(D->getFunction(), Record);
+  Code = serialization::DECL_OMP_DECLARESIMD;
+}
+
+void ASTDeclWriter::VisitOMPDeclareTargetDecl(OMPDeclareTargetDecl *D) {
+  VisitDecl(D);
+  Code = serialization::DECL_OMP_DECLARETARGET;
+}
 //===----------------------------------------------------------------------===//
 // ASTWriter Implementation
 //===----------------------------------------------------------------------===//
@@ -1827,7 +1873,10 @@
   // File scoped assembly or obj-c implementation must be seen. ImportDecl is
   // used by codegen to determine the set of imported modules to search for
   // inputs for automatic linking.
-  if (isa<FileScopeAsmDecl>(D) || isa<ObjCImplDecl>(D) || isa<ImportDecl>(D))
+  if (isa<FileScopeAsmDecl>(D) || isa<ObjCImplDecl>(D) ||
+      isa<OMPThreadPrivateDecl>(D) || isa<OMPDeclareSimdDecl>(D) ||
+      isa<OMPDeclareTargetDecl>(D) || isa<OMPDeclareReductionDecl>(D) ||
+      isa<ImportDecl>(D))
     return true;
 
   return Context.DeclMustBeEmitted(D);
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/Serialization/ASTWriterStmt.cpp cfe-3.5.0.src.omp/lib/Serialization/ASTWriterStmt.cpp
--- cfe-3.5.0.src/lib/Serialization/ASTWriterStmt.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/Serialization/ASTWriterStmt.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -510,6 +510,14 @@
   Code = serialization::EXPR_ARRAY_SUBSCRIPT;
 }
 
+void ASTStmtWriter::VisitCEANIndexExpr(CEANIndexExpr *E) {
+  VisitExpr(E);
+  Writer.AddStmt(E->getLowerBound());
+  Writer.AddSourceLocation(E->getColonLoc(), Record);
+  Writer.AddStmt(E->getLength());
+  Code = serialization::EXPR_CEAN_INDEX;
+}
+
 void ASTStmtWriter::VisitCallExpr(CallExpr *E) {
   VisitExpr(E);
   Record.push_back(E->getNumArgs());
@@ -1661,155 +1669,340 @@
 // OpenMP Clauses.
 //===----------------------------------------------------------------------===//
 
-namespace clang {
-class OMPClauseWriter : public OMPClauseVisitor<OMPClauseWriter> {
-  ASTStmtWriter *Writer;
-  ASTWriter::RecordData &Record;
-public:
-  OMPClauseWriter(ASTStmtWriter *W, ASTWriter::RecordData &Record)
-    : Writer(W), Record(Record) { }
-#define OPENMP_CLAUSE(Name, Class)    \
-  void Visit##Class(Class *S);
-#include "clang/Basic/OpenMPKinds.def"
-  void writeClause(OMPClause *C);
-};
-}
-
 void OMPClauseWriter::writeClause(OMPClause *C) {
   Record.push_back(C->getClauseKind());
   Visit(C);
-  Writer->Writer.AddSourceLocation(C->getLocStart(), Record);
-  Writer->Writer.AddSourceLocation(C->getLocEnd(), Record);
+  Writer.AddSourceLocation(C->getLocStart(), Record);
+  Writer.AddSourceLocation(C->getLocEnd(), Record);
 }
 
 void OMPClauseWriter::VisitOMPIfClause(OMPIfClause *C) {
-  Writer->Writer.AddStmt(C->getCondition());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
+  Writer.AddStmt(C->getCondition());
 }
 
 void OMPClauseWriter::VisitOMPFinalClause(OMPFinalClause *C) {
-  Writer->Writer.AddStmt(C->getCondition());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
+  Writer.AddStmt(C->getCondition());
 }
 
 void OMPClauseWriter::VisitOMPNumThreadsClause(OMPNumThreadsClause *C) {
-  Writer->Writer.AddStmt(C->getNumThreads());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
+  Writer.AddStmt(C->getNumThreads());
 }
 
-void OMPClauseWriter::VisitOMPSafelenClause(OMPSafelenClause *C) {
-  Writer->Writer.AddStmt(C->getSafelen());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
+void OMPClauseWriter::VisitOMPCollapseClause(OMPCollapseClause *C) {
+  Writer.AddStmt(C->getNumForLoops());
 }
 
-void OMPClauseWriter::VisitOMPCollapseClause(OMPCollapseClause *C) {
-  Writer->Writer.AddStmt(C->getNumForLoops());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
+void OMPClauseWriter::VisitOMPDeviceClause(OMPDeviceClause *C) {
+  Writer.AddStmt(C->getDevice());
 }
 
 void OMPClauseWriter::VisitOMPDefaultClause(OMPDefaultClause *C) {
   Record.push_back(C->getDefaultKind());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
-  Writer->Writer.AddSourceLocation(C->getDefaultKindKwLoc(), Record);
+  Writer.AddSourceLocation(C->getDefaultKindLoc(), Record);
 }
 
 void OMPClauseWriter::VisitOMPProcBindClause(OMPProcBindClause *C) {
-  Record.push_back(C->getProcBindKind());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
-  Writer->Writer.AddSourceLocation(C->getProcBindKindKwLoc(), Record);
+  Record.push_back(C->getThreadAffinity());
+  Writer.AddSourceLocation(C->getThreadAffinityLoc(), Record);
 }
 
 void OMPClauseWriter::VisitOMPScheduleClause(OMPScheduleClause *C) {
   Record.push_back(C->getScheduleKind());
-  Writer->Writer.AddStmt(C->getChunkSize());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
-  Writer->Writer.AddSourceLocation(C->getScheduleKindLoc(), Record);
-  Writer->Writer.AddSourceLocation(C->getCommaLoc(), Record);
+  Writer.AddSourceLocation(C->getScheduleKindLoc(), Record);
+  Writer.AddStmt(C->getChunkSize());
 }
 
-void OMPClauseWriter::VisitOMPOrderedClause(OMPOrderedClause *) {}
-
-void OMPClauseWriter::VisitOMPNowaitClause(OMPNowaitClause *) {}
-
-void OMPClauseWriter::VisitOMPUntiedClause(OMPUntiedClause *) {}
-
-void OMPClauseWriter::VisitOMPMergeableClause(OMPMergeableClause *) {}
+void OMPClauseWriter::VisitOMPDistScheduleClause(OMPDistScheduleClause *C) {
+  Record.push_back(C->getDistScheduleKind());
+  Writer.AddSourceLocation(C->getDistScheduleKindLoc(), Record);
+  Writer.AddStmt(C->getDistChunkSize());
+}
 
 void OMPClauseWriter::VisitOMPPrivateClause(OMPPrivateClause *C) {
   Record.push_back(C->varlist_size());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
-  for (auto *VE : C->varlists())
-    Writer->Writer.AddStmt(VE);
+  for (OMPPrivateClause::varlist_iterator I = C->varlist_begin(),
+                                          E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getDefaultInits().begin(),
+                                  E = C->getDefaultInits().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
 }
 
-void OMPClauseWriter::VisitOMPFirstprivateClause(OMPFirstprivateClause *C) {
+void OMPClauseWriter::VisitOMPFirstPrivateClause(OMPFirstPrivateClause *C) {
   Record.push_back(C->varlist_size());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
-  for (auto *VE : C->varlists())
-    Writer->Writer.AddStmt(VE);
+  for (OMPFirstPrivateClause::varlist_iterator I = C->varlist_begin(),
+                                               E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getPseudoVars().begin(),
+                                  E = C->getPseudoVars().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getInits().begin(),
+                                  E = C->getInits().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
 }
 
-void OMPClauseWriter::VisitOMPLastprivateClause(OMPLastprivateClause *C) {
+void OMPClauseWriter::VisitOMPLastPrivateClause(OMPLastPrivateClause *C) {
   Record.push_back(C->varlist_size());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
-  for (auto *VE : C->varlists())
-    Writer->Writer.AddStmt(VE);
+  for (OMPLastPrivateClause::varlist_iterator I = C->varlist_begin(),
+                                              E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getPseudoVars1().begin(),
+                                  E = C->getPseudoVars1().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getPseudoVars2().begin(),
+                                  E = C->getPseudoVars2().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getDefaultInits().begin(),
+                                  E = C->getDefaultInits().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getAssignments().begin(),
+                                  E = C->getAssignments().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
 }
 
 void OMPClauseWriter::VisitOMPSharedClause(OMPSharedClause *C) {
   Record.push_back(C->varlist_size());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
-  for (auto *VE : C->varlists())
-    Writer->Writer.AddStmt(VE);
+  for (OMPSharedClause::varlist_iterator I = C->varlist_begin(),
+                                         E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+}
+
+void OMPClauseWriter::VisitOMPCopyinClause(OMPCopyinClause *C) {
+  Record.push_back(C->varlist_size());
+  for (OMPCopyinClause::varlist_iterator I = C->varlist_begin(),
+                                         E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getPseudoVars1().begin(),
+                                  E = C->getPseudoVars1().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getPseudoVars2().begin(),
+                                  E = C->getPseudoVars2().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getAssignments().begin(),
+                                  E = C->getAssignments().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+}
+
+void OMPClauseWriter::VisitOMPCopyPrivateClause(OMPCopyPrivateClause *C) {
+  Record.push_back(C->varlist_size());
+  for (OMPCopyPrivateClause::varlist_iterator I = C->varlist_begin(),
+                                              E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getPseudoVars1().begin(),
+                                  E = C->getPseudoVars1().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getPseudoVars2().begin(),
+                                  E = C->getPseudoVars2().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getAssignments().begin(),
+                                  E = C->getAssignments().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
 }
 
 void OMPClauseWriter::VisitOMPReductionClause(OMPReductionClause *C) {
   Record.push_back(C->varlist_size());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
-  Writer->Writer.AddSourceLocation(C->getColonLoc(), Record);
-  Writer->Writer.AddNestedNameSpecifierLoc(C->getQualifierLoc(), Record);
-  Writer->Writer.AddDeclarationNameInfo(C->getNameInfo(), Record);
-  for (auto *VE : C->varlists())
-    Writer->Writer.AddStmt(VE);
+  Record.push_back(C->getOperator());
+  Writer.AddNestedNameSpecifierLoc(C->getSpec(), Record);
+  Writer.AddDeclarationNameInfo(C->getOpName(), Record);
+  for (OMPReductionClause::varlist_iterator I = C->varlist_begin(),
+                                            E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getOpExprs().begin(),
+                                  E = C->getOpExprs().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getHelperParameters1st().begin(),
+                                  E = C->getHelperParameters1st().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getHelperParameters2nd().begin(),
+                                  E = C->getHelperParameters2nd().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getDefaultInits().begin(),
+                                  E = C->getDefaultInits().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
 }
 
-void OMPClauseWriter::VisitOMPLinearClause(OMPLinearClause *C) {
+void OMPClauseWriter::VisitOMPOrderedClause(OMPOrderedClause *C) { }
+
+void OMPClauseWriter::VisitOMPNowaitClause(OMPNowaitClause *C) { }
+
+void OMPClauseWriter::VisitOMPUntiedClause(OMPUntiedClause *C) { }
+
+void OMPClauseWriter::VisitOMPMergeableClause(OMPMergeableClause *C) { }
+
+void OMPClauseWriter::VisitOMPReadClause(OMPReadClause *C) { }
+
+void OMPClauseWriter::VisitOMPWriteClause(OMPWriteClause *C) { }
+
+void OMPClauseWriter::VisitOMPUpdateClause(OMPUpdateClause *C) { }
+
+void OMPClauseWriter::VisitOMPCaptureClause(OMPCaptureClause *C) { }
+
+void OMPClauseWriter::VisitOMPSeqCstClause(OMPSeqCstClause *C) { }
+
+void OMPClauseWriter::VisitOMPInBranchClause(OMPInBranchClause *C) { }
+
+void OMPClauseWriter::VisitOMPNotInBranchClause(OMPNotInBranchClause *C) { }
+
+void OMPClauseWriter::VisitOMPFlushClause(OMPFlushClause *C) {
   Record.push_back(C->varlist_size());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
-  Writer->Writer.AddSourceLocation(C->getColonLoc(), Record);
-  for (auto *VE : C->varlists())
-    Writer->Writer.AddStmt(VE);
-  Writer->Writer.AddStmt(C->getStep());
+  for (OMPFlushClause::varlist_iterator I = C->varlist_begin(),
+                                        E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
 }
 
-void OMPClauseWriter::VisitOMPAlignedClause(OMPAlignedClause *C) {
+void OMPClauseWriter::VisitOMPDependClause(OMPDependClause *C) {
   Record.push_back(C->varlist_size());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
-  Writer->Writer.AddSourceLocation(C->getColonLoc(), Record);
-  for (auto *VE : C->varlists())
-    Writer->Writer.AddStmt(VE);
-  Writer->Writer.AddStmt(C->getAlignment());
+  Record.push_back(C->getType());
+  Writer.AddSourceLocation(C->getTypeLoc(), Record);
+  for (OMPDependClause::varlist_iterator I = C->varlist_begin(),
+                                         E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (unsigned i = 0, e = C->varlist_size(); i != e; ++i)
+    Writer.AddStmt(C->getBegins(i));
+  for (unsigned i = 0, e = C->varlist_size(); i != e; ++i)
+    Writer.AddStmt(C->getSizeInBytes(i));
 }
 
-void OMPClauseWriter::VisitOMPCopyinClause(OMPCopyinClause *C) {
+void OMPClauseWriter::VisitOMPMapClause(OMPMapClause *C) {
   Record.push_back(C->varlist_size());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
-  for (auto *VE : C->varlists())
-    Writer->Writer.AddStmt(VE);
+  Record.push_back(C->getKind());
+  Writer.AddSourceLocation(C->getKindLoc(), Record);
+  for (OMPMapClause::varlist_iterator I = C->varlist_begin(),
+                                      E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getWholeStartAddresses().begin(),
+                                  E = C->getWholeStartAddresses().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getWholeSizesEndAddresses().begin(),
+                                  E = C->getWholeSizesEndAddresses().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getCopyingStartAddresses().begin(),
+                                  E = C->getCopyingStartAddresses().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getCopyingSizesEndAddresses().begin(),
+                                  E = C->getCopyingSizesEndAddresses().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
 }
 
-void OMPClauseWriter::VisitOMPCopyprivateClause(OMPCopyprivateClause *C) {
+void OMPClauseWriter::VisitOMPToClause(OMPToClause *C) {
   Record.push_back(C->varlist_size());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
-  for (auto *VE : C->varlists())
-    Writer->Writer.AddStmt(VE);
+  for (OMPToClause::varlist_iterator I = C->varlist_begin(),
+                                     E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getWholeStartAddresses().begin(),
+                                  E = C->getWholeStartAddresses().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getWholeSizesEndAddresses().begin(),
+                                  E = C->getWholeSizesEndAddresses().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getCopyingStartAddresses().begin(),
+                                  E = C->getCopyingStartAddresses().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getCopyingSizesEndAddresses().begin(),
+                                  E = C->getCopyingSizesEndAddresses().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
 }
 
-void OMPClauseWriter::VisitOMPFlushClause(OMPFlushClause *C) {
+void OMPClauseWriter::VisitOMPFromClause(OMPFromClause *C) {
   Record.push_back(C->varlist_size());
-  Writer->Writer.AddSourceLocation(C->getLParenLoc(), Record);
-  for (auto *VE : C->varlists())
-    Writer->Writer.AddStmt(VE);
+  for (OMPFromClause::varlist_iterator I = C->varlist_begin(),
+                                       E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getWholeStartAddresses().begin(),
+                                  E = C->getWholeStartAddresses().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getWholeSizesEndAddresses().begin(),
+                                  E = C->getWholeSizesEndAddresses().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getCopyingStartAddresses().begin(),
+                                  E = C->getCopyingStartAddresses().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  for (ArrayRef<Expr *>::iterator I = C->getCopyingSizesEndAddresses().begin(),
+                                  E = C->getCopyingSizesEndAddresses().end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+}
+
+void OMPClauseWriter::VisitOMPUniformClause(OMPUniformClause *C) {
+  Record.push_back(C->varlist_size());
+  for (OMPUniformClause::varlist_iterator I = C->varlist_begin(),
+                                          E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+}
+
+void OMPClauseWriter::VisitOMPSafelenClause(OMPSafelenClause *C) {
+  Writer.AddStmt(C->getSafelen());
+}
+
+void OMPClauseWriter::VisitOMPSimdlenClause(OMPSimdlenClause *C) {
+  Writer.AddStmt(C->getSimdlen());
+}
+
+void OMPClauseWriter::VisitOMPNumTeamsClause(OMPNumTeamsClause *C) {
+  Writer.AddStmt(C->getNumTeams());
+}
+
+void OMPClauseWriter::VisitOMPThreadLimitClause(OMPThreadLimitClause *C) {
+  Writer.AddStmt(C->getThreadLimit());
+}
+
+void OMPClauseWriter::VisitOMPLinearClause(OMPLinearClause *C) {
+  Record.push_back(C->varlist_size());
+  for (OMPLinearClause::varlist_iterator I = C->varlist_begin(),
+                                         E = C->varlist_end();
+       I != E; ++I)
+    Writer.AddStmt(*I);
+  Writer.AddStmt(C->getStep());
+}
+
+void OMPClauseWriter::VisitOMPAlignedClause(OMPAlignedClause *C) {
+  Record.push_back(C->varlist_size());
+  for (OMPAlignedClause::varlist_iterator I = C->varlist_begin(),
+                                          E = C->varlist_end();
+        I != E; ++I)
+    Writer.AddStmt(*I);
+  Writer.AddStmt(C->getAlignment());
 }
 
 //===----------------------------------------------------------------------===//
@@ -1818,8 +2011,8 @@
 void ASTStmtWriter::VisitOMPExecutableDirective(OMPExecutableDirective *E) {
   Writer.AddSourceLocation(E->getLocStart(), Record);
   Writer.AddSourceLocation(E->getLocEnd(), Record);
-  OMPClauseWriter ClauseWriter(this, Record);
-  for (unsigned i = 0; i < E->getNumClauses(); ++i) {
+  OMPClauseWriter ClauseWriter(Writer, Record);
+  for (unsigned i = 0, N = E->getNumClauses(); i < N; ++i) {
     ClauseWriter.writeClause(E->getClause(i));
   }
   if (E->hasAssociatedStmt())
@@ -1833,61 +2026,212 @@
   Code = serialization::STMT_OMP_PARALLEL_DIRECTIVE;
 }
 
+void ASTStmtWriter::VisitOMPForDirective(OMPForDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
+  VisitOMPExecutableDirective(D);
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_FOR_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPParallelForDirective(OMPParallelForDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
+  VisitOMPExecutableDirective(D);
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_PARALLEL_FOR_DIRECTIVE;
+}
+
 void ASTStmtWriter::VisitOMPSimdDirective(OMPSimdDirective *D) {
   VisitStmt(D);
   Record.push_back(D->getNumClauses());
   Record.push_back(D->getCollapsedNumber());
   VisitOMPExecutableDirective(D);
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
   Code = serialization::STMT_OMP_SIMD_DIRECTIVE;
 }
 
-void ASTStmtWriter::VisitOMPForDirective(OMPForDirective *D) {
+void ASTStmtWriter::VisitOMPForSimdDirective(OMPForSimdDirective *D) {
   VisitStmt(D);
   Record.push_back(D->getNumClauses());
   Record.push_back(D->getCollapsedNumber());
   VisitOMPExecutableDirective(D);
-  Code = serialization::STMT_OMP_FOR_DIRECTIVE;
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_FOR_SIMD_DIRECTIVE;
 }
 
-void ASTStmtWriter::VisitOMPSectionsDirective(OMPSectionsDirective *D) {
+void ASTStmtWriter::VisitOMPParallelForSimdDirective(
+    OMPParallelForSimdDirective *D) {
   VisitStmt(D);
   Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
   VisitOMPExecutableDirective(D);
-  Code = serialization::STMT_OMP_SECTIONS_DIRECTIVE;
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_PARALLEL_FOR_SIMD_DIRECTIVE;
 }
 
-void ASTStmtWriter::VisitOMPSectionDirective(OMPSectionDirective *D) {
+void
+ASTStmtWriter::VisitOMPDistributeSimdDirective(OMPDistributeSimdDirective *D) {
   VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
   VisitOMPExecutableDirective(D);
-  Code = serialization::STMT_OMP_SECTION_DIRECTIVE;
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_DISTRIBUTE_SIMD_DIRECTIVE;
 }
 
-void ASTStmtWriter::VisitOMPSingleDirective(OMPSingleDirective *D) {
+void ASTStmtWriter::VisitOMPDistributeParallelForDirective(
+    OMPDistributeParallelForDirective *D) {
   VisitStmt(D);
   Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
   VisitOMPExecutableDirective(D);
-  Code = serialization::STMT_OMP_SINGLE_DIRECTIVE;
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  Writer.AddStmt(D->getLowerBound());
+  Writer.AddStmt(D->getUpperBound());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE;
 }
 
-void ASTStmtWriter::VisitOMPMasterDirective(OMPMasterDirective *D) {
+void ASTStmtWriter::VisitOMPDistributeParallelForSimdDirective(
+    OMPDistributeParallelForSimdDirective *D) {
   VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
   VisitOMPExecutableDirective(D);
-  Code = serialization::STMT_OMP_MASTER_DIRECTIVE;
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  Writer.AddStmt(D->getLowerBound());
+  Writer.AddStmt(D->getUpperBound());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE;
 }
 
-void ASTStmtWriter::VisitOMPCriticalDirective(OMPCriticalDirective *D) {
+void ASTStmtWriter::VisitOMPTeamsDistributeParallelForDirective(
+    OMPTeamsDistributeParallelForDirective *D) {
   VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
   VisitOMPExecutableDirective(D);
-  Writer.AddDeclarationNameInfo(D->getDirectiveName(), Record);
-  Code = serialization::STMT_OMP_CRITICAL_DIRECTIVE;
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  Writer.AddStmt(D->getLowerBound());
+  Writer.AddStmt(D->getUpperBound());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE;
 }
 
-void ASTStmtWriter::VisitOMPParallelForDirective(OMPParallelForDirective *D) {
+void ASTStmtWriter::VisitOMPTeamsDistributeParallelForSimdDirective(
+    OMPTeamsDistributeParallelForSimdDirective *D) {
   VisitStmt(D);
   Record.push_back(D->getNumClauses());
   Record.push_back(D->getCollapsedNumber());
   VisitOMPExecutableDirective(D);
-  Code = serialization::STMT_OMP_PARALLEL_FOR_DIRECTIVE;
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  Writer.AddStmt(D->getLowerBound());
+  Writer.AddStmt(D->getUpperBound());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPTargetTeamsDistributeParallelForDirective(
+    OMPTargetTeamsDistributeParallelForDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
+  VisitOMPExecutableDirective(D);
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  Writer.AddStmt(D->getLowerBound());
+  Writer.AddStmt(D->getUpperBound());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPTargetTeamsDistributeParallelForSimdDirective(
+    OMPTargetTeamsDistributeParallelForSimdDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
+  VisitOMPExecutableDirective(D);
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  Writer.AddStmt(D->getLowerBound());
+  Writer.AddStmt(D->getUpperBound());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::
+      STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPSectionsDirective(OMPSectionsDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  VisitOMPExecutableDirective(D);
+  Code = serialization::STMT_OMP_SECTIONS_DIRECTIVE;
 }
 
 void ASTStmtWriter::VisitOMPParallelSectionsDirective(
@@ -1898,6 +2242,20 @@
   Code = serialization::STMT_OMP_PARALLEL_SECTIONS_DIRECTIVE;
 }
 
+void ASTStmtWriter::VisitOMPSectionDirective(OMPSectionDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  VisitOMPExecutableDirective(D);
+  Code = serialization::STMT_OMP_SECTION_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPSingleDirective(OMPSingleDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  VisitOMPExecutableDirective(D);
+  Code = serialization::STMT_OMP_SINGLE_DIRECTIVE;
+}
+
 void ASTStmtWriter::VisitOMPTaskDirective(OMPTaskDirective *D) {
   VisitStmt(D);
   Record.push_back(D->getNumClauses());
@@ -1907,22 +2265,60 @@
 
 void ASTStmtWriter::VisitOMPTaskyieldDirective(OMPTaskyieldDirective *D) {
   VisitStmt(D);
+  Record.push_back(D->getNumClauses());
   VisitOMPExecutableDirective(D);
   Code = serialization::STMT_OMP_TASKYIELD_DIRECTIVE;
 }
 
+void ASTStmtWriter::VisitOMPMasterDirective(OMPMasterDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  VisitOMPExecutableDirective(D);
+  Code = serialization::STMT_OMP_MASTER_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPCriticalDirective(OMPCriticalDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  VisitOMPExecutableDirective(D);
+  Writer.AddDeclarationNameInfo(D->getDirectiveName(), Record);
+  Code = serialization::STMT_OMP_CRITICAL_DIRECTIVE;
+}
+
 void ASTStmtWriter::VisitOMPBarrierDirective(OMPBarrierDirective *D) {
   VisitStmt(D);
+  Record.push_back(D->getNumClauses());
   VisitOMPExecutableDirective(D);
   Code = serialization::STMT_OMP_BARRIER_DIRECTIVE;
 }
 
 void ASTStmtWriter::VisitOMPTaskwaitDirective(OMPTaskwaitDirective *D) {
   VisitStmt(D);
+  Record.push_back(D->getNumClauses());
   VisitOMPExecutableDirective(D);
   Code = serialization::STMT_OMP_TASKWAIT_DIRECTIVE;
 }
 
+void ASTStmtWriter::VisitOMPTaskgroupDirective(OMPTaskgroupDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  VisitOMPExecutableDirective(D);
+  Code = serialization::STMT_OMP_TASKGROUP_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPAtomicDirective(OMPAtomicDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  VisitOMPExecutableDirective(D);
+  Writer.AddStmt(D->getV());
+  Writer.AddStmt(D->getX());
+  Writer.AddStmt(D->getExpr());
+  Record.push_back(D->getOperator());
+  Record.push_back(D->isCaptureAfter() ? 1 : 0);
+  Record.push_back(D->isReversed() ? 1 : 0);
+  Code = serialization::STMT_OMP_ATOMIC_DIRECTIVE;
+}
+
 void ASTStmtWriter::VisitOMPFlushDirective(OMPFlushDirective *D) {
   VisitStmt(D);
   Record.push_back(D->getNumClauses());
@@ -1930,6 +2326,140 @@
   Code = serialization::STMT_OMP_FLUSH_DIRECTIVE;
 }
 
+void ASTStmtWriter::VisitOMPOrderedDirective(OMPOrderedDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  VisitOMPExecutableDirective(D);
+  Code = serialization::STMT_OMP_ORDERED_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPTeamsDirective(OMPTeamsDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  VisitOMPExecutableDirective(D);
+  Code = serialization::STMT_OMP_TEAMS_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPTargetTeamsDirective(OMPTargetTeamsDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  VisitOMPExecutableDirective(D);
+  Code = serialization::STMT_OMP_TARGET_TEAMS_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPDistributeDirective(OMPDistributeDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
+  VisitOMPExecutableDirective(D);
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_DISTRIBUTE_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPCancelDirective(OMPCancelDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  Record.push_back(D->getConstructType());
+  VisitOMPExecutableDirective(D);
+  Code = serialization::STMT_OMP_CANCEL_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPCancellationPointDirective(
+                                    OMPCancellationPointDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getConstructType());
+  VisitOMPExecutableDirective(D);
+  Code = serialization::STMT_OMP_CANCELLATION_POINT_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPTargetDirective(OMPTargetDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  VisitOMPExecutableDirective(D);
+  Code = serialization::STMT_OMP_TARGET_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPTargetDataDirective(OMPTargetDataDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  VisitOMPExecutableDirective(D);
+  Code = serialization::STMT_OMP_TARGET_DATA_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPTargetUpdateDirective(OMPTargetUpdateDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  VisitOMPExecutableDirective(D);
+  Code = serialization::STMT_OMP_TARGET_UPDATE_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPTeamsDistributeDirective(
+    OMPTeamsDistributeDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
+  VisitOMPExecutableDirective(D);
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_TEAMS_DISTRIBUTE_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPTeamsDistributeSimdDirective(
+    OMPTeamsDistributeSimdDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
+  VisitOMPExecutableDirective(D);
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPTargetTeamsDistributeDirective(
+    OMPTargetTeamsDistributeDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
+  VisitOMPExecutableDirective(D);
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE;
+}
+
+void ASTStmtWriter::VisitOMPTargetTeamsDistributeSimdDirective(
+    OMPTargetTeamsDistributeSimdDirective *D) {
+  VisitStmt(D);
+  Record.push_back(D->getNumClauses());
+  Record.push_back(D->getCollapsedNumber());
+  VisitOMPExecutableDirective(D);
+  Writer.AddStmt(D->getNewIterVar());
+  Writer.AddStmt(D->getNewIterEnd());
+  Writer.AddStmt(D->getInit());
+  Writer.AddStmt(D->getFinal());
+  for (unsigned i = 0, N = D->getCollapsedNumber(); i < N; ++i) {
+    Writer.AddStmt(D->getCounters()[i]);
+  }
+  Code = serialization::STMT_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE;
+}
+
 //===----------------------------------------------------------------------===//
 // ASTWriter Implementation
 //===----------------------------------------------------------------------===//
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/lib/StaticAnalyzer/Core/ExprEngine.cpp cfe-3.5.0.src.omp/lib/StaticAnalyzer/Core/ExprEngine.cpp
--- cfe-3.5.0.src/lib/StaticAnalyzer/Core/ExprEngine.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/lib/StaticAnalyzer/Core/ExprEngine.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -730,22 +730,46 @@
     case Stmt::SwitchStmtClass:
     case Stmt::WhileStmtClass:
     case Expr::MSDependentExistsStmtClass:
-    case Stmt::CapturedStmtClass:
     case Stmt::OMPParallelDirectiveClass:
-    case Stmt::OMPSimdDirectiveClass:
     case Stmt::OMPForDirectiveClass:
+    case Stmt::OMPParallelForDirectiveClass:
+    case Stmt::OMPParallelForSimdDirectiveClass:
+    case Stmt::OMPSimdDirectiveClass:
+    case Stmt::OMPForSimdDirectiveClass:
+    case Stmt::OMPDistributeSimdDirectiveClass:
+    case Stmt::OMPDistributeParallelForDirectiveClass:
+    case Stmt::OMPDistributeParallelForSimdDirectiveClass:
+    case Stmt::OMPTeamsDistributeParallelForDirectiveClass:
+    case Stmt::OMPTeamsDistributeParallelForSimdDirectiveClass:
+    case Stmt::OMPTargetTeamsDistributeParallelForDirectiveClass:
+    case Stmt::OMPTargetTeamsDistributeParallelForSimdDirectiveClass:
     case Stmt::OMPSectionsDirectiveClass:
+    case Stmt::OMPParallelSectionsDirectiveClass:
     case Stmt::OMPSectionDirectiveClass:
     case Stmt::OMPSingleDirectiveClass:
-    case Stmt::OMPMasterDirectiveClass:
-    case Stmt::OMPCriticalDirectiveClass:
-    case Stmt::OMPParallelForDirectiveClass:
-    case Stmt::OMPParallelSectionsDirectiveClass:
     case Stmt::OMPTaskDirectiveClass:
     case Stmt::OMPTaskyieldDirectiveClass:
+    case Stmt::OMPMasterDirectiveClass:
+    case Stmt::OMPCriticalDirectiveClass:
     case Stmt::OMPBarrierDirectiveClass:
     case Stmt::OMPTaskwaitDirectiveClass:
+    case Stmt::OMPTaskgroupDirectiveClass:
+    case Stmt::OMPAtomicDirectiveClass:
     case Stmt::OMPFlushDirectiveClass:
+    case Stmt::OMPOrderedDirectiveClass:
+    case Stmt::OMPTeamsDirectiveClass:
+    case Stmt::OMPTargetTeamsDirectiveClass:
+    case Stmt::OMPDistributeDirectiveClass:
+    case Stmt::OMPCancelDirectiveClass:
+    case Stmt::OMPCancellationPointDirectiveClass:
+    case Stmt::OMPTargetDirectiveClass:
+    case Stmt::OMPTargetDataDirectiveClass:
+    case Stmt::OMPTargetUpdateDirectiveClass:
+    case Stmt::OMPTeamsDistributeDirectiveClass:
+    case Stmt::OMPTeamsDistributeSimdDirectiveClass:
+    case Stmt::OMPTargetTeamsDistributeDirectiveClass:
+    case Stmt::OMPTargetTeamsDistributeSimdDirectiveClass:
+    case Stmt::CapturedStmtClass:
       llvm_unreachable("Stmt should not be in analyzer evaluation loop");
 
     case Stmt::ObjCSubscriptRefExprClass:
@@ -792,7 +816,8 @@
     case Stmt::OpaqueValueExprClass:
     case Stmt::AsTypeExprClass:
     case Stmt::AtomicExprClass:
-      // Fall through.
+    case Stmt::CEANIndexExprClass:
+    // Fall through.
 
     // Cases we intentionally don't evaluate, since they don't need
     // to be explicitly evaluated.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/CodeGenCXX/ctor-dtor-alias.cpp cfe-3.5.0.src.omp/test/CodeGenCXX/ctor-dtor-alias.cpp
--- cfe-3.5.0.src/test/CodeGenCXX/ctor-dtor-alias.cpp	2014-06-02 22:42:01.000000000 -0400
+++ cfe-3.5.0.src.omp/test/CodeGenCXX/ctor-dtor-alias.cpp	2014-11-28 10:49:30.000000000 -0500
@@ -4,6 +4,9 @@
 // RUN: %clang_cc1 -triple x86_64--netbsd -emit-llvm \
 // RUN: -mconstructor-aliases -O2 %s -o - | FileCheck --check-prefix=CHECK-RAUW %s
 
+// RUN: %clang_cc1 -cc1 -triple x86_64--netbsd -emit-llvm \
+// RUN: -mconstructor-aliases -O2 %s -o - | FileCheck --check-prefix=CHECK-RAUW %s
+
 namespace test1 {
 // test that we don't produce an alias when the destructor is weak_odr. The
 // reason to avoid it that another TU might have no explicit template
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/Driver/Inputs/montavista_i686_tree/usr/lib/gcc/i686-montavista-linux/4.2.0/libgcc.a000644 cfe-3.5.0.src.omp/test/Driver/Inputs/montavista_i686_tree/usr/lib/gcc/i686-montavista-linux/4.2.0/libgcc.a000644
--- cfe-3.5.0.src/test/Driver/Inputs/montavista_i686_tree/usr/lib/gcc/i686-montavista-linux/4.2.0/libgcc.a000644	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/Driver/Inputs/montavista_i686_tree/usr/lib/gcc/i686-montavista-linux/4.2.0/libgcc.a000644	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1 @@
+dummy file for gcc toolchain detection (libgcc.a)
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/Driver/cl-x86-flags.c cfe-3.5.0.src.omp/test/Driver/cl-x86-flags.c
--- cfe-3.5.0.src/test/Driver/cl-x86-flags.c	2014-07-16 14:31:25.000000000 -0400
+++ cfe-3.5.0.src.omp/test/Driver/cl-x86-flags.c	2014-11-28 10:49:31.000000000 -0500
@@ -9,73 +9,73 @@
 // MFLAGS-NOT: argument unused during compilation
 
 // -arch:IA32 is no-op.
-// RUN: %clang_cl -m32 -arch:IA32 -### -- 2>&1 %s | FileCheck -check-prefix=IA32 %s
+// RUN: %clang_cl -m32 -arch:IA32 --target=i386 -### -- 2>&1 %s | FileCheck -check-prefix=IA32 %s
 // IA32-NOT: argument unused during compilation
 // IA32-NOT: -target-feature
 
-// RUN: %clang_cl -m32 -arch:ia32 -### -- 2>&1 %s | FileCheck -check-prefix=ia32 %s
+// RUN: %clang_cl -m32 -arch:ia32 --target=i386 -### -- 2>&1 %s | FileCheck -check-prefix=ia32 %s
 // ia32: argument unused during compilation
 // ia32-NOT: -target-feature
 
-// RUN: %clang_cl -m64 -arch:IA32 -### -- 2>&1 %s | FileCheck -check-prefix=IA3264 %s
+// RUN: %clang_cl -m64 -arch:IA32 --target=x86_64 -### -- 2>&1 %s | FileCheck -check-prefix=IA3264 %s
 // IA3264: argument unused during compilation
 // IA3264-NOT: -target-feature
 
-// RUN: %clang_cl -m32 -arch:SSE -### -- 2>&1 %s | FileCheck -check-prefix=SSE %s
+// RUN: %clang_cl -m32 -arch:SSE --target=i386 -### -- 2>&1 %s | FileCheck -check-prefix=SSE %s
 // SSE: -target-feature
 // SSE: +sse
 // SSE-NOT: argument unused during compilation
 
-// RUN: %clang_cl -m32 -arch:sse -### -- 2>&1 %s | FileCheck -check-prefix=sse %s
+// RUN: %clang_cl -m32 -arch:sse --target=i386 -### -- 2>&1 %s | FileCheck -check-prefix=sse %s
 // sse: argument unused during compilation
 // sse-NOT: -target-feature
 
-// RUN: %clang_cl -m32 -arch:SSE2 -### -- 2>&1 %s | FileCheck -check-prefix=SSE2 %s
+// RUN: %clang_cl -m32 -arch:SSE2 --target=i386 -### -- 2>&1 %s | FileCheck -check-prefix=SSE2 %s
 // SSE2: -target-feature
 // SSE2: +sse2
 // SSE2-NOT: argument unused during compilation
 
-// RUN: %clang_cl -m32 -arch:sse2 -### -- 2>&1 %s | FileCheck -check-prefix=sse %s
+// RUN: %clang_cl -m32 -arch:sse2 --target=i386 -### -- 2>&1 %s | FileCheck -check-prefix=sse %s
 // sse2: argument unused during compilation
 // sse2-NOT: -target-feature
 
-// RUN: %clang_cl -m64 -arch:SSE -### -- 2>&1 %s | FileCheck -check-prefix=SSE64 %s
+// RUN: %clang_cl -m64 -arch:SSE --target=x86_64 -### -- 2>&1 %s | FileCheck -check-prefix=SSE64 %s
 // SSE64: argument unused during compilation
 // SSE64-NOT: -target-feature
 
-// RUN: %clang_cl -m64 -arch:SSE2 -### -- 2>&1 %s | FileCheck -check-prefix=SSE264 %s
+// RUN: %clang_cl -m64 -arch:SSE2 --target=x86_64 -### -- 2>&1 %s | FileCheck -check-prefix=SSE264 %s
 // SSE264: argument unused during compilation
 // SSE264-NOT: -target-feature
 
-// RUN: %clang_cl -m32 -arch:AVX -### -- 2>&1 %s | FileCheck -check-prefix=AVX %s
+// RUN: %clang_cl -m32 -arch:AVX --target=i386 -### -- 2>&1 %s | FileCheck -check-prefix=AVX %s
 // AVX: -target-feature
 // AVX: +avx
 
-// RUN: %clang_cl -m32 -arch:avx -### -- 2>&1 %s | FileCheck -check-prefix=avx %s
+// RUN: %clang_cl -m32 -arch:avx --target=i386 -### -- 2>&1 %s | FileCheck -check-prefix=avx %s
 // avx: argument unused during compilation
 // avx-NOT: -target-feature
 
-// RUN: %clang_cl -m32 -arch:AVX2 -### -- 2>&1 %s | FileCheck -check-prefix=AVX2 %s
+// RUN: %clang_cl -m32 -arch:AVX2 --target=i386 -### -- 2>&1 %s | FileCheck -check-prefix=AVX2 %s
 // AVX2: -target-feature
 // AVX2: +avx2
 
-// RUN: %clang_cl -m32 -arch:avx2 -### -- 2>&1 %s | FileCheck -check-prefix=avx2 %s
+// RUN: %clang_cl -m32 -arch:avx2 --target=i386 -### -- 2>&1 %s | FileCheck -check-prefix=avx2 %s
 // avx2: argument unused during compilation
 // avx2-NOT: -target-feature
 
-// RUN: %clang_cl -m64 -arch:AVX -### -- 2>&1 %s | FileCheck -check-prefix=AVX64 %s
+// RUN: %clang_cl -m64 -arch:AVX --target=x86_64 -### -- 2>&1 %s | FileCheck -check-prefix=AVX64 %s
 // AVX64: -target-feature
 // AVX64: +avx
 
-// RUN: %clang_cl -m64 -arch:avx -### -- 2>&1 %s | FileCheck -check-prefix=avx64 %s
+// RUN: %clang_cl -m64 -arch:avx --target=x86_64 -### -- 2>&1 %s | FileCheck -check-prefix=avx64 %s
 // avx64: argument unused during compilation
 // avx64-NOT: -target-feature
 
-// RUN: %clang_cl -m64 -arch:AVX2 -### -- 2>&1 %s | FileCheck -check-prefix=AVX264 %s
+// RUN: %clang_cl -m64 -arch:AVX2 --target=x86_64 -### -- 2>&1 %s | FileCheck -check-prefix=AVX264 %s
 // AVX264: -target-feature
 // AVX264: +avx2
 
-// RUN: %clang_cl -m64 -arch:avx2 -### -- 2>&1 %s | FileCheck -check-prefix=avx264 %s
+// RUN: %clang_cl -m64 -arch:avx2 --target=x86_64 -### -- 2>&1 %s | FileCheck -check-prefix=avx264 %s
 // avx264: argument unused during compilation
 // avx264-NOT: -target-feature
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/Driver/constructors.c cfe-3.5.0.src.omp/test/Driver/constructors.c
--- cfe-3.5.0.src/test/Driver/constructors.c	2014-04-17 08:51:36.000000000 -0400
+++ cfe-3.5.0.src.omp/test/Driver/constructors.c	2014-11-28 10:49:31.000000000 -0500
@@ -7,49 +7,58 @@
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1       \
 // RUN:     -target i386-unknown-linux \
 // RUN:     --sysroot=%S/Inputs/fake_install_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-INIT-ARRAY %s
 //
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1       \
 // RUN:     -fno-use-init-array \
 // RUN:     -target i386-unknown-linux \
 // RUN:     --sysroot=%S/Inputs/fake_install_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-NO-INIT-ARRAY %s
 //
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1       \
 // RUN:     -fno-use-init-array -fuse-init-array \
 // RUN:     -target i386-unknown-linux \
 // RUN:     --sysroot=%S/Inputs/fake_install_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-INIT-ARRAY %s
 //
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1       \
 // RUN:     -target i386-unknown-linux \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-NO-INIT-ARRAY %s
 //
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1       \
 // RUN:     -fuse-init-array \
 // RUN:     -target i386-unknown-linux \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-INIT-ARRAY %s
 //
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1       \
 // RUN:     -target arm-unknown-linux-androideabi \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-INIT-ARRAY %s
 //
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1       \
 // RUN:     -target mipsel-unknown-linux-android \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-INIT-ARRAY %s
 //
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1       \
 // RUN:     -target i386-unknown-linux-android \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-INIT-ARRAY %s
 //
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1       \
 // RUN:     -target aarch64-none-linux-gnu \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-INIT-ARRAY %s
 //
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1       \
@@ -59,6 +68,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1       \
 // RUN:     -target arm64-none-linux-gnu \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-INIT-ARRAY %s
 //
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1       \
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/Driver/gcc-version-debug.c cfe-3.5.0.src.omp/test/Driver/gcc-version-debug.c
--- cfe-3.5.0.src/test/Driver/gcc-version-debug.c	2013-08-14 18:10:17.000000000 -0400
+++ cfe-3.5.0.src.omp/test/Driver/gcc-version-debug.c	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,5 @@
 // RUN: %clang -v --target=i386-unknown-linux \
+// RUN:           --gcc-toolchain="" \
 // RUN:           --sysroot=%S/Inputs/debian_multiarch_tree 2>&1 | FileCheck %s
 
 // CHECK: Found candidate GCC installation: {{.*}}Inputs{{.}}debian_multiarch_tree{{.}}usr{{.}}lib{{.}}gcc{{.}}i686-linux-gnu{{.}}4.5
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/Driver/hexagon-toolchain-elf.c cfe-3.5.0.src.omp/test/Driver/hexagon-toolchain-elf.c
--- cfe-3.5.0.src/test/Driver/hexagon-toolchain-elf.c	2014-06-27 07:18:13.000000000 -0400
+++ cfe-3.5.0.src.omp/test/Driver/hexagon-toolchain-elf.c	2014-11-28 10:49:31.000000000 -0500
@@ -4,6 +4,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK001 %s
 // CHECK001: "-cc1" {{.*}} "-internal-externc-isystem" "{{.*}}/Inputs/hexagon_tree/qc/bin/../../gnu/lib/gcc/hexagon/4.4.0/include"
@@ -13,6 +14,7 @@
 
 // RUN: %clangxx -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK002 %s
 // CHECK002: "-cc1" {{.*}} "-internal-isystem" "[[INSTALL_DIR:.*]]/Inputs/hexagon_tree/qc/bin/../../gnu{{/|\\\\}}hexagon/include/c++/4.4.0"
@@ -27,6 +29,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nostdinc \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK003 %s
@@ -38,6 +41,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nostdlibinc \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK004 %s
@@ -49,6 +53,7 @@
 
 // RUN: %clangxx -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nostdlibinc \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK005 %s
@@ -61,6 +66,7 @@
 
 // RUN: %clangxx -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nostdinc++ \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK006 %s
@@ -73,6 +79,7 @@
 // -----------------------------------------------------------------------------
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -march=hexagonv3 \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK007 %s
@@ -82,6 +89,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -mcpu=hexagonv5 \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK008 %s
@@ -91,6 +99,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -mv2 \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK009 %s
@@ -100,6 +109,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK010 %s
 // CHECK010: "-cc1" {{.*}} "-target-cpu" "hexagonv4"
@@ -131,6 +141,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK011 %s
 // CHECK011: "-cc1"
@@ -155,6 +166,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clangxx -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK012 %s
 // CHECK012: "-cc1"
@@ -180,6 +192,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -Lone -L two -L three \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK013 %s
@@ -204,6 +217,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -static \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK014 %s
@@ -225,6 +239,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -shared \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK015 %s
@@ -254,6 +269,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -shared \
 // RUN:   -static \
 // RUN:   %s 2>&1 \
@@ -287,6 +303,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clangxx -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nostdlib \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK017 %s
@@ -313,6 +330,7 @@
 
 // RUN: %clangxx -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nostartfiles \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK018 %s
@@ -339,6 +357,7 @@
 
 // RUN: %clangxx -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nodefaultlibs \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK019 %s
@@ -368,6 +387,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -moslib=first -moslib=second \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK020 %s
@@ -393,6 +413,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -moslib=first -moslib=second -moslib=standalone\
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK021 %s
@@ -421,6 +442,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clangxx -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -s \
 // RUN:   -Tbss 0xdead -Tdata 0xbeef -Ttext 0xcafe \
 // RUN:   -t \
@@ -453,6 +475,7 @@
 // -----------------------------------------------------------------------------
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK023 %s
 // CHECK023:      "-cc1"
@@ -464,16 +487,19 @@
 
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -fpic \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK024 %s
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -fPIC \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK024 %s
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -fPIC \
 // RUN:   -msmall-data-threshold=8 \
 // RUN:   %s 2>&1 \
@@ -489,16 +515,19 @@
 
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -G=8 \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK025 %s
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -G 8 \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK025 %s
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -msmall-data-threshold=8 \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK025 %s
@@ -515,6 +544,7 @@
 // -----------------------------------------------------------------------------
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -pie \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK026 %s
@@ -525,6 +555,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -pie -shared \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK027 %s
@@ -538,6 +569,7 @@
 // -----------------------------------------------------------------------------
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK028 %s
 // CHECK028:      "-cc1"
@@ -551,6 +583,7 @@
 // -----------------------------------------------------------------------------
 // RUN: %clang -### -target hexagon-unknown-elf     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -gdwarf-2 \
 // RUN:   -Wa,--noexecstack,--trap \
 // RUN:   -Xassembler --keep-locals \
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/Driver/hexagon-toolchain.c cfe-3.5.0.src.omp/test/Driver/hexagon-toolchain.c
--- cfe-3.5.0.src/test/Driver/hexagon-toolchain.c	2014-06-27 07:18:13.000000000 -0400
+++ cfe-3.5.0.src.omp/test/Driver/hexagon-toolchain.c	2014-11-28 10:49:31.000000000 -0500
@@ -4,6 +4,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK001 %s
 // CHECK001: "-cc1" {{.*}} "-internal-externc-isystem" "{{.*}}/Inputs/hexagon_tree/qc/bin/../../gnu/lib/gcc/hexagon/4.4.0/include"
@@ -13,6 +14,7 @@
 
 // RUN: %clangxx -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK002 %s
 // CHECK002: "-cc1" {{.*}} "-internal-isystem" "[[INSTALL_DIR:.*]]/Inputs/hexagon_tree/qc/bin/../../gnu{{/|\\\\}}hexagon/include/c++/4.4.0"
@@ -27,6 +29,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nostdinc \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK003 %s
@@ -38,6 +41,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nostdlibinc \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK004 %s
@@ -49,6 +53,7 @@
 
 // RUN: %clangxx -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nostdlibinc \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK005 %s
@@ -61,6 +66,7 @@
 
 // RUN: %clangxx -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nostdinc++ \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK006 %s
@@ -73,6 +79,7 @@
 // -----------------------------------------------------------------------------
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -march=hexagonv3 \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK007 %s
@@ -82,6 +89,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -mcpu=hexagonv5 \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK008 %s
@@ -91,6 +99,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -mv2 \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK009 %s
@@ -100,6 +109,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK010 %s
 // CHECK010: "-cc1" {{.*}} "-target-cpu" "hexagonv4"
@@ -131,6 +141,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK011 %s
 // CHECK011: "-cc1"
@@ -155,6 +166,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clangxx -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK012 %s
 // CHECK012: "-cc1"
@@ -180,6 +192,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -Lone -L two -L three \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK013 %s
@@ -204,6 +217,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -static \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK014 %s
@@ -225,6 +239,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -shared \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK015 %s
@@ -254,6 +269,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -shared \
 // RUN:   -static \
 // RUN:   %s 2>&1 \
@@ -287,6 +303,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clangxx -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nostdlib \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK017 %s
@@ -313,6 +330,7 @@
 
 // RUN: %clangxx -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nostartfiles \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK018 %s
@@ -339,6 +357,7 @@
 
 // RUN: %clangxx -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -nodefaultlibs \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK019 %s
@@ -368,6 +387,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -moslib=first -moslib=second \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK020 %s
@@ -393,6 +413,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -moslib=first -moslib=second -moslib=standalone\
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK021 %s
@@ -421,6 +442,7 @@
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // RUN: %clangxx -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -s \
 // RUN:   -Tbss 0xdead -Tdata 0xbeef -Ttext 0xcafe \
 // RUN:   -t \
@@ -453,6 +475,7 @@
 // -----------------------------------------------------------------------------
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK023 %s
 // CHECK023:      "-cc1"
@@ -464,16 +487,19 @@
 
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -fpic \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK024 %s
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -fPIC \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK024 %s
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -fPIC \
 // RUN:   -msmall-data-threshold=8 \
 // RUN:   %s 2>&1 \
@@ -489,16 +515,19 @@
 
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -G=8 \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK025 %s
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -G 8 \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK025 %s
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -msmall-data-threshold=8 \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK025 %s
@@ -515,6 +544,7 @@
 // -----------------------------------------------------------------------------
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -pie \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK026 %s
@@ -525,6 +555,7 @@
 
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -pie -shared \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK027 %s
@@ -538,6 +569,7 @@
 // -----------------------------------------------------------------------------
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   %s 2>&1 \
 // RUN:   | FileCheck -check-prefix=CHECK028 %s
 // CHECK028:      "-cc1"
@@ -551,6 +583,7 @@
 // -----------------------------------------------------------------------------
 // RUN: %clang -### -target hexagon-unknown-linux     \
 // RUN:   -ccc-install-dir %S/Inputs/hexagon_tree/qc/bin \
+// RUN:   --gcc-toolchain="" \
 // RUN:   -gdwarf-2 \
 // RUN:   -Wa,--noexecstack,--trap \
 // RUN:   -Xassembler --keep-locals \
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/Driver/linux-header-search.cpp cfe-3.5.0.src.omp/test/Driver/linux-header-search.cpp
--- cfe-3.5.0.src/test/Driver/linux-header-search.cpp	2014-08-27 16:07:13.000000000 -0400
+++ cfe-3.5.0.src.omp/test/Driver/linux-header-search.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -8,6 +8,7 @@
 // RUN:     -stdlib=libc++ \
 // RUN:     -ccc-install-dir %S/Inputs/basic_linux_tree/usr/bin \
 // RUN:     --sysroot=%S/Inputs/basic_linux_libcxx_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-BASIC-LIBCXX-SYSROOT %s
 // CHECK-BASIC-LIBCXX-SYSROOT: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-BASIC-LIBCXX-SYSROOT: "-isysroot" "[[SYSROOT:[^"]+]]"
@@ -18,6 +19,7 @@
 // RUN:     -stdlib=libc++ \
 // RUN:     -ccc-install-dir %S/Inputs/basic_linux_libcxx_tree/usr/bin \
 // RUN:     --sysroot=%S/Inputs/basic_linux_libcxx_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-BASIC-LIBCXX-INSTALL %s
 // CHECK-BASIC-LIBCXX-INSTALL: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-BASIC-LIBCXX-INSTALL: "-isysroot" "[[SYSROOT:[^"]+]]"
@@ -27,7 +29,9 @@
 // Test a very broken version of multiarch that shipped in Ubuntu 11.04.
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target i386-unknown-linux \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/ubuntu_11.04_multiarch_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-UBUNTU-11-04 %s
 // CHECK-UBUNTU-11-04: "{{.*}}clang{{.*}}" "-cc1"
 // CHECK-UBUNTU-11-04: "-isysroot" "[[SYSROOT:[^"]+]]"
@@ -41,7 +45,9 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target x86_64-unknown-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/ubuntu_13.04_multiarch_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-UBUNTU-13-04 %s
 // CHECK-UBUNTU-13-04: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-UBUNTU-13-04: "-isysroot" "[[SYSROOT:[^"]+]]"
@@ -57,6 +63,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target x86_64-unknown-linux-gnux32 \
 // RUN:     --sysroot=%S/Inputs/ubuntu_14.04_multiarch_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-UBUNTU-14-04 %s
 // CHECK-UBUNTU-14-04: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-UBUNTU-14-04: "-isysroot" "[[SYSROOT:[^"]+]]"
@@ -71,7 +78,9 @@
 ///
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target arm-linux-gnueabihf \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/ubuntu_13.04_multiarch_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-UBUNTU-13-04-CROSS %s
 // CHECK-UBUNTU-13-04-CROSS: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-UBUNTU-13-04-CROSS: "-isysroot" "[[SYSROOT:[^"]+]]"
@@ -86,7 +95,9 @@
 // Test Ubuntu/Debian's new version of multiarch, with -m32.
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target x86_64-unknown-linux-gnu -m32 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/ubuntu_13.04_multiarch_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-UBUNTU-13-04-M32 %s
 // CHECK-UBUNTU-13-04-M32: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-UBUNTU-13-04-M32: "-triple" "i386-unknown-linux-gnu"
@@ -100,6 +111,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target x86_64-unknown-linux-gnu -m32 \
 // RUN:     --sysroot=%S/Inputs/ubuntu_14.04_multiarch_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-UBUNTU-14-04-M32 %s
 // CHECK-UBUNTU-14-04-M32: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-UBUNTU-14-04-M32: "-triple" "i386-unknown-linux-gnu"
@@ -114,6 +126,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target x86_64-unknown-linux-gnu -m32 \
 // RUN:     --sysroot=%S/Inputs/ubuntu_14.04_multiarch_tree2 \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-UBUNTU-14-04-I686 %s
 // CHECK-UBUNTU-14-04-I686: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-UBUNTU-14-04-I686: "-triple" "i386-unknown-linux-gnu"
@@ -126,6 +139,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target powerpc64le-unknown-linux-gnu -m32 \
 // RUN:     --sysroot=%S/Inputs/ubuntu_14.04_multiarch_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-UBUNTU-14-04-PPC64LE %s
 // CHECK-UBUNTU-14-04-PPC64LE: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-UBUNTU-14-04-PPC64LE: "-triple" "powerpc64le-unknown-linux-gnu"
@@ -140,7 +154,9 @@
 // Thoroughly exercise the Debian multiarch environment.
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target i686-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-X86 %s
 // CHECK-DEBIAN-X86: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-DEBIAN-X86: "-isysroot" "[[SYSROOT:[^"]+]]"
@@ -154,7 +170,9 @@
 // CHECK-DEBIAN-X86: "-internal-externc-isystem" "[[SYSROOT]]/usr/include"
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target x86_64-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-X86-64 %s
 // CHECK-DEBIAN-X86-64: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-DEBIAN-X86-64: "-isysroot" "[[SYSROOT:[^"]+]]"
@@ -168,7 +186,9 @@
 // CHECK-DEBIAN-X86-64: "-internal-externc-isystem" "[[SYSROOT]]/usr/include"
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target powerpc-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-PPC %s
 // CHECK-DEBIAN-PPC: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-DEBIAN-PPC: "-isysroot" "[[SYSROOT:[^"]+]]"
@@ -182,7 +202,9 @@
 // CHECK-DEBIAN-PPC: "-internal-externc-isystem" "[[SYSROOT]]/usr/include"
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target powerpc64-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-PPC64 %s
 // CHECK-DEBIAN-PPC64: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-DEBIAN-PPC64: "-isysroot" "[[SYSROOT:[^"]+]]"
@@ -199,7 +221,9 @@
 // 4.6.4 release.
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target x86_64-unknown-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/gentoo_linux_gcc_4.6.2_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-GENTOO-4-6-2 %s
 // CHECK-GENTOO-4-6-2: "{{.*}}clang{{.*}}" "-cc1"
 // CHECK-GENTOO-4-6-2: "-isysroot" "[[SYSROOT:[^"]+]]"
@@ -212,7 +236,9 @@
 // CHECK-GENTOO-4-6-2: "-internal-externc-isystem" "[[SYSROOT]]/usr/include"
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target x86_64-unknown-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/gentoo_linux_gcc_4.6.4_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-GENTOO-4-6-4 %s
 // CHECK-GENTOO-4-6-4: "{{.*}}clang{{.*}}" "-cc1"
 // CHECK-GENTOO-4-6-4: "-isysroot" "[[SYSROOT:[^"]+]]"
@@ -228,6 +254,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target mips64-unknown-linux-gnuabi64 \
 // RUN:     --sysroot=%S/Inputs/debian_6_mips64_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-MIPS64-GNUABI %s
 // CHECK-MIPS64-GNUABI: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-MIPS64-GNUABI: "-isysroot" "[[SYSROOT:[^"]+]]"
@@ -244,6 +271,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -fsyntax-only 2>&1 \
 // RUN:     -target mips64el-unknown-linux-gnuabi64 \
 // RUN:     --sysroot=%S/Inputs/debian_6_mips64_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-MIPS64EL-GNUABI %s
 // CHECK-MIPS64EL-GNUABI: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
 // CHECK-MIPS64EL-GNUABI: "-isysroot" "[[SYSROOT:[^"]+]]"
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/Driver/linux-ld.c cfe-3.5.0.src.omp/test/Driver/linux-ld.c
--- cfe-3.5.0.src/test/Driver/linux-ld.c	2014-07-16 04:46:35.000000000 -0400
+++ cfe-3.5.0.src.omp/test/Driver/linux-ld.c	2014-11-28 10:49:31.000000000 -0500
@@ -3,6 +3,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i386-unknown-linux \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-LD-32 %s
 // CHECK-LD-32-NOT: warning:
@@ -16,6 +17,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-unknown-linux \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-LD-64 %s
 // CHECK-LD-64-NOT: warning:
@@ -35,6 +37,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-unknown-linux-gnux32 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-LD-X32 %s
 // CHECK-LD-X32-NOT: warning:
@@ -48,6 +51,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-unknown-linux \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:     --rtlib=compiler-rt \
 // RUN:   | FileCheck --check-prefix=CHECK-LD-RT %s
@@ -68,6 +72,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-unknown-linux \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:     --rtlib=libgcc \
 // RUN:   | FileCheck --check-prefix=CHECK-LD-GCC %s
@@ -89,6 +94,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-unknown-linux \
 // RUN:     -static-libgcc \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-LD-64-STATIC-LIBGCC %s
 // CHECK-LD-64-STATIC-LIBGCC-NOT: warning:
@@ -109,6 +115,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-unknown-linux \
 // RUN:     -static \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-LD-64-STATIC %s
 // CHECK-LD-64-STATIC-NOT: warning:
@@ -129,11 +136,13 @@
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-unknown-linux \
 // RUN:     -static-libgcc -static \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-LD-64-STATIC %s
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i386-unknown-linux -m32 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/multilib_32bit_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-32-TO-32 %s
 // CHECK-32-TO-32: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -150,6 +159,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i386-unknown-linux -m64 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/multilib_32bit_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-32-TO-64 %s
 // CHECK-32-TO-64: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -167,6 +177,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-unknown-linux -m64 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/multilib_64bit_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-64-TO-64 %s
 // CHECK-64-TO-64: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -183,6 +194,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-unknown-linux -m32 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/multilib_64bit_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-64-TO-32 %s
 // CHECK-64-TO-32: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -200,6 +212,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-unknown-linux-gnux32 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/multilib_64bit_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-X32 %s
 // CHECK-X32: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -217,6 +230,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-unknown-linux -mx32 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/multilib_64bit_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-64-TO-X32 %s
 // CHECK-64-TO-X32: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -234,6 +248,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i386-unknown-linux -mx32 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/multilib_64bit_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-32-TO-X32 %s
 // CHECK-32-TO-X32: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -266,6 +281,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i386-unknown-linux -m32 \
 // RUN:     -ccc-install-dir %S/Inputs/fake_install_tree/bin \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-INSTALL-DIR-32 %s
 // CHECK-INSTALL-DIR-32: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -277,6 +293,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-unknown-linux -m64 \
 // RUN:     -ccc-install-dir %S/Inputs/fake_install_tree/bin \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-INSTALL-DIR-64 %s
 // CHECK-INSTALL-DIR-64: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -288,6 +305,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i386-unknown-linux -m32 \
 // RUN:     -ccc-install-dir %S/Inputs/gcc_version_parsing1/bin \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-GCC-VERSION1 %s
 // CHECK-GCC-VERSION1: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -296,6 +314,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i386-unknown-linux -m32 \
 // RUN:     -ccc-install-dir %S/Inputs/gcc_version_parsing2/bin \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-GCC-VERSION2 %s
 // CHECK-GCC-VERSION2: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -304,6 +323,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i386-unknown-linux -m32 \
 // RUN:     -ccc-install-dir %S/Inputs/gcc_version_parsing3/bin \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-GCC-VERSION3 %s
 // CHECK-GCC-VERSION3: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -312,6 +332,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i386-unknown-linux -m32 \
 // RUN:     -ccc-install-dir %S/Inputs/gcc_version_parsing4/bin \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-GCC-VERSION4 %s
 // CHECK-GCC-VERSION4: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -324,6 +345,7 @@
 // RUN:     -target x86_64-unknown-linux-gnu \
 // RUN:     -stdlib=libc++ \
 // RUN:     -ccc-install-dir %S/Inputs/basic_linux_tree/usr/bin \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_libcxx_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-BASIC-LIBCXX-SYSROOT %s
 // CHECK-BASIC-LIBCXX-SYSROOT: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
@@ -335,6 +357,7 @@
 // RUN:     -target x86_64-unknown-linux-gnu \
 // RUN:     -stdlib=libc++ \
 // RUN:     -ccc-install-dir %S/Inputs/basic_linux_libcxx_tree/usr/bin \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_linux_libcxx_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-BASIC-LIBCXX-INSTALL %s
 // CHECK-BASIC-LIBCXX-INSTALL: "{{[^"]*}}clang{{[^"]*}}" "-cc1"
@@ -347,6 +370,7 @@
 // Test a very broken version of multiarch that shipped in Ubuntu 11.04.
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i386-unknown-linux \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/ubuntu_11.04_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-UBUNTU-11-04 %s
 // CHECK-UBUNTU-11-04: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -361,6 +385,7 @@
 // Check multi arch support on Ubuntu 12.04 LTS.
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-unknown-linux-gnueabihf \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/ubuntu_12.04_LTS_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-UBUNTU-12-04-ARM-HF %s
 // CHECK-UBUNTU-12-04-ARM-HF: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -378,6 +403,7 @@
 // Check Ubuntu 13.10 on x86-64 targeting arm-linux-gnueabihf.
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-gnueabihf \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/x86-64_ubuntu_13.10 \
 // RUN:   | FileCheck --check-prefix=CHECK-X86-64-UBUNTU-13-10-ARM-HF %s
 // CHECK-X86-64-UBUNTU-13-10-ARM-HF: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -396,6 +422,7 @@
 // Check Ubuntu 13.10 on x86-64 targeting arm-linux-gnueabi.
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-gnueabi \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/x86-64_ubuntu_13.10 \
 // RUN:   | FileCheck --check-prefix=CHECK-X86-64-UBUNTU-13-10-ARM %s
 // CHECK-X86-64-UBUNTU-13-10-ARM: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -414,6 +441,7 @@
 // Check Ubuntu 14.04 on powerpc64le.
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=powerpc64le-unknown-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/ubuntu_14.04_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-UBUNTU-14-04-PPC64LE %s
 // CHECK-UBUNTU-14-04-PPC64LE: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -432,6 +460,7 @@
 // "/usr/lib/gcc/x86_64-linux-gnu/4.8/x32/crtend.o" "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../libx32/crtn.o"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-unknown-linux-gnux32 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/ubuntu_14.04_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-UBUNTU-14-04-X32 %s
 // CHECK-UBUNTU-14-04-X32: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -451,6 +480,7 @@
 // Check fedora 18 on arm.
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=armv7-unknown-linux-gnueabihf \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/fedora_18_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-FEDORA-18-ARM-HF %s
 // CHECK-FEDORA-18-ARM-HF: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -465,10 +495,12 @@
 // Check Fedora 21 on AArch64.
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm64-unknown-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/fedora_21_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-FEDORA-21-AARCH64 %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=aarch64-unknown-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/fedora_21_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-FEDORA-21-AARCH64 %s
 // CHECK-FEDORA-21-AARCH64: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -482,6 +514,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-unknown-linux-gnueabi \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/ubuntu_12.04_LTS_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-UBUNTU-12-04-ARM %s
 // CHECK-UBUNTU-12-04-ARM: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -499,6 +532,7 @@
 // Test the setup that shipped in SUSE 10.3 on ppc64.
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=powerpc64-suse-linux \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/suse_10.3_ppc64_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-SUSE-10-3-PPC64 %s
 // CHECK-SUSE-10-3-PPC64: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -633,6 +667,7 @@
 // Thoroughly exercise the Debian multiarch environment.
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i686-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-X86 %s
 // CHECK-DEBIAN-X86: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -645,6 +680,7 @@
 // CHECK-DEBIAN-X86: "-L[[SYSROOT]]/usr/lib"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-X86-64 %s
 // CHECK-DEBIAN-X86-64: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -657,6 +693,7 @@
 // CHECK-DEBIAN-X86-64: "-L[[SYSROOT]]/usr/lib"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=powerpc-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-PPC %s
 // CHECK-DEBIAN-PPC: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -669,6 +706,7 @@
 // CHECK-DEBIAN-PPC: "-L[[SYSROOT]]/usr/lib"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=powerpc64-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-PPC64 %s
 // CHECK-DEBIAN-PPC64: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -681,6 +719,7 @@
 // CHECK-DEBIAN-PPC64: "-L[[SYSROOT]]/usr/lib"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-MIPS %s
 // CHECK-DEBIAN-MIPS: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -693,6 +732,7 @@
 // CHECK-DEBIAN-MIPS: "-L[[SYSROOT]]/usr/lib"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mipsel-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-MIPSEL %s
 // CHECK-DEBIAN-MIPSEL: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -705,6 +745,7 @@
 // CHECK-DEBIAN-MIPSEL: "-L[[SYSROOT]]/usr/lib"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-MIPS64 %s
 // CHECK-DEBIAN-MIPS64: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -716,6 +757,7 @@
 // CHECK-DEBIAN-MIPS64: "-L[[SYSROOT]]/usr/lib"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64el-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-MIPS64EL %s
 // CHECK-DEBIAN-MIPS64EL: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -727,6 +769,7 @@
 // CHECK-DEBIAN-MIPS64EL: "-L[[SYSROOT]]/usr/lib"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64-linux-gnu -mabi=n32 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-MIPS64-N32 %s
 // CHECK-DEBIAN-MIPS64-N32: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -738,6 +781,7 @@
 // CHECK-DEBIAN-MIPS64-N32: "-L[[SYSROOT]]/usr/lib"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64el-linux-gnu -mabi=n32 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_multiarch_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-MIPS64EL-N32 %s
 // CHECK-DEBIAN-MIPS64EL-N32: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -751,34 +795,42 @@
 // Test linker invocation on Android.
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-androideabi \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=aarch64-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm64-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mipsel-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64el-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i686-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID %s
 // CHECK-ANDROID: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -791,16 +843,19 @@
 // CHECK-ANDROID: "{{.*}}{{/|\\\\}}crtend_android.o"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-androideabi \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-SO %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-SO %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=aarch64-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-SO %s
@@ -811,21 +866,25 @@
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-SO %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mipsel-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-SO %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64el-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-SO %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i686-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-SO %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-SO %s
@@ -840,16 +899,19 @@
 // CHECK-ANDROID-SO: "{{.*}}{{/|\\\\}}crtend_so.o"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-androideabi \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -static \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-STATIC %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -static \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-STATIC %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=aarch64-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -static \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-STATIC %s
@@ -860,21 +922,25 @@
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-STATIC %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mipsel-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -static \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-STATIC %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64el-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -static \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-STATIC %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i686-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -static \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-STATIC %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -static \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-STATIC %s
@@ -888,41 +954,49 @@
 // CHECK-ANDROID-STATIC: "{{.*}}{{/|\\\\}}crtend_android.o"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-androideabi \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot  \
 // RUN:     -pie \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PIE %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -pie \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PIE %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=aarch64-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot  \
 // RUN:     -pie \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PIE %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm64-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot  \
 // RUN:     -pie \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PIE %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mipsel-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -pie \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PIE %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64el-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -pie \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PIE %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i686-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -pie \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PIE %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -pie \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PIE %s
@@ -935,34 +1009,42 @@
 // CHECK-ANDROID-PIE: "{{.*}}{{/|\\\\}}crtend_android.o"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-androideabi \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-32 %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-32 %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mipsel-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-32 %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=aarch64-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-64 %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm64-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-64 %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64el-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-64 %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i686-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-32 %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-linux-android \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-64 %s
 // CHECK-ANDROID-32: "-dynamic-linker" "/system/bin/linker"
@@ -971,18 +1053,22 @@
 // Test that -pthread does not add -lpthread on Android.
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-androideabi -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-android -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=aarch64-linux-android -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm64-linux-android -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
@@ -991,53 +1077,64 @@
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64el-linux-android -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i686-linux-android -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-linux-android -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-androideabi -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm-linux-android -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=aarch64-linux-android -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=arm64-linux-android -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mipsel-linux-android -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64el-linux-android -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=i686-linux-android -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=x86_64-linux-android -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:     -shared \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD %s
@@ -1045,6 +1142,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %t.o -### -o %t 2>&1 \
 // RUN:     --target=arm-linux-androideabi -pthread \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/basic_android_tree/sysroot \
 // RUN:   | FileCheck --check-prefix=CHECK-ANDROID-PTHREAD-LINK %s
 // CHECK-ANDROID-PTHREAD-LINK-NOT: argument unused during compilation: '-pthread'
@@ -1052,6 +1150,7 @@
 // Check linker invocation on Debian 6 MIPS 32/64-bit.
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mipsel-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_6_mips_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-ML-MIPSEL %s
 // CHECK-DEBIAN-ML-MIPSEL: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -1068,6 +1167,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64el-linux-gnu \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_6_mips_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-ML-MIPS64EL %s
 // CHECK-DEBIAN-ML-MIPS64EL: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -1084,6 +1184,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64el-linux-gnu -mabi=n32 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_6_mips_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-ML-MIPS64EL-N32 %s
 // CHECK-DEBIAN-ML-MIPS64EL-N32: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -1100,6 +1201,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64-linux-gnuabi64 -mabi=n64 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_6_mips64_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-ML-MIPS64-GNUABI %s
 // CHECK-DEBIAN-ML-MIPS64-GNUABI: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -1119,6 +1221,7 @@
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips64el-linux-gnuabi64 -mabi=n64 \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/debian_6_mips64_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-ML-MIPS64EL-GNUABI %s
 // CHECK-DEBIAN-ML-MIPS64EL-GNUABI: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -1139,6 +1242,7 @@
 // Test linker invocation for Freescale SDK (OpenEmbedded).
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=powerpc-fsl-linux \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/freescale_ppc_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-FSL-PPC %s
 // CHECK-FSL-PPC: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -1148,6 +1252,7 @@
 // CHECK-FSL-PPC: "-L[[SYSROOT]]/usr/lib"
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=powerpc64-fsl-linux \
+// RUN:     --gcc-toolchain="" \
 // RUN:     --sysroot=%S/Inputs/freescale_ppc64_tree \
 // RUN:   | FileCheck --check-prefix=CHECK-FSL-PPC64 %s
 // CHECK-FSL-PPC64: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
@@ -1158,41 +1263,53 @@
 //
 // Check that crtfastmath.o is linked with -ffast-math and with -Ofast.
 // RUN: %clang --target=x86_64-unknown-linux -### %s \
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-NOCRTFASTMATH %s
 // RUN: %clang --target=x86_64-unknown-linux -### %s -ffast-math \
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CRTFASTMATH %s
 // RUN: %clang --target=x86_64-unknown-linux -### %s -funsafe-math-optimizations\
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CRTFASTMATH %s
 // RUN: %clang --target=x86_64-unknown-linux -### %s -Ofast\
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CRTFASTMATH %s
 // RUN: %clang --target=x86_64-unknown-linux -### %s -Ofast -O3\
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-NOCRTFASTMATH %s
 // RUN: %clang --target=x86_64-unknown-linux -### %s -O3 -Ofast\
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CRTFASTMATH %s
 // RUN: %clang --target=x86_64-unknown-linux -### %s -ffast-math -fno-fast-math \
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-NOCRTFASTMATH %s
 // RUN: %clang --target=x86_64-unknown-linux -### %s -Ofast -fno-fast-math \
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CRTFASTMATH %s
 // RUN: %clang --target=x86_64-unknown-linux -### %s -Ofast -fno-unsafe-math-optimizations \
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CRTFASTMATH %s
 // RUN: %clang --target=x86_64-unknown-linux -### %s -fno-fast-math -Ofast  \
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CRTFASTMATH %s
 // RUN: %clang --target=x86_64-unknown-linux -### %s -fno-unsafe-math-optimizations -Ofast \
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CRTFASTMATH %s
 // We don't have crtfastmath.o in the i386 tree, use it to check that file
 // detection works.
 // RUN: %clang --target=i386-unknown-linux -### %s -ffast-math \
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-NOCRTFASTMATH %s
 // CHECK-CRTFASTMATH: usr/lib/gcc/x86_64-unknown-linux/4.6.0{{/|\\\\}}crtfastmath.o
@@ -1200,12 +1317,14 @@
 
 // Check that we link in gcrt1.o when compiling with -pg
 // RUN: %clang -pg --target=x86_64-unknown-linux -### %s \
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>& 1 \
 // RUN:   | FileCheck --check-prefix=CHECK-PG %s
 // CHECK-PG: gcrt1.o
 
 // GCC forwards -u to the linker.
 // RUN: %clang -u asdf --target=x86_64-unknown-linux -### %s \
+// RUN:        --gcc-toolchain="" \
 // RUN:        --sysroot=%S/Inputs/basic_linux_tree 2>& 1 \
 // RUN:   | FileCheck --check-prefix=CHECK-u %s
 // CHECK-u: "-u" "asdf"
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/Driver/mips-reduced-toolchain.cpp cfe-3.5.0.src.omp/test/Driver/mips-reduced-toolchain.cpp
--- cfe-3.5.0.src/test/Driver/mips-reduced-toolchain.cpp	2014-03-04 13:37:28.000000000 -0500
+++ cfe-3.5.0.src.omp/test/Driver/mips-reduced-toolchain.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -4,6 +4,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mips-linux-gnu \
 // RUN:     --sysroot=%S/Inputs/debian_reduced_mips_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-MIPS %s
 // CHECK-DEBIAN-MIPS: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
 // CHECK-DEBIAN-MIPS: "{{.*}}/usr/lib/gcc/mips-linux-gnu/4.7{{/|\\\\}}crtbegin.o"
@@ -17,6 +18,7 @@
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     --target=mipsel-linux-gnu \
 // RUN:     --sysroot=%S/Inputs/debian_reduced_mips_tree \
+// RUN:     --gcc-toolchain="" \
 // RUN:   | FileCheck --check-prefix=CHECK-DEBIAN-MIPSEL %s
 // CHECK-DEBIAN-MIPSEL: "{{.*}}ld{{(.exe)?}}" "--sysroot=[[SYSROOT:[^"]+]]"
 // CHECK-DEBIAN-MIPSEL: "{{.*}}/usr/lib/gcc/mipsel-linux-gnu/4.7{{/|\\\\}}crtbegin.o"
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/Driver/pic.c cfe-3.5.0.src.omp/test/Driver/pic.c
--- cfe-3.5.0.src/test/Driver/pic.c	2014-06-24 15:51:29.000000000 -0400
+++ cfe-3.5.0.src.omp/test/Driver/pic.c	2014-11-28 10:49:31.000000000 -0500
@@ -118,12 +118,15 @@
 // Make sure -pie is passed to along to ld and that the right *crt* files
 // are linked in.
 // RUN: %clang %s -target i386-unknown-freebsd -fPIE -pie -### \
+// RUN: --gcc-toolchain="" \
 // RUN: --sysroot=%S/Inputs/basic_freebsd_tree 2>&1 \
 // RUN:   | FileCheck %s --check-prefix=CHECK-PIE-LD
 // RUN: %clang %s -target i386-linux-gnu -fPIE -pie -### \
+// RUN: --gcc-toolchain="" \
 // RUN: --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck %s --check-prefix=CHECK-PIE-LD
 // RUN: %clang %s -target i386-linux-gnu -fPIC -pie -### \
+// RUN: --gcc-toolchain="" \
 // RUN: --sysroot=%S/Inputs/basic_linux_tree 2>&1 \
 // RUN:   | FileCheck %s --check-prefix=CHECK-PIE-LD
 //
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/array.c cfe-3.5.0.src.omp/test/OpenMP/array.c
--- cfe-3.5.0.src/test/OpenMP/array.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/array.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,29 @@
+// RUN: %clang_cc1 -verify -fopenmp -S -emit-llvm -o - -Wno-sizeof-array-argument %s
+// expected-no-diagnostics
+
+int A[2][2] = {1, 2, 3, 4};
+void assert(int arg) { }
+void f(int n, int B[n][n], int C[])
+{
+   int D[2][2] = {1, 2, 3, 4};
+   int E[n][n];
+   assert(n >= 2);
+   E[1][1] = 4;
+#pragma omp parallel firstprivate(B, C, D, E)
+   {
+      assert(sizeof(B) == sizeof(int (*)[n]));
+      assert(sizeof(C) == sizeof(int*));
+      assert(sizeof(D) == 4 * sizeof(int));
+      assert(sizeof(E) == n * n * sizeof(int));
+      /* Private B and C have values of original B and C. */
+      assert(&B[1][1] == &A[1][1]);
+      assert(&C[3] == &A[1][1]);
+      assert(D[1][1] == 4);
+      assert(E[1][1] == 4);
+   }
+}
+int main() {
+   f(2, A, A[0]);
+   return 0;
+}
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/atomic_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/atomic_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/atomic_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/atomic_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,60 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int a;
+// CHECK: int a;
+#pragma omp atomic
+a++;
+// CHECK-NEXT: #pragma omp atomic
+// CHECK-NEXT: a++;
+#pragma omp atomic update
+a--;
+// CHECK-NEXT: #pragma omp atomic update
+// CHECK-NEXT: a--;
+#pragma omp atomic seq_cst
+++a;
+// CHECK-NEXT: #pragma omp atomic seq_cst
+// CHECK-NEXT: ++a;
+#pragma omp atomic update seq_cst
+--a;
+// CHECK-NEXT: #pragma omp atomic update seq_cst
+// CHECK-NEXT: --a;
+#pragma omp atomic read
+a = argc;
+// CHECK-NEXT: #pragma omp atomic read
+// CHECK-NEXT: a = argc;
+#pragma omp atomic read seq_cst
+argc = a;
+// CHECK-NEXT: #pragma omp atomic read seq_cst
+// CHECK-NEXT: argc = a;
+#pragma omp atomic write
+a = argc * 2;
+// CHECK-NEXT: #pragma omp atomic write
+// CHECK-NEXT: a = argc * 2;
+#pragma omp atomic write seq_cst
+argc = a - 3;
+// CHECK-NEXT: #pragma omp atomic write seq_cst
+// CHECK-NEXT: argc = a - 3;
+#pragma omp atomic capture
+a = argc++;
+// CHECK-NEXT: #pragma omp atomic capture
+// CHECK-NEXT: a = argc++;
+#pragma omp atomic capture seq_cst
+{argc = a; ++a;}
+// CHECK-NEXT: #pragma omp atomic capture seq_cst
+// CHECK-NEXT: {
+// CHECK-NEXT: argc = a;
+// CHECK-NEXT: ++a;
+// CHECK-NEXT: }
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/atomic_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/atomic_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/atomic_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/atomic_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,130 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int foo();
+
+struct S {
+  int s;
+  S operator+=(const S &s) { return *this; }
+} s1, s2, s3;
+
+int main() {
+  int a, b, c;
+  int arr[5];
+  
+  #pragma omp atomic
+  ; // expected-error {{expected expression statement for '#pragma omp atomic update'}}
+  #pragma omp atomic untied // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp atomic'}}
+  ++a;
+  #pragma omp atomic unknown // expected-warning {{extra tokens at the end of '#pragma omp atomic' are ignored}}
+  ++a;
+  #pragma omp atomic read write update capture // expected-error {{directive '#pragma omp atomic' cannot contain more than one 'read', 'write', 'update' or 'capture' clause}}
+  ++a;
+  #pragma omp atomic (name) // expected-warning {{extra tokens at the end of '#pragma omp atomic' are ignored}}
+  ++a;
+  #pragma omp atomic read
+  a = b;
+  #pragma omp atomic read seq_cst
+  a = b;
+  #pragma omp atomic read
+  s1 = s2; //expected-error {{statement form is not allowed for '#pragma omp atomic read'}}
+  #pragma omp atomic read
+  a = b + 5; //expected-error {{statement form is not allowed for '#pragma omp atomic read'}}
+  #pragma omp atomic read seq_cst
+  a = a; //expected-error {{statement form is not allowed for '#pragma omp atomic read'}}
+  #pragma omp atomic read
+  ++a; //expected-error {{statement form is not allowed for '#pragma omp atomic read'}}
+
+  #pragma omp atomic write
+  a = b + 5;
+  #pragma omp atomic write seq_cst
+  a = b;
+  #pragma omp atomic write
+  s1 = s2; //expected-error {{statement form is not allowed for '#pragma omp atomic write'}}
+  #pragma omp atomic write seq_cst
+  a = a; //expected-error {{statement form is not allowed for '#pragma omp atomic write'}}
+  #pragma omp atomic write
+  ++a; //expected-error {{statement form is not allowed for '#pragma omp atomic write'}}
+
+  #pragma omp atomic
+  ++a;
+  #pragma omp atomic update
+  b++;
+  #pragma omp atomic seq_cst
+  a -= b;
+  #pragma omp atomic update seq_cst
+  a = b & a;
+  #pragma omp atomic update seq_cst
+  a += b & b;
+  #pragma omp atomic
+  s1 += s2; //expected-error {{statement form is not allowed for '#pragma omp atomic update'}}
+  #pragma omp atomic
+  a %= b; //expected-error {{statement form is not allowed for '#pragma omp atomic update'}}
+  #pragma omp atomic update
+  a = a & int(a); //expected-error {{statement form is not allowed for '#pragma omp atomic update'}}
+  #pragma omp atomic seq_cst
+  a = b && a; //expected-error {{statement form is not allowed for '#pragma omp atomic update'}}
+  #pragma omp atomic update seq_cst
+  {a--;} //expected-error {{expected expression statement for '#pragma omp atomic update'}}
+
+  #pragma omp atomic capture
+  b = ++a;
+  #pragma omp atomic capture
+  a = b++;
+  #pragma omp atomic capture seq_cst
+  c = a -= b;
+  #pragma omp atomic capture seq_cst
+  arr[1] = a = b & a;
+  #pragma omp atomic capture seq_cst
+  arr[1] = arr[1] &= b; //expected-error {{statement form is not allowed for '#pragma omp atomic capture'}}
+  #pragma omp atomic capture seq_cst
+  arr[1] = b &= arr[1]; //expected-error {{statement form is not allowed for '#pragma omp atomic capture'}}
+  #pragma omp atomic capture
+  s3 = s1 += s2; //expected-error {{statement form is not allowed for '#pragma omp atomic capture'}}
+  #pragma omp atomic capture
+  c = a %= b; //expected-error {{statement form is not allowed for '#pragma omp atomic capture'}}
+  #pragma omp atomic capture
+  c = a = a & int(a); //expected-error {{statement form is not allowed for '#pragma omp atomic capture'}}
+  #pragma omp atomic capture seq_cst
+  c = a = b && a; //expected-error {{statement form is not allowed for '#pragma omp atomic capture'}}
+  #pragma omp atomic capture
+  {c = b; ++b;}
+  #pragma omp atomic capture
+  {a = b++ + a; c = a;}
+  #pragma omp atomic capture seq_cst
+  {c = a; a -= b;}
+  #pragma omp atomic capture seq_cst
+  {a = b & a; c = a;}
+  #pragma omp atomic capture seq_cst
+  {a -= b + b; c = a;}
+  #pragma omp atomic capture
+  {s3 = s1; s1 += s2;} //expected-error {{statement form is not allowed for '#pragma omp atomic capture'}}
+  #pragma omp atomic capture
+  {a %= b; c = a;} //expected-error {{statement form is not allowed for '#pragma omp atomic capture'}}
+  #pragma omp atomic capture
+  {c = a; a = a & int(a); c = a;} //expected-error {{statement form is not allowed for '#pragma omp atomic capture'}}
+  #pragma omp atomic capture seq_cst
+  {a = b && a; c = a;} //expected-error {{statement form is not allowed for '#pragma omp atomic capture'}}
+  #pragma omp atomic capture seq_cst
+  {a = b & c; c = a;} //expected-error {{statement form is not allowed for '#pragma omp atomic capture'}}
+
+  return 0;
+}
+
+int foo() {
+  L1:
+    foo();
+  #pragma omp atomic
+  { // expected-error {{expected expression statement for '#pragma omp atomic update'}}
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+  #pragma omp atomic read
+  { // expected-error {{expected expression statement for '#pragma omp atomic read'}}
+    foo();
+    L2:
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/barrier_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/barrier_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/barrier_ast_print.cpp	2014-07-18 05:11:51.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/barrier_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
 // expected-no-diagnostics
 
 #ifndef HEADER
@@ -8,25 +8,13 @@
 
 void foo() {}
 
-template <class T>
-T tmain(T argc) {
-  static T a;
-#pragma omp barrier
-  return a + argc;
-}
-// CHECK:      static int a;
-// CHECK-NEXT: #pragma omp barrier
-// CHECK:      static char a;
-// CHECK-NEXT: #pragma omp barrier
-// CHECK:      static T a;
-// CHECK-NEXT: #pragma omp barrier
-
-int main(int argc, char **argv) {
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
   static int a;
 // CHECK: static int a;
 #pragma omp barrier
-  // CHECK-NEXT: #pragma omp barrier
-  return tmain(argc) + tmain(argv[0][0]) + a;
+// CHECK-NEXT: #pragma omp barrier
+  return (0);
 }
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/barrier_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/barrier_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/barrier_messages.cpp	2014-07-18 05:11:51.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/barrier_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,110 +1,95 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
-template <class T>
-T tmain(T argc) {
-#pragma omp barrier
-  ;
-#pragma omp barrier untied  // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp barrier'}}
-#pragma omp barrier unknown // expected-warning {{extra tokens at the end of '#pragma omp barrier' are ignored}}
-  if (argc)
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-    if (argc) {
-#pragma omp barrier
-    }
-  while (argc)
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-    while (argc) {
-#pragma omp barrier
-    }
-  do
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-    while (argc)
-      ;
-  do {
-#pragma omp barrier
-  } while (argc);
-  switch (argc)
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-    switch (argc)
-    case 1:
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-  switch (argc)
-  case 1: {
-#pragma omp barrier
-  }
-  switch (argc) {
-#pragma omp barrier
-  case 1:
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-    break;
-  default: {
-#pragma omp barrier
-  } break;
-  }
-  for (;;)
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-    for (;;) {
-#pragma omp barrier
-    }
-label:
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-label1 : {
-#pragma omp barrier
-}
-
-  return T();
-}
+int foo();
 
 int main(int argc, char **argv) {
-#pragma omp barrier
+  #pragma omp barrier
   ;
-#pragma omp barrier untied  // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp barrier'}}
-#pragma omp barrier unknown // expected-warning {{extra tokens at the end of '#pragma omp barrier' are ignored}}
+  #pragma omp barrier untied // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp barrier'}}
+  #pragma omp barrier unknown // expected-warning {{extra tokens at the end of '#pragma omp barrier' are ignored}}
   if (argc)
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-    if (argc) {
-#pragma omp barrier
-    }
+    #pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be immediate substatement}}
+  if (argc) {
+    #pragma omp barrier
+  }
   while (argc)
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-    while (argc) {
-#pragma omp barrier
-    }
+    #pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be immediate substatement}}
+  while (argc) {
+    #pragma omp barrier
+  }
   do
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-    while (argc)
-      ;
+    #pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be immediate substatement}}
+  while (argc);
   do {
-#pragma omp barrier
-  } while (argc);
+    #pragma omp barrier
+  }
+  while (argc);
+  switch (argc)
+    #pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be immediate substatement}}
   switch (argc)
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-    switch (argc)
     case 1:
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
+    #pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be immediate substatement}}
   switch (argc)
-  case 1: {
-#pragma omp barrier
-  }
+    case 1: {
+    #pragma omp barrier
+    }
   switch (argc) {
-#pragma omp barrier
+    #pragma omp barrier
   case 1:
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
+    #pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be immediate substatement}}
     break;
   default: {
-#pragma omp barrier
-  } break;
+    #pragma omp barrier
+    }
+    break;
   }
   for (;;)
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-    for (;;) {
-#pragma omp barrier
-    }
-label:
-#pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be an immediate substatement}}
-label1 : {
-#pragma omp barrier
-}
+    #pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be immediate substatement}}
+  for (;;) {
+    #pragma omp barrier
+  }
+  label:
+    #pragma omp barrier // expected-error {{'#pragma omp barrier' cannot be immediate substatement}}
+  label1: {
+    #pragma omp barrier
+  }
+  #pragma omp for
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp barrier // expected-error {{region cannot be closely nested inside a worksharing region}}
+  }
+  #pragma omp sections
+  {
+    foo();
+    #pragma omp barrier // expected-error {{region cannot be closely nested inside a worksharing region}}
+  }
+  #pragma omp single
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp barrier // expected-error {{region cannot be closely nested inside a worksharing region}}
+  }
+  #pragma omp task
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp barrier // expected-error {{region cannot be closely nested inside explicit task region}}
+  }
+  #pragma omp master
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp barrier // expected-error {{region cannot be closely nested inside a master region}}
+  }
+  #pragma omp critical
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp barrier // expected-error {{region cannot be closely nested inside a critical region}}
+  }
+  #pragma omp for ordered
+  for (int i = 0; i < 10; ++i)
+  #pragma omp ordered
+  {
+    foo();
+    #pragma omp barrier // expected-error {{region cannot be closely nested inside an ordered region}}
+  }
 
-  return tmain(argc);
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/cancel_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/cancel_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/cancel_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/cancel_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,49 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+int main (int argc, char **argv) {
+// CHECK: int main(int argc, char **argv) {
+#pragma omp parallel
+{
+#pragma omp cancel parallel
+}
+// CHECK: #pragma omp parallel
+// CHECK-NEXT: {
+// CHECK-NEXT: #pragma omp cancel parallel
+// CHECK-NEXT: }
+#pragma omp sections
+{
+#pragma omp cancel sections if (argc)
+}
+// CHECK-NEXT: #pragma omp sections
+// CHECK: {
+// CHECK: #pragma omp cancel sections if(
+// CHECK: }
+#pragma omp for
+for (int i = 0; i < argc; ++i) {
+#pragma omp cancel for
+}
+// CHECK: #pragma omp for
+// CHECK-NEXT: for (int i = 0; i < argc; ++i) {
+// CHECK-NEXT: #pragma omp cancel for
+// CHECK-NEXT: }
+#pragma omp taskgroup
+#pragma omp task
+{
+#pragma omp cancel taskgroup, if(argc + 1)
+}
+// CHECK: #pragma omp taskgroup
+// CHECK-NEXT: #pragma omp task
+// CHECK: {
+// CHECK: #pragma omp cancel taskgroup if(
+// CHECK: }
+// CHECK: return argc;
+  return argc;
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/cancel_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/cancel_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/cancel_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/cancel_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,83 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int main(int argc, char **argv) {
+  #pragma omp cancel // expected-error {{expected 'parallel', 'sections', 'for' or 'taskgroup' construct type}}
+  ;
+  #pragma omp cancel parallel untied // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp cancel'}}
+  #pragma omp cancel unknown // expected-error {{expected 'parallel', 'sections', 'for' or 'taskgroup' construct type}}
+  #pragma omp cancel sections ( // expected-warning {{extra tokens at the end of '#pragma omp cancel' are ignored}}
+  #pragma omp cancel for, ) // expected-warning {{extra tokens at the end of '#pragma omp cancel' are ignored}}
+  #pragma omp cancel taskgroup () // expected-warning {{extra tokens at the end of '#pragma omp cancel' are ignored}}
+  #pragma omp cancel parallel, if // expected-error {{expected expression}} expected-error {{expected '(' after 'if'}}
+  #pragma omp cancel sections if(argc,argv) // expected-warning {{extra tokens at the end of '#pragma omp cancel' are ignored}} expected-error {{expected ')'}} expected-note{{to match this '('}}
+  if (argc)
+    #pragma omp cancel for, if (argc // expected-error {{'#pragma omp cancel' cannot be immediate substatement}} expected-error {{expected ')'}} expected-note{{to match this '('}}
+  if (argc) {
+  #pragma omp taskgroup
+  #pragma omp task
+    #pragma omp parallel
+    {
+    #pragma omp cancel taskgroup // expected-error {{region cannot be closely nested inside a parallel region}}
+    }
+  }
+  #pragma omp parallel
+  #pragma omp taskgroup
+    {
+    #pragma omp cancel taskgroup // expected-error {{region cannot be closely nested inside a taskgroup region}}
+    }
+  #pragma omp parallel
+    {
+    #pragma omp cancel for // expected-error {{region cannot be closely nested inside a parallel region}}
+    }
+  #pragma omp task
+    {
+    #pragma omp cancel sections // expected-error {{region cannot be closely nested inside explicit task region}}
+    }
+  #pragma omp sections
+    {
+    #pragma omp cancel parallel // expected-error {{region cannot be closely nested inside a worksharing region}}
+    }
+  while (argc)
+    #pragma omp cancel for// expected-error {{'#pragma omp cancel' cannot be immediate substatement}}
+  while (argc) {
+    #pragma omp cancel sections
+  }
+  do
+    #pragma omp cancel parallel // expected-error {{'#pragma omp cancel' cannot be immediate substatement}}
+  while (argc);
+  do {
+    #pragma omp cancel taskgroup
+  }
+  while (argc);
+  switch (argc)
+    #pragma omp cancel parallel // expected-error {{'#pragma omp cancel' cannot be immediate substatement}}
+  switch (argc)
+    case 1:
+    #pragma omp cancel sections // expected-error {{'#pragma omp cancel' cannot be immediate substatement}}
+  switch (argc)
+    case 1: {
+    #pragma omp cancel for
+    }
+  switch (argc) {
+    #pragma omp cancel taskgroup
+  case 1:
+    #pragma omp cancel parallel // expected-error {{'#pragma omp cancel' cannot be immediate substatement}}
+    break;
+  default: {
+    #pragma omp cancel sections
+    }
+    break;
+  }
+  for (;;)
+    #pragma omp cancel for // expected-error {{'#pragma omp cancel' cannot be immediate substatement}}
+  for (;;) {
+    #pragma omp cancel taskgroup
+  }
+  label:
+    #pragma omp cancel parallel // expected-error {{'#pragma omp cancel' cannot be immediate substatement}}
+  label1: {
+    #pragma omp cancel sections
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/cancellation_point_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/cancellation_point_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/cancellation_point_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/cancellation_point_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,47 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+int main (int argc, char **argv) {
+// CHECK: int main(int argc, char **argv) {
+#pragma omp parallel
+{
+#pragma omp cancellation point parallel
+}
+// CHECK: #pragma omp parallel
+// CHECK-NEXT: {
+// CHECK-NEXT: #pragma omp cancellation point parallel
+// CHECK-NEXT: }
+#pragma omp sections
+{
+#pragma omp cancellation point sections
+}
+// CHECK-NEXT: #pragma omp sections
+// CHECK: {
+// CHECK: #pragma omp cancellation point sections
+// CHECK: }
+#pragma omp for
+for (int i = 0; i < argc; ++i) {
+#pragma omp cancellation point for
+}
+// CHECK: #pragma omp for
+// CHECK-NEXT: for (int i = 0; i < argc; ++i) {
+// CHECK-NEXT: #pragma omp cancellation point for
+// CHECK-NEXT: }
+#pragma omp task
+{
+#pragma omp cancellation point taskgroup
+}
+// CHECK: #pragma omp task
+// CHECK: {
+// CHECK: #pragma omp cancellation point taskgroup
+// CHECK: }
+// CHECK: return argc;
+  return argc;
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/cancellation_point_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/cancellation_point_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/cancellation_point_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/cancellation_point_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,83 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int main(int argc, char **argv) {
+  #pragma omp cancellation // expected-error {{expected an OpenMP directive}}
+  #pragma omp cancellation point // expected-error {{expected 'parallel', 'sections', 'for' or 'taskgroup' construct type}}
+  ;
+  #pragma omp cancellation point parallel untied // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp cancellation point'}}
+  #pragma omp cancellation point unknown // expected-error {{expected 'parallel', 'sections', 'for' or 'taskgroup' construct type}}
+  #pragma omp cancellation point sections ( // expected-warning {{extra tokens at the end of '#pragma omp cancellation point' are ignored}}
+  #pragma omp cancellation point for, ) // expected-warning {{extra tokens at the end of '#pragma omp cancellation point' are ignored}}
+  #pragma omp cancellation point taskgroup () // expected-warning {{extra tokens at the end of '#pragma omp cancellation point' are ignored}}
+  #pragma omp cancellation point parallel, if // expected-warning {{extra tokens at the end of '#pragma omp cancellation point' are ignored}}
+  if (argc)
+    #pragma omp cancellation point for // expected-error {{'#pragma omp cancellation point' cannot be immediate substatement}}
+  if (argc) {
+  #pragma omp taskgroup
+  #pragma omp task
+    #pragma omp parallel
+    {
+    #pragma omp cancellation point taskgroup // expected-error {{region cannot be closely nested inside a parallel region}}
+    }
+  }
+  #pragma omp parallel
+  #pragma omp taskgroup
+    {
+    #pragma omp cancellation point taskgroup // expected-error {{region cannot be closely nested inside a taskgroup region}}
+    }
+  #pragma omp parallel
+    {
+    #pragma omp cancellation point for // expected-error {{region cannot be closely nested inside a parallel region}}
+    }
+  #pragma omp task
+    {
+    #pragma omp cancellation point sections // expected-error {{region cannot be closely nested inside explicit task region}}
+    }
+  #pragma omp sections
+    {
+    #pragma omp cancellation point parallel // expected-error {{region cannot be closely nested inside a worksharing region}}
+    }
+  while (argc)
+    #pragma omp cancellation point for// expected-error {{'#pragma omp cancellation point' cannot be immediate substatement}}
+  while (argc) {
+    #pragma omp cancellation point sections
+  }
+  do
+    #pragma omp cancellation point parallel // expected-error {{'#pragma omp cancellation point' cannot be immediate substatement}}
+  while (argc);
+  do {
+    #pragma omp cancellation point taskgroup
+  }
+  while (argc);
+  switch (argc)
+    #pragma omp cancellation point parallel // expected-error {{'#pragma omp cancellation point' cannot be immediate substatement}}
+  switch (argc)
+    case 1:
+    #pragma omp cancellation point sections // expected-error {{'#pragma omp cancellation point' cannot be immediate substatement}}
+  switch (argc)
+    case 1: {
+    #pragma omp cancellation point for
+    }
+  switch (argc) {
+    #pragma omp cancellation point taskgroup
+  case 1:
+    #pragma omp cancellation point parallel // expected-error {{'#pragma omp cancellation point' cannot be immediate substatement}}
+    break;
+  default: {
+    #pragma omp cancellation point sections
+    }
+    break;
+  }
+  for (;;)
+    #pragma omp cancellation point for // expected-error {{'#pragma omp cancellation point' cannot be immediate substatement}}
+  for (;;) {
+    #pragma omp cancellation point taskgroup
+  }
+  label:
+    #pragma omp cancellation point parallel // expected-error {{'#pragma omp cancellation point' cannot be immediate substatement}}
+  label1: {
+    #pragma omp cancellation point sections
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/critical_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/critical_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/critical_ast_print.cpp	2014-07-21 05:42:05.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/critical_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
 // expected-no-diagnostics
 
 #ifndef HEADER
@@ -12,18 +12,11 @@
   int b = argc, c, d, e, f, g;
   static int a;
 // CHECK: static int a;
-#pragma omp critical
+#pragma omp critical (name)
   a=2;
-// CHECK-NEXT: #pragma omp critical
+// CHECK-NEXT: #pragma omp critical (name)
 // CHECK-NEXT: a = 2;
-// CHECK-NEXT: ++a;
-  ++a;
-#pragma omp critical  (the_name)
-  foo();
-// CHECK-NEXT: #pragma omp critical (the_name)
-// CHECK-NEXT: foo();
-// CHECK-NEXT: return 0;
-  return 0;
+  return (0);
 }
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/critical_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/critical_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/critical_messages.cpp	2014-07-21 05:42:05.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/critical_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 int foo();
 
@@ -15,7 +15,7 @@
   {
     #pragma omp critical
   } // expected-error {{expected statement}}
-  #pragma omp critical (name) // expected-note {{previous 'critical' region starts here}}
+  #pragma omp critical (name)
   #pragma omp critical
   for (int i = 0; i < 10; ++i) {
     foo();
@@ -23,7 +23,7 @@
     #pragma omp for
     for (int j = 0; j < 10; j++) {
       foo();
-      #pragma omp critical(name) // expected-error {{cannot nest 'critical' regions having the same name 'name'}}
+      #pragma omp critical(name) // expected-error {{region cannot be nested inside a critical region with name 'name'}}
       foo();
     }
   }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/declare_reduction_ast_print.c cfe-3.5.0.src.omp/test/OpenMP/declare_reduction_ast_print.c
--- cfe-3.5.0.src/test/OpenMP/declare_reduction_ast_print.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/declare_reduction_ast_print.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,25 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+#pragma omp declare reduction (+ : int, char: omp_out *= omp_in)
+// CHECK: #pragma omp declare reduction (+ : int : omp_out *= omp_in)
+// CHECK-NEXT: #pragma omp declare reduction (+ : char : omp_out *= omp_in)
+
+#pragma omp declare reduction (fun : float : omp_out += omp_in) initializer (omp_priv=omp_orig + 15)
+// CHECK: #pragma omp declare reduction (fun : float : omp_out += omp_in) initializer(omp_priv = omp_orig + 15)
+
+struct SSS {
+  int field;
+};
+
+void init(struct SSS *priv, struct SSS orig);
+
+#pragma omp declare reduction (fun : struct SSS : omp_out = omp_in) initializer (init(&omp_priv, omp_orig))
+// CHECK: #pragma omp declare reduction (fun : struct SSS : omp_out = omp_in) initializer(init(&omp_priv, omp_orig))
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/declare_reduction_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/declare_reduction_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/declare_reduction_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/declare_reduction_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,43 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+#pragma omp declare reduction (+ : int, char: omp_out *= omp_in)
+// CHECK: #pragma omp declare reduction (+ : int : omp_out *= omp_in)
+// CHECK-NEXT: #pragma omp declare reduction (+ : char : omp_out *= omp_in)
+
+// CHECK: #pragma omp declare reduction (fun : int : omp_out += omp_in) initializer(omp_priv omp_orig + 15)
+
+template <class T>
+class SSS {
+public:
+#pragma omp declare reduction (fun : T : omp_out += omp_in) initializer (omp_priv omp_orig + 15)
+// CHECK: #pragma omp declare reduction (fun : T : omp_out += omp_in) initializer(omp_priv omp_orig + 15)
+};
+
+SSS<int> d;
+
+void init(SSS<int> &lhs, SSS<int> rhs);
+
+#pragma omp declare reduction (fun : SSS<int> : omp_out = omp_in) initializer (init(omp_priv, omp_orig))
+// CHECK: #pragma omp declare reduction (fun : SSS<int> : omp_out = omp_in) initializer(init(omp_priv, omp_orig))
+
+int main() {
+  int i = 0;
+  SSS<int> sss;
+  #pragma omp parallel reduction(SSS<int>::fun : i)
+// CHECK: #pragma omp parallel reduction(SSS<int>::fun: i)
+  {
+    i += 1;
+  }
+  #pragma omp parallel reduction(::fun:sss)
+// CHECK: #pragma omp parallel reduction(::fun: sss)
+  {
+  }
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/declare_reduction_messages.c cfe-3.5.0.src.omp/test/OpenMP/declare_reduction_messages.c
--- cfe-3.5.0.src/test/OpenMP/declare_reduction_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/declare_reduction_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,50 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int temp;
+
+#pragma omp declare reduction // expected-error {{expected '(' after 'declare reduction'}}
+#pragma omp declare reduction { // expected-error {{expected '(' after 'declare reduction'}} expected-error {{expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&' and '||'}}
+#pragma omp declare reduction ( // expected-error {{expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&' and '||'}}
+#pragma omp declare reduction (# // expected-error {{expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&' and '||'}}
+#pragma omp declare reduction (/ // expected-error {{expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&' and '||'}}
+#pragma omp declare reduction (+ // expected-error {{expected ':'}}
+#pragma omp declare reduction (for // expected-error {{expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&' and '||'}}
+#pragma omp declare reduction (if : // expected-error {{expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&' and '||'}}
+#pragma omp declare reduction (oper : // expected-error {{expected a type}}
+#pragma omp declare reduction (oper ; // expected-error {{expected ':'}} expected-error {{expected a type}}
+#pragma omp declare reduction (fun : int // expected-error {{expected ':'}} expected-error {{expected expression}}
+#pragma omp declare reduction (+ : const int : // expected-error {{a type name cannot be qualified with 'const', 'volatile' or 'restrict'}}
+#pragma omp declare reduction (- : volatile int : // expected-error {{a type name cannot be qualified with 'const', 'volatile' or 'restrict'}}
+#pragma omp declare reduction (* : int ; // expected-error {{expected ','}} expected-error {{expected a type}}
+#pragma omp declare reduction (& : double char : // expected-error {{cannot combine with previous 'double' declaration specifier}} expected-error {{expected expression}}
+#pragma omp declare reduction (^ : double, char, : // expected-error {{expected a type}} expected-error {{expected expression}}
+#pragma omp declare reduction (&& : int, S : // expected-error {{unknown type name 'S'}} expected-error {{expected expression}}
+#pragma omp declare reduction (|| : int, double : temp += omp_in) // expected-error 2 {{variable 'temp' is not allowed in combiner expression for '#pragma omp declare reduction', only 'omp_in' or 'omp_out' are allowed}}
+#pragma omp declare reduction (| : char, float : omp_out += temp ) // expected-error 2 {{variable 'temp' is not allowed in combiner expression for '#pragma omp declare reduction', only 'omp_in' or 'omp_out' are allowed}}
+#pragma omp declare reduction (fun : long : omp_out += omp_in ) { // expected-warning {{extra tokens at the end of '#pragma omp declare reduction' are ignored}} expected-note {{previous declaration is here}}
+#pragma omp declare reduction (fun : unsigned : omp_out += temp)) // expected-error {{variable 'temp' is not allowed in combiner expression for '#pragma omp declare reduction', only 'omp_in' or 'omp_out' are allowed}}
+#pragma omp declare reduction (fun : long (*)(void): omp_out += omp_in) // expected-error {{a type name cannot be a function type}}
+#pragma omp declare reduction (fun : long [3]: omp_out += omp_in) // expected-error {{a type name cannot be an array type}}
+#pragma omp declare reduction (fun23 : long, int, long: omp_out += omp_in) // expected-error {{previous declaration with type 'long' is found}} expected-note {{previous declaration is here}}
+
+#pragma omp declare reduction (fun : long : omp_out += omp_in ) // expected-error {{previous declaration with type 'long' is found}}
+#pragma omp declare reduction (fun1 : long : omp_out += omp_in ) initializer // expected-error {{expected '(' after 'initializer'}} expected-error {{expected expression}}
+#pragma omp declare reduction (fun2 : long : omp_out += omp_in ) initializer { // expected-error {{expected '(' after 'initializer'}} expected-error {{expected expression}}
+#pragma omp declare reduction (fun3 : long : omp_out += omp_in ) initializer [ // expected-error {{expected '(' after 'initializer'}} expected-error {{expected expression}}
+#pragma omp declare reduction (fun4 : long : omp_out += omp_in ) initializer() // expected-error {{expected expression}}
+#pragma omp declare reduction (fun5 : long : omp_out += omp_in ) initializer(temp) // expected-error {{variable 'temp' is not allowed in initializer expression for '#pragma omp declare reduction', only 'omp_priv' or 'omp_orig' are allowed}}
+#pragma omp declare reduction (fun6 : long : omp_out += omp_in ) initializer(omp_orig // expected-error {{expected function call}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+#pragma omp declare reduction (fun7 : long : omp_out += omp_in ) initializer(omp_priv 12) // expected-error {{expected '=' after 'omp_priv'}}
+#pragma omp declare reduction (fun8 : long : omp_out += omp_in ) initializer(omp_priv=23) // expected-note {{previous declaration is here}}
+#pragma omp declare reduction (fun8 : long : omp_out += omp_in ) initializer(omp_priv=23)) // expected-warning {{extra tokens at the end of '#pragma omp declare reduction' are ignored}} expected-error {{previous declaration with type 'long' is found}} 
+#pragma omp declare reduction (fun9 : long : omp_out += omp_in ) initializer(omp_priv=) // expected-error {{expected expression}}
+
+int fun(int arg) {
+#pragma omp declare reduction (red : int : omp_out++)
+  {
+#pragma omp declare reduction (red : int : omp_out++) // expected-note {{previous declaration is here}}
+#pragma omp declare reduction (red : int : omp_out++) // expected-error {{previous declaration with type 'int' is found}}
+  }
+  return arg;
+}
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/declare_reduction_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/declare_reduction_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/declare_reduction_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/declare_reduction_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,82 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int temp;
+
+#pragma omp declare reduction // expected-error {{expected '(' after 'declare reduction'}}
+#pragma omp declare reduction { // expected-error {{expected '(' after 'declare reduction'}} expected-error {{expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&' and '||'}}
+#pragma omp declare reduction ( // expected-error {{expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&' and '||'}}
+#pragma omp declare reduction (# // expected-error {{expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&' and '||'}}
+#pragma omp declare reduction (/ // expected-error {{expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&' and '||'}}
+#pragma omp declare reduction (+ // expected-error {{expected ':'}}
+#pragma omp declare reduction (operator // expected-error {{expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&' and '||'}}
+#pragma omp declare reduction (operator : // expected-error {{expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&' and '||'}}
+#pragma omp declare reduction (oper : // expected-error {{expected a type}}
+#pragma omp declare reduction (oper ; // expected-error {{expected ':'}} expected-error {{expected a type}}
+#pragma omp declare reduction (fun : int // expected-error {{expected ':'}} expected-error {{expected expression}}
+#pragma omp declare reduction (+ : const int : // expected-error {{a type name cannot be qualified with 'const', 'volatile' or 'restrict'}}
+#pragma omp declare reduction (- : volatile int : // expected-error {{a type name cannot be qualified with 'const', 'volatile' or 'restrict'}}
+#pragma omp declare reduction (* : int ; // expected-error {{expected ','}} expected-error {{expected a type}}
+#pragma omp declare reduction (& : double char : // expected-error {{cannot combine with previous 'double' declaration specifier}} expected-error {{expected expression}}
+#pragma omp declare reduction (^ : double, char, : // expected-error {{expected a type}} expected-error {{expected expression}}
+#pragma omp declare reduction (&& : int, S : // expected-error {{unknown type name 'S'}} expected-error {{expected expression}}
+#pragma omp declare reduction (|| : int, double : temp += omp_in) // expected-error 2 {{variable 'temp' is not allowed in combiner expression for '#pragma omp declare reduction', only 'omp_in' or 'omp_out' are allowed}}
+#pragma omp declare reduction (| : char, float : omp_out += ::temp ) // expected-error 2 {{variable 'temp' is not allowed in combiner expression for '#pragma omp declare reduction', only 'omp_in' or 'omp_out' are allowed}}
+#pragma omp declare reduction (fun : long : omp_out += omp_in ) { // expected-warning {{extra tokens at the end of '#pragma omp declare reduction' are ignored}} expected-note {{previous declaration is here}}
+#pragma omp declare reduction (fun : unsigned : omp_out += ::temp)) // expected-error {{variable 'temp' is not allowed in combiner expression for '#pragma omp declare reduction', only 'omp_in' or 'omp_out' are allowed}}
+#pragma omp declare reduction (fun : long &: omp_out += omp_in) // expected-error {{a type name cannot be a reference type}}
+#pragma omp declare reduction (fun : long (*)(void): omp_out += omp_in) // expected-error {{a type name cannot be a function type}}
+#pragma omp declare reduction (fun : long [3]: omp_out += omp_in) // expected-error {{a type name cannot be an array type}}
+#pragma omp declare reduction (fun23 : long, int, long: omp_out += omp_in) // expected-error {{previous declaration with type 'long' is found}} expected-note {{previous declaration is here}}
+
+template <class T>
+class Class1 {
+#pragma omp declare reduction (fun : T : temp) // expected-error {{variable 'temp' is not allowed in combiner expression for '#pragma omp declare reduction', only 'omp_in' or 'omp_out' are allowed}}
+#pragma omp declare reduction (fun1 : T : omp_out++) // expected-note {{previous declaration is here}} expected-error {{a type name cannot be a reference type}}
+#pragma omp declare reduction (fun1 : T : omp_out += omp_in) // expected-error {{previous declaration with type 'T' is found}}
+#pragma omp declare reduction (fun2 : T, T : omp_out++) // expected-error {{previous declaration with type 'T' is found}} expected-note {{previous declaration is here}}
+};
+
+Class1<char &> e; // expected-note {{in instantiation of template class 'Class1<char &>' requested here}}
+
+template <class T>
+class Class2 {
+#pragma omp declare reduction (fun : T : omp_out += omp_in ) // expected-note {{implicitly declared private here}}
+};
+
+#pragma omp declare reduction (fun : long : omp_out += omp_in ) // expected-error {{previous declaration with type 'long' is found}}
+#pragma omp declare reduction (fun1 : long : omp_out += omp_in ) initializer // expected-error {{expected '(' after 'initializer'}} expected-error {{expected expression}}
+#pragma omp declare reduction (fun2 : long : omp_out += omp_in ) initializer { // expected-error {{expected '(' after 'initializer'}} expected-error {{expected expression}}
+#pragma omp declare reduction (fun3 : long : omp_out += omp_in ) initializer [ // expected-error {{expected '(' after 'initializer'}} expected-error {{expected expression}}
+#pragma omp declare reduction (fun4 : long : omp_out += omp_in ) initializer() // expected-error {{expected expression}}
+#pragma omp declare reduction (fun5 : long : omp_out += omp_in ) initializer(temp) // expected-error {{variable 'temp' is not allowed in initializer expression for '#pragma omp declare reduction', only 'omp_priv' or 'omp_orig' are allowed}}
+#pragma omp declare reduction (fun6 : long : omp_out += omp_in ) initializer(omp_orig // expected-error {{expected function call}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+#pragma omp declare reduction (fun7 : long : omp_out += omp_in ) initializer(omp_priv Class1<int>())
+#pragma omp declare reduction (fun7 : long : omp_out += omp_in ) initializer(omp_priv Class2<int>()) // expected-error {{no viable conversion from 'Class2<int>' to 'long'}}
+#pragma omp declare reduction (fun8 : long : omp_out += omp_in ) initializer(omp_priv 23) // expected-note {{previous declaration is here}}
+#pragma omp declare reduction (fun8 : long : omp_out += omp_in ) initializer(omp_priv 23)) // expected-warning {{extra tokens at the end of '#pragma omp declare reduction' are ignored}} expected-error {{previous declaration with type 'long' is found}} 
+#pragma omp declare reduction (fun9 : long : omp_out += omp_in ) initializer(omp_priv=23) // expected-error {{expected expression}}
+
+template <typename T>
+T fun(T arg) {
+#pragma omp declare reduction (red : T : omp_out++)
+  {
+#pragma omp declare reduction (red : T : omp_out++) // expected-note {{previous declaration is here}}
+#pragma omp declare reduction (red : T : omp_out++) // expected-error {{previous declaration with type 'T' is found}}
+  }
+  return arg;
+}
+
+int main() {
+  Class1<int> c1;
+  int i;
+  #pragma omp parallel reduction (::fun : c1) // expected-error {{no member named 'fun' in the global namespace}}
+  {
+  }
+  #pragma omp parallel reduction (::Class1<int>::fun : c1) // expected-error {{no member named 'fun' in 'Class1<int>'}}
+  {
+  }
+  #pragma omp parallel reduction (::Class2<int>::fun : i) // expected-error {{'fun' is a private member of 'Class2<int>'}}
+  {
+  }
+  return fun(15);
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/declare_simd_ast_print.c cfe-3.5.0.src.omp/test/OpenMP/declare_simd_ast_print.c
--- cfe-3.5.0.src/test/OpenMP/declare_simd_ast_print.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/declare_simd_ast_print.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,29 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+#pragma omp declare simd
+void add_1(float *d, float *s1, float *s2);
+
+// CHECK: #pragma omp declare simd
+// CHECK-NEXT: void add_1(float *d, float *s1, float *s2)
+
+#define MY_ALIGN 2*8
+
+#pragma omp declare simd inbranch uniform(hp) aligned(hp, hq:MY_ALIGN) linear(hq, lin:8)
+#pragma omp declare simd notinbranch linear(hp, hq:MY_ALIGN) aligned(hq, lin:8) simdlen(4)
+void h(char *hp, char *hp2, char *hq, char *lin)
+{
+}
+
+// CHECK: #pragma omp declare simd inbranch uniform(hp) aligned(hp,hq: 16) linear(hq,lin: 8)
+// CHECK-NEXT: #pragma omp declare simd notinbranch linear(hp,hq: 16) aligned(hq,lin: 8) simdlen(4)
+// CHECK-NEXT: void h(char *hp, char *hp2, char *hq, char *lin) {
+// CHECK-NEXT: }
+
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/declare_simd_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/declare_simd_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/declare_simd_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/declare_simd_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,88 @@
+// RUN: %clang_cc1 -verify -fopenmp -x c++ -std=c++11 -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+#pragma omp declare simd uniform(d)
+void add_1(float *d);
+
+// CHECK: #pragma omp declare simd uniform(d)
+// CHECK-NEXT: void add_1(float *d);
+//
+
+#define MY_ALIGN 2*8
+
+#pragma omp declare simd uniform(hp)
+#pragma omp declare simd simdlen(8) linear(hq, lin: MY_ALIGN)
+template <class C> void h(C *hp, C *hp2, C *hq, C *lin) {
+}
+
+// CHECK: #pragma omp declare simd uniform(hp)
+// CHECK-NEXT: #pragma omp declare simd simdlen(8) linear(hq,lin: 16)
+// CHECK: template <class C> void h(C *hp, C *hp2, C *hq, C *lin) {
+// CHECK-NEXT: }
+//
+
+
+// Instatiate with <C=int> explicitly.
+// Pragmas need to be same, otherwise standard says that's undefined behavior.
+#pragma omp declare simd uniform(hp)
+#pragma omp declare simd simdlen(8) linear(hq, lin: MY_ALIGN)
+template <>
+void h(int *hp, int *hp2, int *hq, int *lin)
+{
+  // Instatiate with <C=float> implicitly.
+  // This is special case where the directive is stored by Sema and is
+  // generated together with the (pending) function instatiation.
+  h((float*) hp, (float*) hp2, (float*) hq, (float*) lin);
+}
+
+// CHECK: #pragma omp declare simd uniform(hp)
+// CHECK-NEXT: #pragma omp declare simd simdlen(8) linear(hq,lin: 16)
+// CHECK: void h(int *hp, int *hp2, int *hq, int *lin) {
+// CHECK-NEXT: h((float *)hp, (float *)hp2, (float *)hq, (float *)lin);
+// CHECK-NEXT: }
+//
+
+class VV {
+  #pragma omp declare simd
+  int add(int a, int b) { return a + b; }
+
+  #pragma omp declare simd aligned(a,b : 32)
+  float addpf(float *a, float *b) { return *a + *b; }
+};
+
+template <int X>
+class TVV {
+// CHECK: template <int X> class TVV {
+  #pragma omp declare simd
+  int tadd(int a, int b) { return a + b; }
+
+// CHECK: #pragma omp declare simd
+// CHECK-NEXT: int tadd(int a, int b) {
+// CHECK-NEXT: return a + b;
+// CHECK-NEXT: }
+
+
+  #pragma omp declare simd aligned(a,b : X)
+  float taddpf(float *a, float *b) { return *a + *b; }
+
+// CHECK: #pragma omp declare simd aligned(a,b: X)
+// CHECK-NEXT: float taddpf(float *a, float *b) {
+// CHECK-NEXT: return *a + *b;
+// CHECK-NEXT: }
+};
+// CHECK: };
+
+// CHECK-NEXT: TVV<16> t16;
+TVV<16> t16;
+
+void f() {
+  float a = 1.0f, b = 2.0f;
+  float r = t16.taddpf(&a, &b);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/declare_simd_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/declare_simd_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/declare_simd_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/declare_simd_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,70 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -x c++ -std=c++11 %s
+
+// expected-error@+3 {{expected '(' after 'uniform'}}
+// expected-error@+2 {{expected unqualified-id}}
+// expected-error@+1 {{expected identifier}}
+#pragma omp declare simd uniform 
+
+// expected-error@+1 {{expected '(' after 'uniform'}}
+#pragma omp declare simd uniform d
+
+// expected-error@+3 {{expected '(' after 'uniform'}}
+// expected-error@+2 {{expected unqualified-id}}
+// expected-error@+1 {{expected identifier}}
+#pragma omp declare simd uniform{d}
+
+// expected-error@+1 {{expression is not a positive integer value}}
+#pragma omp declare simd simdlen(-32)
+
+void add_1(float *d);
+// expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}}
+#pragma omp declare simd aligned(a : 32)
+#pragma omp declare simd aligned(b : 32) // ok: b is array
+#pragma omp declare simd aligned(c : 32) // ok: c is pointer
+// expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}}
+#pragma omp declare simd aligned(d : 32)
+#pragma omp declare simd aligned(e : 32) // ok: reference to pointer
+// expected-error@+1 {{expression is not a positive integer value}}
+#pragma omp declare simd aligned(f : 0)
+#pragma omp declare simd linear(f : 4) // ok
+#pragma omp declare simd linear(f : 8) // ok : different step in other simd variant
+// expected-error@+2 {{each argument may be in at most one uniform or linear clause}}
+// expected-note@+1 {{previously referenced here}}
+#pragma omp declare simd linear(f : 2) linear(f : 2)
+// expected-error@+2 {{each argument may be in at most one aligned clause}}
+// expected-note@+1 {{previously referenced here}}
+#pragma omp declare simd aligned(f : 2) aligned(f : 2)
+#pragma omp declare simd inbranch inbranch inbranch inbranch // ok
+#pragma omp declare simd notinbranch notinbranch notinbranch notinbranch // ok
+// expected-error@+2 {{declare simd variant cannot be inbranch and notinbranch at the same time}}
+// expected-note@+1 {{previously specified here}}
+#pragma omp declare simd inbranch notinbranch
+// expected-error@+2 {{declare simd variant cannot be inbranch and notinbranch at the same time}}
+// expected-note@+1 {{previously specified here}}
+#pragma omp declare simd notinbranch inbranch
+// expected-error@+2 2 {{declare simd variant cannot be inbranch and notinbranch at the same time}}
+// expected-note@+1 2 {{previously specified here}}
+#pragma omp declare simd inbranch notinbranch notinbranch
+float add_2(float a, float b[], float *c, float &d, float *&e, float **f);
+
+
+#define MY_ALIGN -2*8
+
+#pragma omp declare simd uniform(hp)
+// expected-error@+1 {{expression is not a positive integer value}}
+#pragma omp declare simd simdlen(8) linear(hq, lin: MY_ALIGN)
+template <class C>
+void h(C *hp, C *hp2, C *hq, C *lin)
+{
+}
+
+#pragma omp declare simd uniform(hp)
+// expected-error@+1 {{cannot find the function argument with the name requested in the openmp clause}}
+#pragma omp declare simd simdlen(8) linear(hq, lin, lin2: -MY_ALIGN)
+template <>
+void h(int *hp, int *hp2, int *hq, int *lin)
+{
+  h((float*) hp, (float*) hp2, (float*) hq, (float*) lin);
+}
+
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/declare_simd_metadata.c cfe-3.5.0.src.omp/test/OpenMP/declare_simd_metadata.c
--- cfe-3.5.0.src/test/OpenMP/declare_simd_metadata.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/declare_simd_metadata.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,49 @@
+// RUN: %clang_cc1 -fopenmp -emit-llvm %s -o - | FileCheck %s
+
+#ifdef NOOMP
+__attribute__((vector(uniform(x), linear(y:4), linear(z:1))))
+#else
+#pragma omp declare simd uniform(x) linear(y:4) linear(z)
+#endif
+void g(int x, int y, int z)
+{
+}
+
+// Metadata for g:
+// CHECK: [[GN:![0-9]+]] = metadata !{metadata !"arg_name", metadata !"x", metadata !"y", metadata !"z"}
+// CHECK: [[GS:![0-9]+]] = metadata !{metadata !"arg_step", i32 0, i32 4, i32 1}
+// CHECK: [[GT:![0-9]+]] = metadata !{metadata !"vec_length", i32 undef, i32 {{[0-9]+}}}
+
+#define MY_ALIGN 16
+
+#ifdef NOOMP
+__attribute__((vector(uniform(hp))))
+#else
+#pragma omp declare simd uniform(hp) aligned(hp, hq:MY_ALIGN)
+#endif
+void h(char *hp, char *hp2, char *hq)
+{
+}
+
+// Metadata for h:
+// CHECK: metadata !{metadata !"arg_name", metadata !"hp", metadata !"hp2", metadata !"hq"}
+// CHECK: [[HS:![0-9]+]] = metadata !{metadata !"arg_step", i32 0, i32 undef, i32 undef}
+// CHECK: [[HA:![0-9]+]] = metadata !{metadata !"arg_alig", i32 16, i32 undef, i32 16}
+// CHECK: metadata !{metadata !"vec_length", i8* undef, i32 {{[0-9]+}}}
+
+
+#ifdef NOOMP
+__attribute__((vector(mask, vectorlength(64))))
+#else
+#pragma omp declare simd inbranch simdlen(64)
+#endif
+void k(char (*kf)(int), int a)
+{
+  kf(a);
+}
+
+// Metadata for k:
+// CHECK: metadata !{metadata !"arg_name", metadata !"kf", metadata !"a"}
+// CHECK: metadata !{metadata !"arg_step", i32 undef, i32 undef}
+// CHECK: metadata !{metadata !"vec_length", i8 (i32)* undef, i32 64}
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/declare_simd_metadata.cpp cfe-3.5.0.src.omp/test/OpenMP/declare_simd_metadata.cpp
--- cfe-3.5.0.src/test/OpenMP/declare_simd_metadata.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/declare_simd_metadata.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,83 @@
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-llvm %s -o - | FileCheck %s
+
+#pragma omp declare simd uniform(x) linear(y:4)
+void g(int x, int y)
+{
+}
+
+// Tests for global-function-template with 'omp declare simd'
+
+// Metadata for g:
+// CHECK: [[G1:![0-9]+]] = metadata !{void (i32, i32)* @_Z1gii[[GMETA:(, metadata ![0-9]+)+]]}
+// CHECK: [[GN:![0-9]+]] = metadata !{metadata !"arg_name", metadata !"x", metadata !"y"}
+// CHECK: [[GS:![0-9]+]] = metadata !{metadata !"arg_step", i32 0, i32 4}
+// CHECK: [[GT:![0-9]+]] = metadata !{metadata !"vec_length", i32 undef, i32 {{[0-9]+}}}
+
+#define MY_ALIGN 2*9
+
+#pragma omp declare simd uniform(hp)
+#pragma omp declare simd simdlen(8) linear(hq, lin: MY_ALIGN)
+template <class C>
+void h(C *hp, C *hp2, C *hq, C *lin)
+{
+}
+
+// Instatiate with <C=int> explicitly.
+// Pragmas need to be same, otherwise standard says that's undefined behavior.
+#pragma omp declare simd uniform(hp)
+#pragma omp declare simd simdlen(8) linear(hq, lin: MY_ALIGN)
+template <>
+void h(int *hp, int *hp2, int *hq, int *lin)
+{
+  // Instatiate with <C=float> implicitly.
+  // This is special case where the directive is stored by Sema and is
+  // generated together with the (pending) function instatiation.
+  h((float*) hp, (float*) hp2, (float*) hq, (float*) lin);
+}
+
+// For the function template h we have 2 template instantiations
+// (one implicit with <C=float> and one explicit with <C=int>) and
+// each of them should have 2 simd-variants, as specified by the pragma.
+// CHECK: [[HI1:![0-9]+]] = metadata !{void (i32*, i32*, i32*, i32*)* @_Z1hIiEvPT_S1_S1_S1_[[HI1META:(, metadata ![0-9]+)+]]}
+// CHECK: [[HI2:![0-9]+]] = metadata !{void (i32*, i32*, i32*, i32*)* @_Z1hIiEvPT_S1_S1_S1_[[HI2META:(, metadata ![0-9]+)+]]}
+// CHECK: [[HF1:![0-9]+]] = metadata !{void (float*, float*, float*, float*)* @_Z1hIfEvPT_S1_S1_S1_[[HF1META:(, metadata ![0-9]+)+]]}
+// CHECK: [[HF2:![0-9]+]] = metadata !{void (float*, float*, float*, float*)* @_Z1hIfEvPT_S1_S1_S1_[[HF2META:(, metadata ![0-9]+)+]]}
+
+
+// Tests for special cases for class method and for class-template method
+
+class VV {
+  #pragma omp declare simd
+  int add(int a, int b) { return a + b; }
+
+  #pragma omp declare simd aligned(a,b : 32)
+  float addpf(float *a, float *b) { return *a + *b; }
+};
+
+
+template <int X>
+class TVV {
+  #pragma omp declare simd
+  int tadd(int a, int b) { return a + b; }
+
+  #pragma omp declare simd aligned(a,b : X)
+  float taddpf(float *a, float *b) { return *a + *b; }
+};
+
+TVV<16> t16;
+VV vv;
+
+// The following function instantiates the class and template
+void f() {
+  float a = 1.0f, b = 2.0f;
+  float r = t16.taddpf(&a, &b);
+  float q = vv.addpf(&a, &b);
+}
+
+// Metadata for the class
+// CHECK: [[C01:![0-9]+]] = metadata !{float (%class.VV*, float*, float*)* @_ZN2VV5addpfEPfS0_[[C01META:(, metadata ![0-9]+)+]]}
+//
+// Metadata for the class-template
+// CHECK: [[CT1:![0-9]+]] = metadata !{float (%class.TVV*, float*, float*)* @_ZN3TVVILi16EE6taddpfEPfS1_[[CT1META:(, metadata ![0-9]+)+]]}
+
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/declare_target_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/declare_target_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/declare_target_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/declare_target_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,23 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+#pragma omp declare target
+// CHECK: #pragma omp declare target
+
+void foo() {}
+// CHECK-NEXT: void foo()
+
+#pragma omp end declare target
+// CHECK: #pragma omp end declare target
+
+int main (int argc, char **argv) {
+  foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/declare_target_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/declare_target_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/declare_target_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/declare_target_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,83 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+#pragma omp end declare target // expected-error {{unexpected OpenMP directive '#pragma omp end declare target'}}
+
+int a, b; // expected-warning 2 {{declaration is not declared in any declare target region}}
+__thread int t; // expected-error {{threadprivate variables cannot be used in target constructs}}
+#pragma omp declare target private(a) // expected-warning {{extra tokens at the end of '#pragma omp declare target' are ignored}}
+void f();
+#pragma omp end declare target shared(a) // expected-warning {{extra tokens at the end of '#pragma omp end declare target' are ignored}}
+void c(); // expected-warning {{declaration is not declared in any declare target region}}
+
+extern int b;
+
+struct NonT {
+  int a;
+};
+
+typedef int sint;
+
+#pragma omp declare target // expected-note {{to match this '#pragma omp declare target'}}
+#pragma omp threadprivate(a) // expected-error {{threadprivate variables cannot be used in target constructs}} expected-note {{used here}}
+extern int b;
+int g;
+
+struct T { // expected-note {{mappable type cannot be polymorphic}}
+  int a;
+  virtual int method();
+};
+
+class VC { // expected-note {{mappable type cannot be polymorphic}}
+  T member;
+  NonT member1;
+  public:
+    virtual int method() { T a; return 0; } // expected-error {{type 'T' is not mappable to target}}
+};
+
+struct C {
+  NonT a;
+  sint b;
+  int method();
+  int method1();
+};
+
+int C::method1() {
+  return 0;
+}
+
+void foo() {
+  a = 0; // expected-note {{used here}}
+  b = 0; // expected-note {{used here}}
+  t = 1; // expected-note {{used here}}
+  C object;
+  VC object1; // expected-error {{type 'VC' is not mappable to target}}
+  g = object.method();
+  g += object.method1();
+  g += object1.method();
+  f();
+  c(); // expected-note {{used here}}
+}
+#pragma omp declare target // expected-error {{expected '#pragma omp end declare target'}}
+void foo1() {}
+#pragma omp end declare target
+#pragma omp end declare target // expected-error {{unexpected OpenMP directive '#pragma omp end declare target'}}
+
+int C::method() {
+  return 0;
+}
+
+struct S {
+#pragma omp declare target // expected-error {{directive must be at file or namespace scope}}
+  int v;
+#pragma omp end declare target // expected-error {{unexpected OpenMP directive '#pragma omp end declare target'}}
+};
+
+int main (int argc, char **argv) {
+#pragma omp declare target // expected-error {{unexpected OpenMP directive '#pragma omp declare target'}}
+  int v;
+#pragma omp end declare target // expected-error {{unexpected OpenMP directive '#pragma omp end declare target'}}
+  foo();
+  return (0);
+}
+
+#pragma omp declare target // expected-error {{expected '#pragma omp end declare target'}} expected-note {{to match this '#pragma omp declare target'}}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/distribute_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/distribute_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/distribute_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/distribute_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,42 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  static int a;
+// CHECK: static int a;
+#pragma omp distribute
+// CHECK-NEXT: #pragma omp distribute
+  for (int i=0; i < 2; ++i)a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: a = 2;
+#pragma omp target
+#pragma omp teams
+#pragma omp distribute private(argc,b),firstprivate(argv, c), collapse(2), dist_schedule(static)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j)foo();
+// CHECK-NEXT: #pragma omp target
+// CHECK-NEXT: #pragma omp teams
+// CHECK-NEXT: #pragma omp distribute private(argc,b) firstprivate(argv,c) collapse(2) dist_schedule(static)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j)
+// CHECK-NEXT: foo();
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp distribute dist_schedule(static, argc)
+// CHECK: #pragma omp distribute dist_schedule(static, argc)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/distribute_collapse_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/distribute_collapse_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/distribute_collapse_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/distribute_collapse_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; }
+  operator bool() { return f; }
+} v2;
+
+struct S3 {
+  int f;
+  operator int() { return f; }
+} v3;
+
+int main(int argc, char **argv) { // expected-note {{declared here}}
+  #pragma omp distribute collapse // expected-error {{expected '(' after 'collapse'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute collapse ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute collapse () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute collapse (argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}} expected-note {{read of non-const variable 'argc' is not allowed in a constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute collapse (argc > 0 ? argv[1] : argv[2]) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute collapse (foobool(argc)) collapse(1) // expected-error {{directive '#pragma omp distribute' cannot contain more than one 'collapse' clause}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute collapse (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute collapse (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute collapse (v1) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute collapse (v2) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute collapse (v3) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute collapse (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute collapse (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/distribute_dist_schedule_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/distribute_dist_schedule_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/distribute_dist_schedule_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/distribute_dist_schedule_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,35 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+int main(int argc, char **argv) {
+  #pragma omp distribute dist_schedule // expected-error {{expected '(' after 'dist_schedule'}} expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute dist_schedule ( // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute dist_schedule () // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute dist_schedule (static // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute dist_schedule (static, // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute dist_schedule (argc)) // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}} expected-warning {{extra tokens at the end of '#pragma omp distribute' are ignored}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute dist_schedule (static, argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute dist_schedule (static), dist_schedule (static, 1) // expected-error {{directive '#pragma omp distribute' cannot contain more than one 'dist_schedule' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute dist_schedule (static, S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp distribute dist_schedule (static, argv[1]=2) // expected-error {{statement requires expression of integer type ('char *' invalid)}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/distribute_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/distribute_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/distribute_firstprivate_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/distribute_firstprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,147 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s;
+  static const float S2sc;
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+class S6 {
+  int a;
+public:
+  S6() : a(0) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  S6 p;
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp distribute firstprivate // expected-error {{expected '(' after 'firstprivate'}} expected-error {{expected expression}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp distribute firstprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp distribute firstprivate () // expected-error {{expected expression}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate (argc)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate (S1) // expected-error {{'S1' does not refer to a value}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate (a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate (argv[1]) // expected-error {{expected variable name}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate(ba)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate(ca)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate(da)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate(S2::S2s)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate(S2::S2sc)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute private(i), firstprivate(i) // expected-error {{private variable cannot be firstprivate}} expected-note{{defined as private}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams shared(i)
+  #pragma omp distribute firstprivate(i)
+  for (j = 0; j < argc; ++j) foo();
+  #pragma omp target
+  #pragma omp teams shared(i)
+  #pragma omp distribute firstprivate(i) // expected-note {{defined as firstprivate}}
+  for (i = 0; i < argc; ++i) foo(); // expected-error {{loop iteration variable may not be firstprivate}}
+  #pragma omp target
+  #pragma omp teams private(argc) // expected-note {{defined as private}}
+  #pragma omp distribute firstprivate(argc) // expected-error {{private variable in '#pragma omp teams' cannot be firstprivate in '#pragma omp distribute'}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams reduction(+:argc) // expected-note {{defined as reduction}}
+  #pragma omp distribute firstprivate(argc) // expected-error {{reduction variable in '#pragma omp teams' cannot be firstprivate in '#pragma omp distribute'}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
+  for (i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/distribute_loop_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/distribute_loop_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/distribute_loop_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/distribute_loop_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,203 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+namespace std {
+
+struct random_access_iterator_tag { };
+
+template <class Iter>
+struct iterator_traits {
+  typedef typename Iter::difference_type difference_type; // expected-error {{no type named 'difference_type' in 'Iter'}} expected-error {{no type named 'difference_type' in 'Iter1'}}
+  typedef typename Iter::iterator_category iterator_category; // expected-error {{no type named 'iterator_category' in 'Iter'}} expected-error {{no type named 'iterator_category' in 'Iter1'}} expected-error {{no type named 'iterator_category' in 'Iter2'}}
+};
+
+template <class Iter>
+typename iterator_traits<Iter>::difference_type distance(Iter first, Iter last) {
+  return first - last;
+}
+}
+
+class Iter {
+  public:
+    Iter() { }
+    Iter(const Iter &) { }
+    Iter operator ++() { return *this; }
+    Iter operator --() { return *this; }
+    bool operator <(Iter a) { return true; }
+    bool operator >=(Iter a) { return false; }
+};
+int operator -(Iter a, Iter b) { return 0; }
+class Iter1 {
+  public:
+    Iter1() { }
+    Iter1(const Iter1 &) { }
+    Iter1 operator ++() { return *this; }
+    Iter1 operator --() { return *this; }
+    bool operator <(Iter1 a) { return true; }
+    bool operator >=(Iter1 a) { return false; }
+};
+class Iter2 {
+  public:
+    Iter2() { }
+    Iter2(const Iter2 &) { }
+    Iter2 operator ++() { return *this; }
+    Iter2 operator --() { return *this; }
+    bool operator <(Iter2 a) { return true; }
+    bool operator >=(Iter2 a) { return false; }
+    typedef int difference_type;
+};
+int operator -(Iter2 a, Iter2 b) { return 0; }
+class Iter3 {
+  public:
+    Iter3() { }
+    Iter3(const Iter3 &) { }
+    Iter3 operator ++() { return *this; }
+    Iter3 operator --() { return *this; }
+    bool operator <(Iter3 a) { return true; }
+    bool operator >=(Iter3 a) { return false; }
+    typedef int difference_type;
+    typedef int iterator_category;
+};
+int operator -(Iter3 a, Iter3 b) { return 0; }
+class Iter4 {
+  public:
+    Iter4() { }
+    Iter4(const Iter4 &) { }
+    Iter4 operator ++() { return *this; }
+    Iter4 operator --() { return *this; }
+    bool operator <(Iter4 a) { return true; }
+    bool operator >=(Iter4 a) { return false; }
+    Iter4 operator+=(int) const {return Iter4();}
+    Iter4 operator-=(int) const {return Iter4();}
+    typedef int difference_type;
+    typedef std::random_access_iterator_tag iterator_category;
+};
+int operator -(Iter4 a, Iter4 b) { return 0; }
+
+int t;
+#pragma omp threadprivate(t)
+
+int main() {
+  #pragma omp distribute
+  for (int i = 0; i < 10; i++)
+    ++i;
+  #pragma omp distribute
+  for (t = 0; t < 10; t++)
+    ++t;
+  #pragma omp distribute
+  for (int i; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp distribute
+  for (float i = 0; i < 10.0f; i++) // expected-error {{variable must be of integer or random access iterator type}}
+    ++i;
+  #pragma omp distribute
+  for (int i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp distribute
+  for (int i = 0; i < 10; i |= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  int i;
+  #pragma omp distribute
+  for (i = 0; i < 10; i++)
+    ++i;
+  #pragma omp distribute
+  for (i--; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp distribute
+  for (i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp distribute
+  for (i = 0; i < 10; i ^= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  Iter begin, end;
+  #pragma omp distribute
+  for (Iter I = begin; I >= end; ++I) // expected-error {{increment expression must cause 'I' to decrease on each iteration of the loop}}
+    ++I;
+  #pragma omp distribute
+  for (Iter I = end; I < begin; --I) // expected-error {{increment expression must cause 'I' to increase on each iteration of the loop}}
+    ++I;
+  #pragma omp distribute
+  for (Iter I = begin; I < end; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter>' requested here}} expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp distribute
+  for (Iter I = end; I >= begin; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter1 begin1;
+  #pragma omp distribute
+  for (Iter1 I = begin1; I < begin1; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter1>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp distribute
+  for (Iter1 I = begin1; I >= begin1; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter2 begin2;
+  #pragma omp distribute
+  for (Iter2 I = begin2; I < begin2; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter2>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp distribute
+  for (Iter2 I = begin2; I >= begin2; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter3 begin3;
+  #pragma omp distribute
+  for (Iter3 I = begin3; I < begin3; ++I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp distribute
+  for (Iter3 I = begin3; I >= begin3; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter4 begin4;
+  #pragma omp distribute
+  for (Iter4 I = begin4; I < begin4; ++I)
+    ++I;
+  #pragma omp distribute
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  goto label; // expected-error {{use of undeclared label 'label'}}
+  #pragma omp distribute
+  for (int i = 0; i < 100; ++i) {
+    label: ++i;
+  }
+  #pragma omp distribute collapse(1)
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  #pragma omp distribute collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+  for (Iter4 I1 = begin4; I1 >= begin4; --I1)
+  for (Iter4 I2 = begin4; I2 >= begin4; --I2)
+    ++I;
+  #pragma omp distribute collapse(0) // expected-error {{expression is not a positive integer value}}
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  #pragma omp distribute
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp distribute // expected-error {{region cannot be closely nested inside a distribute region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp single
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp distribute // expected-error {{region cannot be closely nested inside a worksharing region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp sections
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp distribute // expected-error {{region cannot be closely nested inside a worksharing region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp master
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp distribute // expected-error {{region cannot be closely nested inside a master region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp critical
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp distribute // expected-error {{region cannot be closely nested inside a critical region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp for ordered
+  for (Iter4 I = begin4; I >= begin4; --I)
+  #pragma omp ordered
+    #pragma omp distribute // expected-error {{region cannot be closely nested inside an ordered region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp distribute collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I; // expected-error {{only for-loops are allowed for '#pragma omp distribute'}}
+  ++begin4; 
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/distribute_loop_messages1.cpp cfe-3.5.0.src.omp/test/OpenMP/distribute_loop_messages1.cpp
--- cfe-3.5.0.src/test/OpenMP/distribute_loop_messages1.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/distribute_loop_messages1.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,10 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int main() {
+  int i;
+  goto label; // expected-error {{use of undeclared label 'label'}}
+  #pragma omp distribute
+  for (i = 0; i < 100; ++i) {
+    label: ++i;
+  }
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/distribute_parallel_for_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/distribute_parallel_for_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/distribute_parallel_for_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/distribute_parallel_for_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,75 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+template<class T, class N> T reduct(T* arr, N num) {
+  N i;
+  N ind;
+  T sum = (T)0;
+// CHECK: T sum = (T)0;
+#pragma omp distribute parallel for reduction(+:sum) proc_bind(master) dist_schedule(static)
+// CHECK-NEXT: #pragma omp distribute parallel for reduction(+: sum) proc_bind(master) dist_schedule(static)
+  for (i = 0; i < num; ++i) {
+    T cur = arr[ind];
+    ++ind;
+    sum += cur;
+  }
+}
+
+template<class T> struct S {
+  S(const T &a)
+    :m_a(a)
+  {}
+  T result(T *v) const {
+    T res;
+// CHECK: T res;
+#pragma omp distribute parallel for lastprivate(res) if(m_a)
+// CHECK-NEXT: #pragma omp distribute parallel for lastprivate(res) if(this->m_a)
+    for (T i = 7; i < m_a; ++i) {
+      res = v[i-7] + m_a;
+    }
+    return res;
+  }
+  ~S()
+  {}
+  T m_a;
+};
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  int k1=0,k2=0;
+  static int *a;
+// CHECK: static int *a;
+#pragma omp distribute parallel for
+// CHECK-NEXT: #pragma omp distribute parallel for
+  for (int i=0; i < 2; ++i)*a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: *a = 2;
+#pragma omp distribute parallel for private(argc,b),lastprivate(d,f),reduction(+:e) reduction(min : g),  collapse(2) dist_schedule(static, 3)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j) {foo(); k1 += 8; k2 += 8;}
+// CHECK-NEXT: #pragma omp distribute parallel for private(argc,b) lastprivate(d,f) reduction(+: e) reduction(min: g) collapse(2) dist_schedule(static, 3)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j) {
+// CHECK-NEXT: foo();
+// CHECK-NEXT: k1 += 8;
+// CHECK-NEXT: k2 += 8;
+// CHECK-NEXT: }
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp distribute parallel for collapse(1)
+// CHECK:      #pragma omp distribute parallel for collapse(1)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/distribute_parallel_for_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/distribute_parallel_for_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/distribute_parallel_for_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/distribute_parallel_for_misc_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,263 @@
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 100000 -fopenmp -verify %s
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp distribute parallel for'}} */
+#pragma omp distribute parallel for
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp distribute parallel for'}} */
+#pragma omp distribute parallel for foo
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp distribute parallel for'}} */
+#pragma omp distribute parallel for collapse
+
+void test_no_clause()
+{
+  int i;
+  #pragma omp distribute parallel for
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_invalid_clause()
+{
+  int i;
+  /* expected-warning@+1 {{extra tokens at the end of '#pragma omp distribute parallel for' are ignored}} */
+  #pragma omp distribute parallel for foo bar
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_non_identifiers()
+{
+  int i, x;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp distribute parallel for' are ignored}}
+  #pragma omp distribute parallel for;
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp distribute parallel for' are ignored}}
+  #pragma omp distribute parallel for private(x);
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp distribute parallel for' are ignored}}
+  #pragma omp distribute parallel for , private(x);
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_private()
+{
+  int i;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp distribute parallel for private(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute parallel for private(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute parallel for private(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for private()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for private(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp distribute parallel for private(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp distribute parallel for private(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for private(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for private(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_firstprivate()
+{
+  // TODO: tests on this.
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for firstprivate(
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_lastprivate()
+{
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for lastprivate(
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute parallel for lastprivate(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute parallel for lastprivate(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for lastprivate()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for lastprivate(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp distribute parallel for lastprivate(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp distribute parallel for lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for lastprivate(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for lastprivate(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_reduction()
+{
+  int i, x, y;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp distribute parallel for reduction(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp distribute parallel for reduction()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp distribute parallel for reduction(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected identifier}} */
+  #pragma omp distribute parallel for reduction(:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+4 {{expected ')'}} expected-note@+4 {{to match this '('}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute parallel for reduction(,
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp distribute parallel for reduction(+
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  //
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for reduction(+:
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for reduction(+:)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for reduction(+:,y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for reduction(+:x,+:y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for reduction(%:x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp distribute parallel for reduction(+:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for reduction(*:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for reduction(-:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for reduction(&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for reduction(|:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for reduction(^:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for reduction(&&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for reduction(||:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for reduction(max:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for reduction(min:x)
+  for (i = 0; i < 16; ++i) ;
+  struct X { int x; };
+  struct X X;
+  // TODO: Is the following error correct?
+  // expected-error@+1 {{expected variable name}}
+  #pragma omp distribute parallel for reduction(+:X.x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp distribute parallel for reduction(+:x+x)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_multiple_clauses()
+{
+  int i;
+  float x = 0, y = 0, z = 0;
+  #pragma omp distribute parallel for reduction(+:x, y) reduction(-:z) // OK
+  for (i = 0; i < 16; ++i);
+
+  // expected-error@+1 {{private variable cannot be lastprivate}} expected-note@+1 {{defined as private}}
+  #pragma omp distribute parallel for private(x), lastprivate(x)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp distribute parallel for reduction(+:x, y), reduction(-:z)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp distribute parallel for reduction(+:x, y) reduction(-:z)
+  for (i = 0; i < 16; ++i);
+}
+
+void test_for()
+{
+  // expected-error@+3 {{expected '(' after 'for'}}
+  // expected-error@+2 2{{use of undeclared identifier 'i'}}
+  #pragma omp distribute parallel for
+  for int i = 0; i < 16; i++);
+
+  // expected-error@+3 {{expected ')'}}
+  // expected-note@+2 {{to match this '('}}
+  #pragma omp distribute parallel for
+  for (int i = 0; i < 16; i++;
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp distribute parallel for
+  for (int i = 0 i < 16; i++);
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp distribute parallel for
+  for (int i = 0; i < 16 i++);
+
+  // expected-error@+2 2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp distribute parallel for
+  for (int i = 0 i < 16 i++);
+
+  int i = 0;
+  // expected-error@+2 {{initialization of for-loop does not have canonical form}}
+  #pragma omp distribute parallel for
+  for (; i < 16; ++i);
+
+  // expected-error@+2 {{condition of for-loop does not have canonical form}}
+  #pragma omp distribute parallel for
+  for (int i = 0; ; ++i);
+
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp distribute parallel for
+  for (int i = 0; i < 16; );
+
+  // expected-error@+3 {{condition of for-loop does not have canonical form}}
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp distribute parallel for
+  for (int i = 0; ;);
+
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/distribute_parallel_for_simd_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/distribute_parallel_for_simd_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/distribute_parallel_for_simd_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/distribute_parallel_for_simd_misc_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,263 @@
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 100000 -fopenmp -verify %s
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp distribute parallel for simd'}} */
+#pragma omp distribute parallel for simd
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp distribute parallel for simd'}} */
+#pragma omp distribute parallel for simd foo
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp distribute parallel for simd'}} */
+#pragma omp distribute parallel for simd collapse
+
+void test_no_clause()
+{
+  int i;
+  #pragma omp distribute parallel for simd
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_invalid_clause()
+{
+  int i;
+  /* expected-warning@+1 {{extra tokens at the end of '#pragma omp distribute parallel for simd' are ignored}} */
+  #pragma omp distribute parallel for simd foo bar
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_non_identifiers()
+{
+  int i, x;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp distribute parallel for simd' are ignored}}
+  #pragma omp distribute parallel for simd;
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp distribute parallel for simd' are ignored}}
+  #pragma omp distribute parallel for simd private(x);
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp distribute parallel for simd' are ignored}}
+  #pragma omp distribute parallel for simd , private(x);
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_private()
+{
+  int i;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp distribute parallel for simd private(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute parallel for simd private(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute parallel for simd private(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for simd private()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for simd private(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp distribute parallel for simd private(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp distribute parallel for simd private(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for simd private(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for simd private(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_firstprivate()
+{
+  // TODO: tests on this.
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for simd firstprivate(
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_lastprivate()
+{
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for simd lastprivate(
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute parallel for simd lastprivate(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute parallel for simd lastprivate(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for simd lastprivate()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for simd lastprivate(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp distribute parallel for simd lastprivate(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp distribute parallel for simd lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for simd lastprivate(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for simd lastprivate(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_reduction()
+{
+  int i, x, y;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp distribute parallel for simd reduction(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp distribute parallel for simd reduction()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp distribute parallel for simd reduction(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected identifier}} */
+  #pragma omp distribute parallel for simd reduction(:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+4 {{expected ')'}} expected-note@+4 {{to match this '('}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute parallel for simd reduction(,
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp distribute parallel for simd reduction(+
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  //
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for simd reduction(+:
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for simd reduction(+:)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for simd reduction(+:,y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for simd reduction(+:x,+:y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute parallel for simd reduction(%:x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp distribute parallel for simd reduction(+:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for simd reduction(*:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for simd reduction(-:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for simd reduction(&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for simd reduction(|:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for simd reduction(^:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for simd reduction(&&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for simd reduction(||:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for simd reduction(max:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute parallel for simd reduction(min:x)
+  for (i = 0; i < 16; ++i) ;
+  struct X { int x; };
+  struct X X;
+  // TODO: Is the following error correct?
+  // expected-error@+1 {{expected variable name}}
+  #pragma omp distribute parallel for simd reduction(+:X.x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp distribute parallel for simd reduction(+:x+x)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_multiple_clauses()
+{
+  int i;
+  float x = 0, y = 0, z = 0;
+  #pragma omp distribute parallel for simd reduction(+:x, y) reduction(-:z) // OK
+  for (i = 0; i < 16; ++i);
+
+  // expected-error@+1 {{private variable cannot be lastprivate}} expected-note@+1 {{defined as private}}
+  #pragma omp distribute parallel for simd private(x), lastprivate(x)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp distribute parallel for simd reduction(+:x, y), reduction(-:z)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp distribute parallel for simd reduction(+:x, y) reduction(-:z)
+  for (i = 0; i < 16; ++i);
+}
+
+void test_for()
+{
+  // expected-error@+3 {{expected '(' after 'for'}}
+  // expected-error@+2 2{{use of undeclared identifier 'i'}}
+  #pragma omp distribute parallel for simd
+  for int i = 0; i < 16; i++);
+
+  // expected-error@+3 {{expected ')'}}
+  // expected-note@+2 {{to match this '('}}
+  #pragma omp distribute parallel for simd
+  for (int i = 0; i < 16; i++;
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp distribute parallel for simd
+  for (int i = 0 i < 16; i++);
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp distribute parallel for simd
+  for (int i = 0; i < 16 i++);
+
+  // expected-error@+2 2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp distribute parallel for simd
+  for (int i = 0 i < 16 i++);
+
+  int i = 0;
+  // expected-error@+2 {{initialization of for-loop does not have canonical form}}
+  #pragma omp distribute parallel for simd
+  for (; i < 16; ++i);
+
+  // expected-error@+2 {{condition of for-loop does not have canonical form}}
+  #pragma omp distribute parallel for simd
+  for (int i = 0; ; ++i);
+
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp distribute parallel for simd
+  for (int i = 0; i < 16; );
+
+  // expected-error@+3 {{condition of for-loop does not have canonical form}}
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp distribute parallel for simd
+  for (int i = 0; ;);
+
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/distribute_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/distribute_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/distribute_private_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/distribute_private_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,131 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  static float S2s; // expected-note {{predetermined as shared}}
+};
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+};
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f;  // expected-note {{predetermined as shared}}
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+public:
+  S4(int v):a(v) { }
+};
+class S5 { // expected-note {{'S5' declared here}}
+  int a;
+  S5():a(0) {}
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;  // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp distribute private // expected-error {{expected '(' after 'private'}} expected-error {{expected expression}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private () // expected-error {{expected expression}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private (argc)
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private (a, b, c, d, f) // expected-error {{private variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be private}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private (argv[1]) // expected-error {{expected variable name}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private(ba)
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private(ca) // expected-error {{shared variable cannot be private}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private(da) // expected-error {{shared variable cannot be private}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private(S2::S2s) // expected-error {{shared variable cannot be private}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute shared(i) // expected-error {{unexpected OpenMP clause 'shared' in directive '#pragma omp distribute'}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp target
+  #pragma omp teams
+  {
+    int i; // expected-note {{predetermined as private}}
+    #pragma omp distribute firstprivate(i), private(i) // expected-error {{private variable cannot be firstprivate}}
+    for (int k = 0; k < argc; ++k) ++k;
+  }
+  #pragma omp target
+  #pragma omp teams private(i)
+  #pragma omp distribute private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp parallel private(i)
+  #pragma omp target
+  #pragma omp teams firstprivate(i)
+  #pragma omp parallel private(i)
+  #pragma omp target
+  #pragma omp teams reduction(+:i)
+  #pragma omp distribute private(i)
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp distribute private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams private(i)
+    #pragma omp distribute private(i)
+    for (int x = 0; x < 10; ++x) foo();
+  }
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp distribute firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams firstprivate(i)
+    #pragma omp distribute private(i)
+    for (int x = 0; x < 10; ++x) foo();
+  }
+  #pragma omp target
+  #pragma omp teams reduction(+:i)
+  #pragma omp distribute
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams reduction(+:i)
+    #pragma omp distribute private(i)
+    for (int x = 0; x < 10; ++x) foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/distribute_simd_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/distribute_simd_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/distribute_simd_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/distribute_simd_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,95 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+template<class T, class N> T reduct(T* arr, N num) {
+  N i;
+  N ind;
+  T sum = (T)0;
+// CHECK: T sum = (T)0;
+#pragma omp distribute simd  linear(ind), reduction(+:sum)
+// CHECK-NEXT: #pragma omp distribute simd linear(ind) reduction(+: sum)
+  for (i = 0; i < num; ++i) {
+    T cur = arr[ind];
+    ++ind;
+    sum += cur;
+  }
+}
+
+template<class T> struct S {
+  S(const T &a)
+    :m_a(a)
+  {}
+  T result(T *v) const {
+    T res;
+// CHECK: T res;
+#pragma omp distribute simd lastprivate(res) safelen(7)
+// CHECK-NEXT: #pragma omp distribute simd lastprivate(res) safelen(7)
+    for (T i = 7; i < m_a; ++i) {
+      res = v[i-7] + m_a;
+    }
+    return res;
+  }
+  ~S()
+  {}
+  T m_a;
+};
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  int k1=0,k2=0;
+  static int *a;
+// CHECK: static int *a;
+#pragma omp distribute simd
+// CHECK-NEXT: #pragma omp distribute simd
+  for (int i=0; i < 2; ++i)*a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: *a = 2;
+#pragma omp target
+#pragma omp teams
+#pragma omp distribute simd private(argc,b),lastprivate(d,f),reduction(+:e) reduction(min : g),  collapse(2) safelen(2) aligned(a:4), linear(k1,k2:8)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j) {foo(); k1 += 8; k2 += 8;}
+// CHECK-NEXT: #pragma omp target
+// CHECK-NEXT: #pragma omp teams
+// CHECK-NEXT: #pragma omp distribute simd private(argc,b) lastprivate(d,f) reduction(+: e) reduction(min: g) collapse(2) safelen(2) aligned(a: 4) linear(k1,k2: 8)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j) {
+// CHECK-NEXT: foo();
+// CHECK-NEXT: k1 += 8;
+// CHECK-NEXT: k2 += 8;
+// CHECK-NEXT: }
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp distribute simd aligned(a) linear(a)
+// CHECK-NEXT: #pragma omp distribute simd aligned(a) linear(a)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp distribute simd collapse(1)
+// CHECK: #pragma omp distribute simd collapse(1)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  const int CLEN=4;
+#pragma omp distribute simd safelen(CLEN)
+// CHECK: #pragma omp distribute simd safelen(4)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp distribute simd aligned(a:CLEN) linear(a:CLEN) safelen(CLEN)
+// CHECK-NEXT: #pragma omp distribute simd aligned(a: 4) linear(a: 4) safelen(4)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/distribute_simd_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/distribute_simd_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/distribute_simd_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/distribute_simd_misc_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,453 @@
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 100000 -fopenmp -verify %s
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp distribute simd'}} */
+#pragma omp distribute simd
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp distribute simd'}} */
+#pragma omp distribute simd foo
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp distribute simd'}} */
+#pragma omp distribute simd safelen(4)
+
+void test_no_clause()
+{
+  int i;
+  #pragma omp distribute simd
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_invalid_clause()
+{
+  int i;
+  /* expected-warning@+1 {{extra tokens at the end of '#pragma omp distribute simd' are ignored}} */
+  #pragma omp distribute simd foo bar
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_non_identifiers()
+{
+  int i, x;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp distribute simd' are ignored}}
+  #pragma omp distribute simd;
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp distribute simd' are ignored}}
+  #pragma omp distribute simd private(x);
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp distribute simd' are ignored}}
+  #pragma omp distribute simd , private(x);
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_safelen()
+{
+  int i;
+  /* expected-error@+1 {{expected '('}}  expected-error@+1 {{expected expression}}*/
+  #pragma omp distribute simd safelen
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}} */
+  #pragma omp distribute simd safelen(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd safelen()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp distribute simd safelen(,
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp distribute simd' are ignored}}
+  /* expected-error@+1 {{expected expression}}  expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp distribute simd safelen(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected '('}} */
+  #pragma omp distribute simd safelen 4)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp distribute simd safelen(4
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp distribute simd safelen(4,
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp distribute simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp distribute simd safelen(4,)
+  for (i = 0; i < 16; ++i) ;
+  /* xxpected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd safelen(4)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp distribute simd safelen(4 4)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp distribute simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp distribute simd safelen(4,,4)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd safelen(4)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp distribute simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp distribute simd safelen(4,8)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_linear()
+{
+  int i;
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}} */
+  #pragma omp distribute simd linear(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp distribute simd linear(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd linear(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd linear()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd linear(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp distribute simd linear(0)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{use of undeclared identifier 'x'}} */
+  #pragma omp distribute simd linear(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{use of undeclared identifier 'x'}} */
+  /* expected-error@+1 {{use of undeclared identifier 'y'}} */
+  #pragma omp distribute simd linear(x, y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+3 {{use of undeclared identifier 'x'}} */
+  /* expected-error@+2 {{use of undeclared identifier 'y'}} */
+  /* expected-error@+1 {{use of undeclared identifier 'z'}} */
+  #pragma omp distribute simd linear(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd linear(x:)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd linear(x:,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd linear(x:1)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd linear(x:2*2)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp distribute simd' are ignored}}
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp distribute simd linear(x:1,y)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp distribute simd' are ignored}}
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp distribute simd linear(x:1,y,z:1)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be linear}}
+  #pragma omp distribute simd linear(x) linear(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as private}}
+  // expected-error@+1 {{private variable cannot be linear}}
+  #pragma omp distribute simd private(x) linear(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be private}}
+  #pragma omp distribute simd linear(x) private(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be lastprivate}}
+  #pragma omp distribute simd linear(x) lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as lastprivate}}
+  // expected-error@+1 {{lastprivate variable cannot be linear}}
+  #pragma omp distribute simd lastprivate(x) linear(x) 
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_private()
+{
+  int i;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp distribute simd private(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute simd private(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute simd private(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd private()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd private(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp distribute simd private(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp distribute simd private(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd private(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd private(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_firstprivate()
+{
+  // TODO: tests on this.
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd firstprivate(
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_lastprivate()
+{
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd lastprivate(
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute simd lastprivate(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute simd lastprivate(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd lastprivate()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd lastprivate(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp distribute simd lastprivate(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp distribute simd lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd lastprivate(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd lastprivate(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_reduction()
+{
+  int i, x, y;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp distribute simd reduction(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp distribute simd reduction()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp distribute simd reduction(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected identifier}} */
+  #pragma omp distribute simd reduction(:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+4 {{expected ')'}} expected-note@+4 {{to match this '('}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute simd reduction(,
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp distribute simd reduction(+
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  //
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd reduction(+:
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd reduction(+:)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd reduction(+:,y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd reduction(+:x,+:y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd reduction(%:x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp distribute simd reduction(+:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd reduction(*:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd reduction(-:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd reduction(&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd reduction(|:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd reduction(^:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd reduction(&&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd reduction(||:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd reduction(max:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp distribute simd reduction(min:x)
+  for (i = 0; i < 16; ++i) ;
+  struct X { int x; };
+  struct X X;
+  // TODO: Is the following error correct?
+  // expected-error@+1 {{expected variable name}}
+  #pragma omp distribute simd reduction(+:X.x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp distribute simd reduction(+:x+x)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_aligned()
+{
+  int i;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp distribute simd aligned(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute simd aligned(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp distribute simd aligned(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd aligned()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp distribute simd aligned(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp distribute simd aligned(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int *x, y, z[25];
+  #pragma omp distribute simd aligned(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp distribute simd aligned(x, y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp distribute simd aligned(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp distribute simd aligned(x:4)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp distribute simd aligned(x, y:8)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp distribute simd aligned(x, y, z:10+6)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}}
+  // expected-error@+1 {{expression is not an integer constant expression}}
+  #pragma omp distribute simd aligned(x, y, z:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-note@+2 {{defined as aligned}}
+  // expected-error@+1 {{aligned variable cannot be aligned}}
+  #pragma omp distribute simd aligned(x:16) aligned(z,x:16)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_multiple_clauses()
+{
+  int i;
+  float x = 0, y = 0, z = 0;
+  #pragma omp distribute simd safelen(4) reduction(+:x, y) reduction(-:z) // OK
+  for (i = 0; i < 16; ++i);
+
+  // expected-error@+1 {{private variable cannot be lastprivate}} expected-note@+1 {{defined as private}}
+  #pragma omp distribute simd private(x), lastprivate(x)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp distribute simd safelen(4) reduction(+:x, y), reduction(-:z)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp distribute simd reduction(+:x, y) reduction(-:z)
+  for (i = 0; i < 16; ++i);
+}
+
+void test_for()
+{
+  // expected-error@+3 {{expected '(' after 'for'}}
+  // expected-error@+2 2{{use of undeclared identifier 'i'}}
+  #pragma omp distribute simd
+  for int i = 0; i < 16; i++);
+
+  // expected-error@+3 {{expected ')'}}
+  // expected-note@+2 {{to match this '('}}
+  #pragma omp distribute simd
+  for (int i = 0; i < 16; i++;
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp distribute simd
+  for (int i = 0 i < 16; i++);
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp distribute simd
+  for (int i = 0; i < 16 i++);
+
+  // expected-error@+2 2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp distribute simd
+  for (int i = 0 i < 16 i++);
+
+  int i = 0;
+  // expected-error@+2 {{initialization of for-loop does not have canonical form}}
+  #pragma omp distribute simd
+  for (; i < 16; ++i);
+
+  // expected-error@+2 {{condition of for-loop does not have canonical form}}
+  #pragma omp distribute simd
+  for (int i = 0; ; ++i);
+
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp distribute simd
+  for (int i = 0; i < 16; );
+
+  // expected-error@+3 {{condition of for-loop does not have canonical form}}
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp distribute simd
+  for (int i = 0; ;);
+
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/dsitribute_parallel_for_simd_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/dsitribute_parallel_for_simd_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/dsitribute_parallel_for_simd_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/dsitribute_parallel_for_simd_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,75 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+template<class T, class N> T reduct(T* arr, N num) {
+  N i;
+  N ind;
+  T sum = (T)0;
+// CHECK: T sum = (T)0;
+#pragma omp distribute parallel for simd reduction(+:sum) proc_bind(master) dist_schedule(static)
+// CHECK-NEXT: #pragma omp distribute parallel for simd reduction(+: sum) proc_bind(master) dist_schedule(static)
+  for (i = 0; i < num; ++i) {
+    T cur = arr[ind];
+    ++ind;
+    sum += cur;
+  }
+}
+
+template<class T> struct S {
+  S(const T &a)
+    :m_a(a)
+  {}
+  T result(T *v) const {
+    T res;
+// CHECK: T res;
+#pragma omp distribute parallel for simd lastprivate(res) if(m_a)
+// CHECK-NEXT: #pragma omp distribute parallel for simd lastprivate(res) if(this->m_a)
+    for (T i = 7; i < m_a; ++i) {
+      res = v[i-7] + m_a;
+    }
+    return res;
+  }
+  ~S()
+  {}
+  T m_a;
+};
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  int k1=0,k2=0;
+  static int *a;
+// CHECK: static int *a;
+#pragma omp distribute parallel for simd
+// CHECK-NEXT: #pragma omp distribute parallel for simd
+  for (int i=0; i < 2; ++i)*a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: *a = 2;
+#pragma omp distribute parallel for simd private(argc,b),lastprivate(d,f),reduction(+:e) reduction(min : g),  collapse(2) dist_schedule(static, 3) linear(k1) aligned(a:8)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j) {foo(); k1 += 8; k2 += 8;}
+// CHECK-NEXT: #pragma omp distribute parallel for simd private(argc,b) lastprivate(d,f) reduction(+: e) reduction(min: g) collapse(2) dist_schedule(static, 3) linear(k1) aligned(a: 8)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j) {
+// CHECK-NEXT: foo();
+// CHECK-NEXT: k1 += 8;
+// CHECK-NEXT: k2 += 8;
+// CHECK-NEXT: }
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp distribute parallel for simd collapse(1)
+// CHECK:      #pragma omp distribute parallel for simd collapse(1)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/flush_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/flush_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/flush_ast_print.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/flush_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,38 +1,17 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
 // expected-no-diagnostics
 
 #ifndef HEADER
 #define HEADER
 
-void foo() {}
-
-template <class T>
-T tmain(T argc) {
-  static T a;
-#pragma omp flush
-#pragma omp flush(a)
-  return a + argc;
-}
-// CHECK:      static int a;
-// CHECK-NEXT: #pragma omp flush
-// CHECK-NEXT: #pragma omp flush (a)
-// CHECK:      static char a;
-// CHECK-NEXT: #pragma omp flush
-// CHECK-NEXT: #pragma omp flush (a)
-// CHECK:      static T a;
-// CHECK-NEXT: #pragma omp flush
-// CHECK-NEXT: #pragma omp flush (a)
-
-int main(int argc, char **argv) {
-  static int a;
-// CHECK: static int a;
-#pragma omp flush
-#pragma omp flush(a)
-// CHECK-NEXT: #pragma omp flush
-// CHECK-NEXT: #pragma omp flush (a)
-  return tmain(argc) + tmain(argv[0][0]) + a;
+int main (int argc, char **argv) {
+// CHECK: int main(int argc, char **argv) {
+#pragma omp flush(argc)
+// CHECK-NEXT: #pragma omp flush(argc)
+// CHECK-NEXT: return argc;
+  return argc;
 }
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/flush_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/flush_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/flush_messages.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/flush_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,134 +1,61 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
-struct S1 { // expected-note 2 {{declared here}}
-  int a;
-};
-
-template <class T>
-T tmain(T argc) {
-#pragma omp flush
+int main(int argc, char **argv) {
+  #pragma omp flush
   ;
-#pragma omp flush untied  // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp flush'}}
-#pragma omp flush unknown // expected-warning {{extra tokens at the end of '#pragma omp flush' are ignored}}
+  #pragma omp flush untied // expected-warning {{extra tokens at the end of '#pragma omp flush' are ignored}}
+  #pragma omp flush unknown // expected-warning {{extra tokens at the end of '#pragma omp flush' are ignored}}
+  #pragma omp flush ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp flush ) // expected-warning {{extra tokens at the end of '#pragma omp flush' are ignored}}
+  #pragma omp flush () // expected-error {{expected expression}}
+  #pragma omp flush (argc,) // expected-error {{expected expression}}
+  #pragma omp flush (argc,argv)
   if (argc)
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
-    if (argc) {
-#pragma omp flush
-    }
+    #pragma omp flush // expected-error {{'#pragma omp flush' cannot be immediate substatement}}
+  if (argc) {
+    #pragma omp flush
+  }
   while (argc)
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
-    while (argc) {
-#pragma omp flush
-    }
+    #pragma omp flush // expected-error {{'#pragma omp flush' cannot be immediate substatement}}
+  while (argc) {
+    #pragma omp flush
+  }
   do
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
-    while (argc)
-      ;
+    #pragma omp flush // expected-error {{'#pragma omp flush' cannot be immediate substatement}}
+  while (argc);
   do {
-#pragma omp flush
-  } while (argc);
+    #pragma omp flush
+  }
+  while (argc);
+  switch (argc)
+    #pragma omp flush // expected-error {{'#pragma omp flush' cannot be immediate substatement}}
   switch (argc)
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
-    switch (argc)
     case 1:
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
+    #pragma omp flush // expected-error {{'#pragma omp flush' cannot be immediate substatement}}
   switch (argc)
-  case 1: {
-#pragma omp flush
-  }
+    case 1: {
+    #pragma omp flush
+    }
   switch (argc) {
-#pragma omp flush
+    #pragma omp flush
   case 1:
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
+    #pragma omp flush // expected-error {{'#pragma omp flush' cannot be immediate substatement}}
     break;
   default: {
-#pragma omp flush
-  } break;
-  }
-  for (;;)
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
-    for (;;) {
-#pragma omp flush
+    #pragma omp flush
     }
-label:
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
-label1 : {
-#pragma omp flush
-}
-
-#pragma omp flush
-#pragma omp flush(                              // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp flush()                             // expected-error {{expected expression}}
-#pragma omp flush(argc                          // expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp flush(argc,                         // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp flush(argc)
-#pragma omp flush(S1) // expected-error {{'S1' does not refer to a value}}
-#pragma omp flush(argc) flush(argc) // expected-warning {{extra tokens at the end of '#pragma omp flush' are ignored}}
-#pragma omp parallel flush(argc) // expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  ;
-  return T();
-}
-
-int main(int argc, char **argv) {
-#pragma omp flush
-  ;
-#pragma omp flush untied  // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp flush'}}
-#pragma omp flush unknown // expected-warning {{extra tokens at the end of '#pragma omp flush' are ignored}}
-  if (argc)
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
-    if (argc) {
-#pragma omp flush
-    }
-  while (argc)
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
-    while (argc) {
-#pragma omp flush
-    }
-  do
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
-    while (argc)
-      ;
-  do {
-#pragma omp flush
-  } while (argc);
-  switch (argc)
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
-    switch (argc)
-    case 1:
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
-  switch (argc)
-  case 1: {
-#pragma omp flush
-  }
-  switch (argc) {
-#pragma omp flush
-  case 1:
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
     break;
-  default: {
-#pragma omp flush
-  } break;
   }
   for (;;)
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
-    for (;;) {
-#pragma omp flush
-    }
-label:
-#pragma omp flush // expected-error {{'#pragma omp flush' cannot be an immediate substatement}}
-label1 : {
-#pragma omp flush
-}
+    #pragma omp flush // expected-error {{'#pragma omp flush' cannot be immediate substatement}}
+  for (;;) {
+    #pragma omp flush
+  }
+  label:
+    #pragma omp flush // expected-error {{'#pragma omp flush' cannot be immediate substatement}}
+  label1: {
+    #pragma omp flush
+  }
 
-#pragma omp flush
-#pragma omp flush(                              // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp flush()                             // expected-error {{expected expression}}
-#pragma omp flush(argc                          // expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp flush(argc,                         // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp flush(argc)
-#pragma omp flush(S1) // expected-error {{'S1' does not refer to a value}}
-#pragma omp flush(argc) flush(argc) // expected-warning {{extra tokens at the end of '#pragma omp flush' are ignored}}
-#pragma omp parallel flush(argc) // expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  ;
-  return tmain(argc);
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/for_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/for_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/for_ast_print.cpp	2014-06-24 08:55:56.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/for_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
 // expected-no-diagnostics
 
 #ifndef HEADER
@@ -8,57 +8,48 @@
 
 void foo() {}
 
-template <class T, int N>
-T tmain(T argc) {
-  T b = argc, c, d, e, f, g;
-  static T a;
-// CHECK: static T a;
-#pragma omp for schedule(dynamic)
-  // CHECK-NEXT: #pragma omp for schedule(dynamic)
-  for (int i = 0; i < 2; ++i)
-    a = 2;
-// CHECK-NEXT: for (int i = 0; i < 2; ++i)
-// CHECK-NEXT: a = 2;
-#pragma omp parallel
-#pragma omp for private(argc, b), firstprivate(c, d), lastprivate(d, f) collapse(N) schedule(static, N) ordered nowait
-  for (int i = 0; i < 10; ++i)
-    for (int j = 0; j < 10; ++j)
-      for (int j = 0; j < 10; ++j)
-        for (int j = 0; j < 10; ++j)
-          for (int j = 0; j < 10; ++j)
-            foo();
-  // CHECK-NEXT: #pragma omp parallel
-  // CHECK-NEXT: #pragma omp for private(argc,b) firstprivate(c,d) lastprivate(d,f) collapse(N) schedule(static, N) ordered nowait
-  // CHECK-NEXT: for (int i = 0; i < 10; ++i)
-  // CHECK-NEXT: for (int j = 0; j < 10; ++j)
-  // CHECK-NEXT: for (int j = 0; j < 10; ++j)
-  // CHECK-NEXT: for (int j = 0; j < 10; ++j)
-  // CHECK-NEXT: for (int j = 0; j < 10; ++j)
-  // CHECK-NEXT: foo();
-  return T();
-}
-
-int main(int argc, char **argv) {
+int main (int argc, char **argv) {
   int b = argc, c, d, e, f, g;
   static int a;
 // CHECK: static int a;
-#pragma omp for schedule(guided, argc)
-  // CHECK-NEXT: #pragma omp for schedule(guided, argc)
-  for (int i = 0; i < 2; ++i)
-    a = 2;
+#pragma omp for
+// CHECK-NEXT: #pragma omp for
+  for (int i=0; i < 2; ++i)a=2;
 // CHECK-NEXT: for (int i = 0; i < 2; ++i)
 // CHECK-NEXT: a = 2;
 #pragma omp parallel
-#pragma omp for private(argc, b), firstprivate(argv, c), lastprivate(d, f) collapse(2) schedule(auto) ordered nowait
+#pragma omp for private(argc,b),firstprivate(argv, c),lastprivate(d,f),reduction(+:e) reduction(min : g), ordered nowait, collapse(2), schedule(dynamic)
   for (int i = 0; i < 10; ++i)
-    for (int j = 0; j < 10; ++j)
-      foo();
-  // CHECK-NEXT: #pragma omp parallel
-  // CHECK-NEXT: #pragma omp for private(argc,b) firstprivate(argv,c) lastprivate(d,f) collapse(2) schedule(auto) ordered nowait
-  // CHECK-NEXT: for (int i = 0; i < 10; ++i)
-  // CHECK-NEXT: for (int j = 0; j < 10; ++j)
-  // CHECK-NEXT: foo();
-  return (tmain<int, 5>(argc) + tmain<char, 1>(argv[0][0]));
+  for (int j = 0; j < 10; ++j)foo();
+// CHECK-NEXT: #pragma omp parallel
+// CHECK-NEXT: #pragma omp for private(argc,b) firstprivate(argv,c) lastprivate(d,f) reduction(+: e) reduction(min: g) ordered nowait collapse(2) schedule(dynamic, 1)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j)
+// CHECK-NEXT: foo();
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp for nowait, schedule(guided, 12)
+// CHECK-NEXT: #pragma omp for nowait schedule(guided, 12)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp for schedule(static, argc)
+// CHECK: #pragma omp for schedule(static, argc)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp for ordered, schedule(auto)
+// CHECK: #pragma omp for ordered schedule(auto)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp for schedule(runtime)
+// CHECK-NEXT: #pragma omp for schedule(runtime)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
 }
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/for_collapse_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/for_collapse_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/for_collapse_messages.cpp	2014-06-24 08:55:56.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/for_collapse_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
 
 void foo() {
 }
@@ -9,75 +9,46 @@
 
 struct S1; // expected-note {{declared here}}
 
-template <class T, typename S, int N, int ST> // expected-note {{declared here}}
-T tmain(T argc, S **argv) { //expected-note 2 {{declared here}}
-  #pragma omp for collapse // expected-error {{expected '(' after 'collapse'}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for collapse ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for collapse () // expected-error {{expected expression}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
-  // expected-error@+2 2 {{expression is not an integral constant expression}}
-  // expected-note@+1 2 {{read of non-const variable 'argc' is not allowed in a constant expression}}
-  #pragma omp for collapse (argc 
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+1 2 {{argument to 'collapse' clause must be a positive integer value}}
-  #pragma omp for collapse (ST // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for collapse (1)) // expected-warning {{extra tokens at the end of '#pragma omp for' are ignored}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for collapse ((ST > 0) ? 1 + ST : 2) // expected-note 2 {{as specified in 'collapse' clause}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST]; // expected-error 2 {{expected 2 for loops after '#pragma omp for', but found only 1}}
-  // expected-error@+3 2 {{directive '#pragma omp for' cannot contain more than one 'collapse' clause}}
-  // expected-error@+2 2 {{argument to 'collapse' clause must be a positive integer value}}
-  // expected-error@+1 2 {{expression is not an integral constant expression}}
-  #pragma omp for collapse (foobool(argc)), collapse (true), collapse (-5)
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for collapse (S) // expected-error {{'S' does not refer to a value}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+1 2 {{expression is not an integral constant expression}}
-  #pragma omp for collapse (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for collapse (1)
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for collapse (N) // expected-error {{argument to 'collapse' clause must be a positive integer value}}
-  for (T i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for collapse (2) // expected-note {{as specified in 'collapse' clause}}
-  foo(); // expected-error {{expected 2 for loops after '#pragma omp for'}}
-  return argc;
-}
+extern S1 v1;
 
-int main(int argc, char **argv) {
-  #pragma omp for collapse // expected-error {{expected '(' after 'collapse'}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
+struct S2{
+  int f;
+  operator int() { return f; }
+  operator bool() { return f; }
+} v2;
+
+struct S3 {
+  int f;
+  operator int() { return f; }
+} v3;
+
+int main(int argc, char **argv) { // expected-note {{declared here}}
+  #pragma omp for collapse // expected-error {{expected '(' after 'collapse'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
   #pragma omp for collapse ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
+  for (int i = 0; i < 10; ++i) foo();
   #pragma omp for collapse () // expected-error {{expected expression}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp for collapse (4 // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-note {{as specified in 'collapse' clause}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4]; // expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
-  #pragma omp for collapse (2+2)) // expected-warning {{extra tokens at the end of '#pragma omp for' are ignored}}  expected-note {{as specified in 'collapse' clause}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4]; // expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
-  #pragma omp for collapse (foobool(1) > 0 ? 1 : 2) // expected-error {{expression is not an integral constant expression}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+3 {{expression is not an integral constant expression}}
-  // expected-error@+2 2 {{directive '#pragma omp for' cannot contain more than one 'collapse' clause}}
-  // expected-error@+1 2 {{argument to 'collapse' clause must be a positive integer value}}
-  #pragma omp for collapse (foobool(argc)), collapse (true), collapse (-5) 
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for collapse (argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}} expected-note {{read of non-const variable 'argc' is not allowed in a constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for collapse (argc > 0 ? argv[1] : argv[2]) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for collapse (foobool(argc)) collapse(1) // expected-error {{directive '#pragma omp for' cannot contain more than one 'collapse' clause}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
   #pragma omp for collapse (S1) // expected-error {{'S1' does not refer to a value}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+1 {{expression is not an integral constant expression}}
-  #pragma omp for collapse (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+3 {{statement after '#pragma omp for' must be a for loop}}
-  // expected-note@+1 {{in instantiation of function template specialization 'tmain<int, char, -1, -2>' requested here}}
-  #pragma omp for collapse(collapse(tmain<int, char, -1, -2>(argc, argv) // expected-error 2 {{expected ')'}} expected-note 2 {{to match this '('}}
-  foo();
-  #pragma omp for collapse (2) // expected-note {{as specified in 'collapse' clause}}
-  foo(); // expected-error {{expected 2 for loops after '#pragma omp for'}}
-  // expected-note@+1 {{in instantiation of function template specialization 'tmain<int, char, 1, 0>' requested here}}
-  return tmain<int, char, 1, 0>(argc, argv);
-}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for collapse (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for collapse (v1) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for collapse (v2) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for collapse (v3) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for collapse (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for collapse (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
 
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/for_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/for_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/for_firstprivate_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/for_firstprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,14 +7,13 @@
   return argc;
 }
 
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
-
 public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
   static float S2s;
   static const float S2sc;
 };
@@ -23,271 +22,110 @@
 const S2 ba[5];
 class S3 {
   int a;
-  S3 &operator=(const S3 &s3);
-
 public:
-  S3() : a(0) {}
-  S3(S3 &s3) : a(s3.a) {}
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
 };
 const S3 c;
 const S3 ca[5];
 extern const int f;
-class S4 { // expected-note 2 {{'S4' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
   S4(const S4 &s4);
-
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
-class S5 { // expected-note 4 {{'S5' declared here}}
+class S5 { // expected-note {{'S5' declared here}}
   int a;
-  S5(const S5 &s5) : a(s5.a) {}
-
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
 public:
-  S5() : a(0) {}
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
 };
 class S6 {
   int a;
-  S6() : a(0) {}
-
 public:
-  S6(const S6 &s6) : a(s6.a) {}
-  S6(int v) : a(v) {}
+  S6() : a(0) { }
 };
 
 S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class I, class C>
-int foomain(int argc, char **argv) {
-  I e(4); // expected-note {{'e' defined here}}
-  C g(5); // expected-note 2 {{'g' defined here}}
-  int i;
-  int &j = i; // expected-note {{'j' defined here}}
-#pragma omp parallel
-#pragma omp for firstprivate // expected-error {{expected '(' after 'firstprivate'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for firstprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for firstprivate() // expected-error {{expected expression}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for firstprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for firstprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for firstprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for firstprivate(argc)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for firstprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for firstprivate(a, b) // expected-error {{firstprivate variable with incomplete type 'S1'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for firstprivate(argv[1]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for linear(i) // expected-error {{unexpected OpenMP clause 'linear' in directive '#pragma omp for'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;                      // expected-note {{variable with automatic storage duration is predetermined as private; perhaps you forget to enclose 'omp for' directive into a parallel or another task region?}}
-#pragma omp for firstprivate(i) // expected-error {{private variable cannot be firstprivate}}
-    for (int k = 0; k < argc; ++k) {
-      i = k;
-      v += i;
-    }
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp for firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for firstprivate(i)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for lastprivate(g) firstprivate(g) // expected-error {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel private(i) // expected-note {{defined as private}}
-#pragma omp for firstprivate(i) // expected-error {{firstprivate variable must be shared}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel reduction(+ : i) // expected-note {{defined as reduction}}
-#pragma omp for firstprivate(i)       // expected-error {{firstprivate variable must be shared}}
-  for (i = 0; i < argc; ++i)
-    foo();
-  return 0;
-}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
 int main(int argc, char **argv) {
   const int d = 5;
-  const int da[5] = {0};
+  const int da[5] = { 0 };
   S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note 2 {{'g' defined here}}
-  S3 m;
-  S6 n(2);
+  S5 g(5); // expected-note {{'g' defined here}}
+  S6 p;
   int i;
   int &j = i; // expected-note {{'j' defined here}}
-#pragma omp parallel
-#pragma omp for firstprivate // expected-error {{expected '(' after 'firstprivate'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate() // expected-error {{expected expression}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(argc)
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(argv[1]) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(2 * 2) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(ba) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(ca) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(da) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-  int xa;
-#pragma omp parallel
-#pragma omp for firstprivate(xa) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(S2::S2s) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(S2::S2sc) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for safelen(5) // expected-error {{unexpected OpenMP clause 'safelen' in directive '#pragma omp for'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(m) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for private(xa), firstprivate(xa) // expected-error {{private variable cannot be firstprivate}} expected-note {{defined as private}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(i) // expected-note {{defined as firstprivate}}
-  for (i = 0; i < argc; ++i)    // expected-error {{loop iteration variable in the associated loop of 'omp for' directive may not be firstprivate, predetermined as private}}
-    foo();
-#pragma omp parallel shared(xa)
-#pragma omp for firstprivate(xa) // OK: may be firstprivate
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(g) firstprivate(g) // expected-error {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(n) firstprivate(n) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;                      // expected-note {{variable with automatic storage duration is predetermined as private; perhaps you forget to enclose 'omp for' directive into a parallel or another task region?}}
-#pragma omp for firstprivate(i) // expected-error {{private variable cannot be firstprivate}}
-    for (int k = 0; k < argc; ++k) {
-      i = k;
-      v += i;
-    }
-  }
-#pragma omp parallel private(i) // expected-note {{defined as private}}
-#pragma omp for firstprivate(i) // expected-error {{firstprivate variable must be shared}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel reduction(+ : i) // expected-note {{defined as reduction}}
-#pragma omp for firstprivate(i)       // expected-error {{firstprivate variable must be shared}}
-  for (i = 0; i < argc; ++i)
-    foo();
+  #pragma omp for firstprivate // expected-error {{expected '(' after 'firstprivate'}} expected-error {{expected expression}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp for firstprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp for firstprivate () // expected-error {{expected expression}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate (argc)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate (S1) // expected-error {{'S1' does not refer to a value}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate (a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate (argv[1]) // expected-error {{expected variable name}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate(ba)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate(ca)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate(da)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate(S2::S2s)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate(S2::S2sc)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate(p),firstprivate(e, g, p) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for private(i), firstprivate(i) // expected-error {{private variable cannot be firstprivate}} expected-note{{defined as private}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel shared(i)
+  #pragma omp for firstprivate(i)
+  for (j = 0; j < argc; ++j) foo();
+  #pragma omp parallel shared(i)
+  #pragma omp for firstprivate(i) // expected-note {{defined as firstprivate}}
+  for (i = 0; i < argc; ++i) foo(); // expected-error {{loop iteration variable may not be firstprivate}}
+  #pragma omp parallel private(i) // expected-note {{defined as private}}
+  #pragma omp for firstprivate(i) // expected-error {{private variable in '#pragma omp parallel' cannot be firstprivate in '#pragma omp for'}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel reduction(+:i) // expected-note {{defined as reduction}}
+  #pragma omp for firstprivate(i) // expected-error {{reduction variable in '#pragma omp parallel' cannot be firstprivate in '#pragma omp for'}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
+  for (i = 0; i < argc; ++i) foo();
 
-  return foomain<S4, S5>(argc, argv); // expected-note {{in instantiation of function template specialization 'foomain<S4, S5>' requested here}}
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/for_lastprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/for_lastprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/for_lastprivate_messages.cpp	2014-06-19 05:13:45.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/for_lastprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,260 +7,127 @@
   return argc;
 }
 
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
-
 public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-  static float S2s; // expected-note {{static data member is predetermined as shared}}
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note {{predetermined as shared}}
   static const float S2sc;
 };
-const float S2::S2sc = 0; // expected-note {{static data member is predetermined as shared}}
+const float S2::S2sc = 0; // expected-note {{predetermined as shared}}
 const S2 b;
 const S2 ba[5];
-class S3 { // expected-note 2 {{'S3' declared here}}
+class S3 { // expected-note {{'S3' declared here}}
   int a;
-  S3 &operator=(const S3 &s3);
-
+  S3& operator =(const S3& s3);
 public:
-  S3() : a(0) {}
-  S3(S3 &s3) : a(s3.a) {}
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
 };
-const S3 c;         // expected-note {{global variable is predetermined as shared}}
-const S3 ca[5];     // expected-note {{global variable is predetermined as shared}}
-extern const int f; // expected-note {{global variable is predetermined as shared}}
-class S4 {          // expected-note 3 {{'S4' declared here}}
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f; // expected-note {{predetermined as shared}}
+class S4 { // expected-note 2 {{'S4' declared here}}
   int a;
   S4();
   S4(const S4 &s4);
-
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
 class S5 { // expected-note {{'S5' declared here}}
   int a;
-  S5() : a(0) {}
-
-public:
-  S5(const S5 &s5) : a(s5.a) {}
-  S5(int v) : a(v) {}
-};
-class S6 {
-  int a;
-  S6() : a(0) {}
-
+  S5():a(0) {}
 public:
-  S6(const S6 &s6) : a(s6.a) {}
-  S6(int v) : a(v) {}
+  S5(const S5 &s5):a(s5.a) { }
+  S5(int v):a(v) { }
 };
 
 S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class I, class C>
-int foomain(int argc, char **argv) {
-  I e(4); // expected-note {{'e' defined here}}
-  I g(5); // expected-note {{'g' defined here}}
-  int i;
-  int &j = i; // expected-note {{'j' defined here}}
-#pragma omp parallel
-#pragma omp for lastprivate // expected-error {{expected '(' after 'lastprivate'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for lastprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for lastprivate() // expected-error {{expected expression}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for lastprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for lastprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for lastprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for lastprivate(argc)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for lastprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for lastprivate(a, b) // expected-error {{lastprivate variable with incomplete type 'S1'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for lastprivate(argv[1]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for lastprivate(e, g) // expected-error 2 {{lastprivate variable must have an accessible, unambiguous default constructor}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for lastprivate(h) // expected-error {{threadprivate or thread local variable cannot be lastprivate}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for linear(i) // expected-error {{unexpected OpenMP clause 'linear' in directive '#pragma omp for'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;                     // expected-note {{variable with automatic storage duration is predetermined as private; perhaps you forget to enclose 'omp for' directive into a parallel or another task region?}}
-#pragma omp for lastprivate(i) // expected-error {{lastprivate variable must be shared}}
-    for (int k = 0; k < argc; ++k) {
-      i = k;
-      v += i;
-    }
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp for lastprivate(j) // expected-error {{arguments of OpenMP clause 'lastprivate' cannot be of reference type}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-#pragma omp for lastprivate(i)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-  return 0;
-}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
 int main(int argc, char **argv) {
-  const int d = 5;       // expected-note {{constant variable is predetermined as shared}}
-  const int da[5] = {0}; // expected-note {{constant variable is predetermined as shared}}
-  S4 e(4);               // expected-note {{'e' defined here}}
-  S5 g(5);               // expected-note {{'g' defined here}}
-  S3 m;                  // expected-note 2 {{'m' defined here}}
-  S6 n(2);
+  const int d = 5; // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
+  S4 e(4); // expected-note 2 {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  S3 m; // expected-note {{'m' defined here}}
   int i;
   int &j = i; // expected-note {{'j' defined here}}
-#pragma omp parallel
-#pragma omp for lastprivate // expected-error {{expected '(' after 'lastprivate'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate() // expected-error {{expected expression}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(argc)
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(a, b, c, d, f) // expected-error {{lastprivate variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(argv[1]) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(2 * 2) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(ba)
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(ca) // expected-error {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(da) // expected-error {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-  int xa;
-#pragma omp parallel
-#pragma omp for lastprivate(xa) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(S2::S2s) // expected-error {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(S2::S2sc) // expected-error {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for safelen(5) // expected-error {{unexpected OpenMP clause 'safelen' in directive '#pragma omp for'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(e, g) // expected-error 2 {{lastprivate variable must have an accessible, unambiguous default constructor}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(m) // expected-error {{lastprivate variable must have an accessible, unambiguous copy assignment operator}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(h) // expected-error {{threadprivate or thread local variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for private(xa), lastprivate(xa) // expected-error {{private variable cannot be lastprivate}} expected-note {{defined as private}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(i)
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel private(xa) // expected-note {{defined as private}}
-#pragma omp for lastprivate(xa)  // expected-error {{lastprivate variable must be shared}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel reduction(+ : xa) // expected-note {{defined as reduction}}
-#pragma omp for lastprivate(xa)        // expected-error {{lastprivate variable must be shared}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(j) // expected-error {{arguments of OpenMP clause 'lastprivate' cannot be of reference type}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for firstprivate(m) lastprivate(m) // expected-error {{lastprivate variable must have an accessible, unambiguous copy assignment operator}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for lastprivate(n) firstprivate(n) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-  return foomain<S4, S5>(argc, argv); // expected-note {{in instantiation of function template specialization 'foomain<S4, S5>' requested here}}
+  #pragma omp parallel
+  #pragma omp for lastprivate // expected-error {{expected '(' after 'lastprivate'}} expected-error {{expected expression}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate () // expected-error {{expected expression}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate (argc)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate (S1) // expected-error {{'S1' does not refer to a value}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate (a, b, c, d, f) // expected-error {{lastprivate variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be lastprivate}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate (argv[1]) // expected-error {{expected variable name}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate(ba)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate(ca) // expected-error {{shared variable cannot be lastprivate}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate(da) // expected-error {{shared variable cannot be lastprivate}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate(S2::S2s) // expected-error {{shared variable cannot be lastprivate}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate(S2::S2sc) // expected-error {{shared variable cannot be lastprivate}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for firstprivate (g), lastprivate(e, g) // expected-error {{lastprivate variable must have an accessible, unambiguous default constructor}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate(e, g) // expected-error 2 {{lastprivate variable must have an accessible, unambiguous default constructor}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate(m) // expected-error {{lastprivate variable must have an accessible, unambiguous copy assignment operator}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate(h) // expected-error {{threadprivate or thread local variable cannot be lastprivate}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for private(i), lastprivate(i) // expected-error {{private variable cannot be lastprivate}} expected-note{{defined as private}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel shared(i)
+  #pragma omp for lastprivate(i)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel private(i) // expected-note {{defined as private}}
+  #pragma omp for lastprivate(i) // expected-error {{private variable in '#pragma omp parallel' cannot be lastprivate in '#pragma omp for'}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel reduction(+:i) // expected-note {{defined as reduction}}
+  #pragma omp for lastprivate(i) // expected-error {{reduction variable in '#pragma omp parallel' cannot be lastprivate in '#pragma omp for'}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for lastprivate(j) // expected-error {{arguments of OpenMP clause 'lastprivate' cannot be of reference type}}
+  for (i = 0; i < argc; ++i) foo();
+
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/for_loop_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/for_loop_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/for_loop_messages.cpp	2014-07-20 22:45:36.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/for_loop_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,694 +1,203 @@
-// RUN: %clang_cc1 -fsyntax-only -fopenmp=libiomp5 -x c++ -std=c++11 -fexceptions -fcxx-exceptions -verify %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
-class S {
-  int a;
-  S() : a(0) {}
-
-public:
-  S(int v) : a(v) {}
-  S(const S &s) : a(s.a) {}
-};
-
-static int sii;
-#pragma omp threadprivate(sii) // expected-note {{defined as threadprivate or thread local}}
-
-int test_iteration_spaces() {
-  const int N = 100;
-  float a[N], b[N], c[N];
-  int ii, jj, kk;
-  float fii;
-  double dii;
-#pragma omp parallel
-#pragma omp for
-  for (int i = 0; i < 10; i += 1) {
-    c[i] = a[i] + b[i];
-  }
-#pragma omp parallel
-#pragma omp for
-  for (char i = 0; i < 10; i++) {
-    c[i] = a[i] + b[i];
-  }
-#pragma omp parallel
-#pragma omp for
-  for (char i = 0; i < 10; i += '\1') {
-    c[i] = a[i] + b[i];
-  }
-#pragma omp parallel
-#pragma omp for
-  for (long long i = 0; i < 10; i++) {
-    c[i] = a[i] + b[i];
-  }
-#pragma omp parallel
-// expected-error@+2 {{expression must have integral or unscoped enumeration type, not 'double'}}
-#pragma omp for
-  for (long long i = 0; i < 10; i += 1.5) {
-    c[i] = a[i] + b[i];
-  }
-#pragma omp parallel
-#pragma omp for
-  for (long long i = 0; i < 'z'; i += 1u) {
-    c[i] = a[i] + b[i];
-  }
-#pragma omp parallel
-// expected-error@+2 {{variable must be of integer or random access iterator type}}
-#pragma omp for
-  for (float fi = 0; fi < 10.0; fi++) {
-    c[(int)fi] = a[(int)fi] + b[(int)fi];
-  }
-#pragma omp parallel
-// expected-error@+2 {{variable must be of integer or random access iterator type}}
-#pragma omp for
-  for (double fi = 0; fi < 10.0; fi++) {
-    c[(int)fi] = a[(int)fi] + b[(int)fi];
-  }
-#pragma omp parallel
-// expected-error@+2 {{variable must be of integer or random access iterator type}}
-#pragma omp for
-  for (int &ref = ii; ref < 10; ref++) {
-  }
-#pragma omp parallel
-// expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-#pragma omp for
-  for (int i; i < 10; i++)
-    c[i] = a[i];
-
-#pragma omp parallel
-// expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-#pragma omp for
-  for (int i = 0, j = 0; i < 10; ++i)
-    c[i] = a[i];
-
-#pragma omp parallel
-// expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-#pragma omp for
-  for (; ii < 10; ++ii)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-warning@+3 {{expression result unused}}
-// expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-#pragma omp for
-  for (ii + 1; ii < 10; ++ii)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-#pragma omp for
-  for (c[ii] = 0; ii < 10; ++ii)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// Ok to skip parenthesises.
-#pragma omp for
-  for (((ii)) = 0; ii < 10; ++ii)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-#pragma omp for
-  for (int i = 0; i; i++)
-    c[i] = a[i];
-
-#pragma omp parallel
-// expected-error@+3 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'i'}}
-#pragma omp for
-  for (int i = 0; jj < kk; ii++)
-    c[i] = a[i];
-
-#pragma omp parallel
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-#pragma omp for
-  for (int i = 0; !!i; i++)
-    c[i] = a[i];
-
-#pragma omp parallel
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-#pragma omp for
-  for (int i = 0; i != 1; i++)
-    c[i] = a[i];
-
-#pragma omp parallel
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-#pragma omp for
-  for (int i = 0;; i++)
-    c[i] = a[i];
-
-#pragma omp parallel
-// Ok.
-#pragma omp for
-  for (int i = 11; i > 10; i--)
-    c[i] = a[i];
-
-#pragma omp parallel
-// Ok.
-#pragma omp for
-  for (int i = 0; i < 10; ++i)
-    c[i] = a[i];
-
-#pragma omp parallel
-// Ok.
-#pragma omp for
-  for (ii = 0; ii < 10; ++ii)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp for
-  for (ii = 0; ii < 10; ++jj)
-    c[ii] = a[jj];
-
-#pragma omp parallel
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp for
-  for (ii = 0; ii < 10; ++++ii)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// Ok but undefined behavior (in general, cannot check that incr
-// is really loop-invariant).
-#pragma omp for
-  for (ii = 0; ii < 10; ii = ii + ii)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-error@+2 {{expression must have integral or unscoped enumeration type, not 'float'}}
-#pragma omp for
-  for (ii = 0; ii < 10; ii = ii + 1.0f)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// Ok - step was converted to integer type.
-#pragma omp for
-  for (ii = 0; ii < 10; ii = ii + (int)1.1f)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp for
-  for (ii = 0; ii < 10; jj = ii + 2)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-warning@+3 {{relational comparison result unused}}
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp for
-  for (ii = 0; ii<10; jj> kk + 2)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp for
-  for (ii = 0; ii < 10;)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-warning@+3 {{expression result unused}}
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp for
-  for (ii = 0; ii < 10; !ii)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp for
-  for (ii = 0; ii < 10; ii ? ++ii : ++jj)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp for
-  for (ii = 0; ii < 10; ii = ii < 10)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (ii = 0; ii < 10; ii = ii + 0)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (ii = 0; ii < 10; ii = ii + (int)(0.8 - 0.45))
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (ii = 0; (ii) < 10; ii -= 25)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (ii = 0; (ii < 10); ii -= 0)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to decrease on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (ii = 0; ii > 10; (ii += 0))
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (ii = 0; ii < 10; (ii) = (1 - 1) + (ii))
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to decrease on each iteration of OpenMP for loop}}
-#pragma omp for
-  for ((ii = 0); ii > 10; (ii -= 0))
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (ii = 0; (ii < 10); (ii -= 0))
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-note@+2  {{defined as firstprivate}}
-// expected-error@+2 {{loop iteration variable in the associated loop of 'omp for' directive may not be firstprivate, predetermined as private}}
-#pragma omp for firstprivate(ii)
-  for (ii = 0; ii < 10; ii++)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-// expected-error@+3 {{unexpected OpenMP clause 'linear' in directive '#pragma omp for'}}
-// expected-note@+2  {{defined as linear}}
-// expected-error@+2 {{loop iteration variable in the associated loop of 'omp for' directive may not be linear, predetermined as private}}
-#pragma omp for linear(ii)
-  for (ii = 0; ii < 10; ii++)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-#pragma omp for private(ii)
-  for (ii = 0; ii < 10; ii++)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-#pragma omp for lastprivate(ii)
-  for (ii = 0; ii < 10; ii++)
-    c[ii] = a[ii];
-
-#pragma omp parallel
-  {
-// expected-error@+2 {{loop iteration variable in the associated loop of 'omp for' directive may not be threadprivate or thread local, predetermined as private}}
-#pragma omp for
-    for (sii = 0; sii < 10; sii += 1)
-      c[sii] = a[sii];
-  }
-
-#pragma omp parallel
-// expected-error@+2 {{statement after '#pragma omp for' must be a for loop}}
-#pragma omp for
-  for (auto &item : a) {
-    item = item + 1;
-  }
-
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'i' to increase on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (unsigned i = 9; i < 10; i--) {
-    c[i] = a[i] + b[i];
-  }
-
-  int(*lb)[4] = nullptr;
-#pragma omp parallel
-#pragma omp for
-  for (int(*p)[4] = lb; p < lb + 8; ++p) {
-  }
-
-#pragma omp parallel
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp for
-  for (int a{0}; a < 10; ++a) {
-  }
+namespace std {
 
-  return 0;
-}
+struct random_access_iterator_tag { };
 
-// Iterators allowed in openmp for-loops.
-namespace std {
-struct random_access_iterator_tag {};
 template <class Iter>
 struct iterator_traits {
-  typedef typename Iter::difference_type difference_type;
-  typedef typename Iter::iterator_category iterator_category;
+  typedef typename Iter::difference_type difference_type; // expected-error {{no type named 'difference_type' in 'Iter'}} expected-error {{no type named 'difference_type' in 'Iter1'}}
+  typedef typename Iter::iterator_category iterator_category; // expected-error {{no type named 'iterator_category' in 'Iter'}} expected-error {{no type named 'iterator_category' in 'Iter1'}} expected-error {{no type named 'iterator_category' in 'Iter2'}}
 };
+
 template <class Iter>
-typename iterator_traits<Iter>::difference_type
-distance(Iter first, Iter last) { return first - last; }
+typename iterator_traits<Iter>::difference_type distance(Iter first, Iter last) {
+  return first - last;
 }
-class Iter0 {
-public:
-  Iter0() {}
-  Iter0(const Iter0 &) {}
-  Iter0 operator++() { return *this; }
-  Iter0 operator--() { return *this; }
-  bool operator<(Iter0 a) { return true; }
-};
-int operator-(Iter0 a, Iter0 b) { return 0; }
-class Iter1 {
-public:
-  Iter1(float f = 0.0f, double d = 0.0) {}
-  Iter1(const Iter1 &) {}
-  Iter1 operator++() { return *this; }
-  Iter1 operator--() { return *this; }
-  bool operator<(Iter1 a) { return true; }
-  bool operator>=(Iter1 a) { return false; }
-};
-class GoodIter {
-public:
-  GoodIter() {}
-  GoodIter(const GoodIter &) {}
-  GoodIter(int fst, int snd) {}
-  GoodIter &operator=(const GoodIter &that) { return *this; }
-  GoodIter &operator=(const Iter0 &that) { return *this; }
-  GoodIter &operator+=(int x) { return *this; }
-  explicit GoodIter(void *) {}
-  GoodIter operator++() { return *this; }
-  GoodIter operator--() { return *this; }
-  bool operator!() { return true; }
-  bool operator<(GoodIter a) { return true; }
-  bool operator<=(GoodIter a) { return true; }
-  bool operator>=(GoodIter a) { return false; }
-  typedef int difference_type;
-  typedef std::random_access_iterator_tag iterator_category;
-};
-int operator-(GoodIter a, GoodIter b) { return 0; }
-GoodIter operator-(GoodIter a) { return a; }
-GoodIter operator-(GoodIter a, int v) { return GoodIter(); }
-GoodIter operator+(GoodIter a, int v) { return GoodIter(); }
-GoodIter operator-(int v, GoodIter a) { return GoodIter(); }
-GoodIter operator+(int v, GoodIter a) { return GoodIter(); }
-
-int test_with_random_access_iterator() {
-  GoodIter begin, end;
-  Iter0 begin0, end0;
-#pragma omp parallel
-#pragma omp for
-  for (GoodIter I = begin; I < end; ++I)
-    ++I;
-#pragma omp parallel
-// expected-error@+2 {{variable must be of integer or random access iterator type}}
-#pragma omp for
-  for (GoodIter &I = begin; I < end; ++I)
-    ++I;
-#pragma omp parallel
-#pragma omp for
-  for (GoodIter I = begin; I >= end; --I)
-    ++I;
-#pragma omp parallel
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp for
-  for (GoodIter I(begin); I < end; ++I)
-    ++I;
-#pragma omp parallel
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp for
-  for (GoodIter I(nullptr); I < end; ++I)
-    ++I;
-#pragma omp parallel
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp for
-  for (GoodIter I(0); I < end; ++I)
-    ++I;
-#pragma omp parallel
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp for
-  for (GoodIter I(1, 2); I < end; ++I)
-    ++I;
-#pragma omp parallel
-#pragma omp for
-  for (begin = GoodIter(0); begin < end; ++begin)
-    ++begin;
-#pragma omp parallel
-#pragma omp for
-  for (begin = begin0; begin < end; ++begin)
-    ++begin;
-#pragma omp parallel
-// expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-#pragma omp for
-  for (++begin; begin < end; ++begin)
-    ++begin;
-#pragma omp parallel
-#pragma omp for
-  for (begin = end; begin < end; ++begin)
-    ++begin;
-#pragma omp parallel
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'I'}}
-#pragma omp for
-  for (GoodIter I = begin; I - I; ++I)
-    ++I;
-#pragma omp parallel
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'I'}}
-#pragma omp for
-  for (GoodIter I = begin; begin < end; ++I)
-    ++I;
-#pragma omp parallel
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'I'}}
-#pragma omp for
-  for (GoodIter I = begin; !I; ++I)
-    ++I;
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (GoodIter I = begin; I >= end; I = I + 1)
-    ++I;
-#pragma omp parallel
-#pragma omp for
-  for (GoodIter I = begin; I >= end; I = I - 1)
-    ++I;
-#pragma omp parallel
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'I'}}
-#pragma omp for
-  for (GoodIter I = begin; I >= end; I = -I)
-    ++I;
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (GoodIter I = begin; I >= end; I = 2 + I)
-    ++I;
-#pragma omp parallel
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'I'}}
-#pragma omp for
-  for (GoodIter I = begin; I >= end; I = 2 - I)
-    ++I;
-#pragma omp parallel
-#pragma omp for
-  for (Iter0 I = begin0; I < end0; ++I)
-    ++I;
-#pragma omp parallel
-// Initializer is constructor without params.
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp for
-  for (Iter0 I; I < end0; ++I)
-    ++I;
-  Iter1 begin1, end1;
-#pragma omp parallel
-#pragma omp for
-  for (Iter1 I = begin1; I < end1; ++I)
-    ++I;
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (Iter1 I = begin1; I >= end1; ++I)
-    ++I;
-#pragma omp parallel
-// Initializer is constructor with all default params.
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp for
-  for (Iter1 I; I < end1; ++I) {
-  }
-  return 0;
 }
 
-template <typename IT, int ST>
-class TC {
-public:
-  int dotest_lt(IT begin, IT end) {
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'I' to increase on each iteration of OpenMP for loop}}
-#pragma omp for
-    for (IT I = begin; I < end; I = I + ST) {
+class Iter {
+  public:
+    Iter() { }
+    Iter(const Iter &) { }
+    Iter operator ++() { return *this; }
+    Iter operator --() { return *this; }
+    bool operator <(Iter a) { return true; }
+    bool operator >=(Iter a) { return false; }
+};
+int operator -(Iter a, Iter b) { return 0; }
+class Iter1 {
+  public:
+    Iter1() { }
+    Iter1(const Iter1 &) { }
+    Iter1 operator ++() { return *this; }
+    Iter1 operator --() { return *this; }
+    bool operator <(Iter1 a) { return true; }
+    bool operator >=(Iter1 a) { return false; }
+};
+class Iter2 {
+  public:
+    Iter2() { }
+    Iter2(const Iter2 &) { }
+    Iter2 operator ++() { return *this; }
+    Iter2 operator --() { return *this; }
+    bool operator <(Iter2 a) { return true; }
+    bool operator >=(Iter2 a) { return false; }
+    typedef int difference_type;
+};
+int operator -(Iter2 a, Iter2 b) { return 0; }
+class Iter3 {
+  public:
+    Iter3() { }
+    Iter3(const Iter3 &) { }
+    Iter3 operator ++() { return *this; }
+    Iter3 operator --() { return *this; }
+    bool operator <(Iter3 a) { return true; }
+    bool operator >=(Iter3 a) { return false; }
+    typedef int difference_type;
+    typedef int iterator_category;
+};
+int operator -(Iter3 a, Iter3 b) { return 0; }
+class Iter4 {
+  public:
+    Iter4() { }
+    Iter4(const Iter4 &) { }
+    Iter4 operator ++() { return *this; }
+    Iter4 operator --() { return *this; }
+    bool operator <(Iter4 a) { return true; }
+    bool operator >=(Iter4 a) { return false; }
+    Iter4 operator+=(int) const {return Iter4();}
+    Iter4 operator-=(int) const {return Iter4();}
+    typedef int difference_type;
+    typedef std::random_access_iterator_tag iterator_category;
+};
+int operator -(Iter4 a, Iter4 b) { return 0; }
+
+int t;
+#pragma omp threadprivate(t)
+
+int main() {
+  #pragma omp for
+  for (int i = 0; i < 10; i++)
+    ++i;
+  #pragma omp for
+  for (t = 0; t < 10; t++)
+    ++t;
+  #pragma omp for
+  for (int i; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp for
+  for (float i = 0; i < 10.0f; i++) // expected-error {{variable must be of integer or random access iterator type}}
+    ++i;
+  #pragma omp for
+  for (int i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp for
+  for (int i = 0; i < 10; i |= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  int i;
+  #pragma omp for
+  for (i = 0; i < 10; i++)
+    ++i;
+  #pragma omp for
+  for (i--; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp for
+  for (i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp for
+  for (i = 0; i < 10; i ^= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  Iter begin, end;
+  #pragma omp for
+  for (Iter I = begin; I >= end; ++I) // expected-error {{increment expression must cause 'I' to decrease on each iteration of the loop}}
+    ++I;
+  #pragma omp for
+  for (Iter I = end; I < begin; --I) // expected-error {{increment expression must cause 'I' to increase on each iteration of the loop}}
+    ++I;
+  #pragma omp for
+  for (Iter I = begin; I < end; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter>' requested here}} expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp for
+  for (Iter I = end; I >= begin; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter1 begin1;
+  #pragma omp for
+  for (Iter1 I = begin1; I < begin1; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter1>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp for
+  for (Iter1 I = begin1; I >= begin1; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter2 begin2;
+  #pragma omp for
+  for (Iter2 I = begin2; I < begin2; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter2>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp for
+  for (Iter2 I = begin2; I >= begin2; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter3 begin3;
+  #pragma omp for
+  for (Iter3 I = begin3; I < begin3; ++I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp for
+  for (Iter3 I = begin3; I >= begin3; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter4 begin4;
+  #pragma omp for
+  for (Iter4 I = begin4; I < begin4; ++I)
+    ++I;
+  #pragma omp for
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  goto label; // expected-error {{use of undeclared label 'label'}}
+  #pragma omp for
+  for (int i = 0; i < 100; ++i) {
+    label: ++i;
+  }
+  #pragma omp for collapse(1)
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  #pragma omp for collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+  for (Iter4 I1 = begin4; I1 >= begin4; --I1)
+  for (Iter4 I2 = begin4; I2 >= begin4; --I2)
+    ++I;
+  #pragma omp for collapse(0) // expected-error {{expression is not a positive integer value}}
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  #pragma omp for
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp for // expected-error {{region cannot be closely nested inside a worksharing region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
       ++I;
-    }
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'I' to increase on each iteration of OpenMP for loop}}
-#pragma omp for
-    for (IT I = begin; I <= end; I += ST) {
+  #pragma omp single
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp for // expected-error {{region cannot be closely nested inside a worksharing region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
       ++I;
-    }
-#pragma omp parallel
-#pragma omp for
-    for (IT I = begin; I < end; ++I) {
+  #pragma omp sections
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp for // expected-error {{region cannot be closely nested inside a worksharing region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
       ++I;
-    }
-  }
-
-  static IT step() {
-    return IT(ST);
-  }
-};
-template <typename IT, int ST = 0>
-int dotest_gt(IT begin, IT end) {
-#pragma omp parallel
-// expected-note@+3 2 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (IT I = begin; I >= end; I = I + ST) {
-    ++I;
-  }
-#pragma omp parallel
-// expected-note@+3 2 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (IT I = begin; I >= end; I += ST) {
-    ++I;
-  }
-
-#pragma omp parallel
-// expected-note@+3 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-#pragma omp for
-  for (IT I = begin; I >= end; ++I) {
-    ++I;
-  }
-
-#pragma omp parallel
-#pragma omp for
-  for (IT I = begin; I < end; I += TC<int, ST>::step()) {
-    ++I;
-  }
-}
-
-void test_with_template() {
-  GoodIter begin, end;
-  TC<GoodIter, 100> t1;
-  TC<GoodIter, -100> t2;
-  t1.dotest_lt(begin, end);
-  t2.dotest_lt(begin, end);         // expected-note {{in instantiation of member function 'TC<GoodIter, -100>::dotest_lt' requested here}}
-  dotest_gt(begin, end);            // expected-note {{in instantiation of function template specialization 'dotest_gt<GoodIter, 0>' requested here}}
-  dotest_gt<unsigned, -10>(0, 100); // expected-note {{in instantiation of function template specialization 'dotest_gt<unsigned int, -10>' requested here}}
-}
-
-void test_loop_break() {
-  const int N = 100;
-  float a[N], b[N], c[N];
-#pragma omp parallel
-#pragma omp for
-  for (int i = 0; i < 10; i++) {
-    c[i] = a[i] + b[i];
-    for (int j = 0; j < 10; ++j) {
-      if (a[i] > b[j])
-        break; // OK in nested loop
-    }
-    switch (i) {
-    case 1:
-      b[i]++;
-      break;
-    default:
-      break;
-    }
-    if (c[i] > 10)
-      break; // expected-error {{'break' statement cannot be used in OpenMP for loop}}
-
-    if (c[i] > 11)
-      break; // expected-error {{'break' statement cannot be used in OpenMP for loop}}
-  }
-
-#pragma omp parallel
-#pragma omp for
-  for (int i = 0; i < 10; i++) {
-    for (int j = 0; j < 10; j++) {
-      c[i] = a[i] + b[i];
-      if (c[i] > 10) {
-        if (c[i] < 20) {
-          break; // OK
-        }
-      }
-    }
-  }
-}
-
-void test_loop_eh() {
-  const int N = 100;
-  float a[N], b[N], c[N];
-#pragma omp parallel
-#pragma omp for
-  for (int i = 0; i < 10; i++) {
-    c[i] = a[i] + b[i];
-    try {
-      for (int j = 0; j < 10; ++j) {
-        if (a[i] > b[j])
-          throw a[i];
-      }
-      throw a[i];
-    } catch (float f) {
-      if (f > 0.1)
-        throw a[i];
-      return; // expected-error {{cannot return from OpenMP region}}
-    }
-    switch (i) {
-    case 1:
-      b[i]++;
-      break;
-    default:
-      break;
-    }
-    for (int j = 0; j < 10; j++) {
-      if (c[i] > 10)
-        throw c[i];
-    }
-  }
-  if (c[9] > 10)
-    throw c[9]; // OK
-
-#pragma omp parallel
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-    struct S {
-      void g() { throw 0; }
-    };
-  }
-}
-
-void test_loop_firstprivate_lastprivate() {
-  S s(4);
-#pragma omp parallel
-#pragma omp for lastprivate(s) firstprivate(s)
-  for (int i = 0; i < 16; ++i)
-    ;
-}
-
-void test_ordered() {
-#pragma omp parallel
-#pragma omp for ordered ordered // expected-error {{directive '#pragma omp for' cannot contain more than one 'ordered' clause}}
-  for (int i = 0; i < 16; ++i)
-    ;
-}
-
-void test_nowait() {
-#pragma omp parallel
-#pragma omp for nowait nowait // expected-error {{directive '#pragma omp for' cannot contain more than one 'nowait' clause}}
-  for (int i = 0; i < 16; ++i)
-    ;
+  #pragma omp master
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp for // expected-error {{region cannot be closely nested inside a master region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp critical
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp for // expected-error {{region cannot be closely nested inside a critical region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp for ordered
+  for (Iter4 I = begin4; I >= begin4; --I)
+  #pragma omp ordered
+    #pragma omp for // expected-error {{region cannot be closely nested inside an ordered region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp for collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I; // expected-error {{only for-loops are allowed for '#pragma omp for'}}
+  ++begin4; 
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/for_loop_messages1.cpp cfe-3.5.0.src.omp/test/OpenMP/for_loop_messages1.cpp
--- cfe-3.5.0.src/test/OpenMP/for_loop_messages1.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/for_loop_messages1.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,10 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int main() {
+  int i;
+  goto label; // expected-error {{use of undeclared label 'label'}}
+  #pragma omp for
+  for (i = 0; i < 100; ++i) {
+    label: ++i;
+  }
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/for_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/for_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/for_misc_messages.c	2014-06-24 08:55:56.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/for_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,363 +0,0 @@
-// RUN: %clang_cc1 -fsyntax-only -fopenmp=libiomp5 -verify %s
-
-// expected-error@+1 {{unexpected OpenMP directive '#pragma omp for'}}
-#pragma omp for
-
-// expected-error@+1 {{unexpected OpenMP directive '#pragma omp for'}}
-#pragma omp for foo
-
-void test_no_clause() {
-  int i;
-#pragma omp for
-  for (i = 0; i < 16; ++i)
-    ;
-
-// expected-error@+2 {{statement after '#pragma omp for' must be a for loop}}
-#pragma omp for
-  ++i;
-}
-
-void test_branch_protected_scope() {
-  int i = 0;
-L1:
-  ++i;
-
-  int x[24];
-
-#pragma omp parallel
-#pragma omp for
-  for (i = 0; i < 16; ++i) {
-    if (i == 5)
-      goto L1; // expected-error {{use of undeclared label 'L1'}}
-    else if (i == 6)
-      return; // expected-error {{cannot return from OpenMP region}}
-    else if (i == 7)
-      goto L2;
-    else if (i == 8) {
-    L2:
-      x[i]++;
-    }
-  }
-
-  if (x[0] == 0)
-    goto L2; // expected-error {{use of undeclared label 'L2'}}
-  else if (x[1] == 1)
-    goto L1;
-}
-
-void test_invalid_clause() {
-  int i;
-#pragma omp parallel
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp for' are ignored}}
-#pragma omp for foo bar
-  for (i = 0; i < 16; ++i)
-    ;
-}
-
-void test_non_identifiers() {
-  int i, x;
-
-#pragma omp parallel
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp for' are ignored}}
-#pragma omp for;
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+2 {{unexpected OpenMP clause 'linear' in directive '#pragma omp for'}}
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp for' are ignored}}
-#pragma omp for linear(x);
-  for (i = 0; i < 16; ++i)
-    ;
-
-#pragma omp parallel
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp for' are ignored}}
-#pragma omp for private(x);
-  for (i = 0; i < 16; ++i)
-    ;
-
-#pragma omp parallel
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp for' are ignored}}
-#pragma omp for, private(x);
-  for (i = 0; i < 16; ++i)
-    ;
-}
-
-extern int foo();
-
-void test_collapse() {
-  int i;
-#pragma omp parallel
-// expected-error@+1 {{expected '('}}
-#pragma omp for collapse
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-#pragma omp for collapse(
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp for collapse()
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-#pragma omp for collapse(,
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}  expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-#pragma omp for collapse(, )
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-warning@+2 {{extra tokens at the end of '#pragma omp for' are ignored}}
-// expected-error@+1 {{expected '('}}
-#pragma omp for collapse 4)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}}
-// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp for collapse(4
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}}
-// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp for collapse(4,
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}}
-// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp for collapse(4, )
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
-#pragma omp parallel
-// expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp for collapse(4)
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}}
-// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp for collapse(4 4)
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}}
-// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp for collapse(4, , 4)
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
-#pragma omp parallel
-#pragma omp for collapse(4)
-  for (int i1 = 0; i1 < 16; ++i1)
-    for (int i2 = 0; i2 < 16; ++i2)
-      for (int i3 = 0; i3 < 16; ++i3)
-        for (int i4 = 0; i4 < 16; ++i4)
-          foo();
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}}
-// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp for collapse(4, 8)
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
-#pragma omp parallel
-// expected-error@+1 {{expression is not an integer constant expression}}
-#pragma omp for collapse(2.5)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expression is not an integer constant expression}}
-#pragma omp for collapse(foo())
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{argument to 'collapse' clause must be a positive integer value}}
-#pragma omp for collapse(-5)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{argument to 'collapse' clause must be a positive integer value}}
-#pragma omp for collapse(0)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{argument to 'collapse' clause must be a positive integer value}}
-#pragma omp for collapse(5 - 5)
-  for (i = 0; i < 16; ++i)
-    ;
-}
-
-void test_private() {
-  int i;
-#pragma omp parallel
-// expected-error@+2 {{expected expression}}
-// expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-#pragma omp for private(
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp for private(,
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 2 {{expected expression}}
-#pragma omp for private(, )
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp for private()
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp for private(int)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expected variable name}}
-#pragma omp for private(0)
-  for (i = 0; i < 16; ++i)
-    ;
-
-  int x, y, z;
-#pragma omp parallel
-#pragma omp for private(x)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-#pragma omp for private(x, y)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-#pragma omp for private(x, y, z)
-  for (i = 0; i < 16; ++i) {
-    x = y * i + z;
-  }
-}
-
-void test_lastprivate() {
-  int i;
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 {{expected expression}}
-#pragma omp for lastprivate(
-  for (i = 0; i < 16; ++i)
-    ;
-
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp for lastprivate(,
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 2 {{expected expression}}
-#pragma omp for lastprivate(, )
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp for lastprivate()
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp for lastprivate(int)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expected variable name}}
-#pragma omp for lastprivate(0)
-  for (i = 0; i < 16; ++i)
-    ;
-
-  int x, y, z;
-#pragma omp parallel
-#pragma omp for lastprivate(x)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-#pragma omp for lastprivate(x, y)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-#pragma omp for lastprivate(x, y, z)
-  for (i = 0; i < 16; ++i)
-    ;
-}
-
-void test_firstprivate() {
-  int i;
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 {{expected expression}}
-#pragma omp for firstprivate(
-  for (i = 0; i < 16; ++i)
-    ;
-
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp for firstprivate(,
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 2 {{expected expression}}
-#pragma omp for firstprivate(, )
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp for firstprivate()
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp for firstprivate(int)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-// expected-error@+1 {{expected variable name}}
-#pragma omp for firstprivate(0)
-  for (i = 0; i < 16; ++i)
-    ;
-
-  int x, y, z;
-#pragma omp parallel
-#pragma omp for lastprivate(x) firstprivate(x)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-#pragma omp for lastprivate(x, y) firstprivate(x, y)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel
-#pragma omp for lastprivate(x, y, z) firstprivate(x, y, z)
-  for (i = 0; i < 16; ++i)
-    ;
-}
-
-void test_loop_messages() {
-  float a[100], b[100], c[100];
-#pragma omp parallel
-// expected-error@+2 {{variable must be of integer or pointer type}}
-#pragma omp for
-  for (float fi = 0; fi < 10.0; fi++) {
-    c[(int)fi] = a[(int)fi] + b[(int)fi];
-  }
-#pragma omp parallel
-// expected-error@+2 {{variable must be of integer or pointer type}}
-#pragma omp for
-  for (double fi = 0; fi < 10.0; fi++) {
-    c[(int)fi] = a[(int)fi] + b[(int)fi];
-  }
-}
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/for_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/for_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/for_private_messages.cpp	2014-06-19 05:13:45.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/for_private_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,167 +7,124 @@
   return argc;
 }
 
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
-
 public:
-  S2() : a(0) {}
+  S2():a(0) { }
+  static float S2s; // expected-note {{predetermined as shared}}
 };
 const S2 b;
 const S2 ba[5];
 class S3 {
   int a;
-
 public:
-  S3() : a(0) {}
+  S3():a(0) { }
 };
-const S3 ca[5];
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f;  // expected-note {{predetermined as shared}}
 class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
-
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
 class S5 { // expected-note {{'S5' declared here}}
   int a;
-  S5() : a(0) {}
-
+  S5():a(0) {}
 public:
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
 };
 
 S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class I, class C>
-int foomain(I argc, C **argv) {
-  I e(4);
-  I g(5);
-  int i;
-  int &j = i;           // expected-note {{'j' defined here}}
-#pragma omp for private // expected-error {{expected '(' after 'private'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private() // expected-error {{expected expression}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(argc)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(S1) // expected-error {{'S1' does not refer to a value}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(a, b) // expected-error {{private variable with incomplete type 'S1'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(argv[1]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(e, g)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for shared(i) // expected-error {{unexpected OpenMP clause 'shared' in directive '#pragma omp for'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;
-#pragma omp for private(i)
-    for (int k = 0; k < argc; ++k) {
-      i = k;
-      v += i;
-    }
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp for private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(i)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-  return 0;
-}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
 int main(int argc, char **argv) {
+  const int d = 5;  // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
   S4 e(4); // expected-note {{'e' defined here}}
   S5 g(5); // expected-note {{'g' defined here}}
   int i;
-  int &j = i;           // expected-note {{'j' defined here}}
-#pragma omp for private // expected-error {{expected '(' after 'private'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private() // expected-error {{expected expression}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(argc)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(S1) // expected-error {{'S1' does not refer to a value}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(a, b) // expected-error {{private variable with incomplete type 'S1'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(argv[1]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for shared(i) // expected-error {{unexpected OpenMP clause 'shared' in directive '#pragma omp for'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp for private // expected-error {{expected '(' after 'private'}} expected-error {{expected expression}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private () // expected-error {{expected expression}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private (argc)
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private (a, b, c, d, f) // expected-error {{private variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be private}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private (argv[1]) // expected-error {{expected variable name}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private(ba)
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private(ca) // expected-error {{shared variable cannot be private}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private(da) // expected-error {{shared variable cannot be private}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private(S2::S2s) // expected-error {{shared variable cannot be private}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for shared(i) // expected-error {{unexpected OpenMP clause 'shared' in directive '#pragma omp for'}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp parallel
   {
-    int i;
-#pragma omp for private(i)
-    for (int k = 0; k < argc; ++k)
-      ++k;
+    int i; // expected-note {{predetermined as private}}
+    #pragma omp for firstprivate(i), private(i) // expected-error {{private variable cannot be firstprivate}}
+    for (int k = 0; k < argc; ++k) ++k;
+  }
+  #pragma omp parallel shared(i)
+  #pragma omp parallel private(i)
+  #pragma omp for private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp parallel private(i)
+  #pragma omp parallel firstprivate(i)
+  #pragma omp parallel private(i)
+  #pragma omp parallel reduction(+:i)
+  #pragma omp for private(i)
+  for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel private(i)
+    #pragma omp for private(i)
+    for (int x = 0; x < 10; ++x) foo();
+  }
+  #pragma omp parallel
+  #pragma omp for firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel firstprivate(i)
+    #pragma omp for private(i)
+    for (int x = 0; x < 10; ++x) foo();
+  }
+  #pragma omp parallel
+  #pragma omp for reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel reduction(+:i)
+    #pragma omp for private(i)
+    for (int x = 0; x < 10; ++x) foo();
+  }
+  #pragma omp parallel
+  #pragma omp for lastprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel
+    #pragma omp for private(i)
+    for (int x = 0; x < 10; ++x) foo();
   }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp for private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp for private(i)
-  for (int k = 0; k < argc; ++k)
-    ++k;
 
   return 0;
 }
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/for_reduction_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/for_reduction_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/for_reduction_messages.cpp	2014-06-19 05:13:45.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/for_reduction_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,344 +7,158 @@
   return argc;
 }
 
-struct S1; // expected-note {{declared here}} expected-note 4 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
-  S2 &operator+=(const S2 &arg) { return (*this); }
-
+  S2 &operator +=(const S2 &arg) {return (*this);} // expected-note {{implicitly declared private here}}
 public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-  static float S2s; // expected-note 2 {{static data member is predetermined as shared}}
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; //expected-note {{predetermined as shared}}
   static const float S2sc;
 };
-const float S2::S2sc = 0; // expected-note 2 {{'S2sc' defined here}}
-S2 b;                     // expected-note 2 {{'b' defined here}}
-const S2 ba[5];           // expected-note 2 {{'ba' defined here}}
+const float S2::S2sc = 0; // expected-note {{'S2sc' defined here}}
+S2 b; // expected-note {{'b' defined here}}
+const S2 ba[5]; // expected-note {{'ba' defined here}}
 class S3 {
   int a;
-
 public:
-  S3() : a(0) {}
-  S3(const S3 &s3) : a(s3.a) {}
-  S3 operator+=(const S3 &arg1) { return arg1; }
+  S3():a(0) { }
+  S3(const S3 &s3):a(s3.a) { }
+  S3 operator +=(const S3 &arg1) {return arg1;}
 };
-int operator+=(const S3 &arg1, const S3 &arg2) { return 5; }
-S3 c;               // expected-note 2 {{'c' defined here}}
-const S3 ca[5];     // expected-note 2 {{'ca' defined here}}
-extern const int f; // expected-note 4 {{'f' declared here}}
-class S4 {          // expected-note {{'S4' declared here}}
+int operator +=(const S3 &arg1, const S3 &arg2) {return 5;} // expected-note {{candidate function not viable: no known conversion from 'class S6' to 'const S3' for 1st argument}}
+S3 c; // expected-note {{'c' defined here}}
+const S3 ca[5]; // expected-note {{'ca' defined here}}
+extern const int f; // expected-note 2 {{'f' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
   S4(const S4 &s4);
-  S4 &operator+=(const S4 &arg) { return (*this); }
-
+  S4 &operator +=(const S4 &arg) {return (*this);}
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
-S4 &operator&=(S4 &arg1, S4 &arg2) { return arg1; }
+S4 &operator &=(S4 &arg1, S4 &arg2) {return arg1;} // expected-note {{candidate function not viable: no known conversion from 'S5' to 'S4 &' for 1st argument}}
 class S5 {
   int a;
-  S5() : a(0) {}
-  S5(const S5 &s5) : a(s5.a) {}
-  S5 &operator+=(const S5 &arg);
-
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+  S5 &operator +=(const S5 &arg);
 public:
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
 };
 class S6 {
-  int a;
-
-public:
-  S6() : a(6) {}
-  operator int() { return 6; }
-} o; // expected-note 2 {{'o' defined here}}
+    int a;
+  public:
+    S6():a(6){ }
+    operator int() { return 6; }
+} o;
 
 S3 h, k;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class T>       // expected-note {{declared here}}
-T tmain(T argc) {        // expected-note 2 {{'argc' defined here}}
-  const T d = T();       // expected-note 4 {{'d' defined here}}
-  const T da[5] = {T()}; // expected-note 2 {{'da' defined here}}
-  T qa[5] = {T()};
-  T i;
-  T &j = i;                // expected-note 4 {{'j' defined here}}
-  S3 &p = k;               // expected-note 2 {{'p' defined here}}
-  const T &r = da[(int)i]; // expected-note 2 {{'r' defined here}}
-  T &q = qa[(int)i];       // expected-note 2 {{'q' defined here}}
-  T fl;                    // expected-note {{'fl' defined here}}
-#pragma omp parallel
-#pragma omp for reduction // expected-error {{expected '(' after 'reduction'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction + // expected-error {{expected '(' after 'reduction'}} expected-warning {{extra tokens at the end of '#pragma omp for' are ignored}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction( // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(- // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction() // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(*) // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(\) // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(& : argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(| : argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(|| : argc ? i : argc) // expected-error 2 {{expected variable name}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(foo : argc) //expected-error {{incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(&& : argc)
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(^ : T) // expected-error {{'T' does not refer to a value}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 3 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' or 'max' must be of arithmetic type}} expected-error 3 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(max : qa[1]) // expected-error 2 {{expected variable name}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(+ : ba) // expected-error {{a reduction variable with array type 'const S2 [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(* : ca) // expected-error {{a reduction variable with array type 'const S3 [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(- : da) // expected-error {{a reduction variable with array type 'const int [5]'}} expected-error {{a reduction variable with array type 'const float [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(^ : fl) // expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(+ : o) // expected-error {{variable of type 'class S6' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for private(i), reduction(+ : j), reduction(+ : q) // expected-error 4 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel private(k)
-#pragma omp for reduction(+ : p), reduction(+ : p) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(+ : p), reduction(+ : p) // expected-error 3 {{variable can appear only once in OpenMP 'reduction' clause}} expected-note 3 {{previously referenced here}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(+ : r) // expected-error 2 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel shared(i)
-#pragma omp parallel reduction(min : i)
-#pragma omp for reduction(max : j) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel private(fl)  // expected-note 2 {{defined as private}}
-#pragma omp for reduction(+ : fl) // expected-error 2 {{reduction variable must be shared}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel reduction(* : fl) // expected-note 2 {{defined as reduction}}
-#pragma omp for reduction(+ : fl)      // expected-error 2 {{reduction variable must be shared}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-
-  return T();
-}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
 int main(int argc, char **argv) {
-  const int d = 5;       // expected-note 2 {{'d' defined here}}
-  const int da[5] = {0}; // expected-note {{'da' defined here}}
-  int qa[5] = {0};
+  const int d = 5; // expected-note 2 {{'d' defined here}}
+  const int da[5] = { 0 }; // expected-note {{'da' defined here}}
+  int qa[5] = { 0 };
   S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note {{'g' defined here}}
+  S5 g(5);
   int i;
-  int &j = i;           // expected-note 2 {{'j' defined here}}
-  S3 &p = k;            // expected-note 2 {{'p' defined here}}
-  const int &r = da[i]; // expected-note {{'r' defined here}}
-  int &q = qa[i];       // expected-note {{'q' defined here}}
-  float fl;             // expected-note {{'fl' defined here}}
-#pragma omp parallel
-#pragma omp for reduction // expected-error {{expected '(' after 'reduction'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction + // expected-error {{expected '(' after 'reduction'}} expected-warning {{extra tokens at the end of '#pragma omp for' are ignored}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction( // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(- // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction() // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(*) // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(\) // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(foo : argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(| : argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(|| : argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(~ : argc) // expected-error {{expected unqualified-id}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(&& : argc)
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(^ : S1) // expected-error {{'S1' does not refer to a value}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' or 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(max : argv[1]) // expected-error {{expected variable name}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(+ : ba) // expected-error {{a reduction variable with array type 'const S2 [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(* : ca) // expected-error {{a reduction variable with array type 'const S3 [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(- : da) // expected-error {{a reduction variable with array type 'const int [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(^ : fl) // expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{variable of type 'S5' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(+ : o) // expected-error {{variable of type 'class S6' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for private(i), reduction(+ : j), reduction(+ : q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel private(k)
-#pragma omp for reduction(+ : p), reduction(+ : p) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel shared(i)
-#pragma omp parallel reduction(min : i)
-#pragma omp for reduction(max : j) // expected-error {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel private(fl)  // expected-note {{defined as private}}
-#pragma omp for reduction(+ : fl) // expected-error {{reduction variable must be shared}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel reduction(* : fl) // expected-note {{defined as reduction}}
-#pragma omp for reduction(+ : fl)      // expected-error {{reduction variable must be shared}}
-  for (int i = 0; i < 10; ++i)
-    foo();
+  int &j = i; // expected-note {{'j' defined here}}
+  S3 &p = k;
+  const int &r = da[i]; // expected-note 2 {{'r' defined here}}
+  int &q = qa[i]; // expected-note {{'q' defined here}}
+  float fl; // expected-note {{'fl' defined here}}
+  #pragma omp parallel
+  #pragma omp for reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
+  for (int x = 0; x < 10; ++x) foo();
+  #pragma omp for reduction // expected-error {{expected '(' after 'reduction'}} expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp for reduction + // expected-error {{expected '(' after 'reduction'}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp for reduction ( // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp for reduction (- // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp for reduction () // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp for reduction (*) // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp for reduction (\) // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction (&: argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction (| :argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction (|| :argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction (&& :argc)
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction (^ : S1) // expected-error {{'S1' does not refer to a value}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction (+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error {{'operator+=' is a private member of 'S2'}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction (min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' and 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction (max : argv[1]) // expected-error {{expected variable name}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction(+ : ba) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction(* : ca) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction(- : da) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction(^ : fl) // expected-error {{arguments of OpenMP clause 'reduction' with bitwise operators cannot be of floating type}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{no viable overloaded '&='}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction(+ : o) // expected-error {{no viable overloaded '+='}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel private(i)
+  #pragma omp parallel shared(i, j, q)
+  #pragma omp for reduction(|| : i), reduction(+ : j), reduction(+:q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  for (int x = 0; x < 10; ++x) foo();
+  #pragma omp parallel private(i) // expected-note {{defined as private}}
+  #pragma omp for reduction(|| : i) // expected-error {{private variable in '#pragma omp parallel' cannot be reduction in '#pragma omp for'}}
+  for (int x = 0; x < 10; ++x) foo();
+  #pragma omp parallel
+  #pragma omp for private(i), reduction(|| : i) // expected-error {{private variable cannot be reduction}} expected-note {{defined as private}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp for reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel shared(i)
+  #pragma omp parallel reduction(min : i) // expected-note {{defined as reduction}}
+  #pragma omp for reduction(max : i) // expected-error {{reduction variable in '#pragma omp parallel' cannot be reduction in '#pragma omp for'}}
+  for (i = 0; i < 10; ++i) foo();
 
-  return tmain(argc) + tmain(fl); // expected-note {{in instantiation of function template specialization 'tmain<int>' requested here}} expected-note {{in instantiation of function template specialization 'tmain<float>' requested here}}
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/for_schedule_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/for_schedule_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/for_schedule_messages.cpp	2014-06-20 03:16:17.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/for_schedule_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
 
 void foo() {
 }
@@ -9,83 +9,27 @@
 
 struct S1; // expected-note {{declared here}}
 
-template <class T, typename S, int N, int ST> // expected-note {{declared here}}
-T tmain(T argc, S **argv) {
-  #pragma omp for schedule // expected-error {{expected '(' after 'schedule'}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for schedule ( // expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for schedule () // expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for schedule (auto // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for schedule (auto_dynamic // expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for schedule (auto,  // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for schedule (runtime, 3)  // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-  #pragma omp for schedule (guided argc
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+1 2 {{argument to 'schedule' clause must be a positive integer value}}
-  #pragma omp for schedule (static, ST // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for schedule (dynamic, 1)) // expected-warning {{extra tokens at the end of '#pragma omp for' are ignored}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for schedule (guided, (ST > 0) ? 1 + ST : 2)
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+2 2 {{directive '#pragma omp for' cannot contain more than one 'schedule' clause}}
-  // expected-error@+1 {{argument to 'schedule' clause must be a positive integer value}}
-  #pragma omp for schedule (static, foobool(argc)), schedule (dynamic, true), schedule (guided, -5)
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for schedule (static, S) // expected-error {{'S' does not refer to a value}} expected-warning {{extra tokens at the end of '#pragma omp for' are ignored}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+1 2 {{expression must have integral or unscoped enumeration type, not 'char *'}}
-  #pragma omp for schedule (guided, argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for schedule (dynamic, 1)
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp for schedule (static, N) // expected-error {{argument to 'schedule' clause must be a positive integer value}}
-  for (T i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  return argc;
-}
-
 int main(int argc, char **argv) {
-  #pragma omp for schedule // expected-error {{expected '(' after 'schedule'}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
+  #pragma omp for schedule // expected-error {{expected '(' after 'schedule'}} expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}}
+  for (int i = 0; i < 10; ++i) foo();
   #pragma omp for schedule ( // expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
+  for (int i = 0; i < 10; ++i) foo();
   #pragma omp for schedule () // expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp for schedule (auto // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp for schedule (auto_dynamic // expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp for schedule (auto,  // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp for schedule (runtime, 3)  // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp for schedule (guided, 4 // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp for schedule (static, 2+2)) // expected-warning {{extra tokens at the end of '#pragma omp for' are ignored}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp for schedule (dynamic, foobool(1) > 0 ? 1 : 2)
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+2 2 {{directive '#pragma omp for' cannot contain more than one 'schedule' clause}}
-  // expected-error@+1 {{argument to 'schedule' clause must be a positive integer value}}
-  #pragma omp for schedule (guided, foobool(argc)), schedule (static, true), schedule (dynamic, -5)
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp for schedule (guided, S1) // expected-error {{'S1' does not refer to a value}} expected-warning {{extra tokens at the end of '#pragma omp for' are ignored}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+1 {{expression must have integral or unscoped enumeration type, not 'char *'}}
-  #pragma omp for schedule (static, argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+3 {{statement after '#pragma omp for' must be a for loop}}
-  // expected-note@+1 {{in instantiation of function template specialization 'tmain<int, char, -1, -2>' requested here}}
-  #pragma omp for schedule(dynamic, schedule(tmain<int, char, -1, -2>(argc, argv) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-  // expected-note@+1 {{in instantiation of function template specialization 'tmain<int, char, 1, 0>' requested here}}
-  return tmain<int, char, 1, 0>(argc, argv);
-}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for schedule (static // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for schedule (guided, // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for schedule (argc)) // expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}} expected-warning {{extra tokens at the end of '#pragma omp for' are ignored}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for schedule (dynamic, argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for schedule (auto), schedule (runtime) // expected-error {{directive '#pragma omp for' cannot contain more than one 'schedule' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for schedule (guided, S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp for schedule (dynamic, argv[1]=2) // expected-error {{statement requires expression of integer type ('char *' invalid)}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
 
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/for_simd_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/for_simd_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/for_simd_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/for_simd_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,93 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+template<class T, class N> T reduct(T* arr, N num) {
+  N i;
+  N ind;
+  T sum = (T)0;
+// CHECK: T sum = (T)0;
+#pragma omp for simd  linear(ind), reduction(+:sum)
+// CHECK-NEXT: #pragma omp for simd linear(ind) reduction(+: sum)
+  for (i = 0; i < num; ++i) {
+    T cur = arr[ind];
+    ++ind;
+    sum += cur;
+  }
+}
+
+template<class T> struct S {
+  S(const T &a)
+    :m_a(a)
+  {}
+  T result(T *v) const {
+    T res;
+// CHECK: T res;
+#pragma omp for simd lastprivate(res) safelen(7)
+// CHECK-NEXT: #pragma omp for simd lastprivate(res) safelen(7)
+    for (T i = 7; i < m_a; ++i) {
+      res = v[i-7] + m_a;
+    }
+    return res;
+  }
+  ~S()
+  {}
+  T m_a;
+};
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  int k1=0,k2=0;
+  static int *a;
+// CHECK: static int *a;
+#pragma omp for simd
+// CHECK-NEXT: #pragma omp for simd
+  for (int i=0; i < 2; ++i)*a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: *a = 2;
+#pragma omp parallel
+#pragma omp for simd private(argc,b),lastprivate(d,f),reduction(+:e) reduction(min : g),  collapse(2) safelen(2) aligned(a:4), linear(k1,k2:8)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j) {foo(); k1 += 8; k2 += 8;}
+// CHECK-NEXT: #pragma omp parallel
+// CHECK-NEXT: #pragma omp for simd private(argc,b) lastprivate(d,f) reduction(+: e) reduction(min: g) collapse(2) safelen(2) aligned(a: 4) linear(k1,k2: 8)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j) {
+// CHECK-NEXT: foo();
+// CHECK-NEXT: k1 += 8;
+// CHECK-NEXT: k2 += 8;
+// CHECK-NEXT: }
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp for simd aligned(a) linear(a)
+// CHECK-NEXT: #pragma omp for simd aligned(a) linear(a)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp for simd collapse(1)
+// CHECK: #pragma omp for simd collapse(1)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  const int CLEN=4;
+#pragma omp for simd safelen(CLEN)
+// CHECK: #pragma omp for simd safelen(4)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp for simd aligned(a:CLEN) linear(a:CLEN) safelen(CLEN)
+// CHECK-NEXT: #pragma omp for simd aligned(a: 4) linear(a: 4) safelen(4)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/for_simd_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/for_simd_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/for_simd_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/for_simd_misc_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,453 @@
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 100000 -fopenmp -verify %s
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp for simd'}} */
+#pragma omp for simd
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp for simd'}} */
+#pragma omp for simd foo
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp for simd'}} */
+#pragma omp for simd safelen(4)
+
+void test_no_clause()
+{
+  int i;
+  #pragma omp for simd
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_invalid_clause()
+{
+  int i;
+  /* expected-warning@+1 {{extra tokens at the end of '#pragma omp for simd' are ignored}} */
+  #pragma omp for simd foo bar
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_non_identifiers()
+{
+  int i, x;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp for simd' are ignored}}
+  #pragma omp for simd;
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp for simd' are ignored}}
+  #pragma omp for simd private(x);
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp for simd' are ignored}}
+  #pragma omp for simd , private(x);
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_safelen()
+{
+  int i;
+  /* expected-error@+1 {{expected '('}}  expected-error@+1 {{expected expression}}*/
+  #pragma omp for simd safelen
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}} */
+  #pragma omp for simd safelen(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd safelen()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp for simd safelen(,
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp for simd' are ignored}}
+  /* expected-error@+1 {{expected expression}}  expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp for simd safelen(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected '('}} */
+  #pragma omp for simd safelen 4)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp for simd safelen(4
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp for simd safelen(4,
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp for simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp for simd safelen(4,)
+  for (i = 0; i < 16; ++i) ;
+  /* xxpected-error@+1 {{expected expression}} */
+  #pragma omp for simd safelen(4)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp for simd safelen(4 4)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp for simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp for simd safelen(4,,4)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd safelen(4)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp for simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp for simd safelen(4,8)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_linear()
+{
+  int i;
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}} */
+  #pragma omp for simd linear(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp for simd linear(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd linear(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd linear()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd linear(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp for simd linear(0)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{use of undeclared identifier 'x'}} */
+  #pragma omp for simd linear(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{use of undeclared identifier 'x'}} */
+  /* expected-error@+1 {{use of undeclared identifier 'y'}} */
+  #pragma omp for simd linear(x, y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+3 {{use of undeclared identifier 'x'}} */
+  /* expected-error@+2 {{use of undeclared identifier 'y'}} */
+  /* expected-error@+1 {{use of undeclared identifier 'z'}} */
+  #pragma omp for simd linear(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd linear(x:)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd linear(x:,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd linear(x:1)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd linear(x:2*2)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp for simd' are ignored}}
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp for simd linear(x:1,y)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp for simd' are ignored}}
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp for simd linear(x:1,y,z:1)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be linear}}
+  #pragma omp for simd linear(x) linear(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as private}}
+  // expected-error@+1 {{private variable cannot be linear}}
+  #pragma omp for simd private(x) linear(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be private}}
+  #pragma omp for simd linear(x) private(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be lastprivate}}
+  #pragma omp for simd linear(x) lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as lastprivate}}
+  // expected-error@+1 {{lastprivate variable cannot be linear}}
+  #pragma omp for simd lastprivate(x) linear(x) 
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_private()
+{
+  int i;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp for simd private(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp for simd private(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp for simd private(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd private()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd private(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp for simd private(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp for simd private(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd private(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd private(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_firstprivate()
+{
+  // TODO: tests on this.
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd firstprivate(
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_lastprivate()
+{
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd lastprivate(
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp for simd lastprivate(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp for simd lastprivate(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd lastprivate()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd lastprivate(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp for simd lastprivate(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp for simd lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd lastprivate(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd lastprivate(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_reduction()
+{
+  int i, x, y;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp for simd reduction(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp for simd reduction()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp for simd reduction(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected identifier}} */
+  #pragma omp for simd reduction(:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+4 {{expected ')'}} expected-note@+4 {{to match this '('}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp for simd reduction(,
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp for simd reduction(+
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  //
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd reduction(+:
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd reduction(+:)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd reduction(+:,y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd reduction(+:x,+:y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd reduction(%:x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp for simd reduction(+:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd reduction(*:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd reduction(-:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd reduction(&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd reduction(|:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd reduction(^:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd reduction(&&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd reduction(||:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd reduction(max:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp for simd reduction(min:x)
+  for (i = 0; i < 16; ++i) ;
+  struct X { int x; };
+  struct X X;
+  // TODO: Is the following error correct?
+  // expected-error@+1 {{expected variable name}}
+  #pragma omp for simd reduction(+:X.x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp for simd reduction(+:x+x)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_aligned()
+{
+  int i;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp for simd aligned(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp for simd aligned(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp for simd aligned(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd aligned()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp for simd aligned(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp for simd aligned(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int *x, y, z[25];
+  #pragma omp for simd aligned(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp for simd aligned(x, y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp for simd aligned(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp for simd aligned(x:4)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp for simd aligned(x, y:8)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp for simd aligned(x, y, z:10+6)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}}
+  // expected-error@+1 {{expression is not an integer constant expression}}
+  #pragma omp for simd aligned(x, y, z:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-note@+2 {{defined as aligned}}
+  // expected-error@+1 {{aligned variable cannot be aligned}}
+  #pragma omp for simd aligned(x:16) aligned(z,x:16)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_multiple_clauses()
+{
+  int i;
+  float x = 0, y = 0, z = 0;
+  #pragma omp for simd safelen(4) reduction(+:x, y) reduction(-:z) // OK
+  for (i = 0; i < 16; ++i);
+
+  // expected-error@+1 {{private variable cannot be lastprivate}} expected-note@+1 {{defined as private}}
+  #pragma omp for simd private(x), lastprivate(x)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp for simd safelen(4) reduction(+:x, y), reduction(-:z)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp for simd reduction(+:x, y) reduction(-:z)
+  for (i = 0; i < 16; ++i);
+}
+
+void test_for()
+{
+  // expected-error@+3 {{expected '(' after 'for'}}
+  // expected-error@+2 2{{use of undeclared identifier 'i'}}
+  #pragma omp for simd
+  for int i = 0; i < 16; i++);
+
+  // expected-error@+3 {{expected ')'}}
+  // expected-note@+2 {{to match this '('}}
+  #pragma omp for simd
+  for (int i = 0; i < 16; i++;
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp for simd
+  for (int i = 0 i < 16; i++);
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp for simd
+  for (int i = 0; i < 16 i++);
+
+  // expected-error@+2 2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp for simd
+  for (int i = 0 i < 16 i++);
+
+  int i = 0;
+  // expected-error@+2 {{initialization of for-loop does not have canonical form}}
+  #pragma omp for simd
+  for (; i < 16; ++i);
+
+  // expected-error@+2 {{condition of for-loop does not have canonical form}}
+  #pragma omp for simd
+  for (int i = 0; ; ++i);
+
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp for simd
+  for (int i = 0; i < 16; );
+
+  // expected-error@+3 {{condition of for-loop does not have canonical form}}
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp for simd
+  for (int i = 0; ;);
+
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/linking.c cfe-3.5.0.src.omp/test/OpenMP/linking.c
--- cfe-3.5.0.src/test/OpenMP/linking.c	2014-03-07 02:43:52.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/linking.c	2014-11-28 10:49:31.000000000 -0500
@@ -1,71 +1,16 @@
 // Test the that the driver produces reasonable linker invocations with
-// -fopenmp or -fopenmp=libiomp5|libgomp.
+// -fopenmp.
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     -fopenmp -target i386-unknown-linux \
 // RUN:   | FileCheck --check-prefix=CHECK-LD-32 %s
 // CHECK-LD-32: "{{.*}}ld{{(.exe)?}}"
-// CHECK-LD-32: "-lgomp" "-lrt" "-lgcc"
+// CHECK-LD-32: "-liomp5" "-lgcc"
 // CHECK-LD-32: "-lpthread" "-lc"
 //
 // RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
 // RUN:     -fopenmp -target x86_64-unknown-linux \
 // RUN:   | FileCheck --check-prefix=CHECK-LD-64 %s
 // CHECK-LD-64: "{{.*}}ld{{(.exe)?}}"
-// CHECK-LD-64: "-lgomp" "-lrt" "-lgcc"
+// CHECK-LD-64: "-liomp5" "-lgcc"
 // CHECK-LD-64: "-lpthread" "-lc"
-//
-// RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
-// RUN:     -fopenmp=libgomp -target i386-unknown-linux \
-// RUN:   | FileCheck --check-prefix=CHECK-GOMP-LD-32 %s
-// CHECK-GOMP-LD-32: "{{.*}}ld{{(.exe)?}}"
-// CHECK-GOMP-LD-32: "-lgomp" "-lrt" "-lgcc"
-// CHECK-GOMP-LD-32: "-lpthread" "-lc"
-//
-// RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
-// RUN:     -fopenmp=libgomp -target x86_64-unknown-linux \
-// RUN:   | FileCheck --check-prefix=CHECK-GOMP-LD-64 %s
-// CHECK-GOMP-LD-64: "{{.*}}ld{{(.exe)?}}"
-// CHECK-GOMP-LD-64: "-lgomp" "-lrt" "-lgcc"
-// CHECK-GOMP-LD-64: "-lpthread" "-lc"
-//
-// RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
-// RUN:     -fopenmp=libiomp5 -target i386-unknown-linux \
-// RUN:   | FileCheck --check-prefix=CHECK-IOMP5-LD-32 %s
-// CHECK-IOMP5-LD-32: "{{.*}}ld{{(.exe)?}}"
-// CHECK-IOMP5-LD-32: "-liomp5" "-lgcc"
-// CHECK-IOMP5-LD-32: "-lpthread" "-lc"
-//
-// RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
-// RUN:     -fopenmp=libiomp5 -target x86_64-unknown-linux \
-// RUN:   | FileCheck --check-prefix=CHECK-IOMP5-LD-64 %s
-// CHECK-IOMP5-LD-64: "{{.*}}ld{{(.exe)?}}"
-// CHECK-IOMP5-LD-64: "-liomp5" "-lgcc"
-// CHECK-IOMP5-LD-64: "-lpthread" "-lc"
-//
-// RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
-// RUN:     -fopenmp=lib -target i386-unknown-linux \
-// RUN:   | FileCheck --check-prefix=CHECK-LIB-LD-32 %s
-// CHECK-LIB-LD-32: error: unsupported argument 'lib' to option 'fopenmp='
-//
-// RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
-// RUN:     -fopenmp=lib -target x86_64-unknown-linux \
-// RUN:   | FileCheck --check-prefix=CHECK-LIB-LD-64 %s
-// CHECK-LIB-LD-64: error: unsupported argument 'lib' to option 'fopenmp='
-//
-// RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
-// RUN:     -fopenmp -fopenmp=libiomp5 -target i386-unknown-linux \
-// RUN:   | FileCheck --check-prefix=CHECK-LD-WARN-32 %s
-// CHECK-LD-WARN-32: warning: argument unused during compilation: '-fopenmp=libiomp5'
-// CHECK-LD-WARN-32: "{{.*}}ld{{(.exe)?}}"
-// CHECK-LD-WARN-32: "-lgomp" "-lrt" "-lgcc"
-// CHECK-LD-WARN-32: "-lpthread" "-lc"
-//
-// RUN: %clang -no-canonical-prefixes %s -### -o %t.o 2>&1 \
-// RUN:     -fopenmp -fopenmp=libiomp5 -target x86_64-unknown-linux \
-// RUN:   | FileCheck --check-prefix=CHECK-LD-WARN-64 %s
-// CHECK-LD-WARN-64: warning: argument unused during compilation: '-fopenmp=libiomp5'
-// CHECK-LD-WARN-64: "{{.*}}ld{{(.exe)?}}"
-// CHECK-LD-WARN-64: "-lgomp" "-lrt" "-lgcc"
-// CHECK-LD-WARN-64: "-lpthread" "-lc"
-//
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/master_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/master_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/master_ast_print.cpp	2014-07-17 04:54:58.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/master_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
 // expected-no-diagnostics
 
 #ifndef HEADER
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/master_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/master_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/master_messages.cpp	2014-07-17 04:54:58.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/master_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 int foo();
 
@@ -14,19 +14,19 @@
   #pragma omp for
   for (int i = 0; i < 10; ++i) {
     foo();
-    #pragma omp master // expected-error {{region cannot be closely nested inside 'for' region}}
+    #pragma omp master // expected-error {{region cannot be closely nested inside a worksharing region}}
     foo();
   }
   #pragma omp sections
   {
     foo();
-    #pragma omp master // expected-error {{region cannot be closely nested inside 'sections' region}}
+    #pragma omp master // expected-error {{region cannot be closely nested inside a worksharing region}}
     foo();
   }
   #pragma omp single
   for (int i = 0; i < 10; ++i) {
     foo();
-    #pragma omp master // expected-error {{region cannot be closely nested inside 'single' region}}
+    #pragma omp master // expected-error {{region cannot be closely nested inside a worksharing region}}
     foo();
   }
   #pragma omp master
@@ -37,9 +37,11 @@
   }
   #pragma omp for ordered
   for (int i = 0; i < 10; ++i)
-  #pragma omp master // expected-error {{region cannot be closely nested inside 'for' region}}
+  #pragma omp ordered
   {
     foo();
+    #pragma omp master // expected-error {{region cannot be closely nested inside an ordered region}}
+    foo();
   }
 
   return 0;
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/nesting_of_regions.cpp cfe-3.5.0.src.omp/test/OpenMP/nesting_of_regions.cpp
--- cfe-3.5.0.src/test/OpenMP/nesting_of_regions.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/nesting_of_regions.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,2278 +0,0 @@
-// RUN: %clang_cc1 -fsyntax-only -fopenmp=libiomp5 -verify %s
-
-void bar();
-
-template <class T>
-void foo() {
-// PARALLEL DIRECTIVE
-#pragma omp parallel
-#pragma omp for
-  for (int i = 0; i < 10; ++i)
-    ;
-#pragma omp parallel
-#pragma omp simd
-  for (int i = 0; i < 10; ++i)
-    ;
-#pragma omp parallel
-#pragma omp sections
-  {
-    bar();
-  }
-#pragma omp parallel
-#pragma omp section // expected-error {{'omp section' directive must be closely nested to a sections region, not a parallel region}}
-  {
-    bar();
-  }
-#pragma omp parallel
-#pragma omp single
-  bar();
-
-#pragma omp parallel
-#pragma omp master
-  {
-    bar();
-  }
-#pragma omp parallel
-#pragma omp critical
-  {
-    bar();
-  }
-#pragma omp parallel
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i)
-    ;
-#pragma omp parallel
-#pragma omp parallel sections
-  {
-    bar();
-  }
-#pragma omp parallel
-#pragma omp task
-  {
-    bar();
-  }
-#pragma omp parallel
-  {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp parallel
-  {
-#pragma omp barrier
-    bar();
-  }
-#pragma omp parallel
-  {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp parallel
-  {
-#pragma omp flush
-    bar();
-  }
-
-// SIMD DIRECTIVE
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp for // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp simd // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp sections // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    {
-      bar();
-    }
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp section // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    {
-      bar();
-    }
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp single // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    {
-      bar();
-    }
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp master // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    {
-      bar();
-    }
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp critical // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    {
-      bar();
-    }
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel for // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel sections // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    {
-      bar();
-    }
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp task // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    {
-      bar();
-    }
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp taskyield // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    bar();
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp barrier // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    bar();
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp taskwait // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    bar();
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp flush // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    bar();
-  }
-
-// FOR DIRECTIVE
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'for' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'for' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp section // expected-error {{'omp section' directive must be closely nested to a sections region, not a for region}}
-    {
-      bar();
-    }
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'for' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp master // expected-error {{region cannot be closely nested inside 'for' region}}
-    {
-      bar();
-    }
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp critical 
-    {
-      bar();
-    }
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel
-    {
-#pragma omp single // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'for' region}}
-    bar();
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp flush
-    bar();
-  }
-
-// SECTIONS DIRECTIVE
-#pragma omp sections
-  {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'sections' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp sections
-  {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp sections
-  {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp sections
-  {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'sections' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp parallel
-    {
-#pragma omp single // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp parallel
-    {
-#pragma omp master // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp master // OK
-      {
-        bar();
-      }
-    }
-#pragma omp master // expected-error {{region cannot be closely nested inside 'sections' region}}
-    bar();
-  }
-#pragma omp sections
-  {
-#pragma omp parallel
-    {
-#pragma omp critical(A) // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp critical // OK
-      {
-        bar();
-      }
-    }
-#pragma omp critical(A) // expected-error {{statement in 'omp sections' directive must be enclosed into a section region}}
-    bar();
-  }
-#pragma omp sections
-  {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp sections
-  {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp taskyield
-  }
-#pragma omp sections
-  {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'sections' region}}
-  }
-#pragma omp sections
-  {
-#pragma omp taskwait
-  }
-#pragma omp sections
-  {
-#pragma omp flush
-  }
-
-// SECTION DIRECTIVE
-#pragma omp section // expected-error {{orphaned 'omp section' directives are prohibited, it must be closely nested to a sections region}}
-  {
-    bar();
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'section' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-      for (int i = 0; i < 10; ++i)
-        ;
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp simd
-      for (int i = 0; i < 10; ++i)
-        ;
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp parallel
-      for (int i = 0; i < 10; ++i)
-        ;
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'section' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp section // expected-error {{'omp section' directive must be closely nested to a sections region, not a section region}}
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'section' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-      bar();
-#pragma omp master // expected-error {{region cannot be closely nested inside 'section' region}}
-      bar();
-#pragma omp critical
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp parallel
-      {
-#pragma omp single // OK
-        {
-          bar();
-        }
-#pragma omp for // OK
-        for (int i = 0; i < 10; ++i)
-          ;
-#pragma omp sections // OK
-        {
-          bar();
-        }
-      }
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp parallel for
-      for (int i = 0; i < 10; ++i)
-        ;
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp parallel sections
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp task
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp taskyield
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'section' region}}
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp taskwait
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp flush
-      bar();
-    }
-  }
-
-// SINGLE DIRECTIVE
-#pragma omp single
-  {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'single' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp single
-  {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp single
-  {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp single
-  {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'single' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp single
-  {
-#pragma omp master // expected-error {{region cannot be closely nested inside 'single' region}}
-    {
-      bar();
-    }
-  }
-#pragma omp single
-  {
-#pragma omp critical
-    {
-      bar();
-    }
-  }
-#pragma omp single
-  {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'single' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp single
-  {
-#pragma omp parallel
-    {
-#pragma omp single // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp single
-  {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp single
-  {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp single
-  {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp single
-  {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp single
-  {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'single' region}}
-    bar();
-  }
-#pragma omp single
-  {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp single
-  {
-#pragma omp flush
-    bar();
-  }
-
-// MASTER DIRECTIVE
-#pragma omp master
-  {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'master' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp master
-  {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp master
-  {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp master
-  {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'master' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp master
-  {
-#pragma omp master // OK, though second 'master' is redundant
-    {
-      bar();
-    }
-  }
-#pragma omp master
-  {
-#pragma omp critical
-    {
-      bar();
-    }
-  }
-#pragma omp master
-  {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'master' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp master
-  {
-#pragma omp parallel
-    {
-#pragma omp master // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp master
-  {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp master
-  {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp master
-  {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp master
-  {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp master
-  {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'master' region}}
-    bar();
-  }
-#pragma omp master
-  {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp master
-  {
-#pragma omp flush
-    bar();
-  }
-
-// CRITICAL DIRECTIVE
-#pragma omp critical
-  {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'critical' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp critical
-  {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp critical
-  {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp critical
-  {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'critical' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp master // OK, though second 'master' is redundant
-    {
-      bar();
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp critical
-    {
-      bar();
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'critical' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp parallel
-    {
-#pragma omp master // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp critical
-  {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp critical
-  {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'critical' region}}
-    bar();
-  }
-#pragma omp critical
-  {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp critical(Tuzik)
-  {
-#pragma omp critical(grelka)
-    bar();
-  }
-#pragma omp critical(Belka)// expected-note {{previous 'critical' region starts here}}
-  {
-#pragma omp critical(Belka) // expected-error {{cannot nest 'critical' regions having the same name 'Belka'}}
-    {
-#pragma omp critical(Tuzik)
-      {
-#pragma omp parallel
-#pragma omp critical(grelka)
-        {
-          bar();
-        }
-      }
-    }
-  }
-
-// PARALLEL FOR DIRECTIVE
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'parallel for' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'parallel for' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp section // expected-error {{'omp section' directive must be closely nested to a sections region, not a parallel for region}}
-    {
-      bar();
-    }
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'parallel for' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp master // expected-error {{region cannot be closely nested inside 'parallel for' region}}
-    {
-      bar();
-    }
-  }
-
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp critical
-    {
-      bar();
-    }
-  }
-
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel
-    {
-#pragma omp single // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'parallel for' region}}
-    bar();
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp flush
-    bar();
-  }
-
-// PARALLEL SECTIONS DIRECTIVE
-#pragma omp parallel sections
-  {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'parallel sections' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel sections
-  {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel sections
-  {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel sections
-  {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'parallel sections' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp section
-    {
-      bar();
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp section
-    {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'section' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-      bar();
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp section
-    {
-#pragma omp master // expected-error {{region cannot be closely nested inside 'section' region}}
-      bar();
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp section
-    {
-#pragma omp critical
-      bar();
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp parallel
-    {
-#pragma omp single // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel sections
-  {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp taskyield
-  }
-#pragma omp parallel sections
-  {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'parallel sections' region}}
-  }
-#pragma omp parallel sections
-  {
-#pragma omp taskwait
-  }
-#pragma omp parallel sections
-  {
-#pragma omp flush
-  }
-
-// TASK DIRECTIVE
-#pragma omp task
-#pragma omp for // expected-error {{region cannot be closely nested inside 'task' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-  for (int i = 0; i < 10; ++i)
-    ;
-#pragma omp task
-#pragma omp simd
-  for (int i = 0; i < 10; ++i)
-    ;
-#pragma omp task
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'task' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-  {
-    bar();
-  }
-#pragma omp task
-#pragma omp section // expected-error {{'omp section' directive must be closely nested to a sections region, not a task region}}
-  {
-    bar();
-  }
-#pragma omp task
-#pragma omp single // expected-error {{region cannot be closely nested inside 'task' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-  bar();
-#pragma omp task
-#pragma omp master // expected-error {{region cannot be closely nested inside 'task' region}}
-  bar();
-#pragma omp task
-#pragma omp critical
-  bar();
-
-#pragma omp task
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i)
-    ;
-#pragma omp task
-#pragma omp parallel sections
-  {
-    bar();
-  }
-#pragma omp task
-#pragma omp task
-  {
-    bar();
-  }
-#pragma omp task
-  {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp task
-  {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'task' region}}
-    bar();
-  }
-#pragma omp task
-  {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp task
-  {
-#pragma omp flush
-    bar();
-  }
-}
-
-void foo() {
-// PARALLEL DIRECTIVE
-#pragma omp parallel
-#pragma omp for
-  for (int i = 0; i < 10; ++i)
-    ;
-#pragma omp parallel
-#pragma omp simd
-  for (int i = 0; i < 10; ++i)
-    ;
-#pragma omp parallel
-#pragma omp sections
-  {
-    bar();
-  }
-#pragma omp parallel
-#pragma omp section // expected-error {{'omp section' directive must be closely nested to a sections region, not a parallel region}}
-  {
-    bar();
-  }
-#pragma omp parallel
-#pragma omp sections
-  {
-    bar();
-  }
-#pragma omp parallel
-#pragma omp single
-  bar();
-#pragma omp parallel
-#pragma omp master
-  bar();
-#pragma omp parallel
-#pragma omp critical
-  bar();
-#pragma omp parallel
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i)
-    ;
-#pragma omp parallel
-#pragma omp parallel sections
-  {
-    bar();
-  }
-#pragma omp parallel
-#pragma omp task
-  {
-    bar();
-  }
-#pragma omp parallel
-  {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp parallel
-  {
-#pragma omp barrier
-    bar();
-  }
-#pragma omp parallel
-  {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp parallel
-  {
-#pragma omp flush
-    bar();
-  }
-
-// SIMD DIRECTIVE
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp for // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp simd // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp sections // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    {
-      bar();
-    }
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp section // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    {
-      bar();
-    }
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp single // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    bar();
-#pragma omp master // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    bar();
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp single // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    bar();
-#pragma omp critical // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    bar();
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel for // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel sections // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    {
-      bar();
-    }
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp task // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    {
-      bar();
-    }
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp taskyield // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    bar();
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp barrier // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    bar();
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp taskwait // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    bar();
-  }
-#pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-#pragma omp flush // expected-error {{OpenMP constructs may not be nested inside a simd region}}
-    bar();
-  }
-
-// FOR DIRECTIVE
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'for' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'for' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp section // expected-error {{'omp section' directive must be closely nested to a sections region, not a for region}}
-    {
-      bar();
-    }
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'for' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-    bar();
-#pragma omp master // expected-error {{region cannot be closely nested inside 'for' region}}
-    bar();
-#pragma omp critical
-    bar();
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel
-    {
-#pragma omp single // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'for' region}}
-    bar();
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp flush
-    bar();
-  }
-
-// SECTIONS DIRECTIVE
-#pragma omp sections
-  {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'sections' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp sections
-  {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp sections
-  {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp sections
-  {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'sections' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp critical
-    bar();
-#pragma omp single // expected-error {{region cannot be closely nested inside 'sections' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-    bar();
-#pragma omp master // expected-error {{region cannot be closely nested inside 'sections' region}}
-    bar();
-  }
-#pragma omp sections
-  {
-#pragma omp parallel
-    {
-#pragma omp single // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp sections
-  {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp taskyield
-  }
-#pragma omp sections
-  {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'sections' region}}
-    bar();
-  }
-#pragma omp sections
-  {
-#pragma omp taskwait
-  }
-#pragma omp sections
-  {
-#pragma omp flush
-  }
-
-// SECTION DIRECTIVE
-#pragma omp section // expected-error {{orphaned 'omp section' directives are prohibited, it must be closely nested to a sections region}}
-  {
-    bar();
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'section' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-      for (int i = 0; i < 10; ++i)
-        ;
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp simd
-      for (int i = 0; i < 10; ++i)
-        ;
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp parallel
-      for (int i = 0; i < 10; ++i)
-        ;
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'section' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp section // expected-error {{'omp section' directive must be closely nested to a sections region, not a section region}}
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'section' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-      bar();
-#pragma omp master // expected-error {{region cannot be closely nested inside 'section' region}}
-      bar();
-#pragma omp critical
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp parallel
-      {
-#pragma omp single // OK
-        {
-          bar();
-        }
-#pragma omp for // OK
-        for (int i = 0; i < 10; ++i)
-          ;
-#pragma omp sections // OK
-        {
-          bar();
-        }
-      }
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp parallel for
-      for (int i = 0; i < 10; ++i)
-        ;
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp parallel sections
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp task
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp taskyield
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'section' region}}
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp taskwait
-      bar();
-    }
-  }
-#pragma omp sections
-  {
-#pragma omp section
-    {
-#pragma omp flush
-      bar();
-    }
-  }
-
-// SINGLE DIRECTIVE
-#pragma omp single
-  {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'single' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp single
-  {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp single
-  {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp single
-  {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'single' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-    {
-      bar();
-    }
-#pragma omp master // expected-error {{region cannot be closely nested inside 'single' region}}
-    bar();
-#pragma omp critical
-    bar();
-  }
-#pragma omp single
-  {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'single' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp single
-  {
-#pragma omp parallel
-    {
-#pragma omp single // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp single
-  {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp single
-  {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp single
-  {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp single
-  {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp single
-  {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'single' region}}
-    bar();
-  }
-#pragma omp single
-  {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp single
-  {
-#pragma omp flush
-    bar();
-  }
-
-// MASTER DIRECTIVE
-#pragma omp master
-  {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'master' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp master
-  {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp master
-  {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp master
-  {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'master' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp master
-  {
-#pragma omp master // OK, though second 'master' is redundant
-    {
-      bar();
-    }
-  }
-#pragma omp master
-  {
-#pragma omp critical
-    {
-      bar();
-    }
-  }
-#pragma omp master
-  {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'master' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp master
-  {
-#pragma omp parallel
-    {
-#pragma omp master // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp master
-  {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp master
-  {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp master
-  {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp master
-  {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp master
-  {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'master' region}}
-    bar();
-  }
-#pragma omp master
-  {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp master
-  {
-#pragma omp flush
-    bar();
-  }
-
-// CRITICAL DIRECTIVE
-#pragma omp critical
-  {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'critical' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp critical
-  {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp critical
-  {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp critical
-  {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'critical' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp master // OK, though second 'master' is redundant
-    {
-      bar();
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp critical
-    {
-      bar();
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'critical' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp parallel
-    {
-#pragma omp master // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp critical
-  {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp critical
-  {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp critical
-  {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'critical' region}}
-    bar();
-  }
-#pragma omp critical
-  {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp critical(Belka)
-  {
-#pragma omp critical(Strelka)
-    bar();
-  }
-#pragma omp critical(Tuzik)// expected-note {{previous 'critical' region starts here}}
-  {
-#pragma omp critical(grelka) // expected-note {{previous 'critical' region starts here}}
-    {
-#pragma omp critical(Tuzik) // expected-error {{cannot nest 'critical' regions having the same name 'Tuzik'}}
-      {
-#pragma omp parallel
-#pragma omp critical(grelka) // expected-error {{cannot nest 'critical' regions having the same name 'grelka'}}
-        {
-          bar();
-        }
-      }
-    }
-  }
-
-// PARALLEL FOR DIRECTIVE
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'parallel for' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'parallel for' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp section // expected-error {{'omp section' directive must be closely nested to a sections region, not a parallel for region}}
-    {
-      bar();
-    }
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'parallel for' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-    {
-      bar();
-    }
-#pragma omp master // expected-error {{region cannot be closely nested inside 'parallel for' region}}
-    {
-      bar();
-    }
-#pragma omp critical
-    {
-      bar();
-    }
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel
-    {
-#pragma omp single // OK
-      {
-        bar();
-      }
-#pragma omp master // OK
-      {
-        bar();
-      }
-#pragma omp critical // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'parallel for' region}}
-    bar();
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-#pragma omp flush
-    bar();
-  }
-
-// PARALLEL SECTIONS DIRECTIVE
-#pragma omp parallel sections
-  {
-#pragma omp for // expected-error {{region cannot be closely nested inside 'parallel sections' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel sections
-  {
-#pragma omp simd
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel sections
-  {
-#pragma omp parallel
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel sections
-  {
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'parallel sections' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-    {
-      bar();
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp section
-    {
-      bar();
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp section
-    {
-#pragma omp single // expected-error {{region cannot be closely nested inside 'section' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-      bar();
-#pragma omp master // expected-error {{region cannot be closely nested inside 'section' region}}
-      bar();
-#pragma omp critical
-      bar();
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp parallel
-    {
-#pragma omp single // OK
-      {
-        bar();
-      }
-#pragma omp master // OK
-      {
-        bar();
-      }
-#pragma omp critical // OK
-      {
-        bar();
-      }
-#pragma omp for // OK
-      for (int i = 0; i < 10; ++i)
-        ;
-#pragma omp sections // OK
-      {
-        bar();
-      }
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp parallel for
-    for (int i = 0; i < 10; ++i)
-      ;
-  }
-#pragma omp parallel sections
-  {
-#pragma omp parallel sections
-    {
-      bar();
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp task
-    {
-      bar();
-    }
-  }
-#pragma omp parallel sections
-  {
-#pragma omp taskyield
-  }
-#pragma omp parallel sections
-  {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'parallel sections' region}}
-  }
-#pragma omp parallel sections
-  {
-#pragma omp taskwait
-  }
-#pragma omp parallel sections
-  {
-#pragma omp flush
-  }
-
-// TASK DIRECTIVE
-#pragma omp task
-#pragma omp for // expected-error {{region cannot be closely nested inside 'task' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-  for (int i = 0; i < 10; ++i)
-    ;
-#pragma omp task
-#pragma omp simd
-  for (int i = 0; i < 10; ++i)
-    ;
-#pragma omp task
-#pragma omp sections // expected-error {{region cannot be closely nested inside 'task' region; perhaps you forget to enclose 'omp sections' directive into a parallel region?}}
-  {
-    bar();
-  }
-#pragma omp task
-#pragma omp section // expected-error {{'omp section' directive must be closely nested to a sections region, not a task region}}
-  {
-    bar();
-  }
-#pragma omp task
-#pragma omp single // expected-error {{region cannot be closely nested inside 'task' region; perhaps you forget to enclose 'omp single' directive into a parallel region?}}
-  bar();
-#pragma omp task
-#pragma omp master // expected-error {{region cannot be closely nested inside 'task' region}}
-  bar();
-#pragma omp task
-#pragma omp critical
-  bar();
-#pragma omp task
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i)
-    ;
-#pragma omp task
-#pragma omp parallel sections
-  {
-    bar();
-  }
-#pragma omp task
-#pragma omp task
-  {
-    bar();
-  }
-#pragma omp task
-  {
-#pragma omp taskyield
-    bar();
-  }
-#pragma omp task
-  {
-#pragma omp barrier // expected-error {{region cannot be closely nested inside 'task' region}}
-    bar();
-  }
-#pragma omp task
-  {
-#pragma omp taskwait
-    bar();
-  }
-#pragma omp task
-  {
-#pragma omp flush
-    bar();
-  }
-  return foo<int>();
-}
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/no_option.c cfe-3.5.0.src.omp/test/OpenMP/no_option.c
--- cfe-3.5.0.src/test/OpenMP/no_option.c	2014-06-19 05:13:45.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/no_option.c	2014-11-28 10:49:31.000000000 -0500
@@ -2,5 +2,5 @@
 // expected-no-diagnostics
 
 int a;
-#pragma omp threadprivate(a, b)
+#pragma omp threadprivate(a,b)
 #pragma omp parallel
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/no_option_no_warn.c cfe-3.5.0.src.omp/test/OpenMP/no_option_no_warn.c
--- cfe-3.5.0.src/test/OpenMP/no_option_no_warn.c	2014-06-19 05:13:45.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/no_option_no_warn.c	2014-11-28 10:49:31.000000000 -0500
@@ -2,5 +2,5 @@
 // expected-no-diagnostics
 
 int a;
-#pragma omp threadprivate(a, b)
+#pragma omp threadprivate(a,b)
 #pragma omp parallel
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/openmp_common.c cfe-3.5.0.src.omp/test/OpenMP/openmp_common.c
--- cfe-3.5.0.src/test/OpenMP/openmp_common.c	2014-03-06 00:43:53.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/openmp_common.c	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 -o - %s
 
 #pragma omp // expected-error {{expected an OpenMP directive}}
 #pragma omp unknown_directive // expected-error {{expected an OpenMP directive}}
@@ -6,4 +6,11 @@
 void foo() {
 #pragma omp // expected-error {{expected an OpenMP directive}}
 #pragma omp unknown_directive // expected-error {{expected an OpenMP directive}}
+#pragma omp parallel unknown_clause // expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
+#pragma omp parallel ordered // expected-error {{unexpected OpenMP clause 'ordered' in directive '#pragma omp parallel'}}
+#pragma omp for unknown_clause // expected-warning {{extra tokens at the end of '#pragma omp for' are ignored}}
+for (int i = 0; i < 1; ++i) ++i;
+#pragma omp for default(none) // expected-error {{unexpected OpenMP clause 'default' in directive '#pragma omp for'}}
+for (int i = 0; i < 1; ++i) ++i;
+foo();
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/ordered_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/ordered_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/ordered_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/ordered_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,30 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  static int a;
+// CHECK: static int a;
+  #pragma omp for ordered
+  for (int i =0 ; i < argc; ++i)
+  #pragma omp ordered
+  {
+    a=2;
+  }
+// CHECK-NEXT: #pragma omp for ordered
+// CHECK-NEXT: for (int i = 0; i < argc; ++i)
+// CHECK-NEXT: #pragma omp ordered
+// CHECK-NEXT: {
+// CHECK-NEXT: a = 2;
+// CHECK-NEXT: }
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/ordered_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/ordered_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/ordered_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/ordered_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,84 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int foo();
+
+int main() {
+  #pragma omp for ordered
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp ordered
+    ;
+  }
+  #pragma omp for ordered
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp ordered nowait // expected-error {{unexpected OpenMP clause 'nowait' in directive '#pragma omp ordered'}}
+    foo();
+  }
+  #pragma omp for ordered
+  for (int i = 0; i < 10; ++i) {
+    foo();
+  #pragma omp ordered unknown // expected-warning {{extra tokens at the end of '#pragma omp ordered' are ignored}}
+    foo();
+  }
+  #pragma omp for ordered
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp ordered
+  } // expected-error {{expected statement}}
+  #pragma omp for ordered
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp parallel
+    #pragma omp ordered // expected-error {{region must be closely nested inside loop or parallel loop region with 'ordered' clause}}
+    foo();
+  }
+  #pragma omp for ordered
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp critical
+    #pragma omp ordered // expected-error {{region cannot be closely nested inside a critical region}}
+    foo();
+  }
+  #pragma omp for ordered
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp atomic
+    #pragma omp ordered // expected-error {{region cannot be closely nested inside an atomic region}}
+    foo();
+  }
+  #pragma omp for ordered
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp task
+    #pragma omp ordered // expected-error {{region cannot be closely nested inside explicit task region}}
+    foo();
+  }
+
+  return 0;
+}
+
+int foo() {
+  #pragma omp for ordered
+  for (int i = 0; i < 10; ++i) {
+    L1:
+      foo();
+    #pragma omp ordered
+    {
+      foo();
+      goto L1; // expected-error {{use of undeclared label 'L1'}}
+    }
+  }
+  #pragma omp for ordered
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    goto L2; // expected-error {{use of undeclared label 'L2'}}
+    #pragma omp ordered
+    {
+      L2:
+      foo();
+    }
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_ast_print.cpp	2014-06-16 03:08:35.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
 // expected-no-diagnostics
 
 #ifndef HEADER
@@ -8,89 +8,53 @@
 
 void foo() {}
 
-template <class T>
-struct S {
-  operator T() {return T();}
-  static T TS;
-  #pragma omp threadprivate(TS)
-};
-
-// CHECK:      template <class T = int> struct S {
-// CHECK:        static int TS;
-// CHECK-NEXT:   #pragma omp threadprivate(S<int>::TS)
-// CHECK-NEXT: }
-// CHECK:      template <class T = long> struct S {
-// CHECK:        static long TS;
-// CHECK-NEXT:   #pragma omp threadprivate(S<long>::TS)
-// CHECK-NEXT: }
-// CHECK:      template <class T> struct S {
-// CHECK:        static T TS;
-// CHECK-NEXT:   #pragma omp threadprivate(S::TS)
-// CHECK:      };
 
-template <typename T, int C>
+template <typename T>
 T tmain(T argc, T *argv) {
   T b = argc, c, d, e, f, g;
   static T a;
-  S<T> s;
 #pragma omp parallel
   a=2;
-#pragma omp parallel default(none), private(argc,b) firstprivate(argv) shared (d) if (argc > 0) num_threads(C) copyin(S<T>::TS) proc_bind(master) reduction(+:c) reduction(max:e)
-  foo();
-#pragma omp parallel if (C) num_threads(s) proc_bind(close) reduction(^:e, f) reduction(&& : g)
+#pragma omp parallel default(none), private(argc,b) firstprivate(argv) shared (d)
   foo();
   return 0;
 }
-
-// CHECK: template <typename T = int, int C = 5> int tmain(int argc, int *argv) {
+// CHECK: template <typename T = int> int tmain(int argc, int *argv) {
 // CHECK-NEXT: int b = argc, c, d, e, f, g;
 // CHECK-NEXT: static int a;
-// CHECK-NEXT: S<int> s;
 // CHECK-NEXT: #pragma omp parallel
 // CHECK-NEXT: a = 2;
-// CHECK-NEXT: #pragma omp parallel default(none) private(argc,b) firstprivate(argv) shared(d) if(argc > 0) num_threads(5) copyin(S<int>::TS) proc_bind(master) reduction(+: c) reduction(max: e)
-// CHECK-NEXT: foo()
-// CHECK-NEXT: #pragma omp parallel if(5) num_threads(s) proc_bind(close) reduction(^: e,f) reduction(&&: g)
+// CHECK-NEXT: #pragma omp parallel default(none) private(argc,b) firstprivate(argv) shared(d)
 // CHECK-NEXT: foo()
-// CHECK: template <typename T = long, int C = 1> long tmain(long argc, long *argv) {
-// CHECK-NEXT: long b = argc, c, d, e, f, g;
-// CHECK-NEXT: static long a;
-// CHECK-NEXT: S<long> s;
+// CHECK: template <typename T = float> float tmain(float argc, float *argv) {
+// CHECK-NEXT: float b = argc, c, d, e, f, g;
+// CHECK-NEXT: static float a;
 // CHECK-NEXT: #pragma omp parallel
 // CHECK-NEXT: a = 2;
-// CHECK-NEXT: #pragma omp parallel default(none) private(argc,b) firstprivate(argv) shared(d) if(argc > 0) num_threads(1) copyin(S<long>::TS) proc_bind(master) reduction(+: c) reduction(max: e)
+// CHECK-NEXT: #pragma omp parallel default(none) private(argc,b) firstprivate(argv) shared(d)
 // CHECK-NEXT: foo()
-// CHECK-NEXT: #pragma omp parallel if(1) num_threads(s) proc_bind(close) reduction(^: e,f) reduction(&&: g)
-// CHECK-NEXT: foo()
-// CHECK: template <typename T, int C> T tmain(T argc, T *argv) {
+// CHECK: template <typename T> T tmain(T argc, T *argv) {
 // CHECK-NEXT: T b = argc, c, d, e, f, g;
 // CHECK-NEXT: static T a;
-// CHECK-NEXT: S<T> s;
 // CHECK-NEXT: #pragma omp parallel
 // CHECK-NEXT: a = 2;
-// CHECK-NEXT: #pragma omp parallel default(none) private(argc,b) firstprivate(argv) shared(d) if(argc > 0) num_threads(C) copyin(S<T>::TS) proc_bind(master) reduction(+: c) reduction(max: e)
-// CHECK-NEXT: foo()
-// CHECK-NEXT: #pragma omp parallel if(C) num_threads(s) proc_bind(close) reduction(^: e,f) reduction(&&: g)
+// CHECK-NEXT: #pragma omp parallel default(none) private(argc,b) firstprivate(argv) shared(d)
 // CHECK-NEXT: foo()
 
-enum Enum { };
-
 int main (int argc, char **argv) {
-  long x;
+  float x;
   int b = argc, c, d, e, f, g;
   static int a;
-  #pragma omp threadprivate(a)
-  Enum ee;
-// CHECK: Enum ee;
+// CHECK: static int a;
 #pragma omp parallel
 // CHECK-NEXT: #pragma omp parallel
   a=2;
 // CHECK-NEXT: a = 2;
-#pragma omp parallel default(none), private(argc,b) firstprivate(argv) if (argc > 0) num_threads(ee) copyin(a) proc_bind(spread) reduction(| : c, d) reduction(* : e)
-// CHECK-NEXT: #pragma omp parallel default(none) private(argc,b) firstprivate(argv) if(argc > 0) num_threads(ee) copyin(a) proc_bind(spread) reduction(|: c,d) reduction(*: e)
+#pragma omp parallel if(a) num_threads(a), default(none), private(argc,b),firstprivate(argv, c),shared(d,f),reduction(+:e) reduction(min : g) proc_bind(master)
+// CHECK: #pragma omp parallel if(a) num_threads(a) default(none) private(argc,b) firstprivate(argv,c) shared(d,f) reduction(+: e) reduction(min: g) proc_bind(master)
   foo();
 // CHECK-NEXT: foo();
-  return tmain<int, 5>(b, &b) + tmain<long, 1>(x, &x);
+  return tmain(b, &b) + tmain(x, &x);
 }
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_codegen.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_codegen.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_codegen.cpp	2014-06-02 17:47:14.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_codegen.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,145 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -x c++ -emit-llvm %s -fexceptions -fcxx-exceptions -o - | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -triple x86_64-unknown-unknown -fexceptions -fcxx-exceptions -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -triple x86_64-unknown-unknown -fexceptions -fcxx-exceptions -g -std=c++11 -include-pch %t -verify %s -emit-llvm -o - | FileCheck --check-prefix=CHECK-DEBUG %s
-// expected-no-diagnostics
-#ifndef HEADER
-#define HEADER
-
-// CHECK-DAG: %ident_t = type { i32, i32, i32, i32, i8* }
-// CHECK-DAG: %struct.anon = type { i32* }
-// CHECK-DAG: %struct.anon.0 = type { i8*** }
-// CHECK-DAG: [[STR:@.+]] = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00"
-// CHECK-DAG: [[DEF_LOC_2:@.+]] = private unnamed_addr constant %ident_t { i32 0, i32 2, i32 0, i32 0, i8* getelementptr inbounds ([23 x i8]* [[STR]], i32 0, i32 0) }
-// CHECK-DEBUG-DAG: %ident_t = type { i32, i32, i32, i32, i8* }
-// CHECK-DEBUG-DAG: %struct.anon = type { i32* }
-// CHECK-DEBUG-DAG: %struct.anon.0 = type { i8*** }
-// CHECK-DEBUG-DAG: [[STR:@.+]] = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00"
-// CHECK-DEBUG-DAG: [[DEF_LOC_2:@.+]] = private unnamed_addr constant %ident_t { i32 0, i32 2, i32 0, i32 0, i8* getelementptr inbounds ([23 x i8]* [[STR]], i32 0, i32 0) }
-// CHECK-DEBUG-DAG: [[LOC1:@.+]] = private unnamed_addr constant [{{.+}} x i8] c";{{.*}}parallel_codegen.cpp;main;[[@LINE+14]];9;;\00"
-// CHECK-DEBUG-DAG: [[LOC2:@.+]] = private unnamed_addr constant [{{.+}} x i8] c";{{.*}}parallel_codegen.cpp;tmain;[[@LINE+7]];9;;\00"
-
-template <class T>
-void foo(T argc) {}
-
-template <typename T>
-int tmain(T argc) {
-#pragma omp parallel
-  foo(argc);
-  return 0;
-}
-
-int main (int argc, char **argv) {
-#pragma omp parallel
-  foo(argc);
-  return tmain(argv);
-}
-
-// CHECK-LABEL: define {{[a-z]*[ ]?i32}} @main({{i32[ ]?[a-z]*}} %argc, i8** %argv)
-// CHECK:       [[AGG_CAPTURED:%.+]] = alloca %struct.anon
-// CHECK:       [[ARGC_REF:%.+]] = getelementptr inbounds %struct.anon* [[AGG_CAPTURED]], i32 0, i32 0
-// CHECK-NEXT:  store i32* {{%[a-z0-9.]+}}, i32** [[ARGC_REF]]
-// CHECK-NEXT:  [[BITCAST:%.+]] = bitcast %struct.anon* [[AGG_CAPTURED]] to i8*
-// CHECK-NEXT:  call void (%ident_t*, i32, void (i32*, i32*, ...)*, ...)* @__kmpc_fork_call(%ident_t* [[DEF_LOC_2]], i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, %struct.anon*)* @__captured_stmt to void (i32*, i32*, ...)*), i8* [[BITCAST]])
-// CHECK-NEXT:  [[ARGV:%.+]] = load i8*** {{%[a-z0-9.]+}}
-// CHECK-NEXT:  [[RET:%.+]] = call {{[a-z]*[ ]?i32}} [[TMAIN:@.+tmain.+]](i8** [[ARGV]])
-// CHECK-NEXT:  ret i32 [[RET]]
-// CHECK-NEXT:  }
-// CHECK-DEBUG-LABEL: define i32 @main(i32 %argc, i8** %argv)
-// CHECK-DEBUG-DAG:   [[AGG_CAPTURED:%.+]] = alloca %struct.anon
-// CHECK-DEBUG-DAG:   [[LOC_2_ADDR:%.+]] = alloca %ident_t
-// CHECK-DEBUG:       [[KMPC_LOC_VOIDPTR:%.+]] = bitcast %ident_t* [[LOC_2_ADDR]] to i8*
-// CHECK-DEBUG-NEXT:  [[KMPC_DEFAULT_LOC_VOIDPTR:%.+]] = bitcast %ident_t* [[DEF_LOC_2]] to i8*
-// CHECK-DEBUG-NEXT:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* [[KMPC_LOC_VOIDPTR]], i8* [[KMPC_DEFAULT_LOC_VOIDPTR]], i64 ptrtoint (%ident_t* getelementptr (%ident_t* null, i32 1) to i64), i32 8, i1 false)
-// CHECK-DEBUG:       [[ARGC_REF:%.+]] = getelementptr inbounds %struct.anon* [[AGG_CAPTURED]], i32 0, i32 0
-// CHECK-DEBUG-NEXT:  store i32* {{%[a-z0-9.]+}}, i32** [[ARGC_REF]]
-// CHECK-DEBUG-NEXT:  [[KMPC_LOC_PSOURCE_REF:%.+]] = getelementptr inbounds %ident_t* [[LOC_2_ADDR]], i32 0, i32 4
-// CHECK-DEBUG-NEXT:  store i8* getelementptr inbounds ([{{.+}} x i8]* [[LOC1]], i32 0, i32 0), i8** [[KMPC_LOC_PSOURCE_REF]]
-// CHECK-DEBUG-NEXT:  [[BITCAST:%.+]] = bitcast %struct.anon* [[AGG_CAPTURED]] to i8*
-// CHECK-DEBUG-NEXT:  call void (%ident_t*, i32, void (i32*, i32*, ...)*, ...)* @__kmpc_fork_call(%ident_t* [[LOC_2_ADDR]], i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, %struct.anon*)* @__captured_stmt to void (i32*, i32*, ...)*), i8* [[BITCAST]])
-// CHECK-DEBUG-NEXT:  [[ARGV:%.+]] = load i8*** {{%[a-z0-9.]+}}
-// CHECK-DEBUG-NEXT:  [[RET:%.+]] = call i32 [[TMAIN:@.+tmain.+]](i8** [[ARGV]])
-// CHECK-DEBUG-NEXT:  ret i32 [[RET]]
-// CHECK-DEBUG-NEXT:  }
-
-// CHECK-LABEL: define internal void @__captured_stmt(i32* %.global_tid., i32* %.bound_tid., %struct.anon* %__context)
-// CHECK:       [[CONTEXT_ADDR:%.+]] = alloca %struct.anon*
-// CHECK:       store %struct.anon* %__context, %struct.anon** [[CONTEXT_ADDR]]
-// CHECK:       [[CONTEXT_PTR:%.+]] = load %struct.anon** [[CONTEXT_ADDR]]
-// CHECK-NEXT:  [[ARGC_PTR_REF:%.+]] = getelementptr inbounds %struct.anon* [[CONTEXT_PTR]], i32 0, i32 0
-// CHECK-NEXT:  [[ARGC_REF:%.+]] = load i32** [[ARGC_PTR_REF]]
-// CHECK-NEXT:  [[ARGC:%.+]] = load i32* [[ARGC_REF]]
-// CHECK-NEXT:  invoke void [[FOO:@.+foo.+]](i32{{[ ]?[a-z]*}} [[ARGC]])
-// CHECK:       ret void
-// CHECK:       call void @{{.+terminate.*}}(
-// CHECK-NEXT:  unreachable
-// CHECK-NEXT:  }
-// CHECK-DEBUG-LABEL: define internal void @__captured_stmt(i32* %.global_tid., i32* %.bound_tid., %struct.anon* %__context)
-// CHECK-DEBUG:       [[CONTEXT_ADDR:%.+]] = alloca %struct.anon*
-// CHECK-DEBUG:       store %struct.anon* %__context, %struct.anon** [[CONTEXT_ADDR]]
-// CHECK-DEBUG:       [[CONTEXT_PTR:%.+]] = load %struct.anon** [[CONTEXT_ADDR]]
-// CHECK-DEBUG-NEXT:  [[ARGC_PTR_REF:%.+]] = getelementptr inbounds %struct.anon* [[CONTEXT_PTR]], i32 0, i32 0
-// CHECK-DEBUG-NEXT:  [[ARGC_REF:%.+]] = load i32** [[ARGC_PTR_REF]]
-// CHECK-DEBUG-NEXT:  [[ARGC:%.+]] = load i32* [[ARGC_REF]]
-// CHECK-DEBUG-NEXT:  invoke void [[FOO:@.+foo.+]](i32 [[ARGC]])
-// CHECK-DEBUG:       ret void
-// CHECK-DEBUG:       call void @{{.+terminate.*}}(
-// CHECK-DEBUG-NEXT:  unreachable
-// CHECK-DEBUG-NEXT:  }
-
-// CHECK-DAG: define linkonce_odr void [[FOO]]({{i32[ ]?[a-z]*}} %argc)
-// CHECK-DAG: declare void @__kmpc_fork_call(%ident_t*, i32, void (i32*, i32*, ...)*, ...)
-// CHECK-DEBUG-DAG: define linkonce_odr void [[FOO]](i32 %argc)
-// CHECK-DEBUG-DAG: declare void @__kmpc_fork_call(%ident_t*, i32, void (i32*, i32*, ...)*, ...)
-
-// CHECK:       define linkonce_odr {{[a-z]*[ ]?i32}} [[TMAIN]](i8** %argc)
-// CHECK:       [[AGG_CAPTURED:%.+]] = alloca %struct.anon.0
-// CHECK:       [[ARGC_REF:%.+]] = getelementptr inbounds %struct.anon.0* [[AGG_CAPTURED]], i32 0, i32 0
-// CHECK-NEXT:  store i8*** {{%[a-z0-9.]+}}, i8**** [[ARGC_REF]]
-// CHECK-NEXT:  [[BITCAST:%.+]] = bitcast %struct.anon.0* [[AGG_CAPTURED]] to i8*
-// CHECK-NEXT:  call void (%ident_t*, i32, void (i32*, i32*, ...)*, ...)* @__kmpc_fork_call(%ident_t* [[DEF_LOC_2]], i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, %struct.anon.0*)* @__captured_stmt1 to void (i32*, i32*, ...)*), i8* [[BITCAST]])
-// CHECK-NEXT:  ret i32 0
-// CHECK-NEXT:  }
-// CHECK-DEBUG:       define linkonce_odr i32 [[TMAIN]](i8** %argc)
-// CHECK-DEBUG-DAG:   [[AGG_CAPTURED:%.+]] = alloca %struct.anon.0
-// CHECK-DEBUG-DAG:   [[LOC_2_ADDR:%.+]] = alloca %ident_t
-// CHECK-DEBUG:       [[KMPC_LOC_VOIDPTR:%.+]] = bitcast %ident_t* [[LOC_2_ADDR]] to i8*
-// CHECK-DEBUG-NEXT:  [[KMPC_DEFAULT_LOC_VOIDPTR:%.+]] = bitcast %ident_t* [[DEF_LOC_2]] to i8*
-// CHECK-DEBUG-NEXT:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* [[KMPC_LOC_VOIDPTR]], i8* [[KMPC_DEFAULT_LOC_VOIDPTR]], i64 ptrtoint (%ident_t* getelementptr (%ident_t* null, i32 1) to i64), i32 8, i1 false)
-// CHECK-DEBUG:       [[ARGC_REF:%.+]] = getelementptr inbounds %struct.anon.0* [[AGG_CAPTURED]], i32 0, i32 0
-// CHECK-DEBUG-NEXT:  store i8*** {{%[a-z0-9.]+}}, i8**** [[ARGC_REF]]
-// CHECK-DEBUG-NEXT:  [[KMPC_LOC_PSOURCE_REF:%.+]] = getelementptr inbounds %ident_t* [[LOC_2_ADDR]], i32 0, i32 4
-// CHECK-DEBUG-NEXT:  store i8* getelementptr inbounds ([{{.+}} x i8]* [[LOC2]], i32 0, i32 0), i8** [[KMPC_LOC_PSOURCE_REF]]
-// CHECK-DEBUG-NEXT:  [[BITCAST:%.+]] = bitcast %struct.anon.0* [[AGG_CAPTURED]] to i8*
-// CHECK-DEBUG-NEXT:  call void (%ident_t*, i32, void (i32*, i32*, ...)*, ...)* @__kmpc_fork_call(%ident_t* [[LOC_2_ADDR]], i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, %struct.anon.0*)* @__captured_stmt1 to void (i32*, i32*, ...)*), i8* [[BITCAST]])
-// CHECK-DEBUG-NEXT:  ret i32 0
-// CHECK-DEBUG-NEXT:  }
-
-// CHECK-LABEL: define internal void @__captured_stmt1(i32* %.global_tid., i32* %.bound_tid., %struct.anon.0* %__context)
-// CHECK:       [[CONTEXT_ADDR:%.+]] = alloca %struct.anon.0*
-// CHECK:       store %struct.anon.0* %__context, %struct.anon.0** [[CONTEXT_ADDR]]
-// CHECK:       [[CONTEXT_PTR:%.+]] = load %struct.anon.0** [[CONTEXT_ADDR]]
-// CHECK-NEXT:  [[ARGC_PTR_REF:%.+]] = getelementptr inbounds %struct.anon.0* [[CONTEXT_PTR]], i32 0, i32 0
-// CHECK-NEXT:  [[ARGC_REF:%.+]] = load i8**** [[ARGC_PTR_REF]]
-// CHECK-NEXT:  [[ARGC:%.+]] = load i8*** [[ARGC_REF]]
-// CHECK-NEXT:  invoke void [[FOO1:@.+foo.+]](i8** [[ARGC]])
-// CHECK:       ret void
-// CHECK:       call void @{{.+terminate.*}}(
-// CHECK-NEXT:  unreachable
-// CHECK-NEXT:  }
-// CHECK-DEBUG-LABEL: define internal void @__captured_stmt1(i32* %.global_tid., i32* %.bound_tid., %struct.anon.0* %__context)
-// CHECK-DEBUG:       [[CONTEXT_ADDR:%.+]] = alloca %struct.anon.0*
-// CHECK-DEBUG:       store %struct.anon.0* %__context, %struct.anon.0** [[CONTEXT_ADDR]]
-// CHECK-DEBUG:       [[CONTEXT_PTR:%.+]] = load %struct.anon.0** [[CONTEXT_ADDR]]
-// CHECK-DEBUG-NEXT:  [[ARGC_PTR_REF:%.+]] = getelementptr inbounds %struct.anon.0* [[CONTEXT_PTR]], i32 0, i32 0
-// CHECK-DEBUG-NEXT:  [[ARGC_REF:%.+]] = load i8**** [[ARGC_PTR_REF]]
-// CHECK-DEBUG-NEXT:  [[ARGC:%.+]] = load i8*** [[ARGC_REF]]
-// CHECK-DEBUG-NEXT:  invoke void [[FOO1:@.+foo.+]](i8** [[ARGC]])
-// CHECK-DEBUG:       ret void
-// CHECK-DEBUG:       call void @{{.+terminate.*}}(
-// CHECK-DEBUG-NEXT:  unreachable
-// CHECK-DEBUG-NEXT:  }
-
-// CHECK: define linkonce_odr void [[FOO1]](i8** %argc)
-// CHECK-DEBUG: define linkonce_odr void [[FOO1]](i8** %argc)
-
-#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_copyin_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_copyin_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_copyin_messages.cpp	2014-03-30 23:36:38.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_copyin_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -34,12 +34,6 @@
 public:
   S5(int v):a(v) { }
 };
-template <class T>
-class ST {
-public:
-  static T s;
-};
-
 
 S2 k;
 S3 h;
@@ -49,7 +43,7 @@
 
 int main(int argc, char **argv) {
   int i;
-  #pragma omp parallel copyin // expected-error {{expected '(' after 'copyin'}}
+  #pragma omp parallel copyin // expected-error {{expected '(' after 'copyin'}} expected-error {{expected expression}}
   #pragma omp parallel copyin ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   #pragma omp parallel copyin () // expected-error {{expected expression}}
   #pragma omp parallel copyin (k // expected-error {{expected ')'}} expected-note {{to match this '('}}
@@ -60,7 +54,6 @@
   #pragma omp parallel copyin (argv[1]) // expected-error {{expected variable name}}
   #pragma omp parallel copyin(i) // expected-error {{copyin variable must be threadprivate}}
   #pragma omp parallel copyin(m) // expected-error {{copyin variable must have an accessible, unambiguous copy assignment operator}}
-  #pragma omp parallel copyin(ST<int>::s) // expected-error {{copyin variable must be threadprivate}}
   foo();
 
   return 0;
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_default_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_default_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_default_messages.cpp	2014-03-06 00:43:53.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_default_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,9 +1,9 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 -o - %s
 
 void foo();
 
 int main(int argc, char **argv) {
-  #pragma omp parallel default // expected-error {{expected '(' after 'default'}}
+  #pragma omp parallel default // expected-error {{expected '(' after 'default'}} expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
   #pragma omp parallel default ( // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   #pragma omp parallel default () // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
   #pragma omp parallel default (none // expected-error {{expected ')'}} expected-note {{to match this '('}}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_firstprivate_messages.cpp	2014-03-06 00:43:53.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_firstprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -54,7 +54,7 @@
   S5 g(5); // expected-note {{'g' defined here}}
   int i;
   int &j = i; // expected-note {{'j' defined here}}
-  #pragma omp parallel firstprivate // expected-error {{expected '(' after 'firstprivate'}}
+  #pragma omp parallel firstprivate // expected-error {{expected '(' after 'firstprivate'}} expected-error {{expected expression}}
   #pragma omp parallel firstprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   #pragma omp parallel firstprivate () // expected-error {{expected expression}}
   #pragma omp parallel firstprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_ast_print.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
 // expected-no-diagnostics
 
 #ifndef HEADER
@@ -8,57 +8,68 @@
 
 void foo() {}
 
-template <class T, int N>
-T tmain(T argc) {
-  T b = argc, c, d, e, f, h;
-  static T a;
-// CHECK: static T a;
-  static T g;
-#pragma omp threadprivate(g)
-#pragma omp parallel for schedule(dynamic) default(none) copyin(g)
-  // CHECK: #pragma omp parallel for schedule(dynamic) default(none) copyin(g)
-  for (int i = 0; i < 2; ++i)
-    a = 2;
-// CHECK-NEXT: for (int i = 0; i < 2; ++i)
-// CHECK-NEXT: a = 2;
-#pragma omp parallel for private(argc, b), firstprivate(c, d), lastprivate(d, f) collapse(N) schedule(static, N) ordered if (argc) num_threads(N) default(shared) shared(e) reduction(+ : h)
-  for (int i = 0; i < 10; ++i)
-    for (int j = 0; j < 10; ++j)
-      for (int j = 0; j < 10; ++j)
-        for (int j = 0; j < 10; ++j)
-          for (int j = 0; j < 10; ++j)
-            foo();
-  // CHECK-NEXT: #pragma omp parallel for private(argc,b) firstprivate(c,d) lastprivate(d,f) collapse(N) schedule(static, N) ordered if(argc) num_threads(N) default(shared) shared(e) reduction(+: h)
-  // CHECK-NEXT: for (int i = 0; i < 10; ++i)
-  // CHECK-NEXT: for (int j = 0; j < 10; ++j)
-  // CHECK-NEXT: for (int j = 0; j < 10; ++j)
-  // CHECK-NEXT: for (int j = 0; j < 10; ++j)
-  // CHECK-NEXT: for (int j = 0; j < 10; ++j)
-  // CHECK-NEXT: foo();
-  return T();
+template<class T, class N> T reduct(T* arr, N num) {
+  N i;
+  N ind;
+  T sum = (T)0;
+// CHECK: T sum = (T)0;
+#pragma omp parallel for reduction(+:sum) proc_bind(master)
+// CHECK-NEXT: #pragma omp parallel for reduction(+: sum) proc_bind(master)
+  for (i = 0; i < num; ++i) {
+    T cur = arr[ind];
+    ++ind;
+    sum += cur;
+  }
 }
 
-int main(int argc, char **argv) {
-  int b = argc, c, d, e, f, h;
-  static int a;
-// CHECK: static int a;
-  static float g;
-#pragma omp threadprivate(g)
-#pragma omp parallel for schedule(guided, argc) default(none) copyin(g)
-  // CHECK: #pragma omp parallel for schedule(guided, argc) default(none) copyin(g)
-  for (int i = 0; i < 2; ++i)
-    a = 2;
+template<class T> struct S {
+  S(const T &a)
+    :m_a(a)
+  {}
+  T result(T *v) const {
+    T res;
+// CHECK: T res;
+#pragma omp parallel for lastprivate(res) if(m_a)
+// CHECK-NEXT: #pragma omp parallel for lastprivate(res) if(this->m_a)
+    for (T i = 7; i < m_a; ++i) {
+      res = v[i-7] + m_a;
+    }
+    return res;
+  }
+  ~S()
+  {}
+  T m_a;
+};
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  int k1=0,k2=0;
+  static int *a;
+// CHECK: static int *a;
+#pragma omp parallel for
+// CHECK-NEXT: #pragma omp parallel for
+  for (int i=0; i < 2; ++i)*a=2;
 // CHECK-NEXT: for (int i = 0; i < 2; ++i)
-// CHECK-NEXT: a = 2;
-#pragma omp parallel for private(argc, b), firstprivate(argv, c), lastprivate(d, f) collapse(2) schedule(auto) ordered if (argc) num_threads(a) default(shared) shared(e) reduction(+ : h)
+// CHECK-NEXT: *a = 2;
+#pragma omp parallel for private(argc,b),lastprivate(d,f),reduction(+:e) reduction(min : g),  collapse(2)
   for (int i = 0; i < 10; ++i)
-    for (int j = 0; j < 10; ++j)
-      foo();
-  // CHECK-NEXT: #pragma omp parallel for private(argc,b) firstprivate(argv,c) lastprivate(d,f) collapse(2) schedule(auto) ordered if(argc) num_threads(a) default(shared) shared(e) reduction(+: h)
-  // CHECK-NEXT: for (int i = 0; i < 10; ++i)
-  // CHECK-NEXT: for (int j = 0; j < 10; ++j)
-  // CHECK-NEXT: foo();
-  return (tmain<int, 5>(argc) + tmain<char, 1>(argv[0][0]));
+  for (int j = 0; j < 10; ++j) {foo(); k1 += 8; k2 += 8;}
+// CHECK-NEXT: #pragma omp parallel for private(argc,b) lastprivate(d,f) reduction(+: e) reduction(min: g) collapse(2)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j) {
+// CHECK-NEXT: foo();
+// CHECK-NEXT: k1 += 8;
+// CHECK-NEXT: k2 += 8;
+// CHECK-NEXT: }
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp parallel for collapse(1)
+// CHECK:      #pragma omp parallel for collapse(1)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
 }
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_collapse_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_collapse_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_collapse_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_collapse_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,83 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note {{declared here}}
-
-template <class T, typename S, int N, int ST> // expected-note {{declared here}}
-T tmain(T argc, S **argv) { //expected-note 2 {{declared here}}
-  #pragma omp parallel for collapse // expected-error {{expected '(' after 'collapse'}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for collapse ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for collapse () // expected-error {{expected expression}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
-  // expected-error@+2 2 {{expression is not an integral constant expression}}
-  // expected-note@+1 2 {{read of non-const variable 'argc' is not allowed in a constant expression}}
-  #pragma omp parallel for collapse (argc 
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+1 2 {{argument to 'collapse' clause must be a positive integer value}}
-  #pragma omp parallel for collapse (ST // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for collapse (1)) // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for collapse ((ST > 0) ? 1 + ST : 2) // expected-note 2 {{as specified in 'collapse' clause}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST]; // expected-error 2 {{expected 2 for loops after '#pragma omp parallel for', but found only 1}}
-  // expected-error@+3 2 {{directive '#pragma omp parallel for' cannot contain more than one 'collapse' clause}}
-  // expected-error@+2 2 {{argument to 'collapse' clause must be a positive integer value}}
-  // expected-error@+1 2 {{expression is not an integral constant expression}}
-  #pragma omp parallel for collapse (foobool(argc)), collapse (true), collapse (-5)
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for collapse (S) // expected-error {{'S' does not refer to a value}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+1 2 {{expression is not an integral constant expression}}
-  #pragma omp parallel for collapse (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for collapse (1)
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for collapse (N) // expected-error {{argument to 'collapse' clause must be a positive integer value}}
-  for (T i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for collapse (2) // expected-note {{as specified in 'collapse' clause}}
-  foo(); // expected-error {{expected 2 for loops after '#pragma omp parallel for'}}
-  return argc;
-}
-
-int main(int argc, char **argv) {
-  #pragma omp parallel for collapse // expected-error {{expected '(' after 'collapse'}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for collapse ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for collapse () // expected-error {{expected expression}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for collapse (4 // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-note {{as specified in 'collapse' clause}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4]; // expected-error {{expected 4 for loops after '#pragma omp parallel for', but found only 1}}
-  #pragma omp parallel for collapse (2+2)) // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}  expected-note {{as specified in 'collapse' clause}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4]; // expected-error {{expected 4 for loops after '#pragma omp parallel for', but found only 1}}
-  #pragma omp parallel for collapse (foobool(1) > 0 ? 1 : 2) // expected-error {{expression is not an integral constant expression}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+3 {{expression is not an integral constant expression}}
-  // expected-error@+2 2 {{directive '#pragma omp parallel for' cannot contain more than one 'collapse' clause}}
-  // expected-error@+1 2 {{argument to 'collapse' clause must be a positive integer value}}
-  #pragma omp parallel for collapse (foobool(argc)), collapse (true), collapse (-5) 
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for collapse (S1) // expected-error {{'S1' does not refer to a value}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+1 {{expression is not an integral constant expression}}
-  #pragma omp parallel for collapse (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+3 {{statement after '#pragma omp parallel for' must be a for loop}}
-  // expected-note@+1 {{in instantiation of function template specialization 'tmain<int, char, -1, -2>' requested here}}
-  #pragma omp parallel for collapse(collapse(tmain<int, char, -1, -2>(argc, argv) // expected-error 2 {{expected ')'}} expected-note 2 {{to match this '('}}
-  foo();
-  #pragma omp parallel for collapse (2) // expected-note {{as specified in 'collapse' clause}}
-  foo(); // expected-error {{expected 2 for loops after '#pragma omp parallel for'}}
-  // expected-note@+1 {{in instantiation of function template specialization 'tmain<int, char, 1, 0>' requested here}}
-  return tmain<int, char, 1, 0>(argc, argv);
-}
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_copyin_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_copyin_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_copyin_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_copyin_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,93 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note {{declared here}}
-class S2 {
-  mutable int a;
-
-public:
-  S2() : a(0) {}
-  S2 &operator=(S2 &s2) { return *this; }
-};
-class S3 {
-  int a;
-
-public:
-  S3() : a(0) {}
-  S3 &operator=(S3 &s3) { return *this; }
-};
-class S4 { // expected-note {{'S4' declared here}}
-  int a;
-  S4();
-  S4 &operator=(const S4 &s4);
-
-public:
-  S4(int v) : a(v) {}
-};
-class S5 { // expected-note {{'S5' declared here}}
-  int a;
-  S5() : a(0) {}
-  S5 &operator=(const S5 &s5) { return *this; }
-
-public:
-  S5(int v) : a(v) {}
-};
-template <class T>
-class ST {
-public:
-  static T s;
-};
-
-S2 k;
-S3 h;
-S4 l(3); // expected-note {{'l' defined here}}
-S5 m(4); // expected-note {{'m' defined here}}
-#pragma omp threadprivate(h, k, l, m)
-
-int main(int argc, char **argv) {
-  int i;
-#pragma omp parallel for copyin // expected-error {{expected '(' after 'copyin'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for copyin( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for copyin() // expected-error {{expected expression}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for copyin(k // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for copyin(h, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for copyin(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for copyin(l) // expected-error {{copyin variable must have an accessible, unambiguous copy assignment operator}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for copyin(S1) // expected-error {{'S1' does not refer to a value}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for copyin(argv[1]) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for copyin(i) // expected-error {{copyin variable must be threadprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for copyin(m) // expected-error {{copyin variable must have an accessible, unambiguous copy assignment operator}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for copyin(ST < int > ::s) // expected-error {{copyin variable must be threadprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-
-  return 0;
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_default_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_default_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_default_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_default_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,36 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
-
-void foo();
-
-int main(int argc, char **argv) {
-  int i;
-#pragma omp parallel for default // expected-error {{expected '(' after 'default'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for default( // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for default() // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for default(none // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
-    foo();
-#pragma omp parallel for default(shared), default(shared) // expected-error {{directive '#pragma omp parallel for' cannot contain more than one 'default' clause}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for default(x) // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-
-#pragma omp parallel for default(none)
-  for (i = 0; i < argc; ++i)  // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
-    foo();
-
-#pragma omp parallel default(none)
-#pragma omp parallel for default(shared)
-  for (i = 0; i < argc; ++i)
-    foo();
-
-  return 0;
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_firstprivate_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_firstprivate_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,252 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
-extern S1 a;
-class S2 {
-  mutable int a;
-
-public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-  static float S2s;
-  static const float S2sc;
-};
-const float S2::S2sc = 0;
-const S2 b;
-const S2 ba[5];
-class S3 {
-  int a;
-  S3 &operator=(const S3 &s3);
-
-public:
-  S3() : a(0) {}
-  S3(S3 &s3) : a(s3.a) {}
-};
-const S3 c;
-const S3 ca[5];
-extern const int f;
-class S4 { // expected-note 2 {{'S4' declared here}}
-  int a;
-  S4();
-  S4(const S4 &s4);
-
-public:
-  S4(int v) : a(v) {}
-};
-class S5 { // expected-note 4 {{'S5' declared here}}
-  int a;
-  S5(const S5 &s5) : a(s5.a) {}
-
-public:
-  S5() : a(0) {}
-  S5(int v) : a(v) {}
-};
-class S6 {
-  int a;
-  S6() : a(0) {}
-
-public:
-  S6(const S6 &s6) : a(s6.a) {}
-  S6(int v) : a(v) {}
-};
-
-S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class I, class C>
-int foomain(int argc, char **argv) {
-  I e(4); // expected-note {{'e' defined here}}
-  C g(5); // expected-note 2 {{'g' defined here}}
-  int i;
-  int &j = i; // expected-note {{'j' defined here}}
-#pragma omp parallel for firstprivate // expected-error {{expected '(' after 'firstprivate'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for firstprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for firstprivate() // expected-error {{expected expression}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for firstprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for firstprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for firstprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for firstprivate(argc)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for firstprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for firstprivate(a, b) // expected-error {{firstprivate variable with incomplete type 'S1'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for firstprivate(argv[1]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for linear(i) // expected-error {{unexpected OpenMP clause 'linear' in directive '#pragma omp parallel for'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;
-#pragma omp parallel for firstprivate(i)
-    for (int k = 0; k < argc; ++k) {
-      i = k;
-      v += i;
-    }
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp parallel for firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for firstprivate(i)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for lastprivate(g) firstprivate(g) // expected-error {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel private(i)
-#pragma omp parallel for firstprivate(i) // expected-note {{defined as firstprivate}}
-  for (i = 0; i < argc; ++i) // expected-error {{loop iteration variable in the associated loop of 'omp parallel for' directive may not be firstprivate, predetermined as private}}
-    foo();
-#pragma omp parallel reduction(+ : i)
-#pragma omp parallel for firstprivate(i) // expected-note {{defined as firstprivate}}
-  for (i = 0; i < argc; ++i) // expected-error {{loop iteration variable in the associated loop of 'omp parallel for' directive may not be firstprivate, predetermined as private}}
-    foo();
-  return 0;
-}
-
-int main(int argc, char **argv) {
-  const int d = 5;
-  const int da[5] = {0};
-  S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note 2 {{'g' defined here}}
-  S3 m;
-  S6 n(2);
-  int i;
-  int &j = i; // expected-note {{'j' defined here}}
-#pragma omp parallel for firstprivate // expected-error {{expected '(' after 'firstprivate'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate() // expected-error {{expected expression}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(argc)
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(argv[1]) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(2 * 2) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(ba) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(ca) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(da) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-  int xa;
-#pragma omp parallel for firstprivate(xa) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(S2::S2s) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(S2::S2sc) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for safelen(5) // expected-error {{unexpected OpenMP clause 'safelen' in directive '#pragma omp parallel for'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(m) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for private(xa), firstprivate(xa) // expected-error {{private variable cannot be firstprivate}} expected-note {{defined as private}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(i) // expected-note {{defined as firstprivate}}
-  for (i = 0; i < argc; ++i)    // expected-error {{loop iteration variable in the associated loop of 'omp parallel for' directive may not be firstprivate, predetermined as private}}
-    foo();
-#pragma omp parallel shared(xa)
-#pragma omp parallel for firstprivate(xa) // OK: may be firstprivate
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(g) firstprivate(g) // expected-error {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(n) firstprivate(n) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;
-#pragma omp parallel for firstprivate(i)
-    for (int k = 0; k < argc; ++k) {
-      i = k;
-      v += i;
-    }
-  }
-#pragma omp parallel private(i)
-#pragma omp parallel for firstprivate(i) // expected-note {{defined as firstprivate}}
-  for (i = 0; i < argc; ++i) // expected-error {{loop iteration variable in the associated loop of 'omp parallel for' directive may not be firstprivate, predetermined as private}}
-    foo();
-#pragma omp parallel reduction(+ : i)
-#pragma omp parallel for firstprivate(i) // expected-note {{defined as firstprivate}}
-  for (i = 0; i < argc; ++i) // expected-error {{loop iteration variable in the associated loop of 'omp parallel for' directive may not be firstprivate, predetermined as private}}
-    foo();
-
-  return foomain<S4, S5>(argc, argv); // expected-note {{in instantiation of function template specialization 'foomain<S4, S5>' requested here}}
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_if_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_if_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_if_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_if_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,69 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note {{declared here}}
-
-template <class T, class S> // expected-note {{declared here}}
-int tmain(T argc, S **argv) {
-  T i;
-  #pragma omp parallel for if // expected-error {{expected '(' after 'if'}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if () // expected-error {{expected expression}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (argc > 0 ? argv[1] : argv[2])
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp parallel for' cannot contain more than one 'if' clause}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (S) // expected-error {{'S' does not refer to a value}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (argc argc) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if(argc)
-  for (i = 0; i < argc; ++i) foo();
-
-  return 0;
-}
-
-int main(int argc, char **argv) {
-  int i;
-  #pragma omp parallel for if // expected-error {{expected '(' after 'if'}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if () // expected-error {{expected expression}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (argc > 0 ? argv[1] : argv[2])
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp parallel for' cannot contain more than one 'if' clause}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (S1) // expected-error {{'S1' does not refer to a value}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (argc argc) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if (1 0) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for if(if(tmain(argc, argv) // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-
-  return tmain(argc, argv);
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_lastprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_lastprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_lastprivate_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_lastprivate_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,226 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
-extern S1 a;
-class S2 {
-  mutable int a;
-
-public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-  static float S2s; // expected-note {{static data member is predetermined as shared}}
-  static const float S2sc;
-};
-const float S2::S2sc = 0; // expected-note {{static data member is predetermined as shared}}
-const S2 b;
-const S2 ba[5];
-class S3 { // expected-note 2 {{'S3' declared here}}
-  int a;
-  S3 &operator=(const S3 &s3);
-
-public:
-  S3() : a(0) {}
-  S3(S3 &s3) : a(s3.a) {}
-};
-const S3 c;         // expected-note {{global variable is predetermined as shared}}
-const S3 ca[5];     // expected-note {{global variable is predetermined as shared}}
-extern const int f; // expected-note {{global variable is predetermined as shared}}
-class S4 {          // expected-note 3 {{'S4' declared here}}
-  int a;
-  S4();
-  S4(const S4 &s4);
-
-public:
-  S4(int v) : a(v) {}
-};
-class S5 { // expected-note {{'S5' declared here}}
-  int a;
-  S5() : a(0) {}
-
-public:
-  S5(const S5 &s5) : a(s5.a) {}
-  S5(int v) : a(v) {}
-};
-class S6 {
-  int a;
-  S6() : a(0) {}
-
-public:
-  S6(const S6 &s6) : a(s6.a) {}
-  S6(int v) : a(v) {}
-};
-
-S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class I, class C>
-int foomain(int argc, char **argv) {
-  I e(4); // expected-note {{'e' defined here}}
-  I g(5); // expected-note {{'g' defined here}}
-  int i;
-  int &j = i;                        // expected-note {{'j' defined here}}
-#pragma omp parallel for lastprivate // expected-error {{expected '(' after 'lastprivate'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for lastprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for lastprivate() // expected-error {{expected expression}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for lastprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for lastprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for lastprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for lastprivate(argc)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for lastprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for lastprivate(a, b) // expected-error {{lastprivate variable with incomplete type 'S1'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for lastprivate(argv[1]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for lastprivate(e, g) // expected-error 2 {{lastprivate variable must have an accessible, unambiguous default constructor}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for lastprivate(h) // expected-error {{threadprivate or thread local variable cannot be lastprivate}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for linear(i) // expected-error {{unexpected OpenMP clause 'linear' in directive '#pragma omp parallel for'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;
-#pragma omp parallel for lastprivate(i)
-    for (int k = 0; k < argc; ++k) {
-      i = k;
-      v += i;
-    }
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp parallel for lastprivate(j) // expected-error {{arguments of OpenMP clause 'lastprivate' cannot be of reference type}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for lastprivate(i)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-  return 0;
-}
-
-int main(int argc, char **argv) {
-  const int d = 5;       // expected-note {{constant variable is predetermined as shared}}
-  const int da[5] = {0}; // expected-note {{constant variable is predetermined as shared}}
-  S4 e(4);               // expected-note {{'e' defined here}}
-  S5 g(5);               // expected-note {{'g' defined here}}
-  S3 m;                  // expected-note 2 {{'m' defined here}}
-  S6 n(2);
-  int i;
-  int &j = i;                        // expected-note {{'j' defined here}}
-#pragma omp parallel for lastprivate // expected-error {{expected '(' after 'lastprivate'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate() // expected-error {{expected expression}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(argc)
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(a, b, c, d, f) // expected-error {{lastprivate variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(argv[1]) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(2 * 2) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(ba)
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(ca) // expected-error {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(da) // expected-error {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-  int xa;
-#pragma omp parallel for lastprivate(xa) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(S2::S2s) // expected-error {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(S2::S2sc) // expected-error {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for safelen(5) // expected-error {{unexpected OpenMP clause 'safelen' in directive '#pragma omp parallel for'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(e, g) // expected-error 2 {{lastprivate variable must have an accessible, unambiguous default constructor}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(m) // expected-error {{lastprivate variable must have an accessible, unambiguous copy assignment operator}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(h) // expected-error {{threadprivate or thread local variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for private(xa), lastprivate(xa) // expected-error {{private variable cannot be lastprivate}} expected-note {{defined as private}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(i)
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel private(xa)
-#pragma omp parallel for lastprivate(xa)
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel reduction(+ : xa)
-#pragma omp parallel for lastprivate(xa)
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(j) // expected-error {{arguments of OpenMP clause 'lastprivate' cannot be of reference type}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for firstprivate(m) lastprivate(m) // expected-error {{lastprivate variable must have an accessible, unambiguous copy assignment operator}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for lastprivate(n) firstprivate(n) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-  return foomain<S4, S5>(argc, argv); // expected-note {{in instantiation of function template specialization 'foomain<S4, S5>' requested here}}
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_loop_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_loop_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_loop_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_loop_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,593 +0,0 @@
-// RUN: %clang_cc1 -fsyntax-only -fopenmp=libiomp5 -x c++ -std=c++11 -fexceptions -fcxx-exceptions -verify %s
-
-class S {
-  int a;
-  S() : a(0) {}
-
-public:
-  S(int v) : a(v) {}
-  S(const S &s) : a(s.a) {}
-};
-
-static int sii;
-#pragma omp threadprivate(sii) // expected-note {{defined as threadprivate or thread local}}
-
-int test_iteration_spaces() {
-  const int N = 100;
-  float a[N], b[N], c[N];
-  int ii, jj, kk;
-  float fii;
-  double dii;
-#pragma omp parallel for
-  for (int i = 0; i < 10; i += 1) {
-    c[i] = a[i] + b[i];
-  }
-#pragma omp parallel for
-  for (char i = 0; i < 10; i++) {
-    c[i] = a[i] + b[i];
-  }
-#pragma omp parallel for
-  for (char i = 0; i < 10; i += '\1') {
-    c[i] = a[i] + b[i];
-  }
-#pragma omp parallel for
-  for (long long i = 0; i < 10; i++) {
-    c[i] = a[i] + b[i];
-  }
-// expected-error@+2 {{expression must have integral or unscoped enumeration type, not 'double'}}
-#pragma omp parallel for
-  for (long long i = 0; i < 10; i += 1.5) {
-    c[i] = a[i] + b[i];
-  }
-#pragma omp parallel for
-  for (long long i = 0; i < 'z'; i += 1u) {
-    c[i] = a[i] + b[i];
-  }
-// expected-error@+2 {{variable must be of integer or random access iterator type}}
-#pragma omp parallel for
-  for (float fi = 0; fi < 10.0; fi++) {
-    c[(int)fi] = a[(int)fi] + b[(int)fi];
-  }
-// expected-error@+2 {{variable must be of integer or random access iterator type}}
-#pragma omp parallel for
-  for (double fi = 0; fi < 10.0; fi++) {
-    c[(int)fi] = a[(int)fi] + b[(int)fi];
-  }
-// expected-error@+2 {{variable must be of integer or random access iterator type}}
-#pragma omp parallel for
-  for (int &ref = ii; ref < 10; ref++) {
-  }
-// expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-#pragma omp parallel for
-  for (int i; i < 10; i++)
-    c[i] = a[i];
-
-// expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-#pragma omp parallel for
-  for (int i = 0, j = 0; i < 10; ++i)
-    c[i] = a[i];
-
-// expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-#pragma omp parallel for
-  for (; ii < 10; ++ii)
-    c[ii] = a[ii];
-
-// expected-warning@+3 {{expression result unused}}
-// expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-#pragma omp parallel for
-  for (ii + 1; ii < 10; ++ii)
-    c[ii] = a[ii];
-
-// expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-#pragma omp parallel for
-  for (c[ii] = 0; ii < 10; ++ii)
-    c[ii] = a[ii];
-
-// Ok to skip parenthesises.
-#pragma omp parallel for
-  for (((ii)) = 0; ii < 10; ++ii)
-    c[ii] = a[ii];
-
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-#pragma omp parallel for
-  for (int i = 0; i; i++)
-    c[i] = a[i];
-
-// expected-error@+3 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'i'}}
-#pragma omp parallel for
-  for (int i = 0; jj < kk; ii++)
-    c[i] = a[i];
-
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-#pragma omp parallel for
-  for (int i = 0; !!i; i++)
-    c[i] = a[i];
-
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-#pragma omp parallel for
-  for (int i = 0; i != 1; i++)
-    c[i] = a[i];
-
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-#pragma omp parallel for
-  for (int i = 0;; i++)
-    c[i] = a[i];
-
-// Ok.
-#pragma omp parallel for
-  for (int i = 11; i > 10; i--)
-    c[i] = a[i];
-
-// Ok.
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i)
-    c[i] = a[i];
-
-// Ok.
-#pragma omp parallel for
-  for (ii = 0; ii < 10; ++ii)
-    c[ii] = a[ii];
-
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp parallel for
-  for (ii = 0; ii < 10; ++jj)
-    c[ii] = a[jj];
-
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp parallel for
-  for (ii = 0; ii < 10; ++++ii)
-    c[ii] = a[ii];
-
-// Ok but undefined behavior (in general, cannot check that incr
-// is really loop-invariant).
-#pragma omp parallel for
-  for (ii = 0; ii < 10; ii = ii + ii)
-    c[ii] = a[ii];
-
-// expected-error@+2 {{expression must have integral or unscoped enumeration type, not 'float'}}
-#pragma omp parallel for
-  for (ii = 0; ii < 10; ii = ii + 1.0f)
-    c[ii] = a[ii];
-
-// Ok - step was converted to integer type.
-#pragma omp parallel for
-  for (ii = 0; ii < 10; ii = ii + (int)1.1f)
-    c[ii] = a[ii];
-
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp parallel for
-  for (ii = 0; ii < 10; jj = ii + 2)
-    c[ii] = a[ii];
-
-// expected-warning@+3 {{relational comparison result unused}}
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp parallel for
-  for (ii = 0; ii<10; jj> kk + 2)
-    c[ii] = a[ii];
-
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp parallel for
-  for (ii = 0; ii < 10;)
-    c[ii] = a[ii];
-
-// expected-warning@+3 {{expression result unused}}
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp parallel for
-  for (ii = 0; ii < 10; !ii)
-    c[ii] = a[ii];
-
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp parallel for
-  for (ii = 0; ii < 10; ii ? ++ii : ++jj)
-    c[ii] = a[ii];
-
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-#pragma omp parallel for
-  for (ii = 0; ii < 10; ii = ii < 10)
-    c[ii] = a[ii];
-
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (ii = 0; ii < 10; ii = ii + 0)
-    c[ii] = a[ii];
-
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (ii = 0; ii < 10; ii = ii + (int)(0.8 - 0.45))
-    c[ii] = a[ii];
-
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (ii = 0; (ii) < 10; ii -= 25)
-    c[ii] = a[ii];
-
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (ii = 0; (ii < 10); ii -= 0)
-    c[ii] = a[ii];
-
-// expected-note@+3 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to decrease on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (ii = 0; ii > 10; (ii += 0))
-    c[ii] = a[ii];
-
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (ii = 0; ii < 10; (ii) = (1 - 1) + (ii))
-    c[ii] = a[ii];
-
-// expected-note@+3 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to decrease on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for ((ii = 0); ii > 10; (ii -= 0))
-    c[ii] = a[ii];
-
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (ii = 0; (ii < 10); (ii -= 0))
-    c[ii] = a[ii];
-
-// expected-note@+2  {{defined as firstprivate}}
-// expected-error@+2 {{loop iteration variable in the associated loop of 'omp parallel for' directive may not be firstprivate, predetermined as private}}
-#pragma omp parallel for firstprivate(ii)
-  for (ii = 0; ii < 10; ii++)
-    c[ii] = a[ii];
-
-// expected-error@+3 {{unexpected OpenMP clause 'linear' in directive '#pragma omp parallel for'}}
-// expected-note@+2  {{defined as linear}}
-// expected-error@+2 {{loop iteration variable in the associated loop of 'omp parallel for' directive may not be linear, predetermined as private}}
-#pragma omp parallel for linear(ii)
-  for (ii = 0; ii < 10; ii++)
-    c[ii] = a[ii];
-
-#pragma omp parallel for private(ii)
-  for (ii = 0; ii < 10; ii++)
-    c[ii] = a[ii];
-
-#pragma omp parallel for lastprivate(ii)
-  for (ii = 0; ii < 10; ii++)
-    c[ii] = a[ii];
-
-  {
-// expected-error@+2 {{loop iteration variable in the associated loop of 'omp parallel for' directive may not be threadprivate or thread local, predetermined as private}}
-#pragma omp parallel for
-    for (sii = 0; sii < 10; sii += 1)
-      c[sii] = a[sii];
-  }
-
-// expected-error@+2 {{statement after '#pragma omp parallel for' must be a for loop}}
-#pragma omp parallel for
-  for (auto &item : a) {
-    item = item + 1;
-  }
-
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'i' to increase on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (unsigned i = 9; i < 10; i--) {
-    c[i] = a[i] + b[i];
-  }
-
-  int(*lb)[4] = nullptr;
-#pragma omp parallel for
-  for (int(*p)[4] = lb; p < lb + 8; ++p) {
-  }
-
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp parallel for
-  for (int a{0}; a < 10; ++a) {
-  }
-
-  return 0;
-}
-
-// Iterators allowed in openmp for-loops.
-namespace std {
-struct random_access_iterator_tag {};
-template <class Iter>
-struct iterator_traits {
-  typedef typename Iter::difference_type difference_type;
-  typedef typename Iter::iterator_category iterator_category;
-};
-template <class Iter>
-typename iterator_traits<Iter>::difference_type
-distance(Iter first, Iter last) { return first - last; }
-}
-class Iter0 {
-public:
-  Iter0() {}
-  Iter0(const Iter0 &) {}
-  Iter0 operator++() { return *this; }
-  Iter0 operator--() { return *this; }
-  bool operator<(Iter0 a) { return true; }
-};
-int operator-(Iter0 a, Iter0 b) { return 0; }
-class Iter1 {
-public:
-  Iter1(float f = 0.0f, double d = 0.0) {}
-  Iter1(const Iter1 &) {}
-  Iter1 operator++() { return *this; }
-  Iter1 operator--() { return *this; }
-  bool operator<(Iter1 a) { return true; }
-  bool operator>=(Iter1 a) { return false; }
-};
-class GoodIter {
-public:
-  GoodIter() {}
-  GoodIter(const GoodIter &) {}
-  GoodIter(int fst, int snd) {}
-  GoodIter &operator=(const GoodIter &that) { return *this; }
-  GoodIter &operator=(const Iter0 &that) { return *this; }
-  GoodIter &operator+=(int x) { return *this; }
-  explicit GoodIter(void *) {}
-  GoodIter operator++() { return *this; }
-  GoodIter operator--() { return *this; }
-  bool operator!() { return true; }
-  bool operator<(GoodIter a) { return true; }
-  bool operator<=(GoodIter a) { return true; }
-  bool operator>=(GoodIter a) { return false; }
-  typedef int difference_type;
-  typedef std::random_access_iterator_tag iterator_category;
-};
-int operator-(GoodIter a, GoodIter b) { return 0; }
-GoodIter operator-(GoodIter a) { return a; }
-GoodIter operator-(GoodIter a, int v) { return GoodIter(); }
-GoodIter operator+(GoodIter a, int v) { return GoodIter(); }
-GoodIter operator-(int v, GoodIter a) { return GoodIter(); }
-GoodIter operator+(int v, GoodIter a) { return GoodIter(); }
-
-int test_with_random_access_iterator() {
-  GoodIter begin, end;
-  Iter0 begin0, end0;
-#pragma omp parallel for
-  for (GoodIter I = begin; I < end; ++I)
-    ++I;
-// expected-error@+2 {{variable must be of integer or random access iterator type}}
-#pragma omp parallel for
-  for (GoodIter &I = begin; I < end; ++I)
-    ++I;
-#pragma omp parallel for
-  for (GoodIter I = begin; I >= end; --I)
-    ++I;
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp parallel for
-  for (GoodIter I(begin); I < end; ++I)
-    ++I;
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp parallel for
-  for (GoodIter I(nullptr); I < end; ++I)
-    ++I;
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp parallel for
-  for (GoodIter I(0); I < end; ++I)
-    ++I;
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp parallel for
-  for (GoodIter I(1, 2); I < end; ++I)
-    ++I;
-#pragma omp parallel for
-  for (begin = GoodIter(0); begin < end; ++begin)
-    ++begin;
-#pragma omp parallel for
-  for (begin = begin0; begin < end; ++begin)
-    ++begin;
-// expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-#pragma omp parallel for
-  for (++begin; begin < end; ++begin)
-    ++begin;
-#pragma omp parallel for
-  for (begin = end; begin < end; ++begin)
-    ++begin;
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'I'}}
-#pragma omp parallel for
-  for (GoodIter I = begin; I - I; ++I)
-    ++I;
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'I'}}
-#pragma omp parallel for
-  for (GoodIter I = begin; begin < end; ++I)
-    ++I;
-// expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'I'}}
-#pragma omp parallel for
-  for (GoodIter I = begin; !I; ++I)
-    ++I;
-// expected-note@+3 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (GoodIter I = begin; I >= end; I = I + 1)
-    ++I;
-#pragma omp parallel for
-  for (GoodIter I = begin; I >= end; I = I - 1)
-    ++I;
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'I'}}
-#pragma omp parallel for
-  for (GoodIter I = begin; I >= end; I = -I)
-    ++I;
-// expected-note@+3 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (GoodIter I = begin; I >= end; I = 2 + I)
-    ++I;
-// expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'I'}}
-#pragma omp parallel for
-  for (GoodIter I = begin; I >= end; I = 2 - I)
-    ++I;
-#pragma omp parallel for
-  for (Iter0 I = begin0; I < end0; ++I)
-    ++I;
-// Initializer is constructor without params.
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp parallel for
-  for (Iter0 I; I < end0; ++I)
-    ++I;
-  Iter1 begin1, end1;
-#pragma omp parallel for
-  for (Iter1 I = begin1; I < end1; ++I)
-    ++I;
-// expected-note@+3 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (Iter1 I = begin1; I >= end1; ++I)
-    ++I;
-// Initializer is constructor with all default params.
-// expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-#pragma omp parallel for
-  for (Iter1 I; I < end1; ++I) {
-  }
-  return 0;
-}
-
-template <typename IT, int ST>
-class TC {
-public:
-  int dotest_lt(IT begin, IT end) {
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'I' to increase on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-    for (IT I = begin; I < end; I = I + ST) {
-      ++I;
-    }
-// expected-note@+3 {{loop step is expected to be positive due to this condition}}
-// expected-error@+2 {{increment expression must cause 'I' to increase on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-    for (IT I = begin; I <= end; I += ST) {
-      ++I;
-    }
-#pragma omp parallel for
-    for (IT I = begin; I < end; ++I) {
-      ++I;
-    }
-  }
-
-  static IT step() {
-    return IT(ST);
-  }
-};
-template <typename IT, int ST = 0>
-int dotest_gt(IT begin, IT end) {
-// expected-note@+3 2 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (IT I = begin; I >= end; I = I + ST) {
-    ++I;
-  }
-// expected-note@+3 2 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (IT I = begin; I >= end; I += ST) {
-    ++I;
-  }
-
-// expected-note@+3 {{loop step is expected to be negative due to this condition}}
-// expected-error@+2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-#pragma omp parallel for
-  for (IT I = begin; I >= end; ++I) {
-    ++I;
-  }
-
-#pragma omp parallel for
-  for (IT I = begin; I < end; I += TC<int, ST>::step()) {
-    ++I;
-  }
-}
-
-void test_with_template() {
-  GoodIter begin, end;
-  TC<GoodIter, 100> t1;
-  TC<GoodIter, -100> t2;
-  t1.dotest_lt(begin, end);
-  t2.dotest_lt(begin, end);         // expected-note {{in instantiation of member function 'TC<GoodIter, -100>::dotest_lt' requested here}}
-  dotest_gt(begin, end);            // expected-note {{in instantiation of function template specialization 'dotest_gt<GoodIter, 0>' requested here}}
-  dotest_gt<unsigned, -10>(0, 100); // expected-note {{in instantiation of function template specialization 'dotest_gt<unsigned int, -10>' requested here}}
-}
-
-void test_loop_break() {
-  const int N = 100;
-  float a[N], b[N], c[N];
-#pragma omp parallel for
-  for (int i = 0; i < 10; i++) {
-    c[i] = a[i] + b[i];
-    for (int j = 0; j < 10; ++j) {
-      if (a[i] > b[j])
-        break; // OK in nested loop
-    }
-    switch (i) {
-    case 1:
-      b[i]++;
-      break;
-    default:
-      break;
-    }
-    if (c[i] > 10)
-      break; // expected-error {{'break' statement cannot be used in OpenMP for loop}}
-
-    if (c[i] > 11)
-      break; // expected-error {{'break' statement cannot be used in OpenMP for loop}}
-  }
-
-#pragma omp parallel for
-  for (int i = 0; i < 10; i++) {
-    for (int j = 0; j < 10; j++) {
-      c[i] = a[i] + b[i];
-      if (c[i] > 10) {
-        if (c[i] < 20) {
-          break; // OK
-        }
-      }
-    }
-  }
-}
-
-void test_loop_eh() {
-  const int N = 100;
-  float a[N], b[N], c[N];
-#pragma omp parallel for
-  for (int i = 0; i < 10; i++) {
-    c[i] = a[i] + b[i];
-    try {
-      for (int j = 0; j < 10; ++j) {
-        if (a[i] > b[j])
-          throw a[i];
-      }
-      throw a[i];
-    } catch (float f) {
-      if (f > 0.1)
-        throw a[i];
-      return; // expected-error {{cannot return from OpenMP region}}
-    }
-    switch (i) {
-    case 1:
-      b[i]++;
-      break;
-    default:
-      break;
-    }
-    for (int j = 0; j < 10; j++) {
-      if (c[i] > 10)
-        throw c[i];
-    }
-  }
-  if (c[9] > 10)
-    throw c[9]; // OK
-
-#pragma omp parallel for
-  for (int i = 0; i < 10; ++i) {
-    struct S {
-      void g() { throw 0; }
-    };
-  }
-}
-
-void test_loop_firstprivate_lastprivate() {
-  S s(4);
-#pragma omp parallel for lastprivate(s) firstprivate(s)
-  for (int i = 0; i < 16; ++i)
-    ;
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_messages.cpp	2014-07-20 22:45:36.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,86 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -std=c++11 -o - %s
-
-void foo() {
-}
-
-#pragma omp parallel for // expected-error {{unexpected OpenMP directive '#pragma omp parallel for'}}
-
-int main(int argc, char **argv) {
-#pragma omp parallel for { // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (int i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for ( // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (int i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for[ // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (int i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for] // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (int i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for) // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (int i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for } // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (int i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for
-  for (int i = 0; i < argc; ++i)
-    foo();
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-#pragma omp parallel for unknown()
-  for (int i = 0; i < argc; ++i)
-    foo();
-L1:
-  for (int i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for
-  for (int i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for
-  for (int i = 0; i < argc; ++i) {
-    goto L1; // expected-error {{use of undeclared label 'L1'}}
-    argc++;
-  }
-
-  for (int i = 0; i < 10; ++i) {
-    switch (argc) {
-    case (0):
-#pragma omp parallel for
-      for (int i = 0; i < argc; ++i) {
-        foo();
-        break; // expected-error {{'break' statement cannot be used in OpenMP for loop}}
-        continue;
-      }
-    default:
-      break;
-    }
-  }
-#pragma omp parallel for default(none)
-  for (int i = 0; i < 10; ++i)
-    ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
-
-  goto L2; // expected-error {{use of undeclared label 'L2'}}
-#pragma omp parallel for
-  for (int i = 0; i < argc; ++i)
-  L2:
-  foo();
-#pragma omp parallel for
-  for (int i = 0; i < argc; ++i) {
-    return 1; // expected-error {{cannot return from OpenMP region}}
-  }
-
-  [[]] // expected-error {{an attribute list cannot appear here}}
-#pragma omp parallel for
-      for (int n = 0; n < 100; ++n) {
-  }
-
-  return 0;
-}
-
-void test_ordered() {
-#pragma omp parallel for ordered ordered // expected-error {{directive '#pragma omp parallel for' cannot contain more than one 'ordered' clause}}
-  for (int i = 0; i < 16; ++i)
-    ;
-}
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/parallel_for_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/parallel_for_misc_messages.c	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_misc_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -1,309 +1,263 @@
-// RUN: %clang_cc1 -fsyntax-only -fopenmp=libiomp5 -verify %s
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 100000 -fopenmp -verify %s
 
-// expected-error@+1 {{unexpected OpenMP directive '#pragma omp parallel for'}}
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp parallel for'}} */
 #pragma omp parallel for
 
-// expected-error@+1 {{unexpected OpenMP directive '#pragma omp parallel for'}}
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp parallel for'}} */
 #pragma omp parallel for foo
 
-void test_no_clause() {
-  int i;
-#pragma omp parallel for
-  for (i = 0; i < 16; ++i)
-    ;
-
-// expected-error@+2 {{statement after '#pragma omp parallel for' must be a for loop}}
-#pragma omp parallel for
-  ++i;
-}
-
-void test_branch_protected_scope() {
-  int i = 0;
-L1:
-  ++i;
-
-  int x[24];
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp parallel for'}} */
+#pragma omp parallel for collapse
 
-#pragma omp parallel for
-  for (i = 0; i < 16; ++i) {
-    if (i == 5)
-      goto L1; // expected-error {{use of undeclared label 'L1'}}
-    else if (i == 6)
-      return; // expected-error {{cannot return from OpenMP region}}
-    else if (i == 7)
-      goto L2;
-    else if (i == 8) {
-    L2:
-      x[i]++;
-    }
-  }
-
-  if (x[0] == 0)
-    goto L2; // expected-error {{use of undeclared label 'L2'}}
-  else if (x[1] == 1)
-    goto L1;
+void test_no_clause()
+{
+  int i;
+  #pragma omp parallel for
+  for (i = 0; i < 16; ++i) ;
 }
 
-void test_invalid_clause() {
+void test_invalid_clause()
+{
   int i;
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-#pragma omp parallel for foo bar
-  for (i = 0; i < 16; ++i)
-    ;
+  /* expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for' are ignored}} */
+  #pragma omp parallel for foo bar
+  for (i = 0; i < 16; ++i) ;
 }
 
-void test_non_identifiers() {
+void test_non_identifiers()
+{
   int i, x;
 
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-#pragma omp parallel for;
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+2 {{unexpected OpenMP clause 'linear' in directive '#pragma omp parallel for'}}
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-#pragma omp parallel for linear(x);
-  for (i = 0; i < 16; ++i)
-    ;
-
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-#pragma omp parallel for private(x);
-  for (i = 0; i < 16; ++i)
-    ;
-
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-#pragma omp parallel for, private(x);
-  for (i = 0; i < 16; ++i)
-    ;
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
+  #pragma omp parallel for;
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
+  #pragma omp parallel for private(x);
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
+  #pragma omp parallel for , private(x);
+  for (i = 0; i < 16; ++i) ;
 }
 
-extern int foo();
-
-void test_collapse() {
+void test_private()
+{
   int i;
-// expected-error@+1 {{expected '('}}
-#pragma omp parallel for collapse
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-#pragma omp parallel for collapse(
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel for collapse()
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-#pragma omp parallel for collapse(,
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expected expression}}  expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-#pragma omp parallel for collapse(, )
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-warning@+2 {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-// expected-error@+1 {{expected '('}}
-#pragma omp parallel for collapse 4)
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+2 {{expected ')'}}
-// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp parallel for collapse(4
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp parallel for', but found only 1}}
-// expected-error@+2 {{expected ')'}}
-// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp parallel for collapse(4,
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp parallel for', but found only 1}}
-// expected-error@+2 {{expected ')'}}
-// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp parallel for collapse(4, )
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp parallel for', but found only 1}}
-// expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp parallel for collapse(4)
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp parallel for', but found only 1}}
-// expected-error@+2 {{expected ')'}}
-// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp parallel for collapse(4 4)
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp parallel for', but found only 1}}
-// expected-error@+2 {{expected ')'}}
-// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp parallel for collapse(4, , 4)
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp parallel for', but found only 1}}
-#pragma omp parallel for collapse(4)
-  for (int i1 = 0; i1 < 16; ++i1)
-    for (int i2 = 0; i2 < 16; ++i2)
-      for (int i3 = 0; i3 < 16; ++i3)
-        for (int i4 = 0; i4 < 16; ++i4)
-          foo();
-// expected-error@+2 {{expected ')'}}
-// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-#pragma omp parallel for collapse(4, 8)
-  for (i = 0; i < 16; ++i)
-    ; // expected-error {{expected 4 for loops after '#pragma omp parallel for', but found only 1}}
-// expected-error@+1 {{expression is not an integer constant expression}}
-#pragma omp parallel for collapse(2.5)
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expression is not an integer constant expression}}
-#pragma omp parallel for collapse(foo())
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{argument to 'collapse' clause must be a positive integer value}}
-#pragma omp parallel for collapse(-5)
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{argument to 'collapse' clause must be a positive integer value}}
-#pragma omp parallel for collapse(0)
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{argument to 'collapse' clause must be a positive integer value}}
-#pragma omp parallel for collapse(5 - 5)
-  for (i = 0; i < 16; ++i)
-    ;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp parallel for private(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp parallel for private(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp parallel for private(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for private()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for private(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp parallel for private(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp parallel for private(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for private(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for private(x, y, z)
+  for (i = 0; i < 16; ++i) ;
 }
 
-void test_private() {
+void test_firstprivate()
+{
+  // TODO: tests on this.
   int i;
-// expected-error@+2 {{expected expression}}
-// expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-#pragma omp parallel for private(
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp parallel for private(,
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 2 {{expected expression}}
-#pragma omp parallel for private(, )
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel for private()
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel for private(int)
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expected variable name}}
-#pragma omp parallel for private(0)
-  for (i = 0; i < 16; ++i)
-    ;
-
-  int x, y, z;
-#pragma omp parallel for private(x)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel for private(x, y)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel for private(x, y, z)
-  for (i = 0; i < 16; ++i) {
-    x = y * i + z;
-  }
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for firstprivate(
+  for (i = 0; i < 16; ++i) ;
 }
 
-void test_lastprivate() {
+void test_lastprivate()
+{
   int i;
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel for lastprivate(
-  for (i = 0; i < 16; ++i)
-    ;
-
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp parallel for lastprivate(,
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 2 {{expected expression}}
-#pragma omp parallel for lastprivate(, )
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel for lastprivate()
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel for lastprivate(int)
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expected variable name}}
-#pragma omp parallel for lastprivate(0)
-  for (i = 0; i < 16; ++i)
-    ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for lastprivate(
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp parallel for lastprivate(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp parallel for lastprivate(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for lastprivate()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for lastprivate(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp parallel for lastprivate(0)
+  for (i = 0; i < 16; ++i) ;
 
   int x, y, z;
-#pragma omp parallel for lastprivate(x)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel for lastprivate(x, y)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel for lastprivate(x, y, z)
-  for (i = 0; i < 16; ++i)
-    ;
+  #pragma omp parallel for lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for lastprivate(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for lastprivate(x, y, z)
+  for (i = 0; i < 16; ++i) ;
 }
 
-void test_firstprivate() {
+void test_reduction()
+{
+  int i, x, y;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp parallel for reduction(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp parallel for reduction()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp parallel for reduction(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected identifier}} */
+  #pragma omp parallel for reduction(:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+4 {{expected ')'}} expected-note@+4 {{to match this '('}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp parallel for reduction(,
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp parallel for reduction(+
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  //
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for reduction(+:
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for reduction(+:)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for reduction(+:,y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for reduction(+:x,+:y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for reduction(%:x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp parallel for reduction(+:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for reduction(*:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for reduction(-:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for reduction(&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for reduction(|:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for reduction(^:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for reduction(&&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for reduction(||:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for reduction(max:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for reduction(min:x)
+  for (i = 0; i < 16; ++i) ;
+  struct X { int x; };
+  struct X X;
+  // TODO: Is the following error correct?
+  // expected-error@+1 {{expected variable name}}
+  #pragma omp parallel for reduction(+:X.x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp parallel for reduction(+:x+x)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_multiple_clauses()
+{
   int i;
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel for firstprivate(
-  for (i = 0; i < 16; ++i)
-    ;
-
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp parallel for firstprivate(,
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 2 {{expected expression}}
-#pragma omp parallel for firstprivate(, )
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel for firstprivate()
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel for firstprivate(int)
-  for (i = 0; i < 16; ++i)
-    ;
-// expected-error@+1 {{expected variable name}}
-#pragma omp parallel for firstprivate(0)
-  for (i = 0; i < 16; ++i)
-    ;
+  float x = 0, y = 0, z = 0;
+  #pragma omp parallel for reduction(+:x, y) reduction(-:z) // OK
+  for (i = 0; i < 16; ++i);
+
+  // expected-error@+1 {{private variable cannot be lastprivate}} expected-note@+1 {{defined as private}}
+  #pragma omp parallel for private(x), lastprivate(x)
+  for (i = 0; i < 16; ++i);
 
-  int x, y, z;
-#pragma omp parallel for lastprivate(x) firstprivate(x)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel for lastprivate(x, y) firstprivate(x, y)
-  for (i = 0; i < 16; ++i)
-    ;
-#pragma omp parallel for lastprivate(x, y, z) firstprivate(x, y, z)
-  for (i = 0; i < 16; ++i)
-    ;
-}
+  #pragma omp parallel for reduction(+:x, y), reduction(-:z)
+  for (i = 0; i < 16; ++i);
 
-void test_loop_messages() {
-  float a[100], b[100], c[100];
-// expected-error@+2 {{variable must be of integer or pointer type}}
-#pragma omp parallel for
-  for (float fi = 0; fi < 10.0; fi++) {
-    c[(int)fi] = a[(int)fi] + b[(int)fi];
-  }
-// expected-error@+2 {{variable must be of integer or pointer type}}
-#pragma omp parallel for
-  for (double fi = 0; fi < 10.0; fi++) {
-    c[(int)fi] = a[(int)fi] + b[(int)fi];
-  }
+  #pragma omp parallel for reduction(+:x, y) reduction(-:z)
+  for (i = 0; i < 16; ++i);
 }
 
+void test_for()
+{
+  // expected-error@+3 {{expected '(' after 'for'}}
+  // expected-error@+2 2{{use of undeclared identifier 'i'}}
+  #pragma omp parallel for
+  for int i = 0; i < 16; i++);
+
+  // expected-error@+3 {{expected ')'}}
+  // expected-note@+2 {{to match this '('}}
+  #pragma omp parallel for
+  for (int i = 0; i < 16; i++;
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp parallel for
+  for (int i = 0 i < 16; i++);
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp parallel for
+  for (int i = 0; i < 16 i++);
+
+  // expected-error@+2 2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp parallel for
+  for (int i = 0 i < 16 i++);
+
+  int i = 0;
+  // expected-error@+2 {{initialization of for-loop does not have canonical form}}
+  #pragma omp parallel for
+  for (; i < 16; ++i);
+
+  // expected-error@+2 {{condition of for-loop does not have canonical form}}
+  #pragma omp parallel for
+  for (int i = 0; ; ++i);
+
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp parallel for
+  for (int i = 0; i < 16; );
+
+  // expected-error@+3 {{condition of for-loop does not have canonical form}}
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp parallel for
+  for (int i = 0; ;);
+
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_num_threads_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_num_threads_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_num_threads_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_num_threads_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,65 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note {{declared here}}
-
-template <class T, typename S, int N> // expected-note {{declared here}}
-T tmain(T argc, S **argv) {
-  T i;
-  #pragma omp parallel for num_threads // expected-error {{expected '(' after 'num_threads'}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads () // expected-error {{expected expression}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (argc)) // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads ((argc > 0) ? argv[1] : argv[2]) // expected-error 2 {{expression must have integral or unscoped enumeration type, not 'char *'}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (foobool(argc)), num_threads (true), num_threads (-5) // expected-error 2 {{directive '#pragma omp parallel for' cannot contain more than one 'num_threads' clause}} expected-error {{argument to 'num_threads' clause must be a positive integer value}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (S) // expected-error {{'S' does not refer to a value}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error 2 {{expression must have integral or unscoped enumeration type, not 'char *'}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (argc)
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (N) // expected-error {{argument to 'num_threads' clause must be a positive integer value}}
-  for (i = 0; i < argc; ++i) foo();
-
-  return argc;
-}
-
-int main(int argc, char **argv) {
-  int i;
-  #pragma omp parallel for num_threads // expected-error {{expected '(' after 'num_threads'}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads () // expected-error {{expected expression}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (argc)) // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (argc > 0 ? argv[1] : argv[2]) // expected-error {{integral }}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (foobool(argc)), num_threads (true), num_threads (-5) // expected-error 2 {{directive '#pragma omp parallel for' cannot contain more than one 'num_threads' clause}} expected-error {{argument to 'num_threads' clause must be a positive integer value}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (S1) // expected-error {{'S1' does not refer to a value}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression must have integral or unscoped enumeration type, not 'char *'}}
-  for (i = 0; i < argc; ++i) foo();
-  #pragma omp parallel for num_threads (num_threads(tmain<int, char, -1>(argc, argv) // expected-error 2 {{expected ')'}} expected-note 2 {{to match this '('}} expected-note {{in instantiation of function template specialization 'tmain<int, char, -1>' requested here}}
-  for (i = 0; i < argc; ++i) foo();
-
-  return tmain<int, char, 3>(argc, argv); // expected-note {{in instantiation of function template specialization 'tmain<int, char, 3>' requested here}}
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_private_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_private_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,173 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
-extern S1 a;
-class S2 {
-  mutable int a;
-
-public:
-  S2() : a(0) {}
-};
-const S2 b;
-const S2 ba[5];
-class S3 {
-  int a;
-
-public:
-  S3() : a(0) {}
-};
-const S3 ca[5];
-class S4 { // expected-note {{'S4' declared here}}
-  int a;
-  S4();
-
-public:
-  S4(int v) : a(v) {}
-};
-class S5 { // expected-note {{'S5' declared here}}
-  int a;
-  S5() : a(0) {}
-
-public:
-  S5(int v) : a(v) {}
-};
-
-S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class I, class C>
-int foomain(I argc, C **argv) {
-  I e(4);
-  I g(5);
-  int i;
-  int &j = i;           // expected-note {{'j' defined here}}
-#pragma omp parallel for private // expected-error {{expected '(' after 'private'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private() // expected-error {{expected expression}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(argc)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(S1) // expected-error {{'S1' does not refer to a value}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(a, b) // expected-error {{private variable with incomplete type 'S1'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(argv[1]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(e, g)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for nowait // expected-error {{unexpected OpenMP clause 'nowait' in directive '#pragma omp parallel for'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;
-#pragma omp parallel for private(i)
-    for (int k = 0; k < argc; ++k) {
-      i = k;
-      v += i;
-    }
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp parallel for private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(i)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-  return 0;
-}
-
-int main(int argc, char **argv) {
-  S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note {{'g' defined here}}
-  int i;
-  int &j = i;           // expected-note {{'j' defined here}}
-#pragma omp parallel for private // expected-error {{expected '(' after 'private'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private() // expected-error {{expected expression}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(argc)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(S1) // expected-error {{'S1' does not refer to a value}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(a, b) // expected-error {{private variable with incomplete type 'S1'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(argv[1]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for nowait // expected-error {{unexpected OpenMP clause 'nowait' in directive '#pragma omp parallel for'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-  {
-    int i;
-#pragma omp parallel for private(i)
-    for (int k = 0; k < argc; ++k)
-      ++k;
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp parallel for private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel for private(i)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-
-  return 0;
-}
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_proc_bind_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_proc_bind_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_proc_bind_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_proc_bind_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,35 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
-
-void foo();
-
-int main(int argc, char **argv) {
-  int i;
-#pragma omp parallel for proc_bind // expected-error {{expected '(' after 'proc_bind'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for proc_bind( // expected-error {{expected 'master', 'close' or 'spread' in OpenMP clause 'proc_bind'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for proc_bind() // expected-error {{expected 'master', 'close' or 'spread' in OpenMP clause 'proc_bind'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for proc_bind(master // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for proc_bind(close), proc_bind(spread) // expected-error {{directive '#pragma omp parallel for' cannot contain more than one 'proc_bind' clause}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel for proc_bind(x) // expected-error {{expected 'master', 'close' or 'spread' in OpenMP clause 'proc_bind'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-
-#pragma omp parallel for proc_bind(master)
-  for (i = 0; i < argc; ++i)
-    foo();
-
-#pragma omp parallel proc_bind(close)
-#pragma omp parallel for proc_bind(spread)
-  for (i = 0; i < argc; ++i)
-    foo();
-  return 0;
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_reduction_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_reduction_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_reduction_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_reduction_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,295 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note {{declared here}} expected-note 4 {{forward declaration of 'S1'}}
-extern S1 a;
-class S2 {
-  mutable int a;
-  S2 &operator+=(const S2 &arg) { return (*this); }
-
-public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-  static float S2s; // expected-note 2 {{static data member is predetermined as shared}}
-  static const float S2sc;
-};
-const float S2::S2sc = 0; // expected-note 2 {{'S2sc' defined here}}
-S2 b;                     // expected-note 2 {{'b' defined here}}
-const S2 ba[5];           // expected-note 2 {{'ba' defined here}}
-class S3 {
-  int a;
-
-public:
-  S3() : a(0) {}
-  S3(const S3 &s3) : a(s3.a) {}
-  S3 operator+=(const S3 &arg1) { return arg1; }
-};
-int operator+=(const S3 &arg1, const S3 &arg2) { return 5; }
-S3 c;               // expected-note 2 {{'c' defined here}}
-const S3 ca[5];     // expected-note 2 {{'ca' defined here}}
-extern const int f; // expected-note 4 {{'f' declared here}}
-class S4 {          // expected-note {{'S4' declared here}}
-  int a;
-  S4();
-  S4(const S4 &s4);
-  S4 &operator+=(const S4 &arg) { return (*this); }
-
-public:
-  S4(int v) : a(v) {}
-};
-S4 &operator&=(S4 &arg1, S4 &arg2) { return arg1; }
-class S5 {
-  int a;
-  S5() : a(0) {}
-  S5(const S5 &s5) : a(s5.a) {}
-  S5 &operator+=(const S5 &arg);
-
-public:
-  S5(int v) : a(v) {}
-};
-class S6 {
-  int a;
-
-public:
-  S6() : a(6) {}
-  operator int() { return 6; }
-} o; // expected-note 2 {{'o' defined here}}
-
-S3 h, k;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class T>       // expected-note {{declared here}}
-T tmain(T argc) {        // expected-note 2 {{'argc' defined here}}
-  const T d = T();       // expected-note 4 {{'d' defined here}}
-  const T da[5] = {T()}; // expected-note 2 {{'da' defined here}}
-  T qa[5] = {T()};
-  T i;
-  T &j = i;                        // expected-note 4 {{'j' defined here}}
-  S3 &p = k;                       // expected-note 2 {{'p' defined here}}
-  const T &r = da[(int)i];         // expected-note 2 {{'r' defined here}}
-  T &q = qa[(int)i];               // expected-note 2 {{'q' defined here}}
-  T fl;                            // expected-note {{'fl' defined here}}
-#pragma omp parallel for reduction // expected-error {{expected '(' after 'reduction'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction + // expected-error {{expected '(' after 'reduction'}} expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction( // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(- // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction() // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(*) // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(\) // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(& : argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(| : argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(|| : argc ? i : argc) // expected-error 2 {{expected variable name}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(foo : argc) //expected-error {{incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(&& : argc)
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(^ : T) // expected-error {{'T' does not refer to a value}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 3 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' or 'max' must be of arithmetic type}} expected-error 3 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(max : qa[1]) // expected-error 2 {{expected variable name}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(+ : ba) // expected-error {{a reduction variable with array type 'const S2 [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(* : ca) // expected-error {{a reduction variable with array type 'const S3 [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(- : da) // expected-error {{a reduction variable with array type 'const int [5]'}} expected-error {{a reduction variable with array type 'const float [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(^ : fl) // expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(+ : o) // expected-error {{variable of type 'class S6' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for private(i), reduction(+ : j), reduction(+ : q) // expected-error 4 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel private(k)
-#pragma omp parallel for reduction(+ : p), reduction(+ : p) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(+ : p), reduction(+ : p) // expected-error 3 {{variable can appear only once in OpenMP 'reduction' clause}} expected-note 3 {{previously referenced here}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(+ : r) // expected-error 2 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel shared(i)
-#pragma omp parallel reduction(min : i)
-#pragma omp parallel for reduction(max : j) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel private(fl)
-#pragma omp parallel for reduction(+ : fl)
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel reduction(* : fl)
-#pragma omp parallel for reduction(+ : fl)
-  for (int i = 0; i < 10; ++i)
-    foo();
-
-  return T();
-}
-
-int main(int argc, char **argv) {
-  const int d = 5;       // expected-note 2 {{'d' defined here}}
-  const int da[5] = {0}; // expected-note {{'da' defined here}}
-  int qa[5] = {0};
-  S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note {{'g' defined here}}
-  int i;
-  int &j = i;                      // expected-note 2 {{'j' defined here}}
-  S3 &p = k;                       // expected-note 2 {{'p' defined here}}
-  const int &r = da[i];            // expected-note {{'r' defined here}}
-  int &q = qa[i];                  // expected-note {{'q' defined here}}
-  float fl;                        // expected-note {{'fl' defined here}}
-#pragma omp parallel for reduction // expected-error {{expected '(' after 'reduction'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction + // expected-error {{expected '(' after 'reduction'}} expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction( // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(- // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction() // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(*) // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(\) // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(foo : argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(| : argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(|| : argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(~ : argc) // expected-error {{expected unqualified-id}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(&& : argc)
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(^ : S1) // expected-error {{'S1' does not refer to a value}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' or 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(max : argv[1]) // expected-error {{expected variable name}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(+ : ba) // expected-error {{a reduction variable with array type 'const S2 [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(* : ca) // expected-error {{a reduction variable with array type 'const S3 [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(- : da) // expected-error {{a reduction variable with array type 'const int [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(^ : fl) // expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{variable of type 'S5' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(+ : o) // expected-error {{variable of type 'class S6' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for private(i), reduction(+ : j), reduction(+ : q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel private(k)
-#pragma omp parallel for reduction(+ : p), reduction(+ : p) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel for reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel shared(i)
-#pragma omp parallel reduction(min : i)
-#pragma omp parallel for reduction(max : j) // expected-error {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel private(fl)
-#pragma omp parallel for reduction(+ : fl)
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel reduction(* : fl)
-#pragma omp parallel for reduction(+ : fl)
-  for (int i = 0; i < 10; ++i)
-    foo();
-
-  return tmain(argc) + tmain(fl); // expected-note {{in instantiation of function template specialization 'tmain<int>' requested here}} expected-note {{in instantiation of function template specialization 'tmain<float>' requested here}}
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_schedule_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_schedule_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_schedule_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_schedule_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,91 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note {{declared here}}
-
-template <class T, typename S, int N, int ST> // expected-note {{declared here}}
-T tmain(T argc, S **argv) {
-  #pragma omp parallel for schedule // expected-error {{expected '(' after 'schedule'}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for schedule ( // expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for schedule () // expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for schedule (auto // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for schedule (auto_dynamic // expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for schedule (auto,  // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for schedule (runtime, 3)  // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-  #pragma omp parallel for schedule (guided argc
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+1 2 {{argument to 'schedule' clause must be a positive integer value}}
-  #pragma omp parallel for schedule (static, ST // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for schedule (dynamic, 1)) // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for schedule (guided, (ST > 0) ? 1 + ST : 2)
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+2 2 {{directive '#pragma omp parallel for' cannot contain more than one 'schedule' clause}}
-  // expected-error@+1 {{argument to 'schedule' clause must be a positive integer value}}
-  #pragma omp parallel for schedule (static, foobool(argc)), schedule (dynamic, true), schedule (guided, -5)
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for schedule (static, S) // expected-error {{'S' does not refer to a value}} expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+1 2 {{expression must have integral or unscoped enumeration type, not 'char *'}}
-  #pragma omp parallel for schedule (guided, argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for schedule (dynamic, 1)
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp parallel for schedule (static, N) // expected-error {{argument to 'schedule' clause must be a positive integer value}}
-  for (T i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  return argc;
-}
-
-int main(int argc, char **argv) {
-  #pragma omp parallel for schedule // expected-error {{expected '(' after 'schedule'}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for schedule ( // expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for schedule () // expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for schedule (auto // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for schedule (auto_dynamic // expected-error {{expected 'static', 'dynamic', 'guided', 'auto' or 'runtime' in OpenMP clause 'schedule'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for schedule (auto,  // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for schedule (runtime, 3)  // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for schedule (guided, 4 // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for schedule (static, 2+2)) // expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for schedule (dynamic, foobool(1) > 0 ? 1 : 2)
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+2 2 {{directive '#pragma omp parallel for' cannot contain more than one 'schedule' clause}}
-  // expected-error@+1 {{argument to 'schedule' clause must be a positive integer value}}
-  #pragma omp parallel for schedule (guided, foobool(argc)), schedule (static, true), schedule (dynamic, -5)
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp parallel for schedule (guided, S1) // expected-error {{'S1' does not refer to a value}} expected-warning {{extra tokens at the end of '#pragma omp parallel for' are ignored}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+1 {{expression must have integral or unscoped enumeration type, not 'char *'}}
-  #pragma omp parallel for schedule (static, argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+3 {{statement after '#pragma omp parallel for' must be a for loop}}
-  // expected-note@+1 {{in instantiation of function template specialization 'tmain<int, char, -1, -2>' requested here}}
-  #pragma omp parallel for schedule(dynamic, schedule(tmain<int, char, -1, -2>(argc, argv) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-  // expected-note@+1 {{in instantiation of function template specialization 'tmain<int, char, 1, 0>' requested here}}
-  return tmain<int, char, 1, 0>(argc, argv);
-}
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_simd_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_for_simd_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_for_simd_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_simd_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,91 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+template<class T, class N> T reduct(T* arr, N num) {
+  N i;
+  N ind;
+  T sum = (T)0;
+// CHECK: T sum = (T)0;
+#pragma omp parallel for simd  linear(ind), reduction(+:sum) proc_bind(master)
+// CHECK-NEXT: #pragma omp parallel for simd linear(ind) reduction(+: sum) proc_bind(master)
+  for (i = 0; i < num; ++i) {
+    T cur = arr[ind];
+    ++ind;
+    sum += cur;
+  }
+}
+
+template<class T> struct S {
+  S(const T &a)
+    :m_a(a)
+  {}
+  T result(T *v) const {
+    T res;
+// CHECK: T res;
+#pragma omp parallel for simd lastprivate(res) safelen(7) if(m_a)
+// CHECK-NEXT: #pragma omp parallel for simd lastprivate(res) safelen(7) if(this->m_a)
+    for (T i = 7; i < m_a; ++i) {
+      res = v[i-7] + m_a;
+    }
+    return res;
+  }
+  ~S()
+  {}
+  T m_a;
+};
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  int k1=0,k2=0;
+  static int *a;
+// CHECK: static int *a;
+#pragma omp parallel for simd
+// CHECK-NEXT: #pragma omp parallel for simd
+  for (int i=0; i < 2; ++i)*a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: *a = 2;
+#pragma omp parallel for simd private(argc,b),lastprivate(d,f),reduction(+:e) reduction(min : g),  collapse(2) safelen(2) aligned(a:4), linear(k1,k2:8)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j) {foo(); k1 += 8; k2 += 8;}
+// CHECK-NEXT: #pragma omp parallel for simd private(argc,b) lastprivate(d,f) reduction(+: e) reduction(min: g) collapse(2) safelen(2) aligned(a: 4) linear(k1,k2: 8)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j) {
+// CHECK-NEXT: foo();
+// CHECK-NEXT: k1 += 8;
+// CHECK-NEXT: k2 += 8;
+// CHECK-NEXT: }
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp parallel for simd aligned(a) linear(a)
+// CHECK-NEXT: #pragma omp parallel for simd aligned(a) linear(a)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp parallel for simd collapse(1)
+// CHECK-NEXT: #pragma omp parallel for simd collapse(1)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  const int CLEN=4;
+#pragma omp parallel for simd safelen(CLEN)
+// CHECK: #pragma omp parallel for simd safelen(4)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp parallel for simd aligned(a:CLEN) linear(a:CLEN) safelen(CLEN)
+// CHECK-NEXT: #pragma omp parallel for simd aligned(a: 4) linear(a: 4) safelen(4)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_for_simd_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/parallel_for_simd_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/parallel_for_simd_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_for_simd_misc_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,453 @@
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 100000 -fopenmp -verify %s
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp parallel for simd'}} */
+#pragma omp parallel for simd
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp parallel for simd'}} */
+#pragma omp parallel for simd foo
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp parallel for simd'}} */
+#pragma omp parallel for simd safelen(4)
+
+void test_no_clause()
+{
+  int i;
+  #pragma omp parallel for simd
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_invalid_clause()
+{
+  int i;
+  /* expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for simd' are ignored}} */
+  #pragma omp parallel for simd foo bar
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_non_identifiers()
+{
+  int i, x;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for simd' are ignored}}
+  #pragma omp parallel for simd;
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for simd' are ignored}}
+  #pragma omp parallel for simd private(x);
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel for simd' are ignored}}
+  #pragma omp parallel for simd , private(x);
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_safelen()
+{
+  int i;
+  /* expected-error@+1 {{expected '('}}  expected-error@+1 {{expected expression}}*/
+  #pragma omp parallel for simd safelen
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}} */
+  #pragma omp parallel for simd safelen(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd safelen()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp parallel for simd safelen(,
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp parallel for simd' are ignored}}
+  /* expected-error@+1 {{expected expression}}  expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp parallel for simd safelen(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected '('}} */
+  #pragma omp parallel for simd safelen 4)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp parallel for simd safelen(4
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp parallel for simd safelen(4,
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp parallel for simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp parallel for simd safelen(4,)
+  for (i = 0; i < 16; ++i) ;
+  /* xxpected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd safelen(4)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp parallel for simd safelen(4 4)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp parallel for simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp parallel for simd safelen(4,,4)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd safelen(4)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp parallel for simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp parallel for simd safelen(4,8)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_linear()
+{
+  int i;
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}} */
+  #pragma omp parallel for simd linear(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp parallel for simd linear(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd linear(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd linear()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd linear(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp parallel for simd linear(0)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{use of undeclared identifier 'x'}} */
+  #pragma omp parallel for simd linear(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{use of undeclared identifier 'x'}} */
+  /* expected-error@+1 {{use of undeclared identifier 'y'}} */
+  #pragma omp parallel for simd linear(x, y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+3 {{use of undeclared identifier 'x'}} */
+  /* expected-error@+2 {{use of undeclared identifier 'y'}} */
+  /* expected-error@+1 {{use of undeclared identifier 'z'}} */
+  #pragma omp parallel for simd linear(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd linear(x:)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd linear(x:,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd linear(x:1)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd linear(x:2*2)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp parallel for simd' are ignored}}
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp parallel for simd linear(x:1,y)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp parallel for simd' are ignored}}
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp parallel for simd linear(x:1,y,z:1)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be linear}}
+  #pragma omp parallel for simd linear(x) linear(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as private}}
+  // expected-error@+1 {{private variable cannot be linear}}
+  #pragma omp parallel for simd private(x) linear(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be private}}
+  #pragma omp parallel for simd linear(x) private(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be lastprivate}}
+  #pragma omp parallel for simd linear(x) lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as lastprivate}}
+  // expected-error@+1 {{lastprivate variable cannot be linear}}
+  #pragma omp parallel for simd lastprivate(x) linear(x) 
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_private()
+{
+  int i;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp parallel for simd private(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp parallel for simd private(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp parallel for simd private(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd private()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd private(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp parallel for simd private(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp parallel for simd private(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd private(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd private(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_firstprivate()
+{
+  // TODO: tests on this.
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd firstprivate(
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_lastprivate()
+{
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd lastprivate(
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp parallel for simd lastprivate(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp parallel for simd lastprivate(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd lastprivate()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd lastprivate(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp parallel for simd lastprivate(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp parallel for simd lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd lastprivate(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd lastprivate(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_reduction()
+{
+  int i, x, y;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp parallel for simd reduction(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp parallel for simd reduction()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp parallel for simd reduction(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected identifier}} */
+  #pragma omp parallel for simd reduction(:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+4 {{expected ')'}} expected-note@+4 {{to match this '('}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp parallel for simd reduction(,
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp parallel for simd reduction(+
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  //
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd reduction(+:
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd reduction(+:)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd reduction(+:,y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd reduction(+:x,+:y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd reduction(%:x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp parallel for simd reduction(+:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd reduction(*:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd reduction(-:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd reduction(&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd reduction(|:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd reduction(^:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd reduction(&&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd reduction(||:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd reduction(max:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp parallel for simd reduction(min:x)
+  for (i = 0; i < 16; ++i) ;
+  struct X { int x; };
+  struct X X;
+  // TODO: Is the following error correct?
+  // expected-error@+1 {{expected variable name}}
+  #pragma omp parallel for simd reduction(+:X.x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp parallel for simd reduction(+:x+x)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_aligned()
+{
+  int i;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp parallel for simd aligned(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp parallel for simd aligned(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp parallel for simd aligned(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd aligned()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp parallel for simd aligned(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp parallel for simd aligned(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int *x, y, z[25];
+  #pragma omp parallel for simd aligned(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp parallel for simd aligned(x, y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp parallel for simd aligned(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp parallel for simd aligned(x:4)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp parallel for simd aligned(x, y:8)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp parallel for simd aligned(x, y, z:10+6)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}}
+  // expected-error@+1 {{expression is not an integer constant expression}}
+  #pragma omp parallel for simd aligned(x, y, z:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-note@+2 {{defined as aligned}}
+  // expected-error@+1 {{aligned variable cannot be aligned}}
+  #pragma omp parallel for simd aligned(x:16) aligned(z,x:16)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_multiple_clauses()
+{
+  int i;
+  float x = 0, y = 0, z = 0;
+  #pragma omp parallel for simd safelen(4) reduction(+:x, y) reduction(-:z) // OK
+  for (i = 0; i < 16; ++i);
+
+  // expected-error@+1 {{private variable cannot be lastprivate}} expected-note@+1 {{defined as private}}
+  #pragma omp parallel for simd private(x), lastprivate(x)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp parallel for simd safelen(4) reduction(+:x, y), reduction(-:z)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp parallel for simd reduction(+:x, y) reduction(-:z)
+  for (i = 0; i < 16; ++i);
+}
+
+void test_for()
+{
+  // expected-error@+3 {{expected '(' after 'for'}}
+  // expected-error@+2 2{{use of undeclared identifier 'i'}}
+  #pragma omp parallel for simd
+  for int i = 0; i < 16; i++);
+
+  // expected-error@+3 {{expected ')'}}
+  // expected-note@+2 {{to match this '('}}
+  #pragma omp parallel for simd
+  for (int i = 0; i < 16; i++;
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp parallel for simd
+  for (int i = 0 i < 16; i++);
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp parallel for simd
+  for (int i = 0; i < 16 i++);
+
+  // expected-error@+2 2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp parallel for simd
+  for (int i = 0 i < 16 i++);
+
+  int i = 0;
+  // expected-error@+2 {{initialization of for-loop does not have canonical form}}
+  #pragma omp parallel for simd
+  for (; i < 16; ++i);
+
+  // expected-error@+2 {{condition of for-loop does not have canonical form}}
+  #pragma omp parallel for simd
+  for (int i = 0; ; ++i);
+
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp parallel for simd
+  for (int i = 0; i < 16; );
+
+  // expected-error@+3 {{condition of for-loop does not have canonical form}}
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp parallel for simd
+  for (int i = 0; ;);
+
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_if_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_if_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_if_messages.cpp	2014-03-06 00:43:53.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_if_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
 
 void foo() {
 }
@@ -9,26 +9,8 @@
 
 struct S1; // expected-note {{declared here}}
 
-template <class T, class S> // expected-note {{declared here}}
-int tmain(T argc, S **argv) {
-  #pragma omp parallel if // expected-error {{expected '(' after 'if'}}
-  #pragma omp parallel if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp parallel if () // expected-error {{expected expression}}
-  #pragma omp parallel if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp parallel if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  #pragma omp parallel if (argc > 0 ? argv[1] : argv[2])
-  #pragma omp parallel if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp parallel' cannot contain more than one 'if' clause}}
-  #pragma omp parallel if (S) // expected-error {{'S' does not refer to a value}}
-  #pragma omp parallel if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp parallel if (argc argc) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp parallel if(argc)
-  foo();
-
-  return 0;
-}
-
 int main(int argc, char **argv) {
-  #pragma omp parallel if // expected-error {{expected '(' after 'if'}}
+  #pragma omp parallel if // expected-error {{expected '(' after 'if'}} expected-error {{expected expression}}
   #pragma omp parallel if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   #pragma omp parallel if () // expected-error {{expected expression}}
   #pragma omp parallel if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
@@ -37,10 +19,7 @@
   #pragma omp parallel if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp parallel' cannot contain more than one 'if' clause}}
   #pragma omp parallel if (S1) // expected-error {{'S1' does not refer to a value}}
   #pragma omp parallel if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp parallel if (argc argc) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp parallel if (1 0) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp parallel if(if(tmain(argc, argv) // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   foo();
 
-  return tmain(argc, argv);
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_messages.c cfe-3.5.0.src.omp/test/OpenMP/parallel_messages.c
--- cfe-3.5.0.src/test/OpenMP/parallel_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,19 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() { }
+
+int main(int argc, char **argv) {
+  L1:
+    foo();
+  #pragma omp parallel
+  {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+  #pragma omp parallel
+  L2:
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_messages.cpp	2014-03-06 00:43:53.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -std=c++11 -o - %s
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
 
 void foo() {
 }
@@ -6,21 +6,8 @@
 #pragma omp parallel // expected-error {{unexpected OpenMP directive '#pragma omp parallel'}}
 
 int main(int argc, char **argv) {
-  #pragma omp parallel { // expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  foo();
-  #pragma omp parallel ( // expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  foo();
-  #pragma omp parallel [ // expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  foo();
-  #pragma omp parallel ] // expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  foo();
-  #pragma omp parallel ) // expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  foo();
-  #pragma omp parallel } // expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  foo();
   #pragma omp parallel
-  // expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  #pragma omp parallel unknown()
+  #pragma omp parallel unknown() // expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
   foo();
   L1:
     foo();
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_num_threads_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_num_threads_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_num_threads_messages.cpp	2014-03-06 01:15:19.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_num_threads_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
 
 void foo() {
 }
@@ -7,38 +7,36 @@
   return argc;
 }
 
-struct S1; // expected-note {{declared here}}
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
 
-template <class T, typename S, int N> // expected-note {{declared here}}
-T tmain(T argc, S **argv) {
-  #pragma omp parallel num_threads // expected-error {{expected '(' after 'num_threads'}}
-  #pragma omp parallel num_threads ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp parallel num_threads () // expected-error {{expected expression}}
-  #pragma omp parallel num_threads (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp parallel num_threads (argc)) // expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  #pragma omp parallel num_threads ((argc > 0) ? argv[1] : argv[2]) // expected-error 2 {{expression must have integral or unscoped enumeration type, not 'char *'}}
-  #pragma omp parallel num_threads (foobool(argc)), num_threads (true), num_threads (-5) // expected-error 2 {{directive '#pragma omp parallel' cannot contain more than one 'num_threads' clause}} expected-error {{argument to 'num_threads' clause must be a positive integer value}}
-  #pragma omp parallel num_threads (S) // expected-error {{'S' does not refer to a value}}
-  #pragma omp parallel num_threads (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error 2 {{expression must have integral or unscoped enumeration type, not 'char *'}}
-  #pragma omp parallel num_threads (argc)
-  #pragma omp parallel num_threads (N) // expected-error {{argument to 'num_threads' clause must be a positive integer value}}
-  foo();
+extern S1 v1;
 
-  return argc;
-}
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
 
 int main(int argc, char **argv) {
-  #pragma omp parallel num_threads // expected-error {{expected '(' after 'num_threads'}}
+  #pragma omp parallel num_threads // expected-error {{expected '(' after 'num_threads'}} expected-error {{expected expression}}
   #pragma omp parallel num_threads ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   #pragma omp parallel num_threads () // expected-error {{expected expression}}
   #pragma omp parallel num_threads (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp parallel num_threads (argc)) // expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  #pragma omp parallel num_threads (argc > 0 ? argv[1] : argv[2]) // expected-error {{integral }}
-  #pragma omp parallel num_threads (foobool(argc)), num_threads (true), num_threads (-5) // expected-error 2 {{directive '#pragma omp parallel' cannot contain more than one 'num_threads' clause}} expected-error {{argument to 'num_threads' clause must be a positive integer value}}
+  #pragma omp parallel num_threads (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  #pragma omp parallel num_threads (foobool(argc)) num_threads(3) // expected-error {{directive '#pragma omp parallel' cannot contain more than one 'num_threads' clause}}
   #pragma omp parallel num_threads (S1) // expected-error {{'S1' does not refer to a value}}
-  #pragma omp parallel num_threads (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression must have integral or unscoped enumeration type, not 'char *'}}
-  #pragma omp parallel num_threads (num_threads(tmain<int, char, -1>(argc, argv) // expected-error 2 {{expected ')'}} expected-note 2 {{to match this '('}} expected-note {{in instantiation of function template specialization 'tmain<int, char, -1>' requested here}}
+  #pragma omp parallel num_threads (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  #pragma omp parallel num_threads (v1) // expected-error {{expression has incomplete type 'S1'}}
+  #pragma omp parallel num_threads (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  #pragma omp parallel num_threads (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  #pragma omp parallel num_threads (0) // expected-error {{expression is not a positive integer value}}
+  #pragma omp parallel num_threads (-1) // expected-error {{expression is not a positive integer value}}
   foo();
 
-  return tmain<int, char, 3>(argc, argv); // expected-note {{in instantiation of function template specialization 'tmain<int, char, 3>' requested here}}
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_private_messages.cpp	2014-06-19 05:13:45.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_private_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -13,7 +13,7 @@
   mutable int a;
 public:
   S2():a(0) { }
-  static float S2s; // expected-note {{static data member is predetermined as shared}}
+  static float S2s; // expected-note {{predetermined as shared}}
 };
 const S2 b;
 const S2 ba[5];
@@ -22,9 +22,9 @@
 public:
   S3():a(0) { }
 };
-const S3 c; // expected-note {{global variable is predetermined as shared}}
-const S3 ca[5]; // expected-note {{global variable is predetermined as shared}}
-extern const int f; // expected-note {{global variable is predetermined as shared}}
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f; // expected-note {{predetermined as shared}}
 class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
@@ -42,13 +42,13 @@
 #pragma omp threadprivate(threadvar) // expected-note {{defined as threadprivate or thread local}}
 
 int main(int argc, char **argv) {
-  const int d = 5; // expected-note {{constant variable is predetermined as shared}}
-  const int da[5] = { 0 }; // expected-note {{constant variable is predetermined as shared}}
+  const int d = 5; // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
   S4 e(4); // expected-note {{'e' defined here}}
   S5 g(5); // expected-note {{'g' defined here}}
   int i;
   int &j = i; // expected-note {{'j' defined here}}
-  #pragma omp parallel private // expected-error {{expected '(' after 'private'}}
+  #pragma omp parallel private // expected-error {{expected '(' after 'private'}} expected-error {{expected expression}}
   #pragma omp parallel private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   #pragma omp parallel private () // expected-error {{expected expression}}
   #pragma omp parallel private (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
@@ -66,16 +66,48 @@
   #pragma omp parallel private(threadvar) // expected-error {{threadprivate or thread local variable cannot be private}}
   #pragma omp parallel shared(i), private(i) // expected-error {{shared variable cannot be private}} expected-note {{defined as shared}}
   foo();
-  #pragma omp parallel firstprivate(i) private(i) // expected-error {{firstprivate variable cannot be private}} expected-note {{defined as firstprivate}}
-  foo();
+  #pragma omp parallel shared(i)
   #pragma omp parallel private(i)
-  #pragma omp parallel private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type 'int &'}}
+  #pragma omp parallel private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
   foo();
+  #pragma omp for private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel private(i)
+    foo();
+  }
+  #pragma omp parallel
+  #pragma omp for firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel private(i)
+    foo();
+  }
+  #pragma omp parallel
+  #pragma omp for reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel private(i)
+    foo();
+  }
+  #pragma omp parallel
+  #pragma omp for lastprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel private(i)
+    foo();
+  }
+  #pragma omp parallel private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel private(i)
+    foo();
+  }
   #pragma omp parallel firstprivate(i)
   for (int k = 0; k < 10; ++k) {
     #pragma omp parallel private(i)
     foo();
   }
+  #pragma omp parallel reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel private(i)
+    foo();
+  }
 
   return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_proc_bind_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_proc_bind_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_proc_bind_messages.cpp	2014-05-06 02:04:14.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_proc_bind_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,9 +1,9 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
 
 void foo();
 
 int main(int argc, char **argv) {
-  #pragma omp parallel proc_bind // expected-error {{expected '(' after 'proc_bind'}}
+  #pragma omp parallel proc_bind // expected-error {{expected '(' after 'proc_bind'}} expected-error {{expected 'master', 'close' or 'spread' in OpenMP clause 'proc_bind'}}
   #pragma omp parallel proc_bind ( // expected-error {{expected 'master', 'close' or 'spread' in OpenMP clause 'proc_bind'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   #pragma omp parallel proc_bind () // expected-error {{expected 'master', 'close' or 'spread' in OpenMP clause 'proc_bind'}}
   #pragma omp parallel proc_bind (master // expected-error {{expected ')'}} expected-note {{to match this '('}}
@@ -11,11 +11,5 @@
   #pragma omp parallel proc_bind (x) // expected-error {{expected 'master', 'close' or 'spread' in OpenMP clause 'proc_bind'}}
   foo();
 
-  #pragma omp parallel proc_bind(master)
-  ++argc;
-
-  #pragma omp parallel proc_bind(close)
-  #pragma omp parallel proc_bind(spread)
-  ++argc;
   return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_reduction_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_reduction_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_reduction_messages.cpp	2014-06-19 05:13:45.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_reduction_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,234 +7,104 @@
   return argc;
 }
 
-struct S1; // expected-note {{declared here}} expected-note 4 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
-  S2 &operator+=(const S2 &arg) { return (*this); }
-
+  S2 &operator +=(const S2 &arg) {return (*this);} // expected-note {{implicitly declared private here}}
 public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-  static float S2s; // expected-note 2 {{static data member is predetermined as shared}}
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note {{predetermined as shared}}
   static const float S2sc;
 };
-const float S2::S2sc = 0; // expected-note 2 {{'S2sc' defined here}}
-S2 b;                     // expected-note 2 {{'b' defined here}}
-const S2 ba[5];           // expected-note 2 {{'ba' defined here}}
+const float S2::S2sc = 0; // expected-note {{'S2sc' defined here}}
+S2 b; // expected-note {{'b' defined here}}
+const S2 ba[5]; // expected-note {{'ba' defined here}}
 class S3 {
   int a;
-
 public:
-  S3() : a(0) {}
-  S3(const S3 &s3) : a(s3.a) {}
-  S3 operator+=(const S3 &arg1) { return arg1; }
+  S3():a(0) { }
+  S3(const S3 &s3):a(s3.a) { }
+  S3 operator +=(const S3 &arg1) {return arg1;}
 };
-int operator+=(const S3 &arg1, const S3 &arg2) { return 5; }
-S3 c;               // expected-note 2 {{'c' defined here}}
-const S3 ca[5];     // expected-note 2 {{'ca' defined here}}
-extern const int f; // expected-note 4 {{'f' declared here}}
-class S4 {          // expected-note {{'S4' declared here}}
+int operator +=(const S3 &arg1, const S3 &arg2) {return 5;} // expected-note {{candidate function not viable: no known conversion from 'class S6' to 'const S3' for 1st argument}}
+S3 c; // expected-note {{'c' defined here}}
+const S3 ca[5]; // expected-note {{'ca' defined here}}
+extern const int f; // expected-note 2 {{'f' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
   S4(const S4 &s4);
-  S4 &operator+=(const S4 &arg) { return (*this); }
-
+  S4 &operator +=(const S4 &arg) {return (*this);}
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
-S4 &operator&=(S4 &arg1, S4 &arg2) { return arg1; }
+S4 &operator &=(S4 &arg1, S4 &arg2) {return arg1;} // expected-note {{candidate function not viable: no known conversion from 'S5' to 'S4 &' for 1st argument}}
 class S5 {
   int a;
-  S5() : a(0) {}
-  S5(const S5 &s5) : a(s5.a) {}
-  S5 &operator+=(const S5 &arg);
-
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+  S5 &operator +=(const S5 &arg);
 public:
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
 };
 class S6 {
-  int a;
-
-public:
-  S6() : a(6) {}
-  operator int() { return 6; }
-} o; // expected-note 2 {{'o' defined here}}
+    int a;
+  public:
+    S6():a(6){ }
+    operator int() { return 6; }
+} o;
 
 S3 h, k;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class T>       // expected-note {{declared here}}
-T tmain(T argc) {        // expected-note 2 {{'argc' defined here}}
-  const T d = T();       // expected-note 4 {{'d' defined here}}
-  const T da[5] = {T()}; // expected-note 2 {{'da' defined here}}
-  T qa[5] = {T()};
-  T i;
-  T &j = i;                    // expected-note 4 {{'j' defined here}}
-  S3 &p = k;                   // expected-note 2 {{'p' defined here}}
-  const T &r = da[(int)i];     // expected-note 2 {{'r' defined here}}
-  T &q = qa[(int)i];           // expected-note 2 {{'q' defined here}}
-  T fl;                        // expected-note {{'fl' defined here}}
-#pragma omp parallel reduction // expected-error {{expected '(' after 'reduction'}}
-  foo();
-#pragma omp parallel reduction + // expected-error {{expected '(' after 'reduction'}} expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  foo();
-#pragma omp parallel reduction( // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp parallel reduction(- // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp parallel reduction() // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  foo();
-#pragma omp parallel reduction(*) // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}}
-  foo();
-#pragma omp parallel reduction(\) // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  foo();
-#pragma omp parallel reduction(& : argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  foo();
-#pragma omp parallel reduction(| : argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  foo();
-#pragma omp parallel reduction(|| : argc ? i : argc) // expected-error 2 {{expected variable name}}
-  foo();
-#pragma omp parallel reduction(foo : argc) //expected-error {{incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max'}}
-  foo();
-#pragma omp parallel reduction(&& : argc)
-  foo();
-#pragma omp parallel reduction(^ : T) // expected-error {{'T' does not refer to a value}}
-  foo();
-#pragma omp parallel reduction(+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 3 {{const-qualified variable cannot be reduction}}
-  foo();
-#pragma omp parallel reduction(min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' or 'max' must be of arithmetic type}} expected-error 3 {{const-qualified variable cannot be reduction}}
-  foo();
-#pragma omp parallel reduction(max : qa[1]) // expected-error 2 {{expected variable name}}
-  foo();
-#pragma omp parallel reduction(+ : ba) // expected-error {{a reduction variable with array type 'const S2 [5]'}}
-  foo();
-#pragma omp parallel reduction(* : ca) // expected-error {{a reduction variable with array type 'const S3 [5]'}}
-  foo();
-#pragma omp parallel reduction(- : da) // expected-error {{a reduction variable with array type 'const int [5]'}} expected-error {{a reduction variable with array type 'const float [5]'}}
-  foo();
-#pragma omp parallel reduction(^ : fl) // expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  foo();
-#pragma omp parallel reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
-  foo();
-#pragma omp parallel reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
-  foo();
-#pragma omp parallel reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
-  foo();
-#pragma omp parallel reduction(+ : o) // expected-error {{variable of type 'class S6' is not valid for specified reduction operation}}
-  foo();
-#pragma omp parallel private(i), reduction(+ : j), reduction(+ : q) // expected-error 4 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  foo();
-#pragma omp parallel private(k)
-#pragma omp parallel reduction(+ : p), reduction(+ : p) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  foo();
-#pragma omp parallel reduction(+ : p), reduction(+ : p) // expected-error 3 {{variable can appear only once in OpenMP 'reduction' clause}} expected-note 3 {{previously referenced here}}
-  foo();
-#pragma omp parallel reduction(+ : r) // expected-error 2 {{const-qualified variable cannot be reduction}}
-  foo();
-#pragma omp parallel shared(i)
-#pragma omp parallel reduction(min : i)
-#pragma omp parallel reduction(max : j) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  foo();
-#pragma omp parallel
-#pragma omp for private(fl)
-  for (int i = 0; i < 10; ++i)
-#pragma omp parallel reduction(+ : fl)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(- : fl)
-  for (int i = 0; i < 10; ++i)
-#pragma omp parallel reduction(+ : fl)
-    foo();
-
-  return T();
-}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
 int main(int argc, char **argv) {
-  const int d = 5;       // expected-note 2 {{'d' defined here}}
-  const int da[5] = {0}; // expected-note {{'da' defined here}}
-  int qa[5] = {0};
+  const int d = 5; // expected-note 2 {{'d' defined here}}
+  const int da[5] = { 0 }; // expected-note {{'da' defined here}}
+  int qa[5] = { 0 };
   S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note {{'g' defined here}}
+  S5 g(5);
   int i;
-  int &j = i;                  // expected-note 2 {{'j' defined here}}
-  S3 &p = k;                   // expected-note 2 {{'p' defined here}}
-  const int &r = da[i];        // expected-note {{'r' defined here}}
-  int &q = qa[i];              // expected-note {{'q' defined here}}
-  float fl;                    // expected-note {{'fl' defined here}}
-#pragma omp parallel reduction // expected-error {{expected '(' after 'reduction'}}
-  foo();
-#pragma omp parallel reduction + // expected-error {{expected '(' after 'reduction'}} expected-warning {{extra tokens at the end of '#pragma omp parallel' are ignored}}
-  foo();
-#pragma omp parallel reduction( // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp parallel reduction(- // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp parallel reduction() // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  foo();
-#pragma omp parallel reduction(*) // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}}
-  foo();
-#pragma omp parallel reduction(\) // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  foo();
-#pragma omp parallel reduction(foo : argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max'}}
-  foo();
-#pragma omp parallel reduction(| : argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp parallel reduction(|| : argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  foo();
-#pragma omp parallel reduction(~ : argc) // expected-error {{expected unqualified-id}}
-  foo();
-#pragma omp parallel reduction(&& : argc)
-  foo();
-#pragma omp parallel reduction(^ : S1) // expected-error {{'S1' does not refer to a value}}
-  foo();
-#pragma omp parallel reduction(+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{const-qualified variable cannot be reduction}}
-  foo();
-#pragma omp parallel reduction(min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' or 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
-  foo();
-#pragma omp parallel reduction(max : argv[1]) // expected-error {{expected variable name}}
-  foo();
-#pragma omp parallel reduction(+ : ba) // expected-error {{a reduction variable with array type 'const S2 [5]'}}
-  foo();
-#pragma omp parallel reduction(* : ca) // expected-error {{a reduction variable with array type 'const S3 [5]'}}
-  foo();
-#pragma omp parallel reduction(- : da) // expected-error {{a reduction variable with array type 'const int [5]'}}
-  foo();
-#pragma omp parallel reduction(^ : fl) // expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  foo();
-#pragma omp parallel reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
-  foo();
-#pragma omp parallel reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
-  foo();
-#pragma omp parallel reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{variable of type 'S5' is not valid for specified reduction operation}}
-  foo();
-#pragma omp parallel reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
-  foo();
-#pragma omp parallel reduction(+ : o) // expected-error {{variable of type 'class S6' is not valid for specified reduction operation}}
-  foo();
-#pragma omp parallel private(i), reduction(+ : j), reduction(+ : q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  foo();
-#pragma omp parallel private(k)
-#pragma omp parallel reduction(+ : p), reduction(+ : p) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  foo();
-#pragma omp parallel reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
-  foo();
-#pragma omp parallel reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
-  foo();
-#pragma omp parallel shared(i)
-#pragma omp parallel reduction(min : i)
-#pragma omp parallel reduction(max : j) // expected-error {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  int &j = i; // expected-note 2 {{'j' defined here}}
+  S3 &p = k; // expected-note 2 {{'p' defined here}}
+  const int &r = da[i]; // expected-note {{'r' defined here}}
+  int &q = qa[i]; // expected-note {{'q' defined here}}
+  float fl; // expected-note {{'fl' defined here}}
+  #pragma omp parallel reduction // expected-error {{expected '(' after 'reduction'}} expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  #pragma omp parallel reduction + // expected-error {{expected '(' after 'reduction'}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  #pragma omp parallel reduction ( // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel reduction (- // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel reduction () // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  #pragma omp parallel reduction (*) // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  #pragma omp parallel reduction (\) // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  #pragma omp parallel reduction (&: argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel reduction (| :argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel reduction (|| :argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  #pragma omp parallel reduction (&& :argc)
+  #pragma omp parallel reduction (^ : S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp parallel reduction (+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error {{'operator+=' is a private member of 'S2'}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  #pragma omp parallel reduction (min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' and 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  #pragma omp parallel reduction (max : argv[1]) // expected-error {{expected variable name}}
+  #pragma omp parallel reduction(+ : ba) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  #pragma omp parallel reduction(* : ca) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  #pragma omp parallel reduction(- : da) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  #pragma omp parallel reduction(^ : fl) // expected-error {{arguments of OpenMP clause 'reduction' with bitwise operators cannot be of floating type}}
+  #pragma omp parallel reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
+  #pragma omp parallel reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
+  #pragma omp parallel reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{no viable overloaded '&='}}
+  #pragma omp parallel reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
+  #pragma omp parallel reduction(+ : o) // expected-error {{no viable overloaded '+='}}
+  #pragma omp parallel private(i), reduction(+ : j), reduction(+:q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  #pragma omp parallel reduction(+ : p), reduction(+ : p) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  {}
+  #pragma omp parallel reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
+  #pragma omp parallel reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
+  foo();
+  #pragma omp parallel shared(i)
+  #pragma omp parallel reduction(min : i)
+  #pragma omp parallel reduction(max : j) // expected-error {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
   foo();
-#pragma omp parallel
-#pragma omp for private(fl)
-  for (int i = 0; i < 10; ++i)
-#pragma omp parallel reduction(+ : fl)
-    foo();
-#pragma omp parallel
-#pragma omp for reduction(- : fl)
-  for (int i = 0; i < 10; ++i)
-#pragma omp parallel reduction(+ : fl)
-    foo();
 
-  return tmain(argc) + tmain(fl); // expected-note {{in instantiation of function template specialization 'tmain<int>' requested here}} expected-note {{in instantiation of function template specialization 'tmain<float>' requested here}}
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_sections_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_sections_ast_print.cpp	2014-07-08 04:12:03.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,144 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
-// expected-no-diagnostics
-
-#ifndef HEADER
-#define HEADER
-
-void foo() {}
-
-template <class T>
-struct S {
-  operator T() { return T(); }
-  static T TS;
-#pragma omp threadprivate(TS)
-};
-
-// CHECK:      template <class T = int> struct S {
-// CHECK:        static int TS;
-// CHECK-NEXT:   #pragma omp threadprivate(S<int>::TS)
-// CHECK-NEXT: }
-// CHECK:      template <class T = long> struct S {
-// CHECK:        static long TS;
-// CHECK-NEXT:   #pragma omp threadprivate(S<long>::TS)
-// CHECK-NEXT: }
-// CHECK:      template <class T> struct S {
-// CHECK:        static T TS;
-// CHECK-NEXT:   #pragma omp threadprivate(S::TS)
-// CHECK:      };
-
-template <typename T, int C>
-T tmain(T argc, T *argv) {
-  T b = argc, c, d, e, f, g;
-  static T a;
-  S<T> s;
-#pragma omp parallel sections
-  {
-    a = 2;
-  }
-#pragma omp parallel sections default(none), private(argc, b) firstprivate(argv) shared(d) if (argc > 0) num_threads(C) copyin(S < T > ::TS) proc_bind(master) reduction(+ : c) reduction(max : e)
-  {
-    foo();
-  }
-#pragma omp parallel sections if (C) num_threads(s) proc_bind(close) reduction(^ : e, f) reduction(&& : g) lastprivate(b, c)
-  {
-    foo();
-#pragma omp section
-    foo();
-  }
-  return 0;
-}
-
-// CHECK: template <typename T = int, int C = 5> int tmain(int argc, int *argv) {
-// CHECK-NEXT: int b = argc, c, d, e, f, g;
-// CHECK-NEXT: static int a;
-// CHECK-NEXT: S<int> s;
-// CHECK-NEXT: #pragma omp parallel sections
-// CHECK-NEXT: {
-// CHECK-NEXT: a = 2;
-// CHECK-NEXT: }
-// CHECK-NEXT: #pragma omp parallel sections default(none) private(argc,b) firstprivate(argv) shared(d) if(argc > 0) num_threads(5) copyin(S<int>::TS) proc_bind(master) reduction(+: c) reduction(max: e)
-// CHECK-NEXT: {
-// CHECK-NEXT: foo();
-// CHECK-NEXT: }
-// CHECK-NEXT: #pragma omp parallel sections if(5) num_threads(s) proc_bind(close) reduction(^: e,f) reduction(&&: g) lastprivate(b,c)
-// CHECK-NEXT: {
-// CHECK-NEXT: foo();
-// CHECK-NEXT: #pragma omp section
-// CHECK-NEXT: foo();
-// CHECK-NEXT: }
-// CHECK: template <typename T = long, int C = 1> long tmain(long argc, long *argv) {
-// CHECK-NEXT: long b = argc, c, d, e, f, g;
-// CHECK-NEXT: static long a;
-// CHECK-NEXT: S<long> s;
-// CHECK-NEXT: #pragma omp parallel sections
-// CHECK-NEXT: {
-// CHECK-NEXT: a = 2;
-// CHECK-NEXT: }
-// CHECK-NEXT: #pragma omp parallel sections default(none) private(argc,b) firstprivate(argv) shared(d) if(argc > 0) num_threads(1) copyin(S<long>::TS) proc_bind(master) reduction(+: c) reduction(max: e)
-// CHECK-NEXT: {
-// CHECK-NEXT: foo();
-// CHECK-NEXT: }
-// CHECK-NEXT: #pragma omp parallel sections if(1) num_threads(s) proc_bind(close) reduction(^: e,f) reduction(&&: g) lastprivate(b,c)
-// CHECK-NEXT: {
-// CHECK-NEXT: foo();
-// CHECK-NEXT: #pragma omp section
-// CHECK-NEXT: foo();
-// CHECK-NEXT: }
-// CHECK: template <typename T, int C> T tmain(T argc, T *argv) {
-// CHECK-NEXT: T b = argc, c, d, e, f, g;
-// CHECK-NEXT: static T a;
-// CHECK-NEXT: S<T> s;
-// CHECK-NEXT: #pragma omp parallel sections
-// CHECK-NEXT: {
-// CHECK-NEXT: a = 2;
-// CHECK-NEXT: }
-// CHECK-NEXT: #pragma omp parallel sections default(none) private(argc,b) firstprivate(argv) shared(d) if(argc > 0) num_threads(C) copyin(S<T>::TS) proc_bind(master) reduction(+: c) reduction(max: e)
-// CHECK-NEXT: {
-// CHECK-NEXT: foo();
-// CHECK-NEXT: }
-// CHECK-NEXT: #pragma omp parallel sections if(C) num_threads(s) proc_bind(close) reduction(^: e,f) reduction(&&: g) lastprivate(b,c)
-// CHECK-NEXT: {
-// CHECK-NEXT: foo();
-// CHECK-NEXT: #pragma omp section
-// CHECK-NEXT: foo();
-// CHECK-NEXT: }
-
-enum Enum {};
-
-int main(int argc, char **argv) {
-  long x;
-  int b = argc, c, d, e, f, g;
-  static int a;
-#pragma omp threadprivate(a)
-  Enum ee;
-// CHECK: Enum ee;
-#pragma omp parallel sections
-  // CHECK-NEXT: #pragma omp parallel sections
-  {
-    a = 2;
-  }
-// CHECK-NEXT: {
-// CHECK-NEXT: a = 2;
-// CHECK-NEXT: }
-#pragma omp parallel sections default(none), private(argc, b) firstprivate(argv) if (argc > 0) num_threads(ee) copyin(a) proc_bind(spread) reduction(| : c, d) reduction(* : e) lastprivate(argv)
-  // CHECK-NEXT: #pragma omp parallel sections default(none) private(argc,b) firstprivate(argv) if(argc > 0) num_threads(ee) copyin(a) proc_bind(spread) reduction(|: c,d) reduction(*: e) lastprivate(argv)
-  {
-    foo();
-#pragma omp section
-    foo();
-#pragma omp section
-    foo();
-  }
-  // CHECK-NEXT: {
-  // CHECK-NEXT: foo();
-  // CHECK-NEXT: #pragma omp section
-  // CHECK-NEXT: foo();
-  // CHECK-NEXT: #pragma omp section
-  // CHECK-NEXT: foo();
-  // CHECK-NEXT: }
-  return tmain<int, 5>(b, &b) + tmain<long, 1>(x, &x);
-}
-
-#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_sections_copyin_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_copyin_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_sections_copyin_messages.cpp	2014-07-08 04:12:03.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_copyin_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,105 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note {{declared here}}
-class S2 {
-  mutable int a;
-
-public:
-  S2() : a(0) {}
-  S2 &operator=(S2 &s2) { return *this; }
-};
-class S3 {
-  int a;
-
-public:
-  S3() : a(0) {}
-  S3 &operator=(S3 &s3) { return *this; }
-};
-class S4 { // expected-note {{'S4' declared here}}
-  int a;
-  S4();
-  S4 &operator=(const S4 &s4);
-
-public:
-  S4(int v) : a(v) {}
-};
-class S5 { // expected-note {{'S5' declared here}}
-  int a;
-  S5() : a(0) {}
-  S5 &operator=(const S5 &s5) { return *this; }
-
-public:
-  S5(int v) : a(v) {}
-};
-template <class T>
-class ST {
-public:
-  static T s;
-};
-
-S2 k;
-S3 h;
-S4 l(3); // expected-note {{'l' defined here}}
-S5 m(4); // expected-note {{'m' defined here}}
-#pragma omp threadprivate(h, k, l, m)
-
-int main(int argc, char **argv) {
-  int i;
-#pragma omp parallel sections copyin // expected-error {{expected '(' after 'copyin'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections copyin( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections copyin() // expected-error {{expected expression}}
-  {
-    foo();
-  }
-#pragma omp parallel sections copyin(k // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections copyin(h, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections copyin(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections copyin(l) // expected-error {{copyin variable must have an accessible, unambiguous copy assignment operator}}
-  {
-    foo();
-  }
-#pragma omp parallel sections copyin(S1) // expected-error {{'S1' does not refer to a value}}
-  {
-    foo();
-  }
-#pragma omp parallel sections copyin(argv[1]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections copyin(i) // expected-error {{copyin variable must be threadprivate}}
-  {
-    foo();
-  }
-#pragma omp parallel sections copyin(m) // expected-error {{copyin variable must have an accessible, unambiguous copy assignment operator}}
-  {
-    foo();
-  }
-#pragma omp parallel sections copyin(ST < int > ::s) // expected-error {{copyin variable must be threadprivate}}
-  {
-    foo();
-  }
-
-  return 0;
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_sections_default_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_default_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_sections_default_messages.cpp	2014-07-08 04:12:03.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_default_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,39 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
-
-void foo();
-
-int main(int argc, char **argv) {
-#pragma omp parallel sections default // expected-error {{expected '(' after 'default'}}
-  {
-#pragma omp parallel sections default( // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-    {
-#pragma omp parallel sections default() // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
-      {
-#pragma omp parallel sections default(none // expected-error {{expected ')'}} expected-note {{to match this '('}}
-        {
-#pragma omp parallel sections default(shared), default(shared) // expected-error {{directive '#pragma omp parallel sections' cannot contain more than one 'default' clause}}
-          {
-#pragma omp parallel sections default(x) // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
-            {
-              foo();
-            }
-          }
-        }
-      }
-    }
-  }
-
-#pragma omp parallel sections default(none)
-  {
-    ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
-  }
-
-#pragma omp parallel sections default(none)
-  {
-#pragma omp parallel sections default(shared)
-    {
-      ++argc;
-    }
-  }
-  return 0;
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_sections_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_sections_firstprivate_messages.cpp	2014-07-08 04:12:03.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_firstprivate_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,295 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
-extern S1 a;
-class S2 {
-  mutable int a;
-
-public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-  static float S2s;
-  static const float S2sc;
-};
-const float S2::S2sc = 0;
-const S2 b;
-const S2 ba[5];
-class S3 {
-  int a;
-  S3 &operator=(const S3 &s3);
-
-public:
-  S3() : a(0) {}
-  S3(S3 &s3) : a(s3.a) {}
-};
-const S3 c;
-const S3 ca[5];
-extern const int f;
-class S4 { // expected-note 2 {{'S4' declared here}}
-  int a;
-  S4();
-  S4(const S4 &s4);
-
-public:
-  S4(int v) : a(v) {}
-};
-class S5 { // expected-note 4 {{'S5' declared here}}
-  int a;
-  S5(const S5 &s5) : a(s5.a) {}
-
-public:
-  S5() : a(0) {}
-  S5(int v) : a(v) {}
-};
-class S6 {
-  int a;
-  S6() : a(0) {}
-
-public:
-  S6(const S6 &s6) : a(s6.a) {}
-  S6(int v) : a(v) {}
-};
-
-S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class I, class C>
-int foomain(int argc, char **argv) {
-  I e(4); // expected-note {{'e' defined here}}
-  C g(5); // expected-note 2 {{'g' defined here}}
-  int i;
-  int &j = i;                              // expected-note {{'j' defined here}}
-#pragma omp parallel sections firstprivate // expected-error {{expected '(' after 'firstprivate'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate() // expected-error {{expected expression}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(argc)
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(a, b) // expected-error {{firstprivate variable with incomplete type 'S1'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(argv[1]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
-  {
-    foo();
-  }
-#pragma omp parallel sections linear(i) // expected-error {{unexpected OpenMP clause 'linear' in directive '#pragma omp parallel sections'}}
-  {
-    foo();
-  }
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;
-#pragma omp parallel sections firstprivate(i)
-    {
-      foo();
-    }
-    v += i;
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp parallel sections firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(i)
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(g) firstprivate(g) // expected-error {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  {
-    foo();
-  }
-#pragma omp parallel private(i)
-#pragma omp parallel sections firstprivate(i)
-  {
-    foo();
-  }
-#pragma omp parallel reduction(+ : i)
-#pragma omp parallel sections firstprivate(i)
-  {
-    foo();
-  }
-  return 0;
-}
-
-int main(int argc, char **argv) {
-  const int d = 5;
-  const int da[5] = {0};
-  S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note 2 {{'g' defined here}}
-  S3 m;
-  S6 n(2);
-  int i;
-  int &j = i;                              // expected-note {{'j' defined here}}
-#pragma omp parallel sections firstprivate // expected-error {{expected '(' after 'firstprivate'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate() // expected-error {{expected expression}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(argc)
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(argv[1]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(2 * 2) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(ba) // OK
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(ca) // OK
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(da) // OK
-  {
-    foo();
-  }
-  int xa;
-#pragma omp parallel sections firstprivate(xa) // OK
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(S2::S2s) // OK
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(S2::S2sc) // OK
-  {
-    foo();
-  }
-#pragma omp parallel sections safelen(5) // expected-error {{unexpected OpenMP clause 'safelen' in directive '#pragma omp parallel sections'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(m) // OK
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(xa), firstprivate(xa) // expected-error {{private variable cannot be firstprivate}} expected-note {{defined as private}}
-  {
-    foo();
-  }
-#pragma omp parallel shared(xa)
-#pragma omp parallel sections firstprivate(xa) // OK: may be firstprivate
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(g) firstprivate(g) // expected-error {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(n) firstprivate(n) // OK
-  {
-    foo();
-  }
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;
-#pragma omp parallel sections firstprivate(i)
-    {
-      foo();
-    }
-    v += i;
-  }
-#pragma omp parallel private(i)
-#pragma omp parallel sections firstprivate(i)
-  {
-    foo();
-  }
-#pragma omp parallel reduction(+ : i)
-#pragma omp parallel sections firstprivate(i)
-  {
-    foo();
-  }
-
-  return foomain<S4, S5>(argc, argv); // expected-note {{in instantiation of function template specialization 'foomain<S4, S5>' requested here}}
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_sections_if_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_if_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_sections_if_messages.cpp	2014-07-08 04:12:03.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_if_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,113 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note {{declared here}}
-
-template <class T, class S> // expected-note {{declared here}}
-int tmain(T argc, S **argv) {
-  #pragma omp parallel sections if // expected-error {{expected '(' after 'if'}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if () // expected-error {{expected expression}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (argc > 0 ? argv[1] : argv[2])
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp parallel sections' cannot contain more than one 'if' clause}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (S) // expected-error {{'S' does not refer to a value}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (argc argc) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if(argc)
-  {
-    foo();
-  }
-
-  return 0;
-}
-
-int main(int argc, char **argv) {
-  #pragma omp parallel sections if // expected-error {{expected '(' after 'if'}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if () // expected-error {{expected expression}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (argc > 0 ? argv[1] : argv[2])
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp parallel sections' cannot contain more than one 'if' clause}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (S1) // expected-error {{'S1' does not refer to a value}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (argc argc) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if (1 0) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-  #pragma omp parallel sections if(if(tmain(argc, argv) // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-
-  return tmain(argc, argv);
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_sections_lastprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_lastprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_sections_lastprivate_messages.cpp	2014-07-08 04:12:03.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_lastprivate_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,269 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
-extern S1 a;
-class S2 {
-  mutable int a;
-
-public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-  static float S2s; // expected-note {{static data member is predetermined as shared}}
-  static const float S2sc;
-};
-const float S2::S2sc = 0; // expected-note {{static data member is predetermined as shared}}
-const S2 b;
-const S2 ba[5];
-class S3 { // expected-note 2 {{'S3' declared here}}
-  int a;
-  S3 &operator=(const S3 &s3);
-
-public:
-  S3() : a(0) {}
-  S3(S3 &s3) : a(s3.a) {}
-};
-const S3 c;         // expected-note {{global variable is predetermined as shared}}
-const S3 ca[5];     // expected-note {{global variable is predetermined as shared}}
-extern const int f; // expected-note {{global variable is predetermined as shared}}
-class S4 {          // expected-note 3 {{'S4' declared here}}
-  int a;
-  S4();
-  S4(const S4 &s4);
-
-public:
-  S4(int v) : a(v) {}
-};
-class S5 { // expected-note {{'S5' declared here}}
-  int a;
-  S5() : a(0) {}
-
-public:
-  S5(const S5 &s5) : a(s5.a) {}
-  S5(int v) : a(v) {}
-};
-class S6 {
-  int a;
-  S6() : a(0) {}
-
-public:
-  S6(const S6 &s6) : a(s6.a) {}
-  S6(int v) : a(v) {}
-};
-
-S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class I, class C>
-int foomain(int argc, char **argv) {
-  I e(4); // expected-note {{'e' defined here}}
-  I g(5); // expected-note {{'g' defined here}}
-  int i;
-  int &j = i;                             // expected-note {{'j' defined here}}
-#pragma omp parallel sections lastprivate // expected-error {{expected '(' after 'lastprivate'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate() // expected-error {{expected expression}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(argc)
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(a, b) // expected-error {{lastprivate variable with incomplete type 'S1'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(argv[1]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(e, g) // expected-error 2 {{lastprivate variable must have an accessible, unambiguous default constructor}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(h) // expected-error {{threadprivate or thread local variable cannot be lastprivate}}
-  {
-    foo();
-  }
-#pragma omp parallel sections linear(i) // expected-error {{unexpected OpenMP clause 'linear' in directive '#pragma omp parallel sections'}}
-  {
-    foo();
-  }
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;
-#pragma omp parallel sections lastprivate(i)
-    {
-      foo();
-    }
-    v += i;
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp parallel sections lastprivate(j) // expected-error {{arguments of OpenMP clause 'lastprivate' cannot be of reference type}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(i)
-  {
-    foo();
-  }
-  return 0;
-}
-
-int main(int argc, char **argv) {
-  const int d = 5;       // expected-note {{constant variable is predetermined as shared}}
-  const int da[5] = {0}; // expected-note {{constant variable is predetermined as shared}}
-  S4 e(4);               // expected-note {{'e' defined here}}
-  S5 g(5);               // expected-note {{'g' defined here}}
-  S3 m;                  // expected-note 2 {{'m' defined here}}
-  S6 n(2);
-  int i;
-  int &j = i;                             // expected-note {{'j' defined here}}
-#pragma omp parallel sections lastprivate // expected-error {{expected '(' after 'lastprivate'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate() // expected-error {{expected expression}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(argc)
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(a, b, c, d, f) // expected-error {{lastprivate variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be lastprivate}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(argv[1]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(2 * 2) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(ba)
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(ca) // expected-error {{shared variable cannot be lastprivate}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(da) // expected-error {{shared variable cannot be lastprivate}}
-  {
-    foo();
-  }
-  int xa;
-#pragma omp parallel sections lastprivate(xa) // OK
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(S2::S2s) // expected-error {{shared variable cannot be lastprivate}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(S2::S2sc) // expected-error {{shared variable cannot be lastprivate}}
-  {
-    foo();
-  }
-#pragma omp parallel sections safelen(5) // expected-error {{unexpected OpenMP clause 'safelen' in directive '#pragma omp parallel sections'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(e, g) // expected-error 2 {{lastprivate variable must have an accessible, unambiguous default constructor}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(m) // expected-error {{lastprivate variable must have an accessible, unambiguous copy assignment operator}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(h) // expected-error {{threadprivate or thread local variable cannot be lastprivate}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(xa), lastprivate(xa) // expected-error {{private variable cannot be lastprivate}} expected-note {{defined as private}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(i)
-  {
-    foo();
-  }
-#pragma omp parallel private(xa)
-#pragma omp parallel sections lastprivate(xa)
-  {
-    foo();
-  }
-#pragma omp parallel reduction(+ : xa)
-#pragma omp parallel sections lastprivate(xa)
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(j) // expected-error {{arguments of OpenMP clause 'lastprivate' cannot be of reference type}}
-  {
-    foo();
-  }
-#pragma omp parallel sections firstprivate(m) lastprivate(m) // expected-error {{lastprivate variable must have an accessible, unambiguous copy assignment operator}}
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(n) firstprivate(n) // OK
-  {
-    foo();
-  }
-  return foomain<S4, S5>(argc, argv); // expected-note {{in instantiation of function template specialization 'foomain<S4, S5>' requested here}}
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_sections_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_sections_messages.cpp	2014-07-20 22:45:36.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,85 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -std=c++11 -o - %s
-
-void foo() {
-}
-
-#pragma omp parallel sections // expected-error {{unexpected OpenMP directive '#pragma omp parallel sections'}}
-
-int main(int argc, char **argv) {
-#pragma omp parallel sections {// expected-warning {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-  {
-    foo();
-  }
-#pragma omp parallel sections( // expected-warning {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-  {
-    foo();
-  }
-#pragma omp parallel sections[ // expected-warning {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-  {
-    foo();
-  }
-#pragma omp parallel sections] // expected-warning {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-  {
-    foo();
-  }
-#pragma omp parallel sections) // expected-warning {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-  {
-    foo();
-  }
-#pragma omp parallel sections } // expected-warning {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-  {
-    foo();
-  }
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-#pragma omp parallel sections unknown()
-  {
-    foo();
-#pragma omp section
-  L1:
-    foo();
-  }
-#pragma omp parallel sections
-  {
-    ;
-  }
-#pragma omp parallel sections
-  {
-    goto L1; // expected-error {{use of undeclared label 'L1'}}
-  }
-
-  for (int i = 0; i < 10; ++i) {
-    switch (argc) {
-    case (0):
-#pragma omp parallel sections
-    {
-      foo();
-      break;    // expected-error {{'break' statement not in loop or switch statement}}
-      continue; // expected-error {{'continue' statement not in loop statement}}
-    }
-    default:
-      break;
-    }
-  }
-#pragma omp parallel sections default(none)
-  {
-    ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
-  }
-
-  goto L2; // expected-error {{use of undeclared label 'L2'}}
-#pragma omp parallel sections
-  {
-  L2:
-    foo();
-  }
-#pragma omp parallel sections
-  {
-    return 1; // expected-error {{cannot return from OpenMP region}}
-  }
-
-  [[]] // expected-error {{an attribute list cannot appear here}}
-#pragma omp parallel sections
-  {
-  }
-
-  return 0;
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_sections_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/parallel_sections_misc_messages.c	2014-07-08 04:12:03.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,260 +0,0 @@
-// RUN: %clang_cc1 -fsyntax-only -fopenmp=libiomp5 -verify %s
-
-void foo();
-
-// expected-error@+1 {{unexpected OpenMP directive '#pragma omp parallel sections'}}
-#pragma omp parallel sections
-
-// expected-error@+1 {{unexpected OpenMP directive '#pragma omp parallel sections'}}
-#pragma omp parallel sections foo
-
-void test_no_clause() {
-  int i;
-#pragma omp parallel sections
-  {
-    foo();
-  }
-
-// expected-error@+2 {{the statement for '#pragma omp parallel sections' must be a compound statement}}
-#pragma omp parallel sections
-  ++i;
-
-#pragma omp parallel sections
-  {
-    foo();
-    foo(); // expected-error {{statement in 'omp parallel sections' directive must be enclosed into a section region}}
-  }
-
-}
-
-void test_branch_protected_scope() {
-  int i = 0;
-L1:
-  ++i;
-
-  int x[24];
-
-#pragma omp parallel sections
-  {
-    if (i == 5)
-      goto L1; // expected-error {{use of undeclared label 'L1'}}
-    else if (i == 6)
-      return; // expected-error {{cannot return from OpenMP region}}
-    else if (i == 7)
-      goto L2;
-    else if (i == 8) {
-    L2:
-      x[i]++;
-    }
-#pragma omp section
-    if (i == 5)
-      goto L1; // expected-error {{use of undeclared label 'L1'}}
-    else if (i == 6)
-      return; // expected-error {{cannot return from OpenMP region}}
-    else if (i == 7)
-      goto L3;
-    else if (i == 8) {
-    L3:
-      x[i]++;
-    }
-  }
-
-  if (x[0] == 0)
-    goto L2; // expected-error {{use of undeclared label 'L2'}}
-  else if (x[1] == 1)
-    goto L1;
-  goto L3; // expected-error {{use of undeclared label 'L3'}}
-}
-
-void test_invalid_clause() {
-  int i;
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-#pragma omp parallel sections foo bar
-  {
-    foo();
-// expected-error@+1 {{unexpected OpenMP clause 'nowait' in directive '#pragma omp section'}}
-#pragma omp section nowait
-    ;
-  }
-}
-
-void test_non_identifiers() {
-  int i, x;
-
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-#pragma omp parallel sections;
-  {
-    foo();
-  }
-// expected-error@+2 {{unexpected OpenMP clause 'linear' in directive '#pragma omp parallel sections'}}
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-#pragma omp parallel sections linear(x);
-  {
-    foo();
-  }
-
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-#pragma omp parallel sections private(x);
-  {
-    foo();
-  }
-
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-#pragma omp parallel sections, private(x);
-  {
-    foo();
-  }
-}
-
-void test_private() {
-  int i;
-// expected-error@+2 {{expected expression}}
-// expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-#pragma omp parallel sections private(
-  {
-    foo();
-  }
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp parallel sections private(,
-  {
-    foo();
-  }
-// expected-error@+1 2 {{expected expression}}
-#pragma omp parallel sections private(, )
-  {
-    foo();
-  }
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel sections private()
-  {
-    foo();
-  }
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel sections private(int)
-  {
-    foo();
-  }
-// expected-error@+1 {{expected variable name}}
-#pragma omp parallel sections private(0)
-  {
-    foo();
-  }
-
-  int x, y, z;
-#pragma omp parallel sections private(x)
-  {
-    foo();
-  }
-#pragma omp parallel sections private(x, y)
-  {
-    foo();
-  }
-#pragma omp parallel sections private(x, y, z)
-  {
-    foo();
-  }
-}
-
-void test_lastprivate() {
-  int i;
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel sections lastprivate(
-  {
-    foo();
-  }
-
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp parallel sections lastprivate(,
-  {
-    foo();
-  }
-// expected-error@+1 2 {{expected expression}}
-#pragma omp parallel sections lastprivate(, )
-  {
-    foo();
-  }
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel sections lastprivate()
-  {
-    foo();
-  }
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel sections lastprivate(int)
-  {
-    foo();
-  }
-// expected-error@+1 {{expected variable name}}
-#pragma omp parallel sections lastprivate(0)
-  {
-    foo();
-  }
-
-  int x, y, z;
-#pragma omp parallel sections lastprivate(x)
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(x, y)
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(x, y, z)
-  {
-    foo();
-  }
-}
-
-void test_firstprivate() {
-  int i;
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel sections firstprivate(
-  {
-    foo();
-  }
-
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp parallel sections firstprivate(,
-  {
-    foo();
-  }
-// expected-error@+1 2 {{expected expression}}
-#pragma omp parallel sections firstprivate(, )
-  {
-    foo();
-  }
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel sections firstprivate()
-  {
-    foo();
-  }
-// expected-error@+1 {{expected expression}}
-#pragma omp parallel sections firstprivate(int)
-  {
-    foo();
-  }
-// expected-error@+1 {{expected variable name}}
-#pragma omp parallel sections firstprivate(0)
-  {
-    foo();
-  }
-
-  int x, y, z;
-#pragma omp parallel sections lastprivate(x) firstprivate(x)
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(x, y) firstprivate(x, y)
-  {
-    foo();
-  }
-#pragma omp parallel sections lastprivate(x, y, z) firstprivate(x, y, z)
-  {
-    foo();
-  }
-}
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_sections_num_threads_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_num_threads_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_sections_num_threads_messages.cpp	2014-07-08 04:12:03.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_num_threads_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,63 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note {{declared here}}
-
-template <class T, typename S, int N> // expected-note {{declared here}}
-T tmain(T argc, S **argv) {
-  #pragma omp parallel sections num_threads // expected-error {{expected '(' after 'num_threads'}}
-  {foo();}
-  #pragma omp parallel sections num_threads ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {foo();}
-  #pragma omp parallel sections num_threads () // expected-error {{expected expression}}
-  {foo();}
-  #pragma omp parallel sections num_threads (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {foo();}
-  #pragma omp parallel sections num_threads (argc)) // expected-warning {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-  {foo();}
-  #pragma omp parallel sections num_threads ((argc > 0) ? argv[1] : argv[2]) // expected-error 2 {{expression must have integral or unscoped enumeration type, not 'char *'}}
-  {foo();}
-  #pragma omp parallel sections num_threads (foobool(argc)), num_threads (true), num_threads (-5) // expected-error 2 {{directive '#pragma omp parallel sections' cannot contain more than one 'num_threads' clause}} expected-error {{argument to 'num_threads' clause must be a positive integer value}}
-  {foo();}
-  #pragma omp parallel sections num_threads (S) // expected-error {{'S' does not refer to a value}}
-  {foo();}
-  #pragma omp parallel sections num_threads (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error 2 {{expression must have integral or unscoped enumeration type, not 'char *'}}
-  {foo();}
-  #pragma omp parallel sections num_threads (argc)
-  {foo();}
-  #pragma omp parallel sections num_threads (N) // expected-error {{argument to 'num_threads' clause must be a positive integer value}}
-  {foo();}
-
-  return argc;
-}
-
-int main(int argc, char **argv) {
-  #pragma omp parallel sections num_threads // expected-error {{expected '(' after 'num_threads'}}
-  {foo();}
-  #pragma omp parallel sections num_threads ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {foo();}
-  #pragma omp parallel sections num_threads () // expected-error {{expected expression}}
-  {foo();}
-  #pragma omp parallel sections num_threads (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {foo();}
-  #pragma omp parallel sections num_threads (argc)) // expected-warning {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-  {foo();}
-  #pragma omp parallel sections num_threads (argc > 0 ? argv[1] : argv[2]) // expected-error {{integral }}
-  {foo();}
-  #pragma omp parallel sections num_threads (foobool(argc)), num_threads (true), num_threads (-5) // expected-error 2 {{directive '#pragma omp parallel sections' cannot contain more than one 'num_threads' clause}} expected-error {{argument to 'num_threads' clause must be a positive integer value}}
-  {foo();}
-  #pragma omp parallel sections num_threads (S1) // expected-error {{'S1' does not refer to a value}}
-  {foo();}
-  #pragma omp parallel sections num_threads (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression must have integral or unscoped enumeration type, not 'char *'}}
-  {foo();}
-  #pragma omp parallel sections num_threads (num_threads(tmain<int, char, -1>(argc, argv) // expected-error 2 {{expected ')'}} expected-note 2 {{to match this '('}} expected-note {{in instantiation of function template specialization 'tmain<int, char, -1>' requested here}}
-  {foo();}
-
-  return tmain<int, char, 3>(argc, argv); // expected-note {{in instantiation of function template specialization 'tmain<int, char, 3>' requested here}}
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_sections_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_sections_private_messages.cpp	2014-07-11 07:25:16.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_private_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,204 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
-extern S1 a;
-class S2 {
-  mutable int a;
-
-public:
-  S2() : a(0) {}
-};
-const S2 b;
-const S2 ba[5];
-class S3 {
-  int a;
-
-public:
-  S3() : a(0) {}
-};
-const S3 ca[5];
-class S4 { // expected-note {{'S4' declared here}}
-  int a;
-  S4();
-
-public:
-  S4(int v) : a(v) {}
-};
-class S5 { // expected-note {{'S5' declared here}}
-  int a;
-  S5() : a(0) {}
-
-public:
-  S5(int v) : a(v) {}
-};
-
-S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class I, class C>
-int foomain(I argc, C **argv) {
-  I e(4);
-  I g(5);
-  int i;
-  int &j = i;                         // expected-note {{'j' defined here}}
-#pragma omp parallel sections private // expected-error {{expected '(' after 'private'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private() // expected-error {{expected expression}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(argc)
-  {
-    foo();
-  }
-#pragma omp parallel sections private(S1) // expected-error {{'S1' does not refer to a value}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(a, b) // expected-error {{private variable with incomplete type 'S1'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(argv[1]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(e, g)
-  {
-    foo();
-  }
-#pragma omp parallel sections private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
-  {
-    foo();
-  }
-#pragma omp parallel sections copyprivate(h) // expected-error {{unexpected OpenMP clause 'copyprivate' in directive '#pragma omp parallel sections'}}
-  {
-    foo();
-  }
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;
-#pragma omp parallel sections private(i)
-    {
-      foo();
-    }
-    v += i;
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp parallel sections private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(i)
-  {
-    foo();
-  }
-  return 0;
-}
-
-int main(int argc, char **argv) {
-  S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note {{'g' defined here}}
-  int i;
-  int &j = i;                         // expected-note {{'j' defined here}}
-#pragma omp parallel sections private // expected-error {{expected '(' after 'private'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private() // expected-error {{expected expression}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(argc)
-  {
-    foo();
-  }
-#pragma omp parallel sections private(S1) // expected-error {{'S1' does not refer to a value}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(a, b) // expected-error {{private variable with incomplete type 'S1'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(argv[1]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
-  {
-    foo();
-  }
-#pragma omp parallel sections copyprivate(h) // expected-error {{unexpected OpenMP clause 'copyprivate' in directive '#pragma omp parallel sections'}}
-  {
-    foo();
-  }
-#pragma omp parallel
-  {
-    int i;
-#pragma omp parallel sections private(i)
-    {
-      foo();
-    }
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp parallel sections private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(i)
-  {
-    foo();
-  }
-
-  return 0;
-}
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_sections_proc_bind_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_proc_bind_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_sections_proc_bind_messages.cpp	2014-07-08 04:12:03.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_proc_bind_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,28 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
-
-void foo();
-
-int main(int argc, char **argv) {
-#pragma omp parallel sections proc_bind // expected-error {{expected '(' after 'proc_bind'}}
-  { foo(); }
-#pragma omp parallel sections proc_bind( // expected-error {{expected 'master', 'close' or 'spread' in OpenMP clause 'proc_bind'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  { foo(); }
-#pragma omp parallel sections proc_bind() // expected-error {{expected 'master', 'close' or 'spread' in OpenMP clause 'proc_bind'}}
-  { foo(); }
-#pragma omp parallel sections proc_bind(master // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  { foo(); }
-#pragma omp parallel sections proc_bind(close), proc_bind(spread) // expected-error {{directive '#pragma omp parallel sections' cannot contain more than one 'proc_bind' clause}}
-  { foo(); }
-#pragma omp parallel sections proc_bind(x) // expected-error {{expected 'master', 'close' or 'spread' in OpenMP clause 'proc_bind'}}
-  { foo(); }
-
-#pragma omp parallel sections proc_bind(master)
-  { ++argc; }
-
-#pragma omp parallel sections proc_bind(close)
-  {
-#pragma omp parallel sections proc_bind(spread)
-    { ++argc; }
-  }
-  return 0;
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_sections_reduction_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_reduction_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_sections_reduction_messages.cpp	2014-07-08 04:12:03.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_reduction_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,358 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note {{declared here}} expected-note 4 {{forward declaration of 'S1'}}
-extern S1 a;
-class S2 {
-  mutable int a;
-  S2 &operator+=(const S2 &arg) { return (*this); }
-
-public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-  static float S2s; // expected-note 2 {{static data member is predetermined as shared}}
-  static const float S2sc;
-};
-const float S2::S2sc = 0; // expected-note 2 {{'S2sc' defined here}}
-S2 b;                     // expected-note 2 {{'b' defined here}}
-const S2 ba[5];           // expected-note 2 {{'ba' defined here}}
-class S3 {
-  int a;
-
-public:
-  S3() : a(0) {}
-  S3(const S3 &s3) : a(s3.a) {}
-  S3 operator+=(const S3 &arg1) { return arg1; }
-};
-int operator+=(const S3 &arg1, const S3 &arg2) { return 5; }
-S3 c;               // expected-note 2 {{'c' defined here}}
-const S3 ca[5];     // expected-note 2 {{'ca' defined here}}
-extern const int f; // expected-note 4 {{'f' declared here}}
-class S4 {          // expected-note {{'S4' declared here}}
-  int a;
-  S4();
-  S4(const S4 &s4);
-  S4 &operator+=(const S4 &arg) { return (*this); }
-
-public:
-  S4(int v) : a(v) {}
-};
-S4 &operator&=(S4 &arg1, S4 &arg2) { return arg1; }
-class S5 {
-  int a;
-  S5() : a(0) {}
-  S5(const S5 &s5) : a(s5.a) {}
-  S5 &operator+=(const S5 &arg);
-
-public:
-  S5(int v) : a(v) {}
-};
-class S6 {
-  int a;
-
-public:
-  S6() : a(6) {}
-  operator int() { return 6; }
-} o; // expected-note 2 {{'o' defined here}}
-
-S3 h, k;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class T>       // expected-note {{declared here}}
-T tmain(T argc) {        // expected-note 2 {{'argc' defined here}}
-  const T d = T();       // expected-note 4 {{'d' defined here}}
-  const T da[5] = {T()}; // expected-note 2 {{'da' defined here}}
-  T qa[5] = {T()};
-  T i;
-  T &j = i;                             // expected-note 4 {{'j' defined here}}
-  S3 &p = k;                            // expected-note 2 {{'p' defined here}}
-  const T &r = da[(int)i];              // expected-note 2 {{'r' defined here}}
-  T &q = qa[(int)i];                    // expected-note 2 {{'q' defined here}}
-  T fl;                                 // expected-note {{'fl' defined here}}
-#pragma omp parallel sections reduction // expected-error {{expected '(' after 'reduction'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction + // expected-error {{expected '(' after 'reduction'}} expected-warning {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction( // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(- // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction() // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(*) // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(\) // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(& : argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(| : argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(|| : argc ? i : argc) // expected-error 2 {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(foo : argc) //expected-error {{incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(&& : argc)
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(^ : T) // expected-error {{'T' does not refer to a value}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 3 {{const-qualified variable cannot be reduction}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' or 'max' must be of arithmetic type}} expected-error 3 {{const-qualified variable cannot be reduction}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(max : qa[1]) // expected-error 2 {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(+ : ba) // expected-error {{a reduction variable with array type 'const S2 [5]'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(* : ca) // expected-error {{a reduction variable with array type 'const S3 [5]'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(- : da) // expected-error {{a reduction variable with array type 'const int [5]'}} expected-error {{a reduction variable with array type 'const float [5]'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(^ : fl) // expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(+ : o) // expected-error {{variable of type 'class S6' is not valid for specified reduction operation}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(i), reduction(+ : j), reduction(+ : q) // expected-error 4 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  {
-    foo();
-  }
-#pragma omp parallel private(k)
-#pragma omp parallel sections reduction(+ : p), reduction(+ : p) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(+ : p), reduction(+ : p) // expected-error 3 {{variable can appear only once in OpenMP 'reduction' clause}} expected-note 3 {{previously referenced here}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(+ : r) // expected-error 2 {{const-qualified variable cannot be reduction}}
-  {
-    foo();
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel reduction(min : i)
-#pragma omp parallel sections reduction(max : j) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  {
-    foo();
-  }
-#pragma omp parallel private(fl)
-#pragma omp parallel sections reduction(+ : fl)
-  {
-    foo();
-  }
-#pragma omp parallel reduction(* : fl)
-#pragma omp parallel sections reduction(+ : fl)
-  {
-    foo();
-  }
-
-  return T();
-}
-
-int main(int argc, char **argv) {
-  const int d = 5;       // expected-note 2 {{'d' defined here}}
-  const int da[5] = {0}; // expected-note {{'da' defined here}}
-  int qa[5] = {0};
-  S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note {{'g' defined here}}
-  int i;
-  int &j = i;                           // expected-note 2 {{'j' defined here}}
-  S3 &p = k;                            // expected-note 2 {{'p' defined here}}
-  const int &r = da[i];                 // expected-note {{'r' defined here}}
-  int &q = qa[i];                       // expected-note {{'q' defined here}}
-  float fl;                             // expected-note {{'fl' defined here}}
-#pragma omp parallel sections reduction // expected-error {{expected '(' after 'reduction'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction + // expected-error {{expected '(' after 'reduction'}} expected-warning {{extra tokens at the end of '#pragma omp parallel sections' are ignored}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction( // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(- // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction() // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(*) // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(\) // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(foo : argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(| : argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(|| : argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(~ : argc) // expected-error {{expected unqualified-id}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(&& : argc)
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(^ : S1) // expected-error {{'S1' does not refer to a value}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{const-qualified variable cannot be reduction}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' or 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(max : argv[1]) // expected-error {{expected variable name}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(+ : ba) // expected-error {{a reduction variable with array type 'const S2 [5]'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(* : ca) // expected-error {{a reduction variable with array type 'const S3 [5]'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(- : da) // expected-error {{a reduction variable with array type 'const int [5]'}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(^ : fl) // expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{variable of type 'S5' is not valid for specified reduction operation}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(+ : o) // expected-error {{variable of type 'class S6' is not valid for specified reduction operation}}
-  {
-    foo();
-  }
-#pragma omp parallel sections private(i), reduction(+ : j), reduction(+ : q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  {
-    foo();
-  }
-#pragma omp parallel private(k)
-#pragma omp parallel sections reduction(+ : p), reduction(+ : p) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
-  {
-    foo();
-  }
-#pragma omp parallel sections reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
-  {
-    foo();
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel reduction(min : i)
-#pragma omp parallel sections reduction(max : j) // expected-error {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  {
-    foo();
-  }
-#pragma omp parallel private(fl)
-#pragma omp parallel sections reduction(+ : fl)
-  {
-    foo();
-  }
-#pragma omp parallel reduction(* : fl)
-#pragma omp parallel sections reduction(+ : fl)
-  {
-    foo();
-  }
-
-  return tmain(argc) + tmain(fl); // expected-note {{in instantiation of function template specialization 'tmain<int>' requested here}} expected-note {{in instantiation of function template specialization 'tmain<float>' requested here}}
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_sections_shared_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_shared_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_sections_shared_messages.cpp	2014-07-08 04:12:03.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_sections_shared_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,110 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
-
-void foo() {
-}
-
-bool foobool(int argc) {
-  return argc;
-}
-
-struct S1; // expected-note {{declared here}}
-extern S1 a;
-class S2 {
-  mutable int a;
-
-public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-};
-const S2 b;
-const S2 ba[5];
-class S3 {
-  int a;
-
-public:
-  S3() : a(0) {}
-  S3(S3 &s3) : a(s3.a) {}
-};
-const S3 c;
-const S3 ca[5];
-extern const int f;
-class S4 {
-  int a;
-  S4();
-  S4(const S4 &s4);
-
-public:
-  S4(int v) : a(v) {}
-};
-class S5 {
-  int a;
-  S5() : a(0) {}
-  S5(const S5 &s5) : a(s5.a) {}
-
-public:
-  S5(int v) : a(v) {}
-};
-
-S3 h;
-#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
-
-int main(int argc, char **argv) {
-  const int d = 5;
-  const int da[5] = {0};
-  S4 e(4);
-  S5 g(5);
-  int i;
-  int &j = i;
-#pragma omp parallel sections shared // expected-error {{expected '(' after 'shared'}}
-  { foo(); }
-#pragma omp parallel sections shared( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  { foo(); }
-#pragma omp parallel sections shared() // expected-error {{expected expression}}
-  { foo(); }
-#pragma omp parallel sections shared(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  { foo(); }
-#pragma omp parallel sections shared(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  { foo(); }
-#pragma omp parallel sections shared(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  { foo(); }
-#pragma omp parallel sections shared(argc)
-  { foo(); }
-#pragma omp parallel sections shared(S1) // expected-error {{'S1' does not refer to a value}}
-  { foo(); }
-#pragma omp parallel sections shared(a, b, c, d, f)
-  { foo(); }
-#pragma omp parallel sections shared(argv[1]) // expected-error {{expected variable name}}
-  { foo(); }
-#pragma omp parallel sections shared(ba)
-  { foo(); }
-#pragma omp parallel sections shared(ca)
-  { foo(); }
-#pragma omp parallel sections shared(da)
-  { foo(); }
-#pragma omp parallel sections shared(e, g)
-  { foo(); }
-#pragma omp parallel sections shared(h) // expected-error {{threadprivate or thread local variable cannot be shared}}
-  { foo(); }
-#pragma omp parallel sections private(i), shared(i) // expected-error {{private variable cannot be shared}} expected-note {{defined as private}}
-  { foo(); }
-#pragma omp parallel sections firstprivate(i), shared(i) // expected-error {{firstprivate variable cannot be shared}} expected-note {{defined as firstprivate}}
-  { foo(); }
-#pragma omp parallel sections private(i)
-  {
-#pragma omp parallel sections shared(i)
-    {
-#pragma omp parallel sections shared(j)
-      { foo(); }
-    }
-  }
-#pragma omp parallel sections firstprivate(i)
-  {
-#pragma omp parallel sections shared(i)
-    {
-#pragma omp parallel sections shared(j)
-      { foo(); }
-    }
-  }
-
-  return 0;
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/parallel_shared_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/parallel_shared_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/parallel_shared_messages.cpp	2014-03-06 00:43:53.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/parallel_shared_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -51,7 +51,7 @@
   S5 g(5);
   int i;
   int &j = i;
-  #pragma omp parallel shared // expected-error {{expected '(' after 'shared'}}
+  #pragma omp parallel shared // expected-error {{expected '(' after 'shared'}} expected-error {{expected expression}}
   #pragma omp parallel shared ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   #pragma omp parallel shared () // expected-error {{expected expression}}
   #pragma omp parallel shared (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/predefined_macro.c cfe-3.5.0.src.omp/test/OpenMP/predefined_macro.c
--- cfe-3.5.0.src/test/OpenMP/predefined_macro.c	2014-03-06 07:27:56.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/predefined_macro.c	2014-11-28 10:49:31.000000000 -0500
@@ -1,32 +1,32 @@
-// RUN: %clang_cc1 -fopenmp=libiomp5 -verify -DFOPENMP -o - %s
+// RUN: %clang_cc1 -fopenmp -verify -DFOPENMP -o - %s
 // RUN: %clang_cc1 -verify -o - %s
 // expected-no-diagnostics
 #ifdef FOPENMP
-// -fopenmp=libiomp5 option is specified
+// -fopenmp option is specified
 #ifndef _OPENMP
 #error "No _OPENMP macro is defined with -fopenmp option"
-#elsif _OPENMP != 201307
+#elsif _OPENMP != 201107
 #error "_OPENMP has incorrect value"
 #endif //_OPENMP
 #else
-// No -fopenmp=libiomp5 option is specified
+// No -fopenmp option is specified
 #ifdef _OPENMP
 #error "_OPENMP macro is defined without -fopenmp option"
 #endif // _OPENMP
 #endif // FOPENMP
 
-// RUN: %clang_cc1 -fopenmp=libiomp5 -verify -DFOPENMP -o - %s
+// RUN: %clang_cc1 -fopenmp -verify -DFOPENMP -o - %s
 // RUN: %clang_cc1 -verify -o - %s
 // expected-no-diagnostics
 #ifdef FOPENMP
-// -fopenmp=libiomp5 option is specified
+// -fopenmp option is specified
 #ifndef _OPENMP
 #error "No _OPENMP macro is defined with -fopenmp option"
-#elsif _OPENMP != 201307
+#elsif _OPENMP != 201107
 #error "_OPENMP has incorrect value"
 #endif // _OPENMP
 #else
-// No -fopenmp=libiomp5 option is specified
+// No -fopenmp option is specified
 #ifdef _OPENMP
 #error "_OPENMP macro is defined without -fopenmp option"
 #endif // _OPENMP
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/sections_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/sections_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/sections_ast_print.cpp	2014-06-26 04:21:58.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/sections_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
 // expected-no-diagnostics
 
 #ifndef HEADER
@@ -8,45 +8,41 @@
 
 void foo() {}
 
-template <class T, int N>
-T tmain(T argc) {
-  T b = argc, c, d, e, f, g;
-  static T a;
-// CHECK: static T a;
-#pragma omp parallel
-#pragma omp sections private(argc, b), firstprivate(c, d), lastprivate(d, f) reduction(- : g) nowait
-  {
-    foo();
-  }
-  // CHECK-NEXT: #pragma omp parallel
-  // CHECK-NEXT: #pragma omp sections private(argc,b) firstprivate(c,d) lastprivate(d,f) reduction(-: g) nowait
-  // CHECK-NEXT: {
-  // CHECK-NEXT: foo();
-  // CHECK-NEXT: }
-  return T();
-}
-
-int main(int argc, char **argv) {
+int main (int argc, char **argv) {
   int b = argc, c, d, e, f, g;
   static int a;
 // CHECK: static int a;
+#pragma omp sections
+{
+  a=2;
+}
+// CHECK-NEXT: #pragma omp sections
+// CHECK-NEXT: {
+// CHECK-NEXT: a = 2;
+// CHECK-NEXT: }
 #pragma omp parallel
-#pragma omp sections private(argc, b), firstprivate(argv, c), lastprivate(d, f) reduction(+ : g) nowait
+#pragma omp sections private(argc,b),firstprivate(argv, c),lastprivate(d,f),reduction(+:e) reduction(min : g), nowait
+{
+  foo();
+  #pragma omp section
+  #pragma omp sections
   {
-#pragma omp section
-    foo();
-#pragma omp section
+    #pragma omp section
     foo();
   }
-  // CHECK-NEXT: #pragma omp parallel
-  // CHECK-NEXT: #pragma omp sections private(argc,b) firstprivate(argv,c) lastprivate(d,f) reduction(+: g) nowait
-  // CHECK-NEXT: {
-  // CHECK-NEXT: #pragma omp section
-  // CHECK-NEXT: foo();
-  // CHECK-NEXT: #pragma omp section
-  // CHECK-NEXT: foo();
-  // CHECK-NEXT: }
-  return (tmain<int, 5>(argc) + tmain<char, 1>(argv[0][0]));
+}
+// CHECK-NEXT: #pragma omp parallel
+// CHECK-NEXT: #pragma omp sections private(argc,b) firstprivate(argv,c) lastprivate(d,f) reduction(+: e) reduction(min: g) nowait
+// CHECK-NEXT: {
+// CHECK-NEXT: foo();
+// CHECK-NEXT: #pragma omp section
+// CHECK-NEXT: #pragma omp sections
+// CHECK-NEXT: {
+// CHECK-NEXT: #pragma omp section
+// CHECK-NEXT: foo();
+// CHECK-NEXT: }
+// CHECK-NEXT: }
+  return (0);
 }
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/sections_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/sections_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/sections_firstprivate_messages.cpp	2014-06-25 07:44:49.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/sections_firstprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,14 +7,13 @@
   return argc;
 }
 
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
-
 public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
   static float S2s;
   static const float S2sc;
 };
@@ -23,313 +22,195 @@
 const S2 ba[5];
 class S3 {
   int a;
-  S3 &operator=(const S3 &s3);
-
 public:
-  S3() : a(0) {}
-  S3(S3 &s3) : a(s3.a) {}
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
 };
 const S3 c;
 const S3 ca[5];
 extern const int f;
-class S4 { // expected-note 2 {{'S4' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
   S4(const S4 &s4);
-
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
-class S5 { // expected-note 4 {{'S5' declared here}}
+class S5 { // expected-note {{'S5' declared here}}
   int a;
-  S5(const S5 &s5) : a(s5.a) {}
-
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
 public:
-  S5() : a(0) {}
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
 };
 class S6 {
   int a;
-  S6() : a(0) {}
-
 public:
-  S6(const S6 &s6) : a(s6.a) {}
-  S6(int v) : a(v) {}
+  S6() : a(0) { }
 };
 
 S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
-template <class I, class C>
-int foomain(int argc, char **argv) {
-  I e(4); // expected-note {{'e' defined here}}
-  C g(5); // expected-note 2 {{'g' defined here}}
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  S6 p;
   int i;
   int &j = i; // expected-note {{'j' defined here}}
-#pragma omp parallel
-#pragma omp sections firstprivate // expected-error {{expected '(' after 'firstprivate'}}
-  {
-    foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp sections firstprivate // expected-error {{expected '(' after 'firstprivate'}} expected-error {{expected expression}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate() // expected-error {{expected expression}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp sections firstprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
-    foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(argc)
+  #pragma omp sections firstprivate () // expected-error {{expected expression}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(a, b) // expected-error {{firstprivate variable with incomplete type 'S1'}}
+  #pragma omp parallel
+  #pragma omp sections firstprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(argv[1]) // expected-error {{expected variable name}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
+  #pragma omp parallel
+  #pragma omp sections firstprivate (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections linear(i) // expected-error {{unexpected OpenMP clause 'linear' in directive '#pragma omp sections'}}
+  #pragma omp parallel
+  #pragma omp sections firstprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
   {
     foo();
-  }
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;                           // expected-note {{variable with automatic storage duration is predetermined as private; perhaps you forget to enclose 'omp sections' directive into a parallel or another task region?}}
-#pragma omp sections firstprivate(i) // expected-error {{private variable cannot be firstprivate}}
-    {
-      foo();
-    }
-    v += i;
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp sections firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(i)
+  #pragma omp parallel
+  #pragma omp sections firstprivate (argc)
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(g) firstprivate(g) // expected-error {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel private(i)      // expected-note {{defined as private}}
-#pragma omp sections firstprivate(i) // expected-error {{firstprivate variable must be shared}}
+  #pragma omp parallel
+  #pragma omp sections firstprivate (S1) // expected-error {{'S1' does not refer to a value}}
   {
     foo();
-  }
-#pragma omp parallel reduction(+ : i) // expected-note {{defined as reduction}}
-#pragma omp sections firstprivate(i)  // expected-error {{firstprivate variable must be shared}}
-  {
+    #pragma omp section
     foo();
   }
-  return 0;
-}
-
-int main(int argc, char **argv) {
-  const int d = 5;
-  const int da[5] = {0};
-  S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note 2 {{'g' defined here}}
-  S3 m;
-  S6 n(2);
-  int i;
-  int &j = i; // expected-note {{'j' defined here}}
-#pragma omp parallel
-#pragma omp sections firstprivate // expected-error {{expected '(' after 'firstprivate'}}
+  #pragma omp parallel
+  #pragma omp sections firstprivate (a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate() // expected-error {{expected expression}}
+  #pragma omp parallel
+  #pragma omp sections firstprivate (argv[1]) // expected-error {{expected variable name}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp sections firstprivate(ba)
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(argc)
+  #pragma omp parallel
+  #pragma omp sections firstprivate(ca)
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
+  #pragma omp parallel
+  #pragma omp sections firstprivate(da)
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(argv[1]) // expected-error {{expected variable name}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(2 * 2) // expected-error {{expected variable name}}
+  #pragma omp parallel
+  #pragma omp sections firstprivate(S2::S2s)
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(ba) // OK
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(ca) // OK
+  #pragma omp parallel
+  #pragma omp sections firstprivate(S2::S2sc)
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(da) // OK
-  {
+    #pragma omp section
     foo();
   }
-  int xa;
-#pragma omp parallel
-#pragma omp sections firstprivate(xa) // OK
+  #pragma omp parallel
+  #pragma omp sections lastprivate(p),firstprivate(e, g, p) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(S2::S2s) // OK
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(S2::S2sc) // OK
+  #pragma omp parallel
+  #pragma omp sections firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections safelen(5) // expected-error {{unexpected OpenMP clause 'safelen' in directive '#pragma omp sections'}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
+  #pragma omp parallel
+  #pragma omp sections private(i), firstprivate(i) // expected-error {{private variable cannot be firstprivate}} expected-note{{defined as private}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(m) // OK
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
+  #pragma omp parallel shared(i)
+  #pragma omp sections firstprivate(i)
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections private(xa), firstprivate(xa) // expected-error {{private variable cannot be firstprivate}} expected-note {{defined as private}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel shared(xa)
-#pragma omp sections firstprivate(xa) // OK: may be firstprivate
+  #pragma omp parallel private(i) // expected-note {{defined as private}}
+  #pragma omp sections firstprivate(i) // expected-error {{private variable in '#pragma omp parallel' cannot be firstprivate in '#pragma omp sections'}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(g) firstprivate(g) // expected-error {{firstprivate variable must have an accessible, unambiguous copy constructor}}
+  #pragma omp parallel reduction(+:i) // expected-note {{defined as reduction}}
+  #pragma omp sections firstprivate(i) // expected-error {{reduction variable in '#pragma omp parallel' cannot be firstprivate in '#pragma omp sections'}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(n) firstprivate(n) // OK
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;                           // expected-note {{variable with automatic storage duration is predetermined as private; perhaps you forget to enclose 'omp sections' directive into a parallel or another task region?}}
-#pragma omp sections firstprivate(i) // expected-error {{private variable cannot be firstprivate}}
-    {
-      foo();
-    }
-    v += i;
-  }
-#pragma omp parallel private(i)      // expected-note {{defined as private}}
-#pragma omp sections firstprivate(i) // expected-error {{firstprivate variable must be shared}}
+  #pragma omp parallel
+  #pragma omp sections firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
   {
     foo();
-  }
-#pragma omp parallel reduction(+ : i) // expected-note {{defined as reduction}}
-#pragma omp sections firstprivate(i)  // expected-error {{firstprivate variable must be shared}}
-  {
+    #pragma omp section
     foo();
   }
 
-  return foomain<S4, S5>(argc, argv); // expected-note {{in instantiation of function template specialization 'foomain<S4, S5>' requested here}}
-}
+  return 0;
+}
\ No newline at end of file
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/sections_lastprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/sections_lastprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/sections_lastprivate_messages.cpp	2014-06-25 07:44:49.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/sections_lastprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,303 +7,220 @@
   return argc;
 }
 
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
-
 public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-  static float S2s; // expected-note {{static data member is predetermined as shared}}
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note {{predetermined as shared}}
   static const float S2sc;
 };
-const float S2::S2sc = 0; // expected-note {{static data member is predetermined as shared}}
+const float S2::S2sc = 0; // expected-note {{predetermined as shared}}
 const S2 b;
 const S2 ba[5];
-class S3 { // expected-note 2 {{'S3' declared here}}
+class S3 { // expected-note {{'S3' declared here}}
   int a;
-  S3 &operator=(const S3 &s3);
-
+  S3& operator =(const S3& s3);
 public:
-  S3() : a(0) {}
-  S3(S3 &s3) : a(s3.a) {}
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
 };
-const S3 c;         // expected-note {{global variable is predetermined as shared}}
-const S3 ca[5];     // expected-note {{global variable is predetermined as shared}}
-extern const int f; // expected-note {{global variable is predetermined as shared}}
-class S4 {          // expected-note 3 {{'S4' declared here}}
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f; // expected-note {{predetermined as shared}}
+class S4 { // expected-note 2 {{'S4' declared here}}
   int a;
   S4();
   S4(const S4 &s4);
-
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
 class S5 { // expected-note {{'S5' declared here}}
   int a;
-  S5() : a(0) {}
-
-public:
-  S5(const S5 &s5) : a(s5.a) {}
-  S5(int v) : a(v) {}
-};
-class S6 {
-  int a;
-  S6() : a(0) {}
-
+  S5():a(0) {}
 public:
-  S6(const S6 &s6) : a(s6.a) {}
-  S6(int v) : a(v) {}
+  S5(const S5 &s5):a(s5.a) { }
+  S5(int v):a(v) { }
 };
 
 S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
-template <class I, class C>
-int foomain(int argc, char **argv) {
-  I e(4); // expected-note {{'e' defined here}}
-  I g(5); // expected-note {{'g' defined here}}
+int main(int argc, char **argv) {
+  const int d = 5; // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
+  S4 e(4); // expected-note 2 {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  S3 m; // expected-note {{'m' defined here}}
   int i;
   int &j = i; // expected-note {{'j' defined here}}
-#pragma omp parallel
-#pragma omp sections lastprivate // expected-error {{expected '(' after 'lastprivate'}}
+  #pragma omp sections lastprivate // expected-error {{expected '(' after 'lastprivate'}} expected-error {{expected expression}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate() // expected-error {{expected expression}}
+  #pragma omp sections lastprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp sections lastprivate () // expected-error {{expected expression}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(argc)
+  #pragma omp parallel
+  #pragma omp sections lastprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(a, b) // expected-error {{lastprivate variable with incomplete type 'S1'}}
+  #pragma omp parallel
+  #pragma omp sections lastprivate (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(argv[1]) // expected-error {{expected variable name}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(e, g) // expected-error 2 {{lastprivate variable must have an accessible, unambiguous default constructor}}
+  #pragma omp parallel
+  #pragma omp sections lastprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(h) // expected-error {{threadprivate or thread local variable cannot be lastprivate}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections linear(i) // expected-error {{unexpected OpenMP clause 'linear' in directive '#pragma omp sections'}}
+  #pragma omp parallel
+  #pragma omp sections lastprivate (argc)
   {
     foo();
-  }
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;                          // expected-note {{variable with automatic storage duration is predetermined as private; perhaps you forget to enclose 'omp sections' directive into a parallel or another task region?}}
-#pragma omp sections lastprivate(i) // expected-error {{lastprivate variable must be shared}}
-    {
-      foo();
-    }
-    v += i;
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp sections lastprivate(j) // expected-error {{arguments of OpenMP clause 'lastprivate' cannot be of reference type}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(i)
+  #pragma omp parallel
+  #pragma omp sections lastprivate (S1) // expected-error {{'S1' does not refer to a value}}
   {
     foo();
-  }
-  return 0;
-}
-
-int main(int argc, char **argv) {
-  const int d = 5;       // expected-note {{constant variable is predetermined as shared}}
-  const int da[5] = {0}; // expected-note {{constant variable is predetermined as shared}}
-  S4 e(4);               // expected-note {{'e' defined here}}
-  S5 g(5);               // expected-note {{'g' defined here}}
-  S3 m;                  // expected-note 2 {{'m' defined here}}
-  S6 n(2);
-  int i;
-  int &j = i; // expected-note {{'j' defined here}}
-#pragma omp parallel
-#pragma omp sections lastprivate // expected-error {{expected '(' after 'lastprivate'}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp sections lastprivate (a, b, c, d, f) // expected-error {{lastprivate variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be lastprivate}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate() // expected-error {{expected expression}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp sections lastprivate (argv[1]) // expected-error {{expected variable name}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  #pragma omp parallel
+  #pragma omp sections lastprivate(ba)
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(argc)
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp parallel
+  #pragma omp sections lastprivate(ca) // expected-error {{shared variable cannot be lastprivate}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(a, b, c, d, f) // expected-error {{lastprivate variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be lastprivate}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(argv[1]) // expected-error {{expected variable name}}
+  #pragma omp parallel
+  #pragma omp sections lastprivate(da) // expected-error {{shared variable cannot be lastprivate}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(2 * 2) // expected-error {{expected variable name}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(ba)
+  #pragma omp parallel
+  #pragma omp sections lastprivate(S2::S2s) // expected-error {{shared variable cannot be lastprivate}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(ca) // expected-error {{shared variable cannot be lastprivate}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(da) // expected-error {{shared variable cannot be lastprivate}}
+  #pragma omp parallel
+  #pragma omp sections lastprivate(S2::S2sc) // expected-error {{shared variable cannot be lastprivate}}
   {
     foo();
-  }
-  int xa;
-#pragma omp parallel
-#pragma omp sections lastprivate(xa) // OK
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(S2::S2s) // expected-error {{shared variable cannot be lastprivate}}
+  #pragma omp parallel
+  #pragma omp sections firstprivate (g), lastprivate(e, g) // expected-error {{lastprivate variable must have an accessible, unambiguous default constructor}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(S2::S2sc) // expected-error {{shared variable cannot be lastprivate}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections safelen(5) // expected-error {{unexpected OpenMP clause 'safelen' in directive '#pragma omp sections'}}
+  #pragma omp parallel
+  #pragma omp sections lastprivate(e, g) // expected-error 2 {{lastprivate variable must have an accessible, unambiguous default constructor}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(e, g) // expected-error 2 {{lastprivate variable must have an accessible, unambiguous default constructor}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(m) // expected-error {{lastprivate variable must have an accessible, unambiguous copy assignment operator}}
+  #pragma omp parallel
+  #pragma omp sections lastprivate(m) // expected-error {{lastprivate variable must have an accessible, unambiguous copy assignment operator}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(h) // expected-error {{threadprivate or thread local variable cannot be lastprivate}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections private(xa), lastprivate(xa) // expected-error {{private variable cannot be lastprivate}} expected-note {{defined as private}}
+  #pragma omp parallel
+  #pragma omp sections lastprivate(h) // expected-error {{threadprivate or thread local variable cannot be lastprivate}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(i)
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel private(xa)     // expected-note {{defined as private}}
-#pragma omp sections lastprivate(xa) // expected-error {{lastprivate variable must be shared}}
+  #pragma omp parallel
+  #pragma omp sections private(i), lastprivate(i) // expected-error {{private variable cannot be lastprivate}} expected-note{{defined as private}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp parallel reduction(+ : xa) // expected-note {{defined as reduction}}
-#pragma omp sections lastprivate(xa)   // expected-error {{lastprivate variable must be shared}}
+  #pragma omp parallel shared(i)
+  #pragma omp sections lastprivate(i)
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(j) // expected-error {{arguments of OpenMP clause 'lastprivate' cannot be of reference type}}
+  #pragma omp parallel private(i) // expected-note {{defined as private}}
+  #pragma omp sections lastprivate(i) // expected-error {{private variable in '#pragma omp parallel' cannot be lastprivate in '#pragma omp sections'}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp parallel
-#pragma omp sections firstprivate(m) lastprivate(m) // expected-error {{lastprivate variable must have an accessible, unambiguous copy assignment operator}}
+  #pragma omp parallel reduction(+:i) // expected-note {{defined as reduction}}
+  #pragma omp sections lastprivate(i) // expected-error {{reduction variable in '#pragma omp parallel' cannot be lastprivate in '#pragma omp sections'}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp parallel
-#pragma omp sections lastprivate(n) firstprivate(n) // OK
+  #pragma omp parallel
+  #pragma omp sections lastprivate(j) // expected-error {{arguments of OpenMP clause 'lastprivate' cannot be of reference type}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-  return foomain<S4, S5>(argc, argv); // expected-note {{in instantiation of function template specialization 'foomain<S4, S5>' requested here}}
-}
+
+  return 0;
+}
\ No newline at end of file
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/sections_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/sections_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/sections_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/sections_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,123 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int foo();
+
+int main() {
+  #pragma omp section // expected-error {{orphaned '#pragma omp section' is prohibited}}
+  ;
+  #pragma omp section // expected-error {{orphaned '#pragma omp section' is prohibited}}
+  foo();
+  #pragma omp sections
+  {
+    foo();
+    #pragma omp parallel
+    #pragma omp section // expected-error {{orphaned '#pragma omp section' is prohibited}}
+    foo();
+  }
+  #pragma omp sections
+  {
+    foo();
+    foo(); // expected-error {{the statement for '#pragma omp sections' must be '#pragma omp section'}}
+  }
+  #pragma omp sections
+  {
+    #pragma omp section
+    foo();
+    foo(); // expected-error {{the statement for '#pragma omp sections' must be '#pragma omp section'}}
+  }
+  #pragma omp sections
+  foo(); // expected-error {{the statement for '#pragma omp sections' must be compound statement}}
+  #pragma omp sections nowait nowait // expected-error {{directive '#pragma omp sections' cannot contain more than one 'nowait' clause}}
+  {
+    foo();
+  }
+  #pragma omp sections
+  {
+    foo();
+    #pragma omp section
+    {
+      foo();
+      foo();
+    }
+    #pragma omp section
+  } // expected-error {{expected statement}}
+  #pragma omp sections
+  {
+    foo();
+    #pragma omp sections // expected-error {{region cannot be closely nested inside a worksharing region}}
+    {
+      foo();
+    }
+  }
+  #pragma omp for
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp sections // expected-error {{region cannot be closely nested inside a worksharing region}}
+    {
+      foo();
+    }
+  }
+  #pragma omp single
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp sections // expected-error {{region cannot be closely nested inside a worksharing region}}
+    {
+      foo();
+    }
+  }
+  #pragma omp master
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp sections // expected-error {{region cannot be closely nested inside a master region}}
+    {
+      foo();
+    }
+  }
+  #pragma omp critical
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp sections // expected-error {{region cannot be closely nested inside a critical region}}
+    {
+      foo();
+    }
+  }
+  #pragma omp for ordered
+  for (int i = 0; i < 10; ++i)
+  #pragma omp ordered
+  {
+    foo();
+    #pragma omp sections // expected-error {{region cannot be closely nested inside an ordered region}}
+    {
+      foo();
+    }
+  }
+
+  return 0;
+}
+
+int foo() {
+  L1:
+    foo();
+  #pragma omp sections
+  {
+    LS:
+    #pragma omp section
+    {
+      foo();
+      goto L1; // expected-error {{use of undeclared label 'L1'}}
+    }
+    #pragma omp section
+    {
+      foo();
+      goto LS; // expected-error {{use of undeclared label 'LS'}}
+    }
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+  #pragma omp sections
+  {
+    L2:
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/sections_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/sections_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/sections_misc_messages.c	2014-07-20 22:45:36.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/sections_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,299 +0,0 @@
-// RUN: %clang_cc1 -fsyntax-only -fopenmp=libiomp5 -verify %s
-
-void foo();
-
-// expected-error@+1 {{unexpected OpenMP directive '#pragma omp sections'}}
-#pragma omp sections
-
-// expected-error@+1 {{unexpected OpenMP directive '#pragma omp sections'}}
-#pragma omp sections foo
-
-void test_no_clause() {
-  int i;
-#pragma omp sections
-  {
-    foo();
-  }
-
-// expected-error@+2 {{the statement for '#pragma omp sections' must be a compound statement}}
-#pragma omp sections
-  ++i;
-
-#pragma omp sections
-  {
-    foo();
-    foo(); // expected-error {{statement in 'omp sections' directive must be enclosed into a section region}}
-  }
-}
-
-void test_branch_protected_scope() {
-  int i = 0;
-L1:
-  ++i;
-
-  int x[24];
-
-#pragma omp parallel
-#pragma omp sections
-  {
-    if (i == 5)
-      goto L1; // expected-error {{use of undeclared label 'L1'}}
-    else if (i == 6)
-      return; // expected-error {{cannot return from OpenMP region}}
-    else if (i == 7)
-      goto L2;
-    else if (i == 8) {
-    L2:
-      x[i]++;
-    }
-#pragma omp section
-    if (i == 5)
-      goto L1; // expected-error {{use of undeclared label 'L1'}}
-    else if (i == 6)
-      return; // expected-error {{cannot return from OpenMP region}}
-    else if (i == 7)
-      goto L3;
-    else if (i == 8) {
-    L3:
-      x[i]++;
-    }
-  }
-
-  if (x[0] == 0)
-    goto L2; // expected-error {{use of undeclared label 'L2'}}
-  else if (x[1] == 1)
-    goto L1;
-  goto L3; // expected-error {{use of undeclared label 'L3'}}
-}
-
-void test_invalid_clause() {
-  int i;
-#pragma omp parallel
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp sections' are ignored}}
-#pragma omp sections foo bar
-  {
-    foo();
-// expected-error@+1 {{unexpected OpenMP clause 'nowait' in directive '#pragma omp section'}}
-#pragma omp section nowait
-    ;
-  }
-}
-
-void test_non_identifiers() {
-  int i, x;
-
-#pragma omp parallel
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp sections' are ignored}}
-#pragma omp sections;
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+2 {{unexpected OpenMP clause 'linear' in directive '#pragma omp sections'}}
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp sections' are ignored}}
-#pragma omp sections linear(x);
-  {
-    foo();
-  }
-
-#pragma omp parallel
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp sections' are ignored}}
-#pragma omp sections private(x);
-  {
-    foo();
-  }
-
-#pragma omp parallel
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp sections' are ignored}}
-#pragma omp sections, private(x);
-  {
-    foo();
-  }
-}
-
-void test_private() {
-  int i;
-#pragma omp parallel
-// expected-error@+2 {{expected expression}}
-// expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-#pragma omp sections private(
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp sections private(,
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+1 2 {{expected expression}}
-#pragma omp sections private(, )
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp sections private()
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp sections private(int)
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+1 {{expected variable name}}
-#pragma omp sections private(0)
-  {
-    foo();
-  }
-
-  int x, y, z;
-#pragma omp parallel
-#pragma omp sections private(x)
-  {
-    foo();
-  }
-#pragma omp parallel
-#pragma omp sections private(x, y)
-  {
-    foo();
-  }
-#pragma omp parallel
-#pragma omp sections private(x, y, z)
-  {
-    foo();
-  }
-}
-
-void test_lastprivate() {
-  int i;
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 {{expected expression}}
-#pragma omp sections lastprivate(
-  {
-    foo();
-  }
-
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp sections lastprivate(,
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+1 2 {{expected expression}}
-#pragma omp sections lastprivate(, )
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp sections lastprivate()
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp sections lastprivate(int)
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+1 {{expected variable name}}
-#pragma omp sections lastprivate(0)
-  {
-    foo();
-  }
-
-  int x, y, z;
-#pragma omp parallel
-#pragma omp sections lastprivate(x)
-  {
-    foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(x, y)
-  {
-    foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(x, y, z)
-  {
-    foo();
-  }
-}
-
-void test_firstprivate() {
-  int i;
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 {{expected expression}}
-#pragma omp sections firstprivate(
-  {
-    foo();
-  }
-
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp sections firstprivate(,
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+1 2 {{expected expression}}
-#pragma omp sections firstprivate(, )
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp sections firstprivate()
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp sections firstprivate(int)
-  {
-    foo();
-  }
-#pragma omp parallel
-// expected-error@+1 {{expected variable name}}
-#pragma omp sections firstprivate(0)
-  {
-    foo();
-  }
-
-  int x, y, z;
-#pragma omp parallel
-#pragma omp sections lastprivate(x) firstprivate(x)
-  {
-    foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(x, y) firstprivate(x, y)
-  {
-    foo();
-  }
-#pragma omp parallel
-#pragma omp sections lastprivate(x, y, z) firstprivate(x, y, z)
-  {
-    foo();
-  }
-}
-
-void test_nowait() {
-#pragma omp parallel
-#pragma omp sections nowait nowait // expected-error {{directive '#pragma omp sections' cannot contain more than one 'nowait' clause}}
-  {
-    ;
-  }
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/sections_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/sections_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/sections_private_messages.cpp	2014-06-25 07:44:49.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/sections_private_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,198 +7,213 @@
   return argc;
 }
 
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
-
 public:
-  S2() : a(0) {}
+  S2():a(0) { }
+  static float S2s; // expected-note {{predetermined as shared}}
 };
 const S2 b;
 const S2 ba[5];
 class S3 {
   int a;
-
 public:
-  S3() : a(0) {}
+  S3():a(0) { }
 };
-const S3 ca[5];
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f;  // expected-note {{predetermined as shared}}
 class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
-
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
 class S5 { // expected-note {{'S5' declared here}}
   int a;
-  S5() : a(0) {}
-
+  S5():a(0) {}
 public:
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
 };
 
 S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
-template <class I, class C>
-int foomain(I argc, C **argv) {
-  I e(4);
-  I g(5);
+int main(int argc, char **argv) {
+  const int d = 5;  // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
   int i;
-  int &j = i;                // expected-note {{'j' defined here}}
-#pragma omp sections private // expected-error {{expected '(' after 'private'}}
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp sections private // expected-error {{expected '(' after 'private'}} expected-error {{expected expression}}
   {
     foo();
-  }
-#pragma omp sections private( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp sections private() // expected-error {{expected expression}}
+  #pragma omp sections private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   {
     foo();
-  }
-#pragma omp sections private(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp sections private(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp sections private () // expected-error {{expected expression}}
   {
     foo();
-  }
-#pragma omp sections private(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp sections private(argc)
+  #pragma omp sections private (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
   {
     foo();
-  }
-#pragma omp sections private(S1) // expected-error {{'S1' does not refer to a value}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp sections private(a, b) // expected-error {{private variable with incomplete type 'S1'}}
+  #pragma omp sections private (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   {
     foo();
-  }
-#pragma omp sections private(argv[1]) // expected-error {{expected variable name}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp sections private(e, g)
+  #pragma omp sections private (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
   {
     foo();
-  }
-#pragma omp sections private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp sections shared(i) // expected-error {{unexpected OpenMP clause 'shared' in directive '#pragma omp sections'}}
+  #pragma omp sections private (argc)
   {
     foo();
-  }
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;
-#pragma omp sections private(i)
-    {
-      foo();
-    }
-    v += i;
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp sections private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp sections private(i)
+  #pragma omp sections private (S1) // expected-error {{'S1' does not refer to a value}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-  return 0;
-}
-
-int main(int argc, char **argv) {
-  S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note {{'g' defined here}}
-  int i;
-  int &j = i;                // expected-note {{'j' defined here}}
-#pragma omp sections private // expected-error {{expected '(' after 'private'}}
+  #pragma omp sections private (a, b, c, d, f) // expected-error {{private variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be private}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp sections private( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp sections private (argv[1]) // expected-error {{expected variable name}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp sections private() // expected-error {{expected expression}}
+  #pragma omp sections private(ba)
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp sections private(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp sections private(ca) // expected-error {{shared variable cannot be private}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp sections private(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp sections private(da) // expected-error {{shared variable cannot be private}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp sections private(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  #pragma omp sections private(S2::S2s) // expected-error {{shared variable cannot be private}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp sections private(argc)
+  #pragma omp sections private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp sections private(S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp sections private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp sections private(a, b) // expected-error {{private variable with incomplete type 'S1'}}
+  #pragma omp sections shared(i) // expected-error {{unexpected OpenMP clause 'shared' in directive '#pragma omp sections'}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp sections private(argv[1]) // expected-error {{expected variable name}}
+  #pragma omp parallel
+  #pragma omp sections firstprivate(i), private(i) // expected-error {{firstprivate variable cannot be private}} expected-note {{defined as firstprivate}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp sections private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
+  #pragma omp parallel shared(i)
+  #pragma omp parallel private(i)
+  #pragma omp sections private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp sections private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
+  #pragma omp parallel shared(i)
+  #pragma omp parallel private(i)
+  #pragma omp parallel firstprivate(i)
+  #pragma omp parallel reduction(+:i)
+  #pragma omp sections private(i)
   {
     foo();
+    #pragma omp section
+    foo();
   }
-#pragma omp sections shared(i) // expected-error {{unexpected OpenMP clause 'shared' in directive '#pragma omp sections'}}
+  #pragma omp sections private(i)
   {
     foo();
+    #pragma omp section
+    #pragma omp sections private(i)
+    {
+      foo();
+    }
   }
-#pragma omp parallel
+  #pragma omp parallel
+  #pragma omp sections firstprivate(i)
   {
-    int i;
-#pragma omp sections private(i)
+    foo();
+    #pragma omp section
+    #pragma omp sections private(i)
     {
       foo();
     }
   }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp sections private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
+  #pragma omp parallel
+  #pragma omp sections reduction(+:i)
   {
     foo();
+    #pragma omp section
+    #pragma omp sections private(i)
+    {
+      foo();
+    }
   }
-#pragma omp sections private(i)
+  #pragma omp parallel
+  #pragma omp sections lastprivate(i)
   {
     foo();
+    #pragma omp section
+    #pragma omp sections private(i)
+    {
+      foo();
+    }
   }
 
   return 0;
-}
-
+}
\ No newline at end of file
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/sections_reduction_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/sections_reduction_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/sections_reduction_messages.cpp	2014-06-25 07:44:49.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/sections_reduction_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,407 +7,280 @@
   return argc;
 }
 
-struct S1; // expected-note {{declared here}} expected-note 4 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
-  S2 &operator+=(const S2 &arg) { return (*this); }
-
+  S2 &operator +=(const S2 &arg) {return (*this);} // expected-note {{implicitly declared private here}}
 public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-  static float S2s; // expected-note 2 {{static data member is predetermined as shared}}
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note {{predetermined as shared}}
   static const float S2sc;
 };
-const float S2::S2sc = 0; // expected-note 2 {{'S2sc' defined here}}
-S2 b;                     // expected-note 2 {{'b' defined here}}
-const S2 ba[5];           // expected-note 2 {{'ba' defined here}}
+const float S2::S2sc = 0; // expected-note {{'S2sc' defined here}}
+S2 b; // expected-note {{'b' defined here}}
+const S2 ba[5]; // expected-note {{'ba' defined here}}
 class S3 {
   int a;
-
 public:
-  S3() : a(0) {}
-  S3(const S3 &s3) : a(s3.a) {}
-  S3 operator+=(const S3 &arg1) { return arg1; }
+  S3():a(0) { }
+  S3(const S3 &s3):a(s3.a) { }
+  S3 operator +=(const S3 &arg1) {return arg1;}
 };
-int operator+=(const S3 &arg1, const S3 &arg2) { return 5; }
-S3 c;               // expected-note 2 {{'c' defined here}}
-const S3 ca[5];     // expected-note 2 {{'ca' defined here}}
-extern const int f; // expected-note 4 {{'f' declared here}}
-class S4 {          // expected-note {{'S4' declared here}}
+int operator +=(const S3 &arg1, const S3 &arg2) {return 5;} // expected-note {{candidate function not viable: no known conversion from 'class S6' to 'const S3' for 1st argument}}
+S3 c; // expected-note {{'c' defined here}}
+const S3 ca[5]; // expected-note {{'ca' defined here}}
+extern const int f; // expected-note 2 {{'f' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
   S4(const S4 &s4);
-  S4 &operator+=(const S4 &arg) { return (*this); }
-
+  S4 &operator +=(const S4 &arg) {return (*this);}
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
-S4 &operator&=(S4 &arg1, S4 &arg2) { return arg1; }
+S4 &operator &=(S4 &arg1, S4 &arg2) {return arg1;} // expected-note {{candidate function not viable: no known conversion from 'S5' to 'S4 &' for 1st argument}}
 class S5 {
   int a;
-  S5() : a(0) {}
-  S5(const S5 &s5) : a(s5.a) {}
-  S5 &operator+=(const S5 &arg);
-
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+  S5 &operator +=(const S5 &arg);
 public:
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
 };
 class S6 {
-  int a;
-
-public:
-  S6() : a(6) {}
-  operator int() { return 6; }
-} o; // expected-note 2 {{'o' defined here}}
+    int a;
+  public:
+    S6():a(6){ }
+    operator int() { return 6; }
+} o;
 
 S3 h, k;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
-template <class T>       // expected-note {{declared here}}
-T tmain(T argc) {        // expected-note 2 {{'argc' defined here}}
-  const T d = T();       // expected-note 4 {{'d' defined here}}
-  const T da[5] = {T()}; // expected-note 2 {{'da' defined here}}
-  T qa[5] = {T()};
-  T i;
-  T &j = i;                // expected-note 4 {{'j' defined here}}
-  S3 &p = k;               // expected-note 2 {{'p' defined here}}
-  const T &r = da[(int)i]; // expected-note 2 {{'r' defined here}}
-  T &q = qa[(int)i];       // expected-note 2 {{'q' defined here}}
-  T fl;                    // expected-note {{'fl' defined here}}
-#pragma omp parallel
-#pragma omp sections reduction // expected-error {{expected '(' after 'reduction'}}
+int main(int argc, char **argv) {
+  const int d = 5; // expected-note 2 {{'d' defined here}}
+  const int da[5] = { 0 }; // expected-note {{'da' defined here}}
+  int qa[5] = { 0 };
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5);
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  S3 &p = k;
+  const int &r = da[i]; // expected-note 2 {{'r' defined here}}
+  int &q = qa[i]; // expected-note {{'q' defined here}}
+  float fl; // expected-note {{'fl' defined here}}
+  #pragma omp sections reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction + // expected-error {{expected '(' after 'reduction'}} expected-warning {{extra tokens at the end of '#pragma omp sections' are ignored}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction( // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp sections reduction // expected-error {{expected '(' after 'reduction'}} expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(- // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction() // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
+  #pragma omp sections reduction + // expected-error {{expected '(' after 'reduction'}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(*) // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(\) // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
+  #pragma omp sections reduction ( // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(& : argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(| : argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{variable of type 'float' is not valid for specified reduction operation}}
+  #pragma omp sections reduction (- // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(|| : argc ? i : argc) // expected-error 2 {{expected variable name}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(foo : argc) //expected-error {{incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max'}}
+  #pragma omp sections reduction () // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(&& : argc)
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(^ : T) // expected-error {{'T' does not refer to a value}}
+  #pragma omp sections reduction (*) // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 3 {{const-qualified variable cannot be reduction}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' or 'max' must be of arithmetic type}} expected-error 3 {{const-qualified variable cannot be reduction}}
+  #pragma omp sections reduction (\) // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(max : qa[1]) // expected-error 2 {{expected variable name}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(+ : ba) // expected-error {{a reduction variable with array type 'const S2 [5]'}}
+  #pragma omp parallel
+  #pragma omp sections reduction (&: argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(* : ca) // expected-error {{a reduction variable with array type 'const S3 [5]'}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(- : da) // expected-error {{a reduction variable with array type 'const int [5]'}} expected-error {{a reduction variable with array type 'const float [5]'}}
+  #pragma omp parallel
+  #pragma omp sections reduction (| :argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(^ : fl) // expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
+  #pragma omp parallel
+  #pragma omp sections reduction (|| :argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
+  #pragma omp parallel
+  #pragma omp sections reduction (&& :argc)
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(+ : o) // expected-error {{variable of type 'class S6' is not valid for specified reduction operation}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections private(i), reduction(+ : j), reduction(+ : q) // expected-error 4 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  #pragma omp parallel
+  #pragma omp sections reduction (^ : S1) // expected-error {{'S1' does not refer to a value}}
   {
     foo();
-  }
-#pragma omp parallel private(k)
-#pragma omp sections reduction(+ : p), reduction(+ : p) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(+ : p), reduction(+ : p) // expected-error 3 {{variable can appear only once in OpenMP 'reduction' clause}} expected-note 3 {{previously referenced here}}
+  #pragma omp parallel
+  #pragma omp sections reduction (+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error {{'operator+=' is a private member of 'S2'}} expected-error 2 {{const-qualified variable cannot be reduction}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(+ : r) // expected-error 2 {{const-qualified variable cannot be reduction}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel shared(i)
-#pragma omp parallel reduction(min : i)
-#pragma omp sections reduction(max : j) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  #pragma omp parallel
+  #pragma omp sections reduction (min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' and 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
   {
     foo();
-  }
-#pragma omp parallel private(fl)       // expected-note 2 {{defined as private}}
-#pragma omp sections reduction(+ : fl) // expected-error 2 {{reduction variable must be shared}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel reduction(* : fl) // expected-note 2 {{defined as reduction}}
-#pragma omp sections reduction(+ : fl) // expected-error 2 {{reduction variable must be shared}}
+  #pragma omp parallel
+  #pragma omp sections reduction (max : argv[1]) // expected-error {{expected variable name}}
   {
     foo();
-  }
-
-  return T();
-}
-
-int main(int argc, char **argv) {
-  const int d = 5;       // expected-note 2 {{'d' defined here}}
-  const int da[5] = {0}; // expected-note {{'da' defined here}}
-  int qa[5] = {0};
-  S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note {{'g' defined here}}
-  int i;
-  int &j = i;           // expected-note 2 {{'j' defined here}}
-  S3 &p = k;            // expected-note 2 {{'p' defined here}}
-  const int &r = da[i]; // expected-note {{'r' defined here}}
-  int &q = qa[i];       // expected-note {{'q' defined here}}
-  float fl;             // expected-note {{'fl' defined here}}
-#pragma omp parallel
-#pragma omp sections reduction // expected-error {{expected '(' after 'reduction'}}
-  {
-    foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction + // expected-error {{expected '(' after 'reduction'}} expected-warning {{extra tokens at the end of '#pragma omp sections' are ignored}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction( // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp sections reduction(+ : ba) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(- // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction() // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
+  #pragma omp parallel
+  #pragma omp sections reduction(* : ca) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(*) // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(\) // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
+  #pragma omp parallel
+  #pragma omp sections reduction(- : da) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(foo : argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max'}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(| : argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp sections reduction(^ : fl) // expected-error {{arguments of OpenMP clause 'reduction' with bitwise operators cannot be of floating type}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(|| : argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(~ : argc) // expected-error {{expected unqualified-id}}
+  #pragma omp parallel
+  #pragma omp sections reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(&& : argc)
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(^ : S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp parallel
+  #pragma omp sections reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{const-qualified variable cannot be reduction}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' or 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  #pragma omp parallel
+  #pragma omp sections reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{no viable overloaded '&='}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(max : argv[1]) // expected-error {{expected variable name}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(+ : ba) // expected-error {{a reduction variable with array type 'const S2 [5]'}}
+  #pragma omp parallel
+  #pragma omp sections reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(* : ca) // expected-error {{a reduction variable with array type 'const S3 [5]'}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(- : da) // expected-error {{a reduction variable with array type 'const int [5]'}}
+  #pragma omp parallel
+  #pragma omp sections reduction(+ : o) // expected-error {{no viable overloaded '+='}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(^ : fl) // expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
+  #pragma omp parallel shared(i, j, q)
+  #pragma omp sections reduction(|| : i), reduction(+ : j), reduction(+:q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{variable of type 'S5' is not valid for specified reduction operation}}
+  #pragma omp parallel private(i) // expected-note {{defined as private}}
+  #pragma omp sections reduction(|| : i) // expected-error {{private variable in '#pragma omp parallel' cannot be reduction in '#pragma omp sections'}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(+ : o) // expected-error {{variable of type 'class S6' is not valid for specified reduction operation}}
+  #pragma omp parallel
+  #pragma omp sections private(i), reduction(|| : i) // expected-error {{private variable cannot be reduction}} expected-note {{defined as private}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections private(i), reduction(+ : j), reduction(+ : q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel private(k)
-#pragma omp sections reduction(+ : p), reduction(+ : p) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  #pragma omp parallel
+  #pragma omp sections reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
   {
     foo();
-  }
-#pragma omp parallel
-#pragma omp sections reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel
-#pragma omp sections reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
+  #pragma omp parallel
+  #pragma omp sections reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
   {
     foo();
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel reduction(min : i)
-#pragma omp sections reduction(max : j) // expected-error {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  {
+    #pragma omp section
     foo();
   }
-#pragma omp parallel private(fl)       // expected-note {{defined as private}}
-#pragma omp sections reduction(+ : fl) // expected-error {{reduction variable must be shared}}
+  #pragma omp parallel shared(i)
+  #pragma omp parallel reduction(min : i) // expected-note {{defined as reduction}}
+  #pragma omp sections reduction(max : i) // expected-error {{reduction variable in '#pragma omp parallel' cannot be reduction in '#pragma omp sections'}}
   {
     foo();
-  }
-#pragma omp parallel reduction(* : fl) // expected-note {{defined as reduction}}
-#pragma omp sections reduction(+ : fl) // expected-error {{reduction variable must be shared}}
-  {
+    #pragma omp section
     foo();
   }
 
-  return tmain(argc) + tmain(fl); // expected-note {{in instantiation of function template specialization 'tmain<int>' requested here}} expected-note {{in instantiation of function template specialization 'tmain<float>' requested here}}
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/simd_aligned_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/simd_aligned_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/simd_aligned_messages.cpp	2014-06-16 03:08:35.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/simd_aligned_messages.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,201 +0,0 @@
-// RUN: %clang_cc1 -x c++ -std=c++11 -verify -fopenmp=libiomp5 %s
-
-struct B {
-  static int ib[20]; // expected-note 0 {{'B::ib' declared here}}
-  static constexpr int bfoo() { return 8; }
-};
-namespace X {
-  B x; // expected-note {{'x' defined here}}
-};
-constexpr int bfoo() { return 4; }
-
-int **z;
-const int C1 = 1;
-const int C2 = 2;
-void test_aligned_colons(int *&rp)
-{
-  int *B = 0;
-  #pragma omp simd aligned(B:bfoo())
-  for (int i = 0; i < 10; ++i) ;
-  // expected-error@+1 {{unexpected ':' in nested name specifier; did you mean '::'}}
-  #pragma omp simd aligned(B::ib:B:bfoo())
-  for (int i = 0; i < 10; ++i) ;
-  #pragma omp simd aligned(B:B::bfoo())
-  for (int i = 0; i < 10; ++i) ;
-  // expected-error@+1 {{unexpected ':' in nested name specifier; did you mean '::'?}}
-  #pragma omp simd aligned(z:B:bfoo())
-  for (int i = 0; i < 10; ++i) ;
-  #pragma omp simd aligned(B:B::bfoo())
-  for (int i = 0; i < 10; ++i) ;
-  // expected-error@+2 {{integral constant expression must have integral or unscoped enumeration type, not 'int **'}}
-  // expected-error@+1 {{argument of aligned clause should be array, pointer, reference to array or reference to pointer, not 'B'}}
-  #pragma omp simd aligned(X::x : ::z)
-  for (int i = 0; i < 10; ++i) ;
-  // expected-error@+1 {{integral constant expression must have integral or unscoped enumeration type, not 'B'}}
-  #pragma omp simd aligned(B,rp,::z: X::x)
-  for (int i = 0; i < 10; ++i) ;
-  #pragma omp simd aligned(::z)
-  for (int i = 0; i < 10; ++i) ;
-  // expected-error@+1 {{expected variable name}}
-  #pragma omp simd aligned(B::bfoo())
-  for (int i = 0; i < 10; ++i) ;
-  #pragma omp simd aligned(B::ib,B:C1+C2)
-  for (int i = 0; i < 10; ++i) ;
-}
-
-// expected-note@+1 {{'num' defined here}}
-template<int L, class T, class N> T test_template(T* arr, N num) {
-  N i;
-  T sum = (T)0;
-  T ind2 = - num * L;
-  // Negative number is passed as L.
-  // expected-error@+1 {{argument to 'aligned' clause must be a positive integer value}}
-  #pragma omp simd aligned(arr:L)
-  for (i = 0; i < num; ++i) {
-    T cur = arr[(int)ind2];
-    ind2 += L;
-    sum += cur;
-  }
-  // expected-error@+1 {{argument of aligned clause should be array, pointer, reference to array or reference to pointer, not 'int'}}
-  #pragma omp simd aligned(num:4)
-  for (i = 0; i < num; ++i);
-  return T();
-}
-
-template<int LEN> int test_warn() {
-  int *ind2 = 0;
-  // expected-error@+1 {{argument to 'aligned' clause must be a positive integer value}}
-  #pragma omp simd aligned(ind2:LEN)
-  for (int i = 0; i < 100; i++) {
-    ind2 += LEN;
-  }
-  return 0;
-}
-
-struct S1; // expected-note 2 {{declared here}}
-extern S1 a; // expected-note {{'a' declared here}}
-class S2 {
-  mutable int a;
-public:
-  S2():a(0) { }
-};
-const S2 b; // expected-note 1 {{'b' defined here}}
-const S2 ba[5];
-class S3 {
-  int a;
-public:
-  S3():a(0) { }
-};
-const S3 ca[5];
-class S4 {
-  int a;
-  S4();
-public:
-  S4(int v):a(v) { }
-};
-class S5 {
-  int a;
-  S5():a(0) {}
-public:
-  S5(int v):a(v) { }
-};
-
-S3 h; // expected-note 2 {{'h' defined here}}
-#pragma omp threadprivate(h)
-
-template<class I, class C> int foomain(I argc, C **argv) {
-  I e(argc);
-  I g(argc);
-  int i; // expected-note {{declared here}} expected-note {{'i' defined here}}
-  // expected-note@+2 {{declared here}}
-  // expected-note@+1 {{reference to 'i' is not a constant expression}}
-  int &j = i;
-  #pragma omp simd aligned // expected-error {{expected '(' after 'aligned'}}
-  for (I k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (I k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned () // expected-error {{expected expression}}
-  for (I k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (I k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (I k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (I k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned (argc : 5)
-  for (I k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned (S1) // expected-error {{'S1' does not refer to a value}}
-  for (I k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned (argv[1]) // expected-error {{expected variable name}}
-  for (I k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned(e, g)
-  for (I k = 0; k < argc; ++k) ++k;
-  // expected-error@+1 {{argument of aligned clause should be array, pointer, reference to array or reference to pointer, not 'S3'}}
-  #pragma omp simd aligned(h)
-  for (I k = 0; k < argc; ++k) ++k;
-  // expected-error@+1 {{argument of aligned clause should be array, pointer, reference to array or reference to pointer, not 'int'}}
-  #pragma omp simd aligned(i)
-  for (I k = 0; k < argc; ++k) ++k;
-  #pragma omp parallel
-  {
-    int *v = 0;
-    I i;
-    #pragma omp simd aligned(v:16)
-    for (I k = 0; k < argc; ++k) { i = k; v += 2; }
-  }
-  float *f;
-  #pragma omp simd aligned(f)
-  for (I k = 0; k < argc; ++k) ++k;
-  int v = 0;
-  // expected-note@+2 {{initializer of 'j' is not a constant expression}}
-  // expected-error@+1 {{expression is not an integral constant expression}}
-  #pragma omp simd aligned(f:j)
-  for (I k = 0; k < argc; ++k) { ++k; v += j; }
-  #pragma omp simd aligned(f)
-  for (I k = 0; k < argc; ++k) ++k;
-  return 0;
-}
-
-// expected-note@+1 2 {{'argc' defined here}}
-int main(int argc, char **argv) {
-  double darr[100];
-  // expected-note@+1 {{in instantiation of function template specialization 'test_template<-4, double, int>' requested here}}
-  test_template<-4>(darr, 4);
-  test_warn<4>(); // ok
-  // expected-note@+1 {{in instantiation of function template specialization 'test_warn<0>' requested here}}
-  test_warn<0>();
-
-  int i;
-  int &j = i;
-  #pragma omp simd aligned // expected-error {{expected '(' after 'aligned'}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned () // expected-error {{expected expression}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned (argv // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k) ++k;
-  // expected-error@+1 {{argument of aligned clause should be array, pointer, reference to array or reference to pointer, not 'int'}}
-  #pragma omp simd aligned (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k) ++k;
-  // expected-error@+1 {{argument of aligned clause should be array, pointer, reference to array or reference to pointer, not 'int'}}
-  #pragma omp simd aligned (argc)
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned (S1) // expected-error {{'S1' does not refer to a value}}
-  for (int k = 0; k < argc; ++k) ++k;
-  // expected-error@+2 {{argument of aligned clause should be array, pointer, reference to array or reference to pointer, not 'S1'}}
-  // expected-error@+1 {{argument of aligned clause should be array, pointer, reference to array or reference to pointer, not 'S2'}}
-  #pragma omp simd aligned (a, b) 
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd aligned (argv[1]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k) ++k;
-  // expected-error@+1 {{argument of aligned clause should be array, pointer, reference to array or reference to pointer, not 'S3'}}
-  #pragma omp simd aligned(h)
-  for (int k = 0; k < argc; ++k) ++k;
-  int *pargc = &argc;
-  foomain<int*,char>(pargc,argv);
-  return 0;
-}
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/simd_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/simd_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/simd_ast_print.cpp	2014-06-04 09:06:39.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/simd_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,25 +1,23 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
 // expected-no-diagnostics
 
 #ifndef HEADER
 #define HEADER
 
 void foo() {}
-int g_ind = 1;
+
 template<class T, class N> T reduct(T* arr, N num) {
   N i;
   N ind;
-  N myind;
   T sum = (T)0;
 // CHECK: T sum = (T)0;
-#pragma omp simd private(myind, g_ind), linear(ind), aligned(arr)
-// CHECK-NEXT: #pragma omp simd private(myind,g_ind) linear(ind) aligned(arr)
+#pragma omp simd linear(ind), reduction(+:sum)
+// CHECK-NEXT: #pragma omp simd linear(ind) reduction(+: sum)
   for (i = 0; i < num; ++i) {
-    myind = ind;
-    T cur = arr[myind];
-    ind += g_ind;
+    T cur = arr[ind];
+    ++ind;
     sum += cur;
   }
 }
@@ -30,28 +28,12 @@
   {}
   T result(T *v) const {
     T res;
-    T val;
-    T lin = 0;
 // CHECK: T res;
-// CHECK: T val;
-// CHECK: T lin = 0;
-    #pragma omp simd private(val)  safelen(7) linear(lin : -5) lastprivate(res)
-// CHECK-NEXT: #pragma omp simd private(val) safelen(7) linear(lin: -5) lastprivate(res)
+#pragma omp simd lastprivate(res) safelen(7)
+// CHECK-NEXT: #pragma omp simd lastprivate(res) safelen(7) 
     for (T i = 7; i < m_a; ++i) {
-      val = v[i-7] + m_a;
-      res = val;
-      lin -= 5;
-    }
-    const T clen = 3;
-// CHECK: T clen = 3;
-    #pragma omp simd safelen(clen-1)
-// CHECK-NEXT: #pragma omp simd safelen(clen - 1)
-    for(T i = clen+2; i < 20; ++i) {
-// CHECK-NEXT: for (T i = clen + 2; i < 20; ++i) {
-      v[i] = v[v-clen] + 1;
-// CHECK-NEXT: v[i] = v[v - clen] + 1;
+      res = v[i-7] + m_a;
     }
-// CHECK-NEXT: }
     return res;
   }
   ~S()
@@ -59,34 +41,6 @@
   T m_a;
 };
 
-template<int LEN> struct S2 {
-  static void func(int n, float *a, float *b, float *c) {
-    int k1 = 0, k2 = 0;
-#pragma omp simd safelen(LEN) linear(k1,k2:LEN) aligned(a:LEN)
-    for(int i = 0; i < n; i++) {
-      c[i] = a[i] + b[i];
-      c[k1] = a[k1] + b[k1];
-      c[k2] = a[k2] + b[k2];
-      k1 = k1 + LEN;
-      k2 = k2 + LEN;
-    }
-  }
-};
-
-// S2<4>::func is called below in main.
-// CHECK: template <int LEN = 4> struct S2 {
-// CHECK-NEXT: static void func(int n, float *a, float *b, float *c)     {
-// CHECK-NEXT:   int k1 = 0, k2 = 0;
-// CHECK-NEXT: #pragma omp simd safelen(4) linear(k1,k2: 4) aligned(a: 4)
-// CHECK-NEXT:   for (int i = 0; i < n; i++) {
-// CHECK-NEXT:     c[i] = a[i] + b[i];
-// CHECK-NEXT:     c[k1] = a[k1] + b[k1];
-// CHECK-NEXT:     c[k2] = a[k2] + b[k2];
-// CHECK-NEXT:     k1 = k1 + 4;
-// CHECK-NEXT:     k2 = k2 + 4;
-// CHECK-NEXT:   }
-// CHECK-NEXT: }
-
 int main (int argc, char **argv) {
   int b = argc, c, d, e, f, g;
   int k1=0,k2=0;
@@ -97,10 +51,12 @@
   for (int i=0; i < 2; ++i)*a=2;
 // CHECK-NEXT: for (int i = 0; i < 2; ++i)
 // CHECK-NEXT: *a = 2;
-#pragma omp simd private(argc, b),lastprivate(d,f) collapse(2) aligned(a : 4)
+#pragma omp parallel
+#pragma omp simd private(argc,b),lastprivate(d,f),reduction(+:e) reduction(min : g),  collapse(2) safelen(2) aligned(a:4), linear(k1,k2:8)
   for (int i = 0; i < 10; ++i)
   for (int j = 0; j < 10; ++j) {foo(); k1 += 8; k2 += 8;}
-// CHECK-NEXT: #pragma omp simd private(argc,b) lastprivate(d,f) collapse(2) aligned(a: 4)
+// CHECK-NEXT: #pragma omp parallel
+// CHECK-NEXT: #pragma omp simd private(argc,b) lastprivate(d,f) reduction(+: e) reduction(min: g) collapse(2) safelen(2) aligned(a: 4) linear(k1,k2: 8)
 // CHECK-NEXT: for (int i = 0; i < 10; ++i)
 // CHECK-NEXT: for (int j = 0; j < 10; ++j) {
 // CHECK-NEXT: foo();
@@ -110,16 +66,27 @@
   for (int i = 0; i < 10; ++i)foo();
 // CHECK-NEXT: for (int i = 0; i < 10; ++i)
 // CHECK-NEXT: foo();
-  const int CLEN = 4;
-// CHECK-NEXT: const int CLEN = 4;
-  #pragma omp simd aligned(a:CLEN) linear(a:CLEN) safelen(CLEN) collapse( 1 )
-// CHECK-NEXT: #pragma omp simd aligned(a: CLEN) linear(a: CLEN) safelen(CLEN) collapse(1)
+#pragma omp simd aligned(a) linear(a)
+// CHECK-NEXT: #pragma omp simd aligned(a) linear(a)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp simd collapse(1)
+// CHECK: #pragma omp simd collapse(1)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  const int CLEN=4;
+#pragma omp simd safelen(CLEN)
+// CHECK: #pragma omp simd safelen(4)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp simd aligned(a:CLEN) linear(a:CLEN) safelen(CLEN)
+// CHECK-NEXT: #pragma omp simd aligned(a: 4) linear(a: 4) safelen(4)
   for (int i = 0; i < 10; ++i)foo();
 // CHECK-NEXT: for (int i = 0; i < 10; ++i)
 // CHECK-NEXT: foo();
-
-  float arr[16];
-  S2<4>::func(0,arr,arr,arr);
   return (0);
 }
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/simd_collapse_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/simd_collapse_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/simd_collapse_messages.cpp	2014-06-24 08:55:56.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/simd_collapse_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,5 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+// This test is same as for_collapse_messages.cpp, but regarding 'simd' instead of 'for'.
 
 void foo() {
 }
@@ -9,75 +10,46 @@
 
 struct S1; // expected-note {{declared here}}
 
-template <class T, typename S, int N, int ST> // expected-note {{declared here}}
-T tmain(T argc, S **argv) { //expected-note 2 {{declared here}}
-  #pragma omp simd collapse // expected-error {{expected '(' after 'collapse'}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp simd collapse ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp simd collapse () // expected-error {{expected expression}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
-  // expected-error@+2 2 {{expression is not an integral constant expression}}
-  // expected-note@+1 2 {{read of non-const variable 'argc' is not allowed in a constant expression}}
-  #pragma omp simd collapse (argc 
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+1 2 {{argument to 'collapse' clause must be a positive integer value}}
-  #pragma omp simd collapse (ST // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp simd collapse (1)) // expected-warning {{extra tokens at the end of '#pragma omp simd' are ignored}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp simd collapse ((ST > 0) ? 1 + ST : 2) // expected-note 2 {{as specified in 'collapse' clause}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST]; // expected-error 2 {{expected 2 for loops after '#pragma omp simd', but found only 1}}
-  // expected-error@+3 2 {{directive '#pragma omp simd' cannot contain more than one 'collapse' clause}}
-  // expected-error@+2 2 {{argument to 'collapse' clause must be a positive integer value}}
-  // expected-error@+1 2 {{expression is not an integral constant expression}}
-  #pragma omp simd collapse (foobool(argc)), collapse (true), collapse (-5)
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp simd collapse (S) // expected-error {{'S' does not refer to a value}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+1 2 {{expression is not an integral constant expression}}
-  #pragma omp simd collapse (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp simd collapse (1)
-  for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp simd collapse (N) // expected-error {{argument to 'collapse' clause must be a positive integer value}}
-  for (T i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp simd collapse (2) // expected-note {{as specified in 'collapse' clause}}
-  foo(); // expected-error {{expected 2 for loops after '#pragma omp simd'}}
-  return argc;
-}
+extern S1 v1;
 
-int main(int argc, char **argv) {
-  #pragma omp simd collapse // expected-error {{expected '(' after 'collapse'}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
+struct S2{
+  int f;
+  operator int() { return f; }
+  operator bool() { return f; }
+} v2;
+
+struct S3 {
+  int f;
+  operator int() { return f; }
+} v3;
+
+int main(int argc, char **argv) { // expected-note {{declared here}}
+  #pragma omp simd collapse // expected-error {{expected '(' after 'collapse'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
   #pragma omp simd collapse ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
+  for (int i = 0; i < 10; ++i) foo();
   #pragma omp simd collapse () // expected-error {{expected expression}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp simd collapse (4 // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-note {{as specified in 'collapse' clause}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4]; // expected-error {{expected 4 for loops after '#pragma omp simd', but found only 1}}
-  #pragma omp simd collapse (2+2)) // expected-warning {{extra tokens at the end of '#pragma omp simd' are ignored}} expected-note {{as specified in 'collapse' clause}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4]; // expected-error {{expected 4 for loops after '#pragma omp simd', but found only 1}}
-  #pragma omp simd collapse (foobool(1) > 0 ? 1 : 2) // expected-error {{expression is not an integral constant expression}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+3 {{expression is not an integral constant expression}}
-  // expected-error@+2 2 {{directive '#pragma omp simd' cannot contain more than one 'collapse' clause}}
-  // expected-error@+1 2 {{argument to 'collapse' clause must be a positive integer value}}
-  #pragma omp simd collapse (foobool(argc)), collapse (true), collapse (-5) 
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp simd collapse (argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}} expected-note {{read of non-const variable 'argc' is not allowed in a constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp simd collapse (argc > 0 ? argv[1] : argv[2]) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp simd collapse (foobool(argc)) collapse(1) // expected-error {{directive '#pragma omp simd' cannot contain more than one 'collapse' clause}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
   #pragma omp simd collapse (S1) // expected-error {{'S1' does not refer to a value}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+1 {{expression is not an integral constant expression}}
-  #pragma omp simd collapse (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  #pragma omp simd collapse (2) // expected-note {{as specified in 'collapse' clause}}
-  foo(); // expected-error {{expected 2 for loops after '#pragma omp simd'}}
-  // expected-error@+3 {{statement after '#pragma omp simd' must be a for loop}}
-  // expected-note@+1 {{in instantiation of function template specialization 'tmain<int, char, -1, -2>' requested here}}
-  #pragma omp simd collapse(collapse(tmain<int, char, -1, -2>(argc, argv) // expected-error 2 {{expected ')'}} expected-note 2 {{to match this '('}}
-  foo();
-  // expected-note@+1 {{in instantiation of function template specialization 'tmain<int, char, 1, 0>' requested here}}
-  return tmain<int, char, 1, 0>(argc, argv);
-}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp simd collapse (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp simd collapse (v1) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp simd collapse (v2) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp simd collapse (v3) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp simd collapse (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp simd collapse (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
 
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/simd_lastprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/simd_lastprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/simd_lastprivate_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/simd_lastprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,202 +7,109 @@
   return argc;
 }
 
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
-
 public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-  static float S2s; // expected-note {{static data member is predetermined as shared}}
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note {{predetermined as shared}}
   static const float S2sc;
 };
-const float S2::S2sc = 0; // expected-note {{static data member is predetermined as shared}}
+const float S2::S2sc = 0; // expected-note {{predetermined as shared}}
 const S2 b;
 const S2 ba[5];
 class S3 { // expected-note {{'S3' declared here}}
   int a;
-  S3 &operator=(const S3 &s3);
-
+  S3& operator =(const S3& s3);
 public:
-  S3() : a(0) {}
-  S3(S3 &s3) : a(s3.a) {}
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
 };
-const S3 c;         // expected-note {{global variable is predetermined as shared}}
-const S3 ca[5];     // expected-note {{global variable is predetermined as shared}}
-extern const int f; // expected-note {{global variable is predetermined as shared}}
-class S4 {          // expected-note {{'S4' declared here}}
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f; // expected-note {{predetermined as shared}}
+class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
   S4(const S4 &s4);
-
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
 class S5 { // expected-note {{'S5' declared here}}
   int a;
-  S5() : a(0) {}
-
+  S5():a(0) {}
 public:
-  S5(const S5 &s5) : a(s5.a) {}
-  S5(int v) : a(v) {}
+  S5(const S5 &s5):a(s5.a) { }
+  S5(int v):a(v) { }
 };
 
 S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class I, class C>
-int foomain(I argc, C **argv) {
-  I e(4);
-  I g(5);
-  int i;
-  int &j = i;                // expected-note {{'j' defined here}}
-#pragma omp simd lastprivate // expected-error {{expected '(' after 'lastprivate'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp simd lastprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp simd lastprivate() // expected-error {{expected expression}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp simd lastprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp simd lastprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp simd lastprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp simd lastprivate(argc)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp simd lastprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp simd lastprivate(a, b) // expected-error {{lastprivate variable with incomplete type 'S1'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp simd lastprivate(argv[1]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp simd lastprivate(e, g)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp simd lastprivate(h) // expected-error {{threadprivate or thread local variable cannot be lastprivate}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp simd firstprivate(i) // expected-error {{unexpected OpenMP clause 'firstprivate' in directive '#pragma omp simd'}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;
-#pragma omp simd lastprivate(i)
-    for (int k = 0; k < argc; ++k) {
-      i = k;
-      v += i;
-    }
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp simd lastprivate(j) // expected-error {{arguments of OpenMP clause 'lastprivate' cannot be of reference type}}
-  for (int k = 0; k < argc; ++k)
-    ++k;
-#pragma omp simd lastprivate(i)
-  for (int k = 0; k < argc; ++k)
-    ++k;
-  return 0;
-}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
 int main(int argc, char **argv) {
-  const int d = 5;       // expected-note {{constant variable is predetermined as shared}}
-  const int da[5] = {0}; // expected-note {{constant variable is predetermined as shared}}
-  S4 e(4);               // expected-note {{'e' defined here}}
-  S5 g(5);               // expected-note {{'g' defined here}}
-  S3 m;                  // expected-note {{'m' defined here}}
+  const int d = 5; // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  S3 m; // expected-note {{'m' defined here}}
   int i;
-  int &j = i;                // expected-note {{'j' defined here}}
-#pragma omp simd lastprivate // expected-error {{expected '(' after 'lastprivate'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate() // expected-error {{expected expression}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(argc)
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(a, b, c, d, f) // expected-error {{lastprivate variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(argv[1]) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(2 * 2) // expected-error {{expected variable name}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(ba)
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(ca) // expected-error {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(da) // expected-error {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-  int xa;
-#pragma omp simd lastprivate(xa) // OK
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(S2::S2s) // expected-error {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(S2::S2sc) // expected-error {{shared variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd firstprivate(g) // expected-error {{unexpected OpenMP clause 'firstprivate' in directive '#pragma omp simd'}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(e, g) // expected-error 2 {{lastprivate variable must have an accessible, unambiguous default constructor}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(m) // expected-error {{lastprivate variable must have an accessible, unambiguous copy assignment operator}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(h) // expected-error {{threadprivate or thread local variable cannot be lastprivate}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd private(xa), lastprivate(xa) // expected-error {{private variable cannot be lastprivate}} expected-note {{defined as private}}
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp simd lastprivate(i) // expected-note {{defined as lastprivate}}
-  for (i = 0; i < argc; ++i) // expected-error {{loop iteration variable in the associated loop of 'omp simd' directive may not be lastprivate, predetermined as linear}}
-    foo();
-#pragma omp parallel private(xa)
-#pragma omp simd lastprivate(xa) // OK: may be lastprivate
-  for (i = 0; i < argc; ++i)
-    foo();
-#pragma omp parallel
-#pragma omp simd lastprivate(j) // expected-error {{arguments of OpenMP clause 'lastprivate' cannot be of reference type}}
-  for (i = 0; i < argc; ++i)
-    foo();
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp simd lastprivate // expected-error {{expected '(' after 'lastprivate'}} expected-error {{expected expression}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate () // expected-error {{expected expression}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate (argc)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate (S1) // expected-error {{'S1' does not refer to a value}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate (a, b, c, d, f) // expected-error {{lastprivate variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be lastprivate}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate (argv[1]) // expected-error {{expected variable name}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate (2*2) // expected-error {{expected variable name}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate(ba)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate(ca) // expected-error {{shared variable cannot be lastprivate}} // TODO: is it true for simd?
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate(da) // expected-error {{shared variable cannot be lastprivate}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate(S2::S2s) // expected-error {{shared variable cannot be lastprivate}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate(S2::S2sc) // expected-error {{shared variable cannot be lastprivate}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd firstprivate (g) // expected-error {{unexpected OpenMP clause 'firstprivate' in directive '#pragma omp simd'}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate(e, g) // expected-error 2 {{lastprivate variable must have an accessible, unambiguous default constructor}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate(m) // expected-error {{lastprivate variable must have an accessible, unambiguous copy assignment operator}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd lastprivate(h) // expected-error {{threadprivate or thread local variable cannot be lastprivate}}
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp simd private(i), lastprivate(i) // expected-error {{private variable cannot be lastprivate}} expected-note 2 {{defined as private}}
+  for (i = 0; i < argc; ++i) foo(); // expected-error {{loop iteration variable may not be private}}
+  #pragma omp parallel shared(i)
+  #pragma omp simd lastprivate(i)
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel private(i) 
+  #pragma omp simd lastprivate(i) // OK: may be lastprivate
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel reduction(+:i) 
+  #pragma omp simd lastprivate(i) // OK: may be lastprivate
+  for (i = 0; i < argc; ++i) foo();
+  #pragma omp parallel
+  #pragma omp simd lastprivate(j) // expected-error {{arguments of OpenMP clause 'lastprivate' cannot be of reference type}}
+  for (i = 0; i < argc; ++i) foo();
+
   return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/simd_linear_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/simd_linear_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/simd_linear_messages.cpp	2014-06-16 03:08:35.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/simd_linear_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,206 +1,67 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 0 -fopenmp -verify %s
 
 namespace X {
   int x;
 };
 
-struct B {
-  static int ib; // expected-note {{'B::ib' declared here}}
-  static int bfoo() { return 8; }
+struct A {
+  int a;
+  void bar() {
+    #pragma omp simd linear(X::x)
+    for (int i = 0; i < 10; i++) ;
+    int j;
+    #pragma omp simd linear(j)
+    for (int i = 0; i < 10; i++) ;
+
+    // TODO: Should be error here or no error in next directive?
+    #pragma omp simd linear(j:this->a)
+    for (int i = 0; i < 10; i++) ;
+    // expected-error@+1 {{expected variable name}}
+    #pragma omp simd linear(a)
+    for (int i = 0; i < 10; i++) ;
+  }
 };
 
-int bfoo() { return 4; }
 
 int z;
 const int C1 = 1;
 const int C2 = 2;
-void test_linear_colons()
+void test_linear()
 {
-  int B = 0;
-  #pragma omp simd linear(B:bfoo())
-  for (int i = 0; i < 10; ++i) ;
-  // expected-error@+1 {{unexpected ':' in nested name specifier; did you mean '::'}}
-  #pragma omp simd linear(B::ib:B:bfoo())
-  for (int i = 0; i < 10; ++i) ;
-  // expected-error@+1 {{use of undeclared identifier 'ib'; did you mean 'B::ib'}}
-  #pragma omp simd linear(B:ib)
-  for (int i = 0; i < 10; ++i) ;
-  // expected-error@+1 {{unexpected ':' in nested name specifier; did you mean '::'?}}
-  #pragma omp simd linear(z:B:ib)
+  int y;
+  char c;
+  A a;
+  a.a = 2;
+
+  #pragma omp simd linear(X::x)
   for (int i = 0; i < 10; ++i) ;
-  #pragma omp simd linear(B:B::bfoo())
+  #pragma omp simd linear(y:z)
   for (int i = 0; i < 10; ++i) ;
   #pragma omp simd linear(X::x : ::z)
   for (int i = 0; i < 10; ++i) ;
-  #pragma omp simd linear(B,::z, X::x)
+  #pragma omp simd linear(y,::z, X::x)
   for (int i = 0; i < 10; ++i) ;
   #pragma omp simd linear(::z)
   for (int i = 0; i < 10; ++i) ;
-  // expected-error@+1 {{expected variable name}}
-  #pragma omp simd linear(B::bfoo())
+  #pragma omp simd linear(y:C1+C2)
+  for (int i = 0; i < 10; ++i) ;
+  #pragma omp simd linear(c:y)
   for (int i = 0; i < 10; ++i) ;
-  #pragma omp simd linear(B::ib,B:C1+C2)
+  #pragma omp simd linear(y:c)
   for (int i = 0; i < 10; ++i) ;
 }
 
-template<int L, class T, class N> T test_template(T* arr, N num) {
+template<class T, class N> T test_template(T* arr, N num) {
   N i;
+  float ind;
   T sum = (T)0;
-  T ind2 = - num * L; // expected-note {{'ind2' defined here}}
   // expected-error@+1 {{argument of a linear clause should be of integral or pointer type}}
-#pragma omp simd linear(ind2:L)
+#pragma omp simd linear(ind), reduction(+:sum)
   for (i = 0; i < num; ++i) {
-    T cur = arr[(int)ind2];
-    ind2 += L;
+    T cur = arr[ind];
+    ++ind;
     sum += cur;
   }
-  return T();
 }
 
-template<int LEN> int test_warn() {
-  int ind2 = 0;
-  // expected-warning@+1 {{zero linear step (ind2 should probably be const)}}
-  #pragma omp simd linear(ind2:LEN)
-  for (int i = 0; i < 100; i++) {
-    ind2 += LEN;
-  }
-  return ind2;
-}
-
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
-extern S1 a;
-class S2 {
-  mutable int a;
-public:
-  S2():a(0) { }
-};
-const S2 b; // expected-note 2 {{'b' defined here}}
-const S2 ba[5];
-class S3 {
-  int a;
-public:
-  S3():a(0) { }
-};
-const S3 ca[5];
-class S4 {
-  int a;
-  S4();
-public:
-  S4(int v):a(v) { }
-};
-class S5 {
-  int a;
-  S5():a(0) {}
-public:
-  S5(int v):a(v) { }
-};
-
-S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template<class I, class C> int foomain(I argc, C **argv) {
-  I e(4);
-  I g(5);
-  int i;
-  int &j = i; // expected-note {{'j' defined here}}
-  #pragma omp simd linear // expected-error {{expected '(' after 'linear'}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear () // expected-error {{expected expression}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear (argc : 5)
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear (S1) // expected-error {{'S1' does not refer to a value}}
-  for (int k = 0; k < argc; ++k) ++k;
-  // expected-error@+2 {{linear variable with incomplete type 'S1'}}
-  // expected-error@+1 {{const-qualified variable cannot be linear}}
-  #pragma omp simd linear (a, b:B::ib)
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear (argv[1]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear(e, g)
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear(h) // expected-error {{threadprivate or thread local variable cannot be linear}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear(i)
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp parallel
-  {
-    int v = 0;
-    int i;
-    #pragma omp simd linear(v:i)
-    for (int k = 0; k < argc; ++k) { i = k; v += i; }
-  }
-  #pragma omp simd linear(j) // expected-error {{arguments of OpenMP clause 'linear' cannot be of reference type}}
-  for (int k = 0; k < argc; ++k) ++k;
-  int v = 0;
-  #pragma omp simd linear(v:j)
-  for (int k = 0; k < argc; ++k) { ++k; v += j; }
-  #pragma omp simd linear(i)
-  for (int k = 0; k < argc; ++k) ++k;
-  return 0;
-}
-
-int main(int argc, char **argv) {
-  double darr[100];
-  // expected-note@+1 {{in instantiation of function template specialization 'test_template<-4, double, int>' requested here}}
-  test_template<-4>(darr, 4);
-  // expected-note@+1 {{in instantiation of function template specialization 'test_warn<0>' requested here}}
-  test_warn<0>();
-
-  S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note {{'g' defined here}}
-  int i;
-  int &j = i; // expected-note {{'j' defined here}}
-  #pragma omp simd linear // expected-error {{expected '(' after 'linear'}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear () // expected-error {{expected expression}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear (argc)
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear (S1) // expected-error {{'S1' does not refer to a value}}
-  for (int k = 0; k < argc; ++k) ++k;
-  // expected-error@+2 {{linear variable with incomplete type 'S1'}}
-  // expected-error@+1 {{const-qualified variable cannot be linear}}
-  #pragma omp simd linear (a, b) 
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear (argv[1]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k) ++k;
-  // expected-error@+2 {{argument of a linear clause should be of integral or pointer type, not 'S4'}}
-  // expected-error@+1 {{argument of a linear clause should be of integral or pointer type, not 'S5'}}
-  #pragma omp simd linear(e, g)
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear(h) // expected-error {{threadprivate or thread local variable cannot be linear}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp parallel
-  {
-    int i;
-    #pragma omp simd linear(i)
-    for (int k = 0; k < argc; ++k) ++k;
-    #pragma omp simd linear(i : 4)
-    for (int k = 0; k < argc; ++k) { ++k; i += 4; }
-  }
-  #pragma omp simd linear(j) // expected-error {{arguments of OpenMP clause 'linear' cannot be of reference type 'int &'}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd linear(i)
-  for (int k = 0; k < argc; ++k) ++k;
-
-  foomain<int,char>(argc,argv);
-  return 0;
-}
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/simd_loop_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/simd_loop_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/simd_loop_messages.cpp	2014-07-07 09:01:15.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/simd_loop_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,579 +1,221 @@
-// RUN: %clang_cc1 -fsyntax-only -fopenmp=libiomp5 -x c++ -std=c++11 -fexceptions -fcxx-exceptions -verify %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+// This test is same as for_loop_messages.cpp, but regarding 'simd' instead of 'for'.
 
-static int sii;
-#pragma omp threadprivate(sii) // expected-note {{defined as threadprivate or thread local}}
-
-int test_iteration_spaces() {
-  const int N = 100;
-  float a[N], b[N], c[N];
-  int ii, jj, kk;
-  float fii;
-  double dii;
-  #pragma omp simd
-  for (int i = 0; i < 10; i+=1) {
-    c[i] = a[i] + b[i];
-  }
-  #pragma omp simd
-  for (char i = 0; i < 10; i++) {
-    c[i] = a[i] + b[i];
-  }
-  #pragma omp simd
-  for (char i = 0; i < 10; i+='\1') {
-    c[i] = a[i] + b[i];
-  }
-  #pragma omp simd
-  for (long long i = 0; i < 10; i++) {
-    c[i] = a[i] + b[i];
-  }
-  // expected-error@+2 {{expression must have integral or unscoped enumeration type, not 'double'}}
-  #pragma omp simd
-  for (long long i = 0; i < 10; i+=1.5) {
-    c[i] = a[i] + b[i];
-  }
-  #pragma omp simd
-  for (long long i = 0; i < 'z'; i+=1u) {
-    c[i] = a[i] + b[i];
-  }
-  // expected-error@+2 {{variable must be of integer or random access iterator type}}
-  #pragma omp simd
-  for (float fi = 0; fi < 10.0; fi++) {
-    c[(int)fi] = a[(int)fi] + b[(int)fi];
-  }
-  // expected-error@+2 {{variable must be of integer or random access iterator type}}
-  #pragma omp simd
-  for (double fi = 0; fi < 10.0; fi++) {
-    c[(int)fi] = a[(int)fi] + b[(int)fi];
-  }
-  // expected-error@+2 {{variable must be of integer or random access iterator type}}
-  #pragma omp simd
-  for (int &ref = ii; ref < 10; ref++) {
-  }
-  // expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-  #pragma omp simd
-  for (int i; i < 10; i++)
-    c[i] = a[i];
-
-  // expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-  #pragma omp simd
-  for (int i = 0, j = 0; i < 10; ++i)
-    c[i] = a[i];
-
-  // expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-  #pragma omp simd
-  for (;ii < 10; ++ii)
-    c[ii] = a[ii];
-
-  // expected-warning@+3 {{expression result unused}}
-  // expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-  #pragma omp simd
-  for (ii + 1;ii < 10; ++ii)
-    c[ii] = a[ii];
-
-  // expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
-  #pragma omp simd
-  for (c[ii] = 0;ii < 10; ++ii)
-    c[ii] = a[ii];
-
-  // Ok to skip parenthesises.
-  #pragma omp simd
-  for (((ii)) = 0;ii < 10; ++ii)
-    c[ii] = a[ii];
-
-  // expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-  #pragma omp simd
-  for (int i = 0; i; i++)
-    c[i] = a[i];
-
-  // expected-error@+3 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-  // expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'i'}}
-  #pragma omp simd
-  for (int i = 0; jj < kk; ii++)
-    c[i] = a[i];
-
-  // expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-  #pragma omp simd
-  for (int i = 0; !!i; i++)
-    c[i] = a[i];
-
-  // expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-  #pragma omp simd
-  for (int i = 0; i != 1; i++)
-    c[i] = a[i];
-
-  // expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'i'}}
-  #pragma omp simd
-  for (int i = 0; ; i++)
-    c[i] = a[i];
-
-  // Ok.
-  #pragma omp simd
-  for (int i = 11; i > 10; i--)
-    c[i] = a[i];
-
-  // Ok.
-  #pragma omp simd
-  for (int i = 0; i < 10; ++i)
-    c[i] = a[i];
-
-    // Ok.
-  #pragma omp simd
-  for (ii = 0; ii < 10; ++ii)
-    c[ii] = a[ii];
-
-  // expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-  #pragma omp simd
-  for (ii = 0; ii < 10; ++jj)
-    c[ii] = a[jj];
-
-  // expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-  #pragma omp simd
-  for (ii = 0; ii < 10; ++ ++ ii)
-    c[ii] = a[ii];
-
-  // Ok but undefined behavior (in general, cannot check that incr
-  // is really loop-invariant).
-  #pragma omp simd
-  for (ii = 0; ii < 10; ii = ii + ii)
-    c[ii] = a[ii];
-
-  // expected-error@+2 {{expression must have integral or unscoped enumeration type, not 'float'}}
-  #pragma omp simd
-  for (ii = 0; ii < 10; ii = ii + 1.0f)
-    c[ii] = a[ii];
-
-  // Ok - step was converted to integer type.
-  #pragma omp simd
-  for (ii = 0; ii < 10; ii = ii + (int)1.1f)
-    c[ii] = a[ii];
-
-  // expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-  #pragma omp simd
-  for (ii = 0; ii < 10; jj = ii + 2)
-    c[ii] = a[ii];
-
-  // expected-warning@+3 {{relational comparison result unused}}
-  // expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-  #pragma omp simd
-  for (ii = 0; ii < 10; jj > kk + 2)
-    c[ii] = a[ii];
-
-  // expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-  #pragma omp simd
-  for (ii = 0; ii < 10;)
-    c[ii] = a[ii];
-
-  // expected-warning@+3 {{expression result unused}}
-  // expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-  #pragma omp simd
-  for (ii = 0; ii < 10; !ii)
-    c[ii] = a[ii];
-
-  // expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-  #pragma omp simd
-  for (ii = 0; ii < 10; ii ? ++ii : ++jj)
-    c[ii] = a[ii];
-
-  // expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'ii'}}
-  #pragma omp simd
-  for (ii = 0; ii < 10; ii = ii < 10)
-    c[ii] = a[ii];
-
-  // expected-note@+3 {{loop step is expected to be positive due to this condition}}
-  // expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-  #pragma omp simd
-  for (ii = 0; ii < 10; ii = ii + 0)
-    c[ii] = a[ii];
-
-  // expected-note@+3 {{loop step is expected to be positive due to this condition}}
-  // expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-  #pragma omp simd
-  for (ii = 0; ii < 10; ii = ii + (int)(0.8 - 0.45))
-    c[ii] = a[ii];
-
-  // expected-note@+3 {{loop step is expected to be positive due to this condition}}
-  // expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-  #pragma omp simd
-  for (ii = 0; (ii) < 10; ii-=25)
-    c[ii] = a[ii];
-
-  // expected-note@+3 {{loop step is expected to be positive due to this condition}}
-  // expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-  #pragma omp simd
-  for (ii = 0; (ii < 10); ii-=0)
-    c[ii] = a[ii];
-
-  // expected-note@+3 {{loop step is expected to be negative due to this condition}}
-  // expected-error@+2 {{increment expression must cause 'ii' to decrease on each iteration of OpenMP for loop}}
-  #pragma omp simd
-  for (ii = 0; ii > 10; (ii+=0))
-    c[ii] = a[ii];
-
-  // expected-note@+3 {{loop step is expected to be positive due to this condition}}
-  // expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-  #pragma omp simd
-  for (ii = 0; ii < 10; (ii) = (1-1)+(ii))
-    c[ii] = a[ii];
-
-  // expected-note@+3 {{loop step is expected to be negative due to this condition}}
-  // expected-error@+2 {{increment expression must cause 'ii' to decrease on each iteration of OpenMP for loop}}
-  #pragma omp simd
-  for ((ii = 0); ii > 10; (ii-=0))
-    c[ii] = a[ii];
-
-  // expected-note@+3 {{loop step is expected to be positive due to this condition}}
-  // expected-error@+2 {{increment expression must cause 'ii' to increase on each iteration of OpenMP for loop}}
-  #pragma omp simd
-  for (ii = 0; (ii < 10); (ii-=0))
-    c[ii] = a[ii];
-
-  // expected-note@+2  {{defined as private}}
-  // expected-error@+2 {{loop iteration variable in the associated loop of 'omp simd' directive may not be private, predetermined as linear}}
-  #pragma omp simd private(ii)
-  for (ii = 0; ii < 10; ii++)
-    c[ii] = a[ii];
-
-  // expected-error@+3 {{unexpected OpenMP clause 'shared' in directive '#pragma omp simd'}}
-  // expected-note@+2  {{defined as shared}}
-  // expected-error@+2 {{loop iteration variable in the associated loop of 'omp simd' directive may not be shared, predetermined as linear}}
-  #pragma omp simd shared(ii)
-  for (ii = 0; ii < 10; ii++)
-    c[ii] = a[ii];
-
-  #pragma omp simd linear(ii)
-  for (ii = 0; ii < 10; ii++)
-    c[ii] = a[ii];
-
-  #pragma omp simd lastprivate(ii) linear(jj) collapse(2) // expected-note {{defined as linear}}
-  for (ii = 0; ii < 10; ii++)
-  for (jj = 0; jj < 10; jj++) // expected-error {{loop iteration variable in the associated loop of 'omp simd' directive may not be linear, predetermined as lastprivate}}
-    c[ii] = a[jj];
-
-
-  #pragma omp parallel
-  {
-    // expected-error@+2 {{loop iteration variable in the associated loop of 'omp simd' directive may not be threadprivate or thread local, predetermined as linear}}
-    #pragma omp simd
-    for (sii = 0; sii < 10; sii+=1)
-      c[sii] = a[sii];
-  }
-
-  // expected-error@+2 {{statement after '#pragma omp simd' must be a for loop}}
-  #pragma omp simd
-  for (auto &item : a) {
-    item = item + 1;
-  }
-
-  // expected-note@+3 {{loop step is expected to be positive due to this condition}}
-  // expected-error@+2 {{increment expression must cause 'i' to increase on each iteration of OpenMP for loop}}
-  #pragma omp simd
-  for (unsigned i = 9; i < 10; i--) {
-    c[i] = a[i] + b[i];
-  }
-
-  int (*lb)[4] = nullptr;
-  #pragma omp simd
-  for (int (*p)[4] = lb; p < lb + 8; ++p) {
-  }
-
-  // expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
-  #pragma omp simd
-  for (int a{0}; a<10; ++a) {
-  }
-
-  return 0;
-}
-
-// Iterators allowed in openmp for-loops.
 namespace std {
+
 struct random_access_iterator_tag { };
-template <class Iter> struct iterator_traits {
-  typedef typename Iter::difference_type difference_type;
-  typedef typename Iter::iterator_category iterator_category;
+
+template <class Iter>
+struct iterator_traits {
+  typedef typename Iter::difference_type difference_type; // expected-error {{no type named 'difference_type' in 'Iter'}} expected-error {{no type named 'difference_type' in 'Iter1'}}
+  typedef typename Iter::iterator_category iterator_category; // expected-error {{no type named 'iterator_category' in 'Iter'}} expected-error {{no type named 'iterator_category' in 'Iter1'}} expected-error {{no type named 'iterator_category' in 'Iter2'}}
 };
+
 template <class Iter>
-typename iterator_traits<Iter>::difference_type
-distance(Iter first, Iter last) { return first - last; }
+typename iterator_traits<Iter>::difference_type distance(Iter first, Iter last) {
+  return first - last;
+}
 }
-class Iter0 {
+
+class Iter {
   public:
-    Iter0() { }
-    Iter0(const Iter0 &) { }
-    Iter0 operator ++() { return *this; }
-    Iter0 operator --() { return *this; }
-    bool operator <(Iter0 a) { return true; }
+    Iter() { }
+    Iter(const Iter &) { }
+    Iter operator ++() { return *this; }
+    Iter operator --() { return *this; }
+    bool operator <(Iter a) { return true; }
+    bool operator >=(Iter a) { return false; }
 };
-int operator -(Iter0 a, Iter0 b) { return 0; }
+int operator -(Iter a, Iter b) { return 0; }
 class Iter1 {
   public:
-    Iter1(float f=0.0f, double d=0.0) { }
+    Iter1() { }
     Iter1(const Iter1 &) { }
     Iter1 operator ++() { return *this; }
     Iter1 operator --() { return *this; }
     bool operator <(Iter1 a) { return true; }
     bool operator >=(Iter1 a) { return false; }
 };
-class GoodIter {
+class Iter2 {
   public:
-    GoodIter() { }
-    GoodIter(const GoodIter &) { }
-    GoodIter(int fst, int snd) { }
-    GoodIter &operator =(const GoodIter &that) { return *this; }
-    GoodIter &operator =(const Iter0 &that) { return *this; }
-    GoodIter &operator +=(int x) { return *this; }
-    explicit GoodIter(void *) { }
-    GoodIter operator ++() { return *this; }
-    GoodIter operator --() { return *this; }
-    bool operator !() { return true; }
-    bool operator <(GoodIter a) { return true; }
-    bool operator <=(GoodIter a) { return true; }
-    bool operator >=(GoodIter a) { return false; }
+    Iter2() { }
+    Iter2(const Iter2 &) { }
+    Iter2 operator ++() { return *this; }
+    Iter2 operator --() { return *this; }
+    bool operator <(Iter2 a) { return true; }
+    bool operator >=(Iter2 a) { return false; }
+    typedef int difference_type;
+};
+int operator -(Iter2 a, Iter2 b) { return 0; }
+class Iter3 {
+  public:
+    Iter3() { }
+    Iter3(const Iter3 &) { }
+    Iter3 operator ++() { return *this; }
+    Iter3 operator --() { return *this; }
+    bool operator <(Iter3 a) { return true; }
+    bool operator >=(Iter3 a) { return false; }
+    typedef int difference_type;
+    typedef int iterator_category;
+};
+int operator -(Iter3 a, Iter3 b) { return 0; }
+class Iter4 {
+  public:
+    Iter4() { }
+    Iter4(const Iter4 &) { }
+    Iter4 operator ++() { return *this; }
+    Iter4 operator --() { return *this; }
+    bool operator <(Iter4 a) { return true; }
+    bool operator >=(Iter4 a) { return false; }
+    Iter4 operator+=(int) const {return Iter4();}
+    Iter4 operator-=(int) const {return Iter4();}
     typedef int difference_type;
     typedef std::random_access_iterator_tag iterator_category;
 };
-int operator -(GoodIter a, GoodIter b) { return 0; }
-GoodIter operator -(GoodIter a) { return a; }
-GoodIter operator -(GoodIter a, int v) { return GoodIter(); }
-GoodIter operator +(GoodIter a, int v) { return GoodIter(); }
-GoodIter operator -(int v, GoodIter a) { return GoodIter(); }
-GoodIter operator +(int v, GoodIter a) { return GoodIter(); }
+int operator -(Iter4 a, Iter4 b) { return 0; }
 
-int test_with_random_access_iterator() {
-  GoodIter begin, end;
-  Iter0 begin0, end0;
-  #pragma omp simd
-  for (GoodIter I = begin; I < end; ++I)
-    ++I;
-  // expected-error@+2 {{variable must be of integer or random access iterator type}}
+int t;
+#pragma omp threadprivate(t)
+
+int main() {
   #pragma omp simd
-  for (GoodIter &I = begin; I < end; ++I)
-    ++I;
+  for (int i = 0; i < 10; i++)
+    ++i;
   #pragma omp simd
-  for (GoodIter I = begin; I >= end; --I)
-    ++I;
-  // expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
+  for (t = 0; t < 10; t++)
+    ++t;
   #pragma omp simd
-  for (GoodIter I(begin); I < end; ++I)
-    ++I;
-  // expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
+  for (int i; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
   #pragma omp simd
-  for (GoodIter I(nullptr); I < end; ++I)
-    ++I;
-  // expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
+  for (float i = 0; i < 10.0f; i++) // expected-error {{variable must be of integer or random access iterator type}}
+    ++i;
   #pragma omp simd
-  for (GoodIter I(0); I < end; ++I)
-    ++I;
-  // expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
+  for (int i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
   #pragma omp simd
-  for (GoodIter I(1,2); I < end; ++I)
-    ++I;
+  for (int i = 0; i < 10; i |= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  int i;
   #pragma omp simd
-  for (begin = GoodIter(0); begin < end; ++begin)
-    ++begin;
+  for (i = 0; i < 10; i++)
+    ++i;
   #pragma omp simd
-  for (begin = begin0; begin < end; ++begin)
-    ++begin;
-  // expected-error@+2 {{initialization clause of OpenMP for loop must be of the form 'var = init' or 'T var = init'}}
+  for (i--; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
   #pragma omp simd
-  for (++begin; begin < end; ++begin)
-    ++begin;
+  for (i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
   #pragma omp simd
-  for (begin = end; begin < end; ++begin)
-    ++begin;
-  // expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'I'}}
+  for (i = 0; i < 10; i ^= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  Iter begin, end;
   #pragma omp simd
-  for (GoodIter I = begin; I - I; ++I)
+  for (Iter I = begin; I >= end; ++I) // expected-error {{increment expression must cause 'I' to decrease on each iteration of the loop}}
     ++I;
-  // expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'I'}}
   #pragma omp simd
-  for (GoodIter I = begin; begin < end; ++I)
+  for (Iter I = end; I < begin; --I) // expected-error {{increment expression must cause 'I' to increase on each iteration of the loop}}
     ++I;
-  // expected-error@+2 {{condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', or '>=') of loop variable 'I'}}
   #pragma omp simd
-  for (GoodIter I = begin; !I; ++I)
+  for (Iter I = begin; I < end; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter>' requested here}} expected-error {{iteration variable is not of a random access iterator type}}
     ++I;
-  // expected-note@+3 {{loop step is expected to be negative due to this condition}}
-  // expected-error@+2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
   #pragma omp simd
-  for (GoodIter I = begin; I >= end; I = I + 1)
+  for (Iter I = end; I >= begin; --I) // expected-error {{iteration variable is not of a random access iterator type}}
     ++I;
+  Iter1 begin1;
   #pragma omp simd
-  for (GoodIter I = begin; I >= end; I = I - 1)
+  for (Iter1 I = begin1; I < begin1; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter1>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
     ++I;
-  // expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'I'}}
   #pragma omp simd
-  for (GoodIter I = begin; I >= end; I = -I)
+  for (Iter1 I = begin1; I >= begin1; --I) // expected-error {{iteration variable is not of a random access iterator type}}
     ++I;
-  // expected-note@+3 {{loop step is expected to be negative due to this condition}}
-  // expected-error@+2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
+  Iter2 begin2;
   #pragma omp simd
-  for (GoodIter I = begin; I >= end; I = 2 + I)
+  for (Iter2 I = begin2; I < begin2; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter2>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
     ++I;
-  // expected-error@+2 {{increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable 'I'}}
   #pragma omp simd
-  for (GoodIter I = begin; I >= end; I = 2 - I)
+  for (Iter2 I = begin2; I >= begin2; --I) // expected-error {{iteration variable is not of a random access iterator type}}
     ++I;
+  Iter3 begin3;
   #pragma omp simd
-  for (Iter0 I = begin0; I < end0; ++I)
+  for (Iter3 I = begin3; I < begin3; ++I) // expected-error {{iteration variable is not of a random access iterator type}}
     ++I;
-  // Initializer is constructor without params.
-  // expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
   #pragma omp simd
-  for (Iter0 I; I < end0; ++I)
+  for (Iter3 I = begin3; I >= begin3; --I) // expected-error {{iteration variable is not of a random access iterator type}}
     ++I;
-  Iter1 begin1, end1;
+  Iter4 begin4;
   #pragma omp simd
-  for (Iter1 I = begin1; I < end1; ++I)
+  for (Iter4 I = begin4; I < begin4; ++I)
     ++I;
-  // expected-note@+3 {{loop step is expected to be negative due to this condition}}
-  // expected-error@+2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
   #pragma omp simd
-  for (Iter1 I = begin1; I >= end1; ++I)
+  for (Iter4 I = begin4; I >= begin4; --I)
     ++I;
-  // Initializer is constructor with all default params.
-  // expected-warning@+2 {{initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')}}
+  goto label; // expected-error {{use of undeclared label 'label'}}
   #pragma omp simd
-  for (Iter1 I; I < end1; ++I) {
+  for (int i = 0; i < 100; ++i) {
+    label: ++i;
   }
-  return 0;
-}
-
-template <typename IT, int ST> class TC {
-  public:
-    int dotest_lt(IT begin, IT end) {
-      // expected-note@+3 {{loop step is expected to be positive due to this condition}}
-      // expected-error@+2 {{increment expression must cause 'I' to increase on each iteration of OpenMP for loop}}
-      #pragma omp simd
-      for (IT I = begin; I < end; I = I + ST) {
-        ++I;
-      }
-      // expected-note@+3 {{loop step is expected to be positive due to this condition}}
-      // expected-error@+2 {{increment expression must cause 'I' to increase on each iteration of OpenMP for loop}}
-      #pragma omp simd
-      for (IT I = begin; I <= end; I += ST) {
-        ++I;
-      }
-      #pragma omp simd
-      for (IT I = begin; I < end; ++I) {
-        ++I;
-      }
-    }
-
-    static IT step() {
-      return IT(ST);
-    }
-};
-template <typename IT, int ST=0> int dotest_gt(IT begin, IT end) {
-  // expected-note@+3 2 {{loop step is expected to be negative due to this condition}}
-  // expected-error@+2 2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-  #pragma omp simd
-  for (IT I = begin; I >= end; I = I + ST) {
+  #pragma omp simd collapse(1)
+  for (Iter4 I = begin4; I >= begin4; --I)
     ++I;
-  }
-  // expected-note@+3 2 {{loop step is expected to be negative due to this condition}}
-  // expected-error@+2 2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-  #pragma omp simd
-  for (IT I = begin; I >= end; I += ST) {
+  #pragma omp simd collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+  for (Iter4 I1 = begin4; I1 >= begin4; --I1)
+  for (Iter4 I2 = begin4; I2 >= begin4; --I2)
     ++I;
-  }
-
-  // expected-note@+3 {{loop step is expected to be negative due to this condition}}
-  // expected-error@+2 {{increment expression must cause 'I' to decrease on each iteration of OpenMP for loop}}
-  #pragma omp simd
-  for (IT I = begin; I >= end; ++I) {
-    ++I;
-  }
-
-  #pragma omp simd
-  for (IT I = begin; I < end; I+=TC<int,ST>::step()) {
+  #pragma omp simd collapse(0) // expected-error {{expression is not a positive integer value}}
+  for (Iter4 I = begin4; I >= begin4; --I)
     ++I;
-  }
-}
-
-void test_with_template() {
-  GoodIter begin, end;
-  TC<GoodIter, 100> t1;
-  TC<GoodIter, -100> t2;
-  t1.dotest_lt(begin, end);
-  t2.dotest_lt(begin, end); // expected-note {{in instantiation of member function 'TC<GoodIter, -100>::dotest_lt' requested here}}
-  dotest_gt(begin, end); // expected-note {{in instantiation of function template specialization 'dotest_gt<GoodIter, 0>' requested here}}
-  dotest_gt<unsigned, -10>(0, 100); // expected-note {{in instantiation of function template specialization 'dotest_gt<unsigned int, -10>' requested here}}
-}
-
-void test_loop_break() {
-  const int N = 100;
-  float a[N], b[N], c[N];
-  #pragma omp simd
-  for (int i = 0; i < 10; i++) {
-    c[i] = a[i] + b[i];
-    for (int j = 0; j < 10; ++j) {
-      if (a[i] > b[j])
-        break; // OK in nested loop
-    }
-    switch(i) {
-      case 1:
-        b[i]++;
-        break;
-      default:
-        break;
-    }
-    if (c[i] > 10)
-      break; // expected-error {{'break' statement cannot be used in OpenMP for loop}}
-
-    if (c[i] > 11)
-      break; // expected-error {{'break' statement cannot be used in OpenMP for loop}}
-  }
-
   #pragma omp simd
-  for (int i = 0; i < 10; i++) {
-    for (int j = 0; j < 10; j++) {
-      c[i] = a[i] + b[i];
-      if (c[i] > 10) {
-        if (c[i] < 20) {
-          break; // OK
-        }
-      }
-    }
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp for // expected-error {{region cannot be closely nested inside a simd region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp for
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp simd 
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp single
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp simd 
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp sections
+  {
+    #pragma omp simd 
+  for (Iter4 I = begin4; I >= begin4; --I)
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
   }
-}
-
-void test_loop_eh() {
-  const int N = 100;
-  float a[N], b[N], c[N];
-  #pragma omp simd
-  for (int i = 0; i < 10; i++) {
-    c[i] = a[i] + b[i];
-    try { // expected-error {{'try' statement cannot be used in OpenMP simd region}}
-      for (int j = 0; j < 10; ++j) {
-        if (a[i] > b[j])
-          throw a[i]; // expected-error {{'throw' statement cannot be used in OpenMP simd region}}
-      }
-      throw a[i]; // expected-error {{'throw' statement cannot be used in OpenMP simd region}}
-    }
-    catch (float f) {
-      if (f > 0.1)
-        throw a[i]; // expected-error {{'throw' statement cannot be used in OpenMP simd region}}
-      return; // expected-error {{cannot return from OpenMP region}}
-    }
-    switch(i) {
-      case 1:
-        b[i]++;
-        break;
-      default:
-        break;
-    }
-    for (int j = 0; j < 10; j++) {
-      if (c[i] > 10)
-        throw c[i]; // expected-error {{'throw' statement cannot be used in OpenMP simd region}}
+#pragma omp sections
+  {
+#pragma omp section
+    {
+    #pragma omp simd 
+  for (Iter4 I = begin4; I >= begin4; --I)
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
     }
   }
-  if (c[9] > 10)
-    throw c[9]; // OK
-
-  #pragma omp simd
-  for (int i = 0; i < 10; ++i) {
-    struct S {
-      void g() { throw 0; }
-    };
-  }
+  #pragma omp master
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp simd
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp critical
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp simd
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp simd ordered // expected-error {{unexpected OpenMP clause 'ordered' in directive '#pragma omp simd'}}
+  for (Iter4 I = begin4; I >= begin4; --I)
+  #pragma omp ordered // expected-error {{region cannot be closely nested inside a simd region}}
+    #pragma omp simd
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp simd collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I; // expected-error {{only for-loops are allowed for '#pragma omp simd'}}
+  ++begin4; 
 }
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/simd_metadata.c cfe-3.5.0.src.omp/test/OpenMP/simd_metadata.c
--- cfe-3.5.0.src/test/OpenMP/simd_metadata.c	2014-06-25 11:42:16.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/simd_metadata.c	2014-11-28 10:49:31.000000000 -0500
@@ -1,10 +1,10 @@
-// RUN: %clang_cc1 -fopenmp=libiomp5 -emit-llvm %s -o - | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -emit-llvm %s -o - | FileCheck %s
 
 void h1(float *c, float *a, float *b, int size)
 {
 // CHECK-LABEL: define void @h1
   int t = 0;
-#pragma omp simd safelen(16) linear(t)
+#pragma omp simd safelen(16) aligned(a, b, c) linear(t)
   for (int i = 0; i < size; ++i) {
     c[i] = a[i] * a[i] + b[i] * b[t];
     ++t;
@@ -17,7 +17,7 @@
 {
 // CHECK-LABEL: define void @h2
   int t = 0;
-#pragma omp simd linear(t)
+#pragma omp simd aligned(a, b, c) linear(t)
   for (int i = 0; i < size; ++i) {
     c[i] = a[i] * a[i] + b[i] * b[t];
     ++t;
@@ -28,7 +28,7 @@
 void h3(float *c, float *a, float *b, int size)
 {
 // CHECK-LABEL: define void @h3
-#pragma omp simd
+#pragma omp simd aligned(a, b, c)
   for (int i = 0; i < size; ++i) {
     for (int j = 0; j < size; ++j) {
       c[j*i] = a[i] * b[j];
@@ -38,10 +38,23 @@
 // CHECK-NOT: store float {{.+}}, float* {{.+}}, align {{.+}}, !llvm.mem.parallel_loop_access {{![0-9]+}}
 }
 
+void h4(float *c, float *a, float *b, int size)
+{
+// CHECK-LABEL: define void @h4
+#pragma omp simd aligned(a, b, c) collapse(2)
+  for (int i = 0; i < size; ++i) {
+    for (int j = 0; j < size; ++j) {
+      c[j*i] = a[i] * b[j];
+    }
+  }
+// emit parallel_loop_access: nested loop is collapsed.
+// CHECK: store float {{.+}}, float* {{.+}}, align {{.+}}, !llvm.mem.parallel_loop_access [[LOOP_H4_HEADER:![0-9]+]]
+}
+
 // Metadata for h1:
 // CHECK: [[LOOP_H1_HEADER:![0-9]+]] = metadata !{metadata [[LOOP_H1_HEADER]], metadata [[LOOP_WIDTH_16:![0-9]+]], metadata [[LOOP_VEC_ENABLE:![0-9]+]]}
-// CHECK: [[LOOP_WIDTH_16]] = metadata !{metadata !"llvm.loop.vectorize.width", i32 16}
-// CHECK: [[LOOP_VEC_ENABLE]] = metadata !{metadata !"llvm.loop.vectorize.enable", i1 true}
+// CHECK: [[LOOP_WIDTH_16]] = metadata !{metadata !"llvm.vectorizer.width", i32 16}
+// CHECK: [[LOOP_VEC_ENABLE]] = metadata !{metadata !"llvm.vectorizer.enable", i1 true}
 //
 // Metadata for h2:
 // CHECK: [[LOOP_H2_HEADER]] = metadata !{metadata [[LOOP_H2_HEADER]], metadata [[LOOP_VEC_ENABLE]]}
@@ -49,3 +62,6 @@
 // Metadata for h3:
 // CHECK: [[LOOP_H3_HEADER:![0-9]+]] = metadata !{metadata [[LOOP_H3_HEADER]], metadata [[LOOP_VEC_ENABLE]]}
 //
+// Metadata for h4:
+// CHECK: [[LOOP_H4_HEADER]] = metadata !{metadata [[LOOP_H4_HEADER]], metadata [[LOOP_VEC_ENABLE]]}
+//
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/simd_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/simd_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/simd_misc_messages.c	2014-07-08 07:33:21.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/simd_misc_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -1,12 +1,14 @@
-// RUN: %clang_cc1 -fsyntax-only -fopenmp=libiomp5 -verify %s
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 100000 -fopenmp -verify %s
+// This test was initially supposed for '#pragma simd' and was
+// changed to apply to '#pragma omp simd', which is similar.
 
-// expected-error@+1 {{unexpected OpenMP directive '#pragma omp simd'}}
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp simd'}} */
 #pragma omp simd
 
-// expected-error@+1 {{unexpected OpenMP directive '#pragma omp simd'}}
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp simd'}} */
 #pragma omp simd foo
 
-// expected-error@+1 {{unexpected OpenMP directive '#pragma omp simd'}}
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp simd'}} */
 #pragma omp simd safelen(4)
 
 void test_no_clause()
@@ -14,44 +16,12 @@
   int i;
   #pragma omp simd
   for (i = 0; i < 16; ++i) ;
-
-  // expected-error@+2 {{statement after '#pragma omp simd' must be a for loop}}
-  #pragma omp simd
-  ++i;
-}
-
-void test_branch_protected_scope()
-{
-  int i = 0;
-L1:
-  ++i;
-
-  int x[24];
-
-  #pragma omp simd
-  for (i = 0; i < 16; ++i) {
-    if (i == 5)
-      goto L1; // expected-error {{use of undeclared label 'L1'}}
-    else if (i == 6)
-      return; // expected-error {{cannot return from OpenMP region}}
-    else if (i == 7)
-      goto L2;
-    else if (i == 8) {
-L2:
-      x[i]++;
-    }
-  }
-
-  if (x[0] == 0)
-    goto L2; // expected-error {{use of undeclared label 'L2'}}
-  else if (x[1] == 1)
-    goto L1;
 }
 
 void test_invalid_clause()
 {
   int i;
-  // expected-warning@+1 {{extra tokens at the end of '#pragma omp simd' are ignored}}
+  /* expected-warning@+1 {{extra tokens at the end of '#pragma omp simd' are ignored}} */
   #pragma omp simd foo bar
   for (i = 0; i < 16; ++i) ;
 }
@@ -63,10 +33,6 @@
   // expected-warning@+1 {{extra tokens at the end of '#pragma omp simd' are ignored}}
   #pragma omp simd;
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{unexpected OpenMP clause 'firstprivate' in directive '#pragma omp simd'}}
-  // expected-warning@+1 {{extra tokens at the end of '#pragma omp simd' are ignored}}
-  #pragma omp simd firstprivate(x);
-  for (i = 0; i < 16; ++i) ;
 
   // expected-warning@+1 {{extra tokens at the end of '#pragma omp simd' are ignored}}
   #pragma omp simd private(x);
@@ -77,197 +43,114 @@
   for (i = 0; i < 16; ++i) ;
 }
 
-extern int foo();
 void test_safelen()
 {
   int i;
-  // expected-error@+1 {{expected '('}}
+  /* expected-error@+1 {{expected '('}}  expected-error@+1 {{expected expression}}*/
   #pragma omp simd safelen
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}} */
   #pragma omp simd safelen(
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd safelen()
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
   #pragma omp simd safelen(,
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}  expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp simd' are ignored}}
+  /* expected-error@+1 {{expected expression}}  expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
   #pragma omp simd safelen(,)
   for (i = 0; i < 16; ++i) ;
-  // expected-warning@+2 {{extra tokens at the end of '#pragma omp simd' are ignored}}
-  // expected-error@+1 {{expected '('}}
+  /* expected-error@+1 {{expected '('}} */
   #pragma omp simd safelen 4)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected ')'}}
-  // expected-note@+1 {{to match this '('}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
   #pragma omp simd safelen(4
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected ')'}}
-  // expected-note@+1 {{to match this '('}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
   #pragma omp simd safelen(4,
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected ')'}}
-  // expected-note@+1 {{to match this '('}}
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
   #pragma omp simd safelen(4,)
   for (i = 0; i < 16; ++i) ;
-  // xxpected-error@+1 {{expected expression}}
+  /* xxpected-error@+1 {{expected expression}} */
   #pragma omp simd safelen(4)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected ')'}}
-  // expected-note@+1 {{to match this '('}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
   #pragma omp simd safelen(4 4)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected ')'}}
-  // expected-note@+1 {{to match this '('}}
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
   #pragma omp simd safelen(4,,4)
   for (i = 0; i < 16; ++i) ;
   #pragma omp simd safelen(4)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected ')'}}
-  // expected-note@+1 {{to match this '('}}
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
   #pragma omp simd safelen(4,8)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expression is not an integer constant expression}}
-  #pragma omp simd safelen(2.5)
-  for (i = 0; i < 16; ++i);
-  // expected-error@+1 {{expression is not an integer constant expression}}
-  #pragma omp simd safelen(foo())
-  for (i = 0; i < 16; ++i);
-  // expected-error@+1 {{argument to 'safelen' clause must be a positive integer value}}
-  #pragma omp simd safelen(-5)
-  for (i = 0; i < 16; ++i);
-  // expected-error@+1 {{argument to 'safelen' clause must be a positive integer value}}
-  #pragma omp simd safelen(0)
-  for (i = 0; i < 16; ++i);
-  // expected-error@+1 {{argument to 'safelen' clause must be a positive integer value}}
-  #pragma omp simd safelen(5-5)
-  for (i = 0; i < 16; ++i);
-}
-
-void test_collapse()
-{
-  int i;
-  // expected-error@+1 {{expected '('}}
-  #pragma omp simd collapse
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-  #pragma omp simd collapse(
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
-  #pragma omp simd collapse()
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-  #pragma omp simd collapse(,
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}  expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-  #pragma omp simd collapse(,)
-  for (i = 0; i < 16; ++i) ;
-  // expected-warning@+2 {{extra tokens at the end of '#pragma omp simd' are ignored}}
-  // expected-error@+1 {{expected '('}}
-  #pragma omp simd collapse 4)
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected ')'}}
-  // expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-  #pragma omp simd collapse(4
-  for (i = 0; i < 16; ++i) ; // expected-error {{expected 4 for loops after '#pragma omp simd', but found only 1}}
-  // expected-error@+2 {{expected ')'}}
-  // expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-  #pragma omp simd collapse(4,
-  for (i = 0; i < 16; ++i) ; // expected-error {{expected 4 for loops after '#pragma omp simd', but found only 1}}
-  // expected-error@+2 {{expected ')'}}
-  // expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-  #pragma omp simd collapse(4,)
-  for (i = 0; i < 16; ++i) ; // expected-error {{expected 4 for loops after '#pragma omp simd', but found only 1}}
-  // xxpected-error@+1 {{expected expression}} expected-note@+1 {{as specified in 'collapse' clause}}
-  #pragma omp simd collapse(4)
-  for (i = 0; i < 16; ++i) ; // expected-error {{expected 4 for loops after '#pragma omp simd', but found only 1}}
-  // expected-error@+2 {{expected ')'}}
-  // expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-  #pragma omp simd collapse(4 4)
-  for (i = 0; i < 16; ++i) ; // expected-error {{expected 4 for loops after '#pragma omp simd', but found only 1}}
-  // expected-error@+2 {{expected ')'}}
-  // expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-  #pragma omp simd collapse(4,,4)
-  for (i = 0; i < 16; ++i) ; // expected-error {{expected 4 for loops after '#pragma omp simd', but found only 1}}
-  #pragma omp simd collapse(4)
-  for (int i1 = 0; i1 < 16; ++i1)
-    for (int i2 = 0; i2 < 16; ++i2)
-      for (int i3 = 0; i3 < 16; ++i3)
-        for (int i4 = 0; i4 < 16; ++i4)
-          foo();
-  // expected-error@+2 {{expected ')'}}
-  // expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
-  #pragma omp simd collapse(4,8)
-  for (i = 0; i < 16; ++i) ; // expected-error {{expected 4 for loops after '#pragma omp simd', but found only 1}}
-  // expected-error@+1 {{expression is not an integer constant expression}}
-  #pragma omp simd collapse(2.5)
-  for (i = 0; i < 16; ++i);
-  // expected-error@+1 {{expression is not an integer constant expression}}
-  #pragma omp simd collapse(foo())
-  for (i = 0; i < 16; ++i);
-  // expected-error@+1 {{argument to 'collapse' clause must be a positive integer value}}
-  #pragma omp simd collapse(-5)
-  for (i = 0; i < 16; ++i);
-  // expected-error@+1 {{argument to 'collapse' clause must be a positive integer value}}
-  #pragma omp simd collapse(0)
-  for (i = 0; i < 16; ++i);
-  // expected-error@+1 {{argument to 'collapse' clause must be a positive integer value}}
-  #pragma omp simd collapse(5-5)
-  for (i = 0; i < 16; ++i);
 }
 
 void test_linear()
 {
   int i;
-  // expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}} */
   #pragma omp simd linear(
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected expression}}
-  // expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
   #pragma omp simd linear(,
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected expression}}
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd linear(,)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd linear()
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd linear(int)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected variable name}}
+  /* expected-error@+1 {{expected variable name}} */
   #pragma omp simd linear(0)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{use of undeclared identifier 'x'}}
+  /* expected-error@+1 {{use of undeclared identifier 'x'}} */
   #pragma omp simd linear(x)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{use of undeclared identifier 'x'}}
-  // expected-error@+1 {{use of undeclared identifier 'y'}}
+  /* expected-error@+2 {{use of undeclared identifier 'x'}} */
+  /* expected-error@+1 {{use of undeclared identifier 'y'}} */
   #pragma omp simd linear(x, y)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+3 {{use of undeclared identifier 'x'}}
-  // expected-error@+2 {{use of undeclared identifier 'y'}}
-  // expected-error@+1 {{use of undeclared identifier 'z'}}
+  /* expected-error@+3 {{use of undeclared identifier 'x'}} */
+  /* expected-error@+2 {{use of undeclared identifier 'y'}} */
+  /* expected-error@+1 {{use of undeclared identifier 'z'}} */
   #pragma omp simd linear(x, y, z)
   for (i = 0; i < 16; ++i) ;
 
   int x, y;
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd linear(x:)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd linear(x:,)
   for (i = 0; i < 16; ++i) ;
   #pragma omp simd linear(x:1)
   for (i = 0; i < 16; ++i) ;
   #pragma omp simd linear(x:2*2)
   for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp simd' are ignored}}
   // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
   #pragma omp simd linear(x:1,y)
   for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp simd' are ignored}}
   // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
   #pragma omp simd linear(x:1,y,z:1)
   for (i = 0; i < 16; ++i) ;
@@ -287,10 +170,6 @@
   #pragma omp simd linear(x) private(x)
   for (i = 0; i < 16; ++i) ;
 
-  // expected-warning@+1 {{zero linear step (x and other variables in clause should probably be const)}}
-  #pragma omp simd linear(x,y:0)
-  for (i = 0; i < 16; ++i) ;
-
   // expected-note@+2 {{defined as linear}}
   // expected-error@+1 {{linear variable cannot be lastprivate}}
   #pragma omp simd linear(x) lastprivate(x)
@@ -300,107 +179,29 @@
   // expected-error@+1 {{lastprivate variable cannot be linear}}
   #pragma omp simd lastprivate(x) linear(x) 
   for (i = 0; i < 16; ++i) ;
-
-}
-
-void test_aligned()
-{
-  int i;
-  // expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-  #pragma omp simd aligned(
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected expression}}
-  // expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-  #pragma omp simd aligned(,
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected expression}}
-  // expected-error@+1 {{expected expression}}
-  #pragma omp simd aligned(,)
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
-  #pragma omp simd aligned()
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
-  #pragma omp simd aligned(int)
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected variable name}}
-  #pragma omp simd aligned(0)
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{use of undeclared identifier 'x'}}
-  #pragma omp simd aligned(x)
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{use of undeclared identifier 'x'}}
-  // expected-error@+1 {{use of undeclared identifier 'y'}}
-  #pragma omp simd aligned(x, y)
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+3 {{use of undeclared identifier 'x'}}
-  // expected-error@+2 {{use of undeclared identifier 'y'}}
-  // expected-error@+1 {{use of undeclared identifier 'z'}}
-  #pragma omp simd aligned(x, y, z)
-  for (i = 0; i < 16; ++i) ;
-
-  int *x, y, z[25]; // expected-note 4 {{'y' defined here}}
-  #pragma omp simd aligned(x)
-  for (i = 0; i < 16; ++i) ;
-  #pragma omp simd aligned(z)
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
-  #pragma omp simd aligned(x:)
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-  #pragma omp simd aligned(x:,)
-  for (i = 0; i < 16; ++i) ;
-  #pragma omp simd aligned(x:1)
-  for (i = 0; i < 16; ++i) ;
-  #pragma omp simd aligned(x:2*2)
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-  #pragma omp simd aligned(x:1,y)
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-  #pragma omp simd aligned(x:1,y,z:1)
-  for (i = 0; i < 16; ++i) ;
-
-  // expected-error@+1 {{argument of aligned clause should be array or pointer, not 'int'}}
-  #pragma omp simd aligned(x, y)
-  for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{argument of aligned clause should be array or pointer, not 'int'}}
-  #pragma omp simd aligned(x, y, z)
-  for (i = 0; i < 16; ++i) ;
-
-  // expected-note@+2 {{defined as aligned}}
-  // expected-error@+1 {{a variable cannot appear in more than one aligned clause}}
-  #pragma omp simd aligned(x) aligned(z,x)
-  for (i = 0; i < 16; ++i) ;
-
-  // expected-note@+3 {{defined as aligned}}
-  // expected-error@+2 {{a variable cannot appear in more than one aligned clause}}
-  // expected-error@+1 2 {{argument of aligned clause should be array or pointer, not 'int'}}
-  #pragma omp simd aligned(x,y,z) aligned(y,z)
-  for (i = 0; i < 16; ++i) ;
 }
 
 void test_private()
 {
   int i;
-  // expected-error@+2 {{expected expression}}
+  /* expected-error@+2 {{expected expression}} */
   // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
   #pragma omp simd private(
   for (i = 0; i < 16; ++i) ;
   // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-  // expected-error@+1 2 {{expected expression}}
+  /* expected-error@+1 2 {{expected expression}} */
   #pragma omp simd private(,
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 2 {{expected expression}}
+  /* expected-error@+1 2 {{expected expression}} */
   #pragma omp simd private(,)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd private()
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd private(int)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected variable name}}
+  /* expected-error@+1 {{expected variable name}} */
   #pragma omp simd private(0)
   for (i = 0; i < 16; ++i) ;
 
@@ -410,17 +211,15 @@
   #pragma omp simd private(x, y)
   for (i = 0; i < 16; ++i) ;
   #pragma omp simd private(x, y, z)
-  for (i = 0; i < 16; ++i) {
-    x = y * i + z;
-  }
+  for (i = 0; i < 16; ++i) ;
 }
 
 void test_firstprivate()
 {
   int i;
   // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
-  // expected-error@+2 {{unexpected OpenMP clause 'firstprivate' in directive '#pragma omp simd'}}
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+2 {{unexpected OpenMP clause 'firstprivate' in directive '#pragma omp simd'}} */
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd firstprivate(
   for (i = 0; i < 16; ++i) ;
 }
@@ -429,24 +228,24 @@
 {
   int i;
   // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd lastprivate(
   for (i = 0; i < 16; ++i) ;
 
   // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-  // expected-error@+1 2 {{expected expression}}
+  /* expected-error@+1 2 {{expected expression}} */
   #pragma omp simd lastprivate(,
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 2 {{expected expression}}
+  /* expected-error@+1 2 {{expected expression}} */
   #pragma omp simd lastprivate(,)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd lastprivate()
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd lastprivate(int)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected variable name}}
+  /* expected-error@+1 {{expected variable name}} */
   #pragma omp simd lastprivate(0)
   for (i = 0; i < 16; ++i) ;
 
@@ -463,48 +262,50 @@
 {
   int i, x, y;
   // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
-  // expected-error@+2 {{expected identifier}}
-  // expected-warning@+1 {{missing ':' after reduction identifier - ignoring}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
   #pragma omp simd reduction(
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected identifier}}
-  // expected-warning@+1 {{missing ':' after reduction identifier - ignoring}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
   #pragma omp simd reduction()
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected expression}}
-  // expected-warning@+1 {{missing ':' after reduction identifier - ignoring}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
   #pragma omp simd reduction(x)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected identifier}}
+  /* expected-error@+1 {{expected identifier}} */
   #pragma omp simd reduction(:x)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
-  // expected-error@+2 {{expected identifier}}
-  // expected-warning@+1 {{missing ':' after reduction identifier - ignoring}}
+  // expected-error@+4 {{expected ')'}} expected-note@+4 {{to match this '('}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 2 {{expected expression}} */
   #pragma omp simd reduction(,
   for (i = 0; i < 16; ++i) ;
   // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
-  // expected-error@+2 {{expected expression}}
-  // expected-warning@+1 {{missing ':' after reduction identifier - ignoring}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
   #pragma omp simd reduction(+
   for (i = 0; i < 16; ++i) ;
 
   // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
   //
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd reduction(+:
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd reduction(+:)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd reduction(+:,y)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected expression}}
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd reduction(+:x,+:y)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+2 {{expected identifier}}
-  // expected-warning@+1 {{missing ':' after reduction identifier - ignoring}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 {{expected expression}} */
   #pragma omp simd reduction(%:x)
   for (i = 0; i < 16; ++i) ;
 
@@ -530,26 +331,125 @@
   for (i = 0; i < 16; ++i) ;
   struct X { int x; };
   struct X X;
+  // TODO: Is the following error correct?
   // expected-error@+1 {{expected variable name}}
   #pragma omp simd reduction(+:X.x)
   for (i = 0; i < 16; ++i) ;
-  // expected-error@+1 {{expected variable name}}
+  /* expected-error@+1 {{expected variable name}} */
   #pragma omp simd reduction(+:x+x)
   for (i = 0; i < 16; ++i) ;
 }
 
-void test_loop_messages()
+void test_aligned()
 {
-  float a[100], b[100], c[100];
-  // expected-error@+2 {{variable must be of integer or pointer type}}
+  int i;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp simd aligned(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp simd aligned(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp simd aligned(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp simd aligned()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp simd aligned(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp simd aligned(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int *x, y, z[25];
+  #pragma omp simd aligned(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp simd aligned(x, y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp simd aligned(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp simd aligned(x:4)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp simd aligned(x, y:8)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp simd aligned(x, y, z:10+6)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}}
+  // expected-error@+1 {{expression is not an integer constant expression}}
+  #pragma omp simd aligned(x, y, z:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-note@+2 {{defined as aligned}}
+  // expected-error@+1 {{aligned variable cannot be aligned}}
+  #pragma omp simd aligned(x:16) aligned(z,x:16)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_multiple_clauses()
+{
+  int i;
+  float x = 0, y = 0, z = 0;
+  #pragma omp simd safelen(4) reduction(+:x, y) reduction(-:z) // OK
+  for (i = 0; i < 16; ++i);
+
+  // expected-error@+1 {{private variable cannot be lastprivate}} expected-note@+1 {{defined as private}}
+  #pragma omp simd private(x), lastprivate(x)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp simd safelen(4) reduction(+:x, y), reduction(-:z)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp simd reduction(+:x, y) reduction(-:z)
+  for (i = 0; i < 16; ++i);
+}
+
+void test_for()
+{
+  // expected-error@+3 {{expected '(' after 'for'}}
+  // expected-error@+2 2{{use of undeclared identifier 'i'}}
   #pragma omp simd
-  for (float fi = 0; fi < 10.0; fi++) {
-    c[(int)fi] = a[(int)fi] + b[(int)fi];
-  }
-  // expected-error@+2 {{variable must be of integer or pointer type}}
+  for int i = 0; i < 16; i++);
+
+  // expected-error@+3 {{expected ')'}}
+  // expected-note@+2 {{to match this '('}}
   #pragma omp simd
-  for (double fi = 0; fi < 10.0; fi++) {
-    c[(int)fi] = a[(int)fi] + b[(int)fi];
-  }
-}
+  for (int i = 0; i < 16; i++;
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp simd
+  for (int i = 0 i < 16; i++);
 
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp simd
+  for (int i = 0; i < 16 i++);
+
+  // expected-error@+2 2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp simd
+  for (int i = 0 i < 16 i++);
+
+  int i = 0;
+  // expected-error@+2 {{initialization of for-loop does not have canonical form}}
+  #pragma omp simd
+  for (; i < 16; ++i);
+
+  // expected-error@+2 {{condition of for-loop does not have canonical form}}
+  #pragma omp simd
+  for (int i = 0; ; ++i);
+
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp simd
+  for (int i = 0; i < 16; );
+
+  // expected-error@+3 {{condition of for-loop does not have canonical form}}
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp simd
+  for (int i = 0; ;);
+
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/simd_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/simd_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/simd_private_messages.cpp	2014-03-06 06:48:22.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/simd_private_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,12 +7,13 @@
   return argc;
 }
 
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
 public:
   S2():a(0) { }
+  static float S2s; // expected-note {{predetermined as shared}}
 };
 const S2 b;
 const S2 ba[5];
@@ -21,7 +22,9 @@
 public:
   S3():a(0) { }
 };
-const S3 ca[5];
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f;  // expected-note {{predetermined as shared}}
 class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
@@ -36,14 +39,16 @@
 };
 
 S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
-template<class I, class C> int foomain(I argc, C **argv) {
-  I e(4);
-  I g(5);
+int main(int argc, char **argv) {
+  const int d = 5;  // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
   int i;
   int &j = i; // expected-note {{'j' defined here}}
-  #pragma omp simd private // expected-error {{expected '(' after 'private'}}
+  #pragma omp simd private // expected-error {{expected '(' after 'private'}} expected-error {{expected expression}}
   for (int k = 0; k < argc; ++k) ++k;
   #pragma omp simd private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   for (int k = 0; k < argc; ++k) ++k;
@@ -59,56 +64,17 @@
   for (int k = 0; k < argc; ++k) ++k;
   #pragma omp simd private (S1) // expected-error {{'S1' does not refer to a value}}
   for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd private (a, b) // expected-error {{private variable with incomplete type 'S1'}}
+  #pragma omp simd private (a, b, c, d, f) // expected-error {{private variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be private}}
   for (int k = 0; k < argc; ++k) ++k;
   #pragma omp simd private (argv[1]) // expected-error {{expected variable name}}
   for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd private(e, g)
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd shared(i) // expected-error {{unexpected OpenMP clause 'shared' in directive '#pragma omp simd'}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp parallel
-  {
-    int v = 0;
-    int i;
-    #pragma omp simd private(i)
-    for (int k = 0; k < argc; ++k) { i = k; v += i; }
-  }
-  #pragma omp parallel shared(i)
-  #pragma omp parallel private(i)
-  #pragma omp simd private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd private(i)
+  #pragma omp simd private(ba)
   for (int k = 0; k < argc; ++k) ++k;
-  return 0;
-}
-
-int main(int argc, char **argv) {
-  S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note {{'g' defined here}}
-  int i;
-  int &j = i; // expected-note {{'j' defined here}}
-  #pragma omp simd private // expected-error {{expected '(' after 'private'}}
+  #pragma omp simd private(ca) // expected-error {{shared variable cannot be private}}
   for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp simd private(da) // expected-error {{shared variable cannot be private}}
   for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd private () // expected-error {{expected expression}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd private (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd private (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd private (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd private (argc)
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd private (S1) // expected-error {{'S1' does not refer to a value}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd private (a, b) // expected-error {{private variable with incomplete type 'S1'}}
-  for (int k = 0; k < argc; ++k) ++k;
-  #pragma omp simd private (argv[1]) // expected-error {{expected variable name}}
+  #pragma omp simd private(S2::S2s) // expected-error {{shared variable cannot be private}}
   for (int k = 0; k < argc; ++k) ++k;
   #pragma omp simd private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
   for (int k = 0; k < argc; ++k) ++k;
@@ -118,17 +84,54 @@
   for (int k = 0; k < argc; ++k) ++k;
   #pragma omp parallel
   {
-    int i;
-    #pragma omp simd private(i)
+    int i; // expected-note {{predetermined as private}}
+    #pragma omp simd lastprivate(i), private(i) // expected-error {{private variable cannot be lastprivate}}
+    for (int k = 0; k < argc; ++k) ++k;
+  }
+  // TODO: The following seems to be incorrect -- why cannot it be lastprivate in simd?
+  #pragma omp parallel
+  {
+    int i; // expected-note {{predetermined as private}}
+    #pragma omp simd lastprivate(i) // expected-error {{private variable cannot be lastprivate}}
     for (int k = 0; k < argc; ++k) ++k;
   }
   #pragma omp parallel shared(i)
   #pragma omp parallel private(i)
   #pragma omp simd private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
   for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp parallel private(i)
+  #pragma omp parallel firstprivate(i)
+  #pragma omp parallel private(i)
+  #pragma omp parallel reduction(+:i)
   #pragma omp simd private(i)
   for (int k = 0; k < argc; ++k) ++k;
+  #pragma omp for private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel private(i)
+    #pragma omp simd private(i)
+    for (int x = 0; x < 10; ++x) foo();
+  }
+  #pragma omp parallel
+  #pragma omp for firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel firstprivate(i)
+    #pragma omp simd private(i)
+    for (int x = 0; x < 10; ++x) foo();
+  }
+  #pragma omp parallel
+  #pragma omp for reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel reduction(+:i)
+    #pragma omp simd private(i)
+    for (int x = 0; x < 10; ++x) foo();
+  }
+  #pragma omp parallel
+  #pragma omp for lastprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp parallel
+    #pragma omp simd private(i)
+    for (int x = 0; x < 10; ++x) foo();
+  }
 
   return 0;
 }
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/simd_reduction_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/simd_reduction_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/simd_reduction_messages.cpp	2014-07-08 07:33:21.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/simd_reduction_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,292 +7,135 @@
   return argc;
 }
 
-struct S1; // expected-note {{declared here}} expected-note 4 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
-  S2 &operator+=(const S2 &arg) { return (*this); }
-
+  S2 &operator +=(const S2 &arg) {return (*this);} // expected-note {{implicitly declared private here}}
 public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
-  static float S2s; // expected-note 2 {{static data member is predetermined as shared}}
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note {{predetermined as shared}}
   static const float S2sc;
 };
-const float S2::S2sc = 0; // expected-note 2 {{'S2sc' defined here}}
-S2 b;                     // expected-note 2 {{'b' defined here}}
-const S2 ba[5];           // expected-note 2 {{'ba' defined here}}
+const float S2::S2sc = 0; // expected-note {{'S2sc' defined here}}
+S2 b; // expected-note {{'b' defined here}}
+const S2 ba[5]; // expected-note {{'ba' defined here}}
 class S3 {
   int a;
-
 public:
-  S3() : a(0) {}
-  S3(const S3 &s3) : a(s3.a) {}
-  S3 operator+=(const S3 &arg1) { return arg1; }
+  S3():a(0) { }
+  S3(const S3 &s3):a(s3.a) { }
+  S3 operator +=(const S3 &arg1) {return arg1;}
 };
-int operator+=(const S3 &arg1, const S3 &arg2) { return 5; }
-S3 c;               // expected-note 2 {{'c' defined here}}
-const S3 ca[5];     // expected-note 2 {{'ca' defined here}}
-extern const int f; // expected-note 4 {{'f' declared here}}
-class S4 {          // expected-note {{'S4' declared here}}
+int operator +=(const S3 &arg1, const S3 &arg2) {return 5;} // expected-note {{candidate function not viable: no known conversion from 'class S6' to 'const S3' for 1st argument}}
+S3 c; // expected-note {{'c' defined here}}
+const S3 ca[5]; // expected-note {{'ca' defined here}}
+extern const int f; // expected-note 2 {{'f' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
   S4(const S4 &s4);
-  S4 &operator+=(const S4 &arg) { return (*this); }
-
+  S4 &operator +=(const S4 &arg) {return (*this);}
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
-S4 &operator&=(S4 &arg1, S4 &arg2) { return arg1; }
+S4 &operator &=(S4 &arg1, S4 &arg2) {return arg1;} // expected-note {{candidate function not viable: no known conversion from 'S5' to 'S4 &' for 1st argument}}
 class S5 {
   int a;
-  S5() : a(0) {}
-  S5(const S5 &s5) : a(s5.a) {}
-  S5 &operator+=(const S5 &arg);
-
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+  S5 &operator +=(const S5 &arg);
 public:
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
 };
 class S6 {
-  int a;
-
-public:
-  S6() : a(6) {}
-  operator int() { return 6; }
-} o; // expected-note 2 {{'o' defined here}}
+    int a;
+  public:
+    S6():a(6){ }
+    operator int() { return 6; }
+} o;
 
 S3 h, k;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class T>       // expected-note {{declared here}}
-T tmain(T argc) {        // expected-note 2 {{'argc' defined here}}
-  const T d = T();       // expected-note 4 {{'d' defined here}}
-  const T da[5] = {T()}; // expected-note 2 {{'da' defined here}}
-  T qa[5] = {T()};
-  T i;
-  T &j = i;                        // expected-note 4 {{'j' defined here}}
-  S3 &p = k;                       // expected-note 2 {{'p' defined here}}
-  const T &r = da[(int)i];         // expected-note 2 {{'r' defined here}}
-  T &q = qa[(int)i];               // expected-note 2 {{'q' defined here}}
-  T fl;                            // expected-note {{'fl' defined here}}
-#pragma omp simd reduction // expected-error {{expected '(' after 'reduction'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction + // expected-error {{expected '(' after 'reduction'}} expected-warning {{extra tokens at the end of '#pragma omp simd' are ignored}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction( // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(- // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction() // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(*) // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(\) // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(& : argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(| : argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(|| : argc ? i : argc) // expected-error 2 {{expected variable name}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(foo : argc) //expected-error {{incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(&& : argc)
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(^ : T) // expected-error {{'T' does not refer to a value}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 3 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' or 'max' must be of arithmetic type}} expected-error 3 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(max : qa[1]) // expected-error 2 {{expected variable name}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(+ : ba) // expected-error {{a reduction variable with array type 'const S2 [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(* : ca) // expected-error {{a reduction variable with array type 'const S3 [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(- : da) // expected-error {{a reduction variable with array type 'const int [5]'}} expected-error {{a reduction variable with array type 'const float [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(^ : fl) // expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(+ : o) // expected-error {{variable of type 'class S6' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd private(i), reduction(+ : j), reduction(+ : q) // expected-error 4 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(+ : j), reduction(+ : q) // OK
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel private(k)
-#pragma omp simd reduction(+ : p), reduction(+ : p) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(+ : p), reduction(+ : p) // expected-error 3 {{variable can appear only once in OpenMP 'reduction' clause}} expected-note 3 {{previously referenced here}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(+ : r) // expected-error 2 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel shared(i)
-#pragma omp parallel reduction(min : i)
-#pragma omp simd reduction(max : j) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel private(fl)
-#pragma omp simd reduction(+ : fl)
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel reduction(* : fl)
-#pragma omp simd reduction(+ : fl)
-  for (int i = 0; i < 10; ++i)
-    foo();
-
-  return T();
-}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
 int main(int argc, char **argv) {
-  const int d = 5;       // expected-note 2 {{'d' defined here}}
-  const int da[5] = {0}; // expected-note {{'da' defined here}}
-  int qa[5] = {0};
+  const int d = 5; // expected-note 2 {{'d' defined here}}
+  const int da[5] = { 0 }; // expected-note {{'da' defined here}}
+  int qa[5] = { 0 };
   S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note {{'g' defined here}}
+  S5 g(5);
   int i;
-  int &j = i;                      // expected-note 2 {{'j' defined here}}
-  S3 &p = k;                       // expected-note 2 {{'p' defined here}}
-  const int &r = da[i];            // expected-note {{'r' defined here}}
-  int &q = qa[i];                  // expected-note {{'q' defined here}}
-  float fl;                        // expected-note {{'fl' defined here}}
-#pragma omp simd reduction // expected-error {{expected '(' after 'reduction'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction + // expected-error {{expected '(' after 'reduction'}} expected-warning {{extra tokens at the end of '#pragma omp simd' are ignored}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction( // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(- // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction() // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(*) // expected-warning {{missing ':' after reduction identifier - ignoring}} expected-error {{expected expression}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(\) // expected-error {{expected unqualified-id}} expected-warning {{missing ':' after reduction identifier - ignoring}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(foo : argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(| : argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(|| : argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(~ : argc) // expected-error {{expected unqualified-id}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(&& : argc)
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(^ : S1) // expected-error {{'S1' does not refer to a value}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' or 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(max : argv[1]) // expected-error {{expected variable name}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(+ : ba) // expected-error {{a reduction variable with array type 'const S2 [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(* : ca) // expected-error {{a reduction variable with array type 'const S3 [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(- : da) // expected-error {{a reduction variable with array type 'const int [5]'}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(^ : fl) // expected-error {{variable of type 'float' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{variable of type 'S5' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(+ : o) // expected-error {{variable of type 'class S6' is not valid for specified reduction operation}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd private(i), reduction(+ : j), reduction(+ : q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel private(k)
-#pragma omp simd reduction(+ : p), reduction(+ : p) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp simd reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel shared(i)
-#pragma omp parallel reduction(min : i)
-#pragma omp simd reduction(max : j) // expected-error {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel private(fl)
-#pragma omp simd reduction(+ : fl)
-  for (int i = 0; i < 10; ++i)
-    foo();
-#pragma omp parallel reduction(* : fl)
-#pragma omp simd reduction(+ : fl)
-  for (int i = 0; i < 10; ++i)
-    foo();
+  int &j = i; // expected-note {{'j' defined here}}
+  S3 &p = k;
+  const int &r = da[i]; // expected-note 2 {{'r' defined here}}
+  int &q = qa[i]; // expected-note {{'q' defined here}}
+  #pragma omp simd reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
+  for (int x = 0; x < 10; ++x) foo();
+  #pragma omp simd reduction // expected-error {{expected '(' after 'reduction'}} expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction + // expected-error {{expected '(' after 'reduction'}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction ( // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction (- // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction () // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction (*) // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction (\) // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction (&: argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction (| :argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction (|| :argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction (&& :argc)
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction (^ : S1) // expected-error {{'S1' does not refer to a value}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction (+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error {{'operator+=' is a private member of 'S2'}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction (min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' and 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction (max : argv[1]) // expected-error {{expected variable name}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction(+ : ba) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction(* : ca) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction(- : da) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{no viable overloaded '&='}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp simd reduction(+ : o) // expected-error {{no viable overloaded '+='}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel shared(i, j, q)
+  #pragma omp simd reduction(|| : i), reduction(+ : j), reduction(+:q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  for (int x = 0; x < 10; ++x) foo();
+  #pragma omp parallel private(i) 
+  #pragma omp simd reduction(|| : i) 
+  for (int x = 0; x < 10; ++x) foo();
+  #pragma omp parallel
+  #pragma omp simd private(i), reduction(|| : i) // expected-error {{private variable cannot be reduction}} expected-note 2 {{defined as private}}
+  for (i = 0; i < 10; ++i) foo(); // expected-error {{loop iteration variable may not be private}}
+  #pragma omp parallel
+  #pragma omp simd reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel
+  #pragma omp simd reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
+  for (i = 0; i < 10; ++i) foo();
+  #pragma omp parallel shared(i)
+  #pragma omp simd reduction(max : i) // expected-note {{defined as reduction}}
+  for (i = 0; i < 10; ++i) foo(); // expected-error {{loop iteration variable may not be reduction}}
 
-  return tmain(argc) + tmain(fl); // expected-note {{in instantiation of function template specialization 'tmain<int>' requested here}} expected-note {{in instantiation of function template specialization 'tmain<float>' requested here}}
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/simd_safelen_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/simd_safelen_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/simd_safelen_messages.cpp	2014-03-21 00:51:18.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/simd_safelen_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -verify -fopenmp %s
 
 void foo() {
 }
@@ -11,7 +11,7 @@
 
 template <class T, typename S, int N, int ST> // expected-note {{declared here}}
 T tmain(T argc, S **argv) { //expected-note 2 {{declared here}}
-  #pragma omp simd safelen // expected-error {{expected '(' after 'safelen'}}
+  #pragma omp simd safelen // expected-error {{expected '(' after 'safelen'}} // expected-error {{expected expression}}
   for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
   #pragma omp simd safelen ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
@@ -22,7 +22,7 @@
   // expected-note@+1 2 {{read of non-const variable 'argc' is not allowed in a constant expression}}
   #pragma omp simd safelen (argc 
   for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  // expected-error@+1 {{argument to 'safelen' clause must be a positive integer value}}
+  // expected-error@+1 {{expression is not a positive integer value}}
   #pragma omp simd safelen (ST // expected-error {{expected ')'}} expected-note {{to match this '('}}
   for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
   #pragma omp simd safelen (1)) // expected-warning {{extra tokens at the end of '#pragma omp simd' are ignored}}
@@ -30,7 +30,7 @@
   #pragma omp simd safelen ((ST > 0) ? 1 + ST : 2)
   for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
   // expected-error@+3 2 {{directive '#pragma omp simd' cannot contain more than one 'safelen' clause}}
-  // expected-error@+2 2 {{argument to 'safelen' clause must be a positive integer value}}
+  // expected-error@+2 2 {{expression is not a positive integer value}}
   // expected-error@+1 2 {{expression is not an integral constant expression}}
   #pragma omp simd safelen (foobool(argc)), safelen (true), safelen (-5)
   for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
@@ -41,13 +41,13 @@
   for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
   #pragma omp simd safelen (4)
   for (int i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
-  #pragma omp simd safelen (N) // expected-error {{argument to 'safelen' clause must be a positive integer value}}
+  #pragma omp simd safelen (N) // expected-error {{expression is not a positive integer value}}
   for (T i = ST; i < N; i++) argv[0][i] = argv[0][i] - argv[0][i-ST];
   return argc;
 }
 
 int main(int argc, char **argv) {
-  #pragma omp simd safelen // expected-error {{expected '(' after 'safelen'}}
+  #pragma omp simd safelen // expected-error {{expected '(' after 'safelen'}} expected-error {{expected expression}}
   for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
   #pragma omp simd safelen ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
@@ -61,7 +61,7 @@
   for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
   // expected-error@+3 {{expression is not an integral constant expression}}
   // expected-error@+2 2 {{directive '#pragma omp simd' cannot contain more than one 'safelen' clause}}
-  // expected-error@+1 2 {{argument to 'safelen' clause must be a positive integer value}}
+  // expected-error@+1 2 {{expression is not a positive integer value}}
   #pragma omp simd safelen (foobool(argc)), safelen (true), safelen (-5) 
   for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
   #pragma omp simd safelen (S1) // expected-error {{'S1' does not refer to a value}}
@@ -69,7 +69,7 @@
   // expected-error@+1 {{expression is not an integral constant expression}}
   #pragma omp simd safelen (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
   for (int i = 4; i < 12; i++) argv[0][i] = argv[0][i] - argv[0][i-4];
-  // expected-error@+3 {{statement after '#pragma omp simd' must be a for loop}}
+  // expected-error@+3 {{only for-loops are allowed for '#pragma omp simd'}}
   // expected-note@+1 {{in instantiation of function template specialization 'tmain<int, char, -1, -2>' requested here}}
   #pragma omp simd safelen(safelen(tmain<int, char, -1, -2>(argc, argv) // expected-error 2 {{expected ')'}} expected-note 2 {{to match this '('}}
   foo();
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/single_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/single_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/single_ast_print.cpp	2014-06-27 06:37:06.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/single_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
 // expected-no-diagnostics
 
 #ifndef HEADER
@@ -8,31 +8,23 @@
 
 void foo() {}
 
-template <class T, int N>
-T tmain(T argc) {
-  T b = argc, c, d, e, f, g;
-  static T a;
-// CHECK: static T a;
-#pragma omp parallel private(g)
-#pragma omp single private(argc, b), firstprivate(c, d), nowait copyprivate(g)
-  foo();
-  // CHECK-NEXT: #pragma omp parallel private(g)
-  // CHECK-NEXT: #pragma omp single private(argc,b) firstprivate(c,d) nowait copyprivate(g)
-  // CHECK-NEXT: foo();
-  return T();
-}
-
-int main(int argc, char **argv) {
+int main (int argc, char **argv) {
   int b = argc, c, d, e, f, g;
   static int a;
+  #pragma omp threadprivate(a)
 // CHECK: static int a;
-#pragma omp parallel private(g)
-#pragma omp single private(argc, b), firstprivate(argv, c), nowait copyprivate(g)
+// CHECK-NEXT: #pragma omp threadprivate(a)
+#pragma omp single
+  a=2;
+// CHECK-NEXT: #pragma omp single
+// CHECK-NEXT: a = 2;
+#pragma omp parallel
+#pragma omp single private(argc,b),firstprivate(argv, c),copyprivate(a) nowait
   foo();
-  // CHECK-NEXT: #pragma omp parallel private(g)
-  // CHECK-NEXT: #pragma omp single private(argc,b) firstprivate(argv,c) nowait copyprivate(g)
-  // CHECK-NEXT: foo();
-  return (tmain<int, 5>(argc) + tmain<char, 1>(argv[0][0]));
+// CHECK-NEXT: #pragma omp parallel
+// CHECK-NEXT: #pragma omp single private(argc,b) firstprivate(argv,c) copyprivate(a) nowait
+// CHECK-NEXT: foo();
+  return (0);
 }
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/single_copyprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/single_copyprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/single_copyprivate_messages.cpp	2014-06-27 06:37:06.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/single_copyprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,157 +1,87 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
 
-struct S1; // expected-note 2 {{declared here}}
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
 class S2 {
   mutable int a;
-
 public:
-  S2() : a(0) {}
-  S2 &operator=(S2 &s2) { return *this; }
+  S2():a(0) { }
+  S2 & operator =(S2 &s2) { return *this; }
 };
 class S3 {
   int a;
-
 public:
-  S3() : a(0) {}
-  S3 &operator=(S3 &s3) { return *this; }
+  S3():a(0) { }
+  S3 &operator =(S3 &s3) { return *this; }
 };
-class S4 { // expected-note 2 {{'S4' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
-  S4 &operator=(const S4 &s4);
-
+  S4 &operator =(const S4 &s4);
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
-class S5 { // expected-note 2 {{'S5' declared here}}
+class S5 { // expected-note {{'S5' declared here}}
   int a;
-  S5() : a(0) {}
-  S5 &operator=(const S5 &s5) { return *this; }
-
+  S5():a(0) {}
+  S5 &operator =(const S5 &s5) { return *this; }
 public:
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
 };
 
 S2 k;
 S3 h;
-S4 l(3); // expected-note 2 {{'l' defined here}}
-S5 m(4); // expected-note 2 {{'m' defined here}}
+S4 l(3); // expected-note {{'l' defined here}}
+S5 m(4); // expected-note {{'m' defined here}}
 #pragma omp threadprivate(h, k, l, m)
 
-template <class T, class C>
-T tmain(T argc, C **argv) {
-  T i;
-#pragma omp parallel
-#pragma omp single copyprivate // expected-error {{expected '(' after 'copyprivate'}}
-#pragma omp parallel
-#pragma omp single copyprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp parallel
-#pragma omp single copyprivate() // expected-error {{expected expression}}
-#pragma omp parallel
-#pragma omp single copyprivate(k // expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp parallel
-#pragma omp single copyprivate(h, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp parallel
-#pragma omp single copyprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-#pragma omp parallel
-#pragma omp single copyprivate(l) // expected-error {{copyprivate variable must have an accessible, unambiguous copy assignment operator}}
-#pragma omp parallel
-#pragma omp single copyprivate(S1) // expected-error {{'S1' does not refer to a value}}
-#pragma omp parallel
-#pragma omp single copyprivate(argv[1]) // expected-error {{expected variable name}}
-#pragma omp parallel // expected-note {{implicitly determined as shared}}
-#pragma omp single copyprivate(i) // expected-error {{copyprivate variable must be threadprivate or private in the enclosing context}}
-#pragma omp parallel
-#pragma omp single copyprivate(m) // expected-error {{copyprivate variable must have an accessible, unambiguous copy assignment operator}}
-  foo();
-#pragma omp parallel private(i)
-  {
-#pragma omp single copyprivate(i)
-    foo();
-  }
-#pragma omp parallel shared(i) // expected-note {{defined as shared}}
-  {
-#pragma omp single copyprivate(i) // expected-error {{copyprivate variable must be threadprivate or private in the enclosing context}}
-    foo();
-  }
-#pragma omp parallel private(i)
-#pragma omp parallel default(shared) // expected-note {{implicitly determined as shared}}
-  {
-#pragma omp single copyprivate(i) // expected-error {{copyprivate variable must be threadprivate or private in the enclosing context}}
-    foo();
-  }
-#pragma omp parallel private(i)
-#pragma omp parallel // expected-note {{implicitly determined as shared}}
-  {
-#pragma omp single copyprivate(i) // expected-error {{copyprivate variable must be threadprivate or private in the enclosing context}}
-    foo();
-  }
-#pragma omp parallel
-#pragma omp single private(i) copyprivate(i) // expected-error {{private variable cannot be copyprivate}} expected-note {{defined as private}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(i) copyprivate(i) // expected-error {{firstprivate variable cannot be copyprivate}} expected-note {{defined as firstprivate}}
-  foo();
-
-  return T();
-}
-
 int main(int argc, char **argv) {
   int i;
-#pragma omp parallel
-#pragma omp single copyprivate // expected-error {{expected '(' after 'copyprivate'}}
-#pragma omp parallel
-#pragma omp single copyprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp parallel
-#pragma omp single copyprivate() // expected-error {{expected expression}}
-#pragma omp parallel
-#pragma omp single copyprivate(k // expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp parallel
-#pragma omp single copyprivate(h, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp parallel
-#pragma omp single copyprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-#pragma omp parallel
-#pragma omp single copyprivate(l) // expected-error {{copyprivate variable must have an accessible, unambiguous copy assignment operator}}
-#pragma omp parallel
-#pragma omp single copyprivate(S1) // expected-error {{'S1' does not refer to a value}}
-#pragma omp parallel
-#pragma omp single copyprivate(argv[1]) // expected-error {{expected variable name}}
-#pragma omp parallel // expected-note {{implicitly determined as shared}}
-#pragma omp single copyprivate(i) // expected-error {{copyprivate variable must be threadprivate or private in the enclosing context}}
-#pragma omp parallel
-#pragma omp single copyprivate(m) // expected-error {{copyprivate variable must have an accessible, unambiguous copy assignment operator}}
+  #pragma omp parallel
+  #pragma omp single copyprivate // expected-error {{expected '(' after 'copyprivate'}} expected-error {{expected expression}}
+  #pragma omp parallel
+  #pragma omp single copyprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp single copyprivate () // expected-error {{expected expression}}
+  #pragma omp parallel
+  #pragma omp single copyprivate (k // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp single copyprivate (h, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp single copyprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  #pragma omp parallel
+  #pragma omp single copyprivate (l) // expected-error {{copyprivate variable must have an accessible, unambiguous copy assignment operator}}
+  #pragma omp parallel
+  #pragma omp single copyprivate (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp parallel
+  #pragma omp single copyprivate (argv[1]) // expected-error {{expected variable name}}
+  #pragma omp parallel
+  #pragma omp single copyprivate(i) // expected-error {{copyprivate variable must be threadprivate or private in the enclosing context}}
+  #pragma omp parallel
+  #pragma omp single copyprivate(m) // expected-error {{copyprivate variable must have an accessible, unambiguous copy assignment operator}}
   foo();
-#pragma omp parallel private(i)
+  #pragma omp parallel private(i)
   {
-#pragma omp single copyprivate(i)
+    #pragma omp single copyprivate(i)
     foo();
   }
-#pragma omp parallel shared(i) // expected-note {{defined as shared}}
+  #pragma omp parallel shared(i) // expected-note {{defined as shared}}
   {
-#pragma omp single copyprivate(i) // expected-error {{copyprivate variable must be threadprivate or private in the enclosing context}}
+    #pragma omp single copyprivate(i) // expected-error {{copyprivate variable must be threadprivate or private in the enclosing context}}
     foo();
   }
-#pragma omp parallel private(i)
-#pragma omp parallel default(shared) // expected-note {{implicitly determined as shared}}
+  #pragma omp parallel private(i)
+  #pragma omp parallel default(shared)
   {
-#pragma omp single copyprivate(i) // expected-error {{copyprivate variable must be threadprivate or private in the enclosing context}}
+    #pragma omp single copyprivate(i) // expected-error {{copyprivate variable must be threadprivate or private in the enclosing context}}
     foo();
   }
-#pragma omp parallel private(i)
-#pragma omp parallel // expected-note {{implicitly determined as shared}}
-  {
-#pragma omp single copyprivate(i) // expected-error {{copyprivate variable must be threadprivate or private in the enclosing context}}
-    foo();
-  }
-#pragma omp parallel
-#pragma omp single private(i) copyprivate(i) // expected-error {{private variable cannot be copyprivate}} expected-note {{defined as private}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(i) copyprivate(i) // expected-error {{firstprivate variable cannot be copyprivate}} expected-note {{defined as firstprivate}}
-  foo();
 
-  return tmain(argc, argv); // expected-note {{in instantiation of function template specialization 'tmain<int, char>' requested here}}
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/single_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/single_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/single_firstprivate_messages.cpp	2014-06-26 08:05:45.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/single_firstprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,14 +7,13 @@
   return argc;
 }
 
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
-
 public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
   static float S2s;
   static const float S2sc;
 };
@@ -23,217 +22,91 @@
 const S2 ba[5];
 class S3 {
   int a;
-  S3 &operator=(const S3 &s3);
-
 public:
-  S3() : a(0) {}
-  S3(S3 &s3) : a(s3.a) {}
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
 };
 const S3 c;
 const S3 ca[5];
 extern const int f;
-class S4 { // expected-note 2 {{'S4' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
   S4(const S4 &s4);
-
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
-class S5 { // expected-note 4 {{'S5' declared here}}
+class S5 { // expected-note {{'S5' declared here}}
   int a;
-  S5(const S5 &s5) : a(s5.a) {}
-
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
 public:
-  S5() : a(0) {}
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
 };
 class S6 {
   int a;
-  S6() : a(0) {}
-
 public:
-  S6(const S6 &s6) : a(s6.a) {}
-  S6(int v) : a(v) {}
+  S6() : a(0) { }
 };
 
 S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class I, class C>
-int foomain(int argc, char **argv) {
-  I e(4); // expected-note {{'e' defined here}}
-  C g(5); // expected-note 2 {{'g' defined here}}
-  int i;
-  int &j = i; // expected-note {{'j' defined here}}
-#pragma omp parallel
-#pragma omp single firstprivate // expected-error {{expected '(' after 'firstprivate'}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate() // expected-error {{expected expression}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(argc)
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(a, b) // expected-error {{firstprivate variable with incomplete type 'S1'}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(argv[1]) // expected-error {{expected variable name}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
-  foo();
-#pragma omp parallel
-#pragma omp single linear(i) // expected-error {{unexpected OpenMP clause 'linear' in directive '#pragma omp single'}}
-  foo();
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;                         // expected-note {{variable with automatic storage duration is predetermined as private; perhaps you forget to enclose 'omp single' directive into a parallel or another task region?}}
-#pragma omp single firstprivate(i) // expected-error {{private variable cannot be firstprivate}}
-    foo();
-    v += i;
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp single firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(i)
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(g) // expected-error {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  foo();
-#pragma omp parallel private(i)    // expected-note {{defined as private}}
-#pragma omp single firstprivate(i) // expected-error {{firstprivate variable must be shared}}
-  foo();
-#pragma omp parallel reduction(+ : i) // expected-note {{defined as reduction}}
-#pragma omp single firstprivate(i)    // expected-error {{firstprivate variable must be shared}}
-  foo();
-  return 0;
-}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
 int main(int argc, char **argv) {
   const int d = 5;
-  const int da[5] = {0};
+  const int da[5] = { 0 };
   S4 e(4); // expected-note {{'e' defined here}}
-  S5 g(5); // expected-note 2 {{'g' defined here}}
-  S3 m;
-  S6 n(2);
+  S5 g(5); // expected-note {{'g' defined here}}
+  S6 p;
   int i;
   int &j = i; // expected-note {{'j' defined here}}
-#pragma omp parallel
-#pragma omp single firstprivate // expected-error {{expected '(' after 'firstprivate'}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate() // expected-error {{expected expression}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(argc)
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(S1) // expected-error {{'S1' does not refer to a value}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(argv[1]) // expected-error {{expected variable name}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(2 * 2) // expected-error {{expected variable name}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(ba) // OK
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(ca) // OK
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(da) // OK
+  #pragma omp single firstprivate // expected-error {{expected '(' after 'firstprivate'}} expected-error {{expected expression}}
+  #pragma omp parallel
+  #pragma omp single firstprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp single firstprivate () // expected-error {{expected expression}}
+  #pragma omp parallel
+  #pragma omp single firstprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp single firstprivate (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp single firstprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  #pragma omp parallel
+  #pragma omp single firstprivate (argc)
+  #pragma omp parallel
+  #pragma omp single firstprivate (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp parallel
+  #pragma omp single firstprivate (a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
+  #pragma omp parallel
+  #pragma omp single firstprivate (argv[1]) // expected-error {{expected variable name}}
+  #pragma omp parallel
+  #pragma omp single firstprivate(ba)
+  #pragma omp parallel
+  #pragma omp single firstprivate(ca)
+  #pragma omp parallel
+  #pragma omp single firstprivate(da)
+  #pragma omp parallel
+  #pragma omp single firstprivate(S2::S2s)
+  #pragma omp parallel
+  #pragma omp single firstprivate(S2::S2sc)
+  #pragma omp parallel
+  #pragma omp single firstprivate(e, g, p) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
+  #pragma omp parallel
+  #pragma omp single firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
+  #pragma omp parallel
+  #pragma omp single private(i), firstprivate(i) // expected-error {{private variable cannot be firstprivate}} expected-note{{defined as private}}
+  foo();
+  #pragma omp parallel shared(i)
+  #pragma omp single firstprivate(i)
   foo();
-  int xa;
-#pragma omp parallel
-#pragma omp single firstprivate(xa) // OK
+  #pragma omp parallel private(i) // expected-note {{defined as private}}
+  #pragma omp single firstprivate(i) // expected-error {{private variable in '#pragma omp parallel' cannot be firstprivate in '#pragma omp single'}}
   foo();
-#pragma omp parallel
-#pragma omp single firstprivate(S2::S2s) // OK
+  #pragma omp parallel reduction(+:i) // expected-note {{defined as reduction}}
+  #pragma omp single firstprivate(i) // expected-error {{reduction variable in '#pragma omp parallel' cannot be firstprivate in '#pragma omp single'}}
   foo();
-#pragma omp parallel
-#pragma omp single firstprivate(S2::S2sc) // OK
-  foo();
-#pragma omp parallel
-#pragma omp single safelen(5) // expected-error {{unexpected OpenMP clause 'safelen' in directive '#pragma omp single'}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(m) // OK
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
-  foo();
-#pragma omp parallel
-#pragma omp single private(xa), firstprivate(xa) // expected-error {{private variable cannot be firstprivate}} expected-note {{defined as private}}
-  foo();
-#pragma omp parallel shared(xa)
-#pragma omp single firstprivate(xa) // OK: may be firstprivate
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(g) // expected-error {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-  foo();
-#pragma omp parallel
-#pragma omp single firstprivate(n) // OK
-  foo();
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;                         // expected-note {{variable with automatic storage duration is predetermined as private; perhaps you forget to enclose 'omp single' directive into a parallel or another task region?}}
-#pragma omp single firstprivate(i) // expected-error {{private variable cannot be firstprivate}}
-    foo();
-    v += i;
-  }
-#pragma omp parallel private(i)    // expected-note {{defined as private}}
-#pragma omp single firstprivate(i) // expected-error {{firstprivate variable must be shared}}
-  foo();
-#pragma omp parallel reduction(+ : i) // expected-note {{defined as reduction}}
-#pragma omp single firstprivate(i)    // expected-error {{firstprivate variable must be shared}}
+  #pragma omp single firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
   foo();
 
-  return foomain<S4, S5>(argc, argv); // expected-note {{in instantiation of function template specialization 'foomain<S4, S5>' requested here}}
-}
+  return 0;
+}
\ No newline at end of file
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/single_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/single_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/single_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/single_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,70 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int foo();
+
+int main() {
+  #pragma omp single
+  ;
+  #pragma omp single nowait nowait // expected-error {{directive '#pragma omp single' cannot contain more than one 'nowait' clause}}
+  foo();
+  {
+    #pragma omp single
+  } // expected-error {{expected statement}}
+  #pragma omp for
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp single // expected-error {{region cannot be closely nested inside a worksharing region}}
+    foo();
+  }
+  #pragma omp sections
+  {
+    foo();
+    #pragma omp single // expected-error {{region cannot be closely nested inside a worksharing region}}
+    foo();
+  }
+  #pragma omp single
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp single // expected-error {{region cannot be closely nested inside a worksharing region}}
+    foo();
+  }
+  #pragma omp master
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp single // expected-error {{region cannot be closely nested inside a master region}}
+    foo();
+  }
+  #pragma omp critical
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp single // expected-error {{region cannot be closely nested inside a critical region}}
+    foo();
+  }
+  #pragma omp for ordered
+  for (int i = 0; i < 10; ++i)
+  #pragma omp ordered
+  {
+    foo();
+    #pragma omp single // expected-error {{region cannot be closely nested inside an ordered region}}
+    foo();
+  }
+  return 0;
+}
+
+int foo() {
+  L1:
+    foo();
+  #pragma omp single
+  {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+  #pragma omp single
+  {
+    L2:
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/single_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/single_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/single_misc_messages.c	2014-07-20 22:45:36.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/single_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,156 +0,0 @@
-// RUN: %clang_cc1 -fsyntax-only -fopenmp=libiomp5 -verify %s
-
-void foo();
-
-// expected-error@+1 {{unexpected OpenMP directive '#pragma omp single'}}
-#pragma omp single
-
-// expected-error@+1 {{unexpected OpenMP directive '#pragma omp single'}}
-#pragma omp single foo
-
-void test_no_clause() {
-  int i;
-#pragma omp single
-  foo();
-
-#pragma omp single
-  ++i;
-}
-
-void test_branch_protected_scope() {
-  int i = 0;
-L1:
-  ++i;
-
-  int x[24];
-
-#pragma omp parallel
-#pragma omp single
-  {
-    if (i == 5)
-      goto L1; // expected-error {{use of undeclared label 'L1'}}
-    else if (i == 6)
-      return; // expected-error {{cannot return from OpenMP region}}
-    else if (i == 7)
-      goto L2;
-    else if (i == 8) {
-    L2:
-      x[i]++;
-    }
-  }
-
-  if (x[0] == 0)
-    goto L2; // expected-error {{use of undeclared label 'L2'}}
-  else if (x[1] == 1)
-    goto L1;
-}
-
-void test_invalid_clause() {
-  int i;
-#pragma omp parallel
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp single' are ignored}}
-#pragma omp single foo bar
-  foo();
-}
-
-void test_non_identifiers() {
-  int i, x;
-
-#pragma omp parallel
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp single' are ignored}}
-#pragma omp single;
-  foo();
-#pragma omp parallel
-// expected-error@+2 {{unexpected OpenMP clause 'linear' in directive '#pragma omp single'}}
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp single' are ignored}}
-#pragma omp single linear(x);
-  foo();
-
-#pragma omp parallel
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp single' are ignored}}
-#pragma omp single private(x);
-  foo();
-
-#pragma omp parallel
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp single' are ignored}}
-#pragma omp single, private(x);
-  foo();
-}
-
-void test_private() {
-  int i;
-#pragma omp parallel
-// expected-error@+2 {{expected expression}}
-// expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
-#pragma omp single private(
-  foo();
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp single private(,
-  foo();
-#pragma omp parallel
-// expected-error@+1 2 {{expected expression}}
-#pragma omp single private(, )
-  foo();
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp single private()
-  foo();
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp single private(int)
-  foo();
-#pragma omp parallel
-// expected-error@+1 {{expected variable name}}
-#pragma omp single private(0)
-  foo();
-
-  int x, y, z;
-#pragma omp parallel
-#pragma omp single private(x)
-  foo();
-#pragma omp parallel
-#pragma omp single private(x, y)
-  foo();
-#pragma omp parallel
-#pragma omp single private(x, y, z)
-  foo();
-}
-
-void test_firstprivate() {
-  int i;
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 {{expected expression}}
-#pragma omp single firstprivate(
-  foo();
-
-#pragma omp parallel
-// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
-// expected-error@+1 2 {{expected expression}}
-#pragma omp single firstprivate(,
-  foo();
-#pragma omp parallel
-// expected-error@+1 2 {{expected expression}}
-#pragma omp single firstprivate(, )
-  foo();
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp single firstprivate()
-  foo();
-#pragma omp parallel
-// expected-error@+1 {{expected expression}}
-#pragma omp single firstprivate(int)
-  foo();
-#pragma omp parallel
-// expected-error@+1 {{expected variable name}}
-#pragma omp single firstprivate(0)
-  foo();
-}
-
-void test_nowait() {
-#pragma omp single nowait nowait // expected-error {{directive '#pragma omp single' cannot contain more than one 'nowait' clause}}
-  for (int i = 0; i < 16; ++i)
-    ;
-}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/single_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/single_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/single_private_messages.cpp	2014-06-26 08:05:45.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/single_private_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -7,134 +7,113 @@
   return argc;
 }
 
-struct S1; // expected-note 2 {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
 extern S1 a;
 class S2 {
   mutable int a;
-
 public:
-  S2() : a(0) {}
+  S2():a(0) { }
+  static float S2s; // expected-note {{predetermined as shared}}
 };
 const S2 b;
 const S2 ba[5];
 class S3 {
   int a;
-
 public:
-  S3() : a(0) {}
+  S3():a(0) { }
 };
-const S3 ca[5];
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f;  // expected-note {{predetermined as shared}}
 class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
-
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
 class S5 { // expected-note {{'S5' declared here}}
   int a;
-  S5() : a(0) {}
-
+  S5():a(0) {}
 public:
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
 };
 
 S3 h;
-#pragma omp threadprivate(h) // expected-note 2 {{defined as threadprivate or thread local}}
-
-template <class I, class C>
-int foomain(I argc, C **argv) {
-  I e(4);
-  I g(5);
-  int i;
-  int &j = i;                // expected-note {{'j' defined here}}
-#pragma omp single private // expected-error {{expected '(' after 'private'}}
-  foo();
-#pragma omp single private( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp single private() // expected-error {{expected expression}}
-  foo();
-#pragma omp single private(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp single private(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp single private(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  foo();
-#pragma omp single private(argc)
-  foo();
-#pragma omp single private(S1) // expected-error {{'S1' does not refer to a value}}
-  foo();
-#pragma omp single private(a, b) // expected-error {{private variable with incomplete type 'S1'}}
-  foo();
-#pragma omp single private(argv[1]) // expected-error {{expected variable name}}
-  foo();
-#pragma omp single private(e, g)
-  foo();
-#pragma omp single private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
-  foo();
-#pragma omp single shared(i) // expected-error {{unexpected OpenMP clause 'shared' in directive '#pragma omp single'}}
-  foo();
-#pragma omp parallel
-  {
-    int v = 0;
-    int i;
-#pragma omp single private(i)
-    foo();
-    v += i;
-  }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp single private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
-  foo();
-#pragma omp single private(i)
-  foo();
-  return 0;
-}
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
 int main(int argc, char **argv) {
+  const int d = 5;  // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
   S4 e(4); // expected-note {{'e' defined here}}
   S5 g(5); // expected-note {{'g' defined here}}
   int i;
-  int &j = i;                // expected-note {{'j' defined here}}
-#pragma omp single private // expected-error {{expected '(' after 'private'}}
-  foo();
-#pragma omp single private( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp single private() // expected-error {{expected expression}}
-  foo();
-#pragma omp single private(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp single private(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp single private(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  foo();
-#pragma omp single private(argc)
-  foo();
-#pragma omp single private(S1) // expected-error {{'S1' does not refer to a value}}
-  foo();
-#pragma omp single private(a, b) // expected-error {{private variable with incomplete type 'S1'}}
-  foo();
-#pragma omp single private(argv[1]) // expected-error {{expected variable name}}
-  foo();
-#pragma omp single private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp single private // expected-error {{expected '(' after 'private'}} expected-error {{expected expression}}
+  #pragma omp parallel
+  #pragma omp single private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp single private () // expected-error {{expected expression}}
+  #pragma omp parallel
+  #pragma omp single private (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp single private (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp parallel
+  #pragma omp single private (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  #pragma omp parallel
+  #pragma omp single private (argc)
+  #pragma omp parallel
+  #pragma omp single private (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp parallel
+  #pragma omp single private (a, b, c, d, f) // expected-error {{private variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be private}}
+  #pragma omp parallel
+  #pragma omp single private (argv[1]) // expected-error {{expected variable name}}
+  #pragma omp parallel
+  #pragma omp single private(ba)
+  #pragma omp parallel
+  #pragma omp single private(ca) // expected-error {{shared variable cannot be private}}
+  #pragma omp parallel
+  #pragma omp single private(da) // expected-error {{shared variable cannot be private}}
+  #pragma omp parallel
+  #pragma omp single private(S2::S2s) // expected-error {{shared variable cannot be private}}
+  #pragma omp parallel
+  #pragma omp single private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
+  #pragma omp parallel
+  #pragma omp single private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
+  #pragma omp parallel
+  #pragma omp single shared(i) // expected-error {{unexpected OpenMP clause 'shared' in directive '#pragma omp single'}}
+  #pragma omp parallel
+  #pragma omp single firstprivate(i), private(i) // expected-error {{firstprivate variable cannot be private}} expected-note {{defined as firstprivate}}
+  foo();
+  #pragma omp parallel shared(i)
+  #pragma omp parallel private(i)
+  #pragma omp single private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
+  foo();
+  #pragma omp parallel shared(i)
+  #pragma omp parallel private(i)
+  #pragma omp parallel firstprivate(i)
+  #pragma omp parallel reduction(+:i)
+  #pragma omp single private(i)
   foo();
-#pragma omp single private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
-  foo();
-#pragma omp single shared(i) // expected-error {{unexpected OpenMP clause 'shared' in directive '#pragma omp single'}}
-  foo();
-#pragma omp parallel
+  #pragma omp single private(i)
   {
-    int i;
-#pragma omp single private(i)
+    #pragma omp parallel
+    #pragma omp single private(i)
+    foo();
+  }
+  #pragma omp parallel
+  #pragma omp single firstprivate(i)
+  {
+    #pragma omp parallel
+    #pragma omp single private(i)
+    foo();
+  }
+  #pragma omp parallel private(i)
+  #pragma omp single copyprivate(i)
+  {
+    #pragma omp parallel
+    #pragma omp single private(i)
     foo();
   }
-#pragma omp parallel shared(i)
-#pragma omp parallel private(i)
-#pragma omp single private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
-  foo();
-#pragma omp single private(i)
-  foo();
 
   return 0;
-}
-
+}
\ No newline at end of file
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/target_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/target_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,26 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  static int a;
+// CHECK: static int a;
+#pragma omp target
+// CHECK:      #pragma omp target
+  a=2;
+// CHECK-NEXT: a = 2;
+#pragma omp target if(b) device(c+e) map(b,c) map(to:d) map(from:e) map(alloc:f) map(tofrom: g)
+// CHECK:      #pragma omp target if(b) device(c + e) map(tofrom: b,c) map(to: d) map(from: e) map(alloc: f) map(tofrom: g)
+  foo();
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_data_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/target_data_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/target_data_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_data_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,26 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  static int a;
+// CHECK: static int a;
+#pragma omp target data
+// CHECK:      #pragma omp target data
+  a=2;
+// CHECK-NEXT: a = 2;
+#pragma omp target data if(b) device(c+e) map(b,c) map(to:d) map(from:e) map(alloc:f) map(tofrom: g)
+// CHECK:      #pragma omp target data if(b) device(c + e) map(tofrom: b,c) map(to: d) map(from: e) map(alloc: f) map(tofrom: g)
+  foo();
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_data_device_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_data_device_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_data_device_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_data_device_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,42 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target data device // expected-error {{expected '(' after 'device'}} expected-error {{expected expression}}
+  #pragma omp target data device ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target data device () // expected-error {{expected expression}}
+  #pragma omp target data device (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target data device (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  #pragma omp target data device (foobool(argc)) device(3) // expected-error {{directive '#pragma omp target data' cannot contain more than one 'device' clause}}
+  #pragma omp target data device (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp target data device (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  #pragma omp target data device (v1) // expected-error {{expression has incomplete type 'S1'}}
+  #pragma omp target data device (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  #pragma omp target data device (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  #pragma omp target data device (0)
+  #pragma omp target data device (-1) // expected-error {{expression is not a positive integer value}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_data_if_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_data_if_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_data_if_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_data_if_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,25 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+int main(int argc, char **argv) {
+  #pragma omp target data if // expected-error {{expected '(' after 'if'}} expected-error {{expected expression}}
+  #pragma omp target data if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target data if () // expected-error {{expected expression}}
+  #pragma omp target data if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target data if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp target data' are ignored}}
+  #pragma omp target data if (argc > 0 ? argv[1] : argv[2])
+  #pragma omp target data if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp target data' cannot contain more than one 'if' clause}}
+  #pragma omp target data if (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp target data if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_data_map_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_data_map_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_data_map_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_data_map_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,94 @@
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note 2 {{mappable type cannot contain static members}}
+  static const float S2sc; // expected-note 2 {{mappable type cannot contain static members}}
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-error {{threadprivate variables cannot be used in target constructs}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  int *k = &j;
+  const int (&l)[5] = da;
+  #pragma omp target data map // expected-error {{expected '(' after 'map'}} expected-error {{expected expression}}
+  #pragma omp target data map ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target data map () // expected-error {{expected expression}}
+  #pragma omp target data map (alloc) // expected-error {{expected expression}}  expected-error {{expected ':' in 'map' clause}}
+  #pragma omp target data map (to argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error{{expected ':' in 'map' clause}}
+  #pragma omp target data map (from: argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target data map (tofrom: argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  #pragma omp target data map (argc)
+  #pragma omp target data map (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp target data map (a, b, c, d, f) // expected-error {{incomplete type 'S1' where a complete type is required}} expected-error 2 {{type 'S2' is not mappable to target}}
+  #pragma omp target data map (argv[1])
+  #pragma omp target data map(ba) // expected-error 2 {{type 'S2' is not mappable to target}}
+  #pragma omp target data map(ca)
+  #pragma omp target data map(da)
+  #pragma omp target data map(S2::S2s)
+  #pragma omp target data map(S2::S2sc)
+  #pragma omp target data map(e, g)
+  #pragma omp target data map(h) // expected-note {{used here}}
+  #pragma omp target data map(k), map(k[:10]) // expected-error {{variable already marked as mapped in current construct}} expected-note {{used here}}
+  foo();
+  #pragma omp target data map(da)
+  #pragma omp target data map(da[:4])
+  foo();
+  #pragma omp target data map(k, j, l) // expected-note 2 {{used here}}
+  #pragma omp target data map(k[:4]) // expected-error {{variable already marked as mapped in current construct}}
+  #pragma omp target data map(j)
+  #pragma omp target data map(l[:5]) // expected-error {{variable already marked as mapped in current construct}}
+  foo();
+  #pragma omp target data map(k[:4], j, l[:5]) // expected-note 2 {{used here}}
+  #pragma omp target data map(k) // expected-error {{variable already marked as mapped in current construct}}
+  #pragma omp target data map(j)
+  #pragma omp target data map(l) // expected-error {{variable already marked as mapped in current construct}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_data_messages.c cfe-3.5.0.src.omp/test/OpenMP/target_data_messages.c
--- cfe-3.5.0.src/test/OpenMP/target_data_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_data_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,19 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() { }
+
+int main(int argc, char **argv) {
+  L1:
+    foo();
+  #pragma omp target data
+  {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+  #pragma omp target data
+  L2:
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_device_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_device_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_device_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_device_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,42 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target device // expected-error {{expected '(' after 'device'}} expected-error {{expected expression}}
+  #pragma omp target device ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target device () // expected-error {{expected expression}}
+  #pragma omp target device (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target device (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  #pragma omp target device (foobool(argc)) device(3) // expected-error {{directive '#pragma omp target' cannot contain more than one 'device' clause}}
+  #pragma omp target device (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp target device (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  #pragma omp target device (v1) // expected-error {{expression has incomplete type 'S1'}}
+  #pragma omp target device (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  #pragma omp target device (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  #pragma omp target device (0)
+  #pragma omp target device (-1) // expected-error {{expression is not a positive integer value}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_driver_and_codegen.c cfe-3.5.0.src.omp/test/OpenMP/target_driver_and_codegen.c
--- cfe-3.5.0.src/test/OpenMP/target_driver_and_codegen.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_driver_and_codegen.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,199 @@
+///
+/// Perform several offloading tests for the driver and codegen of OpenMP target
+/// regions
+///
+
+/// Check whether an invalid OpenMP target is specified:
+// RUN:   %clang -### -fopenmp -omptargets=aaa-bbb-ccc-ddd %s 2>&1 \
+// RUN:   | FileCheck -check-prefix=CHK-INVALID-TARGET %s
+// CHK-INVALID-TARGET: error: OpenMP target is invalid: 'aaa-bbb-ccc-ddd'
+
+/// Check error for empty -omptargets
+// RUN:   %clang -### -fopenmp -omptargets=  %s 2>&1 \
+// RUN:   | FileCheck -check-prefix=CHK-EMPTY-OMPTARGETS %s
+// CHK-EMPTY-OMPTARGETS: warning: joined argument expects additional value: '-omptargets='
+
+/// Check whether we are using a target whose toolchain was not prepared to
+/// to support offloading:
+// RUN:   %clang -### -fopenmp -omptargets=x86_64-apple-darwin %s 2>&1 \
+// RUN:   | FileCheck -check-prefix=CHK-NO-SUPPORT %s
+// CHK-NO-SUPPORT: error: Toolchain for target 'x86_64-apple-darwin' is not supporting OpenMP offloading.
+
+/// Target independent check of the commands passed to each tool when using
+/// valid OpenMP targets
+// RUN:   %clang -### -fopenmp -target powerpc64-linux -omptargets=powerpc64-ibm-linux-gnu,nvptx64-nvidia-cuda %s 2>&1 \
+// RUN:   | FileCheck -check-prefix=CHK-COMMANDS %s
+//
+// Host commands
+// CHK-COMMANDS: clang{{.*}}" "-cc1" "-fopenmp" "-omptargets=powerpc64-ibm-linux-gnu,nvptx64-nvidia-cuda" "-omp-main-file-path" "[[SRC:[^ ]+]].c"
+// CHK-COMMANDS: "-E"
+// CHK-COMMANDS: "-o" "[[PP:.+]].i"
+// CHK-COMMANDS: "-x" "c" "[[SRC]].c"
+// CHK-COMMANDS: clang{{.*}}" "-cc1" "-fopenmp" "-omptargets=powerpc64-ibm-linux-gnu,nvptx64-nvidia-cuda" "-omp-main-file-path" "[[SRC:[^ ]+]].c"
+// CHK-COMMANDS: "-S"
+// CHK-COMMANDS: "-o" "[[HOSTASM:.+]].s"
+// CHK-COMMANDS: "-x" "cpp-output" "[[PP]].i"
+// CHK-COMMANDS: as" "-a64" "-mppc64" "-many" "-o" "[[HOSTOBJ:.+]].o" "[[HOSTASM]].s"
+
+// Target1 commands
+// CHK-COMMANDS: clang{{.*}}" "-cc1" "-fopenmp" "-omptargets=powerpc64-ibm-linux-gnu,nvptx64-nvidia-cuda" "-omp-target-mode" "-omp-main-file-path" "[[SRC]].c" "-triple" "nvptx64-nvidia-cuda" "-S"
+// CHK-COMMANDS: "-target-cpu" "sm_20"
+// CHK-COMMANDS: "-o" "[[T1ASM:.+]].s" "-x" "cpp-output" "[[PP]].i"
+// CHK-COMMANDS: ptxas" "-o" "[[T1OBJ:.+]].o" "-c" "-arch" "sm_20" "[[T1ASM]].s"
+// CHK-COMMANDS: cp" "[[T1OBJ]].o" "[[T1CBIN:.+]].cubin"
+// CHK-COMMANDS: nvlink" "-o" "[[T1LIB:.+]].so" "-arch" "sm_20" "[[T1CBIN]].cubin"
+
+// Target2 command
+// CHK-COMMANDS: clang{{.*}}" "-cc1" "-fopenmp" "-omptargets=powerpc64-ibm-linux-gnu,nvptx64-nvidia-cuda" "-omp-target-mode" "-omp-main-file-path" "[[SRC]].c" "-triple" "powerpc64-ibm-linux-gnu" "-S"
+// CHK-COMMANDS: "-target-cpu" "ppc64"
+// CHK-COMMANDS: "-o" "[[T2ASM:.+]].s" "-x" "cpp-output" "[[PP]].i"
+// CHK-COMMANDS: as" "-a64" "-mppc64" "-many" "-o" "[[T2OBJ:.+]].o" "[[T2ASM]].s"
+// CHK-COMMANDS: ld" "--eh-frame-hdr" "-m" "elf64ppc" "-shared" "-o" "[[T2LIB:.+]].so" {{.*}} "[[T2OBJ]].o"
+
+// Final linking command
+// CHK-COMMANDS: ld" {{.*}} "-o" "a.out"  {{.*}}  "[[HOSTOBJ]].o" "-liomp5" "-lomptarget" {{.*}} "-T" "[[LKSCRIPT:.+]].lk"
+
+/// Check frontend require main file name
+// RUN:   not %clang_cc1 "-fopenmp" "-omptargets=powerpc64-ibm-linux-gnu,nvptx64-nvidia-cuda" "-triple" "powerpc64-ibm-linux-gnu" %s 2>&1 \
+// RUN:   | FileCheck -check-prefix=CHK-MAINFILE %s
+// RUN:   not %clang_cc1 "-fopenmp" "-omptargets=powerpc64-ibm-linux-gnu,nvptx64-nvidia-cuda" "-omp-target-mode" "-triple" "nvptx64-nvidia-cuda" %s 2>&1 \
+// RUN:   | FileCheck -check-prefix=CHK-MAINFILE %s
+// CHK-MAINFILE: error: Main-file path is required to generate code for OpenMP target regions. Use -omp-main-file-path 'path'.
+
+/// Check frontend module ID error
+// RUN:   not %clang_cc1 "-fopenmp" "-omptargets=powerpc64-ibm-linux-gnu,nvptx64-nvidia-cuda" "-triple" "powerpc64-ibm-linux-gnu" "-omp-main-file-path" "abcd.efgh" %s 2>&1 \
+// RUN:   | FileCheck -check-prefix=CHK-MODULEID %s
+// RUN:   not %clang_cc1 "-fopenmp" "-omptargets=powerpc64-ibm-linux-gnu,nvptx64-nvidia-cuda" "-omp-target-mode" "-triple" "nvptx64-nvidia-cuda" %s "-omp-main-file-path" "abcd.efgh" 2>&1 \
+// RUN:   | FileCheck -check-prefix=CHK-MODULEID %s
+// CHK-MODULEID: error: Unable to generate module ID from input file 'abcd.efgh' for OpenMP target code generation. Make sure the file exists in the file system.
+
+/// Check the subtarget detection
+// RUN:   %clang -### -fopenmp -target powerpc64-linux -omptargets=nvptx64sm_35-nvidia-cuda %s 2>&1 \
+// RUN:   | FileCheck -check-prefix=CHK-SUBTARGET %s
+// CHK-SUBTARGET: clang{{.*}}" "-cc1" "-fopenmp" "-omptargets=nvptx64sm_35-nvidia-cuda" "-omp-target-mode" "-omp-main-file-path" {{.*}} "-triple" "nvptx64sm_35-nvidia-cuda" "-S"
+// CHK-SUBTARGET: "-target-cpu" "sm_35"
+// CHK-SUBTARGET: "-o" "[[ASM:.+]].s"
+// CHK-SUBTARGET: "-x" "cpp-output" "[[PP:.+]].i"
+
+/// Check the codegen
+// RUN:   %clang -S -emit-llvm -O0 -fopenmp -target powerpc64-linux -omptargets=powerpc64-ibm-linux-gnu,nvptx64-nvidia-cuda %s 2>&1
+// RUN:   FileCheck -check-prefix=CHK-CODEGEN-HOST -input-file=target_driver_and_codegen.ll %s
+// RUN:   FileCheck -check-prefix=CHK-CODEGEN-TARGET1 -input-file=target_driver_and_codegen.tgt-nvptx64-nvidia-cuda.ll %s
+// RUN:   FileCheck -check-prefix=CHK-CODEGEN-TARGET2 -input-file=target_driver_and_codegen.tgt-powerpc64-ibm-linux-gnu.ll %s
+
+
+// CHK-CODEGEN-HOST:   @__omptgt__img_start_[[T1:.*]] = external constant i8
+// CHK-CODEGEN-HOST:   @__omptgt__img_end_[[T1]] = external constant i8
+// CHK-CODEGEN-HOST:   @__omptgt__img_start_[[T2:.*]] = external constant i8
+// CHK-CODEGEN-HOST:   @__omptgt__img_end_[[T2]] = external constant i8
+// CHK-CODEGEN-HOST:   @__omptgt__device_images = internal constant [2 x { i8*, i8* }] [
+// CHK-CODEGEN-HOST:   { i8*, i8* } { i8* @__omptgt__img_start_[[T1]], i8* @__omptgt__img_end_[[T1]] },
+// CHK-CODEGEN-HOST:   { i8*, i8* } { i8* @__omptgt__img_start_[[T2]], i8* @__omptgt__img_end_[[T2]] }]
+// CHK-CODEGEN-HOST:   @__omptgt__host_entries_begin = external constant { i8*, i32 }
+// CHK-CODEGEN-HOST:   @__omptgt__host_entries_end = external constant { i8*, i32 }
+// CHK-CODEGEN-HOST:   @__omptgt__target_regions_descriptor =
+// CHK-CODEGEN-HOST:   internal constant { i32, { i8*, i8* }*, { i8*, i32 }*, { i8*, i32 }* } {
+// CHK-CODEGEN-HOST:   i32 2,
+// CHK-CODEGEN-HOST:   { i8*, i8* }* getelementptr inbounds ([2 x { i8*, i8* }]* @__omptgt__device_images, i32 0, i32 0),
+// CHK-CODEGEN-HOST:   { i8*, i32 }* @__omptgt__host_entries_begin,
+// CHK-CODEGEN-HOST:   { i8*, i32 }* @__omptgt__host_entries_end }
+
+/// Argument sizes (int32)
+// CHK-CODEGEN-HOST:   [[S1:@.tgt_sizes[0-9]*]] = private constant [1 x i32] [i32 4]
+/// Map types (to-from)
+// CHK-CODEGEN-HOST:   [[M1:@.tgt_types[0-9]*]] = private constant [1 x i32] [i32 3]
+// CHK-CODEGEN-HOST:   @__omptgt__host_ptr_0 = internal constant [{{[1-9][0-9]*}} x i8] c"__omptgt__0_[[ID:[0-9a-f]+_[0-9a-f]+]]_\00"
+// CHK-CODEGEN-HOST:   @__omptgt__0_[[ID]]__hst_entry =
+// CHK-CODEGEN-HOST:   constant { i8*, i32 } { i8* getelementptr inbounds ([{{[1-9][0-9]*}} x i8]* @__omptgt__host_ptr_0, i32 0, i32 0), i32 0 },
+// CHK-CODEGEN-HOST:   section ".openmptgt_host_entries"
+
+
+/// Argument sizes (int32)
+// CHK-CODEGEN-HOST:   [[S2:@.tgt_sizes[0-9]*]] = private constant [1 x i32] [i32 4]
+/// Map types (to-from)
+// CHK-CODEGEN-HOST:   [[M2:@.tgt_types[0-9]*]] = private constant [1 x i32] [i32 3]
+// CHK-CODEGEN-HOST:   @__omptgt__host_ptr_1 = internal constant [{{[1-9][0-9]*}} x i8] c"__omptgt__1_[[ID:[0-9a-f]+_[0-9a-f]+]]_\00"
+// CHK-CODEGEN-HOST:   @__omptgt__1_[[ID]]__hst_entry =
+// CHK-CODEGEN-HOST:   constant { i8*, i32 } { i8* getelementptr inbounds ([{{[1-9][0-9]*}} x i8]* @__omptgt__host_ptr_1, i32 0, i32 0), i32 0 },
+// CHK-CODEGEN-HOST:   section ".openmptgt_host_entries"
+
+#pragma omp declare target
+// CHK-CODEGEN-HOST:    define signext i32 @tdouble
+// CHK-CODEGEN-TARGET1: define i32 @tdouble
+// CHK-CODEGEN-TARGET2: define signext i32 @tdouble
+int tdouble(int a){
+  return 2*a;
+}
+// CHK-CODEGEN-HOST: define signext i32 @tsquare
+// CHK-CODEGEN-TARGET1: define i32 @tsquare
+// CHK-CODEGEN-TARGET2: define signext i32 @tsquare
+int tsquare(int a){
+  return a*a;
+}
+// CHK-CODEGEN-HOST: define signext i32 @tadd
+// CHK-CODEGEN-TARGET1: define i32 @tadd
+// CHK-CODEGEN-TARGET2: define signext i32 @tadd
+int tadd(int a){
+  return a+a;
+}
+#pragma omp end declare target
+
+int foo(int a){
+  // CHK-CODEGEN-HOST: define signext i32 @foo
+  // CHK-CODEGEN-HOST: call void @__kmpc_register_lib({ i32, { i8*, i8* }*, { i8*, i32 }*, { i8*, i32 }* }* @__omptgt__target_regions_descriptor)
+  int i;
+
+  // CHK-CODEGEN-HOST: [[RET1:%[a-zA-Z0-9_\.]+]] = call i32 @__kmpc_target(
+  // CHK-CODEGEN-HOST: i32 [[DEVICEID1:0]],
+  // CHK-CODEGEN-HOST: i8* getelementptr inbounds ([{{[1-9][0-9]*}} x i8]* @__omptgt__host_ptr_0, i32 0, i32 0),
+  // CHK-CODEGEN-HOST: i32 [[ARGNUM1:[0-9]+]],
+  // CHK-CODEGEN-HOST: i8** [[DATA1:%[a-zA-Z0-9_\.]+]],
+  // CHK-CODEGEN-HOST: i32* getelementptr inbounds ([1 x i32]* [[S1]], i32 0, i32 0),
+  // CHK-CODEGEN-HOST: i32* getelementptr inbounds ([1 x i32]* [[M1]], i32 0, i32 0))
+  // CHK-CODEGEN-HOST: [[CMP1:%[0-9]+]] = icmp eq i32 [[RET1]], 0
+  // CHK-CODEGEN-HOST: br i1 [[CMP1]], label %[[OFFSUCCESS1:[a-zA-Z0-9_\.]+]], label %[[OFFFAIL1:[a-zA-Z0-9_\.]+]]
+
+  // CHK-CODEGEN-HOST: [[OFFFAIL1]]{{.*}}
+  // CHK-CODEGEN-HOST: call void @__omptgt__0_[[ID]]_(i32* %{{.*}})
+  // CHK-CODEGEN-HOST: br label %[[OFFSUCCESS1]]
+
+  // CHK-CODEGEN-HOST: [[OFFSUCCESS1]]{{.*}}
+
+  // CHK-CODEGEN-TARGET1: define void @__omptgt__0_[[ID:[0-9a-f]+_[0-9a-f]+]]_nvptx64_nvidia_cuda
+  // CHK-CODEGEN-TARGET2: define void @__omptgt__0_[[ID:[0-9a-f]+_[0-9a-f]+]]_powerpc64_ibm_linux_gnu
+#pragma omp target
+  {
+    a += tsquare(a);
+  }
+
+  for(i=0; i<5; ++i){
+    // CHK-CODEGEN-HOST: [[RET2:%[a-zA-Z0-9_\.]+]] = call i32 @__kmpc_target(
+    // CHK-CODEGEN-HOST: i32 [[DEVICEID2:0]],
+    // CHK-CODEGEN-HOST: i8* getelementptr inbounds ([{{[1-9][0-9]*}} x i8]* @__omptgt__host_ptr_1, i32 0, i32 0),
+    // CHK-CODEGEN-HOST: i32 [[ARGNUM2:[0-9]+]],
+    // CHK-CODEGEN-HOST: i8** [[DATA2:%[a-zA-Z0-9_\.]+]],
+    // CHK-CODEGEN-HOST: i32* getelementptr inbounds ([1 x i32]* [[S2]], i32 0, i32 0),
+    // CHK-CODEGEN-HOST: i32* getelementptr inbounds ([1 x i32]* [[M2]], i32 0, i32 0))
+    // CHK-CODEGEN-HOST: [[CMP2:%[0-9]+]] = icmp eq i32 [[RET2]], 0
+    // CHK-CODEGEN-HOST: br i1 [[CMP2]], label %[[OFFSUCCESS2:[a-zA-Z0-9_\.]+]], label %[[OFFFAIL2:[a-zA-Z0-9_\.]+]]
+
+    // CHK-CODEGEN-HOST: [[OFFFAIL2]]{{.*}}
+    // CHK-CODEGEN-HOST: call void @__omptgt__1_[[ID]]_(i32* %{{.*}})
+    // CHK-CODEGEN-HOST: br label %[[OFFSUCCESS2]]
+
+    // CHK-CODEGEN-HOST: [[OFFSUCCESS2]]{{.*}}
+
+    // CHK-CODEGEN-TARGET1: define void @__omptgt__1_[[ID]]_nvptx64_nvidia_cuda
+    // CHK-CODEGEN-TARGET2: define void @__omptgt__1_[[ID]]_powerpc64_ibm_linux_gnu
+#pragma omp target
+    {
+      a -= tdouble(a) + tadd(a);
+    }
+  }
+
+  return a;
+}
+
+int main(int argc, char *argv[]){
+  return foo(argc);
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_if_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_if_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_if_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_if_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,25 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+int main(int argc, char **argv) {
+  #pragma omp target if // expected-error {{expected '(' after 'if'}} expected-error {{expected expression}}
+  #pragma omp target if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target if () // expected-error {{expected expression}}
+  #pragma omp target if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp target' are ignored}}
+  #pragma omp target if (argc > 0 ? argv[1] : argv[2])
+  #pragma omp target if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp target' cannot contain more than one 'if' clause}}
+  #pragma omp target if (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp target if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_map_codegen.c cfe-3.5.0.src.omp/test/OpenMP/target_map_codegen.c
--- cfe-3.5.0.src/test/OpenMP/target_map_codegen.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_map_codegen.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,51 @@
+///
+/// Perform preliminary check of map clause codegen
+///
+
+/// Check the codegen
+// RUN:   %clang -S -emit-llvm -O0 -fopenmp -target powerpc64-linux -omptargets=powerpc64-ibm-linux-gnu %s 2>&1
+// RUN:   FileCheck -check-prefix=CHK-CODEGEN-HOST -input-file=target_map_codegen.ll %s
+
+double a[32];
+double b[32];
+double c[32];
+
+
+void foo(double A[32], double B[32], double C[32]){
+  int i;
+
+  // CHK-CODEGEN-HOST: [[MT:@.mapped_types[0-9]*]] = private constant [3 x i32] [i32 1, i32 1, i32 3]
+  // CHK-CODEGEN-HOST: [[MP:%[a-zA-Z0-9_\.]+]] = alloca i8*, i32 3
+  // CHK-CODEGEN-HOST: [[MS:%[a-zA-Z0-9_\.]+]] = alloca i32, i32 3
+
+  // CHK-CODEGEN-HOST: [[P0:%[0-9]+]] = getelementptr inbounds i8** [[MP]], i32 0
+  // CHK-CODEGEN-HOST: [[S0:%[0-9]+]] = getelementptr inbounds i32* [[MS]], i32 0
+  // CHK-CODEGEN-HOST: store i8* bitcast (double* getelementptr inbounds ([32 x double]* @a, i32 0, i64 2) to i8*), i8** [[P0]]
+  // CHK-CODEGEN-HOST: store i32 trunc (i64 sub (i64 ptrtoint (double* getelementptr inbounds ([32 x double]* @a, i64 1, i64 0) to i64), i64 ptrtoint (double* getelementptr inbounds ([32 x double]* @a, i32 0, i64 2) to i64)) to i32), i32* [[S0]]
+
+  // CHK-CODEGEN-HOST: [[P1:%[0-9]+]] = getelementptr inbounds i8** [[MP]], i32 1
+  // CHK-CODEGEN-HOST: [[S1:%[0-9]+]] = getelementptr inbounds i32* [[MS]], i32 1
+  // CHK-CODEGEN-HOST: store i8* bitcast ([32 x double]* @b to i8*), i8** [[P1]]
+  // CHK-CODEGEN-HOST: store i32 256, i32* [[S1]]
+  // CHK-CODEGEN-HOST: [[P2:%[0-9]+]] = getelementptr inbounds i8** [[MP]], i32 2
+  // CHK-CODEGEN-HOST: [[S2:%[0-9]+]] = getelementptr inbounds i32* [[MS]], i32 2
+  // CHK-CODEGEN-HOST: store i8* bitcast ([32 x double]* @c to i8*), i8** [[P2]]
+  // CHK-CODEGEN-HOST: store i32 256, i32* [[S2]]
+
+  // CHK-CODEGEN-HOST: call void @__kmpc_target_data_begin(i32 1, i32 3, i8** [[MP]], i32* [[MS]], i32* getelementptr inbounds ([3 x i32]* [[MT]], i32 0, i32 0))
+  // CHK-CODEGEN-HOST: call i32 @__kmpc_target(
+  // CHK-CODEGEN-HOST: call void @__kmpc_target_data_end(i32 1, i32 3, i8** [[MP]], i32* [[MS]], i32* getelementptr inbounds ([3 x i32]* [[MT]], i32 0, i32 0))
+
+#pragma omp target map(to: a[2:30], b) map(tofrom: c) device(1)
+  for(i=2; i<32; ++i)
+  {
+    C[i] += A[i] * B[i] + a[i];
+  }
+
+  return;
+}
+
+int main(int argc, char *argv[]){
+  foo(a, b, c);
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_map_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_map_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_map_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_map_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,94 @@
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note 2 {{mappable type cannot contain static members}}
+  static const float S2sc; // expected-note 2 {{mappable type cannot contain static members}}
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-error {{threadprivate variables cannot be used in target constructs}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  int *k = &j;
+  const int (&l)[5] = da;
+  #pragma omp target map // expected-error {{expected '(' after 'map'}} expected-error {{expected expression}}
+  #pragma omp target map ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target map () // expected-error {{expected expression}}
+  #pragma omp target map (alloc) // expected-error {{expected expression}}  expected-error {{expected ':' in 'map' clause}}
+  #pragma omp target map (to argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error{{expected ':' in 'map' clause}}
+  #pragma omp target map (from: argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target map (tofrom: argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  #pragma omp target map (argc)
+  #pragma omp target map (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp target map (a, b, c, d, f) // expected-error {{incomplete type 'S1' where a complete type is required}} expected-error 2 {{type 'S2' is not mappable to target}}
+  #pragma omp target map (argv[1])
+  #pragma omp target map(ba) // expected-error 2 {{type 'S2' is not mappable to target}}
+  #pragma omp target map(ca)
+  #pragma omp target map(da)
+  #pragma omp target map(S2::S2s)
+  #pragma omp target map(S2::S2sc)
+  #pragma omp target map(e, g)
+  #pragma omp target map(h) // expected-note {{used here}}
+  #pragma omp target map(k), map(k[:10]) // expected-error {{variable already marked as mapped in current construct}} expected-note {{used here}}
+  foo();
+  #pragma omp target map(da)
+  #pragma omp target map(da[:4])
+  foo();
+  #pragma omp target map(k, j, l) // expected-note 2 {{used here}}
+  #pragma omp target map(k[:4]) // expected-error {{variable already marked as mapped in current construct}}
+  #pragma omp target map(j)
+  #pragma omp target map(l[:5]) // expected-error {{variable already marked as mapped in current construct}}
+  foo();
+  #pragma omp target map(k[:4], j, l[:5]) // expected-note 2 {{used here}}
+  #pragma omp target map(k) // expected-error {{variable already marked as mapped in current construct}}
+  #pragma omp target map(j)
+  #pragma omp target map(l) // expected-error {{variable already marked as mapped in current construct}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_messages.c cfe-3.5.0.src.omp/test/OpenMP/target_messages.c
--- cfe-3.5.0.src/test/OpenMP/target_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,19 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() { }
+
+int main(int argc, char **argv) {
+  L1:
+    foo();
+  #pragma omp target
+  {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+  #pragma omp target
+  L2:
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,28 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  static int a;
+// CHECK: static int a;
+#pragma omp target teams
+// CHECK:      #pragma omp target teams
+  a=2;
+// CHECK-NEXT: a = 2;
+#pragma omp target if(b) device(c+e) map(b,c) map(to:d) map(from:e) map(alloc:f) map(tofrom: g)
+
+#pragma omp target teams num_teams(a), thread_limit(c), default(none), private(argc,b),firstprivate(argv, c),shared(d,f),reduction(+:e) reduction(min : g) if(b) device(c+e) map(b,c) map(to:d) map(from:e) map(alloc:f) map(tofrom: g)
+// CHECK:      #pragma omp target teams num_teams(a) thread_limit(c) default(none) private(argc,b) firstprivate(argv,c) shared(d,f) reduction(+: e) reduction(min: g) if(b) device(c + e) map(tofrom: b,c) map(to: d) map(from: e) map(alloc: f) map(tofrom: g)
+  foo();
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_default_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_default_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_default_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_default_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,20 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo();
+
+int main(int argc, char **argv) {
+  #pragma omp target teams default // expected-error {{expected '(' after 'default'}} expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  foo();
+  #pragma omp target teams default ( // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams default () // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  foo();
+  #pragma omp target teams default (none // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams default (shared), default(shared) // expected-error {{directive '#pragma omp target teams' cannot contain more than one 'default' clause}}
+  foo();
+  #pragma omp target teams default (x) // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_device_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_device_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_device_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_device_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target teams device // expected-error {{expected '(' after 'device'}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams device ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams device () // expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams device (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams device (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  foo();
+  #pragma omp target teams device (foobool(argc)) device(3) // expected-error {{directive '#pragma omp target teams' cannot contain more than one 'device' clause}}
+  foo();
+  #pragma omp target teams device (S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target teams device (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  foo();
+  #pragma omp target teams device (v1) // expected-error {{expression has incomplete type 'S1'}}
+  foo();
+  #pragma omp target teams device (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  foo();
+  #pragma omp target teams device (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  foo();
+  #pragma omp target teams device (0)
+  foo();
+  #pragma omp target teams device (-1) // expected-error {{expression is not a positive integer value}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,38 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  static int a;
+// CHECK: static int a;
+#pragma omp target teams distribute
+// CHECK-NEXT: #pragma omp target teams distribute
+  for (int i=0; i < 2; ++i)a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: a = 2;
+#pragma omp target teams distribute num_teams(a), thread_limit(c), default(none), private(argc,b),firstprivate(argv, c),shared(d,f),reduction(+:e) reduction(min : g) collapse(2), dist_schedule(static) if(a) map(to:c) map (from:d) map(tofrom:e) device(f)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j)foo();
+// CHECK-NEXT: #pragma omp target teams distribute num_teams(a) thread_limit(c) default(none) private(argc,b) firstprivate(argv,c) shared(d,f) reduction(+: e) reduction(min: g) collapse(2) dist_schedule(static) if(a) map(to: c) map(from: d) map(tofrom: e) device(f)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j)
+// CHECK-NEXT: foo();
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp target teams distribute dist_schedule(static, argc)
+// CHECK:      #pragma omp target teams distribute dist_schedule(static, argc)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_collapse_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_collapse_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_collapse_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_collapse_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; }
+  operator bool() { return f; }
+} v2;
+
+struct S3 {
+  int f;
+  operator int() { return f; }
+} v3;
+
+int main(int argc, char **argv) { // expected-note {{declared here}}
+  #pragma omp target teams distribute collapse // expected-error {{expected '(' after 'collapse'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute collapse ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute collapse () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute collapse (argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}} expected-note {{read of non-const variable 'argc' is not allowed in a constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute collapse (argc > 0 ? argv[1] : argv[2]) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute collapse (foobool(argc)) collapse(1) // expected-error {{directive '#pragma omp target teams distribute' cannot contain more than one 'collapse' clause}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute collapse (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute collapse (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute collapse (v1) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute collapse (v2) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute collapse (v3) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute collapse (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute collapse (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_default_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_default_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_default_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_default_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,20 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo();
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute default // expected-error {{expected '(' after 'default'}} expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute default ( // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute default () // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute default (none // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute default (shared), default(shared) // expected-error {{directive '#pragma omp target teams distribute' cannot contain more than one 'default' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute default (x) // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_dist_schedule_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_dist_schedule_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_dist_schedule_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_dist_schedule_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,35 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute dist_schedule // expected-error {{expected '(' after 'dist_schedule'}} expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute dist_schedule ( // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute dist_schedule () // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute dist_schedule (static // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute dist_schedule (static, // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute dist_schedule (argc)) // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}} expected-warning {{extra tokens at the end of '#pragma omp target teams distribute' are ignored}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute dist_schedule (static, argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute dist_schedule (static), dist_schedule (static, 1) // expected-error {{directive '#pragma omp target teams distribute' cannot contain more than one 'dist_schedule' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute dist_schedule (static, S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute dist_schedule (static, argv[1]=2) // expected-error {{statement requires expression of integer type ('char *' invalid)}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_firstprivate_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_firstprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,123 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+
+public:
+  S2() : a(0) {}
+  S2(S2 &s2) : a(s2.a) {}
+  static float S2s;
+  static const float S2sc;
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+
+public:
+  S3() : a(0) {}
+  S3(S3 &s3) : a(s3.a) {}
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+  S4(const S4 &s4);
+
+public:
+  S4(int v) : a(v) {}
+};
+class S5 { // expected-note {{'S5' declared here}}
+  int a;
+  S5() : a(0) {}
+  S5(const S5 &s5) : a(s5.a) {}
+
+public:
+  S5(int v) : a(v) {}
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = {0};
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  int i;
+  int &j = i;                                    // expected-note {{'j' defined here}}
+#pragma omp target teams distribute firstprivate // expected-error {{expected '(' after 'firstprivate'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate() // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(argc)
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(ba)
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(ca)
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(da)
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(S2::S2s)
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(S2::S2sc)
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute private(i), firstprivate(i) // expected-error {{private variable cannot be firstprivate}} expected-note{{defined as private}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(i)
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_if_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_if_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_if_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_if_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,33 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute if // expected-error {{expected '(' after 'if'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute if () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp target teams distribute' are ignored}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute if (argc > 0 ? argv[1] : argv[2])
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp target teams distribute' cannot contain more than one 'if' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute if (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_loop_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_loop_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_loop_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_loop_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,172 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+namespace std {
+
+struct random_access_iterator_tag { };
+
+template <class Iter>
+struct iterator_traits {
+  typedef typename Iter::difference_type difference_type; // expected-error {{no type named 'difference_type' in 'Iter'}} expected-error {{no type named 'difference_type' in 'Iter1'}}
+  typedef typename Iter::iterator_category iterator_category; // expected-error {{no type named 'iterator_category' in 'Iter'}} expected-error {{no type named 'iterator_category' in 'Iter1'}} expected-error {{no type named 'iterator_category' in 'Iter2'}}
+};
+
+template <class Iter>
+typename iterator_traits<Iter>::difference_type distance(Iter first, Iter last) {
+  return first - last;
+}
+}
+
+class Iter {
+  public:
+    Iter() { }
+    Iter(const Iter &) { }
+    Iter operator ++() { return *this; }
+    Iter operator --() { return *this; }
+    bool operator <(Iter a) { return true; }
+    bool operator >=(Iter a) { return false; }
+};
+int operator -(Iter a, Iter b) { return 0; }
+class Iter1 {
+  public:
+    Iter1() { }
+    Iter1(const Iter1 &) { }
+    Iter1 operator ++() { return *this; }
+    Iter1 operator --() { return *this; }
+    bool operator <(Iter1 a) { return true; }
+    bool operator >=(Iter1 a) { return false; }
+};
+class Iter2 {
+  public:
+    Iter2() { }
+    Iter2(const Iter2 &) { }
+    Iter2 operator ++() { return *this; }
+    Iter2 operator --() { return *this; }
+    bool operator <(Iter2 a) { return true; }
+    bool operator >=(Iter2 a) { return false; }
+    typedef int difference_type;
+};
+int operator -(Iter2 a, Iter2 b) { return 0; }
+class Iter3 {
+  public:
+    Iter3() { }
+    Iter3(const Iter3 &) { }
+    Iter3 operator ++() { return *this; }
+    Iter3 operator --() { return *this; }
+    bool operator <(Iter3 a) { return true; }
+    bool operator >=(Iter3 a) { return false; }
+    typedef int difference_type;
+    typedef int iterator_category;
+};
+int operator -(Iter3 a, Iter3 b) { return 0; }
+class Iter4 {
+  public:
+    Iter4() { }
+    Iter4(const Iter4 &) { }
+    Iter4 operator ++() { return *this; }
+    Iter4 operator --() { return *this; }
+    bool operator <(Iter4 a) { return true; }
+    bool operator >=(Iter4 a) { return false; }
+    Iter4 operator+=(int) const {return Iter4();}
+    Iter4 operator-=(int) const {return Iter4();}
+    typedef int difference_type;
+    typedef std::random_access_iterator_tag iterator_category;
+};
+int operator -(Iter4 a, Iter4 b) { return 0; }
+
+int t;
+#pragma omp threadprivate(t)
+
+int main() {
+  #pragma omp target teams distribute
+  for (int i = 0; i < 10; i++)
+    ++i;
+  #pragma omp target teams distribute
+  for (t = 0; t < 10; t++)
+    ++t;
+  #pragma omp target teams distribute
+  for (int i; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target teams distribute
+  for (float i = 0; i < 10.0f; i++) // expected-error {{variable must be of integer or random access iterator type}}
+    ++i;
+  #pragma omp target teams distribute
+  for (int i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target teams distribute
+  for (int i = 0; i < 10; i |= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  int i;
+  #pragma omp target teams distribute
+  for (i = 0; i < 10; i++)
+    ++i;
+  #pragma omp target teams distribute
+  for (i--; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target teams distribute
+  for (i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target teams distribute
+  for (i = 0; i < 10; i ^= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  Iter begin, end;
+  #pragma omp target teams distribute
+  for (Iter I = begin; I >= end; ++I) // expected-error {{increment expression must cause 'I' to decrease on each iteration of the loop}}
+    ++I;
+  #pragma omp target teams distribute
+  for (Iter I = end; I < begin; --I) // expected-error {{increment expression must cause 'I' to increase on each iteration of the loop}}
+    ++I;
+  #pragma omp target teams distribute
+  for (Iter I = begin; I < end; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter>' requested here}} expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target teams distribute
+  for (Iter I = end; I >= begin; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter1 begin1;
+  #pragma omp target teams distribute
+  for (Iter1 I = begin1; I < begin1; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter1>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target teams distribute
+  for (Iter1 I = begin1; I >= begin1; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter2 begin2;
+  #pragma omp target teams distribute
+  for (Iter2 I = begin2; I < begin2; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter2>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target teams distribute
+  for (Iter2 I = begin2; I >= begin2; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter3 begin3;
+  #pragma omp target teams distribute
+  for (Iter3 I = begin3; I < begin3; ++I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target teams distribute
+  for (Iter3 I = begin3; I >= begin3; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter4 begin4;
+  #pragma omp target teams distribute
+  for (Iter4 I = begin4; I < begin4; ++I)
+    ++I;
+  #pragma omp target teams distribute
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  goto label; // expected-error {{use of undeclared label 'label'}}
+  #pragma omp target teams distribute
+  for (int i = 0; i < 100; ++i) {
+    label: ++i;
+  }
+  #pragma omp target teams distribute collapse(1)
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  #pragma omp target teams distribute collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+  for (Iter4 I1 = begin4; I1 >= begin4; --I1)
+  for (Iter4 I2 = begin4; I2 >= begin4; --I2)
+    ++I;
+  #pragma omp target teams distribute collapse(0) // expected-error {{expression is not a positive integer value}}
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  #pragma omp target teams distribute collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I; // expected-error {{only for-loops are allowed for '#pragma omp target teams distribute'}}
+  ++begin4; 
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_loop_messages1.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_loop_messages1.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_loop_messages1.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_loop_messages1.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,10 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int main() {
+  int i;
+  goto label; // expected-error {{use of undeclared label 'label'}}
+  #pragma omp target teams distribute
+  for (i = 0; i < 100; ++i) {
+    label: ++i;
+  }
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_map_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_map_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_map_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_map_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,119 @@
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note 2 {{mappable type cannot contain static members}}
+  static const float S2sc; // expected-note 2 {{mappable type cannot contain static members}}
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-error {{threadprivate variables cannot be used in target constructs}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  int *k = &j;
+  const int (&l)[5] = da;
+  #pragma omp target teams distribute map // expected-error {{expected '(' after 'map'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map (alloc) // expected-error {{expected expression}}  expected-error {{expected ':' in 'map' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map (to argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error{{expected ':' in 'map' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map (from: argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map (tofrom: argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map (argc)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map (a, b, c, d, f) // expected-error {{incomplete type 'S1' where a complete type is required}} expected-error 2 {{type 'S2' is not mappable to target}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map (argv[1])
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map(ba) // expected-error 2 {{type 'S2' is not mappable to target}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map(ca)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map(da)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map(S2::S2s)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map(S2::S2sc)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map(e, g)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map(h) // expected-note {{used here}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map(k), map(k[:10]) // expected-error {{variable already marked as mapped in current construct}} expected-note {{used here}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map(da)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map(da[:4])
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(k) // expected-note {{used here}}
+  #pragma omp target teams distribute map(k[:4]) // expected-error {{variable already marked as mapped in current construct}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map(j)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(l) // expected-note {{used here}}
+  #pragma omp target teams distribute map(l[:5]) // expected-error {{variable already marked as mapped in current construct}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(k[:4]) // expected-note {{used here}}
+  #pragma omp target teams distribute map(k) // expected-error {{variable already marked as mapped in current construct}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute map(j)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(l[:5]) // expected-note {{used here}}
+  #pragma omp target teams distribute map(l) // expected-error {{variable already marked as mapped in current construct}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_messages.c cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_messages.c
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,22 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() { }
+
+int main(int argc, char **argv) {
+  L1:
+    foo();
+  #pragma omp target teams distribute
+  for(int i = 0; i < argc; ++i)
+  {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+  #pragma omp target teams distribute
+  for(int i = 0; i < argc; ++i) {
+    L2:
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,38 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+#pragma omp target teams distribute // expected-error {{unexpected OpenMP directive '#pragma omp target teams distribute'}}
+
+int main(int argc, char **argv) {
+#pragma omp target teams distribute
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target
+  {
+#pragma omp target teams distribute
+    for (int i = 0; i < argc; ++i)
+      foo();
+  }
+#pragma omp target teams distribute unknown() // expected-warning {{extra tokens at the end of '#pragma omp target teams distribute' are ignored}}
+  for (int i = 0; i < argc; ++i)
+    foo();
+L1:
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute
+  for (int i = 0; i < argc; ++i)
+    foo();
+#pragma omp target teams distribute
+  for (int i = 0; i < argc; ++i) {
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+    argc++;
+  }
+
+#pragma omp target teams distribute default(none)
+  for (int i = 0; i < 10; ++i)
+    ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_num_teams_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_num_teams_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_num_teams_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_num_teams_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute num_teams // expected-error {{expected '(' after 'num_teams'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute num_teams( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute num_teams() // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute num_teams(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute num_teams(argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute num_teams(foobool(argc)) num_teams(3) // expected-error {{directive '#pragma omp target teams distribute' cannot contain more than one 'num_teams' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute num_teams(S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute num_teams(argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute num_teams (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute num_teams(v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute num_teams(v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute num_teams(0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute num_teams(-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,75 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+template<class T, class N> T reduct(T* arr, N num) {
+  N i;
+  N ind;
+  T sum = (T)0;
+// CHECK: T sum = (T)0;
+#pragma omp target teams distribute parallel for reduction(+:sum) proc_bind(master) dist_schedule(static) default(shared)
+// CHECK-NEXT: #pragma omp target teams distribute parallel for reduction(+: sum) proc_bind(master) dist_schedule(static)
+  for (i = 0; i < num; ++i) {
+    T cur = arr[ind];
+    ++ind;
+    sum += cur;
+  }
+}
+
+template<class T> struct S {
+  S(const T &a)
+    :m_a(a)
+  {}
+  T result(T *v) const {
+    T res;
+// CHECK: T res;
+#pragma omp target teams distribute parallel for lastprivate(res) if(m_a)
+// CHECK-NEXT: #pragma omp target teams distribute parallel for lastprivate(res) if(this->m_a)
+    for (T i = 7; i < m_a; ++i) {
+      res = v[i-7] + m_a;
+    }
+    return res;
+  }
+  ~S()
+  {}
+  T m_a;
+};
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  int k1=0,k2=0;
+  static int *a;
+// CHECK: static int *a;
+#pragma omp target teams distribute parallel for
+// CHECK-NEXT: #pragma omp target teams distribute parallel for
+  for (int i=0; i < 2; ++i)*a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: *a = 2;
+#pragma omp target teams distribute parallel for private(argc,b),lastprivate(d,f),reduction(+:e) reduction(min : g),  collapse(2) dist_schedule(static, 3) default(none) firstprivate(f) num_teams(b) num_threads(argc) shared(k1, k2) map(to:b) map(from:c) map(tofrom:d) device(f) if(g)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j) {foo(); k1 += 8; k2 += 8;}
+// CHECK-NEXT: #pragma omp target teams distribute parallel for private(argc,b) lastprivate(d,f) reduction(+: e) reduction(min: g) collapse(2) dist_schedule(static, 3) default(none) firstprivate(f) num_teams(b) num_threads(argc) shared(k1,k2) map(to: b) map(from: c) map(tofrom: d) device(f) if(g)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j) {
+// CHECK-NEXT: foo();
+// CHECK-NEXT: k1 += 8;
+// CHECK-NEXT: k2 += 8;
+// CHECK-NEXT: }
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp target teams distribute parallel for collapse(1)
+// CHECK-NEXT: #pragma omp target teams distribute parallel for collapse(1)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_device_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_device_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_device_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_device_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute parallel for device // expected-error {{expected '(' after 'device'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for device ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for device () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for device (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for device (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for device (foobool(argc)) device(3) // expected-error {{directive '#pragma omp target teams distribute parallel for' cannot contain more than one 'device' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for device (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for device (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for device (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for device (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for device (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for device (0)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for device (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_if_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_if_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_if_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_if_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,33 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute parallel for if // expected-error {{expected '(' after 'if'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for if () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp target teams distribute parallel for' are ignored}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for if (argc > 0 ? argv[1] : argv[2])
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp target teams distribute parallel for' cannot contain more than one 'if' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for if (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_map_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_map_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_map_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_map_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,112 @@
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note 2 {{mappable type cannot contain static members}}
+  static const float S2sc; // expected-note 2 {{mappable type cannot contain static members}}
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-error {{threadprivate variables cannot be used in target constructs}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  int *k = &j;
+  const int (&l)[5] = da;
+  #pragma omp target teams distribute parallel for map // expected-error {{expected '(' after 'map'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map (alloc) // expected-error {{expected expression}}  expected-error {{expected ':' in 'map' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map (to argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error{{expected ':' in 'map' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map (from: argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map (tofrom: argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map (argc)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map (a, b, c, d, f) // expected-error {{incomplete type 'S1' where a complete type is required}} expected-error 2 {{type 'S2' is not mappable to target}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map (argv[1])
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map(ba) // expected-error 2 {{type 'S2' is not mappable to target}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map(ca)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map(da)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map(S2::S2s)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map(S2::S2sc)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map(e, g)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map(h) // expected-note {{used here}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for map(k), map(k[:10]) // expected-error {{variable already marked as mapped in current construct}} expected-note {{used here}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(da)
+  #pragma omp target teams distribute parallel for map(da[:4])
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(k, j, l) // expected-note 2 {{used here}}
+  #pragma omp target map(k[:4]) // expected-error {{variable already marked as mapped in current construct}}
+  #pragma omp target map(j)
+  #pragma omp target teams distribute parallel for map(l[:5]) // expected-error {{variable already marked as mapped in current construct}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(k[:4], j, l[:5]) // expected-note 2 {{used here}}
+  #pragma omp target map(k) // expected-error {{variable already marked as mapped in current construct}}
+  #pragma omp target map(j)
+  #pragma omp target teams distribute parallel for map(l) // expected-error {{variable already marked as mapped in current construct}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_messages.c cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_messages.c
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,21 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {}
+
+int main(int argc, char **argv) {
+L1:
+  foo();
+#pragma omp target teams distribute parallel for
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+#pragma omp target teams distribute parallel for
+  for (int i = 0; i < 10; ++i) {
+  L2:
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,53 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+#pragma omp target teams distribute parallel for // expected-error {{unexpected OpenMP directive '#pragma omp target teams distribute parallel for'}}
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute parallel for
+  for (int i = 0; i < 10; ++i) foo();
+  {
+  #pragma omp target teams distribute parallel for
+  for (int i = 0; i < 10; ++i) foo();
+  }
+  {
+    for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for
+  for (int i = 0; i < 10; ++i) foo();
+  }
+  #pragma omp target teams distribute parallel for unknown() // expected-warning {{extra tokens at the end of '#pragma omp target teams distribute parallel for' are ignored}}
+  for (int i = 0; i < 10; ++i) {
+  L1:
+    for (int i = 0; i < 10; ++i) foo();
+  }
+  #pragma omp target teams distribute parallel for
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for
+  for (int i = 0; i < 10; ++i) foo();
+  {
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+    argc++;
+  }
+
+  for (int i = 0; i < 10; ++i) {
+    switch(argc) {
+     case (0):
+      #pragma omp target teams distribute parallel for
+      for (int i = 0; i < 10; ++i)
+      {
+        foo();
+        break; // expected-error {{cannot break from a '#pragma omp target teams distribute parallel for' loop}}
+        continue;
+      }
+      default:
+       break;
+    }
+  }
+  #pragma omp target teams distribute parallel for default(none)
+  for (int i = 0; i < 10; ++i)
+  ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_misc_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,263 @@
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 100000 -fopenmp -verify %s
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp target teams distribute parallel for'}} */
+#pragma omp target teams distribute parallel for
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp target teams distribute parallel for'}} */
+#pragma omp target teams distribute parallel for foo
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp target teams distribute parallel for'}} */
+#pragma omp target teams distribute parallel for collapse
+
+void test_no_clause()
+{
+  int i;
+  #pragma omp target teams distribute parallel for
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_invalid_clause()
+{
+  int i;
+  /* expected-warning@+1 {{extra tokens at the end of '#pragma omp target teams distribute parallel for' are ignored}} */
+  #pragma omp target teams distribute parallel for foo bar
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_non_identifiers()
+{
+  int i, x;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp target teams distribute parallel for' are ignored}}
+  #pragma omp target teams distribute parallel for;
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp target teams distribute parallel for' are ignored}}
+  #pragma omp target teams distribute parallel for private(x);
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp target teams distribute parallel for' are ignored}}
+  #pragma omp target teams distribute parallel for , private(x);
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_private()
+{
+  int i;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp target teams distribute parallel for private(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute parallel for private(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute parallel for private(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for private()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for private(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp target teams distribute parallel for private(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp target teams distribute parallel for private(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for private(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for private(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_firstprivate()
+{
+  // TODO: tests on this.
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for firstprivate(
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_lastprivate()
+{
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for lastprivate(
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute parallel for lastprivate(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute parallel for lastprivate(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for lastprivate()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for lastprivate(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp target teams distribute parallel for lastprivate(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp target teams distribute parallel for lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for lastprivate(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for lastprivate(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_reduction()
+{
+  int i, x, y;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp target teams distribute parallel for reduction(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp target teams distribute parallel for reduction()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp target teams distribute parallel for reduction(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected identifier}} */
+  #pragma omp target teams distribute parallel for reduction(:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+4 {{expected ')'}} expected-note@+4 {{to match this '('}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute parallel for reduction(,
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp target teams distribute parallel for reduction(+
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  //
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for reduction(+:
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for reduction(+:)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for reduction(+:,y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for reduction(+:x,+:y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for reduction(%:x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target teams distribute parallel for reduction(+:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for reduction(*:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for reduction(-:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for reduction(&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for reduction(|:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for reduction(^:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for reduction(&&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for reduction(||:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for reduction(max:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for reduction(min:x)
+  for (i = 0; i < 16; ++i) ;
+  struct X { int x; };
+  struct X X;
+  // TODO: Is the following error correct?
+  // expected-error@+1 {{expected variable name}}
+  #pragma omp target teams distribute parallel for reduction(+:X.x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp target teams distribute parallel for reduction(+:x+x)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_multiple_clauses()
+{
+  int i;
+  float x = 0, y = 0, z = 0;
+  #pragma omp target teams distribute parallel for reduction(+:x, y) reduction(-:z) // OK
+  for (i = 0; i < 16; ++i);
+
+  // expected-error@+1 {{private variable cannot be lastprivate}} expected-note@+1 {{defined as private}}
+  #pragma omp target teams distribute parallel for private(x), lastprivate(x)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target teams distribute parallel for reduction(+:x, y), reduction(-:z)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target teams distribute parallel for reduction(+:x, y) reduction(-:z)
+  for (i = 0; i < 16; ++i);
+}
+
+void test_for()
+{
+  // expected-error@+3 {{expected '(' after 'for'}}
+  // expected-error@+2 2{{use of undeclared identifier 'i'}}
+  #pragma omp target teams distribute parallel for
+  for int i = 0; i < 16; i++);
+
+  // expected-error@+3 {{expected ')'}}
+  // expected-note@+2 {{to match this '('}}
+  #pragma omp target teams distribute parallel for
+  for (int i = 0; i < 16; i++;
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp target teams distribute parallel for
+  for (int i = 0 i < 16; i++);
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp target teams distribute parallel for
+  for (int i = 0; i < 16 i++);
+
+  // expected-error@+2 2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp target teams distribute parallel for
+  for (int i = 0 i < 16 i++);
+
+  int i = 0;
+  // expected-error@+2 {{initialization of for-loop does not have canonical form}}
+  #pragma omp target teams distribute parallel for
+  for (; i < 16; ++i);
+
+  // expected-error@+2 {{condition of for-loop does not have canonical form}}
+  #pragma omp target teams distribute parallel for
+  for (int i = 0; ; ++i);
+
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp target teams distribute parallel for
+  for (int i = 0; i < 16; );
+
+  // expected-error@+3 {{condition of for-loop does not have canonical form}}
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp target teams distribute parallel for
+  for (int i = 0; ;);
+
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_num_teams_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_num_teams_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_num_teams_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_num_teams_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute parallel for num_teams // expected-error {{expected '(' after 'num_teams'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for num_teams ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for num_teams () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for num_teams (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for num_teams (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for num_teams (foobool(argc)) num_teams(3) // expected-error {{directive '#pragma omp target teams distribute parallel for' cannot contain more than one 'num_teams' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for num_teams (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for num_teams (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for num_teams (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for num_teams (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for num_teams (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for num_teams (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for num_teams (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,75 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+template<class T, class N> T reduct(T* arr, N num) {
+  N i;
+  N ind;
+  T sum = (T)0;
+// CHECK: T sum = (T)0;
+#pragma omp target teams distribute parallel for simd reduction(+:sum) proc_bind(master) dist_schedule(static) default(shared)
+// CHECK-NEXT: #pragma omp target teams distribute parallel for simd reduction(+: sum) proc_bind(master) dist_schedule(static)
+  for (i = 0; i < num; ++i) {
+    T cur = arr[ind];
+    ++ind;
+    sum += cur;
+  }
+}
+
+template<class T> struct S {
+  S(const T &a)
+    :m_a(a)
+  {}
+  T result(T *v) const {
+    T res;
+// CHECK: T res;
+#pragma omp target teams distribute parallel for simd lastprivate(res) if(m_a)
+// CHECK-NEXT: #pragma omp target teams distribute parallel for simd lastprivate(res) if(this->m_a)
+    for (T i = 7; i < m_a; ++i) {
+      res = v[i-7] + m_a;
+    }
+    return res;
+  }
+  ~S()
+  {}
+  T m_a;
+};
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  int k1=0,k2=0;
+  static int *a;
+// CHECK: static int *a;
+#pragma omp target teams distribute parallel for simd
+// CHECK-NEXT: #pragma omp target teams distribute parallel for simd
+  for (int i=0; i < 2; ++i)*a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: *a = 2;
+#pragma omp target teams distribute parallel for simd private(argc,b),lastprivate(d,f),reduction(+:e) reduction(min : g),  collapse(2) dist_schedule(static, 3) default(none) firstprivate(f) num_teams(b) num_threads(argc) shared(k1, k2) map(to:b) map(from:c) map(tofrom:d) device(f) if(g)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j) {foo(); k1 += 8; k2 += 8;}
+// CHECK-NEXT: #pragma omp target teams distribute parallel for simd private(argc,b) lastprivate(d,f) reduction(+: e) reduction(min: g) collapse(2) dist_schedule(static, 3) default(none) firstprivate(f) num_teams(b) num_threads(argc) shared(k1,k2) map(to: b) map(from: c) map(tofrom: d) device(f) if(g)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j) {
+// CHECK-NEXT: foo();
+// CHECK-NEXT: k1 += 8;
+// CHECK-NEXT: k2 += 8;
+// CHECK-NEXT: }
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp target teams distribute parallel for simd collapse(1)
+// CHECK-NEXT: #pragma omp target teams distribute parallel for simd collapse(1)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_device_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_device_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_device_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_device_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute parallel for simd device // expected-error {{expected '(' after 'device'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd device ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd device () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd device (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd device (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd device (foobool(argc)) device(3) // expected-error {{directive '#pragma omp target teams distribute parallel for simd' cannot contain more than one 'device' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd device (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd device (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd device (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd device (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd device (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd device (0)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd device (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_if_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_if_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_if_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_if_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,33 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute parallel for simd if // expected-error {{expected '(' after 'if'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd if () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp target teams distribute parallel for simd' are ignored}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd if (argc > 0 ? argv[1] : argv[2])
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp target teams distribute parallel for simd' cannot contain more than one 'if' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd if (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_map_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_map_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_map_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_map_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,113 @@
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note 2 {{mappable type cannot contain static members}}
+  static const float S2sc; // expected-note 2 {{mappable type cannot contain static members}}
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-error {{threadprivate variables cannot be used in target constructs}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  int *k = &j;
+  const int (&l)[5] = da;
+  #pragma omp target teams distribute parallel for simd map // expected-error {{expected '(' after 'map'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map (alloc) // expected-error {{expected expression}}  expected-error {{expected ':' in 'map' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map (to argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error{{expected ':' in 'map' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map (from: argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map (tofrom: argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map (argc)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map (a, b, c, d, f) // expected-error {{incomplete type 'S1' where a complete type is required}} expected-error 2 {{type 'S2' is not mappable to target}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map (argv[1])
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map(ba) // expected-error 2 {{type 'S2' is not mappable to target}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map(ca)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map(da)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map(S2::S2s)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map(e, g)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map(S2::S2sc)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd map(S2::S2sc)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(h) // expected-note {{used here}}
+  #pragma omp target teams distribute parallel for simd map(k), map(k[:10]) // expected-error {{variable already marked as mapped in current construct}} expected-note {{used here}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(da)
+  #pragma omp target teams distribute parallel for simd map(da[:4])
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(k, j, l) // expected-note 2 {{used here}}
+  #pragma omp target map(k[:4]) // expected-error {{variable already marked as mapped in current construct}}
+  #pragma omp target map(j)
+  #pragma omp target teams distribute parallel for simd map(l[:5]) // expected-error {{variable already marked as mapped in current construct}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(k[:4], j, l[:5]) // expected-note 2 {{used here}}
+  #pragma omp target map(k) // expected-error {{variable already marked as mapped in current construct}}
+  #pragma omp target map(j)
+  #pragma omp target teams distribute parallel for simd map(l) // expected-error {{variable already marked as mapped in current construct}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_messages.c cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_messages.c
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,21 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {}
+
+int main(int argc, char **argv) {
+L1:
+  foo();
+#pragma omp target teams distribute parallel for simd
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+#pragma omp target teams distribute parallel for simd
+  for (int i = 0; i < 10; ++i) {
+  L2:
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+#pragma omp target teams distribute parallel for simd // expected-error {{unexpected OpenMP directive '#pragma omp target teams distribute parallel for simd'}}
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute parallel for simd
+  for (int i = 0; i < 10; ++i) foo();
+  {
+  #pragma omp target teams distribute parallel for simd
+  for (int i = 0; i < 10; ++i) foo();
+  }
+  {
+    for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd
+  for (int i = 0; i < 10; ++i) foo();
+  }
+  #pragma omp target teams distribute parallel for simd unknown() // expected-warning {{extra tokens at the end of '#pragma omp target teams distribute parallel for simd' are ignored}}
+  for (int i = 0; i < 10; ++i) {
+  L1:
+    for (int i = 0; i < 10; ++i) foo();
+  }
+  #pragma omp target teams distribute parallel for simd
+  for (int i = 0; i < 10; ++i)
+  ;
+  #pragma omp target teams distribute parallel for simd
+  for (int i = 0; i < 10; ++i)
+  {
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+    argc++;
+  }
+
+  for (int i = 0; i < 10; ++i) {
+    switch(argc) {
+     case (0):
+      #pragma omp target teams distribute parallel for simd
+      for (int i = 0; i < 10; ++i)
+      {
+        foo();
+        break; // expected-error {{cannot break from a '#pragma omp target teams distribute parallel for simd' loop}}
+        continue;
+      }
+      default:
+       break;
+    }
+  }
+  #pragma omp target teams distribute parallel for simd default(none)
+  for (int i = 0; i < 10; ++i)
+  ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_misc_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,263 @@
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 100000 -fopenmp -verify %s
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp target teams distribute parallel for simd'}} */
+#pragma omp target teams distribute parallel for simd
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp target teams distribute parallel for simd'}} */
+#pragma omp target teams distribute parallel for simd foo
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp target teams distribute parallel for simd'}} */
+#pragma omp target teams distribute parallel for simd collapse
+
+void test_no_clause()
+{
+  int i;
+  #pragma omp target teams distribute parallel for simd
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_invalid_clause()
+{
+  int i;
+  /* expected-warning@+1 {{extra tokens at the end of '#pragma omp target teams distribute parallel for simd' are ignored}} */
+  #pragma omp target teams distribute parallel for simd foo bar
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_non_identifiers()
+{
+  int i, x;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp target teams distribute parallel for simd' are ignored}}
+  #pragma omp target teams distribute parallel for simd;
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp target teams distribute parallel for simd' are ignored}}
+  #pragma omp target teams distribute parallel for simd private(x);
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp target teams distribute parallel for simd' are ignored}}
+  #pragma omp target teams distribute parallel for simd , private(x);
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_private()
+{
+  int i;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp target teams distribute parallel for simd private(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd private(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd private(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd private()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd private(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp target teams distribute parallel for simd private(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp target teams distribute parallel for simd private(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for simd private(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for simd private(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_firstprivate()
+{
+  // TODO: tests on this.
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd firstprivate(
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_lastprivate()
+{
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd lastprivate(
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd lastprivate(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd lastprivate(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd lastprivate()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd lastprivate(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp target teams distribute parallel for simd lastprivate(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp target teams distribute parallel for simd lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for simd lastprivate(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for simd lastprivate(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_reduction()
+{
+  int i, x, y;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp target teams distribute parallel for simd reduction(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp target teams distribute parallel for simd reduction()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp target teams distribute parallel for simd reduction(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected identifier}} */
+  #pragma omp target teams distribute parallel for simd reduction(:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+4 {{expected ')'}} expected-note@+4 {{to match this '('}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd reduction(,
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp target teams distribute parallel for simd reduction(+
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  //
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd reduction(+:
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd reduction(+:)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd reduction(+:,y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd reduction(+:x,+:y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute parallel for simd reduction(%:x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target teams distribute parallel for simd reduction(+:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for simd reduction(*:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for simd reduction(-:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for simd reduction(&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for simd reduction(|:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for simd reduction(^:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for simd reduction(&&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for simd reduction(||:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for simd reduction(max:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute parallel for simd reduction(min:x)
+  for (i = 0; i < 16; ++i) ;
+  struct X { int x; };
+  struct X X;
+  // TODO: Is the following error correct?
+  // expected-error@+1 {{expected variable name}}
+  #pragma omp target teams distribute parallel for simd reduction(+:X.x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp target teams distribute parallel for simd reduction(+:x+x)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_multiple_clauses()
+{
+  int i;
+  float x = 0, y = 0, z = 0;
+  #pragma omp target teams distribute parallel for simd reduction(+:x, y) reduction(-:z) // OK
+  for (i = 0; i < 16; ++i);
+
+  // expected-error@+1 {{private variable cannot be lastprivate}} expected-note@+1 {{defined as private}}
+  #pragma omp target teams distribute parallel for simd private(x), lastprivate(x)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target teams distribute parallel for simd reduction(+:x, y), reduction(-:z)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target teams distribute parallel for simd reduction(+:x, y) reduction(-:z)
+  for (i = 0; i < 16; ++i);
+}
+
+void test_for()
+{
+  // expected-error@+3 {{expected '(' after 'for'}}
+  // expected-error@+2 2{{use of undeclared identifier 'i'}}
+  #pragma omp target teams distribute parallel for simd
+  for int i = 0; i < 16; i++);
+
+  // expected-error@+3 {{expected ')'}}
+  // expected-note@+2 {{to match this '('}}
+  #pragma omp target teams distribute parallel for simd
+  for (int i = 0; i < 16; i++;
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp target teams distribute parallel for simd
+  for (int i = 0 i < 16; i++);
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp target teams distribute parallel for simd
+  for (int i = 0; i < 16 i++);
+
+  // expected-error@+2 2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp target teams distribute parallel for simd
+  for (int i = 0 i < 16 i++);
+
+  int i = 0;
+  // expected-error@+2 {{initialization of for-loop does not have canonical form}}
+  #pragma omp target teams distribute parallel for simd
+  for (; i < 16; ++i);
+
+  // expected-error@+2 {{condition of for-loop does not have canonical form}}
+  #pragma omp target teams distribute parallel for simd
+  for (int i = 0; ; ++i);
+
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp target teams distribute parallel for simd
+  for (int i = 0; i < 16; );
+
+  // expected-error@+3 {{condition of for-loop does not have canonical form}}
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp target teams distribute parallel for simd
+  for (int i = 0; ;);
+
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_num_teams_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_num_teams_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_num_teams_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_num_teams_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute parallel for simd num_teams // expected-error {{expected '(' after 'num_teams'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd num_teams ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd num_teams () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd num_teams (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd num_teams (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd num_teams (foobool(argc)) num_teams(3) // expected-error {{directive '#pragma omp target teams distribute parallel for simd' cannot contain more than one 'num_teams' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd num_teams (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd num_teams (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd num_teams (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd num_teams (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd num_teams (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd num_teams (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd num_teams (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_thread_limit_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_thread_limit_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_simd_thread_limit_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_simd_thread_limit_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute parallel for simd thread_limit // expected-error {{expected '(' after 'thread_limit'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd thread_limit ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd thread_limit () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd thread_limit (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd thread_limit (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd thread_limit (foobool(argc)) thread_limit(3) // expected-error {{directive '#pragma omp target teams distribute parallel for simd' cannot contain more than one 'thread_limit' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd thread_limit (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd thread_limit (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd thread_limit (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd thread_limit (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd thread_limit (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd thread_limit (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for simd thread_limit (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_thread_limit_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_thread_limit_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_parallel_for_thread_limit_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_parallel_for_thread_limit_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute parallel for thread_limit // expected-error {{expected '(' after 'thread_limit'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for thread_limit ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for thread_limit () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for thread_limit (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for thread_limit (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for thread_limit (foobool(argc)) thread_limit(3) // expected-error {{directive '#pragma omp target teams distribute parallel for' cannot contain more than one 'thread_limit' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for thread_limit (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for thread_limit (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for thread_limit (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for thread_limit (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for thread_limit (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for thread_limit (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute parallel for thread_limit (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_private_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_private_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,126 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  static float S2s; // expected-note {{predetermined as shared}}
+};
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+};
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f;  // expected-note {{predetermined as shared}}
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+public:
+  S4(int v):a(v) { }
+};
+class S5 { // expected-note {{'S5' declared here}}
+  int a;
+  S5():a(0) {}
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;  // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp target teams distribute private // expected-error {{expected '(' after 'private'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private (argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private (a, b, c, d, f) // expected-error {{private variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private (argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private(ba)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private(ca) // expected-error {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private(da) // expected-error {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private(S2::S2s) // expected-error {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared(i), private(i) // expected-error {{shared variable cannot be private}} expected-note {{defined as shared}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private(i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp for private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target teams distribute firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target teams distribute reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp for lastprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp parallel private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp parallel firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp parallel reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_reduction_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_reduction_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_reduction_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_reduction_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,136 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+  S2 &operator +=(const S2 &arg) {return (*this);} // expected-note {{implicitly declared private here}}
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note {{predetermined as shared}}
+  static const float S2sc;
+};
+const float S2::S2sc = 0; // expected-note {{'S2sc' defined here}}
+S2 b; // expected-note {{'b' defined here}}
+const S2 ba[5]; // expected-note {{'ba' defined here}}
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(const S3 &s3):a(s3.a) { }
+  S3 operator +=(const S3 &arg1) {return arg1;}
+};
+int operator +=(const S3 &arg1, const S3 &arg2) {return 5;} // expected-note {{candidate function not viable: no known conversion from 'class S6' to 'const S3' for 1st argument}}
+S3 c; // expected-note {{'c' defined here}}
+const S3 ca[5]; // expected-note {{'ca' defined here}}
+extern const int f; // expected-note 2 {{'f' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+  S4(const S4 &s4);
+  S4 &operator +=(const S4 &arg) {return (*this);}
+public:
+  S4(int v):a(v) { }
+};
+S4 &operator &=(S4 &arg1, S4 &arg2) {return arg1;} // expected-note {{candidate function not viable: no known conversion from 'S5' to 'S4 &' for 1st argument}}
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+  S5 &operator +=(const S5 &arg);
+public:
+  S5(int v):a(v) { }
+};
+class S6 {
+    int a;
+  public:
+    S6():a(6){ }
+    operator int() { return 6; }
+} o;
+
+S3 h, k;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5; // expected-note 2 {{'d' defined here}}
+  const int da[5] = { 0 }; // expected-note {{'da' defined here}}
+  int qa[5] = { 0 };
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5);
+  int i;
+  int &j = i; // expected-note 2 {{'j' defined here}}
+  S3 &p = k;
+  const int &r = da[i]; // expected-note {{'r' defined here}}
+  int &q = qa[i]; // expected-note {{'q' defined here}}
+  float fl; // expected-note {{'fl' defined here}}
+  #pragma omp target teams distribute reduction // expected-error {{expected '(' after 'reduction'}} expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction + // expected-error {{expected '(' after 'reduction'}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction ( // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction (- // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction () // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction (*) // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction (\) // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction (&: argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction (| :argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction (|| :argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction (&& :argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction (^ : S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction (+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error {{'operator+=' is a private member of 'S2'}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction (min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' and 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction (max : argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction(+ : ba) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction(* : ca) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction(- : da) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction(^ : fl) // expected-error {{arguments of OpenMP clause 'reduction' with bitwise operators cannot be of floating type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{no viable overloaded '&='}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction(+ : o) // expected-error {{no viable overloaded '+='}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private(i), reduction(+ : j), reduction(+:q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp parallel shared(i)
+  #pragma omp target teams distribute reduction(min : i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp parallel reduction(min : i)
+  #pragma omp target teams distribute reduction(max : j) // expected-error {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_shared_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_shared_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_shared_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_shared_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,93 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+};
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  #pragma omp target teams distribute shared // expected-error {{expected '(' after 'shared'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared (argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared (a, b, c, d, f)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared (argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared(ba)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared(ca)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared(da)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared(e, g)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared(h) // expected-error {{threadprivate or thread local variable cannot be shared}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute private(i), shared(i) // expected-error {{private variable cannot be shared}} expected-note {{defined as private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp parallel private(i)
+  #pragma omp target teams distribute shared(i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute shared(j)
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,38 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  static int a;
+// CHECK: static int a;
+#pragma omp target teams distribute simd
+// CHECK:      #pragma omp target teams distribute simd
+  for (int i=0; i < 2; ++i)a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: a = 2;
+#pragma omp target teams distribute simd num_teams(a), thread_limit(c), default(none), private(argc,b),firstprivate(argv, c),shared(d,f),reduction(+:e) reduction(min : g) collapse(2), dist_schedule(static) if(a) map(to:c) map (from:d) map(tofrom:e) device(f)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j)foo();
+// CHECK-NEXT: #pragma omp target teams distribute simd num_teams(a) thread_limit(c) default(none) private(argc,b) firstprivate(argv,c) shared(d,f) reduction(+: e) reduction(min: g) collapse(2) dist_schedule(static) if(a) map(to: c) map(from: d) map(tofrom: e) device(f)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j)
+// CHECK-NEXT: foo();
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp target teams distribute simd dist_schedule(static, argc)
+// CHECK:      #pragma omp target teams distribute simd dist_schedule(static, argc)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_collapse_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_collapse_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_collapse_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_collapse_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; }
+  operator bool() { return f; }
+} v2;
+
+struct S3 {
+  int f;
+  operator int() { return f; }
+} v3;
+
+int main(int argc, char **argv) { // expected-note {{declared here}}
+  #pragma omp target teams distribute simd collapse // expected-error {{expected '(' after 'collapse'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd collapse ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd collapse () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd collapse (argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}} expected-note {{read of non-const variable 'argc' is not allowed in a constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd collapse (argc > 0 ? argv[1] : argv[2]) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd collapse (foobool(argc)) collapse(1) // expected-error {{directive '#pragma omp target teams distribute simd' cannot contain more than one 'collapse' clause}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd collapse (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd collapse (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd collapse (v1) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd collapse (v2) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd collapse (v3) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd collapse (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd collapse (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_default_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_default_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_default_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_default_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,20 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo();
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute simd default // expected-error {{expected '(' after 'default'}} expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd default ( // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd default () // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd default (none // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd default (shared), default(shared) // expected-error {{directive '#pragma omp target teams distribute simd' cannot contain more than one 'default' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd default (x) // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_dist_schedule_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_dist_schedule_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_dist_schedule_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_dist_schedule_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,35 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute simd dist_schedule // expected-error {{expected '(' after 'dist_schedule'}} expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd dist_schedule ( // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd dist_schedule () // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd dist_schedule (static // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd dist_schedule (static, // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd dist_schedule (argc)) // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}} expected-warning {{extra tokens at the end of '#pragma omp target teams distribute simd' are ignored}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd dist_schedule (static, argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd dist_schedule (static), dist_schedule (static, 1) // expected-error {{directive '#pragma omp target teams distribute simd' cannot contain more than one 'dist_schedule' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd dist_schedule (static, S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd dist_schedule (static, argv[1]=2) // expected-error {{statement requires expression of integer type ('char *' invalid)}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_firstprivate_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_firstprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,99 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s;
+  static const float S2sc;
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 { // expected-note {{'S5' declared here}}
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp target teams distribute simd firstprivate // expected-error {{expected '(' after 'firstprivate'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate (argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate (a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate (argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate(ba)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate(ca)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate(da)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate(S2::S2s)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate(S2::S2sc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private(i), firstprivate(i) // expected-error {{private variable cannot be firstprivate}} expected-note{{defined as private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate(i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_if_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_if_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_if_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_if_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,33 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute simd if // expected-error {{expected '(' after 'if'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd if () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp target teams distribute simd' are ignored}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd if (argc > 0 ? argv[1] : argv[2])
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp target teams distribute simd' cannot contain more than one 'if' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd if (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_loop_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_loop_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_loop_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_loop_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,172 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+namespace std {
+
+struct random_access_iterator_tag { };
+
+template <class Iter>
+struct iterator_traits {
+  typedef typename Iter::difference_type difference_type; // expected-error {{no type named 'difference_type' in 'Iter'}} expected-error {{no type named 'difference_type' in 'Iter1'}}
+  typedef typename Iter::iterator_category iterator_category; // expected-error {{no type named 'iterator_category' in 'Iter'}} expected-error {{no type named 'iterator_category' in 'Iter1'}} expected-error {{no type named 'iterator_category' in 'Iter2'}}
+};
+
+template <class Iter>
+typename iterator_traits<Iter>::difference_type distance(Iter first, Iter last) {
+  return first - last;
+}
+}
+
+class Iter {
+  public:
+    Iter() { }
+    Iter(const Iter &) { }
+    Iter operator ++() { return *this; }
+    Iter operator --() { return *this; }
+    bool operator <(Iter a) { return true; }
+    bool operator >=(Iter a) { return false; }
+};
+int operator -(Iter a, Iter b) { return 0; }
+class Iter1 {
+  public:
+    Iter1() { }
+    Iter1(const Iter1 &) { }
+    Iter1 operator ++() { return *this; }
+    Iter1 operator --() { return *this; }
+    bool operator <(Iter1 a) { return true; }
+    bool operator >=(Iter1 a) { return false; }
+};
+class Iter2 {
+  public:
+    Iter2() { }
+    Iter2(const Iter2 &) { }
+    Iter2 operator ++() { return *this; }
+    Iter2 operator --() { return *this; }
+    bool operator <(Iter2 a) { return true; }
+    bool operator >=(Iter2 a) { return false; }
+    typedef int difference_type;
+};
+int operator -(Iter2 a, Iter2 b) { return 0; }
+class Iter3 {
+  public:
+    Iter3() { }
+    Iter3(const Iter3 &) { }
+    Iter3 operator ++() { return *this; }
+    Iter3 operator --() { return *this; }
+    bool operator <(Iter3 a) { return true; }
+    bool operator >=(Iter3 a) { return false; }
+    typedef int difference_type;
+    typedef int iterator_category;
+};
+int operator -(Iter3 a, Iter3 b) { return 0; }
+class Iter4 {
+  public:
+    Iter4() { }
+    Iter4(const Iter4 &) { }
+    Iter4 operator ++() { return *this; }
+    Iter4 operator --() { return *this; }
+    bool operator <(Iter4 a) { return true; }
+    bool operator >=(Iter4 a) { return false; }
+    Iter4 operator+=(int) const {return Iter4();}
+    Iter4 operator-=(int) const {return Iter4();}
+    typedef int difference_type;
+    typedef std::random_access_iterator_tag iterator_category;
+};
+int operator -(Iter4 a, Iter4 b) { return 0; }
+
+int t;
+#pragma omp threadprivate(t)
+
+int main() {
+  #pragma omp target teams distribute simd
+  for (int i = 0; i < 10; i++)
+    ++i;
+  #pragma omp target teams distribute simd
+  for (t = 0; t < 10; t++)
+    ++t;
+  #pragma omp target teams distribute simd
+  for (int i; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target teams distribute simd
+  for (float i = 0; i < 10.0f; i++) // expected-error {{variable must be of integer or random access iterator type}}
+    ++i;
+  #pragma omp target teams distribute simd
+  for (int i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target teams distribute simd
+  for (int i = 0; i < 10; i |= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  int i;
+  #pragma omp target teams distribute simd
+  for (i = 0; i < 10; i++)
+    ++i;
+  #pragma omp target teams distribute simd
+  for (i--; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target teams distribute simd
+  for (i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target teams distribute simd
+  for (i = 0; i < 10; i ^= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  Iter begin, end;
+  #pragma omp target teams distribute simd
+  for (Iter I = begin; I >= end; ++I) // expected-error {{increment expression must cause 'I' to decrease on each iteration of the loop}}
+    ++I;
+  #pragma omp target teams distribute simd
+  for (Iter I = end; I < begin; --I) // expected-error {{increment expression must cause 'I' to increase on each iteration of the loop}}
+    ++I;
+  #pragma omp target teams distribute simd
+  for (Iter I = begin; I < end; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter>' requested here}} expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target teams distribute simd
+  for (Iter I = end; I >= begin; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter1 begin1;
+  #pragma omp target teams distribute simd
+  for (Iter1 I = begin1; I < begin1; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter1>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target teams distribute simd
+  for (Iter1 I = begin1; I >= begin1; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter2 begin2;
+  #pragma omp target teams distribute simd
+  for (Iter2 I = begin2; I < begin2; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter2>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target teams distribute simd
+  for (Iter2 I = begin2; I >= begin2; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter3 begin3;
+  #pragma omp target teams distribute simd
+  for (Iter3 I = begin3; I < begin3; ++I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target teams distribute simd
+  for (Iter3 I = begin3; I >= begin3; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter4 begin4;
+  #pragma omp target teams distribute simd
+  for (Iter4 I = begin4; I < begin4; ++I)
+    ++I;
+  #pragma omp target teams distribute simd
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  goto label; // expected-error {{use of undeclared label 'label'}}
+  #pragma omp target teams distribute simd
+  for (int i = 0; i < 100; ++i) {
+    label: ++i;
+  }
+  #pragma omp target teams distribute simd collapse(1)
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  #pragma omp target teams distribute simd collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+  for (Iter4 I1 = begin4; I1 >= begin4; --I1)
+  for (Iter4 I2 = begin4; I2 >= begin4; --I2)
+    ++I;
+  #pragma omp target teams distribute simd collapse(0) // expected-error {{expression is not a positive integer value}}
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  #pragma omp target teams distribute simd collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I; // expected-error {{only for-loops are allowed for '#pragma omp target teams distribute simd'}}
+  ++begin4; 
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_loop_messages1.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_loop_messages1.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_loop_messages1.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_loop_messages1.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,10 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int main() {
+  int i;
+  goto label; // expected-error {{use of undeclared label 'label'}}
+  #pragma omp target teams distribute simd
+  for (i = 0; i < 100; ++i) {
+    label: ++i;
+  }
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_map_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_map_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_map_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_map_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,119 @@
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note 2 {{mappable type cannot contain static members}}
+  static const float S2sc; // expected-note 2 {{mappable type cannot contain static members}}
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-error {{threadprivate variables cannot be used in target constructs}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  int *k = &j;
+  const int (&l)[5] = da;
+  #pragma omp target teams distribute simd map // expected-error {{expected '(' after 'map'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map (alloc) // expected-error {{expected expression}}  expected-error {{expected ':' in 'map' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map (to argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error{{expected ':' in 'map' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map (from: argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map (tofrom: argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map (argc)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map (a, b, c, d, f) // expected-error {{incomplete type 'S1' where a complete type is required}} expected-error 2 {{type 'S2' is not mappable to target}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map (argv[1])
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map(ba) // expected-error 2 {{type 'S2' is not mappable to target}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map(ca)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map(da)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map(S2::S2s)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map(S2::S2sc)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map(e, g)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map(h) // expected-note {{used here}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map(k), map(k[:10]) // expected-error {{variable already marked as mapped in current construct}} expected-note {{used here}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map(da)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map(da[:4])
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(k) // expected-note {{used here}}
+  #pragma omp target teams distribute simd map(k[:4]) // expected-error {{variable already marked as mapped in current construct}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map(j)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(l) // expected-note {{used here}}
+  #pragma omp target teams distribute simd map(l[:5]) // expected-error {{variable already marked as mapped in current construct}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(k[:5]) // expected-note {{used here}}
+  #pragma omp target teams distribute simd map(k) // expected-error {{variable already marked as mapped in current construct}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target teams distribute simd map(j)
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target map(l[:5]) // expected-note {{used here}}
+  #pragma omp target teams distribute simd map(l) // expected-error {{variable already marked as mapped in current construct}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_messages.c cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_messages.c
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,22 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() { }
+
+int main(int argc, char **argv) {
+  L1:
+    foo();
+  #pragma omp target teams distribute simd
+  for(int i = 0; i < argc; ++i)
+  {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+  #pragma omp target teams distribute simd
+  for(int i = 0; i < argc; ++i) {
+    L2:
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,34 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+#pragma omp target teams distribute simd // expected-error {{unexpected OpenMP directive '#pragma omp target teams distribute simd'}}
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute simd
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  {
+  #pragma omp target teams distribute simd
+  for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target teams distribute simd unknown() // expected-warning {{extra tokens at the end of '#pragma omp target teams distribute simd' are ignored}}
+  for (int i = 0; i < argc; ++i) foo();
+  L1:
+    for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd
+  for (int i = 0; i < argc; ++i)
+  {
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+    argc++;
+  }
+
+  #pragma omp target teams distribute simd default(none)
+  for (int i = 0; i < 10; ++i)
+  ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_misc_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,453 @@
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 100000 -fopenmp -verify %s
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp target teams distribute simd'}} */
+#pragma omp target teams distribute simd
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp target teams distribute simd'}} */
+#pragma omp target teams distribute simd foo
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp target teams distribute simd'}} */
+#pragma omp target teams distribute simd safelen(4)
+
+void test_no_clause()
+{
+  int i;
+  #pragma omp target teams distribute simd
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_invalid_clause()
+{
+  int i;
+  /* expected-warning@+1 {{extra tokens at the end of '#pragma omp target teams distribute simd' are ignored}} */
+  #pragma omp target teams distribute simd foo bar
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_non_identifiers()
+{
+  int i, x;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp target teams distribute simd' are ignored}}
+  #pragma omp target teams distribute simd;
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp target teams distribute simd' are ignored}}
+  #pragma omp target teams distribute simd private(x);
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp target teams distribute simd' are ignored}}
+  #pragma omp target teams distribute simd , private(x);
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_safelen()
+{
+  int i;
+  /* expected-error@+1 {{expected '('}}  expected-error@+1 {{expected expression}}*/
+  #pragma omp target teams distribute simd safelen
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}} */
+  #pragma omp target teams distribute simd safelen(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd safelen()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp target teams distribute simd safelen(,
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp target teams distribute simd' are ignored}}
+  /* expected-error@+1 {{expected expression}}  expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp target teams distribute simd safelen(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected '('}} */
+  #pragma omp target teams distribute simd safelen 4)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp target teams distribute simd safelen(4
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp target teams distribute simd safelen(4,
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp target teams distribute simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp target teams distribute simd safelen(4,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd safelen(4)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp target teams distribute simd safelen(4 4)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp target teams distribute simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp target teams distribute simd safelen(4,,4)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd safelen(4)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp target teams distribute simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp target teams distribute simd safelen(4,8)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_linear()
+{
+  int i;
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}} */
+  #pragma omp target teams distribute simd linear(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp target teams distribute simd linear(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd linear(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd linear()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd linear(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp target teams distribute simd linear(0)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{use of undeclared identifier 'x'}} */
+  #pragma omp target teams distribute simd linear(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{use of undeclared identifier 'x'}} */
+  /* expected-error@+1 {{use of undeclared identifier 'y'}} */
+  #pragma omp target teams distribute simd linear(x, y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+3 {{use of undeclared identifier 'x'}} */
+  /* expected-error@+2 {{use of undeclared identifier 'y'}} */
+  /* expected-error@+1 {{use of undeclared identifier 'z'}} */
+  #pragma omp target teams distribute simd linear(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd linear(x:)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd linear(x:,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd linear(x:1)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd linear(x:2*2)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp target teams distribute simd' are ignored}}
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp target teams distribute simd linear(x:1,y)
+  for (i = 0; i < 16; ++i) ;
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp target teams distribute simd' are ignored}}
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp target teams distribute simd linear(x:1,y,z:1)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be linear}}
+  #pragma omp target teams distribute simd linear(x) linear(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as private}}
+  // expected-error@+1 {{private variable cannot be linear}}
+  #pragma omp target teams distribute simd private(x) linear(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be private}}
+  #pragma omp target teams distribute simd linear(x) private(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be lastprivate}}
+  #pragma omp target teams distribute simd linear(x) lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-note@+2 {{defined as lastprivate}}
+  // expected-error@+1 {{lastprivate variable cannot be linear}}
+  #pragma omp target teams distribute simd lastprivate(x) linear(x) 
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_private()
+{
+  int i;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp target teams distribute simd private(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute simd private(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute simd private(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd private()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd private(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp target teams distribute simd private(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp target teams distribute simd private(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd private(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd private(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_firstprivate()
+{
+  // TODO: tests on this.
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd firstprivate(
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_lastprivate()
+{
+  int i;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd lastprivate(
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute simd lastprivate(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute simd lastprivate(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd lastprivate()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd lastprivate(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp target teams distribute simd lastprivate(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp target teams distribute simd lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd lastprivate(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd lastprivate(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_reduction()
+{
+  int i, x, y;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp target teams distribute simd reduction(
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp target teams distribute simd reduction()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp target teams distribute simd reduction(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected identifier}} */
+  #pragma omp target teams distribute simd reduction(:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+4 {{expected ')'}} expected-note@+4 {{to match this '('}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute simd reduction(,
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp target teams distribute simd reduction(+
+  for (i = 0; i < 16; ++i) ;
+
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  //
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd reduction(+:
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd reduction(+:)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd reduction(+:,y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd reduction(+:x,+:y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd reduction(%:x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target teams distribute simd reduction(+:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd reduction(*:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd reduction(-:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd reduction(&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd reduction(|:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd reduction(^:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd reduction(&&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd reduction(||:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd reduction(max:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target teams distribute simd reduction(min:x)
+  for (i = 0; i < 16; ++i) ;
+  struct X { int x; };
+  struct X X;
+  // TODO: Is the following error correct?
+  // expected-error@+1 {{expected variable name}}
+  #pragma omp target teams distribute simd reduction(+:X.x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp target teams distribute simd reduction(+:x+x)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_aligned()
+{
+  int i;
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp target teams distribute simd aligned(
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute simd aligned(,
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp target teams distribute simd aligned(,)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd aligned()
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp target teams distribute simd aligned(int)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp target teams distribute simd aligned(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int *x, y, z[25];
+  #pragma omp target teams distribute simd aligned(x)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp target teams distribute simd aligned(x, y)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp target teams distribute simd aligned(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target teams distribute simd aligned(x:4)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp target teams distribute simd aligned(x, y:8)
+  for (i = 0; i < 16; ++i) ;
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp target teams distribute simd aligned(x, y, z:10+6)
+  for (i = 0; i < 16; ++i) ;
+  // expected-error@+2 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}}
+  // expected-error@+1 {{expression is not an integer constant expression}}
+  #pragma omp target teams distribute simd aligned(x, y, z:x)
+  for (i = 0; i < 16; ++i) ;
+  // expected-note@+2 {{defined as aligned}}
+  // expected-error@+1 {{aligned variable cannot be aligned}}
+  #pragma omp target teams distribute simd aligned(x:16) aligned(z,x:16)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_multiple_clauses()
+{
+  int i;
+  float x = 0, y = 0, z = 0;
+  #pragma omp target teams distribute simd safelen(4) reduction(+:x, y) reduction(-:z) // OK
+  for (i = 0; i < 16; ++i);
+
+  // expected-error@+1 {{private variable cannot be lastprivate}} expected-note@+1 {{defined as private}}
+  #pragma omp target teams distribute simd private(x), lastprivate(x)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target teams distribute simd safelen(4) reduction(+:x, y), reduction(-:z)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target teams distribute simd reduction(+:x, y) reduction(-:z)
+  for (i = 0; i < 16; ++i);
+}
+
+void test_for()
+{
+  // expected-error@+3 {{expected '(' after 'for'}}
+  // expected-error@+2 2{{use of undeclared identifier 'i'}}
+  #pragma omp target teams distribute simd
+  for int i = 0; i < 16; i++);
+
+  // expected-error@+3 {{expected ')'}}
+  // expected-note@+2 {{to match this '('}}
+  #pragma omp target teams distribute simd
+  for (int i = 0; i < 16; i++;
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp target teams distribute simd
+  for (int i = 0 i < 16; i++);
+
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp target teams distribute simd
+  for (int i = 0; i < 16 i++);
+
+  // expected-error@+2 2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp target teams distribute simd
+  for (int i = 0 i < 16 i++);
+
+  int i = 0;
+  // expected-error@+2 {{initialization of for-loop does not have canonical form}}
+  #pragma omp target teams distribute simd
+  for (; i < 16; ++i);
+
+  // expected-error@+2 {{condition of for-loop does not have canonical form}}
+  #pragma omp target teams distribute simd
+  for (int i = 0; ; ++i);
+
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp target teams distribute simd
+  for (int i = 0; i < 16; );
+
+  // expected-error@+3 {{condition of for-loop does not have canonical form}}
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp target teams distribute simd
+  for (int i = 0; ;);
+
+}
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_num_teams_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_num_teams_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_num_teams_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_num_teams_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute simd num_teams // expected-error {{expected '(' after 'num_teams'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd num_teams( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd num_teams() // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd num_teams(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd num_teams(argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd num_teams(foobool(argc)) num_teams(3) // expected-error {{directive '#pragma omp target teams distribute simd' cannot contain more than one 'num_teams' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd num_teams(S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd num_teams(argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd num_teams (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd num_teams(v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd num_teams(v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd num_teams(0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd num_teams(-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_private_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_private_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,129 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  static float S2s; // expected-note {{predetermined as shared}}
+};
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+};
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f;  // expected-note {{predetermined as shared}}
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+public:
+  S4(int v):a(v) { }
+};
+class S5 { // expected-note {{'S5' declared here}}
+  int a;
+  S5():a(0) {}
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;  // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp target teams distribute simd private // expected-error {{expected '(' after 'private'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private (argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private (a, b, c, d, f) // expected-error {{private variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private (argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private(ba)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private(ca) // expected-error {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private(da) // expected-error {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private(S2::S2s) // expected-error {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared(i), private(i) // expected-error {{shared variable cannot be private}} expected-note {{defined as shared}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private(i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp for private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target teams
+  #pragma omp parallel for firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target teams
+  #pragma omp parallel for reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target teams
+  #pragma omp parallel for lastprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp parallel private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp parallel firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp parallel reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_reduction_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_reduction_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_reduction_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_reduction_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,136 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+  S2 &operator +=(const S2 &arg) {return (*this);} // expected-note {{implicitly declared private here}}
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note {{predetermined as shared}}
+  static const float S2sc;
+};
+const float S2::S2sc = 0; // expected-note {{'S2sc' defined here}}
+S2 b; // expected-note {{'b' defined here}}
+const S2 ba[5]; // expected-note {{'ba' defined here}}
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(const S3 &s3):a(s3.a) { }
+  S3 operator +=(const S3 &arg1) {return arg1;}
+};
+int operator +=(const S3 &arg1, const S3 &arg2) {return 5;} // expected-note {{candidate function not viable: no known conversion from 'class S6' to 'const S3' for 1st argument}}
+S3 c; // expected-note {{'c' defined here}}
+const S3 ca[5]; // expected-note {{'ca' defined here}}
+extern const int f; // expected-note 2 {{'f' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+  S4(const S4 &s4);
+  S4 &operator +=(const S4 &arg) {return (*this);}
+public:
+  S4(int v):a(v) { }
+};
+S4 &operator &=(S4 &arg1, S4 &arg2) {return arg1;} // expected-note {{candidate function not viable: no known conversion from 'S5' to 'S4 &' for 1st argument}}
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+  S5 &operator +=(const S5 &arg);
+public:
+  S5(int v):a(v) { }
+};
+class S6 {
+    int a;
+  public:
+    S6():a(6){ }
+    operator int() { return 6; }
+} o;
+
+S3 h, k;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5; // expected-note 2 {{'d' defined here}}
+  const int da[5] = { 0 }; // expected-note {{'da' defined here}}
+  int qa[5] = { 0 };
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5);
+  int i;
+  int &j = i; // expected-note 2 {{'j' defined here}}
+  S3 &p = k;
+  const int &r = da[i]; // expected-note {{'r' defined here}}
+  int &q = qa[i]; // expected-note {{'q' defined here}}
+  float fl; // expected-note {{'fl' defined here}}
+  #pragma omp target teams distribute simd reduction // expected-error {{expected '(' after 'reduction'}} expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction + // expected-error {{expected '(' after 'reduction'}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction ( // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction (- // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction () // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction (*) // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction (\) // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction (&: argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction (| :argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction (|| :argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction (&& :argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction (^ : S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction (+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error {{'operator+=' is a private member of 'S2'}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction (min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' and 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction (max : argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction(+ : ba) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction(* : ca) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction(- : da) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction(^ : fl) // expected-error {{arguments of OpenMP clause 'reduction' with bitwise operators cannot be of floating type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{no viable overloaded '&='}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction(+ : o) // expected-error {{no viable overloaded '+='}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private(i), reduction(+ : j), reduction(+:q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp parallel shared(i)
+  #pragma omp target teams distribute simd reduction(min : i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp parallel reduction(min : i)
+  #pragma omp target teams distribute simd reduction(max : j) // expected-error {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_shared_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_shared_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_shared_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_shared_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,93 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+};
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  #pragma omp target teams distribute simd shared // expected-error {{expected '(' after 'shared'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared (argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared (a, b, c, d, f)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared (argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared(ba)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared(ca)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared(da)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared(e, g)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared(h) // expected-error {{threadprivate or thread local variable cannot be shared}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd private(i), shared(i) // expected-error {{private variable cannot be shared}} expected-note {{defined as private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp parallel private(i)
+  #pragma omp target teams distribute simd shared(i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd shared(j)
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_thread_limit_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_thread_limit_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_simd_thread_limit_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_simd_thread_limit_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute simd thread_limit // expected-error {{expected '(' after 'thread_limit'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd thread_limit ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd thread_limit () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd thread_limit (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd thread_limit (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd thread_limit (foobool(argc)) thread_limit(3) // expected-error {{directive '#pragma omp target teams distribute simd' cannot contain more than one 'thread_limit' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd thread_limit (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd thread_limit (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd thread_limit (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd thread_limit (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd thread_limit (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd thread_limit (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute simd thread_limit (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_distribute_thread_limit_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_thread_limit_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_distribute_thread_limit_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_distribute_thread_limit_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target teams distribute thread_limit // expected-error {{expected '(' after 'thread_limit'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute thread_limit ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute thread_limit () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute thread_limit (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute thread_limit (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute thread_limit (foobool(argc)) thread_limit(3) // expected-error {{directive '#pragma omp target teams distribute' cannot contain more than one 'thread_limit' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute thread_limit (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute thread_limit (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute thread_limit (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute thread_limit (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute thread_limit (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute thread_limit (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target teams distribute thread_limit (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_firstprivate_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_firstprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,99 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s;
+  static const float S2sc;
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 { // expected-note {{'S5' declared here}}
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp target teams firstprivate // expected-error {{expected '(' after 'firstprivate'}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams firstprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams firstprivate () // expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams firstprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams firstprivate (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams firstprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target teams firstprivate (argc)
+  foo();
+  #pragma omp target teams firstprivate (S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target teams firstprivate (a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
+  foo();
+  #pragma omp target teams firstprivate (argv[1]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target teams firstprivate(ba)
+  foo();
+  #pragma omp target teams firstprivate(ca)
+  foo();
+  #pragma omp target teams firstprivate(da)
+  foo();
+  #pragma omp target teams firstprivate(S2::S2s)
+  foo();
+  #pragma omp target teams firstprivate(S2::S2sc)
+  foo();
+  #pragma omp target teams firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
+  foo();
+  #pragma omp target teams firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
+  foo();
+  #pragma omp target teams private(i), firstprivate(i) // expected-error {{private variable cannot be firstprivate}} expected-note{{defined as private}}
+  foo();
+  #pragma omp target teams firstprivate(i)
+  foo();
+  #pragma omp target teams firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_if_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_if_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_if_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_if_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,33 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+int main(int argc, char **argv) {
+  #pragma omp target teams if // expected-error {{expected '(' after 'if'}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams if () // expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp target teams' are ignored}}
+  foo();
+  #pragma omp target teams if (argc > 0 ? argv[1] : argv[2])
+  foo();
+  #pragma omp target teams if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp target teams' cannot contain more than one 'if' clause}}
+  foo();
+  #pragma omp target teams if (S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target teams if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_map_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_map_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_map_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_map_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,114 @@
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note 2 {{mappable type cannot contain static members}}
+  static const float S2sc; // expected-note 2 {{mappable type cannot contain static members}}
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-error {{threadprivate variables cannot be used in target constructs}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  int *k = &j;
+  const int (&l)[5] = da;
+  #pragma omp target teams map // expected-error {{expected '(' after 'map'}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams map ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams map () // expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams map (alloc) // expected-error {{expected expression}}  expected-error {{expected ':' in 'map' clause}}
+  foo();
+  #pragma omp target teams map (to argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error{{expected ':' in 'map' clause}}
+  foo();
+  #pragma omp target teams map (from: argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams map (tofrom: argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target teams map (argc)
+  foo();
+  #pragma omp target teams map (S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target teams map (a, b, c, d, f) // expected-error {{incomplete type 'S1' where a complete type is required}} expected-error 2 {{type 'S2' is not mappable to target}}
+  foo();
+  #pragma omp target teams map (argv[1])
+  foo();
+  #pragma omp target teams map(ba) // expected-error 2 {{type 'S2' is not mappable to target}}
+  foo();
+  #pragma omp target teams map(ca)
+  foo();
+  #pragma omp target teams map(da)
+  foo();
+  #pragma omp target teams map(S2::S2s)
+  foo();
+  #pragma omp target teams map(S2::S2sc)
+  foo();
+  #pragma omp target teams map(e, g)
+  foo();
+  #pragma omp target teams map(h) // expected-note {{used here}}
+  foo();
+  #pragma omp target teams map(k), map(k[:10]) // expected-error {{variable already marked as mapped in current construct}} expected-note {{used here}}
+  foo();
+  #pragma omp target map(da)
+  #pragma omp target teams map(da[:4])
+  foo();
+  #pragma omp target map(k, j, l) // expected-note {{used here}}
+  #pragma omp target teams map(k[:4]) // expected-error {{variable already marked as mapped in current construct}}
+  foo();
+  #pragma omp target map(k, j, l) // expected-note {{used here}}
+  #pragma omp target map(j)
+  #pragma omp target teams map(l[:5]) // expected-error {{variable already marked as mapped in current construct}}
+  foo();
+  #pragma omp target map(k[:4], j, l[:5]) // expected-note 2 {{used here}}
+  #pragma omp target teams map(k) // expected-error {{variable already marked as mapped in current construct}}
+  #pragma omp target map(j)
+  #pragma omp target teams map(l) // expected-error {{variable already marked as mapped in current construct}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_messages.c cfe-3.5.0.src.omp/test/OpenMP/target_teams_messages.c
--- cfe-3.5.0.src/test/OpenMP/target_teams_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,19 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() { }
+
+int main(int argc, char **argv) {
+  L1:
+    foo();
+  #pragma omp target teams
+  {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+  #pragma omp target teams
+  L2:
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,40 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+#pragma omp target teams // expected-error {{unexpected OpenMP directive '#pragma omp target teams'}}
+
+int main(int argc, char **argv) {
+  #pragma omp target teams
+  foo();
+  #pragma omp target teams unknown() // expected-warning {{extra tokens at the end of '#pragma omp target teams' are ignored}}
+  foo();
+  L1:
+    foo();
+  #pragma omp target teams
+  ;
+  #pragma omp target teams
+  {
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+    argc++;
+  }
+
+  for (int i = 0; i < 10; ++i) {
+    switch(argc) {
+     case (0):
+      #pragma omp target teams
+      {
+        foo();
+        break; // expected-error {{'break' statement not in loop or switch statement}}
+        continue; // expected-error {{'continue' statement not in loop statement}}
+      }
+      default:
+       break;
+    }
+  }
+  #pragma omp target teams default(none)
+  ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_num_teams_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_num_teams_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_num_teams_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_num_teams_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target teams num_teams // expected-error {{expected '(' after 'num_teams'}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams num_teams ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams num_teams () // expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams num_teams (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams num_teams (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  foo();
+  #pragma omp target teams num_teams (foobool(argc)) num_teams(3) // expected-error {{directive '#pragma omp target teams' cannot contain more than one 'num_teams' clause}}
+  foo();
+  #pragma omp target teams num_teams (S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target teams num_teams (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  foo();
+  #pragma omp target teams num_teams (v1) // expected-error {{expression has incomplete type 'S1'}}
+  foo();
+  #pragma omp target teams num_teams (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  foo();
+  #pragma omp target teams num_teams (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  foo();
+  #pragma omp target teams num_teams (0) // expected-error {{expression is not a positive integer value}}
+  foo();
+  #pragma omp target teams num_teams (-1) // expected-error {{expression is not a positive integer value}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_private_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_private_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,129 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  static float S2s; // expected-note {{predetermined as shared}}
+};
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+};
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f;  // expected-note {{predetermined as shared}}
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+public:
+  S4(int v):a(v) { }
+};
+class S5 { // expected-note {{'S5' declared here}}
+  int a;
+  S5():a(0) {}
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;  // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp target teams private // expected-error {{expected '(' after 'private'}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams private () // expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams private (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams private (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams private (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target teams private (argc)
+  foo();
+  #pragma omp target teams private (S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target teams private (a, b, c, d, f) // expected-error {{private variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be private}}
+  foo();
+  #pragma omp target teams private (argv[1]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target teams private(ba)
+  foo();
+  #pragma omp target teams private(ca) // expected-error {{shared variable cannot be private}}
+  foo();
+  #pragma omp target teams private(da) // expected-error {{shared variable cannot be private}}
+  foo();
+  #pragma omp target teams private(S2::S2s) // expected-error {{shared variable cannot be private}}
+  foo();
+  #pragma omp target teams private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
+  foo();
+  #pragma omp target teams private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
+  foo();
+  #pragma omp target teams shared(i), private(i) // expected-error {{shared variable cannot be private}} expected-note {{defined as shared}}
+  foo();
+  #pragma omp target teams private(i)
+  foo();
+  #pragma omp target teams private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
+  foo();
+  #pragma omp for private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams private(i)
+    foo();
+  }
+  #pragma omp target teams
+  #pragma omp parallel for firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams private(i)
+    foo();
+  }
+  #pragma omp target teams
+  #pragma omp parallel for reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams private(i)
+    foo();
+  }
+  #pragma omp target teams
+  #pragma omp parallel for lastprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams private(i)
+    foo();
+  }
+  #pragma omp parallel private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams private(i)
+    foo();
+  }
+  #pragma omp parallel firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams private(i)
+    foo();
+  }
+  #pragma omp parallel reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target teams private(i)
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_reduction_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_reduction_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_reduction_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_reduction_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,136 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+  S2 &operator +=(const S2 &arg) {return (*this);} // expected-note {{implicitly declared private here}}
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note {{predetermined as shared}}
+  static const float S2sc;
+};
+const float S2::S2sc = 0; // expected-note {{'S2sc' defined here}}
+S2 b; // expected-note {{'b' defined here}}
+const S2 ba[5]; // expected-note {{'ba' defined here}}
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(const S3 &s3):a(s3.a) { }
+  S3 operator +=(const S3 &arg1) {return arg1;}
+};
+int operator +=(const S3 &arg1, const S3 &arg2) {return 5;} // expected-note {{candidate function not viable: no known conversion from 'class S6' to 'const S3' for 1st argument}}
+S3 c; // expected-note {{'c' defined here}}
+const S3 ca[5]; // expected-note {{'ca' defined here}}
+extern const int f; // expected-note 2 {{'f' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+  S4(const S4 &s4);
+  S4 &operator +=(const S4 &arg) {return (*this);}
+public:
+  S4(int v):a(v) { }
+};
+S4 &operator &=(S4 &arg1, S4 &arg2) {return arg1;} // expected-note {{candidate function not viable: no known conversion from 'S5' to 'S4 &' for 1st argument}}
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+  S5 &operator +=(const S5 &arg);
+public:
+  S5(int v):a(v) { }
+};
+class S6 {
+    int a;
+  public:
+    S6():a(6){ }
+    operator int() { return 6; }
+} o;
+
+S3 h, k;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5; // expected-note 2 {{'d' defined here}}
+  const int da[5] = { 0 }; // expected-note {{'da' defined here}}
+  int qa[5] = { 0 };
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5);
+  int i;
+  int &j = i; // expected-note 2 {{'j' defined here}}
+  S3 &p = k;
+  const int &r = da[i]; // expected-note {{'r' defined here}}
+  int &q = qa[i]; // expected-note {{'q' defined here}}
+  float fl; // expected-note {{'fl' defined here}}
+  #pragma omp target teams reduction // expected-error {{expected '(' after 'reduction'}} expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  foo();
+  #pragma omp target teams reduction + // expected-error {{expected '(' after 'reduction'}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams reduction ( // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams reduction (- // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams reduction () // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  foo();
+  #pragma omp target teams reduction (*) // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams reduction (\) // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams reduction (&: argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams reduction (| :argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams reduction (|| :argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target teams reduction (&& :argc)
+  foo();
+  #pragma omp target teams reduction (^ : S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target teams reduction (+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error {{'operator+=' is a private member of 'S2'}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  foo();
+  #pragma omp target teams reduction (min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' and 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  foo();
+  #pragma omp target teams reduction (max : argv[1]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target teams reduction(+ : ba) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  foo();
+  #pragma omp target teams reduction(* : ca) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  foo();
+  #pragma omp target teams reduction(- : da) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  foo();
+  #pragma omp target teams reduction(^ : fl) // expected-error {{arguments of OpenMP clause 'reduction' with bitwise operators cannot be of floating type}}
+  foo();
+  #pragma omp target teams reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
+  foo();
+  #pragma omp target teams reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
+  foo();
+  #pragma omp target teams reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{no viable overloaded '&='}}
+  foo();
+  #pragma omp target teams reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
+  foo();
+  #pragma omp target teams reduction(+ : o) // expected-error {{no viable overloaded '+='}}
+  foo();
+  #pragma omp target teams private(i), reduction(+ : j), reduction(+:q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  foo();
+  #pragma omp target teams reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
+  foo();
+  #pragma omp target teams reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
+  foo();
+  #pragma omp parallel shared(i)
+  #pragma omp target teams reduction(min : i)
+  foo();
+  #pragma omp parallel reduction(min : i)
+  #pragma omp target teams reduction(max : j) // expected-error {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_shared_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_shared_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_shared_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_shared_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,93 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+};
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  #pragma omp target teams shared // expected-error {{expected '(' after 'shared'}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams shared ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams shared () // expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams shared (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams shared (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams shared (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target teams shared (argc)
+  foo();
+  #pragma omp target teams shared (S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target teams shared (a, b, c, d, f)
+  foo();
+  #pragma omp target teams shared (argv[1]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target teams shared(ba)
+  foo();
+  #pragma omp target teams shared(ca)
+  foo();
+  #pragma omp target teams shared(da)
+  foo();
+  #pragma omp target teams shared(e, g)
+  foo();
+  #pragma omp target teams shared(h) // expected-error {{threadprivate or thread local variable cannot be shared}}
+  foo();
+  #pragma omp target teams private(i), shared(i) // expected-error {{private variable cannot be shared}} expected-note {{defined as private}}
+  foo();
+  #pragma omp parallel private(i)
+  #pragma omp target teams shared(i)
+  foo();
+  #pragma omp target teams shared(j)
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_teams_thread_limit_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_teams_thread_limit_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_teams_thread_limit_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_teams_thread_limit_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,54 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target teams thread_limit // expected-error {{expected '(' after 'thread_limit'}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams thread_limit ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams thread_limit () // expected-error {{expected expression}}
+  foo();
+  #pragma omp target teams thread_limit (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target teams thread_limit (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  foo();
+  #pragma omp target teams thread_limit (foobool(argc)) thread_limit(3) // expected-error {{directive '#pragma omp target teams' cannot contain more than one 'thread_limit' clause}}
+  foo();
+  #pragma omp target teams thread_limit (S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target teams thread_limit (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  foo();
+  #pragma omp target teams thread_limit (v1) // expected-error {{expression has incomplete type 'S1'}}
+  foo();
+  #pragma omp target teams thread_limit (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  foo();
+  #pragma omp target teams thread_limit (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  foo();
+  #pragma omp target teams thread_limit (0) // expected-error {{expression is not a positive integer value}}
+  foo();
+  #pragma omp target teams thread_limit (-1) // expected-error {{expression is not a positive integer value}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_update_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/target_update_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/target_update_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_update_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,26 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  static int a;
+// CHECK: static int a;
+#pragma omp target update
+// CHECK:      #pragma omp target update
+  a=2;
+// CHECK-NEXT: a = 2;
+#pragma omp target update if(b) device(c+e) from(c) to(e, f)
+// CHECK:      #pragma omp target update if(b) device(c + e) from(c) to(e,f)
+  foo();
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_update_device_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_update_device_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_update_device_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_update_device_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,42 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target update device // expected-error {{expected '(' after 'device'}} expected-error {{expected expression}}
+  #pragma omp target update device ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target update device () // expected-error {{expected expression}}
+  #pragma omp target update device (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target update device (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  #pragma omp target update device (foobool(argc)) device(3) // expected-error {{directive '#pragma omp target update' cannot contain more than one 'device' clause}}
+  #pragma omp target update device (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp target update device (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  #pragma omp target update device (v1) // expected-error {{expression has incomplete type 'S1'}}
+  #pragma omp target update device (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  #pragma omp target update device (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  #pragma omp target update device (0)
+  #pragma omp target update device (-1) // expected-error {{expression is not a positive integer value}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_update_from_to_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_update_from_to_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_update_from_to_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_update_from_to_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,106 @@
+// RUN: %clang_cc1 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note 2 {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note 4 {{mappable type cannot contain static members}}
+  static const float S2sc; // expected-note 4 {{mappable type cannot contain static members}}
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-error 2 {{threadprivate variables cannot be used in target constructs}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  int *k = &j;
+  const int (&l)[5] = da;
+  #pragma omp target update from // expected-error {{expected '(' after 'from'}} expected-error {{expected expression}}
+  #pragma omp target update from ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target update from () // expected-error {{expected expression}}
+  #pragma omp target update from (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target update from (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target update from (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  #pragma omp target update from (argc)
+  #pragma omp target update from (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp target update from (a, b, c, d, f) // expected-error {{incomplete type 'S1' where a complete type is required}} expected-error 2 {{type 'S2' is not mappable to target}}
+  #pragma omp target update from (argv[1])
+  #pragma omp target update from(ba) // expected-error 2 {{type 'S2' is not mappable to target}}
+  #pragma omp target update from(ca)
+  #pragma omp target update from(da)
+  #pragma omp target update from(S2::S2s)
+  #pragma omp target update from(S2::S2sc)
+  #pragma omp target update from(e, g)
+  #pragma omp target update from(h) // expected-note {{used here}}
+  #pragma omp target update from(k), from(k[:10]) // expected-error {{variable can appear only once in OpenMP 'target update' construct}} expected-note {{used here}}
+  foo();
+  #pragma omp target update from(da)
+  #pragma omp target update from(da[:4])
+  foo();
+
+  #pragma omp target update to // expected-error {{expected '(' after 'to'}} expected-error {{expected expression}}
+  #pragma omp target update to ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target update to () // expected-error {{expected expression}}
+  #pragma omp target update to (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target update to (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target update to (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  #pragma omp target update to (argc)
+  #pragma omp target update to (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp target update to (a, b, c, d, f) // expected-error {{incomplete type 'S1' where a complete type is required}} expected-error 2 {{type 'S2' is not mappable to target}}
+  #pragma omp target update to (argv[1])
+  #pragma omp target update to(ba) // expected-error 2 {{type 'S2' is not mappable to target}}
+  #pragma omp target update to(ca)
+  #pragma omp target update to(da)
+  #pragma omp target update to(S2::S2s)
+  #pragma omp target update to(S2::S2sc)
+  #pragma omp target update to(e, g)
+  #pragma omp target update to(h) // expected-note {{used here}}
+  #pragma omp target update to(k), to(k[:10]) // expected-error {{variable can appear only once in OpenMP 'target update' construct}} expected-note {{used here}}
+  foo();
+  #pragma omp target update to(da)
+  #pragma omp target update to(da[:4])
+  foo();
+  #pragma omp target update to(da[:4]) from(da) // expected-error {{variable can appear only once in OpenMP 'target update' construct}} expected-note {{used here}}
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/target_update_if_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/target_update_if_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/target_update_if_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/target_update_if_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,25 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+int main(int argc, char **argv) {
+  #pragma omp target update if // expected-error {{expected '(' after 'if'}} expected-error {{expected expression}}
+  #pragma omp target update if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target update if () // expected-error {{expected expression}}
+  #pragma omp target update if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp target update if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp target update' are ignored}}
+  #pragma omp target update if (argc > 0 ? argv[1] : argv[2])
+  #pragma omp target update if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp target update' cannot contain more than one 'if' clause}}
+  #pragma omp target update if (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp target update if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/task_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/task_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/task_ast_print.cpp	2014-07-17 08:47:03.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/task_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
 // expected-no-diagnostics
 
 #ifndef HEADER
@@ -8,89 +8,37 @@
 
 void foo() {}
 
-template <class T>
-struct S {
-  operator T() { return T(); }
-  static T TS;
-#pragma omp threadprivate(TS)
-};
-
-// CHECK:      template <class T = int> struct S {
-// CHECK:        static int TS;
-// CHECK-NEXT:   #pragma omp threadprivate(S<int>::TS)
-// CHECK-NEXT: }
-// CHECK:      template <class T = long> struct S {
-// CHECK:        static long TS;
-// CHECK-NEXT:   #pragma omp threadprivate(S<long>::TS)
-// CHECK-NEXT: }
-// CHECK:      template <class T> struct S {
-// CHECK:        static T TS;
-// CHECK-NEXT:   #pragma omp threadprivate(S::TS)
-// CHECK:      };
-
-template <typename T, int C>
-T tmain(T argc, T *argv) {
+template <class T, class S>
+T tmain (T argc, S **argv) {
   T b = argc, c, d, e, f, g;
+  T arr[25][123][2234];
   static T a;
-  S<T> s;
-#pragma omp task untied
-  a = 2;
-#pragma omp task default(none), private(argc, b) firstprivate(argv) shared(d) if (argc > 0) final(S<T>::TS > 0)
-  foo();
-#pragma omp task if (C) mergeable
+// CHECK: static int a;
+#pragma omp task
+  a=2;
+// CHECK-NEXT: #pragma omp task
+// CHECK-NEXT: a = 2;
+#pragma omp task if(b), final(a), untied, default(shared) mergeable, private(argc,b),firstprivate(argv, c),shared(d,f) depend(in:argc) depend(out : c) depend(inout:arr[1:argc][:][0:23], argc)
   foo();
-  return 0;
+// CHECK: #pragma omp task if(b) final(a) untied default(shared) mergeable private(argc,b) firstprivate(argv,c) shared(d,f) depend(in: argc) depend(out: c) depend(inout: arr[1:argc][0:123 - 0][0:23],argc)
+// CHECK-NEXT: foo();
+  return T();
 }
 
-// CHECK: template <typename T = int, int C = 5> int tmain(int argc, int *argv) {
-// CHECK-NEXT: int b = argc, c, d, e, f, g;
-// CHECK-NEXT: static int a;
-// CHECK-NEXT: S<int> s;
-// CHECK-NEXT: #pragma omp task untied
-// CHECK-NEXT: a = 2;
-// CHECK-NEXT: #pragma omp task default(none) private(argc,b) firstprivate(argv) shared(d) if(argc > 0) final(S<int>::TS > 0)
-// CHECK-NEXT: foo()
-// CHECK-NEXT: #pragma omp task if(5) mergeable
-// CHECK-NEXT: foo()
-// CHECK: template <typename T = long, int C = 1> long tmain(long argc, long *argv) {
-// CHECK-NEXT: long b = argc, c, d, e, f, g;
-// CHECK-NEXT: static long a;
-// CHECK-NEXT: S<long> s;
-// CHECK-NEXT: #pragma omp task untied
-// CHECK-NEXT: a = 2;
-// CHECK-NEXT: #pragma omp task default(none) private(argc,b) firstprivate(argv) shared(d) if(argc > 0) final(S<long>::TS > 0)
-// CHECK-NEXT: foo()
-// CHECK-NEXT: #pragma omp task if(1) mergeable
-// CHECK-NEXT: foo()
-// CHECK: template <typename T, int C> T tmain(T argc, T *argv) {
-// CHECK-NEXT: T b = argc, c, d, e, f, g;
-// CHECK-NEXT: static T a;
-// CHECK-NEXT: S<T> s;
-// CHECK-NEXT: #pragma omp task untied
-// CHECK-NEXT: a = 2;
-// CHECK-NEXT: #pragma omp task default(none) private(argc,b) firstprivate(argv) shared(d) if(argc > 0) final(S<T>::TS > 0)
-// CHECK-NEXT: foo()
-// CHECK-NEXT: #pragma omp task if(C) mergeable
-// CHECK-NEXT: foo()
-
-enum Enum {};
-
-int main(int argc, char **argv) {
-  long x;
+int main (int argc, char **argv) {
   int b = argc, c, d, e, f, g;
+  int arr[25][123][2234];
   static int a;
-#pragma omp threadprivate(a)
-  Enum ee;
-// CHECK: Enum ee;
-#pragma omp task untied mergeable
-  // CHECK-NEXT: #pragma omp task untied mergeable
-  a = 2;
+// CHECK: static int a;
+#pragma omp task
+  a=2;
+// CHECK-NEXT: #pragma omp task
 // CHECK-NEXT: a = 2;
-#pragma omp task default(none), private(argc, b) firstprivate(argv) if (argc > 0) final(a > 0)
-  // CHECK-NEXT: #pragma omp task default(none) private(argc,b) firstprivate(argv) if(argc > 0) final(a > 0)
+#pragma omp task if(b), final(a), untied, default(shared) mergeable, private(argc,b),firstprivate(argv, c),shared(d,f) depend(in:argc) depend(out : c) depend(inout:arr[1:argc][:][0:23], argc)
   foo();
-  // CHECK-NEXT: foo();
-  return tmain<int, 5>(b, &b) + tmain<long, 1>(x, &x);
+// CHECK: #pragma omp task if(b) final(a) untied default(shared) mergeable private(argc,b) firstprivate(argv,c) shared(d,f) depend(in: argc) depend(out: c) depend(inout: arr[1:argc][0:123 - 0][0:23],argc)
+// CHECK-NEXT: foo();
+  return tmain(argc, argv);
 }
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/task_default_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/task_default_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/task_default_messages.cpp	2014-07-11 07:25:16.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/task_default_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,21 +1,15 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -o - %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
 
 void foo();
 
 int main(int argc, char **argv) {
-#pragma omp task default                          // expected-error {{expected '(' after 'default'}}
-#pragma omp task default(                         // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp task default()                        // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
-#pragma omp task default(none                     // expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp task default(shared), default(shared) // expected-error {{directive '#pragma omp task' cannot contain more than one 'default' clause}}
-#pragma omp task default(x)                       // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  #pragma omp task default // expected-error {{expected '(' after 'default'}} expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  #pragma omp task default ( // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp task default () // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  #pragma omp task default (none // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp task default (shared), default(shared) // expected-error {{directive '#pragma omp task' cannot contain more than one 'default' clause}}
+  #pragma omp task default (x) // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
   foo();
 
-#pragma omp task default(none)
-  ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
-
-#pragma omp task default(none)
-#pragma omp task default(shared)
-  ++argc;
   return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/task_depend_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/task_depend_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/task_depend_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/task_depend_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,39 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+class vector {
+  public:
+    int operator[](int index) { return 0; }
+};
+
+int main(int argc, char **argv) {
+  vector vec;
+  typedef float V __attribute__((vector_size(16)));
+  V a;
+
+  #pragma omp task depend // expected-error {{expected '(' after 'depend'}} expected-error {{expected dependence type 'in', 'out' or 'inout'}}
+  #pragma omp task depend ( // expected-error {{expected dependence type 'in', 'out' or 'inout'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp task depend () // expected-error {{expected dependence type 'in', 'out' or 'inout'}}
+  #pragma omp task depend (argc // expected-error {{expected dependence type 'in', 'out' or 'inout'}} expected-error {{expected ':' in 'depend' clause}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp task depend (in : argc)) // expected-warning {{extra tokens at the end of '#pragma omp task' are ignored}}
+  #pragma omp task depend (out: ) // expected-error {{expected expression}}
+  #pragma omp task depend (inout : foobool(argc)), depend (in, argc) // expected-error {{argument expression must be an l-value}} expected-error {{expected ':' in 'depend' clause}} expected-error {{expected expression}}
+  #pragma omp task depend (out :S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp task depend (in : argv[1][1]='2') // expected-error {{expected variable name or an array item}} 
+  #pragma omp task depend (in : vec[1:2]) // expected-error {{argument expression must be an l-value}}
+  #pragma omp task depend (in : argv[0:-1]) // expected-error {{length of the array section must be greater than 0}}
+  #pragma omp task depend (in : argv[:]) // expected-error {{cannot define default length for non-array type 'char **'}}
+  #pragma omp task depend (in : argv[3:4:1]) // expected-error {{expected ']'}} expected-note {{to match this '['}}
+  #pragma omp task depend(in:a[0:1]) // expected-error{{extended array notation is not allowed}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/task_final_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/task_final_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/task_final_messages.cpp	2014-07-17 03:32:53.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/task_final_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
 
 void foo() {
 }
@@ -9,26 +9,8 @@
 
 struct S1; // expected-note {{declared here}}
 
-template <class T, class S> // expected-note {{declared here}}
-int tmain(T argc, S **argv) {
-  #pragma omp task final // expected-error {{expected '(' after 'final'}}
-  #pragma omp task final ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task final () // expected-error {{expected expression}}
-  #pragma omp task final (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task final (argc)) // expected-warning {{extra tokens at the end of '#pragma omp task' are ignored}}
-  #pragma omp task final (argc > 0 ? argv[1] : argv[2])
-  #pragma omp task final (foobool(argc)), final (true) // expected-error {{directive '#pragma omp task' cannot contain more than one 'final' clause}}
-  #pragma omp task final (S) // expected-error {{'S' does not refer to a value}}
-  #pragma omp task final (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task final (argc argc) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task final(argc)
-  foo();
-
-  return 0;
-}
-
 int main(int argc, char **argv) {
-  #pragma omp task final // expected-error {{expected '(' after 'final'}}
+  #pragma omp task final // expected-error {{expected '(' after 'final'}} expected-error {{expected expression}}
   #pragma omp task final ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   #pragma omp task final () // expected-error {{expected expression}}
   #pragma omp task final (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
@@ -37,10 +19,7 @@
   #pragma omp task final (foobool(argc)), final (true) // expected-error {{directive '#pragma omp task' cannot contain more than one 'final' clause}}
   #pragma omp task final (S1) // expected-error {{'S1' does not refer to a value}}
   #pragma omp task final (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task final (argc argc) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task final (1 0) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task final(if(tmain(argc, argv) // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   foo();
 
-  return tmain(argc, argv);
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/task_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/task_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/task_firstprivate_messages.cpp	2014-07-11 07:25:16.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/task_firstprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -11,10 +11,9 @@
 extern S1 a;
 class S2 {
   mutable int a;
-
 public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
   static float S2s;
   static const float S2sc;
 };
@@ -23,10 +22,9 @@
 const S2 ba[5];
 class S3 {
   int a;
-
 public:
-  S3() : a(0) {}
-  S3(S3 &s3) : a(s3.a) {}
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
 };
 const S3 c;
 const S3 ca[5];
@@ -35,17 +33,20 @@
   int a;
   S4();
   S4(const S4 &s4);
-
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
 class S5 { // expected-note {{'S5' declared here}}
   int a;
-  S5() : a(0) {}
-  S5(const S5 &s5) : a(s5.a) {}
-
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
 public:
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
+};
+class S6 {
+  int a;
+public:
+  S6() : a(0) { }
 };
 
 S3 h;
@@ -53,34 +54,43 @@
 
 int main(int argc, char **argv) {
   const int d = 5;
-  const int da[5] = {0};
+  const int da[5] = { 0 };
   S4 e(4); // expected-note {{'e' defined here}}
   S5 g(5); // expected-note {{'g' defined here}}
+  S6 p;
   int i;
-  int &j = i;                                               // expected-note {{'j' defined here}}
-#pragma omp task firstprivate                               // expected-error {{expected '(' after 'firstprivate'}}
-#pragma omp task firstprivate(                              // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp task firstprivate()                             // expected-error {{expected expression}}
-#pragma omp task firstprivate(argc                          // expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp task firstprivate(argc,                         // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp task firstprivate(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-#pragma omp task firstprivate(argc)
-#pragma omp task firstprivate(S1)            // expected-error {{'S1' does not refer to a value}}
-#pragma omp task firstprivate(a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
-#pragma omp task firstprivate(argv[1])       // expected-error {{expected variable name}}
-#pragma omp task firstprivate(ba)
-#pragma omp task firstprivate(ca)
-#pragma omp task firstprivate(da)
-#pragma omp task firstprivate(S2::S2s)
-#pragma omp task firstprivate(S2::S2sc)
-#pragma omp task firstprivate(e, g)          // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
-#pragma omp task firstprivate(h)             // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
-#pragma omp task private(i), firstprivate(i) // expected-error {{private variable cannot be firstprivate}} expected-note{{defined as private}}
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp task firstprivate // expected-error {{expected '(' after 'firstprivate'}} expected-error {{expected expression}}
+  #pragma omp task firstprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp task firstprivate () // expected-error {{expected expression}}
+  #pragma omp task firstprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp task firstprivate (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp task firstprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  #pragma omp task firstprivate (argc)
+  #pragma omp task firstprivate (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp task firstprivate (a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
+  #pragma omp task firstprivate (argv[1]) // expected-error {{expected variable name}}
+  #pragma omp task firstprivate(ba)
+  #pragma omp task firstprivate(ca)
+  #pragma omp task firstprivate(da)
+  #pragma omp task firstprivate(S2::S2s)
+  #pragma omp task firstprivate(S2::S2sc)
+  #pragma omp task firstprivate(e, g, p) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
+  #pragma omp task firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
+  #pragma omp task private(i), firstprivate(i) // expected-error {{private variable cannot be firstprivate}} expected-note{{defined as private}}
+  foo();
+  #pragma omp parallel shared(i)
+  #pragma omp task firstprivate(i)
+  foo();
+  #pragma omp parallel private(i)
+  #pragma omp parallel shared(i)
+  #pragma omp task firstprivate(i)
   foo();
-#pragma omp task shared(i)
-#pragma omp task firstprivate(i)
-#pragma omp task firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
+  #pragma omp parallel reduction(+:i) // expected-note {{defined as reduction}}
+  #pragma omp task firstprivate(i) // expected-error {{reduction variable in '#pragma omp parallel' cannot be firstprivate in '#pragma omp task'}}
+  foo();
+  #pragma omp task firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
   foo();
 
   return 0;
-}
+}
\ No newline at end of file
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/task_if_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/task_if_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/task_if_messages.cpp	2014-07-11 07:25:16.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/task_if_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
 
 void foo() {
 }
@@ -9,26 +9,8 @@
 
 struct S1; // expected-note {{declared here}}
 
-template <class T, class S> // expected-note {{declared here}}
-int tmain(T argc, S **argv) {
-  #pragma omp task if // expected-error {{expected '(' after 'if'}}
-  #pragma omp task if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task if () // expected-error {{expected expression}}
-  #pragma omp task if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task if (argc)) // expected-warning {{extra tokens at the end of '#pragma omp task' are ignored}}
-  #pragma omp task if (argc > 0 ? argv[1] : argv[2])
-  #pragma omp task if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp task' cannot contain more than one 'if' clause}}
-  #pragma omp task if (S) // expected-error {{'S' does not refer to a value}}
-  #pragma omp task if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task if (argc argc) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task if(argc)
-  foo();
-
-  return 0;
-}
-
 int main(int argc, char **argv) {
-  #pragma omp task if // expected-error {{expected '(' after 'if'}}
+  #pragma omp task if // expected-error {{expected '(' after 'if'}} expected-error {{expected expression}}
   #pragma omp task if ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   #pragma omp task if () // expected-error {{expected expression}}
   #pragma omp task if (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
@@ -37,10 +19,7 @@
   #pragma omp task if (foobool(argc)), if (true) // expected-error {{directive '#pragma omp task' cannot contain more than one 'if' clause}}
   #pragma omp task if (S1) // expected-error {{'S1' does not refer to a value}}
   #pragma omp task if (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task if (argc argc) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task if (1 0) // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  #pragma omp task if(if(tmain(argc, argv) // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
   foo();
 
-  return tmain(argc, argv);
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/task_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/task_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/task_messages.cpp	2014-07-17 08:47:03.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/task_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,275 +1,35 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 -std=c++11 -o - %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
-void foo() {
-}
-
-#pragma omp task // expected-error {{unexpected OpenMP directive '#pragma omp task'}}
+int foo();
 
-class S { // expected-note 6 {{'S' declared here}}
-  S(const S &s) { a = s.a + 12; }
-  int a;
-
-public:
-  S() : a(0) {}
-  S(int a) : a(a) {}
-  operator int() { return a; }
-  S &operator++() { return *this; }
-  S operator+(const S &) { return *this; }
-};
+int main() {
+  #pragma omp task
+  ;
+  #pragma omp task untied untied // expected-error {{directive '#pragma omp task' cannot contain more than one 'untied' clause}}
+  foo();
+  #pragma omp task mergeable mergeable // expected-error {{directive '#pragma omp task' cannot contain more than one 'mergeable' clause}}
+  foo();
+  {
+    #pragma omp task
+  } // expected-error {{expected statement}}
 
-template <class T>
-int foo() {
-  T a; // expected-note 3 {{'a' defined here}}
-  T &b = a; // expected-note 4 {{'b' defined here}}
-  int r;
-#pragma omp task default(none)
-#pragma omp task default(shared)
-  ++a;
-// expected-error@+2 {{predetermined as a firstprivate in a task construct variable must have an accessible, unambiguous copy constructor}}
-#pragma omp task default(none)
-#pragma omp task
-// expected-note@+1 {{used here}}
-  ++a;
-#pragma omp task
-// expected-error@+1 {{predetermined as a firstprivate in a task construct variable must have an accessible, unambiguous copy constructor}}
-#pragma omp task
-  // expected-note@+1 {{used here}}
-  ++a;
-#pragma omp task default(shared)
-#pragma omp task
-  ++a;
-#pragma omp task
-#pragma omp parallel
-  ++a;
-// expected-error@+2 {{predetermined as a firstprivate in a task construct variable cannot be of reference type 'int &'}}
-// expected-error@+1 {{predetermined as a firstprivate in a task construct variable cannot be of reference type 'S &'}}
-#pragma omp task
-  // expected-note@+1 2 {{used here}}
-  ++b;
-// expected-error@+3 {{predetermined as a firstprivate in a task construct variable cannot be of reference type 'int &'}}
-// expected-error@+2 {{predetermined as a firstprivate in a task construct variable cannot be of reference type 'S &'}}
-// expected-error@+1 {{predetermined as a firstprivate in a task construct variable must have an accessible, unambiguous copy constructor}}
-#pragma omp task
-// expected-note@+1 3 {{used here}}
-#pragma omp parallel shared(a, b)
-  ++a, ++b;
-// expected-note@+1 3 {{defined as reduction}}
-#pragma omp parallel reduction(+ : r)
-// expected-error@+1 {{argument of a reduction clause of a parallel construct must not appear in a firstprivate clause on a task construct}}
-#pragma omp task firstprivate(r)
-  // expected-error@+1 2 {{reduction variables may not be accessed in an explicit task}}
-  ++r;
-// expected-note@+1 2 {{defined as reduction}}
-#pragma omp parallel reduction(+ : r)
-#pragma omp task default(shared)
-  // expected-error@+1 2 {{reduction variables may not be accessed in an explicit task}}
-  ++r;
-// expected-note@+1 2 {{defined as reduction}}
-#pragma omp parallel reduction(+ : r)
-#pragma omp task
-  // expected-error@+1 2 {{reduction variables may not be accessed in an explicit task}}
-  ++r;
-#pragma omp parallel
-// expected-note@+1 3 {{defined as reduction}}
-#pragma omp for reduction(+ : r)
-  for (int i = 0; i < 10; ++i)
-// expected-error@+1 {{argument of a reduction clause of a for construct must not appear in a firstprivate clause on a task construct}}
-#pragma omp task firstprivate(r)
-    // expected-error@+1 2 {{reduction variables may not be accessed in an explicit task}}
-    ++r;
-#pragma omp parallel
-// expected-note@+1 2 {{defined as reduction}}
-#pragma omp for reduction(+ : r)
-  for (int i = 0; i < 10; ++i)
-#pragma omp task default(shared)
-    // expected-error@+1 2 {{reduction variables may not be accessed in an explicit task}}
-    ++r;
-#pragma omp parallel
-// expected-note@+1 2 {{defined as reduction}}
-#pragma omp for reduction(+ : r)
-  for (int i = 0; i < 10; ++i)
-#pragma omp task
-    // expected-error@+1 2 {{reduction variables may not be accessed in an explicit task}}
-    ++r;
-// expected-note@+1 {{non-shared variable in a task construct is predetermined as firstprivate}}
-#pragma omp task
-// expected-error@+2 {{reduction variable must be shared}}
-// expected-error@+1 {{region cannot be closely nested inside 'task' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-#pragma omp for reduction(+ : r)
-  ++r;
-// expected-error@+1 {{directive '#pragma omp task' cannot contain more than one 'untied' clause}}
-#pragma omp task untied untied
-  ++r;
-// expected-error@+1 {{directive '#pragma omp task' cannot contain more than one 'mergeable' clause}}
-#pragma omp task mergeable mergeable
-  ++r;
-  return a + b;
+  return 0;
 }
 
-int main(int argc, char **argv) {
-  int a;
-  int &b = a; // expected-note 2 {{'b' defined here}}
-  S sa;       // expected-note 3 {{'sa' defined here}}
-  S &sb = sa; // expected-note 2 {{'sb' defined here}}
-  int r;
-#pragma omp task { // expected-warning {{extra tokens at the end of '#pragma omp task' are ignored}}
-  foo();
-#pragma omp task( // expected-warning {{extra tokens at the end of '#pragma omp task' are ignored}}
-  foo();
-#pragma omp task[ // expected-warning {{extra tokens at the end of '#pragma omp task' are ignored}}
-  foo();
-#pragma omp task] // expected-warning {{extra tokens at the end of '#pragma omp task' are ignored}}
-  foo();
-#pragma omp task) // expected-warning {{extra tokens at the end of '#pragma omp task' are ignored}}
-  foo();
-#pragma omp task } // expected-warning {{extra tokens at the end of '#pragma omp task' are ignored}}
-  foo();
-#pragma omp task
-// expected-warning@+1 {{extra tokens at the end of '#pragma omp task' are ignored}}
-#pragma omp task unknown()
-  foo();
-L1:
-  foo();
-#pragma omp task
-  ;
-#pragma omp task
+int foo() {
+  L1:
+    foo();
+  #pragma omp task
   {
+    foo();
     goto L1; // expected-error {{use of undeclared label 'L1'}}
-    argc++;
-  }
-
-  for (int i = 0; i < 10; ++i) {
-    switch (argc) {
-    case (0):
-#pragma omp task
-    {
-      foo();
-      break;    // expected-error {{'break' statement not in loop or switch statement}}
-      continue; // expected-error {{'continue' statement not in loop statement}}
-    }
-    default:
-      break;
-    }
   }
-#pragma omp task default(none)
-  ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
-
   goto L2; // expected-error {{use of undeclared label 'L2'}}
-#pragma omp task
-L2:
-  foo();
-#pragma omp task
+  #pragma omp task
   {
-    return 1; // expected-error {{cannot return from OpenMP region}}
+    L2:
+    foo();
   }
 
-  [[]] // expected-error {{an attribute list cannot appear here}}
-#pragma omp task
-      for (int n = 0; n < 100; ++n) {
-  }
-
-#pragma omp task default(none)
-#pragma omp task default(shared)
-  ++a;
-#pragma omp task default(none)
-#pragma omp task
-  ++a;
-#pragma omp task default(shared)
-#pragma omp task
-  ++a;
-#pragma omp task
-#pragma omp parallel
-  ++a;
-// expected-error@+1 {{predetermined as a firstprivate in a task construct variable cannot be of reference type 'int &'}}
-#pragma omp task
-  // expected-note@+1 {{used here}}
-  ++b;
-// expected-error@+1 {{predetermined as a firstprivate in a task construct variable cannot be of reference type 'int &'}}
-#pragma omp task
-// expected-note@+1 {{used here}}
-#pragma omp parallel shared(a, b)
-  ++a, ++b;
-#pragma omp task default(none)
-#pragma omp task default(shared)
-  ++sa;
-#pragma omp task default(none)
-// expected-error@+1 {{predetermined as a firstprivate in a task construct variable must have an accessible, unambiguous copy constructor}}
-#pragma omp task
-// expected-note@+1 {{used here}}
-  ++sa;
-#pragma omp task
-// expected-error@+1 {{predetermined as a firstprivate in a task construct variable must have an accessible, unambiguous copy constructor}}
-#pragma omp task
-// expected-note@+1 {{used here}}
-  ++sa;
-#pragma omp task default(shared)
-#pragma omp task
-  ++sa;
-#pragma omp task
-#pragma omp parallel
-  ++sa;
-// expected-error@+1 {{predetermined as a firstprivate in a task construct variable cannot be of reference type 'S &'}}
-#pragma omp task
-  // expected-note@+1 {{used here}}
-  ++sb;
-// expected-error@+2 {{predetermined as a firstprivate in a task construct variable cannot be of reference type 'S &'}}
-// expected-error@+1 {{predetermined as a firstprivate in a task construct variable must have an accessible, unambiguous copy constructor}}
-#pragma omp task
-// expected-note@+1 2 {{used here}}
-#pragma omp parallel shared(sa, sb)
-  ++sa, ++sb;
-// expected-note@+1 2 {{defined as reduction}}
-#pragma omp parallel reduction(+ : r)
-// expected-error@+1 {{argument of a reduction clause of a parallel construct must not appear in a firstprivate clause on a task construct}}
-#pragma omp task firstprivate(r)
-  // expected-error@+1 {{reduction variables may not be accessed in an explicit task}}
-  ++r;
-// expected-note@+1 {{defined as reduction}}
-#pragma omp parallel reduction(+ : r)
-#pragma omp task default(shared)
-  // expected-error@+1 {{reduction variables may not be accessed in an explicit task}}
-  ++r;
-// expected-note@+1 {{defined as reduction}}
-#pragma omp parallel reduction(+ : r)
-#pragma omp task
-  // expected-error@+1 {{reduction variables may not be accessed in an explicit task}}
-  ++r;
-#pragma omp parallel
-// expected-note@+1 2 {{defined as reduction}}
-#pragma omp for reduction(+ : r)
-  for (int i = 0; i < 10; ++i)
-// expected-error@+1 {{argument of a reduction clause of a for construct must not appear in a firstprivate clause on a task construct}}
-#pragma omp task firstprivate(r)
-    // expected-error@+1 {{reduction variables may not be accessed in an explicit task}}
-    ++r;
-#pragma omp parallel
-// expected-note@+1 {{defined as reduction}}
-#pragma omp for reduction(+ : r)
-  for (int i = 0; i < 10; ++i)
-#pragma omp task default(shared)
-    // expected-error@+1 {{reduction variables may not be accessed in an explicit task}}
-    ++r;
-#pragma omp parallel
-// expected-note@+1 {{defined as reduction}}
-#pragma omp for reduction(+ : r)
-  for (int i = 0; i < 10; ++i)
-#pragma omp task
-    // expected-error@+1 {{reduction variables may not be accessed in an explicit task}}
-    ++r;
-// expected-note@+1 {{non-shared variable in a task construct is predetermined as firstprivate}}
-#pragma omp task
-// expected-error@+2 {{reduction variable must be shared}}
-// expected-error@+1 {{region cannot be closely nested inside 'task' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
-#pragma omp for reduction(+ : r)
-  ++r;
-// expected-error@+1 {{directive '#pragma omp task' cannot contain more than one 'untied' clause}}
-#pragma omp task untied untied
-  ++r;
-// expected-error@+1 {{directive '#pragma omp task' cannot contain more than one 'mergeable' clause}}
-#pragma omp task mergeable mergeable
-  ++r;
-  // expected-note@+2 {{in instantiation of function template specialization 'foo<int>' requested here}}
-  // expected-note@+1 {{in instantiation of function template specialization 'foo<S>' requested here}}
-  return foo<int>() + foo<S>();
+  return 0;
 }
-
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/task_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/task_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/task_private_messages.cpp	2014-07-11 07:25:16.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/task_private_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -11,73 +11,102 @@
 extern S1 a;
 class S2 {
   mutable int a;
-
 public:
-  S2() : a(0) {}
-  static float S2s; // expected-note {{static data member is predetermined as shared}}
+  S2():a(0) { }
+  static float S2s; // expected-note {{predetermined as shared}}
 };
 const S2 b;
 const S2 ba[5];
 class S3 {
   int a;
-
 public:
-  S3() : a(0) {}
+  S3():a(0) { }
 };
-const S3 c;         // expected-note {{global variable is predetermined as shared}}
-const S3 ca[5];     // expected-note {{global variable is predetermined as shared}}
-extern const int f; // expected-note {{global variable is predetermined as shared}}
-class S4 {          // expected-note {{'S4' declared here}}
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f;  // expected-note {{predetermined as shared}}
+class S4 { // expected-note {{'S4' declared here}}
   int a;
   S4();
-
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
 class S5 { // expected-note {{'S5' declared here}}
   int a;
-  S5() : a(0) {}
-
+  S5():a(0) {}
 public:
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
 };
 
-int threadvar;
-#pragma omp threadprivate(threadvar) // expected-note {{defined as threadprivate or thread local}}
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
 
 int main(int argc, char **argv) {
-  const int d = 5;       // expected-note {{constant variable is predetermined as shared}}
-  const int da[5] = {0}; // expected-note {{constant variable is predetermined as shared}}
-  S4 e(4);               // expected-note {{'e' defined here}}
-  S5 g(5);               // expected-note {{'g' defined here}}
+  const int d = 5;  // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
   int i;
-  int &j = i;                                          // expected-note {{'j' defined here}}
-#pragma omp task private                               // expected-error {{expected '(' after 'private'}}
-#pragma omp task private(                              // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp task private()                             // expected-error {{expected expression}}
-#pragma omp task private(argc                          // expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp task private(argc,                         // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-#pragma omp task private(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-#pragma omp task private(argc argv)                    // expected-error {{expected ',' or ')' in 'private' clause}}
-#pragma omp task private(S1)                           // expected-error {{'S1' does not refer to a value}}
-#pragma omp task private(a, b, c, d, f)                // expected-error {{a private variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be private}}
-#pragma omp task private(argv[1])                      // expected-error {{expected variable name}}
-#pragma omp task private(ba)
-#pragma omp task private(ca)           // expected-error {{shared variable cannot be private}}
-#pragma omp task private(da)           // expected-error {{shared variable cannot be private}}
-#pragma omp task private(S2::S2s)      // expected-error {{shared variable cannot be private}}
-#pragma omp task private(e, g)         // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
-#pragma omp task private(threadvar)    // expected-error {{threadprivate or thread local variable cannot be private}}
-#pragma omp task shared(i), private(i) // expected-error {{shared variable cannot be private}} expected-note {{defined as shared}}
-  foo();
-#pragma omp task firstprivate(i) private(i) // expected-error {{firstprivate variable cannot be private}} expected-note {{defined as firstprivate}}
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp task private // expected-error {{expected '(' after 'private'}} expected-error {{expected expression}}
+  #pragma omp task private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp task private () // expected-error {{expected expression}}
+  #pragma omp task private (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp task private (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp task private (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  #pragma omp task private (argc)
+  #pragma omp task private (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp task private (a, b, c, d, f) // expected-error {{private variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be private}}
+  #pragma omp task private (argv[1]) // expected-error {{expected variable name}}
+  #pragma omp task private(ba)
+  #pragma omp task private(ca) // expected-error {{shared variable cannot be private}}
+  #pragma omp task private(da) // expected-error {{shared variable cannot be private}}
+  #pragma omp task private(S2::S2s) // expected-error {{shared variable cannot be private}}
+  #pragma omp task private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
+  #pragma omp task private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
+  #pragma omp task shared(i), private(i) // expected-error {{shared variable cannot be private}} expected-note {{defined as shared}}
   foo();
-#pragma omp task private(i)
-#pragma omp task private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type 'int &'}}
+  #pragma omp parallel
+  #pragma omp task shared(i)
+  #pragma omp task private(i)
+  #pragma omp task private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
   foo();
-#pragma omp task firstprivate(i)
+  #pragma omp for private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp task private(i)
+    foo();
+  }
+  #pragma omp parallel
+  #pragma omp for firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp task private(i)
+    foo();
+  }
+  #pragma omp parallel
+  #pragma omp for reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp task private(i)
+    foo();
+  }
+  #pragma omp parallel
+  #pragma omp for lastprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp task private(i)
+    foo();
+  }
+  #pragma omp task private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp task private(i)
+    foo();
+  }
+  #pragma omp task firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp task private(i)
+    foo();
+  }
+  #pragma omp parallel reduction(+:i)
   for (int k = 0; k < 10; ++k) {
-#pragma omp task private(i)
+    #pragma omp task private(i)
     foo();
   }
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/task_shared_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/task_shared_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/task_shared_messages.cpp	2014-07-11 07:25:16.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/task_shared_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
 void foo() {
 }
@@ -11,19 +11,17 @@
 extern S1 a;
 class S2 {
   mutable int a;
-
 public:
-  S2() : a(0) {}
-  S2(S2 &s2) : a(s2.a) {}
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
 };
 const S2 b;
 const S2 ba[5];
 class S3 {
   int a;
-
 public:
-  S3() : a(0) {}
-  S3(S3 &s3) : a(s3.a) {}
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
 };
 const S3 c;
 const S3 ca[5];
@@ -32,17 +30,15 @@
   int a;
   S4();
   S4(const S4 &s4);
-
 public:
-  S4(int v) : a(v) {}
+  S4(int v):a(v) { }
 };
 class S5 {
   int a;
-  S5() : a(0) {}
-  S5(const S5 &s5) : a(s5.a) {}
-
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
 public:
-  S5(int v) : a(v) {}
+  S5(int v):a(v) { }
 };
 
 S3 h;
@@ -50,52 +46,33 @@
 
 int main(int argc, char **argv) {
   const int d = 5;
-  const int da[5] = {0};
+  const int da[5] = { 0 };
   S4 e(4);
   S5 g(5);
   int i;
   int &j = i;
-#pragma omp task shared                               // expected-error {{expected '(' after 'shared'}}
-  foo();
-#pragma omp task shared(                              // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp task shared()                             // expected-error {{expected expression}}
-  foo();
-#pragma omp task shared(argc                          // expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp task shared(argc,                         // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
-  foo();
-#pragma omp task shared(argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
-  foo();
-#pragma omp task shared(argc)
-  foo();
-#pragma omp task shared(S1) // expected-error {{'S1' does not refer to a value}}
-  foo();
-#pragma omp task shared(a, b, c, d, f)
-  foo();
-#pragma omp task shared(argv[1]) // expected-error {{expected variable name}}
-  foo();
-#pragma omp task shared(ba)
-  foo();
-#pragma omp task shared(ca)
-  foo();
-#pragma omp task shared(da)
-  foo();
-#pragma omp task shared(e, g)
-  foo();
-#pragma omp task shared(h)             // expected-error {{threadprivate or thread local variable cannot be shared}}
-  foo();
-#pragma omp task private(i), shared(i) // expected-error {{private variable cannot be shared}} expected-note {{defined as private}}
-  foo();
-#pragma omp task firstprivate(i), shared(i) // expected-error {{firstprivate variable cannot be shared}} expected-note {{defined as firstprivate}}
-  foo();
-#pragma omp parallel private(i)
-#pragma omp task shared(i)
-#pragma omp task shared(j)
-  foo();
-#pragma omp parallel firstprivate(i)
-#pragma omp task shared(i)
-#pragma omp task shared(j)
+  #pragma omp parallel
+  #pragma omp task shared // expected-error {{expected '(' after 'shared'}} expected-error {{expected expression}}
+  #pragma omp task shared ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp task shared () // expected-error {{expected expression}}
+  #pragma omp task shared (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp task shared (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  #pragma omp task shared (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  #pragma omp task shared (argc)
+  #pragma omp task shared (S1) // expected-error {{'S1' does not refer to a value}}
+  #pragma omp task shared (a, b, c, d, f)
+  #pragma omp task shared (argv[1]) // expected-error {{expected variable name}}
+  #pragma omp task shared(ba)
+  #pragma omp task shared(ca)
+  #pragma omp task shared(da)
+  #pragma omp task shared(e, g)
+  #pragma omp task shared(h) // expected-error {{threadprivate or thread local variable cannot be shared}}
+  #pragma omp task private(i), shared(i) // expected-error {{private variable cannot be shared}} expected-note {{defined as private}}
+  foo();
+  #pragma omp parallel
+  #pragma omp task private(i)
+  #pragma omp task shared(i)
+  #pragma omp task shared(j)
   foo();
 
   return 0;
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/taskgroup_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/taskgroup_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/taskgroup_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/taskgroup_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,26 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  static int a;
+// CHECK: static int a;
+#pragma omp taskgroup
+{
+  a=2;
+}
+// CHECK-NEXT: #pragma omp taskgroup
+// CHECK-NEXT: {
+// CHECK-NEXT: a = 2;
+// CHECK-NEXT: }
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/taskgroup_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/taskgroup_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/taskgroup_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/taskgroup_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,57 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int foo();
+
+int main() {
+  #pragma omp taskgroup
+  ;
+  #pragma omp taskgroup nowait // expected-error {{unexpected OpenMP clause 'nowait' in directive '#pragma omp taskgroup'}}
+  #pragma omp taskgroup unknown // expected-warning {{extra tokens at the end of '#pragma omp taskgroup' are ignored}}
+  foo();
+  {
+    #pragma omp taskgroup
+  } // expected-error {{expected statement}}
+  #pragma omp for
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp taskgroup
+    foo();
+  }
+  #pragma omp sections
+  {
+    #pragma omp taskgroup
+    foo();
+  }
+  #pragma omp single
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp taskgroup
+    foo();
+  }
+  #pragma omp task
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    #pragma omp taskgroup
+    foo();
+  }
+
+  return 0;
+}
+
+int foo() {
+  L1:
+    foo();
+  #pragma omp taskgroup
+  {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+  #pragma omp taskgroup
+  {
+    L2:
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/taskwait_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/taskwait_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/taskwait_ast_print.cpp	2014-07-18 06:17:07.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/taskwait_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,32 +0,0 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
-// expected-no-diagnostics
-
-#ifndef HEADER
-#define HEADER
-
-void foo() {}
-
-template <class T>
-T tmain(T argc) {
-  static T a;
-#pragma omp taskwait
-  return a + argc;
-}
-// CHECK:      static int a;
-// CHECK-NEXT: #pragma omp taskwait
-// CHECK:      static char a;
-// CHECK-NEXT: #pragma omp taskwait
-// CHECK:      static T a;
-// CHECK-NEXT: #pragma omp taskwait
-
-int main(int argc, char **argv) {
-  static int a;
-// CHECK: static int a;
-#pragma omp taskwait
-  // CHECK-NEXT: #pragma omp taskwait
-  return tmain(argc) + tmain(argv[0][0]) + a;
-}
-
-#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/taskwait_ast_printer.cpp cfe-3.5.0.src.omp/test/OpenMP/taskwait_ast_printer.cpp
--- cfe-3.5.0.src/test/OpenMP/taskwait_ast_printer.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/taskwait_ast_printer.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,20 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  static int a;
+// CHECK: static int a;
+#pragma omp taskwait
+// CHECK-NEXT: #pragma omp taskwait
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/taskwait_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/taskwait_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/taskwait_messages.cpp	2014-07-18 06:17:07.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/taskwait_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,110 +1,56 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
-template <class T>
-T tmain(T argc) {
-#pragma omp taskwait
+int main(int argc, char **argv) {
+  #pragma omp taskwait
   ;
-#pragma omp taskwait untied  // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp taskwait'}}
-#pragma omp taskwait unknown // expected-warning {{extra tokens at the end of '#pragma omp taskwait' are ignored}}
+  #pragma omp taskwait untied // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp taskwait'}}
+  #pragma omp taskwait unknown // expected-warning {{extra tokens at the end of '#pragma omp taskwait' are ignored}}
   if (argc)
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
-    if (argc) {
-#pragma omp taskwait
-    }
+    #pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be immediate substatement}}
+  if (argc) {
+    #pragma omp taskwait
+  }
   while (argc)
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
-    while (argc) {
-#pragma omp taskwait
-    }
+    #pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be immediate substatement}}
+  while (argc) {
+    #pragma omp taskwait
+  }
   do
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
-    while (argc)
-      ;
+    #pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be immediate substatement}}
+  while (argc);
   do {
-#pragma omp taskwait
-  } while (argc);
+    #pragma omp taskwait
+  }
+  while (argc);
+  switch (argc)
+    #pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be immediate substatement}}
   switch (argc)
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
-    switch (argc)
     case 1:
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
+    #pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be immediate substatement}}
   switch (argc)
-  case 1: {
-#pragma omp taskwait
-  }
+    case 1: {
+    #pragma omp taskwait
+    }
   switch (argc) {
-#pragma omp taskwait
+    #pragma omp taskwait
   case 1:
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
+    #pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be immediate substatement}}
     break;
   default: {
-#pragma omp taskwait
-  } break;
-  }
-  for (;;)
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
-    for (;;) {
-#pragma omp taskwait
-    }
-label:
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
-label1 : {
-#pragma omp taskwait
-}
-
-  return T();
-}
-
-int main(int argc, char **argv) {
-#pragma omp taskwait
-  ;
-#pragma omp taskwait untied  // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp taskwait'}}
-#pragma omp taskwait unknown // expected-warning {{extra tokens at the end of '#pragma omp taskwait' are ignored}}
-  if (argc)
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
-    if (argc) {
-#pragma omp taskwait
+    #pragma omp taskwait
     }
-  while (argc)
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
-    while (argc) {
-#pragma omp taskwait
-    }
-  do
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
-    while (argc)
-      ;
-  do {
-#pragma omp taskwait
-  } while (argc);
-  switch (argc)
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
-    switch (argc)
-    case 1:
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
-  switch (argc)
-  case 1: {
-#pragma omp taskwait
-  }
-  switch (argc) {
-#pragma omp taskwait
-  case 1:
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
     break;
-  default: {
-#pragma omp taskwait
-  } break;
   }
   for (;;)
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
-    for (;;) {
-#pragma omp taskwait
-    }
-label:
-#pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be an immediate substatement}}
-label1 : {
-#pragma omp taskwait
-}
+    #pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be immediate substatement}}
+  for (;;) {
+    #pragma omp taskwait
+  }
+  label:
+    #pragma omp taskwait // expected-error {{'#pragma omp taskwait' cannot be immediate substatement}}
+  label1: {
+    #pragma omp taskwait
+  }
 
-  return tmain(argc);
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/taskyield_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/taskyield_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/taskyield_ast_print.cpp	2014-07-18 03:47:19.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/taskyield_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
 // expected-no-diagnostics
 
 #ifndef HEADER
@@ -8,25 +8,13 @@
 
 void foo() {}
 
-template <class T>
-T tmain(T argc) {
-  static T a;
-#pragma omp taskyield
-  return a + argc;
-}
-// CHECK:      static int a;
-// CHECK-NEXT: #pragma omp taskyield
-// CHECK:      static char a;
-// CHECK-NEXT: #pragma omp taskyield
-// CHECK:      static T a;
-// CHECK-NEXT: #pragma omp taskyield
-
-int main(int argc, char **argv) {
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
   static int a;
 // CHECK: static int a;
 #pragma omp taskyield
-  // CHECK-NEXT: #pragma omp taskyield
-  return tmain(argc) + tmain(argv[0][0]) + a;
+// CHECK-NEXT: #pragma omp taskyield
+  return (0);
 }
 
 #endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/taskyield_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/taskyield_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/taskyield_messages.cpp	2014-07-18 03:47:19.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/taskyield_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,110 +1,56 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
-template <class T>
-T tmain(T argc) {
-#pragma omp taskyield
+int main(int argc, char **argv) {
+  #pragma omp taskyield
   ;
-#pragma omp taskyield untied  // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp taskyield'}}
-#pragma omp taskyield unknown // expected-warning {{extra tokens at the end of '#pragma omp taskyield' are ignored}}
+  #pragma omp taskyield untied // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp taskyield'}}
+  #pragma omp taskyield unknown // expected-warning {{extra tokens at the end of '#pragma omp taskyield' are ignored}}
   if (argc)
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
-    if (argc) {
-#pragma omp taskyield
-    }
+    #pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be immediate substatement}}
+  if (argc) {
+    #pragma omp taskyield
+  }
   while (argc)
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
-    while (argc) {
-#pragma omp taskyield
-    }
+    #pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be immediate substatement}}
+  while (argc) {
+    #pragma omp taskyield
+  }
   do
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
-    while (argc)
-      ;
+    #pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be immediate substatement}}
+  while (argc);
   do {
-#pragma omp taskyield
-  } while (argc);
+    #pragma omp taskyield
+  }
+  while (argc);
+  switch (argc)
+    #pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be immediate substatement}}
   switch (argc)
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
-    switch (argc)
     case 1:
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
+    #pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be immediate substatement}}
   switch (argc)
-  case 1: {
-#pragma omp taskyield
-  }
+    case 1: {
+    #pragma omp taskyield
+    }
   switch (argc) {
-#pragma omp taskyield
+    #pragma omp taskyield
   case 1:
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
+    #pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be immediate substatement}}
     break;
   default: {
-#pragma omp taskyield
-  } break;
-  }
-  for (;;)
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
-    for (;;) {
-#pragma omp taskyield
-    }
-label:
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
-label1 : {
-#pragma omp taskyield
-}
-
-  return T();
-}
-
-int main(int argc, char **argv) {
-#pragma omp taskyield
-  ;
-#pragma omp taskyield untied  // expected-error {{unexpected OpenMP clause 'untied' in directive '#pragma omp taskyield'}}
-#pragma omp taskyield unknown // expected-warning {{extra tokens at the end of '#pragma omp taskyield' are ignored}}
-  if (argc)
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
-    if (argc) {
-#pragma omp taskyield
+    #pragma omp taskyield
     }
-  while (argc)
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
-    while (argc) {
-#pragma omp taskyield
-    }
-  do
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
-    while (argc)
-      ;
-  do {
-#pragma omp taskyield
-  } while (argc);
-  switch (argc)
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
-    switch (argc)
-    case 1:
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
-  switch (argc)
-  case 1: {
-#pragma omp taskyield
-  }
-  switch (argc) {
-#pragma omp taskyield
-  case 1:
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
     break;
-  default: {
-#pragma omp taskyield
-  } break;
   }
   for (;;)
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
-    for (;;) {
-#pragma omp taskyield
-    }
-label:
-#pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be an immediate substatement}}
-label1 : {
-#pragma omp taskyield
-}
+    #pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be immediate substatement}}
+  for (;;) {
+    #pragma omp taskyield
+  }
+  label:
+    #pragma omp taskyield // expected-error {{'#pragma omp taskyield' cannot be immediate substatement}}
+  label1: {
+    #pragma omp taskyield
+  }
 
-  return tmain(argc);
+  return 0;
 }
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,30 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  static int a;
+// CHECK: static int a;
+#pragma omp target
+#pragma omp teams
+// CHECK:      #pragma omp target
+// CHECK-NEXT: #pragma omp teams
+  a=2;
+// CHECK-NEXT: a = 2;
+#pragma omp target
+#pragma omp teams num_teams(a), thread_limit(c), default(none), private(argc,b),firstprivate(argv, c),shared(d,f),reduction(+:e) reduction(min : g)
+// CHECK:      #pragma omp target
+// CHECK-NEXT: #pragma omp teams num_teams(a) thread_limit(c) default(none) private(argc,b) firstprivate(argv,c) shared(d,f) reduction(+: e) reduction(min: g)
+  foo();
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_default_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_default_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_default_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_default_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,26 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo();
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams default // expected-error {{expected '(' after 'default'}} expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  foo();
+  #pragma omp target
+  #pragma omp teams default ( // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams default () // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  foo();
+  #pragma omp target
+  #pragma omp teams default (none // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams default (shared), default(shared) // expected-error {{directive '#pragma omp teams' cannot contain more than one 'default' clause}}
+  foo();
+  #pragma omp target
+  #pragma omp teams default (x) // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,44 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  static int a;
+// CHECK: static int a;
+#pragma omp target
+#pragma omp teams distribute
+// CHECK-NEXT: #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute
+  for (int i=0; i < 2; ++i)a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: a = 2;
+#pragma omp target
+#pragma omp teams distribute num_teams(a), thread_limit(c), default(none), private(argc,b),firstprivate(argv, c),shared(d,f),reduction(+:e) reduction(min : g) collapse(2), dist_schedule(static)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j)foo();
+// CHECK-NEXT: #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute num_teams(a) thread_limit(c) default(none) private(argc,b) firstprivate(argv,c) shared(d,f) reduction(+: e) reduction(min: g) collapse(2) dist_schedule(static)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j)
+// CHECK-NEXT: foo();
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp target
+#pragma omp teams distribute dist_schedule(static, argc)
+// CHECK:      #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute dist_schedule(static, argc)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_collapse_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_collapse_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_collapse_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_collapse_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,67 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; }
+  operator bool() { return f; }
+} v2;
+
+struct S3 {
+  int f;
+  operator int() { return f; }
+} v3;
+
+int main(int argc, char **argv) { // expected-note {{declared here}}
+  #pragma omp target
+  #pragma omp teams distribute collapse // expected-error {{expected '(' after 'collapse'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute collapse ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute collapse () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute collapse (argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}} expected-note {{read of non-const variable 'argc' is not allowed in a constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute collapse (argc > 0 ? argv[1] : argv[2]) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute collapse (foobool(argc)) collapse(1) // expected-error {{directive '#pragma omp teams distribute' cannot contain more than one 'collapse' clause}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute collapse (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute collapse (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute collapse (v1) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute collapse (v2) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute collapse (v3) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute collapse (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute collapse (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_default_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_default_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_default_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_default_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,26 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo();
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute default // expected-error {{expected '(' after 'default'}} expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute default ( // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute default () // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute default (none // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute default (shared), default(shared) // expected-error {{directive '#pragma omp teams distribute' cannot contain more than one 'default' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute default (x) // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_dist_schedule_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_dist_schedule_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_dist_schedule_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_dist_schedule_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,45 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute dist_schedule // expected-error {{expected '(' after 'dist_schedule'}} expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute dist_schedule ( // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute dist_schedule () // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute dist_schedule (static // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute dist_schedule (static, // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute dist_schedule (argc)) // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}} expected-warning {{extra tokens at the end of '#pragma omp teams distribute' are ignored}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute dist_schedule (static, argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute dist_schedule (static), dist_schedule (static, 1) // expected-error {{directive '#pragma omp teams distribute' cannot contain more than one 'dist_schedule' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute dist_schedule (static, S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute dist_schedule (static, argv[1]=2) // expected-error {{statement requires expression of integer type ('char *' invalid)}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_firstprivate_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_firstprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,119 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s;
+  static const float S2sc;
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 { // expected-note {{'S5' declared here}}
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp target
+  #pragma omp teams distribute firstprivate // expected-error {{expected '(' after 'firstprivate'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate (argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate (a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate (argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate(ba)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate(ca)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate(da)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate(S2::S2s)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate(S2::S2sc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private(i), firstprivate(i) // expected-error {{private variable cannot be firstprivate}} expected-note{{defined as private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate(i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_loop_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_loop_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_loop_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_loop_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,231 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+namespace std {
+
+struct random_access_iterator_tag { };
+
+template <class Iter>
+struct iterator_traits {
+  typedef typename Iter::difference_type difference_type; // expected-error {{no type named 'difference_type' in 'Iter'}} expected-error {{no type named 'difference_type' in 'Iter1'}}
+  typedef typename Iter::iterator_category iterator_category; // expected-error {{no type named 'iterator_category' in 'Iter'}} expected-error {{no type named 'iterator_category' in 'Iter1'}} expected-error {{no type named 'iterator_category' in 'Iter2'}}
+};
+
+template <class Iter>
+typename iterator_traits<Iter>::difference_type distance(Iter first, Iter last) {
+  return first - last;
+}
+}
+
+class Iter {
+  public:
+    Iter() { }
+    Iter(const Iter &) { }
+    Iter operator ++() { return *this; }
+    Iter operator --() { return *this; }
+    bool operator <(Iter a) { return true; }
+    bool operator >=(Iter a) { return false; }
+};
+int operator -(Iter a, Iter b) { return 0; }
+class Iter1 {
+  public:
+    Iter1() { }
+    Iter1(const Iter1 &) { }
+    Iter1 operator ++() { return *this; }
+    Iter1 operator --() { return *this; }
+    bool operator <(Iter1 a) { return true; }
+    bool operator >=(Iter1 a) { return false; }
+};
+class Iter2 {
+  public:
+    Iter2() { }
+    Iter2(const Iter2 &) { }
+    Iter2 operator ++() { return *this; }
+    Iter2 operator --() { return *this; }
+    bool operator <(Iter2 a) { return true; }
+    bool operator >=(Iter2 a) { return false; }
+    typedef int difference_type;
+};
+int operator -(Iter2 a, Iter2 b) { return 0; }
+class Iter3 {
+  public:
+    Iter3() { }
+    Iter3(const Iter3 &) { }
+    Iter3 operator ++() { return *this; }
+    Iter3 operator --() { return *this; }
+    bool operator <(Iter3 a) { return true; }
+    bool operator >=(Iter3 a) { return false; }
+    typedef int difference_type;
+    typedef int iterator_category;
+};
+int operator -(Iter3 a, Iter3 b) { return 0; }
+class Iter4 {
+  public:
+    Iter4() { }
+    Iter4(const Iter4 &) { }
+    Iter4 operator ++() { return *this; }
+    Iter4 operator --() { return *this; }
+    bool operator <(Iter4 a) { return true; }
+    bool operator >=(Iter4 a) { return false; }
+    Iter4 operator+=(int) const {return Iter4();}
+    Iter4 operator-=(int) const {return Iter4();}
+    typedef int difference_type;
+    typedef std::random_access_iterator_tag iterator_category;
+};
+int operator -(Iter4 a, Iter4 b) { return 0; }
+
+int t;
+#pragma omp threadprivate(t)
+
+int main() {
+  #pragma omp target
+  #pragma omp teams distribute
+  for (int i = 0; i < 10; i++)
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (t = 0; t < 10; t++)
+    ++t;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (int i; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (float i = 0; i < 10.0f; i++) // expected-error {{variable must be of integer or random access iterator type}}
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (int i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (int i = 0; i < 10; i |= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  int i;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (i = 0; i < 10; i++)
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (i--; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (i = 0; i < 10; i ^= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  Iter begin, end;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter I = begin; I >= end; ++I) // expected-error {{increment expression must cause 'I' to decrease on each iteration of the loop}}
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter I = end; I < begin; --I) // expected-error {{increment expression must cause 'I' to increase on each iteration of the loop}}
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter I = begin; I < end; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter>' requested here}} expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter I = end; I >= begin; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter1 begin1;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter1 I = begin1; I < begin1; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter1>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter1 I = begin1; I >= begin1; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter2 begin2;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter2 I = begin2; I < begin2; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter2>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter2 I = begin2; I >= begin2; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter3 begin3;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter3 I = begin3; I < begin3; ++I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter3 I = begin3; I >= begin3; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter4 begin4;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter4 I = begin4; I < begin4; ++I)
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  goto label; // expected-error {{use of undeclared label 'label'}}
+  #pragma omp target
+  #pragma omp teams distribute
+  for (int i = 0; i < 100; ++i) {
+    label: ++i;
+  }
+  #pragma omp target
+  #pragma omp teams distribute collapse(1)
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+  for (Iter4 I1 = begin4; I1 >= begin4; --I1)
+  for (Iter4 I2 = begin4; I2 >= begin4; --I2)
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute collapse(0) // expected-error {{expression is not a positive integer value}}
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp teams distribute // expected-error {{region must be closely nested inside a target region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp single
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp teams distribute // expected-error {{region must be closely nested inside a target region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp sections
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp teams distribute // expected-error {{region must be closely nested inside a target region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp master
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp teams distribute // expected-error {{region must be closely nested inside a target region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp critical
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp teams distribute // expected-error {{region must be closely nested inside a target region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp for ordered
+  for (Iter4 I = begin4; I >= begin4; --I)
+  #pragma omp ordered
+    #pragma omp teams distribute // expected-error {{region must be closely nested inside a target region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp target
+  #pragma omp teams distribute collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I; // expected-error {{only for-loops are allowed for '#pragma omp teams distribute'}}
+  ++begin4; 
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_loop_messages1.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_loop_messages1.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_loop_messages1.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_loop_messages1.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,11 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int main() {
+  int i;
+  goto label; // expected-error {{use of undeclared label 'label'}}
+  #pragma omp target
+  #pragma omp teams distribute
+  for (i = 0; i < 100; ++i) {
+    label: ++i;
+  }
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_messages.c cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_messages.c
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,24 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() { }
+
+int main(int argc, char **argv) {
+  L1:
+    foo();
+  #pragma omp target
+  #pragma omp teams distribute
+  for(int i = 0; i < argc; ++i)
+  {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+  #pragma omp target
+  #pragma omp teams distribute
+  for(int i = 0; i < argc; ++i) {
+    L2:
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,45 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+#pragma omp teams distribute // expected-error {{unexpected OpenMP directive '#pragma omp teams distribute'}}
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  {
+  #pragma omp teams distribute
+  for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target
+  {
+    for (int i = 0; i < argc; ++i) foo();
+  #pragma omp teams distribute // expected-error {{the teams construct must be the only construct inside of target region}}
+  for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target
+  #pragma omp teams distribute unknown() // expected-warning {{extra tokens at the end of '#pragma omp teams distribute' are ignored}}
+  for (int i = 0; i < argc; ++i) foo();
+  L1:
+    for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute
+  for (int i = 0; i < argc; ++i)
+  {
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+    argc++;
+  }
+
+  #pragma omp target
+  #pragma omp teams distribute default(none)
+  for (int i = 0; i < 10; ++i)
+  ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_num_teams_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_num_teams_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_num_teams_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_num_teams_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,67 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute num_teams // expected-error {{expected '(' after 'num_teams'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute num_teams( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute num_teams() // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute num_teams(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute num_teams(argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute num_teams(foobool(argc)) num_teams(3) // expected-error {{directive '#pragma omp teams distribute' cannot contain more than one 'num_teams' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute num_teams(S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute num_teams(argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute num_teams (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute num_teams(v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute num_teams(v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute num_teams(0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute num_teams(-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,85 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+template<class T, class N> T reduct(T* arr, N num) {
+  N i;
+  N ind;
+  T sum = (T)0;
+// CHECK: T sum = (T)0;
+#pragma omp target
+#pragma omp teams distribute parallel for reduction(+:sum) proc_bind(master) dist_schedule(static) default(shared)
+// CHECK-NEXT: #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute parallel for reduction(+: sum) proc_bind(master) dist_schedule(static)
+  for (i = 0; i < num; ++i) {
+    T cur = arr[ind];
+    ++ind;
+    sum += cur;
+  }
+}
+
+template<class T> struct S {
+  S(const T &a)
+    :m_a(a)
+  {}
+  T result(T *v) const {
+    T res;
+// CHECK: T res;
+#pragma omp target
+#pragma omp teams distribute parallel for lastprivate(res) if(m_a)
+// CHECK-NEXT: #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute parallel for lastprivate(res) if(this->m_a)
+    for (T i = 7; i < m_a; ++i) {
+      res = v[i-7] + m_a;
+    }
+    return res;
+  }
+  ~S()
+  {}
+  T m_a;
+};
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  int k1=0,k2=0;
+  static int *a;
+// CHECK: static int *a;
+#pragma omp target
+#pragma omp teams distribute parallel for
+// CHECK-NEXT: #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute parallel for
+  for (int i=0; i < 2; ++i)*a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: *a = 2;
+#pragma omp target
+#pragma omp teams distribute parallel for private(argc,b),lastprivate(d,f),reduction(+:e) reduction(min : g),  collapse(2) dist_schedule(static, 3) default(none) firstprivate(f) num_teams(b) num_threads(argc) shared(k1, k2)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j) {foo(); k1 += 8; k2 += 8;}
+// CHECK-NEXT: #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute parallel for private(argc,b) lastprivate(d,f) reduction(+: e) reduction(min: g) collapse(2) dist_schedule(static, 3) default(none) firstprivate(f) num_teams(b) num_threads(argc) shared(k1,k2)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j) {
+// CHECK-NEXT: foo();
+// CHECK-NEXT: k1 += 8;
+// CHECK-NEXT: k2 += 8;
+// CHECK-NEXT: }
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp target
+#pragma omp teams distribute parallel for collapse(1)
+// CHECK:      #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute parallel for collapse(1)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_messages.c cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_messages.c
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,23 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {}
+
+int main(int argc, char **argv) {
+L1:
+  foo();
+#pragma omp target
+#pragma omp teams distribute parallel for
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+#pragma omp target
+#pragma omp teams distribute parallel for
+  for (int i = 0; i < 10; ++i) {
+  L2:
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,61 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+#pragma omp teams distribute parallel for // expected-error {{unexpected OpenMP directive '#pragma omp teams distribute parallel for'}}
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute parallel for
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  {
+  #pragma omp teams distribute parallel for
+  for (int i = 0; i < 10; ++i) foo();
+  }
+  #pragma omp target
+  {
+    for (int i = 0; i < 10; ++i) foo();
+  #pragma omp teams distribute parallel for // expected-error {{the teams construct must be the only construct inside of target region}}
+  for (int i = 0; i < 10; ++i) foo();
+  }
+  #pragma omp target
+  #pragma omp teams distribute parallel for unknown() // expected-warning {{extra tokens at the end of '#pragma omp teams distribute parallel for' are ignored}}
+  for (int i = 0; i < 10; ++i) {
+  L1:
+    for (int i = 0; i < 10; ++i) foo();
+  }
+  #pragma omp target
+  #pragma omp teams distribute parallel for
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for
+  for (int i = 0; i < 10; ++i) foo();
+  {
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+    argc++;
+  }
+
+  for (int i = 0; i < 10; ++i) {
+    switch(argc) {
+     case (0):
+      #pragma omp target
+      #pragma omp teams distribute parallel for
+      for (int i = 0; i < 10; ++i)
+      {
+        foo();
+        break; // expected-error {{cannot break from a '#pragma omp teams distribute parallel for' loop}}
+        continue;
+      }
+      default:
+       break;
+    }
+  }
+  #pragma omp target
+  #pragma omp teams distribute parallel for default(none)
+  for (int i = 0; i < 10; ++i)
+  ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_misc_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,323 @@
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 100000 -fopenmp -verify %s
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp teams distribute parallel for'}} */
+#pragma omp teams distribute parallel for
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp teams distribute parallel for'}} */
+#pragma omp teams distribute parallel for foo
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp teams distribute parallel for'}} */
+#pragma omp teams distribute parallel for collapse
+
+void test_no_clause()
+{
+  int i;
+  #pragma omp target
+  #pragma omp teams distribute parallel for
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_invalid_clause()
+{
+  int i;
+  #pragma omp target
+  /* expected-warning@+1 {{extra tokens at the end of '#pragma omp teams distribute parallel for' are ignored}} */
+  #pragma omp teams distribute parallel for foo bar
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_non_identifiers()
+{
+  int i, x;
+
+  #pragma omp target
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp teams distribute parallel for' are ignored}}
+  #pragma omp teams distribute parallel for;
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp teams distribute parallel for' are ignored}}
+  #pragma omp teams distribute parallel for private(x);
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp teams distribute parallel for' are ignored}}
+  #pragma omp teams distribute parallel for , private(x);
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_private()
+{
+  int i;
+  #pragma omp target
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp teams distribute parallel for private(
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute parallel for private(,
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute parallel for private(,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for private()
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for private(int)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp teams distribute parallel for private(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp target
+  #pragma omp teams distribute parallel for private(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for private(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for private(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_firstprivate()
+{
+  // TODO: tests on this.
+  int i;
+  #pragma omp target
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for firstprivate(
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_lastprivate()
+{
+  int i;
+  #pragma omp target
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for lastprivate(
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute parallel for lastprivate(,
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute parallel for lastprivate(,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for lastprivate()
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for lastprivate(int)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp teams distribute parallel for lastprivate(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp target
+  #pragma omp teams distribute parallel for lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for lastprivate(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for lastprivate(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_reduction()
+{
+  int i, x, y;
+  #pragma omp target
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp teams distribute parallel for reduction(
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp teams distribute parallel for reduction()
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp teams distribute parallel for reduction(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected identifier}} */
+  #pragma omp teams distribute parallel for reduction(:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-error@+4 {{expected ')'}} expected-note@+4 {{to match this '('}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute parallel for reduction(,
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp teams distribute parallel for reduction(+
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  //
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for reduction(+:
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for reduction(+:)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for reduction(+:,y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for reduction(+:x,+:y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for reduction(%:x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  #pragma omp teams distribute parallel for reduction(+:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for reduction(*:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for reduction(-:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for reduction(&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for reduction(|:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for reduction(^:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for reduction(&&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for reduction(||:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for reduction(max:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for reduction(min:x)
+  for (i = 0; i < 16; ++i) ;
+  struct X { int x; };
+  struct X X;
+  #pragma omp target
+  // TODO: Is the following error correct?
+  // expected-error@+1 {{expected variable name}}
+  #pragma omp teams distribute parallel for reduction(+:X.x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp teams distribute parallel for reduction(+:x+x)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_multiple_clauses()
+{
+  int i;
+  float x = 0, y = 0, z = 0;
+  #pragma omp target
+  #pragma omp teams distribute parallel for reduction(+:x, y) reduction(-:z) // OK
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target
+  // expected-error@+1 {{private variable cannot be lastprivate}} expected-note@+1 {{defined as private}}
+  #pragma omp teams distribute parallel for private(x), lastprivate(x)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target
+  #pragma omp teams distribute parallel for reduction(+:x, y), reduction(-:z)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target
+  #pragma omp teams distribute parallel for reduction(+:x, y) reduction(-:z)
+  for (i = 0; i < 16; ++i);
+}
+
+void test_for()
+{
+  #pragma omp target
+  // expected-error@+3 {{expected '(' after 'for'}}
+  // expected-error@+2 2{{use of undeclared identifier 'i'}}
+  #pragma omp teams distribute parallel for
+  for int i = 0; i < 16; i++);
+
+  #pragma omp target
+  // expected-error@+3 {{expected ')'}}
+  // expected-note@+2 {{to match this '('}}
+  #pragma omp teams distribute parallel for
+  for (int i = 0; i < 16; i++;
+
+  #pragma omp target
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp teams distribute parallel for
+  for (int i = 0 i < 16; i++);
+
+  #pragma omp target
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp teams distribute parallel for
+  for (int i = 0; i < 16 i++);
+
+  #pragma omp target
+  // expected-error@+2 2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp teams distribute parallel for
+  for (int i = 0 i < 16 i++);
+
+  int i = 0;
+  #pragma omp target
+  // expected-error@+2 {{initialization of for-loop does not have canonical form}}
+  #pragma omp teams distribute parallel for
+  for (; i < 16; ++i);
+
+  #pragma omp target
+  // expected-error@+2 {{condition of for-loop does not have canonical form}}
+  #pragma omp teams distribute parallel for
+  for (int i = 0; ; ++i);
+
+  #pragma omp target
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp teams distribute parallel for
+  for (int i = 0; i < 16; );
+
+  #pragma omp target
+  // expected-error@+3 {{condition of for-loop does not have canonical form}}
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp teams distribute parallel for
+  for (int i = 0; ;);
+
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_num_teams_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_num_teams_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_num_teams_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_num_teams_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,67 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute parallel for num_teams // expected-error {{expected '(' after 'num_teams'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for num_teams ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for num_teams () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for num_teams (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for num_teams (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for num_teams (foobool(argc)) num_teams(3) // expected-error {{directive '#pragma omp teams distribute parallel for' cannot contain more than one 'num_teams' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for num_teams (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for num_teams (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for num_teams (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for num_teams (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for num_teams (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for num_teams (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for num_teams (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_simd_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_simd_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_simd_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_simd_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,85 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+template<class T, class N> T reduct(T* arr, N num) {
+  N i;
+  N ind;
+  T sum = (T)0;
+// CHECK: T sum = (T)0;
+#pragma omp target
+#pragma omp teams distribute parallel for simd reduction(+:sum) proc_bind(master) dist_schedule(static) default(shared)
+// CHECK-NEXT: #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute parallel for simd reduction(+: sum) proc_bind(master) dist_schedule(static)
+  for (i = 0; i < num; ++i) {
+    T cur = arr[ind];
+    ++ind;
+    sum += cur;
+  }
+}
+
+template<class T> struct S {
+  S(const T &a)
+    :m_a(a)
+  {}
+  T result(T *v) const {
+    T res;
+// CHECK: T res;
+#pragma omp target
+#pragma omp teams distribute parallel for simd lastprivate(res) if(m_a)
+// CHECK-NEXT: #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute parallel for simd lastprivate(res) if(this->m_a)
+    for (T i = 7; i < m_a; ++i) {
+      res = v[i-7] + m_a;
+    }
+    return res;
+  }
+  ~S()
+  {}
+  T m_a;
+};
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  int k1=0,k2=0;
+  static int *a;
+// CHECK: static int *a;
+#pragma omp target
+#pragma omp teams distribute parallel for simd
+// CHECK-NEXT: #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute parallel for simd
+  for (int i=0; i < 2; ++i)*a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: *a = 2;
+#pragma omp target
+#pragma omp teams distribute parallel for simd private(argc,b),lastprivate(d,f),reduction(+:e) reduction(min : g),  collapse(2) dist_schedule(static, 3) default(none) firstprivate(f) num_teams(b) num_threads(argc) shared(k1, k2)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j) {foo(); k1 += 8; k2 += 8;}
+// CHECK-NEXT: #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute parallel for simd private(argc,b) lastprivate(d,f) reduction(+: e) reduction(min: g) collapse(2) dist_schedule(static, 3) default(none) firstprivate(f) num_teams(b) num_threads(argc) shared(k1,k2)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j) {
+// CHECK-NEXT: foo();
+// CHECK-NEXT: k1 += 8;
+// CHECK-NEXT: k2 += 8;
+// CHECK-NEXT: }
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp target
+#pragma omp teams distribute parallel for simd collapse(1)
+// CHECK:      #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute parallel for simd collapse(1)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_simd_messages.c cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_simd_messages.c
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_simd_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_simd_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,23 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {}
+
+int main(int argc, char **argv) {
+L1:
+  foo();
+#pragma omp target
+#pragma omp teams distribute parallel for simd
+  for (int i = 0; i < 10; ++i) {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+#pragma omp target
+#pragma omp teams distribute parallel for simd
+  for (int i = 0; i < 10; ++i) {
+  L2:
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_simd_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_simd_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_simd_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_simd_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,62 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+#pragma omp teams distribute parallel for simd // expected-error {{unexpected OpenMP directive '#pragma omp teams distribute parallel for simd'}}
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  {
+  #pragma omp teams distribute parallel for simd
+  for (int i = 0; i < 10; ++i) foo();
+  }
+  #pragma omp target
+  {
+    for (int i = 0; i < 10; ++i) foo();
+  #pragma omp teams distribute parallel for simd // expected-error {{the teams construct must be the only construct inside of target region}}
+  for (int i = 0; i < 10; ++i) foo();
+  }
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd unknown() // expected-warning {{extra tokens at the end of '#pragma omp teams distribute parallel for simd' are ignored}}
+  for (int i = 0; i < 10; ++i) {
+  L1:
+    for (int i = 0; i < 10; ++i) foo();
+  }
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd
+  for (int i = 0; i < 10; ++i)
+  ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd
+  for (int i = 0; i < 10; ++i)
+  {
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+    argc++;
+  }
+
+  for (int i = 0; i < 10; ++i) {
+    switch(argc) {
+     case (0):
+      #pragma omp target
+      #pragma omp teams distribute parallel for simd
+      for (int i = 0; i < 10; ++i)
+      {
+        foo();
+        break; // expected-error {{cannot break from a '#pragma omp teams distribute parallel for simd' loop}}
+        continue;
+      }
+      default:
+       break;
+    }
+  }
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd default(none)
+  for (int i = 0; i < 10; ++i)
+  ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_simd_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_simd_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_simd_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_simd_misc_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,323 @@
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 100000 -fopenmp -verify %s
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp teams distribute parallel for simd'}} */
+#pragma omp teams distribute parallel for simd
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp teams distribute parallel for simd'}} */
+#pragma omp teams distribute parallel for simd foo
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp teams distribute parallel for simd'}} */
+#pragma omp teams distribute parallel for simd collapse
+
+void test_no_clause()
+{
+  int i;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_invalid_clause()
+{
+  int i;
+  #pragma omp target
+  /* expected-warning@+1 {{extra tokens at the end of '#pragma omp teams distribute parallel for simd' are ignored}} */
+  #pragma omp teams distribute parallel for simd foo bar
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_non_identifiers()
+{
+  int i, x;
+
+  #pragma omp target
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp teams distribute parallel for simd' are ignored}}
+  #pragma omp teams distribute parallel for simd;
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp teams distribute parallel for simd' are ignored}}
+  #pragma omp teams distribute parallel for simd private(x);
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp teams distribute parallel for simd' are ignored}}
+  #pragma omp teams distribute parallel for simd , private(x);
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_private()
+{
+  int i;
+  #pragma omp target
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp teams distribute parallel for simd private(
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd private(,
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd private(,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd private()
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd private(int)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp teams distribute parallel for simd private(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd private(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd private(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd private(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_firstprivate()
+{
+  // TODO: tests on this.
+  int i;
+  #pragma omp target
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd firstprivate(
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_lastprivate()
+{
+  int i;
+  #pragma omp target
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd lastprivate(
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd lastprivate(,
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd lastprivate(,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd lastprivate()
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd lastprivate(int)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp teams distribute parallel for simd lastprivate(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd lastprivate(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd lastprivate(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_reduction()
+{
+  int i, x, y;
+  #pragma omp target
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp teams distribute parallel for simd reduction(
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp teams distribute parallel for simd reduction()
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp teams distribute parallel for simd reduction(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected identifier}} */
+  #pragma omp teams distribute parallel for simd reduction(:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-error@+4 {{expected ')'}} expected-note@+4 {{to match this '('}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd reduction(,
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp teams distribute parallel for simd reduction(+
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  //
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd reduction(+:
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd reduction(+:)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd reduction(+:,y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd reduction(+:x,+:y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute parallel for simd reduction(%:x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd reduction(+:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd reduction(*:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd reduction(-:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd reduction(&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd reduction(|:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd reduction(^:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd reduction(&&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd reduction(||:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd reduction(max:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd reduction(min:x)
+  for (i = 0; i < 16; ++i) ;
+  struct X { int x; };
+  struct X X;
+  #pragma omp target
+  // TODO: Is the following error correct?
+  // expected-error@+1 {{expected variable name}}
+  #pragma omp teams distribute parallel for simd reduction(+:X.x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp teams distribute parallel for simd reduction(+:x+x)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_multiple_clauses()
+{
+  int i;
+  float x = 0, y = 0, z = 0;
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd reduction(+:x, y) reduction(-:z) // OK
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target
+  // expected-error@+1 {{private variable cannot be lastprivate}} expected-note@+1 {{defined as private}}
+  #pragma omp teams distribute parallel for simd private(x), lastprivate(x)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd reduction(+:x, y), reduction(-:z)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd reduction(+:x, y) reduction(-:z)
+  for (i = 0; i < 16; ++i);
+}
+
+void test_for()
+{
+  #pragma omp target
+  // expected-error@+3 {{expected '(' after 'for'}}
+  // expected-error@+2 2{{use of undeclared identifier 'i'}}
+  #pragma omp teams distribute parallel for simd
+  for int i = 0; i < 16; i++);
+
+  #pragma omp target
+  // expected-error@+3 {{expected ')'}}
+  // expected-note@+2 {{to match this '('}}
+  #pragma omp teams distribute parallel for simd
+  for (int i = 0; i < 16; i++;
+
+  #pragma omp target
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp teams distribute parallel for simd
+  for (int i = 0 i < 16; i++);
+
+  #pragma omp target
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp teams distribute parallel for simd
+  for (int i = 0; i < 16 i++);
+
+  #pragma omp target
+  // expected-error@+2 2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp teams distribute parallel for simd
+  for (int i = 0 i < 16 i++);
+
+  int i = 0;
+  #pragma omp target
+  // expected-error@+2 {{initialization of for-loop does not have canonical form}}
+  #pragma omp teams distribute parallel for simd
+  for (; i < 16; ++i);
+
+  #pragma omp target
+  // expected-error@+2 {{condition of for-loop does not have canonical form}}
+  #pragma omp teams distribute parallel for simd
+  for (int i = 0; ; ++i);
+
+  #pragma omp target
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp teams distribute parallel for simd
+  for (int i = 0; i < 16; );
+
+  #pragma omp target
+  // expected-error@+3 {{condition of for-loop does not have canonical form}}
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp teams distribute parallel for simd
+  for (int i = 0; ;);
+
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_simd_num_teams_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_simd_num_teams_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_simd_num_teams_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_simd_num_teams_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,67 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd num_teams // expected-error {{expected '(' after 'num_teams'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd num_teams ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd num_teams () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd num_teams (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd num_teams (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd num_teams (foobool(argc)) num_teams(3) // expected-error {{directive '#pragma omp teams distribute parallel for simd' cannot contain more than one 'num_teams' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd num_teams (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd num_teams (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd num_teams (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd num_teams (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd num_teams (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd num_teams (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd num_teams (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_simd_thread_limit_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_simd_thread_limit_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_simd_thread_limit_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_simd_thread_limit_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,67 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd thread_limit // expected-error {{expected '(' after 'thread_limit'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd thread_limit ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd thread_limit () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd thread_limit (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd thread_limit (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd thread_limit (foobool(argc)) thread_limit(3) // expected-error {{directive '#pragma omp teams distribute parallel for simd' cannot contain more than one 'thread_limit' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd thread_limit (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd thread_limit (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd thread_limit (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd thread_limit (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd thread_limit (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd thread_limit (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for simd thread_limit (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_thread_limit_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_thread_limit_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_parallel_for_thread_limit_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_parallel_for_thread_limit_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,67 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute parallel for thread_limit // expected-error {{expected '(' after 'thread_limit'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for thread_limit ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for thread_limit () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for thread_limit (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for thread_limit (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for thread_limit (foobool(argc)) thread_limit(3) // expected-error {{directive '#pragma omp teams distribute parallel for' cannot contain more than one 'thread_limit' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for thread_limit (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for thread_limit (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for thread_limit (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for thread_limit (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for thread_limit (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for thread_limit (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute parallel for thread_limit (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_private_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_private_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,158 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  static float S2s; // expected-note {{predetermined as shared}}
+};
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+};
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f;  // expected-note {{predetermined as shared}}
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+public:
+  S4(int v):a(v) { }
+};
+class S5 { // expected-note {{'S5' declared here}}
+  int a;
+  S5():a(0) {}
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;  // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp target
+  #pragma omp teams distribute private // expected-error {{expected '(' after 'private'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private (argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private (a, b, c, d, f) // expected-error {{private variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private (argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private(ba)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private(ca) // expected-error {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private(da) // expected-error {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private(S2::S2s) // expected-error {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared(i), private(i) // expected-error {{shared variable cannot be private}} expected-note {{defined as shared}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private(i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp for private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp parallel for firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp parallel for reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp parallel for lastprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp parallel private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp parallel firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp parallel reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_reduction_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_reduction_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_reduction_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_reduction_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,165 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+  S2 &operator +=(const S2 &arg) {return (*this);} // expected-note {{implicitly declared private here}}
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note {{predetermined as shared}}
+  static const float S2sc;
+};
+const float S2::S2sc = 0; // expected-note {{'S2sc' defined here}}
+S2 b; // expected-note {{'b' defined here}}
+const S2 ba[5]; // expected-note {{'ba' defined here}}
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(const S3 &s3):a(s3.a) { }
+  S3 operator +=(const S3 &arg1) {return arg1;}
+};
+int operator +=(const S3 &arg1, const S3 &arg2) {return 5;} // expected-note {{candidate function not viable: no known conversion from 'class S6' to 'const S3' for 1st argument}}
+S3 c; // expected-note {{'c' defined here}}
+const S3 ca[5]; // expected-note {{'ca' defined here}}
+extern const int f; // expected-note 2 {{'f' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+  S4(const S4 &s4);
+  S4 &operator +=(const S4 &arg) {return (*this);}
+public:
+  S4(int v):a(v) { }
+};
+S4 &operator &=(S4 &arg1, S4 &arg2) {return arg1;} // expected-note {{candidate function not viable: no known conversion from 'S5' to 'S4 &' for 1st argument}}
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+  S5 &operator +=(const S5 &arg);
+public:
+  S5(int v):a(v) { }
+};
+class S6 {
+    int a;
+  public:
+    S6():a(6){ }
+    operator int() { return 6; }
+} o;
+
+S3 h, k;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5; // expected-note 2 {{'d' defined here}}
+  const int da[5] = { 0 }; // expected-note {{'da' defined here}}
+  int qa[5] = { 0 };
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5);
+  int i;
+  int &j = i; // expected-note 2 {{'j' defined here}}
+  S3 &p = k;
+  const int &r = da[i]; // expected-note {{'r' defined here}}
+  int &q = qa[i]; // expected-note {{'q' defined here}}
+  float fl; // expected-note {{'fl' defined here}}
+  #pragma omp target
+  #pragma omp teams distribute reduction // expected-error {{expected '(' after 'reduction'}} expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction + // expected-error {{expected '(' after 'reduction'}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction ( // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction (- // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction () // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction (*) // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction (\) // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction (&: argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction (| :argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction (|| :argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction (&& :argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction (^ : S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction (+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error {{'operator+=' is a private member of 'S2'}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction (min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' and 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction (max : argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction(+ : ba) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction(* : ca) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction(- : da) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction(^ : fl) // expected-error {{arguments of OpenMP clause 'reduction' with bitwise operators cannot be of floating type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{no viable overloaded '&='}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction(+ : o) // expected-error {{no viable overloaded '+='}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private(i), reduction(+ : j), reduction(+:q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp parallel shared(i)
+  #pragma omp target
+  #pragma omp teams distribute reduction(min : i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp parallel reduction(min : i)
+  #pragma omp target
+  #pragma omp teams distribute reduction(max : j) // expected-error {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_shared_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_shared_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_shared_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_shared_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,111 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+};
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  #pragma omp target
+  #pragma omp teams distribute shared // expected-error {{expected '(' after 'shared'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared (argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared (a, b, c, d, f)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared (argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared(ba)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared(ca)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared(da)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared(e, g)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared(h) // expected-error {{threadprivate or thread local variable cannot be shared}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute private(i), shared(i) // expected-error {{private variable cannot be shared}} expected-note {{defined as private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp parallel private(i)
+  #pragma omp target
+  #pragma omp teams distribute shared(i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute shared(j)
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_ast_print.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,44 @@
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print | FileCheck %s
+// expected-no-diagnostics
+
+#ifndef HEADER
+#define HEADER
+
+void foo() {}
+
+int main (int argc, char **argv) {
+  int b = argc, c, d, e, f, g;
+  static int a;
+// CHECK: static int a;
+#pragma omp target
+#pragma omp teams distribute simd
+// CHECK:      #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute simd
+  for (int i=0; i < 2; ++i)a=2;
+// CHECK-NEXT: for (int i = 0; i < 2; ++i)
+// CHECK-NEXT: a = 2;
+#pragma omp target
+#pragma omp teams distribute simd num_teams(a), thread_limit(c), default(none), private(argc,b),firstprivate(argv, c),shared(d,f),reduction(+:e) reduction(min : g) collapse(2), dist_schedule(static)
+  for (int i = 0; i < 10; ++i)
+  for (int j = 0; j < 10; ++j)foo();
+// CHECK-NEXT: #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute simd num_teams(a) thread_limit(c) default(none) private(argc,b) firstprivate(argv,c) shared(d,f) reduction(+: e) reduction(min: g) collapse(2) dist_schedule(static)
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: for (int j = 0; j < 10; ++j)
+// CHECK-NEXT: foo();
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+#pragma omp target
+#pragma omp teams distribute simd dist_schedule(static, argc)
+// CHECK:      #pragma omp target
+// CHECK-NEXT: #pragma omp teams distribute simd dist_schedule(static, argc)
+  for (int i = 0; i < 10; ++i)foo();
+// CHECK-NEXT: for (int i = 0; i < 10; ++i)
+// CHECK-NEXT: foo();
+  return (0);
+}
+
+#endif
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_collapse_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_collapse_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_collapse_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_collapse_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,67 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; }
+  operator bool() { return f; }
+} v2;
+
+struct S3 {
+  int f;
+  operator int() { return f; }
+} v3;
+
+int main(int argc, char **argv) { // expected-note {{declared here}}
+  #pragma omp target
+  #pragma omp teams distribute simd collapse // expected-error {{expected '(' after 'collapse'}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd collapse ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd collapse () // expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd collapse (argc // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}} expected-note {{read of non-const variable 'argc' is not allowed in a constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd collapse (argc > 0 ? argv[1] : argv[2]) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd collapse (foobool(argc)) collapse(1) // expected-error {{directive '#pragma omp teams distribute simd' cannot contain more than one 'collapse' clause}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd collapse (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd collapse (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd collapse (v1) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd collapse (v2) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd collapse (v3) // expected-error {{expression is not an integral constant expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd collapse (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd collapse (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_default_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_default_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_default_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_default_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,26 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo();
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute simd default // expected-error {{expected '(' after 'default'}} expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd default ( // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd default () // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd default (none // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd default (shared), default(shared) // expected-error {{directive '#pragma omp teams distribute simd' cannot contain more than one 'default' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd default (x) // expected-error {{expected 'none' or 'shared' in OpenMP clause 'default'}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_dist_schedule_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_dist_schedule_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_dist_schedule_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_dist_schedule_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,45 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute simd dist_schedule // expected-error {{expected '(' after 'dist_schedule'}} expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd dist_schedule ( // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd dist_schedule () // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd dist_schedule (static // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd dist_schedule (static, // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expected expression}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd dist_schedule (argc)) // expected-error {{expected 'static' in OpenMP clause 'dist_schedule'}} expected-warning {{extra tokens at the end of '#pragma omp teams distribute simd' are ignored}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd dist_schedule (static, argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd dist_schedule (static), dist_schedule (static, 1) // expected-error {{directive '#pragma omp teams distribute simd' cannot contain more than one 'dist_schedule' clause}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd dist_schedule (static, S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < 10; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd dist_schedule (static, argv[1]=2) // expected-error {{statement requires expression of integer type ('char *' invalid)}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < 10; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_firstprivate_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_firstprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,119 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s;
+  static const float S2sc;
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 { // expected-note {{'S5' declared here}}
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate // expected-error {{expected '(' after 'firstprivate'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate (argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate (a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate (argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate(ba)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate(ca)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate(da)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate(S2::S2s)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate(S2::S2sc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private(i), firstprivate(i) // expected-error {{private variable cannot be firstprivate}} expected-note{{defined as private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate(i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_loop_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_loop_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_loop_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_loop_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,231 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+namespace std {
+
+struct random_access_iterator_tag { };
+
+template <class Iter>
+struct iterator_traits {
+  typedef typename Iter::difference_type difference_type; // expected-error {{no type named 'difference_type' in 'Iter'}} expected-error {{no type named 'difference_type' in 'Iter1'}}
+  typedef typename Iter::iterator_category iterator_category; // expected-error {{no type named 'iterator_category' in 'Iter'}} expected-error {{no type named 'iterator_category' in 'Iter1'}} expected-error {{no type named 'iterator_category' in 'Iter2'}}
+};
+
+template <class Iter>
+typename iterator_traits<Iter>::difference_type distance(Iter first, Iter last) {
+  return first - last;
+}
+}
+
+class Iter {
+  public:
+    Iter() { }
+    Iter(const Iter &) { }
+    Iter operator ++() { return *this; }
+    Iter operator --() { return *this; }
+    bool operator <(Iter a) { return true; }
+    bool operator >=(Iter a) { return false; }
+};
+int operator -(Iter a, Iter b) { return 0; }
+class Iter1 {
+  public:
+    Iter1() { }
+    Iter1(const Iter1 &) { }
+    Iter1 operator ++() { return *this; }
+    Iter1 operator --() { return *this; }
+    bool operator <(Iter1 a) { return true; }
+    bool operator >=(Iter1 a) { return false; }
+};
+class Iter2 {
+  public:
+    Iter2() { }
+    Iter2(const Iter2 &) { }
+    Iter2 operator ++() { return *this; }
+    Iter2 operator --() { return *this; }
+    bool operator <(Iter2 a) { return true; }
+    bool operator >=(Iter2 a) { return false; }
+    typedef int difference_type;
+};
+int operator -(Iter2 a, Iter2 b) { return 0; }
+class Iter3 {
+  public:
+    Iter3() { }
+    Iter3(const Iter3 &) { }
+    Iter3 operator ++() { return *this; }
+    Iter3 operator --() { return *this; }
+    bool operator <(Iter3 a) { return true; }
+    bool operator >=(Iter3 a) { return false; }
+    typedef int difference_type;
+    typedef int iterator_category;
+};
+int operator -(Iter3 a, Iter3 b) { return 0; }
+class Iter4 {
+  public:
+    Iter4() { }
+    Iter4(const Iter4 &) { }
+    Iter4 operator ++() { return *this; }
+    Iter4 operator --() { return *this; }
+    bool operator <(Iter4 a) { return true; }
+    bool operator >=(Iter4 a) { return false; }
+    Iter4 operator+=(int) const {return Iter4();}
+    Iter4 operator-=(int) const {return Iter4();}
+    typedef int difference_type;
+    typedef std::random_access_iterator_tag iterator_category;
+};
+int operator -(Iter4 a, Iter4 b) { return 0; }
+
+int t;
+#pragma omp threadprivate(t)
+
+int main() {
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (int i = 0; i < 10; i++)
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (t = 0; t < 10; t++)
+    ++t;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (int i; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (float i = 0; i < 10.0f; i++) // expected-error {{variable must be of integer or random access iterator type}}
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (int i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (int i = 0; i < 10; i |= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  int i;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (i = 0; i < 10; i++)
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (i--; i < 10; i++) // expected-error {{initialization of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (i = 0; i != 10; i++) // expected-error {{condition of for-loop does not have canonical form}}
+    ++i;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (i = 0; i < 10; i ^= 2) // expected-error {{increment of for-loop does not have canonical form}}
+    ++i;
+  Iter begin, end;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (Iter I = begin; I >= end; ++I) // expected-error {{increment expression must cause 'I' to decrease on each iteration of the loop}}
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (Iter I = end; I < begin; --I) // expected-error {{increment expression must cause 'I' to increase on each iteration of the loop}}
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (Iter I = begin; I < end; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter>' requested here}} expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (Iter I = end; I >= begin; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter1 begin1;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (Iter1 I = begin1; I < begin1; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter1>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (Iter1 I = begin1; I >= begin1; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter2 begin2;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (Iter2 I = begin2; I < begin2; ++I) // expected-note {{in instantiation of template class 'std::iterator_traits<Iter2>' requested here}}  expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (Iter2 I = begin2; I >= begin2; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter3 begin3;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (Iter3 I = begin3; I < begin3; ++I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (Iter3 I = begin3; I >= begin3; --I) // expected-error {{iteration variable is not of a random access iterator type}}
+    ++I;
+  Iter4 begin4;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (Iter4 I = begin4; I < begin4; ++I)
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  goto label; // expected-error {{use of undeclared label 'label'}}
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (int i = 0; i < 100; ++i) {
+    label: ++i;
+  }
+  #pragma omp target
+  #pragma omp teams distribute simd collapse(1)
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute simd collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+  for (Iter4 I1 = begin4; I1 >= begin4; --I1)
+  for (Iter4 I2 = begin4; I2 >= begin4; --I2)
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute simd collapse(0) // expected-error {{expression is not a positive integer value}}
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I;
+  #pragma omp target
+  #pragma omp teams distribute
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp teams distribute simd // expected-error {{region must be closely nested inside a target region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp single
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp teams distribute simd // expected-error {{region must be closely nested inside a target region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp sections
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp teams distribute simd // expected-error {{region must be closely nested inside a target region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp master
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp teams distribute simd // expected-error {{region must be closely nested inside a target region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp critical
+  for (Iter4 I = begin4; I >= begin4; --I)
+    #pragma omp teams distribute simd // expected-error {{region must be closely nested inside a target region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp for ordered
+  for (Iter4 I = begin4; I >= begin4; --I)
+  #pragma omp ordered
+    #pragma omp teams distribute simd // expected-error {{region must be closely nested inside a target region}}
+    for (Iter4 J = begin4; J >= begin4; --J)
+      ++I;
+  #pragma omp target
+  #pragma omp teams distribute simd collapse(3)
+  for (Iter4 I = begin4; I >= begin4; --I)
+    ++I; // expected-error {{only for-loops are allowed for '#pragma omp teams distribute simd'}}
+  ++begin4; 
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_loop_messages1.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_loop_messages1.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_loop_messages1.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_loop_messages1.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,11 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+int main() {
+  int i;
+  goto label; // expected-error {{use of undeclared label 'label'}}
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (i = 0; i < 100; ++i) {
+    label: ++i;
+  }
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_messages.c cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_messages.c
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,24 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() { }
+
+int main(int argc, char **argv) {
+  L1:
+    foo();
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for(int i = 0; i < argc; ++i)
+  {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for(int i = 0; i < argc; ++i) {
+    L2:
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,45 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+#pragma omp teams distribute simd // expected-error {{unexpected OpenMP directive '#pragma omp teams distribute simd'}}
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  {
+  #pragma omp teams distribute simd
+  for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target
+  {
+    for (int i = 0; i < argc; ++i) foo();
+  #pragma omp teams distribute simd // expected-error {{the teams construct must be the only construct inside of target region}}
+  for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target
+  #pragma omp teams distribute simd unknown() // expected-warning {{extra tokens at the end of '#pragma omp teams distribute simd' are ignored}}
+  for (int i = 0; i < argc; ++i) foo();
+  L1:
+    for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (int i = 0; i < argc; ++i)
+  {
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+    argc++;
+  }
+
+  #pragma omp target
+  #pragma omp teams distribute simd default(none)
+  for (int i = 0; i < 10; ++i)
+  ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_misc_messages.c cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_misc_messages.c
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_misc_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_misc_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,561 @@
+// RUN: %clang_cc1 -fsyntax-only -ferror-limit 100000 -fopenmp -verify %s
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp teams distribute simd'}} */
+#pragma omp teams distribute simd
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp teams distribute simd'}} */
+#pragma omp teams distribute simd foo
+
+/* expected-error@+1 {{unexpected OpenMP directive '#pragma omp teams distribute simd'}} */
+#pragma omp teams distribute simd safelen(4)
+
+void test_no_clause()
+{
+  int i;
+  #pragma omp target
+  #pragma omp teams distribute simd
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_invalid_clause()
+{
+  int i;
+  #pragma omp target
+  /* expected-warning@+1 {{extra tokens at the end of '#pragma omp teams distribute simd' are ignored}} */
+  #pragma omp teams distribute simd foo bar
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_non_identifiers()
+{
+  int i, x;
+
+  #pragma omp target
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp teams distribute simd' are ignored}}
+  #pragma omp teams distribute simd;
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp teams distribute simd' are ignored}}
+  #pragma omp teams distribute simd private(x);
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-warning@+1 {{extra tokens at the end of '#pragma omp teams distribute simd' are ignored}}
+  #pragma omp teams distribute simd , private(x);
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_safelen()
+{
+  int i;
+  #pragma omp target
+  /* expected-error@+1 {{expected '('}}  expected-error@+1 {{expected expression}}*/
+  #pragma omp teams distribute simd safelen
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}} */
+  #pragma omp teams distribute simd safelen(
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd safelen()
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp teams distribute simd safelen(,
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp teams distribute simd' are ignored}}
+  /* expected-error@+1 {{expected expression}}  expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp teams distribute simd safelen(,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected '('}} */
+  #pragma omp teams distribute simd safelen 4)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp teams distribute simd safelen(4
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp teams distribute simd safelen(4,
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp teams distribute simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp teams distribute simd safelen(4,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd safelen(4)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp teams distribute simd safelen(4 4)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp teams distribute simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp teams distribute simd safelen(4,,4)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd safelen(4)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-warning@+3 {{extra tokens at the end of '#pragma omp teams distribute simd' are ignored}}
+  /* expected-error@+2 {{expected ')'}} */
+  /* expected-note@+1 {{to match this '('}} */
+  #pragma omp teams distribute simd safelen(4,8)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_linear()
+{
+  int i;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}} */
+  #pragma omp teams distribute simd linear(
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}*/
+  #pragma omp teams distribute simd linear(,
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd linear(,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd linear()
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd linear(int)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp teams distribute simd linear(0)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{use of undeclared identifier 'x'}} */
+  #pragma omp teams distribute simd linear(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+2 {{use of undeclared identifier 'x'}} */
+  /* expected-error@+1 {{use of undeclared identifier 'y'}} */
+  #pragma omp teams distribute simd linear(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+3 {{use of undeclared identifier 'x'}} */
+  /* expected-error@+2 {{use of undeclared identifier 'y'}} */
+  /* expected-error@+1 {{use of undeclared identifier 'z'}} */
+  #pragma omp teams distribute simd linear(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd linear(x:)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd linear(x:,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd linear(x:1)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd linear(x:2*2)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp teams distribute simd' are ignored}}
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp teams distribute simd linear(x:1,y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-warning@+2 {{extra tokens at the end of '#pragma omp teams distribute simd' are ignored}}
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp teams distribute simd linear(x:1,y,z:1)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be linear}}
+  #pragma omp teams distribute simd linear(x) linear(x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-note@+2 {{defined as private}}
+  // expected-error@+1 {{private variable cannot be linear}}
+  #pragma omp teams distribute simd private(x) linear(x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be private}}
+  #pragma omp teams distribute simd linear(x) private(x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-note@+2 {{defined as linear}}
+  // expected-error@+1 {{linear variable cannot be lastprivate}}
+  #pragma omp teams distribute simd linear(x) lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-note@+2 {{defined as lastprivate}}
+  // expected-error@+1 {{lastprivate variable cannot be linear}}
+  #pragma omp teams distribute simd lastprivate(x) linear(x) 
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_private()
+{
+  int i;
+  #pragma omp target
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp teams distribute simd private(
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute simd private(,
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute simd private(,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd private()
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd private(int)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp teams distribute simd private(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp target
+  #pragma omp teams distribute simd private(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd private(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd private(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_firstprivate()
+{
+  // TODO: tests on this.
+  int i;
+  #pragma omp target
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd firstprivate(
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_lastprivate()
+{
+  int i;
+  #pragma omp target
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd lastprivate(
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute simd lastprivate(,
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute simd lastprivate(,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd lastprivate()
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd lastprivate(int)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp teams distribute simd lastprivate(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int x, y, z;
+  #pragma omp target
+  #pragma omp teams distribute simd lastprivate(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd lastprivate(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd lastprivate(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_reduction()
+{
+  int i, x, y;
+  #pragma omp target
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp teams distribute simd reduction(
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+2 {{expected identifier}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp teams distribute simd reduction()
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp teams distribute simd reduction(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected identifier}} */
+  #pragma omp teams distribute simd reduction(:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-error@+4 {{expected ')'}} expected-note@+4 {{to match this '('}}
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute simd reduction(,
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  /* expected-error@+2 {{expected expression}} */
+  /* expected-error@+1 {{expected ':' in 'reduction' clause}} */
+  #pragma omp teams distribute simd reduction(+
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  // expected-error@+3 {{expected ')'}} expected-note@+3 {{to match this '('}}
+  //
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd reduction(+:
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd reduction(+:)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd reduction(+:,y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd reduction(+:x,+:y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+3 {{expected identifier}} */
+  /* expected-error@+2 {{expected ':' in 'reduction' clause}} */
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd reduction(%:x)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(+:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(*:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(-:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(|:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(^:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(&&:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(||:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(max:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(min:x)
+  for (i = 0; i < 16; ++i) ;
+  struct X { int x; };
+  struct X X;
+  #pragma omp target
+  // TODO: Is the following error correct?
+  // expected-error@+1 {{expected variable name}}
+  #pragma omp teams distribute simd reduction(+:X.x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp teams distribute simd reduction(+:x+x)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_aligned()
+{
+  int i;
+  #pragma omp target
+  /* expected-error@+2 {{expected expression}} */
+  // expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
+  #pragma omp teams distribute simd aligned(
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute simd aligned(,
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 2 {{expected expression}} */
+  #pragma omp teams distribute simd aligned(,)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd aligned()
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected expression}} */
+  #pragma omp teams distribute simd aligned(int)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{expected variable name}} */
+  #pragma omp teams distribute simd aligned(0)
+  for (i = 0; i < 16; ++i) ;
+
+  int *x, y, z[25];
+  #pragma omp target
+  #pragma omp teams distribute simd aligned(x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp teams distribute simd aligned(x, y)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp teams distribute simd aligned(x, y, z)
+  for (i = 0; i < 16; ++i) ;
+
+  #pragma omp target
+  #pragma omp teams distribute simd aligned(x:4)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp teams distribute simd aligned(x, y:8)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  /* expected-error@+1 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}} */
+  #pragma omp teams distribute simd aligned(x, y, z:10+6)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-error@+2 {{argument of an aligned clause should be array, pointer, reference to array or reference to pointer}}
+  // expected-error@+1 {{expression is not an integer constant expression}}
+  #pragma omp teams distribute simd aligned(x, y, z:x)
+  for (i = 0; i < 16; ++i) ;
+  #pragma omp target
+  // expected-note@+2 {{defined as aligned}}
+  // expected-error@+1 {{aligned variable cannot be aligned}}
+  #pragma omp teams distribute simd aligned(x:16) aligned(z,x:16)
+  for (i = 0; i < 16; ++i) ;
+}
+
+void test_multiple_clauses()
+{
+  int i;
+  float x = 0, y = 0, z = 0;
+  #pragma omp target
+  #pragma omp teams distribute simd safelen(4) reduction(+:x, y) reduction(-:z) // OK
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target
+  // expected-error@+1 {{private variable cannot be lastprivate}} expected-note@+1 {{defined as private}}
+  #pragma omp teams distribute simd private(x), lastprivate(x)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target
+  #pragma omp teams distribute simd safelen(4) reduction(+:x, y), reduction(-:z)
+  for (i = 0; i < 16; ++i);
+
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(+:x, y) reduction(-:z)
+  for (i = 0; i < 16; ++i);
+}
+
+void test_for()
+{
+  #pragma omp target
+  // expected-error@+3 {{expected '(' after 'for'}}
+  // expected-error@+2 2{{use of undeclared identifier 'i'}}
+  #pragma omp teams distribute simd
+  for int i = 0; i < 16; i++);
+
+  #pragma omp target
+  // expected-error@+3 {{expected ')'}}
+  // expected-note@+2 {{to match this '('}}
+  #pragma omp teams distribute simd
+  for (int i = 0; i < 16; i++;
+
+  #pragma omp target
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp teams distribute simd
+  for (int i = 0 i < 16; i++);
+
+  #pragma omp target
+  // expected-error@+2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp teams distribute simd
+  for (int i = 0; i < 16 i++);
+
+  #pragma omp target
+  // expected-error@+2 2 {{expected ';' in 'for' statement specifier}}
+  #pragma omp teams distribute simd
+  for (int i = 0 i < 16 i++);
+
+  int i = 0;
+  #pragma omp target
+  // expected-error@+2 {{initialization of for-loop does not have canonical form}}
+  #pragma omp teams distribute simd
+  for (; i < 16; ++i);
+
+  #pragma omp target
+  // expected-error@+2 {{condition of for-loop does not have canonical form}}
+  #pragma omp teams distribute simd
+  for (int i = 0; ; ++i);
+
+  #pragma omp target
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp teams distribute simd
+  for (int i = 0; i < 16; );
+
+  #pragma omp target
+  // expected-error@+3 {{condition of for-loop does not have canonical form}}
+  // expected-error@+2 {{increment of for-loop does not have canonical form}}
+  #pragma omp teams distribute simd
+  for (int i = 0; ;);
+
+}
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_num_teams_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_num_teams_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_num_teams_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_num_teams_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,67 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute simd num_teams // expected-error {{expected '(' after 'num_teams'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd num_teams( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd num_teams() // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd num_teams(argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd num_teams(argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd num_teams(foobool(argc)) num_teams(3) // expected-error {{directive '#pragma omp teams distribute simd' cannot contain more than one 'num_teams' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd num_teams(S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd num_teams(argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd num_teams (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd num_teams(v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd num_teams(v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd num_teams(0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd num_teams(-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_private_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_private_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,158 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  static float S2s; // expected-note {{predetermined as shared}}
+};
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+};
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f;  // expected-note {{predetermined as shared}}
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+public:
+  S4(int v):a(v) { }
+};
+class S5 { // expected-note {{'S5' declared here}}
+  int a;
+  S5():a(0) {}
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;  // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp target
+  #pragma omp teams distribute simd private // expected-error {{expected '(' after 'private'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private (argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private (a, b, c, d, f) // expected-error {{private variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private (argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private(ba)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private(ca) // expected-error {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private(da) // expected-error {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private(S2::S2s) // expected-error {{shared variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared(i), private(i) // expected-error {{shared variable cannot be private}} expected-note {{defined as shared}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private(i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp for private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp parallel for firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp parallel for reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp parallel for lastprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp parallel private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp parallel firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+  #pragma omp parallel reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams distribute simd private(i)
+    for (int i = 0; i < argc; ++i) foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_reduction_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_reduction_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_reduction_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_reduction_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,165 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+  S2 &operator +=(const S2 &arg) {return (*this);} // expected-note {{implicitly declared private here}}
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note {{predetermined as shared}}
+  static const float S2sc;
+};
+const float S2::S2sc = 0; // expected-note {{'S2sc' defined here}}
+S2 b; // expected-note {{'b' defined here}}
+const S2 ba[5]; // expected-note {{'ba' defined here}}
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(const S3 &s3):a(s3.a) { }
+  S3 operator +=(const S3 &arg1) {return arg1;}
+};
+int operator +=(const S3 &arg1, const S3 &arg2) {return 5;} // expected-note {{candidate function not viable: no known conversion from 'class S6' to 'const S3' for 1st argument}}
+S3 c; // expected-note {{'c' defined here}}
+const S3 ca[5]; // expected-note {{'ca' defined here}}
+extern const int f; // expected-note 2 {{'f' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+  S4(const S4 &s4);
+  S4 &operator +=(const S4 &arg) {return (*this);}
+public:
+  S4(int v):a(v) { }
+};
+S4 &operator &=(S4 &arg1, S4 &arg2) {return arg1;} // expected-note {{candidate function not viable: no known conversion from 'S5' to 'S4 &' for 1st argument}}
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+  S5 &operator +=(const S5 &arg);
+public:
+  S5(int v):a(v) { }
+};
+class S6 {
+    int a;
+  public:
+    S6():a(6){ }
+    operator int() { return 6; }
+} o;
+
+S3 h, k;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5; // expected-note 2 {{'d' defined here}}
+  const int da[5] = { 0 }; // expected-note {{'da' defined here}}
+  int qa[5] = { 0 };
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5);
+  int i;
+  int &j = i; // expected-note 2 {{'j' defined here}}
+  S3 &p = k;
+  const int &r = da[i]; // expected-note {{'r' defined here}}
+  int &q = qa[i]; // expected-note {{'q' defined here}}
+  float fl; // expected-note {{'fl' defined here}}
+  #pragma omp target
+  #pragma omp teams distribute simd reduction // expected-error {{expected '(' after 'reduction'}} expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction + // expected-error {{expected '(' after 'reduction'}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction ( // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction (- // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction () // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction (*) // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction (\) // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction (&: argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction (| :argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction (|| :argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction (&& :argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction (^ : S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction (+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error {{'operator+=' is a private member of 'S2'}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction (min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' and 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction (max : argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(+ : ba) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(* : ca) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(- : da) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(^ : fl) // expected-error {{arguments of OpenMP clause 'reduction' with bitwise operators cannot be of floating type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{no viable overloaded '&='}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(+ : o) // expected-error {{no viable overloaded '+='}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private(i), reduction(+ : j), reduction(+:q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp parallel shared(i)
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(min : i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp parallel reduction(min : i)
+  #pragma omp target
+  #pragma omp teams distribute simd reduction(max : j) // expected-error {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_shared_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_shared_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_shared_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_shared_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,111 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+};
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  #pragma omp target
+  #pragma omp teams distribute simd shared // expected-error {{expected '(' after 'shared'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared (argc)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared (a, b, c, d, f)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared (argv[1]) // expected-error {{expected variable name}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared(ba)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared(ca)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared(da)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared(e, g)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared(h) // expected-error {{threadprivate or thread local variable cannot be shared}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd private(i), shared(i) // expected-error {{private variable cannot be shared}} expected-note {{defined as private}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp parallel private(i)
+  #pragma omp target
+  #pragma omp teams distribute simd shared(i)
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd shared(j)
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_thread_limit_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_thread_limit_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_simd_thread_limit_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_simd_thread_limit_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,67 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute simd thread_limit // expected-error {{expected '(' after 'thread_limit'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd thread_limit ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd thread_limit () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd thread_limit (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd thread_limit (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd thread_limit (foobool(argc)) thread_limit(3) // expected-error {{directive '#pragma omp teams distribute simd' cannot contain more than one 'thread_limit' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd thread_limit (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd thread_limit (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd thread_limit (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd thread_limit (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd thread_limit (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd thread_limit (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute simd thread_limit (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_distribute_thread_limit_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_thread_limit_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_distribute_thread_limit_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_distribute_thread_limit_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,67 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams distribute thread_limit // expected-error {{expected '(' after 'thread_limit'}} expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute thread_limit ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute thread_limit () // expected-error {{expected expression}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute thread_limit (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute thread_limit (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute thread_limit (foobool(argc)) thread_limit(3) // expected-error {{directive '#pragma omp teams distribute' cannot contain more than one 'thread_limit' clause}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute thread_limit (S1) // expected-error {{'S1' does not refer to a value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute thread_limit (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute thread_limit (v1) // expected-error {{expression has incomplete type 'S1'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute thread_limit (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute thread_limit (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute thread_limit (0) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+  #pragma omp target
+  #pragma omp teams distribute thread_limit (-1) // expected-error {{expression is not a positive integer value}}
+  for (int i = 0; i < argc; ++i) foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_firstprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_firstprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_firstprivate_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_firstprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,119 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s;
+  static const float S2sc;
+};
+const float S2::S2sc = 0;
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 { // expected-note {{'S5' declared here}}
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp target
+  #pragma omp teams firstprivate // expected-error {{expected '(' after 'firstprivate'}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate () // expected-error {{expected expression}}
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate (argc)
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate (S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate (a, b, c, d, f) // expected-error {{firstprivate variable with incomplete type 'S1'}}
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate (argv[1]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate(ba)
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate(ca)
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate(da)
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate(S2::S2s)
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate(S2::S2sc)
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate(e, g) // expected-error 2 {{firstprivate variable must have an accessible, unambiguous copy constructor}}
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate(h) // expected-error {{threadprivate or thread local variable cannot be firstprivate}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private(i), firstprivate(i) // expected-error {{private variable cannot be firstprivate}} expected-note{{defined as private}}
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate(i)
+  foo();
+  #pragma omp target
+  #pragma omp teams firstprivate(j) // expected-error {{arguments of OpenMP clause 'firstprivate' cannot be of reference type}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_messages.c cfe-3.5.0.src.omp/test/OpenMP/teams_messages.c
--- cfe-3.5.0.src/test/OpenMP/teams_messages.c	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_messages.c	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,21 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() { }
+
+int main(int argc, char **argv) {
+  L1:
+    foo();
+  #pragma omp target
+  #pragma omp teams
+  {
+    foo();
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+  }
+  goto L2; // expected-error {{use of undeclared label 'L2'}}
+  #pragma omp target
+  #pragma omp teams
+  L2:
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,57 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -o - %s
+
+void foo() {
+}
+
+#pragma omp teams // expected-error {{unexpected OpenMP directive '#pragma omp teams'}}
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams
+  foo();
+  #pragma omp target
+  {
+  #pragma omp teams
+  foo();
+  }
+  #pragma omp target
+  {
+    foo();
+  #pragma omp teams // expected-error {{the teams construct must be the only construct inside of target region}}
+  foo();
+  }
+  #pragma omp target
+  #pragma omp teams unknown() // expected-warning {{extra tokens at the end of '#pragma omp teams' are ignored}}
+  foo();
+  L1:
+    foo();
+  #pragma omp target
+  #pragma omp teams
+  ;
+  #pragma omp target
+  #pragma omp teams
+  {
+    goto L1; // expected-error {{use of undeclared label 'L1'}}
+    argc++;
+  }
+
+  for (int i = 0; i < 10; ++i) {
+    switch(argc) {
+     case (0):
+      #pragma omp target
+      #pragma omp teams
+      {
+        foo();
+        break; // expected-error {{'break' statement not in loop or switch statement}}
+        continue; // expected-error {{'continue' statement not in loop statement}}
+      }
+      default:
+       break;
+    }
+  }
+  #pragma omp target
+  #pragma omp teams default(none)
+  ++argc; // expected-error {{variable 'argc' must have explicitly specified data sharing attributes}}
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_num_teams_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_num_teams_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_num_teams_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_num_teams_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,67 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams num_teams // expected-error {{expected '(' after 'num_teams'}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target
+  #pragma omp teams num_teams ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams num_teams () // expected-error {{expected expression}}
+  foo();
+  #pragma omp target
+  #pragma omp teams num_teams (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams num_teams (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  foo();
+  #pragma omp target
+  #pragma omp teams num_teams (foobool(argc)) num_teams(3) // expected-error {{directive '#pragma omp teams' cannot contain more than one 'num_teams' clause}}
+  foo();
+  #pragma omp target
+  #pragma omp teams num_teams (S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target
+  #pragma omp teams num_teams (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  foo();
+  #pragma omp target
+  #pragma omp teams num_teams (v1) // expected-error {{expression has incomplete type 'S1'}}
+  foo();
+  #pragma omp target
+  #pragma omp teams num_teams (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  foo();
+  #pragma omp target
+  #pragma omp teams num_teams (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  foo();
+  #pragma omp target
+  #pragma omp teams num_teams (0) // expected-error {{expression is not a positive integer value}}
+  foo();
+  #pragma omp target
+  #pragma omp teams num_teams (-1) // expected-error {{expression is not a positive integer value}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_private_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_private_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_private_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_private_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,158 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note{{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  static float S2s; // expected-note {{predetermined as shared}}
+};
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+};
+const S3 c; // expected-note {{predetermined as shared}}
+const S3 ca[5]; // expected-note {{predetermined as shared}}
+extern const int f;  // expected-note {{predetermined as shared}}
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+public:
+  S4(int v):a(v) { }
+};
+class S5 { // expected-note {{'S5' declared here}}
+  int a;
+  S5():a(0) {}
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;  // expected-note {{predetermined as shared}}
+  const int da[5] = { 0 }; // expected-note {{predetermined as shared}}
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5); // expected-note {{'g' defined here}}
+  int i;
+  int &j = i; // expected-note {{'j' defined here}}
+  #pragma omp target
+  #pragma omp teams private // expected-error {{expected '(' after 'private'}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private () // expected-error {{expected expression}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private (argc)
+  foo();
+  #pragma omp target
+  #pragma omp teams private (S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private (a, b, c, d, f) // expected-error {{private variable with incomplete type 'S1'}} expected-error 3 {{shared variable cannot be private}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private (argv[1]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private(ba)
+  foo();
+  #pragma omp target
+  #pragma omp teams private(ca) // expected-error {{shared variable cannot be private}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private(da) // expected-error {{shared variable cannot be private}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private(S2::S2s) // expected-error {{shared variable cannot be private}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private(e, g) // expected-error 2 {{private variable must have an accessible, unambiguous default constructor}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private(h) // expected-error {{threadprivate or thread local variable cannot be private}}
+  foo();
+  #pragma omp target
+  #pragma omp teams shared(i), private(i) // expected-error {{shared variable cannot be private}} expected-note {{defined as shared}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private(i)
+  foo();
+  #pragma omp target
+  #pragma omp teams private(j) // expected-error {{arguments of OpenMP clause 'private' cannot be of reference type}}
+  foo();
+  #pragma omp for private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams private(i)
+    foo();
+  }
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp parallel for firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams private(i)
+    foo();
+  }
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp parallel for reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams private(i)
+    foo();
+  }
+  #pragma omp target
+  #pragma omp teams
+  #pragma omp parallel for lastprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams private(i)
+    foo();
+  }
+  #pragma omp parallel private(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams private(i)
+    foo();
+  }
+  #pragma omp parallel firstprivate(i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams private(i)
+    foo();
+  }
+  #pragma omp parallel reduction(+:i)
+  for (int k = 0; k < 10; ++k) {
+    #pragma omp target
+    #pragma omp teams private(i)
+    foo();
+  }
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_reduction_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_reduction_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_reduction_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_reduction_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,165 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note 2 {{forward declaration of 'S1'}}
+extern S1 a;
+class S2 {
+  mutable int a;
+  S2 &operator +=(const S2 &arg) {return (*this);} // expected-note {{implicitly declared private here}}
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+  static float S2s; // expected-note {{predetermined as shared}}
+  static const float S2sc;
+};
+const float S2::S2sc = 0; // expected-note {{'S2sc' defined here}}
+S2 b; // expected-note {{'b' defined here}}
+const S2 ba[5]; // expected-note {{'ba' defined here}}
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(const S3 &s3):a(s3.a) { }
+  S3 operator +=(const S3 &arg1) {return arg1;}
+};
+int operator +=(const S3 &arg1, const S3 &arg2) {return 5;} // expected-note {{candidate function not viable: no known conversion from 'class S6' to 'const S3' for 1st argument}}
+S3 c; // expected-note {{'c' defined here}}
+const S3 ca[5]; // expected-note {{'ca' defined here}}
+extern const int f; // expected-note 2 {{'f' declared here}}
+class S4 { // expected-note {{'S4' declared here}}
+  int a;
+  S4();
+  S4(const S4 &s4);
+  S4 &operator +=(const S4 &arg) {return (*this);}
+public:
+  S4(int v):a(v) { }
+};
+S4 &operator &=(S4 &arg1, S4 &arg2) {return arg1;} // expected-note {{candidate function not viable: no known conversion from 'S5' to 'S4 &' for 1st argument}}
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+  S5 &operator +=(const S5 &arg);
+public:
+  S5(int v):a(v) { }
+};
+class S6 {
+    int a;
+  public:
+    S6():a(6){ }
+    operator int() { return 6; }
+} o;
+
+S3 h, k;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5; // expected-note 2 {{'d' defined here}}
+  const int da[5] = { 0 }; // expected-note {{'da' defined here}}
+  int qa[5] = { 0 };
+  S4 e(4); // expected-note {{'e' defined here}}
+  S5 g(5);
+  int i;
+  int &j = i; // expected-note 2 {{'j' defined here}}
+  S3 &p = k;
+  const int &r = da[i]; // expected-note {{'r' defined here}}
+  int &q = qa[i]; // expected-note {{'q' defined here}}
+  float fl; // expected-note {{'fl' defined here}}
+  #pragma omp target
+  #pragma omp teams reduction // expected-error {{expected '(' after 'reduction'}} expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction + // expected-error {{expected '(' after 'reduction'}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction ( // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction (- // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction () // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction (*) // expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction (\) // expected-error {{expected unqualified-id}} expected-error {{expected ':' in 'reduction' clause}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction (&: argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction (| :argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction (|| :argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction (&& :argc)
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction (^ : S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction (+ : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error {{'operator+=' is a private member of 'S2'}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction (min : a, b, c, d, f) // expected-error {{reduction variable with incomplete type 'S1'}} expected-error 2 {{arguments of OpenMP clause 'reduction' for 'min' and 'max' must be of arithmetic type}} expected-error 2 {{const-qualified variable cannot be reduction}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction (max : argv[1]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction(+ : ba) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction(* : ca) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction(- : da) // expected-error {{arguments of OpenMP clause 'reduction' cannot be of array type}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction(^ : fl) // expected-error {{arguments of OpenMP clause 'reduction' with bitwise operators cannot be of floating type}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction(&& : S2::S2s) // expected-error {{shared variable cannot be reduction}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction(&& : S2::S2sc) // expected-error {{const-qualified variable cannot be reduction}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction(& : e, g) // expected-error {{reduction variable must have an accessible, unambiguous default constructor}} expected-error {{no viable overloaded '&='}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction(+ : h, k) // expected-error {{threadprivate or thread local variable cannot be reduction}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction(+ : o) // expected-error {{no viable overloaded '+='}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private(i), reduction(+ : j), reduction(+:q) // expected-error 2 {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction(+ : p), reduction(+ : p) // expected-error {{variable can appear only once in OpenMP 'reduction' clause}} expected-note {{previously referenced here}}
+  foo();
+  #pragma omp target
+  #pragma omp teams reduction(+ : r) // expected-error {{const-qualified variable cannot be reduction}}
+  foo();
+  #pragma omp parallel shared(i)
+  #pragma omp target
+  #pragma omp teams reduction(min : i)
+  foo();
+  #pragma omp parallel reduction(min : i)
+  #pragma omp target
+  #pragma omp teams reduction(max : j) // expected-error {{argument of OpenMP clause 'reduction' must reference the same object in all threads}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_shared_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_shared_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_shared_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_shared_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,111 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}}
+extern S1 a;
+class S2 {
+  mutable int a;
+public:
+  S2():a(0) { }
+  S2(S2 &s2):a(s2.a) { }
+};
+const S2 b;
+const S2 ba[5];
+class S3 {
+  int a;
+public:
+  S3():a(0) { }
+  S3(S3 &s3):a(s3.a) { }
+};
+const S3 c;
+const S3 ca[5];
+extern const int f;
+class S4 {
+  int a;
+  S4();
+  S4(const S4 &s4);
+public:
+  S4(int v):a(v) { }
+};
+class S5 {
+  int a;
+  S5():a(0) {}
+  S5(const S5 &s5):a(s5.a) { }
+public:
+  S5(int v):a(v) { }
+};
+
+S3 h;
+#pragma omp threadprivate(h) // expected-note {{defined as threadprivate or thread local}}
+
+int main(int argc, char **argv) {
+  const int d = 5;
+  const int da[5] = { 0 };
+  S4 e(4);
+  S5 g(5);
+  int i;
+  int &j = i;
+  #pragma omp target
+  #pragma omp teams shared // expected-error {{expected '(' after 'shared'}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target
+  #pragma omp teams shared ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams shared () // expected-error {{expected expression}}
+  foo();
+  #pragma omp target
+  #pragma omp teams shared (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams shared (argc, // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams shared (argc > 0 ? argv[1] : argv[2]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target
+  #pragma omp teams shared (argc)
+  foo();
+  #pragma omp target
+  #pragma omp teams shared (S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target
+  #pragma omp teams shared (a, b, c, d, f)
+  foo();
+  #pragma omp target
+  #pragma omp teams shared (argv[1]) // expected-error {{expected variable name}}
+  foo();
+  #pragma omp target
+  #pragma omp teams shared(ba)
+  foo();
+  #pragma omp target
+  #pragma omp teams shared(ca)
+  foo();
+  #pragma omp target
+  #pragma omp teams shared(da)
+  foo();
+  #pragma omp target
+  #pragma omp teams shared(e, g)
+  foo();
+  #pragma omp target
+  #pragma omp teams shared(h) // expected-error {{threadprivate or thread local variable cannot be shared}}
+  foo();
+  #pragma omp target
+  #pragma omp teams private(i), shared(i) // expected-error {{private variable cannot be shared}} expected-note {{defined as private}}
+  foo();
+  #pragma omp parallel private(i)
+  #pragma omp target
+  #pragma omp teams shared(i)
+  foo();
+  #pragma omp target
+  #pragma omp teams shared(j)
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/teams_thread_limit_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/teams_thread_limit_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/teams_thread_limit_messages.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/teams_thread_limit_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,67 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 -std=c++11 -o - %s
+
+void foo() {
+}
+
+bool foobool(int argc) {
+  return argc;
+}
+
+struct S1; // expected-note {{declared here}} expected-note {{forward declaration of 'S1'}}
+
+extern S1 v1;
+
+struct S2{
+  int f;
+  operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+  operator bool() { return f; } // expected-note {{conversion to integral type 'bool'}}
+} v2;
+
+struct S3 {
+  int f;
+  explicit operator int() { return f; } // expected-note {{conversion to integral type 'int'}}
+} v3;
+
+int main(int argc, char **argv) {
+  #pragma omp target
+  #pragma omp teams thread_limit // expected-error {{expected '(' after 'thread_limit'}} expected-error {{expected expression}}
+  foo();
+  #pragma omp target
+  #pragma omp teams thread_limit ( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams thread_limit () // expected-error {{expected expression}}
+  foo();
+  #pragma omp target
+  #pragma omp teams thread_limit (argc // expected-error {{expected ')'}} expected-note {{to match this '('}}
+  foo();
+  #pragma omp target
+  #pragma omp teams thread_limit (argc > 0 ? argv[1] : argv[2]) // expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  foo();
+  #pragma omp target
+  #pragma omp teams thread_limit (foobool(argc)) thread_limit(3) // expected-error {{directive '#pragma omp teams' cannot contain more than one 'thread_limit' clause}}
+  foo();
+  #pragma omp target
+  #pragma omp teams thread_limit (S1) // expected-error {{'S1' does not refer to a value}}
+  foo();
+  #pragma omp target
+  #pragma omp teams thread_limit (argv[1]=2) // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{statement requires expression of integer type ('char *' invalid)}}
+  foo();
+  #pragma omp target
+  #pragma omp teams thread_limit (v1) // expected-error {{expression has incomplete type 'S1'}}
+  foo();
+  #pragma omp target
+  #pragma omp teams thread_limit (v2) // expected-error {{multiple conversions from expression type 'struct S2' to an integral or enumeration type}}
+  foo();
+  #pragma omp target
+  #pragma omp teams thread_limit (v3) // expected-error {{expression type 'struct S3' requires explicit conversion to 'int'}}
+  foo();
+  #pragma omp target
+  #pragma omp teams thread_limit (0) // expected-error {{expression is not a positive integer value}}
+  foo();
+  #pragma omp target
+  #pragma omp teams thread_limit (-1) // expected-error {{expression is not a positive integer value}}
+  foo();
+
+  return 0;
+}
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/threadprivate_ast_print.cpp cfe-3.5.0.src.omp/test/OpenMP/threadprivate_ast_print.cpp
--- cfe-3.5.0.src/test/OpenMP/threadprivate_ast_print.cpp	2014-03-07 03:03:37.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/threadprivate_ast_print.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -verify -fopenmp=libiomp5 -ast-print %s | FileCheck %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -x c++ -std=c++11 -emit-pch -o %t %s
-// RUN: %clang_cc1 -fopenmp=libiomp5 -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print
+// RUN: %clang_cc1 -verify -fopenmp -ast-print %s | FileCheck %s
+// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -emit-pch -o %t %s
+// RUN: %clang_cc1 -fopenmp -std=c++11 -include-pch %t -fsyntax-only -verify %s -ast-print
 // expected-no-diagnostics
 
 #ifndef HEADER
@@ -26,16 +26,9 @@
 #pragma omp threadprivate(d, b)
 // CHECK-NEXT: #pragma omp threadprivate(d,b)
 
-template <class T>
-struct ST {
-  static T m;
-  #pragma omp threadprivate(m)
-};
-
 template <class T> T foo() {
   static T v;
   #pragma omp threadprivate(v)
-  v = ST<T>::m;
   return v;
 }
 //CHECK: template <class T = int> int foo() {
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/threadprivate_codegen.cpp cfe-3.5.0.src.omp/test/OpenMP/threadprivate_codegen.cpp
--- cfe-3.5.0.src/test/OpenMP/threadprivate_codegen.cpp	1969-12-31 19:00:00.000000000 -0500
+++ cfe-3.5.0.src.omp/test/OpenMP/threadprivate_codegen.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -0,0 +1,65 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -emit-llvm -o - %s | FileCheck %s
+// expected-no-diagnostics
+
+// CHECK: gs = internal global %class.S zeroinitializer
+// CHECK: gs1 = internal global %class.S zeroinitializer
+// CHECK: gs.cache. = common global i8** null
+// CHECK: arr_x = global [5 x [10 x %class.S]] zeroinitializer
+// CHECK: arr_x.cache. = common global i8** null
+// CHECK: s1 = internal global %class.S zeroinitializer
+// CHECK: s1.cache. = common global i8** null
+
+class S{
+  public:
+  int a;
+  S() : a(0) {}
+  S(int a) : a(a) {}
+  S(const S& s) {a = 12 + s.a;}
+};
+
+static S gs(5), gs1(5);
+#pragma omp threadprivate(gs)
+// CHECK: define internal i8* @__kmpc_ctor_{{[a-zA-Z0-9_]+}}gs(i8*)
+// CHECK: %{{[a-zA-Z0-9_.]+}} = alloca i8*
+// CHECK: store i8* %0, i8** %{{[a-zA-Z0-9_.]+}}
+// CHECK: %{{.*}} = bitcast i8* %0 to %class.S*
+// CHECK: call void @{{[a-zA-Z0-9_]+}}(%class.S* %{{.*}}, i32 5)
+// CHECK: ret i8* %0
+// CHECK: define internal void @__omp_threadprivate_{{[a-zA-Z0-9_]+}}gs()
+// CHECK: %{{[a-zA-Z0-9_.]+}} = alloca i8*
+// CHECK: call void @__kmpc_threadprivate_register({ i32, i32, i32, i32, i8* }* %{{[a-zA-Z0-9_.]+}}, i8* bitcast (%class.S* @{{[a-zA-Z0-9_]+}}gs to i8*), i8* (i8*)* @__kmpc_ctor_{{[a-zA-Z0-9_]+}}gs, i8* (i8*, i8*)* null, i8* (i8*)* null)
+// CHECK: ret void
+S arr_x[5][10];
+#pragma omp threadprivate(arr_x)
+// CHECK: define internal i8* @__kmpc_ctor_{{.+}}arr_x(i8*)
+// CHECK: %{{[a-zA-Z0-9_.]+}} = alloca i8*
+// CHECK: store i8* %0, i8** %{{[a-zA-Z0-9_.]+}}
+// CHECK: {{.*}} = bitcast i8* %0 to {{.*}}%class.S]]*
+// CHECK: call void @{{.+}}(%class.S*
+// CHECK: ret i8* %0
+// CHECK: define internal void @__omp_threadprivate_vec_{{.*}}arr_x()
+// CHECK: %{{.*}} = alloca i8*
+// CHECK: call void @__kmpc_threadprivate_register({ i32, i32, i32, i32, i8* }* %{{[a-zA-Z0-9_.]+}}, i8* bitcast ([5 x [10 x %class.S]]* @{{[a-zA-Z0-9_]*}}arr_x to i8*), i8* (i8*)* @__kmpc_ctor_{{[a-zA-Z0-9_]*}}arr_x, i8* (i8*, i8*)* null, i8* (i8*)* null)
+// CHECK: ret void
+
+// CHECK: define i32 @main(i32 %argc, i8** %argv)
+int main(int argc, char **argv) {
+  static S s1(gs.a);
+// CHECK: %{{[0-9]+}} = call i32 @__kmpc_global_thread_num({ i32, i32, i32, i32, i8* }* %{{[a-zA-Z0-9_.]+}})
+// CHECK-NEXT: store i32 %{{[0-9]+}}, i32* %{{[a-zA-Z0-9_.]+}}
+// CHECK: call i32 @__cxa_guard_acquire
+// CHECK: = call i8* @__kmpc_threadprivate_cached({ i32, i32, i32, i32, i8* }* %{{[a-zA-Z0-9_.]+}}, i32 %{{[a-zA-Z0-9_.]+}}, i8* bitcast (%class.S* @{{[a-zA-Z0-9_]+}}gs to i8*), i64 4, i8*** @{{[a-zA-Z0-9_]+}}gs.cache.)
+// CHECK: call void @__cxa_guard_release
+  #pragma omp threadprivate(s1)
+// CHECK: = call i8* @__kmpc_threadprivate_cached({ i32, i32, i32, i32, i8* }* %{{[a-zA-Z0-9_.]+}}, i32 %{{[a-zA-Z0-9_.]+}}, i8* bitcast (%class.S* @{{[a-zA-Z0-9_]+}}s1 to i8*), i64 4, i8*** @{{[a-zA-Z0-9_]+}}s1.cache.)
+  return s1.a;
+}
+// CHECK: }
+// CHECK: define internal void @_GLOBAL__sub_I_threadprivate_codegen.cpp()
+// CHECK: call void @__cxx_global_var_init()
+// CHECK: call void @__cxx_global_var_init1()
+// CHECK: call void @__omp_threadprivate_{{[a-zA-Z0-9_]+}}gs()
+// CHECK: call void @__cxx_global_var_init2()
+// CHECK: call void @__omp_threadprivate_vec_arr_x()
+// CHECK: ret void
+
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/OpenMP/threadprivate_messages.cpp cfe-3.5.0.src.omp/test/OpenMP/threadprivate_messages.cpp
--- cfe-3.5.0.src/test/OpenMP/threadprivate_messages.cpp	2014-06-05 23:41:14.000000000 -0400
+++ cfe-3.5.0.src.omp/test/OpenMP/threadprivate_messages.cpp	2014-11-28 10:49:31.000000000 -0500
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp=libiomp5 -ferror-limit 100 %s
+// RUN: %clang_cc1 -triple x86_64-apple-macos10.7.0 -verify -fopenmp -ferror-limit 100 %s
 
-#pragma omp threadprivate // expected-error {{expected '(' after 'threadprivate'}}
+#pragma omp threadprivate // expected-error {{expected '(' after 'threadprivate'}} expected-error {{expected identifier}}
 #pragma omp threadprivate( // expected-error {{expected identifier}} expected-error {{expected ')'}} expected-note {{to match this '('}}
 #pragma omp threadprivate() // expected-error {{expected identifier}}
 #pragma omp threadprivate(1) // expected-error {{expected unqualified-id}}
@@ -24,22 +24,13 @@
   return (a);
 }
 
-#pragma omp threadprivate (a) (
-// expected-error@-1 {{'#pragma omp threadprivate' must precede all references to variable 'a'}} expected-warning@-1 {{extra tokens at the end of '#pragma omp threadprivate' are ignored}}
-#pragma omp threadprivate (a) [ // expected-error {{'#pragma omp threadprivate' must precede all references to variable 'a'}} expected-warning {{extra tokens at the end of '#pragma omp threadprivate' are ignored}}
-#pragma omp threadprivate (a) { // expected-error {{'#pragma omp threadprivate' must precede all references to variable 'a'}} expected-warning {{extra tokens at the end of '#pragma omp threadprivate' are ignored}}
-#pragma omp threadprivate (a) ) // expected-error {{'#pragma omp threadprivate' must precede all references to variable 'a'}} expected-warning {{extra tokens at the end of '#pragma omp threadprivate' are ignored}}
-#pragma omp threadprivate (a) ] // expected-error {{'#pragma omp threadprivate' must precede all references to variable 'a'}} expected-warning {{extra tokens at the end of '#pragma omp threadprivate' are ignored}}
-#pragma omp threadprivate (a) } // expected-error {{'#pragma omp threadprivate' must precede all references to variable 'a'}} expected-warning {{extra tokens at the end of '#pragma omp threadprivate' are ignored}}
-#pragma omp threadprivate a // expected-error {{expected '(' after 'threadprivate'}}
+#pragma omp threadprivate a // expected-error {{expected '(' after 'threadprivate'}} expected-error {{'#pragma omp threadprivate' must precede all references to variable 'a'}}
 #pragma omp threadprivate(d // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{'#pragma omp threadprivate' must precede all references to variable 'd'}}
 #pragma omp threadprivate(d)) // expected-error {{'#pragma omp threadprivate' must precede all references to variable 'd'}} expected-warning {{extra tokens at the end of '#pragma omp threadprivate' are ignored}}
 int x, y;
 #pragma omp threadprivate(x)) // expected-warning {{extra tokens at the end of '#pragma omp threadprivate' are ignored}}
-#pragma omp threadprivate(y)),
-// expected-warning@-1 {{extra tokens at the end of '#pragma omp threadprivate' are ignored}}
-#pragma omp threadprivate(a,d)
-// expected-error@-1 {{'#pragma omp threadprivate' must precede all references to variable 'a'}} expected-error@-1 {{'#pragma omp threadprivate' must precede all references to variable 'd'}}
+#pragma omp threadprivate(y)), // expected-warning {{extra tokens at the end of '#pragma omp threadprivate' are ignored}}
+#pragma omp threadprivate(a,d)  // expected-error {{'#pragma omp threadprivate' must precede all references to variable 'a'}} expected-error {{'#pragma omp threadprivate' must precede all references to variable 'd'}}
 #pragma omp threadprivate(d.a) // expected-error {{expected identifier}}
 #pragma omp threadprivate((float)a) // expected-error {{expected unqualified-id}}
 int foa; // expected-note {{'foa' declared here}}
@@ -55,17 +46,17 @@
 int &f = a; // expected-note {{'f' defined here}}
 #pragma omp threadprivate (f) // expected-error {{arguments of '#pragma omp threadprivate' cannot be of reference type 'int &'}}
 
-class TestClass {
+class Class {
   private:
     int a; // expected-note {{declared here}}
     static int b; // expected-note {{'b' declared here}}
-    TestClass() : a(0){}
+    Class() : a(0){}
   public:
-    TestClass (int aaa) : a(aaa) {}
+    Class (int aaa) : a(aaa) {}
 #pragma omp threadprivate (b, a) // expected-error {{'a' is not a global variable, static local variable or static data member}}
 } g(10);
 #pragma omp threadprivate (b) // expected-error {{use of undeclared identifier 'b'}}
-#pragma omp threadprivate (TestClass::b) // expected-error {{'#pragma omp threadprivate' must appear in the scope of the 'TestClass::b' variable declaration}}
+#pragma omp threadprivate (Class::b) // expected-error {{'#pragma omp threadprivate' must appear in the scope of the 'Class::b' variable declaration}}
 #pragma omp threadprivate (g)
 
 namespace ns {
@@ -108,12 +99,10 @@
 
 int main(int argc, char **argv) { // expected-note {{'argc' defined here}}
 
-  int x, y = argc; // expected-note 2 {{'y' defined here}}
+  int x, y = argc; // expected-note {{'y' defined here}}
   static double d1;
   static double d2;
   static double d3; // expected-note {{'d3' defined here}}
-  static TestClass LocalClass(y); // expected-error {{variable with local storage in initial value of threadprivate variable}}
-#pragma omp threadprivate(LocalClass)
 
   d.a = a;
   d2++;
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/test/Preprocessor/assembler-with-cpp.c cfe-3.5.0.src.omp/test/Preprocessor/assembler-with-cpp.c
--- cfe-3.5.0.src/test/Preprocessor/assembler-with-cpp.c	2013-10-21 01:02:28.000000000 -0400
+++ cfe-3.5.0.src.omp/test/Preprocessor/assembler-with-cpp.c	2014-11-28 10:49:32.000000000 -0500
@@ -80,7 +80,3 @@
 // rdar://8823139
 # ##
 // CHECK-Identifiers-False: # ##
-
-#define X(a) # # # 1
-X(1)
-// CHECK-Identifiers-False: # # # 1
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/tools/clang-format-vs/README.txt cfe-3.5.0.src.omp/tools/clang-format-vs/README.txt
--- cfe-3.5.0.src/tools/clang-format-vs/README.txt	2013-12-03 13:02:51.000000000 -0500
+++ cfe-3.5.0.src.omp/tools/clang-format-vs/README.txt	1969-12-31 19:00:00.000000000 -0500
@@ -1,13 +0,0 @@
-This directory contains a VSPackage project to generate a Visual Studio extension
-for clang-format.
-
-Build prerequisites are:
-- Visual Studio 2012 Professional
-- Visual Studio 2010 Professional
-- Visual Studio 2010 SDK.
-
-clang-format.exe must be copied into the ClangFormat/ directory before building.
-It will be bundled into the .vsix file.
-
-The extension can be built manually from ClangFormat.sln (e.g. by opening it in
-Visual Studio), or with cmake by setting the BUILD_CLANG_FORMAT_VS_PLUGIN flag.
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/tools/libclang/CIndex.cpp cfe-3.5.0.src.omp/tools/libclang/CIndex.cpp
--- cfe-3.5.0.src/tools/libclang/CIndex.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/tools/libclang/CIndex.cpp	2014-11-28 10:49:33.000000000 -0500
@@ -1857,20 +1857,54 @@
   void VisitLambdaExpr(const LambdaExpr *E);
   void VisitOMPExecutableDirective(const OMPExecutableDirective *D);
   void VisitOMPParallelDirective(const OMPParallelDirective *D);
-  void VisitOMPSimdDirective(const OMPSimdDirective *D);
   void VisitOMPForDirective(const OMPForDirective *D);
+  void VisitOMPParallelForDirective(const OMPParallelForDirective *D);
+  void VisitOMPParallelForSimdDirective(const OMPParallelForSimdDirective *D);
+  void VisitOMPSimdDirective(const OMPSimdDirective *D);
+  void VisitOMPForSimdDirective(const OMPForSimdDirective *D);
+  void VisitOMPDistributeSimdDirective(const OMPDistributeSimdDirective *D);
+  void VisitOMPDistributeParallelForDirective(
+      const OMPDistributeParallelForDirective *D);
+  void VisitOMPDistributeParallelForSimdDirective(
+      const OMPDistributeParallelForSimdDirective *D);
+  void VisitOMPTeamsDistributeParallelForDirective(
+      const OMPTeamsDistributeParallelForDirective *D);
+  void VisitOMPTeamsDistributeParallelForSimdDirective(
+      const OMPTeamsDistributeParallelForSimdDirective *D);
+  void VisitOMPTargetTeamsDistributeParallelForDirective(
+      const OMPTargetTeamsDistributeParallelForDirective *D);
+  void VisitOMPTargetTeamsDistributeParallelForSimdDirective(
+      const OMPTargetTeamsDistributeParallelForSimdDirective *D);
   void VisitOMPSectionsDirective(const OMPSectionsDirective *D);
+  void VisitOMPParallelSectionsDirective(const OMPParallelSectionsDirective *D);
   void VisitOMPSectionDirective(const OMPSectionDirective *D);
   void VisitOMPSingleDirective(const OMPSingleDirective *D);
-  void VisitOMPMasterDirective(const OMPMasterDirective *D);
-  void VisitOMPCriticalDirective(const OMPCriticalDirective *D);
-  void VisitOMPParallelForDirective(const OMPParallelForDirective *D);
-  void VisitOMPParallelSectionsDirective(const OMPParallelSectionsDirective *D);
   void VisitOMPTaskDirective(const OMPTaskDirective *D);
   void VisitOMPTaskyieldDirective(const OMPTaskyieldDirective *D);
+  void VisitOMPMasterDirective(const OMPMasterDirective *D);
+  void VisitOMPCriticalDirective(const OMPCriticalDirective *D);
   void VisitOMPBarrierDirective(const OMPBarrierDirective *D);
   void VisitOMPTaskwaitDirective(const OMPTaskwaitDirective *D);
+  void VisitOMPTaskgroupDirective(const OMPTaskgroupDirective *D);
+  void VisitOMPAtomicDirective(const OMPAtomicDirective *D);
   void VisitOMPFlushDirective(const OMPFlushDirective *D);
+  void VisitOMPOrderedDirective(const OMPOrderedDirective *D);
+  void VisitOMPTeamsDirective(const OMPTeamsDirective *D);
+  void VisitOMPTargetTeamsDirective(const OMPTargetTeamsDirective *D);
+  void VisitOMPDistributeDirective(const OMPDistributeDirective *D);
+  void VisitOMPCancelDirective(const OMPCancelDirective *D);
+  void VisitOMPCancellationPointDirective(
+                       const OMPCancellationPointDirective *D);
+  void VisitOMPTargetDirective(const OMPTargetDirective *D);
+  void VisitOMPTargetDataDirective(const OMPTargetDataDirective *D);
+  void VisitOMPTargetUpdateDirective(const OMPTargetUpdateDirective *D);
+  void VisitOMPTeamsDistributeDirective(const OMPTeamsDistributeDirective *D);
+  void VisitOMPTeamsDistributeSimdDirective(
+      const OMPTeamsDistributeSimdDirective *D);
+  void VisitOMPTargetTeamsDistributeDirective(
+      const OMPTargetTeamsDistributeDirective *D);
+  void VisitOMPTargetTeamsDistributeSimdDirective(
+      const OMPTargetTeamsDistributeSimdDirective *D);
 
 private:
   void AddDeclarationNameInfo(const Stmt *S);
@@ -1930,94 +1964,135 @@
   VisitorWorkList::iterator I = WL.begin() + size, E = WL.end();
   std::reverse(I, E);
 }
+
 namespace {
 class OMPClauseEnqueue : public ConstOMPClauseVisitor<OMPClauseEnqueue> {
   EnqueueVisitor *Visitor;
   /// \brief Process clauses with list of variables.
-  template <typename T>
-  void VisitOMPClauseList(T *Node);
+  template <typename T> void VisitOMPClauseList(const T *Node);
+
 public:
-  OMPClauseEnqueue(EnqueueVisitor *Visitor) : Visitor(Visitor) { }
-#define OPENMP_CLAUSE(Name, Class)                                             \
-  void Visit##Class(const Class *C);
+  OMPClauseEnqueue(EnqueueVisitor *Visitor) : Visitor(Visitor) {}
+#define OPENMP_CLAUSE(Name, Class) void Visit##Class(const Class *C);
 #include "clang/Basic/OpenMPKinds.def"
 };
 
-void OMPClauseEnqueue::VisitOMPIfClause(const OMPIfClause *C) {
-  Visitor->AddStmt(C->getCondition());
+template <typename T> void OMPClauseEnqueue::VisitOMPClauseList(const T *Node) {
+  for (typename T::varlist_const_iterator I = Node->varlist_begin(),
+                                          E = Node->varlist_end();
+       I != E; ++I)
+    Visitor->AddStmt(*I);
 }
 
-void OMPClauseEnqueue::VisitOMPFinalClause(const OMPFinalClause *C) {
-  Visitor->AddStmt(C->getCondition());
-}
+void OMPClauseEnqueue::VisitOMPIfClause(const OMPIfClause *C) {}
 
-void OMPClauseEnqueue::VisitOMPNumThreadsClause(const OMPNumThreadsClause *C) {
-  Visitor->AddStmt(C->getNumThreads());
-}
+void OMPClauseEnqueue::VisitOMPFinalClause(const OMPFinalClause *C) {}
 
-void OMPClauseEnqueue::VisitOMPSafelenClause(const OMPSafelenClause *C) {
-  Visitor->AddStmt(C->getSafelen());
-}
+void OMPClauseEnqueue::VisitOMPNumThreadsClause(const OMPNumThreadsClause *C) {}
 
-void OMPClauseEnqueue::VisitOMPCollapseClause(const OMPCollapseClause *C) {
-  Visitor->AddStmt(C->getNumForLoops());
-}
+void OMPClauseEnqueue::VisitOMPCollapseClause(const OMPCollapseClause *C) {}
 
-void OMPClauseEnqueue::VisitOMPDefaultClause(const OMPDefaultClause *C) { }
+void OMPClauseEnqueue::VisitOMPDefaultClause(const OMPDefaultClause *C) {}
 
-void OMPClauseEnqueue::VisitOMPProcBindClause(const OMPProcBindClause *C) { }
+void OMPClauseEnqueue::VisitOMPProcBindClause(const OMPProcBindClause *C) {}
 
-void OMPClauseEnqueue::VisitOMPScheduleClause(const OMPScheduleClause *C) {
-  Visitor->AddStmt(C->getChunkSize());
-}
+void OMPClauseEnqueue::VisitOMPDeviceClause(const OMPDeviceClause *C) {}
 
-void OMPClauseEnqueue::VisitOMPOrderedClause(const OMPOrderedClause *) {}
+void OMPClauseEnqueue::VisitOMPScheduleClause(const OMPScheduleClause *C) {}
 
-void OMPClauseEnqueue::VisitOMPNowaitClause(const OMPNowaitClause *) {}
-
-void OMPClauseEnqueue::VisitOMPUntiedClause(const OMPUntiedClause *) {}
+void
+OMPClauseEnqueue::VisitOMPDistScheduleClause(const OMPDistScheduleClause *C) {}
 
-void OMPClauseEnqueue::VisitOMPMergeableClause(const OMPMergeableClause *) {}
+void OMPClauseEnqueue::VisitOMPPrivateClause(const OMPPrivateClause *C) {
+  VisitOMPClauseList(C);
+}
 
-template<typename T>
-void OMPClauseEnqueue::VisitOMPClauseList(T *Node) {
-  for (const auto *I : Node->varlists())
-    Visitor->AddStmt(I);
+void
+OMPClauseEnqueue::VisitOMPFirstPrivateClause(const OMPFirstPrivateClause *C) {
+  VisitOMPClauseList(C);
 }
 
-void OMPClauseEnqueue::VisitOMPPrivateClause(const OMPPrivateClause *C) {
+void
+OMPClauseEnqueue::VisitOMPLastPrivateClause(const OMPLastPrivateClause *C) {
   VisitOMPClauseList(C);
 }
-void OMPClauseEnqueue::VisitOMPFirstprivateClause(
-                                        const OMPFirstprivateClause *C) {
+
+void OMPClauseEnqueue::VisitOMPSharedClause(const OMPSharedClause *C) {
   VisitOMPClauseList(C);
 }
-void OMPClauseEnqueue::VisitOMPLastprivateClause(
-                                        const OMPLastprivateClause *C) {
+
+void OMPClauseEnqueue::VisitOMPCopyinClause(const OMPCopyinClause *C) {
   VisitOMPClauseList(C);
 }
-void OMPClauseEnqueue::VisitOMPSharedClause(const OMPSharedClause *C) {
+
+void
+OMPClauseEnqueue::VisitOMPCopyPrivateClause(const OMPCopyPrivateClause *C) {
   VisitOMPClauseList(C);
 }
+
 void OMPClauseEnqueue::VisitOMPReductionClause(const OMPReductionClause *C) {
   VisitOMPClauseList(C);
 }
-void OMPClauseEnqueue::VisitOMPLinearClause(const OMPLinearClause *C) {
+
+void OMPClauseEnqueue::VisitOMPOrderedClause(const OMPOrderedClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPNowaitClause(const OMPNowaitClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPUntiedClause(const OMPUntiedClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPMergeableClause(const OMPMergeableClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPReadClause(const OMPReadClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPWriteClause(const OMPWriteClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPUpdateClause(const OMPUpdateClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPCaptureClause(const OMPCaptureClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPSeqCstClause(const OMPSeqCstClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPInBranchClause(const OMPInBranchClause *C) {}
+
+void
+OMPClauseEnqueue::VisitOMPNotInBranchClause(const OMPNotInBranchClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPFlushClause(const OMPFlushClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPDependClause(const OMPDependClause *C) {
   VisitOMPClauseList(C);
-  Visitor->AddStmt(C->getStep());
 }
-void OMPClauseEnqueue::VisitOMPAlignedClause(const OMPAlignedClause *C) {
+
+void OMPClauseEnqueue::VisitOMPMapClause(const OMPMapClause *C) {
   VisitOMPClauseList(C);
-  Visitor->AddStmt(C->getAlignment());
 }
-void OMPClauseEnqueue::VisitOMPCopyinClause(const OMPCopyinClause *C) {
+
+void OMPClauseEnqueue::VisitOMPToClause(const OMPToClause *C) {
+  VisitOMPClauseList(C);
+}
+
+void OMPClauseEnqueue::VisitOMPFromClause(const OMPFromClause *C) {
   VisitOMPClauseList(C);
 }
+
+void OMPClauseEnqueue::VisitOMPUniformClause(const OMPUniformClause *C) {
+  VisitOMPClauseList(C);
+}
+
+void OMPClauseEnqueue::VisitOMPSafelenClause(const OMPSafelenClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPSimdlenClause(const OMPSimdlenClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPNumTeamsClause(const OMPNumTeamsClause *C) {}
+
 void
-OMPClauseEnqueue::VisitOMPCopyprivateClause(const OMPCopyprivateClause *C) {
+OMPClauseEnqueue::VisitOMPThreadLimitClause(const OMPThreadLimitClause *C) {}
+
+void OMPClauseEnqueue::VisitOMPLinearClause(const OMPLinearClause *C) {
   VisitOMPClauseList(C);
 }
-void OMPClauseEnqueue::VisitOMPFlushClause(const OMPFlushClause *C) {
+
+void OMPClauseEnqueue::VisitOMPAlignedClause(const OMPAlignedClause *C) {
   VisitOMPClauseList(C);
 }
 }
@@ -2300,8 +2375,8 @@
   Visit(E->getSyntacticForm());
 }
 
-void EnqueueVisitor::VisitOMPExecutableDirective(
-  const OMPExecutableDirective *D) {
+void
+EnqueueVisitor::VisitOMPExecutableDirective(const OMPExecutableDirective *D) {
   EnqueueChildren(D);
   for (ArrayRef<OMPClause *>::iterator I = D->clauses().begin(),
                                        E = D->clauses().end();
@@ -2313,37 +2388,64 @@
   VisitOMPExecutableDirective(D);
 }
 
+void EnqueueVisitor::VisitOMPForDirective(const OMPForDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void
+EnqueueVisitor::VisitOMPParallelForDirective(const OMPParallelForDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPParallelForSimdDirective(
+    const OMPParallelForSimdDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
 void EnqueueVisitor::VisitOMPSimdDirective(const OMPSimdDirective *D) {
   VisitOMPExecutableDirective(D);
 }
 
-void EnqueueVisitor::VisitOMPForDirective(const OMPForDirective *D) {
+void EnqueueVisitor::VisitOMPForSimdDirective(const OMPForSimdDirective *D) {
   VisitOMPExecutableDirective(D);
 }
 
-void EnqueueVisitor::VisitOMPSectionsDirective(const OMPSectionsDirective *D) {
+void EnqueueVisitor::VisitOMPDistributeSimdDirective(
+    const OMPDistributeSimdDirective *D) {
   VisitOMPExecutableDirective(D);
 }
 
-void EnqueueVisitor::VisitOMPSectionDirective(const OMPSectionDirective *D) {
+void EnqueueVisitor::VisitOMPDistributeParallelForDirective(
+    const OMPDistributeParallelForDirective *D) {
   VisitOMPExecutableDirective(D);
 }
 
-void EnqueueVisitor::VisitOMPSingleDirective(const OMPSingleDirective *D) {
+void EnqueueVisitor::VisitOMPDistributeParallelForSimdDirective(
+    const OMPDistributeParallelForSimdDirective *D) {
   VisitOMPExecutableDirective(D);
 }
 
-void EnqueueVisitor::VisitOMPMasterDirective(const OMPMasterDirective *D) {
+void EnqueueVisitor::VisitOMPTeamsDistributeParallelForDirective(
+    const OMPTeamsDistributeParallelForDirective *D) {
   VisitOMPExecutableDirective(D);
 }
 
-void EnqueueVisitor::VisitOMPCriticalDirective(const OMPCriticalDirective *D) {
+void EnqueueVisitor::VisitOMPTeamsDistributeParallelForSimdDirective(
+    const OMPTeamsDistributeParallelForSimdDirective *D) {
   VisitOMPExecutableDirective(D);
-  AddDeclarationNameInfo(D);
 }
 
-void
-EnqueueVisitor::VisitOMPParallelForDirective(const OMPParallelForDirective *D) {
+void EnqueueVisitor::VisitOMPTargetTeamsDistributeParallelForDirective(
+    const OMPTargetTeamsDistributeParallelForDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPTargetTeamsDistributeParallelForSimdDirective(
+    const OMPTargetTeamsDistributeParallelForSimdDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPSectionsDirective(const OMPSectionsDirective *D) {
   VisitOMPExecutableDirective(D);
 }
 
@@ -2352,6 +2454,14 @@
   VisitOMPExecutableDirective(D);
 }
 
+void EnqueueVisitor::VisitOMPSectionDirective(const OMPSectionDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPSingleDirective(const OMPSingleDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
 void EnqueueVisitor::VisitOMPTaskDirective(const OMPTaskDirective *D) {
   VisitOMPExecutableDirective(D);
 }
@@ -2361,6 +2471,14 @@
   VisitOMPExecutableDirective(D);
 }
 
+void EnqueueVisitor::VisitOMPMasterDirective(const OMPMasterDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPCriticalDirective(const OMPCriticalDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
 void EnqueueVisitor::VisitOMPBarrierDirective(const OMPBarrierDirective *D) {
   VisitOMPExecutableDirective(D);
 }
@@ -2369,10 +2487,80 @@
   VisitOMPExecutableDirective(D);
 }
 
+void
+EnqueueVisitor::VisitOMPTaskgroupDirective(const OMPTaskgroupDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPAtomicDirective(const OMPAtomicDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
 void EnqueueVisitor::VisitOMPFlushDirective(const OMPFlushDirective *D) {
   VisitOMPExecutableDirective(D);
 }
 
+void EnqueueVisitor::VisitOMPOrderedDirective(const OMPOrderedDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPTeamsDirective(const OMPTeamsDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void
+EnqueueVisitor::VisitOMPTargetTeamsDirective(const OMPTargetTeamsDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void
+EnqueueVisitor::VisitOMPDistributeDirective(const OMPDistributeDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPCancelDirective(const OMPCancelDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPCancellationPointDirective(
+    const OMPCancellationPointDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPTargetDirective(const OMPTargetDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void
+EnqueueVisitor::VisitOMPTargetDataDirective(const OMPTargetDataDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPTargetUpdateDirective(
+    const OMPTargetUpdateDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPTeamsDistributeDirective(
+    const OMPTeamsDistributeDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPTeamsDistributeSimdDirective(
+    const OMPTeamsDistributeSimdDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPTargetTeamsDistributeDirective(
+    const OMPTargetTeamsDistributeDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
+void EnqueueVisitor::VisitOMPTargetTeamsDistributeSimdDirective(
+    const OMPTargetTeamsDistributeSimdDirective *D) {
+  VisitOMPExecutableDirective(D);
+}
+
 void CursorVisitor::EnqueueWorkList(VisitorWorkList &WL, const Stmt *S) {
   EnqueueVisitor(WL, MakeCXCursor(S, StmtParent, TU,RegionOfInterest)).Visit(S);
 }
@@ -4047,34 +4235,83 @@
     return cxstring::createRef("ModuleImport");
   case CXCursor_OMPParallelDirective:
     return cxstring::createRef("OMPParallelDirective");
-  case CXCursor_OMPSimdDirective:
-    return cxstring::createRef("OMPSimdDirective");
   case CXCursor_OMPForDirective:
     return cxstring::createRef("OMPForDirective");
+  case CXCursor_OMPParallelForDirective:
+    return cxstring::createRef("OMPParallelForDirective");
+  case CXCursor_OMPSimdDirective:
+    return cxstring::createRef("OMPSimdDirective");
+  case CXCursor_OMPForSimdDirective:
+    return cxstring::createRef("OMPForSimdDirective");
+  case CXCursor_OMPParallelForSimdDirective:
+    return cxstring::createRef("OMPParallelForSimdDirective");
+  case CXCursor_OMPDistributeSimdDirective:
+    return cxstring::createRef("OMPDistributeSimdDirective");
+  case CXCursor_OMPDistributeParallelForDirective:
+    return cxstring::createRef("OMPDistributeParallelForDirective");
+  case CXCursor_OMPDistributeParallelForSimdDirective:
+    return cxstring::createRef("OMPDistributeParallelForSimdDirective");
+  case CXCursor_OMPTeamsDistributeParallelForDirective:
+    return cxstring::createRef("OMPTeamsDistributeParallelForDirective");
+  case CXCursor_OMPTeamsDistributeParallelForSimdDirective:
+    return cxstring::createRef("OMPTeamsDistributeParallelForSimdDirective");
+  case CXCursor_OMPTargetTeamsDistributeParallelForDirective:
+    return cxstring::createRef("OMPTargetTeamsDistributeParallelForDirective");
+  case CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective:
+    return cxstring::createRef(
+        "OMPTargetTeamsDistributeParallelForSimdDirective");
   case CXCursor_OMPSectionsDirective:
     return cxstring::createRef("OMPSectionsDirective");
+  case CXCursor_OMPParallelSectionsDirective:
+    return cxstring::createRef("OMPParallelSectionsDirective");
   case CXCursor_OMPSectionDirective:
     return cxstring::createRef("OMPSectionDirective");
   case CXCursor_OMPSingleDirective:
     return cxstring::createRef("OMPSingleDirective");
-  case CXCursor_OMPMasterDirective:
-    return cxstring::createRef("OMPMasterDirective");
-  case CXCursor_OMPCriticalDirective:
-    return cxstring::createRef("OMPCriticalDirective");
-  case CXCursor_OMPParallelForDirective:
-    return cxstring::createRef("OMPParallelForDirective");
-  case CXCursor_OMPParallelSectionsDirective:
-    return cxstring::createRef("OMPParallelSectionsDirective");
   case CXCursor_OMPTaskDirective:
     return cxstring::createRef("OMPTaskDirective");
   case CXCursor_OMPTaskyieldDirective:
     return cxstring::createRef("OMPTaskyieldDirective");
+  case CXCursor_OMPMasterDirective:
+    return cxstring::createRef("OMPMasterDirective");
+  case CXCursor_OMPCriticalDirective:
+    return cxstring::createRef("OMPCriticalDirective");
   case CXCursor_OMPBarrierDirective:
     return cxstring::createRef("OMPBarrierDirective");
   case CXCursor_OMPTaskwaitDirective:
     return cxstring::createRef("OMPTaskwaitDirective");
+  case CXCursor_OMPTaskgroupDirective:
+    return cxstring::createRef("OMPTaskgroupDirective");
+  case CXCursor_OMPAtomicDirective:
+    return cxstring::createRef("OMPAtomicDirective");
   case CXCursor_OMPFlushDirective:
     return cxstring::createRef("OMPFlushDirective");
+  case CXCursor_OMPOrderedDirective:
+    return cxstring::createRef("OMPOrderedDirective");
+  case CXCursor_OMPTeamsDirective:
+    return cxstring::createRef("OMPTeamsDirective");
+  case CXCursor_OMPTargetTeamsDirective:
+    return cxstring::createRef("OMPTargetTeamsDirective");
+  case CXCursor_OMPDistributeDirective:
+    return cxstring::createRef("OMPDisitributeDirective");
+  case CXCursor_OMPCancelDirective:
+    return cxstring::createRef("OMPCancelDirective");
+  case CXCursor_OMPCancellationPointDirective:
+    return cxstring::createRef("OMPCancellationPointDirective");
+  case CXCursor_OMPTargetDirective:
+    return cxstring::createRef("OMPTargetDirective");
+  case CXCursor_OMPTargetDataDirective:
+    return cxstring::createRef("OMPTargetDataDirective");
+  case CXCursor_OMPTargetUpdateDirective:
+    return cxstring::createRef("OMPTargetUpdateDirective");
+  case CXCursor_OMPTeamsDistributeDirective:
+    return cxstring::createRef("OMPTeamsDisitributeDirective");
+  case CXCursor_OMPTeamsDistributeSimdDirective:
+    return cxstring::createRef("OMPTeamsDisitributeSimdDirective");
+  case CXCursor_OMPTargetTeamsDistributeDirective:
+    return cxstring::createRef("OMPTargetTeamsDisitributeDirective");
+  case CXCursor_OMPTargetTeamsDistributeSimdDirective:
+    return cxstring::createRef("OMPTargetTeamsDisitributeSimdDirective");
   }
 
   llvm_unreachable("Unhandled CXCursorKind");
@@ -4811,6 +5048,9 @@
   case Decl::ClassScopeFunctionSpecialization:
   case Decl::Import:
   case Decl::OMPThreadPrivate:
+  case Decl::OMPDeclareReduction:
+  case Decl::OMPDeclareSimd:
+  case Decl::OMPDeclareTarget:
     return C;
 
   // Declaration kinds that don't make any sense here, but are
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/tools/libclang/CXCursor.cpp cfe-3.5.0.src.omp/tools/libclang/CXCursor.cpp
--- cfe-3.5.0.src/tools/libclang/CXCursor.cpp	2014-07-21 07:26:11.000000000 -0400
+++ cfe-3.5.0.src.omp/tools/libclang/CXCursor.cpp	2014-11-28 10:49:33.000000000 -0500
@@ -251,6 +251,7 @@
   case Stmt::ObjCDictionaryLiteralClass:
   case Stmt::ObjCBoxedExprClass:
   case Stmt::ObjCSubscriptRefExprClass:
+  case Stmt::CEANIndexExprClass:
     K = CXCursor_UnexposedExpr;
     break;
 
@@ -520,48 +521,120 @@
   case Stmt::OMPParallelDirectiveClass:
     K = CXCursor_OMPParallelDirective;
     break;
+  case Stmt::OMPForDirectiveClass:
+    K = CXCursor_OMPForDirective;
+    break;
+  case Stmt::OMPParallelForDirectiveClass:
+    K = CXCursor_OMPParallelForDirective;
+    break;
+  case Stmt::OMPParallelForSimdDirectiveClass:
+    K = CXCursor_OMPParallelForSimdDirective;
+    break;
   case Stmt::OMPSimdDirectiveClass:
     K = CXCursor_OMPSimdDirective;
     break;
-  case Stmt::OMPForDirectiveClass:
-    K = CXCursor_OMPForDirective;
+  case Stmt::OMPForSimdDirectiveClass:
+    K = CXCursor_OMPForSimdDirective;
     break;
-  case Stmt::OMPSectionsDirectiveClass:
-    K = CXCursor_OMPSectionsDirective;
+  case Stmt::OMPDistributeSimdDirectiveClass:
+    K = CXCursor_OMPDistributeSimdDirective;
     break;
-  case Stmt::OMPSectionDirectiveClass:
-    K = CXCursor_OMPSectionDirective;
+  case Stmt::OMPDistributeParallelForDirectiveClass:
+    K = CXCursor_OMPDistributeParallelForDirective;
     break;
-  case Stmt::OMPSingleDirectiveClass:
-    K = CXCursor_OMPSingleDirective;
+  case Stmt::OMPDistributeParallelForSimdDirectiveClass:
+    K = CXCursor_OMPDistributeParallelForSimdDirective;
     break;
-  case Stmt::OMPMasterDirectiveClass:
-    K = CXCursor_OMPMasterDirective;
+  case Stmt::OMPTeamsDistributeParallelForDirectiveClass:
+    K = CXCursor_OMPTeamsDistributeParallelForDirective;
     break;
-  case Stmt::OMPCriticalDirectiveClass:
-    K = CXCursor_OMPCriticalDirective;
+  case Stmt::OMPTeamsDistributeParallelForSimdDirectiveClass:
+    K = CXCursor_OMPTeamsDistributeParallelForSimdDirective;
     break;
-  case Stmt::OMPParallelForDirectiveClass:
-    K = CXCursor_OMPParallelForDirective;
+  case Stmt::OMPTargetTeamsDistributeParallelForDirectiveClass:
+    K = CXCursor_OMPTargetTeamsDistributeParallelForDirective;
+    break;
+  case Stmt::OMPTargetTeamsDistributeParallelForSimdDirectiveClass:
+    K = CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective;
+    break;
+  case Stmt::OMPSectionsDirectiveClass:
+    K = CXCursor_OMPSectionsDirective;
     break;
   case Stmt::OMPParallelSectionsDirectiveClass:
     K = CXCursor_OMPParallelSectionsDirective;
     break;
+  case Stmt::OMPSectionDirectiveClass:
+    K = CXCursor_OMPSectionDirective;
+    break;
+  case Stmt::OMPSingleDirectiveClass:
+    K = CXCursor_OMPSingleDirective;
+    break;
   case Stmt::OMPTaskDirectiveClass:
     K = CXCursor_OMPTaskDirective;
     break;
   case Stmt::OMPTaskyieldDirectiveClass:
     K = CXCursor_OMPTaskyieldDirective;
     break;
+  case Stmt::OMPMasterDirectiveClass:
+    K = CXCursor_OMPMasterDirective;
+    break;
+  case Stmt::OMPCriticalDirectiveClass:
+    K = CXCursor_OMPCriticalDirective;
+    break;
   case Stmt::OMPBarrierDirectiveClass:
     K = CXCursor_OMPBarrierDirective;
     break;
   case Stmt::OMPTaskwaitDirectiveClass:
     K = CXCursor_OMPTaskwaitDirective;
     break;
+  case Stmt::OMPTaskgroupDirectiveClass:
+    K = CXCursor_OMPTaskgroupDirective;
+    break;
+  case Stmt::OMPAtomicDirectiveClass:
+    K = CXCursor_OMPAtomicDirective;
+    break;
   case Stmt::OMPFlushDirectiveClass:
     K = CXCursor_OMPFlushDirective;
     break;
+  case Stmt::OMPOrderedDirectiveClass:
+    K = CXCursor_OMPOrderedDirective;
+    break;
+  case Stmt::OMPTeamsDirectiveClass:
+    K = CXCursor_OMPTeamsDirective;
+    break;
+  case Stmt::OMPTargetTeamsDirectiveClass:
+    K = CXCursor_OMPTargetTeamsDirective;
+    break;
+  case Stmt::OMPDistributeDirectiveClass:
+    K = CXCursor_OMPDistributeDirective;
+    break;
+  case Stmt::OMPTargetDirectiveClass:
+    K = CXCursor_OMPTargetDirective;
+    break;
+  case Stmt::OMPTargetDataDirectiveClass:
+    K = CXCursor_OMPTargetDataDirective;
+    break;
+  case Stmt::OMPTargetUpdateDirectiveClass:
+    K = CXCursor_OMPTargetUpdateDirective;
+    break;
+  case Stmt::OMPCancelDirectiveClass:
+    K = CXCursor_OMPCancelDirective;
+    break;
+  case Stmt::OMPCancellationPointDirectiveClass:
+    K = CXCursor_OMPCancellationPointDirective;
+    break;
+  case Stmt::OMPTeamsDistributeDirectiveClass:
+    K = CXCursor_OMPTeamsDistributeDirective;
+    break;
+  case Stmt::OMPTeamsDistributeSimdDirectiveClass:
+    K = CXCursor_OMPTeamsDistributeSimdDirective;
+    break;
+  case Stmt::OMPTargetTeamsDistributeDirectiveClass:
+    K = CXCursor_OMPTargetTeamsDistributeDirective;
+    break;
+  case Stmt::OMPTargetTeamsDistributeSimdDirectiveClass:
+    K = CXCursor_OMPTargetTeamsDistributeSimdDirective;
+    break;
   }
 
   CXCursor C = { K, 0, { Parent, S, TU } };
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/tools/scan-build/scan-build.1 cfe-3.5.0.src.omp/tools/scan-build/scan-build.1
--- cfe-3.5.0.src/tools/scan-build/scan-build.1	2014-02-11 16:37:27.000000000 -0500
+++ cfe-3.5.0.src.omp/tools/scan-build/scan-build.1	2014-11-28 10:49:33.000000000 -0500
@@ -1,6 +1,6 @@
 .\" This file is distributed under the University of Illinois Open Source
 .\" License. See LICENSE.TXT for details.
-.\" $Id$
+.\" $Id$
 .Dd May 25, 2012
 .Dt SCAN-BUILD 1
 .Os "clang" "3.5"
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/tools/scan-build/scan-build.bat cfe-3.5.0.src.omp/tools/scan-build/scan-build.bat
--- cfe-3.5.0.src/tools/scan-build/scan-build.bat	2013-05-01 20:52:46.000000000 -0400
+++ cfe-3.5.0.src.omp/tools/scan-build/scan-build.bat	2014-11-28 10:49:33.000000000 -0500
@@ -1 +1 @@
-perl -S scan-build %*
+perl -S scan-build %*
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/www/cxx_dr_status.html cfe-3.5.0.src.omp/www/cxx_dr_status.html
--- cfe-3.5.0.src/www/cxx_dr_status.html	2014-06-03 17:58:55.000000000 -0400
+++ cfe-3.5.0.src.omp/www/cxx_dr_status.html	2014-11-28 10:49:33.000000000 -0500
@@ -28,7 +28,7 @@
 <!--*************************************************************************-->
 <h1>C++ Defect Report Support in Clang</h1>
 <!--*************************************************************************-->
-<p>Last updated: $Date$</p>
+<p>Last updated: $Date$</p>
 
 <h2 id="cxxdr">C++ defect report implementation status</h2>
 
diff --exclude=.git --exclude=.gitattributes -uNr cfe-3.5.0.src/www/cxx_status.html cfe-3.5.0.src.omp/www/cxx_status.html
--- cfe-3.5.0.src/www/cxx_status.html	2014-06-22 12:00:05.000000000 -0400
+++ cfe-3.5.0.src.omp/www/cxx_status.html	2014-11-28 10:49:33.000000000 -0500
@@ -25,7 +25,7 @@
 <!--*************************************************************************-->
 <h1>C++ Support in Clang</h1>
 <!--*************************************************************************-->
-<p>Last updated: $Date$</p>
+<p>Last updated: $Date$</p>
 
 <p>Clang fully implements all published ISO C++ standards including <a
 href="#cxx11">C++11</a>, as well as the upcoming standard provisionally named <a
@@ -580,6 +580,31 @@
     </tr>
 </table>
 
+<h2 id="ts">Technical specifications and standing documents</h2>
+
+<p>ISO C++ also publishes a number of documents describing additional language
+and library features that are not part of standard C++. The following table
+describes which language features have been implemented in Clang and in which
+Clang version they became available:</p>
+
+<table width="689" border="1" cellspacing="0">
+ <tr>
+    <th>Document</th>
+    <th>Latest draft</th>
+    <th>Available in Clang?</th>
+ </tr>
+    <tr>
+      <td>SD-6: SG10 feature test recommendations</td>
+      <td><a href="http://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations">SD-6</a></td>
+      <td class="svn" align="center">SVN (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3745">N3745</a>)</td>
+    </tr>
+    <tr>
+      <td>[DRAFT TS] Array extensions (arrays of runtime bound)</td>
+      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3820.html">N3820</a></td>
+      <td class="none" align="center">No</td>
+    </tr>
+</table>
+
 </div>
 </body>
 </html>
