
--- koffice-1.6.1/configure.in.in	2006-11-17 10:13:49.000000000 -0500
+++ koffice-1.6.1-new/configure.in.in	2006-12-10 13:44:21.000000000 -0500
@@ -11,6 +11,7 @@
 
 KDE_INIT_DOXYGEN([The KOffice API Reference], [Version $VERSION])
 
+KDE_ENABLE_HIDDEN_VISIBILITY
 # Check for GraphicsMagick...
 
 have_graphicsmagick=no
--- koffice-1.6.1/core	1969-12-31 19:00:00.000000000 -0500
+++ koffice-1.6.1-new/core	2006-12-10 13:44:21.000000000 -0500
@@ -0,0 +1,71 @@
+/*
+ * This file is part of Krita
+ *
+ *  Copyright (c) 2006 Cyrille Berger <cberger@cberger.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _KIS_PERSPECTVE_MATH_H_
+#define _KIS_PERSPECTVE_MATH_H_
+
+#include "kis_point.h"
+#include <koffice_export.h>
+
+class QRect;
+
+class KRITACORE_EXPORT KisPerspectiveMath {
+    private:
+        KisPerspectiveMath() { }
+    public:
+        static double* computeMatrixTransfo( const KisPoint& topLeft1, const KisPoint& topRight1, const KisPoint& bottomLeft1, const KisPoint& bottomRight1 , const KisPoint& topLeft2, const KisPoint& topRight2, const KisPoint& bottomLeft2, const KisPoint& bottomRight2);
+      static double* computeMatrixTransfoToPerspective(const KisPoint& topLeft, const KisPoint& topRight, const KisPoint& bottomLeft, const KisPoint& bottomRight, const QRect& r);
+      static double* computeMatrixTransfoFromPerspective(const QRect& r, const KisPoint& topLeft, const KisPoint& topRight, const KisPoint& bottomLeft, const KisPoint& bottomRight);
+      struct LineEquation {
+            // y = a*x + b
+      double a, b;
+    };
+    /// TODO: get ride of this in 2.0
+    inline static KisPoint matProd(const double (&m)[3][3], const KisPoint& p)
+    {
+        double s = ( p.x() * m[2][0] + p.y() * m[2][1] + 1.0);
+        s = (s == 0.) ? 1. : 1./s;
+        return KisPoint( (p.x() * m[0][0] + p.y() * m[0][1] + m[0][2] ) * s,
+                         (p.x() * m[1][0] + p.y() * m[1][1] + m[1][2] ) * s );
+    }
+    static inline LineEquation computeLineEquation(const KisPoint* p1, const KisPoint* p2)
+    {
+      LineEquation eq;
+      double x1 = p1->x(); double x2 = p2->x();
+      if( fabs(x1 - x2) < 0.000001 )
+      {
+        x1 += 0.0001; // Introduce a small perturbation
+      }
+      eq.a = (p2->y() - p1->y()) / (double)( x2 - x1 );
+      eq.b = -eq.a * x1 + p1->y();
+      return eq;
+    }
+    static inline KisPoint computeIntersection(const LineEquation& d1, const LineEquation& d2)
+    {
+      double a1 = d1.a; double a2 = d2.a;
+      if( fabs(a1 - a2) < 0.000001 )
+      {
+        a1 += 0.0001; // Introduce a small perturbation
+      }
+      double x = (d1.b - d2.b) / (a2 - a1);
+      return KisPoint(x, a2 * x + d2.b);
+    }
+};
+
+#endif
--- koffice-1.6.1/filters/kchart/libimageexport/imageexport.h	2006-11-17 10:09:26.000000000 -0500
+++ koffice-1.6.1-new/filters/kchart/libimageexport/imageexport.h	2006-12-10 13:44:21.000000000 -0500
@@ -21,9 +21,10 @@
 #define __IMAGEEXPORT_H__
 
 #include <KoFilter.h>
+#include <koffice_export.h>
 
 class QPixmap;
-class ImageExport : public KoFilter
+class KOFFICEFILTER_EXPORT ImageExport : public KoFilter
 {
     Q_OBJECT
 
--- koffice-1.6.1/filters/kpresenter/libimageexport/imageexport.h	2006-11-17 10:08:48.000000000 -0500
+++ koffice-1.6.1-new/filters/kpresenter/libimageexport/imageexport.h	2006-12-10 13:44:21.000000000 -0500
@@ -21,9 +21,10 @@
 #define __IMAGEEXPORT_H__
 
 #include <KoFilter.h>
+#include <koffice_export.h>
 
 class QPixmap;
-class ImageExport : public KoFilter
+class KOFFICEFILTER_EXPORT ImageExport : public KoFilter
 {
     Q_OBJECT
 
--- koffice-1.6.1/karbon/Makefile.am	2006-11-17 10:13:49.000000000 -0500
+++ koffice-1.6.1-new/karbon/Makefile.am	2006-12-10 13:44:21.000000000 -0500
@@ -30,7 +30,8 @@
 	$(LIBART_LIBS) \
 	$(LIBFONTCONFIG_LIBS) \
 	$(LIBMAGICK_LIBS) \
-	$(LIBFREETYPE_LIBS)
+	$(LIBFREETYPE_LIBS) \
+	$(LIB_X11)
 
 libkarbonpart_la_SOURCES = karbon_factory_init.cc
 libkarbonpart_la_LDFLAGS = $(KDE_PLUGIN) $(LIBFREETYPE_RPATH)
--- koffice-1.6.1/karbon/core/vgradient.h	2006-11-17 10:13:35.000000000 -0500
+++ koffice-1.6.1-new/karbon/core/vgradient.h	2006-12-10 13:44:21.000000000 -0500
@@ -74,7 +74,7 @@
 		repeat  = 2
 	};
 
-	class VColorStopList : public QPtrList<VColorStop>
+	class KARBONBASE_EXPORT VColorStopList : public QPtrList<VColorStop>
 	{
 		protected:
 			virtual int compareItems( QPtrCollection::Item item1, QPtrCollection::Item item2 );
--- koffice-1.6.1/karbon/visitors/vselectobjects.h	2006-11-17 10:13:44.000000000 -0500
+++ koffice-1.6.1-new/karbon/visitors/vselectobjects.h	2006-12-10 13:44:21.000000000 -0500
@@ -29,13 +29,15 @@
 #include "vimage.h"
 #include "vvisitor.h"
 
+#include <koffice_export.h>
+
 /**
  * This visitor visits a selection and selects objects that are contained
  * in a paramater selection rectangle. For composites it makes a more accurate test, if the
  * selection rectangle intersects with any part of the composite, it is selected.
  * Also this visitor can be used to deselect objects.
  */
-class VSelectObjects : public VVisitor
+class KARBONBASE_EXPORT VSelectObjects : public VVisitor
 {
 public:
 	VSelectObjects( VObjectList& selection, bool select = true )
--- koffice-1.6.1/kchart/kchart_factory.h	2006-11-17 10:11:47.000000000 -0500
+++ koffice-1.6.1-new/kchart/kchart_factory.h	2006-12-10 13:44:21.000000000 -0500
@@ -9,7 +9,7 @@
 
 
 #include <KoFactory.h>
-
+#include <koffice_export.h>
 
 class KInstance;
 class KAboutData;
@@ -17,7 +17,7 @@
 namespace KChart
 {
 
-class KChartFactory : public KoFactory
+class KCHART_EXPORT KChartFactory : public KoFactory
 {
     Q_OBJECT
 public:
--- koffice-1.6.1/kchart/kdchart/KDChartVectorTable.h	2006-11-17 10:11:38.000000000 -0500
+++ koffice-1.6.1-new/kchart/kdchart/KDChartVectorTable.h	2006-12-10 13:46:35.000000000 -0500
@@ -36,6 +36,8 @@
 #include <KDChartDataIntern.h>
 #include <KDChartTableBase.h>
 
+#include <koffice_export.h>
+
 class KDCHART_EXPORT KDChartVectorTablePrivate : public QShared
 {
 public:
@@ -182,31 +184,39 @@
     }
 
 public slots:
-    Iterator begin() {
+
+    /*
+       we have to add KDCHART_EXPORT to each of these slots
+       because -fvisibility-inlines-hidden will hide them; since
+       they're public, this would be considered by some to be
+       undesireable.  ;)
+    */
+
+    Iterator begin() KDCHART_EXPORT {
         return sh->matrix.begin();
     }
 
-    ConstIterator begin() const {
+    ConstIterator begin() const KDCHART_EXPORT {
         return sh->matrix.begin();
     }
 
-    Iterator end() {
+    Iterator end() KDCHART_EXPORT {
         return sh->matrix.end();
     }
 
-    ConstIterator end() const {
+    ConstIterator end() const KDCHART_EXPORT {
         return sh->matrix.end();
     }
 
-    bool isEmpty() const {
+    bool isEmpty() const KDCHART_EXPORT {
         return ( sh->col_count == 0 && sh->row_count == 0 );
     }
 
-    uint cols() const {
+    uint cols() const KDCHART_EXPORT {
         return sh->col_count;
     }
 
-    uint rows() const {
+    uint rows() const KDCHART_EXPORT {
         return sh->row_count;
     }
     // WARNING: The KDChartData class is an internal class now,
@@ -221,7 +231,7 @@
 */
     virtual bool cellCoord( uint _row, uint _col,
                             QVariant& _value,
-                            int coordinate=1 ) const
+                            int coordinate=1 ) const KDCHART_EXPORT
     {
         if( _row >= sh->row_count || _col >= sh->col_count )
             return false;
@@ -230,7 +240,7 @@
     }
 
     virtual bool cellProp( uint _row, uint _col,
-                           int& _prop ) const
+                           int& _prop ) const KDCHART_EXPORT 
     {
         if( _row >= sh->row_count || _col >= sh->col_count )
             return false;
@@ -240,29 +250,29 @@
 
     virtual void setCell( uint _row, uint _col,
                           const QVariant& _value1,
-                          const QVariant& _value2=QVariant() ) {
+                          const QVariant& _value2=QVariant() ) KDCHART_EXPORT {
         detach();
         const KDChartData element( _value1, _value2 );
         sh->setCell( _row, _col, element );
     }
 
     virtual void setProp( uint _row, uint _col,
-                          int _propSet=0 )
+                          int _propSet=0 ) KDCHART_EXPORT
     {
         sh->cell( _row, _col ).setPropertySet( _propSet );
     }
     
-    void clearCell( uint _row, uint _col ) {
+    void clearCell( uint _row, uint _col ) KDCHART_EXPORT {
         detach();
         sh->clearCell( _row, _col );
     }
 
-    void clearAllCells() {
+    void clearAllCells() KDCHART_EXPORT {
         detach();
         sh->clearAllCells();
     }
 
-    void expand( uint _rows, uint _cols ) {
+    void expand( uint _rows, uint _cols ) KDCHART_EXPORT {
         detach();
         sh->expand( _rows, _cols );
         // adjust the usedRows / usedCols, if they had been set before
@@ -272,7 +282,7 @@
             setUsedRows( QMIN( _usedRows, _rows ) );
     }
 
-    void setUsedRows( uint _rows ) {
+    void setUsedRows( uint _rows ) KDCHART_EXPORT {
         Q_ASSERT( _rows <= rows() );
         if( _usedRows < _rows )
             setSorted( false );
@@ -280,11 +290,13 @@
         _useUsedRows = true;
     }
 
-    uint usedRows() const {
+    uint usedRows() const KDCHART_EXPORT
+    {
         return _useUsedRows ? _usedRows : rows();
     }
 
-    void setUsedCols( uint _cols ) {
+    void setUsedCols( uint _cols ) KDCHART_EXPORT
+    {
         Q_ASSERT( _cols <= cols() );
         if( _usedCols < _cols )
             setSorted( false );
@@ -292,7 +304,8 @@
         _useUsedCols = true;
     }
 
-    uint usedCols() const {
+    uint usedCols() const KDCHART_EXPORT
+    {
         return _useUsedCols ? _usedCols : cols();
     }
 
--- koffice-1.6.1/kexi/Makefile.global	2006-11-17 10:03:56.000000000 -0500
+++ koffice-1.6.1-new/kexi/Makefile.global	2006-12-10 13:44:22.000000000 -0500
@@ -9,7 +9,7 @@
 KDE_CXXFLAGS = \
 $(USE_EXCEPTIONS) $(KEXI_OPTIONS)
 
-KDE_CXXFLAGS += -include $(top_srcdir)/kexi/kexi_global.h
+KDE_CXXFLAGS += $(KOFFICECORE_INCLUDES) -include $(top_srcdir)/kexi/kexi_global.h
 
 # temporary:
 ##KDE_CXXFLAGS += -DKEXI_NO_AUTOFIELD_WIDGET
--- koffice-1.6.1/kexi/formeditor/Makefile.am	2006-11-17 10:03:55.000000000 -0500
+++ koffice-1.6.1-new/kexi/formeditor/Makefile.am	2006-12-10 13:44:22.000000000 -0500
@@ -1,5 +1,7 @@
 include $(top_srcdir)/kexi/Makefile.global
 
+KDE_CXXFLAGS += 
+
 INCLUDES = -I$(top_srcdir)/kexi/widget -I$(top_srcdir)/kexi/widget/utils \
   -I$(top_srcdir)/kexi/widget/tableview \
   -I$(top_srcdir)/kexi/core \
--- koffice-1.6.1/kexi/kexi_export.h	2006-11-17 10:03:56.000000000 -0500
+++ koffice-1.6.1-new/kexi/kexi_export.h	2006-12-10 13:44:22.000000000 -0500
@@ -22,6 +22,25 @@
 
 #include <kexidb/kexidb_export.h>
 
+#ifdef __KDE_HAVE_GCC_VISIBILITY
+#define MAKE_KEXICORE_LIB
+#define MAKE_KEXIMAIN_LIB
+#define MAKE_KEXITABLEFILTERS_LIB
+#define MAKE_KEXIDATATABLE_LIB
+#define MAKE_KEXIEXTWIDGETS_LIB
+#define MAKE_KFORMEDITOR_LIB
+#define MAKE_KEXIPRJWIZARD_LIB
+#define MAKE_KEXIFILTER_LIB
+#define MAKE_KEXIWIDGETS_LIB
+#define MAKE_KEXIUUID_LIB
+#define MAKE_KEXIRELATIONSVIEW_LIB
+#define MAKE_KEXIGUIUTILS_LIB
+#define MAKE_KROSS_MAIN_LIB
+#define MAKE_KEXIFORMUTILS_LIB
+#define MAKE_KEXIREPORTUTILS_LIB
+#define MAKE_KOPROPERTY_LIB
+#endif
+
 #ifdef MAKE_KEXICORE_LIB
 # define KEXICORE_EXPORT KDE_EXPORT
 #elif defined(KDE_MAKE_LIB)
--- koffice-1.6.1/kexi/kexidb/drivers/configure.in.bot	2006-11-17 10:03:28.000000000 -0500
+++ koffice-1.6.1-new/kexi/kexidb/drivers/configure.in.bot	2006-12-10 13:44:22.000000000 -0500
@@ -15,7 +15,7 @@
 fi
 
 if test -z "$PG_INCDIR" -o -z "$PG_LIBDIR" -o \
-        -z "$PQXX_INCDIR" -o -z "$PQXX_LIBDIR"; then
+        -z "$PQXX_CFLAGS" -o -z "$PQXX_LIBS"; then
 
   echo "----------------------------------------------------------------------"
 
@@ -50,28 +50,28 @@
   fi
 
 # LIBPQXX messages
-  if test -z "$PQXX_INCDIR"; then
+  if test -z "$PQXX_CFLAGS"; then
     echo "  + The PostgreSQL C++ API (libpqxx) headers were not found."
   fi
 
-  if test -z "$PQXX_LIBDIR"; then
+  if test -z "$PQXX_LIBS"; then
     echo "  + The PostgreSQL C++ API (libpqxx) shared libraries were not found."
   fi
 
-  if test -z "$PQXX_INCDIR" -a -z "$PQXX_LIBDIR" ; then
+  if test -z "$PQXX_INCLUDES" -a -z "$PQXX_LIBS" ; then
       pqxx_parts_missing="HEADER or the libpqxx LIBRARY"
-  elif test -z "$PQXX_INCDIR" ; then
+  elif test -z "$PQXX_INCLUDES" ; then
       pqxx_parts_missing="HEADER"
-  elif test -z "$PQXX_LIBDIR" ; then
+  elif test -z "$PQXX_LIBS" ; then
       pqxx_parts_missing="LIBRARY"
   fi
 
-  if test -z "$PQXX_INCDIR" -o -z "$PQXX_LIBDIR" ; then
+  if test -z "$PQXX_INCLUDES" -o -z "$PQXX_LIBS" ; then
   cat <<EOS
     Could not find the libpqxx $pqxx_parts_missing files.
     These are required by Kexi's PostgreSQL drivers.
 
-    Note: Kexi requires the SHARED libpqxx.so library files.
+    Note: Kexi requires the SHARED libpqxx library files.
           If you build pqxx library on your own, don't forget to use the
           --enable-shared option when you run libpqxx's configure script.
           This is necessary to compile the SHARED .so library, and
--- koffice-1.6.1/kexi/kexidb/drivers/configure.in.in	2006-11-17 10:03:28.000000000 -0500
+++ koffice-1.6.1-new/kexi/kexidb/drivers/configure.in.in	2006-12-10 13:44:22.000000000 -0500
@@ -206,39 +206,11 @@
 ], ac_pqxx_libdir=
 )
 
-
-dnl ========================================
-dnl   libpqxx headers
-dnl ========================================
-if test "$compile_pgsql_plugin" = "yes"; then
-  AC_MSG_CHECKING([for PostgreSQL C++ includes])
-  pqxx_incdirs="$ac_pqxx_incdir /usr/local/include /usr/include"
-  AC_FIND_FILE(pqxx/pqxx, $pqxx_incdirs, pqxx_incdir)
-  if test -r $pqxx_incdir/pqxx/pqxx; then
-    PQXX_INCDIR=$pqxx_incdir
-    AC_MSG_RESULT([$PQXX_INCDIR])
-    AC_SUBST(PQXX_INCDIR)
-  else
-    compile_pgsql_plugin="no"
-    AC_MSG_RESULT([not found])
-  fi
-fi
-
-dnl ========================================
-dnl   libpqxx libraries
-dnl ========================================
 if test "$compile_pgsql_plugin" = "yes"; then
-  AC_MSG_CHECKING([for PostgreSQL C++ libraries])
-  pqxx_libdirs="$ac_pqxx_libdir /usr/local/lib$kdelibsuff /usr/lib$kdelibsuff"
-  AC_FIND_FILE(libpqxx.so, $pqxx_libdirs, pqxx_libdir)
-  if test -r $pqxx_libdir/libpqxx.so; then
-    PQXX_LIBDIR=$pqxx_libdir
-    AC_MSG_RESULT([$PQXX_LIBDIR])
-    AC_SUBST(PQXX_LIBDIR)
-  else
-    compile_pgsql_plugin="no"
-    AC_MSG_RESULT([not found])
-  fi
+	ac_save_PKG_CONFIG_PATH="$PKG_CONFIG_PATH"
+	PKG_CONFIG_PATH="$ac_pqxx_libdir/pkgconfig:$PKG_CONFIG_PATH"
+	PKG_CHECK_MODULES([PQXX], [libpqxx >= 2.4.0], [], [compile_pgsql_plugin=no])
+	PKG_CONFIG_PATH="$ac_save_PKG_CONFIG_PATH"
 fi
 
 AM_CONDITIONAL(compile_pgsql_plugin, test "$compile_pgsql_plugin" = "yes")
--- koffice-1.6.1/kexi/kexidb/drivers/mySQL/Makefile.am	2006-11-17 10:03:28.000000000 -0500
+++ koffice-1.6.1-new/kexi/kexidb/drivers/mySQL/Makefile.am	2006-12-10 13:44:22.000000000 -0500
@@ -20,7 +20,8 @@
   $(LIB_QT) \
   $(MYSQL_LIBS) \
   -lmysqlclient \
-  ../../libkexidb.la
+  ../../libkexidb.la \
+  ../../parser/libkexidbparser.la
 
 kexidb_mysqldriver_la_LDFLAGS = $(all_libraries) -module $(KDE_PLUGIN) $(VER_INFO) -no-undefined
 
--- koffice-1.6.1/kexi/kexidb/drivers/mySQL/mysqlpreparedstatement.h	2006-11-17 10:03:28.000000000 -0500
+++ koffice-1.6.1-new/kexi/kexidb/drivers/mySQL/mysqlpreparedstatement.h	2006-12-10 13:44:22.000000000 -0500
@@ -30,7 +30,7 @@
 {
 
 /*! Implementation of prepared statements for MySQL driver. */
-class MySqlPreparedStatement : public PreparedStatement, public MySqlConnectionInternal
+class KEXI_DB_EXPORT MySqlPreparedStatement : public PreparedStatement, public MySqlConnectionInternal
 {
 	public:
 		MySqlPreparedStatement(StatementType type, ConnectionInternal& conn, FieldList& fields);
--- koffice-1.6.1/kexi/kexidb/drivers/pqxx/Makefile.am	2006-11-17 10:03:25.000000000 -0500
+++ koffice-1.6.1-new/kexi/kexidb/drivers/pqxx/Makefile.am	2006-12-10 13:44:22.000000000 -0500
@@ -2,17 +2,17 @@
 
 kde_module_LTLIBRARIES = kexidb_pqxxsqldriver.la
 
-INCLUDES = -I$(srcdir)/../../.. $(all_includes) -I$(PG_INCDIR) -I$(PQXX_INCDIR)
+INCLUDES = -I$(srcdir)/../../.. $(all_includes) -I$(PG_INCDIR) $(PQXX_CFLAGS)
 
 kexidb_pqxxsqldriver_la_METASOURCES = AUTO
 
 kexidb_pqxxsqldriver_la_SOURCES = pqxxdriver.cpp pqxxcursor.cpp pqxxconnection.cpp \
 	pqxxkeywords.cpp pqxxconnection_p.cpp pqxxpreparedstatement.cpp
 
-kexidb_pqxxsqldriver_la_LIBADD = $(LIB_KPARTS) $(LIB_QT) -lpqxx ../../libkexidb.la
+kexidb_pqxxsqldriver_la_LIBADD = $(LIB_KPARTS) $(LIB_QT) -lpqxx.2 ../../libkexidb.la ../../parser/libkexidbparser.la
 
 kexidb_pqxxsqldriver_la_LDFLAGS = $(all_libraries) -module $(KDE_PLUGIN) \
-	-L$(PQXX_LIBDIR) -L$(PG_LIBDIR) $(VER_INFO) -no-undefined
+	$(PQXX_LIBS) -L$(PG_LIBDIR) $(VER_INFO) -no-undefined
 
 kde_services_DATA = kexidb_pqxxsqldriver.desktop
 
--- koffice-1.6.1/kexi/kexidb/kexidb_export.h	2006-11-17 10:03:28.000000000 -0500
+++ koffice-1.6.1-new/kexi/kexidb/kexidb_export.h	2006-12-10 13:44:22.000000000 -0500
@@ -26,6 +26,12 @@
 /* KDE_EXPORT will be defined multiple times without this on kdelibs 3.3 (tested on 3.3.1) */
 #include <kdemacros.h>
 
+#ifdef __KDE_HAVE_GCC_VISIBILITY
+#define MAKE_KEXI_DB_LIB
+#define MAKE_KEXIMIGR_LIB
+#define MAKE_KEXI_SERVER_SUPPORT
+#endif
+
 /* workaround for KDElibs < 3.2 on !win32 */
 #ifndef KDE_EXPORT
 # define KDE_EXPORT
@@ -51,6 +57,10 @@
 /* -- compile-time settings -- */
 #if defined(Q_WS_WIN) || defined(KEXI_OPTIONS)
 /* defined in a .pro file or 'KEXI_OPTIONS' env. variable */
+#elif defined(MAKE_KEXI_SERVER_SUPPORT)
+# define KEXI_SERVER_SUPPORT KDE_EXPORT
+#elif defined(KDE_MAKE_LIB)
+# define KEXI_SERVER_SUPPORT KDE_IMPORT
 #else
 # define KEXI_SERVER_SUPPORT
 #endif
--- koffice-1.6.1/kexi/kexidb/parser/Makefile.am	2006-11-17 10:03:22.000000000 -0500
+++ koffice-1.6.1-new/kexi/kexidb/parser/Makefile.am	2006-12-10 13:44:22.000000000 -0500
@@ -3,7 +3,7 @@
 lib_LTLIBRARIES = libkexidbparser.la
 libkexidbparser_la_SOURCES = sqlscanner.cpp sqlparser.cpp parser.cpp parser_p.cpp
 libkexidbparser_la_LIBADD = $(LIB_KPARTS) $(LIB_KDEUI) ../libkexidb.la
-libkexidbparser_la_LDFLAGS = $(all_libraries) $(KDE_RPATH) $(VER_INFO)
+libkexidbparser_la_LDFLAGS = $(all_libraries) $(KDE_RPATH) $(VER_INFO) -no-undefined
 
 noinst_HEADERS = parser_p.h
 
@@ -24,7 +24,7 @@
 	cat sqlparser.tab.h >> sqlparser.h; \
 	echo '#endif' >> sqlparser.h; \
 	cat sqlparser.tab.c > sqlparser.cpp; \
-	echo "const char * const tname(int offset) { return yytname[offset]; }" >> sqlparser.cpp; \
+	echo "KDE_EXPORT const char * const tname(int offset) { return yytname[offset]; }" >> sqlparser.cpp; \
 	./extract_tokens.sh > tokens.cpp; \
 	rm -f sqlparser.tab.h sqlparser.tab.c
 
--- koffice-1.6.1/kexi/kexidb/parser/sqlparser.cpp	2006-11-17 10:03:22.000000000 -0500
+++ koffice-1.6.1-new/kexi/kexidb/parser/sqlparser.cpp	2006-12-10 13:44:22.000000000 -0500
@@ -814,6 +814,8 @@
 #include "parser_p.h"
 #include "sqltypes.h"
 
+#include <koffice_export.h>
+
 int yylex();
 
 //	using namespace std;
@@ -3469,4 +3471,4 @@
 
 
 
-const char * const tname(int offset) { return yytname[offset]; }
+KDE_EXPORT const char * const tname(int offset) { return yytname[offset]; }
--- koffice-1.6.1/kexi/kexiutils/kexiutils_export.h	2006-11-17 18:00:33.000000000 -0500
+++ koffice-1.6.1-new/kexi/kexiutils/kexiutils_export.h	2006-12-10 13:44:22.000000000 -0500
@@ -22,6 +22,12 @@
 
 #include <kdemacros.h>
 
+#include <koffice_export.h>
+
+#ifdef __KDE_HAVE_GCC_VISIBILITY
+#define MAKE_KEXIUTILS_LIB
+#endif
+
 #ifdef MAKE_KEXIUTILS_LIB
 # define KEXIUTILS_EXPORT KDE_EXPORT
 #elif defined(KDE_MAKE_LIB)
--- koffice-1.6.1/kexi/main/configure.in.in	2006-11-17 10:02:31.000000000 -0500
+++ koffice-1.6.1-new/kexi/main/configure.in.in	2006-12-10 13:44:22.000000000 -0500
@@ -20,7 +20,7 @@
 AC_FIND_FILE(knewstuff/downloaddialog.h, $kde_incdirs, knewstuff_incdir)
 ac_knewstuff_includes="$knewstuff_incdir"
 
-AC_FIND_FILE(libknewstuff.so, $kde_libdirs, knewstuff_libdir)
+AC_FIND_FILE(libknewstuff.dylib, $kde_libdirs, knewstuff_libdir)
 ac_knewstuff_libraries="$knewstuff_libdir"
 
 if test "$ac_knewstuff_includes" = NO || test "$ac_knewstuff_libraries" = NO; then
--- koffice-1.6.1/kexi/main/startup/Makefile.am	2006-11-17 10:02:30.000000000 -0500
+++ koffice-1.6.1-new/kexi/main/startup/Makefile.am	2006-12-10 13:44:22.000000000 -0500
@@ -1,5 +1,7 @@
 include $(top_srcdir)/kexi/Makefile.global
 
+KDE_CXXFLAGS += 
+
 noinst_LTLIBRARIES = libkeximainstartup.la
 
 libkeximainstartup_la_SOURCES = KexiConnSelectorBase.ui KexiProjectSelectorBase.ui \
--- koffice-1.6.1/kexi/main.cpp	2006-11-17 10:03:56.000000000 -0500
+++ koffice-1.6.1-new/kexi/main.cpp	2006-12-10 13:44:22.000000000 -0500
@@ -25,7 +25,7 @@
 #include <qapplication.h>
 #include <main/keximainwindowimpl.h>
 
-extern "C" int kdemain(int argc, char *argv[])
+extern "C" KDE_EXPORT int kdemain(int argc, char *argv[])
 {
 	int result = KexiMainWindowImpl::create(argc, argv);
 	if (!qApp)
--- koffice-1.6.1/kexi/widget/relations/Makefile.am	2006-11-17 10:02:26.000000000 -0500
+++ koffice-1.6.1-new/kexi/widget/relations/Makefile.am	2006-12-10 13:44:22.000000000 -0500
@@ -1,12 +1,14 @@
 include $(top_srcdir)/kexi/Makefile.global
 
+KDE_CXXFLAGS += 
+
 lib_LTLIBRARIES = libkexirelationsview.la
 
 libkexirelationsview_la_SOURCES = kexirelationview.cpp kexirelationviewconnection.cpp \
 				kexirelationviewtable.cpp kexirelationwidget.cpp
 
 libkexirelationsview_la_LDFLAGS = $(all_libraries) $(VER_INFO) -Wnounresolved
-libkexirelationsview_la_LIBADD = ../../core/libkexicore.la
+libkexirelationsview_la_LIBADD = ../../core/libkexicore.la ../libkexiextendedwidgets.la
 
 libkexirelationsview_la_METASOURCES = AUTO
 
--- koffice-1.6.1/kexi/widget/utils/Makefile.am	2006-11-17 10:02:27.000000000 -0500
+++ koffice-1.6.1-new/kexi/widget/utils/Makefile.am	2006-12-10 13:44:22.000000000 -0500
@@ -1,5 +1,7 @@
 include $(top_srcdir)/kexi/Makefile.global
 
+KDE_CXXFLAGS += 
+
 lib_LTLIBRARIES = libkexiguiutils.la
 libkexiguiutils_la_SOURCES = kexisharedactionclient.cpp kexirecordnavigator.cpp \
 	kexigradientwidget.cpp kexirecordmarker.cpp kexidisplayutils.cpp \
--- koffice-1.6.1/kivio/kiviopart/kivio_command.h	2006-11-17 10:12:37.000000000 -0500
+++ koffice-1.6.1-new/kivio/kiviopart/kivio_command.h	2006-12-10 13:44:22.000000000 -0500
@@ -226,7 +226,7 @@
 };
 
 
-class KivioChangeStencilHAlignmentCommand : public KNamedCommand
+class KIVIO_EXPORT KivioChangeStencilHAlignmentCommand : public KNamedCommand
 {
   public:
     KivioChangeStencilHAlignmentCommand(const QString& _name, KivioPage* _page, KivioStencil* _stencil,
@@ -244,7 +244,7 @@
     QString m_textBoxName;
 };
 
-class KivioChangeStencilVAlignmentCommand : public KNamedCommand
+class KIVIO_EXPORT KivioChangeStencilVAlignmentCommand : public KNamedCommand
 {
   public:
     KivioChangeStencilVAlignmentCommand(const QString& _name, KivioPage* _page, KivioStencil* _stencil,
@@ -263,7 +263,7 @@
 };
 
 
-class KivioChangeStencilFontCommand : public KNamedCommand
+class KIVIO_EXPORT KivioChangeStencilFontCommand : public KNamedCommand
 {
   public:
     KivioChangeStencilFontCommand(const QString& _name, KivioPage* _page, KivioStencil* _stencil,
@@ -282,7 +282,7 @@
     QString m_textBoxName;
 };
 
-class KivioChangeStencilColorCommand : public KNamedCommand
+class KIVIO_EXPORT KivioChangeStencilColorCommand : public KNamedCommand
 {
   public:
     enum ColorType { CT_TEXTCOLOR, CT_FGCOLOR, CT_BGCOLOR };
@@ -410,7 +410,7 @@
     bool m_bValue;
 };
 
-class KivioAddConnectorTargetCommand : public KNamedCommand
+class KIVIO_EXPORT KivioAddConnectorTargetCommand : public KNamedCommand
 {
   public:
     KivioAddConnectorTargetCommand(const QString& name, KivioPage* page,
@@ -425,7 +425,7 @@
     KoPoint m_targetPoint;
 };
 
-class KivioCustomDragCommand : public KNamedCommand
+class KIVIO_EXPORT KivioCustomDragCommand : public KNamedCommand
 {
   public:
     KivioCustomDragCommand(const QString& name, KivioPage* page, KivioStencil* stencil,
--- koffice-1.6.1/kivio/kiviopart/kivio_map.h	2006-11-17 10:12:37.000000000 -0500
+++ koffice-1.6.1-new/kivio/kiviopart/kivio_map.h	2006-12-10 13:44:22.000000000 -0500
@@ -36,11 +36,13 @@
 #include <qptrlist.h>
 #include <qstringlist.h>
 
+#include <koffice_export.h>
+
 /*
  * A map is a simple container for all pages. Usually a complete map is saved in one file.
  */
 
-class KivioMap : public QObject
+class KIVIO_EXPORT KivioMap : public QObject
 {
   public:
     /**
--- koffice-1.6.1/kivio/kiviopart/kiviosdk/kivio_layer.h	2006-11-17 10:12:35.000000000 -0500
+++ koffice-1.6.1-new/kivio/kiviopart/kiviosdk/kivio_layer.h	2006-12-10 13:44:22.000000000 -0500
@@ -36,12 +36,14 @@
 
 #include "kivio_stencil.h"
 
+#include <koffice_export.h>
+
 #define FLOW_LAYER_VISIBLE 0x0001
 #define FLOW_LAYER_CONNECTABLE 0x0002
 #define FLOW_LAYER_NOT_EDITABLE 0x0004
 #define FLOW_LAYER_NOT_PRINTABLE 0x0008
 
-class KivioLayer
+class KIVIO_EXPORT KivioLayer
 {
 protected:
     friend class KivioGroupStencil;
--- koffice-1.6.1/kivio/kiviopart/kiviosdk/kivio_screen_painter.h	2006-11-17 10:12:35.000000000 -0500
+++ koffice-1.6.1-new/kivio/kiviopart/kiviosdk/kivio_screen_painter.h	2006-12-10 13:44:22.000000000 -0500
@@ -25,10 +25,12 @@
 #include <qpainter.h>
 #include <qpixmap.h>
 
+#include <koffice_export.h>
+
 class KivioPoint;
 
 
-class KivioScreenPainter : public KivioPainter
+class KIVIO_EXPORT KivioScreenPainter : public KivioPainter
 {
 protected:
     QPainter *m_pPainter;
--- koffice-1.6.1/kivio/kiviopart/ui/kiviostencilsetwidget.ui.orig	2006-11-17 10:12:37.000000000 -0500
+++ koffice-1.6.1-new/kivio/kiviopart/ui/kiviostencilsetwidget.ui.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,168 +0,0 @@
-<!DOCTYPE UI><UI version="3.3" stdsetdef="1">
-<class>KivioStencilSetWidget</class>
-<comment>This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-</comment>
-<author>(C) 2004-2005 Peter Simonsson</author>
-<widget class="QWidget">
-    <property name="name">
-        <cstring>KivioStencilSetWidget</cstring>
-    </property>
-    <property name="geometry">
-        <rect>
-            <x>0</x>
-            <y>0</y>
-            <width>600</width>
-            <height>480</height>
-        </rect>
-    </property>
-    <property name="caption">
-        <string>Stencil Set</string>
-    </property>
-    <grid>
-        <property name="name">
-            <cstring>unnamed</cstring>
-        </property>
-        <property name="margin">
-            <number>0</number>
-        </property>
-        <widget class="QSplitter" row="0" column="0">
-            <property name="name">
-                <cstring>splitter1</cstring>
-            </property>
-            <property name="orientation">
-                <enum>Horizontal</enum>
-            </property>
-            <widget class="KListView">
-                <column>
-                    <property name="text">
-                        <string>Stencil Set</string>
-                    </property>
-                    <property name="clickable">
-                        <bool>true</bool>
-                    </property>
-                    <property name="resizable">
-                        <bool>true</bool>
-                    </property>
-                </column>
-                <property name="name">
-                    <cstring>m_stencilSetLView</cstring>
-                </property>
-                <property name="rootIsDecorated">
-                    <bool>true</bool>
-                </property>
-                <property name="resizeMode">
-                    <enum>AllColumns</enum>
-                </property>
-                <property name="fullWidth">
-                    <bool>true</bool>
-                </property>
-                <property name="itemsMovable">
-                    <bool>false</bool>
-                </property>
-                <property name="dropVisualizer">
-                    <bool>false</bool>
-                </property>
-                <property name="shadeSortColumn">
-                    <bool>false</bool>
-                </property>
-            </widget>
-            <widget class="QGroupBox">
-                <property name="name">
-                    <cstring>m_stencilsetGBox</cstring>
-                </property>
-                <property name="title">
-                    <string>No Selection</string>
-                </property>
-                <grid>
-                    <property name="name">
-                        <cstring>unnamed</cstring>
-                    </property>
-                    <widget class="QSplitter" row="0" column="0">
-                        <property name="name">
-                            <cstring>m_stencilSetSplitter</cstring>
-                        </property>
-                        <property name="orientation">
-                            <enum>Vertical</enum>
-                        </property>
-                        <widget class="QIconView">
-                            <property name="name">
-                                <cstring>m_stencilIView</cstring>
-                            </property>
-                            <property name="acceptDrops">
-                                <bool>false</bool>
-                            </property>
-                            <property name="hScrollBarMode">
-                                <enum>AlwaysOff</enum>
-                            </property>
-                            <property name="selectionMode">
-                                <enum>NoSelection</enum>
-                            </property>
-                            <property name="gridX">
-                                <number>64</number>
-                            </property>
-                            <property name="gridY">
-                                <number>64</number>
-                            </property>
-                            <property name="resizeMode">
-                                <enum>Adjust</enum>
-                            </property>
-                            <property name="itemsMovable">
-                                <bool>false</bool>
-                            </property>
-                            <property name="whatsThis" stdset="0">
-                                <string>This is a preview of the stencils contained in the set</string>
-                            </property>
-                        </widget>
-                        <widget class="QTextBrowser">
-                            <property name="name">
-                                <cstring>m_descriptionBrowser</cstring>
-                            </property>
-                            <property name="sizePolicy">
-                                <sizepolicy>
-                                    <hsizetype>7</hsizetype>
-                                    <vsizetype>4</vsizetype>
-                                    <horstretch>0</horstretch>
-                                    <verstretch>0</verstretch>
-                                </sizepolicy>
-                            </property>
-                        </widget>
-                    </widget>
-                    <widget class="QPushButton" row="1" column="0">
-                        <property name="name">
-                            <cstring>m_addToDocBtn</cstring>
-                        </property>
-                        <property name="enabled">
-                            <bool>false</bool>
-                        </property>
-                        <property name="text">
-                            <string>&amp;Add to Document</string>
-                        </property>
-                    </widget>
-                </grid>
-            </widget>
-        </widget>
-    </grid>
-</widget>
-<customwidgets>
-</customwidgets>
-<includes>
-    <include location="global" impldecl="in implementation">kdialog.h</include>
-</includes>
-<layoutdefaults spacing="6" margin="11"/>
-<layoutfunctions spacing="KDialog::spacingHint" margin="KDialog::marginHint"/>
-<includehints>
-    <includehint>klistview.h</includehint>
-</includehints>
-</UI>
--- koffice-1.6.1/kpresenter/KPrCanvas.h	2006-11-17 10:13:01.000000000 -0500
+++ koffice-1.6.1-new/kpresenter/KPrCanvas.h	2006-12-10 13:44:22.000000000 -0500
@@ -41,6 +41,8 @@
 #include <KoTextFormat.h>
 #include "presstep.h"
 
+#include <koffice_export.h>
+
 class KURL;
 class KoTextFormatInterface;
 class KPrView;
@@ -79,7 +81,7 @@
  *
  * It manages the graphical representation of all the objects.
  */
-class KPrCanvas : public QWidget
+class KPRESENTER_EXPORT KPrCanvas : public QWidget
 {
     Q_OBJECT
 
--- koffice-1.6.1/kpresenter/KPrFactory.h	2006-11-17 10:13:01.000000000 -0500
+++ koffice-1.6.1-new/kpresenter/KPrFactory.h	2006-12-10 13:44:22.000000000 -0500
@@ -22,9 +22,11 @@
 #define KPRESENTER_FACTORY_H
 
 #include <KoFactory.h>
+#include <koffice_export.h>
+
 class KAboutData;
 
-class KPrFactory : public KoFactory
+class KPRESENTER_EXPORT KPrFactory : public KoFactory
 {
     Q_OBJECT
 public:
--- koffice-1.6.1/kpresenter/KPrView.h	2006-11-17 10:13:01.000000000 -0500
+++ koffice-1.6.1-new/kpresenter/KPrView.h	2006-12-10 13:44:22.000000000 -0500
@@ -35,6 +35,8 @@
 #include <KoPen.h>
 #include <KoRuler.h>
 
+#include <koffice_export.h>
+
 class QPopupMenu;
 class QSplitter;
 class QLabel;
@@ -114,7 +116,7 @@
 };
 
 
-class KPrView : public KoView
+class KPRESENTER_EXPORT KPrView : public KoView
 {
     friend class PageBase;
     Q_OBJECT
--- koffice-1.6.1/krita/colorspaces/ycbcr_u16/kis_ycbcr_u16_colorspace.h	2006-11-17 10:11:25.000000000 -0500
+++ koffice-1.6.1-new/krita/colorspaces/ycbcr_u16/kis_ycbcr_u16_colorspace.h	2006-12-10 13:44:22.000000000 -0500
@@ -21,6 +21,7 @@
 #define KIS_YCBCR_U16_COLORSPACE_H
 
 #include <kis_u16_base_colorspace.h>
+#include <koffice_export.h>
 
 #include <klocale.h>
 
@@ -28,7 +29,7 @@
 #define LUMA_GREEN 0.587
 #define LUMA_BLUE 0.114
 
-class KisYCbCrU16ColorSpace : public KisU16BaseColorSpace
+class KRITATOOL_EXPORT KisYCbCrU16ColorSpace : public KisU16BaseColorSpace
 {
     public:
         KisYCbCrU16ColorSpace(KisColorSpaceFactoryRegistry* parent, KisProfile* p);
--- koffice-1.6.1/krita/colorspaces/ycbcr_u8/kis_ycbcr_u8_colorspace.h	2006-11-17 10:11:26.000000000 -0500
+++ koffice-1.6.1-new/krita/colorspaces/ycbcr_u8/kis_ycbcr_u8_colorspace.h	2006-12-10 13:44:22.000000000 -0500
@@ -21,6 +21,7 @@
 #define KIS_YCBCR_U8_COLORSPACE_H
 
 #include <kis_u8_base_colorspace.h>
+#include <koffice_export.h>
 
 #include <klocale.h>
 
@@ -28,7 +29,7 @@
 #define LUMA_GREEN 0.587
 #define LUMA_BLUE 0.114
 
-class KisYCbCrU8ColorSpace : public KisU8BaseColorSpace
+class KRITATOOL_EXPORT KisYCbCrU8ColorSpace : public KisU8BaseColorSpace
 {
     public:
         KisYCbCrU8ColorSpace(KisColorSpaceFactoryRegistry* parent, KisProfile* p);
--- koffice-1.6.1/krita/core/kis_alpha_mask.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_alpha_mask.h	2006-12-10 13:44:22.000000000 -0500
@@ -26,12 +26,14 @@
 #include "kis_global.h"
 #include "kis_types.h"
 
+#include <koffice_export.h>
+
 /**
  * KisAlphaMask is intended to create alpha values from a QImage for use
  * in brush creation. It is not a generic alpha mask that can be used with
  * KisPaintDevices: use a KisSelection for that.
  */
-class KisAlphaMask : public KShared {
+class KRITACORE_EXPORT KisAlphaMask : public KShared {
     
  public:
     /**
--- koffice-1.6.1/krita/core/kis_autobrush_resource.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_autobrush_resource.h	2006-12-10 13:44:22.000000000 -0500
@@ -21,7 +21,9 @@
 
 #include "kis_brush.h"
 
-class KisAutobrushShape {
+#include <koffice_export.h>
+
+class KRITACORE_EXPORT KisAutobrushShape {
     public:
         KisAutobrushShape(Q_INT32 w, Q_INT32 h, double fh, double fv) : m_w(w), m_h(h), m_fh(fh), m_fv(fv)
         { };
@@ -32,7 +34,7 @@
         double m_fh, m_fv;
 };
 
-class KisAutobrushCircleShape : public KisAutobrushShape {
+class KRITACORE_EXPORT KisAutobrushCircleShape : public KisAutobrushShape {
     public:
         KisAutobrushCircleShape(Q_INT32 w, Q_INT32 h, double fh, double fv);
     public:
@@ -48,7 +50,7 @@
         double m_xfadecoef, m_yfadecoef;
 };
 
-class KisAutobrushRectShape : public KisAutobrushShape {
+class KRITACORE_EXPORT KisAutobrushRectShape : public KisAutobrushShape {
     public:
         KisAutobrushRectShape(Q_INT32 w, Q_INT32 h, double fh, double fv);
     protected:
@@ -57,7 +59,7 @@
         double m_xcentre, m_ycentre, m_c;
 };
 
-class KisAutobrushResource : public KisBrush
+class KRITACORE_EXPORT KisAutobrushResource : public KisBrush
 {
     public:
         KisAutobrushResource(QImage& img) : KisBrush("")
--- koffice-1.6.1/krita/core/kis_autogradient_resource.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_autogradient_resource.h	2006-12-10 13:44:22.000000000 -0500
@@ -22,7 +22,9 @@
 
 #include "kis_gradient.h"
 
-class KisAutogradientResource : public KisGradient
+#include <koffice_export.h>
+
+class KRITACORE_EXPORT KisAutogradientResource : public KisGradient
 {
 
 public:
--- koffice-1.6.1/krita/core/kis_background.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_background.h	2006-12-10 13:44:22.000000000 -0500
@@ -21,8 +21,9 @@
 #include <qimage.h>
 
 #include <ksharedptr.h>
+#include <koffice_export.h>
 
-class KisBackground : public KShared {
+class KRITACORE_EXPORT KisBackground : public KShared {
 
 public:
     KisBackground();
--- koffice-1.6.1/krita/core/kis_command.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_command.h	2006-12-10 13:44:22.000000000 -0500
@@ -22,10 +22,11 @@
 
 #include <qstring.h>
 #include <kcommand.h>
+#include <koffice_export.h>
 
 class KisUndoAdapter;
 
-class KisCommand : public KCommand {
+class KRITACORE_EXPORT KisCommand : public KCommand {
     typedef KCommand super;
 
 public:
--- koffice-1.6.1/krita/core/kis_convolution_painter.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_convolution_painter.h	2006-12-10 13:44:22.000000000 -0500
@@ -37,7 +37,7 @@
 class KisKernel;
 typedef KSharedPtr<KisKernel> KisKernelSP;
 
-class KisKernel : public KShared 
+class KRITACORE_EXPORT KisKernel : public KShared 
 {
 
 public:
--- koffice-1.6.1/krita/core/kis_exif_value.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_exif_value.h	2006-12-10 13:44:22.000000000 -0500
@@ -25,6 +25,8 @@
 #include <qcstring.h>
 #include <qstring.h>
 
+#include <koffice_export.h>
+
 typedef QMemArray<Q_UINT8> UByteArray;
 
 struct KisExifRational {
@@ -37,7 +39,7 @@
     Q_INT32 denominator;
 };
 
-class ExifValue {
+class KRITACORE_EXPORT ExifValue {
     typedef union {
         Q_UINT8 m_byte;
         Q_UINT16 m_short;
--- koffice-1.6.1/krita/core/kis_filter_config_widget.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_filter_config_widget.h	2006-12-10 13:44:22.000000000 -0500
@@ -20,13 +20,14 @@
 
 #include <qwidget.h>
 #include "kis_filter_configuration.h"
+#include <koffice_export.h>
 
 /**
  * Empty base class. Filters can build their own configuration widgets that
  * inherit this class. The configuration widget can emit sigPleaseUpdatePreview
  * when it wants the preview in the filter dialog to be updated. 
  */
-class KisFilterConfigWidget : public QWidget {
+class KRITACORE_EXPORT KisFilterConfigWidget : public QWidget {
 
     Q_OBJECT
 
--- koffice-1.6.1/krita/core/kis_filter_strategy.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_filter_strategy.h	2006-12-10 13:44:22.000000000 -0500
@@ -25,8 +25,9 @@
 #include "kis_types.h"
 #include "kis_generic_registry.h"
 #include "kis_id.h"
+#include <koffice_export.h>
 
-class KisFilterStrategy
+class KRITACORE_EXPORT KisFilterStrategy
 {
     public:
         KisFilterStrategy(KisID id) : m_id(id) {}
@@ -44,7 +45,7 @@
         KisID m_id;
 };
 
-class KisHermiteFilterStrategy : public KisFilterStrategy
+class KRITACORE_EXPORT KisHermiteFilterStrategy : public KisFilterStrategy
 {
     public:
         KisHermiteFilterStrategy() : KisFilterStrategy(KisID("Hermite", i18n("Hermite")))
@@ -66,7 +67,7 @@
         virtual double valueAt(double t) const;
 };
 
-class KisBoxFilterStrategy : public KisFilterStrategy
+class KRITACORE_EXPORT KisBoxFilterStrategy : public KisFilterStrategy
 {
     public:
         KisBoxFilterStrategy() : KisFilterStrategy(KisID("Box", i18n("Box")))
@@ -78,7 +79,7 @@
         virtual bool boxSpecial() { return true;};
 };
 
-class KisTriangleFilterStrategy : public KisFilterStrategy
+class KRITACORE_EXPORT KisTriangleFilterStrategy : public KisFilterStrategy
 {
     public:
         KisTriangleFilterStrategy() : KisFilterStrategy(KisID("Triangle", i18n("Triangle aka (bi)linear")))
@@ -89,7 +90,7 @@
         virtual double valueAt(double t) const;
 };
 
-class KisBellFilterStrategy : public KisFilterStrategy
+class KRITACORE_EXPORT KisBellFilterStrategy : public KisFilterStrategy
 {
     public:
         KisBellFilterStrategy() : KisFilterStrategy(KisID("Bell", i18n("Bell")))
@@ -99,7 +100,7 @@
         virtual double valueAt(double t) const;
 };
 
-class KisBSplineFilterStrategy : public KisFilterStrategy
+class KRITACORE_EXPORT KisBSplineFilterStrategy : public KisFilterStrategy
 {
     public:
         KisBSplineFilterStrategy() : KisFilterStrategy(KisID("BSpline", i18n("BSpline")))
@@ -109,7 +110,7 @@
         virtual double valueAt(double t) const;
 };
 
-class KisLanczos3FilterStrategy : public KisFilterStrategy
+class KRITACORE_EXPORT KisLanczos3FilterStrategy : public KisFilterStrategy
 {
     public:
         KisLanczos3FilterStrategy() : KisFilterStrategy(KisID("Lanczos3", i18n("Lanczos3")))
@@ -121,7 +122,7 @@
         double sinc(double x) const; 
 };
 
-class KisMitchellFilterStrategy : public KisFilterStrategy
+class KRITACORE_EXPORT KisMitchellFilterStrategy : public KisFilterStrategy
 {
     public:
         KisMitchellFilterStrategy() : KisFilterStrategy(KisID("Mitchell", i18n("Mitchell")))
@@ -131,7 +132,7 @@
         virtual double valueAt(double t) const;
 };
 
-class KisFilterStrategyRegistry : public KisGenericRegistry<KisFilterStrategy *>
+class KRITACORE_EXPORT KisFilterStrategyRegistry : public KisGenericRegistry<KisFilterStrategy *>
 {
 public:
     virtual ~KisFilterStrategyRegistry();
--- koffice-1.6.1/krita/core/kis_gradient.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_gradient.h	2006-12-10 13:44:23.000000000 -0500
@@ -32,6 +32,8 @@
 #include "kis_resource.h"
 #include "kis_global.h"
 
+#include <koffice_export.h>
+
 class QImage;
 
 enum {
@@ -62,7 +64,7 @@
         double m_alpha;
 };
 
-class KisGradientSegment {
+class KRITACORE_EXPORT KisGradientSegment {
     public:
         KisGradientSegment(int interpolationType, int colorInterpolationType, double startOffset, double middleOffset, double endOffset, const Color& startColor, const Color& endColor);
 
@@ -229,7 +231,7 @@
         Color m_endColor;
 };
 
-class KisGradient : public KisResource {
+class KRITACORE_EXPORT KisGradient : public KisResource {
     typedef KisResource super;
     Q_OBJECT
 
--- koffice-1.6.1/krita/core/kis_group_layer.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_group_layer.h	2006-12-10 13:44:23.000000000 -0500
@@ -25,6 +25,8 @@
 
 #include "kis_paint_layer.h"
 
+#include <koffice_export.h>
+
 class KisMergeVisitor;
 
 /**
@@ -33,7 +35,7 @@
  * KisLayer::nextSibling() moves towards higher indices, from the top to the bottom layer; prevSibling() the reverse.
  * (Implementation detail: internally, the indices are reversed, for speed.)
  **/
-class KisGroupLayer : public KisLayer {
+class KRITACORE_EXPORT KisGroupLayer : public KisLayer {
     typedef KisLayer super;
 
     Q_OBJECT
--- koffice-1.6.1/krita/core/kis_histogram.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_histogram.h	2006-12-10 13:44:23.000000000 -0500
@@ -22,6 +22,7 @@
 #include "kis_types.h"
 #include "kis_colorspace.h"
 #include "kis_histogram_producer.h"
+#include <koffice_export.h>
 
 enum enumHistogramType {
     LINEAR,
@@ -40,7 +41,7 @@
  * The calculations are done in the range 0 - 1, instead of the native range that a pixel
  * might have, so it's not always as precise as it could be. But you can't have it all...
  */
-class KisHistogram : public KShared {
+class KRITACORE_EXPORT KisHistogram : public KShared {
 
 public:
     /**
--- koffice-1.6.1/krita/core/kis_imagepipe_brush.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_imagepipe_brush.h	2006-12-10 13:44:23.000000000 -0500
@@ -31,6 +31,8 @@
 #include "kis_brush.h"
 #include "kis_global.h"
 
+#include <koffice_export.h>
+
 class QCString;
 class QImage;
 class QPoint;
@@ -98,7 +100,7 @@
 };
 
 
-class KisImagePipeBrush : public KisBrush {
+class KRITACORE_EXPORT KisImagePipeBrush : public KisBrush {
     typedef KisBrush super;
     Q_OBJECT
 
--- koffice-1.6.1/krita/core/kis_iterator.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_iterator.h	2006-12-10 13:44:23.000000000 -0500
@@ -21,6 +21,7 @@
 
 #include <qglobal.h>
 #include <ksharedptr.h>
+#include <koffice_export.h>
 
 class KisTiledRectIterator;
 typedef KSharedPtr<KisTiledRectIterator> KisTiledRectIteratorSP;
@@ -37,7 +38,7 @@
  * The KisRectIterator iterators over a rectangular area in the most efficient order. That is,
  * there is no guarantee that the iterator will work scanline by scanline.
  */
-class KisRectIterator
+class KRITACORE_EXPORT KisRectIterator
 {
 
 
@@ -81,7 +82,7 @@
     KisTiledRectIteratorSP m_iter;
 };
 
-class KisHLineIterator
+class KRITACORE_EXPORT KisHLineIterator
 {
 
 public:
@@ -132,7 +133,7 @@
     KisTiledHLineIteratorSP m_iter;
 };
 
-class KisVLineIterator
+class KRITACORE_EXPORT KisVLineIterator
 {
 
 public:
--- koffice-1.6.1/krita/core/kis_meta_registry.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_meta_registry.h	2006-12-10 13:44:23.000000000 -0500
@@ -18,6 +18,8 @@
 #ifndef _KIS_META_REGISTRY_
 #define _KIS_META_REGISTRY_
 
+#include <koffice_export.h>
+
 class KisColorSpaceFactoryRegistry;
 class KisMathToolboxFactoryRegistry;
 
@@ -26,7 +28,7 @@
  *
  * XXX: Maybe this should go into the SDK
  */
-class KisMetaRegistry {
+class KRITACORE_EXPORT KisMetaRegistry {
 
 public:
 
--- koffice-1.6.1/krita/core/kis_nameserver.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_nameserver.h	2006-12-10 13:44:23.000000000 -0500
@@ -20,8 +20,9 @@
 
 #include <qstring.h>
 #include "kis_global.h"
+#include <koffice_export.h>
 
-class KisNameServer {
+class KRITACORE_EXPORT KisNameServer {
 public:
     KisNameServer(const QString& prefix, Q_INT32 seed = 1);
     ~KisNameServer();
--- koffice-1.6.1/krita/core/kis_paint_layer.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_paint_layer.h	2006-12-10 13:44:23.000000000 -0500
@@ -22,10 +22,12 @@
 #include "kis_layer.h"
 #include "kis_paint_device.h"
 #include "kis_colorspace.h"
+#include <koffice_export.h>
+
 /**
  * This layer is of a type that can be painted on.
  */
-class KisPaintLayer : public KisLayer, public KisLayerSupportsIndirectPainting {
+class KRITACORE_EXPORT KisPaintLayer : public KisLayer, public KisLayerSupportsIndirectPainting {
     typedef KisLayer super;
 
     Q_OBJECT
--- koffice-1.6.1/krita/core/kis_paintop.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_paintop.h	2006-12-10 13:44:23.000000000 -0500
@@ -108,7 +108,7 @@
  * If there is an optionWidget, the derived paintop itself must support settings,
  * and it's up to the factory to do that.
  */
-class KisPaintOpFactory  : public KShared
+class KRITACORE_EXPORT KisPaintOpFactory  : public KShared
 {
 
 public:
--- koffice-1.6.1/krita/core/kis_palette.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_palette.h	2006-12-10 13:44:23.000000000 -0500
@@ -31,6 +31,8 @@
 #include "kis_gradient.h"
 #include "kis_alpha_mask.h"
 
+#include <koffice_export.h>
+
 class QPoint;
 class QPixmap;
 class KisPaintDevice;
@@ -47,7 +49,7 @@
  * Open Gimp, Photoshop or RIFF palette files. This is a straight port
  * from the Gimp.
  */
-class KisPalette : public KisResource {
+class KRITACORE_EXPORT KisPalette : public KisResource {
     typedef KisResource super;
 
     Q_OBJECT
--- koffice-1.6.1/krita/core/kis_pattern.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_pattern.h	2006-12-10 13:44:23.000000000 -0500
@@ -26,13 +26,14 @@
 #include "kis_debug_areas.h"
 #include "kis_resource.h"
 #include "kis_types.h"
+#include <koffice_export.h>
 
 class QPoint;
 class QImage;
 class KisColorSpace;
 class KisPaintDevice;
 
-class KisPattern : public KisResource {
+class KRITACORE_EXPORT KisPattern : public KisResource {
     typedef KisResource super;
     Q_OBJECT
 
--- koffice-1.6.1/krita/core/kis_perspective_grid.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_perspective_grid.h	2006-12-10 13:44:23.000000000 -0500
@@ -26,6 +26,7 @@
 #include <kis_perspective_math.h>
 #include <kis_point.h>
 #include <ksharedptr.h>
+#include <koffice_export.h>
 
 class KisPerspectiveGridNode : public KisPoint, public KShared {
     public:
@@ -34,7 +35,7 @@
 };
 typedef KSharedPtr<KisPerspectiveGridNode> KisPerspectiveGridNodeSP;
 
-class KisSubPerspectiveGrid {
+class KRITACORE_EXPORT KisSubPerspectiveGrid {
     public:
         KisSubPerspectiveGrid(KisPerspectiveGridNodeSP topLeft, KisPerspectiveGridNodeSP topRight, KisPerspectiveGridNodeSP bottomRight, KisPerspectiveGridNodeSP bottomLeft);
         
@@ -83,7 +84,7 @@
         static int s_lastIndex;
 };
 
-class KisPerspectiveGrid {
+class KRITACORE_EXPORT KisPerspectiveGrid {
     public:
         KisPerspectiveGrid();
         ~KisPerspectiveGrid();
--- koffice-1.6.1/krita/core/kis_perspective_math.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_perspective_math.h	2006-12-10 13:44:23.000000000 -0500
@@ -21,10 +21,11 @@
 #define _KIS_PERSPECTVE_MATH_H_
 
 #include "kis_point.h"
+#include <koffice_export.h>
 
 class QRect;
 
-class KisPerspectiveMath {
+class KRITACORE_EXPORT KisPerspectiveMath {
     private:
         KisPerspectiveMath() { }
     public:
--- koffice-1.6.1/krita/core/kis_perspectivetransform_worker.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_perspectivetransform_worker.h	2006-12-10 13:44:23.000000000 -0500
@@ -22,11 +22,12 @@
 
 #include "kis_types.h"
 #include "kis_progress_subject.h"
+#include <koffice_export.h>
 
 class KisPoint;
 class KisProgressDisplayInterface;
 
-class KisPerspectiveTransformWorker : public KisProgressSubject
+class KRITACORE_EXPORT KisPerspectiveTransformWorker : public KisProgressSubject
 {
     public:
         KisPerspectiveTransformWorker(KisPaintDeviceSP dev, const KisPoint& topLeft, const KisPoint& topRight, const KisPoint& bottomLeft, const KisPoint& bottomRight, KisProgressDisplayInterface *progress);
--- koffice-1.6.1/krita/core/kis_random_accessor.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_random_accessor.h	2006-12-10 13:44:23.000000000 -0500
@@ -21,6 +21,7 @@
 #define KIS_RANDOM_ACCESSOR_H
 
 #include <ksharedptr.h>
+#include <koffice_export.h>
 
 #include <kis_global.h>
 
@@ -29,7 +30,7 @@
 
 class KisTiledDataManager;
 
-class KisRandomAccessor{
+class KRITACORE_EXPORT KisRandomAccessor{
     public:
         KisRandomAccessor(KisTiledDataManager *ktm, Q_INT32 x, Q_INT32 y, Q_INT32 offsetx, Q_INT32 offsety, bool writable);
         KisRandomAccessor(const KisRandomAccessor& rhs);
--- koffice-1.6.1/krita/core/kis_random_sub_accessor.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_random_sub_accessor.h	2006-12-10 13:44:23.000000000 -0500
@@ -23,8 +23,9 @@
 #include "kis_point.h"
 #include "kis_random_accessor.h"
 #include "kis_types.h"
+#include <koffice_export.h>
 
-class KisRandomSubAccessorPixel{
+class KRITACORE_EXPORT KisRandomSubAccessorPixel{
     public:
         KisRandomSubAccessorPixel(KisPaintDeviceSP device);
         ~KisRandomSubAccessorPixel();
--- koffice-1.6.1/krita/core/kis_resource.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_resource.h	2006-12-10 13:44:23.000000000 -0500
@@ -21,7 +21,7 @@
 #include <qimage.h>
 #include <qobject.h>
 #include <qstring.h>
-
+#include <koffice_export.h>
 
 /**
  * The KisResource class provides a representation of Krita image resources.  This
@@ -29,7 +29,7 @@
  *
  * This replaces the KisKrayon facility that used to be present in Krayon.
  */
-class KisResource : public QObject {
+class KRITACORE_EXPORT KisResource : public QObject {
     typedef QObject super;
     Q_OBJECT
 
--- koffice-1.6.1/krita/core/kis_rotate_visitor.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_rotate_visitor.h	2006-12-10 13:44:23.000000000 -0500
@@ -20,12 +20,13 @@
 
 #include "kis_types.h"
 #include "kis_progress_subject.h"
+#include <koffice_export.h>
 
 class QRect;
 class KisPaintDevice;
 class KisProgressDisplayInterface;
 
-class KisRotateVisitor : public KisProgressSubject {
+class KRITACORE_EXPORT KisRotateVisitor : public KisProgressSubject {
         typedef KisProgressSubject super;  
         
         /* Structs for the image rescaling routine */
--- koffice-1.6.1/krita/core/kis_scale_visitor.h	2006-11-18 06:39:30.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_scale_visitor.h	2006-12-10 15:37:12.000000000 -0500
@@ -37,7 +37,7 @@
 class KisProgressDisplayInterface;
 class KisFilterStrategy;
 
-class KisScaleWorker : public KisThread {
+class KRITACORE_EXPORT KisScaleWorker : public KisThread {
 
     /* Structs for the image rescaling routine */
     class Contrib {
--- koffice-1.6.1/krita/core/kis_strategy_move.cc.rej	2006-11-18 06:39:34.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_strategy_move.cc.rej	1969-12-31 19:00:00.000000000 -0500
@@ -1,37 +0,0 @@
-***************
-*** 96,105 ****
-  
-              pos -= m_dragStart; // convert to delta
-              rc = dev->extent();
--             kdDebug() << "Before move extent: " << rc << endl;
-              dev->setX(dev->x() + pos.x());
-              dev->setY(dev->y() + pos.y());
--             kdDebug() << "Extent afdter move: " << dev->extent() << endl;
-              rc = rc.unite(dev->extent());
-  
-              m_layerPosition = QPoint(dev->x(), dev->y());
---- 96,103 ----
-  
-              pos -= m_dragStart; // convert to delta
-              rc = dev->extent();
-              dev->setX(dev->x() + pos.x());
-              dev->setY(dev->y() + pos.y());
-              rc = rc.unite(dev->extent());
-  
-              m_layerPosition = QPoint(dev->x(), dev->y());
-***************
-*** 112,118 ****
-  
-  void KisStrategyMove::endDrag(const QPoint& pos, bool undo)
-  {
--     kdDebug() << "Done dragging\n";
-      if (m_subject && m_dragging) {
-          KisImageSP img = m_subject->currentImg();
-          KisLayerSP dev;
---- 110,115 ----
-  
-  void KisStrategyMove::endDrag(const QPoint& pos, bool undo)
-  {
-      if (m_subject && m_dragging) {
-          KisImageSP img = m_subject->currentImg();
-          KisLayerSP dev;
--- koffice-1.6.1/krita/core/kis_thread_pool.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_thread_pool.h	2006-12-10 13:44:23.000000000 -0500
@@ -24,6 +24,7 @@
 #include <qmutex.h>
 
 #include "kis_thread.h"
+#include <koffice_export.h>
 
 /**
  * A thread pool starts executing threads some time after they are added,
@@ -33,7 +34,7 @@
  * have run. This means that you cannot add getters for important data to
  * threads you feed the threadpool. Instead, post the data using a customevent.
  */
-class KisThreadPool : public KisThread {
+class KRITACORE_EXPORT KisThreadPool : public KisThread {
 
 public:
 
--- koffice-1.6.1/krita/core/kis_transaction.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_transaction.h	2006-12-10 13:44:23.000000000 -0500
@@ -25,10 +25,12 @@
 
 #include "kis_types.h"
 
+#include <koffice_export.h>
+
 class QRect;
 class KisTransactionPrivate;
 
-class KisTransaction : public KCommand {
+class KRITACORE_EXPORT KisTransaction : public KCommand {
 public:
     KisTransaction(const QString& name, KisPaintDeviceSP device);
     virtual ~KisTransaction();
--- koffice-1.6.1/krita/core/kis_transform_worker.cc.orig	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_transform_worker.cc.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,545 +0,0 @@
-/*
- *  Copyright (c) 2004 Michael Thaler <michael.thaler@physik.tu-muenchen.de> filters
- *  Copyright (c) 2005 Casper Boemann <cbr@boemann.dk>
- *  Copyright (c) 2005 Boudewijn Rempt <boud@valdyas.org> right angle rotators
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-#include <kdebug.h>
-#include <klocale.h>
-
-#include "kis_debug_areas.h"
-#include "kis_paint_device.h"
-#include "kis_selection.h"
-#include "kis_transform_worker.h"
-#include "kis_progress_display_interface.h"
-#include "kis_iterators_pixel.h"
-#include "kis_filter_strategy.h"
-#include "kis_layer.h"
-
-KisTransformWorker::KisTransformWorker(KisPaintDeviceSP dev, double xscale, double yscale,
-                    double xshear, double yshear, double rotation,
-                    Q_INT32 xtranslate, Q_INT32 ytranslate,
-                    KisProgressDisplayInterface *progress, KisFilterStrategy *filter)
-{
-    m_dev= dev;
-    m_xscale = xscale;
-    m_yscale = yscale;
-    m_xshear = xshear;
-    m_yshear = yshear;
-    m_rotation = rotation,
-    m_xtranslate = xtranslate;
-    m_ytranslate = ytranslate;
-    m_progress = progress;
-    m_filter = filter;
-}
-
-void KisTransformWorker::rotateRight90(KisPaintDeviceSP src, KisPaintDeviceSP dst)
-{
-    KisSelectionSP dstSelection;
-    Q_INT32 pixelSize = src->pixelSize();
-    QRect r;
-    KisColorSpace *cs = src->colorSpace();
-
-    if(src->hasSelection())
-    {
-        r = src->selection()->selectedExactRect();
-        dstSelection = dst->selection();
-    }
-    else
-    {
-        r = src->exactBounds();
-        dstSelection = new KisSelection(dst); // essentially a dummy to be deleted
-    }
-
-    for (Q_INT32 y = r.bottom(); y >= r.top(); --y) {
-        KisHLineIteratorPixel hit = src->createHLineIterator(r.x(), y, r.width(), true);
-        KisVLineIterator vit = dst->createVLineIterator(-y, r.x(), r.width(), true);
-        KisVLineIterator dstSelIt = dstSelection->createVLineIterator(-y, r.x(), r.width(), true);
-
-            while (!hit.isDone()) {
-            if (hit.isSelected())  {
-                memcpy(vit.rawData(), hit.rawData(), pixelSize);
-
-                // XXX: Should set alpha = alpha*(1-selectedness)
-                cs->setAlpha(hit.rawData(), 0, 1);
-            }
-            *(dstSelIt.rawData()) = hit.selectedness();
-            ++hit;
-            ++vit;
-            ++dstSelIt;
-        }
-    }
-}
-
-void KisTransformWorker::rotateLeft90(KisPaintDeviceSP src, KisPaintDeviceSP dst)
-{
-    kdDebug() << "rotateLeft90 called\n";
-    KisSelectionSP dstSelection;
-    Q_INT32 pixelSize = src->pixelSize();
-    QRect r;
-    KisColorSpace *cs = src->colorSpace();
-
-    if(src->hasSelection())
-    {
-        r = src->selection()->selectedExactRect();
-        dstSelection = dst->selection();
-    }
-    else
-    {
-        r = src->exactBounds();
-        dstSelection = new KisSelection(dst); // essentially a dummy to be deleted
-    }
-    Q_INT32 x = 0;
-
-    for (Q_INT32 y = r.top(); y <= r.bottom(); ++y) {
-        // Read the horizontal line from back to front, write onto the vertical column
-        KisHLineIteratorPixel hit = src->createHLineIterator(r.x(), y, r.width(), true);
-        KisVLineIterator vit = dst->createVLineIterator(y, -r.x() - r.width(), r.width(), true);
-        KisVLineIterator dstSelIt = dstSelection->createVLineIterator(y, -r.x() - r.width(), r.width(), true);
-
-        hit += r.width() - 1;
-        while (!vit.isDone()) {
-            if (hit.isSelected()) {
-                memcpy(vit.rawData(), hit.rawData(), pixelSize);
-
-                // XXX: Should set alpha = alpha*(1-selectedness)
-                cs->setAlpha(hit.rawData(), 0, 1);
-            }
-            *(dstSelIt.rawData()) = hit.selectedness();
-            --hit;
-            ++vit;
-            ++dstSelIt;
-        }
-        ++x;
-    }
-}
-
-void KisTransformWorker::rotate180(KisPaintDeviceSP src, KisPaintDeviceSP dst)
-{
-    KisSelectionSP dstSelection;
-    Q_INT32 pixelSize = src->pixelSize();
-    QRect r;
-    KisColorSpace *cs = src->colorSpace();
-
-    if(src->hasSelection())
-    {
-        r = src->selection()->selectedExactRect();
-        dstSelection = dst->selection();
-    }
-    else
-    {
-        r = src->exactBounds();
-        dstSelection = new KisSelection(dst); // essentially a dummy to be deleted
-    }
-
-    for (Q_INT32 y = r.top(); y <= r.bottom(); ++y) {
-        KisHLineIteratorPixel srcIt = src->createHLineIterator(r.x(), y, r.width(), true);
-        KisHLineIterator dstIt = dst->createHLineIterator(-r.x() - r.width(), -y, r.width(), true);
-        KisHLineIterator dstSelIt = dstSelection->createHLineIterator(-r.x() - r.width(), -y, r.width(), true);
-
-        srcIt += r.width() - 1;
-        while (!dstIt.isDone()) {
-            if (srcIt.isSelected())  {
-                memcpy(dstIt.rawData(), srcIt.rawData(), pixelSize);
-
-                // XXX: Should set alpha = alpha*(1-selectedness)
-                cs->setAlpha(srcIt.rawData(), 0, 1);
-            }
-            *(dstSelIt.rawData()) = srcIt.selectedness();
-            --srcIt;
-            ++dstIt;
-            ++dstSelIt;
-        }
-    }
-}
-
-template <class iter> iter createIterator(KisPaintDevice *dev, Q_INT32 start, Q_INT32 lineNum, Q_INT32 len);
-
-template <> KisHLineIteratorPixel createIterator <KisHLineIteratorPixel>
-(KisPaintDevice *dev, Q_INT32 start, Q_INT32 lineNum, Q_INT32 len)
-{
-    return dev->createHLineIterator(start, lineNum, len, true);
-}
-
-template <> KisVLineIteratorPixel createIterator <KisVLineIteratorPixel>
-(KisPaintDevice *dev, Q_INT32 start, Q_INT32 lineNum, Q_INT32 len)
-{
-    return dev->createVLineIterator(lineNum, start, len, true);
-}
-
-template <class iter> void calcDimensions (KisPaintDevice *dev, Q_INT32 &srcStart, Q_INT32 &srcLen, Q_INT32 &firstLine, Q_INT32 &numLines, Q_INT32 &srcStartData, Q_INT32 &srcLenData);
-
-template <> void calcDimensions <KisHLineIteratorPixel>
-        (KisPaintDevice *dev, Q_INT32 &srcStart, Q_INT32 &srcLen, Q_INT32 &firstLine, Q_INT32 &numLines, Q_INT32 &srcStartData, Q_INT32 &srcLenData)
-{
-    dev->exactBounds(srcStartData, firstLine, srcLenData, numLines);
-    if(dev->hasSelection())
-    {
-        QRect r = dev->selection()->selectedExactRect();
-        r.rect(&srcStart, &firstLine, &srcLen, &numLines);
-    }
-    else
-    {
-        srcStart = srcStartData;
-        srcLen = srcLenData;
-    }
-}
-
-template <> void calcDimensions <KisVLineIteratorPixel>
-        (KisPaintDevice *dev, Q_INT32 &srcStart, Q_INT32 &srcLen, Q_INT32 &firstLine, Q_INT32 &numLines, Q_INT32 &srcStartData, Q_INT32 &srcLenData)
-{
-    dev->exactBounds(firstLine, srcStartData, numLines, srcLenData);
-    if(dev->hasSelection())
-    {
-        QRect r = dev->selection()->selectedExactRect();
-        r.rect(&firstLine, &srcStart, &numLines, &srcLen);
-    }
-    else
-    {
-        srcStart = srcStartData;
-        srcLen = srcLenData;
-    }
-}
-
-struct FilterValues
-{
-    Q_UINT8 numWeights;
-    Q_UINT8 *weight;
-    ~FilterValues() {delete [] weight;}
-};
-
-template <class T> void KisTransformWorker::transformPass(KisPaintDevice *src, KisPaintDevice *dst, double floatscale, double shear, Q_INT32 dx, KisFilterStrategy *filterStrategy)
-{
-    Q_INT32 lineNum,srcStart,firstLine,srcLen,numLines,srcStartData,srcLenData;
-    Q_INT32 center, begin, end;    /* filter calculation variables */
-    Q_UINT8 *data;
-    Q_UINT8 pixelSize = src->pixelSize();
-    KisSelectionSP dstSelection;
-    KisColorSpace * cs = src->colorSpace();
-    Q_INT32 scale;
-    Q_INT32 scaleDenom;
-    Q_INT32 shearFracOffset;
-
-    if(src->hasSelection())
-        dstSelection = dst->selection();
-    else
-        dstSelection = new KisSelection(dst); // essentially a dummy to be deleted
-
-    calcDimensions <T>(src, srcStart, srcLen, firstLine, numLines,srcStartData,srcLenData);
-
-    scale = int(floatscale*srcLen);
-    scaleDenom = srcLen;
-
-    if(scaleDenom == 0)
-        return;
-
-    Q_INT32 support = filterStrategy->intSupport();
-    Q_INT32 dstLen, dstStart;
-    Q_INT32 invfscale = 256;
-
-    // handle magnification/minification
-    if(abs(scale) < scaleDenom)
-    {
-        support *= scaleDenom;
-        support /= scale;
-
-        invfscale *= scale;
-        invfscale /= scaleDenom;
-        if(scale < 0) // handle mirroring
-        {
-            support = -support;
-            invfscale = -invfscale;
-        }
-    }
-
-    // handle mirroring
-    if(scale < 0)
-        dstLen = - scale;
-    else
-        dstLen = scale;
-
-    // Calculate extra length (in each side) needed due to shear
-    Q_INT32 extraLen = (support+256)>>8 + 1;
-
-    Q_UINT8 *tmpLine = new Q_UINT8[(srcLen +2*extraLen)* pixelSize];
-    Q_CHECK_PTR(tmpLine);
-
-    Q_UINT8 *tmpSel = new Q_UINT8[srcLen+2*extraLen];
-    Q_CHECK_PTR(tmpSel);
-
-    //allocate space for colors
-    const Q_UINT8 **colors = new const Q_UINT8 *[2*support+1];
-
-    // Precalculate weights
-    FilterValues *filterWeights = new FilterValues[256];
-
-    for(int center = 0; center<256; ++center)
-    {
-        Q_INT32 begin = (255 + center - support)>>8; // takes ceiling by adding 255
-        Q_INT32 span = ((center + support)>>8) - begin + 1; // takes floor to get end. Subtracts begin to get span
-        Q_INT32 t = (((begin<<8) - center) * invfscale)>>8;
-        Q_INT32 dt = invfscale;
-        filterWeights[center].weight = new Q_UINT8[span];
-//printf("%d (",center);
-        Q_UINT32 sum=0;
-        for(int num = 0; num<span; ++num)
-        {
-            Q_UINT32 tmpw = filterStrategy->intValueAt(t) * invfscale;
-
-            tmpw >>=8;
-            filterWeights[center].weight[num] = tmpw;
-//printf(" %d=%d,%d",t,filterWeights[center].weight[num],tmpw);
-            t += dt;
-            sum+=tmpw;
-        }
-//printf(" )%d sum =%d",span,sum);
-        if(sum!=255)
-        {
-            double fixfactor= 255.0/sum;
-            sum=0;
-            for(int num = 0; num<span; ++num)
-            {
-                filterWeights[center].weight[num] = int(filterWeights[center].weight[num] * fixfactor);
-                sum+=filterWeights[center].weight[num];
-            }
-        }
-
-//printf("  sum2 =%d",sum);
-        int num = 0; 
-        while(sum<255 && num*2<span)
-        {
-            filterWeights[center].weight[span/2 + num]++;
-            ++sum;
-            if(sum<255 && num<span/2)
-            {
-                filterWeights[center].weight[span/2 - num - 1]++;
-                ++sum;
-            }
-            ++num;
-        }
-//printf("  sum3 =%d\n",sum);
-
-        filterWeights[center].numWeights = span;
-    }
-
-    for(lineNum = firstLine; lineNum < firstLine+numLines; lineNum++)
-    {
-        if(scale < 0)
-            dstStart = srcStart * scale / scaleDenom - dstLen + dx;
-        else
-            dstStart = (srcStart) * scale / scaleDenom + dx;
-
-        shearFracOffset = -int( 256 * (lineNum * shear - floor(lineNum * shear)));
-        dstStart += int(floor(lineNum * shear));
-
-        // Build a temporary line
-        T srcIt = createIterator <T>(src, QMAX(srcStart - extraLen, srcStartData), lineNum, srcLen+2*extraLen);
-        Q_INT32 i = 0;
-        Q_INT32 x = srcStart - extraLen;
-        while(i < srcLen + 2*extraLen)
-        {
-            Q_UINT8 *data;
-
-            data = srcIt.rawData();
-            memcpy(&tmpLine[i*pixelSize], data, pixelSize);
-            if(srcIt.isSelected())
-            {
-                tmpSel[i] = 255;
-            }
-            else
-            {
-                tmpSel[i] = 0;
-            }
-            if(x >= srcStartData && x < srcStartData + srcLenData - 1)
-            {
-                // XXX: Should set alpha = alpha*(1-selectedness)
-                cs->setAlpha(data, 0, 1);
-                ++srcIt;
-            }
-            i++;
-            x++;
-        }
-
-        T dstIt = createIterator <T>(dst, dstStart, lineNum, dstLen);
-        T dstSelIt = createIterator <T>(dstSelection, dstStart, lineNum, dstLen);
-
-        i=0;
-        while(!dstIt.isDone())
-        {
-            if(scaleDenom<2500)
-                center = ((i<<8) * scaleDenom) / scale;
-            else
-            {
-                if(scaleDenom<46000) // real limit is actually 46340 pixels
-                    center = ((i * scaleDenom) / scale)<<8;
-                else
-                    center = ((i<<8)/scale * scaleDenom) / scale; // XXX fails for sizes over 2^23 pixels src width
-            }
-
-            if(scale < 0)
-                center += srcLen<<8;
-
-            center += 128*scaleDenom/scale;//xxx doesn't work for scale<0;
-            center += (extraLen<<8) + shearFracOffset;
-
-            // find contributing pixels
-            begin = (255 + center - support)>>8; // takes ceiling by adding 255
-            end = (center + support)>>8; // takes floor
-
-////printf("sup=%d begin=%d end=%d",support,begin,end);
-            Q_UINT8 selectedness = tmpSel[center>>8];
-            if(selectedness)
-            {
-                int num=0;
-                for(int srcpos = begin; srcpos <= end; ++srcpos)
-                {
-                    colors[num] = &tmpLine[srcpos*pixelSize];
-                    num++;
-                }
-                data = dstIt.rawData();
-                cs->mixColors(colors, filterWeights[center&255].weight, filterWeights[center&255].numWeights, data);
-                data = dstSelIt.rawData();
-                *data = selectedness;
-            }
-
-            ++dstSelIt;
-            ++dstIt;
-            i++;
-        }
-
-        //progress info
-        m_progressStep += dstLen;
-        if(m_lastProgressReport != (m_progressStep * 100) / m_progressTotalSteps)
-        {
-            m_lastProgressReport = (m_progressStep * 100) / m_progressTotalSteps;
-            emit notifyProgress(m_lastProgressReport);
-        }
-        if (m_cancelRequested) {
-            break;
-        }
-    }
-    delete [] colors;
-    delete [] tmpLine;
-    delete [] tmpSel;
-    delete [] filterWeights;
-}
-
-bool KisTransformWorker::run()
-{
-    //progress info
-    m_cancelRequested = false;
-    if(m_progress)
-        m_progress->setSubject(this, true, true);
-    m_progressTotalSteps = 0;
-    m_progressStep = 0;
-    QRect r;
-    if(m_dev->hasSelection())
-        r = m_dev->selection()->selectedExactRect();
-    else
-        r = m_dev->exactBounds();
-
-    KisPaintDeviceSP tmpdev1 = new KisPaintDevice(m_dev->colorSpace(),"transform_tmpdev1");;
-    KisPaintDeviceSP tmpdev2 = new KisPaintDevice(m_dev->colorSpace(),"transform_tmpdev2");;
-    KisPaintDeviceSP tmpdev3 = new KisPaintDevice(m_dev->colorSpace(),"transform_tmpdev2");;
-    KisPaintDeviceSP srcdev = m_dev;
-
-    double xscale = m_xscale;
-    double yscale = m_yscale;
-    double xshear = m_xshear;
-    double yshear = m_yshear;
-    double rotation = m_rotation;
-    Q_INT32 xtranslate = m_xtranslate;
-    Q_INT32 ytranslate = m_ytranslate;
-
-    if(rotation < 0.0)
-        rotation = -fmod(-rotation, 2*M_PI) + 2*M_PI;
-    else
-        rotation = fmod(rotation, 2*M_PI);
-    int rotQuadrant = int(rotation /(M_PI/2) + 0.5) & 3;
-
-    double tmp;
-    switch(rotQuadrant)
-    {
-        case 0:
-            break;
-        case 1:
-            rotateRight90(srcdev, tmpdev1);
-            srcdev = tmpdev1;
-            rotation -= M_PI/2;
-            tmp = xscale;
-            xscale=yscale;
-            yscale=tmp;
-            break;
-        case 2:
-            rotate180(srcdev, tmpdev1);
-            srcdev = tmpdev1;
-            rotation -= M_PI;
-            break;
-        case 3:
-            rotateLeft90(srcdev, tmpdev1);
-            srcdev = tmpdev1;
-            rotation += M_PI/2 + 2*M_PI;
-            tmp = xscale;
-            xscale = yscale;
-            yscale = tmp;
-            break;
-        default:
-            break;
-    }
-
-    yshear = sin(rotation);
-    xshear = -tan(rotation/2);
-    xtranslate -= int(xshear*ytranslate);
-
-    m_progressTotalSteps = int(yscale * r.width() * r.height());
-    m_progressTotalSteps += int(xscale * r.width() * (r.height() * yscale + r.width()*yshear));
-
-    m_lastProgressReport=0;
-
-    if ( m_cancelRequested) {
-        emit notifyProgressDone();
-        return false;
-    }
-
-    transformPass <KisHLineIteratorPixel>(srcdev, tmpdev2, xscale, yscale*xshear, 0, m_filter);
-    if(m_dev->hasSelection())
-        m_dev->selection()->clear();
-
-    if ( m_cancelRequested) {
-        emit notifyProgressDone();
-        return false;
-    }
-
-    transformPass <KisVLineIteratorPixel>(tmpdev2, tmpdev3, yscale, yshear, ytranslate, m_filter);
-    if(m_dev->hasSelection())
-        m_dev->selection()->clear();
-
-    if ( m_cancelRequested) {
-        emit notifyProgressDone();
-        return false;
-    }
-
-    transformPass <KisHLineIteratorPixel>(tmpdev3, m_dev, 1.0, xshear, xtranslate, m_filter);
-    if (m_dev->parentLayer()) {
-        m_dev->parentLayer()->setDirty();
-    }
-
-    //progress info
-    emit notifyProgressDone();
-    m_dev->emitSelectionChanged();
-
-    return m_cancelRequested;
-}
--- koffice-1.6.1/krita/core/kis_transform_worker.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_transform_worker.h	2006-12-10 13:44:23.000000000 -0500
@@ -22,6 +22,7 @@
 
 #include "kis_types.h"
 #include "kis_progress_subject.h"
+#include <koffice_export.h>
 
 class KisPaintDevice;
 class KisProgressDisplayInterface;
@@ -29,7 +30,7 @@
 class KisVLineIteratorPixel;
 class KisFilterStrategy;
 
-class KisTransformWorker : public KisProgressSubject {
+class KRITACORE_EXPORT KisTransformWorker : public KisProgressSubject {
     typedef KisProgressSubject super;
 
 public:
--- koffice-1.6.1/krita/core/kis_vec.h	2006-11-17 10:10:04.000000000 -0500
+++ koffice-1.6.1-new/krita/core/kis_vec.h	2006-12-10 13:44:23.000000000 -0500
@@ -26,12 +26,14 @@
 #include <qpoint.h>
 #include "kis_point.h"
 
+#include <koffice_export.h>
+
 /*
  * vector classes
  */
 const double epsilon = DBL_EPSILON;
 
-class KisVector2D
+class KRITACORE_EXPORT KisVector2D
 {
 public:
     KisVector2D();
@@ -229,7 +231,7 @@
     return KisPoint(m_x, m_y);
 }
 
-class KisVector3D
+class KRITACORE_EXPORT KisVector3D
 {
 public:
     KisVector3D();
--- koffice-1.6.1/krita/core/tiles/kis_tile.h	2006-11-17 10:10:00.000000000 -0500
+++ koffice-1.6.1-new/krita/core/tiles/kis_tile.h	2006-12-10 13:44:23.000000000 -0500
@@ -21,6 +21,8 @@
 #include <qglobal.h>
 #include <qrect.h>
 
+#include <koffice_export.h>
+
 class KisTiledDataManager;
 class KisTiledIterator;
 
@@ -29,7 +31,7 @@
  * a part of a PaintDevice, but only the individual pixels
  * are accesable and that only via iterators.
  */
-class KisTile  {
+class KRITACORE_EXPORT KisTile  {
 public:
     KisTile(Q_INT32 pixelSize, Q_INT32 col, Q_INT32 row, const Q_UINT8 *defPixel);
     KisTile(const KisTile& rhs, Q_INT32 col, Q_INT32 row);
--- koffice-1.6.1/krita/core/tiles/kis_tilemanager.cc	2006-11-17 10:10:00.000000000 -0500
+++ koffice-1.6.1-new/krita/core/tiles/kis_tilemanager.cc	2006-12-10 13:44:23.000000000 -0500
@@ -18,8 +18,8 @@
 
 #include <kdebug.h>
 
-#include <sys/mman.h>
 #include <sys/types.h>
+#include <sys/mman.h>
 #include <sys/stat.h>
 #include <unistd.h>
 #include <string.h>
--- koffice-1.6.1/krita/core/tiles/kis_tilemanager.h	2006-11-17 10:10:00.000000000 -0500
+++ koffice-1.6.1-new/krita/core/tiles/kis_tilemanager.h	2006-12-10 13:44:23.000000000 -0500
@@ -27,6 +27,8 @@
 
 #include <ktempfile.h>
 
+#include <koffice_export.h>
+
 class KisTile;
 class KisTiledDataManager;
 
@@ -41,7 +43,7 @@
  *  * tries to preallocate and recycle some tiles to make future allocations faster
  *    (not done yet)
  */
-class KisTileManager  {
+class KRITACORE_EXPORT KisTileManager  {
 public:
     ~KisTileManager();
     static KisTileManager* instance();
--- koffice-1.6.1/krita/kritacolor/kis_abstract_colorspace.h	2006-11-17 10:11:19.000000000 -0500
+++ koffice-1.6.1-new/krita/kritacolor/kis_abstract_colorspace.h	2006-12-10 13:44:23.000000000 -0500
@@ -34,7 +34,6 @@
 #include "kis_colorspace.h"
 #include "koffice_export.h"
 
-
 class QPainter;
 class KisPixelRO;
 class KisColorSpaceFactoryRegistry;
--- koffice-1.6.1/krita/kritacolor/kis_basic_histogram_producers.h	2006-11-17 10:11:19.000000000 -0500
+++ koffice-1.6.1-new/krita/kritacolor/kis_basic_histogram_producers.h	2006-12-10 13:44:23.000000000 -0500
@@ -28,9 +28,11 @@
 #include "kis_colorspace.h"
 #include "kis_id.h"
 
+#include <koffice_export.h>
+
 class KisLabColorSpace;
 
-class KisBasicHistogramProducer : public KisHistogramProducer {
+class KRITA_EXPORT KisBasicHistogramProducer : public KisHistogramProducer {
 public:
     KisBasicHistogramProducer(const KisID& id, int channels, int nrOfBins, KisColorSpace *colorSpace);
     virtual ~KisBasicHistogramProducer() {}
@@ -82,7 +84,7 @@
     QValueVector<Q_INT32> m_external;
 };
 
-class KisBasicU8HistogramProducer : public KisBasicHistogramProducer {
+class KRITA_EXPORT KisBasicU8HistogramProducer : public KisBasicHistogramProducer {
 public:
     KisBasicU8HistogramProducer(const KisID& id, KisColorSpace *colorSpace);
     virtual void addRegionToBin(Q_UINT8 * pixels, Q_UINT8 * selectionMask, Q_UINT32 nPixels, KisColorSpace *colorSpace);
@@ -90,7 +92,7 @@
     virtual double maximalZoom() const { return 1.0; }
 };
 
-class KisBasicU16HistogramProducer : public KisBasicHistogramProducer {
+class KRITA_EXPORT KisBasicU16HistogramProducer : public KisBasicHistogramProducer {
 public:
     KisBasicU16HistogramProducer(const KisID& id, KisColorSpace *colorSpace);
     virtual void addRegionToBin(Q_UINT8 * pixels, Q_UINT8 * selectionMask, Q_UINT32 nPixels, KisColorSpace *colorSpace);
@@ -98,7 +100,7 @@
     virtual double maximalZoom() const;
 };
 
-class KisBasicF32HistogramProducer : public KisBasicHistogramProducer {
+class KRITA_EXPORT KisBasicF32HistogramProducer : public KisBasicHistogramProducer {
 public:
     KisBasicF32HistogramProducer(const KisID& id, KisColorSpace *colorSpace);
     virtual void addRegionToBin(Q_UINT8 * pixels, Q_UINT8 * selectionMask, Q_UINT32 nPixels, KisColorSpace *colorSpace);
@@ -107,7 +109,7 @@
 };
 
 #ifdef HAVE_OPENEXR
-class KisBasicF16HalfHistogramProducer : public KisBasicHistogramProducer {
+class KRITA_EXPORT KisBasicF16HalfHistogramProducer : public KisBasicHistogramProducer {
 public:
     KisBasicF16HalfHistogramProducer(const KisID& id, KisColorSpace *colorSpace);
     virtual void addRegionToBin(Q_UINT8 * pixels, Q_UINT8 * selectionMask, Q_UINT32 nPixels, KisColorSpace *colorSpace);
@@ -122,7 +124,7 @@
  * Factories with Producers in the code because they are incompatible types, and
  * in the GUI we actually only need a producer's name, not a factory's.
  */
-template<class T> class KisBasicHistogramProducerFactory : public KisHistogramProducerFactory {
+template<class T> class KRITA_EXPORT KisBasicHistogramProducerFactory : public KisHistogramProducerFactory {
 public:
     KisBasicHistogramProducerFactory(const KisID& id, KisColorSpace *colorSpace)
         : KisHistogramProducerFactory(id), m_cs(colorSpace) {}
@@ -140,7 +142,7 @@
  * Registry, because it isCompatibleWith all colorspaces, and should only be used in extreme
  * cases (like no other producer being available
  **/
-class KisGenericRGBHistogramProducer : public KisBasicHistogramProducer {
+class KRITA_EXPORT KisGenericRGBHistogramProducer : public KisBasicHistogramProducer {
 public:
     KisGenericRGBHistogramProducer();
     virtual void addRegionToBin(Q_UINT8 * pixels, Q_UINT8 * selectionMask, Q_UINT32 nPixels, KisColorSpace *colorSpace);
@@ -152,7 +154,7 @@
 };
 
 /** KisGenericRGBHistogramProducer his special Factory that isCompatibleWith everything. */
-class KisGenericRGBHistogramProducerFactory : public KisHistogramProducerFactory {
+class KRITA_EXPORT KisGenericRGBHistogramProducerFactory : public KisHistogramProducerFactory {
 public:
     KisGenericRGBHistogramProducerFactory()
         : KisHistogramProducerFactory(KisID("GENRGBHISTO", i18n("Generic RGB Histogram"))) {}
@@ -168,7 +170,7 @@
  * to L*a*b*, and then does its counting.
  * It isCompatibleWith all colorspaces
  **/
-class KisGenericLabHistogramProducer : public KisBasicHistogramProducer {
+class KRITA_EXPORT KisGenericLabHistogramProducer : public KisBasicHistogramProducer {
     public:
         KisGenericLabHistogramProducer();
         virtual ~KisGenericLabHistogramProducer();
@@ -183,7 +185,7 @@
 };
 
 /** KisGenericLabHistogramProducer his special Factory that isCompatibleWith everything. */
-class KisGenericLabHistogramProducerFactory : public KisHistogramProducerFactory {
+class KRITA_EXPORT KisGenericLabHistogramProducerFactory : public KisHistogramProducerFactory {
     public:
         KisGenericLabHistogramProducerFactory()
     : KisHistogramProducerFactory(KisID("GENLABHISTO", i18n("Generic L*a*b* Histogram"))) {}
--- koffice-1.6.1/krita/kritacolor/kis_color.h	2006-11-17 10:11:19.000000000 -0500
+++ koffice-1.6.1-new/krita/kritacolor/kis_color.h	2006-12-10 13:44:23.000000000 -0500
@@ -25,12 +25,14 @@
 #include "kis_profile.h"
 #include "kis_colorspace.h"
 
+#include <koffice_export.h>
+
 
 /**
  * A KisColor describes a color in a certain colorspace.
  *
  */
-class KisColor {
+class KRITA_EXPORT KisColor {
 
 public:
     /// Create an empty KisColor. It will be valid, but also black and transparent
--- koffice-1.6.1/krita/kritacolor/kis_color_conversions.h	2006-11-17 10:11:18.000000000 -0500
+++ koffice-1.6.1-new/krita/kritacolor/kis_color_conversions.h	2006-12-10 13:44:23.000000000 -0500
@@ -21,29 +21,31 @@
 
 #include <qglobal.h>
 
+#include <koffice_export.h>
+
 /**
  * A number of often-used conversions between color models
  */
 
 // 8-bit integer versions. RGBSL are 0-255, H is 0-360.
- void rgb_to_hsv(int R, int G, int B, int *H, int *S, int *V);
- void hsv_to_rgb(int H, int S, int V, int *R, int *G, int *B);
+ void KRITA_EXPORT rgb_to_hsv(int R, int G, int B, int *H, int *S, int *V);
+ void KRITA_EXPORT hsv_to_rgb(int H, int S, int V, int *R, int *G, int *B);
 
 // Floating point versions. RGBSL are 0-1, H is 0-360.
- void RGBToHSV(float r, float g, float b, float *h, float *s, float *v);
- void HSVToRGB(float h, float s, float v, float *r, float *g, float *b);
+ void KRITA_EXPORT RGBToHSV(float r, float g, float b, float *h, float *s, float *v);
+ void KRITA_EXPORT HSVToRGB(float h, float s, float v, float *r, float *g, float *b);
 
- void RGBToHSL(float r, float g, float b, float *h, float *s, float *l);
- void HSLToRGB(float h, float sl, float l, float *r, float *g, float *b);
+ void KRITA_EXPORT RGBToHSL(float r, float g, float b, float *h, float *s, float *l);
+ void KRITA_EXPORT HSLToRGB(float h, float sl, float l, float *r, float *g, float *b);
 
- void rgb_to_hls(Q_UINT8 r, Q_UINT8 g, Q_UINT8 b, float * h, float * l, float * s);
+ void KRITA_EXPORT rgb_to_hls(Q_UINT8 r, Q_UINT8 g, Q_UINT8 b, float * h, float * l, float * s);
 
- float hue_value(float n1, float n2, float hue);
+ float KRITA_EXPORT hue_value(float n1, float n2, float hue);
 
- void hls_to_rgb(float h, float l, float s, Q_UINT8 * r, Q_UINT8 * g, Q_UINT8 * b);
+ void KRITA_EXPORT hls_to_rgb(float h, float l, float s, Q_UINT8 * r, Q_UINT8 * g, Q_UINT8 * b);
 
- void rgb_to_hls(Q_UINT8 r, Q_UINT8 g, Q_UINT8 b, int * h, int * l, int * s);
- void hls_to_rgb(int h, int l, int s, Q_UINT8 * r, Q_UINT8 * g, Q_UINT8 * b);
+ void KRITA_EXPORT rgb_to_hls(Q_UINT8 r, Q_UINT8 g, Q_UINT8 b, int * h, int * l, int * s);
+ void KRITA_EXPORT hls_to_rgb(int h, int l, int s, Q_UINT8 * r, Q_UINT8 * g, Q_UINT8 * b);
 
 #endif // _KIS_CONVERSIONS_H_
 
--- koffice-1.6.1/krita/kritacolor/kis_colorspace.h	2006-11-17 10:11:19.000000000 -0500
+++ koffice-1.6.1-new/krita/kritacolor/kis_colorspace.h	2006-12-10 13:44:23.000000000 -0500
@@ -27,6 +27,8 @@
 #include "kis_composite_op.h"
 #include "kis_channelinfo.h"
 
+#include <koffice_export.h>
+
 class DCOPObject;
 
 class KisProfile;
@@ -55,7 +57,7 @@
  * in Krita. This is the definition of the public API for
  * colormodels.
  */
-class KisColorSpace {
+class KRITA_EXPORT KisColorSpace {
 
 
 public:
@@ -421,7 +423,7 @@
 
 };
 
-class KisColorSpaceFactory {
+class KRITA_EXPORT KisColorSpaceFactory {
 public:
     /**
      * Krita definition for use in .kra files and internally: unchanging name +
--- koffice-1.6.1/krita/kritacolor/kis_colorspace_factory_registry.h	2006-11-17 10:11:18.000000000 -0500
+++ koffice-1.6.1-new/krita/kritacolor/kis_colorspace_factory_registry.h	2006-12-10 13:44:23.000000000 -0500
@@ -22,6 +22,7 @@
 #include "qobject.h"
 #include "kis_generic_registry.h"
 #include "kis_colorspace.h"
+#include <koffice_export.h>
 
 class QStringList;
 class KisPaintDeviceAction;
@@ -32,7 +33,7 @@
  *      - a registry of singleton colorspace factories.
  *      - a registry of icc profiles
  */
-class KisColorSpaceFactoryRegistry : public QObject,  public KisGenericRegistry<KisColorSpaceFactory *> {
+class KRITA_EXPORT KisColorSpaceFactoryRegistry : public QObject,  public KisGenericRegistry<KisColorSpaceFactory *> {
 
 
     Q_OBJECT
--- koffice-1.6.1/krita/kritacolor/kis_composite_op.h	2006-11-17 10:11:18.000000000 -0500
+++ koffice-1.6.1-new/krita/kritacolor/kis_composite_op.h	2006-12-10 13:44:23.000000000 -0500
@@ -24,6 +24,8 @@
 //#include "kis_global.h"
 #include "kis_id.h"
 
+#include <koffice_export.h>
+
 enum CompositeOp {
     COMPOSITE_OVER,
     COMPOSITE_IN,
@@ -72,7 +74,7 @@
     COMPOSITE_UNDEF
 };
 
-class KisCompositeOp {
+class KRITA_EXPORT KisCompositeOp {
 public:
     KisCompositeOp();
     KisCompositeOp(const QString& id);
--- koffice-1.6.1/krita/kritacolor/kis_f16half_base_colorspace.h	2006-11-17 10:11:19.000000000 -0500
+++ koffice-1.6.1-new/krita/kritacolor/kis_f16half_base_colorspace.h	2006-12-10 13:44:23.000000000 -0500
@@ -26,6 +26,8 @@
 #include "kis_abstract_colorspace.h"
 #include "kis_integer_maths.h"
 
+#include <koffice_export.h>
+
 /**
  * This class is the base for all 16-bit float colorspaces using the
  * OpenEXR half format. This format can be used with the OpenGL
@@ -58,7 +60,7 @@
 #define F16HALF_OPACITY_OPAQUE ((half)1.0f)
 #define F16HALF_OPACITY_TRANSPARENT ((half)0.0f)
 
-class KisF16HalfBaseColorSpace : public KisAbstractColorSpace {
+class KRITA_EXPORT KisF16HalfBaseColorSpace : public KisAbstractColorSpace {
 
 public:
 
--- koffice-1.6.1/krita/kritacolor/kis_f32_base_colorspace.h	2006-11-17 10:11:18.000000000 -0500
+++ koffice-1.6.1-new/krita/kritacolor/kis_f32_base_colorspace.h	2006-12-10 13:44:23.000000000 -0500
@@ -24,6 +24,8 @@
 #include "kis_abstract_colorspace.h"
 #include "kis_integer_maths.h"
 
+#include <koffice_export.h>
+
 /**
  * This class is the base for all 32-bit float colorspaces.
  */
@@ -54,7 +56,7 @@
 #define F32_OPACITY_OPAQUE 1.0f
 #define F32_OPACITY_TRANSPARENT 0.0f
 
-class KisF32BaseColorSpace : public KisAbstractColorSpace {
+class KRITA_EXPORT KisF32BaseColorSpace : public KisAbstractColorSpace {
 
 public:
 
--- koffice-1.6.1/krita/kritacolor/kis_histogram_producer.h	2006-11-17 10:11:18.000000000 -0500
+++ koffice-1.6.1-new/krita/kritacolor/kis_histogram_producer.h	2006-12-10 13:44:23.000000000 -0500
@@ -26,6 +26,8 @@
 
 #include "kis_generic_registry.h"
 
+#include <koffice_export.h>
+
 class KisRectIteratorPixel;
 class QString;
 class KisChannelInfo;
@@ -110,7 +112,7 @@
     KisID m_id;
 };
 
-class KisHistogramProducerFactoryRegistry
+class KRITA_EXPORT KisHistogramProducerFactoryRegistry
     : public KisGenericRegistry<KisHistogramProducerFactory*> {
 public:
     virtual ~KisHistogramProducerFactoryRegistry();
--- koffice-1.6.1/krita/kritacolor/kis_profile.h	2006-11-17 10:11:19.000000000 -0500
+++ koffice-1.6.1-new/krita/kritacolor/kis_profile.h	2006-12-10 13:44:23.000000000 -0500
@@ -33,10 +33,12 @@
 
 #include <kis_annotation.h>
 
+#include <koffice_export.h>
+
 //XXX: Profiles should be loaded by the color strategies
 //     and be available only through the color strategy
 //     that matches the profile's color model
-class KisProfile {
+class KRITA_EXPORT KisProfile {
 
 public:
     KisProfile(QByteArray rawData);
--- koffice-1.6.1/krita/kritacolor/kis_u16_base_colorspace.h	2006-11-17 10:11:19.000000000 -0500
+++ koffice-1.6.1-new/krita/kritacolor/kis_u16_base_colorspace.h	2006-12-10 13:44:23.000000000 -0500
@@ -22,12 +22,14 @@
 #include "kis_abstract_colorspace.h"
 #include "kis_integer_maths.h"
 
+#include <koffice_export.h>
+
 /**
  * This is the base class for 16-bit/channel colorspaces with 16-bit alpha
  * channels. It defines a number of common methods, like handling 16-bit alpha
  * and up- and down-scaling of channels.
  */
-class KisU16BaseColorSpace : public KisAbstractColorSpace {
+class KRITA_EXPORT KisU16BaseColorSpace : public KisAbstractColorSpace {
 
 public:
 
--- koffice-1.6.1/krita/kritacolor/kis_u8_base_colorspace.h	2006-11-17 10:11:19.000000000 -0500
+++ koffice-1.6.1-new/krita/kritacolor/kis_u8_base_colorspace.h	2006-12-10 13:44:23.000000000 -0500
@@ -26,10 +26,12 @@
 #include "kis_abstract_colorspace.h"
 #include "kis_integer_maths.h"
 
+#include <koffice_export.h>
+
 /**
  * This class is the base for all homogenous 8-bit/channel colorspaces with 8-bit alpha channels
  */
-class KisU8BaseColorSpace : public KisAbstractColorSpace {
+class KRITA_EXPORT KisU8BaseColorSpace : public KisAbstractColorSpace {
 
 public:
 
--- koffice-1.6.1/krita/plugins/filters/levelfilter/kritalevelfilter.desktop.orig	2006-11-17 10:09:49.000000000 -0500
+++ koffice-1.6.1-new/krita/plugins/filters/levelfilter/kritalevelfilter.desktop.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,44 +0,0 @@
-[Desktop Entry]
-Encoding=UTF-8
-Name=Levels
-Name[br]=Liveoù
-Name[da]=Niveauer
-Name[de]=Stufen
-Name[el]=Επίπεδα
-Name[es]=Niveles
-Name[et]=Tasemed
-Name[hu]=Szintek
-Name[it]=Livelli
-Name[ja]=レベル
-Name[km]=កម្រិត
-Name[pt]=Níveis
-Name[pt_BR]=Níveis
-Name[sk]=Úrovne
-Name[sl]=Ravni
-Name[sr]=Нивои
-Name[sr@Latn]=Nivoi
-Name[sv]=Nivåer
-Name[zh_TW]=等級
-Comment=Levels
-Comment[br]=Liveoù
-Comment[da]=Niveauer
-Comment[de]=Stufen
-Comment[el]=Επίπεδα
-Comment[es]=Niveles
-Comment[et]=Tasemed
-Comment[hu]=Szintek
-Comment[it]=Livelli
-Comment[ja]=レベル
-Comment[km]=កម្រិត
-Comment[pt]=Níveis
-Comment[pt_BR]=Níveis
-Comment[sk]=Úrovne
-Comment[sl]=Ravni
-Comment[sr]=Нивои
-Comment[sr@Latn]=Nivoi
-Comment[sv]=Nivåer
-Comment[zh_TW]=等級
-ServiceTypes=Krita/Filter
-Type=Service
-X-KDE-Library=kritalevelfilter
-X-Krita-Version=2
--- koffice-1.6.1/krita/plugins/viewplugins/histogram/wdghistogram.ui.rej	2006-11-18 06:39:30.000000000 -0500
+++ koffice-1.6.1-new/krita/plugins/viewplugins/histogram/wdghistogram.ui.rej	1969-12-31 19:00:00.000000000 -0500
@@ -1,18 +0,0 @@
-***************
-*** 12,20 ****
-              <height>380</height>
-          </rect>
-      </property>
--     <property name="caption">
--         <string>WdgHistogram</string>
--     </property>
-      <vbox>
-          <property name="name">
-              <cstring>unnamed</cstring>
---- 12,17 ----
-              <height>380</height>
-          </rect>
-      </property>
-      <vbox>
-          <property name="name">
-              <cstring>unnamed</cstring>
--- koffice-1.6.1/krita/plugins/viewplugins/scripting/kritascripting/kis_script_monitor.h	2006-11-17 10:09:54.000000000 -0500
+++ koffice-1.6.1-new/krita/plugins/viewplugins/scripting/kritascripting/kis_script_monitor.h	2006-12-10 13:44:23.000000000 -0500
@@ -21,6 +21,8 @@
 
 #include <qobject.h>
 
+#include <koffice_export.h>
+
 namespace Kross {
     namespace Api {
         class ScriptGUIClient;
@@ -31,7 +33,7 @@
 /**
 	@author Cyrille Berger <cberger@cberger.net>
 */
-class KisScriptMonitor : public QObject {
+class KRITA_EXPORT KisScriptMonitor : public QObject {
     Q_OBJECT
     private:
         KisScriptMonitor();
--- koffice-1.6.1/krita/plugins/viewplugins/scripting/kritascripting/kis_script_progress.h	2006-11-17 10:09:54.000000000 -0500
+++ koffice-1.6.1-new/krita/plugins/viewplugins/scripting/kritascripting/kis_script_progress.h	2006-12-10 13:44:23.000000000 -0500
@@ -21,13 +21,15 @@
 
 #include <kis_progress_subject.h>
 
+#include <koffice_export.h>
+
 class KisView;
 
 /**
  * TODO: clarify the situation, while, in the future, multiple scripts could be running at a same time,
  * some of the functions are global to all script and some aren't.
  */
-class KisScriptProgress : public KisProgressSubject
+class KRITA_EXPORT KisScriptProgress : public KisProgressSubject
 {
     public:
         KisScriptProgress(KisView* view) : m_view(view) {};
--- koffice-1.6.1/krita/sdk/kis_generic_registry.h	2006-11-17 10:09:58.000000000 -0500
+++ koffice-1.6.1-new/krita/sdk/kis_generic_registry.h	2006-12-10 13:44:23.000000000 -0500
@@ -35,6 +35,7 @@
  * user-visible, translated string that can be used in the 
  * user interface.
  */
+#undef _T
 template<typename _T>
 class KisGenericRegistry {
 protected:
--- koffice-1.6.1/krita/ui/imageviewer.h	2006-11-17 10:11:34.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/imageviewer.h	2006-12-10 13:44:23.000000000 -0500
@@ -22,6 +22,8 @@
 #include <qscrollview.h>
 #include <qimage.h>
 
+#include <koffice_export.h>
+
 class QLabel;
 
 /**
@@ -30,7 +32,7 @@
  * XXX: We should add a signal that emits newly eposed rects so the filters
  *      don't have to filter everything, but just the the new bits.
  */
-class ImageViewer : public QScrollView {
+class KRITAUI_EXPORT ImageViewer : public QScrollView {
     Q_OBJECT
 
 public:
--- koffice-1.6.1/krita/ui/kis_canvas.h	2006-11-17 10:11:34.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/kis_canvas.h	2006-12-10 13:44:23.000000000 -0500
@@ -35,6 +35,8 @@
 #include "kis_vec.h"
 #include "kis_input_device.h"
 
+#include <koffice_export.h>
+
 #ifdef Q_WS_X11
 
 // Irix has a different (and better) XInput tablet driver to
@@ -276,7 +278,7 @@
 #endif // Q_WS_X11
 };
 
-class KisCanvas : public QObject {
+class KRITAUI_EXPORT KisCanvas : public QObject {
     Q_OBJECT
 
 public:
--- koffice-1.6.1/krita/ui/kis_canvas_painter.h	2006-11-17 10:11:34.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/kis_canvas_painter.h	2006-12-10 13:44:23.000000000 -0500
@@ -27,6 +27,8 @@
 
 #include "kis_global.h"
 
+#include <koffice_export.h>
+
 class KisCanvas;
 class KisCanvasWidget;
 
@@ -188,7 +190,7 @@
     QWMatrix m_defaultWorldMatrix;
 };
 
-class KisCanvasPainter {
+class KRITAUI_EXPORT KisCanvasPainter {
 public:
     KisCanvasPainter();
     KisCanvasPainter(KisCanvas *canvas);
--- koffice-1.6.1/krita/ui/kis_cmb_idlist.h	2006-11-17 10:11:34.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/kis_cmb_idlist.h	2006-12-10 13:44:23.000000000 -0500
@@ -25,12 +25,14 @@
 
 #include "kis_id.h"
 
+#include <koffice_export.h>
+
 /**
  * A combobox that is associated with a list of KisID's. The
  * descriptive (i18n'ed) text is displayed, but the various
  * signals return a KisID.
  */
-class KisCmbIDList : public QComboBox
+class KRITAUI_EXPORT KisCmbIDList : public QComboBox
 {
     typedef QComboBox super;
 
--- koffice-1.6.1/krita/ui/kis_filters_listview.h	2006-11-18 06:39:38.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/kis_filters_listview.h	2006-12-10 13:44:23.000000000 -0500
@@ -31,6 +31,8 @@
 #include "kis_paint_device.h"
 #include "kis_thread.h"
 
+#include <koffice_export.h>
+
 class KisView;
 class KisFilter;
 class KisFilterConfiguration;
@@ -102,7 +104,7 @@
     KisFiltersThumbnailThread * m_thread;
 };
 
-class KisFiltersListView : public KIconView {
+class KRITAUI_EXPORT KisFiltersListView : public KIconView {
 
 public:
     explicit KisFiltersListView(QWidget * parent = 0, const char * name = 0, WFlags f = 0, bool filterForAdjustmentLayers = false);
--- koffice-1.6.1/krita/ui/kis_histogram_view.h	2006-11-17 10:11:34.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/kis_histogram_view.h	2006-12-10 13:44:23.000000000 -0500
@@ -28,6 +28,8 @@
 #include "kis_histogram_producer.h"
 #include "kis_histogram.h"
 
+#include <koffice_export.h>
+
 class KisChannelInfo;
 
 /**
@@ -45,7 +47,7 @@
  * some functionality will disappear, like listProducers(). Setting a histogram will discard
  * info on the layer, and setting a layer will discard info on the histogram.
  **/
-class KisHistogramView : public QLabel {
+class KRITAUI_EXPORT KisHistogramView : public QLabel {
     Q_OBJECT
 public:
     KisHistogramView(QWidget *parent = 0, const char *name = 0, WFlags f = 0);
--- koffice-1.6.1/krita/ui/kis_input_device.h	2006-11-17 10:11:34.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/kis_input_device.h	2006-12-10 13:44:23.000000000 -0500
@@ -20,8 +20,9 @@
 #define KIS_INPUT_DEVICE_H_
 
 #include <qvaluevector.h>
+#include <koffice_export.h>
 
-class KisInputDevice {
+class KRITAUI_EXPORT KisInputDevice {
 public:
     KisInputDevice();
 
--- koffice-1.6.1/krita/ui/kis_int_spinbox.h	2006-11-17 10:11:34.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/kis_int_spinbox.h	2006-12-10 13:44:23.000000000 -0500
@@ -27,12 +27,14 @@
 
 #include <knumvalidator.h>
 
+#include <koffice_export.h>
+
 class QLabel;
 class QLineEdit;
 class QLayout;
 class QValidator;
 
-class KisPopupSlider : public QPopupMenu {
+class KRITAUI_EXPORT KisPopupSlider : public QPopupMenu {
     Q_OBJECT
 
 public:
@@ -70,7 +72,7 @@
  *
  *
  */
-class KisIntSpinbox : public QWidget
+class KRITAUI_EXPORT KisIntSpinbox : public QWidget
 {
 
     Q_OBJECT
--- koffice-1.6.1/krita/ui/kis_matrix_widget.ui	2006-11-17 10:11:34.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/kis_matrix_widget.ui	2006-12-10 13:44:23.000000000 -0500
@@ -4,6 +4,7 @@
     <property name="name">
         <cstring>KisMatrixWidget</cstring>
     </property>
+    <exportmacro>KRITAUI_EXPORT</exportmacro>
     <property name="geometry">
         <rect>
             <x>0</x>
@@ -199,6 +200,7 @@
 </tabstops>
 <includes>
     <include location="local" impldecl="in implementation">kis_matrix_widget.ui.h</include>
+    <include location="local" impldecl="in declaration">koffice_export.h</include>
 </includes>
 <signals>
     <signal>valueChanged()</signal>
--- koffice-1.6.1/krita/ui/kis_perspective_grid_manager.h	2006-11-17 10:11:33.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/kis_perspective_grid_manager.h	2006-12-10 13:44:23.000000000 -0500
@@ -22,13 +22,14 @@
 #define KIS_PERSPECTIVE_GRID_MANAGER_H
 
 #include <qobject.h>
+#include <koffice_export.h>
 
 class KAction;
 class KActionCollection;
 class KToggleAction;
 class KisView;
 
-class KisPerspectiveGridManager : public QObject
+class KRITA_EXPORT KisPerspectiveGridManager : public QObject
 {
     Q_OBJECT
     public:
--- koffice-1.6.1/krita/ui/kis_previewwidget.h	2006-11-17 10:11:34.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/kis_previewwidget.h	2006-12-10 13:44:23.000000000 -0500
@@ -29,6 +29,8 @@
 
 #include "kis_previewwidgetbase.h"
 
+#include <koffice_export.h>
+
 class QWidget;
 class KisProfile;
 /**
@@ -39,7 +41,7 @@
  * (maybe not those that create a new image) would use this. This can prevent the distracting
  * effect the GIMP has with a different preview for almost every filter.
  */
-class KisPreviewWidget : public PreviewWidgetBase
+class KRITAUI_EXPORT KisPreviewWidget : public PreviewWidgetBase
 {
     Q_OBJECT
 
--- koffice-1.6.1/krita/ui/kis_resourceserver.h	2006-11-17 10:11:34.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/kis_resourceserver.h	2006-12-10 13:44:23.000000000 -0500
@@ -27,9 +27,11 @@
 
 #include "kis_generic_registry.h"
 
+#include <koffice_export.h>
+
 class KisResource;
 
-class KisResourceServerBase : public QObject {
+class KRITAUI_EXPORT KisResourceServerBase : public QObject {
     Q_OBJECT
 public:
     KisResourceServerBase(QString type);
@@ -56,7 +58,7 @@
 };
 
 
-template <class T> class KisResourceServer : public KisResourceServerBase {
+template <class T> class KRITAUI_EXPORT KisResourceServer : public KisResourceServerBase {
     typedef KisResourceServerBase super;
 
 public:
@@ -70,7 +72,7 @@
 
 
 
-class KisResourceServerRegistry : public KisGenericRegistry<KisResourceServerBase*>
+class KRITAUI_EXPORT KisResourceServerRegistry : public KisGenericRegistry<KisResourceServerBase*>
 {
 
 public:
--- koffice-1.6.1/krita/ui/kis_tool.h	2006-11-17 10:11:34.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/kis_tool.h	2006-12-10 13:44:23.000000000 -0500
@@ -29,6 +29,8 @@
 #include "kis_shared_ptr_vector.h"
 #include "kis_canvas_observer.h"
 
+#include <koffice_export.h>
+
 class QCursor;
 class QEvent;
 class QKeyEvent;
@@ -58,7 +60,7 @@
 
 const Q_UINT8 NUMBER_OF_TOOLTYPES = 6;
 
-class KisTool : public QObject, public KisCanvasObserver, public KShared {
+class KRITAUI_EXPORT KisTool : public QObject, public KisCanvasObserver, public KShared {
     Q_OBJECT
 
 public:
--- koffice-1.6.1/krita/ui/kis_view.cc.orig	2006-11-17 10:11:34.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/kis_view.cc.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,4008 +0,0 @@
-/* This file is part of KimageShop^WKrayon^WKrita
- *
- *  Copyright (c) 1999 Matthias Elter  <me@kde.org>
- *                1999 Michael Koch    <koch@kde.org>
- *                1999 Carsten Pfeiffer <pfeiffer@kde.org>
- *                2002 Patrick Julien <freak@codepimps.org>
- *                2003-2005 Boudewijn Rempt <boud@valdyas.org>
- *                2004 Clarence Dang <dang@kde.org>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <algorithm>
-#include <cmath>
-
-// Qt
-#include <qapplication.h>
-#include <qbutton.h>
-#include <qcursor.h>
-#include <qevent.h>
-#include <qpainter.h>
-#include <qscrollbar.h>
-#include <qspinbox.h>
-#include <qdockarea.h>
-#include <qstringlist.h>
-#include <qstyle.h>
-#include <qpopupmenu.h>
-#include <qvaluelist.h>
-#include <qstringlist.h>
-#include <qobjectlist.h>
-
-// KDE
-#include <kis_meta_registry.h>
-#include <kglobalsettings.h>
-#include <dcopobject.h>
-#include <kaction.h>
-#include <kcolordialog.h>
-#include <kiconloader.h>
-#include <kfiledialog.h>
-#include <klocale.h>
-#include <kmessagebox.h>
-#include <knotifyclient.h>
-#include <kprinter.h>
-#include <kpushbutton.h>
-#include <kstatusbar.h>
-#include <kstdaction.h>
-#include <kinputdialog.h>
-#include <kurldrag.h>
-#include <kpopupmenu.h>
-#include <kdebug.h>
-#include <ksharedptr.h>
-#include <ktoolbar.h>
-#include <kparts/plugin.h>
-#include <kservice.h>
-#include <ktrader.h>
-#include <kparts/componentfactory.h>
-#include <kparts/event.h>
-
-// KOffice
-#include <KoPartSelectAction.h>
-#include <KoFilterManager.h>
-#include <KoMainWindow.h>
-#include <KoView.h>
-#include <KoTabBar.h>
-#include <ko_gray_widget.h>
-#include <ko_hsv_widget.h>
-#include <ko_rgb_widget.h>
-#include <kopalettemanager.h>
-#include <kopalette.h>
-
-// Local
-#include "kis_brush.h"
-#include "kis_button_press_event.h"
-#include "kis_button_release_event.h"
-#include "kis_canvas.h"
-#include "kis_canvas_painter.h"
-#include "kis_color.h"
-#include "kis_colorspace_factory_registry.h"
-#include "kis_config.h"
-#include "kis_controlframe.h"
-#include "kis_cursor.h"
-#include "kis_doc.h"
-#include "kis_double_click_event.h"
-#include "kis_factory.h"
-#include "kis_filter_strategy.h"
-#include "kis_gradient.h"
-#include "kis_group_layer.h"
-#include "kis_adjustment_layer.h"
-#include "kis_paint_device.h"
-#include "kis_tool_freehand.h"
-//#include "kis_guide.h"
-
-#include "kis_layerbox.h"
-#include "kis_import_catcher.h"
-#include "kis_layer.h"
-#include "kis_paint_layer.h"
-#include "kis_move_event.h"
-#include "kis_paint_device.h"
-#include "kis_painter.h"
-#include "kis_paintop_registry.h"
-#include "kis_part_layer.h"
-#include "kis_part_layer_handler.h"
-#include "kis_pattern.h"
-#include "kis_profile.h"
-#include "kis_rect.h"
-#include "kis_resource.h"
-#include "kis_palette.h"
-#include "kis_ruler.h"
-#include "kis_selection.h"
-#include "KoToolBox.h"
-#include "kis_tool.h"
-#include "kis_tool_manager.h"
-#include "kis_transaction.h"
-#include "kis_types.h"
-#include "kis_undo_adapter.h"
-#include "kis_view.h"
-#include "kis_view_iface.h"
-#include "kis_label_progress.h"
-#include "kis_opengl_image_context.h"
-#include "kis_background.h"
-#include "kis_paint_device_action.h"
-#include "kis_filter_configuration.h"
-#include "kis_transform_worker.h"
-#include "kis_shear_visitor.h"
-
-#include <kis_resourceserver.h>
-#include <kis_resource_mediator.h>
-
-#include "kis_icon_item.h"
-#include "kis_palette_widget.h"
-#include "kis_birdeye_box.h"
-#include "kis_color.h"
-#include "kis_factory.h"
-
-// Dialog boxes
-#include "kis_dlg_new_layer.h"
-#include "kis_dlg_layer_properties.h"
-#include "kis_dlg_preferences.h"
-#include "kis_dlg_image_properties.h"
-#include "kis_dlg_adjustment_layer.h"
-#include "kis_dlg_adj_layer_props.h"
-
-// Action managers
-#include "kis_selection_manager.h"
-#include "kis_filter_manager.h"
-#include "kis_grid_manager.h"
-#include "kis_perspective_grid_manager.h"
-
-#include "kis_custom_palette.h"
-#include "wdgpalettechooser.h"
-
-#include <fixx11h.h>
-
-// Time in ms that must pass after a tablet event before a mouse event is allowed to
-// change the input device to the mouse. This is needed because mouse events are always
-// sent to a receiver if it does not accept the tablet event.
-#define MOUSE_CHANGE_EVENT_DELAY 100
-
-KisView::KisView(KisDoc *doc, KisUndoAdapter *adapter, QWidget *parent, const char *name)
-    : super(doc, parent, name)
-    , KXMLGUIBuilder( shell() )
-    , m_panning( false )
-    , m_oldTool( 0 )
-    , m_doc( doc )
-    , m_canvas( 0 )
-    , m_popup( 0 )
-    , m_partHandler( 0 )
-    , m_gridManager( 0 )
-    , m_perspectiveGridManager( 0 )
-    , m_selectionManager( 0 )
-    , m_filterManager( 0 )
-    , m_paletteManager( 0 )
-    , m_toolManager( 0 )
-    , m_actLayerVis( false )
-    , m_hRuler( 0 )
-    , m_vRuler( 0 )
-    , m_imgFlatten( 0 )
-    , m_imgMergeLayer( 0 )
-    , m_imgRename( 0 )
-    , m_imgResizeToLayer( 0 )
-    , m_imgScan( 0 )
-    , m_actionPartLayer( 0 )
-    , m_layerAdd( 0 )
-    , m_layerBottom( 0 )
-    , m_layerDup( 0 )
-    , m_layerHide( 0 )
-    , m_layerLower( 0 )
-    , m_layerProperties( 0 )
-    , m_layerRaise( 0 )
-    , m_layerRm( 0 )
-    , m_layerSaveAs( 0 )
-    , m_layerTop( 0 )
-    , m_zoomIn( 0 )
-    , m_zoomOut( 0 )
-    , m_actualPixels( 0 )
-    , m_actualSize( 0 )
-    , m_fitToCanvas( 0 )
-    , m_fullScreen( 0 )
-    , m_imgProperties( 0 )
-    , m_RulerAction( 0 )
-    , m_guideAction( 0 )
-    , m_dcop( 0 )
-    , m_hScroll( 0 )
-    , m_vScroll( 0 )
-    , m_scrollX( 0 )
-    , m_scrollY( 0 )
-    , m_canvasXOffset( 0)
-    , m_canvasYOffset( 0)
-    , m_paintViewEnabled( false )
-    , m_guiActivateEventReceived( false )
-    , m_showEventReceived( false )
-    , m_imageLoaded( false )
-//    , m_currentGuide( 0 )
-    , m_adapter( adapter )
-    , m_statusBarZoomLabel( 0 )
-    , m_statusBarSelectionLabel( 0 )
-    , m_statusBarProfileLabel( 0 )
-    , m_progress( 0 )
-    , m_layerBox( 0 )
-    , m_toolBox( 0 )
-    , m_brush( 0 )
-    , m_pattern( 0 )
-    , m_gradient( 0 )
-    , m_toolIsPainting( false )
-    , m_monitorProfile( 0 )
-    , m_HDRExposure( 0 )
-{
-
-    Q_ASSERT(doc);
-    Q_ASSERT(adapter);
-    Q_ASSERT(parent);
-
-    KisConfig cfg;
-
-    m_currentColorChooserDisplay = KisID("BLA");
-    setFocusPolicy( QWidget::StrongFocus );
-
-    // Must come before input devices are referenced as this detects them.
-#ifdef Q_WS_X11
-    KisCanvasWidget::initX11Support();
-#endif
-    // Install event filter before we create any child widgets so they can see
-    // the tablet events.
-    qApp->installEventFilter(this);
-
-    m_tabletEventTimer.start();
-    m_inputDevice = KisInputDevice::mouse();
-
-    connect(&m_initialZoomTimer, SIGNAL(timeout()), SLOT(slotInitialZoomTimeout()));
-
-    m_paletteManager = new KoPaletteManager(this, actionCollection(), "Krita palette manager");
-    if (cfg.fixDockerWidth()) m_paletteManager->setFixedWidth( 360 );
-
-    m_paletteManager->createPalette( krita::CONTROL_PALETTE, i18n("Control box"));
-    m_paletteManager->createPalette( krita::COLORBOX, i18n("Colors"));
-    m_paletteManager->createPalette( krita::LAYERBOX, i18n("Layers"));
-
-    m_selectionManager = new KisSelectionManager(this, doc);
-    m_filterManager = new KisFilterManager(this, doc);
-    m_toolManager = new KisToolManager(canvasSubject(), getCanvasController());
-    m_gridManager = new KisGridManager(this);
-    m_perspectiveGridManager = new KisPerspectiveGridManager(this);
-
-    // This needs to be set before the dockers are created.
-    m_image = m_doc->currentImage();
-    KisColorSpace * cs = KisMetaRegistry::instance()->csRegistry()->getRGB8();
-    m_fg = KisColor(Qt::black, cs);
-    m_bg = KisColor(Qt::white, cs);
-
-    createDockers();
-
-    setInstance(KisFactory::instance(), false);
-    setClientBuilder( this );
-
-    if (!doc->isReadWrite())
-        setXMLFile("krita_readonly.rc");
-    else
-        setXMLFile("krita.rc");
-
-    KStdAction::keyBindings( mainWindow()->guiFactory(), SLOT( configureShortcuts() ), actionCollection() );
-
-    createLayerBox();
-
-    setupCanvas();
-    m_canvas->hide();
-    setupRulers();
-    setupScrollBars();
-    setupStatusBar();
-
-    setupActions();
-    dcopObject();
-
-
-    connect(this, SIGNAL(autoScroll(const QPoint &)), SLOT(slotAutoScroll(const QPoint &)));
-
-    setMouseTracking(true);
-
-    resetMonitorProfile();
-
-    layersUpdated();
-
-    m_brushesAndStuffToolBar = new KisControlFrame(mainWindow(), this);
-
-    // Load all plugins
-    KTrader::OfferList offers = KTrader::self()->query(QString::fromLatin1("Krita/ViewPlugin"),
-                                                         QString::fromLatin1("(Type == 'Service') and "
-                                                                             "([X-Krita-Version] == 2)"));
-    KTrader::OfferList::ConstIterator iter;
-    for(iter = offers.begin(); iter != offers.end(); ++iter)
-    {
-        KService::Ptr service = *iter;
-        int errCode = 0;
-        KParts::Plugin* plugin =
-             KParts::ComponentFactory::createInstanceFromService<KParts::Plugin> ( service, this, 0, QStringList(), &errCode);
-        if ( plugin ) {
-            kdDebug(41006) << "found plugin " << service->property("Name").toString() << "\n";
-            insertChildClient(plugin);
-        }
-        else {
-            kdDebug(41006) << "found plugin " << service->property("Name").toString() << ", " << errCode << "\n";
-	    if( errCode == KParts::ComponentFactory::ErrNoLibrary)
-	    {
-		kdWarning(41006) << " Error loading plugin was : ErrNoLibrary " << KLibLoader::self()->lastErrorMessage() << endl;
-	    }
-        }
-    }
-
-    if(!doc->isLoading())
-    {
-        slotLoadingFinished();
-    } else {
-        connect(doc, SIGNAL(loadingFinished()), this, SLOT(slotLoadingFinished()));
-    }
-
-    setFocus();
-}
-
-KisView::~KisView()
-{
-    KisConfig cfg;
-    cfg.setShowRulers( m_RulerAction->isChecked() );
-
-    delete m_dcop;
-    delete m_paletteManager;
-    delete m_selectionManager;
-    delete m_filterManager;
-    delete m_toolManager;
-
-}
-
-
-static Qt::Dock stringToDock( const QString& attrPosition )
-{
-    KToolBar::Dock dock = KToolBar::DockTop;
-    if ( !attrPosition.isEmpty() ) {
-        if ( attrPosition == "top" )
-            dock = Qt::DockTop;
-        else if ( attrPosition == "left" )
-            dock = Qt::DockLeft;
-        else if ( attrPosition == "right" )
-            dock = Qt::DockRight;
-        else if ( attrPosition == "bottom" )
-            dock = Qt::DockBottom;
-        else if ( attrPosition == "floating" )
-            dock = Qt::DockTornOff;
-        else if ( attrPosition == "flat" )
-            dock = Qt::DockMinimized;
-    }
-    return dock;
-}
-
-QWidget * KisView::createContainer( QWidget *parent, int index, const QDomElement &element, int &id )
-{
-    if( element.attribute( "name" ) == "ToolBox" )
-    {
-        m_toolBox = new KoToolBox(mainWindow(), "ToolBox", KisFactory::instance(), NUMBER_OF_TOOLTYPES);
-        m_toolBox->setLabel(i18n("Krita"));
-        m_toolManager->setUp(m_toolBox, m_paletteManager, actionCollection());
-
-        Dock dock = stringToDock( element.attribute( "position" ).lower() );
-
-        mainWindow()->addDockWindow( m_toolBox, dock, false);
-        mainWindow()->moveDockWindow( m_toolBox, dock, false, 0, 0 );
-    }
-
-    return KXMLGUIBuilder::createContainer( parent, index, element, id );
-
-}
-
-void KisView::removeContainer( QWidget *container, QWidget *parent, QDomElement &element, int id )
-{
-    Q_ASSERT(container);
-
-    if( shell() && container == m_toolBox )
-    {
-        delete m_toolBox;
-        m_toolManager->youAintGotNoToolBox();
-    }
-    else {
-        KXMLGUIBuilder::removeContainer( container, parent, element, id );
-    }
-}
-
-KoPaletteManager * KisView::paletteManager()
-{
-    if (!m_paletteManager) {
-        m_paletteManager = new KoPaletteManager(this, actionCollection(), "Krita palette manager");
-        Q_CHECK_PTR(m_paletteManager);
-    }
-    return m_paletteManager;
-}
-
-void KisView::createLayerBox()
-{
-    m_layerBox = new KisLayerBox(this);
-    m_layerBox->setCaption(i18n("Layers"));
-
-    connect(m_layerBox, SIGNAL(sigRequestLayer(KisGroupLayerSP, KisLayerSP)),
-            this, SLOT(addLayer(KisGroupLayerSP, KisLayerSP)));
-    connect(m_layerBox, SIGNAL(sigRequestGroupLayer(KisGroupLayerSP, KisLayerSP)),
-            this, SLOT(addGroupLayer(KisGroupLayerSP, KisLayerSP)));
-    connect(m_layerBox, SIGNAL(sigRequestAdjustmentLayer(KisGroupLayerSP, KisLayerSP)),
-            this, SLOT(addAdjustmentLayer(KisGroupLayerSP, KisLayerSP)));
-    connect(m_layerBox, SIGNAL(sigRequestPartLayer(KisGroupLayerSP, KisLayerSP, const KoDocumentEntry&)),
-            this, SLOT(addPartLayer(KisGroupLayerSP, KisLayerSP, const KoDocumentEntry&)));
-    connect(m_layerBox, SIGNAL(sigRequestLayerProperties(KisLayerSP)),
-            this, SLOT(showLayerProperties(KisLayerSP)));
-    connect(m_layerBox, SIGNAL(sigOpacityChanged(int, bool)), this, SLOT(layerOpacity(int, bool)));
-    connect(m_layerBox, SIGNAL(sigOpacityFinishedChanging(int, int)),
-            this, SLOT(layerOpacityFinishedChanging(int, int)));
-    connect(m_layerBox, SIGNAL(sigItemComposite(const KisCompositeOp&)), this, SLOT(layerCompositeOp(const KisCompositeOp&)));
-
-    paletteManager()->addWidget(m_layerBox, "layerbox", krita::LAYERBOX, 0);
-
-}
-
-DCOPObject* KisView::dcopObject()
-{
-    if (!m_dcop) {
-        m_dcop = new KisViewIface(this);
-        Q_CHECK_PTR(m_dcop);
-    }
-    return m_dcop;
-}
-
-void KisView::setupScrollBars()
-{
-    m_scrollX = 0;
-    m_scrollY = 0;
-    m_vScroll = new QScrollBar(QScrollBar::Vertical, this);
-    Q_CHECK_PTR(m_vScroll);
-
-    m_hScroll = new QScrollBar(QScrollBar::Horizontal, this);
-    Q_CHECK_PTR(m_hScroll);
-
-    m_vScroll->setGeometry(width() - 16, 20, 16, height() - 36);
-    m_hScroll->setGeometry(20, height() - 16, width() - 36, 16);
-    m_hScroll->setValue(0);
-    m_vScroll->setValue(0);
-    QObject::connect(m_vScroll, SIGNAL(valueChanged(int)), this, SLOT(scrollV(int)));
-    QObject::connect(m_hScroll, SIGNAL(valueChanged(int)), this, SLOT(scrollH(int)));
-}
-
-void KisView::setupRulers()
-{
-    m_hRuler = new KisRuler(Qt::Horizontal, this);
-    Q_CHECK_PTR(m_hRuler);
-
-    m_vRuler = new KisRuler(Qt::Vertical, this);
-    Q_CHECK_PTR(m_vRuler);
-
-    m_hRuler->setGeometry(20, 0, width() - 20, 20);
-    m_vRuler->setGeometry(0, 20, 20, height() - 20);
-
-    if (statusBar()) {
-        m_hRuler->installEventFilter(this);
-        m_vRuler->installEventFilter(this);
-    }
-}
-
-#define EPSILON 1e-6
-
-void KisView::updateStatusBarZoomLabel ()
-{
-    if (zoom() < 1 - EPSILON) {
-        m_statusBarZoomLabel->setText(i18n("Zoom %1%").arg(zoom() * 100, 0, 'g', 4));
-    } else {
-        m_statusBarZoomLabel->setText(i18n("Zoom %1%").arg(zoom() * 100, 0, 'f', 0));
-    }
-    m_statusBarZoomLabel->setMaximumWidth(m_statusBarZoomLabel->fontMetrics().width(i18n("Zoom %1%").arg("0.8888  ")));
-}
-
-void KisView::updateStatusBarSelectionLabel()
-{
-    if (m_statusBarSelectionLabel == 0) {
-        return;
-    }
-
-    KisImageSP img = currentImg();
-    if (img) {
-        KisPaintDeviceSP dev = img->activeDevice();
-        if (dev) {
-            if (dev->hasSelection()) {
-                QRect r = dev->selection()->selectedExactRect();
-                m_statusBarSelectionLabel->setText( i18n("Selection Active: x = %1 y = %2 width = %3 height = %4").arg(r.x()).arg(r.y()).arg( r.width()).arg( r.height()));
-                return;
-            }
-        }
-    }
-
-    m_statusBarSelectionLabel->setText(i18n("No Selection"));
-}
-
-void KisView::updateStatusBarProfileLabel()
-{
-    if (m_statusBarProfileLabel == 0) {
-        return;
-    }
-
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    if (img->getProfile() == 0) {
-        m_statusBarProfileLabel->setText(i18n("No profile"));
-    }
-    else {
-        m_statusBarProfileLabel->setText(img->colorSpace()->id().name() + "  " + img->getProfile()->productName());
-    }
-}
-
-
-KisProfile *  KisView::monitorProfile()
-{
-    if (m_monitorProfile == 0) {
-        resetMonitorProfile();
-    }
-    return m_monitorProfile;
-}
-
-
-void KisView::resetMonitorProfile()
-{
-    m_monitorProfile = KisProfile::getScreenProfile();
-
-    if (m_monitorProfile == 0) {
-        KisConfig cfg;
-        QString monitorProfileName = cfg.monitorProfile();
-        m_monitorProfile = KisMetaRegistry::instance()->csRegistry()->getProfileByName(monitorProfileName);
-    }
-
-}
-
-void KisView::setupStatusBar()
-{
-    KStatusBar *sb = statusBar();
-
-    if (sb) {
-        m_statusBarZoomLabel = new QLabel(sb);
-        addStatusBarItem(m_statusBarZoomLabel,1);
-        updateStatusBarZoomLabel();
-
-        m_statusBarSelectionLabel = new KSqueezedTextLabel(sb);
-        addStatusBarItem(m_statusBarSelectionLabel,2);
-        updateStatusBarSelectionLabel();
-
-        m_statusBarProfileLabel = new KSqueezedTextLabel(sb);
-        addStatusBarItem(m_statusBarProfileLabel,3);
-        updateStatusBarProfileLabel();
-
-        //int height = m_statusBarProfileLabel->height();
-
-        m_progress = new KisLabelProgress(this);
-        m_progress->setMaximumWidth(225);
-        m_progress->setMinimumWidth(225);
-        m_progress->setMaximumHeight(fontMetrics().height() );
-        addStatusBarItem(m_progress, 2, true);
-
-        m_progress->hide();
-    }
-}
-
-void KisView::setupActions()
-{
-    KisConfig cfg;
-
-    m_selectionManager->setup(actionCollection());
-    m_filterManager->setup(actionCollection());
-    m_gridManager->setup(actionCollection());
-    m_perspectiveGridManager->setup(actionCollection());
-
-
-    m_fullScreen = KStdAction::fullScreen( NULL, NULL, actionCollection(), this );
-    connect( m_fullScreen, SIGNAL( toggled( bool )), this, SLOT( slotUpdateFullScreen( bool )));
-
-    m_imgProperties = new KAction(i18n("Image Properties"), 0, this, SLOT(slotImageProperties()), actionCollection(), "img_properties");
-    m_imgScan = 0; // How the hell do I get a KAction to the scan plug-in?!?
-    m_imgResizeToLayer = new KAction(i18n("Resize Image to Size of Current Layer"), 0, this, SLOT(imgResizeToActiveLayer()), actionCollection(), "resizeimgtolayer");
-
-    // view actions
-    m_zoomIn = KStdAction::zoomIn(this, SLOT(slotZoomIn()), actionCollection(), "zoom_in");
-    m_zoomOut = KStdAction::zoomOut(this, SLOT(slotZoomOut()), actionCollection(), "zoom_out");
-    m_actualPixels = new KAction(i18n("Actual Pixels"), "Ctrl+0", this, SLOT(slotActualPixels()), actionCollection(), "actual_pixels");
-    m_actualSize = KStdAction::actualSize(this, SLOT(slotActualSize()), actionCollection(), "actual_size");
-    m_actualSize->setEnabled(false);
-    m_fitToCanvas = KStdAction::fitToPage(this, SLOT(slotFitToCanvas()), actionCollection(), "fit_to_canvas");
-
-    // layer actions
-    m_layerAdd = new KAction(i18n("&Add..."), "Ctrl+Shift+N", this, SLOT(layerAdd()), actionCollection(), "insert_layer");
-
-    m_actionPartLayer = new KoPartSelectAction( i18n( "&Object Layer" ), "frame_query",
-                                                    this, SLOT( addPartLayer() ),
-                                                    actionCollection(), "insert_part_layer" );
-
-
-    m_actionAdjustmentLayer = new KAction( i18n( "&Adjustment Layer" ), 0,
-            this, SLOT( addAdjustmentLayer() ),
-            actionCollection(), "insert_adjustment_layer" );
-
-
-    m_layerRm = new KAction(i18n("&Remove"), 0, this, SLOT(layerRemove()), actionCollection(), "remove_layer");
-    m_layerDup = new KAction(i18n("Duplicate"), 0, this, SLOT(layerDuplicate()), actionCollection(), "duplicate_layer");
-    m_layerHide = new KAction(i18n("&Hide/Show"), 0, this, SLOT(layerToggleVisible()), actionCollection(), "hide_layer");
-    m_layerRaise = new KAction(i18n("Raise"), "raise", "Ctrl+]", this, SLOT(layerRaise()), actionCollection(), "raiselayer");
-    m_layerLower = new KAction(i18n("Lower"), "lower", "Ctrl+[", this, SLOT(layerLower()), actionCollection(), "lowerlayer");
-    m_layerTop = new KAction(i18n("To Top"), "bring_forward", "Ctrl+Shift+]", this, SLOT(layerFront()), actionCollection(), "toplayer");
-    m_layerBottom = new KAction(i18n("To Bottom"), "send_backward", "Ctrl+Shift+[", this, SLOT(layerBack()), actionCollection(), "bottomlayer");
-    m_layerProperties = new KAction(i18n("Properties"), 0, this, SLOT(layerProperties()), actionCollection(), "layer_properties");
-    (void)new KAction(i18n("I&nsert Image as Layer..."), 0, this, SLOT(slotInsertImageAsLayer()), actionCollection(), "insert_image_as_layer");
-    m_layerSaveAs = new KAction(i18n("Save Layer as Image..."), "filesave", this, SLOT(saveLayerAsImage()), actionCollection(), "save_layer_as_image");
-    (void)new KAction(i18n("Flip on &X Axis"), "view_left_right", 0, this, SLOT(mirrorLayerX()), actionCollection(), "mirrorLayerX");
-    (void)new KAction(i18n("Flip on &Y Axis"), "view_top_bottom", 0, this, SLOT(mirrorLayerY()), actionCollection(), "mirrorLayerY");
-
-    m_createMask = new KAction(i18n("Create Mask"), 0, this,
-                               SLOT(slotCreateMask()), actionCollection(), "create_mask");
-    m_maskFromSelection = new KAction(i18n("Mask From Selection"), 0, this,
-                                      SLOT(slotMaskFromSelection()), actionCollection(),
-                                      "mask_fromsel");
-    m_maskToSelection = new KAction(i18n("Mask to Selection"), 0, this,
-                               SLOT(slotMaskToSelection()), actionCollection(), "mask_tosel");
-    m_applyMask = new KAction(i18n("Apply Mask"), 0, this, SLOT(slotApplyMask()),
-                              actionCollection(), "apply_mask");
-    m_removeMask = new KAction(i18n("Remove Mask"), 0, this,
-                               SLOT(slotRemoveMask()), actionCollection(), "remove_mask");
-    m_showMask = new KToggleAction(i18n( "Show Mask" ), 0, this,
-                                   SLOT(slotShowMask()), actionCollection(), "show_mask");
-    m_editMask = new KToggleAction(i18n( "Edit Mask" ), 0, this,
-                                   SLOT(slotEditMask()), actionCollection(), "edit_mask");
-
-    // image actions
-    m_imgFlatten = new KAction(i18n("&Flatten Image"), "Ctrl+Shift+E", this, SLOT(flattenImage()), actionCollection(), "flatten_image");
-    m_imgMergeLayer = new KAction(i18n("&Merge with Layer Below"), "Ctrl+E", this, SLOT(mergeLayer()), actionCollection(), "merge_layer");
-
-    // setting actions
-    KStdAction::preferences(this, SLOT(preferences()), actionCollection(), "preferences");
-
-    m_RulerAction = new KToggleAction( i18n( "Show Rulers" ), "Ctrl+R", this, SLOT( showRuler() ), actionCollection(), "view_ruler" );
-    m_RulerAction->setChecked(cfg.showRulers());
-    m_RulerAction->setCheckedState(i18n("Hide Rulers"));
-    m_RulerAction->setWhatsThis( i18n("The rulers show the horizontal and vertical positions of the mouse on the image "
-                                      "and can be used to position your mouse at the right place on the canvas. <p>Uncheck this to disable "
-                                      "the rulers from being displayed." ) );
-
-    //m_guideAction = new KToggleAction( i18n( "Guide Lines" ), 0, this, SLOT( viewGuideLines() ), actionCollection(), "view_guidelines" );
-
-    // Add new palette
-    new KAction(i18n("Add New Palette..."), 0, this, SLOT(slotAddPalette()),
-                actionCollection(), "add_palette");
-    new KAction(i18n("Edit Palette..."), 0, this, SLOT(slotEditPalette()),
-                actionCollection(), "edit_palette");
-
-    // XXX: This triggers a repaint of the image, but way too early
-    //showRuler();
-
-}
-
-void KisView::resizeEvent(QResizeEvent *)
-{
-    if (!m_paintViewEnabled) {
-        startInitialZoomTimerIfReady();
-    }
-
-    KisImageSP img = currentImg();
-    Q_INT32 scrollBarExtent = style().pixelMetric(QStyle::PM_ScrollBarExtent);
-    Q_INT32 drawH;
-    Q_INT32 drawW;
-    Q_INT32 docW;
-    Q_INT32 docH;
-
-//    if (img) {
-//        KisGuideMgr *mgr = img->guides();
-//        mgr->resize(size());
-//    }
-
-    docW = static_cast<Q_INT32>(ceil(docWidth() * zoom()));
-    docH = static_cast<Q_INT32>(ceil(docHeight() * zoom()));
-
-    m_rulerThickness = m_RulerAction->isChecked() ? RULER_THICKNESS : 0;
-    drawH = height() - m_rulerThickness;
-    drawW = width() - m_rulerThickness;
-
-    if (drawH < docH) {
-        // Will need vert scrollbar
-        drawW -= scrollBarExtent;
-        if (drawW < docW)
-            // Will need horiz scrollbar
-            drawH -= scrollBarExtent;
-    } else if (drawW < docW) {
-        // Will need horiz scrollbar
-        drawH -= scrollBarExtent;
-        if (drawH < docH)
-            // Will need vert scrollbar
-            drawW -= scrollBarExtent;
-    }
-
-    m_vScroll->setEnabled(docH > drawH);
-    m_hScroll->setEnabled(docW > drawW);
-
-    if (docH <= drawH && docW <= drawW) {
-        // we need no scrollbars
-        m_vScroll->hide();
-        m_hScroll->hide();
-        m_vScroll->setValue(0);
-        m_hScroll->setValue(0);
-        m_vScrollBarExtent = 0;
-        m_hScrollBarExtent = 0;
-    } else if (docH <= drawH) {
-        // we need a horizontal scrollbar only
-        m_vScroll->hide();
-        m_vScroll->setValue(0);
-        m_hScroll->setRange(0, docW - drawW);
-        m_hScroll->setGeometry(m_rulerThickness,
-                     height() - scrollBarExtent,
-                     width() - m_rulerThickness,
-                     scrollBarExtent);
-        m_hScroll->show();
-        m_hScrollBarExtent = scrollBarExtent;
-        m_hScrollBarExtent = scrollBarExtent;
-    } else if(docW <= drawW) {
-        // we need a vertical scrollbar only
-        m_hScroll->hide();
-        m_hScroll->setValue(0);
-        m_vScroll->setRange(0, docH - drawH);
-        m_vScroll->setGeometry(width() - scrollBarExtent, m_rulerThickness, scrollBarExtent, height()  - m_rulerThickness);
-        m_vScroll->show();
-        m_vScrollBarExtent = scrollBarExtent;
-    } else {
-        // we need both scrollbars
-        m_vScroll->setRange(0, docH - drawH);
-        m_vScroll->setGeometry(width() - scrollBarExtent,
-                    m_rulerThickness,
-                    scrollBarExtent,
-                    height() -2* m_rulerThickness);
-        m_hScroll->setRange(0, docW - drawW);
-        m_hScroll->setGeometry(m_rulerThickness,
-                     height() - scrollBarExtent,
-                     width() - 2*m_rulerThickness,
-                     scrollBarExtent);
-        m_vScroll->show();
-        m_hScroll->show();
-        m_vScrollBarExtent = scrollBarExtent;
-        m_hScrollBarExtent = scrollBarExtent;
-    }
-
-    Q_INT32 oldCanvasXOffset = m_canvasXOffset;
-    Q_INT32 oldCanvasYOffset = m_canvasYOffset;
-
-    if (docW < drawW) {
-        m_canvasXOffset = (drawW - docW) / 2;
-    } else {
-        m_canvasXOffset = 0;
-    }
-
-    if (docH < drawH) {
-        m_canvasYOffset = (drawH - docH) / 2;
-    } else {
-        m_canvasYOffset = 0;
-    }
-
-    //Check if rulers are visible
-    if( m_RulerAction->isChecked() )
-        m_canvas->setGeometry(m_rulerThickness, m_rulerThickness, drawW, drawH);
-    else
-        m_canvas->setGeometry(0, 0, drawW, drawH);
-    m_canvas->show();
-
-    if (!m_canvas->isOpenGLCanvas()) {
-
-        if (m_canvasPixmap.size() != QSize(drawW, drawH)) {
-
-            Q_INT32 oldCanvasWidth = m_canvasPixmap.width();
-            Q_INT32 oldCanvasHeight = m_canvasPixmap.height();
-
-            Q_INT32 newCanvasWidth = drawW;
-            Q_INT32 newCanvasHeight = drawH;
-
-            QRegion exposedRegion = QRect(0, 0, newCanvasWidth, newCanvasHeight);
-
-            // Increase size first so that we can copy the old image area to the new one.
-            m_canvasPixmap.resize(QMAX(oldCanvasWidth, newCanvasWidth), QMAX(oldCanvasHeight, newCanvasHeight));
-
-            if (!m_canvasPixmap.isNull()) {
-
-                if (oldCanvasXOffset != m_canvasXOffset || oldCanvasYOffset != m_canvasYOffset) {
-
-                    Q_INT32 srcX;
-                    Q_INT32 srcY;
-                    Q_INT32 srcWidth;
-                    Q_INT32 srcHeight;
-                    Q_INT32 dstX;
-                    Q_INT32 dstY;
-
-                    if (oldCanvasXOffset <= m_canvasXOffset) {
-                        // Move to the right
-                        srcX = 0;
-                        dstX = m_canvasXOffset - oldCanvasXOffset;
-                        srcWidth = oldCanvasWidth;
-                    } else {
-                        // Move to the left
-                        srcX = oldCanvasXOffset - m_canvasXOffset;
-                        dstX = 0;
-                        srcWidth = newCanvasWidth;
-                    }
-
-                    if (oldCanvasYOffset <= m_canvasYOffset) {
-                        // Move down
-                        srcY = 0;
-                        dstY = m_canvasYOffset - oldCanvasYOffset;
-                        srcHeight = oldCanvasHeight;
-                    } else {
-                        // Move up
-                        srcY = oldCanvasYOffset - m_canvasYOffset;
-                        dstY = 0;
-                        srcHeight = newCanvasHeight;
-                    }
-
-                    bitBlt(&m_canvasPixmap, dstX, dstY, &m_canvasPixmap, srcX, srcY, srcWidth, srcHeight);
-                    exposedRegion -= QRegion(QRect(dstX, dstY, srcWidth, srcHeight));
-                } else {
-                    exposedRegion -= QRegion(QRect(0, 0, oldCanvasWidth, oldCanvasHeight));
-                }
-            }
-
-            m_canvasPixmap.resize(newCanvasWidth, newCanvasHeight);
-
-            if (!m_canvasPixmap.isNull() && !exposedRegion.isEmpty()) {
-
-                QMemArray<QRect> rects = exposedRegion.rects();
-
-                for (unsigned int i = 0; i < rects.count(); i++) {
-                    QRect r = rects[i];
-                    updateQPaintDeviceCanvas(viewToWindow(r));
-                }
-            }
-        }
-    }
-
-    int fontheight = QFontMetrics(KGlobalSettings::generalFont()).height() * 3;
-    m_vScroll->setPageStep(drawH);
-    m_vScroll->setLineStep(fontheight);
-    m_hScroll->setPageStep(drawW);
-    m_hScroll->setLineStep(fontheight);
-
-    m_hRuler->setGeometry(m_rulerThickness + m_canvasXOffset, 0, QMIN(docW, drawW), m_rulerThickness);
-    m_vRuler->setGeometry(0, m_rulerThickness + m_canvasYOffset, m_rulerThickness, QMIN(docH, drawH));
-
-    if (m_vScroll->isVisible())
-        m_vRuler->updateVisibleArea(0, m_vScroll->value());
-    else
-        m_vRuler->updateVisibleArea(0, 0);
-
-    if (m_hScroll->isVisible())
-        m_hRuler->updateVisibleArea(m_hScroll->value(), 0);
-    else
-        m_hRuler->updateVisibleArea(0, 0);
-
-    if( m_RulerAction->isChecked() )
-    {
-        m_hRuler->show();
-        m_vRuler->show();
-    }
-    else {
-        m_hRuler->hide();
-        m_vRuler->hide();
-    }
-
-    emit viewTransformationsChanged();
-}
-
-void KisView::styleChange(QStyle& oldStyle)
-{
-    Q_UNUSED(oldStyle);
-    m_canvas->updateGeometry();
-    refreshKisCanvas();
-}
-
-void KisView::paletteChange(const QPalette& oldPalette)
-{
-    Q_UNUSED(oldPalette);
-    refreshKisCanvas();
-}
-
-void KisView::showEvent(QShowEvent *)
-{
-    if (!m_showEventReceived) {
-        m_showEventReceived = true;
-        startInitialZoomTimerIfReady();
-    }
-}
-
-void KisView::updateReadWrite(bool readwrite)
-{
-    layerUpdateGUI(readwrite);
-}
-
-Q_INT32 KisView::horzValue() const
-{
-    return m_hScroll->value() - m_canvasXOffset;
-}
-
-Q_INT32 KisView::vertValue() const
-{
-    return m_vScroll->value() - m_canvasYOffset;
-}
-
-void KisView::updateQPaintDeviceCanvas(const QRect& imageRect)
-{
-    QRect vr = windowToView(imageRect);
-    vr &= QRect(0, 0, m_canvas->width(), m_canvas->height());
-
-    if (!vr.isEmpty()) {
-
-        QPainter gc;
-
-        if (gc.begin(&m_canvasPixmap)) {
-
-            KisImageSP img = currentImg();
-
-            if (img && m_paintViewEnabled) {
-
-                QRect wr = viewToWindow(vr);
-
-                if (wr.left() < 0 || wr.right() >= img->width() || wr.top() < 0 || wr.bottom() >= img->height()) {
-                    // Erase areas outside document
-                    QRegion rg(vr);
-                    rg -= QRegion(windowToView(QRect(0, 0, img->width(), img->height())));
-
-                    QMemArray<QRect> rects = rg.rects();
-
-                    for (unsigned int i = 0; i < rects.count(); i++) {
-                        QRect er = rects[i];
-                        gc.fillRect(er, colorGroup().mid());
-                    }
-                    wr &= QRect(0, 0, img->width(), img->height());
-                }
-
-                if (!wr.isEmpty()) {
-
-                    KisImage::PaintFlags paintFlags = (KisImage::PaintFlags)KisImage::PAINT_BACKGROUND;
-
-                    if (m_actLayerVis) {
-                        paintFlags = (KisImage::PaintFlags)(paintFlags|KisImage::PAINT_MASKINACTIVELAYERS);
-                    }
-
-                    if (m_selectionManager->displaySelection())
-                    {
-                        paintFlags = (KisImage::PaintFlags)(paintFlags|KisImage::PAINT_SELECTION);
-                    }
-
-                    if (zoom() > 1.0 - EPSILON) {
-
-                        gc.setWorldXForm(true);
-                        gc.translate(-horzValue(), -vertValue());
-                        gc.scale(zoomFactor(), zoomFactor());
-
-                        m_image->renderToPainter(wr.left(), wr.top(),
-                            wr.right(), wr.bottom(), gc, monitorProfile(),
-                            paintFlags, HDRExposure());
-                    } else {
-
-                        QRect canvasRect = windowToView(wr);
-                        QRect scaledImageRect = canvasRect;
-                        scaledImageRect.moveBy(horzValue(), vertValue());
-
-                        QSize scaledImageSize(static_cast<Q_INT32>(ceil(docWidth() * zoom())),
-                                            static_cast<Q_INT32>(ceil(docHeight() * zoom())));
-
-                        QImage image = m_image->convertToQImage(scaledImageRect, scaledImageSize,
-                                                                monitorProfile(), paintFlags, HDRExposure());
-
-                        gc.drawImage(canvasRect.topLeft(), image, image.rect());
-
-                        // Set up for the grid drawer.
-                        gc.setWorldXForm(true);
-                        gc.translate(-horzValue(), -vertValue());
-                        gc.scale(zoomFactor(), zoomFactor());
-                    }
-
-                    m_gridManager->drawGrid( wr, &gc );
-                    m_perspectiveGridManager->drawGrid( wr, &gc );
-                }
-//                    paintGuides();
-            } else {
-                gc.fillRect(vr, colorGroup().mid());
-            }
-        }
-    }
-}
-
-void KisView::paintQPaintDeviceView(const QRegion& canvasRegion)
-{
-    Q_ASSERT(m_canvas->QPaintDeviceWidget() != 0);
-
-    if (m_canvas->QPaintDeviceWidget() != 0 && !m_canvasPixmap.isNull()) {
-        QMemArray<QRect> rects = canvasRegion.rects();
-
-        for (unsigned int i = 0; i < rects.count(); i++) {
-            QRect r = rects[i];
-
-            bitBlt(m_canvas->QPaintDeviceWidget(), r.x(), r.y(), &m_canvasPixmap,
-                   r.x(), r.y(), r.width(), r.height());
-        }
-
-        paintToolOverlay(canvasRegion);
-    }
-}
-
-void KisView::updateOpenGLCanvas(const QRect& imageRect)
-{
-#ifdef HAVE_GL
-    KisImageSP img = currentImg();
-
-    if (img && m_paintViewEnabled) {
-        Q_ASSERT(m_OpenGLImageContext != 0);
-
-        if (m_OpenGLImageContext != 0) {
-            m_OpenGLImageContext->update(imageRect);
-        }
-    }
-#else
-    Q_UNUSED(imageRect);
-#endif
-}
-
-void KisView::paintOpenGLView(const QRect& canvasRect)
-{
-#ifdef HAVE_GL
-    if (!m_canvas->isUpdatesEnabled()) {
-        return;
-    }
-
-    m_canvas->OpenGLWidget()->makeCurrent();
-
-    glDrawBuffer(GL_BACK);
-
-    QColor widgetBackgroundColor = colorGroup().mid();
-
-    glClearColor(widgetBackgroundColor.red() / 255.0, widgetBackgroundColor.green() / 255.0, widgetBackgroundColor.blue() / 255.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    KisImageSP img = currentImg();
-
-    if (img && m_paintViewEnabled) {
-
-        QRect vr = canvasRect;
-        vr &= QRect(0, 0, m_canvas->width(), m_canvas->height());
-
-        if (!vr.isNull()) {
-
-            glMatrixMode(GL_PROJECTION);
-            glLoadIdentity();
-            glViewport(0, 0, m_canvas->width(), m_canvas->height());
-            glOrtho(0, m_canvas->width(), m_canvas->height(), 0, -1, 1);
-
-            glMatrixMode(GL_MODELVIEW);
-            glLoadIdentity();
-
-            glBindTexture(GL_TEXTURE_2D, m_OpenGLImageContext->backgroundTexture());
-
-            glTranslatef(m_canvasXOffset, m_canvasYOffset, 0.0);
-
-            glEnable(GL_TEXTURE_2D);
-            glBegin(GL_QUADS);
-
-            glTexCoord2f(0.0, 0.0);
-            glVertex2f(0.0, 0.0);
-
-            glTexCoord2f((img->width() * zoom()) / KisOpenGLImageContext::BACKGROUND_TEXTURE_WIDTH, 0.0);
-            glVertex2f(img->width() * zoom(), 0.0);
-
-            glTexCoord2f((img->width() * zoom()) / KisOpenGLImageContext::BACKGROUND_TEXTURE_WIDTH,
-                         (img->height() * zoom()) / KisOpenGLImageContext::BACKGROUND_TEXTURE_HEIGHT);
-            glVertex2f(img->width() * zoom(), img->height() * zoom());
-
-            glTexCoord2f(0.0, (img->height() * zoom()) / KisOpenGLImageContext::BACKGROUND_TEXTURE_HEIGHT);
-            glVertex2f(0.0, img->height() * zoom());
-
-            glEnd();
-
-            glTranslatef(-m_canvasXOffset, -m_canvasYOffset, 0.0);
-
-            glTranslatef(-horzValue(), -vertValue(), 0.0);
-            glScalef(zoomFactor(), zoomFactor(), 1.0);
-
-            glEnable(GL_BLEND);
-            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-
-            QRect wr = viewToWindow(QRect(0, 0, m_canvas->width(), m_canvas->height()));
-            wr &= QRect(0, 0, img->width(), img->height());
-
-            m_OpenGLImageContext->setHDRExposure(HDRExposure());
-
-            m_canvas->OpenGLWidget()->makeCurrent();
-
-            for (int x = (wr.left() / m_OpenGLImageContext->imageTextureTileWidth()) * m_OpenGLImageContext->imageTextureTileWidth();
-                  x <= wr.right();
-                  x += m_OpenGLImageContext->imageTextureTileWidth()) {
-                for (int y = (wr.top() / m_OpenGLImageContext->imageTextureTileHeight()) * m_OpenGLImageContext->imageTextureTileHeight();
-                      y <= wr.bottom();
-                      y += m_OpenGLImageContext->imageTextureTileHeight()) {
-
-                    glBindTexture(GL_TEXTURE_2D, m_OpenGLImageContext->imageTextureTile(x, y));
-
-                    glBegin(GL_QUADS);
-
-                    glTexCoord2f(0.0, 0.0);
-                    glVertex2f(x, y);
-
-                    glTexCoord2f(1.0, 0.0);
-                    glVertex2f(x + m_OpenGLImageContext->imageTextureTileWidth(), y);
-
-                    glTexCoord2f(1.0, 1.0);
-                    glVertex2f(x + m_OpenGLImageContext->imageTextureTileWidth(), y + m_OpenGLImageContext->imageTextureTileHeight());
-
-                    glTexCoord2f(0.0, 1.0);
-                    glVertex2f(x, y + m_OpenGLImageContext->imageTextureTileHeight());
-
-                    glEnd();
-                }
-            }
-
-            glDisable(GL_TEXTURE_2D);
-            glDisable(GL_BLEND);
-
-            m_gridManager->drawGrid(wr, 0, true);
-            m_perspectiveGridManager->drawGrid( wr, 0, true );
-
-            // Unbind the texture otherwise the ATI driver crashes when the canvas context is
-            // made current after the textures are deleted following an image resize.
-            glBindTexture(GL_TEXTURE_2D, 0);
-
-            //paintGuides();
-        }
-    }
-
-    m_canvas->OpenGLWidget()->swapBuffers();
-
-    paintToolOverlay(QRegion(canvasRect));
-
-#else
-    Q_UNUSED(canvasRect);
-#endif
-}
-
-void KisView::setInputDevice(KisInputDevice inputDevice)
-{
-    if (inputDevice != m_inputDevice) {
-        m_inputDevice = inputDevice;
-
-        m_toolManager->setToolForInputDevice(m_inputDevice, inputDevice);
-
-        if (m_toolManager->currentTool() == 0) {
-            m_toolManager->setCurrentTool(m_toolManager->findTool("tool_brush", m_inputDevice));
-        }
-        else {
-            m_toolManager->setCurrentTool(m_toolManager->currentTool());
-        }
-        m_toolManager->activateCurrentTool();
-
-        emit sigInputDeviceChanged(inputDevice);
-    }
-
-}
-
-KisInputDevice KisView::currentInputDevice() const
-{
-    return m_inputDevice;
-}
-
-
-KisCanvas *KisView::kiscanvas() const
-{
-    return m_canvas;
-}
-
-void KisView::updateCanvas()
-{
-    if (m_image) {
-        updateCanvas(m_image->bounds());
-    }
-}
-
-void KisView::updateCanvas(Q_INT32 x, Q_INT32 y, Q_INT32 w, Q_INT32 h)
-{
-    updateCanvas(QRect(x, y, w, h));
-}
-
-void KisView::updateCanvas(const QRect& imageRect)
-{
-    if (m_canvas->isOpenGLCanvas()) {
-        updateOpenGLCanvas(imageRect);
-        paintOpenGLView(windowToView(imageRect));
-    } else {
-        updateQPaintDeviceCanvas(imageRect);
-        //m_canvas->update(windowToView(imageRect));
-        m_canvas->repaint(windowToView(imageRect));
-    }
-}
-
-void KisView::refreshKisCanvas()
-{
-    QRect imageRect = viewToWindow(QRect(0, 0, m_canvas->width(), m_canvas->height()));
-
-    if (m_image) {
-        imageRect |= m_image->bounds();
-    }
-
-    updateCanvas(imageRect);
-
-    // Enable this if updateCanvas does an m_canvas->update()
-    //m_canvas->repaint();
-}
-
-void KisView::selectionDisplayToggled(bool displaySelection)
-{
-#ifdef HAVE_GL
-    if (m_canvas->isOpenGLCanvas()) {
-        if (m_OpenGLImageContext) {
-            m_OpenGLImageContext->setSelectionDisplayEnabled(displaySelection);
-        }
-    }
-#else
-    Q_UNUSED(displaySelection);
-#endif
-    updateCanvas();
-}
-
-void KisView::layerUpdateGUI(bool enable)
-{
-    KisImageSP img = currentImg();
-
-    KisLayerSP layer;
-    Q_INT32 nlayers = 0;
-    Q_INT32 nvisible = 0;
-
-
-
-    if (img) {
-        layer = img->activeLayer();
-        nlayers = img->nlayers();
-        nvisible = nlayers - img->nHiddenLayers();
-    }
-
-    KisPaintLayer * pl = dynamic_cast<KisPaintLayer*>(layer.data());
-
-    if (pl && ( m_currentColorChooserDisplay != KisID("BLA") ||
-                pl->paintDevice()->colorSpace()->id() != m_currentColorChooserDisplay)) {
-        if (pl->paintDevice()->colorSpace()->id() == KisID("WET")) {
-            m_paletteManager->hideWidget( "hsvwidget" );
-            m_paletteManager->hideWidget( "rgbwidget" );
-            m_paletteManager->hideWidget( "graywidget" );
-            m_paletteManager->hideWidget( "palettewidget" );
-            m_paletteManager->showWidget( "watercolor docker" );
-        }
-        else {
-            m_paletteManager->hideWidget( "watercolor docker" );
-            m_paletteManager->showWidget( "palettewidget" );
-            m_paletteManager->showWidget( "graywidget" );
-            m_paletteManager->showWidget( "rgbwidget" );
-            m_paletteManager->showWidget( "hsvwidget" );
-        }
-        m_currentColorChooserDisplay = pl->paintDevice()->colorSpace()->id();
-    }
-
-    enable = enable && img && layer && layer->visible() && !layer->locked();
-    m_layerDup->setEnabled(enable);
-    m_layerRm->setEnabled(enable);
-    m_layerHide->setEnabled(img && layer);
-    m_layerProperties->setEnabled(enable);
-    m_layerSaveAs->setEnabled(enable);
-    m_layerRaise->setEnabled(enable && layer->prevSibling());
-    m_layerLower->setEnabled(enable && layer->nextSibling());
-    m_layerTop->setEnabled(enable && nlayers > 1 && layer != img->rootLayer()->firstChild());
-    m_layerBottom->setEnabled(enable && nlayers > 1 && layer != img->rootLayer()->lastChild());
-
-    // XXX these should be named layer instead of img
-    m_imgFlatten->setEnabled(nlayers > 1);
-    m_imgMergeLayer->setEnabled(nlayers > 1 && layer && layer->nextSibling());
-
-
-    m_selectionManager->updateGUI();
-    m_filterManager->updateGUI();
-    m_toolManager->updateGUI();
-    m_gridManager->updateGUI();
-    m_perspectiveGridManager->updateGUI();
-
-
-    KisPartLayer * partLayer = dynamic_cast<KisPartLayer*>(layer.data());
-    if (partLayer) {
-        setCanvasCursor( KisCursor::arrowCursor() );
-    }
-
-    if (img && img->activeDevice())
-        emit currentColorSpaceChanged(img->activeDevice()->colorSpace());
-
-    imgUpdateGUI();
-}
-
-
-void KisView::imgUpdateGUI()
-{
-    KisImageSP img = currentImg();
-
-    m_imgResizeToLayer->setEnabled(img && img->activeLayer());
-
-    updateStatusBarProfileLabel();
-}
-
-static const double zoomLevels[] = {
-    1.0 / 500,
-    1.0 / 333.333333,
-    1.0 / 250,
-    1.0 / 200,
-    1.0 / 150,
-    1.0 / 100,
-    1.0 / 66.666667,
-    1.0 / 50,
-    1.0 / 33.333333,
-    1.0 / 25,
-    1.0 / 20,
-    1.0 / 16,
-    1.0 / 12,
-    1.0 / 8,
-    1.0 / 6,
-    1.0 / 4,
-    1.0 / 3,
-    1.0 / 2,
-    1.0 / 1.5,
-    1,
-    2,
-    3,
-    4,
-    5,
-    6,
-    7,
-    8,
-    12,
-    16
-};
-
-#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
-#define NUM_ZOOM_LEVELS ARRAY_SIZE(zoomLevels)
-
-#define FIRST_ZOOM_LEVEL_INDEX 0
-#define LAST_ZOOM_LEVEL_INDEX (NUM_ZOOM_LEVELS - 1)
-
-#define KISVIEW_MIN_ZOOM (zoomLevels[FIRST_ZOOM_LEVEL_INDEX])
-#define KISVIEW_MAX_ZOOM (zoomLevels[LAST_ZOOM_LEVEL_INDEX])
-
-double KisView::nextZoomInLevel() const
-{
-    uint zoomLevelIndex = FIRST_ZOOM_LEVEL_INDEX;
-
-    while (zoom() >= zoomLevels[zoomLevelIndex] && zoomLevelIndex < LAST_ZOOM_LEVEL_INDEX) {
-        zoomLevelIndex++;
-    }
-
-    return zoomLevels[zoomLevelIndex];
-}
-
-double KisView::nextZoomOutLevel(double zoomLevel) const
-{
-    int zoomLevelIndex = LAST_ZOOM_LEVEL_INDEX;
-
-    while (zoomLevel <= zoomLevels[zoomLevelIndex] && zoomLevelIndex > FIRST_ZOOM_LEVEL_INDEX) {
-        zoomLevelIndex--;
-    }
-
-    return zoomLevels[zoomLevelIndex];
-}
-
-double KisView::nextZoomOutLevel() const
-{
-    return nextZoomOutLevel(zoom());
-}
-
-void KisView::zoomAroundPoint(double x, double y, double zf)
-{
-    // Disable updates while we change the scrollbar settings.
-    m_canvas->setUpdatesEnabled(false);
-    m_hScroll->setUpdatesEnabled(false);
-    m_vScroll->setUpdatesEnabled(false);
-
-    if (x < 0 || y < 0) {
-        // Zoom about the centre of the current display
-        KisImageSP img = currentImg();
-
-        if (img) {
-            if (m_hScroll->isVisible()) {
-                KisPoint c = viewToWindow(KisPoint(m_canvas->width() / 2.0, m_canvas->height() / 2.0));
-                x = c.x();
-            }
-            else {
-                x = img->width() / 2.0;
-            }
-
-            if (m_vScroll->isVisible()) {
-                KisPoint c = viewToWindow(KisPoint(m_canvas->width() / 2.0, m_canvas->height() / 2.0));
-                y = c.y();
-            }
-            else {
-                y = img->height() / 2.0;
-            }
-        }
-        else {
-            x = 0;
-            y = 0;
-        }
-    }
-
-    setZoom(zf);
-
-    Q_ASSERT(m_zoomIn);
-    Q_ASSERT(m_zoomOut);
-
-    updateStatusBarZoomLabel ();
-
-    m_zoomIn->setEnabled(zf < KISVIEW_MAX_ZOOM);
-    m_zoomOut->setEnabled(zf > KISVIEW_MIN_ZOOM);
-    resizeEvent(0);
-
-    m_hRuler->setZoom(zf);
-    m_vRuler->setZoom(zf);
-
-    if (m_hScroll->isVisible()) {
-        double vcx = m_canvas->width() / 2.0;
-        Q_INT32 scrollX = qRound(x * zoom() - vcx);
-        m_hScroll->setValue(scrollX);
-    }
-
-    if (m_vScroll->isVisible()) {
-        double vcy = m_canvas->height() / 2.0;
-        Q_INT32 scrollY = qRound(y * zoom() - vcy);
-        m_vScroll->setValue(scrollY);
-    }
-
-    // Now update everything.
-    m_canvas->setUpdatesEnabled(true);
-    m_hScroll->setUpdatesEnabled(true);
-    m_vScroll->setUpdatesEnabled(true);
-    m_hScroll->update();
-    m_vScroll->update();
-
-    if (m_canvas->isOpenGLCanvas()) {
-        paintOpenGLView(QRect(0, 0, m_canvas->width(), m_canvas->height()));
-    } else {
-        refreshKisCanvas();
-    }
-
-    emit viewTransformationsChanged();
-}
-
-void KisView::zoomTo(const KisRect& r)
-{
-    if (!r.isNull()) {
-
-        double wZoom = fabs(m_canvas->width() / r.width());
-        double hZoom = fabs(m_canvas->height() / r.height());
-
-        double zf = kMin(wZoom, hZoom);
-
-        if (zf < KISVIEW_MIN_ZOOM) {
-            zf = KISVIEW_MIN_ZOOM;
-        }
-        else
-            if (zf > KISVIEW_MAX_ZOOM) {
-                zf = KISVIEW_MAX_ZOOM;
-            }
-
-        zoomAroundPoint(r.center().x(), r.center().y(), zf);
-    }
-}
-
-void KisView::zoomTo(const QRect& r)
-{
-    zoomTo(KisRect(r));
-}
-
-void KisView::zoomTo(Q_INT32 x, Q_INT32 y, Q_INT32 w, Q_INT32 h)
-{
-    zoomTo(KisRect(x, y, w, h));
-}
-
-void KisView::zoomIn(Q_INT32 x, Q_INT32 y)
-{
-    zoomAroundPoint(x, y, nextZoomInLevel());
-}
-
-void KisView::zoomOut(Q_INT32 x, Q_INT32 y)
-{
-    zoomAroundPoint(x, y, nextZoomOutLevel());
-}
-
-void KisView::zoomIn()
-{
-    slotZoomIn();
-}
-
-void KisView::zoomOut()
-{
-    slotZoomOut();
-}
-
-void KisView::slotZoomIn()
-{
-    zoomIn(-1, -1);
-}
-
-void KisView::slotZoomOut()
-{
-    zoomOut(-1, -1);
-}
-
-void KisView::slotActualPixels()
-{
-    zoomAroundPoint(-1, -1, 1.0);
-}
-
-void KisView::slotActualSize()
-{
-    //XXX later this should be update to take screen res and image res into consideration
-    zoomAroundPoint(-1, -1, 1.0);
-}
-
-double KisView::fitToCanvasZoomLevel() const
-{
-    int fullCanvasWidth = width();
-
-    if (m_vRuler->isVisible()) {
-        fullCanvasWidth -= m_vRuler->width();
-    }
-
-    int fullCanvasHeight = height();
-
-    if (m_hRuler->isVisible()) {
-        fullCanvasHeight -= m_hRuler->height();
-    }
-
-    KisImageSP img = currentImg();
-    if (img) {
-        double xZoomLevel = static_cast<double>(fullCanvasWidth) / img->width();
-        double yZoomLevel = static_cast<double>(fullCanvasHeight) / img->height();
-
-        return QMIN(xZoomLevel, yZoomLevel);
-    }
-    else {
-        return 1;
-    }
-}
-
-void KisView::slotFitToCanvas()
-{
-    zoomAroundPoint(-1, -1, fitToCanvasZoomLevel());
-}
-
-void KisView::setInitialZoomLevel()
-{
-    double zoomLevel = fitToCanvasZoomLevel();
-
-    if (zoomLevel > 1) {
-        zoomLevel = 1;
-    } else {
-        zoomLevel = nextZoomOutLevel(zoomLevel);
-    }
-
-    zoomAroundPoint(-1, -1, zoomLevel);
-}
-
-void KisView::imgResizeToActiveLayer()
-{
-    KisImageSP img = currentImg();
-    KisLayerSP layer;
-
-    if (img && (layer = img->activeLayer())) {
-
-        if (m_adapter && m_adapter->undo()) {
-            m_adapter->beginMacro(i18n("Resize Image to Size of Current Layer"));
-        }
-
-        img->lock();
-
-        QRect r = layer->exactBounds();
-        img->resize(r.width(), r.height(), r.x(), r.y(), true);
-
-        img->unlock();
-
-        if (m_adapter && m_adapter->undo()) {
-            m_adapter->endMacro();
-        }
-    }
-}
-
-void KisView::slotImageProperties()
-{
-    KisImageSP img = currentImg();
-
-    if (!img) return;
-
-    KisDlgImageProperties dlg(img, this);
-
-    if (dlg.exec() == QDialog::Accepted) {
-        if (dlg.imageWidth() != img->width() ||
-            dlg.imageHeight() != img->height()) {
-
-            resizeCurrentImage(dlg.imageWidth(),
-                               dlg.imageHeight());
-        }
-        Q_INT32 opacity = dlg.opacity();
-        opacity = opacity * 255 / 100;
-        img->setName(dlg.imageName());
-        img->setColorSpace(dlg.colorSpace());
-        img->setResolution(dlg.resolution(), dlg.resolution());
-        img->setDescription(dlg.description());
-        img->setProfile(dlg.profile());
-    }
-}
-
-void KisView::slotInsertImageAsLayer()
-{
-    if (importImage() > 0)
-        m_doc->setModified(true);
-}
-
-void KisView::slotAddPalette()
-{
-    KDialogBase* base = new KDialogBase(this, 0, true, i18n("Add Palette"), KDialogBase::Ok | KDialogBase::Cancel);
-    KisCustomPalette* p = new KisCustomPalette(base, "add palette", i18n("Add Palette"), this);
-    base->setMainWidget(p);
-    base->show();
-}
-
-void KisView::slotEditPalette()
-{
-    KisPaletteChooser chooser(this);
-    KisResourceServerBase* srv = KisResourceServerRegistry::instance()->get("PaletteServer");
-    if (!srv) {
-        return;
-    }
-    QValueList<KisResource*> resources = srv->resources();
-    QValueList<KisPalette*> palettes;
-
-    for(uint i = 0; i < resources.count(); i++) {
-        KisPalette* palette = dynamic_cast<KisPalette*>(*resources.at(i));
-
-        chooser.paletteList->insertItem(palette->name());
-        palettes.append(palette);
-    }
-
-    if (chooser.exec() != QDialog::Accepted ) {
-        return;
-    }
-
-    int index = chooser.paletteList->currentItem();
-    if (index < 0) {
-        KMessageBox::error(this, i18n("No palette selected."), i18n("Palette"));
-        return;
-    }
-
-    KDialogBase* base = new KDialogBase(this, 0, true, i18n("Edit Palette") , KDialogBase::Ok);
-    KisCustomPalette* cp = new KisCustomPalette(base, "edit palette",
-            i18n("Edit Palette"), this);
-    cp->setEditMode(true);
-    cp->setPalette(*palettes.at(index));
-    base->setMainWidget(cp);
-    base->show();
-}
-
-void KisView::saveLayerAsImage()
-{
-    QStringList listMimeFilter = KoFilterManager::mimeFilter("application/x-krita", KoFilterManager::Export);
-    QString mimelist = listMimeFilter.join(" ");
-
-    KFileDialog fd (QString::null, mimelist, this, "Export Layer", true);
-    fd.setCaption(i18n("Export Layer"));
-    fd.setMimeFilter(listMimeFilter);
-    fd.setOperationMode(KFileDialog::Saving);
-
-    if (!fd.exec()) return;
-
-    KURL url = fd.selectedURL();
-    QString mimefilter = fd.currentMimeFilter();
-
-    if (url.isEmpty())
-        return;
-
-
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    KisLayerSP l = img->activeLayer();
-    if (!l) return;
-
-    QRect r = l->exactBounds();
-
-    KisDoc d;
-    d.prepareForImport();
-
-    KisImageSP dst = new KisImage(d.undoAdapter(), r.width(), r.height(), img->colorSpace(), l->name());
-    d.setCurrentImage( dst );
-    dst->addLayer(l->clone(),dst->rootLayer(),0);
-
-    d.setOutputMimeType(mimefilter.latin1());
-    d.exp0rt(url);
-}
-
-
-
-Q_INT32 KisView::importImage(const KURL& urlArg)
-{
-    KisImageSP currentImage = currentImg();
-
-    if (!currentImage) {
-        return 0;
-    }
-
-    KURL::List urls;
-    Q_INT32 rc = 0;
-
-    if (urlArg.isEmpty()) {
-        QString mimelist = KoFilterManager::mimeFilter("application/x-krita", KoFilterManager::Import).join(" ");
-        urls = KFileDialog::getOpenURLs(QString::null, mimelist, 0, i18n("Import Image"));
-    } else {
-        urls.push_back(urlArg);
-    }
-
-    if (urls.empty())
-        return 0;
-
-    for (KURL::List::iterator it = urls.begin(); it != urls.end(); ++it) {
-        new KisImportCatcher( *it, currentImage );
-    }
-
-    updateCanvas();
-
-    return rc;
-}
-
-void KisView::rotateLayer180()
-{
-    rotateLayer( 180 );
-}
-
-void KisView::rotateLayerLeft90()
-{
-    rotateLayer( 270 );
-}
-
-void KisView::rotateLayerRight90()
-{
-    rotateLayer( 90 );
-}
-
-void KisView::mirrorLayerX()
-{
-    if (!currentImg()) return;
-    KisPaintDeviceSP dev = currentImg()->activeDevice();
-    if (!dev) return;
-
-    KisTransaction * t = 0;
-    if (undoAdapter() && undoAdapter()->undo()) {
-        t = new KisTransaction(i18n("Mirror Layer X"), dev);
-        Q_CHECK_PTR(t);
-    }
-
-    dev->mirrorX();
-
-    if (t) undoAdapter()->addCommand(t);
-
-    m_doc->setModified(true);
-    layersUpdated();
-    updateCanvas();
-}
-
-void KisView::mirrorLayerY()
-{
-    if (!currentImg()) return;
-    KisPaintDeviceSP dev = currentImg()->activeDevice();
-    if (!dev) return;
-
-    KisTransaction * t = 0;
-    if (undoAdapter() && undoAdapter()->undo()) {
-        t = new KisTransaction(i18n("Mirror Layer Y"), dev);
-        Q_CHECK_PTR(t);
-    }
-
-    dev->mirrorY();
-
-    if (t) undoAdapter()->addCommand(t);
-
-    m_doc->setModified(true);
-    layersUpdated();
-    updateCanvas();
-}
-
-void KisView::scaleLayer(double sx, double sy, KisFilterStrategy *filterStrategy)
-{
-    if (!currentImg()) return;
-
-    KisPaintDeviceSP dev = currentImg()->activeDevice();
-    if (!dev) return;
-
-    KisTransaction * t = 0;
-    if (undoAdapter() && undoAdapter()->undo()) {
-        t = new KisTransaction(i18n("Scale Layer"), dev);
-        Q_CHECK_PTR(t);
-    }
-
-    KisTransformWorker worker(dev, sx, sy, 0, 0, 0.0, 0, 0, m_progress, filterStrategy);
-    worker.run();
-
-    if (t) undoAdapter()->addCommand(t);
-
-    m_doc->setModified(true);
-    layersUpdated();
-    updateCanvas();
-}
-
-void KisView::rotateLayer(double angle)
-{
-    if (!currentImg()) return;
-
-    KisPaintDeviceSP dev = currentImg()->activeDevice();
-    if (!dev) return;
-
-    KisTransaction * t = 0;
-    if (undoAdapter() && undoAdapter()->undo()) {
-        t = new KisTransaction(i18n("Rotate Layer"), dev);
-        Q_CHECK_PTR(t);
-    }
-
-    KisFilterStrategy *filter = KisFilterStrategyRegistry::instance()->get(KisID("Triangle"));
-    angle *= M_PI/180;
-    Q_INT32 w = currentImg()->width();
-    Q_INT32 h = currentImg()->height();
-    Q_INT32 tx = Q_INT32((w*cos(angle) - h*sin(angle) - w) / 2 + 0.5);
-    Q_INT32 ty = Q_INT32((h*cos(angle) + w*sin(angle) - h) / 2 + 0.5);
-
-    KisTransformWorker tw(dev, 1.0, 1.0, 0, 0, angle, -tx, -ty, m_progress, filter);
-    tw.run();
-
-    if (t) undoAdapter()->addCommand(t);
-
-    m_doc->setModified(true);
-    layersUpdated();
-    updateCanvas();
-}
-
-void KisView::shearLayer(double angleX, double angleY)
-{
-    if (!currentImg()) return;
-
-    KisLayerSP layer = currentImg()->activeLayer();
-    if (!layer) return;
-
-    KisUndoAdapter * undo = 0;
-    if ((undo = currentImg()->undoAdapter())) {
-        undo->beginMacro(i18n("Shear layer"));
-    }
-
-    KisShearVisitor v(angleX, angleY, m_progress);
-    v.setUndoAdapter(undo);
-    layer->accept(v);
-
-    if (undo) undo->endMacro();
-
-    m_doc->setModified(true);
-    layersUpdated();
-    updateCanvas();
-}
-
-void KisView::flattenImage()
-{
-    KisImageSP img = currentImg();
-
-    if (img) {
-        bool doIt = true;
-
-        if (img->nHiddenLayers() > 0) {
-            int answer = KMessageBox::warningYesNo(this,
-                                   i18n("The image contains hidden layers that will be lost."),
-                                   i18n("Flatten Image"),
-                                   i18n("&Flatten Image"),
-                                   KStdGuiItem::cancel());
-
-            if (answer != KMessageBox::Yes) {
-                doIt = false;
-            }
-        }
-
-        if (doIt) {
-            img->flatten();
-        }
-    }
-}
-
-void KisView::mergeLayer()
-{
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    KisLayerSP layer = img->activeLayer();
-    if (!layer) return;
-
-    img->mergeLayer(layer);
-}
-
-void KisView::preferences()
-{
-#ifdef HAVE_GL
-    bool canvasWasOpenGL = m_canvas->isOpenGLCanvas();
-#endif
-
-    if (PreferencesDialog::editPreferences())
-    {
-        KisConfig cfg;
-        m_paletteManager->slotResetFont();
-        resetMonitorProfile();
-
-#ifdef HAVE_GL
-        if (cfg.useOpenGL() != canvasWasOpenGL) {
-
-            disconnectCurrentImg();
-
-            //XXX: Need to notify other views that this global setting has changed.
-            if (cfg.useOpenGL()) {
-                m_OpenGLImageContext = KisOpenGLImageContext::getImageContext(m_image, monitorProfile());
-                m_canvas->createOpenGLCanvas(m_OpenGLImageContext->sharedContextWidget());
-            } else
-            {
-                m_OpenGLImageContext = 0;
-                m_canvas->createQPaintDeviceCanvas();
-            }
-
-            connectCurrentImg();
-
-            resizeEvent(0);
-        }
-
-        if (cfg.useOpenGL()) {
-            m_OpenGLImageContext->setMonitorProfile(monitorProfile());
-        }
-#endif
-
-        refreshKisCanvas();
-
-        if (m_toolManager->currentTool()) {
-            setCanvasCursor(m_toolManager->currentTool()->cursor());
-        }
-
-#if defined(EXTENDED_X11_TABLET_SUPPORT)
-        m_canvas->selectTabletDeviceEvents();
-#endif
-
-    }
-}
-
-void KisView::layerCompositeOp(const KisCompositeOp& compositeOp)
-{
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    KisLayerSP layer = img->activeLayer();
-    if (!layer) return;
-
-    if (img->undo()) {
-        KNamedCommand *cmd = layer->setCompositeOpCommand(compositeOp);
-        cmd->execute();
-        undoAdapter()->addCommand(cmd);
-    }
-}
-
-// range: 0 - 100
-void KisView::layerOpacity(int opacity, bool dontundo)
-{
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    KisLayerSP layer = img->activeLayer();
-    if (!layer) return;
-
-    opacity = int(float(opacity * 255) / 100 + 0.5);
-    if (opacity > 255)
-        opacity = 255;
-
-    if (opacity == layer->opacity()) return;
-
-    if (dontundo)
-        layer->setOpacity( opacity );
-    else
-    {
-        if (img->undo()) {
-            KNamedCommand *cmd = layer->setOpacityCommand(opacity);
-            cmd->execute();
-            undoAdapter()->addCommand(cmd);
-        }
-    }
-}
-
-void KisView::layerOpacityFinishedChanging( int previous, int opacity )
-{
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    KisLayerSP layer = img->activeLayer();
-    if (!layer) return;
-
-    opacity = int(float(opacity * 255) / 100 + 0.5);
-    if (opacity > 255)
-        opacity = 255;
-
-    previous = int(float(previous * 255) / 100 + 0.5);
-    if (previous > 255)
-        previous = 255;
-
-    if (previous == opacity) return;
-
-    if (img->undo()) {
-        KNamedCommand *cmd = layer->setOpacityCommand(previous, opacity);
-        m_adapter->addCommand(cmd);
-    }
-}
-
-
-void KisView::showRuler()
-{
-    if( m_RulerAction->isChecked() )
-    {
-        m_hRuler->show();
-        m_vRuler->show();
-    }
-    else
-    {
-        m_hRuler->hide();
-        m_vRuler->hide();
-    }
-
-    resizeEvent(0);
-    refreshKisCanvas();
-}
-
-void KisView::slotUpdateFullScreen(bool toggle)
-{
-    if (KoView::shell()) {
-
-        uint newState = KoView::shell()->windowState();
-
-        if (toggle) {
-            newState |= Qt::WindowFullScreen;
-        } else {
-            newState &= ~Qt::WindowFullScreen;
-        }
-
-        KoView::shell()->setWindowState(newState);
-    }
-}
-
-Q_INT32 KisView::docWidth() const
-{
-    return currentImg() ? currentImg()->width() : 0;
-}
-
-Q_INT32 KisView::docHeight() const
-{
-    return currentImg() ? currentImg()->height() : 0;
-}
-
-void KisView::scrollTo(Q_INT32 x, Q_INT32 y)
-{
-    if (m_hScroll->isVisible()) {
-        m_hScroll->setValue(x);
-    }
-    if (m_vScroll->isVisible()) {
-        m_vScroll->setValue(y);
-    }
-}
-
-void KisView::brushActivated(KisResource *brush)
-{
-
-    m_brush = dynamic_cast<KisBrush*>(brush);
-
-    if (m_brush )
-    {
-        emit brushChanged(m_brush);
-        notifyObservers();
-    }
-}
-
-void KisView::patternActivated(KisResource *pattern)
-{
-    m_pattern = dynamic_cast<KisPattern*>(pattern);
-
-    if (m_pattern) {
-        emit patternChanged(m_pattern);
-        notifyObservers();
-    }
-}
-
-void KisView::gradientActivated(KisResource *gradient)
-{
-
-    m_gradient = dynamic_cast<KisGradient*>(gradient);
-
-    if (m_gradient) {
-        emit gradientChanged(m_gradient);
-        notifyObservers();
-    }
-}
-
-void KisView::paintopActivated(const KisID & paintop, const KisPaintOpSettings *paintopSettings)
-{
-    if (paintop.id().isNull() || paintop.id().isEmpty()) {
-        return;
-    }
-
-    m_paintop = paintop;
-    m_paintopSettings = paintopSettings;
-    emit paintopChanged(m_paintop, paintopSettings);
-    notifyObservers();
-}
-
-void KisView::setBGColor(const KisColor& c)
-{
-    m_bg = c;
-    notifyObservers();
-    emit sigBGQColorChanged( c.toQColor() );
-}
-
-void KisView::setFGColor(const KisColor& c)
-{
-    m_fg = c;
-    notifyObservers();
-    emit sigFGQColorChanged( c.toQColor() );
-}
-
-void KisView::slotSetFGColor(const KisColor& c)
-{
-
-    m_fg = c;
-    notifyObservers();
-}
-
-void KisView::slotSetBGColor(const KisColor& c)
-{
-
-    m_bg = c;
-    notifyObservers();
-}
-
-void KisView::slotSetFGQColor(const QColor& c)
-{
-    KisColorSpace * monitorSpace = KisMetaRegistry::instance()->csRegistry()->getColorSpace(KisID("RGBA"), m_monitorProfile);
-    setFGColor(KisColor(c, monitorSpace));
-    emit sigFGQColorChanged(c);
-}
-
-void KisView::slotSetBGQColor(const QColor& c)
-{
-    KisColorSpace * monitorSpace = KisMetaRegistry::instance()->csRegistry()->getColorSpace(KisID("RGBA"), m_monitorProfile);
-    setBGColor(KisColor(c, monitorSpace));
-    emit sigBGQColorChanged(c);
-}
-
-
-void KisView::setupPrinter(KPrinter& printer)
-{
-    KisImageSP img = currentImg();
-
-    if (img) {
-        printer.setPageSelection(KPrinter::ApplicationSide);
-        printer.setPageSize(KPrinter::A4);
-        printer.setOrientation(KPrinter::Portrait);
-    }
-}
-
-void KisView::print(KPrinter& printer)
-{
-    QPainter gc(&printer);
-
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    printer.setFullPage(true);
-    gc.setClipping(false);
-
-    KisConfig cfg;
-    QString printerProfileName = cfg.printerProfile();
-    KisProfile *  printerProfile = KisMetaRegistry::instance()->csRegistry() ->getProfileByName(printerProfileName);
-
-    QRect r = img->bounds();
-    img->renderToPainter(r.x(), r.y(), r.width(), r.height(), gc, printerProfile, KisImage::PAINT_IMAGE_ONLY, HDRExposure());
-}
-
-void KisView::paintToolOverlay(const QRegion& region)
-{
-    if (!region.isEmpty() && m_toolManager->currentTool() && !m_toolIsPainting) {
-        KisCanvasPainter gc(m_canvas);
-
-        gc.setClipRegion(region);
-        gc.setClipping(true);
-
-        // Prevent endless loop if the tool needs to have the canvas repainted
-        m_toolIsPainting = true;
-        m_toolManager->currentTool()->paint(gc, region.boundingRect());
-        m_toolIsPainting = false;
-    }
-}
-
-void KisView::canvasGotPaintEvent(QPaintEvent *event)
-{
-    if (m_canvas->isOpenGLCanvas()) {
-        paintOpenGLView(event->rect());
-    } else {
-        paintQPaintDeviceView(event->region());
-    }
-}
-
-void KisView::canvasGotButtonPressEvent(KisButtonPressEvent *e)
-{
-#if defined(EXTENDED_X11_TABLET_SUPPORT)
-    // The event filter doesn't see tablet events going to the canvas.
-    if (e->device() != KisInputDevice::mouse()) {
-        m_tabletEventTimer.start();
-    }
-#endif // EXTENDED_X11_TABLET_SUPPORT
-
-    if (e->device() != currentInputDevice()) {
-        if (e->device() == KisInputDevice::mouse()) {
-            if (m_tabletEventTimer.elapsed() > MOUSE_CHANGE_EVENT_DELAY) {
-                setInputDevice(KisInputDevice::mouse());
-            }
-        } else {
-            setInputDevice(e->device());
-        }
-    }
-
-    KisImageSP img = currentImg();
-
-//    if (img) {
-//        QPoint pt = mapToScreen(e->pos().floorQPoint());
-//        KisGuideMgr *mgr = img->guides();
-//
-//        m_lastGuidePoint = mapToScreen(e->pos().floorQPoint());
-//        m_currentGuide = 0;
-//
-//        if ((e->state() & ~Qt::ShiftButton) == Qt::NoButton) {
-//            KisGuideSP gd = mgr->find(static_cast<Q_INT32>(pt.x() / zoom()), static_cast<Q_INT32>(pt.y() / zoom()), QMAX(2.0, 2.0 / zoom()));
-//
-//            if (gd) {
-//                m_currentGuide = gd;
-//
-//                if ((e->button() == Qt::RightButton) || ((e->button() & Qt::ShiftButton) == Qt::ShiftButton)) {
-//                    if (gd->isSelected())
-//                        mgr->unselect(gd);
-//                    else
-//                        mgr->select(gd);
-//              } else {
-//                    if (!gd->isSelected()) {
-//                        mgr->unselectAll();
-//                        mgr->select(gd);
-//                    }
-//                }
-//
-//                updateGuides();
-//                return;
-//            }
-//        }
-//    }
-    if (e->button() == Qt::RightButton) {
-
-        if (m_popup == 0 && factory()) {
-            Q_ASSERT(factory());
-            m_popup = (QPopupMenu *)factory()->container("image_popup", this);
-        }
-        if (m_popup) m_popup->popup(e->globalPos().roundQPoint());
-    }
-    else if (e->device() == currentInputDevice() && m_toolManager->currentTool()) {
-        KisPoint p = viewToWindow(e->pos());
-        // somewhat of a hack: we should actually test if we intersect with the scrollers,
-        // but the globalPos seems to be off by a few pixels
-        if (m_vScroll->draggingSlider() || m_hScroll->draggingSlider())
-            return;
-
-        if (m_toolManager->currentTool()->wantsAutoScroll()) {
-            enableAutoScroll();
-        }
-
-        KisButtonPressEvent ev(e->device(), p, e->globalPos(), e->pressure(), e->xTilt(), e->yTilt(), e->button(), e->state());
-        m_toolManager->currentTool()->buttonPress(&ev);
-    }
-}
-
-void KisView::canvasGotMoveEvent(KisMoveEvent *e)
-{
-#if defined(EXTENDED_X11_TABLET_SUPPORT)
-    // The event filter doesn't see tablet events going to the canvas.
-    if (e->device() != KisInputDevice::mouse()) {
-        m_tabletEventTimer.start();
-    }
-#endif // EXTENDED_X11_TABLET_SUPPORT
-
-    if (e->device() != currentInputDevice()) {
-        if (e->device() == KisInputDevice::mouse()) {
-            if (m_tabletEventTimer.elapsed() > MOUSE_CHANGE_EVENT_DELAY) {
-                setInputDevice(KisInputDevice::mouse());
-            }
-        } else {
-            setInputDevice(e->device());
-        }
-    }
-
-    KisImageSP img = currentImg();
-
-    m_hRuler->updatePointer(e->pos().floorX() - m_canvasXOffset, e->pos().floorY() - m_canvasYOffset);
-    m_vRuler->updatePointer(e->pos().floorX() - m_canvasXOffset, e->pos().floorY() - m_canvasYOffset);
-
-    KisPoint wp = viewToWindow(e->pos());
-
-#if 0
-    if (img && m_currentGuide) {
-        QPoint p = mapToScreen(e->pos().floorQPoint());
-        KisGuideMgr *mgr = img->guides();
-
-        if (((e->state() & Qt::LeftButton) == Qt::LeftButton) && mgr->hasSelected()) {
-            eraseGuides();
-            p -= m_lastGuidePoint;
-
-            if (p.x())
-                mgr->moveSelectedByX(p.x() / zoom());
-
-            if (p.y())
-                mgr->moveSelectedByY(p.y() / zoom());
-
-            m_doc->setModified(true);
-            paintGuides();
-        }
-    } else
-#endif
-    if (e->device() == currentInputDevice() && m_toolManager->currentTool()) {
-        KisMoveEvent ev(e->device(), wp, e->globalPos(), e->pressure(), e->xTilt(), e->yTilt(), e->state());
-
-        m_toolManager->currentTool()->move(&ev);
-    }
-
-//    m_lastGuidePoint = mapToScreen(e->pos().floorQPoint());
-    emit cursorPosition(wp.floorX(), wp.floorY());
-}
-
-int KisView::leftBorder() const
-{
-  return m_rulerThickness;
-}
-
-int KisView::rightBorder() const
-{
-  return m_hScrollBarExtent;
-}
-
-int KisView::topBorder() const
-{
-  return m_rulerThickness;
-}
-
-int KisView::bottomBorder() const
-{
-  return m_vScrollBarExtent;
-}
-
-void KisView::mouseMoveEvent(QMouseEvent *e)
-{
-    KisMoveEvent ke(currentInputDevice(), e->pos(), e->globalPos(), PRESSURE_DEFAULT, 0, 0, e->state());
-    canvasGotMoveEvent(&ke);
-}
-
-void KisView::slotAutoScroll(const QPoint &p)
-{
-    scrollTo(horzValue()+p.x(), vertValue()+p.y());
-}
-
-void KisView::canvasGotButtonReleaseEvent(KisButtonReleaseEvent *e)
-{
-#if defined(EXTENDED_X11_TABLET_SUPPORT)
-    // The event filter doesn't see tablet events going to the canvas.
-    if (e->device() != KisInputDevice::mouse()) {
-        m_tabletEventTimer.start();
-    }
-#endif // EXTENDED_X11_TABLET_SUPPORT
-
-    if (e->device() != currentInputDevice()) {
-        if (e->device() == KisInputDevice::mouse()) {
-            if (m_tabletEventTimer.elapsed() > MOUSE_CHANGE_EVENT_DELAY) {
-                setInputDevice(KisInputDevice::mouse());
-            }
-        } else {
-            setInputDevice(e->device());
-        }
-    }
-
-    KisImageSP img = currentImg();
-
-//    if (img && m_currentGuide) {
-//        m_currentGuide = 0;
-//    } else
-    if (e->device() == currentInputDevice() && m_toolManager->currentTool()) {
-        KisPoint p = viewToWindow(e->pos());
-        KisButtonReleaseEvent ev(e->device(), p, e->globalPos(), e->pressure(), e->xTilt(), e->yTilt(), e->button(), e->state());
-
-        disableAutoScroll();
-        if (m_toolManager->currentTool()) {
-            m_toolManager->currentTool()->buttonRelease(&ev);
-        }
-    }
-}
-
-void KisView::canvasGotDoubleClickEvent(KisDoubleClickEvent *e)
-{
-#if defined(EXTENDED_X11_TABLET_SUPPORT)
-    // The event filter doesn't see tablet events going to the canvas.
-    if (e->device() != KisInputDevice::mouse()) {
-        m_tabletEventTimer.start();
-    }
-#endif // EXTENDED_X11_TABLET_SUPPORT
-
-    if (e->device() != currentInputDevice()) {
-        if (e->device() == KisInputDevice::mouse()) {
-            if (m_tabletEventTimer.elapsed() > MOUSE_CHANGE_EVENT_DELAY) {
-                setInputDevice(KisInputDevice::mouse());
-            }
-        } else {
-            setInputDevice(e->device());
-        }
-    }
-
-    if (e->device() == currentInputDevice() && m_toolManager->currentTool()) {
-        KisPoint p = viewToWindow(e->pos());
-        KisDoubleClickEvent ev(e->device(), p, e->globalPos(), e->pressure(), e->xTilt(), e->yTilt(), e->button(), e->state());
-
-        if (m_toolManager->currentTool()) {
-            m_toolManager->currentTool()->doubleClick(&ev);
-        }
-    }
-}
-
-void KisView::canvasGotEnterEvent(QEvent *e)
-{
-}
-
-void KisView::canvasGotLeaveEvent (QEvent *e)
-{
-}
-
-void KisView::canvasGotMouseWheelEvent(QWheelEvent *event)
-{
-    //if(event->state() == ControlButton )
-    //{
-        if(event->delta() / 120 != 0)
-        {
-            if(event->delta() > 0)
-            {
-                zoomIn();
-            } else {
-                zoomOut();
-            }
-	    if (m_oldTool) {
-                KisCanvasPainter gc(m_canvas);
-                m_oldTool->paint(gc);
-            }
-        }
-    //} else {
-    //    QApplication::sendEvent(m_vScroll, event);
-    //}
-}
-
-void KisView::canvasGotKeyPressEvent(QKeyEvent *event)
-{
-    if (!m_toolManager->currentTool()) {
-        event->ignore();
-        return;
-    }
-
-    if (event->key() == Qt::Key_Space) {
-        if (!m_panning) {
-            // Set tool temporarily to pan
-            m_panning = true;
-            m_oldTool = m_toolManager->currentTool();
-            m_toolManager->setCurrentTool( "tool_pan" );
-        }
-        else {
-            // Unset panning
-            m_panning = false;
-            m_toolManager->setCurrentTool( m_oldTool );
-            m_oldTool = 0;
-        }
-    }
-    if (m_toolManager->currentTool())
-        m_toolManager->currentTool()->keyPress(event);
-}
-
-void KisView::canvasGotKeyReleaseEvent(QKeyEvent *event)
-{
-    if (m_toolManager->currentTool())
-        m_toolManager->currentTool()->keyRelease(event);
-}
-
-void KisView::canvasGotDragEnterEvent(QDragEnterEvent *event)
-{
-    bool accept = false;
-
-    // Only accept drag if we're not busy, particularly as we may
-    // be showing a progress bar and calling qApp->processEvents().
-    if (KURLDrag::canDecode(event) && QApplication::overrideCursor() == 0) {
-        accept = true;
-    }
-
-    event->accept(accept);
-}
-
-void KisView::canvasGotDropEvent(QDropEvent *event)
-{
-    KURL::List urls;
-
-    if (KURLDrag::decode(event, urls))
-    {
-        if (urls.count() > 0) {
-            enum enumActionId {
-                addLayerId = 1,
-                addDocumentId = 2,
-                cancelId
-            };
-
-            KPopupMenu popup(this, "drop_popup");
-
-            if (urls.count() == 1) {
-                if (currentImg() != 0) {
-                    popup.insertItem(i18n("Insert as New Layer"), addLayerId);
-                }
-                popup.insertItem(i18n("Open in New Document"), addDocumentId);
-            }
-            else {
-                if (currentImg() != 0) {
-                    popup.insertItem(i18n("Insert as New Layers"), addLayerId);
-                }
-                popup.insertItem(i18n("Open in New Documents"), addDocumentId);
-            }
-
-            popup.insertSeparator();
-            popup.insertItem(i18n("Cancel"), cancelId);
-
-            int actionId = popup.exec(QCursor::pos());
-
-            if (actionId >= 0 && actionId != cancelId) {
-                for (KURL::List::ConstIterator it = urls.begin (); it != urls.end (); ++it) {
-                    KURL url = *it;
-
-                    switch (actionId) {
-                    case addLayerId:
-                        importImage(url);
-                        break;
-                    case addDocumentId:
-                        if (shell() != 0) {
-                            shell()->openDocument(url);
-                        }
-                        break;
-                    }
-                }
-            }
-        }
-    }
-}
-
-void KisView::layerProperties()
-{
-    if (currentImg() && currentImg()->activeLayer())
-        showLayerProperties(currentImg()->activeLayer());
-}
-
-namespace {
-    class KisChangeFilterCmd : public KNamedCommand {
-        typedef KNamedCommand super;
-
-        public:
-            // The QStrings are the _serialized_ configs
-            KisChangeFilterCmd(KisAdjustmentLayerSP layer,
-                               KisFilterConfiguration* config,
-                               const QString& before,
-                               const QString& after) : super(i18n("Change Filter"))
-            {
-                m_layer = layer;
-                m_config = config;
-                m_before = before;
-                m_after = after;
-            }
-        public:
-            virtual void execute()
-            {
-                QApplication::setOverrideCursor(KisCursor::waitCursor());
-                m_config->fromXML(m_after);
-                //Q_ASSERT(m_after == m_config->toString());
-                m_layer->setFilter(m_config);
-                m_layer->setDirty();
-                QApplication::restoreOverrideCursor();
-            }
-
-            virtual void unexecute()
-            {
-                QApplication::setOverrideCursor(KisCursor::waitCursor());
-                m_config->fromXML(m_before);
-                //Q_ASSERT(m_before == m_config->toString());
-                m_layer->setFilter(m_config);
-                m_layer->setDirty();
-                QApplication::restoreOverrideCursor();
-            }
-        private:
-            KisAdjustmentLayerSP m_layer;
-            KisFilterConfiguration* m_config;
-            QString m_before;
-            QString m_after;
-    };
-}
-
-void KisView::showLayerProperties(KisLayerSP layer)
-{
-    Q_ASSERT( layer );
-    if ( !layer ) return;
-
-    KisColorSpace * cs = 0;
-    KisPaintLayer * pl = dynamic_cast<KisPaintLayer*>( layer.data() );
-    if ( pl ) {
-        cs = pl->paintDevice()->colorSpace();
-    }
-    else {
-        cs = layer->image()->colorSpace();
-    }
-
-
-    if (KisAdjustmentLayerSP alayer = dynamic_cast<KisAdjustmentLayer*>(layer.data()))
-    {
-        KisDlgAdjLayerProps dlg(alayer, alayer->name(), i18n("Adjustment Layer Properties"), this, "dlgadjlayerprops");
-        QString before = dlg.filterConfiguration()->toString();
-        if (dlg.exec() == QDialog::Accepted)
-        {
-            KisChangeFilterCmd * cmd = new KisChangeFilterCmd(alayer,
-                    dlg.filterConfiguration(),
-                    before,
-                    dlg.filterConfiguration()->toString());
-            cmd->execute();
-            m_adapter->addCommand(cmd);
-            m_doc->setModified( true );
-        }
-    }
-    else
-    {
-        KisDlgLayerProperties dlg(layer->name(),
-                                  layer->opacity(),
-                                  layer->compositeOp(),
-                                  cs);
-        if (dlg.exec() == QDialog::Accepted)
-        {
-            if (layer->name() != dlg.getName() ||
-                layer->opacity() != dlg.getOpacity() ||
-                layer->compositeOp() != dlg.getCompositeOp())
-            {
-                QApplication::setOverrideCursor(KisCursor::waitCursor());
-                m_adapter->beginMacro(i18n("Property Changes"));
-                layer->image()->setLayerProperties(layer, dlg.getOpacity(), dlg.getCompositeOp(), dlg.getName());
-                layer->setDirty();
-                m_adapter->endMacro();
-                QApplication::restoreOverrideCursor();
-                m_doc->setModified( true );
-            }
-        }
-    }
-}
-
-void KisView::layerAdd()
-{
-    KisImageSP img = currentImg();
-    if (img && img->activeLayer()) {
-        addLayer(img->activeLayer()->parent(), img->activeLayer());
-    }
-    else if (img)
-        addLayer(static_cast<KisGroupLayer*>(img->rootLayer().data()), 0);
-}
-
-void KisView::addLayer(KisGroupLayerSP parent, KisLayerSP above)
-{
-    KisImageSP img = currentImg();
-    if (img) {
-        KisConfig cfg;
-        QString profilename;
-        if(img->colorSpace()->getProfile())
-            profilename = img->colorSpace()->getProfile()->productName();
-        NewLayerDialog dlg(img->colorSpace()->id(), profilename, img->nextLayerName(), this);
-
-        if (dlg.exec() == QDialog::Accepted) {
-            KisColorSpace* cs = KisMetaRegistry::instance()-> csRegistry() ->
-                    getColorSpace(dlg.colorSpaceID(),dlg.profileName());
-            KisLayerSP layer = new KisPaintLayer(img, dlg.layerName(), dlg.opacity(), cs);
-            if (layer) {
-                layer->setCompositeOp(dlg.compositeOp());
-                img->addLayer(layer, parent.data(), above);
-                updateCanvas();
-            } else {
-                KMessageBox::error(this, i18n("Could not add layer to image."), i18n("Layer Error"));
-            }
-        }
-        else {
-            img->rollBackLayerName();
-        }
-    }
-}
-
-void KisView::addGroupLayer(KisGroupLayerSP parent, KisLayerSP above)
-{
-    KisImageSP img = currentImg();
-    if (img) {
-        QString profilename;
-        if(img->colorSpace()->getProfile())
-            profilename = img->colorSpace()->getProfile()->productName();
-        KisConfig cfg;
-        NewLayerDialog dlg(img->colorSpace()->id(), profilename, img->nextLayerName(), this);
-        dlg.setColorSpaceEnabled(false);
-
-        if (dlg.exec() == QDialog::Accepted) {
-            KisLayerSP layer = new KisGroupLayer(img, dlg.layerName(), dlg.opacity());
-            if (layer) {
-                layer->setCompositeOp(dlg.compositeOp());
-                img->addLayer(layer, parent.data(), above);
-                updateCanvas();
-            } else {
-                KMessageBox::error(this, i18n("Could not add layer to image."), i18n("Layer Error"));
-            }
-        }
-    }
-}
-
-void KisView::addPartLayer()
-{
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    addPartLayer(img->rootLayer(), img->rootLayer()->firstChild(), m_actionPartLayer->documentEntry());
-}
-
-void KisView::addPartLayer(KisGroupLayerSP parent, KisLayerSP above, const KoDocumentEntry& entry)
-{
-    delete m_partHandler; // Only one at a time
-    m_partHandler = new KisPartLayerHandler(this, entry, parent, above);
-
-    disconnect(m_canvas, SIGNAL(sigGotButtonPressEvent(KisButtonPressEvent*)), this, 0);
-    disconnect(m_canvas, SIGNAL(sigGotButtonReleaseEvent(KisButtonReleaseEvent*)), this, 0);
-    disconnect(m_canvas, SIGNAL(sigGotMoveEvent(KisMoveEvent*)), this, 0);
-    disconnect(m_canvas, SIGNAL(sigGotKeyPressEvent(QKeyEvent*)), this, 0);
-
-    connect(m_canvas, SIGNAL(sigGotButtonPressEvent(KisButtonPressEvent*)),
-            m_partHandler, SLOT(gotButtonPressEvent(KisButtonPressEvent*)));
-    connect(m_canvas, SIGNAL(sigGotButtonReleaseEvent(KisButtonReleaseEvent*)),
-            m_partHandler, SLOT(gotButtonReleaseEvent(KisButtonReleaseEvent*)));
-    connect(m_canvas, SIGNAL(sigGotMoveEvent(KisMoveEvent*)),
-            m_partHandler, SLOT(gotMoveEvent(KisMoveEvent*)));
-    connect(m_canvas, SIGNAL(sigGotKeyPressEvent(QKeyEvent*)),
-            m_partHandler, SLOT(gotKeyPressEvent(QKeyEvent*)));
-
-    connect(m_partHandler, SIGNAL(sigGotMoveEvent(KisMoveEvent*)),
-            this, SLOT(canvasGotMoveEvent(KisMoveEvent*)));
-    connect(m_partHandler, SIGNAL(sigGotKeyPressEvent(QKeyEvent*)),
-            this, SLOT(canvasGotKeyPressEvent(QKeyEvent*)));
-    connect(m_partHandler, SIGNAL(handlerDone()),
-            this, SLOT(reconnectAfterPartInsert()));
-}
-
-void KisView::insertPart(const QRect& viewRect, const KoDocumentEntry& entry,
-                         KisGroupLayerSP parent, KisLayerSP above) {
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    KoDocument* doc = entry.createDoc(m_doc);
-    if ( !doc )
-        return;
-
-    if ( !doc->showEmbedInitDialog(this) )
-        return;
-
-    QRect rect = viewToWindow(viewRect);
-
-    KisChildDoc * childDoc = m_doc->createChildDoc(rect, doc);
-
-    KisPartLayerImpl* partLayer = new KisPartLayerImpl(img, childDoc);
-    partLayer->setDocType(entry.service()->genericName());
-    img->addLayer(partLayer, parent, above);
-    m_doc->setModified(true);
-
-    reconnectAfterPartInsert();
-}
-
-void KisView::reconnectAfterPartInsert() {
-    connect(m_canvas, SIGNAL(sigGotButtonPressEvent(KisButtonPressEvent*)),
-            this, SLOT(canvasGotButtonPressEvent(KisButtonPressEvent*)));
-    connect(m_canvas, SIGNAL(sigGotButtonReleaseEvent(KisButtonReleaseEvent*)),
-            this, SLOT(canvasGotButtonReleaseEvent(KisButtonReleaseEvent*)));
-    connect(m_canvas, SIGNAL(sigGotMoveEvent(KisMoveEvent*)),
-            this, SLOT(canvasGotMoveEvent(KisMoveEvent*)));
-    connect(m_canvas, SIGNAL(sigGotKeyPressEvent(QKeyEvent*)),
-            this, SLOT(canvasGotKeyPressEvent(QKeyEvent*)));
-
-    delete m_partHandler;
-    m_partHandler = 0;
-}
-
-void KisView::addAdjustmentLayer()
-{
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    addAdjustmentLayer( img->activeLayer()->parent(), img->activeLayer() );
-}
-
-void KisView::addAdjustmentLayer(KisGroupLayerSP parent, KisLayerSP above)
-{
-    Q_ASSERT(parent);
-    Q_ASSERT(above);
-
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    KisLayerSP l = img->activeLayer();
-
-    KisPaintDeviceSP dev;
-
-    //  Argh! I hate having to cast, cast and cast again to see what kind of a layer I've got!
-    KisPaintLayer * pl = dynamic_cast<KisPaintLayer*>(l.data());
-    if (pl) {
-        dev = pl->paintDevice();
-    }
-    else {
-        KisGroupLayer * gl = dynamic_cast<KisGroupLayer*>(l.data());
-        if (gl) {
-            dev = gl->projection(img->bounds());
-        }
-        else {
-            KisAdjustmentLayer * al = dynamic_cast<KisAdjustmentLayer*>(l.data());
-            if (al) {
-                dev = al->cachedPaintDevice();
-            }
-            else {
-                return;
-            }
-        }
-    }
-
-    KisDlgAdjustmentLayer dlg(img, img->nextLayerName(), i18n("New Adjustment Layer"), this, "dlgadjustmentlayer");
-    if (dlg.exec() == QDialog::Accepted) {
-        KisSelectionSP selection = 0;
-        if (dev->hasSelection()) {
-            selection = dev->selection();
-        }
-        KisFilterConfiguration * filter = dlg.filterConfiguration();
-        QString name = dlg.layerName();
-
-        addAdjustmentLayer( parent, above, name, filter, selection);
-
-    }
-}
-
-void KisView::addAdjustmentLayer(KisGroupLayerSP parent, KisLayerSP above, const QString & name,
-                                 KisFilterConfiguration * filter, KisSelectionSP selection)
-{
-    Q_ASSERT(parent);
-    Q_ASSERT(above);
-    Q_ASSERT(filter);
-
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    KisAdjustmentLayer * l = new KisAdjustmentLayer(img, name, filter, selection);
-    img->addLayer(l, parent, above);
-}
-
-void KisView::slotChildActivated(bool a) {
-    // It should be so that the only part (child) we can activate, is the current layer:
-    if (currentImg() && currentImg()->activeLayer())
-    {
-        if (a) {
-            currentImg()->activeLayer()->activate();
-        } else {
-            currentImg()->activeLayer()->deactivate();
-        }
-    }
-
-    super::slotChildActivated(a);
-}
-
-void KisView::layerRemove()
-{
-    KisImageSP img = currentImg();
-
-    if (img) {
-        KisLayerSP layer = img->activeLayer();
-
-        if (layer) {
-
-
-            img->removeLayer(layer);
-
-            if (layer->parent())
-                layer->parent()->setDirty(layer->extent());
-
-            updateCanvas();
-            layerUpdateGUI(img->activeLayer() != 0);
-        }
-    }
-}
-
-void KisView::layerDuplicate()
-{
-    KisImageSP img = currentImg();
-
-    if (!img)
-        return;
-
-    KisLayerSP active = img->activeLayer();
-
-    if (!active)
-        return;
-
-    KisLayerSP dup = active->clone();
-    dup->setName(i18n("Duplicate of '%1'").arg(active->name()));
-    img->addLayer(dup, active->parent().data(), active);
-    if (dup) {
-        img->activate( dup );
-        updateCanvas();
-    } else {
-        KMessageBox::error(this, i18n("Could not add layer to image."), i18n("Layer Error"));
-    }
-}
-
-void KisView::layerRaise()
-{
-    KisImageSP img = currentImg();
-    KisLayerSP layer;
-
-    if (!img)
-        return;
-
-    layer = img->activeLayer();
-
-    img->raiseLayer(layer);
-}
-
-void KisView::layerLower()
-{
-    KisImageSP img = currentImg();
-    KisLayerSP layer;
-
-    if (!img)
-        return;
-
-    layer = img->activeLayer();
-
-    img->lowerLayer(layer);
-}
-
-void KisView::layerFront()
-{
-    KisImageSP img = currentImg();
-    KisLayerSP layer;
-
-    if (!img)
-        return;
-
-    layer = img->activeLayer();
-    img->toTop(layer);
-}
-
-void KisView::layerBack()
-{
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    KisLayerSP layer;
-
-    layer = img->activeLayer();
-    img->toBottom(layer);
-}
-
-void KisView::layersUpdated()
-{
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    KisLayerSP layer = img->activeLayer();
-
-    layerUpdateGUI(img && layer);
-
-    notifyObservers();
-}
-
-void KisView::layerToggleVisible()
-{
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    KisLayerSP layer = img->activeLayer();
-    if (!layer) return;
-
-    layer->setVisible(!layer->visible());
-}
-
-void KisView::layerToggleLocked()
-{
-    KisImageSP img = currentImg();
-    if (!img) return;
-
-    KisLayerSP layer = img->activeLayer();
-    if (!layer) return;
-
-    layer->setLocked(!layer->locked());
-}
-
-void KisView::actLayerVisChanged(int show)
-{
-    m_actLayerVis = (show != 0);
-}
-
-bool KisView::activeLayerHasSelection()
-{
-    return m_image && m_image->activeDevice() && m_image->activeDevice()->hasSelection();
-}
-
-void KisView::scrollH(int value)
-{
-    m_hRuler->updateVisibleArea(value, 0);
-
-    int xShift = m_scrollX - value;
-    m_scrollX = value;
-
-    if (m_canvas->isUpdatesEnabled()) {
-        if (xShift > 0) {
-
-            if (m_canvas->isOpenGLCanvas()) {
-                paintOpenGLView(QRect(0, 0, m_canvas->width(), m_canvas->height()));
-            } else {
-                QRect drawRect(0, 0, xShift, m_canvasPixmap.height());
-
-                bitBlt(&m_canvasPixmap, xShift, 0, &m_canvasPixmap, 0, 0, m_canvasPixmap.width() - xShift, m_canvasPixmap.height());
-
-                updateQPaintDeviceCanvas(viewToWindow(drawRect));
-                m_canvas->repaint();
-            }
-        } else if (xShift < 0) {
-
-            QRect drawRect(m_canvasPixmap.width() + xShift, 0, -xShift, m_canvasPixmap.height());
-
-            if (m_canvas->isOpenGLCanvas()) {
-                paintOpenGLView(QRect(0, 0, m_canvas->width(), m_canvas->height()));
-            } else {
-                bitBlt(&m_canvasPixmap, 0, 0, &m_canvasPixmap, -xShift, 0, m_canvasPixmap.width() + xShift, m_canvasPixmap.height());
-
-                updateQPaintDeviceCanvas(viewToWindow(drawRect));
-                m_canvas->repaint();
-            }
-        }
-	if (m_oldTool) {
-            KisCanvasPainter gc(m_canvas);
-            m_oldTool->paint(gc);
-        }
-    }
-
-    if (xShift != 0) {
-        // XXX do sth with the childframe or so
-    }
-    emit viewTransformationsChanged();
-}
-
-void KisView::scrollV(int value)
-{
-    m_vRuler->updateVisibleArea(0, value);
-
-    int yShift = m_scrollY - value;
-    m_scrollY = value;
-
-    if (m_canvas->isUpdatesEnabled()) {
-        if (yShift > 0) {
-
-            if (m_canvas->isOpenGLCanvas()) {
-                paintOpenGLView(QRect(0, 0, m_canvas->width(), m_canvas->height()));
-            } else {
-                QRect drawRect(0, 0, m_canvasPixmap.width(), yShift);
-
-                bitBlt(&m_canvasPixmap, 0, yShift, &m_canvasPixmap, 0, 0, m_canvasPixmap.width(), m_canvasPixmap.height() - yShift);
-
-                updateQPaintDeviceCanvas(viewToWindow(drawRect));
-                m_canvas->repaint();
-            }
-        } else if (yShift < 0) {
-
-            if (m_canvas->isOpenGLCanvas()) {
-                paintOpenGLView(QRect(0, 0, m_canvas->width(), m_canvas->height()));
-            } else {
-                QRect drawRect(0, m_canvasPixmap.height() + yShift, m_canvasPixmap.width(), -yShift);
-
-                bitBlt(&m_canvasPixmap, 0, 0, &m_canvasPixmap, 0, -yShift, m_canvasPixmap.width(), m_canvasPixmap.height() + yShift);
-
-                updateQPaintDeviceCanvas(viewToWindow(drawRect));
-                m_canvas->repaint();
-            }
-        }
-	if (m_oldTool) {
-            KisCanvasPainter gc(m_canvas);
-            m_oldTool->paint(gc);
-        }
-    }
-
-    if (yShift != 0) {
-        // XXX do sth with the childframe or so
-    }
-    emit viewTransformationsChanged();
-}
-
-void KisView::setupCanvas()
-{
-    m_canvas = new KisCanvas(this, "kis_canvas");
-    m_canvas->setFocusPolicy( QWidget::StrongFocus );
-    QObject::connect(m_canvas, SIGNAL(sigGotButtonPressEvent(KisButtonPressEvent*)), this, SLOT(canvasGotButtonPressEvent(KisButtonPressEvent*)));
-    QObject::connect(m_canvas, SIGNAL(sigGotButtonReleaseEvent(KisButtonReleaseEvent*)), this, SLOT(canvasGotButtonReleaseEvent(KisButtonReleaseEvent*)));
-    QObject::connect(m_canvas, SIGNAL(sigGotDoubleClickEvent(KisDoubleClickEvent*)), this, SLOT(canvasGotDoubleClickEvent(KisDoubleClickEvent*)));
-    QObject::connect(m_canvas, SIGNAL(sigGotMoveEvent(KisMoveEvent*)), this, SLOT(canvasGotMoveEvent(KisMoveEvent*)));
-    QObject::connect(m_canvas, SIGNAL(sigGotPaintEvent(QPaintEvent*)), this, SLOT(canvasGotPaintEvent(QPaintEvent*)));
-    QObject::connect(m_canvas, SIGNAL(sigGotEnterEvent(QEvent*)), this, SLOT(canvasGotEnterEvent(QEvent*)));
-    QObject::connect(m_canvas, SIGNAL(sigGotLeaveEvent(QEvent*)), this, SLOT(canvasGotLeaveEvent(QEvent*)));
-    QObject::connect(m_canvas, SIGNAL(sigGotMouseWheelEvent(QWheelEvent*)), this, SLOT(canvasGotMouseWheelEvent(QWheelEvent*)));
-    QObject::connect(m_canvas, SIGNAL(sigGotKeyPressEvent(QKeyEvent*)), this, SLOT(canvasGotKeyPressEvent(QKeyEvent*)));
-    QObject::connect(m_canvas, SIGNAL(sigGotKeyReleaseEvent(QKeyEvent*)), this, SLOT(canvasGotKeyReleaseEvent(QKeyEvent*)));
-    QObject::connect(m_canvas, SIGNAL(sigGotDragEnterEvent(QDragEnterEvent*)), this, SLOT(canvasGotDragEnterEvent(QDragEnterEvent*)));
-    QObject::connect(m_canvas, SIGNAL(sigGotDropEvent(QDropEvent*)), this, SLOT(canvasGotDropEvent(QDropEvent*)));
-}
-
-void KisView::connectCurrentImg()
-{
-    if (m_image) {
-        connect(m_image, SIGNAL(sigActiveSelectionChanged(KisImageSP)), m_selectionManager, SLOT(imgSelectionChanged(KisImageSP)));
-        connect(m_image, SIGNAL(sigActiveSelectionChanged(KisImageSP)), this, SLOT(updateCanvas()));
-        connect(m_image, SIGNAL(sigColorSpaceChanged(KisColorSpace *)), this, SLOT(updateStatusBarProfileLabel()));
-        connect(m_image, SIGNAL(sigProfileChanged(KisProfile * )), SLOT(profileChanged(KisProfile * )));
-
-        connect(m_image, SIGNAL(sigLayersChanged(KisGroupLayerSP)), SLOT(layersUpdated()));
-        connect(m_image, SIGNAL(sigMaskInfoChanged()), SLOT(maskUpdated()));
-        connect(m_image, SIGNAL(sigLayerAdded(KisLayerSP)), SLOT(layersUpdated()));
-        connect(m_image, SIGNAL(sigLayerRemoved(KisLayerSP, KisGroupLayerSP, KisLayerSP)), SLOT(layersUpdated()));
-        connect(m_image, SIGNAL(sigLayerMoved(KisLayerSP, KisGroupLayerSP, KisLayerSP)), SLOT(layersUpdated()));
-        connect(m_image, SIGNAL(sigLayerActivated(KisLayerSP)), SLOT(layersUpdated()));
-        connect(m_image, SIGNAL(sigLayerActivated(KisLayerSP)), SLOT(updateCanvas()));
-        connect(m_image, SIGNAL(sigLayerPropertiesChanged(KisLayerSP)), SLOT(layersUpdated()));
-
-        KisConnectPartLayerVisitor v(m_image, this, true);
-        m_image->rootLayer()->accept(v);
-        connect(m_image, SIGNAL(sigLayerAdded(KisLayerSP)),
-                SLOT(handlePartLayerAdded(KisLayerSP)));
-
-        maskUpdated();
-#ifdef HAVE_GL
-        if (m_OpenGLImageContext != 0) {
-            connect(m_OpenGLImageContext, SIGNAL(sigImageUpdated(QRect)), SLOT(slotOpenGLImageUpdated(QRect)));
-            connect(m_OpenGLImageContext, SIGNAL(sigSizeChanged(Q_INT32, Q_INT32)), SLOT(slotImageSizeChanged(Q_INT32, Q_INT32)));
-        } else
-#endif
-        {
-            connect(m_image, SIGNAL(sigImageUpdated(QRect)), SLOT(imgUpdated(QRect)));
-            connect(m_image, SIGNAL(sigSizeChanged(Q_INT32, Q_INT32)), SLOT(slotImageSizeChanged(Q_INT32, Q_INT32)));
-        }
-    }
-
-    m_layerBox->setImage(m_image);
-    m_birdEyeBox->setImage(m_image);
-}
-
-void KisView::disconnectCurrentImg()
-{
-    if (m_image) {
-        m_image->disconnect(this);
-        m_layerBox->setImage(0);
-        m_birdEyeBox->setImage(0);
-
-        KisConnectPartLayerVisitor v(m_image, this, false);
-        m_image->rootLayer()->accept(v);
-    }
-
-#ifdef HAVE_GL
-    if (m_OpenGLImageContext != 0) {
-        m_OpenGLImageContext->disconnect(this);
-    }
-#endif
-}
-
-void KisView::handlePartLayerAdded(KisLayerSP layer)
-{
-    KisPartLayer* l = dynamic_cast<KisPartLayer*>(layer.data());
-    if (!l)
-        return;
-
-    connect(this, SIGNAL(childActivated(KoDocumentChild*)),
-            layer, SLOT(childActivated(KoDocumentChild*)));
-}
-
-void KisView::imgUpdated(QRect rc)
-{
-    updateCanvas(rc);
-}
-
-void KisView::slotOpenGLImageUpdated(QRect rc)
-{
-    paintOpenGLView(windowToView(rc));
-}
-
-void KisView::profileChanged(KisProfile *  /*profile*/)
-{
-    updateStatusBarProfileLabel();
-}
-
-void KisView::slotImageSizeChanged(Q_INT32 /*w*/, Q_INT32 /*h*/)
-{
-    resizeEvent(0);
-    refreshKisCanvas();
-}
-
-void KisView::resizeCurrentImage(Q_INT32 w, Q_INT32 h, bool cropLayers)
-{
-    if (!currentImg()) return;
-
-    currentImg()->resize(w, h, cropLayers);
-    m_doc->setModified(true);
-    layersUpdated();
-}
-
-void KisView::scaleCurrentImage(double sx, double sy, KisFilterStrategy *filterStrategy)
-{
-    if (!currentImg()) return;
-    currentImg()->scale(sx, sy, m_progress, filterStrategy);
-    m_doc->setModified(true);
-    layersUpdated();
-}
-
-void KisView::rotateCurrentImage(double angle)
-{
-    if (!currentImg()) return;
-    currentImg()->rotate(angle, m_progress);
-    m_doc->setModified(true);
-    layersUpdated();
-}
-
-void KisView::shearCurrentImage(double angleX, double angleY)
-{
-    if (!currentImg()) return;
-    currentImg()->shear(angleX, angleY, m_progress);
-    m_doc->setModified(true);
-    layersUpdated();
-}
-
-
-QPoint KisView::viewToWindow(const QPoint& pt)
-{
-    QPoint converted;
-
-    converted.rx() = static_cast<int>((pt.x() + horzValue()) / zoom());
-    converted.ry() = static_cast<int>((pt.y() + vertValue()) / zoom());
-
-    return converted;
-}
-
-QPoint KisView::viewToWindow(const QPoint& pt) const
-{
-    QPoint converted;
-
-    converted.rx() = static_cast<int>((pt.x() + horzValue()) / zoom());
-    converted.ry() = static_cast<int>((pt.y() + vertValue()) / zoom());
-
-    return converted;
-}
-
-KisPoint KisView::viewToWindow(const KisPoint& pt)
-{
-    KisPoint converted;
-
-    converted.setX((pt.x() + horzValue()) / zoom());
-    converted.setY((pt.y() + vertValue()) / zoom());
-
-    return converted;
-}
-
-QRect KisView::viewToWindow(const QRect& rc)
-{
-    QRect r;
-
-    r.setTopLeft(viewToWindow(rc.topLeft()));
-    r.setRight((int)(ceil((rc.right() + 1.0 + horzValue()) / zoom()) - 1));
-    r.setBottom((int)(ceil((rc.bottom() + 1.0 + vertValue()) / zoom()) - 1));
-
-    return r;
-}
-
-KisRect KisView::viewToWindow(const KisRect& rc)
-{
-    KisRect r;
-    KisPoint p = viewToWindow(KisPoint(rc.x(), rc.y()));
-    r.setX(p.x());
-    r.setY(p.y());
-    r.setWidth(rc.width() / zoom());
-    r.setHeight(rc.height() / zoom());
-
-    return r;
-}
-
-void KisView::viewToWindow(Q_INT32 *x, Q_INT32 *y)
-{
-    if (x && y) {
-        QPoint p = viewToWindow(QPoint(*x, *y));
-        *x = p.x();
-        *y = p.y();
-    }
-}
-
-QPoint KisView::windowToView(const QPoint& pt)
-{
-    QPoint p;
-    p.setX(static_cast<int>(pt.x() * zoom() - horzValue()));
-    p.setY(static_cast<int>(pt.y() * zoom() - vertValue()));
-
-    return p;
-}
-
-QPoint KisView::windowToView(const QPoint& pt) const
-{
-    QPoint p;
-    p.setX(static_cast<int>(pt.x() * zoom() - horzValue()));
-    p.setY(static_cast<int>(pt.y() * zoom() - vertValue()));
-
-    return p;
-}
-
-KisPoint KisView::windowToView(const KisPoint& pt)
-{
-    KisPoint p;
-    p.setX(pt.x() * zoom() - horzValue());
-    p.setY(pt.y() * zoom() - vertValue());
-
-    return p;
-}
-
-QRect KisView::windowToView(const QRect& rc)
-{
-    QRect r;
-
-    r.setTopLeft(windowToView(rc.topLeft()));
-    r.setRight((int)(ceil((rc.right() + 1.0) * zoom()) - horzValue() - 1));
-    r.setBottom((int)(ceil((rc.bottom() + 1.0) * zoom()) - vertValue() - 1));
-
-    return r;
-}
-
-KisRect KisView::windowToView(const KisRect& rc)
-{
-    KisRect r;
-    KisPoint p = windowToView(KisPoint(rc.x(), rc.y()));
-    r.setX(p.x());
-    r.setY(p.y());
-    r.setWidth(rc.width() * zoom());
-    r.setHeight(rc.height() * zoom());
-
-    return r;
-}
-
-void KisView::windowToView(Q_INT32 *x, Q_INT32 *y)
-{
-    if (x && y) {
-        QPoint p = windowToView(QPoint(*x, *y));
-        *x = p.x();
-        *y = p.y();
-    }
-}
-
-void KisView::guiActivateEvent(KParts::GUIActivateEvent *event)
-{
-    Q_ASSERT(event);
-
-    if (event->activated()) {
-
-        KStatusBar *sb = statusBar();
-        if (sb) {
-            sb->show();
-        }
-
-        if (!m_guiActivateEventReceived) {
-            m_guiActivateEventReceived = true;
-            startInitialZoomTimerIfReady();
-        }
-    }
-
-    super::guiActivateEvent(event);
-}
-
-bool KisView::eventFilter(QObject *o, QEvent *e)
-{
-    Q_ASSERT(o);
-    Q_ASSERT(e);
-
-    switch (e->type()) {
-    case QEvent::TabletMove:
-    case QEvent::TabletPress:
-    case QEvent::TabletRelease:
-    {
-        QTabletEvent *te = static_cast<QTabletEvent *>(e);
-        KisInputDevice device;
-
-        switch (te->device()) {
-        default:
-        case QTabletEvent::Stylus:
-        case QTabletEvent::NoDevice:
-            device = KisInputDevice::stylus();
-            break;
-        case QTabletEvent::Puck:
-            device = KisInputDevice::puck();
-            break;
-        case QTabletEvent::Eraser:
-            device = KisInputDevice::eraser();
-            break;
-        }
-
-        setInputDevice(device);
-
-        // We ignore device change due to mouse events for a short duration
-        // after a tablet event, since these are almost certainly mouse events
-        // sent to receivers that don't accept the tablet event.
-        m_tabletEventTimer.start();
-        break;
-    }
-    case QEvent::MouseButtonPress:
-    case QEvent::MouseMove:
-    case QEvent::MouseButtonRelease:
-    {
-#ifdef EXTENDED_X11_TABLET_SUPPORT
-        KisInputDevice device = KisCanvasWidget::findActiveInputDevice();
-
-        if (device != KisInputDevice::mouse()) {
-            setInputDevice(device);
-            m_tabletEventTimer.start();
-        } else
-#endif
-        {
-            if (currentInputDevice() != KisInputDevice::mouse() && m_tabletEventTimer.elapsed() > MOUSE_CHANGE_EVENT_DELAY) {
-                setInputDevice(KisInputDevice::mouse());
-            }
-        }
-        break;
-    }
-    case QEvent::KeyPress:
-    case QEvent::KeyRelease:
-    {
-        if (m_canvas->cursorIsOverCanvas()) {
-            m_canvas->handleKeyEvent(e);
-            return true;
-        }
-        break;
-    }
-#if 0
-    // This code is unnecessary now that there's an application event filter
-    // This eventFilter is called for all widgets already, no need to install event filters multiple times
-    // Even worse: with multiple views, they would all install event filters on each other's widgets,
-    // due to the qapp event filter triggering in all views!
-    case QEvent::ChildInserted:
-    {
-        QChildEvent *childEvent = static_cast<QChildEvent *>(e);
-        QObject *child = childEvent->child();
-        if ( child->isWidgetType() ) {
-
-            child->installEventFilter(this);
-
-            QObjectList *objectList = child->queryList("QWidget");
-            QObjectListIt it(*objectList);
-            QObject *obj;
-            while ((obj = it.current()) != 0) {
-                obj->installEventFilter(this);
-                ++it;
-            }
-            delete objectList;
-        }
-    }
-#endif
-    default:
-        // Ignore
-        break;
-    }
-
-#if 0
-    if ((o == m_hRuler || o == m_vRuler) && (e->type() == QEvent::MouseMove || e->type() == QEvent::MouseButtonRelease)) {
-        QMouseEvent *me = dynamic_cast<QMouseEvent*>(e);
-        QPoint pt = mapFromGlobal(me->globalPos());
-        KisImageSP img = currentImg();
-        KisGuideMgr *mgr;
-
-        if (!img)
-            return super::eventFilter(o, e);
-
-        mgr = img->guides();
-
-        if (e->type() == QEvent::MouseMove && (me->state() & Qt::LeftButton)) {
-            bool flag = geometry().contains(pt);
-            KisGuideSP gd;
-
-            if (m_currentGuide == 0 && flag) {
-                // No guide is being edited and moving mouse over the canvas.
-                // Create a new guide.
-                enterEvent(0);
-                eraseGuides();
-                mgr->unselectAll();
-
-                if (o == m_vRuler)
-                    gd = mgr->add((pt.x() - m_vRuler->width() + horzValue()) / zoom(), Qt::Vertical);
-                else
-                    gd = mgr->add((pt.y() - m_hRuler->height() + vertValue()) / zoom(), Qt::Horizontal);
-
-                m_currentGuide = gd;
-                mgr->select(gd);
-                m_lastGuidePoint = mapToScreen(pt);
-            } else if (m_currentGuide) {
-                if (flag) {
-                    // moved an existing guide.
-                    KisMoveEvent kme(currentInputDevice(), pt, me->globalPos(), PRESSURE_DEFAULT, 0, 0, me->state());
-                    canvasGotMoveEvent(&kme);
-                } else {
-                    //  moved a guide out of the frame, destroy it
-                    leaveEvent(0);
-                    eraseGuides();
-                    mgr->remove(m_currentGuide);
-                    paintGuides();
-                    m_currentGuide = 0;
-                }
-            }
-        } else if (e->type() == QEvent::MouseButtonRelease && m_currentGuide) {
-            eraseGuides();
-            mgr->unselect(m_currentGuide);
-            paintGuides();
-            m_currentGuide = 0;
-            enterEvent(0);
-            KisMoveEvent kme(currentInputDevice(), pt, me->globalPos(), PRESSURE_DEFAULT, 0, 0, Qt::NoButton);
-            canvasGotMoveEvent(&kme);
-        }
-    }
-#endif
-
-    return super::eventFilter(o, e);
-}
-
-#if 0
-void KisView::eraseGuides()
-{
-    KisImageSP img = currentImg();
-
-    if (img) {
-        KisGuideMgr *mgr = img->guides();
-
-        if (mgr)
-            mgr->erase(&m_canvasPixmap, this, horzValue(), vertValue(), zoom());
-    }
-}
-
-void KisView::paintGuides()
-{
-    KisImageSP img = currentImg();
-
-    if (img) {
-        KisGuideMgr *mgr = img->guides();
-
-        if (mgr)
-            mgr->paint(&m_canvasPixmap, this, horzValue(), vertValue(), zoom());
-    }
-}
-
-void KisView::updateGuides()
-{
-    eraseGuides();
-    paintGuides();
-}
-#endif
-
-//void KisView::viewGuideLines()
-//{
-//}
-
-QPoint KisView::mapToScreen(const QPoint& pt)
-{
-    QPoint converted;
-
-    converted.rx() = pt.x() + horzValue();
-    converted.ry() = pt.y() + vertValue();
-    return converted;
-}
-
-void KisView::attach(KisCanvasObserver *observer)
-{
-    Q_ASSERT(observer);
-    if (observer)
-        m_observers.push_back(observer);
-}
-
-void KisView::detach(KisCanvasObserver *observer)
-{
-    Q_ASSERT(observer);
-    if (observer) {
-        vKisCanvasObserver_it it = std::find(m_observers.begin(), m_observers.end(), observer);
-
-        if (it != m_observers.end())
-            m_observers.erase(it);
-    }
-}
-
-void KisView::notifyObservers()
-{
-    for (vKisCanvasObserver_it it = m_observers.begin(); it != m_observers.end(); ++it) {
-        (*it)->update(this);
-    }
-}
-
-KisImageSP KisView::currentImg() const
-{
-    return m_image;
-}
-
-void KisView::setCurrentImage(KisImageSP image)
-{
-    if(!image) return;
-
-    disconnectCurrentImg();
-    m_image = image;
-
-    KisConfig cfg;
-
-#ifdef HAVE_GL
-    if (cfg.useOpenGL()) {
-        m_OpenGLImageContext = KisOpenGLImageContext::getImageContext(image, monitorProfile());
-        m_canvas->createOpenGLCanvas(m_OpenGLImageContext->sharedContextWidget());
-    }
-#endif
-    connectCurrentImg();
-    m_layerBox->setImage(currentImg());
-
-    zoomAroundPoint(0, 0, 1.0);
-
-    if (!currentImg())
-        layersUpdated();
-
-    imgUpdateGUI();
-
-    image->blockSignals(false);
-}
-
-KisColor KisView::bgColor() const
-{
-    return m_bg;
-}
-
-KisColor KisView::fgColor() const
-{
-    return m_fg;
-}
-
-KisBrush *KisView::currentBrush() const
-{
-    return m_brush;
-}
-
-KisPattern *KisView::currentPattern() const
-{
-    return m_pattern;
-}
-
-KisGradient *KisView::currentGradient() const
-{
-    return m_gradient;
-}
-
-KisID KisView::currentPaintop() const
-{
-    return m_paintop;
-}
-
-const KisPaintOpSettings *KisView::currentPaintopSettings() const
-{
-    return m_paintopSettings;
-}
-
-double KisView::zoomFactor() const
-{
-    return zoom();
-}
-
-KisUndoAdapter *KisView::undoAdapter() const
-{
-    return m_adapter;
-}
-
-KisCanvasController *KisView::canvasController() const
-{
-    return const_cast<KisCanvasController*>(static_cast<const KisCanvasController*>(this));
-}
-
-KisToolControllerInterface *KisView::toolController() const
-{
-    return const_cast<KisToolControllerInterface*>(static_cast<const KisToolControllerInterface*>(m_toolManager));
-}
-
-KisDoc *KisView::document() const
-{
-    return m_doc;
-}
-
-KisProgressDisplayInterface *KisView::progressDisplay() const
-{
-    return m_progress;
-}
-
-QCursor KisView::setCanvasCursor(const QCursor & cursor)
-{
-    QCursor oldCursor = m_canvas->cursor();
-    QCursor newCursor;
-
-    KisConfig cfg;
-
-    switch (cfg.cursorStyle()) {
-    case CURSOR_STYLE_TOOLICON:
-        newCursor = cursor;
-        break;
-    case CURSOR_STYLE_CROSSHAIR:
-        newCursor = KisCursor::crossCursor();
-        break;
-    case CURSOR_STYLE_POINTER:
-        newCursor = KisCursor::arrowCursor();
-        break;
-    case CURSOR_STYLE_OUTLINE:
-        newCursor = cursor;
-        break;
-    default:
-        newCursor = cursor;
-    }
-
-    m_canvas->setCursor(newCursor);
-    return oldCursor;
-}
-
-float KisView::HDRExposure() const
-{
-    return m_HDRExposure;
-}
-
-void KisView::setHDRExposure(float exposure)
-{
-    if (exposure != m_HDRExposure) {
-        m_HDRExposure = exposure;
-        notifyObservers();
-        updateCanvas();
-    }
-}
-
-void KisView::createDockers()
-{
-
-    m_birdEyeBox = new KisBirdEyeBox(this);
-    m_birdEyeBox->setCaption(i18n("Overview"));
-    m_paletteManager->addWidget( m_birdEyeBox, "birdeyebox", krita::CONTROL_PALETTE);
-
-    m_hsvwidget = new KoHSVWidget(this, "hsv");
-    m_hsvwidget->setCaption(i18n("HSV"));
-
-    connect(m_hsvwidget, SIGNAL(sigFgColorChanged(const QColor &)), this, SLOT(slotSetFGQColor(const QColor &)));
-    connect(m_hsvwidget, SIGNAL(sigBgColorChanged(const QColor &)), this, SLOT(slotSetBGQColor(const QColor &)));
-    connect(this, SIGNAL(sigFGQColorChanged(const QColor &)), m_hsvwidget, SLOT(setFgColor(const QColor &)));
-    connect(this, SIGNAL(sigBGQColorChanged(const QColor &)), m_hsvwidget, SLOT(setBgColor(const QColor &)));
-    m_paletteManager->addWidget( m_hsvwidget, "hsvwidget", krita::COLORBOX, 0, PALETTE_DOCKER, true);
-
-    m_rgbwidget = new KoRGBWidget(this, "rgb");
-    m_rgbwidget->setCaption(i18n("RGB"));
-    connect(m_rgbwidget, SIGNAL(sigFgColorChanged(const QColor &)), this, SLOT(slotSetFGQColor(const QColor &)));
-    connect(m_rgbwidget, SIGNAL(sigBgColorChanged(const QColor &)), this, SLOT(slotSetBGQColor(const QColor &)));
-    connect(this, SIGNAL(sigFGQColorChanged(const QColor &)), m_rgbwidget, SLOT(setFgColor(const QColor &)));
-    connect(this, SIGNAL(sigBGQColorChanged(const QColor &)), m_rgbwidget, SLOT(setBgColor(const QColor &)));
-    m_paletteManager->addWidget( m_rgbwidget, "rgbwidget", krita::COLORBOX);
-
-    m_graywidget = new KoGrayWidget(this, "gray");
-    m_graywidget->setCaption(i18n("Gray"));
-    connect(m_graywidget, SIGNAL(sigFgColorChanged(const QColor &)), this, SLOT(slotSetFGQColor(const QColor &)));
-    connect(m_graywidget, SIGNAL(sigBgColorChanged(const QColor &)), this, SLOT(slotSetBGQColor(const QColor &)));
-    connect(this, SIGNAL(sigFGQColorChanged(const QColor &)), m_graywidget, SLOT(setFgColor(const QColor &)));
-    connect(this, SIGNAL(sigBGQColorChanged(const QColor &)), m_graywidget, SLOT(setBgColor(const QColor &)));
-    m_paletteManager->addWidget( m_graywidget, "graywidget", krita::COLORBOX);
-
-    //make sure the color chooser get right default values
-    emit sigFGQColorChanged(m_fg.toQColor());
-    emit sigBGQColorChanged(m_bg.toQColor());
-
-    m_palettewidget = new KisPaletteWidget(this);
-    m_palettewidget->setCaption(i18n("Palettes"));
-    connect(m_palettewidget, SIGNAL(colorSelected(const QColor &)),
-            this, SLOT(slotSetFGQColor(const QColor &)));
-    // No BGColor or reverse slotFGChanged->palette connections, since that's not useful here
-
-    KisResourceServerBase* rServer;
-    rServer = KisResourceServerRegistry::instance()->get("PaletteServer");
-    QValueList<KisResource*> resources = rServer->resources();
-    QValueList<KisResource*>::iterator it;
-    for ( it = resources.begin(); it != resources.end(); ++it ) {
-        m_palettewidget->slotAddPalette( *it );
-    }
-    connect(m_palettewidget, SIGNAL(colorSelected(const KisColor &)), this, SLOT(slotSetFGColor(const KisColor &)));
-    m_paletteManager->addWidget( m_palettewidget, "palettewidget", krita::COLORBOX, 10, PALETTE_DOCKER, true);
-}
-
-QPoint KisView::applyViewTransformations(const QPoint& p) const {
-    QPoint point(windowToView(p));
-
-    if (m_hRuler->isShown())
-        point.ry() += m_hRuler->height();
-    if (m_vRuler -> isShown())
-        point.rx() += m_vRuler->width();
-
-    return point;
-}
-
-QPoint KisView::reverseViewTransformations(const QPoint& p) const {
-    // Since we now zoom ourselves, the only thing super::~ does is nothing anymore.
-    // Hence, zoom ourselves, like super would
-    // viewToWindow doesn't take the rulers into account, do that ourselves
-    QPoint point(p);
-    if (m_hRuler -> isShown())
-        point.ry() -= m_hRuler -> height();
-    if (m_vRuler -> isShown())
-        point.rx() -= m_vRuler -> width();
-
-    return viewToWindow(point);
-}
-
-void KisView::canvasAddChild(KoViewChild *child) {
-    super::canvasAddChild(child);
-    connect(this, SIGNAL(viewTransformationsChanged()), child, SLOT(reposition()));
-    m_vScroll->raise();
-    m_hScroll->raise();
-    m_vScroll->raise();
-    m_hRuler->raise();
-    m_vRuler->raise();
-}
-
-void KisView::slotLoadingFinished()
-{
-    // Set the current image for real now everything is ready to go.
-    setCurrentImage(document()->currentImage());
-    m_paletteManager->showWidget( "layerbox" );
-    m_canvas->show();
-    disconnect(document(), SIGNAL(loadingFinished()), this, SLOT(slotLoadingFinished()));
-
-    m_imageLoaded = true;
-    startInitialZoomTimerIfReady();
-}
-
-void KisView::startInitialZoomTimerIfReady()
-{
-    if (m_imageLoaded && m_showEventReceived && m_guiActivateEventReceived) {
-        m_initialZoomTimer.start(250, true);
-    }
-}
-
-void KisView::slotInitialZoomTimeout()
-{
-    Q_ASSERT(!m_paintViewEnabled);
-
-    m_paintViewEnabled = true;
-    setInitialZoomLevel();
-}
-
-
-void KisView::slotCreateMask() {
-    KisPaintLayer* layer = dynamic_cast<KisPaintLayer*>(currentImg()->activeLayer().data());
-    if (!layer)
-        return;
-
-    KNamedCommand *cmd = layer->createMaskCommand();
-    cmd->execute();
-    if (undoAdapter() && undoAdapter()->undo()) {
-        undoAdapter()->addCommand(cmd);
-    }
-}
-
-void KisView::slotMaskFromSelection() {
-    KisPaintLayer* layer = dynamic_cast<KisPaintLayer*>(currentImg()->activeLayer().data());
-    if (!layer)
-        return;
-
-    KNamedCommand *cmd = layer->maskFromSelectionCommand();
-    cmd->execute();
-    if (undoAdapter() && undoAdapter()->undo()) {
-        undoAdapter()->addCommand(cmd);
-    }
-}
-
-void KisView::slotMaskToSelection() {
-    KisPaintLayer* layer = dynamic_cast<KisPaintLayer*>(currentImg()->activeLayer().data());
-    if (!layer)
-        return;
-
-    KNamedCommand *cmd = layer->maskToSelectionCommand();
-    cmd->execute();
-    if (undoAdapter() && undoAdapter()->undo()) {
-        undoAdapter()->addCommand(cmd);
-    }
-}
-
-void KisView::slotApplyMask() {
-    KisPaintLayer* layer = dynamic_cast<KisPaintLayer*>(currentImg()->activeLayer().data());
-    if (!layer)
-        return;
-
-    KNamedCommand *cmd = layer->applyMaskCommand();
-    cmd->execute();
-    if (undoAdapter() && undoAdapter()->undo()) {
-        undoAdapter()->addCommand(cmd);
-    }
-}
-
-void KisView::slotRemoveMask() {
-    KisPaintLayer* layer = dynamic_cast<KisPaintLayer*>(currentImg()->activeLayer().data());
-    if (!layer)
-        return;
-
-    KNamedCommand *cmd = layer->removeMaskCommand();
-    cmd->execute();
-    if (undoAdapter() && undoAdapter()->undo()) {
-        undoAdapter()->addCommand(cmd);
-    }
-}
-
-void KisView::slotEditMask() {
-    KisPaintLayer* layer = dynamic_cast<KisPaintLayer*>(currentImg()->activeLayer().data());
-    if (!layer)
-        return;
-
-    layer->setEditMask(m_editMask->isChecked());
-}
-
-void KisView::slotShowMask() {
-    KisPaintLayer* layer = dynamic_cast<KisPaintLayer*>(currentImg()->activeLayer().data());
-    if (!layer)
-        return;
-
-    layer->setRenderMask(m_showMask->isChecked());
-}
-
-void KisView::maskUpdated() {
-    KisPaintLayer* layer = dynamic_cast<KisPaintLayer*>(currentImg()->activeLayer().data());
-    if (!layer) {
-        m_createMask->setEnabled(false);
-        m_applyMask->setEnabled(false);
-        m_removeMask->setEnabled(false);
-        m_editMask->setEnabled(false);
-        m_showMask->setEnabled(false);
-        return;
-    }
-    m_createMask->setEnabled(!layer->hasMask());
-    m_maskFromSelection->setEnabled(true); // Perhaps also update this to false when no selection?
-    m_maskToSelection->setEnabled(layer->hasMask());
-    m_applyMask->setEnabled(layer->hasMask());
-    m_removeMask->setEnabled(layer->hasMask());
-
-    m_editMask->setEnabled(layer->hasMask());
-    m_editMask->setChecked(layer->editMask());
-    m_showMask->setEnabled(layer->hasMask());
-    m_showMask->setChecked(layer->renderMask());
-}
-
-#include "kis_view.moc"
-
--- koffice-1.6.1/krita/ui/squeezedcombobox.h	2006-11-17 10:11:34.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/squeezedcombobox.h	2006-12-10 13:44:23.000000000 -0500
@@ -30,6 +30,8 @@
 #include <qcombobox.h>
 #include <qtooltip.h>
 
+#include <koffice_export.h>
+
 class SqueezedComboBox;
 
 /** @class SqueezedComboBoxTip
@@ -79,7 +81,7 @@
  * @image html squeezedcombobox.png "This is how it looks"
  * @author Tom Albers
  */
-class SqueezedComboBox : public QComboBox
+class KRITAUI_EXPORT SqueezedComboBox : public QComboBox
 {
     Q_OBJECT
 
--- koffice-1.6.1/krita/ui/wdgperformancesettings.ui.rej	2006-11-18 06:39:38.000000000 -0500
+++ koffice-1.6.1-new/krita/ui/wdgperformancesettings.ui.rej	1969-12-31 19:00:00.000000000 -0500
@@ -1,18 +0,0 @@
-***************
-*** 12,20 ****
-              <height>220</height>
-          </rect>
-      </property>
--     <property name="caption">
--         <string>WdgPerformanceSettings</string>
--     </property>
-      <vbox>
-          <property name="name">
-              <cstring>unnamed</cstring>
---- 12,17 ----
-              <height>220</height>
-          </rect>
-      </property>
-      <vbox>
-          <property name="name">
-              <cstring>unnamed</cstring>
--- koffice-1.6.1/kspread/kspread_factory.h	2006-11-17 10:13:25.000000000 -0500
+++ koffice-1.6.1-new/kspread/kspread_factory.h	2006-12-10 13:44:23.000000000 -0500
@@ -28,7 +28,7 @@
 namespace KSpread
 {
 
-class Factory : public KoFactory
+class KSPREAD_EXPORT Factory : public KoFactory
 {
     Q_OBJECT
 public:
--- koffice-1.6.1/kspread/kspread_util.h	2006-11-17 10:13:25.000000000 -0500
+++ koffice-1.6.1-new/kspread/kspread_util.h	2006-12-10 13:44:23.000000000 -0500
@@ -318,11 +318,11 @@
 QPen        util_toPen( QDomElement & element );
 int         util_penCompare( QPen const & pen1, QPen const & pen2 );
 
-QString convertRefToRange( const QString & sheet, const QRect & rect );
-QString convertRefToBase( const QString & sheet, const QRect & rect );
-QString convertRangeToRef( const QString & sheetName, const QRect & _area );
+KSPREAD_EXPORT QString convertRefToRange( const QString & sheet, const QRect & rect );
+KSPREAD_EXPORT QString convertRefToBase( const QString & sheet, const QRect & rect );
+KSPREAD_EXPORT QString convertRangeToRef( const QString & sheetName, const QRect & _area );
 
-void insertBracket( QString & s );
+KSPREAD_EXPORT void insertBracket( QString & s );
 QString convertOasisPenToString( const QPen & pen );
 QPen convertOasisStringToPen( const QString &str );
 
--- koffice-1.6.1/kspread/manipulator_data.h	2006-11-17 10:13:25.000000000 -0500
+++ koffice-1.6.1-new/kspread/manipulator_data.h	2006-12-10 13:44:23.000000000 -0500
@@ -24,6 +24,7 @@
 #include "manipulator.h"
 #include "kspread_global.h"
 #include "kspread_value.h"
+#include <koffice_export.h>
 
 namespace KSpread {
 
@@ -63,7 +64,7 @@
  * If multiple ranges are selected, they all get set to the same values
  */
 
-class DataManipulator : public AbstractDataManipulator {
+class KSPREAD_EXPORT DataManipulator : public AbstractDataManipulator {
   public:
     DataManipulator ();
     virtual ~DataManipulator ();
@@ -97,7 +98,7 @@
 
 /** class ProtectedCheck can be used to check, whether a particular
   range is protected or not */
-class ProtectedCheck : public Region {
+class KSPREAD_EXPORT ProtectedCheck : public Region {
   public:
     ProtectedCheck ();
     virtual ~ProtectedCheck ();
--- koffice-1.6.1/kspread/selection.h	2006-11-17 10:13:25.000000000 -0500
+++ koffice-1.6.1-new/kspread/selection.h	2006-12-10 13:44:23.000000000 -0500
@@ -31,7 +31,7 @@
 {
 class View;
 
-class Selection : public QObject, public Region
+class KSPREAD_EXPORT Selection : public QObject, public Region
 {
   Q_OBJECT
 public:
--- koffice-1.6.1/kword/KWFactory.h	2006-11-17 10:01:21.000000000 -0500
+++ koffice-1.6.1-new/kword/KWFactory.h	2006-12-10 13:44:23.000000000 -0500
@@ -21,10 +21,11 @@
 #define KWORD_FACTORY_H
 
 #include <KoFactory.h>
+#include <koffice_export.h>
 
 class KAboutData;
 
-class KWFactory : public KoFactory
+class KWORD_EXPORT KWFactory : public KoFactory
 {
     Q_OBJECT
 public:
--- koffice-1.6.1/lib/configure.in.in	2006-11-17 10:08:45.000000000 -0500
+++ koffice-1.6.1-new/lib/configure.in.in	2006-12-10 13:44:23.000000000 -0500
@@ -8,7 +8,7 @@
 AC_SUBST(KFORMULA_INCLUDES, '-I$(top_srcdir)/lib/kformula -I$(top_builddir)/lib/kformula')
 dnl those are included with e.g. <koproperty/set.h>
 AC_SUBST(KOPROPERTY_INCLUDES, '-I$(top_srcdir)/lib -I$(top_builddir)/lib')
-AC_SUBST(KROSS_INCLUDES, '-I$(top_srcdir)/lib/kross -I$(top_builddir)/lib/kross')
+AC_SUBST(KROSS_INCLUDES, '-I$(top_srcdir)/lib/kross -I$(top_builddir)/lib/kross $(KOFFICECORE_INCLUDES)')
 AC_SUBST(LIB_KOFFICEUI, '$(top_builddir)/lib/kofficeui/libkofficeui.la')
 AC_SUBST(LIB_KOFFICECORE, '$(top_builddir)/lib/kofficecore/libkofficecore.la')
 AC_SUBST(LIB_KSTORE, '$(top_builddir)/lib/store/libkstore.la')
--- koffice-1.6.1/lib/kofficecore/KoTemplates.h	2006-11-17 10:07:58.000000000 -0500
+++ koffice-1.6.1-new/lib/kofficecore/KoTemplates.h	2006-12-10 13:44:23.000000000 -0500
@@ -105,7 +105,7 @@
 };
 
 
-class KoTemplateTree {
+class KOFFICECORE_EXPORT KoTemplateTree {
 
 public:
     KoTemplateTree(const QCString &templateType, KInstance *instance,
@@ -144,7 +144,7 @@
 
 
 namespace KoTemplates {
-QString stripWhiteSpace(const QString &string);
+KOFFICECORE_EXPORT QString stripWhiteSpace(const QString &string);
 }
 
 #endif
--- koffice-1.6.1/lib/kofficecore/Makefile.am	2006-11-17 10:07:58.000000000 -0500
+++ koffice-1.6.1-new/lib/kofficecore/Makefile.am	2006-12-10 13:44:23.000000000 -0500
@@ -4,7 +4,7 @@
 KDE_CXXFLAGS = $(USE_RTTI) $(WOVERLOADED_VIRTUAL)
 INCLUDES= $(KSTORE_INCLUDES) $(KWMF_INCLUDES) $(all_includes)
 libkofficecore_la_LIBADD  = $(LIB_KSTORE) $(LIB_KOWMF) $(LIB_KPARTS) \
-	$(LIB_KDEPRINT) $(LIB_KABC) $(LIB_KWMF)
+	$(LIB_KDEPRINT) $(LIB_KABC) $(LIB_KWMF) $(LIB_X11)
 
 ####### Files
 
--- koffice-1.6.1/lib/kofficecore/koffice_export.h	2006-11-17 10:07:58.000000000 -0500
+++ koffice-1.6.1-new/lib/kofficecore/koffice_export.h	2006-12-10 13:44:23.000000000 -0500
@@ -134,6 +134,7 @@
 # endif
 #endif
 
+#define KROSS_EXPORT KDE_EXPORT
 #define KPRESENTER_EXPORT KDE_EXPORT
 #define KCHART_EXPORT KDE_EXPORT
 #define KDCHART_EXPORT KDE_EXPORT
@@ -168,6 +169,7 @@
 /* kdemacros is OK, we can use gcc visibility macros */
 #define KOFFICECORE_EXPORT KOFFICE_EXPORT
 #define KOFFICEUI_EXPORT KOFFICE_EXPORT
+#define KROSS_EXPORT KOFFICE_EXPORT
 #define KOPALETTE_EXPORT KOFFICE_EXPORT
 #define KOTEXT_EXPORT KOFFICE_EXPORT
 #define KOFORMULA_EXPORT KOFFICE_EXPORT
--- koffice-1.6.1/lib/kofficeui/KoBrush.h	2006-11-17 10:08:28.000000000 -0500
+++ koffice-1.6.1-new/lib/kofficeui/KoBrush.h	2006-12-10 13:44:23.000000000 -0500
@@ -22,6 +22,7 @@
 #define KOBRUSH_H
 
 #include <qbrush.h>
+#include <koffice_export.h>
 
 class KoGenStyle;
 class KoGenStyles;
@@ -47,7 +48,7 @@
     FT_GRADIENT = 1
 };
 
-class KoBrush
+class KOFFICEUI_EXPORT KoBrush
 {
 public:
     KoBrush();
--- koffice-1.6.1/lib/kofficeui/KoGeneralPropertyUi.ui	2006-11-17 10:08:28.000000000 -0500
+++ koffice-1.6.1-new/lib/kofficeui/KoGeneralPropertyUi.ui	2006-12-10 13:44:23.000000000 -0500
@@ -4,6 +4,7 @@
     <property name="name">
         <cstring>KoGeneralPropertyUI</cstring>
     </property>
+    <exportmacro>KOFFICEUI_EXPORT</exportmacro>
     <property name="geometry">
         <rect>
             <x>0</x>
@@ -190,4 +191,7 @@
     </image>
 </images>
 <layoutdefaults spacing="6" margin="11"/>
+<includes>
+    <include location="global" impldecl="in declaration">koffice_export.h</include>
+</includes>
 </UI>
--- koffice-1.6.1/lib/kofficeui/KoGuideLineDia.h	2006-11-17 10:08:28.000000000 -0500
+++ koffice-1.6.1-new/lib/kofficeui/KoGuideLineDia.h	2006-12-10 13:44:23.000000000 -0500
@@ -27,6 +27,7 @@
 #include "KoRect.h"
 #include "KoPoint.h"
 
+#include <koffice_export.h>
 
 class KoUnitDoubleSpinBox;
 class QRadioButton;
@@ -34,7 +35,7 @@
 /**
  * @brief Class for setting a guide line position.
  */
-class KoGuideLineDia : public KDialogBase
+class KOFFICEUI_EXPORT KoGuideLineDia : public KDialogBase
 {
     Q_OBJECT
 public:
--- koffice-1.6.1/lib/kofficeui/KoPageLayoutColumns.h	2006-11-17 10:08:28.000000000 -0500
+++ koffice-1.6.1-new/lib/kofficeui/KoPageLayoutColumns.h	2006-12-10 13:44:23.000000000 -0500
@@ -25,6 +25,7 @@
 #include <KoUnit.h>
 #include <KoPageLayout.h>
 #include <KoPageLayoutColumnsBase.h>
+#include <koffice_export.h>
 
 class QWidget;
 class KoUnitDoubleSpinBox;
@@ -33,7 +34,7 @@
 /**
  * This class is a widget that shows the KoColumns data structure and allows the user to change it.
  */
-class KoPageLayoutColumns : public KoPageLayoutColumnsBase {
+class KOFFICEUI_EXPORT KoPageLayoutColumns : public KoPageLayoutColumnsBase {
     Q_OBJECT
 
 public:
--- koffice-1.6.1/lib/kofficeui/KoPageLayoutSize.h	2006-11-17 10:08:28.000000000 -0500
+++ koffice-1.6.1-new/lib/kofficeui/KoPageLayoutSize.h	2006-12-10 13:44:23.000000000 -0500
@@ -26,6 +26,7 @@
 #include <kdialogbase.h>
 #include <KoPageLayout.h>
 #include <KoPageLayoutDia.h>
+#include <koffice_export.h>
 
 class QComboBox;
 class KoUnitDoubleSpinBox;
@@ -34,7 +35,7 @@
 /**
  * This class is a widget that shows the KoPageLayout data structure and allows the user to change it.
  */
-class KoPageLayoutSize : public QWidget {
+class KOFFICEUI_EXPORT KoPageLayoutSize : public QWidget {
     Q_OBJECT
 
 public:
--- koffice-1.6.1/lib/kofficeui/KoPen.h	2006-11-17 10:08:28.000000000 -0500
+++ koffice-1.6.1-new/lib/kofficeui/KoPen.h	2006-12-10 13:44:23.000000000 -0500
@@ -21,13 +21,14 @@
 #define KOPEN_H
 
 #include <qpen.h>
+#include <koffice_export.h>
 
 class KoZoomHandler;
 
 /**
  * Pen that handles line widths in points
  */
-class KoPen : public QPen
+class KOFFICEUI_EXPORT KoPen : public QPen
 {
   public:
     KoPen();
--- koffice-1.6.1/lib/kopainter/ko_gray_widget.h	2006-11-17 10:08:17.000000000 -0500
+++ koffice-1.6.1-new/lib/kopainter/ko_gray_widget.h	2006-12-10 13:44:23.000000000 -0500
@@ -32,7 +32,7 @@
 class QSpinBox;
 class KDualColorButton;
 
-class KoGrayWidget
+class KOPAINTER_EXPORT KoGrayWidget
      : public QWidget
 {
     Q_OBJECT
--- koffice-1.6.1/lib/kopainter/ko_hsv_widget.h	2006-11-17 10:08:17.000000000 -0500
+++ koffice-1.6.1-new/lib/kopainter/ko_hsv_widget.h	2006-12-10 13:44:23.000000000 -0500
@@ -35,7 +35,7 @@
 class QLabel;
 class QSpinBox;
 
-class KoHSVWidget
+class KOPAINTER_EXPORT KoHSVWidget
      : public QWidget
 {
     Q_OBJECT
--- koffice-1.6.1/lib/kopainter/ko_rgb_widget.h	2006-11-17 10:08:17.000000000 -0500
+++ koffice-1.6.1-new/lib/kopainter/ko_rgb_widget.h	2006-12-10 13:44:23.000000000 -0500
@@ -34,7 +34,7 @@
 class KoColorSlider;
 class QColor;
 
-class KoRGBWidget
+class KOPAINTER_EXPORT KoRGBWidget
      : public QWidget
 {
     Q_OBJECT
--- koffice-1.6.1/lib/kotext/KoParagDia_p.h	2006-11-17 10:08:42.000000000 -0500
+++ koffice-1.6.1-new/lib/kotext/KoParagDia_p.h	2006-12-10 13:44:23.000000000 -0500
@@ -26,6 +26,8 @@
 #include <qgroupbox.h>
 #include <KoParagCounter.h>
 #include <qspinbox.h>
+#include <koffice_export.h>
+
 class QWidget;
 class QPainter;
 
@@ -110,7 +112,7 @@
 /* class KoBorderPreview                                          */
 /******************************************************************/
 
-class KoBorderPreview : public QFrame/*QGroupBox*/
+class KOTEXT_EXPORT KoBorderPreview : public QFrame/*QGroupBox*/
 {
     Q_OBJECT
 
--- koffice-1.6.1/lib/kross/api/callable.h	2006-11-17 10:08:22.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/api/callable.h	2006-12-10 13:44:23.000000000 -0500
@@ -36,7 +36,7 @@
      * and implement the \a Object::call() method to handle
      * the call.
      */
-    class Callable : public Object
+    class KDE_EXPORT Callable : public Object
     {
         public:
 
--- koffice-1.6.1/lib/kross/api/dict.h	2006-11-17 10:08:22.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/api/dict.h	2006-12-10 13:44:23.000000000 -0500
@@ -32,7 +32,7 @@
      * The Dict class implementates \a Value to handle
      * key=value base dictonaries/maps.
      */
-    class Dict : public Value< List, QMap<QString, Object::Ptr> >
+    class KDE_EXPORT Dict : public Value< List, QMap<QString, Object::Ptr> >
     {
             friend class Value< List, QMap<QString, Object::Ptr> >;
         public:
--- koffice-1.6.1/lib/kross/api/eventaction.h	2006-11-17 10:08:22.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/api/eventaction.h	2006-12-10 13:44:23.000000000 -0500
@@ -37,7 +37,7 @@
      * into the Kross object hierachy and provide access to
      * them.
      */
-    class EventAction : public Event<EventAction>
+    class KDE_EXPORT EventAction : public Event<EventAction>
     {
 
         public:
--- koffice-1.6.1/lib/kross/api/eventsignal.h	2006-11-17 10:08:22.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/api/eventsignal.h	2006-12-10 13:44:23.000000000 -0500
@@ -38,7 +38,7 @@
      * instance and a functionname is represented with
      * a EventSignal and handled by \a EventManager.
      */
-    class EventSignal : public Event<EventSignal>
+    class KDE_EXPORT EventSignal : public Event<EventSignal>
     {
         public:
 
--- koffice-1.6.1/lib/kross/api/eventslot.h	2006-11-17 10:08:22.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/api/eventslot.h	2006-12-10 13:44:23.000000000 -0500
@@ -33,7 +33,7 @@
      * instance and a functionname is represented with
      * a EventSlot and handled by the \a EventManager.
      */
-    class EventSlot : public Event<EventSlot>
+    class KDE_EXPORT EventSlot : public Event<EventSlot>
     {
         public:
 
--- koffice-1.6.1/lib/kross/api/exception.h	2006-11-17 10:08:22.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/api/exception.h	2006-12-10 13:44:23.000000000 -0500
@@ -35,7 +35,7 @@
      * exceptions. Those exceptions are inherited from \a Object
      * and therefore they are first class citizens in Kross.
      */
-    class Exception : public Object
+    class KDE_EXPORT Exception : public Object
     {
         public:
 
--- koffice-1.6.1/lib/kross/api/interpreter.h	2006-11-17 10:08:22.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/api/interpreter.h	2006-12-10 13:44:23.000000000 -0500
@@ -38,7 +38,7 @@
      * is used to provide some abstract informations about each interpreter
      * we are able to use within the \a Manager singelton.
      */
-    class InterpreterInfo
+    class KDE_EXPORT InterpreterInfo
     {
         public:
 
@@ -159,7 +159,7 @@
      * The Interpreter will be managed by the \a Kross::Manager
      * class.
      */
-    class Interpreter
+    class KDE_EXPORT Interpreter
     {
         public:
 
--- koffice-1.6.1/lib/kross/api/list.h	2006-11-17 10:08:22.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/api/list.h	2006-12-10 13:44:23.000000000 -0500
@@ -33,7 +33,7 @@
      * The List class implementates \a Value to handle
      * lists and collections.
      */
-    class List : public Value< List, QValueList<Object::Ptr> >
+    class KDE_EXPORT List : public Value< List, QValueList<Object::Ptr> >
     {
             friend class Value< List, QValueList<Object::Ptr> >;
         public:
--- koffice-1.6.1/lib/kross/api/object.h	2006-11-17 10:08:22.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/api/object.h	2006-12-10 13:44:23.000000000 -0500
@@ -47,7 +47,7 @@
      * This class implementates reference counting for shared
      * objects. So, no need to take care of freeing objects.
      */
-    class Object : public KShared
+    class KDE_EXPORT Object : public KShared
     {
         public:
 
--- koffice-1.6.1/lib/kross/api/qtobject.h	2006-11-17 10:08:22.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/api/qtobject.h	2006-12-10 13:44:23.000000000 -0500
@@ -42,7 +42,7 @@
      * This class publishs all SIGNAL's, SLOT's and Q_PROPERTY's
      * the QObject has.
      */
-    class QtObject : public Kross::Api::Class<QtObject>
+    class KDE_EXPORT QtObject : public Kross::Api::Class<QtObject>
     {
         public:
 
--- koffice-1.6.1/lib/kross/api/script.h	2006-11-17 10:08:22.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/api/script.h	2006-12-10 13:44:23.000000000 -0500
@@ -42,7 +42,7 @@
      * that implements the \a Script functionality for the
      * defined \a Interpreter .
      */
-    class Script
+    class KDE_EXPORT Script
     {
         public:
 
--- koffice-1.6.1/lib/kross/api/variant.h	2006-11-17 10:08:22.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/api/variant.h	2006-12-10 13:44:23.000000000 -0500
@@ -35,7 +35,7 @@
      * Variant value to wrap a QVariant into a \a Kross::Api::Value
      * to enable primitive types like strings or numerics.
      */
-    class Variant : public Value<Variant, QVariant>
+    class KDE_EXPORT Variant : public Value<Variant, QVariant>
     {
             friend class Value<Variant, QVariant>;
         public:
--- koffice-1.6.1/lib/kross/configure.in.in	2006-11-17 10:08:23.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/configure.in.in	2006-12-10 13:44:23.000000000 -0500
@@ -14,8 +14,8 @@
 
 # Compile the Kross python plugin only if both, $LIBPYTHON and
 # $PYTHONINC, are defined.
-AM_CONDITIONAL(compile_kross_python,
-               test -n "$LIBPYTHON" && test -n "$PYTHONINC")
+AM_CONDITIONAL(compile_kross_python, false)
+#               test -n "$LIBPYTHON" && test -n "$PYTHONINC")
 
 ###############################
 # Check for Ruby
--- koffice-1.6.1/lib/kross/main/krossconfig.h	2006-11-17 10:08:21.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/main/krossconfig.h	2006-12-10 13:44:23.000000000 -0500
@@ -21,6 +21,7 @@
 #define KROSS_MAIN_KROSSCONFIG_H
 
 #include <qstring.h>
+#include <koffice_export.h>
 
 /**
  * The Kross scripting bridge to embed scripting functionality
@@ -57,12 +58,12 @@
         /**
          * Debugging function.
          */
-        void krossdebug(const QString &s);
+        KROSS_EXPORT void krossdebug(const QString &s);
 
         /**
          * Warning function.
          */
-        void krosswarning(const QString &s);
+        KROSS_EXPORT void krosswarning(const QString &s);
 
     #else
         // Define these to an empty statement if debugging is disabled.
--- koffice-1.6.1/lib/kross/main/mainmodule.h	2006-11-17 10:08:21.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/main/mainmodule.h	2006-12-10 13:44:23.000000000 -0500
@@ -50,7 +50,7 @@
      * for a root node in a tree of \a Kross::Api::Object
      * instances.
      */
-    class MainModule : public Module
+    class KDE_EXPORT MainModule : public Module
     {
         public:
 
--- koffice-1.6.1/lib/kross/main/scriptaction.h	2006-11-17 10:08:21.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/main/scriptaction.h	2006-12-10 13:44:23.000000000 -0500
@@ -25,6 +25,8 @@
 
 #include "scriptcontainer.h"
 
+#include <koffice_export.h>
+
 namespace Kross { namespace Api {
 
     // Forward declarations.
@@ -36,7 +38,7 @@
      * A ScriptAction extends a KAction by providing a wrapper around
      * a \a ScriptContainer to execute scripting code on activation.
      */
-    class ScriptAction
+    class KROSS_EXPORT ScriptAction
         : public KAction
         , public Kross::Api::ScriptContainer
     {
--- koffice-1.6.1/lib/kross/main/scriptcontainer.h	2006-11-17 10:08:21.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/main/scriptcontainer.h	2006-12-10 13:44:23.000000000 -0500
@@ -47,7 +47,7 @@
      * The class \a ScriptAction provides a higher level class
      * to work with a \a ScriptContainer instances.
      */
-    class ScriptContainer : public MainModule
+    class KDE_EXPORT ScriptContainer : public MainModule
     {
             // We protected the constructor cause ScriptContainer
             // instances should be created only within the
--- koffice-1.6.1/lib/kross/main/wdgscriptsmanager.h	2006-11-17 10:08:21.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/main/wdgscriptsmanager.h	2006-12-10 13:44:23.000000000 -0500
@@ -22,6 +22,8 @@
 #include "main/scriptaction.h"
 #include "main/wdgscriptsmanagerbase.h"
 
+#include <koffice_export.h>
+
 class Scripting;
 
 namespace Kross { namespace Api {
@@ -32,7 +34,7 @@
 /**
 @author Cyrille Berger
 */
-class WdgScriptsManager : public WdgScriptsManagerBase
+class KROSS_EXPORT WdgScriptsManager : public WdgScriptsManagerBase
 {
     Q_OBJECT
     public:
--- koffice-1.6.1/lib/kross/ruby/Makefile.am	2006-11-17 10:08:20.000000000 -0500
+++ koffice-1.6.1-new/lib/kross/ruby/Makefile.am	2006-12-10 13:44:23.000000000 -0500
@@ -1,6 +1,6 @@
 include $(top_srcdir)/lib/kross/Makefile.global
 
-INCLUDES = -I$(top_srcdir)/lib/kross -I$(RUBY_INCLUDEDIR) $(all_includes)
+INCLUDES = $(KROSS_INCLUDES) -I$(RUBY_INCLUDEDIR) $(all_includes)
 METASOURCES = AUTO
 kde_module_LTLIBRARIES = krossruby.la
 
--- koffice-1.6.1/kpresenter/Makefile.am	2006-11-17 10:13:01.000000000 -0500
+++ koffice-1.6.1-new/kpresenter/Makefile.am	2006-12-16 09:14:02.000000000 -0500
@@ -72,7 +72,7 @@
 if include_ARTS
 ARTSKDE = -lartskde
 endif
-libkpresenterprivate_la_LIBADD = autoformEdit/libaf.la $(LIB_KOFFICEUI) $(LIB_KOTEXT) $(LIB_KOPAINTER) $(ARTSKDE)
+libkpresenterprivate_la_LIBADD = autoformEdit/libaf.la $(LIB_KOFFICEUI) $(LIB_KOTEXT) $(LIB_KOPAINTER) $(ARTSKDE) -lXext
 
 ## The part
 kde_module_LTLIBRARIES = libkpresenterpart.la
