diff -uNr qt-x11-free-3.2.3/Makefile qt-x11-free-3.2.3-new/Makefile
--- qt-x11-free-3.2.3/Makefile	Sun Aug  3 07:45:14 2003
+++ qt-x11-free-3.2.3-new/Makefile	Tue Feb  3 16:37:00 2004
@@ -11,7 +11,7 @@
 install: FORCE
 	@$(MAKE) qt.install
 
-all: symlinks src-qmake src-moc sub-src sub-tools sub-tutorial sub-examples
+all: symlinks src-qmake src-moc sub-src sub-tools
 	@echo
 	@echo "The Qt library is now built in ./lib"
 	@echo "The Qt examples are built in the directories in ./examples"
diff -uNr qt-x11-free-3.2.3/include/qdragobject.h qt-x11-free-3.2.3-new/include/qdragobject.h
--- qt-x11-free-3.2.3/include/qdragobject.h	Mon Nov 10 05:22:12 2003
+++ qt-x11-free-3.2.3-new/include/qdragobject.h	Tue Feb  3 16:37:01 2004
@@ -245,10 +245,11 @@
     void move( const QPoint & );
     void drop();
     void updatePixmap();
+    void updatePixmap( const QPoint& cursorPos );
 
 private:
     QDragObject * object;
-    void updateMode( ButtonState newstate );
+    bool updateMode( ButtonState newstate );
     void updateCursor();
 
     QWidget * dragSource;
diff -uNr qt-x11-free-3.2.3/include/qglobal.h qt-x11-free-3.2.3-new/include/qglobal.h
--- qt-x11-free-3.2.3/include/qglobal.h	Mon Nov 10 05:21:38 2003
+++ qt-x11-free-3.2.3-new/include/qglobal.h	Tue Feb  3 16:37:01 2004
@@ -79,6 +79,10 @@
      UNIX	- Any UNIX BSD/SYSV system
 */
 
+#ifndef __DARWIN_X11__
+#define __DARWIN_X11__
+#endif
+
 #if defined(__DARWIN_X11__)
 #  define Q_OS_DARWIN
 #elif defined(__APPLE__) && defined(__GNUC__)
@@ -527,6 +531,8 @@
 
 #if defined(Q_OS_MAC9)
 #  define Q_WS_MAC9
+#elif defined(__DARWIN_X11__)
+#  define Q_WS_X11
 #elif defined(Q_OS_MSDOS)
 #  define Q_WS_WIN16
 #  error "Qt requires Win32 and does not work with Windows 3.x"
diff -uNr qt-x11-free-3.2.3/include/qprogressbar.h qt-x11-free-3.2.3-new/include/qprogressbar.h
--- qt-x11-free-3.2.3/include/qprogressbar.h	Mon Nov 10 05:22:32 2003
+++ qt-x11-free-3.2.3-new/include/qprogressbar.h	Tue Feb  3 16:38:34 2004
@@ -61,6 +61,7 @@
 public:
     QProgressBar( QWidget* parent=0, const char* name=0, WFlags f=0 );
     QProgressBar( int totalSteps, QWidget* parent=0, const char* name=0, WFlags f=0 );
+    virtual ~QProgressBar();
 
     int		totalSteps() const;
     int		progress()   const;
@@ -91,6 +92,7 @@
     virtual bool setIndicator( QString & progress_str, int progress,
 			       int totalSteps );
     void styleChange( QStyle& );
+    bool	requireRepaint( int newProgress ) const;
 
 private:
     int		total_steps;
diff -uNr qt-x11-free-3.2.3/include/qvaluelist.h qt-x11-free-3.2.3-new/include/qvaluelist.h
--- qt-x11-free-3.2.3/include/qvaluelist.h	Mon Nov 10 05:21:38 2003
+++ qt-x11-free-3.2.3-new/include/qvaluelist.h	Tue Feb  3 16:38:28 2004
@@ -636,13 +636,11 @@
     l.clear();
     Q_UINT32 c;
     s >> c;
-    for( Q_UINT32 i = 0; i < c; ++i )
+    for( Q_UINT32 i = 0; i < c && !s.atEnd(); ++i )
     {
 	T t;
 	s >> t;
 	l.append( t );
-	if ( s.atEnd() )
-	    break;
     }
     return s;
 }
diff -uNr qt-x11-free-3.2.3/mkspecs/darwin-g++/qmake.conf qt-x11-free-3.2.3-new/mkspecs/darwin-g++/qmake.conf
--- qt-x11-free-3.2.3/mkspecs/darwin-g++/qmake.conf	Mon Nov 10 05:23:45 2003
+++ qt-x11-free-3.2.3-new/mkspecs/darwin-g++/qmake.conf	Tue Feb  3 16:37:01 2004
@@ -8,27 +8,27 @@
 
 MAKEFILE_GENERATOR	= UNIX
 TEMPLATE		= app
-CONFIG			+= qt warn_on release
-CONFIG			+= qt warn_on release link_prl
-DEFINES                 += __DARWIN_X11__
+CONFIG			+= qt warn_on release link_prl lib_version_first
+DEFINES			+= __DARWIN_X11__
 
-QMAKE_CC		= cc
+QMAKE_CC		= gcc-3.3
 QMAKE_LEX		= flex
 QMAKE_LEXFLAGS		= 
 QMAKE_YACC		= yacc
 QMAKE_YACCFLAGS		= -d
-QMAKE_CFLAGS		= -pipe
+QMAKE_CFLAGS		= -pipe -fno-common -fPIC
 QMAKE_CFLAGS_DEPS	= -M
 QMAKE_CFLAGS_WARN_ON	= -Wall -W
 QMAKE_CFLAGS_WARN_OFF	= -w
-QMAKE_CFLAGS_RELEASE	= -O2
+QMAKE_CFLAGS_RELEASE	= -Os
 QMAKE_CFLAGS_DEBUG	= -g
 QMAKE_CFLAGS_SHLIB	= -fPIC
 QMAKE_EXTENSION_SHLIB	= dylib
+QMAKE_EXTENSION_PLUGIN  = so
 QMAKE_CFLAGS_YACC	= -Wno-unused -Wno-parentheses
 QMAKE_CFLAGS_THREAD	=
 
-QMAKE_CXX		= c++
+QMAKE_CXX		= c++-3.3
 QMAKE_CXXFLAGS		= $$QMAKE_CFLAGS
 QMAKE_CXXFLAGS_DEPS	= $$QMAKE_CFLAGS_DEPS
 QMAKE_CXXFLAGS_WARN_ON	= $$QMAKE_CFLAGS_WARN_ON
@@ -39,22 +39,22 @@
 QMAKE_CXXFLAGS_YACC	= $$QMAKE_CFLAGS_YACC
 QMAKE_CXXFLAGS_THREAD	=
 
-QMAKE_INCDIR		= /usr/local/include
-QMAKE_LIBDIR		=
+QMAKE_INCDIR		= @PREFIX@/include/qt
+QMAKE_LIBDIR		= @PREFIX@/lib
 QMAKE_INCDIR_X11	= /usr/X11R6/include
 QMAKE_LIBDIR_X11	= /usr/X11R6/lib
-QMAKE_INCDIR_QT		= $(QTDIR)/include
-QMAKE_LIBDIR_QT		= $(QTDIR)/lib
+QMAKE_INCDIR_QT		= @PREFIX@/include/qt
+QMAKE_LIBDIR_QT		= @PREFIX@/lib
 QMAKE_INCDIR_OPENGL	= /usr/X11R6/include
 QMAKE_LIBDIR_OPENGL	= /usr/X11R6/lib
 
-QMAKE_LINK		= c++
-QMAKE_LINK_SHLIB	= c++
-QMAKE_LFLAGS		=
+QMAKE_LINK		= c++-3.3
+QMAKE_LINK_SHLIB	= c++-3.3
+QMAKE_LFLAGS		= -headerpad_max_install_names
 QMAKE_LFLAGS_RELEASE	=
 QMAKE_LFLAGS_DEBUG	=
-QMAKE_LFLAGS_APP        = 
-QMAKE_LFLAGS_SHLIB	= -dynamiclib
+QMAKE_LFLAGS_APP	= -prebind
+QMAKE_LFLAGS_SHLIB	= -dynamiclib -single_module -install_name $$QMAKE_LIBDIR/$(TARGET1)
 QMAKE_LFLAGS_PLUGIN	= -bundle
 QMAKE_LFLAGS_THREAD	= 
 
@@ -63,17 +63,17 @@
 
 QMAKE_RPATH		= 
 
-QMAKE_LIBS_DYNLOAD	=
+QMAKE_LIBS_DYNLOAD	= -ldl
 QMAKE_LIBS_X11		= -lXext -lX11 -lm
 QMAKE_LIBS_X11SM	= -lSM -lICE
 QMAKE_LIBS_QT		= -lqt
 QMAKE_LIBS_QT_THREAD	= -lqt-mt
 QMAKE_LIBS_OPENGL	= -lGLU -lGL -lXmu
 QMAKE_LIBS_OPENGL_QT	= -lGL -lXmu
-QMAKE_LIBS_THREAD	=
+QMAKE_LIBS_THREAD	= -lXt
 
-QMAKE_MOC		= $(QTDIR)/bin/moc
-QMAKE_UIC		= $(QTDIR)/bin/uic
+QMAKE_MOC		= @PREFIX@/bin/moc
+QMAKE_UIC		= @PREFIX@/bin/uic
 
 QMAKE_AR		= ar cq
 QMAKE_RANLIB		= ranlib -s
diff -uNr qt-x11-free-3.2.3/mkspecs/linux-g++/qplatformdefs.h qt-x11-free-3.2.3-new/mkspecs/linux-g++/qplatformdefs.h
--- qt-x11-free-3.2.3/mkspecs/linux-g++/qplatformdefs.h	Tue May 13 03:08:28 2003
+++ qt-x11-free-3.2.3-new/mkspecs/linux-g++/qplatformdefs.h	Tue Feb  3 16:37:01 2004
@@ -102,5 +102,6 @@
 #define QT_VSNPRINTF		::vsnprintf
 #endif
 
+#define QT_MITSHM
 
 #endif // QPLATFORMDEFS_H
diff -uNr qt-x11-free-3.2.3/qmake/Makefile.unix qt-x11-free-3.2.3-new/qmake/Makefile.unix
--- qt-x11-free-3.2.3/qmake/Makefile.unix	Tue May 13 12:17:58 2003
+++ qt-x11-free-3.2.3-new/qmake/Makefile.unix	Tue Feb  3 16:37:01 2004
@@ -36,8 +36,8 @@
 	-I. -Igenerators -Igenerators/unix -Igenerators/win32 -Igenerators/mac \
 	-I@BUILD_PATH@/include/qmake -I@BUILD_PATH@/include -I@SOURCE_PATH@/include \
 	-DQT_NO_TEXTCODEC -DQT_NO_UNICODETABLES -DQT_NO_COMPONENT -DQT_NO_STL \
-	-DQT_NO_COMPRESS -I@QMAKESPEC@ -DHAVE_QCONFIG_CPP
-LFLAGS=@QMAKE_LFLAGS@
+	-DQT_NO_COMPRESS -I@QMAKESPEC@ -DHAVE_QCONFIG_CPP -mdynamic-no-pic
+LFLAGS=@QMAKE_LFLAGS@ -mdynamic-no-pic
 
 qmake: $(OBJS) $(QOBJS)
 	$(CXX) -o $@ $(OBJS) $(QOBJS) $(LFLAGS)
diff -uNr qt-x11-free-3.2.3/qmake/generators/unix/unixmake.h qt-x11-free-3.2.3-new/qmake/generators/unix/unixmake.h
--- qt-x11-free-3.2.3/qmake/generators/unix/unixmake.h	Mon Nov 10 05:22:48 2003
+++ qt-x11-free-3.2.3-new/qmake/generators/unix/unixmake.h	Tue Feb  3 16:37:01 2004
@@ -69,6 +69,7 @@
     
 private:
     void init2();
+    QString prefixedVariable( const QString &projectVariableName, const QString &defaultSuffix );
 };
 
 inline UnixMakefileGenerator::~UnixMakefileGenerator()
diff -uNr qt-x11-free-3.2.3/qmake/generators/unix/unixmake2.cpp qt-x11-free-3.2.3-new/qmake/generators/unix/unixmake2.cpp
--- qt-x11-free-3.2.3/qmake/generators/unix/unixmake2.cpp	Mon Nov 10 05:22:48 2003
+++ qt-x11-free-3.2.3-new/qmake/generators/unix/unixmake2.cpp	Tue Feb  3 16:37:01 2004
@@ -1186,14 +1186,14 @@
 	} else if( project->isActiveConfig("plugin") ) {
 	    project->variables()["TARGET_x.y.z"].append("lib" +
 							project->first("TARGET") + "." + 
-							project->first("QMAKE_EXTENSION_SHLIB"));
+							(project->first("QMAKE_EXTENSION_PLUGIN").isEmpty()? project->first("QMAKE_EXTENSION_SHLIB") : project->first("QMAKE_EXTENSION_PLUGIN")));
 	    if(project->isActiveConfig("lib_version_first"))
 		project->variables()["TARGET_x"].append("lib" + project->first("TARGET") + "." +
 							project->first("VER_MAJ") + "." +
-							project->first("QMAKE_EXTENSION_SHLIB"));
+							(project->first("QMAKE_EXTENSION_PLUGIN").isEmpty()? project->first("QMAKE_EXTENSION_SHLIB") : project->first("QMAKE_EXTENSION_PLUGIN")));
 	    else
 		project->variables()["TARGET_x"].append("lib" + project->first("TARGET") + "." +
-							project->first("QMAKE_EXTENSION_SHLIB") +
+							(project->first("QMAKE_EXTENSION_PLUGIN").isEmpty()? project->first("QMAKE_EXTENSION_SHLIB") : project->first("QMAKE_EXTENSION_PLUGIN")) +
 							"." + project->first("VER_MAJ"));
 
 	    project->variables()["TARGET"] = project->variables()["TARGET_x.y.z"];
@@ -1358,6 +1358,20 @@
 }
 
 QString
+UnixMakefileGenerator::prefixedVariable( const QString &projectVariableName, const QString &defaultSuffix )
+{
+    QString prefix = qInstallPath();
+
+    QString value = var( projectVariableName );
+    if ( value.isEmpty() )
+	value = "${prefix}" + defaultSuffix;
+    else if ( value.startsWith( prefix ) )
+	value.replace( prefix, "${prefix}" );
+
+    return value;
+}
+
+QString
 UnixMakefileGenerator::libtoolFileName()
 {
     QString ret = var("TARGET");
@@ -1476,13 +1490,14 @@
     QTextStream t(&ft);
 
     QString prefix = qInstallPath();
-    QString libDir = prefix + "/lib";
-    QString includeDir = prefix + "/include";
 
-    t << "prefix=" << libDir << endl;
+    QString libDir = prefixedVariable( "libs.path", "/lib" );
+    QString includeDir = prefixedVariable( "headers.path", "/include" );
+
+    t << "prefix=" << prefix << endl;
     t << "exec_prefix=${prefix}\n"
-      << "libdir=${exec_prefix}/lib\n"
-      << "includedir=${prefix}/include" << endl;
+      << "libdir=" << libDir << endl
+      << "includedir=" << includeDir << endl;
     // non-standard entry. Provides useful info normally only
     // contained in the internal .qmake.cache file
     t << varGlue("CONFIG", "qt_config=", " ", "") << endl << endl;
@@ -1499,7 +1514,7 @@
 	libs << "QMAKE_LIBS"; //obvious one
     if(project->isActiveConfig("thread"))
 	libs << "QMAKE_LFLAGS_THREAD"; //not sure about this one, but what about things like -pthread?
-    t << "Libs: -L" << libDir << " -l" << lname << " ";
+    t << "Libs: -L${libdir} -l" << var( "QMAKE_ORIG_TARGET" ) << " ";
     for(QStringList::ConstIterator it = libs.begin(); it != libs.end(); ++it)
 	t << project->variables()[(*it)].join(" ") << " ";
     t << endl;
@@ -1511,5 +1526,5 @@
       << varGlue("PRL_EXPORT_DEFINES","-D"," -D"," ")
       << project->variables()["PRL_EXPORT_CXXFLAGS"].join(" ")
 	//      << varGlue("DEFINES","-D"," -D"," ")
-      << " -I" << includeDir;
+      << " -I${includedir}" << endl;
 }
diff -uNr qt-x11-free-3.2.3/qmake/main.cpp qt-x11-free-3.2.3-new/qmake/main.cpp
--- qt-x11-free-3.2.3/qmake/main.cpp	Mon Nov 10 05:22:47 2003
+++ qt-x11-free-3.2.3-new/qmake/main.cpp	Tue Feb  3 16:37:01 2004
@@ -49,7 +49,7 @@
 
 // for Borland, main is defined to qMain which breaks qmake
 #undef main
-#ifdef Q_OS_MAC
+#if defined( Q_OS_MAC ) || defined( Q_OS_DARWIN )
 // for qurl
 bool qt_resolve_symlinks = FALSE;
 #endif
diff -uNr qt-x11-free-3.2.3/src/iconview/qiconview.cpp qt-x11-free-3.2.3-new/src/iconview/qiconview.cpp
--- qt-x11-free-3.2.3/src/iconview/qiconview.cpp	Mon Nov 10 05:21:47 2003
+++ qt-x11-free-3.2.3-new/src/iconview/qiconview.cpp	Tue Feb  3 16:37:01 2004
@@ -258,6 +258,7 @@
     uint dragging		:1;
     uint drawActiveSelection	:1;
     uint inMenuMode		:1;
+    uint controlPressed         :1;
 
     QIconViewToolTip *toolTip;
     QPixmapCache maskCache;
@@ -2727,6 +2728,7 @@
     d->lastItem = 0;
     d->count = 0;
     d->mousePressed = FALSE;
+    d->controlPressed = FALSE;
     d->selectionMode = Single;
     d->currentItem = 0;
     d->highlightedItem = 0;
@@ -3264,9 +3266,11 @@
 {
     QRect oldRubber = QRect( *d->rubber );
 
-    QPoint pos = QCursor::pos();
-    pos = viewport()->mapFromGlobal( pos );
-    pos = viewportToContents( pos );
+    QPoint vp = viewport()->mapFromGlobal( QCursor::pos() );
+    QPoint pos = viewportToContents( vp );
+
+    if ( pos == d->rubber->bottomRight() )
+      return;
 
     d->rubber->setRight( pos.x() );
     d->rubber->setBottom( pos.y() );
@@ -3290,9 +3294,18 @@
 	    alreadyIntersected = TRUE;
 	    QIconViewItem *item = c->items.first();
 	    for ( ; item; item = c->items.next() ) {
-		if ( d->selectedItems.find( item ) )
-		    continue;
-		if ( !item->intersects( nr ) ) {
+               if ( d->selectedItems.find( item ) ) {
+                   if ( item->intersects( nr ) && item->isSelected() && d->controlPressed ) {
+                       item->setSelected( FALSE );
+                       changed = TRUE;
+                       rr = rr.unite( item->rect() );
+                   } else if ( !item->intersects( nr ) && !item->isSelected() && d->controlPressed ) {
+                       item->setSelected( TRUE, TRUE );
+                       changed = TRUE;
+                       rr = rr.unite( item->rect() );
+                   } else
+                       continue;
+               } else if ( !item->intersects( nr ) ) {
 		    if ( item->isSelected() ) {
 			item->setSelected( FALSE );
 			changed = TRUE;
@@ -3359,15 +3372,14 @@
 	if ( d->selectionMode == Single )
 	    emit selectionChanged( d->currentItem );
     }
-
-    if ( !QRect( 0, 0, viewport()->width(), viewport()->height() ).contains( pos ) &&
+    if ( !QRect( 50, 50, viewport()->width()-100, viewport()->height()-100 ).contains( vp ) &&
 	 !d->scrollTimer ) {
 	d->scrollTimer = new QTimer( this );
 
 	connect( d->scrollTimer, SIGNAL( timeout() ),
 		 this, SLOT( doAutoScroll() ) );
 	d->scrollTimer->start( 100, FALSE );
-    } else if ( QRect( 0, 0, viewport()->width(), viewport()->height() ).contains( pos ) &&
+    } else if ( QRect( 50, 50, viewport()->width()-100, viewport()->height()-100 ).contains( vp ) &&
 		d->scrollTimer ) {
 	disconnect( d->scrollTimer, SIGNAL( timeout() ),
 		    this, SLOT( doAutoScroll() ) );
@@ -4483,7 +4495,7 @@
 	    }
 	}
     } else if ( ( d->selectionMode != Single || e->button() == RightButton )
-		&& !( e->state() & ControlButton ) )
+		&& !( e->state() & ControlButton ) && !( e->state() & ShiftButton ) )
 	selectAll( FALSE );
 
     setCurrentItem( item );
@@ -4494,12 +4506,11 @@
 	    d->tmpCurrentItem = d->currentItem;
 	    d->currentItem = 0;
 	    repaintItem( d->tmpCurrentItem );
-	    if ( d->rubber )
-		delete d->rubber;
-	    d->rubber = 0;
+	    delete d->rubber;
 	    d->rubber = new QRect( e->x(), e->y(), 0, 0 );
 	    d->selectedItems.clear();
-	    if ( ( e->state() & ControlButton ) == ControlButton ) {
+	    if ( ( e->state() & ControlButton ) == ControlButton ||
+	         ( e->state() & ShiftButton ) == ShiftButton ) {
 		for ( QIconViewItem *i = firstItem(); i; i = i->nextItem() )
 		    if ( i->isSelected() )
 			d->selectedItems.insert( i, i );
@@ -4507,6 +4518,7 @@
 	}
 
 	d->mousePressed = TRUE;
+	d->controlPressed = ( ( e->state() & ControlButton ) == ControlButton );
     }
 
  emit_signals:
@@ -4773,7 +4785,7 @@
 
     QIconViewItem *i = findItem( e->pos() );
 
-    if ( !i && e->source() == viewport() && d->currentItem && !d->cleared ) {
+    if ( (!i || i == d->currentItem) && e->source() == viewport() && d->currentItem && !d->cleared ) {
 	if ( !d->rearrangeEnabled )
 	    return;
 	QRect r = d->currentItem->rect();
@@ -5216,11 +5228,11 @@
 	d->findContainers( dir, relativeTo, searchRect);
 
     cList->first();
-    while ( cList->current() && !centerMatch ) {
+    while ( cList->current() ) {
 	QPtrList<QIconViewItem> &list = (cList->current())->items;
 	for ( item = list.first(); item; item = list.next() ) {
 	    if ( neighbourItem( dir, relativeTo, item ) &&
-		 searchRect.contains( item->rect().center() ) &&
+		 searchRect.intersects( item->rect() ) &&
 		 item != currentItem() ) {
  		int ml = (relativeTo - item->rect().center()).manhattanLength();
 		if ( centerMatch ) {
@@ -6148,7 +6160,9 @@
 	    item->d->container2 = 0;
 	    c->items.append( item );
 	    item = item->next;
-	} else if ( c->rect.intersects( item->rect() ) ) {
+	} else if ( c->rect.intersects( item->rect() ) && (
+			( d->arrangement == LeftToRight && item->y() >= c->rect.y() ) ||
+			( d->arrangement == TopToBottom && item->x() >= c->rect.x() ) ) ) {
 	    item->d->container1 = c;
 	    c->items.append( item );
 	    c = c->n;
@@ -6292,7 +6306,7 @@
 			    item->selected = TRUE;
 			    selectedRect = selectedRect.unite( item->rect() );
 			}
-		    } else if ( item->selected ) {
+		    } else if ( item->selected && !control ) {
 			item->selected = FALSE;
 			unselectedRect = unselectedRect.unite( item->rect() );
 			changed = TRUE;
diff -uNr qt-x11-free-3.2.3/src/kernel/qapplication_x11.cpp qt-x11-free-3.2.3-new/src/kernel/qapplication_x11.cpp
--- qt-x11-free-3.2.3/src/kernel/qapplication_x11.cpp	Mon Nov 10 05:21:54 2003
+++ qt-x11-free-3.2.3-new/src/kernel/qapplication_x11.cpp	Tue Feb  3 16:37:02 2004
@@ -254,6 +254,7 @@
 Atom		qt_net_wm_state_modal	= 0;
 Atom		qt_net_wm_state_max_v	= 0;
 Atom		qt_net_wm_state_max_h	= 0;
+Atom		qt_net_wm_state_fullscreen	= 0;
 Atom            qt_net_wm_window_type   = 0;
 Atom            qt_net_wm_window_type_normal	= 0;
 Atom            qt_net_wm_window_type_dialog	= 0;
@@ -1418,6 +1419,62 @@
     }
 }
 
+void qt_net_change_state(const QWidget* w, Atom state, bool set)
+{
+    if( w->isShown()) { // managed by WM
+        XEvent ev;
+        ev.xclient.type = ClientMessage;
+        ev.xclient.message_type = qt_net_wm_state;
+        ev.xclient.display = w->x11Display();
+        ev.xclient.window = w->winId();
+        ev.xclient.format = 32;
+        ev.xclient.data.l[ 0 ] = set ? 1 : 0;
+        ev.xclient.data.l[ 1 ] = state;
+        ev.xclient.data.l[ 2 ] = 0;
+        ev.xclient.data.l[ 3 ] = 0;
+        ev.xclient.data.l[ 4 ] = 0;
+        XSendEvent( w->x11Display(), RootWindow(w->x11Display(), w->x11Screen() ), False,
+            SubstructureRedirectMask|SubstructureNotifyMask, &ev );
+    } else {
+        Atom ret;
+	int format, e;
+	unsigned char *data = 0;
+	unsigned long nitems, after;
+	e = XGetWindowProperty( w->x11Display(), w->winId(),
+			       qt_net_wm_state, 0, 1024, False,
+			       XA_ATOM, &ret, &format, &nitems,
+			       &after, &data);
+	if (e == Success && ret == XA_ATOM && format == 32 &&
+	    nitems > 0) {
+	    Atom *states = (Atom *) data;
+            Atom *new_states = new Atom[ nitems + 1 ];
+	    unsigned long i;
+            unsigned long new_count = 0;
+	    for (i = 0; i < nitems; i++) {
+		if (states[i] == state) {
+                    if(set) {
+                        delete[] new_states;
+                        return; // already set, no need to change anything
+                    }
+                    // else don't copy
+                } else
+                    new_states[ new_count++ ] = states[ i ];
+	    }
+            if( set )
+                new_states[ new_count++ ] = state;
+	    XChangeProperty( w->x11Display(), w->winId(), qt_net_wm_state, XA_ATOM, 32, PropModeReplace,
+			    (unsigned char *) new_states, new_count );
+            delete[] new_states;
+        } else {
+            Atom states[ 1 ] = { state };
+	    XChangeProperty( w->x11Display(), w->winId(), qt_net_wm_state, XA_ATOM, 32, PropModeReplace,
+			    (unsigned char *) states, set ? 1 : 0 );
+        }
+	if (data)
+	    XFree(data);
+    }
+}
+
 void qt_x11_create_wm_client_leader()
 {
     if ( qt_x11_wm_client_leader ) return;
@@ -1910,6 +1967,7 @@
 	qt_x11_intern_atom( "_NET_WM_STATE_MODAL", &qt_net_wm_state_modal );
 	qt_x11_intern_atom( "_NET_WM_STATE_MAXIMIZED_VERT", &qt_net_wm_state_max_v );
 	qt_x11_intern_atom( "_NET_WM_STATE_MAXIMIZED_HORZ", &qt_net_wm_state_max_h );
+	qt_x11_intern_atom( "_NET_WM_STATE_FULLSCREEN", &qt_net_wm_state_fullscreen );
 	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE", &qt_net_wm_window_type );
 	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE_NORMAL",
 			    &qt_net_wm_window_type_normal );
@@ -3347,6 +3405,7 @@
 					       &after, &data);
 
 			bool isMaximized = FALSE;
+ 			bool isFullScreen = FALSE;
 			if (e == Success && ret == XA_ATOM && format == 32 &&
 			    nitems > 0) {
 			    Atom *states = (Atom *) data;
@@ -3356,8 +3415,9 @@
 				if (states[i] == qt_net_wm_state_max_v ||
 				    states[i] == qt_net_wm_state_max_h) {
 				    isMaximized = TRUE;
-				    break;
-				}
+				} else if (states[i] == qt_net_wm_state_fullscreen) {
+                                    isFullScreen = TRUE;
+                                }
 			    }
 			}
 
@@ -3365,6 +3425,21 @@
 			    widget->setWState(WState_Maximized);
 			else
 			    widget->clearWState(WState_Maximized);
+                            
+                        if( qt_net_supports(qt_net_wm_state_fullscreen)) {
+                            if( !isFullScreen && widget->isFullScreen()) {
+                                // if there was QWidget::showFullScreen( bool ), that
+                                // wouldn't mess with maximize state etc., this could be just
+                                // widget->showFullScreen( false )
+                                widget->topData()->fullscreen = 0;
+                                QEvent e( QEvent::ShowNormal );
+                                QApplication::sendSpontaneousEvent( widget, &e );
+                            } else if( isFullScreen && !widget->isFullScreen()) {
+                                widget->topData()->fullscreen = 1;
+                                QEvent e( QEvent::ShowFullScreen );
+                                QApplication::sendSpontaneousEvent( widget, &e );
+                            }
+                        }
 
 			if (data)
 			    XFree(data);
@@ -3494,10 +3569,23 @@
 
 	// update the size for desktop widget
 	int scr = XRRRootToScreen( appDpy, event->xany.window );
+
+	// Determine if we're at right-angles & thus DisplayWidth/DisplayHeight should be switched
+	XRRScreenConfiguration* xrrconfig;
+	xrrconfig = XRRGetScreenInfo( appDpy, event->xany.window );
+	Rotation rotation;
+	XRRConfigCurrentConfiguration( xrrconfig, &rotation );
+	XRRFreeScreenConfigInfo( xrrconfig );
+
 	QWidget *w = desktop()->screen( scr );
 	QSize oldSize( w->size() );
-	w->crect.setWidth( DisplayWidth( appDpy, scr ) );
-        w->crect.setHeight( DisplayHeight( appDpy, scr ) );
+	if (rotation & (RR_Rotate_90 | RR_Rotate_270)) {
+	    w->crect.setWidth( DisplayHeight( appDpy, scr ) );
+	    w->crect.setHeight( DisplayWidth( appDpy, scr ) );
+	} else {
+	    w->crect.setWidth( DisplayWidth( appDpy, scr ) );
+	    w->crect.setHeight( DisplayHeight( appDpy, scr ) );
+	}
 	if ( w->size() != oldSize ) {
 	    QResizeEvent e( w->size(), oldSize );
 	    QApplication::sendEvent( w, &e );
@@ -3654,9 +3742,12 @@
 	QWidget* enter = 0;
 	XEvent ev;
 	while ( XCheckMaskEvent( widget->x11Display(), EnterWindowMask | LeaveWindowMask , &ev )
-		&& !qt_x11EventFilter( &ev ) && !widget->x11Event( &ev ) ) {
+		&& !qt_x11EventFilter( &ev )) {
+            QWidget* event_widget = QWidget::find( ev.xcrossing.window );
+            if( event_widget && event_widget->x11Event( &ev ) )
+                break;
 	    if ( ev.type == LeaveNotify && ev.xcrossing.mode == NotifyNormal ){
-		enter = QWidget::find( ev.xcrossing.window );
+		enter = event_widget;
 		XPutBackEvent( widget->x11Display(), &ev );
 		break;
 	    }
@@ -3664,7 +3755,7 @@
 		  ev.xcrossing.detail == NotifyVirtual  ||
 		  ev.xcrossing.detail == NotifyNonlinearVirtual )
 		continue;
-	    enter = QWidget::find( ev.xcrossing.window );
+	    enter = event_widget;
 	    if ( ev.xcrossing.focus &&
 		 enter && !enter->isDesktop() && !enter->isActiveWindow() ) {
 		if ( qt_focus_model == FocusModel_Unknown ) // check focus model
@@ -4027,7 +4118,7 @@
 // Keyboard event translation
 //
 
-static int translateButtonState( int s )
+int qt_x11_translateButtonState( int s )
 {
     int bst = 0;
     if ( s & Button1Mask )
@@ -4093,7 +4184,7 @@
 	pos.ry() = lastMotion.y;
 	globalPos.rx() = lastMotion.x_root;
 	globalPos.ry() = lastMotion.y_root;
-	state = translateButtonState( lastMotion.state );
+	state = qt_x11_translateButtonState( lastMotion.state );
 	if ( qt_button_down && (state & (LeftButton |
 					 MidButton |
 					 RightButton ) ) == 0 )
@@ -4117,7 +4208,7 @@
 	pos.ry() = xevent->xcrossing.y;
 	globalPos.rx() = xevent->xcrossing.x_root;
 	globalPos.ry() = xevent->xcrossing.y_root;
-	state = translateButtonState( xevent->xcrossing.state );
+	state = qt_x11_translateButtonState( xevent->xcrossing.state );
 	if ( qt_button_down && (state & (LeftButton |
 					 MidButton |
 					 RightButton ) ) == 0 )
@@ -4129,7 +4220,7 @@
 	pos.ry() = event->xbutton.y;
 	globalPos.rx() = event->xbutton.x_root;
 	globalPos.ry() = event->xbutton.y_root;
-	state = translateButtonState( event->xbutton.state );
+	state = qt_x11_translateButtonState( event->xbutton.state );
 	switch ( event->xbutton.button ) {
 	case Button1: button = LeftButton; break;
 	case Button2: button = MidButton; break;
@@ -4924,7 +5015,7 @@
     XKeyEvent xkeyevent = event->xkey;
 
     // save the modifier state, we will use the keystate uint later by passing
-    // it to translateButtonState
+    // it to qt_x11_translateButtonState
     uint keystate = event->xkey.state;
     // remove the modifiers where mode_switch exists... HPUX machines seem
     // to have alt *AND* mode_switch both in Mod1Mask, which causes
@@ -5038,7 +5129,7 @@
     }
 #endif // !QT_NO_XIM
 
-    state = translateButtonState( keystate );
+    state = qt_x11_translateButtonState( keystate );
 
     static int directionKeyEvent = 0;
     if ( qt_use_rtl_extensions && type == QEvent::KeyRelease ) {
diff -uNr qt-x11-free-3.2.3/src/kernel/qclipboard_x11.cpp qt-x11-free-3.2.3-new/src/kernel/qclipboard_x11.cpp
--- qt-x11-free-3.2.3/src/kernel/qclipboard_x11.cpp	Mon Nov 10 05:21:57 2003
+++ qt-x11-free-3.2.3-new/src/kernel/qclipboard_x11.cpp	Tue Feb  3 16:38:21 2004
@@ -112,10 +112,6 @@
 
 // event capture mechanism for qt_xclb_wait_for_event
 static bool waiting_for_data = FALSE;
-static bool has_captured_event = FALSE;
-static Window capture_event_win = None;
-static int capture_event_type = -1;
-static XEvent captured_event;
 
 class QClipboardWatcher; // forward decl
 static QClipboardWatcher *selection_watcher = 0;
@@ -432,68 +428,35 @@
 { return inSelectionMode_obsolete; }
 
 
-// event filter function... captures interesting events while
-// qt_xclb_wait_for_event is running the event loop
-static int qt_xclb_event_filter(XEvent *event)
-{
-    if (event->xany.type == capture_event_type &&
-	event->xany.window == capture_event_win) {
-	VDEBUG( "QClipboard: event_filter(): caught event type %d", event->type );
-	has_captured_event = TRUE;
-	captured_event = *event;
-	return 1;
-    }
-
-    return 0;
-}
-
 bool qt_xclb_wait_for_event( Display *dpy, Window win, int type, XEvent *event,
 			     int timeout )
 {
-    if ( waiting_for_data )
-	qFatal( "QClipboard: internal error, qt_xclb_wait_for_event recursed" );
-
-    waiting_for_data = TRUE;
-
     QTime started = QTime::currentTime();
     QTime now = started;
-
-    has_captured_event = FALSE;
-    capture_event_win = win;
-    capture_event_type = type;
-
-    QX11EventFilter old_event_filter = qt_set_x11_event_filter(qt_xclb_event_filter);
+    bool flushed = FALSE;
 
     do {
-	if ( XCheckTypedWindowEvent(dpy,win,type,event) ) {
-	    waiting_for_data = FALSE;
-	    qt_set_x11_event_filter(old_event_filter);
+	if ( XCheckTypedWindowEvent(dpy,win,type,event) )
 	    return TRUE;
-	}
 
 	now = QTime::currentTime();
 	if ( started > now )			// crossed midnight
 	    started = now;
 
-	// 0x08 == ExcludeTimers for X11 only
-	qApp->eventLoop()->processEvents( QEventLoop::ExcludeUserInput |
-					  QEventLoop::ExcludeSocketNotifiers |
-					  QEventLoop::WaitForMore | 0x08 );
-
-	if ( has_captured_event ) {
-	    waiting_for_data = FALSE;
-	    *event = captured_event;
-	    qt_set_x11_event_filter(old_event_filter);
-	    return TRUE;
+	if(!flushed) {
+	    XFlush( dpy );
+	    flushed = TRUE;
 	}
-    } while ( started.msecsTo(now) < timeout );
 
-    waiting_for_data = FALSE;
-    qt_set_x11_event_filter(old_event_filter);
+	// sleep 50ms, so we don't use up CPU cycles all the time.
+	struct timeval usleep_tv;
+	usleep_tv.tv_sec = 0;
+	usleep_tv.tv_usec = 50000;
+	select(0, 0, 0, 0, &usleep_tv);
+    } while ( started.msecsTo(now) < timeout );
 
     return FALSE;
 }
-
 
 static inline int maxSelectionIncr( Display *dpy )
 { return XMaxRequestSize(dpy) > 65536 ? 65536*4 : XMaxRequestSize(dpy)*4 - 100; }
diff -uNr qt-x11-free-3.2.3/src/kernel/qdesktopwidget_x11.cpp qt-x11-free-3.2.3-new/src/kernel/qdesktopwidget_x11.cpp
--- qt-x11-free-3.2.3/src/kernel/qdesktopwidget_x11.cpp	Mon Nov 10 05:22:11 2003
+++ qt-x11-free-3.2.3-new/src/kernel/qdesktopwidget_x11.cpp	Tue Feb  3 16:37:02 2004
@@ -44,6 +44,9 @@
 // defined in qapplication_x11.cpp
 extern Atom qt_net_workarea;
 extern bool qt_net_supports(Atom atom);
+#ifndef QT_NO_XRANDR
+extern bool qt_use_xrandr;
+#endif
 
 // function to update the workarea of the screen
 static bool qt_desktopwidget_workarea_dirty = TRUE;
@@ -154,6 +157,22 @@
 		y = 0;
 		w = WidthOfScreen(ScreenOfDisplay(QPaintDevice::x11AppDisplay(), i));
 		h = HeightOfScreen(ScreenOfDisplay(QPaintDevice::x11AppDisplay(), i));
+
+#ifndef QT_NO_XRANDR
+		if (qt_use_xrandr) {
+		    XRRScreenConfiguration* xrrconfig;
+		    xrrconfig = XRRGetScreenInfo(QPaintDevice::x11AppDisplay(), QPaintDevice::x11AppRootWindow( i ));
+		    Rotation rotation;
+		    XRRConfigCurrentConfiguration(xrrconfig, &rotation);
+		    XRRFreeScreenConfigInfo(xrrconfig);
+
+		    if (rotation & (RR_Rotate_90 | RR_Rotate_270)) {
+			int tmp = h;
+			h = w;
+			w = tmp;
+		    }
+		}
+#endif
 	    }
 
 	rects[i].setRect(x, y, w, h);
diff -uNr qt-x11-free-3.2.3/src/kernel/qdnd_x11.cpp qt-x11-free-3.2.3-new/src/kernel/qdnd_x11.cpp
--- qt-x11-free-3.2.3/src/kernel/qdnd_x11.cpp	Mon Nov 10 05:22:04 2003
+++ qt-x11-free-3.2.3-new/src/kernel/qdnd_x11.cpp	Tue Feb  3 16:37:02 2004
@@ -49,13 +49,15 @@
 #include "qdragobject.h"
 #include "qobjectlist.h"
 #include "qcursor.h"
+#include "qbitmap.h"
+#include "qpainter.h"
 
 #include "qt_x11_p.h"
 
 // conflict resolution
 
-// unused, may be used again later: const int XKeyPress = KeyPress;
-// unused, may be used again later: const int XKeyRelease = KeyRelease;
+const int XKeyPress = KeyPress;
+const int XKeyRelease = KeyRelease;
 #undef KeyPress
 #undef KeyRelease
 
@@ -112,6 +114,8 @@
 Atom qt_xdnd_type_list;
 const int qt_xdnd_version = 4;
 
+extern int qt_x11_translateButtonState( int s );
+
 // Actions
 //
 // The Xdnd spec allows for user-defined actions. This could be implemented
@@ -196,6 +200,8 @@
 static int qt_xdnd_current_screen = -1;
 // state of dragging... true if dragging, false if not
 bool qt_xdnd_dragging = FALSE;
+// need to check state of keyboard modifiers
+static bool need_modifiers_check = FALSE;
 
 // dict of payload data, sorted by type atom
 static QIntDict<QByteArray> * qt_xdnd_target_data = 0;
@@ -251,20 +257,47 @@
 public:
     QShapedPixmapWidget(int screen = -1) :
 	QWidget(QApplication::desktop()->screen( screen ),
-		0, WStyle_Customize | WStyle_Tool | WStyle_NoBorder | WX11BypassWM )
+		0, WStyle_Customize | WStyle_Tool | WStyle_NoBorder | WX11BypassWM ), oldpmser( 0 ), oldbmser( 0 )
     {
     }
 
-    void setPixmap(QPixmap pm)
+    void setPixmap(QPixmap pm, QPoint hot)
     {
-	if ( pm.mask() ) {
+	int bmser = pm.mask() ? pm.mask()->serialNumber() : 0;
+	if( oldpmser == pm.serialNumber() && oldbmser == bmser
+	    && oldhot == hot )
+	    return;
+	oldpmser = pm.serialNumber();
+	oldbmser = bmser;
+	oldhot = hot;
+	bool hotspot_in = !(hot.x() < 0 || hot.y() < 0 || hot.x() >= pm.width() || hot.y() >= pm.height());
+// if the pixmap has hotspot in its area, make a "hole" in it at that position
+// this will allow XTranslateCoordinates() to find directly the window below the cursor instead
+// of finding this pixmap, and therefore there won't be needed any (slow) search for the window
+// using findRealWindow()
+	if( hotspot_in ) {
+	    QBitmap mask = pm.mask() ? *pm.mask() : QBitmap( pm.width(), pm.height());
+	    if( !pm.mask())
+		mask.fill( Qt::color1 );
+	    QPainter p( &mask );
+	    p.setPen( Qt::color0 );
+	    p.drawPoint( hot.x(), hot.y());
+	    p.end();
+    	    pm.setMask( mask );
+    	    setMask( mask );
+	} else if ( pm.mask() ) {
 	    setMask( *pm.mask() );
 	} else {
 	    clearMask();
 	}
 	resize(pm.width(),pm.height());
 	setErasePixmap(pm);
+	erase();
     }
+private:
+    int oldpmser;
+    int oldbmser;
+    QPoint oldhot;
 };
 
 static QShapedPixmapWidget * qt_xdnd_deco = 0;
@@ -433,6 +466,7 @@
     qt_xdnd_atom_numbers = 0;
     delete qt_xdnd_target_data;
     qt_xdnd_target_data = 0;
+    delete noDropCursor;
     noDropCursor = 0;
     delete copyCursor;
     copyCursor = 0;
@@ -850,8 +884,59 @@
 
 void QDragManager::timerEvent( QTimerEvent* e )
 {
-    if ( e->timerId() == heartbeat && qt_xdnd_source_sameanswer.isNull() )
-	move( QCursor::pos() );
+    if ( e->timerId() == heartbeat ) {
+        if( need_modifiers_check ) {
+            Window root, child;
+            int root_x, root_y, win_x, win_y;
+            unsigned int mask;
+            XQueryPointer( qt_xdisplay(), qt_xrootwin( qt_xdnd_current_screen ),
+                &root, &child, &root_x, &root_y, &win_x, &win_y, &mask );
+            if( updateMode( (ButtonState)qt_x11_translateButtonState( mask )))
+                qt_xdnd_source_sameanswer = QRect(); // force move
+        }
+        need_modifiers_check = TRUE;
+        if( qt_xdnd_source_sameanswer.isNull() )
+	    move( QCursor::pos() );
+    }
+}
+
+static bool qt_xdnd_was_move = false;
+static bool qt_xdnd_found = false;
+// check whole incoming X queue for move events
+// checking whole queue is done by always returning False in the predicate
+// if there's another move event in the queue, and there's not a mouse button
+// or keyboard or ClientMessage event before it, the current move event
+// may be safely discarded
+// this helps avoiding being overloaded by being flooded from many events
+// from the XServer
+static
+Bool qt_xdnd_predicate( Display*, XEvent* ev, XPointer )
+{
+    if( qt_xdnd_found )
+	return False;
+    if( ev->type == MotionNotify )
+    {
+	qt_xdnd_was_move = true;
+	qt_xdnd_found = true;
+    }
+    if( ev->type == ButtonPress || ev->type == ButtonRelease
+	|| ev->type == XKeyPress || ev->type == XKeyRelease
+	|| ev->type == ClientMessage )
+    {
+	qt_xdnd_was_move = false;
+	qt_xdnd_found = true;
+    }
+    return False;
+}
+
+static
+bool qt_xdnd_another_movement()
+{
+    qt_xdnd_was_move = false;
+    qt_xdnd_found = false;
+    XEvent dummy;
+    XCheckIfEvent( qt_xdisplay(), &dummy, qt_xdnd_predicate, NULL );
+    return qt_xdnd_was_move;
 }
 
 bool QDragManager::eventFilter( QObject * o, QEvent * e)
@@ -876,8 +961,11 @@
 
     if ( e->type() == QEvent::MouseMove ) {
 	QMouseEvent* me = (QMouseEvent *)e;
-	updateMode(me->stateAfter());
-	move( me->globalPos() );
+	if( !qt_xdnd_another_movement()) {
+	    updateMode(me->stateAfter());
+	    move( me->globalPos() );
+	}
+        need_modifiers_check = FALSE;
 	return TRUE;
     } else if ( e->type() == QEvent::MouseButtonRelease ) {
 	qApp->removeEventFilter( this );
@@ -916,9 +1004,11 @@
 	    beingCancelled = FALSE;
 	    qApp->exit_loop();
 	} else {
-	    updateMode(ke->stateAfter());
-	    qt_xdnd_source_sameanswer = QRect(); // force move
-	    move( QCursor::pos() );
+	    if( updateMode(ke->stateAfter())) {
+	        qt_xdnd_source_sameanswer = QRect(); // force move
+	        move( QCursor::pos() );
+            }
+            need_modifiers_check = FALSE;
 	}
 	return TRUE; // Eat all key events
     }
@@ -944,10 +1034,10 @@
 
 
 static Qt::ButtonState oldstate;
-void QDragManager::updateMode( ButtonState newstate )
+bool QDragManager::updateMode( ButtonState newstate )
 {
     if ( newstate == oldstate )
-	return;
+	return false;
     const int both = ShiftButton|ControlButton;
     if ( (newstate & both) == both ) {
 	global_requested_action = QDropEvent::Link;
@@ -971,6 +1061,7 @@
 	}
     }
     oldstate = newstate;
+    return true;
 }
 
 
@@ -1103,7 +1194,7 @@
 	delete qt_xdnd_deco;
 	qt_xdnd_deco = new QShapedPixmapWidget( screen );
     }
-    updatePixmap();
+    updatePixmap( globalPos );
 
     if ( qt_xdnd_source_sameanswer.contains( globalPos ) &&
 	 qt_xdnd_source_sameanswer.isValid() ) {
@@ -1639,6 +1730,7 @@
     qt_xdnd_source_sameanswer = QRect();
     move(QCursor::pos());
     heartbeat = startTimer(200);
+    need_modifiers_check = FALSE;
 
 #ifndef QT_NO_CURSOR
     qApp->setOverrideCursor( arrowCursor );
@@ -1669,7 +1761,7 @@
     // qt_xdnd_source_object persists until we get an xdnd_finish message
 }
 
-void QDragManager::updatePixmap()
+void QDragManager::updatePixmap( const QPoint& cursorPos )
 {
     if ( qt_xdnd_deco ) {
 	QPixmap pm;
@@ -1684,15 +1776,19 @@
 		defaultPm = new QPixmap(default_pm);
 	    pm = *defaultPm;
 	}
-	qt_xdnd_deco->setPixmap(pm);
-	qt_xdnd_deco->move(QCursor::pos()-pm_hot);
-	qt_xdnd_deco->repaint(FALSE);
+	qt_xdnd_deco->setPixmap(pm, pm_hot);
+	qt_xdnd_deco->move(cursorPos-pm_hot);
 	    //if ( willDrop ) {
 	    qt_xdnd_deco->show();
 	    //} else {
 	    //    qt_xdnd_deco->hide();
 	    //}
     }
+}
+
+void QDragManager::updatePixmap()
+{
+    updatePixmap( QCursor::pos());
 }
 
 #endif // QT_NO_DRAGANDDROP
diff -uNr qt-x11-free-3.2.3/src/kernel/qdragobject.cpp qt-x11-free-3.2.3-new/src/kernel/qdragobject.cpp
--- qt-x11-free-3.2.3/src/kernel/qdragobject.cpp	Mon Nov 10 05:21:57 2003
+++ qt-x11-free-3.2.3-new/src/kernel/qdragobject.cpp	Tue Feb  3 16:37:02 2004
@@ -363,7 +363,7 @@
 */
 void QDragObject::setPixmap(QPixmap pm)
 {
-    setPixmap(pm,QPoint(pm.width()/2,pm.height()/2));
+    setPixmap(pm,QPoint(-10,-10));
 }
 
 /*!
diff -uNr qt-x11-free-3.2.3/src/kernel/qdragobject.h qt-x11-free-3.2.3-new/src/kernel/qdragobject.h
--- qt-x11-free-3.2.3/src/kernel/qdragobject.h	Mon Nov 10 05:22:12 2003
+++ qt-x11-free-3.2.3-new/src/kernel/qdragobject.h	Tue Feb  3 16:37:02 2004
@@ -245,10 +245,11 @@
     void move( const QPoint & );
     void drop();
     void updatePixmap();
+    void updatePixmap( const QPoint& cursorPos );
 
 private:
     QDragObject * object;
-    void updateMode( ButtonState newstate );
+    bool updateMode( ButtonState newstate );
     void updateCursor();
 
     QWidget * dragSource;
diff -uNr qt-x11-free-3.2.3/src/kernel/qpixmap_x11.cpp qt-x11-free-3.2.3-new/src/kernel/qpixmap_x11.cpp
--- qt-x11-free-3.2.3/src/kernel/qpixmap_x11.cpp	Mon Nov 10 05:21:57 2003
+++ qt-x11-free-3.2.3-new/src/kernel/qpixmap_x11.cpp	Tue Feb  3 16:38:04 2004
@@ -37,7 +37,20 @@
 
 // NOT REVISED
 
+
+#include "qplatformdefs.h"
+
+#if defined(Q_OS_WIN32) && defined(QT_MITSHM)
+#undef QT_MITSHM
+#endif
+
+#ifdef QT_MITSHM
+
+// Use the MIT Shared Memory extension for pixmap<->image conversions
+#define QT_MITSHM_CONVERSIONS
+
 // Uncomment the next line to enable the MIT Shared Memory extension
+// for QPixmap::xForm()
 //
 // WARNING:  This has some problems:
 //
@@ -45,14 +58,13 @@
 //    2. Qt does not handle the ShmCompletion message, so you will
 //        get strange effects if you xForm() repeatedly.
 //
-// #define QT_MITSHM
+// #define QT_MITSHM_XFORM
 
-#if defined(Q_OS_WIN32) && defined(QT_MITSHM)
-#undef QT_MITSHM
+#else
+#undef QT_MITSHM_CONVERSIONS
+#undef QT_MITSHM_XFORM
 #endif
 
-#include "qplatformdefs.h"
-
 #include "qbitmap.h"
 #include "qpaintdevicemetrics.h"
 #include "qimage.h"
@@ -87,7 +99,7 @@
   MIT Shared Memory Extension support: makes xForm noticeably (~20%) faster.
  *****************************************************************************/
 
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
 
 static bool	       xshminit = FALSE;
 static XShmSegmentInfo xshminfo;
@@ -169,8 +181,100 @@
 //     return FALSE;
 // }
 
-#endif // QT_MITSHM
+#endif // QT_MITSHM_XFORM
+
+#ifdef QT_MITSHM_CONVERSIONS
 
+static bool qt_mitshm_error = false;
+static int qt_mitshm_errorhandler( Display*, XErrorEvent* )
+{
+    qt_mitshm_error = true;
+    return 0;
+}
+
+static XImage* qt_XShmCreateImage( Display* dpy, Visual* visual, unsigned int depth,
+    int format, int /*offset*/, char* /*data*/, unsigned int width, unsigned int height,
+    int /*bitmap_pad*/, int /*bytes_per_line*/, XShmSegmentInfo* shminfo )
+{
+    if( width * height * depth < 100*100*32 )
+        return NULL;
+    static int shm_inited = -1;
+    if( shm_inited == -1 ) {
+        if( XShmQueryExtension( dpy ))
+            shm_inited = 1;
+        else
+            shm_inited = 0;
+    }
+    if( shm_inited == 0 )
+        return NULL;
+    XImage* xi = XShmCreateImage( dpy, visual, depth, format, NULL, shminfo, width,
+        height );
+    if( xi == NULL )
+        return NULL;
+    shminfo->shmid = shmget( IPC_PRIVATE, xi->bytes_per_line * xi->height,
+        IPC_CREAT|0777);
+    if( shminfo->shmid < 0 ) {
+        XDestroyImage( xi );
+        return NULL;
+    }
+    shminfo->readOnly = False;
+    shminfo->shmaddr = (char*)shmat( shminfo->shmid, 0, 0 );
+    if( shminfo->shmaddr == (char*)-1 ) {
+        XDestroyImage( xi );
+        shmctl( shminfo->shmid, IPC_RMID, 0 );
+        return NULL;
+    }
+    xi->data = shminfo->shmaddr;
+#ifndef QT_MITSHM_RMID_IGNORES_REFCOUNT
+    // mark as deleted to automatically free the memory in case
+    // of a crash (but this doesn't work e.g. on Solaris)
+    shmctl( shminfo->shmid, IPC_RMID, 0 );
+#endif
+    if( shm_inited == 1 ) { // first time
+        XErrorHandler old_h = XSetErrorHandler( qt_mitshm_errorhandler );
+        XShmAttach( dpy, shminfo );
+        shm_inited = 2;
+        XSync( dpy, False );
+        XSetErrorHandler( old_h );
+        if( qt_mitshm_error ) { // oops ... perhaps we are remote?
+            shm_inited = 0;
+            XDestroyImage( xi );
+            shmdt( shminfo->shmaddr );
+#ifdef QT_MITSHM_RMID_IGNORES_REFCOUNT
+            shmctl( shminfo->shmid, IPC_RMID, 0 );
+#endif    
+            return NULL;
+        }
+    } else
+        XShmAttach( dpy, shminfo );
+    return xi;
+}
+
+static void qt_XShmDestroyImage( XImage* xi, XShmSegmentInfo* shminfo )
+{
+    XShmDetach( QPaintDevice::x11AppDisplay(), shminfo );
+    XDestroyImage( xi );
+    shmdt( shminfo->shmaddr );
+#ifdef QT_MITSHM_RMID_IGNORES_REFCOUNT
+    shmctl( shminfo->shmid, IPC_RMID, 0 );
+#endif    
+}
+
+static XImage* qt_XShmGetImage( const QPixmap* pix, int format,
+    XShmSegmentInfo* shminfo )
+{
+    XImage* xi = qt_XShmCreateImage( pix->x11Display(), (Visual*)pix->x11Visual(),
+        pix->depth(), format, 0, 0, pix->width(), pix->height(), 32, 0, shminfo );
+    if( xi == NULL )
+        return NULL;
+    if( XShmGetImage( pix->x11Display(), pix->handle(), xi, 0, 0, AllPlanes ) == False ) {
+        qt_XShmDestroyImage( xi, shminfo );
+        return NULL;
+    }
+    return xi;
+}
+
+#endif // QT_MITSHM_CONVERSIONS
 
 /*****************************************************************************
   Internal functions
@@ -621,9 +725,20 @@
 	d = 32;					//   > 8  ==> 32
 
     XImage *xi = (XImage *)data->ximage;	// any cached ximage?
-    if ( !xi )					// fetch data from X server
-	xi = XGetImage( x11Display(), hd, 0, 0, w, h, AllPlanes,
+#ifdef QT_MITSHM_CONVERSIONS
+    bool mitshm_ximage = false;
+    XShmSegmentInfo shminfo;
+#endif
+    if ( !xi ) {				// fetch data from X server
+#ifdef QT_MITSHM_CONVERSIONS
+        xi = qt_XShmGetImage( this, mono ? XYPixmap : ZPixmap, &shminfo );
+        if( xi ) {
+            mitshm_ximage = true;
+        } else
+#endif
+	    xi = XGetImage( x11Display(), hd, 0, 0, w, h, AllPlanes,
 			mono ? XYPixmap : ZPixmap );
+    }
     Q_CHECK_PTR( xi );
 
     QImage::Endian bitOrder = QImage::IgnoreEndian;
@@ -632,15 +747,31 @@
 		   QImage::LittleEndian : QImage::BigEndian;
     }
     image.create( w, h, d, 0, bitOrder );
-    if ( image.isNull() )			// could not create image
+    if ( image.isNull() ) {			// could not create image
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage )
+            qt_XShmDestroyImage( xi, &shminfo );
+        else
+#endif
+        qSafeXDestroyImage( xi );
 	return image;
+    }
 
     const QPixmap* msk = mask();
     const QPixmap *alf = data->alphapm;
 
     QImage alpha;
     if (alf) {
-	XImage *axi = XGetImage(x11Display(), alf->hd, 0, 0, w, h, AllPlanes, ZPixmap);
+        XImage* axi;
+#ifdef QT_MITSHM_CONVERSIONS
+        bool mitshm_aximage = false;
+        XShmSegmentInfo ashminfo;
+        axi = qt_XShmGetImage( alf, ZPixmap, &ashminfo );
+        if( axi ) {
+            mitshm_aximage = true;
+        } else
+#endif
+            axi = XGetImage(x11Display(), alf->hd, 0, 0, w, h, AllPlanes, ZPixmap);
 
 	if (axi) {
 	    image.setAlphaBuffer( TRUE );
@@ -654,7 +785,12 @@
 		src += axi->bytes_per_line;
 	    }
 
-	    qSafeXDestroyImage( axi );
+#ifdef QT_MITSHM_CONVERSIONS
+            if( mitshm_aximage )
+                qt_XShmDestroyImage( axi, &ashminfo );
+            else
+#endif
+    	        qSafeXDestroyImage( axi );
 	}
     } else if (msk) {
 	image.setAlphaBuffer( TRUE );
@@ -796,6 +932,12 @@
 		  xi->bits_per_pixel );
 #endif
 	image.reset();
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage )
+            qt_XShmDestroyImage( xi, &shminfo );
+        else
+#endif
+            qSafeXDestroyImage( xi );
 	return image;
     }
 
@@ -901,10 +1043,22 @@
 	delete [] carr;
     }
     if ( data->optim != BestOptim ) {		// throw away image data
-	qSafeXDestroyImage( xi );
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage )
+            qt_XShmDestroyImage( xi, &shminfo );
+        else
+#endif
+            qSafeXDestroyImage( xi );
 	((QPixmap*)this)->data->ximage = 0;
-    } else					// keep ximage data
+    } else {					// keep ximage data
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage ) { // copy the XImage?
+            qt_XShmDestroyImage( xi, &shminfo );
+            xi = 0;
+        }
+#endif
 	((QPixmap*)this)->data->ximage = xi;
+    }
 
     return image;
 }
@@ -940,10 +1094,10 @@
     }
     detach();					// detach other references
     QImage  image = img;
-    int	 w   = image.width();
-    int	 h   = image.height();
+    const uint	 w   = image.width();
+    const uint	 h   = image.height();
     int	 d   = image.depth();
-    int	 dd  = x11Depth();
+    const int	 dd  = x11Depth();
     bool force_mono = (dd == 1 || isQBitmap() ||
 		       (conversion_flags & ColorMode_Mask)==MonoOnly );
 
@@ -1009,7 +1163,7 @@
 	    Q_CHECK_PTR( tmp_bits );
 	    bits = (char *)tmp_bits;
 	    uchar *p, *b, *end;
-	    int y, count;
+	    uint y, count;
 	    if ( image.bitOrder() == QImage::BigEndian ) {
 		const uchar *f = qt_get_bitflip_array();
 		b = tmp_bits;
@@ -1067,28 +1221,31 @@
     bool    trucol = (visual->c_class == TrueColor);
     int	    nbytes = image.numBytes();
     uchar  *newbits= 0;
-    register uchar *p;
+    int newbits_size = 0;
+#ifdef QT_MITSHM_CONVERSIONS
+    bool mitshm_ximage = false;
+    XShmSegmentInfo shminfo;
+#endif
 
     if ( trucol ) {				// truecolor display
 	QRgb  pix[256];				// pixel translation table
-	bool  d8 = d == 8;
-	uint  red_mask	  = (uint)visual->red_mask;
-	uint  green_mask  = (uint)visual->green_mask;
-	uint  blue_mask	  = (uint)visual->blue_mask;
-	int   red_shift	  = highest_bit( red_mask )   - 7;
-	int   green_shift = highest_bit( green_mask ) - 7;
-	int   blue_shift  = highest_bit( blue_mask )  - 7;
-	uint  rbits = highest_bit(red_mask) - lowest_bit(red_mask) + 1;
-	uint  gbits = highest_bit(green_mask) - lowest_bit(green_mask) + 1;
-	uint  bbits = highest_bit(blue_mask) - lowest_bit(blue_mask) + 1;
-	int   r, g, b;
+	const bool  d8 = d == 8;
+	const uint  red_mask	  = (uint)visual->red_mask;
+	const uint  green_mask  = (uint)visual->green_mask;
+	const uint  blue_mask	  = (uint)visual->blue_mask;
+	const int   red_shift	  = highest_bit( red_mask )   - 7;
+	const int   green_shift = highest_bit( green_mask ) - 7;
+	const int   blue_shift  = highest_bit( blue_mask )  - 7;
+	const uint  rbits = highest_bit(red_mask) - lowest_bit(red_mask) + 1;
+	const uint  gbits = highest_bit(green_mask) - lowest_bit(green_mask) + 1;
+	const uint  bbits = highest_bit(blue_mask) - lowest_bit(blue_mask) + 1;
 
 	if ( d8 ) {				// setup pixel translation
 	    QRgb *ctable = image.colorTable();
 	    for ( int i=0; i<image.numColors(); i++ ) {
-		r = qRed  (ctable[i]);
-		g = qGreen(ctable[i]);
-		b = qBlue (ctable[i]);
+		int r = qRed  (ctable[i]);
+		int g = qGreen(ctable[i]);
+		int b = qBlue (ctable[i]);
 		r = red_shift	> 0 ? r << red_shift   : r >> -red_shift;
 		g = green_shift > 0 ? g << green_shift : g >> -green_shift;
 		b = blue_shift	> 0 ? b << blue_shift  : b >> -blue_shift;
@@ -1096,23 +1253,26 @@
 	    }
 	}
 
-	xi = XCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0 );
+#ifdef QT_MITSHM_CONVERSIONS
+        xi = qt_XShmCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0, &shminfo );
+        if( xi != NULL ) {
+            mitshm_ximage = true;
+            newbits = (uchar*)xi->data;
+        }
+        else
+#endif
+	    xi = XCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0 );
 	Q_CHECK_PTR( xi );
-	newbits = (uchar *)malloc( xi->bytes_per_line*h );
+        if( newbits == NULL )
+    	    newbits = (uchar *)malloc( xi->bytes_per_line*h );
 	Q_CHECK_PTR( newbits );
 	if ( !newbits )				// no memory
 	    return FALSE;
-	uchar *src;
-	uchar *dst;
-	QRgb   pixel;
 	int    bppc = xi->bits_per_pixel;
 
-	if ( bppc > 8 && xi->byte_order == LSBFirst )
-	    bppc++;
-
 	bool contig_bits = n_bits(red_mask) == rbits &&
-      n_bits(green_mask) == gbits &&
-       n_bits(blue_mask) == bbits;
+                           n_bits(green_mask) == gbits &&
+                           n_bits(blue_mask) == bbits;
 	bool dither_tc =
 	    // Want it?
 	    (conversion_flags & Dither_Mask) != ThresholdDither &&
@@ -1158,36 +1318,74 @@
 	    }
 	    init=TRUE;
 	}
+        
+        enum { BPP8, 
+               BPP16_8_3_M3, BPP16_7_2_M3, BPP16_MSB, BPP16_LSB,
+               BPP24_MSB, BPP24_LSB,
+               BPP32_16_8_0, BPP32_MSB, BPP32_LSB
+        } mode = BPP8;
 
-	for ( int y=0; y<h; y++ ) {
-	    QRgb *p;
-	    src = image.scanLine( y );
-	    dst = newbits + xi->bytes_per_line*y;
-	    p	= (QRgb *)src;
-
-#define GET_RGB \
-		r = qRed  ( *p ); \
-		g = qGreen( *p ); \
-		b = qBlue ( *p++ ); \
-		r = red_shift   > 0 \
-		    ? r << red_shift   : r >> -red_shift; \
-		g = green_shift > 0 \
-		    ? g << green_shift : g >> -green_shift; \
-		b = blue_shift  > 0 \
-		    ? b << blue_shift  : b >> -blue_shift;
+	if ( bppc > 8 && xi->byte_order == LSBFirst )
+	    bppc++;
+
+        int wordsize;
+        bool bigendian;
+        qSysInfo( &wordsize, &bigendian );
+        bool same_msb_lsb = ( xi->byte_order == MSBFirst ) == ( bigendian );
+        
+        if( bppc == 8 ) // 8 bit
+            mode = BPP8;
+        else if( bppc == 16 || bppc == 17 ) { // 16 bit MSB/LSB
+            if( red_shift == 8 && green_shift == 3 && blue_shift == -3
+                && !d8 && same_msb_lsb )
+                mode = BPP16_8_3_M3;
+            else if( red_shift == 7 && green_shift == 2 && blue_shift == -3
+                && !d8 && same_msb_lsb )
+                mode = BPP16_7_2_M3;
+            else
+                mode = bppc == 17 ? BPP16_LSB : BPP16_MSB;
+        } else if( bppc == 24 || bppc == 25 ) { // 24 bit MSB/LSB
+            mode = bppc == 25 ? BPP24_LSB : BPP24_MSB;
+        } else if( bppc == 32 || bppc == 33 ) { // 32 bit MSB/LSB
+            if( red_shift == 16 && green_shift == 8 && blue_shift == 0
+                && !d8 && same_msb_lsb )
+                mode = BPP32_16_8_0;
+            else
+                mode = bppc == 33 ? BPP32_LSB : BPP32_MSB;
+        } else
+	    qFatal("Logic error 3");
 
 #define GET_PIXEL \
+                int pixel; \
 		if ( d8 ) pixel = pix[*src++]; \
 		else { \
-		    GET_RGB \
-		    pixel = (b & blue_mask)|(g & green_mask) | (r & red_mask); \
+		    int r = qRed  ( *p ); \
+		    int g = qGreen( *p ); \
+		    int b = qBlue ( *p++ ); \
+		    r = red_shift   > 0 \
+		        ? r << red_shift   : r >> -red_shift; \
+		    g = green_shift > 0 \
+		        ? g << green_shift : g >> -green_shift; \
+		    b = blue_shift  > 0 \
+		        ? b << blue_shift  : b >> -blue_shift; \
+		    pixel = (r & red_mask)|(g & green_mask) | (b & blue_mask); \
 		}
 
+// optimized case - no d8 case, shift only once instead of twice, mask only once instead of twice,
+// use direct values instead of variables, and use only one statement
+// (*p >> 16), (*p >> 8 ) and (*p) are qRed(),qGreen() and qBlue() without masking
+// shifts have to be passed including the shift operator (e.g. '>>3'), because of the direction
+#define GET_PIXEL_OPT(red_shift,green_shift,blue_shift,red_mask,green_mask,blue_mask) \
+                int pixel = ((( *p >> 16 ) red_shift ) & red_mask ) \
+                    | ((( *p >> 8 ) green_shift ) & green_mask ) \
+                    | ((( *p ) blue_shift ) & blue_mask ); \
+                ++p;
+
 #define GET_PIXEL_DITHER_TC \
-		r = qRed  ( *p ); \
-		g = qGreen( *p ); \
-		b = qBlue ( *p++ ); \
-		int thres = D[x%16][y%16]; \
+		int r = qRed  ( *p ); \
+		int g = qGreen( *p ); \
+		int b = qBlue ( *p++ ); \
+		const int thres = D[x%16][y%16]; \
 		if ( r <= (255-(1<<(8-rbits))) && ((r<<rbits) & 255) \
 			> thres) \
 		    r += (1<<(8-rbits)); \
@@ -1203,112 +1401,199 @@
 		    ? g << green_shift : g >> -green_shift; \
 		b = blue_shift  > 0 \
 		    ? b << blue_shift  : b >> -blue_shift; \
-		pixel = (b & blue_mask)|(g & green_mask) | (r & red_mask);
+		int pixel = (r & red_mask)|(g & green_mask) | (b & blue_mask);
 
-	    int x;
-	    if ( dither_tc ) {
-		switch ( bppc ) {
-		case 16:			// 16 bit MSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL_DITHER_TC
+// again, optimized case
+// can't be optimized that much :(
+#define GET_PIXEL_DITHER_TC_OPT(red_shift,green_shift,blue_shift,red_mask,green_mask,blue_mask, \
+                                rbits,gbits,bbits) \
+		const int thres = D[x%16][y%16]; \
+		int r = qRed  ( *p ); \
+		if ( r <= (255-(1<<(8-rbits))) && ((r<<rbits) & 255) \
+			> thres) \
+		    r += (1<<(8-rbits)); \
+		int g = qGreen( *p ); \
+		if ( g <= (255-(1<<(8-gbits))) && ((g<<gbits) & 255) \
+			> thres) \
+		    g += (1<<(8-gbits)); \
+		int b = qBlue ( *p++ ); \
+		if ( b <= (255-(1<<(8-bbits))) && ((b<<bbits) & 255) \
+			> thres) \
+		    b += (1<<(8-bbits)); \
+                int pixel = (( r red_shift ) & red_mask ) \
+                    | (( g green_shift ) & green_mask ) \
+                    | (( b blue_shift ) & blue_mask );
+
+#define CYCLE(body) \
+	for ( uint y=0; y<h; y++ ) { \
+	    uchar* src = image.scanLine( y ); \
+	    uchar* dst = newbits + xi->bytes_per_line*y; \
+	    QRgb* p = (QRgb *)src; \
+            body \
+        }
+
+        if ( dither_tc ) {
+	    switch ( mode ) {
+                case BPP16_8_3_M3:
+                    CYCLE(
+                        Q_INT16* dst16 = (Q_INT16*)dst;
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL_DITHER_TC_OPT(<<8,<<3,>>3,0xf800,0x7e0,0x1f,5,6,5)
+                            *dst16++ = pixel;
+		        }
+                    )
+		    break;
+                case BPP16_7_2_M3:
+                    CYCLE(
+                        Q_INT16* dst16 = (Q_INT16*)dst;
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL_DITHER_TC_OPT(<<7,<<2,>>3,0x7c00,0x3e0,0x1f,5,5,5)
+                            *dst16++ = pixel;
+		        }
+                    )
+		    break;
+		case BPP16_MSB:			// 16 bit MSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL_DITHER_TC
 			    *dst++ = (pixel >> 8);
-			*dst++ = pixel;
-		    }
+			    *dst++ = pixel;
+		        }
+                    )
 		    break;
-		case 17:			// 16 bit LSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL_DITHER_TC
+		case BPP16_LSB:			// 16 bit LSB
+                    CYCLE(
+    		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL_DITHER_TC
 			    *dst++ = pixel;
-			*dst++ = pixel >> 8;
-		    }
+			    *dst++ = pixel >> 8;
+		        }
+                    )
 		    break;
 		default:
 		    qFatal("Logic error");
 		}
-	    } else {
-		switch ( bppc ) {
-		case 8:			// 8 bit
-		    for ( x=0; x<w; x++ ) {
-			pixel = pix[*src++];
-			*dst++ = pixel;
-		    }
+	} else {
+	    switch ( mode ) {
+		case BPP8:			// 8 bit
+                    CYCLE(
+                    Q_UNUSED(p);
+		        for ( uint x=0; x<w; x++ ) {
+			    int pixel = pix[*src++];
+			    *dst++ = pixel;
+		        }
+                    )
 		    break;
-		case 16:			// 16 bit MSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL
+                case BPP16_8_3_M3:
+                    CYCLE(
+                        Q_INT16* dst16 = (Q_INT16*)dst;
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL_OPT(<<8,<<3,>>3,0xf800,0x7e0,0x1f)
+                            *dst16++ = pixel;
+		        }
+                    )
+		    break;
+                case BPP16_7_2_M3:
+                    CYCLE(
+                        Q_INT16* dst16 = (Q_INT16*)dst;
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL_OPT(<<7,<<2,>>3,0x7c00,0x3e0,0x1f)
+                            *dst16++ = pixel;
+		        }
+                    )
+		    break;
+		case BPP16_MSB:			// 16 bit MSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL
 			    *dst++ = (pixel >> 8);
-			*dst++ = pixel;
-		    }
+			    *dst++ = pixel;
+		        }
+                    )
 		    break;
-		case 17:			// 16 bit LSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL
+		case BPP16_LSB:			// 16 bit LSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL
 			    *dst++ = pixel;
-			*dst++ = pixel >> 8;
-		    }
+			    *dst++ = pixel >> 8;
+		        }
+                    )
 		    break;
-		case 24:			// 24 bit MSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL
+		case BPP24_MSB:			// 24 bit MSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL
 			    *dst++ = pixel >> 16;
-			*dst++ = pixel >> 8;
-			*dst++ = pixel;
-		    }
+			    *dst++ = pixel >> 8;
+			    *dst++ = pixel;
+		        }
+                    )
 		    break;
-		case 25:			// 24 bit LSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL
+		case BPP24_LSB:			// 24 bit LSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL
 			    *dst++ = pixel;
-			*dst++ = pixel >> 8;
-			*dst++ = pixel >> 16;
-		    }
+			    *dst++ = pixel >> 8;
+			    *dst++ = pixel >> 16;
+		        }
+                    )
 		    break;
-		case 32:			// 32 bit MSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL
+                case BPP32_16_8_0:
+                    CYCLE(
+                        memcpy( dst, p, w * 4 );
+                    )
+                    break;
+		case BPP32_MSB:			// 32 bit MSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL
 			    *dst++ = pixel >> 24;
-			*dst++ = pixel >> 16;
-			*dst++ = pixel >> 8;
-			*dst++ = pixel;
-		    }
+			    *dst++ = pixel >> 16;
+			    *dst++ = pixel >> 8;
+			    *dst++ = pixel;
+		        }
+                    )
 		    break;
-		case 33:			// 32 bit LSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL
+		case BPP32_LSB:			// 32 bit LSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL
 			    *dst++ = pixel;
-			*dst++ = pixel >> 8;
-			*dst++ = pixel >> 16;
-			*dst++ = pixel >> 24;
-		    }
+			    *dst++ = pixel >> 8;
+			    *dst++ = pixel >> 16;
+			    *dst++ = pixel >> 24;
+		        }
+                    )
 		    break;
 		default:
 		    qFatal("Logic error 2");
-		}
 	    }
 	}
 	xi->data = (char *)newbits;
     }
 
     if ( d == 8 && !trucol ) {			// 8 bit pixmap
-	int  i, j;
 	int  pop[256];				// pixel popularity
 
 	if ( image.numColors() == 0 )
 	    image.setNumColors( 1 );
 
 	memset( pop, 0, sizeof(int)*256 );	// reset popularity array
-	for ( i=0; i<h; i++ ) {			// for each scanline...
-	    p = image.scanLine( i );
+	for ( uint i=0; i<h; i++ ) {			// for each scanline...
+	    uchar* p = image.scanLine( i );
 	    uchar *end = p + w;
 	    while ( p < end )			// compute popularity
 		pop[*p++]++;
 	}
 
 	newbits = (uchar *)malloc( nbytes );	// copy image into newbits
+        newbits_size = nbytes;
 	Q_CHECK_PTR( newbits );
 	if ( !newbits )				// no memory
 	    return FALSE;
-	p = newbits;
+	uchar* p = newbits;
 	memcpy( p, image.bits(), nbytes );	// copy image data into newbits
 
 	/*
@@ -1323,11 +1608,11 @@
 	    int	  mindist;
 	};
 	int ncols = 0;
-	for ( i=0; i<image.numColors(); i++ ) { // compute number of colors
+	for ( int i=0; i<image.numColors(); i++ ) { // compute number of colors
 	    if ( pop[i] > 0 )
 		ncols++;
 	}
-	for ( i=image.numColors(); i<256; i++ ) // ignore out-of-range pixels
+	for ( int i=image.numColors(); i<256; i++ ) // ignore out-of-range pixels
 	    pop[i] = 0;
 
 	// works since we make sure above to have at least
@@ -1342,9 +1627,9 @@
 	int  maxpop = 0;
 	int  maxpix = 0;
 	Q_CHECK_PTR( pixarr );
-	j = 0;
+	uint j = 0;
 	QRgb* ctable = image.colorTable();
-	for ( i=0; i<256; i++ ) {		// init pixel array
+	for ( uint i=0; i<256; i++ ) {		// init pixel array
 	    if ( pop[i] > 0 ) {
 		px->r = qRed  ( ctable[i] );
 		px->g = qGreen( ctable[i] );
@@ -1364,7 +1649,7 @@
 	pixarr_sorted[0] = pixarr[maxpix];
 	pixarr[maxpix].use = 0;
 
-	for ( i=1; i<ncols; i++ ) {		// sort pixels
+	for ( int i=1; i<ncols; i++ ) {		// sort pixels
 	    int minpix = -1, mindist = -1;
 	    px = &pixarr_sorted[i-1];
 	    int r = px->r;
@@ -1372,7 +1657,7 @@
 	    int b = px->b;
 	    int dist;
 	    if ( (i & 1) || i<10 ) {		// sort on max distance
-		for ( j=0; j<ncols; j++ ) {
+		for ( int j=0; j<ncols; j++ ) {
 		    px = &pixarr[j];
 		    if ( px->use ) {
 			dist = (px->r - r)*(px->r - r) +
@@ -1387,7 +1672,7 @@
 		    }
 		}
 	    } else {				// sort on max popularity
-		for ( j=0; j<ncols; j++ ) {
+		for ( int j=0; j<ncols; j++ ) {
 		    px = &pixarr[j];
 		    if ( px->use ) {
 			dist = (px->r - r)*(px->r - r) +
@@ -1408,32 +1693,39 @@
 
 	uint pix[256];				// pixel translation table
 	px = &pixarr_sorted[0];
-	for ( i=0; i<ncols; i++ ) {		// allocate colors
+	for ( int i=0; i<ncols; i++ ) {		// allocate colors
 	    QColor c( px->r, px->g, px->b );
 	    pix[px->index] = c.pixel(x11Screen());
 	    px++;
 	}
 
 	p = newbits;
-	for ( i=0; i<nbytes; i++ ) {		// translate pixels
+	for ( int i=0; i<nbytes; i++ ) {		// translate pixels
 	    *p = pix[*p];
 	    p++;
 	}
     }
 
     if ( !xi ) {				// X image not created
-	xi = XCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0 );
+#ifdef QT_MITSHM_CONVERSIONS
+        xi = qt_XShmCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0, &shminfo );
+        if( xi != NULL )
+            mitshm_ximage = true;
+        else
+#endif
+	    xi = XCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0 );
 	if ( xi->bits_per_pixel == 16 ) {	// convert 8 bpp ==> 16 bpp
 	    ushort *p2;
 	    int	    p2inc = xi->bytes_per_line/sizeof(ushort);
 	    ushort *newerbits = (ushort *)malloc( xi->bytes_per_line * h );
+            newbits_size = xi->bytes_per_line * h;
 	    Q_CHECK_PTR( newerbits );
 	    if ( !newerbits )				// no memory
 		return FALSE;
-	    p = newbits;
-	    for ( int y=0; y<h; y++ ) {		// OOPS: Do right byte order!!
+	    uchar* p = newbits;
+	    for ( uint y=0; y<h; y++ ) {		// OOPS: Do right byte order!!
 		p2 = newerbits + p2inc*y;
-		for ( int x=0; x<w; x++ )
+		for ( uint x=0; x<w; x++ )
 		    *p2++ = *p++;
 	    }
 	    free( newbits );
@@ -1444,10 +1736,18 @@
 		      "(bpp=%d)", xi->bits_per_pixel );
 #endif
 	}
-	xi->data = (char *)newbits;
+#ifdef QT_MITSHM_CONVERSIONS
+        if( newbits_size > 0 && mitshm_ximage ) { // need to copy to shared memory
+            memcpy( xi->data, newbits, newbits_size );
+            free( newbits );
+            newbits = (uchar*)xi->data;
+        }
+        else
+#endif
+            xi->data = (char *)newbits;
     }
 
-    if ( hd && (width() != w || height() != h || this->depth() != dd) ) {
+    if ( hd && (width() != (int)w || height() != (int)h || this->depth() != dd) ) {
 
 #ifndef QT_NO_XFTFREETYPE
 	if (rendhd) {
@@ -1477,19 +1777,24 @@
 
     }
 
-    XPutImage( dpy, hd, qt_xget_readonly_gc( x11Screen(), FALSE  ),
-	       xi, 0, 0, 0, 0, w, h );
+#ifdef QT_MITSHM_CONVERSIONS
+    if( mitshm_ximage )
+        XShmPutImage( dpy, hd, qt_xget_readonly_gc( x11Screen(), FALSE ),
+                      xi, 0, 0, 0, 0, w, h, False );
+    else
+#endif
+        XPutImage( dpy, hd, qt_xget_readonly_gc( x11Screen(), FALSE  ),
+                   xi, 0, 0, 0, 0, w, h );
 
-    if ( data->optim != BestOptim ) {		// throw away image
-	qSafeXDestroyImage( xi );
-	data->ximage = 0;
-    } else {					// keep ximage that we created
-	data->ximage = xi;
-    }
     data->w = w;
     data->h = h;
     data->d = dd;
 
+    XImage* axi = NULL;
+#ifdef QT_MITSHM_CONVERSIONS
+    bool mitshm_aximage = false;
+    XShmSegmentInfo ashminfo;
+#endif
     if ( img.hasAlphaBuffer() ) {
 	QBitmap m;
 	m = img.createAlphaMask( conversion_flags );
@@ -1513,29 +1818,79 @@
 	    data->alphapm->rendhd =
 		(HANDLE) XftDrawCreateAlpha( x11Display(), data->alphapm->hd, 8 );
 
-	    XImage *axi = XCreateImage(x11Display(), (Visual *) x11Visual(),
+#ifdef QT_MITSHM_CONVERSIONS
+            axi = qt_XShmCreateImage( x11Display(), (Visual*)x11Visual(),
+                                      8, ZPixmap, 0, 0, w, h, 8, 0, &ashminfo );
+            if( axi != NULL )
+                mitshm_aximage = true;
+            else
+#endif
+	        axi = XCreateImage(x11Display(), (Visual *) x11Visual(),
 				       8, ZPixmap, 0, 0, w, h, 8, 0);
 
 	    if (axi) {
-		// the data is deleted by qSafeXDestroyImage
-		axi->data = (char *) malloc(h * axi->bytes_per_line);
-		Q_CHECK_PTR( axi->data );
-
+                if( axi->data==NULL ) {
+		    // the data is deleted by qSafeXDestroyImage
+		    axi->data = (char *) malloc(h * axi->bytes_per_line);
+		    Q_CHECK_PTR( axi->data );
+                }
 		char *aptr = axi->data;
 		int *iptr = (int *) image.bits();
-		int max = w * h;
-		for (int i = 0; i < max; i++)
-		    *aptr++ = *iptr++ >> 24; // squirt
+                if( axi->bytes_per_line == (int)w ) {
+		    uint max = w * h;
+		    for (uint i = 0; i < max; i++)
+		        *aptr++ = *iptr++ >> 24; // squirt
+                } else {
+                    for (uint i = 0; i < h; ++i ) {
+                        for (uint j = 0; j < w; ++ j )
+                            *aptr++ = *iptr++ >> 24; // squirt
+                        aptr += ( axi->bytes_per_line - w );
+                    }
+                }
 
 		GC gc = XCreateGC(x11Display(), data->alphapm->hd, 0, 0);
-		XPutImage(dpy, data->alphapm->hd, gc, axi, 0, 0, 0, 0, w, h);
+#ifdef QT_MITSHM_CONVERSIONS
+                if( mitshm_aximage )
+                    XShmPutImage( dpy, data->alphapm->hd, gc, axi, 0, 0, 0, 0, w, h, False );
+                else
+#endif
+		    XPutImage(dpy, data->alphapm->hd, gc, axi, 0, 0, 0, 0, w, h);
 		XFreeGC(x11Display(), gc);
-		qSafeXDestroyImage(axi);
 	    }
 	}
 #endif // QT_NO_XFTFREETYPE
     }
 
+#ifdef QT_MITSHM_CONVERSIONS
+    if( mitshm_ximage || mitshm_aximage )
+        XSync( x11Display(), False ); // wait until processed
+#endif
+
+    if ( data->optim != BestOptim ) {		// throw away image
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage )
+            qt_XShmDestroyImage( xi, &shminfo );
+        else
+#endif
+	qSafeXDestroyImage( xi );
+	data->ximage = 0;
+    } else {					// keep ximage that we created
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage ) { // copy the XImage?
+            qt_XShmDestroyImage( xi, &shminfo );
+            xi = 0;
+        }
+#endif
+	data->ximage = xi;
+    }
+    if( axi ) {
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_aximage )
+            qt_XShmDestroyImage( axi, &ashminfo );
+        else
+#endif
+        qSafeXDestroyImage(axi);
+    }
     return TRUE;
 }
 
@@ -1692,7 +2047,7 @@
 	return pm;
     }
 
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
     static bool try_once = TRUE;
     if (try_once) {
 	try_once = FALSE;
@@ -1725,7 +2080,7 @@
 	dbpl = ((w*bpp+31)/32)*4;
     dbytes = dbpl*h;
 
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
     if ( use_mitshm ) {
 	dptr = (uchar *)xshmimg->data;
 	uchar fillbyte = bpp == 8 ? white.pixel() : 0xff;
@@ -1741,7 +2096,7 @@
 	    memset( dptr, Qt::white.pixel( x11Screen() ), dbytes );
 	else
 	    memset( dptr, 0xff, dbytes );
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
     }
 #endif
 
@@ -1772,7 +2127,7 @@
     } else {
 	xbpl  = (w*bpp)/8;
 	p_inc = dbpl - xbpl;
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
 	if ( use_mitshm )
 	    p_inc = xshmimg->bytes_per_line - xbpl;
 #endif
@@ -1809,7 +2164,7 @@
 	QPixmap pm( w, h );
 	pm.data->uninit = FALSE;
 	pm.x11SetScreen( x11Screen() );
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
 	if ( use_mitshm ) {
 	    XCopyArea( dpy, xshmpm, pm.handle(), gc, 0, 0, w, h, 0, 0 );
 	} else {
@@ -1818,7 +2173,7 @@
 			       ZPixmap, 0, (char *)dptr, w, h, 32, 0 );
 	    XPutImage( dpy, pm.handle(), gc, xi, 0, 0, 0, 0, w, h);
 	    qSafeXDestroyImage( xi );
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
 	}
 #endif
 
diff -uNr qt-x11-free-3.2.3/src/kernel/qprocess_unix.cpp qt-x11-free-3.2.3-new/src/kernel/qprocess_unix.cpp
--- qt-x11-free-3.2.3/src/kernel/qprocess_unix.cpp	Mon Nov 10 05:21:57 2003
+++ qt-x11-free-3.2.3-new/src/kernel/qprocess_unix.cpp	Tue Feb  3 16:37:02 2004
@@ -779,7 +779,7 @@
 
 	if ( env == 0 ) { // inherit environment and start process
 	    QString command = _arguments[0];
-#if defined(Q_OS_MACX) //look in a bundle
+#if defined(Q_OS_MACX) || defined(Q_OS_DARWIN) //look in a bundle
 	    const QString mac_bundle_suffix = ".app/Contents/MacOS/";
 	    if(!QFile::exists(command) && QFile::exists(command + mac_bundle_suffix)) {
 		QString exec = command;
@@ -799,7 +799,7 @@
 	} else { // start process with environment settins as specified in env
 	    // construct the environment for exec
 	    int numEntries = env->count();
-#if defined(Q_OS_MACX)
+#if defined(Q_OS_MACX) || defined(Q_OS_DARWIN)
 	    QString ld_library_path("DYLD_LIBRARY_PATH");
 #else
 	    QString ld_library_path("LD_LIBRARY_PATH");
@@ -831,7 +831,7 @@
 		    QStringList pathList = QStringList::split( ':', getenv( "PATH" ) );
 		    for (QStringList::Iterator it = pathList.begin(); it != pathList.end(); ++it ) {
 			QString dir = *it;
-#if defined(Q_OS_MACX) //look in a bundle
+#if defined(Q_OS_MACX) || defined(Q_OS_DARWIN) //look in a bundle
 			if(!QFile::exists(dir + "/" + command) && QFile::exists(dir + "/" + command + ".app"))
 			    dir += "/" + command + ".app/Contents/MacOS";
 #endif
@@ -841,7 +841,7 @@
 			QFileInfo fileInfo( dir + "/" + command );
 #endif
 			if ( fileInfo.isExecutable() ) {
-#if defined(Q_OS_MACX)
+#if defined(Q_OS_MACX) || defined(Q_OS_DARWIN)
 			    arglistQ[0] = fileInfo.absFilePath().local8Bit();
 #else
 			    arglistQ[0] = fileInfo.filePath().local8Bit();
@@ -852,7 +852,7 @@
 		    }
 		}
 	    }
-#if defined(Q_OS_MACX)
+#if defined(Q_OS_MACX) || defined(Q_OS_DARWIN)
 	    if(!QFile::exists(arglist[0])) {
 		QString command = arglist[0];
 		const QString mac_bundle_suffix = ".app/Contents/MacOS/";
diff -uNr qt-x11-free-3.2.3/src/kernel/qwidget.cpp qt-x11-free-3.2.3-new/src/kernel/qwidget.cpp
--- qt-x11-free-3.2.3/src/kernel/qwidget.cpp	Mon Nov 10 05:22:05 2003
+++ qt-x11-free-3.2.3-new/src/kernel/qwidget.cpp	Tue Feb  3 16:37:02 2004
@@ -5718,11 +5718,19 @@
     strange effects on desktop changes or when the user raises other
     windows.
 
-    Future X11 window managers that follow modern post-ICCCM
-    specifications may support full-screen mode properly.
+    X11 window managers that follow modern post-ICCCM
+    specifications support full-screen mode properly.
 
     \sa showNormal(), showMaximized(), show(), hide(), isVisible()
 */
+
+#if defined(Q_WS_X11)
+#include <X11/X.h>
+extern Atom qt_net_wm_state_fullscreen;
+extern bool qt_net_supports(Atom);
+extern void qt_net_change_state(const QWidget*,Atom,bool);
+#endif
+
 #if (QT_VERSION-0 >= 0x040000)
 #error "QWidget::showFullScreen() should be virtual (see change #16156)"
 #endif
@@ -5730,6 +5738,20 @@
 {
     if ( !isTopLevel() )
 	return;
+#if defined(Q_WS_X11)
+    if( qt_net_supports(qt_net_wm_state_fullscreen)) {
+        if( topData()->fullscreen ) {
+            show();
+            return;
+        }
+        qt_net_change_state(this,qt_net_wm_state_fullscreen,true);
+        topData()->fullscreen = 1;
+        show();
+        QEvent e( QEvent::ShowFullScreen );
+        QApplication::sendEvent( this, &e );
+        return;
+    }
+#endif
     if ( topData()->fullscreen ) {
 	show();
 	raise();
diff -uNr qt-x11-free-3.2.3/src/kernel/qwidget_x11.cpp qt-x11-free-3.2.3-new/src/kernel/qwidget_x11.cpp
--- qt-x11-free-3.2.3/src/kernel/qwidget_x11.cpp	Mon Nov 10 05:22:04 2003
+++ qt-x11-free-3.2.3-new/src/kernel/qwidget_x11.cpp	Tue Feb  3 16:37:02 2004
@@ -110,6 +110,7 @@
 extern Atom qt_net_wm_state_modal;
 extern Atom qt_net_wm_state_max_v;
 extern Atom qt_net_wm_state_max_h;
+extern Atom qt_net_wm_state_fullscreen;
 extern Atom qt_net_wm_state_stays_on_top;
 extern Atom qt_net_wm_window_type;
 extern Atom qt_net_wm_window_type_normal;
@@ -124,6 +125,7 @@
 
 // defined in qapplication_x11.cpp
 extern bool qt_net_supports(Atom);
+extern void qt_net_change_state(const QWidget*,Atom,bool);
 extern unsigned long *qt_net_virtual_root_list;
 
 #if defined (QT_TABLET_SUPPORT)
@@ -490,9 +492,7 @@
 	     testWFlags(WStyle_StaysOnTop) ||
 	     dialog ||
 	     testWFlags(WStyle_Tool) ) {
-	    if ( testWFlags( WStyle_StaysOnTop ) )
-		XSetTransientForHint( dpy, id, None );
-	    else if ( p )
+	    if ( p )
 		XSetTransientForHint( dpy, id, p->winId() );
 	    else				// application-modal
 		XSetTransientForHint( dpy, id, root_win );
@@ -516,11 +516,11 @@
 	wm_hints.initial_state = NormalState;
 	wm_hints.flags = InputHint | StateHint;
 
-	if ( p && ! p->isDesktop() ) {
-            // the real client leader (head of the group)
-	    wm_hints.window_group = p->winId();
-	    wm_hints.flags |= WindowGroupHint;
-	}
+	if ( !qt_x11_wm_client_leader )
+	    qt_x11_create_wm_client_leader();
+
+	wm_hints.window_group = qt_x11_wm_client_leader;
+	wm_hints.flags |= WindowGroupHint;
 
 	XClassHint class_hint;
 	class_hint.res_class = (char*) title;	// app name
@@ -566,9 +566,6 @@
 			 qt_window_role, XA_STRING, 8, PropModeReplace,
 			 (unsigned char *)name(), qstrlen( name() ) );
 
-	if ( !qt_x11_wm_client_leader )
-	    qt_x11_create_wm_client_leader();
-
 	// set client leader property
 	XChangeProperty( dpy, id, qt_wm_client_leader,
 			 XA_WINDOW, 32, PropModeReplace,
@@ -1729,9 +1726,13 @@
 {
     if ( isTopLevel() ) {
 	if ( topData()->fullscreen ) {
-	    // when reparenting, preserve some widget flags
-	    reparent( 0, topData()->savedFlags, QPoint(0,0) );
-	    topData()->fullscreen = 0;
+            if( qt_net_supports(qt_net_wm_state_fullscreen)) {
+                qt_net_change_state(this,qt_net_wm_state_fullscreen,false);
+            } else {
+	        // when reparenting, preserve some widget flags
+	        reparent( 0, topData()->savedFlags, QPoint(0,0) );
+        	    topData()->fullscreen = 0;
+            }
 	}
 	QRect r = topData()->normalGeometry;
 	if ( r.width() >= 0 ) {
@@ -1745,7 +1746,7 @@
 	extra->topextra->fullscreen = 0;
     if ( !isVisible() ) {
 	show();
-    } else {
+    } else if( testWState( WState_Minimized )) {
 	showWindow();
     }
     QEvent e( QEvent::ShowNormal );
diff -uNr qt-x11-free-3.2.3/src/moc/moc.pro qt-x11-free-3.2.3-new/src/moc/moc.pro
--- qt-x11-free-3.2.3/src/moc/moc.pro	Tue May 13 03:08:35 2003
+++ qt-x11-free-3.2.3-new/src/moc/moc.pro	Tue Feb  3 16:37:02 2004
@@ -44,6 +44,9 @@
 win32:SOURCES	+= ../tools/qfile_win.cpp ../tools/qdir_win.cpp ../tools/qfileinfo_win.cpp
 macx:LIBS	+= -framework Carbon
 
+QMAKE_CFLAGS += -mdynamic-no-pic
+QMAKE_CXXFLAGS += -mdynamic-no-pic
+
 TARGET		= moc
 
 target.path=$$bins.path
diff -uNr qt-x11-free-3.2.3/src/qtmain.pro qt-x11-free-3.2.3-new/src/qtmain.pro
--- qt-x11-free-3.2.3/src/qtmain.pro	Tue May 13 03:08:35 2003
+++ qt-x11-free-3.2.3-new/src/qtmain.pro	Tue Feb  3 16:37:02 2004
@@ -3,6 +3,7 @@
 TEMPLATE	= lib
 TARGET		= qtmain
 VERSION		= 3.1.0
+COMPATIBILITY_VERSION = 3.0.0
 DESTDIR		= $$QMAKE_LIBDIR_QT
 
 CONFIG		+= qt staticlib warn_on release
diff -uNr qt-x11-free-3.2.3/src/tools/qdir_unix.cpp qt-x11-free-3.2.3-new/src/tools/qdir_unix.cpp
--- qt-x11-free-3.2.3/src/tools/qdir_unix.cpp	Mon Nov 10 05:21:39 2003
+++ qt-x11-free-3.2.3-new/src/tools/qdir_unix.cpp	Tue Feb  3 16:37:02 2004
@@ -88,7 +88,7 @@
 
 bool QDir::mkdir( const QString &dirName, bool acceptAbsPath ) const
 {
-#if defined(Q_OS_MACX)  // Mac X doesn't support trailing /'s
+#if defined(Q_OS_MACX) || defined(Q_OS_DARWIN) // Mac X doesn't support trailing /'s
     QString name = dirName;
     if (dirName[dirName.length() - 1] == "/")
 	name = dirName.left( dirName.length() - 1 );
diff -uNr qt-x11-free-3.2.3/src/tools/qglobal.h qt-x11-free-3.2.3-new/src/tools/qglobal.h
--- qt-x11-free-3.2.3/src/tools/qglobal.h	Mon Nov 10 05:21:38 2003
+++ qt-x11-free-3.2.3-new/src/tools/qglobal.h	Tue Feb  3 16:37:02 2004
@@ -79,6 +79,10 @@
      UNIX	- Any UNIX BSD/SYSV system
 */
 
+#ifndef __DARWIN_X11__
+#define __DARWIN_X11__
+#endif
+
 #if defined(__DARWIN_X11__)
 #  define Q_OS_DARWIN
 #elif defined(__APPLE__) && defined(__GNUC__)
@@ -527,6 +531,8 @@
 
 #if defined(Q_OS_MAC9)
 #  define Q_WS_MAC9
+#elif defined(__DARWIN_X11__)
+#  define Q_WS_X11
 #elif defined(Q_OS_MSDOS)
 #  define Q_WS_WIN16
 #  error "Qt requires Win32 and does not work with Windows 3.x"
diff -uNr qt-x11-free-3.2.3/src/tools/qgpluginmanager.cpp qt-x11-free-3.2.3-new/src/tools/qgpluginmanager.cpp
--- qt-x11-free-3.2.3/src/tools/qgpluginmanager.cpp	Mon Nov 10 05:21:38 2003
+++ qt-x11-free-3.2.3-new/src/tools/qgpluginmanager.cpp	Tue Feb  3 16:37:02 2004
@@ -316,7 +316,7 @@
 
 #if defined(Q_OS_WIN32)
     QString filter = "*.dll";
-#elif defined(Q_OS_MACX)
+#elif defined(Q_OS_MACX) || defined(Q_OS_DARWIN)
     QString filter = "*.dylib; *.so; *.bundle";
 #elif defined(Q_OS_HPUX)
     QString filter = "*.sl";
diff -uNr qt-x11-free-3.2.3/src/tools/qlibrary.cpp qt-x11-free-3.2.3-new/src/tools/qlibrary.cpp
--- qt-x11-free-3.2.3/src/tools/qlibrary.cpp	Mon Nov 10 05:21:37 2003
+++ qt-x11-free-3.2.3-new/src/tools/qlibrary.cpp	Tue Feb  3 16:37:02 2004
@@ -1,5 +1,6 @@
+//depot/qt/3/src/tools/qlibrary.cpp#9 - edit change 123005 (text)
 /****************************************************************************
-** $Id: qt/qlibrary.cpp   3.2.3   edited Jun 23 08:51 $
+** $Id: qt/qlibrary.cpp   3.3.0-snapshot-20040130   edited Jan 13 20:03 $
 **
 ** Implementation of QLibrary class
 **
@@ -37,6 +38,7 @@
 
 #include "qplatformdefs.h"
 #include <private/qlibrary_p.h>
+#include <qstringlist.h>
 #include <qfile.h>
 
 #ifndef QT_NO_LIBRARY
@@ -52,7 +54,8 @@
 # endif
 #endif
 
-#if defined(Q_WS_WIN) && !defined(QT_MAKEDLL)
+#if (defined(Q_WS_WIN) && !defined(QT_MAKEDLL)) \
+    || (defined(Q_OS_FREEBSD) && defined(Q_CC_INTEL))
 #define QT_NO_LIBRARY_UNLOAD
 #endif
 
@@ -170,6 +173,54 @@
 	return -1;
     \endcode
 
+    The symbol must be exported as a C-function from the library. This
+    requires the \c {extern "C"} notation if the library is compiled
+    with a C++ compiler. On Windows you also have to explicitly export
+    the function from the DLL using the \c {__declspec(dllexport)}
+    compiler directive.
+
+    \code
+    extern "C" MY_EXPORT_MACRO int avg(int a, int b)
+    {
+	return (a + b) / 2;
+    }
+    \endcode
+
+    with \c MY_EXPORT defined as
+
+    \code
+    #ifdef Q_WS_WIN
+    # define MY_EXPORT __declspec(dllexport)
+    #else
+    # define MY_EXPORT
+    #endif
+    \endcode
+
+    On Darwin and Mac OS X this function uses code from dlcompat, part of the
+    OpenDarwin project.
+
+    \legalese
+
+    Copyright (c) 2002 Jorge Acereda and Peter O'Gorman
+
+    Permission is hereby granted, free of charge, to any person obtaining
+    a copy of this software and associated documentation files (the
+    "Software"), to deal in the Software without restriction, including
+    without limitation the rights to use, copy, modify, merge, publish,
+    distribute, sublicense, and/or sell copies of the Software, and to
+    permit persons to whom the Software is furnished to do so, subject to
+    the following conditions:
+
+    The above copyright notice and this permission notice shall be
+    included in all copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
 void *QLibrary::resolve( const char* symb )
 {
@@ -237,6 +288,32 @@
     before resolving any symbols it is not necessary to call it
     explicitly. In some situations you might want the library loaded
     in advance, in which case you would use this function.
+
+    On Darwin and Mac OS X this function uses code from dlcompat, part of the
+    OpenDarwin project.
+
+    \legalese
+
+    Copyright (c) 2002 Jorge Acereda and Peter O'Gorman
+
+    Permission is hereby granted, free of charge, to any person obtaining
+    a copy of this software and associated documentation files (the
+    "Software"), to deal in the Software without restriction, including
+    without limitation the rights to use, copy, modify, merge, publish,
+    distribute, sublicense, and/or sell copies of the Software, and to
+    permit persons to whom the Software is furnished to do so, subject to
+    the following conditions:
+
+    The above copyright notice and this permission notice shall be
+    included in all copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
 bool QLibrary::load()
 {
@@ -320,29 +397,41 @@
     if ( filename.findRev( '.' ) <= filename.findRev( '/' ) )
 	filename += ".dll";
 #else
+    QStringList filters = "";
 #ifdef Q_OS_MACX
-    QString filter = ".dylib";
+    filters << ".so";
+    filters << ".bundle";
+    filters << ".dylib"; //the last one is also the default one..
 #elif defined(Q_OS_HPUX)
-    QString filter = ".sl";
+    filters << ".sl";
 #else
-    QString filter = ".so";
+    filters << ".so";
 #endif
-    if ( filename.find(filter) == -1 ) {
+    for(QStringList::Iterator it = filters.begin(); TRUE; ) {
+	QString filter = (*it);
+	++it;
+
 	if(QFile::exists(filename + filter)) {
 	    filename += filter;
-	} else { 
-	    const int x = filename.findRev( "/" );
+	    break;
+	} else if(!filter.isEmpty()) {
+	    QString tmpfilename = filename;
+	    const int x = tmpfilename.findRev( "/" );
 	    if ( x != -1 ) {
-		QString path = filename.left( x + 1 );
-		QString file = filename.right( filename.length() - x - 1 );
-		filename = QString( "%1lib%2%3" ).arg( path ).arg( file ).arg( filter );
+		QString path = tmpfilename.left( x + 1 );
+		QString file = tmpfilename.right( tmpfilename.length() - x - 1 );
+		tmpfilename = QString( "%1lib%2" ).arg( path ).arg( file );
 	    } else {
-		filename = QString( "lib%1%2" ).arg( filename ).arg( filter );
+		tmpfilename = QString( "lib%1" ).arg( filename );
+	    }
+	    tmpfilename += filter;
+	    if(QFile::exists(tmpfilename) || it == filters.end()) {
+		filename = tmpfilename;
+		break;
 	    }
 	}
     }
 #endif
-
     return filename;
 }
 #endif //QT_NO_LIBRARY
diff -uNr qt-x11-free-3.2.3/src/tools/qmutex_unix.cpp qt-x11-free-3.2.3-new/src/tools/qmutex_unix.cpp
--- qt-x11-free-3.2.3/src/tools/qmutex_unix.cpp	Mon Nov 10 05:21:38 2003
+++ qt-x11-free-3.2.3-new/src/tools/qmutex_unix.cpp	Tue Feb  3 16:37:02 2004
@@ -44,7 +44,7 @@
 // POSIX threads mutex types
 #if ((defined(PTHREAD_MUTEX_RECURSIVE) && defined(PTHREAD_MUTEX_DEFAULT)) || \
      defined(Q_OS_FREEBSD)) && !defined(Q_OS_UNIXWARE) && !defined(Q_OS_SOLARIS) && \
-    !defined(Q_OS_MAC)
+    !defined(Q_OS_MAC) && !defined(Q_OS_DARWIN)
 // POSIX 1003.1c-1995 - We love this OS
 #  define Q_MUTEX_SET_TYPE(a, b) pthread_mutexattr_settype((a), (b))
 #  if defined(QT_CHECK_RANGE)
diff -uNr qt-x11-free-3.2.3/src/tools/qstring.cpp qt-x11-free-3.2.3-new/src/tools/qstring.cpp
--- qt-x11-free-3.2.3/src/tools/qstring.cpp	Mon Nov 10 05:21:41 2003
+++ qt-x11-free-3.2.3-new/src/tools/qstring.cpp	Tue Feb  3 16:37:02 2004
@@ -1337,7 +1337,7 @@
 QStringData* QString::makeSharedNull()
 {
     QString::shared_null = new QStringData;
-#if defined( Q_OS_MAC ) || defined(Q_OS_SOLARIS) || defined(Q_OS_HPUX) || defined(Q_OS_AIX)
+#if defined( Q_OS_MAC ) || defined( Q_OS_DARWIN ) || defined(Q_OS_SOLARIS) || defined(Q_OS_HPUX) || defined(Q_OS_AIX)
     QString *that = const_cast<QString *>(&QString::null);
     that->d = QString::shared_null;
 #endif
@@ -2541,7 +2541,7 @@
     if ( !sl )
 	return index;
 
-#if defined(Q_OS_MACX) && defined(QT_MACOSX_VERSION) && QT_MACOSX_VERSION >= 0x1020
+#if defined(Q_OS_MACX) && ((defined(QT_MACOSX_VERSION) && QT_MACOSX_VERSION >= 0x1020) || defined(Q_OS_DARWIN))
     if ( sl == 1 )
 	return find( *str.unicode(), index, cs );
 #endif
@@ -2640,7 +2640,7 @@
 
 int QString::findRev( QChar c, int index, bool cs ) const
 {
-#if defined(Q_OS_MACX) && defined(QT_MACOSX_VERSION) && QT_MACOSX_VERSION < 0x1020
+#if defined(Q_OS_MACX) && ((defined(QT_MACOSX_VERSION) && QT_MACOSX_VERSION < 0x1020) || defined(Q_OS_DARWIN))
     return findRev( QString( c ), index, cs );
 #else
     const uint l = length();
@@ -2696,7 +2696,7 @@
     if ( index > delta )
 	index = delta;
 
-#if defined(Q_OS_MACX) && defined(QT_MACOSX_VERSION) && QT_MACOSX_VERSION >= 0x1020
+#if defined(Q_OS_MACX) && ((defined(QT_MACOSX_VERSION) && QT_MACOSX_VERSION >= 0x1020) || defined(Q_OS_DARWIN))
     if ( sl == 1 )
 	return findRev( *str.unicode(), index, cs );
 #endif
diff -uNr qt-x11-free-3.2.3/src/tools/qvaluelist.h qt-x11-free-3.2.3-new/src/tools/qvaluelist.h
--- qt-x11-free-3.2.3/src/tools/qvaluelist.h	Mon Nov 10 05:21:38 2003
+++ qt-x11-free-3.2.3-new/src/tools/qvaluelist.h	Tue Feb  3 16:38:28 2004
@@ -636,13 +636,11 @@
     l.clear();
     Q_UINT32 c;
     s >> c;
-    for( Q_UINT32 i = 0; i < c; ++i )
+    for( Q_UINT32 i = 0; i < c && !s.atEnd(); ++i )
     {
 	T t;
 	s >> t;
 	l.append( t );
-	if ( s.atEnd() )
-	    break;
     }
     return s;
 }
diff -uNr qt-x11-free-3.2.3/src/widgets/qlistbox.cpp qt-x11-free-3.2.3-new/src/widgets/qlistbox.cpp
--- qt-x11-free-3.2.3/src/widgets/qlistbox.cpp	Mon Nov 10 05:22:30 2003
+++ qt-x11-free-3.2.3-new/src/widgets/qlistbox.cpp	Tue Feb  3 16:37:02 2004
@@ -4547,7 +4547,7 @@
     } else if ( d->selectionMode == Extended ) {
 	if ( shift ) {
 	    selectRange( d->selectAnchor ? d->selectAnchor : old,
-			 d->current, FALSE, TRUE, d->selectAnchor ? TRUE : FALSE );
+			 d->current, FALSE, TRUE, d->selectAnchor && !control ? TRUE : FALSE );
 	} else if ( !control ) {
 	    bool block = signalsBlocked();
 	    blockSignals( TRUE );
diff -uNr qt-x11-free-3.2.3/src/widgets/qlistview.cpp qt-x11-free-3.2.3-new/src/widgets/qlistview.cpp
--- qt-x11-free-3.2.3/src/widgets/qlistview.cpp	Mon Nov 10 05:22:33 2003
+++ qt-x11-free-3.2.3-new/src/widgets/qlistview.cpp	Tue Feb  3 16:37:02 2004
@@ -2012,7 +2012,7 @@
 	    ci->truncated = FALSE;
 	    // if we have to do the ellipsis thingy calc the truncated text
 	    int pw = pixmap( column ) ? pixmap( column )->width() + lv->itemMargin() : lv->itemMargin();
-	    if ( !mlenabled && fm.width( t ) + pw > width ) {
+	    if ( !mlenabled && this->width( fm, lv, column ) > width ) {
 		// take care of arabic shaping in width calculation (lars)
 		ci->truncated = TRUE;
 		ci->tmpText = "...";
@@ -2024,7 +2024,7 @@
 		if ( ci->tmpText.isEmpty() )
 		    ci->tmpText = t.left( 1 );
 		ci->tmpText += "...";
-	    } else if ( mlenabled && fm.width( t ) + pw > width ) {
+	    } else if ( mlenabled && this->width( fm, lv, column ) > width ) {
 #ifndef QT_NO_STRINGLIST
 		QStringList list = QStringList::split( QChar('\n'), t, TRUE );
 		for ( QStringList::Iterator it = list.begin(); it != list.end(); ++it ) {
@@ -2849,7 +2849,7 @@
 	int cs;
 
 	// need to paint current?
-	if ( ih > 0 && current->y < cy+ch && current->y+ih >= cy ) {
+	if ( ih > 0 && current->y < cy+ch && current->y+ih > cy ) {
 	    if ( fx < 0 ) {
 		// find first interesting column, once
 		x = 0;
@@ -4974,10 +4974,10 @@
 		QString keyItemKey;
 		QString prefix;
 		while( keyItem ) {
-		    // Look for text in column 0, then left-to-right
-		    keyItemKey = keyItem->text(0);
-		    for (int col = 0; col < d->h->count() && !keyItemKey; col++ )
-			keyItemKey = keyItem->text( d->h->mapToLogical(col) );
+		    // Look first in the sort column, then the leftmost column, then left to right
+		    keyItemKey = keyItem->text( d->sortcolumn );
+		    for ( int col = 0; col < d->h->count() && !keyItemKey; col++ )
+			keyItemKey = keyItem->text( d->h->mapToSection(col) );
 		    if ( !keyItemKey.isEmpty() ) {
 			prefix = keyItemKey;
 			prefix.truncate( input.length() );
@@ -7772,7 +7772,7 @@
     } else if ( d->selectionMode == Extended ) {
 	if ( shift ) {
 	    selectRange( d->selectAnchor ? d->selectAnchor : old,
-			 d->focusItem, FALSE, TRUE, d->selectAnchor ? TRUE : FALSE );
+			 d->focusItem, FALSE, TRUE, d->selectAnchor && !control ? TRUE : FALSE );
 	} else if ( !control ) {
 	    bool block = signalsBlocked();
 	    blockSignals( TRUE );
@@ -8049,15 +8049,14 @@
 	w += d->h->iconSet( col )->pixmap().width();
     w = QMAX( w, 20 );
     QFontMetrics fm( fontMetrics() );
-    QListViewItemIterator it( this );
+    QListViewItem* item = firstChild();
     int rootDepth = rootIsDecorated() ? treeStepSize() : 0;
-    while ( it.current() ) {
-	QListViewItem *item = it.current();
-	++it;
+    while ( item ) {
 	int iw = item->width( fm, this, col );
 	if ( 0 == col )
 	    iw += itemMargin() + rootDepth + item->depth()*treeStepSize() - 1;
 	w = QMAX( w, iw );
+	item = item->itemBelow();
     }
     w = QMAX( w, QApplication::globalStrut().width() );
 
diff -uNr qt-x11-free-3.2.3/src/widgets/qmenubar.cpp qt-x11-free-3.2.3-new/src/widgets/qmenubar.cpp
--- qt-x11-free-3.2.3/src/widgets/qmenubar.cpp	Mon Nov 10 05:22:31 2003
+++ qt-x11-free-3.2.3-new/src/widgets/qmenubar.cpp	Tue Feb  3 16:37:02 2004
@@ -1049,12 +1049,18 @@
   it is a separator item.
 */
 
-int QMenuBar::itemAtPos( const QPoint &pos )
+int QMenuBar::itemAtPos( const QPoint &pos_ )
 {
     calculateRects();
     if ( !irects )
 	return -1;
     int i = 0;
+    QPoint pos = pos_;
+    // Fitts' Law for edges - compensate for the extra margin
+    // added in calculateRects()
+    const int margin = 2;
+    pos.setX( QMAX( margin, QMIN( width() - margin, pos.x())));
+    pos.setY( QMAX( margin, QMIN( height() - margin, pos.y())));
     while ( i < (int)mitems->count() ) {
 	if ( !irects[i].isEmpty() && irects[i].contains( pos ) ) {
 	    QMenuItem *mi = mitems->at(i);
diff -uNr qt-x11-free-3.2.3/src/widgets/qprogressbar.cpp qt-x11-free-3.2.3-new/src/widgets/qprogressbar.cpp
--- qt-x11-free-3.2.3/src/widgets/qprogressbar.cpp	Mon Nov 10 05:22:31 2003
+++ qt-x11-free-3.2.3-new/src/widgets/qprogressbar.cpp	Tue Feb  3 16:38:34 2004
@@ -47,6 +47,14 @@
 #endif
 #include <limits.h>
 
+class QProgressBarPrivate
+{
+    public:
+	QProgressBarPrivate() : last_painted_progress( 0 ) { }
+
+    int last_painted_progress;
+};
+
 /*!
     \class QProgressBar qprogressbar.h
     \brief The QProgressBar widget provides a horizontal progress bar.
@@ -99,7 +107,7 @@
       center_indicator( TRUE ),
       auto_indicator( TRUE ),
       percentage_visible( TRUE ),
-      d( 0 )
+      d( new QProgressBarPrivate )
 {
     setSizePolicy( QSizePolicy( QSizePolicy::Expanding, QSizePolicy::Fixed ) );
     initFrame();
@@ -130,12 +138,20 @@
       center_indicator( TRUE ),
       auto_indicator( TRUE ),
       percentage_visible( TRUE ),
-      d( 0 )
+      d( new QProgressBarPrivate )
 {
     setSizePolicy( QSizePolicy( QSizePolicy::Expanding, QSizePolicy::Fixed ) );
     initFrame();
 }
 
+/*!
+    Destroys the object and frees any allocated ressources.
+*/
+
+QProgressBar::~QProgressBar()
+{
+    delete d;
+}
 
 /*!
     Reset the progress bar. The progress bar "rewinds" and shows no
@@ -188,11 +204,16 @@
 	 progress < 0 || ( ( progress > total_steps ) && total_steps ) )
 	return;
 
+    const bool needRepaint = isVisible() && requireRepaint( progress );
+
     progress_val = progress;
 
     setIndicator( progress_str, progress_val, total_steps );
 
-    repaint( FALSE );
+    if ( needRepaint ) {
+	repaint( FALSE );
+	d->last_painted_progress = progress;
+    }
 
 #if defined(QT_ACCESSIBILITY_SUPPORT)
     QAccessible::updateAccessibility( this, 0, QAccessible::ValueChanged );
@@ -318,6 +339,31 @@
     QFrame::styleChange( old );
 }
 
+/*!
+    This method returns whether changing the progress to the \a newValue
+    would require a repaint of the progress bar. This allows efficient
+    repainting.
+*/
+bool QProgressBar::requireRepaint( int newProgress ) const
+{
+    if ( newProgress == progress_val ||
+	 newProgress == d->last_painted_progress ) {
+	return false;
+    }
+
+    const int width = contentsRect().width();
+    if ( width == 0 ) {
+	return false;
+    }
+
+    float progressPerPixel = 1.0;
+    if ( total_steps > width ) {
+	progressPerPixel = float( total_steps ) / float( width );
+    }
+
+    const int delta = d->last_painted_progress - newProgress;
+    return QABS( delta ) >= progressPerPixel;
+}
 
 /*!
     This method is called to generate the text displayed in the center
diff -uNr qt-x11-free-3.2.3/src/widgets/qprogressbar.h qt-x11-free-3.2.3-new/src/widgets/qprogressbar.h
--- qt-x11-free-3.2.3/src/widgets/qprogressbar.h	Mon Nov 10 05:22:32 2003
+++ qt-x11-free-3.2.3-new/src/widgets/qprogressbar.h	Tue Feb  3 16:38:34 2004
@@ -61,6 +61,7 @@
 public:
     QProgressBar( QWidget* parent=0, const char* name=0, WFlags f=0 );
     QProgressBar( int totalSteps, QWidget* parent=0, const char* name=0, WFlags f=0 );
+    virtual ~QProgressBar();
 
     int		totalSteps() const;
     int		progress()   const;
@@ -91,6 +92,7 @@
     virtual bool setIndicator( QString & progress_str, int progress,
 			       int totalSteps );
     void styleChange( QStyle& );
+    bool	requireRepaint( int newProgress ) const;
 
 private:
     int		total_steps;
diff -uNr qt-x11-free-3.2.3/src/widgets/qtabbar.cpp qt-x11-free-3.2.3-new/src/widgets/qtabbar.cpp
--- qt-x11-free-3.2.3/src/widgets/qtabbar.cpp	Mon Nov 10 05:22:30 2003
+++ qt-x11-free-3.2.3-new/src/widgets/qtabbar.cpp	Tue Feb  3 16:37:02 2004
@@ -1290,7 +1290,7 @@
 	    tb->d->a->insertItem( p, id );
 #endif
 	tb->layoutTabs();
-	tb->repaint();
+	tb->repaint( FALSE );
 
 #if defined(QT_ACCESSIBILITY_SUPPORT)
 	QAccessible::updateAccessibility( tb, tb->indexOf(id)+1, QAccessible::NameChanged );
diff -uNr qt-x11-free-3.2.3/src/widgets/qtooltip.cpp qt-x11-free-3.2.3-new/src/widgets/qtooltip.cpp
--- qt-x11-free-3.2.3/src/widgets/qtooltip.cpp	Mon Nov 10 05:22:33 2003
+++ qt-x11-free-3.2.3-new/src/widgets/qtooltip.cpp	Tue Feb  3 16:37:02 2004
@@ -102,7 +102,7 @@
 		 QToolTipGroup *, const QString& , QToolTip *, bool );
     void    add( QWidget *, const QRect &, const QString& ,
 		 QToolTipGroup *, const QString& , QToolTip *, bool );
-    void    remove( QWidget *, const QRect & );
+    void    remove( QWidget *, const QRect &, bool delayhide = FALSE );
     void    remove( QWidget * );
 
     void    removeFromGroup( QToolTipGroup * );
@@ -201,6 +201,8 @@
 		       QToolTipGroup *g, const QString& gs,
 		       QToolTip *tt, bool a )
 {
+    remove( w, r, TRUE );
+
     QTipManager::Tip *h = (*tips)[ w ];
     QTipManager::Tip *t = new QTipManager::Tip;
     t->next = h;
@@ -214,9 +216,10 @@
 
     if ( h ) {
 	tips->take( w );
-	if (h->autoDelete) {
+
+       if ( h != currentTip && h->autoDelete ) {
 	    t->next = h->next;
-	    delete(h);
+	    delete h;
 	}
     } else
 	connect( w, SIGNAL(destroyed()), this, SLOT(clientWidgetDestroyed()) );
@@ -250,25 +253,29 @@
 }
 
 
-void QTipManager::remove( QWidget *w, const QRect & r )
+void QTipManager::remove( QWidget *w, const QRect & r, bool delayhide )
 {
     QTipManager::Tip *t = (*tips)[ w ];
     if ( t == 0 )
 	return;
 
-    if ( t == currentTip )
-	hideTip();
+    if ( t == currentTip ) {
+        if ( delayhide )
+            currentTip->autoDelete = true;
+        else
+	    hideTip();
+    }
 
     if ( t == previousTip )
 	previousTip = 0;
 
-    if ( t->rect == r ) {
+    if ( ( currentTip != t || !delayhide ) && t->rect == r ) {
 	tips->take( w );
 	if ( t->next )
 	    tips->insert( w, t->next );
 	delete t;
     } else {
-	while( t->next && t->next->rect != r )
+	while(  t->next && t->next->rect != r && ( currentTip != t->next || !delayhide ))
 	    t = t->next;
 	if ( t->next ) {
 	    QTipManager::Tip *d = t->next;
diff -uNr qt-x11-free-3.2.3/tools/assistant/assistant.pro qt-x11-free-3.2.3-new/tools/assistant/assistant.pro
--- qt-x11-free-3.2.3/tools/assistant/assistant.pro	Fri Oct  3 03:46:02 2003
+++ qt-x11-free-3.2.3-new/tools/assistant/assistant.pro	Tue Feb  3 16:37:02 2004
@@ -27,6 +27,8 @@
 win32:RC_FILE = assistant.rc
 mac:RC_FILE = assistant.icns
 
+QMAKE_CFLAGS += -mdynamic-no-pic
+QMAKE_CXXFLAGS += -mdynamic-no-pic
 
 target.path = $$bins.path
 INSTALLS += target
diff -uNr qt-x11-free-3.2.3/tools/designer/app/app.pro qt-x11-free-3.2.3-new/tools/designer/app/app.pro
--- qt-x11-free-3.2.3/tools/designer/app/app.pro	Fri Oct  3 03:46:16 2003
+++ qt-x11-free-3.2.3-new/tools/designer/app/app.pro	Tue Feb  3 16:37:02 2004
@@ -14,6 +14,8 @@
    staticlib:CONFIG -= global_init_link_order #yuck
 }
 
+QMAKE_CFLAGS += -mdynamic-no-pic
+QMAKE_CXXFLAGS += -mdynamic-no-pic
 
 target.path=$$bins.path
 INSTALLS        += target
diff -uNr qt-x11-free-3.2.3/tools/designer/designer/designer.pro qt-x11-free-3.2.3-new/tools/designer/designer/designer.pro
--- qt-x11-free-3.2.3/tools/designer/designer/designer.pro	Mon Aug 18 05:43:30 2003
+++ qt-x11-free-3.2.3-new/tools/designer/designer/designer.pro	Tue Feb  3 16:37:02 2004
@@ -1,5 +1,5 @@
 TEMPLATE	= lib
-CONFIG		+= qt warn_on staticlib qmake_cache
+CONFIG		+= qt warn_on qmake_cache
 CONFIG 		-= dll
 !force_static:!win32:contains(QT_PRODUCT,qt-internal) {
    CONFIG          -= staticlib
diff -uNr qt-x11-free-3.2.3/tools/designer/designer/hierarchyview.cpp qt-x11-free-3.2.3-new/tools/designer/designer/hierarchyview.cpp
--- qt-x11-free-3.2.3/tools/designer/designer/hierarchyview.cpp	Thu Jul 17 05:06:29 2003
+++ qt-x11-free-3.2.3-new/tools/designer/designer/hierarchyview.cpp	Tue Feb  3 16:37:02 2004
@@ -605,6 +605,7 @@
 		    formWindow->mainWindow()->setupTabWidgetHierarchyMenu(
 				  this, SLOT( addTabPage() ),
 				  SLOT( removeTabPage() ) );
+	    tabWidgetMenu->setItemEnabled(MainWindow::POPUP_REMOVE_PAGE_ID, ((QDesignerTabWidget*)w )->count() > 1);
 	    tabWidgetMenu->popup( p );
 	}
     }
diff -uNr qt-x11-free-3.2.3/tools/designer/designer/mainwindow.cpp qt-x11-free-3.2.3-new/tools/designer/designer/mainwindow.cpp
--- qt-x11-free-3.2.3/tools/designer/designer/mainwindow.cpp	Mon Aug 18 07:48:37 2003
+++ qt-x11-free-3.2.3-new/tools/designer/designer/mainwindow.cpp	Tue Feb  3 16:37:02 2004
@@ -2417,8 +2417,8 @@
 {
     QPopupMenu *menu = new QPopupMenu( parent );
 
-    menu->insertItem( tr( "Add Page" ), parent, addSlot );
-    menu->insertItem( tr( "Delete Page" ), parent, removeSlot );
+    menu->insertItem( tr( "Add Page" ), parent, addSlot, 0, POPUP_REMOVE_PAGE_ID+1 );
+    menu->insertItem( tr( "Delete Page" ), parent, removeSlot, 0, POPUP_REMOVE_PAGE_ID );
     menu->insertSeparator();
     actionEditCut->addTo( menu );
     actionEditCopy->addTo( menu );
diff -uNr qt-x11-free-3.2.3/tools/designer/designer/mainwindow.h qt-x11-free-3.2.3-new/tools/designer/designer/mainwindow.h
--- qt-x11-free-3.2.3/tools/designer/designer/mainwindow.h	Tue May 13 03:08:52 2003
+++ qt-x11-free-3.2.3-new/tools/designer/designer/mainwindow.h	Tue Feb  3 16:37:02 2004
@@ -107,6 +107,7 @@
 
     QPopupMenu *setupNormalHierarchyMenu( QWidget *parent );
     QPopupMenu *setupTabWidgetHierarchyMenu( QWidget *parent, const char *addSlot, const char *removeSlot );
+    static const int POPUP_REMOVE_PAGE_ID = 1;
 
     FormWindow *openFormWindow( const QString &fn, bool validFileName = TRUE, FormFile *ff = 0 );
     bool isCustomWidgetUsed( MetaDataBase::CustomWidget *w );
diff -uNr qt-x11-free-3.2.3/tools/designer/editor/editor.pro qt-x11-free-3.2.3-new/tools/designer/editor/editor.pro
--- qt-x11-free-3.2.3/tools/designer/editor/editor.pro	Tue May 13 03:08:53 2003
+++ qt-x11-free-3.2.3-new/tools/designer/editor/editor.pro	Tue Feb  3 16:37:02 2004
@@ -1,5 +1,5 @@
 TEMPLATE	= lib
-CONFIG		+= qt warn_on staticlib
+CONFIG		+= qt warn_on
 CONFIG		-= dll
 HEADERS		= editor.h  \
 		  parenmatcher.h  \
diff -uNr qt-x11-free-3.2.3/tools/designer/uic/main.cpp qt-x11-free-3.2.3-new/tools/designer/uic/main.cpp
--- qt-x11-free-3.2.3/tools/designer/uic/main.cpp	Mon Nov 10 05:23:25 2003
+++ qt-x11-free-3.2.3-new/tools/designer/uic/main.cpp	Tue Feb  3 16:37:02 2004
@@ -146,7 +146,7 @@
 		if ( !dbpaths )
 		    dbpaths = new QStringList();
 		QString fn = QFile::decodeName( argv[++n] );
-		dbpaths->append( fn );
+		dbpaths->prepend( fn );
 		QApplication::addLibraryPath( fn );
 	    } else if ( opt == "version" ) {
 		fprintf( stderr,
diff -uNr qt-x11-free-3.2.3/tools/designer/uic/uic.pro qt-x11-free-3.2.3-new/tools/designer/uic/uic.pro
--- qt-x11-free-3.2.3/tools/designer/uic/uic.pro	Tue May 13 03:08:54 2003
+++ qt-x11-free-3.2.3-new/tools/designer/uic/uic.pro	Tue Feb  3 16:37:02 2004
@@ -29,6 +29,9 @@
 target.path=$$bins.path
 INSTALLS        += target
 
+QMAKE_CFLAGS += -mdynamic-no-pic
+QMAKE_CXXFLAGS += -mdynamic-no-pic
+
 *-mwerks {
    TEMPLATE = lib
    TARGET = McUic
diff -uNr qt-x11-free-3.2.3/tools/linguist/linguist/linguist.pro qt-x11-free-3.2.3-new/tools/linguist/linguist/linguist.pro
--- qt-x11-free-3.2.3/tools/linguist/linguist/linguist.pro	Wed Jun  4 10:56:17 2003
+++ qt-x11-free-3.2.3-new/tools/linguist/linguist/linguist.pro	Tue Feb  3 16:37:02 2004
@@ -105,4 +105,7 @@
 CONFIG	+= qt warn_on
 INCLUDEPATH	+= ../shared
 
+QMAKE_CFLAGS += -mdynamic-no-pic
+QMAKE_CXXFLAGS += -mdynamic-no-pic
+
 LANGUAGE	= C++
diff -uNr qt-x11-free-3.2.3/tools/linguist/lrelease/lrelease.pro qt-x11-free-3.2.3-new/tools/linguist/lrelease/lrelease.pro
--- qt-x11-free-3.2.3/tools/linguist/lrelease/lrelease.pro	Tue May 13 03:08:55 2003
+++ qt-x11-free-3.2.3-new/tools/linguist/lrelease/lrelease.pro	Tue Feb  3 16:37:02 2004
@@ -13,5 +13,8 @@
 INCLUDEPATH	+= ../shared
 DESTDIR		= ../../../bin
 
+QMAKE_CFLAGS += -mdynamic-no-pic
+QMAKE_CXXFLAGS += -mdynamic-no-pic
+
 target.path=$$bins.path
 INSTALLS	+= target
diff -uNr qt-x11-free-3.2.3/tools/linguist/lupdate/lupdate.pro qt-x11-free-3.2.3-new/tools/linguist/lupdate/lupdate.pro
--- qt-x11-free-3.2.3/tools/linguist/lupdate/lupdate.pro	Tue May 13 03:08:55 2003
+++ qt-x11-free-3.2.3-new/tools/linguist/lupdate/lupdate.pro	Tue Feb  3 16:37:02 2004
@@ -17,5 +17,8 @@
 INCLUDEPATH	+= ../shared
 DESTDIR		= ../../../bin
 
+QMAKE_CFLAGS += -mdynamic-no-pic
+QMAKE_CXXFLAGS += -mdynamic-no-pic
+
 target.path=$$bins.path
 INSTALLS	+= target
diff -uNr qt-x11-free-3.2.3/tools/linguist/qm2ts/qm2ts.pro qt-x11-free-3.2.3-new/tools/linguist/qm2ts/qm2ts.pro
--- qt-x11-free-3.2.3/tools/linguist/qm2ts/qm2ts.pro	Tue May 13 03:08:55 2003
+++ qt-x11-free-3.2.3-new/tools/linguist/qm2ts/qm2ts.pro	Tue Feb  3 16:37:02 2004
@@ -11,5 +11,8 @@
 INCLUDEPATH	+= ../shared
 DESTDIR		= ../../../bin
 
+QMAKE_CFLAGS += -mdynamic-no-pic
+QMAKE_CXXFLAGS += -mdynamic-no-pic
+
 target.path=$$bins.path
 INSTALLS	+= target
diff -uNr qt-x11-free-3.2.3/tools/qtconfig/qtconfig.pro qt-x11-free-3.2.3-new/tools/qtconfig/qtconfig.pro
--- qt-x11-free-3.2.3/tools/qtconfig/qtconfig.pro	Tue May 13 03:08:55 2003
+++ qt-x11-free-3.2.3-new/tools/qtconfig/qtconfig.pro	Tue Feb  3 16:37:02 2004
@@ -9,6 +9,9 @@
 target.path=$$bins.path
 INSTALLS	+= target
 
+QMAKE_CFLAGS += -mdynamic-no-pic
+QMAKE_CXXFLAGS += -mdynamic-no-pic
+
 FORMS	= mainwindowbase.ui paletteeditoradvancedbase.ui previewwidgetbase.ui 
 IMAGES	= images/appicon.png
 TEMPLATE	=app
