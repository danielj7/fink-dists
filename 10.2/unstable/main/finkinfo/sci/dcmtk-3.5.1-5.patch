diff -ru dcmtk/dcmdata/include/dccodec.h dcmtk-patched/dcmdata/include/dccodec.h
--- dcmtk/dcmdata/include/dccodec.h	Mon Nov 12 17:29:51 2001
+++ dcmtk-patched/dcmdata/include/dccodec.h	Wed Feb 27 15:23:26 2002
@@ -329,8 +329,10 @@
   /// singleton list of registered codecs
   static OFList<DcmCodecList *> registeredCodecs;
   
+#ifdef _REENTRANT
   /// read/write lock guarding access to singleton list
   static OFReadWriteLock codecLock;
+#endif
 
   // dummy friend declaration to prevent gcc from complaining
   // that this class only defines private constructors and has no friends.
diff -ru dcmtk/dcmdata/include/dcdict.h dcmtk-patched/dcmdata/include/dcdict.h
--- dcmtk/dcmdata/include/dcdict.h	Fri Jun  1 17:48:38 2001
+++ dcmtk-patched/dcmdata/include/dcdict.h	Wed Feb 27 15:23:16 2002
@@ -220,9 +220,11 @@
    */
   DcmDataDictionary dataDict;
 
+#ifdef _REENTRANT
   /** the read/write lock used to protect access from multiple threads
    */
   OFReadWriteLock dataDictLock;
+#endif
 };
 
 
diff -ru dcmtk/dcmdata/libsrc/dccodec.cc dcmtk-patched/dcmdata/libsrc/dccodec.cc
--- dcmtk/dcmdata/libsrc/dccodec.cc	Thu Nov  8 17:19:42 2001
+++ dcmtk-patched/dcmdata/libsrc/dccodec.cc	Wed Feb 27 15:23:26 2002
@@ -38,7 +38,11 @@
 
 // static member variables
 OFList<DcmCodecList *> DcmCodecList::registeredCodecs;
+
+#ifdef _REENTRANT
 OFReadWriteLock DcmCodecList::codecLock;
+#endif
+
 
 DcmCodecList::DcmCodecList(
     const DcmCodec *aCodec,  
@@ -60,12 +64,16 @@
     const DcmCodecParameter *aCodecParameter)
 {
   if ((aCodec == NULL)||(aCodecParameter == NULL)) return EC_IllegalParameter;
+#ifdef _REENTRANT
   if (! codecLock.initialized()) return EC_IllegalCall; // should never happen
+#endif
 
   // acquire write lock on codec list.  Will block if some codec is currently active.
   OFCondition result = EC_Normal;
+#ifdef _REENTRANT
   if (0 == codecLock.wrlock())
   {
+#endif
     DcmCodecList *listEntry = new DcmCodecList(aCodec, aDefaultRepParam, aCodecParameter);
     if (listEntry)
     {
@@ -83,20 +91,26 @@
       }
       if (result.good()) registeredCodecs.push_back(listEntry); else delete listEntry;
     } else result = EC_MemoryExhausted;
+#ifdef _REENTRANT
     codecLock.unlock();
   } else result = EC_IllegalCall;
+#endif
   return result;
 }
 
 OFCondition DcmCodecList::deregisterCodec(const DcmCodec *aCodec)
 {
   if (aCodec == NULL) return EC_IllegalParameter;
+#ifdef _REENTRANT
   if (! codecLock.initialized()) return EC_IllegalCall; // should never happen
+#endif
   // acquire write lock on codec list.  Will block if some codec is currently active.
   OFCondition result = EC_Normal;
 
+#ifdef _REENTRANT
   if (0 == codecLock.wrlock())
   {
+#endif
     OFListIterator(DcmCodecList *) first = registeredCodecs.begin();
     OFListIterator(DcmCodecList *) last = registeredCodecs.end();
     while (first != last)
@@ -107,8 +121,10 @@
       	first = registeredCodecs.erase(first);
       } else ++first;
     }
+#ifdef _REENTRANT
     codecLock.unlock();
   } else result = EC_IllegalCall;
+#endif
   return result;
 } 
 
@@ -117,12 +133,16 @@
     const DcmCodecParameter *aCodecParameter)
 {
   if ((aCodec == NULL)||(aCodecParameter == NULL)) return EC_IllegalParameter;
+#ifdef _REENTRANT
   if (! codecLock.initialized()) return EC_IllegalCall; // should never happen
+#endif
   // acquire write lock on codec list.  Will block if some codec is currently active.
   OFCondition result = EC_Normal;
 
+#ifdef _REENTRANT
   if (0 == codecLock.wrlock())
   {
+#endif
     OFListIterator(DcmCodecList *) first = registeredCodecs.begin();
     OFListIterator(DcmCodecList *) last = registeredCodecs.end();
     while (first != last)
@@ -130,8 +150,10 @@
       if ((*first)->codec == aCodec) (*first)->codecParameter = aCodecParameter;
       ++first;
     }
+#ifdef _REENTRANT
     codecLock.unlock();
   } else result = EC_IllegalCall;
+#endif
   return result;
 }
 
@@ -143,12 +165,16 @@
     DcmPolymorphOBOW& uncompressedPixelData,
     DcmStack & pixelStack)
 {
+#ifdef _REENTRANT
   if (! codecLock.initialized()) return EC_IllegalCall; // should never happen
+#endif
   OFCondition result = EC_CannotChangeRepresentation;
 
   // acquire write lock on codec list.  Will block if some write lock is currently active.
+#ifdef _REENTRANT
   if (0 == codecLock.rdlock())
   {
+#endif
     E_TransferSyntax fromXfer = fromType.getXfer();
     OFListIterator(DcmCodecList *) first = registeredCodecs.begin();
     OFListIterator(DcmCodecList *) last = registeredCodecs.end();
@@ -160,8 +186,10 @@
         first = last;
       } else ++first;
     }
+#ifdef _REENTRANT
     codecLock.unlock();
   } else result = EC_IllegalCall;
+#endif
   return result;
 }
 
@@ -175,12 +203,16 @@
     DcmStack & pixelStack)
 {
   toPixSeq = NULL;
+#ifdef _REENTRANT
   if (! codecLock.initialized()) return EC_IllegalCall; // should never happen
+#endif
   OFCondition result = EC_CannotChangeRepresentation;
 
   // acquire write lock on codec list.  Will block if some write lock is currently active.
+#ifdef _REENTRANT
   if (0 == codecLock.rdlock())
   {
+#endif
     OFListIterator(DcmCodecList *) first = registeredCodecs.begin();
     OFListIterator(DcmCodecList *) last = registeredCodecs.end();
     while (first != last)
@@ -193,8 +225,10 @@
         first = last;
       } else ++first;
     }
+#ifdef _REENTRANT
     codecLock.unlock();
   } else result = EC_IllegalCall;
+#endif
 
   return result;
 }
@@ -209,12 +243,16 @@
     DcmStack & pixelStack)
 {
   toPixSeq = NULL;
+#ifdef _REENTRANT
   if (! codecLock.initialized()) return EC_IllegalCall; // should never happen
+#endif
   OFCondition result = EC_CannotChangeRepresentation;
 
   // acquire write lock on codec list.  Will block if some write lock is currently active.
+#ifdef _REENTRANT
   if (0 == codecLock.rdlock())
   {
+#endif
     OFListIterator(DcmCodecList *) first = registeredCodecs.begin();
     OFListIterator(DcmCodecList *) last = registeredCodecs.end();
     while (first != last)
@@ -227,8 +265,10 @@
         first = last;
       } else ++first;
     }
+#ifdef _REENTRANT
     codecLock.unlock();
   } else result = EC_IllegalCall;
+#endif
 
   return result;
 }
@@ -237,12 +277,16 @@
     const E_TransferSyntax fromRepType,
     const E_TransferSyntax toRepType)
 {
+#ifdef _REENTRANT
   if (! codecLock.initialized()) return OFFalse; // should never happen
+#endif
   OFBool result = OFFalse;
 
   // acquire write lock on codec list.  Will block if some write lock is currently active.
+#ifdef _REENTRANT
   if (0 == codecLock.rdlock())
   {
+#endif
     OFListIterator(DcmCodecList *) first = registeredCodecs.begin();
     OFListIterator(DcmCodecList *) last = registeredCodecs.end();
     while (first != last)
@@ -253,8 +297,10 @@
         first = last;
       } else ++first;
     }
+#ifdef _REENTRANT
     codecLock.unlock();
   }
+#endif
 
   return result;
 }
diff -ru dcmtk/dcmdata/libsrc/dcdict.cc dcmtk-patched/dcmdata/libsrc/dcdict.cc
--- dcmtk/dcmdata/libsrc/dcdict.cc	Fri Jun  1 17:49:01 2001
+++ dcmtk-patched/dcmdata/libsrc/dcdict.cc	Wed Feb 27 15:23:16 2002
@@ -723,7 +723,9 @@
 
 GlobalDcmDataDictionary::GlobalDcmDataDictionary(OFBool loadBuiltin, OFBool loadExternal)
 : dataDict(loadBuiltin, loadExternal)
+#ifdef _REENTRANT
 , dataDictLock()
+#endif
 {
 }
 
diff -ru dcmtk/ofstd/include/ofthread.h dcmtk-patched/ofstd/include/ofthread.h
--- dcmtk/ofstd/include/ofthread.h	Fri Jun  1 17:51:36 2001
+++ dcmtk-patched/ofstd/include/ofthread.h	Wed Feb 27 15:22:58 2002
@@ -220,7 +220,7 @@
   /** checks whether creation of the object was successful.
    *  @return OFTrue if the object was successfully created, OFFalse otherwise.
    */
-  OFBool initialized();
+  OFBool initialized() const;
 
   /** sets the thread specific value for this object. No attempt is made to 
    *  automatically delete the object pointed to at the termination of the 
@@ -281,7 +281,7 @@
   /** checks whether creation of the object was successful.
    *  @return OFTrue if the object was successfully created, OFFalse otherwise.
    */
-  OFBool initialized();
+  OFBool initialized() const;
   
   /** blocks the calling thread until the semaphore counter is greater than zero
    *  and then atomically decreases the counter.
@@ -349,7 +349,7 @@
   /** checks whether creation of the object was successful.
    *  @return OFTrue if the object was successfully created, OFFalse otherwise.
    */
-  OFBool initialized();
+  OFBool initialized() const;
 
   /** locks the mutex object. If the mutex is already locked, the calling 
    *  thread blocks until the mutex is freed; If the current owner of a 
@@ -421,7 +421,7 @@
   /** checks whether creation of the object was successful.
    *  @return OFTrue if the object was successfully created, OFFalse otherwise.
    */
-  OFBool initialized();
+  OFBool initialized() const;
 
   /** gets a read lock. If the read/write lock is currently locked for 
    *  writing, the calling thread blocks until the write lock is freed. 
diff -ru dcmtk/ofstd/libsrc/ofthread.cc dcmtk-patched/ofstd/libsrc/ofthread.cc
--- dcmtk/ofstd/libsrc/ofthread.cc	Fri Jun  1 17:51:40 2001
+++ dcmtk-patched/ofstd/libsrc/ofthread.cc	Wed Feb 27 15:22:58 2002
@@ -282,9 +282,13 @@
 #endif
 }
 
-OFBool OFThreadSpecificData::initialized()
+OFBool OFThreadSpecificData::initialized() const
 {
+#ifdef WITH_THREADS
   if (theKey) return OFTrue; else return OFFalse;
+#else
+  return OFFalse; // thread specific data is not supported if we are working in a single-thread environment
+#endif
 }
 
 #if defined(WINDOWS_INTERFACE) || defined(POSIX_INTERFACE) || defined(SOLARIS_INTERFACE)
@@ -354,7 +358,7 @@
   const char *str = strerror(code);
   if (str) description = str; else description.clear();
 #else
-  description = "error: thread specitif data not implemented";
+  description = "error: thread specific data not implemented";
 #endif
   return;
 }
@@ -414,9 +418,13 @@
 #endif
 }
 
-OFBool OFSemaphore::initialized()
+OFBool OFSemaphore::initialized() const
 {
+#ifdef WITH_THREADS
   if (theSemaphore) return OFTrue; else return OFFalse;
+#else
+  return OFTrue;
+#endif
 }
 
 int OFSemaphore::wait()
@@ -548,9 +556,13 @@
 }
 
 
-OFBool OFMutex::initialized()
+OFBool OFMutex::initialized() const
 {
+#ifdef WITH_THREADS
   if (theMutex) return OFTrue; else return OFFalse;
+#else
+  return OFTrue;
+#endif
 }
 
   
@@ -694,9 +706,13 @@
 #endif
 }
 
-OFBool OFReadWriteLock::initialized()
+OFBool OFReadWriteLock::initialized() const
 {
+#ifdef WITH_THREADS
   if (theLock) return OFTrue; else return OFFalse;
+#else
+  return OFTrue;
+#endif
 }
 
 int OFReadWriteLock::rdlock()
