diff -ruN yorick-1.5/gist/xbasic.c yorick-1.5.14-2/gist/xbasic.c
--- yorick-1.5/gist/xbasic.c	Sat Sep 13 00:50:45 2003
+++ yorick-1.5.14-2/gist/xbasic.c	Sun May 30 15:06:01 2004
@@ -443,6 +443,8 @@
  *       -- thus, the p_disconnect must take place on the next
  *          event, which is during the GhBeforeWait hlevel.c function
  */
+/* hack to disconnect if last engine destroyed (see GhBeforeWait) */
+static void g_do_disconnect(void);
 extern void (*g_pending_task)(void);
 void (*g_pending_task)(void) = 0;
 
@@ -457,7 +459,7 @@
     p_destroy(w);
   }
   /* for program-driven Kill(), can take care of p_disconnect immediately */
-  if (g_pending_task) g_pending_task();
+  g_do_disconnect();
 }
 
 static int
@@ -1303,9 +1305,6 @@
 
   return s;
 }
-
-/* hack to disconnect if last engine destroyed (see GhBeforeWait) */
-static void g_do_disconnect(void);
 
 void
 g_disconnect(p_scr *s)
diff -ruN yorick-1.5/play/unix/uevent.c yorick-1.5.14-2/play/unix/uevent.c
--- yorick-1.5/play/unix/uevent.c	Mon Aug 27 20:19:02 2001
+++ yorick-1.5.14-2/play/unix/uevent.c	Sun May 30 15:02:30 2004
@@ -21,6 +21,7 @@
 
 #ifdef TEST_POLL
 #define p_realloc (void *)realloc
+#define p_malloc (void *)malloc
 #endif
 
 /* errno determines if a signal caused premature return from poll */
@@ -138,6 +139,8 @@
 
   /* refuse to wait forever with no event sources */
   if (!poll_nfds && timeout<0) return -3;
+  /* work around bug in MacOS 10.3 poll function */
+  if (!poll_fds) poll_fds = p_malloc(sizeof(struct pollfd));
 
   /* check for any events which arrived on previous poll before
    * calling poll again -- assures that first fd in poll_fds cannot
