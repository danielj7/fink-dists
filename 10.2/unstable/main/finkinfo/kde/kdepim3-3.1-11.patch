
--- calendarsystem/Makefile.am	29 Oct 2002 18:08:05 -0000	1.1.1.2
+++ calendarsystem/Makefile.am	29 Nov 2002 19:01:22 -0000	1.2
@@ -1,7 +1,7 @@
 INCLUDES = $(all_includes)
 
 lib_LTLIBRARIES = libkcalsystem.la
-libkcalsystem_la_LDFLAGS = $(all_libraries) -no-undefined -version-info 0:1:0 -module
+libkcalsystem_la_LDFLAGS = $(all_libraries) -no-undefined -version-info 0:1:0
 libkcalsystem_la_LIBADD  = $(LIB_QT) $(LIB_KDEUI)
 libkcalsystem_la_SOURCES = kcalendarsystem.cpp kcalendarsystemhijri.cpp hconv.c
 
--- kaddressbook/Makefile.am	29 Oct 2002 18:08:21 -0000	1.1.1.4
+++ kaddressbook/Makefile.am	29 Nov 2002 19:01:22 -0000	1.2
@@ -10,13 +10,28 @@
 bin_PROGRAMS = kaddressbook
 
 kaddressbook_LDFLAGS = $(all_libraries) $(KDE_RPATH)
-kaddressbook_LDADD   = libkaddressbookpart.la
+kaddressbook_LDADD   = libkaddressbookpart_shared.la
 kaddressbook_SOURCES = main.cpp
 
-kde_module_LTLIBRARIES = libkaddressbookpart.la
+lib_LTLIBRARIES = kaddressbook.la
+kde_module_LTLIBRARIES = libkaddressbookpart.la libkaddressbookpart_shared.la
 
-libkaddressbookpart_la_LDFLAGS = -module $(KDE_PLUGIN) $(all_libraries)
-libkaddressbookpart_la_LIBADD  = $(top_builddir)/libkdepim/libkdepim.la \
+kaddressbook_la_LDFLAGS = $(all_libraries) $(KDE_RPATH) -module -avoid-version
+kaddressbook_la_LIBADD  = libkaddressbookpart_shared.la
+kaddressbook_la_SOURCES = kaddressbook_la_main.cpp
+
+kaddressbook_la_main.cpp: main.cpp
+	cat main.cpp > kaddressbook_la_main.cpp
+
+libkaddressbookpart_la_LDFLAGS = -module $(KDE_PLUGIN) $(all_libraries) -avoid-version
+libkaddressbookpart_la_LIBADD  = libkaddressbookpart_shared.la
+libkaddressbookpart_la_SOURCES = libkaddressbookpart_la_dummy.cpp
+
+libkaddressbookpart_la_dummy.cpp:
+	echo > libkaddressbookpart_la_dummy.cpp
+
+libkaddressbookpart_shared_la_LDFLAGS = $(KDE_RPATH) $(all_libraries) -avoid-version
+libkaddressbookpart_shared_la_LIBADD  = $(top_builddir)/libkdepim/libkdepim.la \
 	./details/libdetails.la \
 	./features/libfeatures.la \
 	./printing/libprinter.la \
@@ -24,7 +39,7 @@
 	$(LIB_KPARTS) $(LIB_KFILE) \
 	-lkabc -lkdeprint
 
-libkaddressbookpart_la_SOURCES = \
+libkaddressbookpart_shared_la_SOURCES = \
  actionmanager.cpp addhostdialog.cpp addresseditwidget.cpp addresseeconfig.cpp \
  addresseeeditordialog.cpp addresseeeditorwidget.cpp addresseeutil.cpp \
  addviewdialog.cpp configureviewdialog.cpp configureviewfilterpage.cpp \
@@ -37,7 +52,7 @@
  phoneeditwidget.cpp prefsdialog.cpp selectfieldswidget.cpp \
  undo.cpp undocmds.cpp viewmanager.cpp viewwrapper.cpp
 
-kaddressbook_METASOURCES = AUTO
+METASOURCES = AUTO
 
 noinst_HEADERS = \
  actionmanager.h addhostdialog.h addresseditwidget.h addresseeconfig.h \
--- kalarmd/Makefile.am	12 Nov 2002 17:27:02 -0000	1.1.1.5
+++ kalarmd/Makefile.am	16 Jan 2003 17:38:12 -0000	1.5
@@ -3,7 +3,7 @@
 lib_LTLIBRARIES = libkalarmd.la
 
 libkalarmd_la_LDFLAGS = $(all_libraries) $(KDE_RPATH)
-libkalarmd_la_LIBADD  = $(LIB_KDECORE)
+libkalarmd_la_LIBADD  = $(LIB_KDECORE) $(LIB_QT) -lDCOP
 libkalarmd_la_SOURCES =  alarmdaemoniface.stub alarmguiiface.stub dummy.cpp
 
 DISTCLEANFILES = dummy.cpp
--- knotes/Makefile.am	29 Oct 2002 18:08:35 -0000	1.1.1.2
+++ knotes/Makefile.am	29 Nov 2002 19:01:22 -0000	1.2
@@ -9,7 +9,7 @@
 include_HEADERS = KNotesIface.h
 noinst_HEADERS  = knotesapp.h knote.h knoteedit.h knoteconfigdlg.h knotebutton.h
 knotes_SOURCES  = knotesapp.cpp knote.cpp knoteedit.cpp knoteconfigdlg.cpp main.cpp KNotesIface.skel
-knotes_LDADD    = $(LIB_KIO) -lkdeprint
+knotes_LDADD    = $(LIB_KIO) $(LIB_KDEPRINT)
 knotes_LDFLAGS  = $(all_libraries) $(KDE_RPATH)
 
 METASOURCES     = AUTO
--- korganizer/Makefile.am	29 Oct 2002 18:08:43 -0000	1.1.1.4
+++ korganizer/Makefile.am	11 Nov 2002 20:56:20 -0000	1.2
@@ -93,7 +93,7 @@
 
 kde_bin_SCRIPTS = ical2vcal korganizerIn
 
-kdelnkdir = $(kde_appsdir)/Applications
+kdelnkdir = $(kde_appsdir)/Utilities
 kdelnk_DATA = korganizer.desktop
 
 rcdir = $(kde_datadir)/korganizer
--- korganizer/knewstuff/Makefile.am	10 Jul 2002 05:20:46 -0000	1.1.1.1
+++ korganizer/knewstuff/Makefile.am	6 Oct 2002 16:12:37 -0000	1.2
@@ -5,7 +5,7 @@
 lib_LTLIBRARIES = libknewstuff.la
 
 libknewstuff_la_LDFLAGS = $(all_libraries) $(KDE_RPATH) -version-info 1:0
-libknewstuff_la_LIBADD  = $(LIB_KIO)
+libknewstuff_la_LIBADD  = $(LIB_KIO) $(LIB_KDECORE) $(LIB_KDEUI) $(LIB_QT)
 libknewstuff_la_SOURCES = engine.cpp entry.cpp downloaddialog.cpp \
   uploaddialog.cpp providerdialog.cpp provider.cpp knewstuff.cpp
 
--- korganizer/plugins/holidays/Makefile.am	27 Nov 2002 02:36:42 -0000	1.1.1.3
+++ korganizer/plugins/holidays/Makefile.am	1 Dec 2002 17:02:08 -0000	1.2
@@ -18,7 +18,8 @@
 servicedir  = $(kde_servicesdir)/korganizer
 service_DATA = holidays.desktop
 
-parser:
-	cd $(srcdir) && yacc -p kcal -d -o parseholiday.c parseholiday.y
+parseholiday.c: parseholiday.y
 	cd $(srcdir) && yacc -p kcal -d -o parseholiday.c parseholiday.y
+
+scanholiday.c: scanholiday.lex
 	cd $(srcdir) && lex -Pkcal -B -oscanholiday.c scanholiday.lex
--- korganizer/plugins/holidays/parseholiday.y	25 Jun 2002 03:18:22 -0000	1.1.1.1
+++ korganizer/plugins/holidays/parseholiday.y	6 Oct 2002 17:22:17 -0000	1.2
@@ -68,7 +68,7 @@
 /*** Variables and structures ***/
 static int	 m, d, y;
 int              kcallineno;	       	/* current line # being parsed */
-FILE            *kcalin;                  /* file currently being processed */
+extern FILE     *kcalin;                  /* file currently being processed */
 int	         yacc_small;		/* small string or on its own line? */
 int	         yacc_stringcolor;	/* color of holiday name text, 1..8 */
 char	        *yacc_string;		/* holiday name text */
--- korganizer/plugins/holidays/scanholiday.lex	25 Jun 2002 03:18:22 -0000	1.1.1.1
+++ korganizer/plugins/holidays/scanholiday.lex	1 Dec 2002 17:02:08 -0000	1.2
@@ -1,4 +1,5 @@
 %{
+#define kcalyacclval kcallval
 #include <string.h>
 #include "parseholiday.h"
 %}
--- kpilot/conduits/configure.in.in	3 Oct 2002 00:58:19 -0000	1.1.1.1
+++ kpilot/conduits/configure.in.in	6 Oct 2002 04:32:13 -0000	1.2
@@ -51,7 +51,7 @@
 dnl
 if  test "$HAVE_MAL" = "0" ; then
 	AC_MSG_CHECKING([for libmal.h alternate])
-	for i in /usr/local/include/mal  /usr/local/include /vol/kde/support/include /usr/include/mal ; do
+	for i in @PREFIX@/include/mal /usr/local/include/mal  /usr/local/include /vol/kde/support/include /usr/include/mal ; do
 		test -f $i/libmal.h && HAVE_MAL=1
 		test -f $i/libmal.h && MAL_INCLUDE="-I$i"
 	done
@@ -68,6 +68,8 @@
 if test "$HAVE_MAL" = "1" ; then
 	HAVE_MAL=0
 
+	CPPFLAGS="$mal_save_cflags $all_includes $MAL_INCLUDE"
+	LDFLAGS="$mal_save_ldflags $all_libraries -L/sw/lib"
 	AC_CHECK_LIB(mal,
 		Disconnect,
 		[MAL_LIB="-lmal"
--- kpilot/conduits/JPilotPluginProxy/configure.in.in	10 Jul 2002 05:21:36 -0000	1.1.1.1
+++ kpilot/conduits/JPilotPluginProxy/configure.in.in	19 Oct 2002 21:02:43 -0000	1.2
@@ -25,218 +25,91 @@
 HAVE_GDBM=0
 HAVE_JPILOT=0
 
-kpilot_save_cflags="$CPPFLAGS"
-kpilot_save_ldflags="$LDFLAGS"
-
-
-
-
 dnl
 dnl First check for GTK, then for gdk, then for glib, and finally for gdbm
 dnl
 
-
+dnl Check for pkg-config
+AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
 
 dnl ********************************************************************************
-dnl *                                       GLIB                                 
+dnl *                                       glib
 dnl ********************************************************************************
 
-CPPFLAGS="$CPPFLAGS $all_includes"
-LDFLAGS="$LDFLAGS $all_libraries"
-
-
-GLIB_LIB=""
-GLIB_INCLUDE=""
+GLIB_PACKAGES="glib"
+GLIB_VERSION="1.2.0"
+AC_MSG_CHECKING(for glib (at least $GLIB_VERSION))
 
-AC_CHECK_HEADER(glib.h,[HAVE_GLIB=1], )
-
-dnl Warn if no headers found. Maybe this should be collected at the end
-dnl of the build as well, like other this-won't-be-built messages?
-
-if  test "$HAVE_GLIB" = "0" ; then
-	AC_MSG_CHECKING([for glib.h alternate])
-	for i in /usr/local/include /usr/include/glib-2.0 /usr/include/glib-1.2 /vol/gnome/support/include /usr/include/glib  ; do
-		test -f $i/glib.h && HAVE_GLIB=1
-		test -f $i/glib.h && GLIB_INCLUDE="-I$i"
-	done
-
-
-	if test "$HAVE_GLIB" = "0" ; then
-		AC_MSG_WARN([JPilotPluginProxy: no glib headers found.])
-	else
-		AC_MSG_RESULT([found])
-	fi
+if test "x$PKG_CONFIG" != "xno"; then
+if $PKG_CONFIG --atleast-version $GLIB_VERSION $GLIB_PACKAGES >/dev/null 2>&1 ; then
+    GLIB_INCLUDE="`$PKG_CONFIG --cflags $GLIB_PACKAGES`"
+    GLIB_LIB="`$PKG_CONFIG --libs $GLIB_PACKAGES`"
+    HAVE_GLIB=1
+    AC_MSG_RESULT(yes)
 fi
-
-
-dnl Search the library
-
-CPPFLAGS="$kpilot_save_cflags  $all_includes $GLIB_INCLUDE"
-LDFLAGS="$kpilot_save_ldflags  $all_libraries"
-
-if test "$HAVE_GLIB" = "1" ; then
-	HAVE_GLIB=0
-	AC_CHECK_LIB(glib, g_free,
-			[GLIB_LIB="-lglib"
-			HAVE_GLIB=1],[],[])
-
-	for i in /usr/local/glib /usr/local/lib /usr/local/lib /vol/kde/support/lib ; do
-		if test "$HAVE_GLIB" = "0" ; then
-			CPPFLAGS="$kpilot_save_cflags  $all_includes $GLIB_INCLUDE"
-			LDFLAGS="$kpilot_save_ldflags  $all_libraries -L$i -R$i"
-
-			unset ac_cv_lib_glib_g_free
-			AC_CHECK_LIB(glib, g_free,
-				[GLIB_LIB="-L$i -R$i -lglib"
-				HAVE_GLIB=1],[],[])
-		fi
-	done
 fi
 
-if test "$HAVE_GLIB" = "0" ; then
-	AC_MSG_WARN([JPilotPluginProxy: glib library or header files not found])
-	DO_NOT_COMPILE="$DO_NOT_COMPILE kpilot/conduits/JPilotPluginProxy"
+if test -z "$GLIB_LIB"; then
+        AC_MSG_RESULT(not installed)
+    DO_NOT_COMPILE="$DO_NOT_COMPILE kpilot/conduits/JPilotPluginProxy"
 fi
 
 AC_SUBST(GLIB_LIB)
 AC_SUBST(GLIB_INCLUDE)
+AC_SUBST(HAVE_GLIB)
 
 
 dnl ********************************************************************************
-dnl *                                       GTK                                 
+dnl *                                       gtk+
 dnl ********************************************************************************
 
-CPPFLAGS="$CPPFLAGS $all_includes"
-LDFLAGS="$LDFLAGS $all_libraries"
-
-
-GTK_LIB=""
-GTK_INCLUDE=""
+GTK_PACKAGES="gtk+"
+GTK_VERSION="1.2.0"
+AC_MSG_CHECKING(for gtk+ (at least $GTK_VERSION))
 
-AC_CHECK_HEADER(gtk/gtk.h,[HAVE_GTK=1], )
-
-dnl Warn if no headers found. Maybe this should be collected at the end
-dnl of the build as well, like other this-won't-be-built messages?
-
-if  test "$HAVE_GTK" = "0" ; then
-	AC_MSG_CHECKING([for gtk.h alternate])
-	for i in /usr/local/include  /vol/gnome/support/include  ; do
-		test -f $i/gtk/gtk.h && HAVE_GTK=1
-		test -f $i/gtk/gtk.h && GTK_INCLUDE="-I$i"
-	done
-
-
-	if test "$HAVE_GTK" = "0" ; then
-		AC_MSG_WARN([JPilotPluginProxy: no gtk headers found.])
-	else
-		AC_MSG_RESULT([found])
-	fi
+if test "x$PKG_CONFIG" != "xno"; then
+if $PKG_CONFIG --atleast-version $GTK_VERSION $GTK_PACKAGES >/dev/null 2>&1 ; then
+    GTK_INCLUDE="`$PKG_CONFIG --cflags $GTK_PACKAGES`"
+    GTK_LIB="`$PKG_CONFIG --libs $GTK_PACKAGES`"
+    HAVE_GTK=1
+    AC_MSG_RESULT(yes)
 fi
-
-
-dnl Search the library
-
-CPPFLAGS="$kpilot_save_cflags  $all_includes $GTK_INCLUDE"
-LDFLAGS="$kpilot_save_ldflags  $all_libraries"
-
-if test "$HAVE_GTK" = "1" ; then
-	AC_CHECK_LIB(gtk, gtk_main,
-			[GLIB_LIB="-lgtk"
-			HAVE_GTK=1],[],[])
-
-	for i in /usr/local/glib /usr/local/lib /usr/lib /vol/kde/support/lib ; do
-		if test "$HAVE_GTK" = "0" ; then
-			CPPFLAGS="$kpilot_save_cflags  $all_includes $GTK_INCLUDE"
-			LDFLAGS="$kpilot_save_ldflags  $all_libraries -L$i -R$i"
-
-			unset ac_cv_lib_gtk_gtk_main
-			AC_CHECK_LIB(gtk, gtk_main,
-				[GTK_LIB="-L$i -R$i -lgtk"
-				HAVE_GTK=1],[],[])
-		fi
-	done
 fi
 
-if test "$HAVE_GTK" = "0" ; then
-	AC_MSG_WARN([JPilotPluginProxy: gtk library or header files not found])
-	DO_NOT_COMPILE="$DO_NOT_COMPILE kpilot/conduits/JPilotPluginProxy"
+if test -z "$GTK_LIB"; then
+        AC_MSG_RESULT(not installed)
+    DO_NOT_COMPILE="$DO_NOT_COMPILE kpilot/conduits/JPilotPluginProxy"
 fi
 
 AC_SUBST(GTK_LIB)
 AC_SUBST(GTK_INCLUDE)
+AC_SUBST(HAVE_GTK)
 
 
 dnl ********************************************************************************
-dnl *                                       GDK                                 
+dnl *                                       gdk+
 dnl ********************************************************************************
 
-CPPFLAGS="$CPPFLAGS $all_includes"
-LDFLAGS="$LDFLAGS $all_libraries"
-
-
-GTK_LIB=""
-GTK_INCLUDE=""
+GDK_PACKAGES="gdk"
+GDK_VERSION="0.12.0"
+AC_MSG_CHECKING(for gdk (at least $GDK_VERSION))
 
-AC_CHECK_HEADER(gtk/gtk.h,[HAVE_GTK=1], )
-
-dnl Warn if no headers found. Maybe this should be collected at the end
-dnl of the build as well, like other this-won't-be-built messages?
-
-if  test "$HAVE_GTK" = "0" ; then
-	AC_MSG_CHECKING([for gtk.h alternate])
-	for i in /usr/local/include  /vol/gnome/support/include  ; do
-		test -f $i/gtk/gtk.h && HAVE_GTK=1
-		test -f $i/gtk/gtk.h && GTK_INCLUDE="-I$i"
-	done
-
-
-	if test "$HAVE_GTK" = "0" ; then
-		AC_MSG_WARN([JPilotPluginProxy: no gtk headers found.])
-	else
-		AC_MSG_RESULT([found])
-	fi
+if test "x$PKG_CONFIG" != "xno"; then
+if $PKG_CONFIG --atleast-version $GDK_VERSION $GDK_PACKAGES >/dev/null 2>&1 ; then
+    GDK_INCLUDE="`$PKG_CONFIG --cflags $GDK_PACKAGES`"
+    GDK_LIB="`$PKG_CONFIG --libs $GDK_PACKAGES`"
+    HAVE_GDK=1
+    AC_MSG_RESULT(yes)
 fi
-
-
-dnl Search the library
-
-CPPFLAGS="$kpilot_save_cflags  $all_includes $GTK_INCLUDE"
-LDFLAGS="$kpilot_save_ldflags  $all_libraries"
-
-if test "$HAVE_GTK" = "1" ; then
-	AC_CHECK_LIB(gtk, gtk_main,
-			[GLIB_LIB="-lgtk"
-			HAVE_GTK=1],[],[])
-
-	for i in /usr/local/glib /usr/local/lib /usr/lib /vol/kde/support/lib ; do
-		if test "$HAVE_GTK" = "0" ; then
-			CPPFLAGS="$kpilot_save_cflags  $all_includes $GTK_INCLUDE"
-			LDFLAGS="$kpilot_save_ldflags  $all_libraries -L$i -R$i"
-
-			unset ac_cv_lib_gtk_gtk_main
-			AC_CHECK_LIB(gtk, gtk_main,
-				[GTK_LIB="-L$i -R$i -lgtk"
-				HAVE_GTK=1],[],[])
-		fi
-	done
 fi
 
-if test "$HAVE_GTK" = "0" ; then
-	AC_MSG_WARN([JPilotPluginProxy: gtk library or header files not found])
-	DO_NOT_COMPILE="$DO_NOT_COMPILE kpilot/conduits/JPilotPluginProxy"
+if test -z "$GDK_LIB"; then
+        AC_MSG_RESULT(not installed)
+    DO_NOT_COMPILE="$DO_NOT_COMPILE kpilot/conduits/JPilotPluginProxy"
 fi
 
-AC_SUBST(GTK_LIB)
-AC_SUBST(GTK_INCLUDE)
-
-
-
-
-
-
+AC_SUBST(GDK_LIB)
+AC_SUBST(GDK_INCLUDE)
+AC_SUBST(HAVE_GDK)
 
 
-CPPFLAGS="$kpilot_save_cflags"
-LDFLAGS="$kpilot_save_ldflags"
-unset kpilot_save_cflags
-unset kpilot_save_ldflags
--- kpilot/conduits/abbrowserconduit/Makefile.am	3 Oct 2002 00:58:19 -0000	1.1.1.4
+++ kpilot/conduits/abbrowserconduit/Makefile.am	31 Oct 2002 19:24:26 -0000	1.2
@@ -23,4 +23,4 @@
 	abbrowser-conduit.cc \
 	kaddressbookConduit.ui
 libaddressconduit_la_LDFLAGS = $(KDE_RPATH) -L../../lib 
-libaddressconduit_la_LIBADD = -lkpilot -lkabc
+libaddressconduit_la_LIBADD = -lkpilot -lkabc -lpisock $(LIB_KDECORE) $(LIB_QT) $(LIB_KDEUI)
--- kpilot/conduits/expense/Makefile.am	25 Jun 2002 03:18:22 -0000	1.1.1.1
+++ kpilot/conduits/expense/Makefile.am	16 Jan 2003 17:38:12 -0000	1.3
@@ -14,7 +14,7 @@
 libexpenseconduit_la_SOURCES = expenseConduit.ui setupDialog.cc \
 	expense.cc expense-factory.cc
 libexpenseconduit_la_LDFLAGS = $(KDE_RPATH) -L../../lib
-libexpenseconduit_la_LIBADD  =  -lkpilot
+libexpenseconduit_la_LIBADD  =  -lkpilot $(PISOCK_LIB) $(LIB_QT) $(LIB_KDECORE) $(LIB_KDEUI) $(LIB_KIO) -lDCOP
 
 # this option you can leave out. Just, if you use "make dist", you need it
 noinst_HEADERS = expense.h setupDialog.h 
--- kpilot/conduits/null/Makefile.am	25 Jun 2002 03:18:22 -0000	1.1.1.1
+++ kpilot/conduits/null/Makefile.am	6 Oct 2002 04:32:13 -0000	1.2
@@ -10,5 +10,5 @@
 
 libnullconduit_la_SOURCES = setup_base.ui null-conduit.cc null-factory.cc
 libnullconduit_la_LDFLAGS = $(KDE_RPATH) -L../../lib
-libnullconduit_la_LIBADD = -lkpilot
+libnullconduit_la_LIBADD = -lkpilot $(LIB_KDECORE) $(LIB_QT) $(LIB_KDEUI)
 
--- kpilot/conduits/popmail/Makefile.am	25 Jun 2002 03:18:22 -0000	1.1.1.1
+++ kpilot/conduits/popmail/Makefile.am	29 Nov 2002 19:01:22 -0000	1.3
@@ -17,7 +17,7 @@
 libpopmailconduit_la_SOURCES = popmail-factory.cc setupDialog.cc \
 	passworddialog.cc popmail-conduit.cc parsedate.c
 libpopmailconduit_la_LDFLAGS = $(KDE_RPATH) -L../../lib
-libpopmailconduit_la_LIBADD   =  -lkpilot
+libpopmailconduit_la_LIBADD   =  -lkpilot $(LIB_QT) $(LIB_KDECORE) $(LIB_KDEUI) $(PISOCK_LIB) $(LIB_KIO) -lDCOP
 
 # this option you can leave out. Just, if you use "make dist", you need it
 noinst_HEADERS = popmail-conduit.h passworddialog.h setupDialog.h
--- kpilot/conduits/popmail/popmail-conduit.cc	15 Jan 2003 05:29:37 -0000	1.1.1.5
+++ kpilot/conduits/popmail/popmail-conduit.cc	15 Jan 2003 05:43:24 -0000	1.3
@@ -41,6 +41,7 @@
 
 
 #include <sys/types.h>
+#include <sys/utsname.h>
 #include <sys/socket.h>
 #include <sys/utsname.h>
 #include <ctype.h>
--- kpilot/conduits/timeconduit/Makefile.am	14 Aug 2002 19:38:40 -0000	1.1.1.1
+++ kpilot/conduits/timeconduit/Makefile.am	6 Oct 2002 04:32:14 -0000	1.2
@@ -17,5 +17,5 @@
 	time-conduit.cc \
 	time-setup_dialog.ui
 libtimeconduit_la_LDFLAGS = $(KDE_RPATH) -L../../lib 
-libtimeconduit_la_LIBADD = -lkpilot 
- 
\ No newline at end of file
+libtimeconduit_la_LIBADD = -lkpilot $(LIB_KDECORE) $(LIB_QT) $(LIB_KDEUI)
+ 
--- kpilot/conduits/vcalconduit/Makefile.am	14 Aug 2002 19:38:44 -0000	1.1.1.3
+++ kpilot/conduits/vcalconduit/Makefile.am	6 Oct 2002 04:32:14 -0000	1.2
@@ -16,12 +16,12 @@
 libvcalconduit_la_SOURCES = korganizerConduit.ui vcal-factorybase.cc vcal-factory.cc  \
 	vcal-setup.cc vcal-conduitbase.cc vcal-conduit.cc
 libvcalconduit_la_LDFLAGS = $(KDE_RPATH) -L../../lib -L../../../libkcal
-libvcalconduit_la_LIBADD = -lkpilot -lkcal
+libvcalconduit_la_LIBADD = -lkpilot -lkcal $(LIB_KDECORE) $(LIB_QT) $(LIB_KIO) $(PISOCK_LIB) $(LIB_KDEUI)
 
 libtodoconduit_la_SOURCES = korganizertodoConduit.ui vcal-factorybase.cc todo-factory.cc  \
 	todo-setup.cc vcal-conduitbase.cc todo-conduit.cc
 libtodoconduit_la_LDFLAGS = $(KDE_RPATH) -L../../lib -L../../../libkcal
-libtodoconduit_la_LIBADD = -lkpilot -lkcal
+libtodoconduit_la_LIBADD = -lkpilot -lkcal $(LIB_KDECORE) $(LIB_QT) $(LIB_KIO) $(PISOCK_LIB) $(LIB_KDEUI)
 
 # You may want to enable debugging like this on systems with broken kdelibs
 # libtodoconduit_la_CFLAGS = -DDEBUG -DDEBUG_CERR
--- kpilot/kpilot/Makefile-standalone	25 Jun 2002 03:18:23 -0000	1.1.1.1
+++ kpilot/kpilot/Makefile-standalone	28 Nov 2002 00:02:51 -0000	1.2
@@ -152,7 +152,7 @@
 
 
 %.kidl : %.h
-	$(DCOPIDL) $< > $@ || ( rm -f $@ ; /bin/false )
+	$(DCOPIDL) $< > $@ || ( rm -f $@ ; false )
 
 %_stub.cc : %.kidl
 	$(DCOPIDL2CPP) --c++-suffix cc --no-skel $<
--- kpilot/lib/Makefile.am	3 Oct 2002 00:58:31 -0000	1.1.1.4
+++ kpilot/lib/Makefile.am	29 Nov 2002 19:01:22 -0000	1.3
@@ -23,8 +23,8 @@
 	pilotMemo.cc pilotAddress.cc \
 	pilotDateEntry.cc pilotTodoEntry.cc
 
-libkpilot_la_LDFLAGS = $(all_libraries) $(KDE_EXTRA_RPATH) $(KDE_RPATH)
-libkpilot_la_LIBADD = $(PISOCK_LIB)
+libkpilot_la_LDFLAGS = $(all_libraries) $(KDE_EXTRA_RPATH) $(KDE_RPATH) $(QT_LDFLAGS)
+libkpilot_la_LIBADD = $(PISOCK_LIB) $(LIB_QT) $(LIB_KDECORE) $(LIB_KIO) $(LIB_KDEUI) -lDCOP
 
 kpilotincludedir = $(includedir)/kpilot
 kpilotinclude_HEADERS = kpilotlink.h uiDialog.h plugin.h syncAction.h \
--- ksync/lib/Makefile.am	3 Oct 2002 00:58:32 -0000	1.1.1.4
+++ ksync/lib/Makefile.am	29 Nov 2002 19:01:22 -0000	1.2
@@ -1,7 +1,7 @@
 INCLUDES = -I$(top_srcdir)/libkcal $(all_includes)
 
 lib_LTLIBRARIES   = libksync.la
-libksync_la_LDFLAGS = $(all_libraries) -no-undefined -version-info 1:0:0 -module
+libksync_la_LDFLAGS = $(all_libraries) -no-undefined -version-info 1:0:0
 libksync_la_LIBADD  = $(top_builddir)/libkcal/libkcal.la -lkabc $(LIB_QT)
 
 libksync_la_SOURCES = \
--- libical/src/Makefile.am	25 Jun 2002 03:18:23 -0000	1.1.1.1
+++ libical/src/Makefile.am	28 Jan 2003 21:35:09 -0000	1.2
@@ -4,4 +4,4 @@
 PYTHON_DIR = 
 #endif
 
-SUBDIRS = libical libicalss libicalvcal $(PYTHON_DIR) test
+SUBDIRS = libical libicalss libicalvcal $(PYTHON_DIR)
--- libical/src/libical/.cvsignore	25 Jun 2002 03:18:23 -0000	1.1.1.1
+++ libical/src/libical/.cvsignore	6 Oct 2002 03:09:13 -0000	1.2
@@ -9,7 +9,6 @@
 icalderivedproperty.h
 icalderivedvalue.c
 icalderivedvalue.h
-icallexer.c
 icalattendee.lo
 icalattendee.o
 icalcomponent.lo
@@ -63,5 +62,3 @@
 vsnprintf.o
 y.output
 
-icalyacc.c
-icalyacc.h
RCS file: libical/src/libical/icallexer.c.new
diff -N libical/src/libical/icallexer.c.new
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ libical/src/libical/icallexer.c.new	28 Jan 2003 21:35:10 -0000	1.1
@@ -0,0 +1,1765 @@
+#define yy_create_buffer ical_yy_create_buffer
+#define yy_delete_buffer ical_yy_delete_buffer
+#define yy_scan_buffer ical_yy_scan_buffer
+#define yy_scan_string ical_yy_scan_string
+#define yy_scan_bytes ical_yy_scan_bytes
+#define yy_flex_debug ical_yy_flex_debug
+#define yy_init_buffer ical_yy_init_buffer
+#define yy_flush_buffer ical_yy_flush_buffer
+#define yy_load_buffer_state ical_yy_load_buffer_state
+#define yy_switch_to_buffer ical_yy_switch_to_buffer
+#define yyin ical_yyin
+#define yyleng ical_yyleng
+#define yylex ical_yylex
+#define yyout ical_yyout
+#define yyrestart ical_yyrestart
+#define yytext ical_yytext
+#define yywrap ical_yywrap
+
+#line 20 "lex.yy.c"
+/* A lexical scanner generated by flex */
+
+/* Scanner skeleton version:
+ * $Header: /Volumes/src/cvs/od/proj/KDE-Darwin/kdepim/libical/src/libical/icallexer.c.new,v 1.1 2003/01/28 21:35:10 ranger Exp $
+ */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+
+#include <stdio.h>
+
+
+/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+
+
+#ifdef __cplusplus
+
+#include <stdlib.h>
+#include <unistd.h>
+
+/* Use prototypes in function declarations. */
+#define YY_USE_PROTOS
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_PROTOS
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef __TURBOC__
+ #pragma warn -rch
+ #pragma warn -use
+#include <io.h>
+#include <stdlib.h>
+#define YY_USE_CONST
+#define YY_USE_PROTOS
+#endif
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+
+#ifdef YY_USE_PROTOS
+#define YY_PROTO(proto) proto
+#else
+#define YY_PROTO(proto) ()
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN yy_start = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((yy_start - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#define YY_BUF_SIZE 16384
+
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+
+extern int yyleng;
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+/* The funky do-while in the following #define is used to turn the definition
+ * int a single C statement (which needs a semi-colon terminator).  This
+ * avoids problems with code like:
+ *
+ * 	if ( condition_holds )
+ *		yyless( 5 );
+ *	else
+ *		do_something_else();
+ *
+ * Prior to using the do-while the compiler would get upset at the
+ * "else" because it interpreted the "if" statement as being all
+ * done when it reached the ';' after the yyless() call.
+ */
+
+/* Return all but the first 'n' matched characters back to the input stream. */
+
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		*yy_cp = yy_hold_char; \
+		YY_RESTORE_YY_MORE_OFFSET \
+		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, yytext_ptr )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+typedef unsigned int yy_size_t;
+
+
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+	};
+
+static YY_BUFFER_STATE yy_current_buffer = 0;
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ */
+#define YY_CURRENT_BUFFER yy_current_buffer
+
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+
+
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 1;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart YY_PROTO(( FILE *input_file ));
+
+void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
+void yy_load_buffer_state YY_PROTO(( void ));
+YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
+void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
+void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
+
+YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
+YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
+YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
+
+static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
+static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
+static void yy_flex_free YY_PROTO(( void * ));
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+
+typedef unsigned char YY_CHAR;
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+typedef int yy_state_type;
+extern char yytext[];
+
+
+static yy_state_type yy_get_previous_state YY_PROTO(( void ));
+static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
+static int yy_get_next_buffer YY_PROTO(( void ));
+static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	yytext_ptr = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	yy_hold_char = *yy_cp; \
+	*yy_cp = '\0'; \
+	if ( yyleng >= YYLMAX ) \
+		YY_FATAL_ERROR( "token too large, exceeds YYLMAX" ); \
+	yy_flex_strncpy( yytext, yytext_ptr, yyleng + 1 ); \
+	yy_c_buf_p = yy_cp;
+
+#define YY_NUM_RULES 12
+#define YY_END_OF_BUFFER 13
+static yyconst short int yy_accept[67] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   13,   12,    5,   12,    4,    1,
+        2,    3,    6,   12,    7,   12,    9,   10,    9,   11,
+        5,    1,    6,    8,   10,    0
+    } ;
+
+static yyconst int yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+        1,    1,    3,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    4,    5,    6,    1,    7,    8,    8,    8,
+        8,    8,    8,    8,    8,    8,    8,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    7,    1,    1,
+        1,    7,    1,    1,    1,    1,    7,    1,    1,    7,
+        1,    1,    7,    9,    1,    1,    7,    1,    1,   10,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    7,
+
+        1,    1,    1,    7,    1,    1,    1,    1,    7,    1,
+        1,    7,    1,    1,    7,    9,    1,    1,    7,    1,
+        1,   10,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst int yy_meta[11] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1
+    } ;
+
+static yyconst short int yy_base[69] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    9,    0,   16,   18,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,   25,   24,    0,    0,
+        0,    0,    0,    0,   28,   31,   31,   25,   31,   18,
+       31,   31,   31,   23,   31,   16,   31,   31,   21,   31,
+       31,   14,   31,   31,   31,   31,   15,   13
+    } ;
+
+static yyconst short int yy_def[69] =
+    {   0,
+       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
+       66,   11,   67,   67,   67,   67,   67,   67,   67,   67,
+       67,   67,   67,   23,   68,   68,   67,   67,   67,   67,
+       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
+       67,   67,   67,   67,   66,   66,   66,   66,   66,   66,
+       66,   66,   66,   66,   66,   66,   66,   66,   66,   66,
+       66,   66,   66,   66,   66,    0,   66,   66
+    } ;
+
+static yyconst short int yy_nxt[42] =
+    {   0,
+       46,   47,   48,   49,   46,   49,   49,   50,   51,   52,
+       53,   54,   55,   57,   55,   46,   56,   58,   59,   58,
+       59,   62,   65,   64,   63,   62,   61,   66,   60,   60,
+       45,   66,   66,   66,   66,   66,   66,   66,   66,   66,
+       66
+    } ;
+
+static yyconst short int yy_chk[42] =
+    {   0,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       23,   23,   23,   68,   23,   67,   23,   25,   25,   26,
+       26,   62,   59,   56,   54,   50,   48,   45,   38,   37,
+       66,   66,   66,   66,   66,   66,   66,   66,   66,   66,
+       66
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+#ifndef YYLMAX
+#define YYLMAX 8192
+#endif
+
+char yytext[YYLMAX];
+char *yytext_ptr;
+#line 1 "../../../../libical/src/libical/icallexer.l"
+#define INITIAL 0
+#line 2 "../../../../libical/src/libical/icallexer.l"
+/* -*- Mode: C -*-
+  ======================================================================
+  FILE: icallexer.l
+  CREATOR: eric 10 June 1999
+  
+  DESCRIPTION:
+  
+  $Id: icallexer.c.new,v 1.1 2003/01/28 21:35:10 ranger Exp $
+  $Locker:  $
+
+  (C) COPYRIGHT 1999 Eric Busboom 
+  http://www.softwarestudio.org
+
+  The contents of this file are subject to the Mozilla Public License
+  Version 1.0 (the "License"); you may not use this file except in
+  compliance with the License. You may obtain a copy of the License at
+  http://www.mozilla.org/MPL/
+ 
+  Software distributed under the License is distributed on an "AS IS"
+  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+  the License for the specific language governing rights and
+  limitations under the License.
+
+  The original author is Eric Busboom
+  The original code is icalitip.y
+
+
+
+  ======================================================================*/
+#include "icalparser.h"
+#include "icalenums.h"
+#include "icalmemory.h"
+#include "assert.h"
+#include "icalyacc.h"
+
+#include <string.h> /* For strdup() */
+
+int icalparser_flex_input(char* buf, int max_size);
+void icalparser_clear_flex_input(void);
+
+
+#define ICAL_MAX_STR_CONST 1024
+
+#undef YY_INPUT
+#define YY_INPUT(b,r,ms) ( r= icalparser_flex_input(b,ms))
+#undef yywrap
+
+#undef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) ical_yyerror(msg)
+
+icalvalue_kind value_kind=ICAL_NO_VALUE;
+void set_parser_value_state(icalvalue_kind kind);
+extern int yydebug; 
+
+void ical_yyerror(char *s);
+
+void init_str_buf(void);
+
+int last_state;
+
+char *str_buf;
+char *str_buf_p;
+size_t buf_sz; /* = ICAL_MAX_STR_CONST;*/
+
+/* Define routines that were not propertly defined because of the
+renaming hack applied in icalyacc.y */
+YY_BUFFER_STATE ical_yy_scan_buffer ( char *base, yy_size_t size );
+YY_BUFFER_STATE ical_yy_scan_string ( yyconst char *yy_str );
+YY_BUFFER_STATE ical_yy_scan_bytes ( yyconst char *bytes, int len );
+
+#define quoted_string 1
+
+#define binary_value 2
+#define boolean_value 3
+#define uri_value 4
+#define time_value 5
+#define duration_value 6
+#define number_value 7
+#define period_value 8
+#define recur_value 9
+#define text_value 10
+#define utcoffset_value 11
+
+#define enum_param_value 12
+#define string_param_value 13
+#define stringlist_param_value 14
+#define keyword 15
+#define line_start 16
+#define component 17
+#define seperator 18
+#define parameter 19
+#define end_of_value 20
+#define paramtext 21
+
+#line 511 "lex.yy.c"
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap YY_PROTO(( void ));
+#else
+extern int yywrap YY_PROTO(( void ));
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+static void yyunput YY_PROTO(( int c, char *buf_ptr ));
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput YY_PROTO(( void ));
+#else
+static int input YY_PROTO(( void ));
+#endif
+#endif
+
+#if YY_STACK_USED
+static int yy_start_stack_ptr = 0;
+static int yy_start_stack_depth = 0;
+static int *yy_start_stack = 0;
+#ifndef YY_NO_PUSH_STATE
+static void yy_push_state YY_PROTO(( int new_state ));
+#endif
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state YY_PROTO(( void ));
+#endif
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state YY_PROTO(( void ));
+#endif
+
+#else
+#define YY_NO_PUSH_STATE 1
+#define YY_NO_POP_STATE 1
+#define YY_NO_TOP_STATE 1
+#endif
+
+#ifdef YY_MALLOC_DECL
+YY_MALLOC_DECL
+#else
+#if __STDC__
+#ifndef __cplusplus
+#include <stdlib.h>
+#endif
+#else
+/* Just try to get by without declaring the routines.  This will fail
+ * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
+ * or sizeof(void*) != sizeof(int).
+ */
+#endif
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( yy_current_buffer->yy_is_interactive ) \
+		{ \
+		int c = '*', n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
+		  && ferror( yyin ) ) \
+		YY_FATAL_ERROR( "input in flex scanner failed" );
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL int yylex YY_PROTO(( void ))
+#endif
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+YY_DECL
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+
+#line 97 "../../../../libical/src/libical/icallexer.l"
+
+
+
+
+
+
+
+#line 670 "lex.yy.c"
+
+	if ( yy_init )
+		{
+		yy_init = 0;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! yy_start )
+			yy_start = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! yy_current_buffer )
+			yy_current_buffer =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+
+		yy_load_buffer_state();
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = yy_c_buf_p;
+
+		/* Support of yytext. */
+		*yy_cp = yy_hold_char;
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = yy_start;
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				yy_last_accepting_state = yy_current_state;
+				yy_last_accepting_cpos = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 67 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 31 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+
+do_action:	/* This label is used only to access EOF actions. */
+
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = yy_hold_char;
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			goto yy_find_action;
+
+
+case 1:
+YY_RULE_SETUP
+#line 105 "../../../../libical/src/libical/icallexer.l"
+{ ical_yylval.v_string =icalmemory_tmp_copy(yytext) ;
+                           return DIGITS; }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 107 "../../../../libical/src/libical/icallexer.l"
+{ return TIME_CHAR; }
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 108 "../../../../libical/src/libical/icallexer.l"
+{ return UTC_CHAR; }
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 109 "../../../../libical/src/libical/icallexer.l"
+{ return yytext[0]; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 110 "../../../../libical/src/libical/icallexer.l"
+{ return EOL;}
+	YY_BREAK
+
+
+case 6:
+YY_RULE_SETUP
+#line 115 "../../../../libical/src/libical/icallexer.l"
+{ return EOL;}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 116 "../../../../libical/src/libical/icallexer.l"
+{ return yytext[0]; }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 117 "../../../../libical/src/libical/icallexer.l"
+{ ical_yylval.v_int=atoi(yytext); return INTNUMBER; }
+	YY_BREAK
+
+
+case 9:
+YY_RULE_SETUP
+#line 122 "../../../../libical/src/libical/icallexer.l"
+{ return CHARACTER; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 123 "../../../../libical/src/libical/icallexer.l"
+{ return EOL;}
+	YY_BREAK
+
+
+case 11:
+YY_RULE_SETUP
+#line 128 "../../../../libical/src/libical/icallexer.l"
+{ BEGIN(last_state); return COMMA; } 
+	YY_BREAK
+
+case 12:
+YY_RULE_SETUP
+#line 132 "../../../../libical/src/libical/icallexer.l"
+ECHO;
+	YY_BREAK
+#line 822 "lex.yy.c"
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(quoted_string):
+case YY_STATE_EOF(binary_value):
+case YY_STATE_EOF(boolean_value):
+case YY_STATE_EOF(uri_value):
+case YY_STATE_EOF(time_value):
+case YY_STATE_EOF(duration_value):
+case YY_STATE_EOF(number_value):
+case YY_STATE_EOF(period_value):
+case YY_STATE_EOF(recur_value):
+case YY_STATE_EOF(text_value):
+case YY_STATE_EOF(utcoffset_value):
+case YY_STATE_EOF(enum_param_value):
+case YY_STATE_EOF(string_param_value):
+case YY_STATE_EOF(stringlist_param_value):
+case YY_STATE_EOF(keyword):
+case YY_STATE_EOF(line_start):
+case YY_STATE_EOF(component):
+case YY_STATE_EOF(seperator):
+case YY_STATE_EOF(parameter):
+case YY_STATE_EOF(end_of_value):
+case YY_STATE_EOF(paramtext):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = yy_hold_char;
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between yy_current_buffer and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			yy_n_chars = yy_current_buffer->yy_n_chars;
+			yy_current_buffer->yy_input_file = yyin;
+			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state();
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = yytext_ptr + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++yy_c_buf_p;
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = yy_c_buf_p;
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer() )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				yy_did_buffer_switch_on_eof = 0;
+
+				if ( yywrap() )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				yy_c_buf_p =
+					yytext_ptr + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				yy_c_buf_p =
+				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of yylex */
+
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+
+static int yy_get_next_buffer()
+	{
+	register char *dest = yy_current_buffer->yy_ch_buf;
+	register char *source = yytext_ptr;
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( yy_current_buffer->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+
+	else
+		{
+		int num_to_read =
+			yy_current_buffer->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+#ifdef YY_USES_REJECT
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+#else
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = yy_current_buffer;
+
+			int yy_c_buf_p_offset =
+				(int) (yy_c_buf_p - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yy_flex_realloc( (void *) b->yy_ch_buf,
+							 b->yy_buf_size + 2 );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = yy_current_buffer->yy_buf_size -
+						number_to_move - 1;
+#endif
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
+			yy_n_chars, num_to_read );
+
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	if ( yy_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			yy_current_buffer->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	yy_n_chars += number_to_move;
+	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+
+	return ret_val;
+	}
+
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+static yy_state_type yy_get_previous_state()
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+
+	yy_current_state = yy_start;
+
+	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			yy_last_accepting_state = yy_current_state;
+			yy_last_accepting_cpos = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 67 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+	}
+
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+
+#ifdef YY_USE_PROTOS
+static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
+#else
+static yy_state_type yy_try_NUL_trans( yy_current_state )
+yy_state_type yy_current_state;
+#endif
+	{
+	register int yy_is_jam;
+	register char *yy_cp = yy_c_buf_p;
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		yy_last_accepting_state = yy_current_state;
+		yy_last_accepting_cpos = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 67 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 66);
+
+	return yy_is_jam ? 0 : yy_current_state;
+	}
+
+
+#ifndef YY_NO_UNPUT
+#ifdef YY_USE_PROTOS
+static void yyunput( int c, register char *yy_bp )
+#else
+static void yyunput( c, yy_bp )
+int c;
+register char *yy_bp;
+#endif
+	{
+	register char *yy_cp = yy_c_buf_p;
+
+	/* undo effects of setting up yytext */
+	*yy_cp = yy_hold_char;
+
+	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = yy_n_chars + 2;
+		register char *dest = &yy_current_buffer->yy_ch_buf[
+					yy_current_buffer->yy_buf_size + 2];
+		register char *source =
+				&yy_current_buffer->yy_ch_buf[number_to_move];
+
+		while ( source > yy_current_buffer->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		yy_current_buffer->yy_n_chars =
+			yy_n_chars = yy_current_buffer->yy_buf_size;
+
+		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+
+	yytext_ptr = yy_bp;
+	yy_hold_char = *yy_cp;
+	yy_c_buf_p = yy_cp;
+	}
+#endif	/* ifndef YY_NO_UNPUT */
+
+
+#ifdef __cplusplus
+static int yyinput()
+#else
+static int input()
+#endif
+	{
+	int c;
+
+	*yy_c_buf_p = yy_hold_char;
+
+	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			/* This was really a NUL. */
+			*yy_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			int offset = yy_c_buf_p - yytext_ptr;
+			++yy_c_buf_p;
+
+			switch ( yy_get_next_buffer() )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/* fall through */
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap() )
+						return EOF;
+
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					yy_c_buf_p = yytext_ptr + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
+	*yy_c_buf_p = '\0';	/* preserve yytext */
+	yy_hold_char = *++yy_c_buf_p;
+
+
+	return c;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yyrestart( FILE *input_file )
+#else
+void yyrestart( input_file )
+FILE *input_file;
+#endif
+	{
+	if ( ! yy_current_buffer )
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+
+	yy_init_buffer( yy_current_buffer, input_file );
+	yy_load_buffer_state();
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
+#else
+void yy_switch_to_buffer( new_buffer )
+YY_BUFFER_STATE new_buffer;
+#endif
+	{
+	if ( yy_current_buffer == new_buffer )
+		return;
+
+	if ( yy_current_buffer )
+		{
+		/* Flush out information for old buffer. */
+		*yy_c_buf_p = yy_hold_char;
+		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	yy_current_buffer = new_buffer;
+	yy_load_buffer_state();
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	yy_did_buffer_switch_on_eof = 1;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_load_buffer_state( void )
+#else
+void yy_load_buffer_state()
+#endif
+	{
+	yy_n_chars = yy_current_buffer->yy_n_chars;
+	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
+	yyin = yy_current_buffer->yy_input_file;
+	yy_hold_char = *yy_c_buf_p;
+	}
+
+
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
+#else
+YY_BUFFER_STATE yy_create_buffer( file, size )
+FILE *file;
+int size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_delete_buffer( YY_BUFFER_STATE b )
+#else
+void yy_delete_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+	{
+	if ( ! b )
+		return;
+
+	if ( b == yy_current_buffer )
+		yy_current_buffer = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yy_flex_free( (void *) b->yy_ch_buf );
+
+	yy_flex_free( (void *) b );
+	}
+
+
+#ifndef YY_ALWAYS_INTERACTIVE
+#ifndef YY_NEVER_INTERACTIVE
+#include<unistd.h>
+#endif
+#endif
+
+#ifdef YY_USE_PROTOS
+void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
+#else
+void yy_init_buffer( b, file )
+YY_BUFFER_STATE b;
+FILE *file;
+#endif
+
+
+	{
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+#if YY_ALWAYS_INTERACTIVE
+	b->yy_is_interactive = 1;
+#else
+#if YY_NEVER_INTERACTIVE
+	b->yy_is_interactive = 0;
+#else
+	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+#endif
+#endif
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_flush_buffer( YY_BUFFER_STATE b )
+#else
+void yy_flush_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+
+	{
+	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == yy_current_buffer )
+		yy_load_buffer_state();
+	}
+
+
+#ifndef YY_NO_SCAN_BUFFER
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
+#else
+YY_BUFFER_STATE yy_scan_buffer( base, size )
+char *base;
+yy_size_t size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b );
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_STRING
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
+#else
+YY_BUFFER_STATE yy_scan_string( yy_str )
+yyconst char *yy_str;
+#endif
+	{
+	int len;
+	for ( len = 0; yy_str[len]; ++len )
+		;
+
+	return yy_scan_bytes( yy_str, len );
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_BYTES
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
+#else
+YY_BUFFER_STATE yy_scan_bytes( bytes, len )
+yyconst char *bytes;
+int len;
+#endif
+	{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = len + 2;
+	buf = (char *) yy_flex_alloc( n );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
+
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_PUSH_STATE
+#ifdef YY_USE_PROTOS
+static void yy_push_state( int new_state )
+#else
+static void yy_push_state( new_state )
+int new_state;
+#endif
+	{
+	if ( yy_start_stack_ptr >= yy_start_stack_depth )
+		{
+		yy_size_t new_size;
+
+		yy_start_stack_depth += YY_START_STACK_INCR;
+		new_size = yy_start_stack_depth * sizeof( int );
+
+		if ( ! yy_start_stack )
+			yy_start_stack = (int *) yy_flex_alloc( new_size );
+
+		else
+			yy_start_stack = (int *) yy_flex_realloc(
+					(void *) yy_start_stack, new_size );
+
+		if ( ! yy_start_stack )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
+
+	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+
+	BEGIN(new_state);
+	}
+#endif
+
+
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state()
+	{
+	if ( --yy_start_stack_ptr < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
+
+	BEGIN(yy_start_stack[yy_start_stack_ptr]);
+	}
+#endif
+
+
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state()
+	{
+	return yy_start_stack[yy_start_stack_ptr - 1];
+	}
+#endif
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+#ifdef YY_USE_PROTOS
+static void yy_fatal_error( yyconst char msg[] )
+#else
+static void yy_fatal_error( msg )
+char msg[];
+#endif
+	{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+	}
+
+
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		yytext[yyleng] = yy_hold_char; \
+		yy_c_buf_p = yytext + n; \
+		yy_hold_char = *yy_c_buf_p; \
+		*yy_c_buf_p = '\0'; \
+		yyleng = n; \
+		} \
+	while ( 0 )
+
+
+/* Internal utility routines. */
+
+#ifndef yytext_ptr
+#ifdef YY_USE_PROTOS
+static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
+#else
+static void yy_flex_strncpy( s1, s2, n )
+char *s1;
+yyconst char *s2;
+int n;
+#endif
+	{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+	}
+#endif
+
+#ifdef YY_NEED_STRLEN
+#ifdef YY_USE_PROTOS
+static int yy_flex_strlen( yyconst char *s )
+#else
+static int yy_flex_strlen( s )
+yyconst char *s;
+#endif
+	{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+	}
+#endif
+
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_alloc( yy_size_t size )
+#else
+static void *yy_flex_alloc( size )
+yy_size_t size;
+#endif
+	{
+	return (void *) malloc( size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_realloc( void *ptr, yy_size_t size )
+#else
+static void *yy_flex_realloc( ptr, size )
+void *ptr;
+yy_size_t size;
+#endif
+	{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void yy_flex_free( void *ptr )
+#else
+static void yy_flex_free( ptr )
+void *ptr;
+#endif
+	{
+	free( ptr );
+	}
+
+#if YY_MAIN
+int main()
+	{
+	yylex();
+	return 0;
+	}
+#endif
+#line 132 "../../../../libical/src/libical/icallexer.l"
+
+
+int yywrap()
+{
+     return 1;
+}
+
+
+void set_parser_value_state(icalvalue_kind kind)
+{
+
+    switch (kind){
+
+	case ICAL_UTCOFFSET_VALUE:
+	    {BEGIN(utcoffset_value);break;}
+
+	case ICAL_DATETIMEPERIOD_VALUE:
+	case ICAL_DURATION_VALUE:
+	case ICAL_PERIOD_VALUE:
+	    {BEGIN(time_value);break;}
+
+	default:
+	{
+	   assert(1==0);
+	}
+    }
+}
+
+void init_str_buf(void)
+{
+   str_buf = icalmemory_tmp_buffer(ICAL_MAX_STR_CONST);
+   str_buf_p = str_buf;
+   buf_sz = ICAL_MAX_STR_CONST;
+
+
+}
+
RCS file: libical/src/libical/icalyacc.c.new
diff -N libical/src/libical/icalyacc.c.new
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ libical/src/libical/icalyacc.c.new	28 Jan 2003 21:35:10 -0000	1.1
@@ -0,0 +1,1447 @@
+
+/*  A Bison parser, made from ../../../../libical/src/libical/icalyacc.y
+    by GNU Bison version 1.28  */
+
+#define YYBISON 1  /* Identify Bison output.  */
+
+#define yyparse ical_yyparse
+#define yylex ical_yylex
+#define yyerror ical_yyerror
+#define yylval ical_yylval
+#define yychar ical_yychar
+#define yydebug ical_yydebug
+#define yynerrs ical_yynerrs
+#define	DIGITS	257
+#define	INTNUMBER	258
+#define	FLOATNUMBER	259
+#define	STRING	260
+#define	EOL	261
+#define	EQUALS	262
+#define	CHARACTER	263
+#define	COLON	264
+#define	COMMA	265
+#define	SEMICOLON	266
+#define	MINUS	267
+#define	TIMESEPERATOR	268
+#define	TRUE	269
+#define	FALSE	270
+#define	FREQ	271
+#define	BYDAY	272
+#define	BYHOUR	273
+#define	BYMINUTE	274
+#define	BYMONTH	275
+#define	BYMONTHDAY	276
+#define	BYSECOND	277
+#define	BYSETPOS	278
+#define	BYWEEKNO	279
+#define	BYYEARDAY	280
+#define	DAILY	281
+#define	MINUTELY	282
+#define	MONTHLY	283
+#define	SECONDLY	284
+#define	WEEKLY	285
+#define	HOURLY	286
+#define	YEARLY	287
+#define	INTERVAL	288
+#define	COUNT	289
+#define	UNTIL	290
+#define	WKST	291
+#define	MO	292
+#define	SA	293
+#define	SU	294
+#define	TU	295
+#define	WE	296
+#define	TH	297
+#define	FR	298
+#define	BIT8	299
+#define	ACCEPTED	300
+#define	ADD	301
+#define	AUDIO	302
+#define	BASE64	303
+#define	BINARY	304
+#define	BOOLEAN	305
+#define	BUSY	306
+#define	BUSYTENTATIVE	307
+#define	BUSYUNAVAILABLE	308
+#define	CALADDRESS	309
+#define	CANCEL	310
+#define	CANCELLED	311
+#define	CHAIR	312
+#define	CHILD	313
+#define	COMPLETED	314
+#define	CONFIDENTIAL	315
+#define	CONFIRMED	316
+#define	COUNTER	317
+#define	DATE	318
+#define	DATETIME	319
+#define	DECLINECOUNTER	320
+#define	DECLINED	321
+#define	DELEGATED	322
+#define	DISPLAY	323
+#define	DRAFT	324
+#define	DURATION	325
+#define	EMAIL	326
+#define	END	327
+#define	FINAL	328
+#define	FLOAT	329
+#define	FREE	330
+#define	GREGORIAN	331
+#define	GROUP	332
+#define	INDIVIDUAL	333
+#define	INPROCESS	334
+#define	INTEGER	335
+#define	NEEDSACTION	336
+#define	NONPARTICIPANT	337
+#define	OPAQUE	338
+#define	OPTPARTICIPANT	339
+#define	PARENT	340
+#define	PERIOD	341
+#define	PRIVATE	342
+#define	PROCEDURE	343
+#define	PUBLIC	344
+#define	PUBLISH	345
+#define	RECUR	346
+#define	REFRESH	347
+#define	REPLY	348
+#define	REQPARTICIPANT	349
+#define	REQUEST	350
+#define	RESOURCE	351
+#define	ROOM	352
+#define	SIBLING	353
+#define	START	354
+#define	TENTATIVE	355
+#define	TEXT	356
+#define	THISANDFUTURE	357
+#define	THISANDPRIOR	358
+#define	TIME	359
+#define	TRANSPAENT	360
+#define	UNKNOWN	361
+#define	UTCOFFSET	362
+#define	XNAME	363
+#define	ALTREP	364
+#define	CN	365
+#define	CUTYPE	366
+#define	DAYLIGHT	367
+#define	DIR	368
+#define	ENCODING	369
+#define	EVENT	370
+#define	FBTYPE	371
+#define	FMTTYPE	372
+#define	LANGUAGE	373
+#define	MEMBER	374
+#define	PARTSTAT	375
+#define	RANGE	376
+#define	RELATED	377
+#define	RELTYPE	378
+#define	ROLE	379
+#define	RSVP	380
+#define	SENTBY	381
+#define	STANDARD	382
+#define	URI	383
+#define	TIME_CHAR	384
+#define	UTC_CHAR	385
+
+#line 1 "../../../../libical/src/libical/icalyacc.y"
+
+/* -*- Mode: C -*-
+  ======================================================================
+  FILE: icalitip.y
+  CREATOR: eric 10 June 1999
+  
+  DESCRIPTION:
+  
+  $Id: icalyacc.c.new,v 1.1 2003/01/28 21:35:10 ranger Exp $
+  $Locker:  $
+
+  (C) COPYRIGHT 1999 Eric Busboom 
+  http://www.softwarestudio.org
+
+  The contents of this file are subject to the Mozilla Public License
+  Version 1.0 (the "License"); you may not use this file except in
+  compliance with the License. You may obtain a copy of the License at
+  http://www.mozilla.org/MPL/
+ 
+  Software distributed under the License is distributed on an "AS IS"
+  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+  the License for the specific language governing rights and
+  limitations under the License.
+
+  The original author is Eric Busboom
+  The original code is icalitip.y
+
+
+
+  =======================================================================*/
+
+#include <stdlib.h>
+#include <string.h> /* for strdup() */
+#include "icalparser.h"
+#include "pvl.h"
+
+icalvalue *icalparser_yy_value; /* Current Value */
+
+void ical_yyerror(char* s);
+void icalparser_clear_flex_input();  
+int ical_yy_lex(void);
+
+/* Globals for UTCOFFSET values */
+int utc; 
+int utc_b; 
+int utcsign;
+
+/* Globals for DURATION values */
+struct icaldurationtype duration;
+
+/* Globals for TRIGGER values */
+struct icaltriggertype trigger;
+
+void copy_list(short* array, size_t size);
+void add_prop(icalproperty_kind);
+void icalparser_fill_date(struct tm* t, char* dstr);
+void icalparser_fill_time(struct tm* t, char* tstr);
+void set_value_type(icalvalue_kind kind);
+void set_parser_value_state();
+struct icaltimetype fill_datetime(char* d, char* t);
+void ical_yy_error(char *s); /* Don't know why I need this.... */
+int yylex(void); /* Or this. */
+
+
+
+/* Set the state of the lexer so it will interpret values ( iCAL
+   VALUEs, that is, ) correctly. */
+
+
+#line 71 "../../../../libical/src/libical/icalyacc.y"
+typedef union {
+	float v_float;
+	int   v_int;
+	char* v_string;
+} YYSTYPE;
+#ifndef YYDEBUG
+#define YYDEBUG 1
+#endif
+
+#include <stdio.h>
+
+#ifndef __cplusplus
+#ifndef __STDC__
+#define const
+#endif
+#endif
+
+
+
+#define	YYFINAL		51
+#define	YYFLAG		-32768
+#define	YYNTBASE	141
+
+#define YYTRANSLATE(x) ((unsigned)(x) <= 385 ? yytranslate[x] : 158)
+
+static const short yytranslate[] = {     0,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,   137,     2,   138,     2,   140,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,   136,     2,     2,
+     2,   133,     2,     2,     2,     2,   134,     2,     2,   139,
+     2,     2,   135,     2,     2,     2,   132,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
+     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
+    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,
+    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,
+    57,    58,    59,    60,    61,    62,    63,    64,    65,    66,
+    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,
+    77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
+    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,
+    97,    98,    99,   100,   101,   102,   103,   104,   105,   106,
+   107,   108,   109,   110,   111,   112,   113,   114,   115,   116,
+   117,   118,   119,   120,   121,   122,   123,   124,   125,   126,
+   127,   128,   129,   130,   131
+};
+
+#if YYDEBUG != 0
+static const short yyprhs[] = {     0,
+     0,     2,     4,     6,     8,    10,    12,    14,    15,    17,
+    18,    20,    25,    27,    30,    33,    36,    39,    42,    45,
+    49,    52,    56,    59,    62,    63,    65,    67,    71,    75,
+    79,    89,    96,    97,    99,   101,   105
+};
+
+static const short yyrhs[] = {   142,
+     0,   145,     0,   154,     0,   155,     0,   157,     0,     1,
+     0,     3,     0,     0,   131,     0,     0,   131,     0,     3,
+   130,     3,   143,     0,   152,     0,   152,   148,     0,     3,
+   132,     0,   130,   149,     0,   130,   150,     0,   130,   151,
+     0,     3,   133,     0,     3,   133,   150,     0,     3,   134,
+     0,     3,   134,   151,     0,     3,   135,     0,     3,   136,
+     0,     0,   137,     0,   138,     0,   153,   139,   146,     0,
+   153,   139,   148,     0,   153,   139,   147,     0,     3,   130,
+     3,   143,   140,     3,   130,     3,   144,     0,     3,   130,
+     3,   143,   140,   154,     0,     0,   137,     0,   138,     0,
+   156,     4,     4,     0,   156,     4,     4,     4,     0
+};
+
+#endif
+
+#if YYDEBUG != 0
+static const short yyrline[] = { 0,
+   177,   179,   180,   181,   182,   183,   190,   205,   207,   210,
+   212,   214,   230,   231,   233,   238,   241,   244,   248,   252,
+   257,   261,   266,   271,   276,   280,   284,   289,   294,   299,
+   308,   329,   358,   364,   365,   367,   373
+};
+#endif
+
+
+#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
+
+static const char * const yytname[] = {   "$","error","$undefined.","DIGITS",
+"INTNUMBER","FLOATNUMBER","STRING","EOL","EQUALS","CHARACTER","COLON","COMMA",
+"SEMICOLON","MINUS","TIMESEPERATOR","TRUE","FALSE","FREQ","BYDAY","BYHOUR","BYMINUTE",
+"BYMONTH","BYMONTHDAY","BYSECOND","BYSETPOS","BYWEEKNO","BYYEARDAY","DAILY",
+"MINUTELY","MONTHLY","SECONDLY","WEEKLY","HOURLY","YEARLY","INTERVAL","COUNT",
+"UNTIL","WKST","MO","SA","SU","TU","WE","TH","FR","BIT8","ACCEPTED","ADD","AUDIO",
+"BASE64","BINARY","BOOLEAN","BUSY","BUSYTENTATIVE","BUSYUNAVAILABLE","CALADDRESS",
+"CANCEL","CANCELLED","CHAIR","CHILD","COMPLETED","CONFIDENTIAL","CONFIRMED",
+"COUNTER","DATE","DATETIME","DECLINECOUNTER","DECLINED","DELEGATED","DISPLAY",
+"DRAFT","DURATION","EMAIL","END","FINAL","FLOAT","FREE","GREGORIAN","GROUP",
+"INDIVIDUAL","INPROCESS","INTEGER","NEEDSACTION","NONPARTICIPANT","OPAQUE","OPTPARTICIPANT",
+"PARENT","PERIOD","PRIVATE","PROCEDURE","PUBLIC","PUBLISH","RECUR","REFRESH",
+"REPLY","REQPARTICIPANT","REQUEST","RESOURCE","ROOM","SIBLING","START","TENTATIVE",
+"TEXT","THISANDFUTURE","THISANDPRIOR","TIME","TRANSPAENT","UNKNOWN","UTCOFFSET",
+"XNAME","ALTREP","CN","CUTYPE","DAYLIGHT","DIR","ENCODING","EVENT","FBTYPE",
+"FMTTYPE","LANGUAGE","MEMBER","PARTSTAT","RANGE","RELATED","RELTYPE","ROLE",
+"RSVP","SENTBY","STANDARD","URI","TIME_CHAR","UTC_CHAR","'W'","'H'","'M'","'S'",
+"'D'","'+'","'-'","'P'","'/'","value","date_value","utc_char","utc_char_b","datetime_value",
+"dur_date","dur_week","dur_time","dur_hour","dur_minute","dur_second","dur_day",
+"dur_prefix","duration_value","period_value","plusminus","utcoffset_value", NULL
+};
+#endif
+
+static const short yyr1[] = {     0,
+   141,   141,   141,   141,   141,   141,   142,   143,   143,   144,
+   144,   145,   146,   146,   147,   148,   148,   148,   149,   149,
+   150,   150,   151,   152,   153,   153,   153,   154,   154,   154,
+   155,   155,    -1,   156,   156,   157,   157
+};
+
+static const short yyr2[] = {     0,
+     1,     1,     1,     1,     1,     1,     1,     0,     1,     0,
+     1,     4,     1,     2,     2,     2,     2,     2,     2,     3,
+     2,     3,     2,     2,     0,     1,     1,     3,     3,     3,
+     9,     6,     0,     1,     1,     3,     4
+};
+
+static const short yydefact[] = {     0,
+     6,     7,    26,    27,     1,     2,     0,     3,     4,     0,
+     5,     0,     0,     0,     8,     0,     0,    28,    30,    29,
+    13,    36,     9,    12,    15,    24,     0,    16,    17,    18,
+    14,    37,    25,    19,    21,    23,     0,    26,    27,    32,
+     0,    20,     0,    22,     0,    10,    11,    31,     0,     0,
+     0
+};
+
+static const short yydefgoto[] = {    49,
+     5,    24,    48,     6,    18,    19,    20,    28,    29,    30,
+    21,     7,     8,     9,    10,    11
+};
+
+static const short yypact[] = {    -1,
+-32768,  -126,     7,     8,-32768,-32768,  -133,-32768,-32768,     9,
+-32768,    11,    -2,    12,  -116,  -129,    14,-32768,-32768,-32768,
+  -112,    15,-32768,  -120,-32768,-32768,  -125,-32768,-32768,-32768,
+-32768,-32768,     2,    18,    19,-32768,  -107,-32768,-32768,-32768,
+  -110,-32768,  -109,-32768,    22,  -104,-32768,-32768,    28,    29,
+-32768
+};
+
+static const short yypgoto[] = {-32768,
+-32768,-32768,-32768,-32768,-32768,-32768,    10,-32768,    -4,    -3,
+-32768,-32768,     0,-32768,-32768,-32768
+};
+
+
+#define	YYLAST		140
+
+
+static const short yytable[] = {     1,
+    16,     2,    25,    12,    37,    13,    26,    34,    35,    36,
+   -34,   -35,    14,    15,    23,    22,    27,    17,    32,    33,
+    41,    43,    45,    35,    46,    36,    47,    50,    51,    42,
+    31,    44,    40,     0,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,     0,     0,     0,    17,     0,     0,
+     0,     0,     0,     0,     0,     3,     4,   -25,    38,    39
+};
+
+static const short yycheck[] = {     1,
+     3,     3,   132,   130,     3,   139,   136,   133,   134,   135,
+     4,     4,     4,     3,   131,     4,     3,   130,     4,   140,
+     3,     3,   130,   134,     3,   135,   131,     0,     0,    34,
+    21,    35,    33,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+    -1,    -1,    -1,    -1,    -1,    -1,    -1,   130,    -1,    -1,
+    -1,    -1,    -1,    -1,    -1,   137,   138,   139,   137,   138
+};
+/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
+#line 3 "/usr/share/bison.simple"
+/* This file comes from bison-1.28.  */
+
+/* Skeleton output parser for bison,
+   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* This is the parser code that is written into each bison parser
+  when the %semantic_parser declaration is not specified in the grammar.
+  It was written by Richard Stallman by simplifying the hairy parser
+  used when %semantic_parser is specified.  */
+
+#ifndef YYPARSE_RETURN_TYPE
+#define YYPARSE_RETURN_TYPE int
+#endif
+
+
+#ifndef YYSTACK_USE_ALLOCA
+#ifdef alloca
+#define YYSTACK_USE_ALLOCA
+#else /* alloca not defined */
+#ifdef __GNUC__
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#else /* not GNU C.  */
+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
+#define YYSTACK_USE_ALLOCA
+#include <alloca.h>
+#else /* not sparc */
+/* We think this test detects Watcom and Microsoft C.  */
+/* This used to test MSDOS, but that is a bad idea
+   since that symbol is in the user namespace.  */
+#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
+#if 0 /* No need for malloc.h, which pollutes the namespace;
+	 instead, just don't use alloca.  */
+#include <malloc.h>
+#endif
+#else /* not MSDOS, or __TURBOC__ */
+#if defined(_AIX)
+/* I don't know what this was needed for, but it pollutes the namespace.
+   So I turned it off.   rms, 2 May 1997.  */
+/* #include <malloc.h>  */
+ #pragma alloca
+#define YYSTACK_USE_ALLOCA
+#else /* not MSDOS, or __TURBOC__, or _AIX */
+#if 0
+#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
+		 and on HPUX 10.  Eventually we can turn this on.  */
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#endif /* __hpux */
+#endif
+#endif /* not _AIX */
+#endif /* not MSDOS, or __TURBOC__ */
+#endif /* not sparc */
+#endif /* not GNU C */
+#endif /* alloca not defined */
+#endif /* YYSTACK_USE_ALLOCA not defined */
+
+#ifdef YYSTACK_USE_ALLOCA
+#define YYSTACK_ALLOC alloca
+#else
+#define YYSTACK_ALLOC malloc
+#endif
+
+/* Note: there must be only one dollar sign in this file.
+   It is replaced by the list of actions, each action
+   as one case of the switch.  */
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		-2
+#define YYEOF		0
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT 	goto yyabortlab
+#define YYERROR		goto yyerrlab1
+/* Like YYERROR except do call yyerror.
+   This remains here temporarily to ease the
+   transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+#define YYFAIL		goto yyerrlab
+#define YYRECOVERING()  (!!yyerrstatus)
+#define YYBACKUP(token, value) \
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    { yychar = (token), yylval = (value);			\
+      yychar1 = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+#ifndef YYPURE
+#define YYLEX		yylex()
+#endif
+
+#ifdef YYPURE
+#ifdef YYLSP_NEEDED
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval, &yylloc)
+#endif
+#else /* not YYLSP_NEEDED */
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval)
+#endif
+#endif /* not YYLSP_NEEDED */
+#endif
+
+/* If nonreentrant, generate the variables here */
+
+#ifndef YYPURE
+
+int	yychar;			/*  the lookahead symbol		*/
+YYSTYPE	yylval;			/*  the semantic value of the		*/
+				/*  lookahead symbol			*/
+
+#ifdef YYLSP_NEEDED
+YYLTYPE yylloc;			/*  location data for the lookahead	*/
+				/*  symbol				*/
+#endif
+
+int yynerrs;			/*  number of parse errors so far       */
+#endif  /* not YYPURE */
+
+#if YYDEBUG != 0
+int yydebug;			/*  nonzero means print parse trace	*/
+/* Since this is uninitialized, it does not stop multiple parsers
+   from coexisting.  */
+#endif
+
+/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+
+#ifndef	YYINITDEPTH
+#define YYINITDEPTH 200
+#endif
+
+/*  YYMAXDEPTH is the maximum size the stacks can grow to
+    (effective only if the built-in stack extension method is used).  */
+
+#if YYMAXDEPTH == 0
+#undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+#define YYMAXDEPTH 10000
+#endif
+
+/* Define __yy_memcpy.  Note that the size argument
+   should be passed with type unsigned int, because that is what the non-GCC
+   definitions require.  With GCC, __builtin_memcpy takes an arg
+   of type size_t, but it can handle unsigned int.  */
+
+#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
+#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
+#else				/* not GNU C or C++ */
+#ifndef __cplusplus
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (to, from, count)
+     char *to;
+     char *from;
+     unsigned int count;
+{
+  register char *f = from;
+  register char *t = to;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#else /* __cplusplus */
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (char *to, char *from, unsigned int count)
+{
+  register char *t = to;
+  register char *f = from;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#endif
+#endif
+
+#line 222 "/usr/share/bison.simple"
+
+/* The user can define YYPARSE_PARAM as the name of an argument to be passed
+   into yyparse.  The argument should have type void *.
+   It should actually point to an object.
+   Grammar actions can access the variable by casting it
+   to the proper pointer type.  */
+
+#ifdef YYPARSE_PARAM
+#ifdef __cplusplus
+#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL
+#else /* not __cplusplus */
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+#endif /* not __cplusplus */
+#else /* not YYPARSE_PARAM */
+#define YYPARSE_PARAM_ARG
+#define YYPARSE_PARAM_DECL
+#endif /* not YYPARSE_PARAM */
+
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+#ifdef YYPARSE_PARAM
+YYPARSE_RETURN_TYPE
+yyparse (void *);
+#else
+YYPARSE_RETURN_TYPE
+yyparse (void);
+#endif
+#endif
+
+YYPARSE_RETURN_TYPE
+yyparse(YYPARSE_PARAM_ARG)
+     YYPARSE_PARAM_DECL
+{
+  register int yystate;
+  register int yyn;
+  register short *yyssp;
+  register YYSTYPE *yyvsp;
+  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
+  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
+
+  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
+  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
+
+  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
+  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
+
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
+  YYLTYPE *yyls = yylsa;
+  YYLTYPE *yylsp;
+
+#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#else
+#define YYPOPSTACK   (yyvsp--, yyssp--)
+#endif
+
+  int yystacksize = YYINITDEPTH;
+#ifndef YYSTACK_USE_ALLOCA
+  int yyfree_stacks = 0;
+#endif
+
+#ifdef YYPURE
+  int yychar;
+  YYSTYPE yylval;
+  int yynerrs;
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylloc;
+#endif
+#endif
+
+  YYSTYPE yyval;		/*  the variable used to return		*/
+				/*  semantic values from the action	*/
+				/*  routines				*/
+
+  int yylen;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Starting parse\n");
+#endif
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss - 1;
+  yyvsp = yyvs;
+#ifdef YYLSP_NEEDED
+  yylsp = yyls;
+#endif
+
+/* Push a new state, which is found in  yystate  .  */
+/* In all cases, when you get here, the value and location stacks
+   have just been pushed. so pushing a state here evens the stacks.  */
+yynewstate:
+
+  *++yyssp = yystate;
+
+  if (yyssp >= yyss + yystacksize - 1)
+    {
+      /* Give user a chance to reallocate the stack */
+      /* Use copies of these so that the &'s don't force the real ones into memory. */
+      YYSTYPE *yyvs1 = yyvs;
+      short *yyss1 = yyss;
+#ifdef YYLSP_NEEDED
+      YYLTYPE *yyls1 = yyls;
+#endif
+
+      /* Get the current used size of the three stacks, in elements.  */
+      int size = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      /* Each stack pointer address is followed by the size of
+	 the data in use in that stack, in bytes.  */
+#ifdef YYLSP_NEEDED
+      /* This used to be a conditional around just the two extra args,
+	 but that might be undefined if yyoverflow is a macro.  */
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yyls1, size * sizeof (*yylsp),
+		 &yystacksize);
+#else
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yystacksize);
+#endif
+
+      yyss = yyss1; yyvs = yyvs1;
+#ifdef YYLSP_NEEDED
+      yyls = yyls1;
+#endif
+#else /* no yyoverflow */
+      /* Extend the stack our own way.  */
+      if (yystacksize >= YYMAXDEPTH)
+	{
+	  yyerror("parser stack overflow");
+#ifndef YYSTACK_USE_ALLOCA
+	  if (yyfree_stacks)
+	    {
+	      free (yyss);
+	      free (yyvs);
+#ifdef YYLSP_NEEDED
+	      free (yyls);
+#endif
+	    }
+#endif	    
+	  return 2;
+	}
+      yystacksize *= 2;
+      if (yystacksize > YYMAXDEPTH)
+	yystacksize = YYMAXDEPTH;
+#ifndef YYSTACK_USE_ALLOCA
+      yyfree_stacks = 1;
+#endif
+      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
+      __yy_memcpy ((char *)yyss, (char *)yyss1,
+		   size * (unsigned int) sizeof (*yyssp));
+      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
+      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
+		   size * (unsigned int) sizeof (*yyvsp));
+#ifdef YYLSP_NEEDED
+      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
+      __yy_memcpy ((char *)yyls, (char *)yyls1,
+		   size * (unsigned int) sizeof (*yylsp));
+#endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + size - 1;
+      yyvsp = yyvs + size - 1;
+#ifdef YYLSP_NEEDED
+      yylsp = yyls + size - 1;
+#endif
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
+#endif
+
+      if (yyssp >= yyss + yystacksize - 1)
+	YYABORT;
+    }
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Entering state %d\n", yystate);
+#endif
+
+  goto yybackup;
+ yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* yychar is either YYEMPTY or YYEOF
+     or a valid token in external form.  */
+
+  if (yychar == YYEMPTY)
+    {
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Reading a token: ");
+#endif
+      yychar = YYLEX;
+    }
+
+  /* Convert token to internal form (in yychar1) for indexing tables with */
+
+  if (yychar <= 0)		/* This means end of input. */
+    {
+      yychar1 = 0;
+      yychar = YYEOF;		/* Don't call YYLEX any more */
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Now at end of input.\n");
+#endif
+    }
+  else
+    {
+      yychar1 = YYTRANSLATE(yychar);
+
+#if YYDEBUG != 0
+      if (yydebug)
+	{
+	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
+	  /* Give the individual parser a way to print the precise meaning
+	     of a token, for further debugging info.  */
+#ifdef YYPRINT
+	  YYPRINT (stderr, yychar, yylval);
+#endif
+	  fprintf (stderr, ")\n");
+	}
+#endif
+    }
+
+  yyn += yychar1;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+    goto yydefault;
+
+  yyn = yytable[yyn];
+
+  /* yyn is what to do for this token type in this state.
+     Negative => reduce, -yyn is rule number.
+     Positive => shift, yyn is new state.
+       New state is final state => don't bother to shift,
+       just return success.
+     0, or most negative number => error.  */
+
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrlab;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
+#endif
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  /* count tokens shifted since error; after three, turn off error status.  */
+  if (yyerrstatus) yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+/* Do the default action for the current state.  */
+yydefault:
+
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+
+/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+yyreduce:
+  yylen = yyr2[yyn];
+  if (yylen > 0)
+    yyval = yyvsp[1-yylen]; /* implement default value of the action */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      int i;
+
+      fprintf (stderr, "Reducing via rule %d (line %d), ",
+	       yyn, yyrline[yyn]);
+
+      /* Print the symbols being reduced, and their result.  */
+      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
+	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
+      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+    }
+#endif
+
+
+  switch (yyn) {
+
+case 6:
+#line 183 "../../../../libical/src/libical/icalyacc.y"
+{ 
+                  icalparser_yy_value = 0;
+		  icalparser_clear_flex_input();
+                  yyclearin;
+                  ;
+    break;}
+case 7:
+#line 191 "../../../../libical/src/libical/icalyacc.y"
+{
+	    struct icaltimetype stm;
+
+	    stm = fill_datetime(yyvsp[0].v_string,0);
+
+	    stm.hour = -1;
+	    stm.minute = -1;
+	    stm.second = -1;
+	    stm.is_utc = 0;
+	    stm.is_date = 1;
+
+	    icalparser_yy_value = icalvalue_new_date(stm);
+	;
+    break;}
+case 8:
+#line 206 "../../../../libical/src/libical/icalyacc.y"
+{utc = 0;;
+    break;}
+case 9:
+#line 207 "../../../../libical/src/libical/icalyacc.y"
+{utc = 1;;
+    break;}
+case 10:
+#line 211 "../../../../libical/src/libical/icalyacc.y"
+{utc_b = 0;;
+    break;}
+case 11:
+#line 212 "../../../../libical/src/libical/icalyacc.y"
+{utc_b = 1;;
+    break;}
+case 12:
+#line 216 "../../../../libical/src/libical/icalyacc.y"
+{
+	    struct  icaltimetype stm;
+	    stm = fill_datetime(yyvsp[-3].v_string, yyvsp[-1].v_string);
+	    stm.is_utc = utc;
+	    stm.is_date = 0;
+
+	    icalparser_yy_value = 
+		icalvalue_new_datetime(stm);
+	;
+    break;}
+case 15:
+#line 234 "../../../../libical/src/libical/icalyacc.y"
+{
+	    duration.weeks = atoi(yyvsp[-1].v_string);
+	;
+    break;}
+case 16:
+#line 239 "../../../../libical/src/libical/icalyacc.y"
+{
+	;
+    break;}
+case 17:
+#line 242 "../../../../libical/src/libical/icalyacc.y"
+{
+	;
+    break;}
+case 18:
+#line 245 "../../../../libical/src/libical/icalyacc.y"
+{
+	;
+    break;}
+case 19:
+#line 249 "../../../../libical/src/libical/icalyacc.y"
+{
+	    duration.hours = atoi(yyvsp[-1].v_string);
+	;
+    break;}
+case 20:
+#line 253 "../../../../libical/src/libical/icalyacc.y"
+{
+	    duration.hours = atoi(yyvsp[-2].v_string);
+	;
+    break;}
+case 21:
+#line 258 "../../../../libical/src/libical/icalyacc.y"
+{
+	    duration.minutes = atoi(yyvsp[-1].v_string);
+	;
+    break;}
+case 22:
+#line 262 "../../../../libical/src/libical/icalyacc.y"
+{
+	    duration.minutes = atoi(yyvsp[-2].v_string);
+	;
+    break;}
+case 23:
+#line 267 "../../../../libical/src/libical/icalyacc.y"
+{
+	    duration.seconds = atoi(yyvsp[-1].v_string);
+	;
+    break;}
+case 24:
+#line 272 "../../../../libical/src/libical/icalyacc.y"
+{
+	    duration.days = atoi(yyvsp[-1].v_string);
+	;
+    break;}
+case 25:
+#line 277 "../../../../libical/src/libical/icalyacc.y"
+{
+	    duration.is_neg = 0;
+	;
+    break;}
+case 26:
+#line 281 "../../../../libical/src/libical/icalyacc.y"
+{
+	    duration.is_neg = 0;
+	;
+    break;}
+case 27:
+#line 285 "../../../../libical/src/libical/icalyacc.y"
+{ 
+	    duration.is_neg = 1;
+	;
+    break;}
+case 28:
+#line 290 "../../../../libical/src/libical/icalyacc.y"
+{ 
+	    icalparser_yy_value = icalvalue_new_duration(duration); 
+	    memset(&duration,0, sizeof(duration));
+	;
+    break;}
+case 29:
+#line 295 "../../../../libical/src/libical/icalyacc.y"
+{ 
+	    icalparser_yy_value = icalvalue_new_duration(duration); 
+	    memset(&duration,0, sizeof(duration));
+	;
+    break;}
+case 30:
+#line 300 "../../../../libical/src/libical/icalyacc.y"
+{ 
+	    icalparser_yy_value = icalvalue_new_duration(duration); 
+	    memset(&duration,0, sizeof(duration));
+	;
+    break;}
+case 31:
+#line 309 "../../../../libical/src/libical/icalyacc.y"
+{
+            struct icalperiodtype p;
+        
+	    p.start = fill_datetime(yyvsp[-8].v_string,yyvsp[-6].v_string);
+	    p.start.is_utc = utc;
+	    p.start.is_date = 0;
+
+
+	    p.end = fill_datetime(yyvsp[-3].v_string,yyvsp[-1].v_string);
+	    p.end.is_utc = utc_b;
+	    p.end.is_date = 0;
+		
+	    p.duration.days = -1;
+	    p.duration.weeks = -1;
+	    p.duration.hours = -1;
+	    p.duration.minutes = -1;
+	    p.duration.seconds = -1;
+
+	    icalparser_yy_value = icalvalue_new_period(p);
+	;
+    break;}
+case 32:
+#line 330 "../../../../libical/src/libical/icalyacc.y"
+{
+            struct icalperiodtype p;
+	    
+	    p.start = fill_datetime(yyvsp[-5].v_string,yyvsp[-3].v_string);
+	    p.start.is_utc = utc;
+	    p.start.is_date = 0;
+
+	    p.end.year = -1;
+	    p.end.month = -1;
+	    p.end.day = -1;
+	    p.end.hour = -1;
+	    p.end.minute = -1;
+	    p.end.second = -1;
+		   
+	    /* The duration_value rule setes the global 'duration'
+               variable, but it also creates a new value in
+               icalparser_yy_value. So, free that, then copy
+               'duration' into the icalperiodtype struct. */
+
+	    p.duration = icalvalue_get_duration(icalparser_yy_value);
+	    icalvalue_free(icalparser_yy_value);
+	    icalparser_yy_value = 0;
+
+	    icalparser_yy_value = icalvalue_new_period(p);
+
+	;
+    break;}
+case 34:
+#line 364 "../../../../libical/src/libical/icalyacc.y"
+{ utcsign = 1; ;
+    break;}
+case 35:
+#line 365 "../../../../libical/src/libical/icalyacc.y"
+{ utcsign = -1; ;
+    break;}
+case 36:
+#line 369 "../../../../libical/src/libical/icalyacc.y"
+{
+	    icalparser_yy_value = icalvalue_new_utcoffset( utcsign * (yyvsp[-1].v_int*3600) + (yyvsp[0].v_int*60) );
+  	;
+    break;}
+case 37:
+#line 374 "../../../../libical/src/libical/icalyacc.y"
+{
+	    icalparser_yy_value = icalvalue_new_utcoffset(utcsign * (yyvsp[-2].v_int*3600) + (yyvsp[-1].v_int*60) +(yyvsp[0].v_int));
+  	;
+    break;}
+}
+   /* the action file gets copied in in place of this dollarsign */
+#line 554 "/usr/share/bison.simple"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+#ifdef YYLSP_NEEDED
+  yylsp -= yylen;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+  *++yyvsp = yyval;
+
+#ifdef YYLSP_NEEDED
+  yylsp++;
+  if (yylen == 0)
+    {
+      yylsp->first_line = yylloc.first_line;
+      yylsp->first_column = yylloc.first_column;
+      yylsp->last_line = (yylsp-1)->last_line;
+      yylsp->last_column = (yylsp-1)->last_column;
+      yylsp->text = 0;
+    }
+  else
+    {
+      yylsp->last_line = (yylsp+yylen-1)->last_line;
+      yylsp->last_column = (yylsp+yylen-1)->last_column;
+    }
+#endif
+
+  /* Now "shift" the result of the reduction.
+     Determine what state that goes to,
+     based on the state we popped back to
+     and the rule number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
+  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTBASE];
+
+  goto yynewstate;
+
+yyerrlab:   /* here on detecting error */
+
+  if (! yyerrstatus)
+    /* If not already recovering from an error, report this error.  */
+    {
+      ++yynerrs;
+
+#ifdef YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (yyn > YYFLAG && yyn < YYLAST)
+	{
+	  int size = 0;
+	  char *msg;
+	  int x, count;
+
+	  count = 0;
+	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
+	  for (x = (yyn < 0 ? -yyn : 0);
+	       x < (sizeof(yytname) / sizeof(char *)); x++)
+	    if (yycheck[x + yyn] == x)
+	      size += strlen(yytname[x]) + 15, count++;
+	  msg = (char *) malloc(size + 15);
+	  if (msg != 0)
+	    {
+	      strcpy(msg, "parse error");
+
+	      if (count < 5)
+		{
+		  count = 0;
+		  for (x = (yyn < 0 ? -yyn : 0);
+		       x < (sizeof(yytname) / sizeof(char *)); x++)
+		    if (yycheck[x + yyn] == x)
+		      {
+			strcat(msg, count == 0 ? ", expecting `" : " or `");
+			strcat(msg, yytname[x]);
+			strcat(msg, "'");
+			count++;
+		      }
+		}
+	      yyerror(msg);
+	      free(msg);
+	    }
+	  else
+	    yyerror ("parse error; also virtual memory exceeded");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror("parse error");
+    }
+
+  goto yyerrlab1;
+yyerrlab1:   /* here on error raised explicitly by an action */
+
+  if (yyerrstatus == 3)
+    {
+      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+
+      /* return failure if at end of input */
+      if (yychar == YYEOF)
+	YYABORT;
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
+#endif
+
+      yychar = YYEMPTY;
+    }
+
+  /* Else will try to reuse lookahead token
+     after shifting the error token.  */
+
+  yyerrstatus = 3;		/* Each real token shifted decrements this */
+
+  goto yyerrhandle;
+
+yyerrdefault:  /* current state does not do anything special for the error token. */
+
+#if 0
+  /* This is wrong; only states that explicitly want error tokens
+     should shift them.  */
+  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
+  if (yyn) goto yydefault;
+#endif
+
+yyerrpop:   /* pop the current state because it cannot handle the error token */
+
+  if (yyssp == yyss) YYABORT;
+  yyvsp--;
+  yystate = *--yyssp;
+#ifdef YYLSP_NEEDED
+  yylsp--;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "Error: state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+yyerrhandle:
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yyerrdefault;
+
+  yyn += YYTERROR;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
+    goto yyerrdefault;
+
+  yyn = yytable[yyn];
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrpop;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrpop;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting error token, ");
+#endif
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  yystate = yyn;
+  goto yynewstate;
+
+ yyacceptlab:
+  /* YYACCEPT comes here.  */
+#ifndef YYSTACK_USE_ALLOCA
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+#endif
+  return 0;
+
+ yyabortlab:
+  /* YYABORT comes here.  */
+#ifndef YYSTACK_USE_ALLOCA
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+#endif    
+  return 1;
+}
+#line 378 "../../../../libical/src/libical/icalyacc.y"
+
+
+struct icaltimetype fill_datetime(char* datestr, char* timestr)
+{
+	    struct icaltimetype stm;
+
+	    memset(&stm,0,sizeof(stm));
+
+	    if (datestr != 0){
+		sscanf(datestr,"%4d%2d%2d",&(stm.year), &(stm.month), 
+		       &(stm.day));
+	    }
+
+	    if (timestr != 0){
+		sscanf(timestr,"%2d%2d%2d", &(stm.hour), &(stm.minute), 
+		       &(stm.second));
+	    }
+
+	    return stm;
+
+}
+
+void ical_yyerror(char* s)
+{
+    /*fprintf(stderr,"Parse error \'%s\'\n", s);*/
+}
+
--- libical/src/libicalss/.cvsignore	25 Jun 2002 03:18:23 -0000	1.1.1.1
+++ libical/src/libicalss/.cvsignore	6 Oct 2002 03:39:42 -0000	1.2
@@ -30,4 +30,3 @@
 libicalss.la
 y.output
 
-icalsslexer.c
RCS file: libical/src/libicalss/icalsslexer.c
diff -N libical/src/libicalss/icalsslexer.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ libical/src/libicalss/icalsslexer.c	28 Jan 2003 21:35:10 -0000	1.2
@@ -0,0 +1,1705 @@
+#define ss_create_buffer ss_create_buffer
+#define ss_delete_buffer ss_delete_buffer
+#define ss_scan_buffer ss_scan_buffer
+#define ss_scan_string ss_scan_string
+#define ss_scan_bytes ss_scan_bytes
+#define ss_flex_debug ss_flex_debug
+#define ss_init_buffer ss_init_buffer
+#define ss_flush_buffer ss_flush_buffer
+#define ss_load_buffer_state ss_load_buffer_state
+#define ss_switch_to_buffer ss_switch_to_buffer
+#define ssin ssin
+#define ssleng ssleng
+#define sslex sslex
+#define ssout ssout
+#define ssrestart ssrestart
+#define sstext sstext
+#define sswrap sswrap
+
+/* A lexical scanner generated by flex */
+
+/* Scanner skeleton version:
+ * $Header: /Volumes/src/cvs/od/proj/KDE-Darwin/kdepim/libical/src/libicalss/icalsslexer.c,v 1.2 2003/01/28 21:35:10 ranger Exp $
+ */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+
+#include <stdio.h>
+
+
+/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+
+
+#ifdef __cplusplus
+
+#include <stdlib.h>
+#include <unistd.h>
+
+/* Use prototypes in function declarations. */
+#define YY_USE_PROTOS
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_PROTOS
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef __TURBOC__
+ #pragma warn -rch
+ #pragma warn -use
+#include <io.h>
+#include <stdlib.h>
+#define YY_USE_CONST
+#define YY_USE_PROTOS
+#endif
+
+#ifdef YY_USE_CONST
+#define ssconst const
+#else
+#define ssconst
+#endif
+
+
+#ifdef YY_USE_PROTOS
+#define YY_PROTO(proto) proto
+#else
+#define YY_PROTO(proto) ()
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN ss_start = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((ss_start - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE ssrestart( ssin )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#define YY_BUF_SIZE 16384
+
+typedef struct ss_buffer_state *YY_BUFFER_STATE;
+
+extern int ssleng;
+extern FILE *ssin, *ssout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+/* The funky do-while in the following #define is used to turn the definition
+ * int a single C statement (which needs a semi-colon terminator).  This
+ * avoids problems with code like:
+ *
+ * 	if ( condition_holds )
+ *		ssless( 5 );
+ *	else
+ *		do_something_else();
+ *
+ * Prior to using the do-while the compiler would get upset at the
+ * "else" because it interpreted the "if" statement as being all
+ * done when it reached the ';' after the ssless() call.
+ */
+
+/* Return all but the first 'n' matched characters back to the input stream. */
+
+#define ssless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up sstext. */ \
+		*ss_cp = ss_hold_char; \
+		YY_RESTORE_YY_MORE_OFFSET \
+		ss_c_buf_p = ss_cp = ss_bp + n - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up sstext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) ssunput( c, sstext_ptr )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+typedef unsigned int ss_size_t;
+
+
+struct ss_buffer_state
+	{
+	FILE *ss_input_file;
+
+	char *ss_ch_buf;		/* input buffer */
+	char *ss_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	ss_size_t ss_buf_size;
+
+	/* Number of characters read into ss_ch_buf, not including EOB
+	 * characters.
+	 */
+	int ss_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int ss_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int ss_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int ss_at_bol;
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int ss_fill_buffer;
+
+	int ss_buffer_status;
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via ssrestart()), so that the user can continue scanning by
+	 * just pointing ssin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+	};
+
+static YY_BUFFER_STATE ss_current_buffer = 0;
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ */
+#define YY_CURRENT_BUFFER ss_current_buffer
+
+
+/* ss_hold_char holds the character lost when sstext is formed. */
+static char ss_hold_char;
+
+static int ss_n_chars;		/* number of characters read into ss_ch_buf */
+
+
+int ssleng;
+
+/* Points to current character in buffer. */
+static char *ss_c_buf_p = (char *) 0;
+static int ss_init = 1;		/* whether we need to initialize */
+static int ss_start = 0;	/* start state number */
+
+/* Flag which is used to allow sswrap()'s to do buffer switches
+ * instead of setting up a fresh ssin.  A bit of a hack ...
+ */
+static int ss_did_buffer_switch_on_eof;
+
+void ssrestart YY_PROTO(( FILE *input_file ));
+
+void ss_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
+void ss_load_buffer_state YY_PROTO(( void ));
+YY_BUFFER_STATE ss_create_buffer YY_PROTO(( FILE *file, int size ));
+void ss_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+void ss_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
+void ss_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+#define YY_FLUSH_BUFFER ss_flush_buffer( ss_current_buffer )
+
+YY_BUFFER_STATE ss_scan_buffer YY_PROTO(( char *base, ss_size_t size ));
+YY_BUFFER_STATE ss_scan_string YY_PROTO(( ssconst char *ss_str ));
+YY_BUFFER_STATE ss_scan_bytes YY_PROTO(( ssconst char *bytes, int len ));
+
+static void *ss_flex_alloc YY_PROTO(( ss_size_t ));
+static void *ss_flex_realloc YY_PROTO(( void *, ss_size_t ));
+static void ss_flex_free YY_PROTO(( void * ));
+
+#define ss_new_buffer ss_create_buffer
+
+#define ss_set_interactive(is_interactive) \
+	{ \
+	if ( ! ss_current_buffer ) \
+		ss_current_buffer = ss_create_buffer( ssin, YY_BUF_SIZE ); \
+	ss_current_buffer->ss_is_interactive = is_interactive; \
+	}
+
+#define ss_set_bol(at_bol) \
+	{ \
+	if ( ! ss_current_buffer ) \
+		ss_current_buffer = ss_create_buffer( ssin, YY_BUF_SIZE ); \
+	ss_current_buffer->ss_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (ss_current_buffer->ss_at_bol)
+
+typedef unsigned char YY_CHAR;
+FILE *ssin = (FILE *) 0, *ssout = (FILE *) 0;
+typedef int ss_state_type;
+extern char sstext[];
+
+
+static ss_state_type ss_get_previous_state YY_PROTO(( void ));
+static ss_state_type ss_try_NUL_trans YY_PROTO(( ss_state_type current_state ));
+static int ss_get_next_buffer YY_PROTO(( void ));
+static void ss_fatal_error YY_PROTO(( ssconst char msg[] ));
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up sstext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	sstext_ptr = ss_bp; \
+	ssleng = (int) (ss_cp - ss_bp); \
+	ss_hold_char = *ss_cp; \
+	*ss_cp = '\0'; \
+	if ( ssleng >= YYLMAX ) \
+		YY_FATAL_ERROR( "token too large, exceeds YYLMAX" ); \
+	ss_flex_strncpy( sstext, sstext_ptr, ssleng + 1 ); \
+	ss_c_buf_p = ss_cp;
+
+#define YY_NUM_RULES 19
+#define YY_END_OF_BUFFER 20
+static ssconst short int ss_accept[47] =
+    {   0,
+        0,    0,    0,    0,    0,    0,   20,   18,   14,   14,
+       18,   13,   17,    4,   15,    7,    5,    8,   17,   17,
+       17,   17,   17,   14,    6,    0,   17,    9,   10,   17,
+       17,   12,   17,   17,   16,   11,   17,   17,   17,    2,
+       17,   17,   17,    3,    1,    0
+    } ;
+
+static ssconst int ss_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    1,    1,    1,    1,    1,    5,    1,
+        1,    6,    1,    7,    6,    6,    1,    6,    6,    6,
+        6,    6,    6,    6,    6,    6,    6,    1,    8,    9,
+       10,   11,    1,    1,   12,    6,   13,   14,   15,   16,
+        6,   17,    6,    6,    6,   18,   19,   20,   21,    6,
+        6,   22,   23,   24,    6,    6,   25,    6,    6,    6,
+        1,    1,    1,    1,    1,    1,   12,    6,   13,   14,
+
+       15,   16,    6,   17,    6,    6,    6,   18,   19,   20,
+       21,    6,    6,   22,   23,   24,    6,    6,   25,    6,
+        6,    6,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static ssconst int ss_meta[26] =
+    {   0,
+        1,    1,    1,    1,    1,    2,    1,    1,    1,    1,
+        1,    2,    2,    2,    2,    2,    2,    2,    2,    2,
+        2,    2,    2,    2,    2
+    } ;
+
+static ssconst short int ss_base[49] =
+    {   0,
+        0,    0,    0,    0,    0,    0,   53,   54,   24,   26,
+       42,    0,    0,   54,   54,   41,   54,   40,   29,   26,
+       25,   31,   28,   28,   54,   39,    0,   54,   54,   29,
+       21,    0,   23,   25,   54,    0,   20,   23,   15,    0,
+       23,   20,   10,    0,    0,   54,   31,   30
+    } ;
+
+static ssconst short int ss_def[49] =
+    {   0,
+       46,    1,    1,    1,    1,    1,   46,   46,   46,   46,
+       46,   47,   48,   46,   46,   46,   46,   46,   48,   48,
+       48,   48,   48,   46,   46,   47,   48,   46,   46,   48,
+       48,   48,   48,   48,   46,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,    0,   46,   46
+    } ;
+
+static ssconst short int ss_nxt[80] =
+    {   0,
+        8,    9,   10,   11,   12,   13,   14,   15,   16,   17,
+       18,   19,   13,   13,   13,   20,   13,   13,   13,   13,
+       21,   13,   22,   13,   23,   24,   24,   24,   24,   24,
+       24,   27,   26,   45,   44,   43,   42,   41,   40,   39,
+       38,   37,   36,   35,   34,   33,   32,   31,   30,   29,
+       28,   25,   46,    7,   46,   46,   46,   46,   46,   46,
+       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
+       46,   46,   46,   46,   46,   46,   46,   46,   46
+    } ;
+
+static ssconst short int ss_chk[80] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    9,    9,   10,   10,   24,
+       24,   48,   47,   43,   42,   41,   39,   38,   37,   34,
+       33,   31,   30,   26,   23,   22,   21,   20,   19,   18,
+       16,   11,    7,   46,   46,   46,   46,   46,   46,   46,
+       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
+       46,   46,   46,   46,   46,   46,   46,   46,   46
+    } ;
+
+static ss_state_type ss_last_accepting_state;
+static char *ss_last_accepting_cpos;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define ssmore() ssmore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+#ifndef YYLMAX
+#define YYLMAX 8192
+#endif
+
+char sstext[YYLMAX];
+char *sstext_ptr;
+#line 1 "icalsslexer.l"
+#define INITIAL 0
+#line 2 "icalsslexer.l"
+/* -*- Mode: C -*-
+  ======================================================================
+  FILE: icalsslexer.l
+  CREATOR: eric 8 Aug 2000
+  
+  DESCRIPTION:
+  
+  $Id: icalsslexer.c,v 1.2 2003/01/28 21:35:10 ranger Exp $
+  $Locker:  $
+
+(C) COPYRIGHT 2000, Eric Busboom, http://www.softwarestudio.org
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of either: 
+
+    The LGPL as published by the Free Software Foundation, version
+    2.1, available at: http://www.fsf.org/copyleft/lesser.html
+
+  Or:
+
+    The Mozilla Public License Version 1.0. You may obtain a copy of
+    the License at http://www.mozilla.org/MPL/
+
+ The Original Code is eric. The Initial Developer of the Original
+ Code is Eric Busboom
+
+  ======================================================================*/
+
+#include "icalssyacc.h"
+#include "icalgaugeimpl.h"
+#include "assert.h"
+
+#include <string.h> /* For strdup() */
+
+int icalparser_flex_input(char* buf, int max_size);
+void icalparser_clear_flex_input();
+
+#undef YY_INPUT
+#define YY_INPUT(b,r,ms) ( r= icalparser_flex_input(b,ms))
+
+#undef SS_FATAL_ERROR
+#define SS_FATAL_ERROR(msg) sserror(msg)
+
+
+#define sql 1
+#define string_value 2
+
+#line 465 "icalsslexer.c"
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int sswrap YY_PROTO(( void ));
+#else
+extern int sswrap YY_PROTO(( void ));
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+static void ssunput YY_PROTO(( int c, char *buf_ptr ));
+#endif
+
+#ifndef sstext_ptr
+static void ss_flex_strncpy YY_PROTO(( char *, ssconst char *, int ));
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int ss_flex_strlen YY_PROTO(( ssconst char * ));
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int ssinput YY_PROTO(( void ));
+#else
+static int input YY_PROTO(( void ));
+#endif
+#endif
+
+#if YY_STACK_USED
+static int ss_start_stack_ptr = 0;
+static int ss_start_stack_depth = 0;
+static int *ss_start_stack = 0;
+#ifndef YY_NO_PUSH_STATE
+static void ss_push_state YY_PROTO(( int new_state ));
+#endif
+#ifndef YY_NO_POP_STATE
+static void ss_pop_state YY_PROTO(( void ));
+#endif
+#ifndef YY_NO_TOP_STATE
+static int ss_top_state YY_PROTO(( void ));
+#endif
+
+#else
+#define YY_NO_PUSH_STATE 1
+#define YY_NO_POP_STATE 1
+#define YY_NO_TOP_STATE 1
+#endif
+
+#ifdef YY_MALLOC_DECL
+YY_MALLOC_DECL
+#else
+#if __STDC__
+#ifndef __cplusplus
+#include <stdlib.h>
+#endif
+#else
+/* Just try to get by without declaring the routines.  This will fail
+ * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
+ * or sizeof(void*) != sizeof(int).
+ */
+#endif
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( sstext, ssleng, 1, ssout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( ss_current_buffer->ss_is_interactive ) \
+		{ \
+		int c = '*', n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( ssin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( ssin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else if ( ((result = fread( buf, 1, max_size, ssin )) == 0) \
+		  && ferror( ssin ) ) \
+		YY_FATAL_ERROR( "input in flex scanner failed" );
+#endif
+
+/* No semi-colon after return; correct usage is to write "ssterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef ssterminate
+#define ssterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) ss_fatal_error( msg )
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL int sslex YY_PROTO(( void ))
+#endif
+
+/* Code executed at the beginning of each rule, after sstext and ssleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+YY_DECL
+	{
+	register ss_state_type ss_current_state;
+	register char *ss_cp, *ss_bp;
+	register int ss_act;
+
+#line 69 "icalsslexer.l"
+
+
+
+
+
+
+#line 623 "icalsslexer.c"
+
+	if ( ss_init )
+		{
+		ss_init = 0;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! ss_start )
+			ss_start = 1;	/* first start state */
+
+		if ( ! ssin )
+			ssin = stdin;
+
+		if ( ! ssout )
+			ssout = stdout;
+
+		if ( ! ss_current_buffer )
+			ss_current_buffer =
+				ss_create_buffer( ssin, YY_BUF_SIZE );
+
+		ss_load_buffer_state();
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		ss_cp = ss_c_buf_p;
+
+		/* Support of sstext. */
+		*ss_cp = ss_hold_char;
+
+		/* ss_bp points to the position in ss_ch_buf of the start of
+		 * the current run.
+		 */
+		ss_bp = ss_cp;
+
+		ss_current_state = ss_start;
+ss_match:
+		do
+			{
+			register YY_CHAR ss_c = ss_ec[YY_SC_TO_UI(*ss_cp)];
+			if ( ss_accept[ss_current_state] )
+				{
+				ss_last_accepting_state = ss_current_state;
+				ss_last_accepting_cpos = ss_cp;
+				}
+			while ( ss_chk[ss_base[ss_current_state] + ss_c] != ss_current_state )
+				{
+				ss_current_state = (int) ss_def[ss_current_state];
+				if ( ss_current_state >= 47 )
+					ss_c = ss_meta[(unsigned int) ss_c];
+				}
+			ss_current_state = ss_nxt[ss_base[ss_current_state] + (unsigned int) ss_c];
+			++ss_cp;
+			}
+		while ( ss_base[ss_current_state] != 54 );
+
+ss_find_action:
+		ss_act = ss_accept[ss_current_state];
+		if ( ss_act == 0 )
+			{ /* have to back up */
+			ss_cp = ss_last_accepting_cpos;
+			ss_current_state = ss_last_accepting_state;
+			ss_act = ss_accept[ss_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+
+do_action:	/* This label is used only to access EOF actions. */
+
+
+		switch ( ss_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*ss_cp = ss_hold_char;
+			ss_cp = ss_last_accepting_cpos;
+			ss_current_state = ss_last_accepting_state;
+			goto ss_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 75 "icalsslexer.l"
+{ return SELECT; }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 76 "icalsslexer.l"
+{ return FROM; }
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 77 "icalsslexer.l"
+{ return WHERE; }
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 78 "icalsslexer.l"
+{ return COMMA; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 79 "icalsslexer.l"
+{ return EQUALS; }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 80 "icalsslexer.l"
+{ return NOTEQUALS; }
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 81 "icalsslexer.l"
+{ return LESS; }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 82 "icalsslexer.l"
+{ return GREATER; }
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 83 "icalsslexer.l"
+{ return LESSEQUALS; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 84 "icalsslexer.l"
+{ return GREATEREQUALS; }
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 85 "icalsslexer.l"
+{ return AND; }
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 86 "icalsslexer.l"
+{ return OR; }
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 87 "icalsslexer.l"
+{ return QUOTE; }
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 88 "icalsslexer.l"
+;			
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 89 "icalsslexer.l"
+{ return EOL; }
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 90 "icalsslexer.l"
+{
+	int c = input();
+	unput(c);
+	if(c!='\''){
+		sslval.v_string= icalmemory_tmp_copy(sstext);
+		return STRING;
+	} else {
+		/*ssmore();*/
+	}
+}
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 101 "icalsslexer.l"
+{ sslval.v_string= icalmemory_tmp_copy(sstext);
+			  return STRING; }
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 105 "icalsslexer.l"
+{ return sstext[0]; }
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 107 "icalsslexer.l"
+ECHO;
+	YY_BREAK
+#line 811 "icalsslexer.c"
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(sql):
+case YY_STATE_EOF(string_value):
+	ssterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int ss_amount_of_matched_text = (int) (ss_cp - sstext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*ss_cp = ss_hold_char;
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( ss_current_buffer->ss_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed ssin at a new source and called
+			 * sslex().  If so, then we have to assure
+			 * consistency between ss_current_buffer and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			ss_n_chars = ss_current_buffer->ss_n_chars;
+			ss_current_buffer->ss_input_file = ssin;
+			ss_current_buffer->ss_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for ss_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since ss_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( ss_c_buf_p <= &ss_current_buffer->ss_ch_buf[ss_n_chars] )
+			{ /* This was really a NUL. */
+			ss_state_type ss_next_state;
+
+			ss_c_buf_p = sstext_ptr + ss_amount_of_matched_text;
+
+			ss_current_state = ss_get_previous_state();
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * ss_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			ss_next_state = ss_try_NUL_trans( ss_current_state );
+
+			ss_bp = sstext_ptr + YY_MORE_ADJ;
+
+			if ( ss_next_state )
+				{
+				/* Consume the NUL. */
+				ss_cp = ++ss_c_buf_p;
+				ss_current_state = ss_next_state;
+				goto ss_match;
+				}
+
+			else
+				{
+				ss_cp = ss_c_buf_p;
+				goto ss_find_action;
+				}
+			}
+
+		else switch ( ss_get_next_buffer() )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				ss_did_buffer_switch_on_eof = 0;
+
+				if ( sswrap() )
+					{
+					/* Note: because we've taken care in
+					 * ss_get_next_buffer() to have set up
+					 * sstext, we can now set up
+					 * ss_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					ss_c_buf_p = sstext_ptr + YY_MORE_ADJ;
+
+					ss_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! ss_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				ss_c_buf_p =
+					sstext_ptr + ss_amount_of_matched_text;
+
+				ss_current_state = ss_get_previous_state();
+
+				ss_cp = ss_c_buf_p;
+				ss_bp = sstext_ptr + YY_MORE_ADJ;
+				goto ss_match;
+
+			case EOB_ACT_LAST_MATCH:
+				ss_c_buf_p =
+				&ss_current_buffer->ss_ch_buf[ss_n_chars];
+
+				ss_current_state = ss_get_previous_state();
+
+				ss_cp = ss_c_buf_p;
+				ss_bp = sstext_ptr + YY_MORE_ADJ;
+				goto ss_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of sslex */
+
+
+/* ss_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+
+static int ss_get_next_buffer()
+	{
+	register char *dest = ss_current_buffer->ss_ch_buf;
+	register char *source = sstext_ptr;
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( ss_c_buf_p > &ss_current_buffer->ss_ch_buf[ss_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( ss_current_buffer->ss_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( ss_c_buf_p - sstext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (ss_c_buf_p - sstext_ptr) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( ss_current_buffer->ss_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		ss_current_buffer->ss_n_chars = ss_n_chars = 0;
+
+	else
+		{
+		int num_to_read =
+			ss_current_buffer->ss_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+#ifdef YY_USES_REJECT
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+#else
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = ss_current_buffer;
+
+			int ss_c_buf_p_offset =
+				(int) (ss_c_buf_p - b->ss_ch_buf);
+
+			if ( b->ss_is_our_buffer )
+				{
+				int new_size = b->ss_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->ss_buf_size += b->ss_buf_size / 8;
+				else
+					b->ss_buf_size *= 2;
+
+				b->ss_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					ss_flex_realloc( (void *) b->ss_ch_buf,
+							 b->ss_buf_size + 2 );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->ss_ch_buf = 0;
+
+			if ( ! b->ss_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			ss_c_buf_p = &b->ss_ch_buf[ss_c_buf_p_offset];
+
+			num_to_read = ss_current_buffer->ss_buf_size -
+						number_to_move - 1;
+#endif
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&ss_current_buffer->ss_ch_buf[number_to_move]),
+			ss_n_chars, num_to_read );
+
+		ss_current_buffer->ss_n_chars = ss_n_chars;
+		}
+
+	if ( ss_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			ssrestart( ssin );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			ss_current_buffer->ss_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	ss_n_chars += number_to_move;
+	ss_current_buffer->ss_ch_buf[ss_n_chars] = YY_END_OF_BUFFER_CHAR;
+	ss_current_buffer->ss_ch_buf[ss_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	sstext_ptr = &ss_current_buffer->ss_ch_buf[0];
+
+	return ret_val;
+	}
+
+
+/* ss_get_previous_state - get the state just before the EOB char was reached */
+
+static ss_state_type ss_get_previous_state()
+	{
+	register ss_state_type ss_current_state;
+	register char *ss_cp;
+
+	ss_current_state = ss_start;
+
+	for ( ss_cp = sstext_ptr + YY_MORE_ADJ; ss_cp < ss_c_buf_p; ++ss_cp )
+		{
+		register YY_CHAR ss_c = (*ss_cp ? ss_ec[YY_SC_TO_UI(*ss_cp)] : 1);
+		if ( ss_accept[ss_current_state] )
+			{
+			ss_last_accepting_state = ss_current_state;
+			ss_last_accepting_cpos = ss_cp;
+			}
+		while ( ss_chk[ss_base[ss_current_state] + ss_c] != ss_current_state )
+			{
+			ss_current_state = (int) ss_def[ss_current_state];
+			if ( ss_current_state >= 47 )
+				ss_c = ss_meta[(unsigned int) ss_c];
+			}
+		ss_current_state = ss_nxt[ss_base[ss_current_state] + (unsigned int) ss_c];
+		}
+
+	return ss_current_state;
+	}
+
+
+/* ss_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = ss_try_NUL_trans( current_state );
+ */
+
+#ifdef YY_USE_PROTOS
+static ss_state_type ss_try_NUL_trans( ss_state_type ss_current_state )
+#else
+static ss_state_type ss_try_NUL_trans( ss_current_state )
+ss_state_type ss_current_state;
+#endif
+	{
+	register int ss_is_jam;
+	register char *ss_cp = ss_c_buf_p;
+
+	register YY_CHAR ss_c = 1;
+	if ( ss_accept[ss_current_state] )
+		{
+		ss_last_accepting_state = ss_current_state;
+		ss_last_accepting_cpos = ss_cp;
+		}
+	while ( ss_chk[ss_base[ss_current_state] + ss_c] != ss_current_state )
+		{
+		ss_current_state = (int) ss_def[ss_current_state];
+		if ( ss_current_state >= 47 )
+			ss_c = ss_meta[(unsigned int) ss_c];
+		}
+	ss_current_state = ss_nxt[ss_base[ss_current_state] + (unsigned int) ss_c];
+	ss_is_jam = (ss_current_state == 46);
+
+	return ss_is_jam ? 0 : ss_current_state;
+	}
+
+
+#ifndef YY_NO_UNPUT
+#ifdef YY_USE_PROTOS
+static void ssunput( int c, register char *ss_bp )
+#else
+static void ssunput( c, ss_bp )
+int c;
+register char *ss_bp;
+#endif
+	{
+	register char *ss_cp = ss_c_buf_p;
+
+	/* undo effects of setting up sstext */
+	*ss_cp = ss_hold_char;
+
+	if ( ss_cp < ss_current_buffer->ss_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = ss_n_chars + 2;
+		register char *dest = &ss_current_buffer->ss_ch_buf[
+					ss_current_buffer->ss_buf_size + 2];
+		register char *source =
+				&ss_current_buffer->ss_ch_buf[number_to_move];
+
+		while ( source > ss_current_buffer->ss_ch_buf )
+			*--dest = *--source;
+
+		ss_cp += (int) (dest - source);
+		ss_bp += (int) (dest - source);
+		ss_current_buffer->ss_n_chars =
+			ss_n_chars = ss_current_buffer->ss_buf_size;
+
+		if ( ss_cp < ss_current_buffer->ss_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--ss_cp = (char) c;
+
+
+	sstext_ptr = ss_bp;
+	ss_hold_char = *ss_cp;
+	ss_c_buf_p = ss_cp;
+	}
+#endif	/* ifndef YY_NO_UNPUT */
+
+
+#ifdef __cplusplus
+static int ssinput()
+#else
+static int input()
+#endif
+	{
+	int c;
+
+	*ss_c_buf_p = ss_hold_char;
+
+	if ( *ss_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* ss_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( ss_c_buf_p < &ss_current_buffer->ss_ch_buf[ss_n_chars] )
+			/* This was really a NUL. */
+			*ss_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			int offset = ss_c_buf_p - sstext_ptr;
+			++ss_c_buf_p;
+
+			switch ( ss_get_next_buffer() )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because ss_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					ssrestart( ssin );
+
+					/* fall through */
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( sswrap() )
+						return EOF;
+
+					if ( ! ss_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return ssinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					ss_c_buf_p = sstext_ptr + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) ss_c_buf_p;	/* cast for 8-bit char's */
+	*ss_c_buf_p = '\0';	/* preserve sstext */
+	ss_hold_char = *++ss_c_buf_p;
+
+
+	return c;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void ssrestart( FILE *input_file )
+#else
+void ssrestart( input_file )
+FILE *input_file;
+#endif
+	{
+	if ( ! ss_current_buffer )
+		ss_current_buffer = ss_create_buffer( ssin, YY_BUF_SIZE );
+
+	ss_init_buffer( ss_current_buffer, input_file );
+	ss_load_buffer_state();
+	}
+
+
+#ifdef YY_USE_PROTOS
+void ss_switch_to_buffer( YY_BUFFER_STATE new_buffer )
+#else
+void ss_switch_to_buffer( new_buffer )
+YY_BUFFER_STATE new_buffer;
+#endif
+	{
+	if ( ss_current_buffer == new_buffer )
+		return;
+
+	if ( ss_current_buffer )
+		{
+		/* Flush out information for old buffer. */
+		*ss_c_buf_p = ss_hold_char;
+		ss_current_buffer->ss_buf_pos = ss_c_buf_p;
+		ss_current_buffer->ss_n_chars = ss_n_chars;
+		}
+
+	ss_current_buffer = new_buffer;
+	ss_load_buffer_state();
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (sswrap()) processing, but the only time this flag
+	 * is looked at is after sswrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	ss_did_buffer_switch_on_eof = 1;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void ss_load_buffer_state( void )
+#else
+void ss_load_buffer_state()
+#endif
+	{
+	ss_n_chars = ss_current_buffer->ss_n_chars;
+	sstext_ptr = ss_c_buf_p = ss_current_buffer->ss_buf_pos;
+	ssin = ss_current_buffer->ss_input_file;
+	ss_hold_char = *ss_c_buf_p;
+	}
+
+
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE ss_create_buffer( FILE *file, int size )
+#else
+YY_BUFFER_STATE ss_create_buffer( file, size )
+FILE *file;
+int size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	b = (YY_BUFFER_STATE) ss_flex_alloc( sizeof( struct ss_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ss_create_buffer()" );
+
+	b->ss_buf_size = size;
+
+	/* ss_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->ss_ch_buf = (char *) ss_flex_alloc( b->ss_buf_size + 2 );
+	if ( ! b->ss_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ss_create_buffer()" );
+
+	b->ss_is_our_buffer = 1;
+
+	ss_init_buffer( b, file );
+
+	return b;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void ss_delete_buffer( YY_BUFFER_STATE b )
+#else
+void ss_delete_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+	{
+	if ( ! b )
+		return;
+
+	if ( b == ss_current_buffer )
+		ss_current_buffer = (YY_BUFFER_STATE) 0;
+
+	if ( b->ss_is_our_buffer )
+		ss_flex_free( (void *) b->ss_ch_buf );
+
+	ss_flex_free( (void *) b );
+	}
+
+
+#ifndef YY_ALWAYS_INTERACTIVE
+#ifndef YY_NEVER_INTERACTIVE
+extern int isatty YY_PROTO(( int ));
+#endif
+#endif
+
+#ifdef YY_USE_PROTOS
+void ss_init_buffer( YY_BUFFER_STATE b, FILE *file )
+#else
+void ss_init_buffer( b, file )
+YY_BUFFER_STATE b;
+FILE *file;
+#endif
+
+
+	{
+	ss_flush_buffer( b );
+
+	b->ss_input_file = file;
+	b->ss_fill_buffer = 1;
+
+#if YY_ALWAYS_INTERACTIVE
+	b->ss_is_interactive = 1;
+#else
+#if YY_NEVER_INTERACTIVE
+	b->ss_is_interactive = 0;
+#else
+	b->ss_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+#endif
+#endif
+	}
+
+
+#ifdef YY_USE_PROTOS
+void ss_flush_buffer( YY_BUFFER_STATE b )
+#else
+void ss_flush_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+
+	{
+	if ( ! b )
+		return;
+
+	b->ss_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->ss_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->ss_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->ss_buf_pos = &b->ss_ch_buf[0];
+
+	b->ss_at_bol = 1;
+	b->ss_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == ss_current_buffer )
+		ss_load_buffer_state();
+	}
+
+
+#ifndef YY_NO_SCAN_BUFFER
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE ss_scan_buffer( char *base, ss_size_t size )
+#else
+YY_BUFFER_STATE ss_scan_buffer( base, size )
+char *base;
+ss_size_t size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) ss_flex_alloc( sizeof( struct ss_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ss_scan_buffer()" );
+
+	b->ss_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->ss_buf_pos = b->ss_ch_buf = base;
+	b->ss_is_our_buffer = 0;
+	b->ss_input_file = 0;
+	b->ss_n_chars = b->ss_buf_size;
+	b->ss_is_interactive = 0;
+	b->ss_at_bol = 1;
+	b->ss_fill_buffer = 0;
+	b->ss_buffer_status = YY_BUFFER_NEW;
+
+	ss_switch_to_buffer( b );
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_STRING
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE ss_scan_string( ssconst char *ss_str )
+#else
+YY_BUFFER_STATE ss_scan_string( ss_str )
+ssconst char *ss_str;
+#endif
+	{
+	int len;
+	for ( len = 0; ss_str[len]; ++len )
+		;
+
+	return ss_scan_bytes( ss_str, len );
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_BYTES
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE ss_scan_bytes( ssconst char *bytes, int len )
+#else
+YY_BUFFER_STATE ss_scan_bytes( bytes, len )
+ssconst char *bytes;
+int len;
+#endif
+	{
+	YY_BUFFER_STATE b;
+	char *buf;
+	ss_size_t n;
+	int i;
+
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = len + 2;
+	buf = (char *) ss_flex_alloc( n );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ss_scan_bytes()" );
+
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
+
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = ss_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in ss_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->ss_is_our_buffer = 1;
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_PUSH_STATE
+#ifdef YY_USE_PROTOS
+static void ss_push_state( int new_state )
+#else
+static void ss_push_state( new_state )
+int new_state;
+#endif
+	{
+	if ( ss_start_stack_ptr >= ss_start_stack_depth )
+		{
+		ss_size_t new_size;
+
+		ss_start_stack_depth += YY_START_STACK_INCR;
+		new_size = ss_start_stack_depth * sizeof( int );
+
+		if ( ! ss_start_stack )
+			ss_start_stack = (int *) ss_flex_alloc( new_size );
+
+		else
+			ss_start_stack = (int *) ss_flex_realloc(
+					(void *) ss_start_stack, new_size );
+
+		if ( ! ss_start_stack )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
+
+	ss_start_stack[ss_start_stack_ptr++] = YY_START;
+
+	BEGIN(new_state);
+	}
+#endif
+
+
+#ifndef YY_NO_POP_STATE
+static void ss_pop_state()
+	{
+	if ( --ss_start_stack_ptr < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
+
+	BEGIN(ss_start_stack[ss_start_stack_ptr]);
+	}
+#endif
+
+
+#ifndef YY_NO_TOP_STATE
+static int ss_top_state()
+	{
+	return ss_start_stack[ss_start_stack_ptr - 1];
+	}
+#endif
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+#ifdef YY_USE_PROTOS
+static void ss_fatal_error( ssconst char msg[] )
+#else
+static void ss_fatal_error( msg )
+char msg[];
+#endif
+	{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+	}
+
+
+
+/* Redefine ssless() so it works in section 3 code. */
+
+#undef ssless
+#define ssless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up sstext. */ \
+		sstext[ssleng] = ss_hold_char; \
+		ss_c_buf_p = sstext + n; \
+		ss_hold_char = *ss_c_buf_p; \
+		*ss_c_buf_p = '\0'; \
+		ssleng = n; \
+		} \
+	while ( 0 )
+
+
+/* Internal utility routines. */
+
+#ifndef sstext_ptr
+#ifdef YY_USE_PROTOS
+static void ss_flex_strncpy( char *s1, ssconst char *s2, int n )
+#else
+static void ss_flex_strncpy( s1, s2, n )
+char *s1;
+ssconst char *s2;
+int n;
+#endif
+	{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+	}
+#endif
+
+#ifdef YY_NEED_STRLEN
+#ifdef YY_USE_PROTOS
+static int ss_flex_strlen( ssconst char *s )
+#else
+static int ss_flex_strlen( s )
+ssconst char *s;
+#endif
+	{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+	}
+#endif
+
+
+#ifdef YY_USE_PROTOS
+static void *ss_flex_alloc( ss_size_t size )
+#else
+static void *ss_flex_alloc( size )
+ss_size_t size;
+#endif
+	{
+	return (void *) malloc( size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void *ss_flex_realloc( void *ptr, ss_size_t size )
+#else
+static void *ss_flex_realloc( ptr, size )
+void *ptr;
+ss_size_t size;
+#endif
+	{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void ss_flex_free( void *ptr )
+#else
+static void ss_flex_free( ptr )
+void *ptr;
+#endif
+	{
+	free( ptr );
+	}
+
+#if YY_MAIN
+int main()
+	{
+	sslex();
+	return 0;
+	}
+#endif
+#line 107 "icalsslexer.l"
+
+
+int sswrap()
+{
+     return 1;
+}
+
--- libkcal/Makefile.am	29 Oct 2002 18:09:14 -0000	1.1.1.4
+++ libkcal/Makefile.am	29 Nov 2002 19:01:22 -0000	1.2
@@ -5,7 +5,7 @@
   -I$(top_builddir)/libical/src/libicalss -I$(srcdir)/versit $(all_includes)
 
 lib_LTLIBRARIES   = libkcal.la
-libkcal_la_LDFLAGS = $(all_libraries) -no-undefined -version-info 2:0:0 -module
+libkcal_la_LDFLAGS = $(all_libraries) -no-undefined -version-info 2:0:0
 libkcal_la_LIBADD  = $(LIB_QT) versit/libversit.la $(LIB_KFILE) \
                      $(top_builddir)/libical/src/libical/libical.la \
                      $(top_builddir)/libical/src/libicalss/libicalss.la
--- libkcal/versit/vcc.c	25 Jun 2002 03:18:24 -0000	1.1.1.1
+++ libkcal/versit/vcc.c	6 Oct 2002 04:36:30 -0000	1.2
@@ -125,7 +125,7 @@
 #endif
 
 #include <string.h>
-#ifndef __FreeBSD__
+#if !defined(__FreeBSD__) && !defined(__APPLE__)
 #include <malloc.h>
 #endif
 #include <stdio.h>
--- libkdepim/Makefile.am	29 Oct 2002 18:09:16 -0000	1.1.1.4
+++ libkdepim/Makefile.am	29 Nov 2002 19:01:22 -0000	1.2
@@ -9,7 +9,7 @@
   categoryeditdialog_base.ui categoryeditdialog.cpp \
   kdateedit.cpp kimportdialog.cpp kvcarddrag.cpp
 
-libkdepim_la_LDFLAGS = $(all_libraries) -no-undefined -version-info 1:0:0 -module
+libkdepim_la_LDFLAGS = $(all_libraries) -no-undefined -version-info 1:0:0
 libkdepim_la_LIBADD  = $(top_builddir)/libkdepim/resources/libkpimresources.la $(LIB_KIO) 
 
 METASOURCES = AUTO
--- libkpimexchange/Makefile.am	29 Oct 2002 18:09:16 -0000	1.1.1.3
+++ libkpimexchange/Makefile.am	1 Dec 2002 17:02:08 -0000	1.2
@@ -9,7 +9,7 @@
 lib_LTLIBRARIES = libkpimexchange.la
 
 libkpimexchange_la_SOURCES = dummy.cpp
-libkpimexchange_la_LDFLAGS = $(all_libraries) -no-undefined -version-info 1:0:0 -module
+libkpimexchange_la_LDFLAGS = $(all_libraries) -no-undefined -version-info 1:0:0
 libkpimexchange_la_LIBADD = core/libkpimexchangecore.la calendar/libkpimexchangecalendar.la \
 			    $(LIB_KIO) $(top_builddir)/libkcal/libkcal.la 
 
