diff --git a/offlineimap/imapserver.py b/offlineimap/imapserver.py
index 4e37ece..ac39b77 100644
--- a/offlineimap/imapserver.py
+++ b/offlineimap/imapserver.py
@@ -23,6 +23,8 @@ from threading import *
 import thread, hmac, os
 import base64
 
+from StringIO import StringIO
+
 try:
     # do we have a recent pykerberos?
     have_gss = False
@@ -60,10 +62,38 @@ class UsefulIMAP4(UsefulIMAPMixIn, imaplib.IMAP4):
     def open(self, host = '', port = imaplib.IMAP4_PORT):
         imaplibutil.new_open(self, host, port)
 
+    # This is a hack to go around Darwin's implementation of
+    # realloc(), which Python uses inside the socket class. If a message
+    # is larger than 1M, we get it piece by piece instead of all at
+    # once.
+
+    def read(self, size):
+        read = 0
+        io = StringIO()
+        while read < size:
+            tmp = size-read
+            if (tmp>1000000): tmp=1000000
+            data = self.file.read(tmp)
+            read += len(data)
+            io.write(data)
+        return io.getvalue()
+
 class UsefulIMAP4_SSL(UsefulIMAPMixIn, imaplibutil.WrappedIMAP4_SSL):
     def open(self, host = '', port = imaplib.IMAP4_SSL_PORT):
         imaplibutil.new_open_ssl(self, host, port)
 
+    # This is the same thing as above, except we can be a little bit
+    # more clever by avoiding the socket class altogether.
+
+    def read(self, size):
+        read = 0
+        io = StringIO()
+        while read < size:
+            data = self.sslobj.read(size-read)
+            read += len(data)
+            io.write(data)
+        return io.getvalue()
+
 class UsefulIMAP4_Tunnel(UsefulIMAPMixIn, imaplibutil.IMAP4_Tunnel): pass
 
 class IMAPServer:
