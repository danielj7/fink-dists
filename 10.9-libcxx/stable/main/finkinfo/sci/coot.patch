diff -Nurd -x'*~' coot-0.8.6.orig/configure coot-0.8.6/configure
--- coot-0.8.6.orig/configure	2016-08-18 07:43:31.000000000 -0400
+++ coot-0.8.6/configure	2016-10-30 17:10:09.000000000 -0400
@@ -19938,6 +19938,11 @@
 
   rm -f conf.gtkgltest
 
+  # Uses Glu directly, but assumes gtlgkext propagates its flags; but
+  # gtkglext might not publish them if they're not part of its API.
+  GTKGLEXT_CFLAGS="$GTKGLEXT_CFLAGS `$PKG_CONFIG --cflags glu`"
+  GTKGLEXT_LIBS="$GTKGLEXT_LIBS `$PKG_CONFIG --libs glu`"
+
 MAKE_COOTRC_CMD="sed -e 's/\#GTK2 //' "
 
 
diff -ruN coot-0.8.7/Makefile.in coot-0.8.8-pre/Makefile.in
--- coot-0.8.7/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/Makefile.in	2017-01-25 14:39:06.000000000 -0800
@@ -65,6 +65,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -259,6 +262,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/RELEASE-NOTES coot-0.8.8-pre/RELEASE-NOTES
--- coot-0.8.7/RELEASE-NOTES	2016-11-08 07:55:17.000000000 -0800
+++ coot-0.8.8-pre/RELEASE-NOTES	2017-01-25 14:34:21.000000000 -0800
@@ -1,5 +1,26 @@
 
 ------
+
+  Pre-release 0.8.8
+
+  o FEATURE: Modern compilers will multi-thread multiple map contouring
+
+  o CHANGE:  delete residue range speeded up [Oliver Clarke]
+
+  o CHANGE:  PG4 added to other solvent ligands
+
+  o CHANGE:  Solid model lighting adjusted
+
+  o BUG-FIX: Colour by B-factor and Occupancy modes restored [Hans Raaijmakers]
+
+  o BUG-FIX: network interface to Drugbank follows server changes
+
+  o BUG-FIX: Fix the PNG image output limits from lidia
+
+  o BUG-FIX: Refmac monomer library is restored (after server crash)
+
+  o BUG-FIX: Use XYP not XYL for carbohydrate tree additions
+
 ------
 
   Release 0.8.7
diff -ruN coot-0.8.7/aclocal.m4 coot-0.8.8-pre/aclocal.m4
--- coot-0.8.7/aclocal.m4	2016-11-08 07:55:20.000000000 -0800
+++ coot-0.8.8-pre/aclocal.m4	2017-01-24 09:37:57.000000000 -0800
@@ -1502,6 +1502,9 @@
 m4_include([macros/aclocal-include.m4])
 m4_include([macros/ax_boost_base.m4])
 m4_include([macros/ax_boost_python.m4])
+m4_include([macros/ax_cxx_compile_stdcxx.m4])
+m4_include([macros/ax_cxx_compile_stdcxx_11.m4])
+m4_include([macros/ax_cxx_have_thread.m4])
 m4_include([macros/ax_openmp.m4])
 m4_include([macros/ax_python_devel.m4])
 m4_include([macros/ccp4srs.m4])
diff -ruN coot-0.8.7/analysis/Makefile.in coot-0.8.8-pre/analysis/Makefile.in
--- coot-0.8.7/analysis/Makefile.in	2016-11-08 07:55:21.000000000 -0800
+++ coot-0.8.8-pre/analysis/Makefile.in	2017-01-25 14:39:04.000000000 -0800
@@ -45,6 +45,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -243,6 +246,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/angles/Makefile.in coot-0.8.8-pre/angles/Makefile.in
--- coot-0.8.7/angles/Makefile.in	2016-11-08 07:55:21.000000000 -0800
+++ coot-0.8.8-pre/angles/Makefile.in	2017-01-25 14:39:04.000000000 -0800
@@ -41,6 +41,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -212,6 +215,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/auxil/Makefile.in coot-0.8.8-pre/auxil/Makefile.in
--- coot-0.8.7/auxil/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/auxil/Makefile.in	2017-01-25 14:39:04.000000000 -0800
@@ -39,6 +39,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -191,6 +194,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/auxil/catcheck/Makefile.in coot-0.8.8-pre/auxil/catcheck/Makefile.in
--- coot-0.8.7/auxil/catcheck/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/auxil/catcheck/Makefile.in	2017-01-25 14:39:04.000000000 -0800
@@ -40,6 +40,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -180,6 +183,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/auxil/rama/Makefile.in coot-0.8.8-pre/auxil/rama/Makefile.in
--- coot-0.8.7/auxil/rama/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/auxil/rama/Makefile.in	2017-01-25 14:39:04.000000000 -0800
@@ -40,6 +40,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -175,6 +178,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/auxil/sec-str/Makefile.in coot-0.8.8-pre/auxil/sec-str/Makefile.in
--- coot-0.8.7/auxil/sec-str/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/auxil/sec-str/Makefile.in	2017-01-25 14:39:04.000000000 -0800
@@ -39,6 +39,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -151,6 +154,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/auxil/strand-analysis/Makefile.in coot-0.8.8-pre/auxil/strand-analysis/Makefile.in
--- coot-0.8.7/auxil/strand-analysis/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/auxil/strand-analysis/Makefile.in	2017-01-25 14:39:04.000000000 -0800
@@ -40,6 +40,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -152,6 +155,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/auxil/vectors/Makefile.in coot-0.8.8-pre/auxil/vectors/Makefile.in
--- coot-0.8.7/auxil/vectors/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/auxil/vectors/Makefile.in	2017-01-25 14:39:04.000000000 -0800
@@ -40,6 +40,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -152,6 +155,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/build/Makefile.in coot-0.8.8-pre/build/Makefile.in
--- coot-0.8.7/build/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/build/Makefile.in	2017-01-25 14:39:04.000000000 -0800
@@ -62,6 +62,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -228,6 +231,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/ccp4mg-utils/Makefile.in coot-0.8.8-pre/ccp4mg-utils/Makefile.in
--- coot-0.8.7/ccp4mg-utils/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/ccp4mg-utils/Makefile.in	2017-01-25 14:39:04.000000000 -0800
@@ -61,6 +61,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -221,6 +224,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/compat/Makefile.in coot-0.8.8-pre/compat/Makefile.in
--- coot-0.8.7/compat/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/compat/Makefile.in	2017-01-25 14:39:04.000000000 -0800
@@ -41,6 +41,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -196,6 +199,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/configure coot-0.8.8-pre/configure
--- coot-0.8.7/configure	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/configure	2017-01-25 14:39:06.000000000 -0800
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.63 for coot 0.8.7.
+# Generated by GNU Autoconf 2.63 for coot 0.8.8-pre.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@@ -743,8 +743,8 @@
 # Identity of this package.
 PACKAGE_NAME='coot'
 PACKAGE_TARNAME='coot'
-PACKAGE_VERSION='0.8.7'
-PACKAGE_STRING='coot 0.8.7'
+PACKAGE_VERSION='0.8.8-pre'
+PACKAGE_STRING='coot 0.8.8-pre'
 PACKAGE_BUGREPORT=''
 
 ac_unique_file="src/main.cc"
@@ -885,6 +885,7 @@
 PKG_CONFIG
 EXPORT_DYNAMIC_FLAG_SPEC
 COOT_STDTYPES
+HAVE_CXX11
 cxxflags_set
 cflags_set
 CXXCPP
@@ -1014,6 +1015,7 @@
 enable_iso_c
 enable_cxx_warnings
 enable_iso_cxx
+with_modern_language_tools
 with_glob_prefix
 with_sqlite3
 with_gpp4
@@ -1615,7 +1617,7 @@
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures coot 0.8.7 to adapt to many kinds of systems.
+\`configure' configures coot 0.8.8-pre to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1685,7 +1687,7 @@
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of coot 0.8.7:";;
+     short | recursive ) echo "Configuration of coot 0.8.8-pre:";;
    esac
   cat <<\_ACEOF
 
@@ -1713,6 +1715,7 @@
   --with-pic              try to use only PIC/non-PIC objects [default=use
                           both]
   --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
+  --with-modern-language-tools with optional experimental features
   --with-glob-prefix=PFX Prefix where glob can been found
   --with-sqlite3 (optional)
   --with-gpp4             Build with the gpp4 library (default is NO)
@@ -1840,7 +1843,7 @@
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-coot configure 0.8.7
+coot configure 0.8.8-pre
 generated by GNU Autoconf 2.63
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
@@ -1854,7 +1857,7 @@
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by coot $as_me 0.8.7, which was
+It was created by coot $as_me 0.8.8-pre, which was
 generated by GNU Autoconf 2.63.  Invocation command line was
 
   $ $0 $@
@@ -2704,7 +2707,7 @@
 
 # Define the identity of the package.
  PACKAGE='coot'
- VERSION='0.8.7'
+ VERSION='0.8.8-pre'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -6401,13 +6404,13 @@
 else
   lt_cv_nm_interface="BSD nm"
   echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:6404: $ac_compile\"" >&5)
+  (eval echo "\"\$as_me:6407: $ac_compile\"" >&5)
   (eval "$ac_compile" 2>conftest.err)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:6407: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval echo "\"\$as_me:6410: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
   (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:6410: output\"" >&5)
+  (eval echo "\"\$as_me:6413: output\"" >&5)
   cat conftest.out >&5
   if $GREP 'External.*some_variable' conftest.out > /dev/null; then
     lt_cv_nm_interface="MS dumpbin"
@@ -7612,7 +7615,7 @@
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 7615 "configure"' > conftest.$ac_ext
+  echo '#line 7618 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -9792,11 +9795,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:9795: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:9798: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:9799: \$? = $ac_status" >&5
+   echo "$as_me:9802: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -10131,11 +10134,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:10134: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:10137: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:10138: \$? = $ac_status" >&5
+   echo "$as_me:10141: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -10236,11 +10239,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:10239: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:10242: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:10243: \$? = $ac_status" >&5
+   echo "$as_me:10246: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -10291,11 +10294,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:10294: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:10297: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:10298: \$? = $ac_status" >&5
+   echo "$as_me:10301: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -13094,7 +13097,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 13097 "configure"
+#line 13100 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -13190,7 +13193,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 13193 "configure"
+#line 13196 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15210,11 +15213,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:15213: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:15216: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:15217: \$? = $ac_status" >&5
+   echo "$as_me:15220: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -15309,11 +15312,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:15312: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:15315: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:15316: \$? = $ac_status" >&5
+   echo "$as_me:15319: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -15361,11 +15364,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:15364: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:15367: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:15368: \$? = $ac_status" >&5
+   echo "$as_me:15371: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -16493,9 +16496,9 @@
 # we need to make the src and pyrogen directories if they do not exist
 if test ! -d src     ; then mkdir src     ; fi
 if test ! -d pyrogen ; then mkdir pyrogen ; fi
-echo 'extern "C" { int git_revision_count() { return 6498 ; } }' > src/git-revision-count.cc
+echo 'extern "C" { int git_revision_count() { return 6603 ; } }' > src/git-revision-count.cc
 echo 'def revision_count():'             > pyrogen/coot_git.py
-echo '    return ' 6498 >> pyrogen/coot_git.py
+echo '    return ' 6603 >> pyrogen/coot_git.py
 
 
 for ac_header in sys/stdtypes.h
@@ -16745,6 +16748,1161 @@
 
 
 
+# Check whether --with-modern-language-tools was given.
+if test "${with_modern_language_tools+set}" = set; then
+  withval=$with_modern_language_tools; coot_modern_language_tools="true"
+else
+  coot_modern_language_tools="false"
+fi
+
+
+if $coot_modern_language_tools = true ; then
+     ax_cxx_compile_alternatives="11 0x"    ax_cxx_compile_cxx11_required=true
+  ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+  ac_success=no
+  { $as_echo "$as_me:$LINENO: checking whether $CXX supports C++11 features by default" >&5
+$as_echo_n "checking whether $CXX supports C++11 features by default... " >&6; }
+if test "${ax_cv_cxx_compile_cxx11+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+// If the compiler admits that it is not ready for C++11, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus < 201103L
+
+#error "This is not a C++11 compiler"
+
+#else
+
+namespace cxx11
+{
+
+  namespace test_static_assert
+  {
+
+    template <typename T>
+    struct check
+    {
+      static_assert(sizeof(int) <= sizeof(T), "not big enough");
+    };
+
+  }
+
+  namespace test_final_override
+  {
+
+    struct Base
+    {
+      virtual void f() {}
+    };
+
+    struct Derived : public Base
+    {
+      virtual void f() override {}
+    };
+
+  }
+
+  namespace test_double_right_angle_brackets
+  {
+
+    template < typename T >
+    struct check {};
+
+    typedef check<void> single_type;
+    typedef check<check<void>> double_type;
+    typedef check<check<check<void>>> triple_type;
+    typedef check<check<check<check<void>>>> quadruple_type;
+
+  }
+
+  namespace test_decltype
+  {
+
+    int
+    f()
+    {
+      int a = 1;
+      decltype(a) b = 2;
+      return a + b;
+    }
+
+  }
+
+  namespace test_type_deduction
+  {
+
+    template < typename T1, typename T2 >
+    struct is_same
+    {
+      static const bool value = false;
+    };
+
+    template < typename T >
+    struct is_same<T, T>
+    {
+      static const bool value = true;
+    };
+
+    template < typename T1, typename T2 >
+    auto
+    add(T1 a1, T2 a2) -> decltype(a1 + a2)
+    {
+      return a1 + a2;
+    }
+
+    int
+    test(const int c, volatile int v)
+    {
+      static_assert(is_same<int, decltype(0)>::value == true, "");
+      static_assert(is_same<int, decltype(c)>::value == false, "");
+      static_assert(is_same<int, decltype(v)>::value == false, "");
+      auto ac = c;
+      auto av = v;
+      auto sumi = ac + av + 'x';
+      auto sumf = ac + av + 1.0;
+      static_assert(is_same<int, decltype(ac)>::value == true, "");
+      static_assert(is_same<int, decltype(av)>::value == true, "");
+      static_assert(is_same<int, decltype(sumi)>::value == true, "");
+      static_assert(is_same<int, decltype(sumf)>::value == false, "");
+      static_assert(is_same<int, decltype(add(c, v))>::value == true, "");
+      return (sumf > 0.0) ? sumi : add(c, v);
+    }
+
+  }
+
+  namespace test_noexcept
+  {
+
+    int f() { return 0; }
+    int g() noexcept { return 0; }
+
+    static_assert(noexcept(f()) == false, "");
+    static_assert(noexcept(g()) == true, "");
+
+  }
+
+  namespace test_constexpr
+  {
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept
+    {
+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;
+    }
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c(const CharT *const s) noexcept
+    {
+      return strlen_c_r(s, 0UL);
+    }
+
+    static_assert(strlen_c("") == 0UL, "");
+    static_assert(strlen_c("1") == 1UL, "");
+    static_assert(strlen_c("example") == 7UL, "");
+    static_assert(strlen_c("another\0example") == 7UL, "");
+
+  }
+
+  namespace test_rvalue_references
+  {
+
+    template < int N >
+    struct answer
+    {
+      static constexpr int value = N;
+    };
+
+    answer<1> f(int&)       { return answer<1>(); }
+    answer<2> f(const int&) { return answer<2>(); }
+    answer<3> f(int&&)      { return answer<3>(); }
+
+    void
+    test()
+    {
+      int i = 0;
+      const int c = 0;
+      static_assert(decltype(f(i))::value == 1, "");
+      static_assert(decltype(f(c))::value == 2, "");
+      static_assert(decltype(f(0))::value == 3, "");
+    }
+
+  }
+
+  namespace test_uniform_initialization
+  {
+
+    struct test
+    {
+      static const int zero {};
+      static const int one {1};
+    };
+
+    static_assert(test::zero == 0, "");
+    static_assert(test::one == 1, "");
+
+  }
+
+  namespace test_lambdas
+  {
+
+    void
+    test1()
+    {
+      auto lambda1 = [](){};
+      auto lambda2 = lambda1;
+      lambda1();
+      lambda2();
+    }
+
+    int
+    test2()
+    {
+      auto a = [](int i, int j){ return i + j; }(1, 2);
+      auto b = []() -> int { return '0'; }();
+      auto c = [=](){ return a + b; }();
+      auto d = [&](){ return c; }();
+      auto e = [a, &b](int x) mutable {
+        const auto identity = [](int y){ return y; };
+        for (auto i = 0; i < a; ++i)
+          a += b--;
+        return x + identity(a + b);
+      }(0);
+      return a + b + c + d + e;
+    }
+
+    int
+    test3()
+    {
+      const auto nullary = [](){ return 0; };
+      const auto unary = [](int x){ return x; };
+      using nullary_t = decltype(nullary);
+      using unary_t = decltype(unary);
+      const auto higher1st = [](nullary_t f){ return f(); };
+      const auto higher2nd = [unary](nullary_t f1){
+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };
+      };
+      return higher1st(nullary) + higher2nd(nullary)(unary);
+    }
+
+  }
+
+  namespace test_variadic_templates
+  {
+
+    template <int...>
+    struct sum;
+
+    template <int N0, int... N1toN>
+    struct sum<N0, N1toN...>
+    {
+      static constexpr auto value = N0 + sum<N1toN...>::value;
+    };
+
+    template <>
+    struct sum<>
+    {
+      static constexpr auto value = 0;
+    };
+
+    static_assert(sum<>::value == 0, "");
+    static_assert(sum<1>::value == 1, "");
+    static_assert(sum<23>::value == 23, "");
+    static_assert(sum<1, 2>::value == 3, "");
+    static_assert(sum<5, 5, 11>::value == 21, "");
+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, "");
+
+  }
+
+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae
+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function
+  // because of this.
+  namespace test_template_alias_sfinae
+  {
+
+    struct foo {};
+
+    template<typename T>
+    using member = typename T::member_type;
+
+    template<typename T>
+    void func(...) {}
+
+    template<typename T>
+    void func(member<T>*) {}
+
+    void test();
+
+    void test() { func<foo>(0); }
+
+  }
+
+}  // namespace cxx11
+
+#endif  // __cplusplus >= 201103L
+
+
+
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ax_cv_cxx_compile_cxx11=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ax_cv_cxx_compile_cxx11=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ax_cv_cxx_compile_cxx11" >&5
+$as_echo "$ax_cv_cxx_compile_cxx11" >&6; }
+  if test x$ax_cv_cxx_compile_cxx11 = xyes; then
+    ac_success=yes
+  fi
+
+    if test x$ac_success = xno; then
+    for alternative in ${ax_cxx_compile_alternatives}; do
+      switch="-std=gnu++${alternative}"
+      cachevar=`$as_echo "ax_cv_cxx_compile_cxx11_$switch" | $as_tr_sh`
+      { $as_echo "$as_me:$LINENO: checking whether $CXX supports C++11 features with $switch" >&5
+$as_echo_n "checking whether $CXX supports C++11 features with $switch... " >&6; }
+if { as_var=$cachevar; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_CXX="$CXX"
+         CXX="$CXX $switch"
+         cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+// If the compiler admits that it is not ready for C++11, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus < 201103L
+
+#error "This is not a C++11 compiler"
+
+#else
+
+namespace cxx11
+{
+
+  namespace test_static_assert
+  {
+
+    template <typename T>
+    struct check
+    {
+      static_assert(sizeof(int) <= sizeof(T), "not big enough");
+    };
+
+  }
+
+  namespace test_final_override
+  {
+
+    struct Base
+    {
+      virtual void f() {}
+    };
+
+    struct Derived : public Base
+    {
+      virtual void f() override {}
+    };
+
+  }
+
+  namespace test_double_right_angle_brackets
+  {
+
+    template < typename T >
+    struct check {};
+
+    typedef check<void> single_type;
+    typedef check<check<void>> double_type;
+    typedef check<check<check<void>>> triple_type;
+    typedef check<check<check<check<void>>>> quadruple_type;
+
+  }
+
+  namespace test_decltype
+  {
+
+    int
+    f()
+    {
+      int a = 1;
+      decltype(a) b = 2;
+      return a + b;
+    }
+
+  }
+
+  namespace test_type_deduction
+  {
+
+    template < typename T1, typename T2 >
+    struct is_same
+    {
+      static const bool value = false;
+    };
+
+    template < typename T >
+    struct is_same<T, T>
+    {
+      static const bool value = true;
+    };
+
+    template < typename T1, typename T2 >
+    auto
+    add(T1 a1, T2 a2) -> decltype(a1 + a2)
+    {
+      return a1 + a2;
+    }
+
+    int
+    test(const int c, volatile int v)
+    {
+      static_assert(is_same<int, decltype(0)>::value == true, "");
+      static_assert(is_same<int, decltype(c)>::value == false, "");
+      static_assert(is_same<int, decltype(v)>::value == false, "");
+      auto ac = c;
+      auto av = v;
+      auto sumi = ac + av + 'x';
+      auto sumf = ac + av + 1.0;
+      static_assert(is_same<int, decltype(ac)>::value == true, "");
+      static_assert(is_same<int, decltype(av)>::value == true, "");
+      static_assert(is_same<int, decltype(sumi)>::value == true, "");
+      static_assert(is_same<int, decltype(sumf)>::value == false, "");
+      static_assert(is_same<int, decltype(add(c, v))>::value == true, "");
+      return (sumf > 0.0) ? sumi : add(c, v);
+    }
+
+  }
+
+  namespace test_noexcept
+  {
+
+    int f() { return 0; }
+    int g() noexcept { return 0; }
+
+    static_assert(noexcept(f()) == false, "");
+    static_assert(noexcept(g()) == true, "");
+
+  }
+
+  namespace test_constexpr
+  {
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept
+    {
+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;
+    }
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c(const CharT *const s) noexcept
+    {
+      return strlen_c_r(s, 0UL);
+    }
+
+    static_assert(strlen_c("") == 0UL, "");
+    static_assert(strlen_c("1") == 1UL, "");
+    static_assert(strlen_c("example") == 7UL, "");
+    static_assert(strlen_c("another\0example") == 7UL, "");
+
+  }
+
+  namespace test_rvalue_references
+  {
+
+    template < int N >
+    struct answer
+    {
+      static constexpr int value = N;
+    };
+
+    answer<1> f(int&)       { return answer<1>(); }
+    answer<2> f(const int&) { return answer<2>(); }
+    answer<3> f(int&&)      { return answer<3>(); }
+
+    void
+    test()
+    {
+      int i = 0;
+      const int c = 0;
+      static_assert(decltype(f(i))::value == 1, "");
+      static_assert(decltype(f(c))::value == 2, "");
+      static_assert(decltype(f(0))::value == 3, "");
+    }
+
+  }
+
+  namespace test_uniform_initialization
+  {
+
+    struct test
+    {
+      static const int zero {};
+      static const int one {1};
+    };
+
+    static_assert(test::zero == 0, "");
+    static_assert(test::one == 1, "");
+
+  }
+
+  namespace test_lambdas
+  {
+
+    void
+    test1()
+    {
+      auto lambda1 = [](){};
+      auto lambda2 = lambda1;
+      lambda1();
+      lambda2();
+    }
+
+    int
+    test2()
+    {
+      auto a = [](int i, int j){ return i + j; }(1, 2);
+      auto b = []() -> int { return '0'; }();
+      auto c = [=](){ return a + b; }();
+      auto d = [&](){ return c; }();
+      auto e = [a, &b](int x) mutable {
+        const auto identity = [](int y){ return y; };
+        for (auto i = 0; i < a; ++i)
+          a += b--;
+        return x + identity(a + b);
+      }(0);
+      return a + b + c + d + e;
+    }
+
+    int
+    test3()
+    {
+      const auto nullary = [](){ return 0; };
+      const auto unary = [](int x){ return x; };
+      using nullary_t = decltype(nullary);
+      using unary_t = decltype(unary);
+      const auto higher1st = [](nullary_t f){ return f(); };
+      const auto higher2nd = [unary](nullary_t f1){
+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };
+      };
+      return higher1st(nullary) + higher2nd(nullary)(unary);
+    }
+
+  }
+
+  namespace test_variadic_templates
+  {
+
+    template <int...>
+    struct sum;
+
+    template <int N0, int... N1toN>
+    struct sum<N0, N1toN...>
+    {
+      static constexpr auto value = N0 + sum<N1toN...>::value;
+    };
+
+    template <>
+    struct sum<>
+    {
+      static constexpr auto value = 0;
+    };
+
+    static_assert(sum<>::value == 0, "");
+    static_assert(sum<1>::value == 1, "");
+    static_assert(sum<23>::value == 23, "");
+    static_assert(sum<1, 2>::value == 3, "");
+    static_assert(sum<5, 5, 11>::value == 21, "");
+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, "");
+
+  }
+
+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae
+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function
+  // because of this.
+  namespace test_template_alias_sfinae
+  {
+
+    struct foo {};
+
+    template<typename T>
+    using member = typename T::member_type;
+
+    template<typename T>
+    void func(...) {}
+
+    template<typename T>
+    void func(member<T>*) {}
+
+    void test();
+
+    void test() { func<foo>(0); }
+
+  }
+
+}  // namespace cxx11
+
+#endif  // __cplusplus >= 201103L
+
+
+
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  eval $cachevar=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval $cachevar=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+         CXX="$ac_save_CXX"
+fi
+ac_res=`eval 'as_val=${'$cachevar'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+      if eval test x\$$cachevar = xyes; then
+        CXX="$CXX $switch"
+        if test -n "$CXXCPP" ; then
+          CXXCPP="$CXXCPP $switch"
+        fi
+        ac_success=yes
+        break
+      fi
+    done
+  fi
+
+    if test x$ac_success = xno; then
+                for alternative in ${ax_cxx_compile_alternatives}; do
+      for switch in -std=c++${alternative} +std=c++${alternative} "-h std=c++${alternative}"; do
+        cachevar=`$as_echo "ax_cv_cxx_compile_cxx11_$switch" | $as_tr_sh`
+        { $as_echo "$as_me:$LINENO: checking whether $CXX supports C++11 features with $switch" >&5
+$as_echo_n "checking whether $CXX supports C++11 features with $switch... " >&6; }
+if { as_var=$cachevar; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_CXX="$CXX"
+           CXX="$CXX $switch"
+           cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+// If the compiler admits that it is not ready for C++11, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus < 201103L
+
+#error "This is not a C++11 compiler"
+
+#else
+
+namespace cxx11
+{
+
+  namespace test_static_assert
+  {
+
+    template <typename T>
+    struct check
+    {
+      static_assert(sizeof(int) <= sizeof(T), "not big enough");
+    };
+
+  }
+
+  namespace test_final_override
+  {
+
+    struct Base
+    {
+      virtual void f() {}
+    };
+
+    struct Derived : public Base
+    {
+      virtual void f() override {}
+    };
+
+  }
+
+  namespace test_double_right_angle_brackets
+  {
+
+    template < typename T >
+    struct check {};
+
+    typedef check<void> single_type;
+    typedef check<check<void>> double_type;
+    typedef check<check<check<void>>> triple_type;
+    typedef check<check<check<check<void>>>> quadruple_type;
+
+  }
+
+  namespace test_decltype
+  {
+
+    int
+    f()
+    {
+      int a = 1;
+      decltype(a) b = 2;
+      return a + b;
+    }
+
+  }
+
+  namespace test_type_deduction
+  {
+
+    template < typename T1, typename T2 >
+    struct is_same
+    {
+      static const bool value = false;
+    };
+
+    template < typename T >
+    struct is_same<T, T>
+    {
+      static const bool value = true;
+    };
+
+    template < typename T1, typename T2 >
+    auto
+    add(T1 a1, T2 a2) -> decltype(a1 + a2)
+    {
+      return a1 + a2;
+    }
+
+    int
+    test(const int c, volatile int v)
+    {
+      static_assert(is_same<int, decltype(0)>::value == true, "");
+      static_assert(is_same<int, decltype(c)>::value == false, "");
+      static_assert(is_same<int, decltype(v)>::value == false, "");
+      auto ac = c;
+      auto av = v;
+      auto sumi = ac + av + 'x';
+      auto sumf = ac + av + 1.0;
+      static_assert(is_same<int, decltype(ac)>::value == true, "");
+      static_assert(is_same<int, decltype(av)>::value == true, "");
+      static_assert(is_same<int, decltype(sumi)>::value == true, "");
+      static_assert(is_same<int, decltype(sumf)>::value == false, "");
+      static_assert(is_same<int, decltype(add(c, v))>::value == true, "");
+      return (sumf > 0.0) ? sumi : add(c, v);
+    }
+
+  }
+
+  namespace test_noexcept
+  {
+
+    int f() { return 0; }
+    int g() noexcept { return 0; }
+
+    static_assert(noexcept(f()) == false, "");
+    static_assert(noexcept(g()) == true, "");
+
+  }
+
+  namespace test_constexpr
+  {
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept
+    {
+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;
+    }
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c(const CharT *const s) noexcept
+    {
+      return strlen_c_r(s, 0UL);
+    }
+
+    static_assert(strlen_c("") == 0UL, "");
+    static_assert(strlen_c("1") == 1UL, "");
+    static_assert(strlen_c("example") == 7UL, "");
+    static_assert(strlen_c("another\0example") == 7UL, "");
+
+  }
+
+  namespace test_rvalue_references
+  {
+
+    template < int N >
+    struct answer
+    {
+      static constexpr int value = N;
+    };
+
+    answer<1> f(int&)       { return answer<1>(); }
+    answer<2> f(const int&) { return answer<2>(); }
+    answer<3> f(int&&)      { return answer<3>(); }
+
+    void
+    test()
+    {
+      int i = 0;
+      const int c = 0;
+      static_assert(decltype(f(i))::value == 1, "");
+      static_assert(decltype(f(c))::value == 2, "");
+      static_assert(decltype(f(0))::value == 3, "");
+    }
+
+  }
+
+  namespace test_uniform_initialization
+  {
+
+    struct test
+    {
+      static const int zero {};
+      static const int one {1};
+    };
+
+    static_assert(test::zero == 0, "");
+    static_assert(test::one == 1, "");
+
+  }
+
+  namespace test_lambdas
+  {
+
+    void
+    test1()
+    {
+      auto lambda1 = [](){};
+      auto lambda2 = lambda1;
+      lambda1();
+      lambda2();
+    }
+
+    int
+    test2()
+    {
+      auto a = [](int i, int j){ return i + j; }(1, 2);
+      auto b = []() -> int { return '0'; }();
+      auto c = [=](){ return a + b; }();
+      auto d = [&](){ return c; }();
+      auto e = [a, &b](int x) mutable {
+        const auto identity = [](int y){ return y; };
+        for (auto i = 0; i < a; ++i)
+          a += b--;
+        return x + identity(a + b);
+      }(0);
+      return a + b + c + d + e;
+    }
+
+    int
+    test3()
+    {
+      const auto nullary = [](){ return 0; };
+      const auto unary = [](int x){ return x; };
+      using nullary_t = decltype(nullary);
+      using unary_t = decltype(unary);
+      const auto higher1st = [](nullary_t f){ return f(); };
+      const auto higher2nd = [unary](nullary_t f1){
+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };
+      };
+      return higher1st(nullary) + higher2nd(nullary)(unary);
+    }
+
+  }
+
+  namespace test_variadic_templates
+  {
+
+    template <int...>
+    struct sum;
+
+    template <int N0, int... N1toN>
+    struct sum<N0, N1toN...>
+    {
+      static constexpr auto value = N0 + sum<N1toN...>::value;
+    };
+
+    template <>
+    struct sum<>
+    {
+      static constexpr auto value = 0;
+    };
+
+    static_assert(sum<>::value == 0, "");
+    static_assert(sum<1>::value == 1, "");
+    static_assert(sum<23>::value == 23, "");
+    static_assert(sum<1, 2>::value == 3, "");
+    static_assert(sum<5, 5, 11>::value == 21, "");
+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, "");
+
+  }
+
+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae
+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function
+  // because of this.
+  namespace test_template_alias_sfinae
+  {
+
+    struct foo {};
+
+    template<typename T>
+    using member = typename T::member_type;
+
+    template<typename T>
+    void func(...) {}
+
+    template<typename T>
+    void func(member<T>*) {}
+
+    void test();
+
+    void test() { func<foo>(0); }
+
+  }
+
+}  // namespace cxx11
+
+#endif  // __cplusplus >= 201103L
+
+
+
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  eval $cachevar=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval $cachevar=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+           CXX="$ac_save_CXX"
+fi
+ac_res=`eval 'as_val=${'$cachevar'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+        if eval test x\$$cachevar = xyes; then
+          CXX="$CXX $switch"
+          if test -n "$CXXCPP" ; then
+            CXXCPP="$CXXCPP $switch"
+          fi
+          ac_success=yes
+          break
+        fi
+      done
+      if test x$ac_success = xyes; then
+        break
+      fi
+    done
+  fi
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+  if test x$ax_cxx_compile_cxx11_required = xtrue; then
+    if test x$ac_success = xno; then
+      { { $as_echo "$as_me:$LINENO: error: *** A compiler with support for C++11 language features is required." >&5
+$as_echo "$as_me: error: *** A compiler with support for C++11 language features is required." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+  if test x$ac_success = xno; then
+    HAVE_CXX11=0
+    { $as_echo "$as_me:$LINENO: No compiler with C++11 support was found" >&5
+$as_echo "$as_me: No compiler with C++11 support was found" >&6;}
+  else
+    HAVE_CXX11=1
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_CXX11 1
+_ACEOF
+
+  fi
+
+
+
+   { $as_echo "$as_me:$LINENO: checking for std::thread in thread" >&5
+$as_echo_n "checking for std::thread in thread... " >&6; }
+if test "${ax_cv_cxx_have_thread+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+        ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+      cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+          #include <thread>
+          using namespace std;
+          thread t;
+
+int
+main ()
+{
+
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ax_cv_cxx_have_thread=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ax_cv_cxx_have_thread=no
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ax_cv_cxx_have_thread" >&5
+$as_echo "$ax_cv_cxx_have_thread" >&6; }
+    if test x"$ax_cv_cxx_have_thread" = "xyes"
+    then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_CXX_THREAD 1
+_ACEOF
+
+    fi
+
+fi
+
+
                   acl_libdirstem=lib
   searchpath=`(LC_ALL=C $CC -print-search-dirs) 2>/dev/null | sed -n -e 's,^libraries: ,,p' | sed -e 's,^=,,'`
   if test -n "$searchpath"; then
@@ -22402,7 +23560,7 @@
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by coot $as_me 0.8.7, which was
+This file was extended by coot $as_me 0.8.8-pre, which was
 generated by GNU Autoconf 2.63.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -22456,7 +23614,7 @@
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-coot config.status 0.8.7
+coot config.status 0.8.8-pre
 configured by $0, generated by GNU Autoconf 2.63,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff -ruN coot-0.8.7/configure.ac coot-0.8.8-pre/configure.ac
--- coot-0.8.7/configure.ac	2016-11-08 07:55:17.000000000 -0800
+++ coot-0.8.8-pre/configure.ac	2017-01-24 09:37:54.000000000 -0800
@@ -25,7 +25,7 @@
 dnl
 dnl Process this file with autoconf to produce a configure script.
 
-AC_INIT(coot, 0.8.7)
+AC_INIT(coot, 0.8.8-pre)
 AC_CONFIG_SRCDIR(src/main.cc)
 AM_INIT_AUTOMAKE
 
@@ -69,6 +69,15 @@
 dnl AC_OPENMP
 AX_OPENMP
 
+AC_ARG_WITH(modern-language-tools, [  --with-modern-language-tools with optional experimental features ],
+ coot_modern_language_tools="true",
+ coot_modern_language_tools="false")
+
+if $coot_modern_language_tools = true ; then
+   AX_CXX_COMPILE_STDCXX_11
+   AX_CXX_HAVE_THREAD
+fi
+
 AC_LIB_PREPARE_MULTILIB
 
 AC_SUBST(COOT_STDTYPES)
diff -ruN coot-0.8.7/coords/Bond_lines.cc coot-0.8.8-pre/coords/Bond_lines.cc
--- coot-0.8.7/coords/Bond_lines.cc	2016-10-23 20:10:15.000000000 -0700
+++ coot-0.8.8-pre/coords/Bond_lines.cc	2017-01-23 10:30:03.000000000 -0800
@@ -41,6 +41,8 @@
 #include "Bond_lines.h"
 #include "coot-utils/coot-coord-utils.hh"
 
+#include "geometry/protein-donor-acceptors.hh"
+
 
 static std::string b_factor_bonds_scale_handle_name = "B-factor-bonds-scale";
 
@@ -231,7 +233,7 @@
 						    int udd_handle) {
 
    mmdb::Contact *contact = NULL;
-   int ncontacts;
+   int ncontacts = 0;
    long i_contact_group = 1;
 
    // matrix stuff
@@ -270,7 +272,7 @@
    // in mmdb's MakeBricks (or something like that) from here, that's
    // because we are passing an atom that has a nan for a coordinate.
 
-   if (0) { 
+   if (false) {
       std::cout << "Seeking contact: selection 1 " << std::endl;
       for (int ii=0; ii<n_selected_atoms_1; ii++)
 	 std::cout << "   " << ii << " " << atom_selection_1[ii] << " :"
@@ -293,195 +295,201 @@
 
    if (ncontacts > 0) {
 
-      std::vector<std::pair<bool, mmdb::Residue *> > het_residues; // bond these separately.
-      std::vector<std::pair<bool, mmdb::Residue *> > hoh_residues; // that have O and Hs.
+      if (contact) {
+
+	 if (false)
+	    for (int i=0; i< ncontacts; i++)
+	       std::cout << "contact " << i << " " << contact[i].id1 << " " << contact[i].id2
+			 << std::endl;
+
+	 std::vector<std::pair<bool, mmdb::Residue *> > het_residues; // bond these separately.
+	 std::vector<std::pair<bool, mmdb::Residue *> > hoh_residues; // that have O and Hs.
       
-      for (int i=0; i< ncontacts; i++) {
+	 for (int i=0; i< ncontacts; i++) {
 
- 	 if (are_different_atom_selections ||
- 	      (contact[i].id2 > contact[i].id1) ) {
+	    if (are_different_atom_selections || (contact[i].id2 > contact[i].id1) ) {
 
-	    mmdb::Atom *atom_p_1 = atom_selection_1[ contact[i].id1 ];
-	    mmdb::Atom *atom_p_2 = atom_selection_2[ contact[i].id2 ];
+	       mmdb::Atom *atom_p_1 = atom_selection_1[ contact[i].id1 ];
+	       mmdb::Atom *atom_p_2 = atom_selection_2[ contact[i].id2 ];
 
-	    std::string chain_id1(atom_p_1->GetChainID());
-	    std::string chain_id2(atom_p_2->GetChainID());
+	       std::string chain_id1(atom_p_1->GetChainID());
+	       std::string chain_id2(atom_p_2->GetChainID());
 
-	    std::string aloc_1(atom_p_1->altLoc);
-	    std::string aloc_2(atom_p_2->altLoc);
+	       std::string aloc_1(atom_p_1->altLoc);
+	       std::string aloc_2(atom_p_2->altLoc);
 
-	    element_1 = atom_p_1->element;
-	    element_2 = atom_p_2->element;
+	       element_1 = atom_p_1->element;
+	       element_2 = atom_p_2->element;
 
-	    coot::Cartesian atom_1_pos(atom_p_1->x, atom_p_1->y, atom_p_1->z);
-	    coot::Cartesian atom_2_pos(atom_p_2->x, atom_p_2->y, atom_p_2->z);
+	       coot::Cartesian atom_1_pos(atom_p_1->x, atom_p_1->y, atom_p_1->z);
+	       coot::Cartesian atom_2_pos(atom_p_2->x, atom_p_2->y, atom_p_2->z);
 
-	    if (chain_id1 == chain_id2) {
+	       if (chain_id1 == chain_id2) {
 
-	       // alternate location test
-	       // 
-	       if ( (aloc_1=="") || (aloc_2=="") || (aloc_1==aloc_2) ) {
+		  // alternate location test
+		  // 
+		  if ( (aloc_1=="") || (aloc_2=="") || (aloc_1==aloc_2) ) {
 
-		  int res_1 = atom_p_1->GetSeqNum();
-		  int res_2 = atom_p_2->GetSeqNum();
+		     int res_1 = atom_p_1->GetSeqNum();
+		     int res_2 = atom_p_2->GetSeqNum();
 
-		  bool bond_het_residue_by_dictionary =
-		     add_bond_by_dictionary_maybe(imol, atom_p_1, atom_p_2, &het_residues); // add to het_residues maybe
+		     bool bond_het_residue_by_dictionary =
+			add_bond_by_dictionary_maybe(imol, atom_p_1, atom_p_2, &het_residues); // add to het_residues maybe
 
-		  if (0)
-		     std::cout << atom_p_1 <<  " " << atom_p_2 << " bonded by dictionary: "
-			       << bond_het_residue_by_dictionary << std::endl;
+		     if (0)
+			std::cout << atom_p_1 <<  " " << atom_p_2 << " bonded by dictionary: "
+				  << bond_het_residue_by_dictionary << std::endl;
 		  
-		  if (bond_het_residue_by_dictionary) {
+		     if (bond_het_residue_by_dictionary) {
 		     
-		     std::string res_name = atom_p_1->GetResName();
-		     if (res_name == "HOH" || res_name == "DOD")
-			add_bond_by_dictionary_maybe(imol, atom_p_1, atom_p_2, &hoh_residues);
+			std::string res_name = atom_p_1->GetResName();
+			if (res_name == "HOH" || res_name == "DOD")
+			   add_bond_by_dictionary_maybe(imol, atom_p_1, atom_p_2, &hoh_residues);
 		     
-		  } else { 
+		     } else { 
 
-		     // this +/- 1 residue test, or are DUM atoms.
+			// this +/- 1 residue test, or are DUM atoms.
 
-		     bool is_neighbour = false;
-		     if (labs(res_1 - res_2) < 2)
-			is_neighbour = true;
-		     if (! is_neighbour)
-			if (labs(atom_p_1->residue->index - atom_p_2->residue->index) < 2)
+			bool is_neighbour = false;
+			if (labs(res_1 - res_2) < 2)
 			   is_neighbour = true;
+			if (! is_neighbour)
+			   if (labs(atom_p_1->residue->index - atom_p_2->residue->index) < 2)
+			      is_neighbour = true;
 
-		     // Maybe DUM-DUM needs it's own bonding selection and drawing function
+			// Maybe DUM-DUM needs it's own bonding selection and drawing function
 		     
-// 		     if (! is_neighbour)
-// 			if (strncmp(atom_p_1->name, "DUM", 3))
-// 			   if (strncmp(atom_p_2->name, "DUM", 3))
-// 			      is_neighbour = true;
+			// 		     if (! is_neighbour)
+			// 			if (strncmp(atom_p_1->name, "DUM", 3))
+			// 			   if (strncmp(atom_p_2->name, "DUM", 3))
+			// 			      is_neighbour = true;
 		     
-		     if (is_neighbour) {
+			if (is_neighbour) {
 
-			//  		  std::cout << "Adding bond " << atom_selection_1[ contact[i].id1 ]
-			//  			    << " to "
-			//  			    << atom_selection_2[ contact[i].id2 ] << std::endl;
+			   //  		  std::cout << "Adding bond " << atom_selection_1[ contact[i].id1 ]
+			   //  			    << " to "
+			   //  			    << atom_selection_2[ contact[i].id2 ] << std::endl;
 
-			if (atom_selection_1[ contact[i].id1 ]->GetModel() ==
-			    atom_selection_2[ contact[i].id2 ]->GetModel()) {
+			   if (atom_selection_1[ contact[i].id1 ]->GetModel() ==
+			       atom_selection_2[ contact[i].id2 ]->GetModel()) {
 
-			   bool done_bond_udd_handle = false; // set only for bonds to hydrogen
+			      bool done_bond_udd_handle = false; // set only for bonds to hydrogen
 
-			   if (element_1 != element_2) {
+			      if (element_1 != element_2) {
 		  
-			      // Bonded to different atom elements.
+				 // Bonded to different atom elements.
 
-			      if (! is_hydrogen(element_1) && ! is_hydrogen(element_2)) { 
-				 add_half_bonds(atom_1_pos, atom_2_pos,
-						atom_selection_1[contact[i].id1],
-						atom_selection_2[contact[i].id2],
-						atom_colour_type);
-			      } else {
-			      
-				 // Bonds to hydrogens are one colour - HYDROGEN_GREY_BOND, not
-				 // half-bonds.
-				 // 
-				 // Except hydrogens on waters are treated differently to other
-				 // hydrogens (if they are not then we don't get to see the
-				 // oxygen).
-			      
-				 std::string resname_1 = atom_p_1->GetResName();
-				 std::string resname_2 = atom_p_2->GetResName();
-				 if (resname_1 == "HOH" || resname_2 == "HOH" ||
-                                     resname_1 == "DOD" || resname_2 == "DOD") {
+				 if (! is_hydrogen(element_1) && ! is_hydrogen(element_2)) { 
 				    add_half_bonds(atom_1_pos, atom_2_pos,
 						   atom_selection_1[contact[i].id1],
 						   atom_selection_2[contact[i].id2],
 						   atom_colour_type);
 				 } else {
 
-				    bool done_h_bond = false; // set when we make a half-bond between H and O.
-				    if (element_1 == " O") {
-				       int bond_udd = NO_BOND;
-				       atom_p_1->GetUDData(udd_handle, bond_udd);
-				       if (bond_udd == BONDED_WITH_STANDARD_ATOM_BOND) {
-				       } else {
-					  add_half_bonds(atom_1_pos, atom_2_pos,
-							 atom_selection_1[contact[i].id1],
-							 atom_selection_2[contact[i].id2],
-							 atom_colour_type);
-					  done_h_bond = true;
+				    // Bonds to hydrogens are one colour - HYDROGEN_GREY_BOND, not
+				    // half-bonds.
+				    //
+				    // Except hydrogens on waters are treated differently to other
+				    // hydrogens (if they are not then we don't get to see the
+				    // oxygen).
+
+				    std::string resname_1 = atom_p_1->GetResName();
+				    std::string resname_2 = atom_p_2->GetResName();
+				    if (resname_1 == "HOH" || resname_2 == "HOH" ||
+					resname_1 == "DOD" || resname_2 == "DOD") {
+				       add_half_bonds(atom_1_pos, atom_2_pos,
+						      atom_selection_1[contact[i].id1],
+						      atom_selection_2[contact[i].id2],
+						      atom_colour_type);
+				    } else {
+
+				       bool done_h_bond = false; // set when we make a half-bond between H and O.
+				       if (element_1 == " O") {
+					  int bond_udd = NO_BOND;
+					  atom_p_1->GetUDData(udd_handle, bond_udd);
+					  if (bond_udd == BONDED_WITH_STANDARD_ATOM_BOND) {
+					  } else {
+					     add_half_bonds(atom_1_pos, atom_2_pos,
+							    atom_selection_1[contact[i].id1],
+							    atom_selection_2[contact[i].id2],
+							    atom_colour_type);
+					     done_h_bond = true;
+					  }
 				       }
-				    }
 				 
-				    if (element_2 == " O") {
-				       int bond_udd = NO_BOND;
-				       atom_p_2->GetUDData(udd_handle, bond_udd);
-				       if (bond_udd == BONDED_WITH_STANDARD_ATOM_BOND) {
-				       } else {
-					  add_half_bonds(atom_1_pos, atom_2_pos,
-							 atom_selection_1[contact[i].id1],
-							 atom_selection_2[contact[i].id2],
-							 atom_colour_type);
-					  done_h_bond = true;
-				       } 
-				    }
+				       if (element_2 == " O") {
+					  int bond_udd = NO_BOND;
+					  atom_p_2->GetUDData(udd_handle, bond_udd);
+					  if (bond_udd == BONDED_WITH_STANDARD_ATOM_BOND) {
+					  } else {
+					     add_half_bonds(atom_1_pos, atom_2_pos,
+							    atom_selection_1[contact[i].id1],
+							    atom_selection_2[contact[i].id2],
+							    atom_colour_type);
+					     done_h_bond = true;
+					  } 
+				       }
 
-				    if (! done_h_bond) {
-				       if (atom_colour_type != coot::COLOUR_BY_USER_DEFINED_COLOURS) {
-					  addBond(HYDROGEN_GREY_BOND, atom_1_pos, atom_2_pos);
-				       } else {
-					  add_half_bonds(atom_1_pos, atom_2_pos,
-							 atom_selection_1[contact[i].id1],
-							 atom_selection_2[contact[i].id2],
-							 atom_colour_type);
+				       if (! done_h_bond) {
+					  if (atom_colour_type != coot::COLOUR_BY_USER_DEFINED_COLOURS) {
+					     addBond(HYDROGEN_GREY_BOND, atom_1_pos, atom_2_pos);
+					  } else {
+					     add_half_bonds(atom_1_pos, atom_2_pos,
+							    atom_selection_1[contact[i].id1],
+							    atom_selection_2[contact[i].id2],
+							    atom_colour_type);
+					  }
 				       }
+				       done_bond_udd_handle = true;
+				       atom_p_1->PutUDData(udd_handle, BONDED_WITH_BOND_TO_HYDROGEN);
+				       atom_p_2->PutUDData(udd_handle, BONDED_WITH_BOND_TO_HYDROGEN);
 				    }
-				    done_bond_udd_handle = true;
-				    atom_p_1->PutUDData(udd_handle, BONDED_WITH_BOND_TO_HYDROGEN);
-				    atom_p_2->PutUDData(udd_handle, BONDED_WITH_BOND_TO_HYDROGEN);
-				 }
-			      } // not hydrogen test
+				 } // not hydrogen test
 		  
-			   } else {
+			      } else {
 		  
-			      // Bonded to an atom of the same element.
-			      //
+				 // Bonded to an atom of the same element.
+				 //
 
-			      if (is_hydrogen(element_1)) { // both are hydrogen
-				 float len2 = (atom_1_pos - atom_2_pos).amplitude_squared(); 
-				 if (len2 < 1) { // protection for weirdness
+				 if (is_hydrogen(element_1)) { // both are hydrogen
+				    float len2 = (atom_1_pos - atom_2_pos).amplitude_squared(); 
+				    if (len2 < 1) { // protection for weirdness
+				       col = atom_colour(atom_selection_1[ contact[i].id1 ], atom_colour_type);
+				       addBond(col, atom_1_pos, atom_2_pos);
+				    }
+				 } else {
 				    col = atom_colour(atom_selection_1[ contact[i].id1 ], atom_colour_type);
 				    addBond(col, atom_1_pos, atom_2_pos);
 				 }
-			      } else {
-				 col = atom_colour(atom_selection_1[ contact[i].id1 ], atom_colour_type);
-				 addBond(col, atom_1_pos, atom_2_pos);
 			      }
-			   }
 
-			   mark_atoms_as_bonded(atom_p_1, atom_p_2, have_udd_atoms, udd_handle, done_bond_udd_handle);
+			      mark_atoms_as_bonded(atom_p_1, atom_p_2, have_udd_atoms, udd_handle, done_bond_udd_handle);
 
+			   }
 			}
 		     }
 		  }
 	       }
-	    }
-	 } // contact atom is higher up the list check.
-// 	 else {
-// 	    std::cout << "debug:: ignoring contact " << i << std::endl;
-// 	 }
+	    } // contact atom is higher up the list check.
+	    // 	 else {
+	    // 	    std::cout << "debug:: ignoring contact " << i << std::endl;
+	    // 	 }
 
-      } // i over ncontacts
+	 } // i over ncontacts
       
-      delete [] contact;
+	 delete [] contact;
 
-      // OK, now we can handle the het_residues: But we don't want to
-      // do this every time that this function is called (X-X, X-H).
-      // So do it only on X-X.
-      //
-      // het_residues is filled for by X-X for everything except HOHs.
-      // 
-      if (! are_different_atom_selections) 
-	 add_bonds_het_residues(het_residues, imol, atom_colour_type, have_udd_atoms, udd_handle);
-      if (hoh_residues.size())
-	 add_bonds_het_residues(hoh_residues, imol, atom_colour_type, have_udd_atoms, udd_handle);
-      
+	 // OK, now we can handle the het_residues: But we don't want to
+	 // do this every time that this function is called (X-X, X-H).
+	 // So do it only on X-X.
+	 //
+	 // het_residues is filled for by X-X for everything except HOHs.
+	 // 
+	 if (! are_different_atom_selections) 
+	    add_bonds_het_residues(het_residues, imol, atom_colour_type, have_udd_atoms, udd_handle);
+	 if (hoh_residues.size())
+	    add_bonds_het_residues(hoh_residues, imol, atom_colour_type, have_udd_atoms, udd_handle);
+      }
    }
 }
 
@@ -1127,8 +1135,8 @@
 	       for (int istep=0; istep<n_steps; istep++) {
 		  double angle_1 = step_frac * 2.0 * M_PI * istep;
 		  double angle_2 = step_frac * 2.0 * M_PI * (istep + 1);
-		  clipper::Coord_orth pt_1 = coot::util::rotate_round_vector(n, first_pt, c, angle_1);
-		  clipper::Coord_orth pt_2 = coot::util::rotate_round_vector(n, first_pt, c, angle_2);
+		  clipper::Coord_orth pt_1 = coot::util::rotate_around_vector(n, first_pt, c, angle_1);
+		  clipper::Coord_orth pt_2 = coot::util::rotate_around_vector(n, first_pt, c, angle_2);
 		  addBond(col, pt_1, pt_2);
 	       }
 	    } else { 
@@ -1854,12 +1862,15 @@
 	 if (draw_these_atom_contacts(residue_atoms[contact[i].id1], SelAtom.atom_selection[contact[i].id2],
 				      protein_geom_p) || residue_is_water_flag) {
 
-	    coot::Cartesian atom_1(residue_atoms[ contact[i].id1 ]->x,
-				   residue_atoms[ contact[i].id1 ]->y,
-				   residue_atoms[ contact[i].id1 ]->z);
-	    coot::Cartesian atom_2(SelAtom.atom_selection[ contact[i].id2 ]->x,
-				   SelAtom.atom_selection[ contact[i].id2 ]->y,
-				   SelAtom.atom_selection[ contact[i].id2 ]->z);
+	    mmdb::Atom *atom_1 = residue_atoms[ contact[i].id1 ];
+	    mmdb::Atom *atom_2 = SelAtom.atom_selection[ contact[i].id2];
+
+	    coot::Cartesian atom_1_pos(residue_atoms[ contact[i].id1 ]->x,
+				       residue_atoms[ contact[i].id1 ]->y,
+				       residue_atoms[ contact[i].id1 ]->z);
+	    coot::Cartesian atom_2_pos(SelAtom.atom_selection[ contact[i].id2 ]->x,
+				       SelAtom.atom_selection[ contact[i].id2 ]->y,
+				       SelAtom.atom_selection[ contact[i].id2 ]->z);
 	    std::string ele1 = residue_atoms[ contact[i].id1 ]->element;
 	    std::string ele2 = SelAtom.atom_selection[ contact[i].id2 ]->element;
 	    std::string alt_conf_1 = residue_atoms[ contact[i].id1 ]->altLoc;
@@ -1882,7 +1893,7 @@
 	       bonding_dist_max -= shorter_bit;
 
 	    if (0) { // debug
-	       std::cout << " DEBUG:: add env dist "
+	       std::cout << " DEBUG:: add environ dist "
 			 << residue_atoms[ contact[i].id1 ] << " to "
 			 << SelAtom.atom_selection[ contact[i].id2 ]
 			 << std::endl;
@@ -1899,19 +1910,30 @@
 		      // ((ele1 != " H") && (ele2 != " H"))) { 
 		      ((! is_hydrogen(ele1)) && (! is_hydrogen(ele2)))) { 
 		     if (ele1 == " C")
-			addBond(0, atom_1, atom_2);
+			addBond(0, atom_1_pos, atom_2_pos);
 		     else {
 			if (ele2 == " C") { 
-			   addBond(0, atom_1, atom_2);
+			   addBond(0, atom_1_pos, atom_2_pos);
 			} else {
 			   
 			   // both atoms not Carbon
 			   
 			   // if (ele1 == " H" && ele2 == " H") {
 			   if (is_hydrogen(ele1) && is_hydrogen(ele2)) { 
-			      addBond(0, atom_1, atom_2); // not a charged/H-bond
-			   } else { 
-			      addBond(1, atom_1, atom_2); // interesting
+			      addBond(0, atom_1_pos, atom_2_pos); // not a charged/H-bond
+			   } else {
+
+			      // stop purple lines between (say) OD2 and mainchain O
+			      coot::quick_protein_donor_acceptors pda;
+			      coot::quick_protein_donor_acceptors::key k1(atom_1->GetResName(), atom_1->GetAtomName());
+			      coot::quick_protein_donor_acceptors::key k2(atom_2->GetResName(), atom_2->GetAtomName());
+			      // is-looked-up, is-H-bond
+			      int colour_index = 1; // H-bond
+			      std::pair<bool,bool> is_valid = pda.is_hydrogen_bond_by_types(k1,k2);
+			      if (is_valid.first)
+				 if (! is_valid.second)
+				    colour_index = 0;
+			      addBond(colour_index, atom_1_pos, atom_2_pos); // interesting
 			   }
 			}
 		     }
@@ -2060,10 +2082,9 @@
       min_dist = tmp;
    }
    
-   for (int iresatom=0; iresatom< nResidueAtoms; iresatom++) { 
-      coot::Cartesian res_atom_pos(residue_atoms[iresatom]->x,
-				   residue_atoms[iresatom]->y,
-				   residue_atoms[iresatom]->z);
+   for (int iresatom=0; iresatom< nResidueAtoms; iresatom++) {
+      mmdb::Atom *res_atom = residue_atoms[iresatom];
+      coot::Cartesian res_atom_pos(res_atom->x, res_atom->y, res_atom->z);
       
       molecule_extents_t mol_extents(SelAtom, max_dist);
       std::vector<std::pair<symm_trans_t, Cell_Translation> > boxes =
@@ -2073,12 +2094,13 @@
 	 mmdb::PPAtom translated = trans_sel(SelAtom, boxes[ibox]);
 	 
 	 for (int it=0; it<SelAtom.n_selected_atoms; it++) { 
-	    
-	    coot::Cartesian symm_atom(translated[it]->x,
-				      translated[it]->y,
-				      translated[it]->z);
-	    
-	    float d = coot::Cartesian::LineLength(symm_atom, res_atom_pos);
+
+	    mmdb::Atom *trans_atom = translated[it];
+	    coot::Cartesian symm_atom_pos(translated[it]->x,
+					  translated[it]->y,
+					  translated[it]->z);
+
+	    float d = coot::Cartesian::LineLength(symm_atom_pos, res_atom_pos);
  	    // std::cout << translated[it] << " d = " << d << std::endl;
 	    if (d < max_dist && d >= min_dist) {
 	       std::string ele1 = residue_atoms[iresatom]->element;
@@ -2087,18 +2109,26 @@
 	       if (draw_env_distances_to_hydrogens_flag ||
 		   // ((ele1 != " H") && (ele2 != " H"))) {
 		   ((!is_hydrogen(ele1)) && (! is_hydrogen(ele2)))) {
-		   
+
 		  if (ele1 == " C")
-		     addBond(0, symm_atom, res_atom_pos);
+		     addBond(0, symm_atom_pos, res_atom_pos);
 		  else {
 		     if (ele2 == " C") { 
-			addBond(0, symm_atom, res_atom_pos);
-		     } else { 
-			// if (ele1 == " H" && ele2 == " H") { 
+			addBond(0, symm_atom_pos, res_atom_pos);
+		     } else {
 			if (is_hydrogen(ele1) && is_hydrogen(ele2)) {
-			   addBond(0, symm_atom, res_atom_pos);
-			} else { 
-			   addBond(1, symm_atom, res_atom_pos);
+			   addBond(0, symm_atom_pos, res_atom_pos);
+			} else {
+			   coot::quick_protein_donor_acceptors pda;
+			   coot::quick_protein_donor_acceptors::key k1(trans_atom->GetResName(), trans_atom->GetAtomName());
+			   coot::quick_protein_donor_acceptors::key k2(  res_atom->GetResName(),   res_atom->GetAtomName());
+			   // is-looked-up, is-H-bond
+			   int colour_index = 1; // H-bond
+			   std::pair<bool,bool> is_valid = pda.is_hydrogen_bond_by_types(k1,k2);
+			   if (is_valid.first)
+			      if (! is_valid.second)
+				 colour_index = 0;
+			   addBond(colour_index, symm_atom_pos, res_atom_pos);
 			}
 		     }
 		  }
diff -ruN coot-0.8.7/coords/Makefile.in coot-0.8.8-pre/coords/Makefile.in
--- coot-0.8.7/coords/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/coords/Makefile.in	2017-01-25 14:39:04.000000000 -0800
@@ -62,6 +62,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -241,6 +244,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/coot-surface/Makefile.in coot-0.8.8-pre/coot-surface/Makefile.in
--- coot-0.8.7/coot-surface/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/coot-surface/Makefile.in	2017-01-25 14:39:04.000000000 -0800
@@ -60,6 +60,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -229,6 +232,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/coot-utils/Makefile.am coot-0.8.8-pre/coot-utils/Makefile.am
--- coot-0.8.7/coot-utils/Makefile.am	2016-09-09 09:43:24.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/Makefile.am	2016-12-21 05:34:30.000000000 -0800
@@ -34,7 +34,8 @@
 	coot-map-heavy.hh coot-lsq-types.h coot-shelx.hh \
 	coot-rama.hh xmap-stats.hh coot-h-bonds.hh lsq-improve.hh coot-hole.hh \
 	read-sm-cif.hh bonded-pairs.hh tree.hh helix-analysis.hh elastic.hh emma.hh \
-	glyco-torsions.hh coot-least-squares.hh coot-density-stats.hh atom-overlaps.hh
+	glyco-torsions.hh coot-least-squares.hh coot-density-stats.hh \
+        atom-overlaps.hh reduce.hh
 
 pkgincludedir = $(includedir)/coot/coot-utils
 
@@ -54,7 +55,7 @@
 libcoot_coord_utils_la_SOURCES = coot-coord-utils.cc \
 	coot-coord-utils-nucleotides.cc coot-rama.cc coot-h-bonds.cc hole.cc read-sm-cif.cc \
 	bonded-pairs.cc helix-analysis.cc elastic.cc glyco-torsions.cc coot-least-squares.cc \
-	atom-overlaps.cc
+	atom-overlaps.cc reduce.cc
 
 
 #    $(top_builddir)/mini-mol/libcoot-mini-mol.la 
@@ -117,7 +118,8 @@
 
 
 # test-agg-clust
-check_PROGRAMS = test-h-bonds testshelxreader testcootutils test-hole test-elastic test-spherical glyco-torsions test-tt-morph
+check_PROGRAMS = test-h-bonds testshelxreader testcootutils test-hole test-elastic test-spherical glyco-torsions \
+	test-tt-morph test-coot-probe
 
 # test_zo_chi_table_SOURCES = test-zo-chi-table.cc
 
@@ -130,6 +132,10 @@
 #        $(top_builddir)/utils/libcoot-utils.la $(GLOB_LIBS)
 
 
+test_coot_probe_SOURCES = test-coot-probe.cc
+test_coot_probe_LDADD =          \
+	./libcoot-coord-utils.la
+
 testshelxreader_SOURCES = test-shelx-reader.cc
 testshelxreader_LDADD =          \
 	./libcoot-shelx.la       \
diff -ruN coot-0.8.7/coot-utils/Makefile.in coot-0.8.8-pre/coot-utils/Makefile.in
--- coot-0.8.7/coot-utils/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/coot-utils/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -58,7 +58,8 @@
 check_PROGRAMS = test-h-bonds$(EXEEXT) testshelxreader$(EXEEXT) \
 	testcootutils$(EXEEXT) test-hole$(EXEEXT) \
 	test-elastic$(EXEEXT) test-spherical$(EXEEXT) \
-	glyco-torsions$(EXEEXT) test-tt-morph$(EXEEXT)
+	glyco-torsions$(EXEEXT) test-tt-morph$(EXEEXT) \
+	test-coot-probe$(EXEEXT)
 subdir = coot-utils
 DIST_COMMON = $(pkginclude_HEADERS) $(srcdir)/Makefile.am \
 	$(srcdir)/Makefile.in
@@ -66,6 +67,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -140,7 +144,7 @@
 	coot-coord-utils-nucleotides.lo coot-rama.lo coot-h-bonds.lo \
 	hole.lo read-sm-cif.lo bonded-pairs.lo helix-analysis.lo \
 	elastic.lo glyco-torsions.lo coot-least-squares.lo \
-	atom-overlaps.lo
+	atom-overlaps.lo reduce.lo
 libcoot_coord_utils_la_OBJECTS = $(am_libcoot_coord_utils_la_OBJECTS)
 libcoot_coord_utils_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
@@ -170,6 +174,9 @@
 am_glyco_torsions_OBJECTS = test-glyco-torsions.$(OBJEXT)
 glyco_torsions_OBJECTS = $(am_glyco_torsions_OBJECTS)
 glyco_torsions_DEPENDENCIES = ./libcoot-coord-utils.la
+am_test_coot_probe_OBJECTS = test-coot-probe.$(OBJEXT)
+test_coot_probe_OBJECTS = $(am_test_coot_probe_OBJECTS)
+test_coot_probe_DEPENDENCIES = ./libcoot-coord-utils.la
 am_test_elastic_OBJECTS = test-elastic.$(OBJEXT)
 test_elastic_OBJECTS = $(am_test_elastic_OBJECTS)
 test_elastic_DEPENDENCIES = ./libcoot-coord-utils.la \
@@ -214,18 +221,20 @@
 	$(libcoot_coord_utils_la_SOURCES) \
 	$(libcoot_map_heavy_la_SOURCES) \
 	$(libcoot_map_utils_la_SOURCES) $(libcoot_shelx_la_SOURCES) \
-	$(glyco_torsions_SOURCES) $(test_elastic_SOURCES) \
-	$(test_h_bonds_SOURCES) $(test_hole_SOURCES) \
-	$(test_spherical_SOURCES) $(test_tt_morph_SOURCES) \
-	$(testcootutils_SOURCES) $(testshelxreader_SOURCES)
+	$(glyco_torsions_SOURCES) $(test_coot_probe_SOURCES) \
+	$(test_elastic_SOURCES) $(test_h_bonds_SOURCES) \
+	$(test_hole_SOURCES) $(test_spherical_SOURCES) \
+	$(test_tt_morph_SOURCES) $(testcootutils_SOURCES) \
+	$(testshelxreader_SOURCES)
 DIST_SOURCES = $(libcoot_coord_extras_la_SOURCES) \
 	$(libcoot_coord_utils_la_SOURCES) \
 	$(libcoot_map_heavy_la_SOURCES) \
 	$(libcoot_map_utils_la_SOURCES) $(libcoot_shelx_la_SOURCES) \
-	$(glyco_torsions_SOURCES) $(test_elastic_SOURCES) \
-	$(test_h_bonds_SOURCES) $(test_hole_SOURCES) \
-	$(test_spherical_SOURCES) $(test_tt_morph_SOURCES) \
-	$(testcootutils_SOURCES) $(testshelxreader_SOURCES)
+	$(glyco_torsions_SOURCES) $(test_coot_probe_SOURCES) \
+	$(test_elastic_SOURCES) $(test_h_bonds_SOURCES) \
+	$(test_hole_SOURCES) $(test_spherical_SOURCES) \
+	$(test_tt_morph_SOURCES) $(testcootutils_SOURCES) \
+	$(testshelxreader_SOURCES)
 HEADERS = $(pkginclude_HEADERS)
 ETAGS = etags
 CTAGS = ctags
@@ -307,6 +316,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -445,7 +455,8 @@
 	coot-map-heavy.hh coot-lsq-types.h coot-shelx.hh \
 	coot-rama.hh xmap-stats.hh coot-h-bonds.hh lsq-improve.hh coot-hole.hh \
 	read-sm-cif.hh bonded-pairs.hh tree.hh helix-analysis.hh elastic.hh emma.hh \
-	glyco-torsions.hh coot-least-squares.hh coot-density-stats.hh atom-overlaps.hh
+	glyco-torsions.hh coot-least-squares.hh coot-density-stats.hh \
+        atom-overlaps.hh reduce.hh
 
 AM_CPPFLAGS = \
 	-I$(top_srcdir)	\
@@ -463,7 +474,7 @@
 libcoot_coord_utils_la_SOURCES = coot-coord-utils.cc \
 	coot-coord-utils-nucleotides.cc coot-rama.cc coot-h-bonds.cc hole.cc read-sm-cif.cc \
 	bonded-pairs.cc helix-analysis.cc elastic.cc glyco-torsions.cc coot-least-squares.cc \
-	atom-overlaps.cc
+	atom-overlaps.cc reduce.cc
 
 
 #    $(top_builddir)/mini-mol/libcoot-mini-mol.la 
@@ -532,6 +543,10 @@
 #	$(top_builddir)/geometry/libcoot-geometry.la 
 #        $(top_builddir)/mini-mol/libcoot-mini-mol.la 
 #        $(top_builddir)/utils/libcoot-utils.la $(GLOB_LIBS)
+test_coot_probe_SOURCES = test-coot-probe.cc
+test_coot_probe_LDADD = \
+	./libcoot-coord-utils.la
+
 testshelxreader_SOURCES = test-shelx-reader.cc
 testshelxreader_LDADD = \
 	./libcoot-shelx.la       \
@@ -660,6 +675,9 @@
 glyco-torsions$(EXEEXT): $(glyco_torsions_OBJECTS) $(glyco_torsions_DEPENDENCIES) 
 	@rm -f glyco-torsions$(EXEEXT)
 	$(CXXLINK) $(glyco_torsions_OBJECTS) $(glyco_torsions_LDADD) $(LIBS)
+test-coot-probe$(EXEEXT): $(test_coot_probe_OBJECTS) $(test_coot_probe_DEPENDENCIES) 
+	@rm -f test-coot-probe$(EXEEXT)
+	$(CXXLINK) $(test_coot_probe_OBJECTS) $(test_coot_probe_LDADD) $(LIBS)
 test-elastic$(EXEEXT): $(test_elastic_OBJECTS) $(test_elastic_DEPENDENCIES) 
 	@rm -f test-elastic$(EXEEXT)
 	$(CXXLINK) $(test_elastic_OBJECTS) $(test_elastic_LDADD) $(LIBS)
@@ -712,6 +730,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/peak-search-from-list.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/peak-search.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/read-sm-cif.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/reduce.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test-coot-probe.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test-elastic.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test-glyco-torsions.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test-h-bonds.Po@am__quote@
diff -ruN coot-0.8.7/coot-utils/atom-overlaps.cc coot-0.8.8-pre/coot-utils/atom-overlaps.cc
--- coot-0.8.7/coot-utils/atom-overlaps.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/atom-overlaps.cc	2017-01-25 14:34:21.000000000 -0800
@@ -1,6 +1,6 @@
 /* coot-utils/atom-overlaps.cc
  * 
- * Copyright 2015 by Medical Research Council
+ * Copyright 2016 by Medical Research Council
  * Author: Paul Emsley
  * 
  * This program is free software; you can redistribute it and/or modify
@@ -19,10 +19,20 @@
  * 02110-1301, USA
  */
 
+#include <stdlib.h> // needed from abs()
 
+#include <iomanip>
+
+
+#ifdef HAVE_CXX_THREAD
+#include <thread>
+#include <future>
+#endif
+
+#include "utils/coot-utils.hh"
 #include "atom-overlaps.hh"
 #include "coot-coord-utils.hh"
-// #include "coot-h-bonds.hh"
+#include "geometry/main-chain.hh"
 
 coot::atom_overlaps_container_t::atom_overlaps_container_t(mmdb::Residue *res_central_in,
 							   const std::vector<mmdb::Residue *> &neighbours_in,
@@ -32,28 +42,70 @@
    res_central = res_central_in;
    neighbours = neighbours_in;
    mol = mol_in;
+   clash_spike_length = 0.5;
    init();
 
 }
 
+// is this used?
 coot::atom_overlaps_container_t::atom_overlaps_container_t(mmdb::Residue *res_central_in,
 							   mmdb::Residue *neighbour,
-							   mmdb::Manager *mol,
+							   mmdb::Manager *mol_in,
 							   const protein_geometry *geom_p_in) {
    geom_p = geom_p_in;
    res_central = res_central_in;
    neighbours.push_back(neighbour);
+   mol = mol_in;
+   clash_spike_length = 0.5;
    init();
-   
+
+}
+
+// this can throw a std::out_of_range (missing residue from dictionary)
+// 
+// clash spike_length should be 0.5;
+coot::atom_overlaps_container_t::atom_overlaps_container_t(mmdb::Residue *res_central_in,
+							   const std::vector<mmdb::Residue *> &neighbours_in,
+							   mmdb::Manager *mol_in,
+							   const protein_geometry *geom_p_in,
+							   double clash_spike_length_in,
+							   double probe_radius_in) {
+   probe_radius = probe_radius_in;
+   geom_p = geom_p_in;
+   res_central = res_central_in;
+   neighbours = neighbours_in;
+   mol = mol_in;
+   clash_spike_length = clash_spike_length_in;
+   init();
+
+}
+
+// this can throw a std::out_of_range (missing residue from dictionary)
+//
+coot::atom_overlaps_container_t::atom_overlaps_container_t(mmdb::Manager *mol_in,
+							   const protein_geometry *geom_p_in,
+							   double clash_spike_length_in,
+							   double probe_radius_in) {
+   geom_p = geom_p_in;
+   res_central = 0;
+   mol = mol_in;
+   clash_spike_length = 0.5;
+   probe_radius = probe_radius_in;
+   init_for_all_atom();
 }
 
 
+
+// this can throw a std::out_of_range (missing residue from dictionary)
+//
 void
 coot::atom_overlaps_container_t::init() {
 
+   overlap_mode = CENTRAL_RESIDUE;
+
    have_dictionary = false; // initially.
-   
-   if (res_central) { 
+
+   if (res_central) {
 
       std::string cres_name = res_central->GetResName();
       std::pair<bool, dictionary_residue_restraints_t> d =
@@ -64,6 +116,11 @@
 	 // Happy path
 	 central_residue_dictionary = d.second;
 
+	 if (false)
+	    std::cout << "central_residue_dictionary has " << central_residue_dictionary.atom_info.size()
+		      << " atoms and " << central_residue_dictionary.bond_restraint.size()
+		      << " bond restraints " << std::endl;
+
 	 neighb_dictionaries.resize(neighbours.size());
 	 have_dictionary = true;
 	 for (unsigned int i=0; i<neighbours.size(); i++) {
@@ -81,72 +138,225 @@
 	 }
       }
 
-      if (have_dictionary) { 
+      if (have_dictionary) {
+	 fill_ligand_atom_neighbour_map(); // and add radius
+	 mark_donors_and_acceptors();
+      }
+   }
+}
+
+// this can throw a std::out_of_range (missing residue from dictionary)
+//
+void
+coot::atom_overlaps_container_t::init_for_all_atom() {
+
+   overlap_mode = ALL_ATOM;
+
+   // neighbours is a misnomer in this case - it is merely a list of all residue
+
+   have_dictionary = true; // initially.
+
+   int imod = 1;
+   mmdb::Model *model_p = mol->GetModel(imod);
+   if (model_p) {
+      mmdb::Chain *chain_p;
+      int n_chains = model_p->GetNumberOfChains();
+      for (int ichain=0; ichain<n_chains; ichain++) {
+	 chain_p = model_p->GetChain(ichain);
+	 int nres = chain_p->GetNumberOfResidues();
+	 mmdb::Residue *residue_p;
+	 for (int ires=0; ires<nres; ires++) {
+	    residue_p = chain_p->GetResidue(ires);
+	    if (residue_p) {
+	       neighbours.push_back(residue_p);
+	       std::string residue_name(residue_p->GetResName());
+	       std::map<std::string, dictionary_residue_restraints_t>::const_iterator it;
+	       it = dictionary_map.find(residue_name);
+	       if (it == dictionary_map.end()) {
+		  std::pair<bool, dictionary_residue_restraints_t> d =
+		     geom_p->get_monomer_restraints(residue_name, protein_geometry::IMOL_ENC_ANY);
+		  if (! d.first) {
+		     std::cout << "Failed to get dictionary for " << residue_name << std::endl;
+		     have_dictionary = false;
+		  } else {
+		     dictionary_map[residue_name] = d.second;
+		  }
+	       }
+	    }
+	 }
+      }
+   }
+
+   // now mark donors and acceptors.
+   //
+   udd_h_bond_type_handle = mol->RegisterUDInteger(mmdb::UDR_ATOM, "hb_type");
 
-	 // now mark donors and acceptors.
-	 //
-	 udd_h_bond_type_handle = mol->RegisterUDInteger(mmdb::UDR_ATOM, "hb_type");
+   mark_donors_and_acceptors_for_neighbours(udd_h_bond_type_handle);
 
-	 // 
-	 mmdb::PAtom *central_residue_atoms = 0;
-	 int n_central_residue_atoms;
-	 res_central->GetAtomTable(central_residue_atoms, n_central_residue_atoms);
-	 for (int iat=0; iat<n_central_residue_atoms; iat++) { 
-	    mmdb::Atom *at = central_residue_atoms[iat];
-	    std::string atom_name(at->name);
-	    std::string ele = at->element;
+}
+
+void
+coot::atom_overlaps_container_t::mark_donors_and_acceptors() {
+
+   // now mark donors and acceptors.
+   //
+   udd_h_bond_type_handle = mol->RegisterUDInteger(mmdb::UDR_ATOM, "hb_type");
+
+   mark_donors_and_acceptors_central_residue(udd_h_bond_type_handle);
+
+   mark_donors_and_acceptors_for_neighbours(udd_h_bond_type_handle);
+}
+
+void
+coot::atom_overlaps_container_t::mark_donors_and_acceptors_central_residue(int udd_h_bond_type_handle) {
+
+   if (res_central) {
+      mmdb::PAtom *central_residue_atoms = 0;
+      int n_central_residue_atoms;
+      res_central->GetAtomTable(central_residue_atoms, n_central_residue_atoms);
+      for (int iat=0; iat<n_central_residue_atoms; iat++) {
+	 mmdb::Atom *at = central_residue_atoms[iat];
+	 std::string atom_name(at->name);
+	 std::string ele = at->element;
+	 if (ele == " H") {
+	    // Hydrogens have energy type "H" from Refmac and acedrg, that doesn't
+	    // tell us if this atom is a donor hydrogen.
+	    // So, find the atom to which the H is attached and if that is a donor then this
+	    // is a hydrogen bond hydrogen.
+	    std::string heavy_neighb_of_H_atom =
+	       central_residue_dictionary.get_bonded_atom(atom_name);
+	    if (! heavy_neighb_of_H_atom.empty()) {
+	       std::string neigh_energy_type = central_residue_dictionary.type_energy(heavy_neighb_of_H_atom);
+	       energy_lib_atom neighb_ela = geom_p->get_energy_lib_atom(neigh_energy_type);
+	       hb_t neighb_hb_type = neighb_ela.hb_type;
+	       if (neighb_hb_type == coot::HB_DONOR) {
+		  // std::cout << "----- adding ligand HB_HYDROGEN udd " << atom_spec_t(at) << std::endl;
+		  at->PutUDData(udd_h_bond_type_handle, coot::HB_HYDROGEN); // hb_t -> int
+	       }
+	       if (neighb_hb_type == coot::HB_BOTH) {
+		  // std::cout << "----- adding ligand HB_HYDROGEN udd " << atom_spec_t(at) << std::endl;
+		  at->PutUDData(udd_h_bond_type_handle, coot::HB_HYDROGEN); // hb_t -> int
+	       }
+	    }
+	 } else {
+	    std::string energy_type = central_residue_dictionary.type_energy(atom_name);
+	    energy_lib_atom ela = geom_p->get_energy_lib_atom(energy_type);
+	    hb_t hb_type = ela.hb_type;
+	    at->PutUDData(udd_h_bond_type_handle, hb_type); // hb_t -> int
+	 }
+      }
+   }
+}
+
+// this can throw a std::out_of_range
+//
+const coot::dictionary_residue_restraints_t &
+coot::atom_overlaps_container_t::get_dictionary(mmdb::Residue *r, unsigned int idx) const {
+
+   if (overlap_mode == ALL_ATOM) {
+      std::string res_name = r->GetResName();
+      std::map<std::string, dictionary_residue_restraints_t>::const_iterator it =
+	 dictionary_map.find(res_name);
+
+      if (it == dictionary_map.end()) {
+	 std::cout << "========= hideous failure in get_dictionary for type " << res_name
+		   << " using " << dictionary_map.size() << " dictionary entries" << std::endl;
+	 std::string mess = "dictionary index out of range for ";
+	 mess += res_name;
+	 std::out_of_range oor(mess);
+	 throw oor;
+      }
+      return it->second;
+   } else {
+      return neighb_dictionaries[idx];
+   }
+}
+
+// this can throw a std::out_of_range
+//
+void
+coot::atom_overlaps_container_t::mark_donors_and_acceptors_for_neighbours(int udd_h_bond_type_handle) {
+
+   for (unsigned int i=0; i<neighbours.size(); i++) {
+      // const dictionary_residue_restraints_t &dict = neighb_dictionaries[i];
+      try {
+	 const dictionary_residue_restraints_t &dict = get_dictionary(neighbours[i], i);
+	 mmdb::PAtom *residue_atoms = 0;
+	 int n_residue_atoms;
+	 neighbours[i]->GetAtomTable(residue_atoms, n_residue_atoms);
+	 for (int iat=0; iat<n_residue_atoms; iat++) { 
+	    mmdb::Atom *n_at = residue_atoms[iat];
+	    std::string atom_name(n_at->name);
+	    std::string ele = n_at->element;
 	    if (ele == " H") {
-	       // Hydrogens have energy type "H" from Refmac and acedrg, that doesn't
-	       // tell us if this atom is a donor hydrogen.
-	       // So, find the atom to which the H is attached and if that is a donor then this
-	       // is a hydrogen bond hydrogen.
-	       std::string heavy_neighb_of_H_atom =
-		  central_residue_dictionary.get_bonded_atom(atom_name);
+	       // as above
+	       std::string heavy_neighb_of_H_atom = dict.get_bonded_atom(atom_name);
 	       if (! heavy_neighb_of_H_atom.empty()) {
-		  std::string neigh_energy_type = central_residue_dictionary.type_energy(heavy_neighb_of_H_atom);
+		  std::string neigh_energy_type = dict.type_energy(heavy_neighb_of_H_atom);
 		  energy_lib_atom neighb_ela = geom_p->get_energy_lib_atom(neigh_energy_type);
 		  hb_t neighb_hb_type = neighb_ela.hb_type;
 		  if (neighb_hb_type == coot::HB_DONOR) {
-		     std::cout << "----- adding ligand HB_HYDROGEN udd " << atom_spec_t(at) << std::endl;
-		     at->PutUDData(udd_h_bond_type_handle, coot::HB_HYDROGEN); // hb_t -> int
+		     // std::cout << "----- adding env HB_HYDROGEN udd " << atom_spec_t(n_at) << std::endl;
+		     n_at->PutUDData(udd_h_bond_type_handle, coot::HB_HYDROGEN); // hb_t -> int
+		  }
+		  if (neighb_hb_type == coot::HB_BOTH) {
+		     // std::cout << "----- adding env HB_HYDROGEN udd " << atom_spec_t(n_at) << std::endl;
+		     n_at->PutUDData(udd_h_bond_type_handle, coot::HB_HYDROGEN); // hb_t -> int
 		  }
 	       }
 	    } else {
-	       std::string energy_type = central_residue_dictionary.type_energy(atom_name);
+	       std::string atom_name(n_at->name);
+	       std::string energy_type = dict.type_energy(atom_name);
 	       energy_lib_atom ela = geom_p->get_energy_lib_atom(energy_type);
 	       hb_t hb_type = ela.hb_type;
-	       at->PutUDData(udd_h_bond_type_handle, hb_type); // hb_t -> int
+	       n_at->PutUDData(udd_h_bond_type_handle, hb_type); // hb_t -> int
+	       if (false)
+		  std::cout << "........... type_energy for atom name " << atom_name
+			    << " in dictionary for comp-id \"" << dict.residue_info.comp_id
+			    << "\" put type " << hb_type << std::endl;
 	    }
 	 }
+      }
+      catch (const std::out_of_range &ex) {
+	 std::cout << "Opps " << ex.what() << std::endl;
+      }
+   }
+}
 
-	 for (unsigned int i=0; i<neighbours.size(); i++) {
-  	    const dictionary_residue_restraints_t &dict = neighb_dictionaries[i];
-	    mmdb::PAtom *residue_atoms = 0;
-	    int n_residue_atoms;
-	    neighbours[i]->GetAtomTable(residue_atoms, n_residue_atoms);
-	    for (int iat=0; iat<n_residue_atoms; iat++) { 
-	       mmdb::Atom *n_at = residue_atoms[iat];
-	       std::string atom_name(n_at->name);
-	       std::string ele = n_at->element;
-	       if (ele == " H") {
-		  // as above
-		  std::string heavy_neighb_of_H_atom = dict.get_bonded_atom(atom_name);
-		  if (! heavy_neighb_of_H_atom.empty()) {
-		     std::string neigh_energy_type = dict.type_energy(heavy_neighb_of_H_atom);
-		     energy_lib_atom neighb_ela = geom_p->get_energy_lib_atom(neigh_energy_type);
-		     hb_t neighb_hb_type = neighb_ela.hb_type;
-		     if (neighb_hb_type == coot::HB_DONOR) {
-			std::cout << "----- adding env HB_HYDROGEN udd " << atom_spec_t(n_at) << std::endl;
-			n_at->PutUDData(udd_h_bond_type_handle, coot::HB_HYDROGEN); // hb_t -> int
-		     }
-		  }
-	       } else {
-		  std::string atom_name(n_at->name);
-		  std::string energy_type = neighb_dictionaries[i].type_energy(atom_name);
-		  energy_lib_atom ela = geom_p->get_energy_lib_atom(energy_type);
-		  hb_t hb_type = ela.hb_type;
-		  n_at->PutUDData(udd_h_bond_type_handle, hb_type); // hb_t -> int
-	       }
+// and radius
+void
+coot::atom_overlaps_container_t::fill_ligand_atom_neighbour_map() {
+
+   mmdb::realtype max_dist = 2.3;
+   if (mol) {
+      mmdb::Contact *pscontact = NULL;
+      int n_contacts;
+      float min_dist = 0.01;
+      long i_contact_group = 1;
+      mmdb::mat44 my_matt;
+      mmdb::SymOps symm;
+      for (int i=0; i<4; i++)
+	 for (int j=0; j<4; j++)
+	    my_matt[i][j] = 0.0;
+      for (int i=0; i<4; i++) my_matt[i][i] = 1.0;
+
+      mmdb::Atom **residue_atoms = 0;
+      int n_residue_atoms;
+      res_central->GetAtomTable(residue_atoms, n_residue_atoms);
+
+      mol->SeekContacts(residue_atoms, n_residue_atoms,
+			residue_atoms, n_residue_atoms,
+			0, max_dist,
+			0, // in same residue
+			pscontact, n_contacts,
+			0, &my_matt, i_contact_group); // makes reverses also
+      if (n_contacts > 0) {
+	 if (pscontact) {
+	    for (int i=0; i<n_contacts; i++) {
+	       mmdb::Atom *neighb_at = residue_atoms[pscontact[i].id2];
+	       double radius = get_vdw_radius_ligand_atom(neighb_at);
+	       std::pair<mmdb::Atom *, double> p(neighb_at, radius);
+	       ligand_atom_neighbour_map[pscontact[i].id1].push_back(p);
 	    }
 	 }
       }
@@ -155,6 +365,7 @@
 
 
 
+
 void
 coot::atom_overlaps_container_t::make_overlaps() {
 
@@ -175,7 +386,9 @@
    res_central->GetAtomTable(central_residue_atoms, n_central_residue_atoms);
 
    for (int j=0; j<n_central_residue_atoms; j++) {
+
       mmdb::Atom *cr_at = central_residue_atoms[j];
+      // std::cout << "Surface points for ligand atom " << atom_spec_t(cr_at) << std::endl;
       clipper::Coord_orth co_cr_at = co(cr_at);
       double r_1 = get_vdw_radius_ligand_atom(cr_at);
 
@@ -189,17 +402,20 @@
 
 	    double ds = (co_cr_at - co_n_at).lengthsq();
 	    if (ds < dist_crit_sqrd) {
-	       
+
 	       double r_2 = get_vdw_radius_neighb_atom(n_at, i);
 	       double d = sqrt(ds);
 
 	       // first is yes/no, second is if the H is on the ligand
 	       // 
-	       std::pair<bool, bool> might_be_h_bond_flag = is_h_bond_H_and_acceptor(cr_at, n_at, d);
+	       std::pair<bool, bool> might_be_h_bond_flag =
+		  is_h_bond_H_and_acceptor(cr_at, n_at, udd_h_bond_type_handle);
 
-	       if (d < (r_1 + r_2)) { 
+	       if (d < (r_1 + r_2 + probe_radius)) { 
 		  double o = get_overlap_volume(d, r_2, r_1);
-		  if (might_be_h_bond_flag.first) { 
+		  bool h_bond_flag = false;
+		  if (might_be_h_bond_flag.first) {
+		     h_bond_flag = true;
 		     if (might_be_h_bond_flag.second) { 
 			std::cout << atom_spec_t(cr_at) << "   " << " and " << atom_spec_t(n_at)
 				  << " r_1 " << r_1 << " and r_2 " << r_2  <<  " and d " << d 
@@ -215,18 +431,25 @@
 			       << " r_1 " << r_1 << " and r_2 " << r_2  <<  " and d " << d 
 			       << " overlap " << o << std::endl;
 		  }
-		  atom_overlap_t ao(cr_at, n_at, o);
-		  // ao.is_h_bond = h_bond_flag;
+		  atom_overlap_t ao(j, cr_at, n_at, r_1, r_2, o);
+		  // atom_overlap_t ao2(-1, n_at, cr_at, r_2, r_1, o);
+		  ao.is_h_bond = h_bond_flag;
 		  overlaps.push_back(ao);
+		  // overlaps.push_back(ao2);
 	       } else {
 		  if (might_be_h_bond_flag.first) { 
 		     if (d < (dist_crit + 0.5)) {
 			std::cout << atom_spec_t(cr_at) << "   " << " and " << atom_spec_t(n_at)
 				  << " r_1 " << r_1 << " and r_2 " << r_2  <<  " and d " << d
-				  << " but might be h-bond anyway " << std::endl;
+				  << " but might be h-bond anyway (is this strange?)"
+				  << std::endl;
+			double o = 0;
+			// atom_overlap_t ao(cr_at, n_at, r_1, r_2, o);
+			// ao.is_h_bond = true;
+			// overlaps.push_back(ao);
 		     }
 		  }
-	       } 
+	       }
 	    }
 	 }
       }
@@ -234,11 +457,17 @@
 }
 
 // first is yes/no, second is if the H is on the ligand
-// 
+//
+// also allow water to be return true values
+//
+// (ligand_atom and env_atom variable names are not appropriate for all-atom case)
+//
+// static
 std::pair<bool, bool>
 coot::atom_overlaps_container_t::is_h_bond_H_and_acceptor(mmdb::Atom *ligand_atom,
 							  mmdb::Atom *env_atom,
-							  const double &d) const {
+							  int udd_h_bond_type_handle
+							  ) {
 
    bool status = false;
    bool H_on_ligand = false;
@@ -250,21 +479,47 @@
    int hb_2 = -1;
    if (ligand_atom->GetUDData(udd_h_bond_type_handle, hb_1) == mmdb::UDDATA_Ok) { 
       if (env_atom->GetUDData(udd_h_bond_type_handle, hb_2) == mmdb::UDDATA_Ok) {
-	 // std::cout << "hb_1 " << hb_1 << " and hb_2 " << hb_2 << std::endl;
+
+	 if (false) // testing
+	    std::cout << "    hb_1 " << hb_1 << " for " << coot::atom_spec_t(ligand_atom)
+		      << " and hb_2 " << hb_2 << " for neighb-atom " << coot::atom_spec_t(env_atom)
+		      << std::endl;
+
 	 if (hb_1 == HB_HYDROGEN) {
 	    if (hb_2 == HB_ACCEPTOR || hb_2 == HB_BOTH) {
 	       status = true;
 	       H_on_ligand = true;
 	    }
 	 } 
-      }
 
-      if (hb_1 == HB_ACCEPTOR || hb_1 == HB_BOTH) {
-	 if (hb_2 == HB_HYDROGEN) {
-	    status = true;
-	    H_on_ligand = false;
+	 if (hb_1 == HB_ACCEPTOR || hb_1 == HB_BOTH) {
+	    if (hb_2 == HB_HYDROGEN) {
+	       status = true;
+	       H_on_ligand = false;
+	    }
 	 }
+      } else {
+	 // it's not bad.  Some H atoms don't have hydrogen UDD.
+	 if (false)
+	    std::cout << "   bad get of uud_h_bond info for env atom " << coot::atom_spec_t(env_atom)
+		      << std::endl;
+      }
+
+      if (status == false) {
+	 // allow HOH to H-bond
+	 std::string resname_1 = ligand_atom->GetResName();
+	 std::string resname_2 = env_atom->GetResName();
+	 if (resname_1 == "HOH")
+	    if (hb_2 == HB_ACCEPTOR || hb_2 == HB_DONOR || hb_2 == HB_BOTH || hb_2 == HB_HYDROGEN)
+	       status = true;
+	 if (resname_2 == "HOH")
+	    if (hb_1 == HB_ACCEPTOR || hb_1 == HB_DONOR || hb_1 == HB_BOTH || hb_1 == HB_HYDROGEN)
+	       status = true;
       }
+   } else {
+      if (false)
+	 std::cout << "   bad get of uud_h_bond info for ligand atom " << coot::atom_spec_t(ligand_atom)
+		   << std::endl;
    }
    return std::pair<bool, bool> (status, H_on_ligand);
 }
@@ -279,11 +534,10 @@
    return V;
 } 
 
-
 double
 coot::atom_overlaps_container_t::get_vdw_radius_ligand_atom(mmdb::Atom *at) {
 
-   double r = 1.5;
+   double r = 2.5;
 
    std::map<mmdb::Atom *, double>::const_iterator it = central_residue_atoms_vdw_radius_map.find(at);
    if (it == central_residue_atoms_vdw_radius_map.end()) {
@@ -291,31 +545,49 @@
 
       // What's the energy type of Atom at?
       //
+      // PDBv3 FIXME - change from 4-char
       std::string te = central_residue_dictionary.type_energy(at->GetAtomName());
-      std::map<std::string, double>::const_iterator it_type =
-	 type_to_vdw_radius_map.find(te);
-      if (it_type == type_to_vdw_radius_map.end()) {
-	 // didn't find it. so look it up and add it.
-	 r = geom_p->get_energy_lib_atom(te).vdw_radius;
-	 hb_t t = geom_p->get_energy_lib_atom(te).hb_type;
-	 // std::cout << "setting map: type_to_vdw_radius_h_bond_type_map[" << te << "] to ("
-	 // << r << "," << t << ")" << std::endl;
-	 type_to_vdw_radius_map[te] = r;
+      if (! te.empty()) {
+	 std::map<std::string, double>::const_iterator it_type =
+	    type_to_vdw_radius_map.find(te);
+	 if (it_type == type_to_vdw_radius_map.end()) {
+	    // didn't find it. so look it up and add it.
+	    if (geom_p)
+	       r = type_energy_to_radius(te);
+	    if (false)
+	       std::cout << "setting ligand atom map: type_to_vdw_radius_h_bond_type_map["
+			 << std::setw(4) << te << "] to " << r << std::endl;
+	    type_to_vdw_radius_map[te] = r;
+	 } else {
+	    r = it_type->second;
+	 }
+	 central_residue_atoms_vdw_radius_map[at] = r;
       } else {
-	 r = it_type->second;
+	 std::cout << "failed to find type-energy for atom " << atom_spec_t(at) << std::endl;
       }
-      central_residue_atoms_vdw_radius_map[at] = r;
    } else {
+      if (false)
+	 std::cout << "radius for atom " << atom_spec_t(at) << " was found in map: value: "
+		   << it->second << std::endl;
       r = it->second;
-   } 
+   }
 
    return r;
 }
 
 
+double
+coot::atom_overlaps_container_t::get_vdw_radius_neighb_atom(int idx_neigh_atom) const {
+
+   // no index checking (a bit cowboy?)
+   //
+   double r = neighb_atom_radius[idx_neigh_atom];
+   return r;
+
+}
 
 double
-coot::atom_overlaps_container_t::get_vdw_radius_neighb_atom(mmdb::Atom *at, unsigned int ires) {
+coot::atom_overlaps_container_t::get_vdw_radius_neighb_atom(mmdb::Atom *at, unsigned int idx_res) {
 
    double r = 1.5;
 
@@ -325,12 +597,11 @@
 
       // What's the energy type of Atom at?
       //
-      std::string te = neighb_dictionaries[ires].type_energy(at->GetAtomName());
+      std::string te = neighb_dictionaries[idx_res].type_energy(at->GetAtomName());
       std::map<std::string, double>::const_iterator it_type = type_to_vdw_radius_map.find(te);
       if (it_type == type_to_vdw_radius_map.end()) {
 	 // didn't find te in types map. so look it up from the dictionary and add to the types map
 	 r = geom_p->get_energy_lib_atom(te).vdw_radius;
-	 hb_t t = geom_p->get_energy_lib_atom(te).hb_type;
 	 type_to_vdw_radius_map[te] = r;
       } else {
 	 r = it_type->second;
@@ -338,10 +609,10 @@
       neighbour_atoms_vdw_radius_map[at] = r;
    } else {
       r = it->second;
-   } 
+   }
 
    return r;
-} 
+}
 
 
 
@@ -356,3 +627,1661 @@
    return type;
 } 
 
+
+
+// probably not the function that you're looking for.
+// Maybe delete this?
+void
+coot::atom_overlaps_container_t::contact_dots_for_overlaps() const {
+
+   double spike_length = 0.5;
+   double clash_dist = 0.4;
+
+   double dot_density = 0.35;
+   dot_density = 1.0;
+
+   double   phi_step = 5.0 * (M_PI/180.0);
+   double theta_step = 5.0 * (M_PI/180.0);
+   if (dot_density > 0.0) {
+      phi_step   /= dot_density;
+      theta_step /= dot_density;
+   }
+
+   for (unsigned int i=0; i<overlaps.size(); i++) {
+
+      // std::cout << "considering overlap idx: " << i << std::endl;
+
+      clipper::Coord_orth pt_at_1(overlaps[i].atom_1->x,
+				  overlaps[i].atom_1->y,
+				  overlaps[i].atom_1->z);
+      clipper::Coord_orth pt_at_2(overlaps[i].atom_2->x,
+				  overlaps[i].atom_2->y,
+				  overlaps[i].atom_2->z);
+      const double &r_1 = overlaps[i].r_1;
+      const double &r_2 = overlaps[i].r_2;
+      const int &idx =    overlaps[i].ligand_atom_index;
+      double r_2_sqrd = r_2 * r_2;
+      double r_2_plus_prb_squard  = r_2_sqrd + 2 * r_2 * probe_radius + probe_radius * probe_radius;
+      double r_2_minux_prb_squard = r_2_sqrd - 2 * r_2 * probe_radius + probe_radius * probe_radius;
+      //
+      bool done_atom_name = false;
+
+      bool even = true;
+      for (double theta=0; theta<M_PI; theta+=theta_step) {
+	 double phi_step_inner = phi_step + 0.1 * pow(theta-0.5*M_PI, 2);
+	 for (double phi=0; phi<2*M_PI; phi+=phi_step_inner) {
+	    if (even) {
+	       clipper::Coord_orth pt(r_1*cos(phi)*sin(theta),
+				      r_1*sin(phi)*sin(theta),
+				      r_1*cos(theta));
+	       clipper::Coord_orth pt_at_surface = pt + pt_at_1;
+	       double d_sqrd = (pt_at_2 - pt_at_surface).lengthsq();
+
+	       // std::cout << "comparing " << sqrt(d_sqrd) << " vs " << sqrt(r_2_plus_prb_squard)
+	       // << " with r_2 " << r_2 << std::endl;
+
+	       if (d_sqrd > r_2_plus_prb_squard) {
+
+		  bool draw_it = ! is_inside_another_ligand_atom(idx, pt_at_surface);
+
+		  if (false) // debugging
+		     if (std::string(overlaps[i].atom_1->name) != " HO3")
+			draw_it = false;
+
+		  if (draw_it) {
+
+		     std::string type = "wide-contact";
+		     bool only_pt = true; // not a spike
+
+		     if (d_sqrd < r_2_sqrd)
+			type = "close-contact";
+
+		     if (d_sqrd < (r_2_sqrd - 2 * r_2 * clash_dist + clash_dist * clash_dist)) {
+			type = "clash";
+			only_pt = false;
+		     }
+
+		     if (overlaps[i].is_h_bond) {
+			type = "H-bond";
+		     }
+
+		     if (false) // debugging
+			if (! done_atom_name) {
+			   std::cout << "   spike for atom " << coot::atom_spec_t(overlaps[i].atom_1)
+				     << std::endl;
+			   done_atom_name = true;
+			}
+
+		     clipper::Coord_orth pt_spike_inner = pt_at_surface;
+		     if (! only_pt) {
+			std::cout << "considering overlap idx: " << i << " "
+				  << atom_spec_t(overlaps[i].atom_1) << " to "
+				  << atom_spec_t(overlaps[i].atom_2) << std::endl;
+
+			clipper::Coord_orth vect_to_pt_1 = pt_at_1 - pt_at_surface;
+			clipper::Coord_orth vect_to_pt_1_unit(vect_to_pt_1.unit());
+
+			// these days, spikes project away from the atom, not inwards
+			//
+			// clipper::Coord_orth pt_spike_inner = pt_at_surface + spike_length * vect_to_pt_1_unit;
+			pt_spike_inner = pt_at_surface - spike_length * vect_to_pt_1_unit;
+		     }
+
+		     // on the surface of atom_1 inside the sphere of atom_2
+		     std::cout << "spike "
+			       << type << " "
+			       << pt_at_surface.x() << " "
+			       << pt_at_surface.y() << " "
+			       << pt_at_surface.z() << " to "
+			       << pt_spike_inner.x() << " "
+			       << pt_spike_inner.y() << " "
+			       << pt_spike_inner.z()
+			       << " theta " << theta << " phi " << phi
+			       << std::endl;
+		  }
+	       }
+	    }
+	 }
+      }
+   }
+}
+
+bool
+coot::atom_overlaps_container_t::is_inside_another_ligand_atom(int idx,
+							       const clipper::Coord_orth &dot_pt) const {
+   bool r = false;
+
+   if (idx >= 0) {
+
+      std::map<int, std::vector<std::pair<mmdb::Atom *, double> > >::const_iterator it;
+      it = ligand_atom_neighbour_map.find(idx);
+
+      if (it != ligand_atom_neighbour_map.end()) {
+
+	 const std::vector<std::pair<mmdb::Atom *, double> > &v = it->second;
+	 for (unsigned int i=0; i<v.size(); i++) {
+	    clipper::Coord_orth pt = co(v[i].first);
+	    double dist_sqrd = (dot_pt - pt).lengthsq();
+
+	    const double &radius_other = v[i].second;
+	    if (dist_sqrd < radius_other * radius_other) {
+	       r = true;
+	       break;
+	    }
+	 }
+      } else {
+	 std::cout << "Opps! Missing in ligand_atom_neighbour_map: idx " << idx << std::endl;
+      }
+   }
+   return r;
+}
+bool
+coot::atom_overlaps_container_t::is_inside_another_ligand_atom(int idx,
+							       const clipper::Coord_orth &probe_pos,
+							       const clipper::Coord_orth &dot_pt) const {
+
+   // for better speed, change the atom -> radius map to atom index -> radius vector
+   // (and directly look up the radius).
+
+   bool consider_probe_also = false; // if this is true, then don't make surface points for inner cusps
+   
+   bool r = false;
+
+   if (idx >= 0) {
+
+      const std::vector<std::pair<mmdb::Atom *, double> > &v = ligand_atom_neighbour_map.find(idx)->second;
+      for (unsigned int i=0; i<v.size(); i++) {
+	 clipper::Coord_orth pt = co(v[i].first);
+	 double dist_sqrd = (dot_pt - pt).lengthsq(); // should be r_1 squared, right?
+	 double radius_other = v[i].second;
+	 radius_other += probe_radius;
+	 if (dist_sqrd < radius_other * radius_other) {
+	    r = true;
+	    break;
+	 }
+      }
+   }
+   return r;
+}
+
+
+coot::atom_overlaps_dots_container_t
+coot::atom_overlaps_container_t::contact_dots_for_ligand() { // or residue
+
+   double dot_density_in = 1.05;
+   atom_overlaps_dots_container_t ao;
+   mmdb::realtype max_dist = 4.0; // max distance for an interaction
+
+   bool excl_mc_flag = true; // exclude main-chain to main-chain interactions also
+
+   if (mol) {
+      mmdb::Contact *pscontact = NULL;
+      int n_contacts;
+      float min_dist = 0.01;
+      long i_contact_group = 1;
+      mmdb::mat44 my_matt;
+      mmdb::SymOps symm;
+      for (int i=0; i<4; i++)
+	 for (int j=0; j<4; j++)
+	    my_matt[i][j] = 0.0;
+      for (int i=0; i<4; i++) my_matt[i][i] = 1.0;
+
+      mmdb::Atom **ligand_residue_atoms = 0;
+      int n_ligand_residue_atoms;
+      res_central->GetAtomTable(ligand_residue_atoms, n_ligand_residue_atoms);
+
+      std::vector<residue_spec_t> env_residue_specs(neighbours.size());
+      for (unsigned int i=0; i<neighbours.size(); i++)
+	 env_residue_specs[i] = residue_spec_t(neighbours[i]);
+      add_residue_neighbour_index_to_neighbour_atoms();
+
+      int mask_mode = 0; // all atoms
+      int i_sel_hnd_env_atoms = specs_to_atom_selection(env_residue_specs, mol, mask_mode);
+
+      mmdb::Atom **env_residue_atoms = 0;
+      int n_env_residue_atoms;
+      mol->GetSelIndex(i_sel_hnd_env_atoms, env_residue_atoms, n_env_residue_atoms);
+      setup_env_residue_atoms_radii(i_sel_hnd_env_atoms);
+
+      mol->SeekContacts(ligand_residue_atoms, n_ligand_residue_atoms,
+			env_residue_atoms, n_env_residue_atoms,
+			0, max_dist,
+			1, // 0: in same residue also?
+			pscontact, n_contacts,
+			0, &my_matt, i_contact_group);
+
+      if (n_contacts > 0) {
+	 if (pscontact) {
+
+	    // which atoms are close to which other atoms?
+	    std::map<int, std::vector<int> > contact_map; // these atoms can have nbc interactions
+	    std::map<int, std::vector<int> > bonded_map;  // these atoms are bonded and can mask
+
+	    // the dots of an atom
+	    // which atom names of which residues are bonded or 1-3 related? (update the map
+	    // as you find and add new residue types in bonded_angle_or_ring_related().
+	    std::map<std::string, std::vector<std::pair<std::string, std::string> > > bonded_neighbours;
+	    // similar thinking: update the ring list map
+	    std::map<std::string, std::vector<std::vector<std::string> > > ring_list_map;
+
+	    for (int i=0; i<n_contacts; i++) {
+	       atom_interaction_type ait =
+		  bonded_angle_or_ring_related(mol, // also check links
+					       ligand_residue_atoms[pscontact[i].id1],
+					       env_residue_atoms[pscontact[i].id2], excl_mc_flag,
+					       &bonded_neighbours,   // updatedby fn.
+					       &ring_list_map        // updatedby fn.
+					       );
+	       if (ait == CLASHABLE) {
+		  contact_map[pscontact[i].id1].push_back(pscontact[i].id2);
+	       } else {
+		  if (ait == BONDED) {
+		     bonded_map[pscontact[i].id1].push_back(pscontact[i].id2);
+		  }
+	       }
+	    }
+	    // std::cout << "done contact map" << std::endl;
+
+
+	    for (int iat=0; iat<n_ligand_residue_atoms; iat++) {
+
+	       mmdb::Atom *cr_at = ligand_residue_atoms[iat];
+	       clipper::Coord_orth pt_at_1 = co(cr_at);
+
+	       double dot_density = dot_density_in;
+	       if (std::string(cr_at->element) == " H")
+		  dot_density *=0.66; // so that surface dots on H atoms don't appear (weirdly) more fine
+
+	       double   phi_step = 5.0 * (M_PI/180.0);
+	       double theta_step = 5.0 * (M_PI/180.0);
+	       if (dot_density > 0.0) {
+		  phi_step   /= dot_density;
+		  theta_step /= dot_density;
+	       }
+	       double r_1 = get_vdw_radius_ligand_atom(cr_at);
+	       bool even = true;
+	       for (double theta=0; theta<M_PI; theta+=theta_step) {
+		  double phi_step_inner = phi_step + 0.1 * pow(theta-0.5*M_PI, 2);
+		  for (double phi=0; phi<2*M_PI; phi+=phi_step_inner) {
+		     if (even) {
+			clipper::Coord_orth pt(r_1*cos(phi)*sin(theta),
+					       r_1*sin(phi)*sin(theta),
+					       r_1*cos(theta));
+			clipper::Coord_orth pt_at_surface = pt + pt_at_1;
+			bool draw_it = ! is_inside_another_ligand_atom(iat, pt_at_surface);
+
+			bool draw_it_2 = ! is_inside_an_env_atom_to_which_its_bonded(iat,
+										     bonded_map[iat],
+										     env_residue_atoms,
+										     pt_at_surface);
+
+			if (draw_it && draw_it_2) {
+
+			   // is the point on the surface of cr_at inside the sphere
+			   // of an environment atom?
+			   // If so, we want to know which one to which it was closest
+
+			   double biggest_overlap = -1; // should be positive if we get a hit
+			   mmdb::Atom *atom_with_biggest_overlap = 0;
+			   double r_2_for_biggest_overlap = 0;
+
+			   // now check which atom this is clashing with (if any) and pick the
+			   // one with the biggest overlap
+			   //
+			   const std::vector<int> &v = contact_map[iat];
+			   for (unsigned int jj=0; jj<v.size(); jj++) {
+
+			      mmdb::Atom *neighb_atom = env_residue_atoms[v[jj]];
+
+			      // turn off main-chain to main-chain interactions (to match the dots from probe)
+			      if (is_main_chain_p(cr_at)) // this might be true for amino-acid residues
+				 if (is_main_chain_p(neighb_atom))
+				    continue;
+
+			      double r_2 = get_vdw_radius_neighb_atom(v[jj]);
+			      double r_2_sqrd = r_2 * r_2;
+
+			      // note that we want to check against the outside of the probe
+			      // sphere - not the middle of the probe sphere - and
+			      // thus we will pick up more wide contacts (like molprobity probe)
+
+			      double rmp = 1.6;  // radius multiplier
+			      double r_2_plus_prb_squard =
+				 r_2_sqrd + 2 * r_2 * rmp * probe_radius + rmp * rmp * probe_radius * probe_radius;
+
+			      clipper::Coord_orth pt_na = co(neighb_atom);
+			      double d_sqrd = (pt_na - pt_at_surface).lengthsq();
+
+			      if (false)
+				 std::cout << " for atom "
+					   << atom_spec_t(env_residue_atoms[v[jj]])
+					   << " comparing " << d_sqrd << " vs "
+					   << r_2_plus_prb_squard << " with r_2 " << r_2
+					   << " probe_radius " << probe_radius << std::endl;
+
+			      if (d_sqrd < r_2_plus_prb_squard) {
+
+				 // OK it was close to something.
+				 double delta_d_sqrd = r_2_plus_prb_squard - d_sqrd;
+				 if (delta_d_sqrd > biggest_overlap) {
+				    biggest_overlap = delta_d_sqrd;
+				    atom_with_biggest_overlap = neighb_atom;
+				    r_2_for_biggest_overlap = r_2;
+				 }
+			      }
+			   }
+
+			   if (atom_with_biggest_overlap) {
+			      double d_surface_pt_to_atom_sqrd =
+				 (co(atom_with_biggest_overlap)-pt_at_surface).lengthsq();
+			      double d_surface_pt_to_atom = sqrt(d_surface_pt_to_atom_sqrd);
+			      double overlap_delta = r_2_for_biggest_overlap - d_surface_pt_to_atom;
+
+			      // first is yes/no, second is H-is-on-ligand?
+			      std::pair<bool, bool> might_be_h_bond_flag =
+				 is_h_bond_H_and_acceptor(cr_at, atom_with_biggest_overlap, udd_h_bond_type_handle);
+			      bool is_h_bond = false;
+			      if (might_be_h_bond_flag.first)
+				 is_h_bond = true;
+			      std::pair<std::string, std::string> c_type_col =
+				 overlap_delta_to_contact_type(overlap_delta, is_h_bond);
+			      const std::string &c_type = c_type_col.first;
+			      const std::string &col    = c_type_col.second;
+
+			      if (false)
+				 std::cout << "spike "
+					   << c_type << " "
+					   << pt_at_surface.x() << " "
+					   << pt_at_surface.y() << " "
+					   << pt_at_surface.z() << " to "
+					   << pt_at_surface.x() << " "
+					   << pt_at_surface.y() << " "
+					   << pt_at_surface.z()
+					   << " theta " << theta << " phi " << phi
+					   << std::endl;
+
+			      if (c_type != "clash") {
+				 atom_overlaps_dots_container_t::dot_t dot(overlap_delta, col, pt_at_surface);
+				 ao.dots[c_type].push_back(dot);
+			      } else {
+				 clipper::Coord_orth vect_to_pt_1 = pt_at_1 - pt_at_surface;
+				 clipper::Coord_orth vect_to_pt_1_unit(vect_to_pt_1.unit());
+				 // these days, spikes project away from the atom, not inwards
+				 // clipper::Coord_orth pt_spike_inner =
+				 // pt_at_surface + clash_spike_length * vect_to_pt_1_unit;
+				 clipper::Coord_orth pt_spike_inner =
+				    pt_at_surface -
+				    0.34* sqrt(biggest_overlap) * clash_spike_length * vect_to_pt_1_unit;
+				 std::pair<clipper::Coord_orth, clipper::Coord_orth> p(pt_at_surface,
+										       pt_spike_inner);
+				 ao.clashes.positions.push_back(p);
+			      }
+
+			   } else {
+
+			      // no environment atom was close to this ligand atom, so just add
+			      // a surface point
+
+			      if (false)
+				 std::cout << "spike-surface "
+					   << pt_at_surface.x() << " "
+					   << pt_at_surface.y() << " "
+					   << pt_at_surface.z() << std::endl;
+
+			      atom_overlaps_dots_container_t::dot_t dot(0, "grey", pt_at_surface);
+			      ao.dots["vdw-surface"].push_back(dot);
+			   }
+			}
+		     }
+		  }
+	       }
+	    }
+	 }
+      }
+   }
+   return ao;
+}
+
+// dot_density_in is default 0.5.
+// bool make_vdw_surface is default false.
+//
+coot::atom_overlaps_dots_container_t
+coot::atom_overlaps_container_t::all_atom_contact_dots(double dot_density_in,
+						       bool make_vdw_surface) {
+
+   coot::atom_overlaps_dots_container_t ao;
+
+   if (mol) {
+      mmdb::realtype max_dist = 1.75 + 1.75 + 2 * probe_radius; // max distance for an interaction
+      mmdb::realtype min_dist = 0.01;
+      int i_sel_hnd = mol->NewSelection(); // d
+      mol->SelectAtoms (i_sel_hnd, 0, "*",
+			mmdb::ANY_RES, // starting resno, an int
+			"*", // any insertion code
+			mmdb::ANY_RES, // ending resno
+			"*", // ending insertion code
+			"*", // any residue name
+			"*", // atom name
+			"*", // elements
+			"*"  // alt loc.
+			);
+
+#ifdef HAVE_CXX_THREAD
+
+      unsigned int n_threads = get_max_number_of_threads();
+
+      if (n_threads == 0) {
+	 ao = all_atom_contact_dots_internal_single_thread(dot_density_in, mol, i_sel_hnd, i_sel_hnd,
+							   min_dist, max_dist, make_vdw_surface);
+      } else {
+	 ao = all_atom_contact_dots_internal_multi_thread(dot_density_in, mol, i_sel_hnd, i_sel_hnd,
+							  min_dist, max_dist, make_vdw_surface);
+      }
+
+#else
+
+      // set ao using non-threaded version
+      //
+      ao = all_atom_contact_dots_internal_single_thread(dot_density_in, mol, i_sel_hnd, i_sel_hnd,
+							min_dist, max_dist, make_vdw_surface);
+
+#endif // HAVE_CXX_THREAD
+
+      mol->DeleteSelection(i_sel_hnd);
+   }
+   return ao;
+}
+
+
+
+coot::atom_overlaps_dots_container_t
+coot::atom_overlaps_container_t::all_atom_contact_dots_internal_single_thread(double dot_density_in,
+									      mmdb::Manager *mol,
+									      int i_sel_hnd_1,
+									      int i_sel_hnd_2,
+									      mmdb::realtype min_dist,
+									      mmdb::realtype max_dist,
+									      bool make_vdw_surface) {
+
+   coot::atom_overlaps_dots_container_t ao;
+   bool exclude_mc_flag = true;
+
+   long i_contact_group = 1;
+   mmdb::mat44 my_matt;
+   mmdb::SymOps symm;
+   for (int i=0; i<4; i++)
+      for (int j=0; j<4; j++)
+	 my_matt[i][j] = 0.0;
+   for (int i=0; i<4; i++) my_matt[i][i] = 1.0;
+
+   mmdb::Atom **atom_selection = 0;
+   int n_selected_atoms;
+   mol->GetSelIndex(i_sel_hnd_1, atom_selection, n_selected_atoms);
+   setup_env_residue_atoms_radii(i_sel_hnd_1);
+   mmdb::Contact *pscontact = NULL;
+   int n_contacts;
+   mol->SeekContacts(atom_selection, n_selected_atoms,
+		     atom_selection, n_selected_atoms,
+		     0.01, max_dist,
+		     0, // 0: in same residue also?
+		     pscontact, n_contacts,
+		     0, &my_matt, i_contact_group);
+   std::cout << "found " << n_selected_atoms << " selected atoms" << std::endl;
+   std::cout << "found " << n_contacts << " all-atom contacts" << std::endl;
+   if (n_contacts > 0) {
+      if (pscontact) {
+	 // which atoms are close to which other atoms?
+	 std::map<int, std::vector<int> > contact_map; // these atoms can have nbc interactions
+	 std::map<int, std::vector<int> > bonded_map;  // these atoms are bonded and can mask
+	 // the dots of an atom
+	 // which atom names of which residues are bonded or 1-3 related? (update the map
+	 // as you find and add new residue types in bonded_angle_or_ring_related().
+	 std::map<std::string, std::vector<std::pair<std::string, std::string> > > bonded_neighbours;
+	 // similar thinking: update the ring list map
+	 std::map<std::string, std::vector<std::vector<std::string> > > ring_list_map;
+
+	 // initialize contact_map and bonded_map - not sure if this speeds things up - but it
+	 // doesn't seem to slow things down.
+	 //
+	 std::vector<int> dum;
+	 for (int iat=0; iat<n_selected_atoms; iat++)
+	    contact_map[iat] = dum;
+	 for (int iat=0; iat<n_selected_atoms; iat++)
+	    bonded_map[iat] = dum;
+
+	 for (int i=0; i<n_contacts; i++) {
+	    if (pscontact[i].id1 < pscontact[i].id2) {
+	       if (clashable_alt_confs(atom_selection[pscontact[i].id1], atom_selection[pscontact[i].id2])) {
+		  atom_interaction_type ait =
+		     bonded_angle_or_ring_related(mol, // also check links
+						  atom_selection[pscontact[i].id1],
+						  atom_selection[pscontact[i].id2], exclude_mc_flag,
+						  &bonded_neighbours,   // updatedby fn.
+						  &ring_list_map        // updatedby fn.
+						  );
+		  if (ait == CLASHABLE) {
+		     contact_map[pscontact[i].id1].push_back(pscontact[i].id2);
+		     contact_map[pscontact[i].id2].push_back(pscontact[i].id1);
+		  } else {
+		     if (ait == BONDED) {
+			bonded_map[pscontact[i].id1].push_back(pscontact[i].id2);
+			bonded_map[pscontact[i].id2].push_back(pscontact[i].id1);
+		     }
+		  }
+	       }
+	    }
+	 }
+
+	 std::cout << "done contact map" << std::endl;
+
+	 // atom_spec_t debug_spec("A", 477, "", " OE2", "");
+	 atom_spec_t debug_spec("A", 523, "", " HE1", "");
+	 atom_spec_t debug_spec_2("A", 480, "", " O  ", "");
+
+	 for (int iat=0; iat<n_selected_atoms; iat++) {
+
+	    mmdb::Atom *at = atom_selection[iat];
+
+	    // if (!(atom_spec_t(at) == debug_spec))
+	    // continue;
+	    // if ((atom_spec_t(at) == debug_spec) || (atom_spec_t(at) == debug_spec_2)) {
+	    // 		  // don't stop this atom
+	    // } else {
+	    // continue;
+	    // }
+
+	    clipper::Coord_orth pt_at_1 = co(at);
+	    double dot_density = dot_density_in;
+	    if (std::string(at->element) == " H")
+	       dot_density *=0.66; // so that surface dots on H atoms don't appear (weirdly) more fine
+	    double   phi_step = 5.0 * (M_PI/180.0);
+	    double theta_step = 5.0 * (M_PI/180.0);
+	    if (dot_density > 0.0) {
+	       phi_step   /= dot_density;
+	       theta_step /= dot_density;
+	    }
+	    double r_1 = get_vdw_radius_neighb_atom(iat);
+	    bool even = true;
+	    for (double theta=0; theta<M_PI; theta+=theta_step) {
+	       double phi_step_inner = phi_step + 0.1 * pow(theta-0.5*M_PI, 2);
+	       for (double phi=0; phi<2*M_PI; phi+=phi_step_inner) {
+		  if (even) {
+		     clipper::Coord_orth pt(r_1*cos(phi)*sin(theta),
+					    r_1*sin(phi)*sin(theta),
+					    r_1*cos(theta));
+		     clipper::Coord_orth pt_at_surface = pt + pt_at_1;
+		     bool draw_it = ! is_inside_another_atom_to_which_its_bonded(iat, at,
+										 pt_at_surface,
+										 bonded_map[iat],
+										 atom_selection,
+										 neighb_atom_radius);
+
+		     if (draw_it) {
+
+			double biggest_overlap = -1; // should be positive if we get a hit
+			mmdb::Atom *atom_with_biggest_overlap = 0;
+			double r_2_for_biggest_overlap = 0;
+
+			// now check which atom this is clashing with (if any) and pick the
+			// one with the biggest overlap
+			//
+			const std::vector<int> &v = contact_map[iat];
+			for (unsigned int jj=0; jj<v.size(); jj++) {
+			   mmdb::Atom *neighb_atom = atom_selection[v[jj]];
+			   double r_2 = get_vdw_radius_neighb_atom(v[jj]);
+			   double r_2_sqrd = r_2 * r_2;
+			   double r_2_plus_prb_squard = r_2_sqrd + 2 * r_2 * probe_radius +
+			      4 * probe_radius * probe_radius;
+			   clipper::Coord_orth pt_na = co(neighb_atom);
+			   double d_sqrd = (pt_na - pt_at_surface).lengthsq();
+
+			   if (false)
+			      std::cout << " for " << atom_spec_t(at) << " " << atom_spec_t(neighb_atom)
+					<< " comparing " << d_sqrd << " vs " << r_2_plus_prb_squard
+					<< std::endl;
+			   if (d_sqrd < r_2_plus_prb_squard) {
+			      // a contact dot on something
+			      double delta_d_sqrd = r_2_plus_prb_squard - d_sqrd;
+			      if (delta_d_sqrd > biggest_overlap) {
+				 biggest_overlap = delta_d_sqrd;
+				 atom_with_biggest_overlap = neighb_atom;
+				 r_2_for_biggest_overlap = r_2;
+			      }
+			   }
+			}
+
+			if (atom_with_biggest_overlap) {
+			   double d_surface_pt_to_atom_sqrd =
+			      (co(atom_with_biggest_overlap) - pt_at_surface).lengthsq();
+			   double d_surface_pt_to_atom = sqrt(d_surface_pt_to_atom_sqrd);
+			   double overlap_delta = r_2_for_biggest_overlap - d_surface_pt_to_atom;
+			   // first is yes/no, second is H-is-on-ligand?
+			   // allow waters to H-bond (without being an H)
+			   std::pair<bool, bool> might_be_h_bond_flag =
+			      is_h_bond_H_and_acceptor(at, atom_with_biggest_overlap, udd_h_bond_type_handle);
+			   bool is_h_bond = false;
+			   if (might_be_h_bond_flag.first)
+			      is_h_bond = true;
+
+			   std::pair<std::string, std::string> c_type_col =
+			      overlap_delta_to_contact_type(overlap_delta, is_h_bond);
+			   const std::string &c_type = c_type_col.first;
+			   const std::string &col    = c_type_col.second;
+
+			   clipper::Coord_orth pt_spike_inner = pt_at_surface;
+			   if (c_type == "clash") {
+			      clipper::Coord_orth vect_to_pt_1 = pt_at_1 - pt_at_surface;
+			      clipper::Coord_orth vect_to_pt_1_unit(vect_to_pt_1.unit());
+			      pt_spike_inner = pt_at_surface -
+				 0.3 * sqrt(biggest_overlap) * clash_spike_length * vect_to_pt_1_unit;
+			   }
+
+			   if (c_type != "clash") {
+
+			      // draw dot if these are atoms from different residues or this is not
+			      // a wide contact
+			      if (at->residue != atom_with_biggest_overlap->residue) {
+				 atom_overlaps_dots_container_t::dot_t dot(overlap_delta, col, pt_at_surface);
+				 ao.dots[c_type].push_back(dot);
+			      }
+			   } else {
+			      // clash
+			      clipper::Coord_orth vect_to_pt_1 = pt_at_1 - pt_at_surface;
+			      clipper::Coord_orth vect_to_pt_1_unit(vect_to_pt_1.unit());
+			      // these days, spikes project away from the atom, not inwards
+			      // clipper::Coord_orth pt_spike_inner =
+			      // pt_at_surface + clash_spike_length * vect_to_pt_1_unit;
+			      clipper::Coord_orth pt_spike_inner =
+				 pt_at_surface -
+				 0.34* sqrt(biggest_overlap) * clash_spike_length * vect_to_pt_1_unit;
+			      std::pair<clipper::Coord_orth, clipper::Coord_orth> p(pt_at_surface,
+										    pt_spike_inner);
+			      ao.clashes.positions.push_back(p);
+			   }
+
+			} else {
+
+			   // no environment atom was close to this ligand atom, so just add
+			   // a surface point
+
+			   if (make_vdw_surface) {
+			      atom_overlaps_dots_container_t::dot_t dot(0, "grey", pt_at_surface);
+			      ao.dots["vdw-surface"].push_back(dot);
+			   }
+			}
+		     }
+		  }
+	       }
+	    }
+	 }
+      }
+   }
+   return ao;
+}
+
+
+
+
+coot::atom_overlaps_dots_container_t
+coot::atom_overlaps_container_t::all_atom_contact_dots_internal_multi_thread(double dot_density_in,
+									     mmdb::Manager *mol,
+									     int i_sel_hnd_1,
+									     int i_sel_hnd_2,
+									     mmdb::realtype min_dist,
+									     mmdb::realtype max_dist,
+									     bool make_vdw_surface) {
+   
+   coot::atom_overlaps_dots_container_t ao;
+#ifdef HAVE_CXX_THREAD
+   bool exclude_mc_flag = true;
+
+   long i_contact_group = 1;
+   mmdb::mat44 my_matt;
+   mmdb::SymOps symm;
+   for (int i=0; i<4; i++)
+      for (int j=0; j<4; j++)
+	 my_matt[i][j] = 0.0;
+   for (int i=0; i<4; i++) my_matt[i][i] = 1.0;
+
+   mmdb::Atom **atom_selection = 0;
+   int n_selected_atoms;
+   mol->GetSelIndex(i_sel_hnd_1, atom_selection, n_selected_atoms);
+   setup_env_residue_atoms_radii(i_sel_hnd_1);
+   mmdb::Contact *pscontact = NULL;
+   int n_contacts;
+   mol->SeekContacts(atom_selection, n_selected_atoms,
+		     atom_selection, n_selected_atoms,
+		     0.01, max_dist,
+		     0, // 0: in same residue also?
+		     pscontact, n_contacts,
+		     0, &my_matt, i_contact_group);
+   std::cout << "found " << n_selected_atoms << " selected atoms" << std::endl;
+   std::cout << "found " << n_contacts << " all-atom contacts" << std::endl;
+   if (n_contacts > 0) {
+      if (pscontact) {
+	 // which atoms are close to which other atoms?
+	 std::map<int, std::vector<int> > contact_map; // these atoms can have nbc interactions
+	 std::map<int, std::vector<int> > bonded_map;  // these atoms are bonded and can mask
+	 // the dots of an atom
+	 // which atom names of which residues are bonded or 1-3 related? (update the map
+	 // as you find and add new residue types in bonded_angle_or_ring_related().
+	 std::map<std::string, std::vector<std::pair<std::string, std::string> > > bonded_neighbours;
+	 // similar thinking: update the ring list map
+	 std::map<std::string, std::vector<std::vector<std::string> > > ring_list_map;
+
+	 // initialize contact_map and bonded_map - not sure if this speeds things up - but it
+	 // doesn't seem to slow things down.
+	 //
+	 for (int iat=0; iat<n_selected_atoms; iat++) {
+	    contact_map[iat].reserve(12);
+	 }
+	 for (int iat=0; iat<n_selected_atoms; iat++) {
+	    bonded_map[iat].reserve(4);
+	 }
+
+	 for (int i=0; i<n_contacts; i++) {
+	    if (pscontact[i].id1 < pscontact[i].id2) {
+	       if (clashable_alt_confs(atom_selection[pscontact[i].id1], atom_selection[pscontact[i].id2])) {
+		  atom_interaction_type ait =
+		     bonded_angle_or_ring_related(mol, // also check links
+						  atom_selection[pscontact[i].id1],
+						  atom_selection[pscontact[i].id2], exclude_mc_flag,
+						  &bonded_neighbours,   // updatedby fn.
+						  &ring_list_map        // updatedby fn.
+						  );
+		  if (ait == CLASHABLE) {
+		     contact_map[pscontact[i].id1].push_back(pscontact[i].id2);
+		     contact_map[pscontact[i].id2].push_back(pscontact[i].id1);
+		  } else {
+		     if (ait == BONDED) {
+			bonded_map[pscontact[i].id1].push_back(pscontact[i].id2);
+			bonded_map[pscontact[i].id2].push_back(pscontact[i].id1);
+		     }
+		  }
+	       }
+	    }
+	 }
+
+	 std::cout << "done contact_map and bonded_map " << std::endl;
+
+	 if (false) { // show contact map:
+	    std::cout << "     contact map: " << contact_map.size() << std::endl;
+	    std::map<int, std::vector<int> >::const_iterator it;
+	    for (it=contact_map.begin(); it!=contact_map.end(); it++) {
+	       for (unsigned int jj=0; jj<it->second.size(); jj++) {
+		  std::cout << "   " << atom_spec_t(atom_selection[it->first]) << " contact to "
+			    << atom_spec_t(atom_selection[it->second[jj]]) << std::endl;
+	       }
+	    }
+	    std::cout << "     bonded map: " << bonded_map.size() << std::endl;
+	    for (it=bonded_map.begin(); it!=bonded_map.end(); it++) {
+	       for (unsigned int jj=0; jj<it->second.size(); jj++) {
+		  std::cout << "   " << atom_spec_t(atom_selection[it->first]) << " bonded to "
+			    << atom_spec_t(atom_selection[it->second[jj]]) << std::endl;
+	       }
+	    }
+	 }
+
+	 unsigned int n_threads = get_max_number_of_threads();
+	 std::vector<std::thread> threads;
+	 unsigned int n_per_thread = n_selected_atoms/n_threads;
+	 std::cout << "n per thread " << n_per_thread << std::endl;
+	 std::vector<atom_overlaps_dots_container_t> results_container_vec(n_threads);
+
+	 for (unsigned int i_thread=0; i_thread<n_threads; i_thread++) {
+	    int iat_start = i_thread * n_per_thread;
+	    int iat_end = iat_start + n_per_thread;
+	    // for the last thread, set the end atom index
+	    if (i_thread == (n_threads - 1))
+	       iat_end = n_selected_atoms; // for loop uses iat_start and tests for < iat_end
+	    
+	    std::cout << "thread: " << i_thread << " from atom " << iat_start << " to " << iat_end << std::endl;
+	    results_container_vec[i_thread] = atom_overlaps_dots_container_t(n_per_thread);
+ 	    threads.push_back(std::thread(contacts_for_atoms, iat_start, iat_end,
+					  atom_selection, contact_map, bonded_map,
+					  neighb_atom_radius, udd_h_bond_type_handle, probe_radius,
+					  dot_density_in, clash_spike_length, make_vdw_surface,
+					  &results_container_vec[i_thread]));
+
+	 }
+	 std::cout << "joining... " << std::endl;
+	 for (unsigned int i_thread=0; i_thread<n_threads; i_thread++)
+	    threads.at(i_thread).join();
+	 std::cout << "joined" << std::endl;
+
+	 if (false) {
+	    for (unsigned int i_thread=0; i_thread<n_threads; i_thread++) {
+	       std::map<std::string, std::vector<atom_overlaps_dots_container_t::dot_t> >::const_iterator it;
+	       for (it =results_container_vec[i_thread].dots.begin();
+		    it!=results_container_vec[i_thread].dots.end();
+		    it++) {
+		  std::cout << "thread  " << i_thread << " results size "
+			    << it->first << " " << it->second.size() << std::endl;
+	       }
+	    }
+	 }
+
+	 std::cout << "consolidating..." << std::endl;
+	 for (unsigned int i_thread=0; i_thread<n_threads; i_thread++)
+	    ao.add(results_container_vec[i_thread]);
+	 if (false) { // debugging
+	    std::cout << "consolidated" << std::endl;
+	    std::map<std::string, std::vector<atom_overlaps_dots_container_t::dot_t> >::const_iterator it;
+	    for (it=ao.dots.begin(); it!=ao.dots.end(); it++)
+	       std::cout << " consolidated size "
+			 << it->first << " " << it->second.size() << std::endl;
+	 }
+      }
+   }
+#endif // HAVE_CXX_THREAD
+
+   return ao;
+}
+
+
+// put results in ao
+//
+void
+coot::atom_overlaps_container_t::contacts_for_atoms(int iat_start, int iat_end,
+						    mmdb::Atom **atom_selection,
+						    const std::map<int, std::vector<int> > &contact_map,
+						    const std::map<int, std::vector<int> > &bonded_map,
+						    const std::vector<double> &neighb_atom_radius,
+						    int udd_h_bond_type_handle,
+						    double probe_radius,
+						    double dot_density_in,
+						    double clash_spike_length,
+						    bool make_vdw_surface,
+						    coot::atom_overlaps_dots_container_t *ao) {
+
+   for (int iat=iat_start; iat<iat_end; iat++) {
+
+      ao->add(contacts_for_atom(iat, atom_selection, contact_map, bonded_map, neighb_atom_radius,
+       				udd_h_bond_type_handle, probe_radius, dot_density_in,
+				clash_spike_length, make_vdw_surface));
+   }
+}
+
+// static
+coot::atom_overlaps_dots_container_t
+coot::atom_overlaps_container_t::contacts_for_atom(int iat,
+						   mmdb::Atom **atom_selection,
+						   const std::map<int, std::vector<int> > &contact_map,
+						   const std::map<int, std::vector<int> > &bonded_map,
+						   const std::vector<double> &neighb_atom_radius,
+						   int udd_h_bond_type_handle,
+						   double probe_radius,
+						   double dot_density_in,
+						   double clash_spike_length,
+						   bool make_vdw_surface) {
+   atom_overlaps_dots_container_t ao;
+
+   mmdb::Atom *at = atom_selection[iat];
+   
+   clipper::Coord_orth pt_at_1 = co(at);
+   double dot_density = dot_density_in;
+   if (std::string(at->element) == " H")
+      dot_density *=0.66; // so that surface dots on H atoms don't appear (weirdly) more fine
+   double   phi_step = 5.0 * (M_PI/180.0);
+   double theta_step = 5.0 * (M_PI/180.0);
+   if (dot_density > 0.0) {
+      phi_step   /= dot_density;
+      theta_step /= dot_density;
+   }
+   double r_1 = neighb_atom_radius[iat];
+   bool even = true;
+   for (double theta=0; theta<M_PI; theta+=theta_step) {
+      double phi_step_inner = phi_step + 0.1 * pow(theta-0.5*M_PI, 2);
+      for (double phi=0; phi<2*M_PI; phi+=phi_step_inner) {
+	 if (even) {
+	    clipper::Coord_orth pt(r_1*cos(phi)*sin(theta),
+				   r_1*sin(phi)*sin(theta),
+				   r_1*cos(theta));
+	    clipper::Coord_orth pt_at_surface = pt + pt_at_1;
+	    std::map<int, std::vector<int> >::const_iterator it = bonded_map.find(iat);
+	    bool draw_it = ! is_inside_another_atom_to_which_its_bonded(iat, at,
+									pt_at_surface,
+									it->second,
+									atom_selection,
+									neighb_atom_radius);
+
+	    if (draw_it) {
+
+	       double biggest_overlap = -1; // should be positive if we get a hit
+	       mmdb::Atom *atom_with_biggest_overlap = 0;
+	       double r_2_for_biggest_overlap = 0;
+
+	       // now check which atom this is clashing with (if any) and pick the
+	       // one with the biggest overlap
+	       //
+	       std::map<int, std::vector<int> >::const_iterator it_contact_map = contact_map.find(iat);
+	       const std::vector<int> &v = it_contact_map->second;
+
+	       for (unsigned int jj=0; jj<v.size(); jj++) {
+		  mmdb::Atom *neighb_atom = atom_selection[v[jj]];
+		  // no contacts for atoms in the same residue
+		  if (neighb_atom->residue == at->residue) continue;
+		  double r_2 = neighb_atom_radius[v[jj]];
+		  double r_2_sqrd = r_2 * r_2;
+		  double r_2_plus_prb_squard = r_2_sqrd + 2 * r_2 * probe_radius +
+		     4 * probe_radius * probe_radius;
+		  clipper::Coord_orth pt_na = co(neighb_atom);
+		  double d_sqrd = (pt_na - pt_at_surface).lengthsq();
+
+		  if (d_sqrd < r_2_plus_prb_squard) {
+		     // a contact dot on something
+		     double delta_d_sqrd = r_2_plus_prb_squard - d_sqrd;
+		     if (delta_d_sqrd > biggest_overlap) {
+			biggest_overlap = delta_d_sqrd;
+			atom_with_biggest_overlap = neighb_atom;
+			r_2_for_biggest_overlap = r_2;
+		     }
+		  }
+	       }
+
+	       if (atom_with_biggest_overlap) {
+		  double d_surface_pt_to_atom_sqrd =
+		     (co(atom_with_biggest_overlap) - pt_at_surface).lengthsq();
+		  double d_surface_pt_to_atom = sqrt(d_surface_pt_to_atom_sqrd);
+		  double overlap_delta = r_2_for_biggest_overlap - d_surface_pt_to_atom;
+		  // first is yes/no, second is H-is-on-ligand?
+		  // allow waters to H-bond (without being an H)
+		  std::pair<bool, bool> might_be_h_bond_flag =
+		     is_h_bond_H_and_acceptor(at, atom_with_biggest_overlap, udd_h_bond_type_handle);
+		  const bool &is_h_bond = might_be_h_bond_flag.first;
+
+		  // std::pair<std::string, std::string> c_type_col =
+		  // overlap_delta_to_contact_type(overlap_delta, is_h_bond);
+
+		  // std::string c_type;
+		  // std::string col;
+
+		  // test_get_type(overlap_delta, is_h_bond, &c_type, &col);
+
+		  // test_get_type(overlap_delta, is_h_bond, &c_type, &col);
+		  
+		  // std::pair<std::string, std::string> ("wide-contact", "blue");
+		  // was
+		  // overlap_delta_to_contact_type(overlap_delta, is_h_bond);
+
+		  // const std::string &c_type = c_type_col.first;
+		  // const std::string &col    = c_type_col.second;
+
+		  std::pair<std::string, std::string> c_type_col =
+		     overlap_delta_to_contact_type(overlap_delta, is_h_bond);
+		  const std::string &c_type = c_type_col.first;
+		  const std::string &col    = c_type_col.second;
+		  
+
+		  clipper::Coord_orth pt_spike_inner = pt_at_surface;
+		  if (c_type == "clash") {
+		     clipper::Coord_orth vect_to_pt_1 = pt_at_1 - pt_at_surface;
+		     clipper::Coord_orth vect_to_pt_1_unit(vect_to_pt_1.unit());
+		     pt_spike_inner = pt_at_surface -
+			0.3 * sqrt(biggest_overlap) * clash_spike_length * vect_to_pt_1_unit;
+		  }
+
+		  if (c_type != "clash") {
+
+		     // draw dot if these are atoms from different residues or this is not
+		     // a wide contact
+		     if (at->residue != atom_with_biggest_overlap->residue) {
+			atom_overlaps_dots_container_t::dot_t dot(overlap_delta, col, pt_at_surface);
+			ao.dots[c_type].push_back(dot);
+		     } else {
+			// this should not happen now that we have the test/continue above
+		     }
+		  } else {
+		     // clash
+		     clipper::Coord_orth vect_to_pt_1 = pt_at_1 - pt_at_surface;
+		     clipper::Coord_orth vect_to_pt_1_unit(vect_to_pt_1.unit());
+		     // these days, spikes project away from the atom, not inwards
+		     // clipper::Coord_orth pt_spike_inner =
+		     // pt_at_surface + clash_spike_length * vect_to_pt_1_unit;
+		     clipper::Coord_orth pt_spike_inner =
+			pt_at_surface -
+			0.34* sqrt(biggest_overlap) * clash_spike_length * vect_to_pt_1_unit;
+		     std::pair<clipper::Coord_orth, clipper::Coord_orth> p(pt_at_surface,
+									   pt_spike_inner);
+		     ao.clashes.positions.push_back(p);
+		  }
+
+	       } else {
+
+		  // no environment atom was close to this ligand atom, so just add
+		  // a surface point
+
+		  if (make_vdw_surface) {
+		     atom_overlaps_dots_container_t::dot_t dot(0, "grey", pt_at_surface);
+		     ao.dots["vdw-surface"].push_back(dot);
+		  }
+	       }
+	    }
+	 }
+      }
+   }
+   return ao;
+}
+
+bool
+coot::atom_overlaps_container_t::clashable_alt_confs(mmdb::Atom *at_1, mmdb::Atom *at_2) const {
+
+   bool r = true;
+
+   std::string alt_conf_1 = at_1->altLoc;
+   std::string alt_conf_2 = at_2->altLoc;
+
+   if (alt_conf_1.empty()) {
+      return true;
+   } else {
+      if (alt_conf_2.empty()) {
+	 return true;
+      } else {
+	 return (alt_conf_1 == alt_conf_2);
+      }
+   }
+
+   return r;
+}
+
+
+
+// for all-atom contacts
+// static (because parallel)
+bool
+coot::atom_overlaps_container_t::is_inside_another_atom_to_which_its_bonded(int atom_idx,
+									    mmdb::Atom *at,
+									    const clipper::Coord_orth &pt_at_surface,
+									    const std::vector<int> &bonded_neighb_indices,
+									    mmdb::Atom **atom_selection,
+									    const std::vector<double> &neighb_atom_radius) {
+
+   bool r = false;
+   // double r_1 = get_vdw_radius_neighb_atom(atom_idx);
+   double r_1 = neighb_atom_radius[atom_idx];
+
+   for (unsigned int i=0; i<bonded_neighb_indices.size(); i++) {
+      mmdb::Atom *clash_neighb = atom_selection[bonded_neighb_indices[i]];
+      clipper::Coord_orth pt_clash_neigh = co(clash_neighb);
+      // double r_2 = get_vdw_radius_neighb_atom(bonded_neighb_indices[i]);
+      double r_2 = neighb_atom_radius[bonded_neighb_indices[i]];
+      double r_2_sqrd = r_2 * r_2;
+      double d_sqrd = (pt_at_surface - pt_clash_neigh).lengthsq();
+//       std::cout << "debug this_atom " << atom_spec_t(at) << " has r_1 " << r_1
+// 		<< " clash atom " << atom_spec_t(clash_neighb) << " has r_2 " << r_2 << std::endl;
+      if (d_sqrd < r_2_sqrd) {
+	 r = true;
+	 break;
+      }
+   }
+
+   return r;
+}
+
+bool
+coot::atom_overlaps_container_t::is_inside_an_env_atom_to_which_its_bonded(int idx,
+									   const std::vector<int> &bonded_neighb_indices,
+									   mmdb::Atom **env_residue_atoms,
+									   const clipper::Coord_orth &pt_at_surface) {
+
+   bool r = false;
+   double r_1 = get_vdw_radius_neighb_atom(idx);
+   for (unsigned int i=0; i<bonded_neighb_indices.size(); i++) {
+      mmdb::Atom *env_atom = env_residue_atoms[bonded_neighb_indices[i]];
+      // std::cout << "testing env_atom: " << atom_spec_t(env_atom) << std::endl;
+      clipper::Coord_orth pt_env_atom = co(env_atom);
+      double r_2 = 1.6;
+      std::string ele(env_atom->element);
+      if (ele == " H")
+	 r_2 = 0.97;
+      double r_2_sqrd = r_2 * r_2;
+      double d_sqrd = (pt_at_surface - pt_env_atom).lengthsq();
+      if (d_sqrd < r_2_sqrd) {
+	 // std::cout << "   " << pt_at_surface.format() << " is inside atom " << atom_spec_t(env_atom) << std::endl;
+	 r = true;
+	 break;
+      }
+   }
+
+   return r;
+}
+
+
+// static
+void
+coot::atom_overlaps_container_t::test_get_type(double delta, bool is_h_bond,
+					       std::string *c_type_p, std::string *col_p) {
+
+   *c_type_p = std::string("wide-contact");
+   *col_p    = std::string("blue");
+}
+
+
+
+// return H-bond, or wide-contact or close-contact or small-overlap or big-overlap or clash
+// We add the mapping to colour here so that it's clearer the relationship betwen the overlap_delta
+// and the colour.  One contact type can have 2 or more colours.
+//
+// static
+std::pair<std::string, std::string>
+coot::atom_overlaps_container_t::overlap_delta_to_contact_type(double delta, bool is_h_bond) {
+
+// from the Word 1999 paper:
+// pale green for H-bonds
+// green (narrow gaps) or yellow (slight overlaps, < 0.2) for good contacts
+// blue for wider gaps > 0.25
+// orange and red for unfavourable (0.25 to 0.4)
+// hot pink for >= 0.4
+
+   std::string type = "wide-contact";
+   std::string colour = "sky";
+
+   if (is_h_bond) {
+      if (delta >= -0.15) { // not 0, so that we turn small overlaps to H-bond dots
+	 delta -= 0.8;
+	 if (delta > 0.4) {
+	    type = "clash";
+	    colour = "hotpink";
+	 } else {
+	    type = "H-bond";
+	    colour = "greentint";
+	 }
+      }
+   } else {
+
+      if (delta > -0.3) {
+	 type = "close-contact";
+	 colour = "royalblue";
+      }
+
+      if (delta > -0.2) {
+	 type = "close-contact";
+	 colour = "sea";
+      }
+
+      if (delta > -0.1) {
+	 type = "small-overlap";
+	 colour = "green";
+      }
+
+      if (delta > 0.10) {
+	 type = "small-overlap";
+	 colour = "yellow";
+      }
+
+      if (delta > 0.2) {
+	 type = "small-overlap";
+	 colour = "orange";
+      }
+
+      if (delta > 0.3) {
+	 type = "small-overlap";
+	 colour = "orangered";
+      }
+
+      if (delta > 0.35) {        // was 0.30, not enough red
+	 type = "big-overlap";
+	 colour = "red";
+      }
+
+      if (delta > 0.45) {         // Word: 0.4
+	 type = "clash";
+	 colour = "hotpink";
+      }
+   }
+   return std::pair<std::string, std::string> (type, colour);
+
+}
+
+void
+coot::atom_overlaps_container_t::add_residue_neighbour_index_to_neighbour_atoms() {
+
+   udd_residue_index_handle = mol->RegisterUDInteger(mmdb::UDR_ATOM, "neighb-residue-index");
+   for (unsigned int i=0; i<neighbours.size(); i++) {
+      mmdb::Atom **residue_atoms = 0;
+      int n_residue_atoms;
+      neighbours[i]->GetAtomTable(residue_atoms, n_residue_atoms);
+      for (int iat=0; iat<n_residue_atoms; iat++) {
+	 mmdb::Atom *at = residue_atoms[iat];
+	 at->PutUDData(udd_residue_index_handle, int(i));
+      }
+   }
+}
+
+
+
+// fill std::vector<double> env_residue_radii;
+//
+// in the case of all-atom env_residues is all atoms
+void
+coot::atom_overlaps_container_t::setup_env_residue_atoms_radii(int i_sel_hnd_env_atoms) {
+
+   double r = 1.5;
+   mmdb::Atom **env_residue_atoms = 0;
+   int n_env_residue_atoms;
+   mol->GetSelIndex(i_sel_hnd_env_atoms, env_residue_atoms, n_env_residue_atoms);
+   neighb_atom_radius.resize(n_env_residue_atoms);
+
+   for (int i=0; i<n_env_residue_atoms; i++) {
+      mmdb::Atom *at = env_residue_atoms[i];
+      mmdb::Residue *res = at->residue;
+      int residue_index;
+      at->GetUDData(udd_residue_index_handle, residue_index);
+      // const dictionary_residue_restraints_t &rest = neighb_dictionaries[residue_index];
+      try {
+	 const dictionary_residue_restraints_t &rest = get_dictionary(res, residue_index);
+	 std::string te = rest.type_energy(at->GetAtomName());
+	 if (! te.empty()) {
+	    std::map<std::string, double>::const_iterator it_type = type_to_vdw_radius_map.find(te);
+	    if (it_type == type_to_vdw_radius_map.end()) {
+	       if (geom_p)
+		  r = type_energy_to_radius(te);
+	       type_to_vdw_radius_map[te] = r;
+	       // std::cout << "debug type_to_vdw_radius_map " << std::setw(4) << te << "   " << r << std::endl;
+	    } else {
+	       r = it_type->second;
+	    }
+	    neighb_atom_radius[i] = r;
+	 }
+      }
+      catch (const std::out_of_range &ex) {
+	 std::cout << "OOpps " << ex.what() << std::endl;
+      }
+   }
+}
+
+double
+coot::atom_overlaps_container_t::type_energy_to_radius(const std::string &te) const {
+
+   double r = 1.2; // 1.17 probe values (from the paper):
+   double r_arom  = 1.05; // 1.0 (paper)
+   double r_polar = 1.05; // 1.0 (paper) 1.05 (measured)
+   // C-H H   1.17
+   // arom H  1.0
+   // polar H 1.0
+   // didn't find te in types map. so look it up from the dictionary and add to the types map
+   if (te[0] == 'H') {
+
+      // HCH1 HCH2 HCH3 HCR6 HCR5 are C-H (default)
+      //
+      if (te == "HNH1") r = r_polar;
+      if (te == "HNT3") r = r_polar;
+      if (te == "HOH1") r = r_polar; // HOH H
+      if (te == "HNC1") r = r_polar; // e.g. ARG
+      if (te == "HNC2") r = r_polar; // ARG
+      if (te == "HNH1") r = r_polar; // mainchain H
+      if (te == "H")    r = r_polar; // unset
+      if (te == "HNH2") r = r_polar; // ND2 of ASN
+      if (te == "HNR5") r = r_arom;  // arom
+   } else {
+      r = geom_p->get_energy_lib_atom(te).vdw_radius;
+   }
+   return r;
+}
+
+// We need here a flag for main-chain -> mainchain interactions also.
+// Currently only consider side-chain -> side-chain and side-chain -> main-chain.
+//
+// Needs clear thinking.
+//
+// If atoms are bonded/1-3/ring related (or (note to self) possibly also 1-4?) then the atoms
+// cannot clash and only these atoms can be neighbouring atoms that are tested to see if
+// surface points are within the sphere of other atoms.
+//
+// so, either clashable or bonded or ignored
+// 
+coot::atom_overlaps_container_t::atom_interaction_type
+coot::atom_overlaps_container_t::bonded_angle_or_ring_related(mmdb::Manager *mol,
+							      mmdb::Atom *at_1,
+							      mmdb::Atom *at_2,
+							      bool exclude_mainchain_also,
+							      std::map<std::string, std::vector<std::pair<std::string, std::string> > > *bonded_neighbours,
+							      std::map<std::string, std::vector<std::vector<std::string> > > *ring_list_map) {
+
+   // At the N terminus, the N has attached Hydrogen atoms H1, H2, H3.  These should not clash
+   // with the N Nitrogen atom.
+
+   // atom_spec_t debug_spec("A", 383, "", " OG ", "");
+   atom_interaction_type ait = CLASHABLE;
+   mmdb::Residue *res_1 = at_1->GetResidue();
+   mmdb::Residue *res_2 = at_2->GetResidue();
+
+   if (res_1 != res_2) {
+      if (are_bonded_residues(res_1, res_2)) {
+	 if (is_main_chain_p(at_1)) {
+	    if (is_main_chain_p(at_2)) {
+	       ait = BONDED; // :-) everything mainchain is bonded to each other (for dot masking)
+	    } else {
+	       // this is a bit hacky - don't allow clashes to CDs in proline from mainchain atoms
+	       // (in other residues)
+	       std::string res_name_2 = res_2->GetResName();
+	       if (res_name_2 == "PRO") {
+		  std::string at_name_1 = at_1->GetAtomName();
+		  std::string at_name_2 = at_2->GetAtomName();
+		  if (at_name_2 == " CD ") {
+		     ait = BONDED;
+		  } else {
+		     ait = CLASHABLE;
+		  }
+	       } else {
+		  ait = CLASHABLE;
+	       }
+	    }
+	 } else {
+
+	    // ---- at_1 is not main-chain
+	    if (is_main_chain_p(at_2)) {
+	       // perhaps the PRO CD - C atoms were the other way around (to above)
+	       std::string at_name_1 = at_1->GetAtomName();
+	       if (at_name_1 == " CD ") {
+		  std::string res_name_2 = res_2->GetResName();
+		  if (res_name_2 == "PRO") {
+		     ait = BONDED;
+		  } else {
+		     ait = CLASHABLE;
+		  }
+	       } else {
+		  ait = CLASHABLE;
+	       }
+	    } else {
+	       ait = CLASHABLE;
+	    }
+	 }
+      } else {
+	 std::string res_name_1 = res_1->GetResName();
+	 std::string res_name_2 = res_2->GetResName();
+	 if (res_name_1 == res_name_2) {
+	    if (res_name_1 == "HOH")
+	       ait = IGNORED;
+	 } else {
+	    ait = CLASHABLE;
+	 }
+      }
+   } else {
+
+      // ------------------- same residue ------------------------
+      //
+      std::string res_name = res_1->GetResName();
+      std::vector<std::pair<std::string, std::string> > bps;
+      std::string atom_name_1 = at_1->name;
+      std::string atom_name_2 = at_2->name;
+      std::map<std::string, std::vector<std::pair<std::string, std::string> > >::const_iterator it;
+      it = bonded_neighbours->find(res_name);
+      if (it == bonded_neighbours->end()) {
+	 bps = geom_p->get_bonded_and_1_3_angles(res_name, protein_geometry::IMOL_ENC_ANY);
+	 // bonded_neighbours[res_name] = bps; // when arg is reference
+	 // bonded_neighbours->insert(res_name, bps);
+	 (*bonded_neighbours)[res_name] = bps;
+      } else {
+	 bps = it->second;
+      }
+      for (unsigned int ipr=0; ipr<bps.size(); ipr++) {
+
+	 if (atom_name_1 == bps[ipr].first) {
+	    if (atom_name_2 == bps[ipr].second) {
+	       ait = BONDED;
+	       break;
+	    }
+	 }
+	 if (atom_name_2 == bps[ipr].first) {
+	    if (atom_name_1 == bps[ipr].second) {
+	       ait = BONDED;
+	       break;
+	    }
+	 }
+      }
+      if (ait == CLASHABLE) { // i.e. so far, unset by this block
+	 bool ringed = in_same_ring(at_1, at_2, *ring_list_map); // update ring_list_map
+	 if (ringed) ait = BONDED;
+      }
+      if (ait == CLASHABLE) {
+	 // N-terminus Hs?
+
+	 // Don't clash on H-H interaction or H-CA either.
+	 //
+	 if (res_1->isNTerminus()) {
+
+	    std::string at_name_1 = at_1->GetAtomName();
+	    std::string at_name_2 = at_2->GetAtomName();
+	    if (at_name_1 == " H1 " || at_name_1 == " H2 " || at_name_1 == " H3 ") {
+	       if (at_name_2 == " H1 " || at_name_2 == " H2 " || at_name_2 == " H3 " ||
+		   at_name_2 == " CA " || at_name_2 == " N  ") {
+		  ait = BONDED;
+	       }
+	    } else {
+	       if (at_name_1 == " CA " || at_name_1 == " N  ") {
+		  if (at_name_2 == " H1 " || at_name_2 == " H2 " || at_name_2 == " H3 ")
+		     ait = BONDED;
+	       }
+	    }
+	 }
+      }
+   }
+
+   if (ait == CLASHABLE) {
+      // maybe it was a link
+      if (is_linked(at_1, at_2))
+	 ait = BONDED;
+   }
+
+   return ait;
+}
+
+bool
+coot::atom_overlaps_container_t::is_linked(mmdb::Atom *at_1,
+					   mmdb::Atom *at_2) const {
+
+   bool status = false;
+   int imod = 1;
+   mmdb::Model *model_p = mol->GetModel(imod);
+   int n_links = model_p->GetNumberOfLinks();
+   if (n_links > 0) {
+      for (int i_link=1; i_link<=n_links; i_link++) {
+	 mmdb::PLink link = model_p->GetLink(i_link);
+	 std::pair<atom_spec_t, atom_spec_t> atoms = link_atoms(link);
+	 atom_spec_t spec_1(at_1);
+	 atom_spec_t spec_2(at_2);
+	 if (spec_1 == atoms.first) {
+	    if (spec_2 == atoms.second) {
+	       status = true;
+	       break;
+	    }
+	 }
+	 if (spec_2 == atoms.first) {
+	    if (spec_1 == atoms.second) {
+	       status = true;
+	       break;
+	    }
+	 }
+      }
+   }
+   return status;
+}
+
+bool
+coot::atom_overlaps_container_t::is_ss_bonded(mmdb::Residue *residue_p) const {
+
+   bool status = false;
+   if (residue_p) {
+      std::string res_name = residue_p->GetResName();
+      if (res_name == "CYS") {
+	 int imod = 1;
+	 mmdb::Model *model_p = mol->GetModel(imod);
+	 // check SS bonds here
+	 status = true;
+      }
+   }
+
+   return status;
+}
+
+
+
+// this modifies ring_list_map, so it is not const.
+bool
+coot::atom_overlaps_container_t::in_same_ring(mmdb::Atom *at_1, mmdb::Atom *at_2,
+					      std::map<std::string, std::vector<std::vector<std::string> > > &ring_list_map) const {
+
+   bool same = false;
+   mmdb::Residue *res_1 = at_1->GetResidue();
+   mmdb::Residue *res_2 = at_2->GetResidue();
+   if (res_1 == res_2) {
+      std::string at_name_1 = at_1->GetAtomName();
+      std::string at_name_2 = at_2->GetAtomName();
+      try {
+	 const dictionary_residue_restraints_t &dict = get_dictionary(res_1, 0);
+	 std::string res_name = at_1->GetResName();
+
+	 // old "calculate ring list each time" way
+	 // same = dict.in_same_ring(at_name_1, at_name_2);
+
+	 std::map<std::string, std::vector<std::vector<std::string> > >::const_iterator it;
+	 it = ring_list_map.find(res_name);
+	 if (it != ring_list_map.end()) {
+	    // same = in_same_ring(at_name_1, at_name_2, it->second);
+	    same = dict.in_same_ring(at_name_1, at_name_2, it->second);
+	 } else {
+	    // on reflection, 5-membered rings are probably not needed because in those cases all atoms are
+	    // bonded or 1-3 angles
+	    std::vector<std::vector<std::string> > ring_list;
+	    if (res_name == "HIS") {
+	       ring_list = his_ring_list();
+	    } else {
+	       if (res_name == "PHE" || res_name == "TYR") {
+		  ring_list = phe_ring_list();
+	       } else {
+		  if (res_name == "TRP") {
+		     ring_list = trp_ring_list();
+		  } else {
+		     if (res_name == "PRO") {
+			ring_list = pro_ring_list();
+		     } else {
+			ring_list = dict.get_ligand_ring_list();
+		     }
+		  }
+	       }
+	    }
+	    ring_list_map[res_name] = ring_list;
+	    // same = in_same_ring(at_name_1, at_name_2, ring_list);
+	    same = dict.in_same_ring(at_name_1, at_name_2, ring_list);
+	 }
+      }
+      catch (const std::out_of_range &ex) {
+	 std::cout << "OOpps " << ex.what() << std::endl;
+      }
+   }
+   return same;
+}
+
+// moved to dictionary_residue_restraints_t
+//
+// bool
+// coot::atom_overlaps_container_t::in_same_ring(const std::string &atom_name_1,
+// 					      const std::string &atom_name_2,
+// 					      const std::vector<std::vector<std::string> > &ring_list) const {
+
+//    bool match = false;
+//    for (unsigned int i=0; i<ring_list.size(); i++) {
+//       unsigned int n_match = 0;
+//       for (unsigned int j=0; j<ring_list[i].size(); j++) {
+// 	 if (ring_list[i][j] == atom_name_1)
+// 	    n_match++;
+// 	 if (ring_list[i][j] == atom_name_2)
+// 	    n_match++;
+//       }
+//       if (n_match == 2) {
+// 	 match = true;
+// 	 break;
+//       }
+//    }
+//    return match;
+// }
+
+std::vector<std::vector<std::string> >
+coot::atom_overlaps_container_t::phe_ring_list() const {
+   std::vector<std::vector<std::string> > v;
+   std::vector<std::string> vi(6);
+   vi[0] = " CG ";
+   vi[1] = " CD1";
+   vi[2] = " CD2";
+   vi[3] = " CE1";
+   vi[4] = " CE2";
+   vi[5] = " CZ ";
+   v.push_back(vi);
+   return v;
+}
+
+
+std::vector<std::vector<std::string> >
+coot::atom_overlaps_container_t::his_ring_list() const {
+   std::vector<std::vector<std::string> > v;
+   std::vector<std::string> vi(5);
+   vi[0] = " CG ";
+   vi[1] = " ND1";
+   vi[2] = " CD2";
+   vi[3] = " NE2";
+   vi[4] = " CE1";
+   v.push_back(vi);
+   return v;
+}
+
+std::vector<std::vector<std::string> >
+coot::atom_overlaps_container_t::trp_ring_list() const {
+
+   std::vector<std::vector<std::string> > v;
+   std::vector<std::string> vi(5);
+   std::vector<std::string> vi2(6);
+   vi[0] = " CG ";
+   vi[1] = " CD1";
+   vi[2] = " NE1";
+   vi[3] = " CE2";
+   vi[4] = " CD2";
+   vi2[0] = " CE2";
+   vi2[1] = " CD2";
+   vi2[2] = " CE3";
+   vi2[3] = " CZ3";
+   vi2[4] = " CH2";
+   vi2[5] = " CZ2";
+   v.push_back(vi);
+   v.push_back(vi2);
+   return v;
+}
+
+std::vector<std::vector<std::string> >
+coot::atom_overlaps_container_t::pro_ring_list() const {
+
+   std::vector<std::vector<std::string> > v;
+   std::vector<std::string> vi(5);
+   vi[0] = " CA ";
+   vi[1] = " CB";
+   vi[2] = " CG";
+   vi[3] = " CD";
+   vi[4] = " N";
+   v.push_back(vi);
+   return v;
+}
+
+
+bool
+coot::atom_overlaps_container_t::are_bonded_residues(mmdb::Residue *res_1, mmdb::Residue *res_2) const {
+
+   bool r = false;
+
+   if (res_1) {
+      if (res_2) {
+	 if (res_1->GetChain() == res_2->GetChain()) {
+
+	    // simple
+
+	    if (abs(res_1->GetSeqNum() - res_2->GetSeqNum()) < 2) {
+	       std::string res_name_1 = res_1->GetResName();
+	       std::string res_name_2 = res_2->GetResName();
+	       if (res_name_1 != "HOH")
+		  if (res_name_2 != "HOH")
+		     r = true;
+	    }
+	 }
+      }
+   }
+   return r;
+}
diff -ruN coot-0.8.7/coot-utils/atom-overlaps.hh coot-0.8.8-pre/coot-utils/atom-overlaps.hh
--- coot-0.8.7/coot-utils/atom-overlaps.hh	2016-09-01 17:13:23.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/atom-overlaps.hh	2017-01-25 14:34:21.000000000 -0800
@@ -31,17 +31,104 @@
 
 namespace coot {
 
+   class atom_overlaps_dots_container_t {
+   public:
+      class spikes_t {
+      public:
+	 std::string type;
+	 std::vector<std::pair<clipper::Coord_orth, clipper::Coord_orth> > positions;
+	 const std::pair<clipper::Coord_orth, clipper::Coord_orth> &operator[](unsigned int idx) {
+	    return positions[idx];
+	 }
+	 unsigned int size() const { return positions.size(); }
+      };
+      class dot_t {
+      public:
+	 double overlap;
+	 clipper::Coord_orth pos;
+	 std::string col;
+	 dot_t(double o, const std::string &col_in, const clipper::Coord_orth &pos_in) {
+	    overlap = o;
+	    pos = pos_in;
+	    col = col_in;
+	 }
+      };
+      atom_overlaps_dots_container_t() {
+	 // I think this speeds things up a bit.
+	 dots["close-contact"].reserve(2500);
+	 dots["small-overlap"].reserve(2500);
+	 dots["wide-contact" ].reserve(2500);
+	 dots["big-overlap"  ].reserve(2500);
+	 dots["H-bond"       ].reserve(2500);
+	 dots["vdw-surface"  ].reserve(2500);
+      }
+
+      // 6,000 a/t -> size 145,000
+      // 1,000 a/t -> size  27,000
+      atom_overlaps_dots_container_t(unsigned int n_atoms_per_thread) {
+
+	 dots["close-contact"].reserve(25 * n_atoms_per_thread);
+	 dots["small-overlap"].reserve(25 * n_atoms_per_thread);
+	 dots["wide-contact" ].reserve(25 * n_atoms_per_thread);
+	 dots["big-overlap"  ].reserve(25 * n_atoms_per_thread);
+	 dots["H-bond"       ].reserve(25 * n_atoms_per_thread);
+	 dots["vdw-surface"  ].reserve(25 * n_atoms_per_thread);
+      }
+
+      std::map<std::string, std::vector<dot_t> > dots;
+      void add(const atom_overlaps_dots_container_t &other) {
+	 std::map<std::string, std::vector<dot_t> >::const_iterator it;
+	 for (it=other.dots.begin(); it!=other.dots.end(); it++)
+	    if (it->second.size())
+	       dots[it->first].insert(dots[it->first].end(),it->second.begin(), it->second.end());
+      }
+      spikes_t clashes;
+      double score() const {
+	 std::map<std::string, std::vector<dot_t> >::const_iterator it;
+	 // do these match the types in overlap_delta_to_contact_type()?
+	 double r = 0;
+	 it = dots.find("H-bond");
+	 if (it != dots.end()) r += it->second.size();
+	 it = dots.find("wide-contact");
+	 if (it != dots.end()) r += 0.1 * it->second.size();
+	 it = dots.find("close-contact");
+	 if (it != dots.end()) r -= 0.0 * it->second.size();
+	 it = dots.find("small-overlap");
+	 if (it != dots.end()) r -= 0.1 * it->second.size();
+	 it = dots.find("big-overlap");
+	 if (it != dots.end()) r -= it->second.size();
+	 r -= clashes.size();
+	 return r;
+      }
+      void debug() const {
+	 std::map<std::string, std::vector<atom_overlaps_dots_container_t::dot_t> >::const_iterator it;
+	 for (it=dots.begin(); it!=dots.end(); it++)
+	    std::cout << " contact dot map " << it->first << " size " << it->second.size() << std::endl;
+      }
+
+   };
+
    class atom_overlap_t {
    public:
       atom_overlap_t(mmdb::Atom *a1, mmdb::Atom *a2) {
 	 atom_1 = a1;
 	 atom_2 = a2;
+	 overlap_volume = -1;
+	 r_1 = -1;
+	 r_2 = -1;
       }
-      atom_overlap_t(mmdb::Atom *a1, mmdb::Atom *a2, const double &o) {
+      atom_overlap_t(int ligand_atom_index_in,
+		     mmdb::Atom *a1, mmdb::Atom *a2, const double &r_1_in, const double &r_2_in,
+		     const double &o) {
+	 ligand_atom_index = ligand_atom_index_in;
 	 atom_1 = a1;
 	 atom_2 = a2;
+	 r_1 = r_1_in;
+	 r_2 = r_2_in;
 	 overlap_volume = o;
       }
+      int ligand_atom_index;
+      double r_1, r_2;
       mmdb::Atom *atom_1; 
       mmdb::Atom *atom_2; 
       double overlap_volume;
@@ -51,29 +138,127 @@
    class atom_overlaps_container_t {
 
       void init();
+      void init_for_all_atom();
+      enum overlap_mode_t { CENTRAL_RESIDUE, ALL_ATOM };
+      overlap_mode_t overlap_mode;
       mmdb::Manager *mol;
       bool have_dictionary; // for central residue (or should it be all residues?)
       mmdb::Residue *res_central;
       std::vector<mmdb::Residue *> neighbours;
       int udd_h_bond_type_handle;
+      int udd_residue_index_handle;
+      double probe_radius;
       
       // for energy types -> vdw radius and h-bond type
       std::map<std::string, double> type_to_vdw_radius_map;
       std::map<mmdb::Atom *, double> central_residue_atoms_vdw_radius_map; // ligand atoms
       std::map<mmdb::Atom *, double> neighbour_atoms_vdw_radius_map; // neighbouring atoms
       dictionary_residue_restraints_t central_residue_dictionary;
+      // for ligand and environment neighbours
       std::vector<dictionary_residue_restraints_t> neighb_dictionaries;
+      // for all atom
+      std::map<std::string, dictionary_residue_restraints_t> dictionary_map;
+
       double get_vdw_radius_ligand_atom(mmdb::Atom *at);
-      double get_vdw_radius_neighb_atom(mmdb::Atom *at, unsigned int idx_neighb);
+      double get_vdw_radius_neighb_atom(mmdb::Atom *at, unsigned int idx_neighb_res);
+      double get_vdw_radius_neighb_atom(int idx_neighb_atom) const;
       double get_overlap_volume(const double &dist, const double &r_1, const double &r_2) const; // in A^3
       const protein_geometry *geom_p;
 
-      // first is yes/no, second is if the H is on the ligand
-      // 
+      bool clashable_alt_confs(mmdb::Atom *at_1, mmdb::Atom *at_2) const;
+      std::vector<double> env_residue_radii;
+      void setup_env_residue_atoms_radii(int i_sel_hnd_env_atoms); // fill above
+      // which calls:
+      double type_energy_to_radius(const std::string &te) const;
+      
+      void add_residue_neighbour_index_to_neighbour_atoms();
+      std::vector<double> neighb_atom_radius;
+
+      // first is yes/no, second is if the H is on the ligand.
+      // also allow water to be return true values.
+      static
       std::pair<bool, bool> is_h_bond_H_and_acceptor(mmdb::Atom *ligand_atom,
-				    mmdb::Atom *env_atom,
-				    const double &d) const;
+						     mmdb::Atom *env_atom,
+						     int udd_h_bond_type_handle);
+
       hb_t get_h_bond_type(mmdb::Atom *at);
+      // store the results of a contact search.
+      //
+      // when we draw the surface of the ligand, for each atom, we don't want to draw
+      // surface points that are nearer to another atom than the "central" atom.  So keep
+      // a quick store of what's close to what and the radius.
+      //
+      std::map<int, std::vector<std::pair<mmdb::Atom *, double> > > ligand_atom_neighbour_map;
+      std::map<int, std::vector<int> > ligand_to_env_atom_neighbour_map;
+      // adds radii too.
+      void fill_ligand_atom_neighbour_map();
+      // include inner cusps (ugly/simple)
+      bool is_inside_another_ligand_atom(int idx,
+					 const clipper::Coord_orth &pt_idx_at) const;
+      // exclude inner cusps (modern/pretty)
+      bool is_inside_another_ligand_atom(int idx,
+					 const clipper::Coord_orth &probe_pos,
+					 const clipper::Coord_orth &pt_idx_at) const;
+      // for all-atom contacts
+      static
+      bool is_inside_another_atom_to_which_its_bonded(int atom_idx,
+						      mmdb::Atom *at,
+						      const clipper::Coord_orth &pt_on_surface,
+						      const std::vector<int> &bonded_neighb_indices,
+						      mmdb::Atom **atom_selection,
+						      const std::vector<double> &neighb_atom_radius);
+      bool is_inside_an_env_atom_to_which_its_bonded(int idx,
+						     const std::vector<int> &bonded_neighb_indices,
+						     mmdb::Atom **env_residue_atoms,
+						     const clipper::Coord_orth &pt_at_surface);
+      double clash_spike_length;
+      void mark_donors_and_acceptors();
+      void mark_donors_and_acceptors_central_residue(int udd_h_bond_type_handle);
+      void mark_donors_and_acceptors_for_neighbours(int udd_h_bond_type_handle);
+      // return a contact-type and a colour
+      static std::pair<std::string, std::string> overlap_delta_to_contact_type(double delta, bool is_h_bond);
+      static void test_get_type(double delta, bool is_h_bond, std::string *c_type_p, std::string *col);
+      // can throw std::exception
+      const dictionary_residue_restraints_t &get_dictionary(mmdb::Residue *r, unsigned int idx) const;
+      // where BONDED here means bonded/1-3-angle/ring related
+      enum atom_interaction_type { CLASHABLE, BONDED, IGNORED };
+      atom_interaction_type
+      bonded_angle_or_ring_related(mmdb::Manager *mol,
+				   mmdb::Atom *at_1,
+				   mmdb::Atom *at_2,
+				   bool exclude_mainchain_also,
+				   std::map<std::string, std::vector<std::pair<std::string, std::string> > > *bonded_neighbours,
+				   std::map<std::string, std::vector<std::vector<std::string> > > *ring_list_map);
+      bool are_bonded_residues(mmdb::Residue *res_1, mmdb::Residue *res_2) const;
+      bool in_same_ring(mmdb::Atom *at_1, mmdb::Atom *at_2,
+			std::map<std::string, std::vector<std::vector<std::string> > > &ring_list_map) const;
+      // check LINK records
+      bool is_linked(mmdb::Atom *at_1, mmdb::Atom *at_2) const;
+      bool is_ss_bonded(mmdb::Residue *residue_p) const;
+//       bool in_same_ring(const std::string &atom_name_1,
+// 			const std::string &atom_name_2,
+// 			const std::vector<std::vector<std::string> > &ring_list) const;
+      std::vector<std::vector<std::string> > phe_ring_list() const;
+      std::vector<std::vector<std::string> > his_ring_list() const;
+      std::vector<std::vector<std::string> > trp_ring_list() const;
+      std::vector<std::vector<std::string> > pro_ring_list() const;
+
+      atom_overlaps_dots_container_t all_atom_contact_dots_internal_multi_thread(double dot_density_in,
+										 mmdb::Manager *mol,
+										 int i_sel_hnd_1,
+										 int i_sel_hnd_2,
+										 mmdb::realtype min_dist,
+										 mmdb::realtype max_dist,
+										 bool make_vdw_surface);
+
+      atom_overlaps_dots_container_t
+      all_atom_contact_dots_internal_single_thread(double dot_density_in,
+						   mmdb::Manager *mol,
+						   int i_sel_hnd_1,
+						   int i_sel_hnd_2,
+						   mmdb::realtype min_dist,
+						   mmdb::realtype max_dist,
+						   bool make_vdw_surface);
       
    public:
       // we need mol to use UDDs to mark the HB donors and acceptors (using coot-h-bonds.hh)
@@ -85,11 +270,90 @@
 				mmdb::Residue *neighbour,
 				mmdb::Manager *mol,
 				const protein_geometry *geom_p_in);
+      // this one for contact dots (around central ligand)
+      atom_overlaps_container_t(mmdb::Residue *res_central_in,
+				const std::vector<mmdb::Residue *> &neighbours_in,
+				mmdb::Manager *mol,
+				const protein_geometry *geom_p_in,
+				double clash_spike_length_in,
+				double probe_radius_in = 0.25);
+      atom_overlaps_container_t(mmdb::Manager *mol_in,
+				const protein_geometry *geom_p_in,
+				double clash_spike_length_in = 0.5,
+				double probe_radius_in = 0.25);
+
       std::vector<atom_overlap_t> overlaps;
       void make_overlaps();
+      void contact_dots_for_overlaps() const; // old
+      atom_overlaps_dots_container_t contact_dots_for_ligand();
+      atom_overlaps_dots_container_t all_atom_contact_dots(double dot_density = 0.5,
+							   bool make_vdw_surface = false);
+
+      // public because thread -> static
+      //
+      static
+      atom_overlaps_dots_container_t
+      contacts_for_atom(int iat,
+			mmdb::Atom **atom_selection,
+			const std::map<int, std::vector<int> > &contact_map,
+			const std::map<int, std::vector<int> > &bonded_map,
+			const std::vector<double> &neighb_atom_radius,
+			int udd_h_bond_type_handle,
+			double probe_radius,
+			double dot_density_in,
+			double clash_spike_length,
+			bool make_vdw_surface);
+      static
+      void
+      contacts_for_atoms(int iat_start, int iat_end,
+			 mmdb::Atom **atom_selection,
+			 const std::map<int, std::vector<int> > &contact_map,
+			 const std::map<int, std::vector<int> > &bonded_map,
+			 const std::vector<double> &neighb_atom_radius,
+			 int udd_h_bond_type_handle,
+			 double probe_radius,
+			 double dot_density_in,
+			 double clash_spike_length,
+			 bool make_vdw_surface,
+			 atom_overlaps_dots_container_t *ao_results); // fill this
+      
+
+      static void contacts_for_atom_test();
+      static void contacts_for_atom_test_1(int iat);
+      static void contacts_for_atom_test_2(int iat, mmdb::Atom **atom_selection);
+      static void contacts_for_atom_test_3(int iat,
+					   mmdb::Atom **atom_selection,
+					   const std::map<int, std::vector<int> > &contact_map);
+      static void contacts_for_atom_test_4(int iat,
+					   mmdb::Atom **atom_selection,
+					   const std::map<int, std::vector<int> > &contact_map,
+					   const std::map<int, std::vector<int> > &bonded_map);
+      static void contacts_for_atom_test_6(int iat,
+					   mmdb::Atom **atom_selection,
+					   const std::map<int, std::vector<int> > &contact_map,
+					   const std::map<int, std::vector<int> > &bonded_map,
+					   double probe_radius, double dot_density_in);
+      static void contacts_for_atom_test_7(int iat,
+					   mmdb::Atom **atom_selection,
+					   const std::map<int, std::vector<int> > &contact_map,
+					   const std::map<int, std::vector<int> > &bonded_map,
+					   const std::vector<double> &neighb_atom_radius,
+					   double probe_radius, double dot_density_in);
+      static void contacts_for_atom_test_all(int iat,
+					     mmdb::Atom **atom_selection,
+					     const std::map<int, std::vector<int> > &contact_map,
+					     const std::map<int, std::vector<int> > &bonded_map,
+					     const std::vector<double> &neighb_atom_radius,
+					     int udd_h_bond_type_handle,
+					     double probe_radius,
+					     double dot_density_in,
+					     double clash_spike_length,
+					     bool make_vdw_surface);
+
    };
 
 }
 
 
+
 #endif // ATOM_OVERLAPS_HH
diff -ruN coot-0.8.7/coot-utils/bonded-pairs.cc coot-0.8.8-pre/coot-utils/bonded-pairs.cc
--- coot-0.8.7/coot-utils/bonded-pairs.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/bonded-pairs.cc	2016-12-21 05:34:30.000000000 -0800
@@ -105,8 +105,7 @@
 	 // get the chem mods for each residue (can throw a runtime
 	 // error if there is one - (not an error).
 	 // 
-	 std::pair<protein_geometry::chem_mod, protein_geometry::chem_mod> mods =
-	    geom.get_chem_mods_for_link(link_type);
+	 std::pair<chem_mod, chem_mod> mods = geom.get_chem_mods_for_link(link_type);
 	 std::string res_1_name = res_1->GetResName();
 	 std::string res_2_name = res_2->GetResName();
 	 for (unsigned int i=0; i<mods.first.atom_mods.size(); i++) {
diff -ruN coot-0.8.7/coot-utils/coot-coord-extras.cc coot-0.8.8-pre/coot-utils/coot-coord-extras.cc
--- coot-0.8.7/coot-utils/coot-coord-extras.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/coot-coord-extras.cc	2016-12-21 05:34:30.000000000 -0800
@@ -294,7 +294,6 @@
 coot::util::is_nucleotide_by_dict_dynamic_add(mmdb::Residue *residue_p, coot::protein_geometry *geom_p) {
 
    bool is_nuc = 0;
-   bool ifound = 0;
    std::string residue_name = residue_p->GetResName();
 
    std::pair<short int, dictionary_residue_restraints_t> p = 
@@ -305,19 +304,23 @@
 	  p.second.residue_info.group == "DNA" ) {
 	 is_nuc = 1;
       }
-   }
-
-   int read_number = 40;
-   if (ifound == 0) {
+   } else {
+      int read_number = 40;
       int status = geom_p->try_dynamic_add(residue_name, read_number);
       if (status != 0) {
 	 // we successfully added it, let's try to run this function
 	 // again.  Or we could just test the last entry in
 	 // geom_p->dict_res_restraints(), but it is not public, so
 	 // it's messy.
-	 // 
-	 is_nuc = is_nucleotide_by_dict_dynamic_add(residue_p, geom_p);
-      } 
+	 //
+	 p = geom_p->get_monomer_restraints(residue_name, protein_geometry::IMOL_ENC_ANY);
+	 if (p.first) {
+	    if (p.second.residue_info.group == "RNA" ||
+		p.second.residue_info.group == "DNA" ) {
+	       is_nuc = 1;
+	    }
+	 }
+      }
    }
    return is_nuc;
 }
diff -ruN coot-0.8.7/coot-utils/coot-coord-extras.hh coot-0.8.8-pre/coot-utils/coot-coord-extras.hh
--- coot-0.8.7/coot-utils/coot-coord-extras.hh	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/coot-coord-extras.hh	2017-01-13 09:52:22.000000000 -0800
@@ -623,6 +623,8 @@
 
    class glyco_tree_t {
       protein_geometry *geom_p;
+      std::vector<mmdb::Residue *> linked_residues;
+
       bool is_pyranose(mmdb::Residue *r) const; 
       tree<linked_residue_t> find_rooted_tree(mmdb::Residue *residue_root_p,
 					      const std::vector<mmdb::Residue *> &residues) const;
@@ -638,11 +640,12 @@
       static bool residue_comparitor(mmdb::Residue *res1, mmdb::Residue *res2) {
 	 return (residue_spec_t(res1) < residue_spec_t(res2));
       } 
+      void print(const tree<linked_residue_t> &glyco_tree) const;
+      std::vector<mmdb::Residue *> residues(const tree<linked_residue_t> &glyco_tree) const;
       
    public:
       glyco_tree_t(mmdb::Residue *residue_p, mmdb::Manager *mol, protein_geometry *geom_p_in);
-      void print(const tree<linked_residue_t> &glyco_tree) const;
-
+      std::vector<mmdb::Residue *> residues(const coot::residue_spec_t &containing_res_spec) const;
    }; 
 }
 
diff -ruN coot-0.8.7/coot-utils/coot-coord-utils-glyco.cc coot-0.8.8-pre/coot-utils/coot-coord-utils-glyco.cc
--- coot-0.8.7/coot-utils/coot-coord-utils-glyco.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/coot-coord-utils-glyco.cc	2017-01-23 10:30:03.000000000 -0800
@@ -306,8 +306,8 @@
 	    position =     clipper::Coord_orth(at_O6->x, at_O6->y, at_O6->z);
 	    direction = origin_shift - base;
 	    clipper::Coord_orth new_pos =
-	       coot::util::rotate_round_vector(direction, position,
-					       origin_shift, diff);
+	       coot::util::rotate_around_vector(direction, position,
+						origin_shift, diff);
 	    at_O6->x = new_pos.x();
 	    at_O6->y = new_pos.y();
 	    at_O6->z = new_pos.z();
@@ -327,7 +327,7 @@
 	    position = clipper::Coord_orth(at_O6->x, at_O6->y, at_O6->z);
 	    double diff = clipper::Util::d2rad(template_torsion - current_torsion);
 	    clipper::Coord_orth new_pos =
-	       coot::util::rotate_round_vector(direction, position, origin_shift, -diff);
+	       coot::util::rotate_around_vector(direction, position, origin_shift, -diff);
 
 	    at_O6->x = new_pos.x();
 	    at_O6->y = new_pos.y();
@@ -340,7 +340,7 @@
 	       mmdb::Atom *at = residue_atoms[i];
 	       clipper::Coord_orth p(at->x, at->y, at->z);
 	       clipper::Coord_orth n =
-		  coot::util::rotate_round_vector(direction, p, origin_shift, -diff);
+		  coot::util::rotate_around_vector(direction, p, origin_shift, -diff);
 	       at->x = n.x();
 	       at->y = n.y();
 	       at->z = n.z();
@@ -437,8 +437,7 @@
    if (r) {
       try { 
 	 // apply the mods given the link type
-	 std::pair<coot::protein_geometry::chem_mod, coot::protein_geometry::chem_mod>
-	    mods = geom_p->get_chem_mods_for_link(link_type);
+	 std::pair<coot::chem_mod, coot::chem_mod> mods = geom_p->get_chem_mods_for_link(link_type);
 
 	 std::string res_name_ref = residue_ref->GetResName();
 	 for (unsigned int i=0; i<mods.first.atom_mods.size(); i++) { 
@@ -668,7 +667,7 @@
 
       std::queue<mmdb::Residue *> q;
       std::vector<mmdb::Residue *> considered;
-      std::vector<mmdb::Residue *> linked_residues;
+      // std::vector<mmdb::Residue *> linked_residues;
       
       if (is_pyranose(residue_p) || std::string(residue_p->name) == "ASN")
 	 q.push(residue_p);
@@ -725,7 +724,7 @@
    } 
 
    return is_pyranose;
-} 
+}
 
 
 // find tree rooted on residue_p.
@@ -786,25 +785,28 @@
 
 		     if (link.first == "NAG-ASN") {
 			if (link.second == true) {
-			   std::cout << "   Adding "
-				     << coot::residue_spec_t(done_residues[ires].second)
-				     << " " << "via NAG-ASN" << " to parent "
-				     << coot::residue_spec_t(it->residue)
-				     << std::endl;
+			   if (false)
+			      std::cout << "   Adding "
+					<< coot::residue_spec_t(done_residues[ires].second)
+					<< " " << "via NAG-ASN" << " to parent "
+					<< coot::residue_spec_t(it->residue)
+					<< std::endl;
 			   linked_residue_t this_linked_residue(done_residues[ires].second, "NAG-ASN");
 			   glyco_tree.append_child(it, this_linked_residue);
 			   something_added = true;
 			   done_residues[ires].first = true;
 			}
 		     } else {
-			std::cout << "found link type " << link.first << " order-switch " 
-				  << link.second << std::endl;
+			if (false)
+			   std::cout << "found link type " << link.first << " order-switch " 
+				     << link.second << std::endl;
 			linked_residue_t this_linked_residue(done_residues[ires].second, link.first);
 			this_linked_residue.order_switch = link.second;
-			std::cout << "   Adding " << coot::residue_spec_t(done_residues[ires].second)
-				  << " via " << link.first << " to parent " 
-				  << coot::residue_spec_t(it->residue)
-				  << std::endl;
+			if (false)
+			   std::cout << "   Adding " << coot::residue_spec_t(done_residues[ires].second)
+				     << " via " << link.first << " to parent " 
+				     << coot::residue_spec_t(it->residue)
+				     << std::endl;
 			glyco_tree.append_child(it, this_linked_residue);
 			something_added = true;
 			done_residues[ires].first = true;
@@ -895,6 +897,45 @@
    }
 }
 
+std::vector<mmdb::Residue *>
+coot::glyco_tree_t::residues(const tree<linked_residue_t> &glyco_tree) const {
+
+   tree<linked_residue_t>::iterator it;
+   std::vector<mmdb::Residue *> v;
+   for (it=glyco_tree.begin(); it != glyco_tree.end(); it++) {
+      v.push_back(it->residue);
+   }
+   return v;
+}
+
+std::vector<mmdb::Residue *>
+coot::glyco_tree_t::residues(const coot::residue_spec_t &containing_res_spec) const {
+
+   // will this always find the right ASN? (consider in protien chain ASN next to ASN)
+   //
+   std::vector<mmdb::Residue *> v;
+   for (unsigned int ires=0; ires<linked_residues.size(); ires++) {
+      mmdb::Residue *this_res = linked_residues[ires];
+      std::string residue_name(this_res->name);
+      std::cout << "residues(): considering residue " << coot::residue_spec_t(this_res) << " "
+		<< residue_name << std::endl;
+      if (residue_name == "ASN") {
+	 std::vector<mmdb::Residue *> res_store;
+	 tree<coot::linked_residue_t> tr = find_ASN_rooted_tree(this_res, linked_residues);
+	 res_store = residues(tr);
+	 for (unsigned int ii=0; ii<res_store.size(); ii++) {
+	    coot::residue_spec_t spec(res_store[ii]);
+	    if (spec == containing_res_spec) {
+	       v = res_store;
+	       break;
+	    }
+	 }
+      }
+   }
+  return v;
+}
+
+
 void
 coot::glyco_tree_t::compare_vs_allowed_trees(const tree<linked_residue_t> &tr_for_testing) const {
 
@@ -1096,7 +1137,7 @@
    linked_residue_t MAN_3  ("BMA", "BETA1-4");  // parent is NAG_2
    linked_residue_t NAG_4  ("NAG", "BETA1-4");  // parent is MAN_3
 
-   linked_residue_t XYL_4  ("XYL", "BETA1-2");  // parent is MAN_3
+   linked_residue_t XYP_4  ("XYP", "BETA1-2");  // parent is MAN_3
    
    linked_residue_t MAN_4_1("MAN", "ALPHA1-6"); // parent is MAN_3
    linked_residue_t NAG_4_2("NAG", "ALPHA1-6"); // parent is MAN_4_1
@@ -1127,7 +1168,7 @@
    tree<linked_residue_t>::iterator gal_5_2 = t.append_child(nag_5_1, GAL_5_2);
    
    tree<linked_residue_t>::iterator nag_4   = t.append_child(man_3,   NAG_4);
-   tree<linked_residue_t>::iterator xyl_4   = t.append_child(man_3,   XYL_4);
+   tree<linked_residue_t>::iterator xyp_4   = t.append_child(man_3,   XYP_4);
 
    tree<linked_residue_t>::iterator man_6_1 = t.append_child(man_3,   MAN_6_1);
    tree<linked_residue_t>::iterator nag_6_2 = t.append_child(man_6_1, NAG_6_2);
diff -ruN coot-0.8.7/coot-utils/coot-coord-utils.cc coot-0.8.8-pre/coot-utils/coot-coord-utils.cc
--- coot-0.8.7/coot-utils/coot-coord-utils.cc	2016-11-08 01:46:23.000000000 -0800
+++ coot-0.8.8-pre/coot-utils/coot-coord-utils.cc	2017-01-23 10:30:03.000000000 -0800
@@ -1693,24 +1693,25 @@
       for (int imod=1; imod<=n_models; imod++) { 
       
 	 mmdb::Model *model_p = mol->GetModel(imod);
-   
-	 mmdb::Chain *chain;
-	 // run over chains of the existing mol
-	 int nchains = model_p->GetNumberOfChains();
-	 if (nchains <= 0) { 
-	    std::cout << "bad nchains in trim molecule " << nchains
-		      << std::endl;
-	 } else { 
-	    for (int ichain=0; ichain<nchains; ichain++) {
-	       chain = model_p->GetChain(ichain);
-	       if (chain == NULL) {  
-		  // This should not be necessary. It seem to be a
-		  // result of mmdb corruption elsewhere - possibly
-		  // DeleteChain in update_molecule_to().
-		  std::cout << "NULL chain in residues_in_molecule: "
-			    << std::endl;
-	       } else {
-		  v.push_back(chain->GetChainID());
+	 if (model_p) {
+	    mmdb::Chain *chain;
+	    // run over chains of the existing mol
+	    int nchains = model_p->GetNumberOfChains();
+	    if (nchains <= 0) {
+	       std::cout << "bad nchains in trim molecule " << nchains
+			 << std::endl;
+	    } else {
+	       for (int ichain=0; ichain<nchains; ichain++) {
+		  chain = model_p->GetChain(ichain);
+		  if (chain == NULL) {
+		     // This should not be necessary. It seem to be a
+		     // result of mmdb corruption elsewhere - possibly
+		     // DeleteChain in update_molecule_to().
+		     std::cout << "NULL chain in residues_in_molecule: "
+			       << std::endl;
+		  } else {
+		     v.push_back(chain->GetChainID());
+		  }
 	       }
 	    }
 	 }
@@ -4394,7 +4395,8 @@
 
 }
 
-
+// the header for this is (in) residue-and-atom-specs.hh.  Hmm... should be fixed.
+//
 std::pair<coot::atom_spec_t, coot::atom_spec_t>
 coot::link_atoms(mmdb::Link *link) {
 
@@ -5874,10 +5876,10 @@
 
 // angle in radians.
 clipper::Coord_orth
-coot::util::rotate_round_vector(const clipper::Coord_orth &direction,
-				const clipper::Coord_orth &position,
-				const clipper::Coord_orth &origin_shift,
-				double angle) {
+coot::util::rotate_around_vector(const clipper::Coord_orth &direction,
+				 const clipper::Coord_orth &position,
+				 const clipper::Coord_orth &origin_shift,
+				 double angle) {
    
    clipper::Coord_orth unit_vec = clipper::Coord_orth(direction.unit());
    
@@ -5925,7 +5927,7 @@
 	 mmdb::Atom *at = residue_atoms[iat];
 	 if (at) {
 	    clipper::Coord_orth pt(at->x, at->y, at->z);
-	    clipper::Coord_orth pt_new = rotate_round_vector(direction, pt, origin_shift, angle);
+	    clipper::Coord_orth pt_new = rotate_around_vector(direction, pt, origin_shift, angle);
 	    at->x = pt_new.x();
 	    at->y = pt_new.y();
 	    at->z = pt_new.z();
diff -ruN coot-0.8.7/coot-utils/coot-coord-utils.hh coot-0.8.8-pre/coot-utils/coot-coord-utils.hh
--- coot-0.8.7/coot-utils/coot-coord-utils.hh	2016-10-23 20:10:15.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/coot-coord-utils.hh	2017-01-23 10:30:04.000000000 -0800
@@ -1110,10 +1110,10 @@
       //
       // Note that angle is in radians.
       // 
-      clipper::Coord_orth rotate_round_vector(const clipper::Coord_orth &direction,
-					      const clipper::Coord_orth &position,
-					      const clipper::Coord_orth &origin_shift,
-					      double angle);
+      clipper::Coord_orth rotate_around_vector(const clipper::Coord_orth &direction,
+					       const clipper::Coord_orth &position,
+					       const clipper::Coord_orth &origin_shift,
+					       double angle);
       // angle in radians
       // 
       void rotate_residue(mmdb::Residue *residue_p,
diff -ruN coot-0.8.7/coot-utils/coot-h-bonds.cc coot-0.8.8-pre/coot-utils/coot-h-bonds.cc
--- coot-0.8.7/coot-utils/coot-h-bonds.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/coot-h-bonds.cc	2017-01-25 14:34:21.000000000 -0800
@@ -38,13 +38,13 @@
    
    if (hb.acceptor_neigh)
       s << " acceptor_neigh: " << coot::atom_spec_t(hb.acceptor_neigh);
-   else 
+   else
       s << " acceptor_neigh: NULL [problem!?]";
-	    
+
    s << " dist: " << hb.dist 
      << " ligand-atom-is-donor?: " << hb.ligand_atom_is_donor;
    return s;
-} 
+}
 
 // typically the atom selection selHnd_1 is for the ligand and
 // selHnd_2 is for everything (else).
@@ -391,9 +391,12 @@
 		     std::vector<std::pair<mmdb::Atom *, float> > nb_2 = neighbour_map[at_2];
 		     std::pair<bool, coot::h_bond> b_hbond =
 			make_h_bond_from_environment_residue_hydrogen(at_1, at_2, nb_1, nb_2);
-		     if (b_hbond.first)
+
+		     if (b_hbond.first) {
+			std::cout << "pushing back b_hbond " << b_hbond.second << std::endl;
 			v.push_back(b_hbond.second);
-		  } 
+		     }
+		  }
 	       }
 	    }
 	 }
@@ -403,7 +406,9 @@
 }
 
 // return an h_bond if the angles are good - otherwise first is 0.
-// 
+//
+// for HOH O as at_2, the angles are always good.
+//
 std::pair<bool, coot::h_bond> 
 coot::h_bonds::make_h_bond_from_ligand_hydrogen(mmdb::Atom *at_1, // H on ligand
 						mmdb::Atom *at_2, // acceptor on residue
@@ -493,29 +498,53 @@
    return std::pair<bool, coot::h_bond> (neighbour_distances_and_angles_are_good && good_donor_acceptor_dist, bond);
 }
 
-// return an h_bond if the angles are good - otherwise first is 0.
-// 
+// return an h_bond if the distance and angles are good - otherwise first is 0.
+//
+//
 std::pair<bool, coot::h_bond> 
 coot::h_bonds::make_h_bond_from_environment_residue_hydrogen(mmdb::Atom *at_1, // acceptor on ligand
 							     mmdb::Atom *at_2, // H on residue
 							     const std::vector<std::pair<mmdb::Atom *, float> > &nb_1,
 							     const std::vector<std::pair<mmdb::Atom *, float> > &nb_2) const {
 
+   std::cout << "in make_h_bond_from_environment_residue_hydrogen() at_1:  " << atom_spec_t(at_1)
+	     << " at_2: " << atom_spec_t(at_2)
+	     << " nb_1.size(): " << nb_1.size() << " nb_2.size() " << nb_2.size()
+	     << std::endl;
+
+   double water_dist_max = 3.25; // pass this
+
+   for (unsigned int i=0; i<nb_1.size(); i++)
+      std::cout << "    nb_1: " << atom_spec_t(nb_1[i].first) << std::endl;
+   for (unsigned int i=0; i<nb_2.size(); i++)
+      std::cout << "    nb_2: " << atom_spec_t(nb_2[i].first) << std::endl;
+
+
    coot::h_bond bond(at_2, at_1, 0); // H atom goes first for this constructor
    bond.dist = coot::distance(at_1, at_2);
 
-   bool neighbour_distances_and_angles_are_good = 1;
-   bool good_donor_acceptor_dist = 0;
+   bool neighbour_distances_and_angles_are_good = true;
+   bool good_donor_acceptor_dist = false;
 
    // Dist D-A
-   for (unsigned int iD=0; iD<nb_2.size(); iD++) { 
+   //
+   for (unsigned int iD=0; iD<nb_2.size(); iD++) {
       double dist = coot::distance(nb_2[iD].first, at_1);
       if (dist < 3.9) { // McDonald and Thornton
-	 good_donor_acceptor_dist = 1;
+	 good_donor_acceptor_dist = true;
 	 break;
       }
    }
 
+   // Dist D-A for HOH acceptor
+   //
+   // (in this case nb_2.size() is 0)
+   //
+   if (std::string(at_2->GetResName()) == "HOH") {
+      if (bond.dist < water_dist_max)
+	 good_donor_acceptor_dist = true;
+   }
+
    // Angle D-H-A
    //
    for (unsigned int iD=0; iD<nb_2.size(); iD++) { 
@@ -559,10 +588,11 @@
    }
 
    // Angle D-A-AA
+   //
    for (unsigned int iD=0; iD<nb_2.size(); iD++) { 
       for (unsigned int iA=0; iA<nb_1.size(); iA++) { 
 	 double angle = coot::angle(nb_2[iD].first, at_1, nb_1[iA].first);
-	 if (0) { 
+	 if (0) {
 	    std::cout << "   H-on-protein angle 3: " << angle <<   "  ";
 	    std::cout << "     angle: "
 		      << coot::atom_spec_t(nb_2[iD].first) << " "
@@ -582,6 +612,10 @@
 	 break;
    }
 
+   std::cout << "in make_h_bond_from_environment_residue_hydrogen() neighbour_distances_and_angles_are_good "
+	     << neighbour_distances_and_angles_are_good << " good_donor_acceptor_dist " << good_donor_acceptor_dist
+	     << std::endl;
+
    return std::pair<bool, coot::h_bond> (neighbour_distances_and_angles_are_good && good_donor_acceptor_dist, bond);
 
 } 
diff -ruN coot-0.8.7/coot-utils/coot-map-utils.cc coot-0.8.8-pre/coot-utils/coot-map-utils.cc
--- coot-0.8.7/coot-utils/coot-map-utils.cc	2016-10-23 20:10:15.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/coot-map-utils.cc	2017-01-23 10:30:04.000000000 -0800
@@ -551,7 +551,7 @@
 	 clipper::Coord_orth dir   = pa3 - pa2;
 	 clipper::Coord_orth pos   = pa4;
 	 clipper::Coord_orth shift = pa3;
-	 clipper::Coord_orth co = coot::util::rotate_round_vector(dir, pos, shift, theta);
+	 clipper::Coord_orth co = coot::util::rotate_around_vector(dir, pos, shift, theta);
 	 float this_d = coot::util::density_at_point(xmap, co);
 	 if (this_d > best_d) {
 	    best_d = this_d;
diff -ruN coot-0.8.7/coot-utils/coot-tree-extras.cc coot-0.8.8-pre/coot-utils/coot-tree-extras.cc
--- coot-0.8.7/coot-utils/coot-tree-extras.cc	2016-09-01 17:13:23.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/coot-tree-extras.cc	2017-01-23 10:30:04.000000000 -0800
@@ -1317,7 +1317,7 @@
       int idx = moving_atom_indices[im].index();
       mmdb::Atom *at = residue_atoms[idx];
       clipper::Coord_orth po(at->x, at->y, at->z);
-      clipper::Coord_orth pt = coot::util::rotate_round_vector(dir, po, base_atom_pos, angle);
+      clipper::Coord_orth pt = coot::util::rotate_around_vector(dir, po, base_atom_pos, angle);
       if (debug)
 	 std::cout << "  rotate_internal() moving atom number " << im << " " << at->name
 		   << " from\n    " << at->x << "," << at->y << "," << at->z << " to "
diff -ruN coot-0.8.7/coot-utils/glyco-torsions.cc coot-0.8.8-pre/coot-utils/glyco-torsions.cc
--- coot-0.8.7/coot-utils/glyco-torsions.cc	2016-09-01 17:13:23.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/glyco-torsions.cc	2016-12-21 05:34:30.000000000 -0800
@@ -23,7 +23,7 @@
 // The problem with carbohydrate-building - as it stands.
 //
 // The set of reference structures has pyranose-BETA1-4-pyranose.  And
-// we paste a MAN onto the extension poart of that to give us initial
+// we paste a MAN onto the extension part of that to give us initial
 // coordinates for the MAN. The link consists of part pre-built base
 // residue and part of this LSQ fitted MAN - and because the C1, O4 C4
 // are not in the same positions as the reference
@@ -106,9 +106,9 @@
       return new_pos;
    } else {
       std::string m = "missing atom";
-      if (! at_1) m += " at_1";
-      if (! at_2) m += " at_2";
-      if (! at_3) m += " at_3";
+      if (! at_1) m += " at_1 " + prior_atom_1.second;
+      if (! at_2) m += " at_2 " + prior_atom_2.second;
+      if (! at_3) m += " at_3 " + prior_atom_3.second;
       throw std::runtime_error(m);
    }
 }
@@ -119,7 +119,7 @@
    new_residue_type = new_residue_comp_id_in;
    new_res_no = 1; // FIXME
 
-   std::string fn = link_type_to_file_name(link_type);
+   std::string fn = link_type_to_file_name(link_type, new_residue_comp_id_in);
    read(fn);
 
    // now handle the decorations
@@ -139,6 +139,28 @@
 }
 
 std::string
+coot::link_by_torsion_t::link_type_to_file_name(const std::string &link_type,
+						const std::string &new_res_comp_id) const {
+
+   // try to get new_res_comp_id-specific template, if not, fall back to generic
+   //
+   std::string p = package_data_dir();
+   std::string f = "link-by-torsion-to-" + new_res_comp_id + "-core-" + link_type + ".tab";
+   std::string ff = util::append_dir_file(p,f);
+
+   std::cout << "......... checking for " << ff << std::endl;
+
+   if (file_exists(ff)) {
+      return ff;
+   } else {
+      f = "link-by-torsion-to-pyranose-core-" + link_type + ".tab";
+      ff = util::append_dir_file(p,f);
+      std::cout << "......... fail... trying  " << ff << std::endl;
+   }
+   return ff;
+} 
+
+std::string
 coot::link_by_torsion_t::link_type_to_file_name(const std::string &link_type) const {
 
    std::string p = package_data_dir();
@@ -169,6 +191,7 @@
       r->seqNum = new_res_no;
       for (unsigned int i=0; i<geom_atom_torsions.size(); i++) {
 	 const atom_by_torsion_t &gat = geom_atom_torsions[i];
+	 std::cout << "in make_residue() i: " << i << " " << gat << std::endl;
 	 clipper::Coord_orth p = geom_atom_torsions[i].pos(base_residue_p, r);
 	 mmdb::Atom *atom = new mmdb::Atom(r); // does an add atom
 	 std::string f = gat.filled_atom_name(); // FIXME PDBv3 the function call is not needed
@@ -176,7 +199,7 @@
 	 atom->SetElementName(gat.element.c_str());
 	 atom->SetCoordinates(p.x(), p.y(), p.z(), 1.0, b_factor);
 	 atom->Het = 1;
-	 if (0) 
+	 if (true)
 	    std::cout << "   " << gat.atom_name << " " << p.format()  << std::endl;
       }
    } 
@@ -455,11 +478,15 @@
 
 coot::link_by_torsion_base_t
 coot::get_names_for_link_type(const std::string &link_type) {
+
+   std::cout << "here in get_names_for_link_type() " << link_type << std::endl;
    
    link_by_torsion_base_t r;
    if (link_type == "ALPHA1-6") r = pyranose_link_1_6_to_core();
    if (link_type == "ALPHA1-2") r = pyranose_link_1_2_to_core();
-   if (link_type == "ALPHA1-3") r = pyranose_link_1_3_to_core();
+   if (link_type == "ALPHA1-3") { r = pyranose_link_1_3_to_core();
+      std::cout << "found ALPHA1-3" << std::endl;
+   }
    if (link_type == "ALPHA2-3") r = pyranose_link_2_3_to_core();
    if (link_type == "BETA1-3")  r = pyranose_link_1_3_to_core();
    if (link_type == "BETA1-4")  r = pyranose_link_1_4_to_core();
@@ -552,6 +579,8 @@
 void
 coot::link_by_torsion_t::read(const std::string &file_name) {
 
+   std::cout << "........... here in read() " << file_name << std::endl;
+
    if (! file_exists(file_name)) {
       std::cout << "ERROR:: file not found " << file_name << std::endl;
       return;
diff -ruN coot-0.8.7/coot-utils/glyco-torsions.hh coot-0.8.8-pre/coot-utils/glyco-torsions.hh
--- coot-0.8.7/coot-utils/glyco-torsions.hh	2016-09-01 17:13:23.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/glyco-torsions.hh	2016-12-21 05:34:30.000000000 -0800
@@ -104,6 +104,9 @@
    class link_by_torsion_t : public link_by_torsion_base_t {
       void init(mmdb::Residue *ref_res_p, mmdb::Residue *ext_res_p);
       std::string link_type_to_file_name(const std::string &link_type) const;
+      std::string link_type_to_file_name(const std::string &link_type,
+					 const std::string &new_res_comp_id) const;
+      
       std::string comp_id_to_decoration_file_name(const std::string &link_type) const;
       float b_factor;
    public:
diff -ruN coot-0.8.7/coot-utils/hole.cc coot-0.8.8-pre/coot-utils/hole.cc
--- coot-0.8.7/coot-utils/hole.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/hole.cc	2017-01-23 10:30:04.000000000 -0800
@@ -399,10 +399,10 @@
 	    // now let's rotate unit_plane_vect around the circle.
 	    clipper::Coord_orth pos(probe_path[i].second * unit_plane_vect);
 	    clipper::Coord_orth circle_point =
-	       coot::util::rotate_round_vector(v_hat,
-					       pos,
-					       clipper::Coord_orth(0,0,0),
-					       theta);
+	       coot::util::rotate_around_vector(v_hat,
+						pos,
+						clipper::Coord_orth(0,0,0),
+						theta);
 	    clipper::Coord_orth surface_point = probe_path[i].first + circle_point;
 
 	    render_stream << surface_point.x() << " "
diff -ruN coot-0.8.7/coot-utils/reduce.cc coot-0.8.8-pre/coot-utils/reduce.cc
--- coot-0.8.7/coot-utils/reduce.cc	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/coot-utils/reduce.cc	2017-01-25 14:38:59.000000000 -0800
@@ -0,0 +1,1550 @@
+
+#include <algorithm>
+#include <string.h>
+#include "utils/coot-utils.hh"
+#include "coot-coord-utils.hh"
+#include "reduce.hh"
+#include "atom-overlaps.hh"
+
+   // Spin-search: OH, SH, NH3, MET methyls
+
+   // OH: SER, TYR, THR
+
+   // look at the Cartesian function position_by_torsion().
+   
+   // main-chain
+   //
+   // placeable_main[" H  "] // bisect C(n-1)-N(n) and CA(n)-N(n)
+
+   // CA is placed by tetrahedron - c.f. push_chiral_hydrogen, but use unit vectors to
+   //                                    the neighbours
+
+   // Hs on CB: HB2 and HB3:
+   // for CYS, ASP, GLU, PHE, HIS, LYS, LEU, MET, ASN, PRO, GLU, ARG, 
+   //     SER, TYR, VAL, TRP, TYR
+   //    bisect CA-CB and CG-CB, call that b
+   //           CA-CG, unit, call that c,
+   //           a fragment of bxc and of b gives the delta from CB for HB2 and HB3
+
+   // ALA: CB Hs: HB1, HB2, HB3, BL-A-T: average positions from N-CA-CB-HBx C-CA-CB-HBx
+
+   // CYS: SG H : HB BL-A-T: CA-CB-SG-HG (180)
+
+   // GLU: CG Hs: Bisect as CB Hs, but use CB-CG-CD
+
+   // GLN: CG Hs: Bisect as CB Hs, but use CB-CG-CD
+
+   // PHE Ring Hs: average BL-A-T of ring torsions (180)
+
+   // HIS: average of  BL-A-T of ring torsions (180)
+
+   // ILE: CB HB: on CB from tetrahedron of CA, CG1, CG2.
+   //           HG1 and H2: bisect CB, CG, CD1
+   //           HD1, HD2, HD3 BL-A-T from CB, CG1, CD1
+   //           HG21 HG22, HG33: BL-A-T from CA-CB-CG2-HG2x
+
+   // LYS: CG Hs: Bisect as CB Hs, but use CB-CG-CD
+   //      CD Hs: Bisect as CB Hs, but use CG-CD-CE
+   //      CE Hs: Bisect as CB Hs, but use CD-CE-NZ
+   //      NZ Hs: HZ1,2,3: BL-A-T from  CD-CE-NZ-HZx
+
+   // LEU:
+
+   // MET: CG Hs: Bisect as CB Hs, but use CB-CG-SD
+   //         HE1,2,3 BL-A-T from CG, SD, CG
+
+   // PRO: +++
+
+   // GLU: CG Hs: Bisect as CB Hs, but use CB-CG-CD
+
+   // ARG: CG Hs: Bisect as CB Hs, but use CB-CG-CD
+   //      CD Hs: Bisect as CB Hs, but use CG-CD-CE
+   //      CE Hs: Bisect as CB Hs, but use CD-CE-NZ
+   //      +++
+
+   // SER: BL-A-T: CA, CG, OG.
+
+   // THR: CG2 Hs: HG2[1,2,3] BL-A-T: CA, CG, CG.
+   //         HG1: BL-A-T on CA, CB, OG (180)  # spin-search
+
+   // VAL: HGxy:  BL-A-T on CA, CB, CG[1,2], HGxy
+
+   // TRP: HD1: average BL-A-T: CD2, CG, CD1 and CE2, NE1, CD1
+   //      HE1: average BL-A-T: CG, CD1, NE1 and CD2, CE2, NE1
+   //      HZ2: average BL-A-T: CD2, CE2, CZ2 and CZ3, CH2, CZ2
+   //      HH2: average BL-A-T: CE2, CZ2, CH2 and CE3, CZ3, CH2
+   //      HZ3: average BL-A-T: CZ2, CH2, CZ3 and CD2, CE3, CZ3
+   //      HE3: average BL-A-T: CE2, CD2, CE3 and CH2, CZ3, CE3
+
+   // TYR Ring Hs: average BL-A-T of ring torsions (180)
+   //          HH: BL-A-T: CE1, CZ, OH # spin-search
+
+
+clipper::Coord_orth
+coot::reduce::position_by_bond_length_angle_torsion(mmdb::Atom *at_1,  // CA
+						    mmdb::Atom *at_2,  // CB
+						    mmdb::Atom *at_3,  // CG
+						    double bl,
+						    double angle_rad,
+						    double torsion_rad) const {
+   
+   clipper::Coord_orth at_1_pos = co(at_1);
+   clipper::Coord_orth at_2_pos = co(at_2);
+   clipper::Coord_orth at_3_pos = co(at_3);
+
+   clipper::Coord_orth new_pos(at_1_pos, at_2_pos, at_3_pos, bl, angle_rad, torsion_rad);
+
+   return new_pos;
+}
+
+clipper::Coord_orth
+coot::reduce::position_by_bisection(mmdb::Atom *at_1,
+				    mmdb::Atom *at_2,
+				    mmdb::Atom *at_3,
+				    double bl) const {
+
+   // bisect the normals
+   clipper::Coord_orth at_1_pos = co(at_1);
+   clipper::Coord_orth at_2_pos = co(at_2);
+   clipper::Coord_orth at_3_pos = co(at_3);
+
+   clipper::Coord_orth vec_1_to_2(at_2_pos-at_1_pos);
+   clipper::Coord_orth vec_3_to_2(at_2_pos-at_3_pos);
+   clipper::Coord_orth vec_1_to_2_uv(vec_1_to_2.unit());
+   clipper::Coord_orth vec_3_to_2_uv(vec_3_to_2.unit());
+
+   // vector from point to mid-atom
+   clipper::Coord_orth bisect_delta = 0.5 * (vec_1_to_2_uv + vec_3_to_2_uv);
+   clipper::Coord_orth bisect_delta_uv(bisect_delta.unit());
+
+   clipper::Coord_orth Hp1 = at_2_pos + bl * bisect_delta_uv;
+
+   return Hp1;
+}
+
+std::pair<clipper::Coord_orth, clipper::Coord_orth>
+coot::reduce::position_pair_by_bisection(mmdb::Atom *at_1,  // CA
+					 mmdb::Atom *at_2,  // CB
+					 mmdb::Atom *at_3,  // CG
+					 double bl,
+					 double alpha // angle btwn the two H atoms
+					 ) const {
+
+   // bisect the normals
+   clipper::Coord_orth at_1_pos = co(at_1);
+   clipper::Coord_orth at_2_pos = co(at_2);
+   clipper::Coord_orth at_3_pos = co(at_3);
+
+   clipper::Coord_orth vec_1_to_2(at_2_pos-at_1_pos);
+   clipper::Coord_orth vec_3_to_2(at_2_pos-at_3_pos);
+   clipper::Coord_orth vec_1_to_2_uv(vec_1_to_2.unit());
+   clipper::Coord_orth vec_3_to_2_uv(vec_3_to_2.unit());
+
+   // vector from point to mid-atom
+   clipper::Coord_orth bisect_delta = 0.5 * (vec_1_to_2_uv + vec_3_to_2_uv);
+   clipper::Coord_orth bisect_delta_uv(bisect_delta.unit());
+
+   // vector from CA->CG
+   clipper::Coord_orth vec_1_to_3 = at_3_pos - at_1_pos;
+   clipper::Coord_orth vec_1_to_3_uv(vec_1_to_3.unit());
+
+   // cpu, the vector between the H atoms is along this vector
+   clipper::Coord_orth cpu(clipper::Coord_orth::cross(vec_1_to_3_uv, bisect_delta_uv));
+
+   double scale_fac_bisector = bl * sin(0.5*(M_PI-alpha));
+   double scale_fac_cpu      = bl * cos(0.5*(M_PI-alpha));
+   
+   clipper::Coord_orth Hp1 = at_2_pos + scale_fac_bisector * bisect_delta_uv - scale_fac_cpu * cpu;
+   clipper::Coord_orth Hp2 = at_2_pos + scale_fac_bisector * bisect_delta_uv + scale_fac_cpu * cpu;
+
+   return std::pair<clipper::Coord_orth, clipper::Coord_orth> (Hp1, Hp2);
+}
+
+clipper::Coord_orth
+coot::reduce::position_by_tetrahedron(mmdb::Atom *at_central,
+				      mmdb::Atom *at_n_1,
+				      mmdb::Atom *at_n_2,
+				      mmdb::Atom *at_n_3,
+				      double bl) const {
+
+   clipper::Coord_orth at_c_pos = co(at_central);
+   clipper::Coord_orth at_n1_pos = co(at_n_1);
+   clipper::Coord_orth at_n2_pos = co(at_n_2);
+   clipper::Coord_orth at_n3_pos = co(at_n_3);
+   clipper::Coord_orth vec_1_to_c(at_c_pos-at_n1_pos);
+   clipper::Coord_orth vec_2_to_c(at_c_pos-at_n2_pos);
+   clipper::Coord_orth vec_3_to_c(at_c_pos-at_n3_pos);
+   clipper::Coord_orth vec_1_to_c_uv(vec_1_to_c.unit());
+   clipper::Coord_orth vec_2_to_c_uv(vec_2_to_c.unit());
+   clipper::Coord_orth vec_3_to_c_uv(vec_3_to_c.unit());
+
+   clipper::Coord_orth under_pos = 0.3333333333 *
+      (vec_1_to_c_uv + vec_2_to_c_uv + vec_3_to_c_uv);
+   clipper::Coord_orth under_pos_uv(under_pos.unit());
+
+   clipper::Coord_orth H_pos = at_c_pos + bl * under_pos_uv;
+   return H_pos;
+}
+
+void
+coot::reduce::add_hydrogen_atoms() {
+
+   if (mol) {
+      add_riding_hydrogens();
+      mol->FinishStructEdit();
+   }
+}
+
+void
+coot::reduce::add_riding_hydrogens() {
+
+   int imod = 1;
+   mmdb::Model *model_p = mol->GetModel(imod);
+   if (model_p) {
+      mmdb::Chain *chain_p;
+      int n_chains = model_p->GetNumberOfChains();
+      for (int ichain=0; ichain<n_chains; ichain++) {
+	 chain_p = model_p->GetChain(ichain);
+	 int nres = chain_p->GetNumberOfResidues();
+	 mmdb::Residue *residue_p;
+	 mmdb::Residue *residue_prev_p;
+	 mmdb::Atom *at;
+	 for (int ires=0; ires<nres; ires++) {
+	    residue_p      = chain_p->GetResidue(ires);
+	    if (ires > 0)
+	       residue_prev_p = chain_p->GetResidue(ires-1);
+	    else
+	       residue_prev_p = 0;
+	    // what about strange missing residues - where we can place the CA HA
+	    // (but not the N's H).
+	    bool done = add_riding_hydrogens(residue_p, residue_prev_p);
+	    if (! done) {
+	       hydrogen_placement_by_dictionary(residue_p);
+	    }
+	 }
+      }
+   }
+
+   mol->FinishStructEdit();
+
+   // Now, which N has the H on the HISs?
+   
+   model_p = mol->GetModel(imod);
+   if (model_p) {
+      mmdb::Chain *chain_p;
+      int n_chains = model_p->GetNumberOfChains();
+      for (int ichain=0; ichain<n_chains; ichain++) {
+	 chain_p = model_p->GetChain(ichain);
+	 if (chain_p) {
+	    int nres = chain_p->GetNumberOfResidues();
+	    for (int ires=0; ires<nres; ires++) {
+	       mmdb::Residue *residue_p = chain_p->GetResidue(ires);
+	       if (residue_p) {
+		  std::string res_name = residue_p->GetResName();
+		  if (res_name == "HIS") {
+		     find_best_his_protonation_orientation(residue_p);
+		  }
+	       }
+	    }
+	 }
+      }
+   }
+}
+
+// only call this with a valid residue_p
+//
+// return a status indication that this residue type was handled
+//
+bool
+coot::reduce::add_riding_hydrogens(mmdb::Residue *residue_p, mmdb::Residue *residue_prev_p) {
+
+   bool done = false;
+   std::string res_name = residue_p->GetResName();
+   double bl = 0.97;
+   double bl_arom  = 0.93;
+   double bl_amino = 0.86;
+   double bl_oh    = 0.84;
+   double bl_sh    = 1.2;
+   if (res_name == "ALA") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      torsion_info_t torsion_1(" N  ", " CA ", " CB ", bl, 109, 180);
+      add_methyl_Hs(" HB1", " HB2", " HB3", torsion_1, residue_p);
+      done = true;
+   }
+   if (res_name == "CYS") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " SG ", bl, 107, residue_p);
+      add_SH_H(" HG ", " SG ", " CB ", " CA ", bl_sh, 109.5, 180, residue_p);
+      done = true;
+   }
+   if (res_name == "ASP") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      done = true;
+   }
+   if (res_name == "GLU") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      add_2_sp3_hydrogens(" HG2", " HG3", " CB ", " CG ", " CD ", bl, 107, residue_p);
+      done = true;
+   }
+   if (res_name == "PHE") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      add_aromatic_hydrogen(" HD1", " CG ", " CD1", " CE1", bl_arom, residue_p);
+      add_aromatic_hydrogen(" HE1", " CD1", " CE1", " CZ ", bl_arom, residue_p);
+      add_aromatic_hydrogen(" HD2", " CG ", " CD2", " CE2", bl_arom, residue_p);
+      add_aromatic_hydrogen(" HE2", " CD2", " CE2", " CZ ", bl_arom, residue_p);
+      add_aromatic_hydrogen(" HZ ", " CE1", " CZ ", " CE2", bl_arom, residue_p);
+      done = true;
+   }
+   if (res_name == "GLY") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p, true);
+      done = true;
+   }
+   if (res_name == "HIS") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      add_his_ring_C_Hs(residue_p);
+      done = true;
+   }
+   if (res_name == "ILE") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens("HG12", "HG13", " CB ", " CG1", " CD1", bl, 107, residue_p);
+      torsion_info_t ti(" CB ", " CG1", " CD1", bl, 109, 180);
+      add_methyl_Hs("HD11", "HD12", "HD13", ti, residue_p);
+      torsion_info_t t2(" CA ", " CB ", " CG2", bl, 109, 180);
+      add_methyl_Hs("HG21", "HG22", "HG23", t2, residue_p);
+      add_tetrahedral_hydrogen(" HB ", " CB ", " CA ", " CG1", " CG2", bl, residue_p);
+      done = true;
+   }
+   if (res_name == "LYS") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      add_2_sp3_hydrogens(" HG2", " HG3", " CB ", " CG ", " CD ", bl, 107, residue_p);
+      add_2_sp3_hydrogens(" HD2", " HD3", " CG ", " CD ", " CE ", bl, 107, residue_p);
+      add_2_sp3_hydrogens(" HE2", " HE3", " CD ", " CE ", " NZ ", bl, 107, residue_p);
+      torsion_info_t ti(" CD ", " CE ", " NZ ", bl, 109, 180);
+      add_methyl_Hs(" HZ1", " HZ2", " HZ3", ti, residue_p);
+      done = true;
+   }
+   if (res_name == "LEU") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      torsion_info_t t1(" CB ", " CG ", " CD1", bl, 109, 180);
+      torsion_info_t t2(" CB ", " CG ", " CD2", bl, 109, 180);
+      add_methyl_Hs("HD11", "HD12", "HD13", t1, residue_p);
+      add_methyl_Hs("HD21", "HD22", "HD23", t2, residue_p);
+      add_tetrahedral_hydrogen(" HG ", " CG ", " CB ", " CD1", " CD2", bl, residue_p);
+      done = true;
+   }
+   if (res_name == "MET") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      add_2_sp3_hydrogens(" HG2", " HG3", " CB ", " CG ", " SD ", bl, 107, residue_p);
+      torsion_info_t t1(" CG ", " SD ", " CE", bl, 109, 180);
+      add_methyl_Hs(" HE1", " HE2", " HE3", t1, residue_p);
+      done = true;
+   }
+   if (res_name == "MSE") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB1", " HB2", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      done = true;
+   }
+   if (res_name == "ASN") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      add_amino_hydrogens("HD21", "HD22", " ND2", " CG ", " OD1", bl_amino, residue_p);
+      done = true;
+   }
+   if (res_name == "PRO") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      add_2_sp3_hydrogens(" HG2", " HG3", " CB ", " CG ", " CD ", bl, 107, residue_p);
+      add_2_sp3_hydrogens(" HD2", " HD3", " CG ", " CD ", " N  ", bl, 107, residue_p);
+      done = true;
+   }
+   if (res_name == "GLN") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      add_2_sp3_hydrogens(" HG2", " HG3", " CB ", " CG ", " CD ", bl, 107, residue_p);
+      add_amino_hydrogens("HE21", "HE22", " NE2", " CD ", " OE1", bl_amino, residue_p);
+      done = true;
+   }
+   if (res_name == "ARG") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      add_2_sp3_hydrogens(" HG2", " HG3", " CB ", " CG ", " CD ", bl, 107, residue_p);
+      add_2_sp3_hydrogens(" HD2", " HD3", " CG ", " CD ", " NE ", bl, 107, residue_p);
+      add_guanidinium_hydrogens(residue_p);
+      done = true;
+   }
+   if (res_name == "SER") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " OG ", bl, 107, residue_p);
+      add_OH_H(" HG ", " OG ", " CB ", " CA ", bl_oh, 109.5, 180, residue_p);
+      done = true;
+   }
+   if (res_name == "THR") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_tetrahedral_hydrogen(" HB ", " CB ", " CA ", " OG1", " CG2", bl, residue_p);
+      torsion_info_t ti(" CA ", " CB ", " CG2", bl, 109, 180);
+      add_methyl_Hs("HG21", "HG22", "HG23", ti, residue_p);
+      add_OH_H(" HG1", " OG1", " CB ", " CA ", bl_oh, 109.5, 180, residue_p);
+      done = true;
+   }
+   if (res_name == "VAL") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      torsion_info_t t1(" CA ", " CB ", " CG1 ", bl, 109, 180);
+      torsion_info_t t2(" CA ", " CB ", " CG2 ", bl, 109, 180);
+      add_methyl_Hs("HG11", "HG12", "HG13", t1, residue_p);
+      add_methyl_Hs("HG21", "HG22", "HG23", t2, residue_p);
+      add_tetrahedral_hydrogen(" HB ", " CB ", " CA ", " CG1", " CG2", bl, residue_p);
+      done = true;
+   }
+   if (res_name == "TRP") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      add_trp_indole_hydrogens(residue_p);
+      done = true;
+   }
+   if (res_name == "TYR") {
+      add_main_chain_hydrogens(residue_p, residue_prev_p);
+      add_2_sp3_hydrogens(" HB2", " HB3", " CA ", " CB ", " CG ", bl, 107, residue_p);
+      add_aromatic_hydrogen(" HD1", " CG ", " CD1", " CE1", bl_arom, residue_p);
+      add_aromatic_hydrogen(" HE1", " CD1", " CE1", " CZ ", bl_arom, residue_p);
+      add_aromatic_hydrogen(" HD2", " CG ", " CD2", " CE2", bl_arom, residue_p);
+      add_aromatic_hydrogen(" HE2", " CD2", " CE2", " CZ ", bl_arom, residue_p);
+      add_OH_H(" HH ", " OH ", " CZ ", " CE1", bl_oh, 109.5, 180, residue_p);
+      done = true;
+   }
+   return done;
+}
+
+// is_gly is false by default
+void
+coot::reduce::add_main_chain_hydrogens(mmdb::Residue *residue_p, mmdb::Residue *residue_prev_p,
+				       bool is_gly) {
+
+   if (is_gly) {
+      double bl = 0.97;
+      add_2_sp3_hydrogens(" HA2", " HA3", " N  ", " CA ", " C  ", bl, 107, residue_p);
+      add_main_chain_H(residue_p, residue_prev_p);
+   } else {
+      add_main_chain_HA(residue_p);
+      std::string residue_name(residue_p->GetResName());
+      if (util::is_standard_amino_acid_name(residue_name))
+	 if (residue_name != "PRO")
+	    add_main_chain_H(residue_p, residue_prev_p);
+   }
+}
+
+
+// The H on the N
+// This function can be (is) called for the first residue in a chain, that is the N-terminus
+// and doesn't have a previous residue. That is checked for.
+void
+coot::reduce::add_main_chain_H(mmdb::Residue *residue_p, mmdb::Residue *residue_prev_p) {
+
+   if (residue_prev_p) {
+      // Try position by torsion based on O-C-N-H
+      double bl = 0.86;
+      if (residue_p->isNTerminus()) {
+	 // NH3+ - needs spin search - these are not riding
+      } else {
+	 std::vector<std::string> alt_confs = util::get_residue_alt_confs(residue_p);
+	 for (unsigned int i=0; i<alt_confs.size(); i++) {
+	    mmdb::Atom *at_ca     = residue_p->GetAtom(" CA ", 0, alt_confs[i].c_str());
+	    mmdb::Atom *at_n      = residue_p->GetAtom(" N  ", 0, alt_confs[i].c_str());
+	    mmdb::Atom *at_c_prev = residue_prev_p->GetAtom(" C  ", 0, alt_confs[i].c_str());
+	    mmdb::Atom *at_o_prev = residue_prev_p->GetAtom(" O  ", 0, alt_confs[i].c_str());
+	    if (at_ca && at_n && at_c_prev && at_o_prev) {
+
+	       clipper::Coord_orth at_c_pos  = co(at_c_prev);
+	       clipper::Coord_orth at_o_pos  = co(at_o_prev);
+	       clipper::Coord_orth at_n_pos  = co(at_n);
+	       clipper::Coord_orth at_ca_pos = co(at_ca);
+	       double angle = clipper::Util::d2rad(125.0);
+	       clipper::Coord_orth H_pos(at_ca_pos, at_c_pos, at_n_pos, bl, angle, M_PI);
+	       mmdb::realtype bf = at_n->tempFactor;
+	       add_hydrogen_atom(" H  ", H_pos, bf, alt_confs[i], residue_p);
+	    }
+	 }
+      }
+   }
+}
+
+// like above but for ligands (both second neighbours come from ligand residue)
+void
+coot::reduce::add_amino_single_H(const std::string &H_at_name,
+				 const std::string &first_neighb,
+				 const std::vector<std::string> &second_neighb_vec,
+				 double bl,
+				 mmdb::Residue *residue_p) {
+
+   if (second_neighb_vec.size() == 2) {
+      add_amino_single_H(H_at_name, second_neighb_vec[0], first_neighb, second_neighb_vec[1], bl, residue_p);
+   }
+}
+
+// add H to second atom by bisection
+void
+coot::reduce::add_amino_single_H(const std::string H_at_name,
+				 const std::string &at_name_1,
+				 const std::string &at_name_2,
+				 const std::string &at_name_3,
+				 double bl,
+				 mmdb::Residue *residue_p) {
+
+   add_trp_indole_hydrogen(H_at_name, at_name_1, at_name_2, at_name_3, bl, residue_p);
+}
+
+
+// The H on the CA
+void
+coot::reduce::add_main_chain_HA(mmdb::Residue *residue_p) {
+
+   double bl = 0.97;
+
+
+   // PDBv3 FIXME
+   std::vector<std::string> alt_confs = util::get_residue_alt_confs(residue_p);
+   for (unsigned int i=0; i<alt_confs.size(); i++) {
+      mmdb::Atom *at_ca = residue_p->GetAtom(" CA ", 0, alt_confs[i].c_str());
+      mmdb::Atom *at_n1 = residue_p->GetAtom(" C  ", 0, alt_confs[i].c_str());
+      mmdb::Atom *at_n2 = residue_p->GetAtom(" N  ", 0, alt_confs[i].c_str());
+      mmdb::Atom *at_n3 = residue_p->GetAtom(" CB ", 0, alt_confs[i].c_str());
+      if (at_ca && at_n1 && at_n2 && at_n3) {
+	 clipper::Coord_orth pos = position_by_tetrahedron(at_ca, at_n1, at_n2, at_n3, bl);
+	 mmdb::realtype bf = at_ca->tempFactor;
+	 add_hydrogen_atom(" HA ", pos, bf, alt_confs[i], residue_p);
+      }
+   }
+}
+
+mmdb::Atom *
+coot::reduce::add_hydrogen_atom(std::string atom_name, clipper::Coord_orth &pos,
+				mmdb::realtype bf,
+				const std::string &altconf,
+				mmdb::Residue *residue_p) {
+
+   mmdb::Atom *new_H = new mmdb::Atom;
+   new_H->SetAtomName(atom_name.c_str());
+   new_H->SetElementName(" H"); // PDBv3 FIXME
+   new_H->SetCoordinates(pos.x(), pos.y(), pos.z(), 1.0, bf);
+   if (! altconf.empty())
+      strncpy(new_H->altLoc, altconf.c_str(), 18); // 19 is mmdb limit, I think
+   int n_atoms = residue_p->GetNumberOfAtoms();
+   int idx = residue_p->AddAtom(new_H);
+   return new_H;
+}
+
+
+void 
+coot::reduce::add_methyl_Hs(const std::string &at_name_1,  // HB1 (for example)
+			    const std::string &at_name_2,  // HB2 + 120 degress
+			    const std::string &at_name_3,  // HB3 - 120 degree
+			    torsion_info_t torsion_1, torsion_info_t torsion_2,
+			    mmdb::Residue *residue_p) {
+
+   std::vector<std::string> alt_confs = util::get_residue_alt_confs(residue_p);
+   for (unsigned int i=0; i<alt_confs.size(); i++) {
+      clipper::Coord_orth p11;
+      clipper::Coord_orth p12;
+      clipper::Coord_orth p13;
+      clipper::Coord_orth p21;
+      clipper::Coord_orth p22;
+      clipper::Coord_orth p23;
+      bool have_1 = false;
+      bool have_2 = false;
+      mmdb::Atom *at_1 = residue_p->GetAtom(torsion_1.at_name_1.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_2 = residue_p->GetAtom(torsion_1.at_name_2.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_3 = residue_p->GetAtom(torsion_1.at_name_3.c_str(), 0, alt_confs[i].c_str());
+      if (at_1 && at_2 && at_3) {
+	 have_1 = true;
+	 p11 = position_by_bond_length_angle_torsion(at_1, at_2, at_3,
+						     torsion_1.bond_length,
+						     clipper::Util::d2rad(torsion_1.angle_deg),
+						     clipper::Util::d2rad(torsion_1.torsion_deg));
+	 p12 = position_by_bond_length_angle_torsion(at_1, at_2, at_3,
+						     torsion_1.bond_length,
+						     clipper::Util::d2rad(torsion_1.angle_deg),
+						     clipper::Util::d2rad(torsion_1.torsion_deg + 120));
+	 p13 = position_by_bond_length_angle_torsion(at_1, at_2, at_3,
+						     torsion_1.bond_length,
+						     clipper::Util::d2rad(torsion_1.angle_deg),
+						     clipper::Util::d2rad(torsion_1.torsion_deg - 120));
+      }
+      at_1 = residue_p->GetAtom(torsion_2.at_name_1.c_str(), 0, alt_confs[i].c_str());
+      at_2 = residue_p->GetAtom(torsion_2.at_name_2.c_str(), 0, alt_confs[i].c_str());
+      at_3 = residue_p->GetAtom(torsion_2.at_name_3.c_str(), 0, alt_confs[i].c_str());
+      if (at_1 && at_2 && at_3) {
+	 have_2 = true;
+	 p21 = position_by_bond_length_angle_torsion(at_1, at_2, at_3,
+						     torsion_2.bond_length,
+						    clipper::Util::d2rad(torsion_2.angle_deg),
+						    clipper::Util::d2rad(torsion_2.torsion_deg));
+	 p22 = position_by_bond_length_angle_torsion(at_1, at_2, at_3,
+						     torsion_2.bond_length,
+						     clipper::Util::d2rad(torsion_2.angle_deg),
+						     clipper::Util::d2rad(torsion_2.torsion_deg + 120));
+	 p23 = position_by_bond_length_angle_torsion(at_1, at_2, at_3,
+						     torsion_2.bond_length,
+						     clipper::Util::d2rad(torsion_2.angle_deg),
+						     clipper::Util::d2rad(torsion_2.torsion_deg - 120));
+      }
+
+      // can construct result differently if we only have either p1 or p2.  THis will do for now.
+      // 
+      if (have_1) {
+	 // this may make them too short. Hmm.
+// 	 clipper::Coord_orth pav_1 = 0.5 * (p11 + p21);
+// 	 clipper::Coord_orth pav_2 = 0.5 * (p12 + p22);
+// 	 clipper::Coord_orth pav_3 = 0.5 * (p13 + p23);
+	 
+	 clipper::Coord_orth pav_1 = p11;
+	 clipper::Coord_orth pav_2 = p12;
+	 clipper::Coord_orth pav_3 = p13;
+	 mmdb::realtype bf = at_3->tempFactor;
+	 add_hydrogen_atom(at_name_1, pav_1, bf, alt_confs[i], residue_p);
+	 add_hydrogen_atom(at_name_2, pav_2, bf, alt_confs[i], residue_p);
+	 add_hydrogen_atom(at_name_3, pav_3, bf, alt_confs[i], residue_p);
+      }
+   }
+}
+void 
+coot::reduce::add_methyl_Hs(const std::string &at_name_1,  // HB1 (for example)
+			    const std::string &at_name_2,  // HB2 + 120 degress
+			    const std::string &at_name_3,  // HB3 - 120 degree
+			    torsion_info_t torsion_1,
+			    mmdb::Residue *residue_p) {
+
+   std::vector<std::string> alt_confs = util::get_residue_alt_confs(residue_p);
+   for (unsigned int i=0; i<alt_confs.size(); i++) {
+      clipper::Coord_orth p11;
+      clipper::Coord_orth p12;
+      clipper::Coord_orth p13;
+      bool have_1 = false;
+      mmdb::Atom *at_1 = residue_p->GetAtom(torsion_1.at_name_1.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_2 = residue_p->GetAtom(torsion_1.at_name_2.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_3 = residue_p->GetAtom(torsion_1.at_name_3.c_str(), 0, alt_confs[i].c_str());
+      if (at_1 && at_2 && at_3) {
+	 have_1 = true;
+	 p11 = position_by_bond_length_angle_torsion(at_1, at_2, at_3,
+						     torsion_1.bond_length,
+						     clipper::Util::d2rad(torsion_1.angle_deg),
+						     clipper::Util::d2rad(torsion_1.torsion_deg));
+	 p12 = position_by_bond_length_angle_torsion(at_1, at_2, at_3,
+						     torsion_1.bond_length,
+						     clipper::Util::d2rad(torsion_1.angle_deg),
+						     clipper::Util::d2rad(torsion_1.torsion_deg + 120));
+	 p13 = position_by_bond_length_angle_torsion(at_1, at_2, at_3,
+						     torsion_1.bond_length,
+						     clipper::Util::d2rad(torsion_1.angle_deg),
+						     clipper::Util::d2rad(torsion_1.torsion_deg - 120));
+      }
+      if (have_1) {
+	 
+	 clipper::Coord_orth pav_1 = p11;
+	 clipper::Coord_orth pav_2 = p12;
+	 clipper::Coord_orth pav_3 = p13;
+	 mmdb::realtype bf = at_3->tempFactor;
+	 add_hydrogen_atom(at_name_1, pav_1, bf, alt_confs[i], residue_p);
+	 add_hydrogen_atom(at_name_2, pav_2, bf, alt_confs[i], residue_p);
+	 add_hydrogen_atom(at_name_3, pav_3, bf, alt_confs[i], residue_p);
+      }
+   }
+}
+
+
+// choose_only_farthest_position is default false.
+// if choose_only_farthest_position is true, only add the H_at_name_1 and
+// add it in the position that is furthese from the averge of the second neighbours
+// e.g. the single H on the N of piperidine.
+//
+void
+coot::reduce::add_2_sp3_hydrogens(const std::string &H_at_name_1,
+				  const std::string &H_at_name_2,
+				  const std::string &at_name_1,
+				  const std::string &at_name_2,
+				  const std::string &at_name_3,
+				  double bond_length,
+				  double angle_between_Hs, // in degrees
+				  mmdb::Residue *residue_p,
+				  bool choose_only_farthest_position) {
+
+   std::vector<std::string> alt_confs = util::get_residue_alt_confs(residue_p);
+   for (unsigned int i=0; i<alt_confs.size(); i++) {
+      
+      mmdb::Atom *at_1 = residue_p->GetAtom(at_name_1.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_2 = residue_p->GetAtom(at_name_2.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_3 = residue_p->GetAtom(at_name_3.c_str(), 0, alt_confs[i].c_str());
+      if (at_1 && at_2 && at_3) {
+	 std::pair<clipper::Coord_orth, clipper::Coord_orth> Hs =
+	    position_pair_by_bisection(at_1, at_2, at_3, bond_length,
+				       clipper::Util::d2rad(angle_between_Hs));
+	 mmdb::realtype bf = at_2->tempFactor;
+	 if (! choose_only_farthest_position) {
+	    add_hydrogen_atom(H_at_name_1, Hs.first,  bf, alt_confs[i], residue_p);
+	    add_hydrogen_atom(H_at_name_2, Hs.second, bf, alt_confs[i], residue_p);
+	 } else {
+	    clipper::Coord_orth at_pos_1 = co(at_1);
+	    clipper::Coord_orth at_pos_3 = co(at_3);
+	    clipper::Coord_orth mp(0.5 * (at_pos_1 + at_pos_3));
+	    double d1 = (Hs.first).lengthsq();
+	    double d2 = (Hs.second).lengthsq();
+	    if (d1 > d2)
+	       add_hydrogen_atom(H_at_name_1, Hs.first,  bf, alt_confs[i], residue_p);
+	    else
+	       add_hydrogen_atom(H_at_name_1, Hs.second, bf, alt_confs[i], residue_p);
+	 }
+      } else {
+	 if (!alt_confs[i].empty()) {
+	    std::cout << "Residue " << residue_spec_t(residue_p) << " " << residue_p->GetResName()
+		      << " alt-conf \"" << alt_confs[i] << "\"" << std::endl;
+	    std::cout << "Fail to add " << H_at_name_1 << " " << H_at_name_2 << " at_1: " << at_1 << std::endl;
+	    std::cout << "            " << H_at_name_1 << " " << H_at_name_2 << " at_2: " << at_2 << std::endl;
+	    std::cout << "            " << H_at_name_1 << " " << H_at_name_2 << " at_3: " << at_3 << std::endl;
+	 }
+      }
+   }
+}
+
+// choose_only_farthest_position is default false.
+// if choose_only_farthest_position is true, only add the H_at_name_1 and
+// add it in the position that is furthese from the averge of the second neighbours
+//
+void
+coot::reduce::add_2_sp3_hydrogens(const std::string &H_at_name_1,
+				  const std::string &H_at_name_2,
+				  const std::string &first_neighb,
+				  const std::vector<std::string> &second_neighb_vec,
+				  double bond_length,
+				  double angle_between_Hs, // in degrees
+				  mmdb::Residue *residue_p,
+				  bool choose_only_farthest_position) {
+
+   if (second_neighb_vec.size() == 2) {
+      const std::string &second_1 = second_neighb_vec[0];
+      const std::string &second_2 = second_neighb_vec[1];
+      add_2_sp3_hydrogens(H_at_name_1, H_at_name_2, second_1, first_neighb, second_2, bond_length,
+			  angle_between_Hs, residue_p, choose_only_farthest_position);
+   } else {
+      std::cout << "WARNING:: in add_2_sp3_hydrogens() second_neighb_vec.size() is "
+		<< second_neighb_vec.size() << std::endl;
+   }
+}
+
+
+
+void
+coot::reduce::add_tetrahedral_hydrogen(const std::string &H_at_name,
+				       const std::string &at_central_name,
+				       const std::string &neighb_at_name_1,
+				       const std::string &neighb_at_name_2,
+				       const std::string &neighb_at_name_3,
+				       double bond_length,
+				       mmdb::Residue *residue_p) {
+
+   
+   std::vector<std::string> alt_confs = util::get_residue_alt_confs(residue_p);
+   for (unsigned int i=0; i<alt_confs.size(); i++) {
+      mmdb::Atom *at_central = residue_p->GetAtom(at_central_name.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_n_1 = residue_p->GetAtom(neighb_at_name_1.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_n_2 = residue_p->GetAtom(neighb_at_name_2.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_n_3 = residue_p->GetAtom(neighb_at_name_3.c_str(), 0, alt_confs[i].c_str());
+      if (at_central && at_n_1 && at_n_2 && at_n_3) {
+	 clipper::Coord_orth H_pos = position_by_tetrahedron(at_central, at_n_1, at_n_2, at_n_3,
+							     bond_length);
+	 mmdb::realtype bf = at_central->tempFactor;
+	 add_hydrogen_atom(H_at_name, H_pos,  bf, alt_confs[i], residue_p);
+      }
+   }
+}
+
+void
+coot::reduce::add_tetrahedral_hydrogen(const std::string &H_at_name,
+				       const std::string &first_neighb,
+				       const std::vector<std::string> &second_neighb_vec,
+				       double bl, mmdb::Residue *residue_p) {
+
+   if (false) {
+      std::cout << "atom " << first_neighb << " has " << second_neighb_vec.size()
+		<< " neighbours" << std::endl;
+      for (unsigned int i=0; i<second_neighb_vec.size(); i++)
+	 std::cout << "   " << second_neighb_vec[i] << std::endl;
+   }
+
+   if (second_neighb_vec.size() == 3)
+      add_tetrahedral_hydrogen(H_at_name, first_neighb,
+			       second_neighb_vec[0],
+			       second_neighb_vec[1],
+			       second_neighb_vec[2],
+			       bl, residue_p);
+   else
+      std::cout << "WARNING:: atom " << first_neighb << " had " << second_neighb_vec.size()
+		<< " neighbours  (not 3)" << std::endl;
+}
+
+
+// This does alphiphatic hydrogens just as well, also aldehyde hydrogens
+void
+coot::reduce::add_aromatic_hydrogen(const std::string &H_at_name,
+				    const std::string &neighb_at_name_1,
+				    const std::string &neighb_at_name_2, // add to this
+				    const std::string &neighb_at_name_3,
+				    double bl, mmdb::Residue *residue_p) {
+
+   std::vector<std::string> alt_confs = util::get_residue_alt_confs(residue_p);
+   for (unsigned int i=0; i<alt_confs.size(); i++) {
+      mmdb::Atom *at_n_1 = residue_p->GetAtom(neighb_at_name_1.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_n_2 = residue_p->GetAtom(neighb_at_name_2.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_n_3 = residue_p->GetAtom(neighb_at_name_3.c_str(), 0, alt_confs[i].c_str());
+      if (at_n_1 && at_n_2 && at_n_3) {
+	 mmdb::realtype bf = at_n_2->tempFactor;
+	 clipper::Coord_orth H_pos = position_by_bisection(at_n_1, at_n_2, at_n_3, bl);
+	 add_hydrogen_atom(H_at_name, H_pos, bf, alt_confs[i], residue_p);
+      } else {
+	 std::cout << "Fail Residue " << residue_spec_t(residue_p) << " " << residue_p->GetResName()
+		   << " alt-conf \"" << alt_confs[i] << "\""
+		   << " failed in add_aromatic_hydrogen " << std::endl;
+	 std::cout << "Fail to add " << neighb_at_name_1 << " at_1: " << at_n_1 << std::endl;
+	 std::cout << "            " << neighb_at_name_2 << " at_2: " << at_n_2 << std::endl;
+	 std::cout << "            " << neighb_at_name_3 << " at_3: " << at_n_3 << std::endl;
+      }
+   }
+}
+
+void
+coot::reduce::add_amino_hydrogens(const std::string &H_at_name_1,
+				  const std::string &H_at_name_2,
+				  const std::string &at_name_1,   // NE2
+				  const std::string &at_name_2,   // CG
+				  const std::string &at_name_3,   // OE1
+				  double bl_amino,
+				  mmdb::Residue *residue_p) {
+
+   std::vector<std::string> alt_confs = util::get_residue_alt_confs(residue_p);
+   for (unsigned int i=0; i<alt_confs.size(); i++) {
+      mmdb::Atom *at_n_1 = residue_p->GetAtom(at_name_1.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_n_2 = residue_p->GetAtom(at_name_2.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_n_3 = residue_p->GetAtom(at_name_3.c_str(), 0, alt_confs[i].c_str());
+      if (at_n_1 && at_n_2 && at_n_3) {
+	 clipper::Coord_orth Hp1 = position_by_bond_length_angle_torsion(at_n_3, at_n_2, at_n_1,
+									 bl_amino,
+									 clipper::Util::d2rad(120),
+									 clipper::Util::d2rad(180));
+	 clipper::Coord_orth Hp2 = position_by_bond_length_angle_torsion(at_n_3, at_n_2, at_n_1,
+									 bl_amino,
+									 clipper::Util::d2rad(120),
+									 clipper::Util::d2rad(0));
+	 mmdb::realtype bf = at_n_1->tempFactor;
+	 add_hydrogen_atom(H_at_name_1, Hp1, bf, alt_confs[i], residue_p);
+	 add_hydrogen_atom(H_at_name_2, Hp2, bf, alt_confs[i], residue_p);
+      } else {
+	 std::cout << "Fail Residue " << residue_spec_t(residue_p) << " " << residue_p->GetResName()
+		   << " alt-conf \"" << alt_confs[i] << "\""
+		   << " failed in add_amino_hydrogens" << std::endl;
+	 std::cout << "Fail to add " << at_name_1 << " at_1: " << at_name_1 << " " << at_n_1 << std::endl;
+	 std::cout << "            " << at_name_2 << " at_2: " << at_name_2 << " " << at_n_2 << std::endl;
+	 std::cout << "            " << at_name_3 << " at_3: " << at_name_3 << " " << at_n_3 << std::endl;
+      }
+   }
+}
+
+void
+coot::reduce::add_amino_hydrogens(const std::string &H_at_name_1,
+				  const std::string &H_at_name_2,
+				  const std::string &first_neighb,
+				  const std::vector<std::string> &second_neighb_vec,
+				  const std::map<std::string, std::vector<std::string> > &third_neighb_map,
+				  double bl_amino,
+				  mmdb::Residue *residue_p) {
+
+   if (second_neighb_vec.size() > 0) {
+      std::string second = second_neighb_vec[0];
+      std::map<std::string, std::vector<std::string> >::const_iterator it;
+      it = third_neighb_map.find(second);
+      if (it != third_neighb_map.end()) {
+	 std::vector<std::string> thirds = it->second;
+	 if (thirds.size() > 0) {
+	    const std::string &third = thirds[0];
+	    add_amino_hydrogens(H_at_name_1, H_at_name_2, first_neighb, second, third, bl_amino, residue_p);
+	 }
+      }
+   }
+}
+
+
+void
+coot::reduce::add_guanidinium_hydrogens(mmdb::Residue *residue_p) {
+
+   std::vector<std::string> alt_confs = util::get_residue_alt_confs(residue_p);
+   for (unsigned int i=0; i<alt_confs.size(); i++) {
+
+      // HE
+      std::string H_at_name = " HE ";
+      double bl = 0.86;
+      mmdb::Atom *at_n_1 = residue_p->GetAtom(" CD ", 0, alt_confs[i].c_str());
+      mmdb::Atom *at_n_2 = residue_p->GetAtom(" NE ", 0, alt_confs[i].c_str());
+      mmdb::Atom *at_n_3 = residue_p->GetAtom(" CZ ", 0, alt_confs[i].c_str());
+      if (at_n_1 && at_n_2 && at_n_3) {
+	 mmdb::realtype bf = at_n_2->tempFactor;
+	 clipper::Coord_orth H_pos = position_by_bisection(at_n_1, at_n_2, at_n_3, bl);
+	 add_hydrogen_atom(H_at_name, H_pos, bf, alt_confs[i], residue_p);
+      } else {
+	 std::cout << "Fail Residue " << residue_spec_t(residue_p) << " " << residue_p->GetResName()
+		   << " alt-conf \"" << alt_confs[i] << "\""
+		   << " failed in add_aromatic_hydrogen " << std::endl;
+	 std::cout << "Fail to add guanidinium-H " << " CD " << " at_1: " << at_n_1 << std::endl;
+	 std::cout << "                          " << " NE " << " at_2: " << at_n_2 << std::endl;
+	 std::cout << "                          " << " CZ " << " at_3: " << at_n_3 << std::endl;
+      }
+
+      // HH[12][12]
+      //
+      at_n_1 = residue_p->GetAtom(" NE", 0, alt_confs[i].c_str());
+      at_n_2 = residue_p->GetAtom(" CZ ", 0, alt_confs[i].c_str());
+      mmdb::Atom *at_nh1 = residue_p->GetAtom(" NH1", 0, alt_confs[i].c_str());
+      mmdb::Atom *at_nh2 = residue_p->GetAtom(" NH2", 0, alt_confs[i].c_str());
+      if (at_n_1 && at_n_2 && at_n_3) {
+	 double bf_nh1 = at_nh2->tempFactor;
+	 double bf_nh2 = at_nh2->tempFactor;
+	 double a = clipper::Util::d2rad(120);
+	 double t = clipper::Util::d2rad(180);
+	 clipper::Coord_orth hh11 = position_by_bond_length_angle_torsion(at_n_1, at_n_2, at_nh1, bl, a, 0);
+	 clipper::Coord_orth hh12 = position_by_bond_length_angle_torsion(at_n_1, at_n_2, at_nh1, bl, a, t);
+	 clipper::Coord_orth hh21 = position_by_bond_length_angle_torsion(at_n_1, at_n_2, at_nh2, bl, a, 0);
+	 clipper::Coord_orth hh22 = position_by_bond_length_angle_torsion(at_n_1, at_n_2, at_nh2, bl, a, t);
+	 add_hydrogen_atom("HH11", hh11, bf_nh1, alt_confs[i], residue_p);
+	 add_hydrogen_atom("HH12", hh12, bf_nh2, alt_confs[i], residue_p);
+	 add_hydrogen_atom("HH21", hh21, bf_nh2, alt_confs[i], residue_p);
+	 add_hydrogen_atom("HH22", hh22, bf_nh2, alt_confs[i], residue_p);
+      }
+   }
+}
+
+void
+coot::reduce::add_trp_indole_hydrogens(mmdb::Residue *residue_p) {
+
+   double bl = 0.86; // H on N
+   double bl_arom = 0.93;
+   add_trp_indole_hydrogen(" HD1", " CG ", " CD1", " NE1", bl, residue_p);
+   add_trp_indole_hydrogen(" HE1", " CD1", " NE1", " CE2", bl_arom, residue_p);
+   add_trp_indole_hydrogen(" HE3", " CD2", " CE3", " CZ3", bl_arom, residue_p);
+   add_trp_indole_hydrogen(" HZ3", " CE3", " CZ3", " CH2", bl_arom, residue_p);
+   add_trp_indole_hydrogen(" HH2", " CZ3", " CH2", " CZ2", bl_arom, residue_p);
+   add_trp_indole_hydrogen(" HZ2", " CH2", " CZ2", " CE2", bl_arom, residue_p);
+}
+
+void
+coot::reduce::add_trp_indole_hydrogen(const std::string &H_name,
+				      const std::string &at_name_1,
+				      const std::string &at_name_2,
+				      const std::string &at_name_3,
+				      double bl,
+				      mmdb::Residue *residue_p) {
+
+   std::vector<std::string> alt_confs = util::get_residue_alt_confs(residue_p);
+   for (unsigned int i=0; i<alt_confs.size(); i++) {
+      mmdb::Atom *at_1 = residue_p->GetAtom(at_name_1.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_2 = residue_p->GetAtom(at_name_2.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_3 = residue_p->GetAtom(at_name_3.c_str(), 0, alt_confs[i].c_str());
+      if (at_1 && at_2 && at_3) {
+	 clipper::Coord_orth H_pos = position_by_bisection(at_1, at_2, at_3, bl);
+	 double bf = at_2->tempFactor;
+	 add_hydrogen_atom(H_name, H_pos, bf, alt_confs[i], residue_p);
+      }
+   }
+}
+
+// this will need a spin-search
+void
+coot::reduce::add_OH_H(const std::string &H_name,
+		       const std::string &at_name_1,  // OG
+		       const std::string &at_name_2,  // CB
+		       const std::string &at_name_3,  // CA
+		       double bl,
+		       double angle,      // deg
+		       double tor_inital, // deg
+		       mmdb::Residue *residue_p) {
+
+   add_xH_H(H_name, at_name_1, at_name_2, at_name_3, bl, angle, tor_inital, residue_p);
+
+}
+
+      
+void
+coot::reduce::add_OH_H(const std::string &H_at_name,
+		       const std::string &first_neighb,
+		       const std::vector<std::string> &second_neighb_vec,
+		       const std::map<std::string, std::vector<std::string> > &third_neighb_map,
+		       double bond_length,
+		       double ang_deg,
+		       double torsion_deg,
+		       mmdb::Residue *residue_p) {
+
+   if (second_neighb_vec.size() > 0) {
+      std::string second = second_neighb_vec[0];
+      std::map<std::string, std::vector<std::string> >::const_iterator it;
+      it = third_neighb_map.find(second);
+      if (it != third_neighb_map.end()) {
+	 std::vector<std::string> thirds = it->second;
+	 if (thirds.size() > 0) {
+	    std::string third = thirds[0];
+	    add_OH_H(H_at_name, first_neighb, second_neighb_vec[0], third,
+		     bond_length, ang_deg, torsion_deg, residue_p);
+	 }
+      } else {
+	 std::cout << "failed to find key " << second << " in thirds map" << std::endl;
+      }
+   }
+}
+
+
+// this will need a spin-search
+std::vector<mmdb::Atom *>
+coot::reduce::add_SH_H(const std::string &H_name,
+		       const std::string &at_name_1,  // OG
+		       const std::string &at_name_2,  // CB
+		       const std::string &at_name_3,  // CA
+		       double bl,
+		       double angle,      // deg
+		       double tor_inital, // deg
+		       mmdb::Residue *residue_p) {
+
+   if (is_ss_bonded(residue_p)) {
+      // don't add an H on the S
+      std::vector<mmdb::Atom *> empty;
+      return empty;
+   } else {
+      return add_xH_H(H_name, at_name_1, at_name_2, at_name_3, bl, angle, tor_inital, residue_p);
+   }
+
+}
+
+
+// this will need a spin-search
+std::vector<mmdb::Atom *>
+coot::reduce::add_xH_H(const std::string &H_name,
+		       const std::string &at_name_1,  // OG
+		       const std::string &at_name_2,  // CB
+		       const std::string &at_name_3,  // CA
+		       double bl,
+		       double angle,      // deg
+		       double tor_inital, // deg
+		       mmdb::Residue *residue_p) {
+
+   std::vector<mmdb::Atom *> r;
+   std::vector<std::string> alt_confs = util::get_residue_alt_confs(residue_p);
+   for (unsigned int i=0; i<alt_confs.size(); i++) {
+      mmdb::Atom *at_1 = residue_p->GetAtom(at_name_1.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_2 = residue_p->GetAtom(at_name_2.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_3 = residue_p->GetAtom(at_name_3.c_str(), 0, alt_confs[i].c_str());
+      if (at_1 && at_2 && at_3) {
+	 clipper::Coord_orth H_pos = position_by_bond_length_angle_torsion(at_3, at_2, at_1, bl,
+									   clipper::Util::d2rad(angle),
+									   clipper::Util::d2rad(tor_inital));
+	 double bf = at_2->tempFactor;
+	 mmdb::Atom *at = add_hydrogen_atom(H_name, H_pos, bf, alt_confs[i], residue_p);
+	 r.push_back(at);
+      }
+   }
+   return r;
+}
+
+void
+coot::reduce::add_his_ring_C_Hs(mmdb::Residue *residue_p) {
+
+   double bl_arom = 0.93;
+   add_his_ring_H(" HD2", " CG ", " CD2", "NE2", bl_arom, residue_p);
+   add_his_ring_H(" HE1", " ND1", " CE1", "NE2", bl_arom, residue_p);
+
+}
+
+std::vector<mmdb::Atom *>
+coot::reduce::add_his_ring_H(const std::string &H_name,
+			     const std::string &at_name_1,
+			     const std::string &at_name_2,
+			     const std::string &at_name_3,
+			     double bl_arom,
+			     mmdb::Residue *residue_p) {
+
+   std::vector<mmdb::Atom *> r;
+   std::vector<std::string> alt_confs = util::get_residue_alt_confs(residue_p);
+   for (unsigned int i=0; i<alt_confs.size(); i++) {
+      mmdb::Atom *at_1 = residue_p->GetAtom(at_name_1.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_2 = residue_p->GetAtom(at_name_2.c_str(), 0, alt_confs[i].c_str());
+      mmdb::Atom *at_3 = residue_p->GetAtom(at_name_3.c_str(), 0, alt_confs[i].c_str());
+      if (at_1 && at_2 && at_3) {
+	 clipper::Coord_orth H_pos = position_by_bisection(at_1, at_2, at_3, bl_arom);
+	 double bf = at_2->tempFactor;
+	 mmdb::Atom *at = add_hydrogen_atom(H_name, H_pos, bf, alt_confs[i], residue_p);
+	 r.push_back(at);
+      }
+   }
+   return r;
+}
+
+void
+coot::reduce::add_his_ring_H(const std::string &H_at_name,
+			     const std::string &first_neigh,
+			     const std::vector<std::string> second_neighb_vec,
+			     double bl,
+			     mmdb::Residue *residue_p) {
+
+   if (second_neighb_vec.size() == 2) {
+      add_his_ring_H(H_at_name, second_neighb_vec[0], first_neigh, second_neighb_vec[1], bl, residue_p);
+   }
+}
+
+void
+coot::reduce::add_aromatic_hydrogen(const std::string &H_at_name,
+				    const std::string &first_neigh,
+				    const std::vector<std::string> second_neighb_vec,
+				    double bl,
+				    mmdb::Residue *residue_p) {
+
+   if (second_neighb_vec.size() == 2) {
+      add_aromatic_hydrogen(H_at_name, second_neighb_vec[0], first_neigh, second_neighb_vec[1],
+			    bl, residue_p);
+   }
+}
+
+void
+coot::reduce::find_best_his_protonation_orientation(mmdb::Residue *residue_p) {
+
+   // Put the H on the ND1 then on the NE2 - see which gives the best
+   // score - choose that.
+   //
+   // Do orientation hypotheses later - maybe.
+
+   if (geom_p) {
+      std::string res_name = residue_p->GetResName();
+      if (res_name == "HIS") {
+	 double bl = 0.86;
+	 std::vector<mmdb::Atom *> v = add_his_ring_H(" HE2", " CE1", "NE2", " CD2", bl, residue_p);
+	 std::vector<mmdb::Residue *> neighbs = coot::residues_near_residue(residue_p, mol, 5);
+	 atom_overlaps_container_t ao_1(residue_p, neighbs, mol, geom_p, 0.5);
+	 atom_overlaps_dots_container_t aod_1 = ao_1.contact_dots_for_ligand();
+	 double s1 = aod_1.score();
+	 // this only does the first alt conf. It can get messy with alt confs.
+
+	 if (v.size() > 0) {
+	    mmdb::Atom *at = v[0];
+	    delete at;
+	    mol->FinishStructEdit();
+	 }
+
+ 	 v = add_his_ring_H(" HD1", " CG ", "ND1", " CE1", bl, residue_p);
+ 	 atom_overlaps_container_t ao_2(residue_p, neighbs, mol, geom_p, 0.5);
+ 	 atom_overlaps_dots_container_t aod_2 = ao_2.contact_dots_for_ligand();
+ 	 double s2 = aod_2.score();
+ 	 std::cout << "scores: " << residue_spec_t(residue_p) << " " << s1 << " " << s2
+ 		   << std::endl;
+	 if (v.size() > 0) { // sanity check
+	    if (s1 > s2) {
+	       // delete HD1
+	       delete v[0];
+	       // add the first one back
+	       add_his_ring_H(" HE2", " CE1", "NE2", " CD2", bl, residue_p);
+	       mol->FinishStructEdit();
+	    }
+	 }
+      }
+   } else {
+      std::cout << "No geometry" << std::endl;
+   }
+}
+
+void
+coot::reduce::switch_his_protonation(mmdb::Residue *residue_p,
+				     mmdb::Atom *current_H_atom) {
+
+   if (current_H_atom) {
+      std::string atom_name = current_H_atom->name;
+      std::string new_atom_name;
+      if (atom_name == " HD1") new_atom_name = " HE2";
+      if (atom_name == " HE2") new_atom_name = " HD1";
+      if (! new_atom_name.empty()) {
+
+	 // ND1 -> HD1   and   NE2 -> HE2 by dictionary
+	 //
+	 // New atom HD1 first
+	 std::cout << "switch_his_protonation() " << 1 << std::endl;
+	 std::string at_name_1 = " CG ";
+	 std::string at_name_2 = " ND1";
+	 std::string at_name_3 = " CE1";
+	 if (new_atom_name == " HE2") {
+	    at_name_1 = " CE1";
+	    at_name_2 = " NE2";
+	    at_name_3 = " CD2";
+	 }
+	 std::string alt_conf = current_H_atom->altLoc;
+	 mmdb::Atom *at_1 = residue_p->GetAtom(at_name_1.c_str(), 0, alt_conf.c_str());
+	 mmdb::Atom *at_2 = residue_p->GetAtom(at_name_2.c_str(), 0, alt_conf.c_str());
+	 mmdb::Atom *at_3 = residue_p->GetAtom(at_name_3.c_str(), 0, alt_conf.c_str());
+	 if (at_1 && at_2 && at_3) {
+	    std::cout << "switch_his_protonation() " << 2 << " " << new_atom_name << std::endl;
+	    current_H_atom->SetAtomName(new_atom_name.c_str());
+	    double bl_arom = 0.93;
+	    clipper::Coord_orth pos = position_by_bisection(at_1, at_2, at_3, bl_arom);
+	    double bf = current_H_atom->tempFactor;
+	    current_H_atom->SetCoordinates(pos.x(), pos.y(), pos.z(), 1.0, bf);
+	 }
+      }
+   }
+}
+
+bool
+coot::reduce::is_ss_bonded(mmdb::Residue *residue_p) const {
+
+   bool status = false;
+   if (residue_p) {
+      std::string res_name = residue_p->GetResName();
+      if (res_name == "CYS") {
+	 int imod = 1;
+	 mmdb::Model *model_p = mol->GetModel(imod);
+	 // check SS bonds here
+	 status = true;
+      }
+   }
+
+   return status;
+}
+
+
+
+void
+coot::reduce::delete_atom_by_name(const std::string &at_name, mmdb::Residue *residue_p) {
+
+   bool an_atom_was_deleted = true; // so we can start the while loop
+   while (an_atom_was_deleted) {
+      an_atom_was_deleted = false;
+      int n_atoms = residue_p->GetNumberOfAtoms();
+      for (int iat=0; iat<n_atoms; iat++) {
+	 mmdb::Atom *at = residue_p->GetAtom(iat);
+	 std::string ele(at->element);
+	 if (ele == " H" || ele == " D") {
+	    residue_p->DeleteAtom(iat);
+	    an_atom_was_deleted = true;
+	    break;
+	 }
+      }
+   }
+}
+
+void
+coot::reduce::delete_hydrogen_atoms() {
+
+   for(int imod = 1; imod<=mol->GetNumberOfModels(); imod++) {
+      mmdb::Model *model_p = mol->GetModel(imod);
+      if (model_p) {
+	 mmdb::Chain *chain_p;
+	 int n_chains = model_p->GetNumberOfChains();
+	 for (int ichain=0; ichain<n_chains; ichain++) {
+	    chain_p = model_p->GetChain(ichain);
+	    int nres = chain_p->GetNumberOfResidues();
+	    mmdb::Residue *residue_p;
+	    mmdb::Atom *at;
+	    for (int ires=0; ires<nres; ires++) {
+	       residue_p = chain_p->GetResidue(ires);
+	       int n_atoms = residue_p->GetNumberOfAtoms();
+	       bool an_atom_was_deleted = true; // so we can start the while loop
+	       while (an_atom_was_deleted) {
+		  an_atom_was_deleted = false;
+		  for (int iat=0; iat<n_atoms; iat++) {
+		     at = residue_p->GetAtom(iat);
+		     std::string ele(at->element);
+		     if (ele == " H" || ele == " D") {
+			residue_p->DeleteAtom(iat);
+			an_atom_was_deleted = true;
+			break;
+		     }
+		  }
+	       }
+	    }
+	 }
+      }
+   }
+}
+
+// skip waters, HOH
+void
+coot::reduce::hydrogen_placement_by_dictionary(mmdb::Residue *residue_p) {
+
+   std::string res_name = residue_p->GetResName();
+   if (res_name != "HOH") {
+      if (geom_p) {
+	 std::pair<bool, dictionary_residue_restraints_t> p =
+	    geom_p->get_monomer_restraints(res_name, imol);
+	 if (p.first) {
+	    hydrogen_placement_by_dictionary(p.second, residue_p);
+	 }
+      }
+   }
+}
+
+void
+coot::reduce::hydrogen_placement_by_dictionary(const dictionary_residue_restraints_t &rest,
+					       mmdb::Residue *residue_p) {
+
+   std::vector<std::string> done_atom_name_list; // so that we don't add some atoms twice
+   for (unsigned int iat=0; iat<rest.atom_info.size(); iat++) {
+      if (rest.atom_info[iat].is_hydrogen()) {
+	 const std::string &H_at_name = rest.atom_info[iat].atom_id_4c;
+	 // if we haven't done it already...
+	 if (std::find(done_atom_name_list.begin(), done_atom_name_list.end(), H_at_name) == done_atom_name_list.end()) {
+	    // skip the HO3' on RNA and DNA. I could instead test for presence/position of next
+	    // residue, but this easier and will be correct for most cases.
+	    if ((rest.residue_info.group == "DNA" || rest.residue_info.group == "RNA") &&
+		H_at_name == "HO3'") {
+	       continue;
+	    } else {
+	       // to which atom is this hydrogen connected?
+	       std::vector<unsigned int> neighbs = rest.neighbours(iat, false);
+	       if (neighbs.size() == 1) {
+		  // what else would it be?
+		  const unsigned int &iat_neighb = neighbs[0];
+		  const std::string &energy_type = rest.atom_info[iat_neighb].type_energy;
+		  if (! energy_type.empty()) {
+		     std::vector<std::string> v =
+			place_hydrogen_by_connected_atom_energy_type(iat, iat_neighb, rest, residue_p);
+		     done_atom_name_list.insert(done_atom_name_list.end(), v.begin(), v.end());
+		  } else {
+		     place_hydrogen_by_connected_2nd_neighbours(iat, iat_neighb, rest, residue_p);
+		  }
+	       }
+	    }
+	 }
+      }
+   }
+
+}
+
+// return a list of placed atoms (sometimes, e.g. NH2) placing one atom means placing two of them
+//
+std::vector<std::string>
+coot::reduce::place_hydrogen_by_connected_atom_energy_type(unsigned int iat,
+							   unsigned int iat_neighb,
+							   const dictionary_residue_restraints_t &rest,
+							   mmdb::Residue *residue_p) {
+
+   std::vector<std::string> v;
+   const std::string &energy_type = rest.atom_info[iat_neighb].type_energy;
+   return place_hydrogen_by_connected_atom_energy_type(energy_type, iat, iat_neighb, rest, residue_p);
+
+}
+
+
+// return a list of placed atoms (sometimes, e.g. NH2) placing one atom means placing two of them
+//
+std::vector<std::string>
+coot::reduce::place_hydrogen_by_connected_atom_energy_type(const std::string &energy_type,
+							   unsigned int iat,
+							   unsigned int iat_neighb,
+							   const dictionary_residue_restraints_t &rest,
+							   mmdb::Residue *residue_p) {
+
+   std::vector<std::string> v;
+   const std::string &H_at_name = rest.atom_info[iat].atom_id_4c;
+   if (false)
+      std::cout << " hydrogen atom " << H_at_name << " in residue type " << rest.residue_info.comp_id
+		<< " by_energy_type: " << energy_type << std::endl;
+   const std::string &first_neighb = rest.atom_info[iat_neighb].atom_id_4c;
+   std::vector<std::string> second_neighb_vec = rest.neighbours(first_neighb, false);
+
+   if (false) {
+      std::cout << " place_hydrogen_by_connected_atom_energy_type second_neighb_vec.size() "
+		<< second_neighb_vec.size() << std::endl;
+      for (unsigned int ii=0; ii<second_neighb_vec.size(); ii++)
+	 std::cout << " place_hydrogen_by_connected_atom_energy_type second_neighb_vec: "
+		   << ii << " " << second_neighb_vec[ii] << std::endl;
+   }
+
+   if (energy_type == "CR16" || energy_type == "CR15") {
+      double bl = 1.08;
+      add_aromatic_hydrogen(H_at_name, first_neighb, second_neighb_vec, bl, residue_p);
+      v.push_back(H_at_name);
+   }
+
+   if (energy_type == "NR15" || energy_type == "NR16") {
+      double bl = 0.86;
+      add_his_ring_H(H_at_name, first_neighb, second_neighb_vec, bl, residue_p);
+      v.push_back(H_at_name);
+   }
+
+   if (energy_type == "NH2" || energy_type == "C2") {
+      double bl_amino = 1.01; // makes refmac mon lib
+      double bl = 0.97;
+      if (energy_type == "NH2") bl = bl_amino;
+      std::string H_at_other = get_other_H_name(first_neighb, H_at_name, rest);
+      if (! H_at_other.empty()) {
+	 std::map<std::string, std::vector<std::string> >
+	    tnm = third_neighbour_map(first_neighb, second_neighb_vec, rest);
+	 add_amino_hydrogens(H_at_name, H_at_other, first_neighb, second_neighb_vec, tnm,
+			     bl, residue_p);
+	 v.push_back(H_at_name);
+	 v.push_back(H_at_other);
+      }
+   }
+
+   if (energy_type == "CH1") {
+      // sp3 carbon with one H atom
+      double bl = 0.97;
+      add_tetrahedral_hydrogen(H_at_name, first_neighb, second_neighb_vec, bl, residue_p);
+      v.push_back(H_at_name);
+   }
+
+   if (energy_type == "CH2") {
+      // sp3 carbon with 2 H atoms
+      double bl = 0.97;
+      std::string H_at_other = get_other_H_name(first_neighb, H_at_name, rest);
+      if (! H_at_other.empty()) {
+	 double angle_between_Hs = 107.0; // we could get this from the dictionary
+	 add_2_sp3_hydrogens(H_at_name, H_at_other, first_neighb, second_neighb_vec,
+			     bl, angle_between_Hs, residue_p);
+	 v.push_back(H_at_name);
+	 v.push_back(H_at_other);
+      }
+   }
+
+   if (energy_type == "NT1") {
+
+      bool choose_only_farthest_position = true; // we find two H positions, choose
+	                                         // the one farthest from the 2nd neighbs.
+
+      // H atom on sp3 nitrogen connected to 2 sp3 carbon atoms, e.g. in piperidine
+      // choose equitorial orientation, not axial.  Which means, build both hydrogen positions
+      // and chose the one that is furthest from the average position of the second neighbours.
+      //
+      double angle_between_Hs = 107.0; // we could get this from the dictionary
+      double bl = 0.86;
+      std::string H_at_other = "Hdum";
+      add_2_sp3_hydrogens(H_at_name, H_at_other, first_neighb, second_neighb_vec,
+			  bl, angle_between_Hs, residue_p, choose_only_farthest_position);
+      v.push_back(H_at_name);
+   }
+
+   if (energy_type == "NT2") {
+      double angle_between_Hs = 107.0; // we could get this from the dictionary
+      double bl = 0.86;
+      std::string H_at_other = get_other_H_name(first_neighb, H_at_name, rest);
+      add_2_sp3_hydrogens(H_at_name, H_at_other, first_neighb, second_neighb_vec,
+			  bl, angle_between_Hs, residue_p);
+      v.push_back(H_at_name);
+      v.push_back(H_at_other);
+   }
+
+   if (energy_type == "OH1") {
+      // needs a spin-search
+      double bl_oh = 0.84;
+      std::map<std::string, std::vector<std::string> > tnm =
+	 third_neighbour_map(first_neighb, second_neighb_vec, rest);
+      add_OH_H(H_at_name, first_neighb, second_neighb_vec, tnm,
+	       bl_oh, 109.5, 180, residue_p);
+      v.push_back(H_at_name);
+   }
+
+   if (energy_type == "SH1") {
+      // needs a spin-search
+      double bl_oh = 1.2; // 1.33 from ener lib.
+      std::map<std::string, std::vector<std::string> > tnm =
+	 third_neighbour_map(first_neighb, second_neighb_vec, rest);
+      add_OH_H(H_at_name, first_neighb, second_neighb_vec, tnm,
+	       bl_oh, 109.5, 180, residue_p);
+      v.push_back(H_at_name);
+   }
+
+   if (energy_type == "CH3" || energy_type == "NT3") {
+      std::vector<std::string> H_other = get_other_H_names(H_at_name, first_neighb, rest);
+      if (H_other.size() == 2) {
+	 std::map<std::string, std::vector<std::string> > tnm =
+	    third_neighbour_map(first_neighb, second_neighb_vec, rest);
+	 double bl = 0.97;
+	 double ang = 109;
+	 double tor = 180;
+	 torsion_info_t tor_info(first_neighb, second_neighb_vec, tnm, bl, ang, tor); // fn reverses order
+	 add_methyl_Hs(H_at_name, H_other[0], H_other[1], tor_info, residue_p);
+	 v.push_back(H_at_name);
+	 v.push_back(H_other[0]);
+	 v.push_back(H_other[1]);
+      }
+   }
+
+   if (energy_type == "NH1") {
+      // e.g. H on the N in an amino acid peptide
+      double bl = 0.86;
+      add_amino_single_H(H_at_name, first_neighb, second_neighb_vec, bl, residue_p);
+      v.push_back(H_at_name);
+   }
+
+   if (energy_type == "C1") {
+      // aldehyde Hydrogen atom
+      if (second_neighb_vec.size() == 2) {
+	 double bl = 0.97;
+	 add_aromatic_hydrogen(H_at_name, second_neighb_vec[0], first_neighb, second_neighb_vec[1],
+			       bl, residue_p);
+	 v.push_back(H_at_name);
+      }
+   }
+
+   if (v.empty()) {
+      std::cout << "FAIL: ------------------------------ " << first_neighb << " "
+		<< energy_type << " for comp_id " << rest.residue_info.comp_id
+		<< std::endl;
+   }
+   return v;
+}
+
+// atoms that are connected to the second neighbour that aren't the first neighbour.
+//
+std::map<std::string, std::vector<std::string> > 
+coot::reduce::third_neighbour_map(const std::string &first_neighb,
+				  const std::vector<std::string> second_neighb_vec,
+				  const coot::dictionary_residue_restraints_t &rest) const {
+
+   std::map<std::string, std::vector<std::string> > m;
+   for (unsigned int i=0; i<second_neighb_vec.size(); i++) {
+      std::vector<std::string> nn = rest.neighbours(second_neighb_vec[i], false);
+      for (unsigned int j=0; j<nn.size(); j++) {
+	 if (nn[j] != first_neighb)
+	    m[second_neighb_vec[i]].push_back(nn[j]);
+      }
+   }
+   return m;
+}
+
+void
+coot::reduce::place_hydrogen_by_connected_2nd_neighbours(unsigned int iat,
+							 unsigned int iat_neighb,
+							 const dictionary_residue_restraints_t &rest,
+							 mmdb::Residue *residue_p) {
+   
+   std::vector<unsigned int> neighbs = rest.neighbours(iat_neighb, false);
+   std::string ele_neighb = rest.atom_info[iat_neighb].type_symbol;
+
+   // something complicated
+   for (unsigned int iat=0; iat<neighbs.size(); iat++) {
+   }
+}
+
+// return a null string on failure.
+//
+std::string
+coot::reduce::get_other_H_name(const std::string &first_neighb,
+			       const std::string &H_at_name,
+			       const dictionary_residue_restraints_t &dict) const {
+
+   return dict.get_other_H_name(H_at_name);
+}
+
+// return a empty vector on failure
+//
+std::vector<std::string>
+coot::reduce::get_other_H_names(const std::string &H_at_name,
+				const std::string &first_neighb,
+				const dictionary_residue_restraints_t &dict) const {
+
+   return dict.get_other_H_names(H_at_name);
+}
diff -ruN coot-0.8.7/coot-utils/reduce.hh coot-0.8.8-pre/coot-utils/reduce.hh
--- coot-0.8.7/coot-utils/reduce.hh	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/coot-utils/reduce.hh	2017-01-25 14:34:21.000000000 -0800
@@ -0,0 +1,292 @@
+
+#ifndef REDUCE_HH
+#define REDUCE_HH
+
+#include "clipper/core/coords.h"
+#include "mmdb2/mmdb_manager.h"
+
+#include "geometry/protein-geometry.hh" // needed to get H-bond types when checking HIS protonatino
+                                        // (and spin searching OHs).
+
+namespace coot {
+
+   class reduce {
+
+      class torsion_info_t {
+      public:
+	 torsion_info_t(const std::string &at_name_1_in, // CA 
+			const std::string &at_name_2_in, // CB
+			const std::string &at_name_3_in, // CG1 (i.e. other way round)
+			double bond_length_in,
+			double angle_deg_in,
+			double torsion_deg_in) {
+	    bond_length = bond_length_in;
+	    at_name_1 = at_name_1_in;
+	    at_name_2 = at_name_2_in;
+	    at_name_3 = at_name_3_in;
+	    angle_deg = angle_deg_in;
+	    torsion_deg = torsion_deg_in;
+	 }
+	 // can throw a std::runtime_error
+	 torsion_info_t(const std::string &first_neighb,
+			const std::vector<std::string> &second_neighb_vec,
+			const std::map<std::string, std::vector<std::string> > &third_neighbour_map,
+			double bl,
+			double angle_in,
+			double torsion_in) {
+	    if (second_neighb_vec.size() > 0) {
+	       std::string second = second_neighb_vec[0];
+	       std::map<std::string, std::vector<std::string> >::const_iterator it;
+	       it = third_neighbour_map.find(second);
+	       if (it != third_neighbour_map.end()) {
+		  std::vector<std::string> thirds = it->second;
+		  if (thirds.size() > 0) {
+		     const std::string &third = thirds[0];
+		     at_name_1 = third;
+		     at_name_2 = second;
+		     at_name_3 = first_neighb;
+		     angle_deg = angle_in;
+		     torsion_deg = torsion_in;
+		     bond_length = bl;
+		  }
+	       }
+	    }
+	 }
+	 std::string at_name_1; // CA (not sure if this atom ordering is sensible)
+	 std::string at_name_2; // CB
+	 std::string at_name_3; // CG1
+	 double bond_length;
+	 double angle_deg;
+	 double torsion_deg;
+      };
+
+      clipper::Coord_orth position_by_bond_length_angle_torsion(mmdb::Atom *at_1,  // CA
+								mmdb::Atom *at_2,  // CB
+								mmdb::Atom *at_3,  // CG
+								double bl,
+								double angle_rad,
+								double torsion_rad) const;
+      clipper::Coord_orth position_by_bisection(mmdb::Atom *at_1, // for Hs on PHE etc
+						mmdb::Atom *at_2,
+						mmdb::Atom *at_3,
+						double bl) const;
+      std::pair<clipper::Coord_orth, clipper::Coord_orth>
+      position_pair_by_bisection(mmdb::Atom *at_1,  // CA
+				 mmdb::Atom *at_2,  // CB
+				 mmdb::Atom *at_3,  // CG
+				 double bl,
+				 double angle_separation // how far apart are the two H atoms?
+				 ) const;
+      clipper::Coord_orth position_by_tetrahedron(mmdb::Atom *at_central,
+						  mmdb::Atom *at_n_1,
+						  mmdb::Atom *at_n_2,
+						  mmdb::Atom *at_n_3,
+						  double bl) const;
+      void add_methyl_Hs(const std::string &at_name_1,
+			 const std::string &at_name_2,
+			 const std::string &at_name_3,
+			 torsion_info_t torsion_1,
+			 mmdb::Residue *residue_p);
+      void add_methyl_Hs(const std::string &at_name_1,
+			 const std::string &at_name_2,
+			 const std::string &at_name_3,
+			 torsion_info_t torsion_1, torsion_info_t torsion_2,
+			 mmdb::Residue *residue_p);
+      void add_2_sp3_hydrogens(const std::string &H_at_name_1,
+			       const std::string &H_at_name_2,
+			       const std::string &at_name_1,
+			       const std::string &at_name_2,
+			       const std::string &at_name_3,
+			       double bond_length,
+			       double angle_between_Hs, // in degrees
+			       mmdb::Residue *residue_p,
+			       bool choose_only_farthest_position=false);
+      void add_2_sp3_hydrogens(const std::string &H_at_name_1,
+			       const std::string &H_at_name_2,
+			       const std::string &first_neighb,
+			       const std::vector<std::string> &second_neighb_vec,
+			       double bond_length,
+			       double angle_between_Hs, // in degrees
+			       mmdb::Residue *residue_p,
+			       bool choose_only_farthest_position=false);
+      void add_tetrahedral_hydrogen(const std::string &H_at_name,
+				    const std::string &central_name,
+				    const std::string &neighb_at_name_1,
+				    const std::string &neighb_at_name_2,
+				    const std::string &neighb_at_name_3,
+				    double bond_length,
+				    mmdb::Residue *residue_p);
+      void add_tetrahedral_hydrogen(const std::string &H_at_name,
+				    const std::string &first_neighb,
+				    const std::vector<std::string> &second_neighb_vec,
+				    double bl, mmdb::Residue *residue_p);
+      
+      void add_aromatic_hydrogen(const std::string &H_at_name,
+				 const std::string &neighb_at_name_1,
+				 const std::string &neighb_at_name_2, // add to this
+				 const std::string &neighb_at_name_3,
+				 double bl, mmdb::Residue *residue_p);
+      void add_amino_hydrogens(const std::string &H_at_name_1,
+			       const std::string &H_at_name_2,
+			       const std::string &at_name_1,
+			       const std::string &at_name_2,
+			       const std::string &at_name_3,
+			       double bl_amino, // angle is 120, torsions are 180 and 0
+			       mmdb::Residue *residue_p);
+      void add_amino_hydrogens(const std::string &H_at_name_1,
+			       const std::string &H_at_name_2,
+			       const std::string &first_neighb,
+			       const std::vector<std::string> &second_neighb_vec,
+			       const std::map<std::string, std::vector<std::string> > &third_neighb_vec,
+			       double bl_amino,
+			       mmdb::Residue *residue_p);
+
+      void add_guanidinium_hydrogens(mmdb::Residue *residue_p);
+      void add_trp_indole_hydrogens(mmdb::Residue *residue_p);
+      void add_trp_indole_hydrogen(const std::string &H_name,
+				   const std::string &at_name_1,
+				   const std::string &at_name_2,
+				   const std::string &at_name_3,
+				   double bl,
+				   mmdb::Residue *residue_p);
+      // this will need a spin-search
+      void add_OH_H(const std::string &H_name,
+		    const std::string &at_name_1,
+		    const std::string &at_name_2,
+		    const std::string &at_name_3,
+		    double bl,
+		    double angle,      // deg
+		    double tor_inital, // deg
+		    mmdb::Residue *residue_p);
+      // this will need a spin-search
+      std::vector<mmdb::Atom *> add_SH_H(const std::string &H_name,
+					 const std::string &at_name_1,
+					 const std::string &at_name_2,
+					 const std::string &at_name_3,
+					 double bl,
+					 double angle,      // deg
+					 double tor_inital, // deg
+					 mmdb::Residue *residue_p);
+      // both of the above wrap this:
+      std::vector<mmdb::Atom *> add_xH_H(const std::string &H_name,
+					 const std::string &at_name_1,
+					 const std::string &at_name_2,
+					 const std::string &at_name_3,
+					 double bl,
+					 double angle,      // deg
+					 double tor_inital, // deg
+					 mmdb::Residue *residue_p);
+
+      void add_OH_H(const std::string &H_at_name,
+		    const std::string &first_neighb,
+		    const std::vector<std::string> &second_neighb_vec,
+		    const std::map<std::string, std::vector<std::string> > &third_neighb_vec,
+		    double bond_length,
+		    double ang_deg,
+		    double torsion_deg,
+		    mmdb::Residue *residue_p);
+      
+      
+      void add_his_ring_C_Hs(mmdb::Residue *residue_p);
+      std::vector<mmdb::Atom *> add_his_ring_H(const std::string &H_name,
+					       const std::string &at_name_1,
+					       const std::string &at_name_2,
+					       const std::string &at_name_3,
+					       double bl,
+					       mmdb::Residue *residue_p);
+
+      void add_his_ring_H(const std::string &H_at_name,
+			  const std::string &first_neigh,
+			  const std::vector<std::string> second_neighb_vec,
+			  double bl,
+			  mmdb::Residue *residue_p);
+
+      void add_aromatic_hydrogen(const std::string &H_at_name,
+				 const std::string &first_neigh,
+				 const std::vector<std::string> second_neighb_vec,
+				 double bl,
+				 mmdb::Residue *residue_p);
+
+      mmdb::Manager *mol;
+      int imol; // for dictionary lookups.
+      protein_geometry *geom_p;
+      void add_riding_hydrogens(); // non-spin-search
+      bool add_riding_hydrogens(mmdb::Residue *residue_p, mmdb::Residue *residue_prev_p);
+      void add_main_chain_hydrogens(mmdb::Residue *residue_p, mmdb::Residue *residue_prev_p,
+				    bool is_gly=false);
+      void add_main_chain_HA(mmdb::Residue *residue_p);
+      void add_main_chain_H(mmdb::Residue *residue_p, mmdb::Residue *residue_prev_p);
+      // like above but for ligands (both second neighbours come from ligand residue)
+      void add_amino_single_H(const std::string &H_at_name,
+			      const std::string &first_neighb,
+			      const std::vector<std::string> &second_neighb_vec,
+			      double bl,
+			      mmdb::Residue *residue_p);
+      // add H to second atom by bisection
+      void add_amino_single_H(const std::string H_at_name,
+			      const std::string &at_name_1,
+			      const std::string &at_name_2,
+			      const std::string &at_name_3,
+			      double bl,
+			      mmdb::Residue *residue_p);
+
+      mmdb::Atom *add_hydrogen_atom(std::string atom_name, clipper::Coord_orth &pos,
+				    mmdb::realtype bf,
+				    const std::string &altconf,
+				    mmdb::Residue *residue_p);
+      // score hypotheses and convert to the best scoring one.
+      void find_best_his_protonation_orientation(mmdb::Residue *residue_p);
+      void delete_atom_by_name(const std::string &at_name, mmdb::Residue *residue_p);
+      void hydrogen_placement_by_dictionary(mmdb::Residue *residue_p);
+      void hydrogen_placement_by_dictionary(const dictionary_residue_restraints_t &rest,
+					    mmdb::Residue *residue_p);
+      // return a list of names of placed atoms
+      std::vector<std::string>
+      place_hydrogen_by_connected_atom_energy_type(unsigned int iat,
+						   unsigned int iat_neighb,
+						   const dictionary_residue_restraints_t &rest,
+						   mmdb::Residue *residue_p);
+      // which calls
+      std::vector<std::string>
+      place_hydrogen_by_connected_atom_energy_type(const std::string &energy_type,
+						   unsigned int iat,
+						   unsigned int iat_neighb,
+						   const dictionary_residue_restraints_t &rest,
+						   mmdb::Residue *residue_p);
+      void place_hydrogen_by_connected_2nd_neighbours(unsigned int iat,
+						      unsigned int iat_neighb,
+						      const dictionary_residue_restraints_t &rest,
+						      mmdb::Residue *residue_p);
+
+      // atoms that are connected to the second neighbour that aren't the first neighbour.
+      //
+      std::map<std::string, std::vector<std::string> > 
+      third_neighbour_map(const std::string &first_neighb,
+			  const std::vector<std::string> second_neighb_vec,
+			  const dictionary_residue_restraints_t &rest) const;
+
+      std::string get_other_H_name(const std::string &first_neighb,
+				   const std::string &H_at_name,
+				   const dictionary_residue_restraints_t &dict) const;
+      std::vector<std::string> get_other_H_names(const std::string &first_neighb,
+						 const std::string &H_at_name,
+						 const dictionary_residue_restraints_t &dict) const;
+
+      bool is_ss_bonded(mmdb::Residue *residue_p) const;
+
+   public:
+      reduce(mmdb::Manager *mol_in, int imol_in) {
+	 mol = mol_in;
+	 imol = imol_in;
+      }
+      void add_hydrogen_atoms(); // changes mol
+      void delete_hydrogen_atoms();
+      void add_geometry(protein_geometry *geom_p_in) { geom_p = geom_p_in; }
+      // change HE2 to HD1 and vice versa
+      void switch_his_protonation(mmdb::Residue *residue_p, mmdb::Atom *current_H_atom);
+      
+   };
+
+}
+
+#endif // REDUCE_HH
diff -ruN coot-0.8.7/coot-utils/test-coot-probe.cc coot-0.8.8-pre/coot-utils/test-coot-probe.cc
--- coot-0.8.7/coot-utils/test-coot-probe.cc	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/coot-utils/test-coot-probe.cc	2017-01-24 09:37:54.000000000 -0800
@@ -0,0 +1,70 @@
+
+#include <stdlib.h>
+#include "atom-overlaps.hh"
+#include "coot-coord-utils.hh"
+#include "geometry/residue-and-atom-specs.hh"
+
+int main(int argc, char **argv) {
+
+   int status = 0;
+   
+   // do we want to probe a ligand or all atoms?
+   mmdb::Residue *residue_p = 0; // set when specified on command line
+
+   if (argc < 2) {
+      std::cout << "Usage: test-coot-probe <filename>" << std::endl;
+      exit(0);
+   } else {
+
+      coot::protein_geometry geom;
+      geom.init_standard();
+      
+      // load all the codes in the input molecule that not already loaded 
+      mmdb::Manager *mol = new mmdb::Manager;
+
+      std::string file_name = argv[1];
+      int read_status = mol->ReadCoorFile(file_name.c_str());
+      coot::residue_spec_t spec;
+
+      if (read_status == mmdb::Error_NoError) {
+
+	 if (! spec.empty()) {
+	    mmdb::Residue *residue_p = coot::util::get_residue(spec, mol);
+	    if (residue_p) {
+	       std::vector<mmdb::Residue *> neighbs = coot::residues_near_residue(residue_p, mol, 5);
+	       try {
+		  coot::atom_overlaps_container_t overlaps(residue_p, neighbs, mol, &geom, 0.5, 0.25);
+		  coot::atom_overlaps_dots_container_t c = overlaps.contact_dots_for_ligand();
+	       }
+	       catch (const std::out_of_range &oor) {
+		  std::cout << "ERROR:: " << oor.what() << std::endl;
+	       }
+	    } else {
+	       std::cout << "Can't find residue" << spec << std::endl;
+	    }
+	 } else {
+	    try {
+
+	       int read_number = 40;
+	       std::vector<std::string> rtv = coot::util::non_standard_residue_types_in_molecule(mol);
+	       for (unsigned int i=0; i<rtv.size(); i++)
+		  if (rtv[i] != "HOH")
+		     geom.try_dynamic_add(rtv[i], read_number++);
+
+	       // spike-length probe-radius
+	       coot::atom_overlaps_container_t overlaps(mol, &geom, 0.5, 0.25);
+	       double dot_density = 0.2;
+	       coot::atom_overlaps_dots_container_t c = overlaps.all_atom_contact_dots(dot_density);
+	    }
+	    catch (const std::out_of_range &oor) {
+	       std::cout << "ERROR:: " << oor.what() << std::endl;
+	    }
+	 }
+      } else {
+	 std::cout << "ERROR:: Failed to read " << file_name << std::endl;
+      }
+   }
+
+   return status;
+
+}
diff -ruN coot-0.8.7/coot-utils/test-utils.cc coot-0.8.8-pre/coot-utils/test-utils.cc
--- coot-0.8.7/coot-utils/test-utils.cc	2016-09-01 17:13:23.000000000 -0700
+++ coot-0.8.8-pre/coot-utils/test-utils.cc	2017-01-24 09:37:54.000000000 -0800
@@ -369,11 +369,17 @@
 int test_atom_overlaps() {
 
    int status = 0;
-   testing_data t;
-   t.geom.try_dynamic_add("MG",  1);
 
-   t.geom.try_dynamic_add("824", 1);
-   // t.geom.init_refmac_mon_lib("824-acedrg.cif", 1);
+
+//    testing_data t;
+//    t.geom.try_dynamic_add("MG",  1);
+//    t.geom.try_dynamic_add("824", 1);
+//    t.geom.init_refmac_mon_lib("824-acedrg.cif", 1);
+
+   coot::protein_geometry geom;
+   geom.init_standard();
+   geom.try_dynamic_add("824", 1);
+   geom.try_dynamic_add("MG", 1);
 
    mmdb::Manager *mol = new mmdb::Manager;
    std::string file_name = "1x8b-H.pdb";
@@ -384,9 +390,9 @@
    if (read_status == mmdb::Error_NoError) {
      mmdb::Residue *residue_p = coot::util::get_residue(spec, mol);
      if (residue_p) {
-       std::vector<mmdb::Residue *> neighbs = coot::residues_near_residue(residue_p, mol, 5);
-       coot::atom_overlaps_container_t overlaps(residue_p, neighbs, mol, &t.geom);
-       overlaps.make_overlaps();
+	std::vector<mmdb::Residue *> neighbs = coot::residues_near_residue(residue_p, mol, 5);
+	coot::atom_overlaps_container_t overlaps(residue_p, neighbs, mol, &geom, 0.5, 0.25);
+	coot::atom_overlaps_dots_container_t c = overlaps.contact_dots_for_ligand();
      } else {
        std::cout << "Can't find residue" << spec << std::endl;
      }
@@ -396,6 +402,56 @@
    return status;
 }
 
+int test_all_atom_overlaps() {
+
+   int status = 0;
+   coot::protein_geometry geom;
+   geom.init_standard();
+   geom.set_verbose(false);
+   geom.try_dynamic_add("824", 1);
+   geom.try_dynamic_add("MG", 1);
+
+   // for 5hcj
+   geom.try_dynamic_add("LMT", 1);
+   geom.try_dynamic_add("MBR", 1);
+   geom.try_dynamic_add("CL", 1);
+   geom.try_dynamic_add("NA", 1);
+   
+
+   mmdb::Manager *mol = new mmdb::Manager;
+   std::string file_name = "1x8b-all-H-no-water.pdb";
+   file_name = "5hcj-with-coot-Hs.pdb";
+   // file_name = "3-atoms.pdb";
+   coot::residue_spec_t spec("A", 901, "");
+
+   int read_status = mol->ReadCoorFile(file_name.c_str());
+
+   if (read_status == mmdb::Error_NoError) {
+      coot::atom_overlaps_container_t overlaps(mol, &geom, 0.5, 0.5);
+      coot::atom_overlaps_dots_container_t c = overlaps.all_atom_contact_dots(0.5);
+   }
+
+   delete mol;
+   return status;
+}
+
+#include "reduce.hh"
+
+int test_reduce() {
+
+   mmdb::Manager *mol = new mmdb::Manager;
+   std::string file_name = "1x8b.pdb";
+   mol->ReadCoorFile(file_name.c_str());
+   // doing this 100 times takes 6s - might be quicker if I don't keep adding Hs
+   // to the same residues :-)
+   int imol = 0; // dummy
+   coot::reduce r(mol, imol);
+   r.add_hydrogen_atoms();
+   mol->WritePDBASCII("reduced.pdb");
+   delete mol;
+   return 1;
+}
+
 
 int main(int argv, char **argc) {
 
@@ -424,8 +480,17 @@
    if (0)
       test_least_squares_fit();
    
-   if (1)
+   if (0)
       test_atom_overlaps();
+
+   
+   if (1)
+      for (unsigned int i=0; i<2; i++) {
+	 test_all_atom_overlaps();
+      }
+   
+   if (0)
+      test_reduce();
    
    return 0;
 }
diff -ruN coot-0.8.7/cootaneer/Makefile.in coot-0.8.8-pre/cootaneer/Makefile.in
--- coot-0.8.7/cootaneer/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/cootaneer/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -61,6 +61,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -233,6 +236,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/cootilus/Makefile.in coot-0.8.8-pre/cootilus/Makefile.in
--- coot-0.8.7/cootilus/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/cootilus/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -61,6 +61,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -234,6 +237,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/data/Makefile.in coot-0.8.8-pre/data/Makefile.in
--- coot-0.8.7/data/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/data/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -58,6 +58,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -193,6 +196,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/db-main/Makefile.in coot-0.8.8-pre/db-main/Makefile.in
--- coot-0.8.7/db-main/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/db-main/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -42,6 +42,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -224,6 +227,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/density-contour/Makefile.in coot-0.8.8-pre/density-contour/Makefile.in
--- coot-0.8.7/density-contour/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/density-contour/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -61,6 +61,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -222,6 +225,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/doc/Makefile.in coot-0.8.8-pre/doc/Makefile.in
--- coot-0.8.7/doc/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/doc/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -40,6 +40,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -153,6 +156,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/geometry/Makefile.am coot-0.8.8-pre/geometry/Makefile.am
--- coot-0.8.7/geometry/Makefile.am	2016-11-01 08:46:49.000000000 -0700
+++ coot-0.8.8-pre/geometry/Makefile.am	2016-12-21 05:34:30.000000000 -0800
@@ -24,7 +24,7 @@
 
 pkginclude_HEADERS =  protein-geometry.hh read-sbase.hh lbg-graph.hh srs-interface.hh \
    dict-utils.hh dict-mismatches.hh energy-lib.hh match-results.hh hb-types.hh main-chain.hh \
-   residue-and-atom-specs.hh
+   residue-and-atom-specs.hh chem_mods.hh
 
 pkgincludedir = $(includedir)/coot/geometry
 
@@ -39,7 +39,7 @@
 
 libcoot_geometry_la_SOURCES = protein-geometry.cc protein-geometry-mmdb.cc \
     read-sbase.cc energy-lib.cc   \
-    chem_mods.cc srs-interface.cc \
+    chem_mods.cc srs-interface.cc protein-donor-acceptors.cc protein-donor-acceptors.hh \
     lbg-graph.cc  dreiding.cc dict-utils.cc cif-parse.cc main-chain.cc residue-and-atom-specs.cc
 
 libcoot_geometry_la_LIBADD = \
diff -ruN coot-0.8.7/geometry/Makefile.in coot-0.8.8-pre/geometry/Makefile.in
--- coot-0.8.7/geometry/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/geometry/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -68,6 +68,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -132,9 +135,9 @@
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
 am_libcoot_geometry_la_OBJECTS = protein-geometry.lo \
 	protein-geometry-mmdb.lo read-sbase.lo energy-lib.lo \
-	chem_mods.lo srs-interface.lo lbg-graph.lo dreiding.lo \
-	dict-utils.lo cif-parse.lo main-chain.lo \
-	residue-and-atom-specs.lo
+	chem_mods.lo srs-interface.lo protein-donor-acceptors.lo \
+	lbg-graph.lo dreiding.lo dict-utils.lo cif-parse.lo \
+	main-chain.lo residue-and-atom-specs.lo
 libcoot_geometry_la_OBJECTS = $(am_libcoot_geometry_la_OBJECTS)
 libcoot_geometry_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
@@ -282,6 +285,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -414,7 +418,7 @@
 EXTRA_DIST = notes Makefile.simple
 pkginclude_HEADERS = protein-geometry.hh read-sbase.hh lbg-graph.hh srs-interface.hh \
    dict-utils.hh dict-mismatches.hh energy-lib.hh match-results.hh hb-types.hh main-chain.hh \
-   residue-and-atom-specs.hh
+   residue-and-atom-specs.hh chem_mods.hh
 
 AM_CPPFLAGS = -I$(top_srcdir) \
 	 $(CLIPPER_CXXFLAGS) $(CCP4SRS_CXXFLAGS) $(MMDB_CXXFLAGS)
@@ -426,7 +430,7 @@
 
 libcoot_geometry_la_SOURCES = protein-geometry.cc protein-geometry-mmdb.cc \
     read-sbase.cc energy-lib.cc   \
-    chem_mods.cc srs-interface.cc \
+    chem_mods.cc srs-interface.cc protein-donor-acceptors.cc protein-donor-acceptors.hh \
     lbg-graph.cc  dreiding.cc dict-utils.cc cif-parse.cc main-chain.cc residue-and-atom-specs.cc
 
 libcoot_geometry_la_LIBADD = \
@@ -607,6 +611,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lbg-graph.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/main-chain.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/make-shelx-restraints.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/protein-donor-acceptors.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/protein-geometry-mmdb.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/protein-geometry.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/read-sbase.Plo@am__quote@
diff -ruN coot-0.8.7/geometry/chem_mods.cc coot-0.8.8-pre/geometry/chem_mods.cc
--- coot-0.8.7/geometry/chem_mods.cc	2015-08-26 04:54:02.000000000 -0700
+++ coot-0.8.8-pre/geometry/chem_mods.cc	2016-12-27 13:13:20.000000000 -0800
@@ -115,10 +115,10 @@
 std::ostream&
 coot::operator<<(std::ostream &s, const coot::chem_mod_plane &a) {
 
-   s << "[chem_mod_plane "
+   s << "[chem_mod_plane function="
      << a.function << " "
      << a.plane_id << " ";
-
+   s << " n_atoms=" << a.atom_id_esd.size();
    for (unsigned int i=0; i<a.atom_id_esd.size(); i++)
       s << "  " << a.atom_id_esd[i].first << " "
 	<< a.atom_id_esd[i].second;
@@ -593,8 +593,10 @@
       ierr_tot += ierr;
 
       if (ierr_tot == 0 || function == "delete") {
-	 coot::chem_mod_plane plane(plane_id, function);
-	 mods[mod_id][plane].add_atom(atom_id_mmdb_expand(atom_id), new_dist_esd);
+	 // coot::chem_mod_plane plane(plane_id, function);
+	 // mods[mod_id][plane].add_atom(atom_id_mmdb_expand(atom_id), new_dist_esd);
+	 std::string atom_name = atom_id_mmdb_expand(atom_id);
+	 mods[mod_id].add_plane_atom(plane_id, function, atom_name, new_dist_esd);
       } else {
 	 std::cout << "oops in add_chem_mod_plane ierr_tot is "
 		   << ierr_tot << std::endl;
@@ -604,7 +606,7 @@
 
 // can throw a std::runtime_error
 // 
-std::pair<coot::protein_geometry::chem_mod, coot::protein_geometry::chem_mod>
+std::pair<coot::chem_mod, coot::chem_mod>
 coot::protein_geometry::get_chem_mods_for_link(const std::string &link_id) const {
 
    bool found = false; 
diff -ruN coot-0.8.7/geometry/chem_mods.hh coot-0.8.8-pre/geometry/chem_mods.hh
--- coot-0.8.7/geometry/chem_mods.hh	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/geometry/chem_mods.hh	2016-12-27 13:13:20.000000000 -0800
@@ -0,0 +1,359 @@
+
+   // ------------------------------------------------------------------------
+   //                  chem_mods
+   // ------------------------------------------------------------------------
+
+namespace coot {
+
+   // a container for the data_mod_list chem_mods (used to be simply
+   // chem_mod, but that name is now used as a class that contains the
+   // actual chem mods (with lists of atoms, bonds, angles and so on).
+   // 
+   class list_chem_mod {
+   public:
+      std::string name;
+      std::string id;
+      std::string group_id;
+      std::string comp_id;
+      list_chem_mod(const std::string &id_in,
+		    const std::string &name_in,
+		    const std::string &comp_id_in,
+		    const std::string &group_id_in) {
+	 id = id_in;
+	 name = name_in;
+	 comp_id = comp_id_in;
+	 group_id = group_id_in;
+      } 
+      friend std::ostream& operator<<(std::ostream &s, list_chem_mod mod);
+   };
+   std::ostream& operator<<(std::ostream &s, list_chem_mod mod);
+
+   enum chem_mod_function_t { CHEM_MOD_FUNCTION_UNSET,
+			      CHEM_MOD_FUNCTION_ADD,
+			      CHEM_MOD_FUNCTION_CHANGE,
+			      CHEM_MOD_FUNCTION_DELETE };
+   
+   class chem_mod_atom {
+   public:
+      chem_mod_atom(const std::string &function_in,
+		    const std::string &atom_id_in,
+		    const std::string &new_atom_id_in,
+		    const std::string &new_type_symbol_in,
+		    const std::string &new_type_energy_in,
+		    mmdb::realtype new_partial_charge_in) {
+	 function = CHEM_MOD_FUNCTION_UNSET;
+	 if (function_in == "add")
+	    function = CHEM_MOD_FUNCTION_ADD;
+	 if (function_in == "delete")
+	    function = CHEM_MOD_FUNCTION_DELETE;
+	 if (function_in == "change")
+	    function = CHEM_MOD_FUNCTION_CHANGE;
+	 atom_id = atom_id_in;
+	 new_atom_id = new_atom_id_in;
+	 new_type_symbol = new_type_symbol_in;
+	 new_type_energy = new_type_energy_in;
+	 new_partial_charge = new_partial_charge_in;
+      }
+      chem_mod_function_t function;
+      std::string atom_id;
+      std::string new_atom_id;
+      std::string new_type_symbol;
+      std::string new_type_energy;
+      mmdb::realtype new_partial_charge;
+      friend std::ostream& operator<<(std::ostream &s, const chem_mod_atom &a);
+   };
+   std::ostream& operator<<(std::ostream &s, const chem_mod_atom &a);
+
+   class chem_mod_tree {
+      chem_mod_function_t function;
+      std::string atom_id;
+      std::string atom_back;
+      std::string back_type;
+      std::string atom_forward;
+      std::string connect_type;
+   public:
+      chem_mod_tree (const std::string &function_in,
+		     const std::string &atom_id_in,
+		     const std::string &atom_back_in,
+		     const std::string &back_type_in,
+		     const std::string &atom_forward_in,
+		     const std::string &connect_type_in) {
+	 function = CHEM_MOD_FUNCTION_UNSET;
+	 if (function_in == "add")
+	    function = CHEM_MOD_FUNCTION_ADD;
+	 if (function_in == "delete")
+	    function = CHEM_MOD_FUNCTION_DELETE;
+	 if (function_in == "change")
+	    function = CHEM_MOD_FUNCTION_CHANGE;
+	 atom_id = atom_id_in;
+	 atom_back = atom_back_in;
+	 back_type = back_type_in;
+	 atom_forward = atom_forward_in;
+	 connect_type = connect_type_in;
+      }
+      friend std::ostream& operator<<(std::ostream &s, const chem_mod_tree &a);
+   };
+   std::ostream& operator<<(std::ostream &s, const chem_mod_tree &a);
+
+   class chem_mod_bond {
+   public:
+      chem_mod_bond(const std::string &function_in,
+		    const std::string &atom_id_1_in,
+		    const std::string &atom_id_2_in,
+		    const std::string &new_type_in,
+		    mmdb::realtype new_value_dist_in,
+		    mmdb::realtype new_value_dist_esd_in) {
+	 function = CHEM_MOD_FUNCTION_UNSET;
+	 if (function_in == "add")
+	    function = CHEM_MOD_FUNCTION_ADD;
+	 if (function_in == "delete")
+	    function = CHEM_MOD_FUNCTION_DELETE;
+	 if (function_in == "change")
+	    function = CHEM_MOD_FUNCTION_CHANGE;
+	 atom_id_1 = atom_id_1_in;
+	 atom_id_2 = atom_id_2_in;
+	 new_type = new_type_in;
+	 new_value_dist = new_value_dist_in;
+	 new_value_dist_esd = new_value_dist_esd_in;
+      }
+      chem_mod_function_t function;
+      std::string atom_id_1;
+      std::string atom_id_2;
+      std::string new_type;
+      mmdb::realtype new_value_dist;
+      mmdb::realtype new_value_dist_esd;
+      friend std::ostream& operator<<(std::ostream &s, const chem_mod_bond &a);
+   };
+   std::ostream& operator<<(std::ostream &s, const chem_mod_bond &a);
+
+   class chem_mod_angle {
+   public:
+      chem_mod_angle(const std::string &function_in,
+		     const std::string &atom_id_1_in,
+		     const std::string &atom_id_2_in,
+		     const std::string &atom_id_3_in,
+		     mmdb::realtype new_value_angle_in,
+		     mmdb::realtype new_value_angle_esd_in) {
+	 function = CHEM_MOD_FUNCTION_UNSET;
+	 if (function_in == "add")
+	    function = CHEM_MOD_FUNCTION_ADD;
+	 if (function_in == "delete")
+	    function = CHEM_MOD_FUNCTION_DELETE;
+	 if (function_in == "change")
+	    function = CHEM_MOD_FUNCTION_CHANGE;
+	 atom_id_1 = atom_id_1_in;
+	 atom_id_2 = atom_id_2_in;
+	 atom_id_3 = atom_id_3_in;
+	 new_value_angle = new_value_angle_in;
+	 new_value_angle_esd = new_value_angle_esd_in;
+      }
+      chem_mod_function_t function;
+      std::string atom_id_1;
+      std::string atom_id_2;
+      std::string atom_id_3;
+      std::string new_type;
+      mmdb::realtype new_value_angle;
+      mmdb::realtype new_value_angle_esd;
+      friend std::ostream& operator<<(std::ostream &s, const chem_mod_angle &a);
+   };
+   std::ostream& operator<<(std::ostream &s, const chem_mod_angle &a);
+
+   class chem_mod_tor {
+   public:
+      chem_mod_tor(const std::string &function_in,
+		   const std::string &atom_id_1_in,
+		   const std::string &atom_id_2_in,
+		   const std::string &atom_id_3_in,
+		   const std::string &atom_id_4_in,
+		   mmdb::realtype new_value_angle_in,
+		   mmdb::realtype new_value_angle_esd_in,
+		   int new_period_in) {
+	 function = CHEM_MOD_FUNCTION_UNSET;
+	 if (function_in == "add")
+	    function = CHEM_MOD_FUNCTION_ADD;
+	 if (function_in == "delete")
+	    function = CHEM_MOD_FUNCTION_DELETE;
+	 if (function_in == "change")
+	    function = CHEM_MOD_FUNCTION_CHANGE;
+	 atom_id_1 = atom_id_1_in;
+	 atom_id_2 = atom_id_2_in;
+	 atom_id_3 = atom_id_3_in;
+	 atom_id_4 = atom_id_4_in;
+	 new_value_angle = new_value_angle_in;
+	 new_value_angle_esd = new_value_angle_esd_in;
+	 new_period = new_period_in;
+      }
+      chem_mod_function_t function;
+      std::string atom_id_1;
+      std::string atom_id_2;
+      std::string atom_id_3;
+      std::string atom_id_4;
+      std::string new_type;
+      mmdb::realtype new_value_angle;
+      mmdb::realtype new_value_angle_esd;
+      int new_period;
+      friend std::ostream& operator<<(std::ostream &s, const chem_mod_tor &a);
+   };
+   std::ostream& operator<<(std::ostream &s, const chem_mod_tor &a);
+
+   class chem_mod_plane {
+   public:
+      chem_mod_plane(const std::string &plane_id_in,
+		     const std::string &function_in) {
+	 function = CHEM_MOD_FUNCTION_UNSET;
+	 if (function_in == "add")
+	    function = CHEM_MOD_FUNCTION_ADD;
+	 if (function_in == "delete")
+	    function = CHEM_MOD_FUNCTION_DELETE;
+	 if (function_in == "change")
+	    function = CHEM_MOD_FUNCTION_CHANGE;
+	 plane_id = plane_id_in;
+      }
+      chem_mod_function_t function;
+      std::string plane_id;
+      std::vector<std::pair<std::string, mmdb::realtype> > atom_id_esd;
+      void add_atom(const std::string &atom_id, mmdb::realtype esd) {
+	 std::pair<std::string, mmdb::realtype> p(atom_id, esd);
+	 atom_id_esd.push_back(p);
+      }
+      friend std::ostream& operator<<(std::ostream &s, const chem_mod_plane &a);
+   };
+   std::ostream& operator<<(std::ostream &s, const chem_mod_plane &a);
+
+   class chem_mod_chir {
+   public:
+      chem_mod_chir(const std::string &function_in,
+		    const std::string &atom_id_centre_in,
+		    const std::string &atom_id_1_in,
+		    const std::string &atom_id_2_in,
+		    const std::string &atom_id_3_in,
+		    int new_volume_sign_in) {
+	 function = CHEM_MOD_FUNCTION_UNSET;
+	 if (function_in == "add")
+	    function = CHEM_MOD_FUNCTION_ADD;
+	 if (function_in == "delete")
+	    function = CHEM_MOD_FUNCTION_DELETE;
+	 if (function_in == "change")
+	    function = CHEM_MOD_FUNCTION_CHANGE;
+	 atom_id_centre = atom_id_centre_in;
+	 atom_id_1 = atom_id_1_in;
+	 atom_id_2 = atom_id_2_in;
+	 atom_id_3 = atom_id_3_in;
+	 new_volume_sign = new_volume_sign_in;
+      }
+      chem_mod_function_t function;
+      std::string atom_id_centre;
+      std::string atom_id_1;
+      std::string atom_id_2;
+      std::string atom_id_3;
+      int new_volume_sign;
+      friend std::ostream& operator<<(std::ostream &s, const chem_mod_chir &a);
+   };
+   std::ostream& operator<<(std::ostream &s, const chem_mod_chir &a);
+
+
+
+
+      class chem_mod {
+
+      public:
+	 chem_mod() {};
+	 std::vector<chem_mod_atom>  atom_mods;
+	 std::vector<chem_mod_tree>  tree_mods;
+	 std::vector<chem_mod_bond>  bond_mods;
+	 std::vector<chem_mod_angle> angle_mods;
+	 std::vector<chem_mod_tor>   tor_mods;
+	 std::vector<chem_mod_plane> plane_mods;
+	 std::vector<chem_mod_chir>  chir_mods;
+	 void add_mod_atom(const chem_mod_atom &chem_atom) {
+	    atom_mods.push_back(chem_atom);
+	 }
+	 void add_mod_tree(const chem_mod_tree &chem_tree) {
+	    tree_mods.push_back(chem_tree);
+	 }
+	 void add_mod_bond(const chem_mod_bond &chem_bond) {
+	    bond_mods.push_back(chem_bond);
+	 }
+	 void add_mod_angle(const chem_mod_angle &chem_angle) {
+	    angle_mods.push_back(chem_angle);
+	 }
+	 void add_mod_tor(const chem_mod_tor &chem_tor) {
+	    tor_mods.push_back(chem_tor);
+	 }
+	 void add_mod_plane(const chem_mod_plane &chem_plane) {
+	    plane_mods.push_back(chem_plane);
+	 }
+	 void add_mod_chir(const chem_mod_chir &chem_chir) {
+	    chir_mods.push_back(chem_chir);
+	 }
+	 void add_plane_atom(const std::string &plane_id,
+			     const std::string &function,
+			     const std::string &atom_name,
+			     double dist) {
+	    bool done = false;
+	    for (unsigned int iplane=0; iplane<plane_mods.size(); iplane++) {
+	       if (plane_mods[iplane].plane_id == plane_id) {
+		  chem_mod_function_t cmft = CHEM_MOD_FUNCTION_UNSET;
+		  if (function == "add")    cmft = CHEM_MOD_FUNCTION_ADD;
+		  if (function == "change") cmft = CHEM_MOD_FUNCTION_CHANGE;
+		  if (function == "delete") cmft = CHEM_MOD_FUNCTION_DELETE;
+		  if (plane_mods[iplane].function == cmft) {
+		     plane_mods[iplane].add_atom(atom_name, dist);
+		     done = true;
+		     break;
+		  }
+	       }
+	    }
+	    if (! done) {
+	       chem_mod_plane cmpl(plane_id, function);
+	       cmpl.add_atom(atom_name, dist);
+	       plane_mods.push_back(cmpl);
+	    }
+	 }
+	 friend std::ostream& operator<<(std::ostream &s, chem_mod mod);
+      };
+   std::ostream& operator<<(std::ostream &s, chem_mod mod);
+
+
+      class min_chem_mod {
+
+      public:
+	 min_chem_mod() {};
+//	 std::vector<chem_mod_atom>  atom_mods;
+// 	 std::vector<chem_mod_tree>  tree_mods;
+// 	 std::vector<chem_mod_bond>  bond_mods;
+// 	 std::vector<chem_mod_angle> angle_mods;
+// 	 std::vector<chem_mod_tor>   tor_mods;
+// 	 std::vector<chem_mod_plane> plane_mods;
+// 	 std::vector<chem_mod_chir>  chir_mods;
+	 void add_mod_atom(const chem_mod_atom &chem_atom) {
+	    // atom_mods.push_back(chem_atom);
+	 }
+	 void add_mod_tree(const chem_mod_tree &chem_tree) {
+	    // tree_mods.push_back(chem_tree);
+	 }
+	 void add_mod_bond(const chem_mod_bond &chem_bond) {
+	    // bond_mods.push_back(chem_bond);
+	 }
+	 void add_mod_angle(const chem_mod_angle &chem_angle) {
+	    // angle_mods.push_back(chem_angle);
+	 }
+	 void add_mod_tor(const chem_mod_tor &chem_tor) {
+	    // tor_mods.push_back(chem_tor);
+	 }
+	 void add_mod_plane(const chem_mod_plane &chem_plane) {
+	    // plane_mods.push_back(chem_plane);
+	 }
+	 void add_mod_chir(const chem_mod_chir &chem_chir) {
+	    // chir_mods.push_back(chem_chir);
+	 }
+	 void add_plane_atom(const std::string &plane_id,
+			     const std::string &function,
+			     const std::string &atom_name,
+			     double dist) {
+	 }
+	 friend std::ostream& operator<<(std::ostream &s, min_chem_mod mod);
+      };
+   std::ostream& operator<<(std::ostream &s, min_chem_mod mod);
+
+}
diff -ruN coot-0.8.7/geometry/cif-parse.cc coot-0.8.8-pre/geometry/cif-parse.cc
--- coot-0.8.7/geometry/cif-parse.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/geometry/cif-parse.cc	2016-12-21 05:34:30.000000000 -0800
@@ -1387,7 +1387,9 @@
 	    if (ierr_optional_x == 0)
 	       if (ierr_optional_y == 0)
 		  if (ierr_optional_z == 0) {
-		     model_Cartn = std::pair<bool, clipper::Coord_orth>(true, clipper::Coord_orth(x,y,z));
+		     // model_Cartn = std::pair<bool, clipper::Coord_orth>(true, clipper::Coord_orth(x,y,z));
+		     model_Cartn.first = true;
+		     model_Cartn.second = clipper::Coord_orth(x,y,z);
 		     if (close_float_p(x, 0.0))
 			if (close_float_p(z, 0.0))
 			   if (close_float_p(z, 0.0))
@@ -1432,22 +1434,15 @@
 			 << pdbx_model_Cartn_ideal.second.format()
 			 << std::endl;
 
-	    // mon_lib_add_atom(comp_id, atom_id, padded_name, type_symbol, type_energy,
-	    // partial_charge, formal_charge, aromaticity,
-	    // model_Cartn, pdbx_model_Cartn_ideal);
-
 	    dict_atom atom_info(atom_id, padded_name, type_symbol, type_energy, partial_charge);
 
-	    // add formal_charge, aromaticity,
-	    
 	    if (model_Cartn.first)
 	       atom_info.add_pos(dict_atom::REAL_MODEL_POS, model_Cartn);
-	    
 	    if (pdbx_model_Cartn_ideal.first)
 	       atom_info.add_pos(dict_atom::IDEAL_MODEL_POS, pdbx_model_Cartn_ideal);
 
-	    atom_info.formal_charge = formal_charge;
-	    atom_info.aromaticity = aromaticity;
+	    atom_info.formal_charge      = formal_charge;
+	    atom_info.aromaticity        = aromaticity;
 	    atom_info.pdbx_stereo_config = pdbx_stereo_config_flag;
 
 	    mon_lib_add_atom(comp_id, imol_enc, atom_info);
diff -ruN coot-0.8.7/geometry/main-chain.cc coot-0.8.8-pre/geometry/main-chain.cc
--- coot-0.8.7/geometry/main-chain.cc	2016-09-09 09:43:24.000000000 -0700
+++ coot-0.8.8-pre/geometry/main-chain.cc	2016-12-21 05:34:30.000000000 -0800
@@ -1,6 +1,9 @@
 
 #include "main-chain.hh"
 
+
+// PDBv3 FIXME
+
 bool
 coot::is_main_chain_p(mmdb::Atom *at) { 
 
@@ -13,6 +16,23 @@
        mol_atom_name == " O  ") {
       return 1;
    } else {
+      std::string res_name = at->GetResName();
+      if (res_name == "GLY") {
+	 if (mol_atom_name == " HA2" ||
+	     mol_atom_name == " HA3") {
+	    return 1;
+	 }
+	 
+	 // Perhaps N-terminal H atom?
+	 mmdb::Residue *res = at->residue;
+	 if (res) {
+	    if (res->isNTerminus()) {
+	       if (mol_atom_name == " H1 ") return true;
+	       if (mol_atom_name == " H2 ") return true;
+	       if (mol_atom_name == " H3 ") return true;
+	    }
+	 }
+      }
       return 0;
    } 
 }
diff -ruN coot-0.8.7/geometry/protein-donor-acceptors.cc coot-0.8.8-pre/geometry/protein-donor-acceptors.cc
--- coot-0.8.7/geometry/protein-donor-acceptors.cc	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/geometry/protein-donor-acceptors.cc	2016-11-14 23:14:01.000000000 -0800
@@ -0,0 +1,125 @@
+
+#include <iostream>
+
+#include "protein-donor-acceptors.hh"
+
+void
+coot::quick_protein_donor_acceptors::init() {
+
+   std::pair<std::string, std::string> p;
+
+   // PDBv3 FIXME
+   hb_type_map[key("CYS", " SG ")] = HB_ACCEPTOR;
+   hb_type_map[key("ASP", " OD1")] = HB_ACCEPTOR;
+   hb_type_map[key("ASP", " OD2")] = HB_ACCEPTOR;
+   hb_type_map[key("GLU", " OE1")] = HB_ACCEPTOR;
+   hb_type_map[key("GLU", " OE2")] = HB_ACCEPTOR;
+   hb_type_map[key("HIS", " ND1")] = HB_BOTH;
+   hb_type_map[key("HIS", " NE2")] = HB_BOTH;
+   hb_type_map[key("LYS", " NZ ")] = HB_DONOR;
+   hb_type_map[key("MET", " SD ")] = HB_ACCEPTOR;
+   hb_type_map[key("ASN", " OD1")] = HB_ACCEPTOR;
+   hb_type_map[key("ASN", " ND2")] = HB_DONOR;
+   hb_type_map[key("GLN", " OE1")] = HB_ACCEPTOR;
+   hb_type_map[key("GLN", " NE2")] = HB_DONOR;
+   hb_type_map[key("ARG", " NE ")] = HB_DONOR;
+   hb_type_map[key("ARG", " NH1")] = HB_DONOR;
+   hb_type_map[key("ARG", " NH2")] = HB_DONOR;
+   hb_type_map[key("SER", " OG ")] = HB_BOTH;
+   hb_type_map[key("THR", " OG ")] = HB_BOTH;
+   hb_type_map[key("TRP", " NE1")] = HB_DONOR;
+   hb_type_map[key("TYR", " OH ")] = HB_BOTH;
+
+   const char *l[] = {"ALA", "CYS", "ASP", "GLU", "PHE", "GLY", "HIS", "ILE", "LYS", "LEU",
+		      "MET", "MSE", "ASN", "PRO", "GLN", "ARG", "SER", "TYR", "VAL", "TRP",
+		      "TYR" };
+   unsigned int n_res_types = 21;
+
+   for (unsigned int i=0; i<n_res_types; i++) {
+      key pn(l[i], " N  ");
+      key po(l[i], " O  ");
+      hb_type_map[pn] = HB_DONOR;
+      hb_type_map[po] = HB_ACCEPTOR;
+   }
+
+}
+
+coot::hb_t
+coot::quick_protein_donor_acceptors::get_type(const key &k) const {
+
+   hb_t r = HB_UNASSIGNED;
+
+   std::map<key, hb_t>::const_iterator it = hb_type_map.find(k);
+
+   if (it != hb_type_map.end()) {
+      r = it->second;
+   }
+
+   return r;
+}
+
+// first: did we find an answer (ie. both were protein residues?)
+// second: was it a potential hydrogen bond (had the correct atom types?"
+//
+std::pair<bool, bool>
+coot::quick_protein_donor_acceptors::is_hydrogen_bond_by_types(const std::pair<key, key> &hbtp) const {
+
+   bool found = false;
+   bool r = false;
+   const key &key_1 = hbtp.first;
+   const key &key_2 = hbtp.second;
+   hb_t type_1 = get_type(key_1);
+   if (type_1 == HB_BOTH || type_1 == HB_ACCEPTOR || type_1 == HB_DONOR) {
+      hb_t type_2 = get_type(key_2);
+      if (type_2 == HB_BOTH || type_2 == HB_ACCEPTOR || type_2 == HB_DONOR) {
+	 found = true;
+	 if (type_1 == HB_BOTH || type_1 == HB_ACCEPTOR)
+	    if (type_2 == HB_BOTH || type_2 == HB_DONOR)
+	       r = true;
+	 if (type_1 == HB_BOTH || type_1 == HB_DONOR)
+	    if (type_2 == HB_BOTH || type_2 == HB_ACCEPTOR)
+	       r = true;
+      } else {
+	 if (type_2 == HB_NEITHER)
+	    found = true;
+      }
+   } else {
+      hb_t type_2 = get_type(key_2);
+      if (type_1 != HB_UNASSIGNED)
+	 if (type_2 != HB_UNASSIGNED)
+	    found = true;
+   }
+
+   return std::pair<bool, bool> (found, r);
+}
+
+std::vector<std::pair<bool, bool> >
+coot::quick_protein_donor_acceptors::is_hydrogen_bond_by_types(std::vector<std::pair<key, key> > &hbtp) const {
+
+   std::vector<std::pair<bool, bool> > v(hbtp.size());
+   for (unsigned int i=0; i<hbtp.size(); i++)
+      v[i] = is_hydrogen_bond_by_types(hbtp[i]);
+   return v;
+}
+
+
+
+void
+coot::quick_protein_donor_acceptors::test() const {
+   
+   hb_t r;
+
+   if (false) {
+      std::cout << "ref: HB_UNASSIGNED " << HB_UNASSIGNED << std::endl;
+      std::cout << "ref: HB_NEITHER " << HB_NEITHER << std::endl;
+      std::cout << "ref: HB_DONOR " << HB_DONOR << std::endl;
+      std::cout << "ref: HB_ACCEPTOR " << HB_ACCEPTOR << std::endl;
+      std::cout << "ref: HB_HYDROGEN " << HB_HYDROGEN << std::endl;
+   }
+
+   bool r1 = (is_hydrogen_bond_by_types(std::pair<key,key>(key("ALA", " CB "), key("SER", " OG "))).second == false);
+   bool r2 = (is_hydrogen_bond_by_types(std::pair<key,key>(key("ALA", " N  "), key("SER", " OG "))).second == true);
+   bool r3 = (is_hydrogen_bond_by_types(std::pair<key,key>(key("TYR", " N  "), key("TRP", " NE1"))).second == false);
+
+   std::cout << r1 << " " << r2 << " " << r3 << std::endl;
+}
diff -ruN coot-0.8.7/geometry/protein-donor-acceptors.hh coot-0.8.8-pre/geometry/protein-donor-acceptors.hh
--- coot-0.8.7/geometry/protein-donor-acceptors.hh	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/geometry/protein-donor-acceptors.hh	2016-11-14 23:14:01.000000000 -0800
@@ -0,0 +1,51 @@
+
+#ifndef PROTEIN_DONOR_ACCEPTORS_HH
+#define PROTEIN_DONOR_ACCEPTORS_HH
+
+#include <string>
+#include <vector>
+#include <map>
+#include "hb-types.hh"
+
+namespace coot {
+
+   class quick_protein_donor_acceptors {
+      void init();
+   public:
+
+      class key {
+      public:
+	 std::string res_name;
+	 std::string atom_name;
+	 key(const std::string &r, const std::string &a) {
+	    res_name = r;
+	    atom_name = a;
+	 }
+	 // this one is less than the key_in?
+	 bool operator<(const key &key_in) const {
+	    if (res_name < key_in.res_name) {
+	       return true;
+	    } else {
+	       if (res_name > key_in.res_name) {
+		  return false;
+	       } else {
+		  return atom_name < key_in.atom_name;
+	       }
+	    }
+	 }
+      };
+      std::map<key, hb_t> hb_type_map;
+      quick_protein_donor_acceptors() { init(); }
+      hb_t get_type(const key &k) const;
+      void test() const;
+      std::pair<bool, bool> is_hydrogen_bond_by_types(const std::pair<key,key> &hbtp) const;
+      std::pair<bool, bool> is_hydrogen_bond_by_types(const key &k1, const key &k2) const {
+	 std::pair<key,key> kp(k1,k2);
+	 return is_hydrogen_bond_by_types(kp);
+      }
+      std::vector<std::pair<bool, bool> > is_hydrogen_bond_by_types(std::vector<std::pair<key, key> > &hbtps) const;
+   };
+
+}
+
+#endif // PROTEIN_DONOR_ACCEPTORS_HH
diff -ruN coot-0.8.7/geometry/protein-geometry.cc coot-0.8.8-pre/geometry/protein-geometry.cc
--- coot-0.8.7/geometry/protein-geometry.cc	2016-11-01 08:46:49.000000000 -0700
+++ coot-0.8.8-pre/geometry/protein-geometry.cc	2016-12-21 05:34:30.000000000 -0800
@@ -931,14 +931,23 @@
    return r;
 }
 
-// likewise look up the energy type.  Return "" on no atom fould
+// likewise look up the energy type.  Return "" on no atom found
 // with that atom_name.
 // 
 std::string
 coot::dictionary_residue_restraints_t::type_energy(const std::string &atom_name) const {
 
    std::string r = "";
+
+   // If you are reading this, then you are looking in a dictionary looked up from an index
+   // that is out of bounds.
+   // 
+   // std::cout << "dictionary_has " << atom_info.size() << " atoms" << std::endl;
+   
    for (unsigned int iat=0; iat<atom_info.size(); iat++) {
+      if (false)
+	 std::cout << "comparing :" << atom_name << ": with :" << atom_info[iat].atom_id_4c
+		   << ":" << std::endl;
       if (atom_info[iat].atom_id_4c == atom_name) { // PDBv3 FIXME
 	 r = atom_info[iat].type_energy;
 	 break;
@@ -964,7 +973,45 @@
       }
    }
    return n;
-} 
+}
+
+std::vector<unsigned int>
+coot::dictionary_residue_restraints_t::neighbours(unsigned int idx, bool allow_hydrogen_neighbours_flag) const {
+
+   std::vector<unsigned int> v;
+   std::string atom_name = atom_info[idx].atom_id_4c;
+   for (unsigned int i=0; i<bond_restraint.size(); i++) { 
+      if (bond_restraint[i].atom_id_1() == atom_name) {
+	 const std::string &other_atom_name = bond_restraint[i].atom_id_2();
+	 if (allow_hydrogen_neighbours_flag || ! is_hydrogen(other_atom_name)) {
+	    // what is the index of atom_id_2?  - bleugh.  This shows
+	    // that the dictionary store should work with atom indices, not
+	    // atom names (i.e. do it like RDKit does it).
+	    for (unsigned int iat=0; iat<atom_info.size(); iat++) {
+	       if (atom_info[iat].atom_id_4c == other_atom_name) {
+		  v.push_back(iat);
+		  break;
+	       }
+	    }
+	 }
+      }
+      if (bond_restraint[i].atom_id_2() == atom_name) {
+	 const std::string &other_atom_name = bond_restraint[i].atom_id_1();
+	 if (allow_hydrogen_neighbours_flag || ! is_hydrogen(other_atom_name)) {
+	    // what is the index of atom_id_2?  - bleugh.  This shows
+	    // that the dictionary store should work with atom indices, not
+	    // atom names (i.e. do it like RDKit does it).
+	    for (unsigned int iat=0; iat<atom_info.size(); iat++) {
+	       if (atom_info[iat].atom_id_4c == other_atom_name) {
+		  v.push_back(iat);
+		  break;
+	       }
+	    }
+	 }
+      }
+   }
+   return v;
+}
 
 
 
@@ -990,6 +1037,88 @@
 }
 
 
+// return an empty string on failure
+std::string
+coot::dictionary_residue_restraints_t::get_other_H_name(const std::string &H_at_name) const {
+
+   std::string r;
+
+   // if it's a hydrogen atom name as input then the neighbour of that won't be
+   // a hydrogen
+   //
+   std::vector<std::string> neighbs = neighbours(H_at_name, false);
+
+   if (neighbs.size() == 1) {
+      const std::string &n = neighbs[0];
+      for (unsigned int i=0; i<bond_restraint.size(); i++) {
+	 if (bond_restraint[i].atom_id_1() == n) {
+	    if (bond_restraint[i].atom_id_2() != H_at_name) {
+	       if (false)
+		  std::cout << "here 1 with br " << bond_restraint[i] << " ele :"
+			    << element(bond_restraint[i].atom_id_2_4c()) << ":" << std::endl;
+	       if (element(bond_restraint[i].atom_id_2_4c()) == " H") {
+		  r = bond_restraint[i].atom_id_2_4c();
+		  break;
+	       }
+	    }
+	 }
+	 if (bond_restraint[i].atom_id_2() == n) {
+	    if (bond_restraint[i].atom_id_1() != H_at_name) {
+	       if (false)
+		  std::cout << "here 2 with br " << bond_restraint[i] << " ele :"
+			    << element(bond_restraint[i].atom_id_1_4c()) << ":" << std::endl;
+	       if (element(bond_restraint[i].atom_id_1_4c()) == " H") {
+		  r = bond_restraint[i].atom_id_1_4c();
+		  break;
+	       }
+	    }
+	 }
+      }
+   }
+   return r;
+}
+
+// return an empty vector on failure
+std::vector<std::string>
+coot::dictionary_residue_restraints_t::get_other_H_names(const std::string &H_at_name) const {
+
+   std::vector<std::string> v;
+
+   // if it's a hydrogen atom name as input then the neighbour of that won't be
+   // a hydrogen
+   //
+   std::vector<std::string> neighbs = neighbours(H_at_name, false);
+
+   if (neighbs.size() == 1) {
+      const std::string &n = neighbs[0];
+      for (unsigned int i=0; i<bond_restraint.size(); i++) {
+	 if (bond_restraint[i].atom_id_1() == n) {
+	    if (bond_restraint[i].atom_id_2() != H_at_name) {
+	       if (false)
+		  std::cout << "here 1 with br " << bond_restraint[i] << " ele :"
+			    << element(bond_restraint[i].atom_id_2_4c()) << ":" << std::endl;
+	       if (element(bond_restraint[i].atom_id_2_4c()) == " H") {
+		  v.push_back(bond_restraint[i].atom_id_2_4c());
+	       }
+	    }
+	 }
+	 if (bond_restraint[i].atom_id_2() == n) {
+	    if (bond_restraint[i].atom_id_1() != H_at_name) {
+	       if (false)
+		  std::cout << "here 2 with br " << bond_restraint[i] << " ele :"
+			    << element(bond_restraint[i].atom_id_1_4c()) << ":" << std::endl;
+	       if (element(bond_restraint[i].atom_id_1_4c()) == " H") {
+		  v.push_back(bond_restraint[i].atom_id_1_4c());
+	       }
+	    }
+	 }
+      }
+   }
+   return v;
+}
+
+
+
 
 void 
 coot::protein_geometry::add_restraint(std::string comp_id,
@@ -2906,6 +3035,17 @@
 }
 
 bool
+coot::dict_atom::is_hydrogen() const {
+
+   bool r = false;
+   if (type_symbol == "H" ||
+       type_symbol == " H" ||
+       type_symbol == "D")
+      r = true;
+   return r;
+}
+
+bool
 coot::dictionary_residue_restraints_t::is_hydrogen(unsigned int idx) const {
 
    bool r = false;
@@ -3805,6 +3945,8 @@
       model_p->AddChain(chain_p);
       mol = new mmdb::Manager;
       mol->AddModel(model_p);
+   } else {
+      std::cout << "WARNING:: Null residue in mol_from_dictionary() for " << three_letter_code << std::endl;
    }
    return mol;
 }
@@ -3895,7 +4037,7 @@
 	 flag_and_have_coords = true;
       }
 
-      if (! flag_and_have_coords) { 
+      if (! flag_and_have_coords) {
 	 // OK, try model_Cartn (and that is idealised if the dictionary was refmac)
 	 // (better than nothing).
 	 // 
@@ -3986,6 +4128,28 @@
    return match;
 }
 
+bool
+coot::dictionary_residue_restraints_t::in_same_ring(const std::string &atom_name_1, const std::string &atom_name_2,
+						    const std::vector<std::vector<std::string> > &ring_list) const {
+
+   bool match = false;
+
+   for (unsigned int i=0; i<ring_list.size(); i++) {
+      unsigned int n_match = 0;
+      for (unsigned int j=0; j<ring_list[i].size(); j++) {
+	 if (ring_list[i][j] == atom_name_1)
+	    n_match++;
+	 if (ring_list[i][j] == atom_name_2)
+	    n_match++;
+      }
+      if (n_match == 2) {
+	 match = true;
+	 break;
+      }
+   }
+   return match;
+}
+
 
 
 bool
diff -ruN coot-0.8.7/geometry/protein-geometry.hh coot-0.8.8-pre/geometry/protein-geometry.hh
--- coot-0.8.7/geometry/protein-geometry.hh	2016-11-01 08:46:49.000000000 -0700
+++ coot-0.8.8-pre/geometry/protein-geometry.hh	2016-12-21 05:34:30.000000000 -0800
@@ -46,6 +46,8 @@
 #endif
 #endif
 
+#include "chem_mods.hh"
+
 #include "match-results.hh"
 
 #include "energy-lib.hh"
@@ -504,6 +506,7 @@
       }
       dict_atom() {}; // for resize(0);
       void add_pos(int pos_type, const std::pair<bool, clipper::Coord_orth> &model_pos_ideal);
+      bool is_hydrogen() const;
       friend std::ostream& operator<<(std::ostream &s, const dict_atom &at);
    };
    std::ostream& operator<<(std::ostream &s, const dict_atom &at);
@@ -697,8 +700,16 @@
       // return null on failure
       mmdb::Residue *GetResidue(bool idealize_flag, float b_factor) const;
 
+      // This is very slow if you call it a number of times.
+      // Better to extract the ring info with get_ligand_ring_list()
+      // and test for atom_name_1 and atom_name_2 using that.
       bool in_same_ring(const std::string &atom_name_1, const std::string &atom_name_2) const;
 
+      // Here for convenience, but it doesn't rely on class functions or data items
+      // (could/should be static?)
+      bool in_same_ring(const std::string &atom_name_1, const std::string &atom_name_2,
+			const std::vector<std::vector<std::string> > &ring_list) const;
+
       bool ligand_has_aromatic_bonds_p() const;
 
       std::vector<std::vector<std::string> > get_ligand_aromatic_ring_list() const;
@@ -708,6 +719,10 @@
       bool is_bond_order_data_only() const { return filled_with_bond_order_data_only_flag; }
 
       std::vector<std::string> neighbours(const std::string &atom_name, bool allow_hydrogen_neighbours_flag) const;
+      // same thing with indexing into the atom_info vector.  No protection
+      // for out of bounds atom_idx value (i.e. atom_idx must be valid).
+      std::vector<unsigned int> neighbours(unsigned atom_idx,
+					   bool allow_hydrogen_neighbours_flag) const;
 
       // return "" on not found
       std::string get_bond_type(const std::string &name_1, const std::string &name_2) const;
@@ -773,6 +788,11 @@
       bool is_connected_to_donor(const std::string &H_at_name_4c,
 				 const energy_lib_t &energy_lib) const;
 
+      // return an empty string on failure
+      std::string get_other_H_name(const std::string &H_at_name) const;
+      // return an empty vector on failure
+      std::vector<std::string> get_other_H_names(const std::string &H_at_name) const;
+
       friend std::ostream& operator<<(std::ostream &s, const dictionary_residue_restraints_t &rest);
 
 #ifdef HAVE_CCP4SRS
@@ -1035,258 +1055,6 @@
    };
    std::ostream& operator<<(std::ostream &s, chem_link lnk);
 
-   // ------------------------------------------------------------------------
-   //                  chem_mods
-   // ------------------------------------------------------------------------
-   
-   // a container for the data_mod_list chem_mods (used to be simply
-   // chem_mod, but that name is now used as a class that contains the
-   // actual chem mods (with lists of atoms, bonds, angles and so on).
-   // 
-   class list_chem_mod {
-   public:
-      std::string name;
-      std::string id;
-      std::string group_id;
-      std::string comp_id;
-      list_chem_mod(const std::string &id_in,
-		    const std::string &name_in,
-		    const std::string &comp_id_in,
-		    const std::string &group_id_in) {
-	 id = id_in;
-	 name = name_in;
-	 comp_id = comp_id_in;
-	 group_id = group_id_in;
-      } 
-      friend std::ostream& operator<<(std::ostream &s, list_chem_mod mod);
-   };
-   std::ostream& operator<<(std::ostream &s, list_chem_mod mod);
-
-   enum chem_mod_function_t { CHEM_MOD_FUNCTION_UNSET,
-			      CHEM_MOD_FUNCTION_ADD,
-			      CHEM_MOD_FUNCTION_CHANGE,
-			      CHEM_MOD_FUNCTION_DELETE };
-   
-   class chem_mod_atom {
-   public:
-      chem_mod_atom(const std::string &function_in,
-		    const std::string &atom_id_in,
-		    const std::string &new_atom_id_in,
-		    const std::string &new_type_symbol_in,
-		    const std::string &new_type_energy_in,
-		    mmdb::realtype new_partial_charge_in) {
-	 function = CHEM_MOD_FUNCTION_UNSET;
-	 if (function_in == "add")
-	    function = CHEM_MOD_FUNCTION_ADD;
-	 if (function_in == "delete")
-	    function = CHEM_MOD_FUNCTION_DELETE;
-	 if (function_in == "change")
-	    function = CHEM_MOD_FUNCTION_CHANGE;
-	 atom_id = atom_id_in;
-	 new_atom_id = new_atom_id_in;
-	 new_type_symbol = new_type_symbol_in;
-	 new_type_energy = new_type_energy_in;
-	 new_partial_charge = new_partial_charge_in;
-      }
-      chem_mod_function_t function;
-      std::string atom_id;
-      std::string new_atom_id;
-      std::string new_type_symbol;
-      std::string new_type_energy;
-      mmdb::realtype new_partial_charge;
-      friend std::ostream& operator<<(std::ostream &s, const chem_mod_atom &a);
-   };
-   std::ostream& operator<<(std::ostream &s, const chem_mod_atom &a);
-
-   class chem_mod_tree {
-      chem_mod_function_t function;
-      std::string atom_id;
-      std::string atom_back;
-      std::string back_type;
-      std::string atom_forward;
-      std::string connect_type;
-   public:
-      chem_mod_tree (const std::string &function_in,
-		     const std::string &atom_id_in,
-		     const std::string &atom_back_in,
-		     const std::string &back_type_in,
-		     const std::string &atom_forward_in,
-		     const std::string &connect_type_in) {
-	 function = CHEM_MOD_FUNCTION_UNSET;
-	 if (function_in == "add")
-	    function = CHEM_MOD_FUNCTION_ADD;
-	 if (function_in == "delete")
-	    function = CHEM_MOD_FUNCTION_DELETE;
-	 if (function_in == "change")
-	    function = CHEM_MOD_FUNCTION_CHANGE;
-	 atom_id = atom_id_in;
-	 atom_back = atom_back_in;
-	 back_type = back_type_in;
-	 atom_forward = atom_forward_in;
-	 connect_type = connect_type_in;
-      }
-      friend std::ostream& operator<<(std::ostream &s, const chem_mod_tree &a);
-   };
-   std::ostream& operator<<(std::ostream &s, const chem_mod_tree &a);
-
-   class chem_mod_bond {
-   public:
-      chem_mod_bond(const std::string &function_in,
-		    const std::string &atom_id_1_in,
-		    const std::string &atom_id_2_in,
-		    const std::string &new_type_in,
-		    mmdb::realtype new_value_dist_in,
-		    mmdb::realtype new_value_dist_esd_in) {
-	 function = CHEM_MOD_FUNCTION_UNSET;
-	 if (function_in == "add")
-	    function = CHEM_MOD_FUNCTION_ADD;
-	 if (function_in == "delete")
-	    function = CHEM_MOD_FUNCTION_DELETE;
-	 if (function_in == "change")
-	    function = CHEM_MOD_FUNCTION_CHANGE;
-	 atom_id_1 = atom_id_1_in;
-	 atom_id_2 = atom_id_2_in;
-	 new_type = new_type_in;
-	 new_value_dist = new_value_dist_in;
-	 new_value_dist_esd = new_value_dist_esd_in;
-      }
-      chem_mod_function_t function;
-      std::string atom_id_1;
-      std::string atom_id_2;
-      std::string new_type;
-      mmdb::realtype new_value_dist;
-      mmdb::realtype new_value_dist_esd;
-      friend std::ostream& operator<<(std::ostream &s, const chem_mod_bond &a);
-   };
-   std::ostream& operator<<(std::ostream &s, const chem_mod_bond &a);
-
-   class chem_mod_angle {
-   public:
-      chem_mod_angle(const std::string &function_in,
-		     const std::string &atom_id_1_in,
-		     const std::string &atom_id_2_in,
-		     const std::string &atom_id_3_in,
-		     mmdb::realtype new_value_angle_in,
-		     mmdb::realtype new_value_angle_esd_in) {
-	 function = CHEM_MOD_FUNCTION_UNSET;
-	 if (function_in == "add")
-	    function = CHEM_MOD_FUNCTION_ADD;
-	 if (function_in == "delete")
-	    function = CHEM_MOD_FUNCTION_DELETE;
-	 if (function_in == "change")
-	    function = CHEM_MOD_FUNCTION_CHANGE;
-	 atom_id_1 = atom_id_1_in;
-	 atom_id_2 = atom_id_2_in;
-	 atom_id_3 = atom_id_3_in;
-	 new_value_angle = new_value_angle_in;
-	 new_value_angle_esd = new_value_angle_esd_in;
-      }
-      chem_mod_function_t function;
-      std::string atom_id_1;
-      std::string atom_id_2;
-      std::string atom_id_3;
-      std::string new_type;
-      mmdb::realtype new_value_angle;
-      mmdb::realtype new_value_angle_esd;
-      friend std::ostream& operator<<(std::ostream &s, const chem_mod_angle &a);
-   };
-   std::ostream& operator<<(std::ostream &s, const chem_mod_angle &a);
-
-   class chem_mod_tor {
-   public:
-      chem_mod_tor(const std::string &function_in,
-		   const std::string &atom_id_1_in,
-		   const std::string &atom_id_2_in,
-		   const std::string &atom_id_3_in,
-		   const std::string &atom_id_4_in,
-		   mmdb::realtype new_value_angle_in,
-		   mmdb::realtype new_value_angle_esd_in,
-		   int new_period_in) {
-	 function = CHEM_MOD_FUNCTION_UNSET;
-	 if (function_in == "add")
-	    function = CHEM_MOD_FUNCTION_ADD;
-	 if (function_in == "delete")
-	    function = CHEM_MOD_FUNCTION_DELETE;
-	 if (function_in == "change")
-	    function = CHEM_MOD_FUNCTION_CHANGE;
-	 atom_id_1 = atom_id_1_in;
-	 atom_id_2 = atom_id_2_in;
-	 atom_id_3 = atom_id_3_in;
-	 atom_id_4 = atom_id_4_in;
-	 new_value_angle = new_value_angle_in;
-	 new_value_angle_esd = new_value_angle_esd_in;
-	 new_period = new_period_in;
-      }
-      chem_mod_function_t function;
-      std::string atom_id_1;
-      std::string atom_id_2;
-      std::string atom_id_3;
-      std::string atom_id_4;
-      std::string new_type;
-      mmdb::realtype new_value_angle;
-      mmdb::realtype new_value_angle_esd;
-      int new_period;
-      friend std::ostream& operator<<(std::ostream &s, const chem_mod_tor &a);
-   };
-   std::ostream& operator<<(std::ostream &s, const chem_mod_tor &a);
-
-   class chem_mod_plane {
-   public:
-      chem_mod_plane(const std::string &plane_id_in,
-		     const std::string &function_in) {
-	 function = CHEM_MOD_FUNCTION_UNSET;
-	 if (function_in == "add")
-	    function = CHEM_MOD_FUNCTION_ADD;
-	 if (function_in == "delete")
-	    function = CHEM_MOD_FUNCTION_DELETE;
-	 if (function_in == "change")
-	    function = CHEM_MOD_FUNCTION_CHANGE;
-	 plane_id = plane_id_in;
-      }
-      chem_mod_function_t function;
-      std::string plane_id;
-      std::vector<std::pair<std::string, mmdb::realtype> > atom_id_esd;
-      void add_atom(const std::string &atom_id, mmdb::realtype esd) {
-	 std::pair<std::string, mmdb::realtype> p(atom_id, esd);
-	 atom_id_esd.push_back(p);
-      }
-      friend std::ostream& operator<<(std::ostream &s, const chem_mod_plane &a);
-   };
-   std::ostream& operator<<(std::ostream &s, const chem_mod_plane &a);
-
-   class chem_mod_chir {
-   public:
-      chem_mod_chir(const std::string &function_in,
-		    const std::string &atom_id_centre_in,
-		    const std::string &atom_id_1_in,
-		    const std::string &atom_id_2_in,
-		    const std::string &atom_id_3_in,
-		    int new_volume_sign_in) {
-	 function = CHEM_MOD_FUNCTION_UNSET;
-	 if (function_in == "add")
-	    function = CHEM_MOD_FUNCTION_ADD;
-	 if (function_in == "delete")
-	    function = CHEM_MOD_FUNCTION_DELETE;
-	 if (function_in == "change")
-	    function = CHEM_MOD_FUNCTION_CHANGE;
-	 atom_id_centre = atom_id_centre_in;
-	 atom_id_1 = atom_id_1_in;
-	 atom_id_2 = atom_id_2_in;
-	 atom_id_3 = atom_id_3_in;
-	 new_volume_sign = new_volume_sign_in;
-      }
-      chem_mod_function_t function;
-      std::string atom_id_centre;
-      std::string atom_id_1;
-      std::string atom_id_2;
-      std::string atom_id_3;
-      int new_volume_sign;
-      friend std::ostream& operator<<(std::ostream &s, const chem_mod_chir &a);
-   };
-   std::ostream& operator<<(std::ostream &s, const chem_mod_chir &a);
-
-   
-
 
    // ---------------------------------------------------------------
    // helper classes for linkage selection
@@ -1712,51 +1480,6 @@
       // and fills these chem mod classes, simple container class
       // indexed with map on the mod_id
 
-
-      class chem_mod {
-
-      public:
-	 chem_mod() {};
-	 std::vector<chem_mod_atom>  atom_mods;
-	 std::vector<chem_mod_tree>  tree_mods;
-	 std::vector<chem_mod_bond>  bond_mods;
-	 std::vector<chem_mod_angle> angle_mods;
-	 std::vector<chem_mod_tor>   tor_mods;
-	 std::vector<chem_mod_plane> plane_mods;
-	 std::vector<chem_mod_chir>  chir_mods;
-	 void add_mod_atom(const chem_mod_atom &chem_atom) {
-	    atom_mods.push_back(chem_atom);
-	 }
-	 void add_mod_tree(const chem_mod_tree &chem_tree) {
-	    tree_mods.push_back(chem_tree);
-	 }
-	 void add_mod_bond(const chem_mod_bond &chem_bond) {
-	    bond_mods.push_back(chem_bond);
-	 }
-	 void add_mod_angle(const chem_mod_angle &chem_angle) {
-	    angle_mods.push_back(chem_angle);
-	 }
-	 void add_mod_tor(const chem_mod_tor &chem_tor) {
-	    tor_mods.push_back(chem_tor);
-	 }
-	 void add_mod_plane(const chem_mod_plane &chem_plane) {
-	    plane_mods.push_back(chem_plane);
-	 }
-	 void add_mod_chir(const chem_mod_chir &chem_chir) {
-	    chir_mods.push_back(chem_chir);
-	 }
-	 chem_mod_plane &operator[](const chem_mod_plane &plane) {
-	    for (unsigned int iplane=0; iplane<plane_mods.size(); iplane++) {
-	       if (plane_mods[iplane].plane_id == plane.plane_id) {
-		  return plane_mods[iplane];
-	       }
-	    }
-	    plane_mods.push_back(plane);
-	    return plane_mods.back();
-	 }
-      };
-      
-      
       std::map<std::string, chem_mod> mods;
       // can throw an std::runtime exception if there is no chem mod
       // for the link_id (and that's fine)
diff -ruN coot-0.8.7/geometry/residue-and-atom-specs.hh coot-0.8.8-pre/geometry/residue-and-atom-specs.hh
--- coot-0.8.7/geometry/residue-and-atom-specs.hh	2016-11-01 08:46:49.000000000 -0700
+++ coot-0.8.8-pre/geometry/residue-and-atom-specs.hh	2016-12-21 05:34:30.000000000 -0800
@@ -138,6 +138,9 @@
 	 }
 	 return r;
       }
+      bool operator !=(const atom_spec_t &matcher) const {
+	 return ! operator==(matcher);
+      }
 #endif 
 
 #ifndef SWIG
@@ -260,6 +263,9 @@
 	    u = false;
 	 return u;
       }
+      bool empty() const {
+	 return unset_p();
+      }
       residue_spec_t next() const {
 	 residue_spec_t r = *this;
 	 if (res_no != mmdb::MinInt4)
diff -ruN coot-0.8.7/geometry/test-geometry.cc coot-0.8.8-pre/geometry/test-geometry.cc
--- coot-0.8.7/geometry/test-geometry.cc	2016-09-01 17:13:23.000000000 -0700
+++ coot-0.8.8-pre/geometry/test-geometry.cc	2016-11-14 23:14:01.000000000 -0800
@@ -29,6 +29,7 @@
 #include <iostream>
 
 #include "protein-geometry.hh"
+#include "protein-donor-acceptors.hh"
 
 std::vector <std::string> protein_monomers();
 
@@ -62,7 +63,7 @@
 }
 
 int
-main(int argc, char **argv) {
+ccp4_setup(int argc, char **argv) {
  
    std::string filename;
    int read_number = 1;
@@ -119,3 +120,20 @@
    return 0; 
 }
 
+void
+test_quick_hbs() {
+
+   coot::quick_protein_donor_acceptors qpda;
+   qpda.test();
+
+}
+
+
+int main(int argc, char **argv) {
+
+   // ccp4_setup(argc, argv);
+
+   test_quick_hbs();
+
+   return 0;
+}
diff -ruN coot-0.8.7/goograph/Makefile.in coot-0.8.8-pre/goograph/Makefile.in
--- coot-0.8.7/goograph/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/goograph/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -61,6 +61,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -235,6 +238,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/greg-tests/Makefile.in coot-0.8.8-pre/greg-tests/Makefile.in
--- coot-0.8.7/greg-tests/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/greg-tests/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -39,6 +39,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -151,6 +154,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/high-res/Makefile.in coot-0.8.8-pre/high-res/Makefile.in
--- coot-0.8.7/high-res/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/high-res/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -62,6 +62,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -233,6 +236,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/ideal/Makefile.in coot-0.8.8-pre/ideal/Makefile.in
--- coot-0.8.7/ideal/Makefile.in	2016-11-08 07:55:22.000000000 -0800
+++ coot-0.8.8-pre/ideal/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -68,6 +68,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -300,6 +303,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/ideal/mods.cc coot-0.8.8-pre/ideal/mods.cc
--- coot-0.8.7/ideal/mods.cc	2016-09-01 17:13:23.000000000 -0700
+++ coot-0.8.8-pre/ideal/mods.cc	2016-12-27 13:13:20.000000000 -0800
@@ -51,8 +51,8 @@
 	 apply_mod("COO", geom, idr, residue_p);
       }
    }
-   return mod_counts;
 
+   return mod_counts;
 }
 
 void
@@ -64,27 +64,26 @@
    // We crash here when linked with CCP4srs, geom.mods has been corrupted.
    //
    if (false) {
-      std::map<std::string, coot::protein_geometry::chem_mod>::const_iterator iit;
-      std::cout << "------ Here are the current mods: " << geom.mods.size() << std::endl;
+      std::map<std::string, coot::chem_mod>::const_iterator iit;
       for (iit=geom.mods.begin(); iit!=geom.mods.end(); iit++) 
 	 std::cout << "  " << iit->first << std::endl;
    }
 
-   std::map<std::string, coot::protein_geometry::chem_mod>::const_iterator it = 
-      geom.mods.find(mod_name);
+   std::map<std::string, coot::chem_mod>::const_iterator it = geom.mods.find(mod_name);
 
    if (it != geom.mods.end()) {
-      for (unsigned int i=0; i<it->second.bond_mods.size(); i++) { 
+
+      for (unsigned int i=0; i<it->second.bond_mods.size(); i++) {
 	 apply_mod_bond(it->second.bond_mods[i], residue_p);
       }
-      for (unsigned int i=0; i<it->second.angle_mods.size(); i++) { 
+      for (unsigned int i=0; i<it->second.angle_mods.size(); i++) {
 	 apply_mod_angle(it->second.angle_mods[i], residue_p);
       }
-      for (unsigned int i=0; i<it->second.plane_mods.size(); i++) { 
+      for (unsigned int i=0; i<it->second.plane_mods.size(); i++) {
 	 apply_mod_plane(it->second.plane_mods[i], residue_p);
       }
    } else {
-      std::cout << "mod name \"" << mod_name << "\" not found in dictionary "
+      std::cout << "WARNING:: mod name \"" << mod_name << "\" not found in dictionary "
 		<< std::endl;
    } 
 }
@@ -366,9 +365,9 @@
    residue_p->GetAtomTable(residue_atoms, n_residue_atoms);
    
    std::map<std::string, std::vector <int> > pos; // we worry about alt confs.
-   
+
    for (unsigned int i=0; i<mod_plane.atom_id_esd.size(); i++) {
-      for (int iat=0; iat<n_residue_atoms; iat++) { 
+      for (int iat=0; iat<n_residue_atoms; iat++) {
 	 std::string atom_name(residue_atoms[iat]->name);
 	 if (atom_name == mod_plane.atom_id_esd[i].first) {
 	    int atom_index;
@@ -383,7 +382,7 @@
    std::map<std::string, std::vector <int> >::const_iterator it;
    for (it=pos.begin(); it!=pos.end(); it++) {
       const std::vector<int> &position_indices = it->second;
-   
+
       if (position_indices.size() > 3) {
 	 double esd = 0.02;
 
@@ -393,7 +392,7 @@
 	 
 	 std::vector<bool> fixed_flags = make_fixed_flags(position_indices);
 	 add_plane(position_sigma_indices, fixed_flags);
-	 if (0) { 
+	 if (false) {
 	    std::cout << "DEBUG:: mod_plane_add() adding plane\n";
 	    for (unsigned int i=0; i<position_indices.size(); i++)
 	       std::cout << "   " << coot::atom_spec_t(atom[position_indices[i]]) << "\n";
diff -ruN coot-0.8.7/ideal/pepflip.cc coot-0.8.8-pre/ideal/pepflip.cc
--- coot-0.8.7/ideal/pepflip.cc	2016-09-01 17:13:23.000000000 -0700
+++ coot-0.8.8-pre/ideal/pepflip.cc	2017-01-23 10:30:04.000000000 -0800
@@ -184,7 +184,7 @@
 	 clipper::Coord_orth p1(ca_at->x, ca_at->y, ca_at->z);
 	 clipper::Coord_orth p2(c_at->x,   c_at->y,  c_at->z);
 	 clipper::Coord_orth p3(o_at->x,   o_at->y,  o_at->z);
-	 clipper::Coord_orth p3_new = util::rotate_round_vector(p2-p1, p3, p1, M_PI);
+	 clipper::Coord_orth p3_new = util::rotate_around_vector(p2-p1, p3, p1, M_PI);
 	 o_at->x = p3_new.x();
 	 o_at->y = p3_new.y();
 	 o_at->z = p3_new.z();
diff -ruN coot-0.8.7/lbg/Makefile.in coot-0.8.8-pre/lbg/Makefile.in
--- coot-0.8.7/lbg/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/lbg/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -66,6 +66,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -270,6 +273,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/lbg/fetch.py coot-0.8.8-pre/lbg/fetch.py
--- coot-0.8.7/lbg/fetch.py	2016-09-16 05:53:12.000000000 -0700
+++ coot-0.8.8-pre/lbg/fetch.py	2017-01-23 10:30:04.000000000 -0800
@@ -113,7 +113,7 @@
     try_chemspider = False # usually not needed
     if "DrugBank" in db_dict:
        try:
-          db_mol_uri = "http://www.drugbank.ca/structures/structures/small_molecule_drugs/" + \
+          db_mol_uri = "https://www.drugbank.ca/structures/small_molecule_drugs/" + \
                        db_dict["DrugBank"] + ".mol"
           file_name = db_dict["DrugBank"] + ".mol"
           fetch_it = True
diff -ruN coot-0.8.7/lbg/flev-annotations.hh coot-0.8.8-pre/lbg/flev-annotations.hh
--- coot-0.8.7/lbg/flev-annotations.hh	2016-09-09 09:43:24.000000000 -0700
+++ coot-0.8.8-pre/lbg/flev-annotations.hh	2017-01-25 14:34:21.000000000 -0800
@@ -192,24 +192,29 @@
 	 mmdb::Atom *ligand_atom = at_donor;
 	 mmdb::Atom *residue_atom = at_acceptor;
 
-	 if (! ligand_atom_is_donor_flag)
-	    std::swap(ligand_atom, residue_atom);
+	 if (at_donor) {
+	    if (at_acceptor) {
 
-	 if (is_a_metal(residue_atom->residue)) {
-	    r_bond_type = METAL_CONTACT_BOND;
-	 } else { 
-
-	    if (ligand_atom_is_donor_flag) { 
-	       if (coot::is_main_chain_p(residue_atom))
-		  r_bond_type = H_BOND_ACCEPTOR_MAINCHAIN;
-	       else
-		  r_bond_type = H_BOND_ACCEPTOR_SIDECHAIN;
+	       if (! ligand_atom_is_donor_flag)
+		  std::swap(ligand_atom, residue_atom);
+
+	       if (is_a_metal(residue_atom->residue)) {
+		  r_bond_type = METAL_CONTACT_BOND;
+	       } else { 
+
+		  if (ligand_atom_is_donor_flag) { 
+		     if (coot::is_main_chain_p(residue_atom))
+			r_bond_type = H_BOND_ACCEPTOR_MAINCHAIN;
+		     else
+			r_bond_type = H_BOND_ACCEPTOR_SIDECHAIN;
 	       
-	    } else {
-	       if (coot::is_main_chain_p(residue_atom))
-		  r_bond_type = H_BOND_DONOR_MAINCHAIN;
-	       else
-		  r_bond_type = H_BOND_DONOR_SIDECHAIN;
+		  } else {
+		     if (coot::is_main_chain_p(residue_atom))
+			r_bond_type = H_BOND_DONOR_MAINCHAIN;
+		     else
+			r_bond_type = H_BOND_DONOR_SIDECHAIN;
+		  }
+	       }
 	    }
 	 }
 	 return r_bond_type;
diff -ruN coot-0.8.7/lbg/lbg-flev.cc coot-0.8.8-pre/lbg/lbg-flev.cc
--- coot-0.8.7/lbg/lbg-flev.cc	2016-11-01 11:08:05.000000000 -0700
+++ coot-0.8.8-pre/lbg/lbg-flev.cc	2017-01-10 02:55:38.000000000 -0800
@@ -253,6 +253,30 @@
    }
 }
 
+// top left and bottom right corners.
+//
+std::pair<lig_build::pos_t, lig_build::pos_t>
+lbg_info_t::flev_residues_extents() const {
+
+   std::pair<lig_build::pos_t, lig_build::pos_t> p; // defaults with (-1, -1) for coordinates
+   if (draw_flev_annotations_flag) {
+      lig_build::pos_t ligand_centre = mol.get_ligand_centre();
+      GooCanvasItem *root = goo_canvas_get_root_item (GOO_CANVAS(canvas));
+      if (residue_circles.size()) {
+	 p.first  = lig_build::pos_t( 9999, 9999);
+	 p.second = lig_build::pos_t(-9999, -9999);
+	 for (unsigned int i=0; i<residue_circles.size(); i++) {
+	    const lig_build::pos_t &pos = residue_circles[i].pos;
+	    if (pos.x < p.first.x) p.first.x = pos.x;
+	    if (pos.y < p.first.y) p.first.y = pos.y;
+	    if (pos.x > p.second.x) p.second.x = pos.x;
+	    if (pos.y > p.second.y) p.second.y = pos.y;
+	 }
+      }
+   }
+   return p;
+}
+
 void
 lbg_info_t::draw_all_flev_ligand_annotations() {
 
diff -ruN coot-0.8.7/lbg/lbg.cc coot-0.8.8-pre/lbg/lbg.cc
--- coot-0.8.7/lbg/lbg.cc	2016-11-08 01:46:24.000000000 -0800
+++ coot-0.8.8-pre/lbg/lbg.cc	2017-01-13 09:52:22.000000000 -0800
@@ -3710,6 +3710,11 @@
    int re_index[mol_in.atoms.size()]; // map from mol_in atom indexing
 				      // the this molecule atom
 				      // indexing.
+
+   if (false)
+      std::cout << "import_from_widgeted_molecule with " << mol_in.atoms.size()
+		<< " atoms" << std::endl;
+
    for (unsigned int i=0; i<mol_in.atoms.size(); i++)
       re_index[i] = UNASSIGNED_INDEX;
 
@@ -3722,11 +3727,14 @@
 						    mol_in.atoms[iat].element,
 						    mol_in.atoms[iat].charge,
 						    ci);
-	 if (0) 
+	 if (false)
 	    std::cout << "render from molecule " << iat
 		      << " id: " << mol_in.atoms[iat].atom_id
 		      << " name: " << mol_in.atoms[iat].atom_name
-		      << " charge:" << mol_in.atoms[iat].charge << std::endl;
+		      << " charge:" << mol_in.atoms[iat].charge
+		      << " pos: " << mol_in.atoms[iat].atom_position
+		      << std::endl;
+
 	 double sa = mol_in.atoms[iat].get_solvent_accessibility();
 	 new_atom.set_atom_name(mol_in.atoms[iat].get_atom_name());
 
@@ -3740,7 +3748,7 @@
 	 std::pair<bool, int> s = mol.add_atom(new_atom);
 	 re_index[iat] = s.second;
 	 
-	 if (0)
+	 if (false)
 	    if (! s.first)
 	       std::cout << "render_from_molecule() atom " << iat
 			 << " was close to atom " << s.second << " "
@@ -3820,13 +3828,14 @@
 	 }
       }
    }
+
    // for input_coords_to_canvas_coords() to work:
    //
    mol.centre_correction = mol_in.centre_correction;
    mol.scale_correction  = mol_in.scale_correction;
    mol.mol_in_min_y = mol_in.mol_in_min_y;
    mol.mol_in_max_y = mol_in.mol_in_max_y;
-   
+
    // 
    make_saves_mutex = 1; // allow saves again.
 
@@ -3921,7 +3930,7 @@
    }
 
    draw_substitution_contour();
-   
+
 }
 
 void
@@ -4060,17 +4069,33 @@
 lbg_info_t::write_png(const std::string &file_name) {
 
    std::pair<lig_build::pos_t, lig_build::pos_t> extents = mol.ligand_extents();
+   std::pair<lig_build::pos_t, lig_build::pos_t> extents_flev = flev_residues_extents();
 
    gdouble scale =  goo_canvas_get_scale(GOO_CANVAS(canvas));
+
    // std::cout << "goo_canvas_get_scale() " << scale << std::endl;
+   // std::cout << "extents_flev: " << extents_flev.first << " " << extents_flev.second
+   //           << std::endl;
    
    int size_x = int(extents.second.x) + 30;
    int size_y = int(extents.second.y) + 30;
 
+   if (extents_flev.second.x > size_x) size_x = extents_flev.second.x;
+   if (extents_flev.second.y > size_y) size_y = extents_flev.second.y;
+
+   // the above extents give us the centre of residue circle - we want to see the whole circle,
+   // so expand things a bit.
+
+   size_x += 40;
+   size_y += 40;
+
    if (key_group) {
-      size_y += 240; // *scale?
-      size_x += 50;
+      // std::cout << "adding space for (just) the key" << std::endl;
+      size_y += 260; // *scale?
+      size_x += 150;
    }
+   // std::cout << "new size_x: " << size_x << std::endl;
+   // std::cout << "new size_y: " << size_y << std::endl;
    
    cairo_surface_t *surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, size_x, size_y);
    cairo_t *cr = cairo_create (surface);
@@ -4087,7 +4112,7 @@
       /* Scale *before* setting the source surface (1) */
       cairo_scale(cr, scale, scale);
       cairo_set_source_surface(cr, surface, 0, 0);
-      cairo_pattern_set_extend (cairo_get_source(cr), CAIRO_EXTEND_REFLECT); 
+      cairo_pattern_set_extend(cairo_get_source(cr), CAIRO_EXTEND_REFLECT);
       /* Replace the destination with the source instead of overlaying */
       cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
       /* Do the actual drawing */
@@ -4223,8 +4248,8 @@
    bool try_as_mdl_mol = false;
 #ifndef MAKE_ENHANCED_LIGAND_TOOLS
    // fallback
-   try_as_mdl_mol = true; 
-#else    
+   try_as_mdl_mol = true;
+#else
    try {
       RDKit::RWMol *m = RDKit::Mol2FileToMol(file_name);
       coot::set_3d_conformer_state(m);
@@ -4237,6 +4262,7 @@
       }
    }
    catch (const RDKit::FileParseException &rte) {
+
       try {
 	 bool sanitize = true;
 	 bool removeHs = false;
@@ -4324,6 +4350,7 @@
    try {
       // molfile molecules don't know about aromatic bonds, we need
       // to kekulize now.
+
       RDKit::MolOps::Kekulize(*m); // non-const reference?
       double weight_for_3d_distances = 0.4;
 
@@ -4339,7 +4366,7 @@
 	       std::cout << "WARNING:: import_mol_from_file() failed to make 2d conformer "
 			 << std::endl;
 	    iconf = iconf_local;
-	 } 
+	 }
 
 	 //    Old way (Pre-Feb 2013) goving via a molfile_molecule_t
 	 //    
@@ -4352,11 +4379,10 @@
 
 	 widgeted_molecule_t wmol = import_rdkit_mol(m, iconf);
 	 mdl_file_name = file_name;
-   
 	 import_from_widgeted_molecule(wmol);
 	 render();
 	 update_descriptor_attributes();
-     
+
       } else {
 	 std::cout << "WARNING:: molecule from " << file_name << " had 0 conformers " << std::endl;
       }
@@ -4861,11 +4887,17 @@
    std::string status_string;
    
    if (get_drug_mdl_file_function_pointer) {
+
       try {
 	 if (get_drug_mdl_file_function_pointer) {
 	    std::string file_name = get_drug_mdl_file_function_pointer(drug_name);
-	    import_mol_from_file(file_name);
-	    save_molecule();
+	    if (file_name.empty()) {
+	       std::cout << "WARNING:: in get_drug(): empty mol file name." << std::endl;
+	    } else {
+	       status = true;
+	       import_mol_from_file(file_name);
+	       save_molecule();
+	    }
 	 }
       }
       catch (const std::runtime_error &rte) {
@@ -4949,6 +4981,9 @@
 			 status_string.c_str());
 
    }
+#else
+   std::cout << "WARNING:: Not compiled with enhanced-ligand-tools - Nothing doing Hermione"
+	     << std::endl;
 #endif // MAKE_ENHANCED_LIGAND_TOOLS
 }
 
diff -ruN coot-0.8.7/lbg/lbg.hh coot-0.8.8-pre/lbg/lbg.hh
--- coot-0.8.7/lbg/lbg.hh	2016-11-01 11:08:05.000000000 -0700
+++ coot-0.8.8-pre/lbg/lbg.hh	2017-01-10 02:55:38.000000000 -0800
@@ -1149,11 +1149,13 @@
    static void on_sbase_search_result_button_clicked(GtkButton *button, gpointer user_data);
    static gboolean watch_for_mdl_from_coot(gpointer user_data);
    time_t coot_mdl_ready_time;
+   std::pair<lig_build::pos_t, lig_build::pos_t> flev_residues_extents() const; // for canvas sizing
    void read_draw_residues(const std::string &file_name);
    void draw_all_flev_annotations(); // which calls draw_all_residue_attribs();
    void draw_all_flev_residue_attribs();
    void draw_all_flev_ligand_annotations();
    
+   
    std::vector<residue_circle_t> read_residues(const std::string &file_name) const;
    // if you don't have add_rep_handles, pass an empty vector.
    void draw_residue_circles(const std::vector<residue_circle_t> &v,
diff -ruN coot-0.8.7/libgtkgraph/Makefile.in coot-0.8.8-pre/libgtkgraph/Makefile.in
--- coot-0.8.7/libgtkgraph/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/libgtkgraph/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -40,6 +40,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -198,6 +201,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/libtool coot-0.8.8-pre/libtool
--- coot-0.8.7/libtool	2016-11-08 07:55:36.000000000 -0800
+++ coot-0.8.8-pre/libtool	2017-01-25 14:39:19.000000000 -0800
@@ -1,7 +1,7 @@
 #! /bin/sh
 
 # libtool - Provide generalized library-building support services.
-# Generated automatically by config.status (coot) 0.8.7
+# Generated automatically by config.status (coot) 0.8.8-pre
 # Libtool was configured on host pc:
 # NOTE: Changes made to this file will be lost: look at ltmain.sh.
 #
diff -ruN coot-0.8.7/lidia-core/Makefile.in coot-0.8.8-pre/lidia-core/Makefile.in
--- coot-0.8.7/lidia-core/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/lidia-core/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -60,6 +60,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -247,6 +250,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/lidia-core/rdkit-interface.cc coot-0.8.8-pre/lidia-core/rdkit-interface.cc
--- coot-0.8.7/lidia-core/rdkit-interface.cc	2016-11-08 04:15:53.000000000 -0800
+++ coot-0.8.8-pre/lidia-core/rdkit-interface.cc	2016-12-21 05:34:30.000000000 -0800
@@ -2361,7 +2361,7 @@
 int
 coot::add_2d_conformer(RDKit::ROMol *rdk_mol, double weight_for_3d_distances) {
 
-   bool debug = true;
+   bool debug = false;
 
    int icurrent_conf = 0; // the conformer number from which the
                           // distance matrix is generated.  Should this
diff -ruN coot-0.8.7/lidia-core/test-cod-atom-types.cc coot-0.8.8-pre/lidia-core/test-cod-atom-types.cc
--- coot-0.8.7/lidia-core/test-cod-atom-types.cc	2016-10-23 20:10:15.000000000 -0700
+++ coot-0.8.8-pre/lidia-core/test-cod-atom-types.cc	2017-01-23 10:30:04.000000000 -0800
@@ -191,6 +191,52 @@
 
 }
 
+void
+write_bonds_by_type(RDKit::RWMol *rdkm, const std::vector<cod::atom_type_t> &v) {
+
+   if (rdkm) {
+      unsigned int n_atoms = rdkm->getNumAtoms();
+      if (n_atoms == v.size()) {
+	 unsigned int n_bonds = rdkm->getNumBonds();
+	 for (unsigned int ib=0; ib<n_bonds; ib++) {
+	    const RDKit::Bond *bond_p = rdkm->getBondWithIdx(ib);
+	    int idx_1 = bond_p->getBeginAtomIdx();
+	    int idx_2 = bond_p->getEndAtomIdx();
+	    std::string t1 = v[idx_1].level_4;
+	    std::string t2 = v[idx_2].level_4;
+	    if (t1 > t2) {
+	       // std::swap(t1, t2);
+	    }
+	    std::cout << "BOND level-4 " << t1 << "     " << t2 << std::endl;
+	    // std::cout << "BOND level-3 " << v[idx_1].level_3 << "     " << v[idx_2].level_3 << std::endl;
+	    // std::cout << "BOND level-2 " << v[idx_1].level_2.string() << "     "
+	    // << v[idx_2].level_2.string() << std::endl;
+	 }
+      }
+   }
+}
+
+void molecule_from_mdl_mol(const std::string &file_name) {
+
+   try {
+      RDKit::RWMol *rdkm = RDKit::MolFileToMol(file_name);
+      if (rdkm) {
+	 cod::atom_types_t t;
+	 std::vector<cod::atom_type_t> v = t.get_cod_atom_types(*rdkm);
+	 std::cout << "PE-TYPES:: -------- " << v.size() << " atoms " << " from "
+		   << file_name << std::endl;
+	 for (unsigned int i=0; i<v.size(); i++)
+	    std::cout << "   " << i << " " << v[i].level_4 << "" << std::endl;
+	 write_bonds_by_type(rdkm, v);
+      } else {
+	 std::cout << "WARNING:: file " << file_name << " null molecule" << std::endl;
+      }
+   }
+   catch (const RDKit::MolSanitizeException &e) {
+      std::cout << "WARNING:: file " << file_name << " "  << e.what() << std::endl;
+   }
+}
+
 void read_tables(const std::string &tables_dir_name) {
 
    cod::bond_record_container_t brc(tables_dir_name);
@@ -269,6 +315,14 @@
 	     << std::endl;
 }
 
+void proc_mols(const std::string &mol_dir) {
+
+   std::vector<std::string> files = coot::util::glob_files(mol_dir, "*.mol");
+   for (unsigned int i=0; i<files.size(); i++) {
+      molecule_from_mdl_mol(files[i]);
+   }
+}
+
 
 int main(int argc, char **argv) {
 
@@ -280,7 +334,7 @@
 
 	 if (s == "primes") {
 	    test_primes();
-	 } else { 
+	 } else {
 	    if (s.length() == 3)
 	       molecule_from_comp_id(s);
 	    else
@@ -296,7 +350,12 @@
 	 if (comp_id == "tables") {
 	    read_tables(file_name); // dir-name in this case
 	 } else {
-	    molecule_from_ccd_pdbx(comp_id, file_name);
+	    if (comp_id == "mol-dir") {
+	       std::string mol_dir = file_name;
+	       proc_mols(mol_dir);
+	    } else {
+	       molecule_from_ccd_pdbx(comp_id, file_name);
+	    }
 	 }
       }
 
diff -ruN coot-0.8.7/ligand/Makefile.in coot-0.8.8-pre/ligand/Makefile.in
--- coot-0.8.7/ligand/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/ligand/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -69,6 +69,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -324,6 +327,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/ligand/backrub-rotamer.cc coot-0.8.8-pre/ligand/backrub-rotamer.cc
--- coot-0.8.7/ligand/backrub-rotamer.cc	2015-08-26 04:54:02.000000000 -0700
+++ coot-0.8.8-pre/ligand/backrub-rotamer.cc	2017-01-23 10:30:04.000000000 -0800
@@ -34,8 +34,8 @@
 coot::backrub::search(const coot::dictionary_residue_restraints_t &rest) {
 
    coot::minimol::molecule mol;
-   int n_vr = 20;                     // total is 2*n_vr+2
-   double vector_rotation_range = 20; // degrees either side of the starting position.
+   int n_vr = 15;                     // total is 2*n_vr+1
+   double vector_rotation_range = 15; // degrees either side of the starting position.
 
    float best_score = -9999;
    coot::minimol::fragment best_frag;
@@ -167,7 +167,7 @@
 	 // rotate pt
 	 double ra = M_PI*rotation_angle/180.0;
 	 clipper::Coord_orth pt_new =
-	    coot::util::rotate_round_vector(dir, pt, ca_prev, ra);
+	    coot::util::rotate_around_vector(dir, pt, ca_prev, ra);
 	 f[ires][iat].pos = pt_new;
       }
    }
@@ -454,7 +454,7 @@
 		     // rotate pt
 		     double ra = M_PI*sample_rotation_angle/180.0;
 		     clipper::Coord_orth pt_new =
-			coot::util::rotate_round_vector(dir, pt, ca_ref_rot, ra);
+			coot::util::rotate_around_vector(dir, pt, ca_ref_rot, ra);
 		     double d =  clipper::Coord_orth::length(O_pos, pt_new);
 		     sum_dist += d;
 		  }
@@ -545,7 +545,7 @@
 	    // rotate pt
 	    double ra = M_PI*best_back_rotation_angle/180.0;
 	    clipper::Coord_orth pt_new =
-	       coot::util::rotate_round_vector(dir, pt, ca_ref_rot, ra);
+	       coot::util::rotate_around_vector(dir, pt, ca_ref_rot, ra);
 	    (*f)[ires][iat].pos = pt_new;
 	 } 
       }
diff -ruN coot-0.8.7/ligand/ligand-percentiles.cc coot-0.8.8-pre/ligand/ligand-percentiles.cc
--- coot-0.8.7/ligand/ligand-percentiles.cc	2016-09-01 17:13:23.000000000 -0700
+++ coot-0.8.8-pre/ligand/ligand-percentiles.cc	2017-01-13 09:52:22.000000000 -0800
@@ -170,7 +170,7 @@
    if (argc > 1) {
       std::string metric_str = "density_correlation";
       std::string value_str;
-      std::string database_name = std::string(PKGDATADIR) + "/data/ligands-2016.db";
+      std::string database_name = coot::package_data_dir() + "/data/ligands-2016.db";
       bool do_help = false;
       bool do_rank = false;
 
diff -ruN coot-0.8.7/ligand/trace.cc coot-0.8.8-pre/ligand/trace.cc
--- coot-0.8.7/ligand/trace.cc	2016-09-09 09:43:24.000000000 -0700
+++ coot-0.8.8-pre/ligand/trace.cc	2017-01-23 10:30:04.000000000 -0800
@@ -638,17 +638,17 @@
    clipper::Coord_orth rel_line_pt_C(diff_p_unit * f_ca_ca_c + perp_unit * 0.48);
    clipper::Coord_orth rel_line_pt_N(diff_p_unit * f_ca_ca_n - perp_unit * 0.47);
 
-   clipper::Coord_orth p_N = util::rotate_round_vector(diff_p_unit,
-						       pos_1 + rel_line_pt_N,
-						       pos_1, alpha);
-
-   clipper::Coord_orth p_O = util::rotate_round_vector(diff_p_unit,
-						       pos_1 + rel_line_pt_O,
-						       pos_1, alpha);
-   
-   clipper::Coord_orth p_C = util::rotate_round_vector(diff_p_unit,
-						       pos_1 + rel_line_pt_C,
-						       pos_1, alpha);
+   clipper::Coord_orth p_N = util::rotate_around_vector(diff_p_unit,
+							pos_1 + rel_line_pt_N,
+							pos_1, alpha);
+   
+   clipper::Coord_orth p_O = util::rotate_around_vector(diff_p_unit,
+							pos_1 + rel_line_pt_O,
+							pos_1, alpha);
+   
+   clipper::Coord_orth p_C = util::rotate_around_vector(diff_p_unit,
+							pos_1 + rel_line_pt_C,
+							pos_1, alpha);
 
    minimol::residue r1(res_no_base,   "ALA");
    minimol::residue r2(res_no_base+1, "ALA");
@@ -945,28 +945,28 @@
 
       // direction position orig-shift angle
       // 
-      clipper::Coord_orth p_CO = util::rotate_round_vector(diff_p_unit,
-							  pos_1 + rel_line_pt_O,
-							  pos_1, alpha);
+      clipper::Coord_orth p_CO = util::rotate_around_vector(diff_p_unit,
+							    pos_1 + rel_line_pt_O,
+							    pos_1, alpha);
       
-      clipper::Coord_orth p_CO_low = util::rotate_round_vector(diff_p_unit,
-							  pos_1 + rel_line_pt_O_low,
-							  pos_1, alpha);
+      clipper::Coord_orth p_CO_low = util::rotate_around_vector(diff_p_unit,
+								pos_1 + rel_line_pt_O_low,
+								pos_1, alpha);
       
-      clipper::Coord_orth p_CO_anti = util::rotate_round_vector(diff_p_unit,
-							  pos_1 + rel_line_pt_CO_anti,
-							  pos_1, alpha);
+      clipper::Coord_orth p_CO_anti = util::rotate_around_vector(diff_p_unit,
+								 pos_1 + rel_line_pt_CO_anti,
+								 pos_1, alpha);
       
-      clipper::Coord_orth p_N = util::rotate_round_vector(diff_p_unit,
-							  pos_1 + rel_line_pt_N,
-							  pos_1, alpha);
+      clipper::Coord_orth p_N = util::rotate_around_vector(diff_p_unit,
+							   pos_1 + rel_line_pt_N,
+							   pos_1, alpha);
       
-      clipper::Coord_orth p_2 = util::rotate_round_vector(diff_p_unit,
-							  pos_1 + rel_line_pt_perp1,
-							  pos_1, alpha);
-      clipper::Coord_orth p_3 = util::rotate_round_vector(diff_p_unit,
-							  pos_1 + rel_line_pt_perp2,
-							  pos_1, alpha);
+      clipper::Coord_orth p_2 = util::rotate_around_vector(diff_p_unit,
+							   pos_1 + rel_line_pt_perp1,
+							   pos_1, alpha);
+      clipper::Coord_orth p_3 = util::rotate_around_vector(diff_p_unit,
+							   pos_1 + rel_line_pt_perp2,
+							   pos_1, alpha);
 
       // clipper::Coord_orth p_N_acceptor_1 = util::rotate_round_vector(diff_p_unit,
       // 								     pos_1 + rel_line_pt_N_accpt,
diff -ruN coot-0.8.7/ligand/wiggly-ligand.cc coot-0.8.8-pre/ligand/wiggly-ligand.cc
--- coot-0.8.7/ligand/wiggly-ligand.cc	2016-11-01 08:46:49.000000000 -0700
+++ coot-0.8.8-pre/ligand/wiggly-ligand.cc	2016-12-21 05:34:30.000000000 -0800
@@ -135,11 +135,12 @@
       // urgh.  What to do...
       non_const_non_ring_torsions = non_const_torsions;
    } 
-
-   std::cout << "This residue has " << m_torsions.size() << " defined non-H torsions "
-	     << "of which " << n_non_const_torsionable << " are (non-const) rotatable and "
-	     << non_const_non_ring_torsions.size() << " are non-const and non-ring torsions"
-	     << std::endl;
+ 
+   if (false)
+      std::cout << "This residue has " << m_torsions.size() << " defined non-H torsions "
+	        << "of which " << n_non_const_torsionable << " are (non-const) rotatable and "
+	        << non_const_non_ring_torsions.size() << " are non-const and non-ring torsions"
+	        << std::endl;
    
    if (debug_wiggly_ligands) {
       for (unsigned int itor=0; itor<m_torsions.size(); itor++) { 
@@ -378,10 +379,11 @@
       non_const_non_ring_torsions = non_const_torsions;
    } 
 
-   std::cout << "This residue has " << m_torsions.size() << " defined non-H torsions "
-	     << "of which " << n_non_const_torsionable << " are (non-const) rotatable and "
-	     << non_const_non_ring_torsions.size() << " are non-const and non-ring torsions"
-	     << std::endl;
+   if (false)
+      std::cout << "This residue has " << m_torsions.size() << " defined non-H torsions "
+	        << "of which " << n_non_const_torsionable << " are (non-const) rotatable and "
+	        << non_const_non_ring_torsions.size() << " are non-const and non-ring torsions"
+	        << std::endl;
    
    if (debug_wiggly_ligands) {
       for (unsigned int itor=0; itor<m_torsions.size(); itor++) { 
@@ -617,8 +619,6 @@
       if (ifound)
 	 break;
    }
-
-   std::cout << "get_monomer type: " << r << std::endl;
    return r;
 }
 
diff -ruN coot-0.8.7/macros/Makefile.in coot-0.8.8-pre/macros/Makefile.in
--- coot-0.8.7/macros/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/macros/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -59,6 +59,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -171,6 +174,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/macros/ax_cxx_compile_stdcxx.m4 coot-0.8.8-pre/macros/ax_cxx_compile_stdcxx.m4
--- coot-0.8.7/macros/ax_cxx_compile_stdcxx.m4	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/macros/ax_cxx_compile_stdcxx.m4	2017-01-23 10:30:04.000000000 -0800
@@ -0,0 +1,982 @@
+# ===========================================================================
+#   http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CXX_COMPILE_STDCXX(VERSION, [ext|noext], [mandatory|optional])
+#
+# DESCRIPTION
+#
+#   Check for baseline language coverage in the compiler for the specified
+#   version of the C++ standard.  If necessary, add switches to CXX and
+#   CXXCPP to enable support.  VERSION may be '11' (for the C++11 standard)
+#   or '14' (for the C++14 standard).
+#
+#   The second argument, if specified, indicates whether you insist on an
+#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.
+#   -std=c++11).  If neither is specified, you get whatever works, with
+#   preference for an extended mode.
+#
+#   The third argument, if specified 'mandatory' or if left unspecified,
+#   indicates that baseline support for the specified C++ standard is
+#   required and that the macro should error out if no mode with that
+#   support is found.  If specified 'optional', then configuration proceeds
+#   regardless, after defining HAVE_CXX${VERSION} if and only if a
+#   supporting mode is found.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
+#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
+#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
+#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>
+#   Copyright (c) 2015 Paul Norman <penorman@mac.com>
+#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>
+#   Copyright (c) 2016 Krzesimir Nowak <qdlacz@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 6
+
+dnl  This macro is based on the code from the AX_CXX_COMPILE_STDCXX_11 macro
+dnl  (serial version number 13).
+
+AX_REQUIRE_DEFINED([AC_MSG_WARN])
+AC_DEFUN([AX_CXX_COMPILE_STDCXX], [dnl
+  m4_if([$1], [11], [ax_cxx_compile_alternatives="11 0x"],
+        [$1], [14], [ax_cxx_compile_alternatives="14 1y"],
+        [$1], [17], [ax_cxx_compile_alternatives="17 1z"],
+        [m4_fatal([invalid first argument `$1' to AX_CXX_COMPILE_STDCXX])])dnl
+  m4_if([$2], [], [],
+        [$2], [ext], [],
+        [$2], [noext], [],
+        [m4_fatal([invalid second argument `$2' to AX_CXX_COMPILE_STDCXX])])dnl
+  m4_if([$3], [], [ax_cxx_compile_cxx$1_required=true],
+        [$3], [mandatory], [ax_cxx_compile_cxx$1_required=true],
+        [$3], [optional], [ax_cxx_compile_cxx$1_required=false],
+        [m4_fatal([invalid third argument `$3' to AX_CXX_COMPILE_STDCXX])])
+  AC_LANG_PUSH([C++])dnl
+  ac_success=no
+  AC_CACHE_CHECK(whether $CXX supports C++$1 features by default,
+  ax_cv_cxx_compile_cxx$1,
+  [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
+    [ax_cv_cxx_compile_cxx$1=yes],
+    [ax_cv_cxx_compile_cxx$1=no])])
+  if test x$ax_cv_cxx_compile_cxx$1 = xyes; then
+    ac_success=yes
+  fi
+
+  m4_if([$2], [noext], [], [dnl
+  if test x$ac_success = xno; then
+    for alternative in ${ax_cxx_compile_alternatives}; do
+      switch="-std=gnu++${alternative}"
+      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])
+      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,
+                     $cachevar,
+        [ac_save_CXX="$CXX"
+         CXX="$CXX $switch"
+         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
+          [eval $cachevar=yes],
+          [eval $cachevar=no])
+         CXX="$ac_save_CXX"])
+      if eval test x\$$cachevar = xyes; then
+        CXX="$CXX $switch"
+        if test -n "$CXXCPP" ; then
+          CXXCPP="$CXXCPP $switch"
+        fi
+        ac_success=yes
+        break
+      fi
+    done
+  fi])
+
+  m4_if([$2], [ext], [], [dnl
+  if test x$ac_success = xno; then
+    dnl HP's aCC needs +std=c++11 according to:
+    dnl http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/PDF_Release_Notes/769149-001.pdf
+    dnl Cray's crayCC needs "-h std=c++11"
+    for alternative in ${ax_cxx_compile_alternatives}; do
+      for switch in -std=c++${alternative} +std=c++${alternative} "-h std=c++${alternative}"; do
+        cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])
+        AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,
+                       $cachevar,
+          [ac_save_CXX="$CXX"
+           CXX="$CXX $switch"
+           AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
+            [eval $cachevar=yes],
+            [eval $cachevar=no])
+           CXX="$ac_save_CXX"])
+        if eval test x\$$cachevar = xyes; then
+          CXX="$CXX $switch"
+          if test -n "$CXXCPP" ; then
+            CXXCPP="$CXXCPP $switch"
+          fi
+          ac_success=yes
+          break
+        fi
+      done
+      if test x$ac_success = xyes; then
+        break
+      fi
+    done
+  fi])
+  AC_LANG_POP([C++])
+  if test x$ax_cxx_compile_cxx$1_required = xtrue; then
+    if test x$ac_success = xno; then
+      AC_MSG_ERROR([*** A compiler with support for C++$1 language features is required.])
+    fi
+  fi
+  if test x$ac_success = xno; then
+    HAVE_CXX$1=0
+    AC_MSG_NOTICE([No compiler with C++$1 support was found])
+  else
+    HAVE_CXX$1=1
+    AC_DEFINE(HAVE_CXX$1,1,
+              [define if the compiler supports basic C++$1 syntax])
+  fi
+  AC_SUBST(HAVE_CXX$1)
+  m4_if([$1], [17], [AC_MSG_WARN([C++17 is not yet standardized, so the checks may change in incompatible ways anytime])])
+])
+
+
+dnl  Test body for checking C++11 support
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_11],
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
+)
+
+
+dnl  Test body for checking C++14 support
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_14],
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14
+)
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_17],
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_17
+)
+
+dnl  Tests for new features in C++11
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_11], [[
+
+// If the compiler admits that it is not ready for C++11, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus < 201103L
+
+#error "This is not a C++11 compiler"
+
+#else
+
+namespace cxx11
+{
+
+  namespace test_static_assert
+  {
+
+    template <typename T>
+    struct check
+    {
+      static_assert(sizeof(int) <= sizeof(T), "not big enough");
+    };
+
+  }
+
+  namespace test_final_override
+  {
+
+    struct Base
+    {
+      virtual void f() {}
+    };
+
+    struct Derived : public Base
+    {
+      virtual void f() override {}
+    };
+
+  }
+
+  namespace test_double_right_angle_brackets
+  {
+
+    template < typename T >
+    struct check {};
+
+    typedef check<void> single_type;
+    typedef check<check<void>> double_type;
+    typedef check<check<check<void>>> triple_type;
+    typedef check<check<check<check<void>>>> quadruple_type;
+
+  }
+
+  namespace test_decltype
+  {
+
+    int
+    f()
+    {
+      int a = 1;
+      decltype(a) b = 2;
+      return a + b;
+    }
+
+  }
+
+  namespace test_type_deduction
+  {
+
+    template < typename T1, typename T2 >
+    struct is_same
+    {
+      static const bool value = false;
+    };
+
+    template < typename T >
+    struct is_same<T, T>
+    {
+      static const bool value = true;
+    };
+
+    template < typename T1, typename T2 >
+    auto
+    add(T1 a1, T2 a2) -> decltype(a1 + a2)
+    {
+      return a1 + a2;
+    }
+
+    int
+    test(const int c, volatile int v)
+    {
+      static_assert(is_same<int, decltype(0)>::value == true, "");
+      static_assert(is_same<int, decltype(c)>::value == false, "");
+      static_assert(is_same<int, decltype(v)>::value == false, "");
+      auto ac = c;
+      auto av = v;
+      auto sumi = ac + av + 'x';
+      auto sumf = ac + av + 1.0;
+      static_assert(is_same<int, decltype(ac)>::value == true, "");
+      static_assert(is_same<int, decltype(av)>::value == true, "");
+      static_assert(is_same<int, decltype(sumi)>::value == true, "");
+      static_assert(is_same<int, decltype(sumf)>::value == false, "");
+      static_assert(is_same<int, decltype(add(c, v))>::value == true, "");
+      return (sumf > 0.0) ? sumi : add(c, v);
+    }
+
+  }
+
+  namespace test_noexcept
+  {
+
+    int f() { return 0; }
+    int g() noexcept { return 0; }
+
+    static_assert(noexcept(f()) == false, "");
+    static_assert(noexcept(g()) == true, "");
+
+  }
+
+  namespace test_constexpr
+  {
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept
+    {
+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;
+    }
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c(const CharT *const s) noexcept
+    {
+      return strlen_c_r(s, 0UL);
+    }
+
+    static_assert(strlen_c("") == 0UL, "");
+    static_assert(strlen_c("1") == 1UL, "");
+    static_assert(strlen_c("example") == 7UL, "");
+    static_assert(strlen_c("another\0example") == 7UL, "");
+
+  }
+
+  namespace test_rvalue_references
+  {
+
+    template < int N >
+    struct answer
+    {
+      static constexpr int value = N;
+    };
+
+    answer<1> f(int&)       { return answer<1>(); }
+    answer<2> f(const int&) { return answer<2>(); }
+    answer<3> f(int&&)      { return answer<3>(); }
+
+    void
+    test()
+    {
+      int i = 0;
+      const int c = 0;
+      static_assert(decltype(f(i))::value == 1, "");
+      static_assert(decltype(f(c))::value == 2, "");
+      static_assert(decltype(f(0))::value == 3, "");
+    }
+
+  }
+
+  namespace test_uniform_initialization
+  {
+
+    struct test
+    {
+      static const int zero {};
+      static const int one {1};
+    };
+
+    static_assert(test::zero == 0, "");
+    static_assert(test::one == 1, "");
+
+  }
+
+  namespace test_lambdas
+  {
+
+    void
+    test1()
+    {
+      auto lambda1 = [](){};
+      auto lambda2 = lambda1;
+      lambda1();
+      lambda2();
+    }
+
+    int
+    test2()
+    {
+      auto a = [](int i, int j){ return i + j; }(1, 2);
+      auto b = []() -> int { return '0'; }();
+      auto c = [=](){ return a + b; }();
+      auto d = [&](){ return c; }();
+      auto e = [a, &b](int x) mutable {
+        const auto identity = [](int y){ return y; };
+        for (auto i = 0; i < a; ++i)
+          a += b--;
+        return x + identity(a + b);
+      }(0);
+      return a + b + c + d + e;
+    }
+
+    int
+    test3()
+    {
+      const auto nullary = [](){ return 0; };
+      const auto unary = [](int x){ return x; };
+      using nullary_t = decltype(nullary);
+      using unary_t = decltype(unary);
+      const auto higher1st = [](nullary_t f){ return f(); };
+      const auto higher2nd = [unary](nullary_t f1){
+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };
+      };
+      return higher1st(nullary) + higher2nd(nullary)(unary);
+    }
+
+  }
+
+  namespace test_variadic_templates
+  {
+
+    template <int...>
+    struct sum;
+
+    template <int N0, int... N1toN>
+    struct sum<N0, N1toN...>
+    {
+      static constexpr auto value = N0 + sum<N1toN...>::value;
+    };
+
+    template <>
+    struct sum<>
+    {
+      static constexpr auto value = 0;
+    };
+
+    static_assert(sum<>::value == 0, "");
+    static_assert(sum<1>::value == 1, "");
+    static_assert(sum<23>::value == 23, "");
+    static_assert(sum<1, 2>::value == 3, "");
+    static_assert(sum<5, 5, 11>::value == 21, "");
+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, "");
+
+  }
+
+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae
+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function
+  // because of this.
+  namespace test_template_alias_sfinae
+  {
+
+    struct foo {};
+
+    template<typename T>
+    using member = typename T::member_type;
+
+    template<typename T>
+    void func(...) {}
+
+    template<typename T>
+    void func(member<T>*) {}
+
+    void test();
+
+    void test() { func<foo>(0); }
+
+  }
+
+}  // namespace cxx11
+
+#endif  // __cplusplus >= 201103L
+
+]])
+
+
+dnl  Tests for new features in C++14
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_14], [[
+
+// If the compiler admits that it is not ready for C++14, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus < 201402L
+
+#error "This is not a C++14 compiler"
+
+#else
+
+namespace cxx14
+{
+
+  namespace test_polymorphic_lambdas
+  {
+
+    int
+    test()
+    {
+      const auto lambda = [](auto&&... args){
+        const auto istiny = [](auto x){
+          return (sizeof(x) == 1UL) ? 1 : 0;
+        };
+        const int aretiny[] = { istiny(args)... };
+        return aretiny[0];
+      };
+      return lambda(1, 1L, 1.0f, '1');
+    }
+
+  }
+
+  namespace test_binary_literals
+  {
+
+    constexpr auto ivii = 0b0000000000101010;
+    static_assert(ivii == 42, "wrong value");
+
+  }
+
+  namespace test_generalized_constexpr
+  {
+
+    template < typename CharT >
+    constexpr unsigned long
+    strlen_c(const CharT *const s) noexcept
+    {
+      auto length = 0UL;
+      for (auto p = s; *p; ++p)
+        ++length;
+      return length;
+    }
+
+    static_assert(strlen_c("") == 0UL, "");
+    static_assert(strlen_c("x") == 1UL, "");
+    static_assert(strlen_c("test") == 4UL, "");
+    static_assert(strlen_c("another\0test") == 7UL, "");
+
+  }
+
+  namespace test_lambda_init_capture
+  {
+
+    int
+    test()
+    {
+      auto x = 0;
+      const auto lambda1 = [a = x](int b){ return a + b; };
+      const auto lambda2 = [a = lambda1(x)](){ return a; };
+      return lambda2();
+    }
+
+  }
+
+  namespace test_digit_separators
+  {
+
+    constexpr auto ten_million = 100'000'000;
+    static_assert(ten_million == 100000000, "");
+
+  }
+
+  namespace test_return_type_deduction
+  {
+
+    auto f(int& x) { return x; }
+    decltype(auto) g(int& x) { return x; }
+
+    template < typename T1, typename T2 >
+    struct is_same
+    {
+      static constexpr auto value = false;
+    };
+
+    template < typename T >
+    struct is_same<T, T>
+    {
+      static constexpr auto value = true;
+    };
+
+    int
+    test()
+    {
+      auto x = 0;
+      static_assert(is_same<int, decltype(f(x))>::value, "");
+      static_assert(is_same<int&, decltype(g(x))>::value, "");
+      return x;
+    }
+
+  }
+
+}  // namespace cxx14
+
+#endif  // __cplusplus >= 201402L
+
+]])
+
+
+dnl  Tests for new features in C++17
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_17], [[
+
+// If the compiler admits that it is not ready for C++17, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus <= 201402L
+
+#error "This is not a C++17 compiler"
+
+#else
+
+#if defined(__clang__)
+  #define REALLY_CLANG
+#else
+  #if defined(__GNUC__)
+    #define REALLY_GCC
+  #endif
+#endif
+
+#include <initializer_list>
+#include <utility>
+#include <type_traits>
+
+namespace cxx17
+{
+
+#if !defined(REALLY_CLANG)
+  namespace test_constexpr_lambdas
+  {
+
+    // TODO: test it with clang++ from git
+
+    constexpr int foo = [](){return 42;}();
+
+  }
+#endif // !defined(REALLY_CLANG)
+
+  namespace test::nested_namespace::definitions
+  {
+
+  }
+
+  namespace test_fold_expression
+  {
+
+    template<typename... Args>
+    int multiply(Args... args)
+    {
+      return (args * ... * 1);
+    }
+
+    template<typename... Args>
+    bool all(Args... args)
+    {
+      return (args && ...);
+    }
+
+  }
+
+  namespace test_extended_static_assert
+  {
+
+    static_assert (true);
+
+  }
+
+  namespace test_auto_brace_init_list
+  {
+
+    auto foo = {5};
+    auto bar {5};
+
+    static_assert(std::is_same<std::initializer_list<int>, decltype(foo)>::value);
+    static_assert(std::is_same<int, decltype(bar)>::value);
+  }
+
+  namespace test_typename_in_template_template_parameter
+  {
+
+    template<template<typename> typename X> struct D;
+
+  }
+
+  namespace test_fallthrough_nodiscard_maybe_unused_attributes
+  {
+
+    int f1()
+    {
+      return 42;
+    }
+
+    [[nodiscard]] int f2()
+    {
+      [[maybe_unused]] auto unused = f1();
+
+      switch (f1())
+      {
+      case 17:
+        f1();
+        [[fallthrough]];
+      case 42:
+        f1();
+      }
+      return f1();
+    }
+
+  }
+
+  namespace test_extended_aggregate_initialization
+  {
+
+    struct base1
+    {
+      int b1, b2 = 42;
+    };
+
+    struct base2
+    {
+      base2() {
+        b3 = 42;
+      }
+      int b3;
+    };
+
+    struct derived : base1, base2
+    {
+        int d;
+    };
+
+    derived d1 {{1, 2}, {}, 4};  // full initialization
+    derived d2 {{}, {}, 4};      // value-initialized bases
+
+  }
+
+  namespace test_general_range_based_for_loop
+  {
+
+    struct iter
+    {
+      int i;
+
+      int& operator* ()
+      {
+        return i;
+      }
+
+      const int& operator* () const
+      {
+        return i;
+      }
+
+      iter& operator++()
+      {
+        ++i;
+        return *this;
+      }
+    };
+
+    struct sentinel
+    {
+      int i;
+    };
+
+    bool operator== (const iter& i, const sentinel& s)
+    {
+      return i.i == s.i;
+    }
+
+    bool operator!= (const iter& i, const sentinel& s)
+    {
+      return !(i == s);
+    }
+
+    struct range
+    {
+      iter begin() const
+      {
+        return {0};
+      }
+
+      sentinel end() const
+      {
+        return {5};
+      }
+    };
+
+    void f()
+    {
+      range r {};
+
+      for (auto i : r)
+      {
+        [[maybe_unused]] auto v = i;
+      }
+    }
+
+  }
+
+  namespace test_lambda_capture_asterisk_this_by_value
+  {
+
+    struct t
+    {
+      int i;
+      int foo()
+      {
+        return [*this]()
+        {
+          return i;
+        }();
+      }
+    };
+
+  }
+
+  namespace test_enum_class_construction
+  {
+
+    enum class byte : unsigned char
+    {};
+
+    byte foo {42};
+
+  }
+
+  namespace test_constexpr_if
+  {
+
+    template <bool cond>
+    int f ()
+    {
+      if constexpr(cond)
+      {
+        return 13;
+      }
+      else
+      {
+        return 42;
+      }
+    }
+
+  }
+
+  namespace test_selection_statement_with_initializer
+  {
+
+    int f()
+    {
+      return 13;
+    }
+
+    int f2()
+    {
+      if (auto i = f(); i > 0)
+      {
+        return 3;
+      }
+
+      switch (auto i = f(); i + 4)
+      {
+      case 17:
+        return 2;
+
+      default:
+        return 1;
+      }
+    }
+
+  }
+
+#if !defined(REALLY_CLANG)
+  namespace test_template_argument_deduction_for_class_templates
+  {
+
+    // TODO: test it with clang++ from git
+
+    template <typename T1, typename T2>
+    struct pair
+    {
+      pair (T1 p1, T2 p2)
+        : m1 {p1},
+          m2 {p2}
+      {}
+
+      T1 m1;
+      T2 m2;
+    };
+
+    void f()
+    {
+      [[maybe_unused]] auto p = pair{13, 42u};
+    }
+
+  }
+#endif // !defined(REALLY_CLANG)
+
+  namespace test_non_type_auto_template_parameters
+  {
+
+    template <auto n>
+    struct B
+    {};
+
+    B<5> b1;
+    B<'a'> b2;
+
+  }
+
+#if !defined(REALLY_CLANG)
+  namespace test_structured_bindings
+  {
+
+    // TODO: test it with clang++ from git
+
+    int arr[2] = { 1, 2 };
+    std::pair<int, int> pr = { 1, 2 };
+
+    auto f1() -> int(&)[2]
+    {
+      return arr;
+    }
+
+    auto f2() -> std::pair<int, int>&
+    {
+      return pr;
+    }
+
+    struct S
+    {
+      int x1 : 2;
+      volatile double y1;
+    };
+
+    S f3()
+    {
+      return {};
+    }
+
+    auto [ x1, y1 ] = f1();
+    auto& [ xr1, yr1 ] = f1();
+    auto [ x2, y2 ] = f2();
+    auto& [ xr2, yr2 ] = f2();
+    const auto [ x3, y3 ] = f3();
+
+  }
+#endif // !defined(REALLY_CLANG)
+
+#if !defined(REALLY_CLANG)
+  namespace test_exception_spec_type_system
+  {
+
+    // TODO: test it with clang++ from git
+
+    struct Good {};
+    struct Bad {};
+
+    void g1() noexcept;
+    void g2();
+
+    template<typename T>
+    Bad
+    f(T*, T*);
+
+    template<typename T1, typename T2>
+    Good
+    f(T1*, T2*);
+
+    static_assert (std::is_same_v<Good, decltype(f(g1, g2))>);
+
+  }
+#endif // !defined(REALLY_CLANG)
+
+  namespace test_inline_variables
+  {
+
+    template<class T> void f(T)
+    {}
+
+    template<class T> inline T g(T)
+    {
+      return T{};
+    }
+
+    template<> inline void f<>(int)
+    {}
+
+    template<> int g<>(int)
+    {
+      return 5;
+    }
+
+  }
+
+}  // namespace cxx17
+
+#endif  // __cplusplus <= 201402L
+
+]])
diff -ruN coot-0.8.7/macros/ax_cxx_compile_stdcxx_11.m4 coot-0.8.8-pre/macros/ax_cxx_compile_stdcxx_11.m4
--- coot-0.8.7/macros/ax_cxx_compile_stdcxx_11.m4	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/macros/ax_cxx_compile_stdcxx_11.m4	2017-01-23 10:30:04.000000000 -0800
@@ -0,0 +1,39 @@
+# ============================================================================
+#  http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx_11.m4
+# ============================================================================
+#
+# SYNOPSIS
+#
+#   AX_CXX_COMPILE_STDCXX_11([ext|noext], [mandatory|optional])
+#
+# DESCRIPTION
+#
+#   Check for baseline language coverage in the compiler for the C++11
+#   standard; if necessary, add switches to CXX and CXXCPP to enable
+#   support.
+#
+#   This macro is a convenience alias for calling the AX_CXX_COMPILE_STDCXX
+#   macro with the version set to C++11.  The two optional arguments are
+#   forwarded literally as the second and third argument respectively.
+#   Please see the documentation for the AX_CXX_COMPILE_STDCXX macro for
+#   more information.  If you want to use this macro, you also need to
+#   download the ax_cxx_compile_stdcxx.m4 file.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
+#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
+#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
+#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>
+#   Copyright (c) 2015 Paul Norman <penorman@mac.com>
+#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved. This file is offered as-is, without any
+#   warranty.
+
+#serial 17
+
+AX_REQUIRE_DEFINED([AX_CXX_COMPILE_STDCXX])
+AC_DEFUN([AX_CXX_COMPILE_STDCXX_11], [AX_CXX_COMPILE_STDCXX([11], [$1], [$2])])
diff -ruN coot-0.8.7/macros/ax_cxx_have_thread.m4 coot-0.8.8-pre/macros/ax_cxx_have_thread.m4
--- coot-0.8.7/macros/ax_cxx_have_thread.m4	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/macros/ax_cxx_have_thread.m4	2017-01-17 12:48:52.000000000 -0800
@@ -0,0 +1,58 @@
+# ===========================================================================
+#     http://www.gnu.org/software/autoconf-archive/ax_cxx_have_thread.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CXX_HAVE_THREAD()
+#
+# DESCRIPTION
+#
+#   This macro checks if std::thread, added in C++11, is defined in the
+#   <thread> header.
+#
+#   If it is, define the ax_cv_cxx_have_thread environment variable to "yes"
+#   and define HAVE_CXX_THREAD.
+#
+# CONTRIBUTING
+#
+#   You can contribute changes on GitHub by forking this repository:
+#
+#   https://github.com/emcrisostomo/CXX-Autoconf-Macros.git
+#
+# LICENSE
+#
+#   Copyright (c) 2014 Enrico M. Crisostomo <enrico.m.crisostomo@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 1
+
+AC_DEFUN([AX_CXX_HAVE_THREAD],
+  [AC_CACHE_CHECK(
+    [for std::thread in thread],
+    ax_cv_cxx_have_thread,
+    [dnl
+      AC_LANG_PUSH([C++])
+      AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+        [
+          [#include <thread>]
+          [using namespace std;]
+          [thread t;]
+        ],
+        []
+        )],
+        [ax_cv_cxx_have_thread=yes],
+        [ax_cv_cxx_have_thread=no]
+      )
+    AC_LANG_POP([C++])])
+    if test x"$ax_cv_cxx_have_thread" = "xyes"
+    then
+      AC_DEFINE(HAVE_CXX_THREAD,
+        1,
+        [Define if thread defines the std::thread class.])
+    fi
+  ])
diff -ruN coot-0.8.7/man/Makefile.in coot-0.8.8-pre/man/Makefile.in
--- coot-0.8.7/man/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/man/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -40,6 +40,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -177,6 +180,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/mini-mol/Makefile.in coot-0.8.8-pre/mini-mol/Makefile.in
--- coot-0.8.7/mini-mol/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/mini-mol/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -62,6 +62,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -228,6 +231,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/pdb-templates/FUC-decorations.tab coot-0.8.8-pre/pdb-templates/FUC-decorations.tab
--- coot-0.8.7/pdb-templates/FUC-decorations.tab	2015-08-26 04:54:02.000000000 -0700
+++ coot-0.8.8-pre/pdb-templates/FUC-decorations.tab	2016-12-21 05:34:30.000000000 -0800
@@ -2,4 +2,3 @@
    atom O3 O based-on 0 C3 0 C2 0 C1 bond-length: 1.41391 angle: 108.56800 tors:  173.00967
    atom O4 O based-on 0 C4 0 C3 0 C2 bond-length: 1.40925 angle: 109.78753 tors:   73.61034
    atom C6 C based-on 0 C5 0 C4 0 C3 bond-length: 1.52647 angle: 110.38170 tors:  175.19390
-   atom   based-on 0  0  0  bond-length: 1.52647 angle: 110.38170 tors:  175.19390
diff -ruN coot-0.8.7/pdb-templates/Makefile.am coot-0.8.8-pre/pdb-templates/Makefile.am
--- coot-0.8.7/pdb-templates/Makefile.am	2015-08-26 04:54:02.000000000 -0700
+++ coot-0.8.8-pre/pdb-templates/Makefile.am	2016-12-21 05:34:30.000000000 -0800
@@ -8,17 +8,20 @@
 	     SIA-pyranose-via-ALPHA2-3.pdb      \
 	     link-by-torsion-to-pyranose-core-ALPHA1-2.tab \
 	     link-by-torsion-to-pyranose-core-ALPHA1-3.tab \
+	     link-by-torsion-to-FUC-core-ALPHA1-3.tab \
 	     link-by-torsion-to-pyranose-core-ALPHA1-6.tab \
 	     link-by-torsion-to-pyranose-core-ALPHA2-3.tab \
 	     link-by-torsion-to-pyranose-core-BETA1-3.tab  \
 	     link-by-torsion-to-pyranose-core-BETA1-4.tab  \
              link-by-torsion-to-pyranose-core-NAG-ASN.tab  \
+	     link-by-torsion-to-pyranose-core-XYP-BMA.tab  \
              NAG-decorations.tab \
              BMA-decorations.tab \
              MAN-decorations.tab \
              GLC-decorations.tab \
              GAL-decorations.tab \
              FUC-decorations.tab \
+             XYP-decorations.tab \
 	     theor-helix-70.pdb
 
 subpkgdatadir = $(pkgdatadir)
diff -ruN coot-0.8.7/pdb-templates/Makefile.in coot-0.8.8-pre/pdb-templates/Makefile.in
--- coot-0.8.7/pdb-templates/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/pdb-templates/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -40,6 +40,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -175,6 +178,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -311,17 +315,20 @@
 	     SIA-pyranose-via-ALPHA2-3.pdb      \
 	     link-by-torsion-to-pyranose-core-ALPHA1-2.tab \
 	     link-by-torsion-to-pyranose-core-ALPHA1-3.tab \
+	     link-by-torsion-to-FUC-core-ALPHA1-3.tab \
 	     link-by-torsion-to-pyranose-core-ALPHA1-6.tab \
 	     link-by-torsion-to-pyranose-core-ALPHA2-3.tab \
 	     link-by-torsion-to-pyranose-core-BETA1-3.tab  \
 	     link-by-torsion-to-pyranose-core-BETA1-4.tab  \
              link-by-torsion-to-pyranose-core-NAG-ASN.tab  \
+	     link-by-torsion-to-pyranose-core-XYP-BMA.tab  \
              NAG-decorations.tab \
              BMA-decorations.tab \
              MAN-decorations.tab \
              GLC-decorations.tab \
              GAL-decorations.tab \
              FUC-decorations.tab \
+             XYP-decorations.tab \
 	     theor-helix-70.pdb
 
 subpkgdatadir = $(pkgdatadir)
diff -ruN coot-0.8.7/pdb-templates/XYP-decorations.tab coot-0.8.8-pre/pdb-templates/XYP-decorations.tab
--- coot-0.8.7/pdb-templates/XYP-decorations.tab	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/pdb-templates/XYP-decorations.tab	2016-12-21 05:34:30.000000000 -0800
@@ -0,0 +1,3 @@
+   atom O2B O based-on 0 C2B 0 C1B 1 O2  bond-length: 1.43971 angle: 109.97759 tors:  -73.
+   atom O3B O based-on 0 C3B 0 C2B 0 C1B bond-length: 1.43495 angle: 109.14116 tors: -172.
+   atom O4B O based-on 0 C4B 0 C3B 0 C2B bond-length: 1.44418 angle: 108.20904 tors: 169.
diff -ruN coot-0.8.7/pdb-templates/link-by-torsion-to-FUC-core-ALPHA1-3.tab coot-0.8.8-pre/pdb-templates/link-by-torsion-to-FUC-core-ALPHA1-3.tab
--- coot-0.8.7/pdb-templates/link-by-torsion-to-FUC-core-ALPHA1-3.tab	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/pdb-templates/link-by-torsion-to-FUC-core-ALPHA1-3.tab	2016-12-21 05:34:30.000000000 -0800
@@ -0,0 +1,6 @@
+   atom C1 C based-on 1 O3 1 C3 1 C2 bond-length: 1.43725 angle: 109.74604 tors: -100.
+   atom C2 C based-on 0 C1 1 O3 1 C3 bond-length: 1.52044 angle: 107.76593 tors:  168.
+   atom C3 C based-on 0 C2 0 C1 1 O3 bond-length: 1.52094 angle: 108.22451 tors:   65.
+   atom C4 C based-on 0 C3 0 C2 0 C1 bond-length: 1.52374 angle: 108.62584 tors:   53.
+   atom C5 C based-on 0 C4 0 C3 0 C2 bond-length: 1.52583 angle: 109.69168 tors:  -55.
+   atom O5 O based-on 0 C5 0 C4 0 C3 bond-length: 1.41358 angle: 109.97146 tors:  -57.
diff -ruN coot-0.8.7/pdb-templates/link-by-torsion-to-pyranose-core-XYP-BMA.tab coot-0.8.8-pre/pdb-templates/link-by-torsion-to-pyranose-core-XYP-BMA.tab
--- coot-0.8.7/pdb-templates/link-by-torsion-to-pyranose-core-XYP-BMA.tab	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/pdb-templates/link-by-torsion-to-pyranose-core-XYP-BMA.tab	2016-12-21 05:34:30.000000000 -0800
@@ -0,0 +1,7 @@
+# atom names for XYP beta-D-xylopyranose
+   atom C1B C based-on 1  O2 1  C2 1  C1 bond-length: 1.54960 angle: 117.90639 tors: -106.
+   atom C2B C based-on 0 C1B 1  O2 1  C2 bond-length: 1.53896 angle: 114.71917 tors:  161.
+   atom C3B C based-on 0 C2B 0 C1B 1  O2 bond-length: 1.52793 angle: 111.16498 tors:  166.
+   atom C4B C based-on 0 C3B 0 C2B 0 C1B bond-length: 1.52411 angle: 112.18610 tors:  -52.
+   atom C5B C based-on 0 C4B 0 C3B 0 C2B bond-length: 1.52936 angle: 109.83957 tors:   50.
+   atom O5B O based-on 0 C5B 0 C4B 0 C3B bond-length: 1.39994 angle: 111.50530 tors:  -52.
diff -ruN coot-0.8.7/pixmaps/Makefile.in coot-0.8.8-pre/pixmaps/Makefile.in
--- coot-0.8.7/pixmaps/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/pixmaps/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -62,6 +62,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -237,6 +240,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/pixmaps/icons/Makefile.in coot-0.8.8-pre/pixmaps/icons/Makefile.in
--- coot-0.8.7/pixmaps/icons/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/pixmaps/icons/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -39,6 +39,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -151,6 +154,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/protein_db/Makefile.in coot-0.8.8-pre/protein_db/Makefile.in
--- coot-0.8.7/protein_db/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/protein_db/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -61,6 +61,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -224,6 +227,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/pyrogen/Makefile.in coot-0.8.8-pre/pyrogen/Makefile.in
--- coot-0.8.7/pyrogen/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/pyrogen/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -68,6 +68,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -291,6 +294,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/pyrogen/coot_git.py coot-0.8.8-pre/pyrogen/coot_git.py
--- coot-0.8.7/pyrogen/coot_git.py	2016-11-08 07:55:30.000000000 -0800
+++ coot-0.8.8-pre/pyrogen/coot_git.py	2017-01-25 14:39:13.000000000 -0800
@@ -1,2 +1,2 @@
 def revision_count():
-    return  6498
+    return  6603
diff -ruN coot-0.8.7/python/Makefile.in coot-0.8.8-pre/python/Makefile.in
--- coot-0.8.7/python/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/python/Makefile.in	2017-01-25 14:39:06.000000000 -0800
@@ -60,6 +60,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -195,6 +198,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/python/contact_score_isolated_ligand.py coot-0.8.8-pre/python/contact_score_isolated_ligand.py
--- coot-0.8.7/python/contact_score_isolated_ligand.py	2016-04-01 10:50:24.000000000 -0700
+++ coot-0.8.8-pre/python/contact_score_isolated_ligand.py	2016-12-21 05:34:30.000000000 -0800
@@ -1,4 +1,6 @@
 
+# this function is not at startup?
+
 def deactivate_molecules_except(imol):
     for i in model_molecule_list():
         if (i != imol):
@@ -33,15 +35,17 @@
 
     write_pdb_file(imol_selection, ligand_selection_pdb)
     write_pdb_file(imol, protein_selection_pdb)
-    popen_command(probe_command, ["-q", "-u", "-once", # -once or -both
+
+    args = ["-q", "-unformated", "-once", # -once or -both
+                                  # "-outside", # crashes probe
                                   # first pattern
                                   "CHAIN" + chain_id + " " + str(res_no),
                                   # second pattern
                                   "not " + str(res_no),
                                   # consider og33 (occ > 0.33)
-                                  "-density30",
-                                  ligand_selection_pdb, protein_selection_pdb],
-                  [], dots_file_name, False)
+                                  "-density50",
+                                  ligand_selection_pdb, protein_selection_pdb]
+    popen_command(probe_command, args, [], dots_file_name, False)
 
     # debugging!?
     handle_read_draw_probe_dots_unformatted(dots_file_name, imol, 0)
@@ -55,4 +59,25 @@
     with UsingActiveAtom() as [aa_imol, aa_chain_id, aa_res_no,
                                aa_ins_code, aa_atom_name, aa_alt_conf]:
         contact_score_ligand(aa_imol, [aa_chain_id, aa_res_no, aa_ins_code])
-        
+
+def coot_contact_dots_ligand_func():
+    with UsingActiveAtom() as [aa_imol, aa_chain_id, aa_res_no,
+                               aa_ins_code, aa_atom_name, aa_alt_conf]:
+        coot_contact_dots_for_ligand_py(aa_imol, [aa_chain_id, aa_res_no, aa_ins_code])
+
+# not ready for public yet
+def coot_all_atom_contact_dots_func():
+    
+    with UsingActiveAtom() as [aa_imol, aa_chain_id, aa_res_no,
+                               aa_ins_code, aa_atom_name, aa_alt_conf]:
+
+        coot_probe_object_names = ['wide-contact', 'close-contact', 'small-overlap',
+                                   'big-overlap', 'H-bond', 'clashes']
+        n = number_of_generic_objects()
+        for i in range(n):
+           if generic_object_name(i) in coot_probe_object_names:
+              close_generic_object(i)
+           else:
+               print generic_object_name(i), "is not in", coot_probe_object_names
+        coot_all_atom_contact_dots(aa_imol)
+
diff -ruN coot-0.8.7/python/coot_gui.py coot-0.8.8-pre/python/coot_gui.py
--- coot-0.8.7/python/coot_gui.py	2016-09-09 09:43:24.000000000 -0700
+++ coot-0.8.8-pre/python/coot_gui.py	2017-01-24 09:37:54.000000000 -0800
@@ -4422,7 +4422,7 @@
    global additional_solvent_ligands
    return (additional_solvent_ligands +
            ["EDO", "GOL", "DMS", "ACT", "MPD", "CIT", "SO4", "PO4", "TRS",
-            "TAM"])
+            "TAM", "PG4"])
 
 # add solvent molecules
 #
diff -ruN coot-0.8.7/python/coot_utils.py coot-0.8.8-pre/python/coot_utils.py
--- coot-0.8.7/python/coot_utils.py	2016-09-16 05:53:12.000000000 -0700
+++ coot-0.8.8-pre/python/coot_utils.py	2017-01-23 10:30:04.000000000 -0800
@@ -3225,12 +3225,12 @@
             mol_name = parse_wiki_drug_xml(xml_tree, "DrugBank  *= ")
 
             if not isinstance(mol_name, str):
-                print "BL WARNING:: mol_name not a string (DrugBank entry from wikipedia)", mol_name
+                print "WARNING:: mol_name not a string (DrugBank entry from wikipedia)", mol_name
                 # try pubchem as fallback
                 mol_name = parse_wiki_drug_xml(xml_tree,  "PubChem  *= ")
                 if not isinstance(mol_name, str):
 
-                    print "BL WARNING:: mol_name not a string (pubchem entry either)", mol_name
+                    print "WARNING:: mol_name not a string (pubchem entry either)", mol_name
                     # so was there a redirect?
                     # if so, get the name and call get_drug_via_wikipedia with it
                     redirected_drug_name = get_redirected_drug_name(xml_tree)
@@ -3250,7 +3250,7 @@
                     coot_get_url(pc_mol_uri, file_name)
                     
             else:
-                db_mol_uri = "http://www.drugbank.ca/structures/structures/small_molecule_drugs/" + \
+                db_mol_uri = "https://www.drugbank.ca/structures/small_molecule_drugs/" + \
                              mol_name + ".mol"
                 file_name = mol_name + ".mol"
                 coot_get_url(db_mol_uri, file_name)
diff -ruN coot-0.8.7/python/gui_add_linked_cho.py coot-0.8.8-pre/python/gui_add_linked_cho.py
--- coot-0.8.7/python/gui_add_linked_cho.py	2016-03-18 05:57:22.000000000 -0700
+++ coot-0.8.8-pre/python/gui_add_linked_cho.py	2017-01-13 09:52:23.000000000 -0800
@@ -26,6 +26,8 @@
     add_pyranose_pseudo_ring_plane_restraints("MAN")
     add_pyranose_pseudo_ring_plane_restraints("GAL")
     add_pyranose_pseudo_ring_plane_restraints("GLC")
+    add_pyranose_pseudo_ring_plane_restraints("XYP")
+    add_pyranose_pseudo_ring_plane_restraints("FUC")
 
 
 def multi_add_linked_residue(imol, res_spec, residues_to_add):
@@ -102,6 +104,18 @@
            ]
     return ret
 
+def paucimannose_tree():
+    ret = [["NAG-ASN", "NAG"],
+           [  ["ALPHA1-3", "FUC"] ],
+           [  ["BETA1-4", "NAG"],
+              ["BETA1-4", "BMA"],
+              [ ["XYP-BMA",  "XYP"] ],
+              [ ["ALPHA1-3", "MAN"] ],
+              [ ["ALPHA1-6", "MAN"] ]
+           ]
+           ]
+    return ret
+
 # now can be user defined
 global add_linked_residue_tree_correlation_cut_off
 add_linked_residue_tree_correlation_cut_off = 0.6
@@ -147,8 +161,13 @@
 
             centre_view_on_residue_centre(parent)
 
-            print "BL DEBUG:: ============== calling add_linked_residue with args", imol, new_res_type, new_link
-
+            active_atom = active_residue_py()
+            active_residue = active_atom[:4]
+            save_residue_specs = glyco_tree_residues_py(imol, active_residue)
+
+            imol_glyco_pre = new_molecule_by_residue_specs_py(imol, save_residue_specs)
+            set_mol_displayed(imol_glyco_pre, 0)
+            set_mol_active(imol_glyco_pre, 0)
             new_res_spec = add_linked_residue(imol,
                                               res_spec2chain_id(parent),
                                               res_spec2res_no(parent),
@@ -159,17 +178,21 @@
             local_ls = [parent] + ls
             with AutoAccept():
                 refine_residues(imol, local_ls)
+            # make this optional
+            rotate_y_scene(200, 0.5)
             if (not isinstance(new_res_spec, list)):
                 # badness
                 return False
             else:
-                # okey!?
+                # okay!?
                 preped_new_res_spec = new_res_spec[1:]  # strip off leading result
                 if well_fitting_qm(preped_new_res_spec):
+                    # close_molecule(imol_glyco_pre)
                     return preped_new_res_spec
                 else:
                     print "----------- That was not well fitting. Deleting:", preped_new_res_spec
                     delete_residue_by_spec(preped_new_res_spec)
+                    replace_residues_from_mol_py(imol, imol_glyco_pre, save_residue_specs)
                     with AutoAccept():
                         # Note: may not get rid of screwed up refinement from
                         # adding a carb too much...
@@ -189,7 +212,7 @@
                     break
             else:
                 if isinstance(branch, list):
-                    process_tree(parent, branch, proc_func)                    
+                    process_tree(parent, branch, proc_func)
 
     # main line of add_linked_residue_tree
     #
@@ -205,7 +228,173 @@
     except:
         print "BL INFO:: not changing default B for new carb atoms"
     process_tree(parent, tree, func)
+    g = glyco_validate()
+    g.auto_delete_residues()
+    # reset
     set_default_temperature_factor_for_new_atoms(previous_m)
+
+
+def delete_glyco_tree():
+    
+    active_atom = active_residue_py()
+    try:
+        imol = active_atom[0]
+        active_residue = active_atom[:4]
+        print "active_residue", active_residue
+        glyco_tree_residues = glyco_tree_residues_py(imol, active_residue)
+        print active_residue
+        print "glyco_tree_residues", glyco_tree_residues
+        for res in glyco_tree_residues:
+            rn = residue_name_by_spec(imol, res)
+            if rn != "ASN":
+                delete_residue_by_spec(imol, res)
+    except KeyError as e:
+        print e
+    except TypeError as e:
+        print e
+
+# this has to be at the top level for reasons that I don't understand
+# (python function scoping) - I'll just put it down to python being shit as usual.
+#
+def glyco_validation_dialog_set_go_to_residue(imol, residue_spec):
+    rc = residue_centre(imol,
+                        res_spec_utils.residue_spec_to_chain_id(residue_spec),
+                        res_spec_utils.residue_spec_to_res_no(residue_spec),
+                        '')
+    set_rotation_centre(*rc)
+
+def load_privateer_dictionary():
+    if os.path.exists("privateer-lib.cif"):
+        read_cif_dictionary("privateer-lib.cif")
+        set_refine_with_torsion_restraints(1)
+    
+class glyco_validate:
+
+    def run_privateer(self, imol, glyco_tree_residues, hklin_fn, fp_col, sigfp_col, pdbin_fn, privateer_log):
+        if is_valid_model_molecule(imol):
+            args = ['-mtzin', hklin_fn, '-colin-fo', fp_col+','+sigfp_col,
+                    '-pdbin', pdbin_fn]
+            # using'-mode', 'ccp4i2' makes a file with no residue nambers (afaics)
+            popen_command("privateer", args, [], privateer_log, False)
+
+    def make_privateer_validation_info(self, imol, fp_col, sigfp_col, glyco_tree_residues):
+
+        imol_map = imol_refinement_map()
+
+        if len(glyco_tree_residues) > 0:
+            d = get_directory("coot-ccp4")
+            spid = str(os.getpid())
+            fn_pdb = "coot-privateer-" + spid + ".pdb"
+            fn_log = "coot-privateer-" + spid + ".log"
+            privateer_pdb = os.path.join(d, fn_pdb)
+            privateer_log = os.path.join(d, fn_log)
+            hklin_fn = mtz_file_name(imol_map);
+            write_pdb_file(imol, privateer_pdb)
+            self.run_privateer(imol, glyco_tree_residues, hklin_fn, fp_col, sigfp_col, privateer_pdb, privateer_log)
+            pvi = self.parse_privateer_log(privateer_log, imol, glyco_tree_residues)
+            return pvi
+        else:
+            return []
+
+    # return a list of residues with privateer validation info
+    #
+    def parse_privateer_log(self, log_file_name, imol, glyco_tree_residues):
+
+        print 'parse_privateer_log', log_file_name, imol, glyco_tree_residues
+
+        pvi = []
+        f = open(log_file_name)
+        lines = f.readlines()
+        for line in lines:
+            l = line.rstrip()
+            if len(l) > 10:
+                if l[:4] == 'coot':
+                    words = l.split()
+                    if len(words) > 12:
+                        for r in glyco_tree_residues:
+                            rn = residue_name_by_spec(imol, r)
+                            try:
+                                res_id = rn + "-" + res_spec_utils.residue_spec_to_chain_id(r) + \
+                                         '-' + str(res_spec_utils.residue_spec_to_res_no(r))
+                                # print "res_id", res_id
+                                if words[1] == res_id:
+                                    # print words[12] , yes or check
+                                    new_item = (r, words)
+                                    pvi.append(new_item)
+                            except TypeError as e:
+                                print e
+        print "parsed", log_file_name
+        return pvi
+
+    def make_validation_dialog(self, imol, privateer_validation_info):
+
+        print "make_validation_dialog", privateer_validation_info
+        buttons = []
+        for vi in privateer_validation_info:
+            residue_spec = vi[0]
+            words = vi[1]
+            state = words[12]
+            if state == "yes":
+                state = " OK  " # label spacing
+            button_text = words[1] + "   Q=" + words[3] + " RSCC=" + words[6] + \
+                          " Cnf=" + words[8] + "   " + state
+            # string->function? Hideous
+            func = "glyco_validation_dialog_set_go_to_residue(" + str(imol) + "," + \
+                   str(residue_spec) + ")"
+            button = [button_text, func]
+            buttons.append(button)
+        if len(buttons) > 0:
+            button = ["Load Privateer Dictionary", "load_privateer_dictionary()"]
+            buttons.append(button)
+            dialog_box_of_buttons("Privateer Validation", (400, 220), buttons, " Close ")
+
+    def validation_dialog(self):
+        
+        active_atom = active_residue_py()
+        try:
+            imol = active_atom[0]
+            active_residue = active_atom[:4]
+            glyco_tree_residues = glyco_tree_residues_py(imol, active_residue)
+
+            print 'imol', imol
+            print 'active_residue', active_residue
+            print 'glyco_tree_residues', glyco_tree_residues
+
+            fp_col='FP'
+            sigfp_col='SIGFP'    
+            pvi = self.make_privateer_validation_info(imol, fp_col, sigfp_col, glyco_tree_residues)
+            # print "validation_dialog()", pvi
+            if len(pvi) > 0:
+                # now make a gui
+                self.make_validation_dialog(imol, pvi)
+
+        except KeyError as e:
+            print e
+
+        # no active atom
+        except TypeError as e:
+            print e
+
+    def auto_delete_residues_internal(self, imol, glyco_tree_residues):
+        fp_col='FP'
+        sigfp_col='SIGFP'
+        pvi = self.make_privateer_validation_info(imol, fp_col, sigfp_col, glyco_tree_residues)
+        for res_info in pvi:
+            print "test", res_info
+            res_status = res_info[1][12]
+            if res_status == 'check' or res_status == 'no':
+                delete_residue_by_spec(imol, res_info[0])
+
+    def auto_delete_residues(self):
+        try:
+            active_atom = active_residue_py()
+            imol = active_atom[0]
+            active_residue = active_atom[:4]
+            glyco_tree_residues = glyco_tree_residues_py(imol, active_residue)
+            self.auto_delete_residues_internal(imol, glyco_tree_residues)
+        except TypeError as e:
+            print e
+    
             
 # graphics...
 
@@ -260,9 +449,17 @@
                 lambda func: add_carbo_link_func("MAN", "ALPHA1-6"))
 
             add_simple_coot_menu_menuitem(
+                menu, "Add an ALPHA1-3 FUC",
+                lambda func: add_carbo_link_func("FUC", "ALPHA1-3"))
+
+            add_simple_coot_menu_menuitem(
                 menu, "Add an ALPHA1-6 FUC",
                 lambda func: add_carbo_link_func("FUC", "ALPHA1-6"))
 
+            add_simple_coot_menu_menuitem(
+                menu, "Add an XYP-BMA XYP",
+                lambda func: add_carbo_link_func("XYP", "XYP-BMA"))
+
             def add_multi_carbo_link_func(link_list):
                 with UsingActiveAtom() as [aa_imol, aa_chain_id, aa_res_no,
                                            aa_ins_code, aa_atom_name, aa_alt_conf]:
@@ -284,7 +481,6 @@
                 menu, "Auto Fit & Refine Off for Link Addition",
                 lambda func: set_add_linked_residue_do_fit_and_refine(0))
 
-
             def add_oligo_mannose_func():
                 with UsingActiveAtom() as [aa_imol, aa_chain_id, aa_res_no,
                                            aa_ins_code, aa_atom_name, aa_alt_conf]:
@@ -294,11 +490,23 @@
                                             [aa_chain_id, aa_res_no, aa_ins_code],
                                             oligomannose_tree())
                 
+            def add_paucimannose_func():
+                with UsingActiveAtom() as [aa_imol, aa_chain_id, aa_res_no,
+                                           aa_ins_code, aa_atom_name, aa_alt_conf]:
+                    make_backup(aa_imol)
+                    # switch backup off?!
+                    add_linked_residue_tree(aa_imol,
+                                            [aa_chain_id, aa_res_no, aa_ins_code],
+                                            paucimannose_tree())
+
             add_simple_coot_menu_menuitem(
                 menu, "Add Oligomannose",
                 lambda func: add_oligo_mannose_func())
 
-            
+            add_simple_coot_menu_menuitem(
+                menu, "Add Paucimannose",
+                lambda func: add_paucimannose_func())
+
             def torsion_fit_this_func(refine = False):
                 with UsingActiveAtom() as [aa_imol, aa_chain_id, aa_res_no,
                                            aa_ins_code, aa_atom_name, aa_alt_conf]:
@@ -309,11 +517,26 @@
                     if refine:
                         with AutoAccept():
                             refine_residues(aa_imol, [centre_residue])
+
+            def torsion_fit_this_and_neighbours_func(refine = False):
+                with UsingActiveAtom() as [aa_imol, aa_chain_id, aa_res_no,
+                                           aa_ins_code, aa_atom_name, aa_alt_conf]:
+                    centre_residue = [aa_chain_id,aa_res_no, aa_ins_code]
+                    residues = residues_near_residue(aa_imol, centre_residue, 1.9)
+                    residues.append(centre_residue)
+                    multi_residue_torsion_fit(aa_imol, residues, 30000)
+                    if refine:
+                        with AutoAccept():
+                            refine_residues(aa_imol, [centre_residue])
                 
             add_simple_coot_menu_menuitem(
                 menu, "Torsion Fit this residue",
                 lambda func: torsion_fit_this_func())
 
+            add_simple_coot_menu_menuitem(
+                menu, "Torsion Fit This Residue and Neighbours",
+                lambda func: torsion_fit_this_and_neighbours_func())
+
 
             add_simple_coot_menu_menuitem(
                 menu, "Torsion Fit & Refine this residue",
@@ -323,10 +546,3 @@
                 menu, "Add synthetic pyranose plane restraints",
                 lambda func: add_synthetic_carbohydrate_planes())
 
-            
-            
-
-            
-                                       
-            
-    
diff -ruN coot-0.8.7/python/gui_contact_score_isolated_ligand.py coot-0.8.8-pre/python/gui_contact_score_isolated_ligand.py
--- coot-0.8.7/python/gui_contact_score_isolated_ligand.py	2016-04-01 11:00:48.000000000 -0700
+++ coot-0.8.8-pre/python/gui_contact_score_isolated_ligand.py	2016-12-21 05:34:30.000000000 -0800
@@ -1,5 +1,13 @@
 
 
 add_simple_coot_menu_menuitem(coot_menubar_menu("Ligand"),
-			      "Isolated dots for this ligand",
+			      "Isolated Molprobity Dots for this Ligand",
                               lambda func: contact_score_ligand_func())
+
+add_simple_coot_menu_menuitem(coot_menubar_menu("Ligand"),
+                              "Isolated Coot Ligand Dots for this Ligand",
+                              lambda func: coot_contact_dots_ligand_func())
+
+add_simple_coot_menu_menuitem(coot_menubar_menu("Ligand"),
+                              "Coot All-Atom Contact Dots",
+                              lambda func: coot_all_atom_contact_dots_func())
diff -ruN coot-0.8.7/python-tests/Makefile.in coot-0.8.8-pre/python-tests/Makefile.in
--- coot-0.8.7/python-tests/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/python-tests/Makefile.in	2017-01-25 14:39:05.000000000 -0800
@@ -39,6 +39,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -151,6 +154,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/rama-data/Makefile.in coot-0.8.8-pre/rama-data/Makefile.in
--- coot-0.8.7/rama-data/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/rama-data/Makefile.in	2017-01-25 14:39:06.000000000 -0800
@@ -60,6 +60,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -195,6 +198,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/rcrane/Makefile.in coot-0.8.8-pre/rcrane/Makefile.in
--- coot-0.8.7/rcrane/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/rcrane/Makefile.in	2017-01-25 14:39:06.000000000 -0800
@@ -60,6 +60,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -196,6 +199,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/scheme/Makefile.in coot-0.8.8-pre/scheme/Makefile.in
--- coot-0.8.7/scheme/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/scheme/Makefile.in	2017-01-25 14:39:06.000000000 -0800
@@ -41,6 +41,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -176,6 +179,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/scheme/contact-score-isolated-ligand.scm coot-0.8.8-pre/scheme/contact-score-isolated-ligand.scm
--- coot-0.8.7/scheme/contact-score-isolated-ligand.scm	2016-09-01 17:13:24.000000000 -0700
+++ coot-0.8.8-pre/scheme/contact-score-isolated-ligand.scm	2016-12-21 05:34:30.000000000 -0800
@@ -85,7 +85,7 @@
 (if (defined? 'coot-main-menubar)
     (let ((menu (coot-menubar-menu "Ligand")))
       (add-simple-coot-menu-menuitem 
-       menu "Isolated dots for this ligand"
+       menu "Isolated Molprobity dots for this ligand"
        (lambda ()
         (using-active-atom
 	   (contact-score-ligand aa-imol (list aa-chain-id aa-res-no aa-ins-code)))))))
diff -ruN coot-0.8.7/scheme/coot-gui.scm coot-0.8.8-pre/scheme/coot-gui.scm
--- coot-0.8.7/scheme/coot-gui.scm	2016-01-28 11:46:52.000000000 -0800
+++ coot-0.8.8-pre/scheme/coot-gui.scm	2017-01-24 09:37:54.000000000 -0800
@@ -2983,7 +2983,7 @@
 (define *solvent-ligand-list* 
   (append
    *additional-solvent-ligands*
-   (list "EDO" "GOL" "DMS" "ACT" "MPD" "CIT" "SO4" "PO4" "TRS" "TAM")))
+   (list "EDO" "GOL" "DMS" "ACT" "MPD" "CIT" "SO4" "PO4" "TRS" "TAM" "PG4")))
 
 (define *random-jiggle-n-trials* 50)
 
diff -ruN coot-0.8.7/scheme/coot-utils.scm coot-0.8.8-pre/scheme/coot-utils.scm
--- coot-0.8.7/scheme/coot-utils.scm	2016-09-16 05:53:12.000000000 -0700
+++ coot-0.8.8-pre/scheme/coot-utils.scm	2017-01-13 09:52:23.000000000 -0800
@@ -3112,7 +3112,7 @@
 		   (if curl-info
 		       (let ((v1 (assoc 'content-length-download curl-info))
 			     (v2 (assoc 'size-download           curl-info)))
-			 (if (list v1)
+			 (if (list v1)  ;; Do I mean "list?"?
 			     (if (list v2)
 				 (let ((f (/ (cdr v2) (cdr v1))))
 				   (format #t "~3,2f% " (* f 100))
@@ -3380,14 +3380,13 @@
     (let ((i (drugbox->drugitem "PubChem  *=" s)))
       (format #t "in drugbox->pubchem i: ~s~%" i)
       i))
-      
-	
+
   (define (drugbox->chemspider s)
     (let ((i (drugbox->drugitem "ChemSpiderID  *=" s)))
       (format #t "in drugbox->chemspider i: ~s~%" i)
       i))
 
-	
+
 
   ;; With some clever coding, these handle-***-value functions could
   ;; be consolidated.  There is likely something clever in Python to
@@ -3424,7 +3423,7 @@
 			;; try pubchem as a fallback
 			(let ((pc (drugbox->pubchem rev-string)))
 			  (if (not (string? pc))
-			      
+
 			      ;; OK, try chemspider extraction
 			      (let ((cs (drugbox->chemspider rev-string)))
 				(if (not (string? cs))
@@ -3466,7 +3465,7 @@
 					 "http://www.drugbank.ca/structures/structures/small_molecule_drugs/" 
 					 dbi ".mol"))
 			    (file-name (string-append dbi ".mol")))
-			;; (format #t "getting url: ~s~%" db-mol-uri)
+			(format #t "getting drugbank url: ~s ~s~%" db-mol-uri file-name)
 			(coot-get-url db-mol-uri file-name)
 			file-name)))))))
 
@@ -3476,33 +3475,50 @@
 
   (define (handle-rev-string-2016 rev-string)
     (let ((lines (string-split rev-string #\newline)))
-      (let ((db-id #f))
-	(for-each (lambda (line)
-		    (if (string-match "DrugBank = " line)
-			(let ((parts (string->list-of-strings line)))
-			  (if (> (length parts) 3)
-			      (set! db-id (list-ref parts 3)))))
-		    ;; match other databases here
-		    )
-		  lines)
-
-	(format #t "db-id: ~s~%" db-id)
-
-	;; check an association-list for the "DrugBank" entry
-	;; 
-	(if (string? db-id)
-
-	    ;; normal path hopefully
-	    ;; 
-	    (let ((db-mol-uri (string-append 
-			       "http://www.drugbank.ca/structures/structures/small_molecule_drugs/" 
-			       db-id ".mol"))
-		  (file-name (string-append db-id ".mol")))
-	      (format #t "getting url: ~s~%" db-mol-uri)
-	      (coot-get-url db-mol-uri file-name)
-	      file-name)
 
-	    #f))))
+      (cond 
+       ((= (length lines) 1)
+	(let* ((line (car lines))
+	       (open-match (string-match "#[Rr][Ee][Dd][Ii][Rr][Ee][Cc][Tt] \\[\\[" line)))
+	  (if open-match
+	      (let ((close-match (string-match "\\]\\]" line)))
+		(if close-match
+		    (begin
+; 				  (format #t "-----------:  open-match ~%" open-match)
+; 				  (format #t "-----------: close-match ~%" close-match)
+; 				  (format #t "-----------: line ~%" line)
+		      (let ((s (substring line 12 (car (vector-ref close-match 1)))))
+			(get-drug-via-wikipedia s)))))))) ;; returns a file anme
+
+       (else
+	(let ((db-id #f)) ;; drugbank-id e.g. DB01098
+	  (for-each (lambda (line)
+		      (if (string-match "DrugBank = " line)
+			  (let ((parts (string->list-of-strings line)))
+			    (if (> (length parts) 3)
+				(set! db-id (list-ref parts 3)))))
+		      ;; match other databases here
+		      )
+		    lines)
+
+	  (format #t "DEBUG:: handle-rev-string-2016: db-id: ~s~%" db-id)
+	  
+	  ;; check an association-list for the "DrugBank" entry
+	  ;; 
+	  (if (string? db-id)
+
+	      ;; normal path hopefully
+	      ;; 
+	      (let ((db-mol-uri (string-append
+				 ;; "http://www.drugbank.ca/structures/structures/small_molecule_drugs/"
+				 "https://www.drugbank.ca/structures/small_molecule_drugs/"
+				 db-id ".mol"))
+		    (file-name (string-append db-id ".mol")))
+		(format #t "DEBUG:: handle-rev-string-2016: getting url: ~s to file ~s~%" db-mol-uri file-name)
+		(coot-get-url db-mol-uri file-name)
+		file-name)
+ 
+	      #f))))))
 
 
   (define (handle-sxml-rev-value sxml)
@@ -3617,7 +3633,7 @@
 
 
   ;; main line
-
+  ;;
   (if (string? drug-name-in)
       (if (> (string-length drug-name-in) 0)
 	  ;; we need to downcase the drug name for wikipedia
@@ -3631,15 +3647,27 @@
 		 (xml (coot-get-url-as-string url)))
 
 	    (format #t "INFO:: get-drug-via-wikipedia: url: ~s~%" url)
+	    (let ((l (string-length xml)))
+
+	      (if (= l 0)
+		  ;; something bad happened - wikipedia replied with an empty string
+		  (begin
+		    (format #t "INFO:: Badness - wikipedia replied with an empty string~%"))
+
+		  (begin
+		    (call-with-output-file (string-append drug-name ".xml")
+		      (lambda (port)
+			(display xml port)))
+
+		    ;;
+		    (let ((captured (call-with-input-string
+				     xml (lambda (string-port)
+					   (let ((sxml (xml->sxml string-port)))
+					     (handle-sxml sxml))))))
+		      captured))))))))
+
 
-	    (call-with-output-file (string-append drug-name ".xml")
-	      (lambda (port)
-		(display xml port)))
-
-	    (call-with-input-string
-	     xml (lambda (string-port)
-		   (let ((sxml (xml->sxml string-port)))
-		     (handle-sxml sxml))))))))
+;; --------------------------------------------------------
 
 
 (define (get-SMILES-for-comp-id-from-pdbe comp-id)
diff -ruN coot-0.8.7/scheme/gui-add-linked-cho.scm coot-0.8.8-pre/scheme/gui-add-linked-cho.scm
--- coot-0.8.7/scheme/gui-add-linked-cho.scm	2016-09-01 17:13:24.000000000 -0700
+++ coot-0.8.8-pre/scheme/gui-add-linked-cho.scm	2016-12-21 05:34:30.000000000 -0800
@@ -118,6 +118,15 @@
 			       (("ALPHA1-2" . "MAN")
 				(("ALPHA1-2" . "MAN"))))))))
 
+(define paucimannose-tree '(("NAG-ASN" . "NAG")
+			    (("ALPHA1-3" . "FUC"))
+			    (("BETA1-4" . "NAG")
+			     (("BETA1-4" . "BMA")
+			      (("ALPHA1-6" . "MAN"))
+			      (("ALPHA1-3" . "MAN"))
+			      (("XYP-BMA"  . "XYP"))))))
+
+
 ;(define oligomannose-tree '(("NAG-ASN" . "NAG")
 ;			    (("BETA1-4" . "NAG")
 ;			     (("BETA1-4" . "BMA")
@@ -327,6 +336,13 @@
 	    (add-linked-residue aa-imol aa-chain-id aa-res-no aa-ins-code "MAN" "ALPHA1-6"))))
 
 	(add-simple-coot-menu-menuitem
+	 menu "Add an ALPHA1-3 FUC"
+	 (lambda () 
+	   (set-matrix 8)
+	   (using-active-atom
+	    (add-linked-residue aa-imol aa-chain-id aa-res-no aa-ins-code "FUC" "ALPHA1-3"))))
+
+	(add-simple-coot-menu-menuitem
 	 menu "Add an ALPHA1-6 FUC"
 	 (lambda () 
 	   (set-matrix 8)
@@ -334,6 +350,13 @@
 	    (add-linked-residue aa-imol aa-chain-id aa-res-no aa-ins-code "FUC" "ALPHA1-6"))))
 
 	(add-simple-coot-menu-menuitem
+	 menu "Add an XYP-BMA XYP"
+	 (lambda () 
+	   (set-matrix 8)
+	   (using-active-atom
+	    (add-linked-residue aa-imol aa-chain-id aa-res-no aa-ins-code "XYP" "XYP-BMA"))))
+
+	(add-simple-coot-menu-menuitem
 	 menu "N-link add NAG, NAG, BMA"
 	 (lambda ()
 	   (using-active-atom
@@ -367,6 +390,16 @@
 				     oligomannose-tree))))
 
 	(add-simple-coot-menu-menuitem
+	 menu "Add Paucimannose"
+	 (lambda ()
+	   (using-active-atom
+	    (make-backup aa-imol)
+	    ;; (with-no-backups aa-imol
+	    (add-linked-residue-tree aa-imol
+				     (list aa-chain-id aa-res-no aa-ins-code)
+				     paucimannose-tree))))
+
+	(add-simple-coot-menu-menuitem
 	 menu "Torsion Fit this residue"
 	 (lambda ()
 	   (using-active-atom
diff -ruN coot-0.8.7/scheme/gui-ligand-sliders.scm coot-0.8.8-pre/scheme/gui-ligand-sliders.scm
--- coot-0.8.7/scheme/gui-ligand-sliders.scm	2016-09-01 17:13:24.000000000 -0700
+++ coot-0.8.8-pre/scheme/gui-ligand-sliders.scm	2017-01-13 09:52:23.000000000 -0800
@@ -28,7 +28,7 @@
      ((number? item) (number->string item))
      ((equal? item #t) "True")
      ((equal? item #f) "False")
-     (else 
+     (else
       "False")))
 
   (let ((string-parts (map item-to-string ls)))
@@ -48,7 +48,7 @@
 	  
 	  ;; unhappy path
 	  (begin 
-	    (format #t "Failed to read columms from file ~s for map molecule ~s~%" fn imol-map)
+	    (format #t "Failed to read columms from file ~s for map molecule ~s~%" file-name imol-map)
 	    (values #f #f #f))
 	  
 	  ;; happy path
@@ -68,7 +68,7 @@
 		  ;; unhappy path
 		  (begin
 		    (format #t "Failed to find columns of the necessary types from ~s : ~s ~s ~s~%~!"
-			    fn l1 l2 l3)
+			    file-name l1 l2 l3)
 		    (values #f #f #f))
 
 		  ;; happy path
diff -ruN coot-0.8.7/scheme/mutate.scm coot-0.8.8-pre/scheme/mutate.scm
--- coot-0.8.7/scheme/mutate.scm	2016-08-11 02:40:08.000000000 -0700
+++ coot-0.8.8-pre/scheme/mutate.scm	2017-01-23 10:30:04.000000000 -0800
@@ -194,7 +194,9 @@
    (else 
     #f)))
 
-
+;; Mutate a residue range of nucleotides
+;; where sequence is a string (for example: "atgccgta")
+;;
 (define (mutate-nucleotide-range imol chain-id resno-start resno-end sequence)
 
   ;; Return #f on unknown letter.  We don't need to be specific about
diff -ruN coot-0.8.7/scheme/redefine-functions.scm coot-0.8.8-pre/scheme/redefine-functions.scm
--- coot-0.8.7/scheme/redefine-functions.scm	2016-07-18 20:00:11.000000000 -0700
+++ coot-0.8.8-pre/scheme/redefine-functions.scm	2016-12-21 05:34:30.000000000 -0800
@@ -10,6 +10,8 @@
 (define water-chain water-chain-scm)
 (define water-chain-from-shelx-ins water-chain-from-shelx-ins-scm)
 (define generic-object-name generic-object-name-scm)
+(define generic-object-is-displayed? generic-object-is-displayed-p)
+(define is-closed-generic-object? is-closed-generic-object-p)
 (define additional-representation-info additional-representation-info-scm)
 (define missing-atom-info missing-atom-info-scm)
 (define key-sym-code key-sym-code-scm)
diff -ruN coot-0.8.7/skeleton/Makefile.in coot-0.8.8-pre/skeleton/Makefile.in
--- coot-0.8.7/skeleton/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/skeleton/Makefile.in	2017-01-25 14:39:06.000000000 -0800
@@ -61,6 +61,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -225,6 +228,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/src/Makefile.am coot-0.8.8-pre/src/Makefile.am
--- coot-0.8.7/src/Makefile.am	2016-11-01 11:06:09.000000000 -0700
+++ coot-0.8.8-pre/src/Makefile.am	2016-12-21 05:34:30.000000000 -0800
@@ -105,6 +105,7 @@
                              $(top_srcdir)/src/coot.i           \
                              $(top_srcdir)/src/lbg-interface.hh \
                              $(top_srcdir)/src/c-interface-ligands-swig.hh \
+			     $(top_srcdir)/src/c-interface-generic-objects.h \
                              $(top_srcdir)/src/sdf-interface.hh \
                              $(top_srcdir)/src/cfc.hh \
                              $(top_srcdir)/src/cmtz-interface.hh \
@@ -322,6 +323,7 @@
         dots-representation.hh   \
 	drag-and-drop.hh         \
 	drag-and-drop.cc         \
+	draw-generic-display-objects.cc \
 	flev.hh			 \
 	flev.cc                  \
 	generic-display-object.hh\
@@ -384,6 +386,7 @@
 	molecule-class-info-maps-2.cc 	\
 	molecule-class-info-kdc.cc      \
 	molecule-class-info-dots.cc 	\
+	molecule-class-info-dots-internal.cc 	\
 	molecule-class-info-other.cc 	\
 	molecule-class-info-build.cc 	\
 	molecule-class-info.h 	        \
diff -ruN coot-0.8.7/src/Makefile.in coot-0.8.8-pre/src/Makefile.in
--- coot-0.8.7/src/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/src/Makefile.in	2017-01-25 14:39:06.000000000 -0800
@@ -76,6 +76,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -159,12 +162,13 @@
 	coot_pythonmodule.cc coot-preferences.h coot-references.h \
 	coot-setup-python.cc coot-setup-python.hh coot-version.hh \
 	coot_wrap_guile.cc dots-representation.hh drag-and-drop.hh \
-	drag-and-drop.cc flev.hh flev.cc generic-display-object.hh \
-	generic-objects.cc generic-display-objects-c.h \
-	geometry-graphs.cc geometry-graphs.hh get-residue.hh \
-	get-residue.cc get-monomer.hh get-monomer.cc gl-bits.hh \
-	globjects.cc globjects.h gl-matrix.h globularize.cc \
-	globularize.hh graphics-info.cc graphics-info-defines.cc \
+	drag-and-drop.cc draw-generic-display-objects.cc flev.hh \
+	flev.cc generic-display-object.hh generic-objects.cc \
+	generic-display-objects-c.h geometry-graphs.cc \
+	geometry-graphs.hh get-residue.hh get-residue.cc \
+	get-monomer.hh get-monomer.cc gl-bits.hh globjects.cc \
+	globjects.h gl-matrix.h globularize.cc globularize.hh \
+	graphics-info.cc graphics-info-defines.cc \
 	graphics-info-graphs.cc graphics-info-gui.cc \
 	graphics-info-modelling.cc graphics-info-navigation.cc \
 	graphics-info-navigation-gtk1.cc \
@@ -184,6 +188,7 @@
 	molecule-class-info.cc molecule-class-info-bonds.cc \
 	molecule-class-info-maps.cc molecule-class-info-maps-2.cc \
 	molecule-class-info-kdc.cc molecule-class-info-dots.cc \
+	molecule-class-info-dots-internal.cc \
 	molecule-class-info-other.cc molecule-class-info-build.cc \
 	molecule-class-info.h molecule-class-info-mutate.cc \
 	molecule-class-info-residues.cc molecule-class-info-refine.cc \
@@ -244,13 +249,13 @@
 	coot-glue-gtk2.$(OBJEXT) coot-glue-gtk2-python.$(OBJEXT) \
 	coot-hydrogens.$(OBJEXT) coot_pythonmodule.$(OBJEXT) \
 	coot-setup-python.$(OBJEXT) coot_wrap_guile.$(OBJEXT) \
-	drag-and-drop.$(OBJEXT) flev.$(OBJEXT) \
-	generic-objects.$(OBJEXT) geometry-graphs.$(OBJEXT) \
-	get-residue.$(OBJEXT) get-monomer.$(OBJEXT) \
-	globjects.$(OBJEXT) globularize.$(OBJEXT) \
-	graphics-info.$(OBJEXT) graphics-info-defines.$(OBJEXT) \
-	graphics-info-graphs.$(OBJEXT) graphics-info-gui.$(OBJEXT) \
-	graphics-info-modelling.$(OBJEXT) \
+	drag-and-drop.$(OBJEXT) draw-generic-display-objects.$(OBJEXT) \
+	flev.$(OBJEXT) generic-objects.$(OBJEXT) \
+	geometry-graphs.$(OBJEXT) get-residue.$(OBJEXT) \
+	get-monomer.$(OBJEXT) globjects.$(OBJEXT) \
+	globularize.$(OBJEXT) graphics-info.$(OBJEXT) \
+	graphics-info-defines.$(OBJEXT) graphics-info-graphs.$(OBJEXT) \
+	graphics-info-gui.$(OBJEXT) graphics-info-modelling.$(OBJEXT) \
 	graphics-info-navigation.$(OBJEXT) \
 	graphics-info-navigation-gtk1.$(OBJEXT) \
 	graphics-info-navigation-gtk2.$(OBJEXT) \
@@ -272,6 +277,7 @@
 	molecule-class-info-maps-2.$(OBJEXT) \
 	molecule-class-info-kdc.$(OBJEXT) \
 	molecule-class-info-dots.$(OBJEXT) \
+	molecule-class-info-dots-internal.$(OBJEXT) \
 	molecule-class-info-other.$(OBJEXT) \
 	molecule-class-info-build.$(OBJEXT) \
 	molecule-class-info-mutate.$(OBJEXT) \
@@ -501,6 +507,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -802,12 +809,13 @@
 	coot_pythonmodule.cc coot-preferences.h coot-references.h \
 	coot-setup-python.cc coot-setup-python.hh coot-version.hh \
 	coot_wrap_guile.cc dots-representation.hh drag-and-drop.hh \
-	drag-and-drop.cc flev.hh flev.cc generic-display-object.hh \
-	generic-objects.cc generic-display-objects-c.h \
-	geometry-graphs.cc geometry-graphs.hh get-residue.hh \
-	get-residue.cc get-monomer.hh get-monomer.cc gl-bits.hh \
-	globjects.cc globjects.h gl-matrix.h globularize.cc \
-	globularize.hh graphics-info.cc graphics-info-defines.cc \
+	drag-and-drop.cc draw-generic-display-objects.cc flev.hh \
+	flev.cc generic-display-object.hh generic-objects.cc \
+	generic-display-objects-c.h geometry-graphs.cc \
+	geometry-graphs.hh get-residue.hh get-residue.cc \
+	get-monomer.hh get-monomer.cc gl-bits.hh globjects.cc \
+	globjects.h gl-matrix.h globularize.cc globularize.hh \
+	graphics-info.cc graphics-info-defines.cc \
 	graphics-info-graphs.cc graphics-info-gui.cc \
 	graphics-info-modelling.cc graphics-info-navigation.cc \
 	graphics-info-navigation-gtk1.cc \
@@ -827,6 +835,7 @@
 	molecule-class-info.cc molecule-class-info-bonds.cc \
 	molecule-class-info-maps.cc molecule-class-info-maps-2.cc \
 	molecule-class-info-kdc.cc molecule-class-info-dots.cc \
+	molecule-class-info-dots-internal.cc \
 	molecule-class-info-other.cc molecule-class-info-build.cc \
 	molecule-class-info.h molecule-class-info-mutate.cc \
 	molecule-class-info-residues.cc molecule-class-info-refine.cc \
@@ -1232,6 +1241,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/coot_wrap_python.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/density-score-by-residue-src.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/drag-and-drop.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/draw-generic-display-objects.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fix-nomenclature.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/flev.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/generic-objects.Po@am__quote@
@@ -1271,6 +1281,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/main.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/molecule-class-info-bonds.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/molecule-class-info-build.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/molecule-class-info-dots-internal.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/molecule-class-info-dots.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/molecule-class-info-kdc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/molecule-class-info-kk.Po@am__quote@
@@ -1634,6 +1645,7 @@
                              $(top_srcdir)/src/coot.i           \
                              $(top_srcdir)/src/lbg-interface.hh \
                              $(top_srcdir)/src/c-interface-ligands-swig.hh \
+			     $(top_srcdir)/src/c-interface-generic-objects.h \
                              $(top_srcdir)/src/sdf-interface.hh \
                              $(top_srcdir)/src/cfc.hh \
                              $(top_srcdir)/src/cmtz-interface.hh \
diff -ruN coot-0.8.7/src/c-interface-analysis.cc coot-0.8.8-pre/src/c-interface-analysis.cc
--- coot-0.8.7/src/c-interface-analysis.cc	2016-06-28 20:00:18.000000000 -0700
+++ coot-0.8.8-pre/src/c-interface-analysis.cc	2016-12-21 05:34:30.000000000 -0800
@@ -35,6 +35,7 @@
 #include "graphics-info.h"
 #include "cc-interface.hh"
 #include "c-interface.h"
+#include "c-interface-generic-objects.h"
 
 #include "coot-utils/coot-hole.hh"
 
diff -ruN coot-0.8.7/src/c-interface-build.cc coot-0.8.8-pre/src/c-interface-build.cc
--- coot-0.8.7/src/c-interface-build.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/src/c-interface-build.cc	2017-01-13 09:52:23.000000000 -0800
@@ -410,6 +410,71 @@
    return istate;
 }
 
+#ifdef USE_GUILE
+int replace_residues_from_mol_scm(int imol_target,
+				 int imol_ref,
+				 SCM residue_specs_list_ref_scm) {
+
+   int status = 0;
+   if (is_valid_model_molecule(imol_target)) {
+      if (is_valid_model_molecule(imol_ref)) {
+	 mmdb::Manager *mol = graphics_info_t::molecules[imol_ref].atom_sel.mol;
+	 std::vector<coot::residue_spec_t> specs = scm_to_residue_specs(residue_specs_list_ref_scm);
+	 if (specs.size()) {
+	    mmdb::Manager *mol_new = coot::util::create_mmdbmanager_from_residue_specs(specs, mol);
+	    if (mol_new) {
+	       atom_selection_container_t asc = make_asc(mol_new);
+	       status = graphics_info_t::molecules[imol_target].replace_fragment(asc);
+	       graphics_draw();
+	    }
+	 }
+      }
+   }
+
+   if (false) {
+      // we can't yet add the residue_spec_list_scm
+      std::vector<std::string> command_strings;
+      command_strings.push_back("replace-fragement-from-mol-scm");
+      command_strings.push_back(graphics_info_t::int_to_string(imol_target));
+      add_to_history(command_strings);
+   }
+   return status;
+}
+#endif // USE_GUILE
+
+/*! \brief replace the given residues from the reference molecule to the target molecule
+*/
+#ifdef USE_PYTHON
+int replace_residues_from_mol_py(int imol_target,
+				 int imol_ref,
+				 PyObject *residue_specs_list_ref_py) {
+
+   int status = 0;
+   if (is_valid_model_molecule(imol_target)) {
+      if (is_valid_model_molecule(imol_ref)) {
+	 mmdb::Manager *mol = graphics_info_t::molecules[imol_ref].atom_sel.mol;
+	 std::vector<coot::residue_spec_t> specs = py_to_residue_specs(residue_specs_list_ref_py);
+	 if (specs.size()) {
+	    mmdb::Manager *mol_new = coot::util::create_mmdbmanager_from_residue_specs(specs, mol);
+	    atom_selection_container_t asc = make_asc(mol_new);
+	    status = graphics_info_t::molecules[imol_target].replace_fragment(asc);
+	    graphics_draw();
+	 }
+      }
+   }
+
+   if (false) {
+      // we can't yet add the residue_spec_list_py
+      std::vector<std::string> command_strings;
+      command_strings.push_back("replace-fragement-from-mol-py");
+      command_strings.push_back(graphics_info_t::int_to_string(imol_target));
+      add_to_history(command_strings);
+   }
+   return status;
+}
+#endif /* USE_PYTHON */
+
+
 /*! \brief copy the given residue range from the reference chain to the target chain 
 
 resno_range_start and resno_range_end are inclusive. */
@@ -4381,6 +4446,45 @@
    return imol;
 }
 
+#ifdef USE_PYTHON
+/*! \brief create a new molecule that consists of only the atoms
+  of the specified list of residues
+@return the new molecule number, -1 means an error. */
+int new_molecule_by_residue_specs_py(int imol, PyObject *residue_spec_list_py) {
+
+   int imol_new = -1;
+   if (is_valid_model_molecule(imol)) {
+      std::vector<coot::residue_spec_t> specs = py_to_residue_specs(residue_spec_list_py);
+      if (specs.size()) {
+	 graphics_info_t g;
+	 mmdb::Manager *mol = g.molecules[imol].atom_sel.mol;
+	 mmdb::Manager *mol_new = coot::util::create_mmdbmanager_from_residue_specs(specs, mol);
+	 if (mol_new) {
+	    imol_new = graphics_info_t::create_molecule();
+	    atom_selection_container_t asc = make_asc(mol_new);
+	    std::string label = "residues-selected-from-mol-";
+	    label += coot::util::int_to_string(imol);
+	    g.molecules[imol_new].install_model(imol_new, asc, g.Geom_p(), label, 1);
+	 }
+      }
+   }
+   return imol_new;
+
+}
+#endif /* USE_PYTHON */
+
+#ifdef USE_GUILE
+/*! \brief create a new molecule that consists of only the atoms
+  of the specified list of residues
+@return the new molecule number, -1 means an error. */
+int new_molecule_by_residue_specs_scm(int imol, SCM *residue_spec_list_scm) {
+
+   int imol_new = -1;
+   return imol_new;
+}
+#endif /* USE_GUILE */
+
+
 // ---------------------------------------------------------------------
 // b-factor
 // ---------------------------------------------------------------------
diff -ruN coot-0.8.7/src/c-interface-generic-objects.h coot-0.8.8-pre/src/c-interface-generic-objects.h
--- coot-0.8.7/src/c-interface-generic-objects.h	2016-09-01 17:13:24.000000000 -0700
+++ coot-0.8.8-pre/src/c-interface-generic-objects.h	2016-12-21 05:34:30.000000000 -0800
@@ -20,6 +20,8 @@
  * 02110-1301, USA
  */
 
+#include "generic-display-objects-c.h"
+
 /*  ----------------------------------------------------------------------- */
 /*                  Generic Objects                                         */
 /*  ----------------------------------------------------------------------- */
@@ -44,25 +46,33 @@
 /*! \brief add a dashed line to generic object object_number 
 
 dash_density is number of dashes per Angstrom.*/
-void to_generic_object_add_dashed_line(int object_number, 
+void to_generic_object_add_dashed_line(int object_number,
 				       const char *colour,
 				       int line_width,
 				       float dash_density,
-				       float from_x1, 
-				       float from_y1, 
-				       float from_z1, 
-				       float to_x2, 
-				       float to_y2, 
+				       float from_x1,
+				       float from_y1,
+				       float from_z1,
+				       float to_x2,
+				       float to_y2,
 				       float to_z2); 
 
 /*! \brief add point to generic object object_number */
-void to_generic_object_add_point(int object_number, 
+void to_generic_object_add_point(int object_number,
 				 const char *colour,
 				 int point_width,
-				 float from_x1, 
-				 float from_y1, 
+				 float from_x1,
+				 float from_y1,
 				 float from_z1);
 
+#ifndef SWIG
+void to_generic_object_add_point_internal(int object_number,
+				 const std::string &colour_name, // needed for indexing objects by colour
+				 const coot::colour_holder &colour,
+				 int point_width,
+				 const clipper::Coord_orth &pt);
+#endif // SWIG
+
 /*! \brief add point to generic object object_number */
 void to_generic_object_add_arc(int object_number, 
 			       const char *colour,
@@ -105,8 +115,12 @@
   generally need this function.  */
 void set_display_generic_object(int object_number, short int istate);
 
-/*! \brief display (1) or undisplay (0) all generic display objects */
-void set_display_all_generic_objects(int state);
+/*! \brief set the display status of object number object_number, 
+
+  set the state of a generic object to be drawn, but no redraw. 
+  Use when enabling multiple generic objects.
+*/
+void set_display_generic_object_simple(int object_number, short int istate);
 
 
 /*! \brief is generic display object displayed?
@@ -152,16 +166,10 @@
 */
 short int is_closed_generic_object_p(int object_number);
 
-void close_all_generic_objects();
-
 /*! \brief clear out the lines and points from object_number, but keep
   it displayable (not closed). */
 void generic_object_clear(int object_number);
 
-/*! \brief a kludgey thing, so that the generic objects gui can be
-  called from a callback.  */
-void generic_objects_gui_wrapper();
-
 /*! \brief attach the generic object to a particular molecule 
 
 one might do this if the generic object is specific to a molecule.
diff -ruN coot-0.8.7/src/c-interface-gui.cc coot-0.8.8-pre/src/c-interface-gui.cc
--- coot-0.8.7/src/c-interface-gui.cc	2016-11-08 01:46:24.000000000 -0800
+++ coot-0.8.8-pre/src/c-interface-gui.cc	2016-12-21 05:34:30.000000000 -0800
@@ -72,6 +72,7 @@
 #include "graphics-info.h"
 #include "interface.h"
 #include "c-interface.h"
+#include "c-interface-generic-objects.h"
 #include "c-interface-gtk-widgets.h"
 #include "c-interface-preferences.h"
 #include "cc-interface.hh"
@@ -126,6 +127,8 @@
 }
 
 
+#include "c-interface-widgets.hh"
+
 void
 open_cif_dictionary_file_selector_dialog() {
    
@@ -140,42 +143,50 @@
 
       if (graphics_info_t::gtk2_file_chooser_selector_flag == coot::CHOOSER_STYLE) {
 
+	 GtkWidget *aa_hbutton_box = gtk_dialog_get_action_area(GTK_DIALOG(fileselection));
+	 if (GTK_IS_HBUTTON_BOX(aa_hbutton_box))
+	    add_cif_dictionary_selector_molecule_selector(fileselection, aa_hbutton_box);
+
       } else {
 
-	 // classic
+	 // classic (I'm in the club, Moet Chandon in my cup...)
 
-	 // use action area for molecule selection
-	 //
 	 GtkWidget *aa_hbox = GTK_FILE_SELECTION(fileselection)->action_area;
-
-	 std::cout << "here with aa_hbox " << aa_hbox << std::endl;
-	 if (aa_hbox) {
-	    GtkWidget *frame = gtk_frame_new("Select Mol");
-	    GtkWidget *optionmenu = gtk_option_menu_new();
-	    g_object_set_data_full(G_OBJECT(fileselection),
-				   "cif_dictionary_file_selector_molecule_select_option_menu",
-				   gtk_widget_ref(optionmenu),
-				   (GDestroyNotify) gtk_widget_unref);
-
-	    GtkSignalFunc callback_func =
-	       GTK_SIGNAL_FUNC(cif_dictionary_molecule_menu_item_select);
-
-	    graphics_info_t g;
-	    int imol = first_coords_imol();
-	    fill_option_menu_with_coordinates_options_for_dictionary(optionmenu);
-
-	    gtk_box_pack_start(GTK_BOX(aa_hbox), frame, FALSE, TRUE, 0);
-	    gtk_container_add(GTK_CONTAINER(frame),optionmenu);
-	    gtk_widget_show(optionmenu);
-	    gtk_widget_show(frame);
-	 
-	 }
+	 if (aa_hbox)
+	    add_cif_dictionary_selector_molecule_selector(fileselection, aa_hbox);
       }
       gtk_widget_show(fileselection);
    }
 }
 
 void
+add_cif_dictionary_selector_molecule_selector(GtkWidget *fileselection, // maybe it's a chooser
+					      GtkWidget *aa_hbox) {
+
+   // if we came from a chooser, aa_hbox is an hbutton_box
+   // if we came from a selector, aa_hbox is an hbox.
+
+   GtkWidget *frame = gtk_frame_new("Select Mol");
+   GtkWidget *optionmenu = gtk_option_menu_new();
+   g_object_set_data_full(G_OBJECT(fileselection),
+			  "cif_dictionary_file_selector_molecule_select_option_menu",
+			  gtk_widget_ref(optionmenu),
+			  (GDestroyNotify) gtk_widget_unref);
+
+   GtkSignalFunc callback_func =
+      GTK_SIGNAL_FUNC(cif_dictionary_molecule_menu_item_select);
+
+   graphics_info_t g;
+   int imol = first_coords_imol();
+   fill_option_menu_with_coordinates_options_for_dictionary(optionmenu);
+
+   gtk_box_pack_start(GTK_BOX(aa_hbox), frame, FALSE, TRUE, 0);
+   gtk_container_add(GTK_CONTAINER(frame),optionmenu);
+   gtk_widget_show(optionmenu);
+   gtk_widget_show(frame);
+}
+
+void
 fill_option_menu_with_coordinates_options_for_dictionary(GtkWidget *option_menu) {
 
    // Auto is at the top, followed by All, then numbers
diff -ruN coot-0.8.7/src/c-interface-info.cc coot-0.8.8-pre/src/c-interface-info.cc
--- coot-0.8.7/src/c-interface-info.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/src/c-interface-info.cc	2017-01-13 09:52:23.000000000 -0800
@@ -1093,20 +1093,32 @@
 	 PyObject *chain_id_py = PyList_GetItem(residue_in, 0);
 	 PyObject *resno_py    = PyList_GetItem(residue_in, 1);
 	 PyObject *ins_code_py = PyList_GetItem(residue_in, 2);
-	 std::string chain_id  = PyString_AsString(chain_id_py);
-	 std::string ins_code  = PyString_AsString(ins_code_py);
-	 long resno            = PyInt_AsLong(resno_py);
-	 rspec = coot::residue_spec_t(chain_id, resno, ins_code);
+	 if (PyString_Check(chain_id_py)) {
+	    if (PyString_Check(ins_code_py)) {
+	       if (PyInt_Check(resno_py)) {
+		  std::string chain_id  = PyString_AsString(chain_id_py);
+		  std::string ins_code  = PyString_AsString(ins_code_py);
+		  long resno            = PyInt_AsLong(resno_py);
+		  rspec = coot::residue_spec_t(chain_id, resno, ins_code);
+	       }
+	    }
+	 }
       }
 
       if (PyList_Size(residue_in) == 4) {
 	 PyObject *chain_id_py = PyList_GetItem(residue_in, 1);
 	 PyObject *resno_py    = PyList_GetItem(residue_in, 2);
 	 PyObject *ins_code_py = PyList_GetItem(residue_in, 3);
-	 std::string chain_id  = PyString_AsString(chain_id_py);
-	 std::string ins_code  = PyString_AsString(ins_code_py);
-	 long resno            = PyInt_AsLong(resno_py);
-	 rspec = coot::residue_spec_t(chain_id, resno, ins_code);
+	 if (PyString_Check(chain_id_py)) {
+	    if (PyString_Check(ins_code_py)) {
+	       if (PyInt_Check(resno_py)) {
+		  std::string chain_id  = PyString_AsString(chain_id_py);
+		  std::string ins_code  = PyString_AsString(ins_code_py);
+		  long resno            = PyInt_AsLong(resno_py);
+		  rspec = coot::residue_spec_t(chain_id, resno, ins_code);
+	       }
+	    }
+	 }
       }
 
    }
@@ -4977,7 +4989,7 @@
 
 
 #ifdef USE_GUILE
-   SCM link_info_scm(int imol) {
+SCM link_info_scm(int imol) {
 
    SCM r = SCM_EOL;
    if (is_valid_model_molecule(imol)) {
diff -ruN coot-0.8.7/src/c-interface-ligands-gui.cc coot-0.8.8-pre/src/c-interface-ligands-gui.cc
--- coot-0.8.7/src/c-interface-ligands-gui.cc	2016-11-08 01:46:24.000000000 -0800
+++ coot-0.8.8-pre/src/c-interface-ligands-gui.cc	2017-01-10 02:55:38.000000000 -0800
@@ -920,7 +920,7 @@
 
 #ifdef USE_SQLITE3
 
-   std::string pkg_data_dir = PKGDATADIR;
+   std::string pkg_data_dir = coot::package_data_dir();
    std::string ligands_db_file_name = "ligands.db";
    std::string d = coot::util::append_dir_file(pkg_data_dir, "data");
    std::string f = coot::util::append_dir_file(d, ligands_db_file_name);
@@ -1187,10 +1187,11 @@
 
    graphics_info_t g;
    ligand_wiggly_ligand_data_t *ldp = static_cast<ligand_wiggly_ligand_data_t *>(data);
-
-   std::cout << "runnign install_simple_wiggly_ligand_idle_fn() with g.ligand_wiggly_ligand_count "
-	     << g.ligand_wiggly_ligand_count << " " << g.ligand_wiggly_ligand_n_samples
-	     << " g.ligand_wiggly_ligand_n_samples and finish " << ldp->finish << std::endl;
+  
+   if (false)
+      std::cout << "INFO:: running install_simple_wiggly_ligand_idle_fn() with g.ligand_wiggly_ligand_count "
+	        << g.ligand_wiggly_ligand_count << " " << g.ligand_wiggly_ligand_n_samples
+	        << " g.ligand_wiggly_ligand_n_samples and finish " << ldp->finish << std::endl;
 
    if (g.ligand_wiggly_ligand_count >= g.ligand_wiggly_ligand_n_samples) {
 
diff -ruN coot-0.8.7/src/c-interface-ligands-swig.hh coot-0.8.8-pre/src/c-interface-ligands-swig.hh
--- coot-0.8.7/src/c-interface-ligands-swig.hh	2016-01-11 08:00:11.000000000 -0800
+++ coot-0.8.8-pre/src/c-interface-ligands-swig.hh	2016-12-21 05:34:30.000000000 -0800
@@ -125,6 +125,26 @@
 // return False if unknown
 bool comprised_of_organic_set_p(const std::string &rn);
 
+// all-atom contact dots.  This is not the place for this declaration (not a ligand function)
+void coot_all_atom_contact_dots(int imol);
+
+#ifdef USE_PYTHON
+void coot_contact_dots_for_ligand_py(int imol, PyObject *ligand_spec);
+// change HE2 to HD1 and vice versa
+void switch_HIS_protonation_py(int imol, PyObject *residue_spec);
+#endif
+
+// this is not a ligand function - it does not belong here.
+void coot_reduce(int imol);
+
+
+#ifdef USE_GUILE
+void coot_contact_dots_for_ligand_scm(int imol, SCM residue_spec_scm);
+// change HE2 to HD1 and vice versa
+void switch_HIS_protonation_scm(int imol, SCM residue_spec_scm);
+#endif
+
+
 
 // we want to read in the built-in database to convert these scores to percentiles
 // return -1 (test for negative) on failure
@@ -136,9 +156,8 @@
 double get_ligand_percentile(std::string metric_name, double metric_value, short int reverse_order);
 
 
-
-bool
-enhanced_ligand_coot_p();
+// is enhanced ligand version
+bool enhanced_ligand_coot_p();
 
 
 #endif // C_INTERFACE_LIGANDS_SWIG_HH
diff -ruN coot-0.8.7/src/c-interface-ligands.cc coot-0.8.8-pre/src/c-interface-ligands.cc
--- coot-0.8.7/src/c-interface-ligands.cc	2016-11-08 01:46:24.000000000 -0800
+++ coot-0.8.8-pre/src/c-interface-ligands.cc	2017-01-24 09:37:54.000000000 -0800
@@ -54,6 +54,7 @@
 
 #include "graphics-info.h"
 #include "c-interface.h"
+#include "c-interface-generic-objects.h"
 #include "c-interface-gtk-widgets.h"
 #include "cc-interface.hh"
 #include "cc-interface-scripting.hh"
@@ -849,8 +850,6 @@
 std::vector<int>
 execute_ligand_search_internal(coot::wligand *wlig_p) {
    
-   std::cout << "Executing ligand search internal using wlig_p " << wlig_p << std::endl;
-
    std::vector<int> solutions;
 
    graphics_info_t g;
@@ -3471,3 +3470,184 @@
 }
 
 
+// ---------------------------------------------------
+
+
+////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////
+//                 coot built-in contact dots
+////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "coot-utils/atom-overlaps.hh"
+
+void
+coot_contact_dots_for_ligand_internal(int imol, coot::residue_spec_t &res_spec) {
+
+   graphics_info_t g;
+   mmdb::Manager *mol = g.molecules[imol].atom_sel.mol;
+   mmdb::Residue *residue_p = coot::util::get_residue(res_spec, mol);
+   if (residue_p) {
+      std::vector<mmdb::Residue *> neighbs = coot::residues_near_residue(residue_p, mol, 5);
+      coot::atom_overlaps_container_t overlaps(residue_p, neighbs, mol, g.Geom_p(), 0.5, 0.25);
+      coot::atom_overlaps_dots_container_t c = overlaps.contact_dots_for_ligand();
+      std::cout << "------------- score " << c.score() << std::endl;
+
+      // for quick colour lookups.
+      std::map<std::string, coot::colour_holder> colour_map;
+      colour_map["blue"      ] = coot::generic_display_object_t::colour_values_from_colour_name("blue");
+      colour_map["sky"       ] = coot::generic_display_object_t::colour_values_from_colour_name("sky");
+      colour_map["sea"       ] = coot::generic_display_object_t::colour_values_from_colour_name("sea");
+      colour_map["greentint" ] = coot::generic_display_object_t::colour_values_from_colour_name("greentint");
+      colour_map["green"     ] = coot::generic_display_object_t::colour_values_from_colour_name("green");
+      colour_map["orange"    ] = coot::generic_display_object_t::colour_values_from_colour_name("orange");
+      colour_map["orangered" ] = coot::generic_display_object_t::colour_values_from_colour_name("orangered");
+      colour_map["yellow"    ] = coot::generic_display_object_t::colour_values_from_colour_name("yellow");
+      colour_map["yellowtint"] = coot::generic_display_object_t::colour_values_from_colour_name("yellowtint");
+      colour_map["red"       ] = coot::generic_display_object_t::colour_values_from_colour_name("red");
+      colour_map["#55dd55"   ] = coot::generic_display_object_t::colour_values_from_colour_name("#55dd55");
+      colour_map["hotpink"   ] = coot::generic_display_object_t::colour_values_from_colour_name("hotpink");
+      colour_map["grey"      ] = coot::generic_display_object_t::colour_values_from_colour_name("grey");
+      colour_map["magenta"   ] = coot::generic_display_object_t::colour_values_from_colour_name("magenta");
+      colour_map["royalblue" ] = coot::generic_display_object_t::colour_values_from_colour_name("royalblue");
+      
+      std::map<std::string, std::vector<coot::atom_overlaps_dots_container_t::dot_t> >::const_iterator it;
+      for (it=c.dots.begin(); it!=c.dots.end(); it++) {
+	 const std::string &type = it->first;
+	 const std::vector<coot::atom_overlaps_dots_container_t::dot_t> &v = it->second;
+	 std::string obj_name = type;
+	 int obj = new_generic_object_number(obj_name.c_str());
+	 int point_size = 2;
+	 if (type == "vdw-surface") point_size = 1;
+	 for (unsigned int i=0; i<v.size(); i++) {
+	    const std::string &col = v[i].col;
+	    to_generic_object_add_point_internal(obj, col, colour_map[col], point_size, v[i].pos);
+	 }
+	 if (type != "vdw-surface")
+	    set_display_generic_object(obj, 1); // should be a function with no redraw
+      }
+      int clashes_obj = new_generic_object_number("clashes");
+      for (unsigned int i=0; i<c.clashes.size(); i++) {
+	 to_generic_object_add_line(clashes_obj, "#ff59b4", 2,
+				    c.clashes[i].first.x(),  c.clashes[i].first.y(),  c.clashes[i].first.z(),
+				    c.clashes[i].second.x(), c.clashes[i].second.y(), c.clashes[i].second.z());
+      }
+      set_display_generic_object(clashes_obj, 1);
+      
+   } else {
+      std::cout << "Can't find residue" << res_spec << std::endl;
+   }
+}
+
+#ifdef USE_PYTHON
+void
+coot_contact_dots_for_ligand_py(int imol, PyObject *ligand_spec_py) {
+
+   coot::residue_spec_t res_spec = residue_spec_from_py(ligand_spec_py);
+   if (is_valid_model_molecule(imol)) {
+      coot_contact_dots_for_ligand_internal(imol, res_spec);
+   }
+}
+#endif
+
+#ifdef USE_PYTHON
+void switch_HIS_protonation_py(int imol, PyObject *residue_spec_py) {
+
+   coot::residue_spec_t res_spec = residue_spec_from_py(residue_spec_py);
+   if (is_valid_model_molecule(imol)) {
+      graphics_info_t::molecules[imol].switch_HIS_protonation(res_spec);
+   }
+   graphics_draw();
+}
+#endif // USE_PYTHON
+
+#ifdef USE_GUILE
+void switch_HIS_protonation_scm(int imol, SCM residue_spec_scm) {
+
+   coot::residue_spec_t res_spec = residue_spec_from_scm(residue_spec_scm);
+   if (is_valid_model_molecule(imol)) {
+      graphics_info_t::molecules[imol].switch_HIS_protonation(res_spec);
+   }
+   graphics_draw();
+}
+#endif // USE_GUILE
+
+
+void coot_reduce(int imol) {
+
+   if (is_valid_model_molecule(imol)) {
+      graphics_info_t g;
+      g.molecules[imol].reduce(g.Geom_p());
+      graphics_draw();
+   }
+}
+
+
+
+#ifdef USE_GUILE
+void
+coot_contact_dots_for_ligand_scm(int imol, SCM ligand_spec_scm) {
+
+   coot::residue_spec_t res_spec = residue_spec_from_scm(ligand_spec_scm);
+   if (is_valid_model_molecule(imol)) {
+      coot_contact_dots_for_ligand_internal(imol, res_spec);
+   }
+}
+#endif
+
+// all-atom contact dots.  This is not the place for this definition (not a ligand function)
+//
+void coot_all_atom_contact_dots(int imol) {
+
+   if (is_valid_model_molecule(imol)) {
+      graphics_info_t g;
+      mmdb::Manager *mol = g.molecules[imol].atom_sel.mol;
+      // spike-length ball-radius
+      coot::atom_overlaps_container_t overlaps(mol, g.Geom_p(), 0.5, 0.25);
+      // dot density
+      coot::atom_overlaps_dots_container_t c = overlaps.all_atom_contact_dots(0.95, true);
+
+      std::map<std::string, std::vector<coot::atom_overlaps_dots_container_t::dot_t> >::const_iterator it;
+
+      // for quick colour lookups.
+      std::map<std::string, coot::colour_holder> colour_map;
+      colour_map["blue"      ] = coot::generic_display_object_t::colour_values_from_colour_name("blue");
+      colour_map["sky"       ] = coot::generic_display_object_t::colour_values_from_colour_name("sky");
+      colour_map["sea"       ] = coot::generic_display_object_t::colour_values_from_colour_name("sea");
+      colour_map["greentint" ] = coot::generic_display_object_t::colour_values_from_colour_name("greentint");
+      colour_map["green"     ] = coot::generic_display_object_t::colour_values_from_colour_name("green");
+      colour_map["orange"    ] = coot::generic_display_object_t::colour_values_from_colour_name("orange");
+      colour_map["orangered" ] = coot::generic_display_object_t::colour_values_from_colour_name("orangered");
+      colour_map["yellow"    ] = coot::generic_display_object_t::colour_values_from_colour_name("yellow");
+      colour_map["yellowtint"] = coot::generic_display_object_t::colour_values_from_colour_name("yellowtint");
+      colour_map["red"       ] = coot::generic_display_object_t::colour_values_from_colour_name("red");
+      colour_map["#55dd55"   ] = coot::generic_display_object_t::colour_values_from_colour_name("#55dd55");
+      colour_map["hotpink"   ] = coot::generic_display_object_t::colour_values_from_colour_name("hotpink");
+      colour_map["grey"      ] = coot::generic_display_object_t::colour_values_from_colour_name("grey");
+      colour_map["magenta"   ] = coot::generic_display_object_t::colour_values_from_colour_name("magenta");
+      
+      for (it=c.dots.begin(); it!=c.dots.end(); it++) {
+	 const std::string &type = it->first;
+	 const std::vector<coot::atom_overlaps_dots_container_t::dot_t> &v = it->second;
+	 std::string obj_name = type;
+	 int obj = new_generic_object_number(obj_name.c_str());
+	 std::string col = "#445566";
+	 int point_size = 2;
+	 if (type == "vdw-surface") point_size = 1;
+	 for (unsigned int i=0; i<v.size(); i++) {
+	    const std::string &col = v[i].col;
+	    to_generic_object_add_point_internal(obj, col, colour_map[col], point_size, v[i].pos);
+	 }
+	 if (type != "vdw-surface")
+	    set_display_generic_object_simple(obj, 1); // should be a function with no redraw
+      }
+      int clashes_obj = new_generic_object_number("clashes");
+      for (unsigned int i=0; i<c.clashes.size(); i++) {
+	 to_generic_object_add_line(clashes_obj, "#ff59b4", 2,
+				    c.clashes[i].first.x(),  c.clashes[i].first.y(),  c.clashes[i].first.z(),
+				    c.clashes[i].second.x(), c.clashes[i].second.y(), c.clashes[i].second.z());
+      }
+      set_display_generic_object_simple(clashes_obj, 1);
+      graphics_draw();
+   }
+}
diff -ruN coot-0.8.7/src/c-interface-ligands.hh coot-0.8.8-pre/src/c-interface-ligands.hh
--- coot-0.8.7/src/c-interface-ligands.hh	2016-01-06 20:00:03.000000000 -0800
+++ coot-0.8.8-pre/src/c-interface-ligands.hh	2016-12-21 05:34:30.000000000 -0800
@@ -33,6 +33,8 @@
 #include "lbg/flev-annotations.hh"
 #include "ligand-check.hh"
 
+// not for swig
+
 namespace coot { 
 
    void write_solvent_accessibilities(const std::vector<std::pair<coot::atom_spec_t, float> > &sav,
@@ -103,4 +105,8 @@
 
 } // namespace coot
 
+
+void coot_contact_dots_for_ligand_internal(int imol, coot::residue_spec_t &res_spec);
+
+
 #endif // C_INTERFACE_LIGANDS_HH
diff -ruN coot-0.8.7/src/c-interface-mogul.cc coot-0.8.8-pre/src/c-interface-mogul.cc
--- coot-0.8.7/src/c-interface-mogul.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/src/c-interface-mogul.cc	2016-12-21 05:34:30.000000000 -0800
@@ -32,6 +32,7 @@
 
 #include "graphics-info.h"
 #include "c-interface.h"
+#include "c-interface-generic-objects.h"
 #include "cc-interface-mogul.hh"
 
 #include "interface.h"
diff -ruN coot-0.8.7/src/c-interface-network.cc coot-0.8.8-pre/src/c-interface-network.cc
--- coot-0.8.7/src/c-interface-network.cc	2015-09-04 07:41:53.000000000 -0700
+++ coot-0.8.8-pre/src/c-interface-network.cc	2017-01-13 09:52:23.000000000 -0800
@@ -257,7 +257,7 @@
 #ifdef USE_GUILE
 	 std::string s = get_drug_via_wikipedia_and_drugbank_scm(drugname);
 	 if (s.empty()) {
-	    std::cout << "INFO:: get_drug_via_wikipedia result-not-a-string" << std::endl;
+	    std::cout << "INFO:: get_drug_via_wikipedia_scm result-not-a-string" << std::endl;
 	 }
 	 return s;
 #endif
@@ -271,6 +271,9 @@
 }
 
 #ifdef USE_GUILE
+
+#include "c-interface-scm.hh" // for debugging
+
 // Return the file name of the mdl mol file.
 // 
 // Return empty string on error
@@ -283,6 +286,7 @@
    command += single_quote(drugname);
    command += ")";
    SCM r = safe_scheme_command(command);
+   std::string sr = scm_to_locale_string(display_scm(r));
    if (scm_is_true(scm_string_p(r)))
       s = scm_to_locale_string(r);
    return s;
diff -ruN coot-0.8.7/src/c-interface-pisa.cc coot-0.8.8-pre/src/c-interface-pisa.cc
--- coot-0.8.7/src/c-interface-pisa.cc	2015-08-26 04:54:02.000000000 -0700
+++ coot-0.8.8-pre/src/c-interface-pisa.cc	2016-12-21 05:34:30.000000000 -0800
@@ -32,6 +32,7 @@
 
 #include "graphics-info.h"
 #include "c-interface.h"
+#include "c-interface-generic-objects.h"
 #include "cc-interface.hh"
 #include "c-interface-scm.hh"
 #include "c-interface-python.hh"
@@ -945,9 +946,6 @@
 	 if (c_2.first)
 	    centre_2 = c_2.second;
 
-	 // coot::dots_representation_info_t d1(frag_mol_1, frag_mol_2);
-	 // coot::dots_representation_info_t d2(frag_mol_2, frag_mol_1);
-
 	 coot::dots_representation_info_t d1(frag_mol_1, frag_mol_2);
 	 coot::dots_representation_info_t d2(frag_mol_2, frag_mol_1);
 
diff -ruN coot-0.8.7/src/c-interface-preferences.cc coot-0.8.8-pre/src/c-interface-preferences.cc
--- coot-0.8.7/src/c-interface-preferences.cc	2016-09-01 17:13:24.000000000 -0700
+++ coot-0.8.8-pre/src/c-interface-preferences.cc	2016-12-21 05:34:30.000000000 -0800
@@ -1077,104 +1077,6 @@
 
 
 
-/*! \brief return the number of generic display objects */
-int number_of_generic_objects() {
-
-   graphics_info_t g;
-   return g.generic_objects_p->size();
-}
-
-void generic_objects_gui_wrapper() {
-
-   graphics_info_t g;
-   if (! g.generic_objects_dialog) { 
-      g.generic_objects_dialog = wrapped_create_generic_objects_dialog();
-   }
-   gtk_widget_show(g.generic_objects_dialog);
-   
-
-   // --------------------------- old (by scripting) ------------------------
-
-//    std::vector<std::string> cmd;
-//    cmd.push_back("generic-objects-gui");
-//    graphics_info_t g;
-
-// #if defined USE_GUILE && !defined WINDOWS_MINGW
-
-//    std::string s = g.state_command(cmd, coot::STATE_SCM);
-//    safe_scheme_command(s);
-
-
-// #else
-// #ifdef USE_PYGTK
-
-//    std::string s = g.state_command(cmd, coot::STATE_PYTHON);
-//    safe_python_command(s);
-
-// #endif // USE_PYGTK
-
-// #endif // USE_GUILE
-
-   
-
-} 
-
-
-std::pair<short int, std::string>
-is_interesting_dots_object_next_p(const std::vector<std::string> &vs) {
-
-   std::pair<short int, std::string> r(0, "");
-
-   if (vs.size() == 3) {
-//       std::cout << "Looking at bits:  \n  "; 
-//       for (unsigned int i=0; i<3; i++) { 
-// 	 std::cout << ":" << vs[i] << ": ";
-//       }
-//       std::cout << "\n"; 
-      if ((vs[1] == "wide") && (vs[2] == "contact)")) {
-	 r.first = 1;
-	 r.second = "wide contact";
-      }
-      if ((vs[1] == "close") && (vs[2] == "contact)")) {
-	 r.first = 1;
-	 r.second = "close contact";
-      }
-      if ((vs[1] == "small") && (vs[2] == "overlap)")) {
-	 r.first = 1;
-	 r.second = "small overlap";
-      }
-      if ((vs[1] == "bad") && (vs[2] == "overlap)")) {
-	 r.first = 1;
-	 r.second = "bad overlap";
-      }
-      if (vs[1] == "H-bonds)") { 
-	 r.first = 1;
-	 r.second = "H-bonds";
-      }
-   }
-   return r;
-}
-
-std::string probe_dots_short_contact_name_to_expanded_name(const std::string &short_name) {
-
-   std::vector<std::pair<std::string, std::string> > names;
-   names.push_back(std::pair<std::string, std::string>("wc", "wide contact"));
-   names.push_back(std::pair<std::string, std::string>("cc", "close contact"));
-   names.push_back(std::pair<std::string, std::string>("so", "small overlap"));
-   names.push_back(std::pair<std::string, std::string>("bo", "bad overlap"));
-   names.push_back(std::pair<std::string, std::string>("hb", "H-bonds"));
-
-   std::string r = "unknown";
-   for (int i=0; i<5; i++) {
-      if (names[i].first == short_name) {
-	 r = names[i].second;
-	 break;
-      }
-   } 
-   return r;
-} 
-
-
 
 // This is tedious and irritating to parse in C++.
 // 
diff -ruN coot-0.8.7/src/c-interface-residues.cc coot-0.8.8-pre/src/c-interface-residues.cc
--- coot-0.8.7/src/c-interface-residues.cc	2016-09-01 17:13:24.000000000 -0700
+++ coot-0.8.8-pre/src/c-interface-residues.cc	2017-01-13 09:52:23.000000000 -0800
@@ -270,3 +270,112 @@
    g.register_user_defined_interesting_positions(v);
 }
 #endif // USE_PYTHON 
+
+
+#ifdef USE_GUILE
+SCM glyco_tree_scm(int imol, SCM active_residue_scm) {
+
+   SCM r = SCM_BOOL_F;
+
+   if (is_valid_model_molecule(imol)) {
+
+      coot::residue_spec_t residue_spec = residue_spec_from_scm(active_residue_scm);
+      graphics_info_t g;
+      mmdb::Residue *residue_p = g.molecules[imol].get_residue(residue_spec);
+      mmdb::Manager *mol = g.molecules[imol].atom_sel.mol;
+      std::vector<std::string> types_with_no_dictionary =
+	 g.molecules[imol].no_dictionary_for_residue_type_as_yet(*g.Geom_p());
+      for (unsigned int i=0; i<types_with_no_dictionary.size(); i++)
+	 g.Geom_p()->try_dynamic_add(types_with_no_dictionary[i], 41);
+      coot::glyco_tree_t t(residue_p, mol, g.Geom_p());
+   }
+   return r;
+}
+#endif
+
+#ifdef USE_GUILE
+SCM glyco_tree_residues_scm(int imol, SCM active_residue_scm) {
+   
+   SCM r = SCM_BOOL_F;
+
+   if (is_valid_model_molecule(imol)) {
+
+      coot::residue_spec_t residue_spec = residue_spec_from_scm(active_residue_scm);
+      graphics_info_t g;
+      mmdb::Residue *residue_p = g.molecules[imol].get_residue(residue_spec);
+      mmdb::Manager *mol = g.molecules[imol].atom_sel.mol;
+      std::vector<std::string> types_with_no_dictionary =
+	 g.molecules[imol].no_dictionary_for_residue_type_as_yet(*g.Geom_p());
+      for (unsigned int i=0; i<types_with_no_dictionary.size(); i++)
+	 g.Geom_p()->try_dynamic_add(types_with_no_dictionary[i], 41);
+      coot::glyco_tree_t t(residue_p, mol, g.Geom_p());
+      std::vector<mmdb::Residue *> v_residues;
+      std::vector<coot::residue_spec_t> v(v_residues.size());
+   }
+   return r;
+}
+#endif
+
+#ifdef USE_PYTHON
+PyObject *glyco_tree_py(int imol, PyObject *active_residue_py) {
+
+   PyObject *r = Py_False;
+   if (is_valid_model_molecule(imol)) {
+
+      coot::residue_spec_t residue_spec = residue_spec_from_py(active_residue_py);
+      graphics_info_t g;
+      mmdb::Residue *residue_p = g.molecules[imol].get_residue(residue_spec);
+      mmdb::Manager *mol = g.molecules[imol].atom_sel.mol;
+      std::vector<std::string> types_with_no_dictionary =
+	 g.molecules[imol].no_dictionary_for_residue_type_as_yet(*g.Geom_p());
+      for (unsigned int i=0; i<types_with_no_dictionary.size(); i++)
+	 g.Geom_p()->try_dynamic_add(types_with_no_dictionary[i], 41);
+      coot::glyco_tree_t t(residue_p, mol, g.Geom_p());
+
+   }
+
+   if (PyBool_Check(r))
+     Py_INCREF(r);
+
+   return r;
+
+}
+#endif /* PYTHON */
+
+#ifdef USE_PYTHON
+PyObject *glyco_tree_residues_py(int imol, PyObject *active_residue_py) {
+
+   PyObject *r = Py_False;
+   if (is_valid_model_molecule(imol)) {
+
+      coot::residue_spec_t residue_spec = residue_spec_from_py(active_residue_py);
+
+      std::cout << "..... active residue spec: " << residue_spec << std::endl;
+      graphics_info_t g;
+      mmdb::Residue *residue_p = g.molecules[imol].get_residue(residue_spec);
+      mmdb::Manager *mol = g.molecules[imol].atom_sel.mol;
+      std::vector<std::string> types_with_no_dictionary =
+	 g.molecules[imol].no_dictionary_for_residue_type_as_yet(*g.Geom_p());
+      for (unsigned int i=0; i<types_with_no_dictionary.size(); i++)
+	 g.Geom_p()->try_dynamic_add(types_with_no_dictionary[i], 41);
+      coot::glyco_tree_t t(residue_p, mol, g.Geom_p());
+      std::vector<mmdb::Residue *> v_residues = t.residues(residue_spec);
+
+      std::cout << ".... v_residues.size() "  << v_residues.size() << std::endl;
+      
+      std::vector<coot::residue_spec_t> v(v_residues.size());
+      r = PyList_New(v_residues.size());
+      for (unsigned int i=0; i<v_residues.size(); i++) {
+	 std::cout << "     " << i << " " << coot::residue_spec_t(v_residues[i]) << std::endl;
+	 coot::residue_spec_t spec(v_residues[i]);
+	 PyList_SetItem(r, i, residue_spec_to_py(spec));
+      }
+   }
+
+   if (PyBool_Check(r))
+     Py_INCREF(r);
+
+   return r;
+
+}
+#endif /* PYTHON */
diff -ruN coot-0.8.7/src/c-interface-test.cc coot-0.8.8-pre/src/c-interface-test.cc
--- coot-0.8.7/src/c-interface-test.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/src/c-interface-test.cc	2016-12-27 13:13:20.000000000 -0800
@@ -1,4 +1,4 @@
-/* src/c-interface.cc
+/* src/c-interface-test.cc
  * 
  * Copyright 2002, 2003, 2004, 2005, 2006, 2007 The University of York
  * Copyright 2008, 2009 by The University of Oxford
@@ -116,6 +116,7 @@
 
 
 #include "c-interface.h"
+#include "c-interface-generic-objects.h"
 #include "c-interface-gtk-widgets.h"
 #include "cc-interface.hh"
 #include "c-interface-ligands.hh"
@@ -771,8 +772,8 @@
 
       std::vector<std::string> types_with_no_dictionary =
 	 g.molecules[imol].no_dictionary_for_residue_type_as_yet(*g.Geom_p());
-      std::cout << "glyco-test found " << types_with_no_dictionary.size() << " types with no dictionary"
-		<< std::endl;
+      std::cout << "glyco-test found " << types_with_no_dictionary.size()
+		<< " types with no dictionary" << std::endl;
       for (unsigned int i=0; i<types_with_no_dictionary.size(); i++) {
 	 std::cout << "trying to dynamic add: " << types_with_no_dictionary[i] << std::endl;
 	 g.Geom_p()->try_dynamic_add(types_with_no_dictionary[i], 41);
@@ -782,5 +783,3 @@
    } 
 
 }
-
-
diff -ruN coot-0.8.7/src/c-interface-widgets.hh coot-0.8.8-pre/src/c-interface-widgets.hh
--- coot-0.8.7/src/c-interface-widgets.hh	2016-09-01 17:13:24.000000000 -0700
+++ coot-0.8.8-pre/src/c-interface-widgets.hh	2016-12-21 05:34:30.000000000 -0800
@@ -1,4 +1,4 @@
-/* src/c-interface-widgets.h
+/* src/c-interface-widgets.hh
  * 
  * Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007 The University of York
  * Copyright 2007 by Paul Emsley
@@ -66,7 +66,17 @@
 
 void add_ligand_builder_menu_item_maybe();
 void start_ligand_builder_gui_XXX(GtkMenuItem     *menuitem,
-			      gpointer         user_data);
+				  gpointer         user_data);
+
+
+/* ------------------------------------------------------------------------- */
+/*                    Cif dictionary                                         */
+/* ------------------------------------------------------------------------- */
+// Add a molecule chooser for a new cif file
+//
+void add_cif_dictionary_selector_molecule_selector(GtkWidget *fileselection,
+						   GtkWidget *aa_hbox);
+
 
 
 /* ------------------------------------------------------------------------- */
diff -ruN coot-0.8.7/src/c-interface.h coot-0.8.8-pre/src/c-interface.h
--- coot-0.8.7/src/c-interface.h	2016-10-23 20:10:15.000000000 -0700
+++ coot-0.8.8-pre/src/c-interface.h	2017-01-13 09:52:23.000000000 -0800
@@ -708,6 +708,23 @@
 		       int imol_reference, const char *chain_id_reference, 
 		       int resno_range_start, int resno_range_end);
 
+/*! \brief replace the given residues from the reference molecule to the target molecule
+*/
+#ifdef __cplusplus
+#ifdef USE_GUILE
+int replace_residues_from_mol_scm(int imol_target,
+				 int imol_ref,
+				 SCM residue_specs_list_ref_scm);
+#endif /* USE_GUILE */
+
+#ifdef USE_PYTHON
+int replace_residues_from_mol_py(int imol_target,
+				 int imol_ref,
+				 PyObject *residue_specs_list_ref_py);
+#endif /* USE_PYTHON */
+#endif	/* __cplusplus */
+
+
 /*! \brief replace pdb.  Fail if molecule_number is not a valid model molecule.
   Return -1 on failure.  Else return molecule_number  */
 int clear_and_update_model_molecule_from_file(int molecule_number, 
@@ -2732,6 +2749,17 @@
 /*                    glyco tools test  */
 void glyco_tree_test();
 
+#ifdef __cplusplus
+#ifdef USE_GUILE
+SCM glyco_tree_scm(int imol, SCM active_residue_scm);
+SCM glyco_tree_residues_scm(int imol, SCM active_residue_scm);
+#endif
+#ifdef USE_PYTHON
+PyObject *glyco_tree_py(int imol, PyObject *active_residue_py);
+PyObject *glyco_tree_residues_py(int imol, PyObject *active_residue_py);
+#endif /* PYTHON */
+#endif
+
 
 
 /*  ----------------------------------------------------------------------- */
@@ -3758,6 +3786,7 @@
 		    const char *atom_name_3,
 		    const char *atom_name_4, double tors);
 
+/*! \brief create a multi-residue torsion dialog (user manipulation of torsions) */
 void multi_residue_torsion_scm(int imol, SCM residues_specs_scm);
 
 
@@ -3776,6 +3805,7 @@
 		         const char *atom_name_3,
 		         const char *atom_name_4, double tors);
 
+/*! \brief create a multi-residue torsion dialog (user manipulation of torsions) */
 void multi_residue_torsion_py(int imol, PyObject *residues_specs_py);
 
 #endif  /* USE_PYTHON */
@@ -5729,12 +5759,30 @@
 @return the new molecule number, -1 means an error. */
 int new_molecule_by_atom_selection(int imol, const char* atom_selection);
 
-/*! \brief create a new molecule that consists of only the atoms 
+/*! \brief create a new molecule that consists of only the atoms
   within the given radius (r) of the given position.
 
 @return the new molecule number, -1 means an error. */
 int new_molecule_by_sphere_selection(int imol, float x, float y, float z, 
 				     float r, short int allow_partial_residues);
+
+
+#ifdef __cplusplus
+#ifdef USE_PYTHON
+/*! \brief create a new molecule that consists of only the atoms
+  of the specified list of residues
+@return the new molecule number, -1 means an error. */
+int new_molecule_by_residue_specs_py(int imol, PyObject *residue_spec_list_py);
+#endif /* USE_PYTHON */
+
+#ifdef USE_GUILE
+/*! \brief create a new molecule that consists of only the atoms 
+  of the specified list of residues
+@return the new molecule number, -1 means an error. */
+int new_molecule_by_residue_specs_scm(int imol, SCM *residue_spec_list_scm);
+#endif /* USE_GUILE */
+#endif /* __cplusplus */
+
 /*! \} */
 
 
@@ -5992,7 +6040,7 @@
 void handle_online_coot_search_request(const char *entry_text);
 /* \} */
 
-#include "c-interface-generic-objects.h"
+// #include "c-interface-generic-objects.h"
 
 
 /*  ----------------------------------------------------------------------- */
diff -ruN coot-0.8.7/src/callbacks.c coot-0.8.8-pre/src/callbacks.c
--- coot-0.8.7/src/callbacks.c	2016-11-01 08:46:49.000000000 -0700
+++ coot-0.8.8-pre/src/callbacks.c	2017-01-24 09:37:54.000000000 -0800
@@ -12249,6 +12249,7 @@
 
   GtkWidget *w = lookup_widget(GTK_WIDGET(button), "generic_objects_dialog");
   gtk_widget_hide(w);
+  graphics_draw();
 
 } 
 
@@ -12257,7 +12258,8 @@
 on_generic_objects_dialog_close        (GtkDialog       *dialog,
                                         gpointer         user_data) { 
 
-  printf("on_generic_objects_dialog_close\n");
+/*   printf("on_generic_objects_dialog_close\n"); */
+  graphics_draw();
 
 }
 
diff -ruN coot-0.8.7/src/coot-render.hh coot-0.8.8-pre/src/coot-render.hh
--- coot-0.8.7/src/coot-render.hh	2016-10-08 10:35:45.000000000 -0700
+++ coot-0.8.8-pre/src/coot-render.hh	2016-12-27 13:13:20.000000000 -0800
@@ -21,11 +21,28 @@
 
    class ray_trace_molecule_info {
 
-      float bond_thickness; 
       float density_thickness;
       float zoom;
    public:
 
+      class bond_t {
+      public:
+         Cartesian begin_pos;
+         Cartesian end_pos;
+         double bond_thickness;
+	 bond_t (const Cartesian &b, const Cartesian &e, double bt) {
+	    begin_pos = b;
+	    end_pos = e;
+	    bond_thickness = bt;
+	 }
+      };
+
+      class coloured_bonds_container_t {
+      public:
+         std::vector<bond_t> bonds;
+         colour_t colour;
+      };
+
       class ball_t {
       public:
 	 Cartesian pos;
@@ -59,10 +76,10 @@
       std::vector<std::pair<Cartesian, Cartesian> > density_lines;
       colour_t density_colour;
       // bond_lines and bond_colour have the same size.
-      std::vector<std::pair<Cartesian, Cartesian> > bond_lines;
+      std::vector<coloured_bonds_container_t> bond_lines;
       std::vector<std::pair<Cartesian, Cartesian> > bone_lines;
       std::vector<colour_t> bond_colour;
-      std::vector<std::pair<Cartesian, colour_t> > atom;
+      // std::vector<std::pair<Cartesian, colour_t> > atom;
       std::vector<ball_t> balls;
 
       // extra restraints representation
diff -ruN coot-0.8.7/src/coot.i coot-0.8.8-pre/src/coot.i
--- coot-0.8.7/src/coot.i	2016-09-09 09:43:25.000000000 -0700
+++ coot-0.8.8-pre/src/coot.i	2016-12-21 05:34:30.000000000 -0800
@@ -18,6 +18,8 @@
 #include "cc-interface-scripting.hh"
 #include "c-interface-refmac.h"
 #include "cc-interface-ncs.hh"
+#include "c-interface-generic-objects.h"
+#include "generic-display-objects-c.h"
 #include "manipulation-modes.hh"
 #include "rotamer-search-modes.hh"
 #include "lbg-interface.hh"
@@ -78,6 +80,7 @@
 %include "coot-version.hh"
 %include "get-monomer.hh"
 %include "globularize.hh"
+%include "generic-display-objects-c.h"
 %include "cfc.hh"
 %include "cc-interface-user-defined-atom-colours.hh"
 %include "../coords/phenix-geo.hh"
diff -ruN coot-0.8.7/src/coot.py coot-0.8.8-pre/src/coot.py
--- coot-0.8.7/src/coot.py	2016-11-01 08:50:03.000000000 -0700
+++ coot-0.8.8-pre/src/coot.py	2017-01-13 09:54:26.000000000 -0800
@@ -1041,6 +1041,10 @@
     return _coot.copy_residue_range(imol_target, chain_id_target, imol_reference, chain_id_reference, resno_range_start, resno_range_end)
 copy_residue_range = _coot.copy_residue_range
 
+def replace_residues_from_mol_py(imol_target, imol_ref, residue_specs_list_ref_py):
+    return _coot.replace_residues_from_mol_py(imol_target, imol_ref, residue_specs_list_ref_py)
+replace_residues_from_mol_py = _coot.replace_residues_from_mol_py
+
 def clear_and_update_model_molecule_from_file(molecule_number, file_name):
     return _coot.clear_and_update_model_molecule_from_file(molecule_number, file_name)
 clear_and_update_model_molecule_from_file = _coot.clear_and_update_model_molecule_from_file
@@ -2531,6 +2535,14 @@
     return _coot.glyco_tree_test()
 glyco_tree_test = _coot.glyco_tree_test
 
+def glyco_tree_py(imol, active_residue_py):
+    return _coot.glyco_tree_py(imol, active_residue_py)
+glyco_tree_py = _coot.glyco_tree_py
+
+def glyco_tree_residues_py(imol, active_residue_py):
+    return _coot.glyco_tree_residues_py(imol, active_residue_py)
+glyco_tree_residues_py = _coot.glyco_tree_residues_py
+
 def post_display_control_window():
     return _coot.post_display_control_window()
 post_display_control_window = _coot.post_display_control_window
@@ -4931,6 +4943,10 @@
     return _coot.new_molecule_by_sphere_selection(imol, x, y, z, r, allow_partial_residues)
 new_molecule_by_sphere_selection = _coot.new_molecule_by_sphere_selection
 
+def new_molecule_by_residue_specs_py(imol, residue_spec_list_py):
+    return _coot.new_molecule_by_residue_specs_py(imol, residue_spec_list_py)
+new_molecule_by_residue_specs_py = _coot.new_molecule_by_residue_specs_py
+
 def set_axis_orientation_matrix(m11, m12, m13, m21, m22, m23, m31, m32, m33):
     return _coot.set_axis_orientation_matrix(m11, m12, m13, m21, m22, m23, m31, m32, m33)
 set_axis_orientation_matrix = _coot.set_axis_orientation_matrix
@@ -6531,6 +6547,22 @@
     return _coot.comprised_of_organic_set_p(rn)
 comprised_of_organic_set_p = _coot.comprised_of_organic_set_p
 
+def coot_all_atom_contact_dots(imol):
+    return _coot.coot_all_atom_contact_dots(imol)
+coot_all_atom_contact_dots = _coot.coot_all_atom_contact_dots
+
+def coot_contact_dots_for_ligand_py(imol, ligand_spec):
+    return _coot.coot_contact_dots_for_ligand_py(imol, ligand_spec)
+coot_contact_dots_for_ligand_py = _coot.coot_contact_dots_for_ligand_py
+
+def switch_HIS_protonation_py(imol, residue_spec):
+    return _coot.switch_HIS_protonation_py(imol, residue_spec)
+switch_HIS_protonation_py = _coot.switch_HIS_protonation_py
+
+def coot_reduce(imol):
+    return _coot.coot_reduce(imol)
+coot_reduce = _coot.coot_reduce
+
 def get_ligand_percentile(metric_name, metric_value, reverse_order):
     return _coot.get_ligand_percentile(metric_name, metric_value, reverse_order)
 get_ligand_percentile = _coot.get_ligand_percentile
@@ -6749,9 +6781,9 @@
     return _coot.set_display_generic_object(object_number, istate)
 set_display_generic_object = _coot.set_display_generic_object
 
-def set_display_all_generic_objects(state):
-    return _coot.set_display_all_generic_objects(state)
-set_display_all_generic_objects = _coot.set_display_all_generic_objects
+def set_display_generic_object_simple(object_number, istate):
+    return _coot.set_display_generic_object_simple(object_number, istate)
+set_display_generic_object_simple = _coot.set_display_generic_object_simple
 
 def generic_object_is_displayed_p(object_number):
     return _coot.generic_object_is_displayed_p(object_number)
@@ -6785,18 +6817,10 @@
     return _coot.is_closed_generic_object_p(object_number)
 is_closed_generic_object_p = _coot.is_closed_generic_object_p
 
-def close_all_generic_objects():
-    return _coot.close_all_generic_objects()
-close_all_generic_objects = _coot.close_all_generic_objects
-
 def generic_object_clear(object_number):
     return _coot.generic_object_clear(object_number)
 generic_object_clear = _coot.generic_object_clear
 
-def generic_objects_gui_wrapper():
-    return _coot.generic_objects_gui_wrapper()
-generic_objects_gui_wrapper = _coot.generic_objects_gui_wrapper
-
 def attach_generic_object_to_molecule(obj_number, imol):
     return _coot.attach_generic_object_to_molecule(obj_number, imol)
 attach_generic_object_to_molecule = _coot.attach_generic_object_to_molecule
@@ -7173,6 +7197,9 @@
     def unset_p(self):
         return _coot.residue_spec_t_unset_p(self)
 
+    def empty(self):
+        return _coot.residue_spec_t_empty(self)
+
     def next(self):
         return _coot.residue_spec_t_next(self)
 
@@ -7372,6 +7399,22 @@
     return _coot.globularize(imol)
 globularize = _coot.globularize
 
+def clear_generic_objects_dialog_pointer():
+    return _coot.clear_generic_objects_dialog_pointer()
+clear_generic_objects_dialog_pointer = _coot.clear_generic_objects_dialog_pointer
+
+def set_display_all_generic_objects(state):
+    return _coot.set_display_all_generic_objects(state)
+set_display_all_generic_objects = _coot.set_display_all_generic_objects
+
+def generic_objects_gui_wrapper():
+    return _coot.generic_objects_gui_wrapper()
+generic_objects_gui_wrapper = _coot.generic_objects_gui_wrapper
+
+def close_all_generic_objects():
+    return _coot.close_all_generic_objects()
+close_all_generic_objects = _coot.close_all_generic_objects
+
 def set_user_defined_atom_colour_by_residue_py(imol, residue_specs_colour_index_tuple_list_py):
     return _coot.set_user_defined_atom_colour_by_residue_py(imol, residue_specs_colour_index_tuple_list_py)
 set_user_defined_atom_colour_by_residue_py = _coot.set_user_defined_atom_colour_by_residue_py
diff -ruN coot-0.8.7/src/coot_wrap_guile.cc coot-0.8.8-pre/src/coot_wrap_guile.cc
--- coot-0.8.7/src/coot_wrap_guile.cc	2016-11-01 08:50:00.000000000 -0700
+++ coot-0.8.8-pre/src/coot_wrap_guile.cc	2017-01-13 09:54:22.000000000 -0800
@@ -1400,6 +1400,8 @@
 #include "cc-interface-scripting.hh"
 #include "c-interface-refmac.h"
 #include "cc-interface-ncs.hh"
+#include "c-interface-generic-objects.h"
+#include "generic-display-objects-c.h"
 #include "manipulation-modes.hh"
 #include "rotamer-search-modes.hh"
 #include "lbg-interface.hh"
@@ -5890,6 +5892,34 @@
 
 
 static SCM
+_wrap_replace_residues_from_mol_scm (SCM s_0, SCM s_1, SCM s_2)
+{
+#define FUNC_NAME "replace-residues-from-mol-scm"
+  int arg1 ;
+  int arg2 ;
+  SCM arg3 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  int result;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  {
+    arg2 = (int) scm_to_int(s_1);
+  }
+  arg3=s_2;
+  result = (int)replace_residues_from_mol_scm(arg1,arg2,arg3);
+  {
+    gswig_result = scm_from_long(result);
+  }
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
 _wrap_clear_and_update_model_molecule_from_file (SCM s_0, SCM s_1)
 {
 #define FUNC_NAME "clear-and-update-model-molecule-from-file"
@@ -14570,6 +14600,50 @@
 
 
 static SCM
+_wrap_glyco_tree_scm (SCM s_0, SCM s_1)
+{
+#define FUNC_NAME "glyco-tree-scm"
+  int arg1 ;
+  SCM arg2 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  SCM result;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  arg2=s_1;
+  result = (SCM)glyco_tree_scm(arg1,arg2);
+  gswig_result=result;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_glyco_tree_residues_scm (SCM s_0, SCM s_1)
+{
+#define FUNC_NAME "glyco-tree-residues-scm"
+  int arg1 ;
+  SCM arg2 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  SCM result;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  arg2=s_1;
+  result = (SCM)glyco_tree_residues_scm(arg1,arg2);
+  gswig_result=result;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
 _wrap_post_display_control_window ()
 {
 #define FUNC_NAME "post-display-control-window"
@@ -29201,6 +29275,33 @@
 
 
 static SCM
+_wrap_new_molecule_by_residue_specs_scm (SCM s_0, SCM s_1)
+{
+#define FUNC_NAME "new-molecule-by-residue-specs-scm"
+  int arg1 ;
+  SCM *arg2 = (SCM *) 0 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  int result;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  {
+    arg2 = (SCM *)SWIG_MustGetPtr(s_1, SWIGTYPE_p_unsigned_long, 2, 0);
+  }
+  result = (int)new_molecule_by_residue_specs_scm(arg1,arg2);
+  {
+    gswig_result = scm_from_long(result);
+  }
+  
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
 _wrap_set_axis_orientation_matrix (SCM s_0, SCM s_1, SCM s_2, SCM s_3, SCM s_4, SCM s_5, SCM s_6, SCM s_7, SCM s_8)
 {
 #define FUNC_NAME "set-axis-orientation-matrix"
@@ -40821,6 +40922,86 @@
 
 
 static SCM
+_wrap_coot_all_atom_contact_dots (SCM s_0)
+{
+#define FUNC_NAME "coot-all-atom-contact-dots"
+  int arg1 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  coot_all_atom_contact_dots(arg1);
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_coot_reduce (SCM s_0)
+{
+#define FUNC_NAME "coot-reduce"
+  int arg1 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  coot_reduce(arg1);
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_coot_contact_dots_for_ligand_scm (SCM s_0, SCM s_1)
+{
+#define FUNC_NAME "coot-contact-dots-for-ligand-scm"
+  int arg1 ;
+  SCM arg2 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  arg2=s_1;
+  coot_contact_dots_for_ligand_scm(arg1,arg2);
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_switch_HIS_protonation_scm (SCM s_0, SCM s_1)
+{
+#define FUNC_NAME "switch-HIS-protonation-scm"
+  int arg1 ;
+  SCM arg2 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  arg2=s_1;
+  switch_HIS_protonation_scm(arg1,arg2);
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
 _wrap_get_ligand_percentile (SCM s_0, SCM s_1, SCM s_2)
 {
 #define FUNC_NAME "get-ligand-percentile"
@@ -42341,17 +42522,21 @@
 
 
 static SCM
-_wrap_set_display_all_generic_objects (SCM s_0)
+_wrap_set_display_generic_object_simple (SCM s_0, SCM s_1)
 {
-#define FUNC_NAME "set-display-all-generic-objects"
+#define FUNC_NAME "set-display-generic-object-simple"
   int arg1 ;
+  short arg2 ;
   SCM gswig_result;
   SWIGUNUSED int gswig_list_p = 0;
   
   {
     arg1 = (int) scm_to_int(s_0);
   }
-  set_display_all_generic_objects(arg1);
+  {
+    arg2 = (short) scm_to_short(s_1);
+  }
+  set_display_generic_object_simple(arg1,arg2);
   gswig_result = SCM_UNSPECIFIED;
   
   return gswig_result;
@@ -42523,21 +42708,6 @@
 
 
 static SCM
-_wrap_close_all_generic_objects ()
-{
-#define FUNC_NAME "close-all-generic-objects"
-  SCM gswig_result;
-  SWIGUNUSED int gswig_list_p = 0;
-  
-  close_all_generic_objects();
-  gswig_result = SCM_UNSPECIFIED;
-  
-  return gswig_result;
-#undef FUNC_NAME
-}
-
-
-static SCM
 _wrap_generic_object_clear (SCM s_0)
 {
 #define FUNC_NAME "generic-object-clear"
@@ -42557,21 +42727,6 @@
 
 
 static SCM
-_wrap_generic_objects_gui_wrapper ()
-{
-#define FUNC_NAME "generic-objects-gui-wrapper"
-  SCM gswig_result;
-  SWIGUNUSED int gswig_list_p = 0;
-  
-  generic_objects_gui_wrapper();
-  gswig_result = SCM_UNSPECIFIED;
-  
-  return gswig_result;
-#undef FUNC_NAME
-}
-
-
-static SCM
 _wrap_attach_generic_object_to_molecule (SCM s_0, SCM s_1)
 {
 #define FUNC_NAME "attach-generic-object-to-molecule"
@@ -46901,6 +47056,29 @@
 
 
 static SCM
+_wrap_residue_spec_t_empty (SCM s_0)
+{
+#define FUNC_NAME "residue-spec-t-empty"
+  coot::residue_spec_t *arg1 = (coot::residue_spec_t *) 0 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  bool result;
+  
+  {
+    arg1 = (coot::residue_spec_t *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_coot__residue_spec_t, 1, 0);
+  }
+  result = (bool)((coot::residue_spec_t const *)arg1)->empty();
+  {
+    gswig_result = scm_from_bool(result);
+  }
+  
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
 _wrap_residue_spec_t_next (SCM s_0)
 {
 #define FUNC_NAME "residue-spec-t-next"
@@ -48227,6 +48405,70 @@
 
 
 static SCM
+_wrap_clear_generic_objects_dialog_pointer ()
+{
+#define FUNC_NAME "clear-generic-objects-dialog-pointer"
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  clear_generic_objects_dialog_pointer();
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_set_display_all_generic_objects (SCM s_0)
+{
+#define FUNC_NAME "set-display-all-generic-objects"
+  int arg1 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  set_display_all_generic_objects(arg1);
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_generic_objects_gui_wrapper ()
+{
+#define FUNC_NAME "generic-objects-gui-wrapper"
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  generic_objects_gui_wrapper();
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_close_all_generic_objects ()
+{
+#define FUNC_NAME "close-all-generic-objects"
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  close_all_generic_objects();
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
 _wrap_set_user_defined_atom_colour_scm (SCM s_0, SCM s_1)
 {
 #define FUNC_NAME "set-user-defined-atom-colour-scm"
@@ -49699,6 +49941,7 @@
   scm_c_define_gsubr("het-group-n-atoms", 1, 0, 0, (swig_guile_proc) _wrap_het_group_n_atoms);
   scm_c_define_gsubr("replace-fragment", 3, 0, 0, (swig_guile_proc) _wrap_replace_fragment);
   scm_c_define_gsubr("copy-residue-range", 6, 0, 0, (swig_guile_proc) _wrap_copy_residue_range);
+  scm_c_define_gsubr("replace-residues-from-mol-scm", 3, 0, 0, (swig_guile_proc) _wrap_replace_residues_from_mol_scm);
   scm_c_define_gsubr("clear-and-update-model-molecule-from-file", 2, 0, 0, (swig_guile_proc) _wrap_clear_and_update_model_molecule_from_file);
   scm_c_define_gsubr("screendump-image", 1, 0, 0, (swig_guile_proc) _wrap_screendump_image);
   scm_c_define_gsubr("check-for-dark-blue-density", 0, 0, 0, (swig_guile_proc) _wrap_check_for_dark_blue_density);
@@ -50071,6 +50314,8 @@
   scm_c_define_gsubr("test-function", 2, 0, 0, (swig_guile_proc) _wrap_test_function);
   scm_c_define_gsubr("test-function-scm", 2, 0, 0, (swig_guile_proc) _wrap_test_function_scm);
   scm_c_define_gsubr("glyco-tree-test", 0, 0, 0, (swig_guile_proc) _wrap_glyco_tree_test);
+  scm_c_define_gsubr("glyco-tree-scm", 2, 0, 0, (swig_guile_proc) _wrap_glyco_tree_scm);
+  scm_c_define_gsubr("glyco-tree-residues-scm", 2, 0, 0, (swig_guile_proc) _wrap_glyco_tree_residues_scm);
   scm_c_define_gsubr("post-display-control-window", 0, 0, 0, (swig_guile_proc) _wrap_post_display_control_window);
   scm_c_define_gsubr("add-map-display-control-widgets", 0, 0, 0, (swig_guile_proc) _wrap_add_map_display_control_widgets);
   scm_c_define_gsubr("add-mol-display-control-widgets", 0, 0, 0, (swig_guile_proc) _wrap_add_mol_display_control_widgets);
@@ -50667,6 +50912,7 @@
   scm_c_define_gsubr("new-molecule-by-residue-type-selection", 2, 0, 0, (swig_guile_proc) _wrap_new_molecule_by_residue_type_selection);
   scm_c_define_gsubr("new-molecule-by-atom-selection", 2, 0, 0, (swig_guile_proc) _wrap_new_molecule_by_atom_selection);
   scm_c_define_gsubr("new-molecule-by-sphere-selection", 6, 0, 0, (swig_guile_proc) _wrap_new_molecule_by_sphere_selection);
+  scm_c_define_gsubr("new-molecule-by-residue-specs-scm", 2, 0, 0, (swig_guile_proc) _wrap_new_molecule_by_residue_specs_scm);
   scm_c_define_gsubr("set-axis-orientation-matrix", 9, 0, 0, (swig_guile_proc) _wrap_set_axis_orientation_matrix);
   scm_c_define_gsubr("set-axis-orientation-matrix-usage", 1, 0, 0, (swig_guile_proc) _wrap_set_axis_orientation_matrix_usage);
   scm_c_define_gsubr("ideal-nucleic-acid", 4, 0, 0, (swig_guile_proc) _wrap_ideal_nucleic_acid);
@@ -51063,6 +51309,10 @@
   scm_c_define_gsubr("match-residue-and-dictionary", 10, 0, 0, (swig_guile_proc) _wrap_match_residue_and_dictionary);
   scm_c_define_gsubr("match-this-residue-and-dictionary", 7, 0, 0, (swig_guile_proc) _wrap_match_this_residue_and_dictionary);
   scm_c_define_gsubr("comprised-of-organic-set-p", 1, 0, 0, (swig_guile_proc) _wrap_comprised_of_organic_set_p);
+  scm_c_define_gsubr("coot-all-atom-contact-dots", 1, 0, 0, (swig_guile_proc) _wrap_coot_all_atom_contact_dots);
+  scm_c_define_gsubr("coot-reduce", 1, 0, 0, (swig_guile_proc) _wrap_coot_reduce);
+  scm_c_define_gsubr("coot-contact-dots-for-ligand-scm", 2, 0, 0, (swig_guile_proc) _wrap_coot_contact_dots_for_ligand_scm);
+  scm_c_define_gsubr("switch-HIS-protonation-scm", 2, 0, 0, (swig_guile_proc) _wrap_switch_HIS_protonation_scm);
   scm_c_define_gsubr("get-ligand-percentile", 3, 0, 0, (swig_guile_proc) _wrap_get_ligand_percentile);
   scm_c_define_gsubr("enhanced-ligand-coot-p", 0, 0, 0, (swig_guile_proc) _wrap_enhanced_ligand_coot_p);
   scm_c_define_gsubr("mogul-markup", 5, 0, 0, (swig_guile_proc) _wrap_mogul_markup);
@@ -51120,7 +51370,7 @@
   scm_c_define_gsubr("to-generic-object-add-pentakis-dodecahedron", 7, 0, 0, (swig_guile_proc) _wrap_to_generic_object_add_pentakis_dodecahedron);
   scm_c_define_gsubr("to-generic-object-add-display-list-handle", 2, 0, 0, (swig_guile_proc) _wrap_to_generic_object_add_display_list_handle);
   scm_c_define_gsubr("set-display-generic-object", 2, 0, 0, (swig_guile_proc) _wrap_set_display_generic_object);
-  scm_c_define_gsubr("set-display-all-generic-objects", 1, 0, 0, (swig_guile_proc) _wrap_set_display_all_generic_objects);
+  scm_c_define_gsubr("set-display-generic-object-simple", 2, 0, 0, (swig_guile_proc) _wrap_set_display_generic_object_simple);
   scm_c_define_gsubr("generic-object-is-displayed-p", 1, 0, 0, (swig_guile_proc) _wrap_generic_object_is_displayed_p);
   scm_c_define_gsubr("generic-object-index", 1, 0, 0, (swig_guile_proc) _wrap_generic_object_index);
   scm_c_define_gsubr("generic-object-name-scm", 1, 0, 0, (swig_guile_proc) _wrap_generic_object_name_scm);
@@ -51129,9 +51379,7 @@
   scm_c_define_gsubr("generic-object-has-objects-p", 1, 0, 0, (swig_guile_proc) _wrap_generic_object_has_objects_p);
   scm_c_define_gsubr("close-generic-object", 1, 0, 0, (swig_guile_proc) _wrap_close_generic_object);
   scm_c_define_gsubr("is-closed-generic-object-p", 1, 0, 0, (swig_guile_proc) _wrap_is_closed_generic_object_p);
-  scm_c_define_gsubr("close-all-generic-objects", 0, 0, 0, (swig_guile_proc) _wrap_close_all_generic_objects);
   scm_c_define_gsubr("generic-object-clear", 1, 0, 0, (swig_guile_proc) _wrap_generic_object_clear);
-  scm_c_define_gsubr("generic-objects-gui-wrapper", 0, 0, 0, (swig_guile_proc) _wrap_generic_objects_gui_wrapper);
   scm_c_define_gsubr("attach-generic-object-to-molecule", 2, 0, 0, (swig_guile_proc) _wrap_attach_generic_object_to_molecule);
   scm_c_define_gsubr("set-display-generic-objects-as-solid", 1, 0, 0, (swig_guile_proc) _wrap_set_display_generic_objects_as_solid);
   SWIG_TypeClientData(SWIGTYPE_p_coot__mtz_type_label, (void *) &_swig_guile_clientdatamtz_type_label);
@@ -51284,6 +51532,7 @@
   scm_c_define_gsubr("residue-spec-t-int-user-data-get", 1, 0, 0, (swig_guile_proc) _wrap_residue_spec_t_int_user_data_get);
   scm_c_define_gsubr("new-residue-spec-t", 0, 0, 1, (swig_guile_proc) _wrap_new_residue_spec_t);
   scm_c_define_gsubr("residue-spec-t-unset-p", 1, 0, 0, (swig_guile_proc) _wrap_residue_spec_t_unset_p);
+  scm_c_define_gsubr("residue-spec-t-empty", 1, 0, 0, (swig_guile_proc) _wrap_residue_spec_t_empty);
   scm_c_define_gsubr("residue-spec-t-next", 1, 0, 0, (swig_guile_proc) _wrap_residue_spec_t_next);
   scm_c_define_gsubr("residue-spec-t-previous", 1, 0, 0, (swig_guile_proc) _wrap_residue_spec_t_previous);
   scm_c_define_gsubr("residue-spec-t-format", 1, 0, 0, (swig_guile_proc) _wrap_residue_spec_t_format);
@@ -51343,6 +51592,10 @@
   scm_c_define_gsubr("get-monomer-for-molecule", 2, 0, 0, (swig_guile_proc) _wrap_get_monomer_for_molecule);
   scm_c_define_gsubr("get-monomer-from-dictionary", 2, 0, 0, (swig_guile_proc) _wrap_get_monomer_from_dictionary);
   scm_c_define_gsubr("globularize", 1, 0, 0, (swig_guile_proc) _wrap_globularize);
+  scm_c_define_gsubr("clear-generic-objects-dialog-pointer", 0, 0, 0, (swig_guile_proc) _wrap_clear_generic_objects_dialog_pointer);
+  scm_c_define_gsubr("set-display-all-generic-objects", 1, 0, 0, (swig_guile_proc) _wrap_set_display_all_generic_objects);
+  scm_c_define_gsubr("generic-objects-gui-wrapper", 0, 0, 0, (swig_guile_proc) _wrap_generic_objects_gui_wrapper);
+  scm_c_define_gsubr("close-all-generic-objects", 0, 0, 0, (swig_guile_proc) _wrap_close_all_generic_objects);
   scm_c_define_gsubr("set-user-defined-atom-colour-scm", 2, 0, 0, (swig_guile_proc) _wrap_set_user_defined_atom_colour_scm);
   scm_c_define_gsubr("set-user-defined-atom-colour-by-residue-scm", 2, 0, 0, (swig_guile_proc) _wrap_set_user_defined_atom_colour_by_residue_scm);
   scm_c_define_gsubr("clear-user-defined-atom-colours", 1, 0, 0, (swig_guile_proc) _wrap_clear_user_defined_atom_colours);
diff -ruN coot-0.8.7/src/coot_wrap_guile_pre.cc coot-0.8.8-pre/src/coot_wrap_guile_pre.cc
--- coot-0.8.7/src/coot_wrap_guile_pre.cc	2016-11-01 08:49:24.000000000 -0700
+++ coot-0.8.8-pre/src/coot_wrap_guile_pre.cc	2017-01-13 09:53:48.000000000 -0800
@@ -1394,6 +1394,8 @@
 #include "cc-interface-scripting.hh"
 #include "c-interface-refmac.h"
 #include "cc-interface-ncs.hh"
+#include "c-interface-generic-objects.h"
+#include "generic-display-objects-c.h"
 #include "manipulation-modes.hh"
 #include "rotamer-search-modes.hh"
 #include "lbg-interface.hh"
@@ -5884,6 +5886,34 @@
 
 
 static SCM
+_wrap_replace_residues_from_mol_scm (SCM s_0, SCM s_1, SCM s_2)
+{
+#define FUNC_NAME "replace-residues-from-mol-scm"
+  int arg1 ;
+  int arg2 ;
+  SCM arg3 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  int result;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  {
+    arg2 = (int) scm_to_int(s_1);
+  }
+  arg3=s_2;
+  result = (int)replace_residues_from_mol_scm(arg1,arg2,arg3);
+  {
+    gswig_result = scm_from_long(result);
+  }
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
 _wrap_clear_and_update_model_molecule_from_file (SCM s_0, SCM s_1)
 {
 #define FUNC_NAME "clear-and-update-model-molecule-from-file"
@@ -14564,6 +14594,50 @@
 
 
 static SCM
+_wrap_glyco_tree_scm (SCM s_0, SCM s_1)
+{
+#define FUNC_NAME "glyco-tree-scm"
+  int arg1 ;
+  SCM arg2 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  SCM result;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  arg2=s_1;
+  result = (SCM)glyco_tree_scm(arg1,arg2);
+  gswig_result=result;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_glyco_tree_residues_scm (SCM s_0, SCM s_1)
+{
+#define FUNC_NAME "glyco-tree-residues-scm"
+  int arg1 ;
+  SCM arg2 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  SCM result;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  arg2=s_1;
+  result = (SCM)glyco_tree_residues_scm(arg1,arg2);
+  gswig_result=result;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
 _wrap_post_display_control_window ()
 {
 #define FUNC_NAME "post-display-control-window"
@@ -29195,6 +29269,33 @@
 
 
 static SCM
+_wrap_new_molecule_by_residue_specs_scm (SCM s_0, SCM s_1)
+{
+#define FUNC_NAME "new-molecule-by-residue-specs-scm"
+  int arg1 ;
+  SCM *arg2 = (SCM *) 0 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  int result;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  {
+    arg2 = (SCM *)SWIG_MustGetPtr(s_1, SWIGTYPE_p_unsigned_long, 2, 0);
+  }
+  result = (int)new_molecule_by_residue_specs_scm(arg1,arg2);
+  {
+    gswig_result = scm_from_long(result);
+  }
+  
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
 _wrap_set_axis_orientation_matrix (SCM s_0, SCM s_1, SCM s_2, SCM s_3, SCM s_4, SCM s_5, SCM s_6, SCM s_7, SCM s_8)
 {
 #define FUNC_NAME "set-axis-orientation-matrix"
@@ -40815,6 +40916,86 @@
 
 
 static SCM
+_wrap_coot_all_atom_contact_dots (SCM s_0)
+{
+#define FUNC_NAME "coot-all-atom-contact-dots"
+  int arg1 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  coot_all_atom_contact_dots(arg1);
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_coot_reduce (SCM s_0)
+{
+#define FUNC_NAME "coot-reduce"
+  int arg1 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  coot_reduce(arg1);
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_coot_contact_dots_for_ligand_scm (SCM s_0, SCM s_1)
+{
+#define FUNC_NAME "coot-contact-dots-for-ligand-scm"
+  int arg1 ;
+  SCM arg2 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  arg2=s_1;
+  coot_contact_dots_for_ligand_scm(arg1,arg2);
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_switch_HIS_protonation_scm (SCM s_0, SCM s_1)
+{
+#define FUNC_NAME "switch-HIS-protonation-scm"
+  int arg1 ;
+  SCM arg2 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  arg2=s_1;
+  switch_HIS_protonation_scm(arg1,arg2);
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
 _wrap_get_ligand_percentile (SCM s_0, SCM s_1, SCM s_2)
 {
 #define FUNC_NAME "get-ligand-percentile"
@@ -42335,17 +42516,21 @@
 
 
 static SCM
-_wrap_set_display_all_generic_objects (SCM s_0)
+_wrap_set_display_generic_object_simple (SCM s_0, SCM s_1)
 {
-#define FUNC_NAME "set-display-all-generic-objects"
+#define FUNC_NAME "set-display-generic-object-simple"
   int arg1 ;
+  short arg2 ;
   SCM gswig_result;
   SWIGUNUSED int gswig_list_p = 0;
   
   {
     arg1 = (int) scm_to_int(s_0);
   }
-  set_display_all_generic_objects(arg1);
+  {
+    arg2 = (short) scm_to_short(s_1);
+  }
+  set_display_generic_object_simple(arg1,arg2);
   gswig_result = SCM_UNSPECIFIED;
   
   return gswig_result;
@@ -42517,21 +42702,6 @@
 
 
 static SCM
-_wrap_close_all_generic_objects ()
-{
-#define FUNC_NAME "close-all-generic-objects"
-  SCM gswig_result;
-  SWIGUNUSED int gswig_list_p = 0;
-  
-  close_all_generic_objects();
-  gswig_result = SCM_UNSPECIFIED;
-  
-  return gswig_result;
-#undef FUNC_NAME
-}
-
-
-static SCM
 _wrap_generic_object_clear (SCM s_0)
 {
 #define FUNC_NAME "generic-object-clear"
@@ -42551,21 +42721,6 @@
 
 
 static SCM
-_wrap_generic_objects_gui_wrapper ()
-{
-#define FUNC_NAME "generic-objects-gui-wrapper"
-  SCM gswig_result;
-  SWIGUNUSED int gswig_list_p = 0;
-  
-  generic_objects_gui_wrapper();
-  gswig_result = SCM_UNSPECIFIED;
-  
-  return gswig_result;
-#undef FUNC_NAME
-}
-
-
-static SCM
 _wrap_attach_generic_object_to_molecule (SCM s_0, SCM s_1)
 {
 #define FUNC_NAME "attach-generic-object-to-molecule"
@@ -46895,6 +47050,29 @@
 
 
 static SCM
+_wrap_residue_spec_t_empty (SCM s_0)
+{
+#define FUNC_NAME "residue-spec-t-empty"
+  coot::residue_spec_t *arg1 = (coot::residue_spec_t *) 0 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  bool result;
+  
+  {
+    arg1 = (coot::residue_spec_t *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_coot__residue_spec_t, 1, 0);
+  }
+  result = (bool)((coot::residue_spec_t const *)arg1)->empty();
+  {
+    gswig_result = scm_from_bool(result);
+  }
+  
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
 _wrap_residue_spec_t_next (SCM s_0)
 {
 #define FUNC_NAME "residue-spec-t-next"
@@ -48221,6 +48399,70 @@
 
 
 static SCM
+_wrap_clear_generic_objects_dialog_pointer ()
+{
+#define FUNC_NAME "clear-generic-objects-dialog-pointer"
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  clear_generic_objects_dialog_pointer();
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_set_display_all_generic_objects (SCM s_0)
+{
+#define FUNC_NAME "set-display-all-generic-objects"
+  int arg1 ;
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  {
+    arg1 = (int) scm_to_int(s_0);
+  }
+  set_display_all_generic_objects(arg1);
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_generic_objects_gui_wrapper ()
+{
+#define FUNC_NAME "generic-objects-gui-wrapper"
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  generic_objects_gui_wrapper();
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
+_wrap_close_all_generic_objects ()
+{
+#define FUNC_NAME "close-all-generic-objects"
+  SCM gswig_result;
+  SWIGUNUSED int gswig_list_p = 0;
+  
+  close_all_generic_objects();
+  gswig_result = SCM_UNSPECIFIED;
+  
+  return gswig_result;
+#undef FUNC_NAME
+}
+
+
+static SCM
 _wrap_set_user_defined_atom_colour_scm (SCM s_0, SCM s_1)
 {
 #define FUNC_NAME "set-user-defined-atom-colour-scm"
@@ -49693,6 +49935,7 @@
   scm_c_define_gsubr("het-group-n-atoms", 1, 0, 0, (swig_guile_proc) _wrap_het_group_n_atoms);
   scm_c_define_gsubr("replace-fragment", 3, 0, 0, (swig_guile_proc) _wrap_replace_fragment);
   scm_c_define_gsubr("copy-residue-range", 6, 0, 0, (swig_guile_proc) _wrap_copy_residue_range);
+  scm_c_define_gsubr("replace-residues-from-mol-scm", 3, 0, 0, (swig_guile_proc) _wrap_replace_residues_from_mol_scm);
   scm_c_define_gsubr("clear-and-update-model-molecule-from-file", 2, 0, 0, (swig_guile_proc) _wrap_clear_and_update_model_molecule_from_file);
   scm_c_define_gsubr("screendump-image", 1, 0, 0, (swig_guile_proc) _wrap_screendump_image);
   scm_c_define_gsubr("check-for-dark-blue-density", 0, 0, 0, (swig_guile_proc) _wrap_check_for_dark_blue_density);
@@ -50065,6 +50308,8 @@
   scm_c_define_gsubr("test-function", 2, 0, 0, (swig_guile_proc) _wrap_test_function);
   scm_c_define_gsubr("test-function-scm", 2, 0, 0, (swig_guile_proc) _wrap_test_function_scm);
   scm_c_define_gsubr("glyco-tree-test", 0, 0, 0, (swig_guile_proc) _wrap_glyco_tree_test);
+  scm_c_define_gsubr("glyco-tree-scm", 2, 0, 0, (swig_guile_proc) _wrap_glyco_tree_scm);
+  scm_c_define_gsubr("glyco-tree-residues-scm", 2, 0, 0, (swig_guile_proc) _wrap_glyco_tree_residues_scm);
   scm_c_define_gsubr("post-display-control-window", 0, 0, 0, (swig_guile_proc) _wrap_post_display_control_window);
   scm_c_define_gsubr("add-map-display-control-widgets", 0, 0, 0, (swig_guile_proc) _wrap_add_map_display_control_widgets);
   scm_c_define_gsubr("add-mol-display-control-widgets", 0, 0, 0, (swig_guile_proc) _wrap_add_mol_display_control_widgets);
@@ -50661,6 +50906,7 @@
   scm_c_define_gsubr("new-molecule-by-residue-type-selection", 2, 0, 0, (swig_guile_proc) _wrap_new_molecule_by_residue_type_selection);
   scm_c_define_gsubr("new-molecule-by-atom-selection", 2, 0, 0, (swig_guile_proc) _wrap_new_molecule_by_atom_selection);
   scm_c_define_gsubr("new-molecule-by-sphere-selection", 6, 0, 0, (swig_guile_proc) _wrap_new_molecule_by_sphere_selection);
+  scm_c_define_gsubr("new-molecule-by-residue-specs-scm", 2, 0, 0, (swig_guile_proc) _wrap_new_molecule_by_residue_specs_scm);
   scm_c_define_gsubr("set-axis-orientation-matrix", 9, 0, 0, (swig_guile_proc) _wrap_set_axis_orientation_matrix);
   scm_c_define_gsubr("set-axis-orientation-matrix-usage", 1, 0, 0, (swig_guile_proc) _wrap_set_axis_orientation_matrix_usage);
   scm_c_define_gsubr("ideal-nucleic-acid", 4, 0, 0, (swig_guile_proc) _wrap_ideal_nucleic_acid);
@@ -51057,6 +51303,10 @@
   scm_c_define_gsubr("match-residue-and-dictionary", 10, 0, 0, (swig_guile_proc) _wrap_match_residue_and_dictionary);
   scm_c_define_gsubr("match-this-residue-and-dictionary", 7, 0, 0, (swig_guile_proc) _wrap_match_this_residue_and_dictionary);
   scm_c_define_gsubr("comprised-of-organic-set-p", 1, 0, 0, (swig_guile_proc) _wrap_comprised_of_organic_set_p);
+  scm_c_define_gsubr("coot-all-atom-contact-dots", 1, 0, 0, (swig_guile_proc) _wrap_coot_all_atom_contact_dots);
+  scm_c_define_gsubr("coot-reduce", 1, 0, 0, (swig_guile_proc) _wrap_coot_reduce);
+  scm_c_define_gsubr("coot-contact-dots-for-ligand-scm", 2, 0, 0, (swig_guile_proc) _wrap_coot_contact_dots_for_ligand_scm);
+  scm_c_define_gsubr("switch-HIS-protonation-scm", 2, 0, 0, (swig_guile_proc) _wrap_switch_HIS_protonation_scm);
   scm_c_define_gsubr("get-ligand-percentile", 3, 0, 0, (swig_guile_proc) _wrap_get_ligand_percentile);
   scm_c_define_gsubr("enhanced-ligand-coot-p", 0, 0, 0, (swig_guile_proc) _wrap_enhanced_ligand_coot_p);
   scm_c_define_gsubr("mogul-markup", 5, 0, 0, (swig_guile_proc) _wrap_mogul_markup);
@@ -51114,7 +51364,7 @@
   scm_c_define_gsubr("to-generic-object-add-pentakis-dodecahedron", 7, 0, 0, (swig_guile_proc) _wrap_to_generic_object_add_pentakis_dodecahedron);
   scm_c_define_gsubr("to-generic-object-add-display-list-handle", 2, 0, 0, (swig_guile_proc) _wrap_to_generic_object_add_display_list_handle);
   scm_c_define_gsubr("set-display-generic-object", 2, 0, 0, (swig_guile_proc) _wrap_set_display_generic_object);
-  scm_c_define_gsubr("set-display-all-generic-objects", 1, 0, 0, (swig_guile_proc) _wrap_set_display_all_generic_objects);
+  scm_c_define_gsubr("set-display-generic-object-simple", 2, 0, 0, (swig_guile_proc) _wrap_set_display_generic_object_simple);
   scm_c_define_gsubr("generic-object-is-displayed-p", 1, 0, 0, (swig_guile_proc) _wrap_generic_object_is_displayed_p);
   scm_c_define_gsubr("generic-object-index", 1, 0, 0, (swig_guile_proc) _wrap_generic_object_index);
   scm_c_define_gsubr("generic-object-name-scm", 1, 0, 0, (swig_guile_proc) _wrap_generic_object_name_scm);
@@ -51123,9 +51373,7 @@
   scm_c_define_gsubr("generic-object-has-objects-p", 1, 0, 0, (swig_guile_proc) _wrap_generic_object_has_objects_p);
   scm_c_define_gsubr("close-generic-object", 1, 0, 0, (swig_guile_proc) _wrap_close_generic_object);
   scm_c_define_gsubr("is-closed-generic-object-p", 1, 0, 0, (swig_guile_proc) _wrap_is_closed_generic_object_p);
-  scm_c_define_gsubr("close-all-generic-objects", 0, 0, 0, (swig_guile_proc) _wrap_close_all_generic_objects);
   scm_c_define_gsubr("generic-object-clear", 1, 0, 0, (swig_guile_proc) _wrap_generic_object_clear);
-  scm_c_define_gsubr("generic-objects-gui-wrapper", 0, 0, 0, (swig_guile_proc) _wrap_generic_objects_gui_wrapper);
   scm_c_define_gsubr("attach-generic-object-to-molecule", 2, 0, 0, (swig_guile_proc) _wrap_attach_generic_object_to_molecule);
   scm_c_define_gsubr("set-display-generic-objects-as-solid", 1, 0, 0, (swig_guile_proc) _wrap_set_display_generic_objects_as_solid);
   SWIG_TypeClientData(SWIGTYPE_p_coot__mtz_type_label, (void *) &_swig_guile_clientdatamtz_type_label);
@@ -51278,6 +51526,7 @@
   scm_c_define_gsubr("residue-spec-t-int-user-data-get", 1, 0, 0, (swig_guile_proc) _wrap_residue_spec_t_int_user_data_get);
   scm_c_define_gsubr("new-residue-spec-t", 0, 0, 1, (swig_guile_proc) _wrap_new_residue_spec_t);
   scm_c_define_gsubr("residue-spec-t-unset-p", 1, 0, 0, (swig_guile_proc) _wrap_residue_spec_t_unset_p);
+  scm_c_define_gsubr("residue-spec-t-empty", 1, 0, 0, (swig_guile_proc) _wrap_residue_spec_t_empty);
   scm_c_define_gsubr("residue-spec-t-next", 1, 0, 0, (swig_guile_proc) _wrap_residue_spec_t_next);
   scm_c_define_gsubr("residue-spec-t-previous", 1, 0, 0, (swig_guile_proc) _wrap_residue_spec_t_previous);
   scm_c_define_gsubr("residue-spec-t-format", 1, 0, 0, (swig_guile_proc) _wrap_residue_spec_t_format);
@@ -51337,6 +51586,10 @@
   scm_c_define_gsubr("get-monomer-for-molecule", 2, 0, 0, (swig_guile_proc) _wrap_get_monomer_for_molecule);
   scm_c_define_gsubr("get-monomer-from-dictionary", 2, 0, 0, (swig_guile_proc) _wrap_get_monomer_from_dictionary);
   scm_c_define_gsubr("globularize", 1, 0, 0, (swig_guile_proc) _wrap_globularize);
+  scm_c_define_gsubr("clear-generic-objects-dialog-pointer", 0, 0, 0, (swig_guile_proc) _wrap_clear_generic_objects_dialog_pointer);
+  scm_c_define_gsubr("set-display-all-generic-objects", 1, 0, 0, (swig_guile_proc) _wrap_set_display_all_generic_objects);
+  scm_c_define_gsubr("generic-objects-gui-wrapper", 0, 0, 0, (swig_guile_proc) _wrap_generic_objects_gui_wrapper);
+  scm_c_define_gsubr("close-all-generic-objects", 0, 0, 0, (swig_guile_proc) _wrap_close_all_generic_objects);
   scm_c_define_gsubr("set-user-defined-atom-colour-scm", 2, 0, 0, (swig_guile_proc) _wrap_set_user_defined_atom_colour_scm);
   scm_c_define_gsubr("set-user-defined-atom-colour-by-residue-scm", 2, 0, 0, (swig_guile_proc) _wrap_set_user_defined_atom_colour_by_residue_scm);
   scm_c_define_gsubr("clear-user-defined-atom-colours", 1, 0, 0, (swig_guile_proc) _wrap_clear_user_defined_atom_colours);
diff -ruN coot-0.8.7/src/coot_wrap_python.cc coot-0.8.8-pre/src/coot_wrap_python.cc
--- coot-0.8.7/src/coot_wrap_python.cc	2016-11-01 08:50:03.000000000 -0700
+++ coot-0.8.8-pre/src/coot_wrap_python.cc	2017-01-13 09:54:26.000000000 -0800
@@ -3221,6 +3221,8 @@
 #include "cc-interface-scripting.hh"
 #include "c-interface-refmac.h"
 #include "cc-interface-ncs.hh"
+#include "c-interface-generic-objects.h"
+#include "generic-display-objects-c.h"
 #include "manipulation-modes.hh"
 #include "rotamer-search-modes.hh"
 #include "lbg-interface.hh"
@@ -17020,6 +17022,40 @@
 }
 
 
+SWIGINTERN PyObject *_wrap_replace_residues_from_mol_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  int arg2 ;
+  PyObject *arg3 = (PyObject *) 0 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  int result;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:replace_residues_from_mol_py",&obj0,&obj1,&obj2)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "replace_residues_from_mol_py" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  ecode2 = SWIG_AsVal_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "replace_residues_from_mol_py" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  arg3 = obj2;
+  result = (int)replace_residues_from_mol_py(arg1,arg2,arg3);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_clear_and_update_model_molecule_from_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   int arg1 ;
@@ -26958,6 +26994,56 @@
 }
 
 
+SWIGINTERN PyObject *_wrap_glyco_tree_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:glyco_tree_py",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "glyco_tree_py" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  arg2 = obj1;
+  result = (PyObject *)glyco_tree_py(arg1,arg2);
+  resultobj = result;
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_glyco_tree_residues_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:glyco_tree_residues_py",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "glyco_tree_residues_py" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  arg2 = obj1;
+  result = (PyObject *)glyco_tree_residues_py(arg1,arg2);
+  resultobj = result;
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_post_display_control_window(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   
@@ -44850,6 +44936,31 @@
 }
 
 
+SWIGINTERN PyObject *_wrap_new_molecule_by_residue_specs_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  int result;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:new_molecule_by_residue_specs_py",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_molecule_by_residue_specs_py" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  arg2 = obj1;
+  result = (int)new_molecule_by_residue_specs_py(arg1,arg2);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_set_axis_orientation_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   float arg1 ;
@@ -58548,6 +58659,96 @@
 }
 
 
+SWIGINTERN PyObject *_wrap_coot_all_atom_contact_dots(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:coot_all_atom_contact_dots",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "coot_all_atom_contact_dots" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  coot_all_atom_contact_dots(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_coot_contact_dots_for_ligand_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:coot_contact_dots_for_ligand_py",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "coot_contact_dots_for_ligand_py" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  arg2 = obj1;
+  coot_contact_dots_for_ligand_py(arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_switch_HIS_protonation_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:switch_HIS_protonation_py",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "switch_HIS_protonation_py" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  arg2 = obj1;
+  switch_HIS_protonation_py(arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_coot_reduce(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:coot_reduce",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "coot_reduce" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  coot_reduce(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_get_ligand_percentile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   std::string arg1 ;
@@ -60402,20 +60603,29 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_set_display_all_generic_objects(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_set_display_generic_object_simple(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   int arg1 ;
+  short arg2 ;
   int val1 ;
   int ecode1 = 0 ;
+  short val2 ;
+  int ecode2 = 0 ;
   PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:set_display_all_generic_objects",&obj0)) SWIG_fail;
+  if (!PyArg_ParseTuple(args,(char *)"OO:set_display_generic_object_simple",&obj0,&obj1)) SWIG_fail;
   ecode1 = SWIG_AsVal_int(obj0, &val1);
   if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_display_all_generic_objects" "', argument " "1"" of type '" "int""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_display_generic_object_simple" "', argument " "1"" of type '" "int""'");
   } 
   arg1 = static_cast< int >(val1);
-  set_display_all_generic_objects(arg1);
+  ecode2 = SWIG_AsVal_short(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_display_generic_object_simple" "', argument " "2"" of type '" "short""'");
+  } 
+  arg2 = static_cast< short >(val2);
+  set_display_generic_object_simple(arg1,arg2);
   resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
@@ -60582,18 +60792,6 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_close_all_generic_objects(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  
-  if (!PyArg_ParseTuple(args,(char *)":close_all_generic_objects")) SWIG_fail;
-  close_all_generic_objects();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
 SWIGINTERN PyObject *_wrap_generic_object_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   int arg1 ;
@@ -60615,18 +60813,6 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_generic_objects_gui_wrapper(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  
-  if (!PyArg_ParseTuple(args,(char *)":generic_objects_gui_wrapper")) SWIG_fail;
-  generic_objects_gui_wrapper();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
 SWIGINTERN PyObject *_wrap_attach_generic_object_to_molecule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   int arg1 ;
@@ -65258,6 +65444,28 @@
 }
 
 
+SWIGINTERN PyObject *_wrap_residue_spec_t_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  coot::residue_spec_t *arg1 = (coot::residue_spec_t *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  bool result;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:residue_spec_t_empty",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_coot__residue_spec_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "residue_spec_t_empty" "', argument " "1"" of type '" "coot::residue_spec_t const *""'"); 
+  }
+  arg1 = reinterpret_cast< coot::residue_spec_t * >(argp1);
+  result = (bool)((coot::residue_spec_t const *)arg1)->empty();
+  resultobj = SWIG_From_bool(static_cast< bool >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_residue_spec_t_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   coot::residue_spec_t *arg1 = (coot::residue_spec_t *) 0 ;
@@ -66727,6 +66935,63 @@
 }
 
 
+SWIGINTERN PyObject *_wrap_clear_generic_objects_dialog_pointer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":clear_generic_objects_dialog_pointer")) SWIG_fail;
+  clear_generic_objects_dialog_pointer();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_set_display_all_generic_objects(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:set_display_all_generic_objects",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_display_all_generic_objects" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  set_display_all_generic_objects(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_generic_objects_gui_wrapper(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":generic_objects_gui_wrapper")) SWIG_fail;
+  generic_objects_gui_wrapper();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_close_all_generic_objects(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":close_all_generic_objects")) SWIG_fail;
+  close_all_generic_objects();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_set_user_defined_atom_colour_by_residue_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   int arg1 ;
@@ -67873,6 +68138,7 @@
 	 { (char *)"het_group_n_atoms", _wrap_het_group_n_atoms, METH_VARARGS, NULL},
 	 { (char *)"replace_fragment", _wrap_replace_fragment, METH_VARARGS, NULL},
 	 { (char *)"copy_residue_range", _wrap_copy_residue_range, METH_VARARGS, NULL},
+	 { (char *)"replace_residues_from_mol_py", _wrap_replace_residues_from_mol_py, METH_VARARGS, NULL},
 	 { (char *)"clear_and_update_model_molecule_from_file", _wrap_clear_and_update_model_molecule_from_file, METH_VARARGS, NULL},
 	 { (char *)"screendump_image", _wrap_screendump_image, METH_VARARGS, NULL},
 	 { (char *)"check_for_dark_blue_density", _wrap_check_for_dark_blue_density, METH_VARARGS, NULL},
@@ -68245,6 +68511,8 @@
 	 { (char *)"test_function", _wrap_test_function, METH_VARARGS, NULL},
 	 { (char *)"test_function_py", _wrap_test_function_py, METH_VARARGS, NULL},
 	 { (char *)"glyco_tree_test", _wrap_glyco_tree_test, METH_VARARGS, NULL},
+	 { (char *)"glyco_tree_py", _wrap_glyco_tree_py, METH_VARARGS, NULL},
+	 { (char *)"glyco_tree_residues_py", _wrap_glyco_tree_residues_py, METH_VARARGS, NULL},
 	 { (char *)"post_display_control_window", _wrap_post_display_control_window, METH_VARARGS, NULL},
 	 { (char *)"add_map_display_control_widgets", _wrap_add_map_display_control_widgets, METH_VARARGS, NULL},
 	 { (char *)"add_mol_display_control_widgets", _wrap_add_mol_display_control_widgets, METH_VARARGS, NULL},
@@ -68844,6 +69112,7 @@
 	 { (char *)"new_molecule_by_residue_type_selection", _wrap_new_molecule_by_residue_type_selection, METH_VARARGS, NULL},
 	 { (char *)"new_molecule_by_atom_selection", _wrap_new_molecule_by_atom_selection, METH_VARARGS, NULL},
 	 { (char *)"new_molecule_by_sphere_selection", _wrap_new_molecule_by_sphere_selection, METH_VARARGS, NULL},
+	 { (char *)"new_molecule_by_residue_specs_py", _wrap_new_molecule_by_residue_specs_py, METH_VARARGS, NULL},
 	 { (char *)"set_axis_orientation_matrix", _wrap_set_axis_orientation_matrix, METH_VARARGS, NULL},
 	 { (char *)"set_axis_orientation_matrix_usage", _wrap_set_axis_orientation_matrix_usage, METH_VARARGS, NULL},
 	 { (char *)"ideal_nucleic_acid", _wrap_ideal_nucleic_acid, METH_VARARGS, NULL},
@@ -69249,6 +69518,10 @@
 	 { (char *)"match_residue_and_dictionary", _wrap_match_residue_and_dictionary, METH_VARARGS, NULL},
 	 { (char *)"match_this_residue_and_dictionary", _wrap_match_this_residue_and_dictionary, METH_VARARGS, NULL},
 	 { (char *)"comprised_of_organic_set_p", _wrap_comprised_of_organic_set_p, METH_VARARGS, NULL},
+	 { (char *)"coot_all_atom_contact_dots", _wrap_coot_all_atom_contact_dots, METH_VARARGS, NULL},
+	 { (char *)"coot_contact_dots_for_ligand_py", _wrap_coot_contact_dots_for_ligand_py, METH_VARARGS, NULL},
+	 { (char *)"switch_HIS_protonation_py", _wrap_switch_HIS_protonation_py, METH_VARARGS, NULL},
+	 { (char *)"coot_reduce", _wrap_coot_reduce, METH_VARARGS, NULL},
 	 { (char *)"get_ligand_percentile", _wrap_get_ligand_percentile, METH_VARARGS, NULL},
 	 { (char *)"enhanced_ligand_coot_p", _wrap_enhanced_ligand_coot_p, METH_VARARGS, NULL},
 	 { (char *)"mogul_markup", _wrap_mogul_markup, METH_VARARGS, NULL},
@@ -69304,7 +69577,7 @@
 	 { (char *)"to_generic_object_add_pentakis_dodecahedron", _wrap_to_generic_object_add_pentakis_dodecahedron, METH_VARARGS, NULL},
 	 { (char *)"to_generic_object_add_display_list_handle", _wrap_to_generic_object_add_display_list_handle, METH_VARARGS, NULL},
 	 { (char *)"set_display_generic_object", _wrap_set_display_generic_object, METH_VARARGS, NULL},
-	 { (char *)"set_display_all_generic_objects", _wrap_set_display_all_generic_objects, METH_VARARGS, NULL},
+	 { (char *)"set_display_generic_object_simple", _wrap_set_display_generic_object_simple, METH_VARARGS, NULL},
 	 { (char *)"generic_object_is_displayed_p", _wrap_generic_object_is_displayed_p, METH_VARARGS, NULL},
 	 { (char *)"generic_object_index", _wrap_generic_object_index, METH_VARARGS, NULL},
 	 { (char *)"generic_object_name_py", _wrap_generic_object_name_py, METH_VARARGS, NULL},
@@ -69313,9 +69586,7 @@
 	 { (char *)"generic_object_has_objects_p", _wrap_generic_object_has_objects_p, METH_VARARGS, NULL},
 	 { (char *)"close_generic_object", _wrap_close_generic_object, METH_VARARGS, NULL},
 	 { (char *)"is_closed_generic_object_p", _wrap_is_closed_generic_object_p, METH_VARARGS, NULL},
-	 { (char *)"close_all_generic_objects", _wrap_close_all_generic_objects, METH_VARARGS, NULL},
 	 { (char *)"generic_object_clear", _wrap_generic_object_clear, METH_VARARGS, NULL},
-	 { (char *)"generic_objects_gui_wrapper", _wrap_generic_objects_gui_wrapper, METH_VARARGS, NULL},
 	 { (char *)"attach_generic_object_to_molecule", _wrap_attach_generic_object_to_molecule, METH_VARARGS, NULL},
 	 { (char *)"set_display_generic_objects_as_solid", _wrap_set_display_generic_objects_as_solid, METH_VARARGS, NULL},
 	 { (char *)"mtz_type_label_column_type_set", _wrap_mtz_type_label_column_type_set, METH_VARARGS, NULL},
@@ -69458,6 +69729,7 @@
 	 { (char *)"residue_spec_t_int_user_data_get", _wrap_residue_spec_t_int_user_data_get, METH_VARARGS, NULL},
 	 { (char *)"new_residue_spec_t", _wrap_new_residue_spec_t, METH_VARARGS, NULL},
 	 { (char *)"residue_spec_t_unset_p", _wrap_residue_spec_t_unset_p, METH_VARARGS, NULL},
+	 { (char *)"residue_spec_t_empty", _wrap_residue_spec_t_empty, METH_VARARGS, NULL},
 	 { (char *)"residue_spec_t_next", _wrap_residue_spec_t_next, METH_VARARGS, NULL},
 	 { (char *)"residue_spec_t_previous", _wrap_residue_spec_t_previous, METH_VARARGS, NULL},
 	 { (char *)"residue_spec_t_format", _wrap_residue_spec_t_format, METH_VARARGS, NULL},
@@ -69512,6 +69784,10 @@
 	 { (char *)"get_monomer_for_molecule", _wrap_get_monomer_for_molecule, METH_VARARGS, NULL},
 	 { (char *)"get_monomer_from_dictionary", _wrap_get_monomer_from_dictionary, METH_VARARGS, NULL},
 	 { (char *)"globularize", _wrap_globularize, METH_VARARGS, NULL},
+	 { (char *)"clear_generic_objects_dialog_pointer", _wrap_clear_generic_objects_dialog_pointer, METH_VARARGS, NULL},
+	 { (char *)"set_display_all_generic_objects", _wrap_set_display_all_generic_objects, METH_VARARGS, NULL},
+	 { (char *)"generic_objects_gui_wrapper", _wrap_generic_objects_gui_wrapper, METH_VARARGS, NULL},
+	 { (char *)"close_all_generic_objects", _wrap_close_all_generic_objects, METH_VARARGS, NULL},
 	 { (char *)"set_user_defined_atom_colour_by_residue_py", _wrap_set_user_defined_atom_colour_by_residue_py, METH_VARARGS, NULL},
 	 { (char *)"set_user_defined_atom_colour_py", _wrap_set_user_defined_atom_colour_py, METH_VARARGS, NULL},
 	 { (char *)"clear_user_defined_atom_colours", _wrap_clear_user_defined_atom_colours, METH_VARARGS, NULL},
diff -ruN coot-0.8.7/src/coot_wrap_python_pre.cc coot-0.8.8-pre/src/coot_wrap_python_pre.cc
--- coot-0.8.7/src/coot_wrap_python_pre.cc	2016-11-01 08:50:03.000000000 -0700
+++ coot-0.8.8-pre/src/coot_wrap_python_pre.cc	2017-01-13 09:54:26.000000000 -0800
@@ -3218,6 +3218,8 @@
 #include "cc-interface-scripting.hh"
 #include "c-interface-refmac.h"
 #include "cc-interface-ncs.hh"
+#include "c-interface-generic-objects.h"
+#include "generic-display-objects-c.h"
 #include "manipulation-modes.hh"
 #include "rotamer-search-modes.hh"
 #include "lbg-interface.hh"
@@ -17017,6 +17019,40 @@
 }
 
 
+SWIGINTERN PyObject *_wrap_replace_residues_from_mol_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  int arg2 ;
+  PyObject *arg3 = (PyObject *) 0 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  int result;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:replace_residues_from_mol_py",&obj0,&obj1,&obj2)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "replace_residues_from_mol_py" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  ecode2 = SWIG_AsVal_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "replace_residues_from_mol_py" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  arg3 = obj2;
+  result = (int)replace_residues_from_mol_py(arg1,arg2,arg3);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_clear_and_update_model_molecule_from_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   int arg1 ;
@@ -26955,6 +26991,56 @@
 }
 
 
+SWIGINTERN PyObject *_wrap_glyco_tree_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:glyco_tree_py",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "glyco_tree_py" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  arg2 = obj1;
+  result = (PyObject *)glyco_tree_py(arg1,arg2);
+  resultobj = result;
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_glyco_tree_residues_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:glyco_tree_residues_py",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "glyco_tree_residues_py" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  arg2 = obj1;
+  result = (PyObject *)glyco_tree_residues_py(arg1,arg2);
+  resultobj = result;
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_post_display_control_window(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   
@@ -44847,6 +44933,31 @@
 }
 
 
+SWIGINTERN PyObject *_wrap_new_molecule_by_residue_specs_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  int result;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:new_molecule_by_residue_specs_py",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_molecule_by_residue_specs_py" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  arg2 = obj1;
+  result = (int)new_molecule_by_residue_specs_py(arg1,arg2);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_set_axis_orientation_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   float arg1 ;
@@ -58545,6 +58656,96 @@
 }
 
 
+SWIGINTERN PyObject *_wrap_coot_all_atom_contact_dots(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:coot_all_atom_contact_dots",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "coot_all_atom_contact_dots" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  coot_all_atom_contact_dots(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_coot_contact_dots_for_ligand_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:coot_contact_dots_for_ligand_py",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "coot_contact_dots_for_ligand_py" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  arg2 = obj1;
+  coot_contact_dots_for_ligand_py(arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_switch_HIS_protonation_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:switch_HIS_protonation_py",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "switch_HIS_protonation_py" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  arg2 = obj1;
+  switch_HIS_protonation_py(arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_coot_reduce(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:coot_reduce",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "coot_reduce" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  coot_reduce(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_get_ligand_percentile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   std::string arg1 ;
@@ -60399,20 +60600,29 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_set_display_all_generic_objects(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_set_display_generic_object_simple(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   int arg1 ;
+  short arg2 ;
   int val1 ;
   int ecode1 = 0 ;
+  short val2 ;
+  int ecode2 = 0 ;
   PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:set_display_all_generic_objects",&obj0)) SWIG_fail;
+  if (!PyArg_ParseTuple(args,(char *)"OO:set_display_generic_object_simple",&obj0,&obj1)) SWIG_fail;
   ecode1 = SWIG_AsVal_int(obj0, &val1);
   if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_display_all_generic_objects" "', argument " "1"" of type '" "int""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_display_generic_object_simple" "', argument " "1"" of type '" "int""'");
   } 
   arg1 = static_cast< int >(val1);
-  set_display_all_generic_objects(arg1);
+  ecode2 = SWIG_AsVal_short(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_display_generic_object_simple" "', argument " "2"" of type '" "short""'");
+  } 
+  arg2 = static_cast< short >(val2);
+  set_display_generic_object_simple(arg1,arg2);
   resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
@@ -60579,18 +60789,6 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_close_all_generic_objects(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  
-  if (!PyArg_ParseTuple(args,(char *)":close_all_generic_objects")) SWIG_fail;
-  close_all_generic_objects();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
 SWIGINTERN PyObject *_wrap_generic_object_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   int arg1 ;
@@ -60612,18 +60810,6 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_generic_objects_gui_wrapper(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  
-  if (!PyArg_ParseTuple(args,(char *)":generic_objects_gui_wrapper")) SWIG_fail;
-  generic_objects_gui_wrapper();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
 SWIGINTERN PyObject *_wrap_attach_generic_object_to_molecule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   int arg1 ;
@@ -65255,6 +65441,28 @@
 }
 
 
+SWIGINTERN PyObject *_wrap_residue_spec_t_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  coot::residue_spec_t *arg1 = (coot::residue_spec_t *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  bool result;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:residue_spec_t_empty",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_coot__residue_spec_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "residue_spec_t_empty" "', argument " "1"" of type '" "coot::residue_spec_t const *""'"); 
+  }
+  arg1 = reinterpret_cast< coot::residue_spec_t * >(argp1);
+  result = (bool)((coot::residue_spec_t const *)arg1)->empty();
+  resultobj = SWIG_From_bool(static_cast< bool >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_residue_spec_t_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   coot::residue_spec_t *arg1 = (coot::residue_spec_t *) 0 ;
@@ -66724,6 +66932,63 @@
 }
 
 
+SWIGINTERN PyObject *_wrap_clear_generic_objects_dialog_pointer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":clear_generic_objects_dialog_pointer")) SWIG_fail;
+  clear_generic_objects_dialog_pointer();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_set_display_all_generic_objects(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:set_display_all_generic_objects",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_display_all_generic_objects" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = static_cast< int >(val1);
+  set_display_all_generic_objects(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_generic_objects_gui_wrapper(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":generic_objects_gui_wrapper")) SWIG_fail;
+  generic_objects_gui_wrapper();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_close_all_generic_objects(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":close_all_generic_objects")) SWIG_fail;
+  close_all_generic_objects();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_set_user_defined_atom_colour_by_residue_py(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   int arg1 ;
@@ -67870,6 +68135,7 @@
 	 { (char *)"het_group_n_atoms", _wrap_het_group_n_atoms, METH_VARARGS, NULL},
 	 { (char *)"replace_fragment", _wrap_replace_fragment, METH_VARARGS, NULL},
 	 { (char *)"copy_residue_range", _wrap_copy_residue_range, METH_VARARGS, NULL},
+	 { (char *)"replace_residues_from_mol_py", _wrap_replace_residues_from_mol_py, METH_VARARGS, NULL},
 	 { (char *)"clear_and_update_model_molecule_from_file", _wrap_clear_and_update_model_molecule_from_file, METH_VARARGS, NULL},
 	 { (char *)"screendump_image", _wrap_screendump_image, METH_VARARGS, NULL},
 	 { (char *)"check_for_dark_blue_density", _wrap_check_for_dark_blue_density, METH_VARARGS, NULL},
@@ -68242,6 +68508,8 @@
 	 { (char *)"test_function", _wrap_test_function, METH_VARARGS, NULL},
 	 { (char *)"test_function_py", _wrap_test_function_py, METH_VARARGS, NULL},
 	 { (char *)"glyco_tree_test", _wrap_glyco_tree_test, METH_VARARGS, NULL},
+	 { (char *)"glyco_tree_py", _wrap_glyco_tree_py, METH_VARARGS, NULL},
+	 { (char *)"glyco_tree_residues_py", _wrap_glyco_tree_residues_py, METH_VARARGS, NULL},
 	 { (char *)"post_display_control_window", _wrap_post_display_control_window, METH_VARARGS, NULL},
 	 { (char *)"add_map_display_control_widgets", _wrap_add_map_display_control_widgets, METH_VARARGS, NULL},
 	 { (char *)"add_mol_display_control_widgets", _wrap_add_mol_display_control_widgets, METH_VARARGS, NULL},
@@ -68841,6 +69109,7 @@
 	 { (char *)"new_molecule_by_residue_type_selection", _wrap_new_molecule_by_residue_type_selection, METH_VARARGS, NULL},
 	 { (char *)"new_molecule_by_atom_selection", _wrap_new_molecule_by_atom_selection, METH_VARARGS, NULL},
 	 { (char *)"new_molecule_by_sphere_selection", _wrap_new_molecule_by_sphere_selection, METH_VARARGS, NULL},
+	 { (char *)"new_molecule_by_residue_specs_py", _wrap_new_molecule_by_residue_specs_py, METH_VARARGS, NULL},
 	 { (char *)"set_axis_orientation_matrix", _wrap_set_axis_orientation_matrix, METH_VARARGS, NULL},
 	 { (char *)"set_axis_orientation_matrix_usage", _wrap_set_axis_orientation_matrix_usage, METH_VARARGS, NULL},
 	 { (char *)"ideal_nucleic_acid", _wrap_ideal_nucleic_acid, METH_VARARGS, NULL},
@@ -69246,6 +69515,10 @@
 	 { (char *)"match_residue_and_dictionary", _wrap_match_residue_and_dictionary, METH_VARARGS, NULL},
 	 { (char *)"match_this_residue_and_dictionary", _wrap_match_this_residue_and_dictionary, METH_VARARGS, NULL},
 	 { (char *)"comprised_of_organic_set_p", _wrap_comprised_of_organic_set_p, METH_VARARGS, NULL},
+	 { (char *)"coot_all_atom_contact_dots", _wrap_coot_all_atom_contact_dots, METH_VARARGS, NULL},
+	 { (char *)"coot_contact_dots_for_ligand_py", _wrap_coot_contact_dots_for_ligand_py, METH_VARARGS, NULL},
+	 { (char *)"switch_HIS_protonation_py", _wrap_switch_HIS_protonation_py, METH_VARARGS, NULL},
+	 { (char *)"coot_reduce", _wrap_coot_reduce, METH_VARARGS, NULL},
 	 { (char *)"get_ligand_percentile", _wrap_get_ligand_percentile, METH_VARARGS, NULL},
 	 { (char *)"enhanced_ligand_coot_p", _wrap_enhanced_ligand_coot_p, METH_VARARGS, NULL},
 	 { (char *)"mogul_markup", _wrap_mogul_markup, METH_VARARGS, NULL},
@@ -69301,7 +69574,7 @@
 	 { (char *)"to_generic_object_add_pentakis_dodecahedron", _wrap_to_generic_object_add_pentakis_dodecahedron, METH_VARARGS, NULL},
 	 { (char *)"to_generic_object_add_display_list_handle", _wrap_to_generic_object_add_display_list_handle, METH_VARARGS, NULL},
 	 { (char *)"set_display_generic_object", _wrap_set_display_generic_object, METH_VARARGS, NULL},
-	 { (char *)"set_display_all_generic_objects", _wrap_set_display_all_generic_objects, METH_VARARGS, NULL},
+	 { (char *)"set_display_generic_object_simple", _wrap_set_display_generic_object_simple, METH_VARARGS, NULL},
 	 { (char *)"generic_object_is_displayed_p", _wrap_generic_object_is_displayed_p, METH_VARARGS, NULL},
 	 { (char *)"generic_object_index", _wrap_generic_object_index, METH_VARARGS, NULL},
 	 { (char *)"generic_object_name_py", _wrap_generic_object_name_py, METH_VARARGS, NULL},
@@ -69310,9 +69583,7 @@
 	 { (char *)"generic_object_has_objects_p", _wrap_generic_object_has_objects_p, METH_VARARGS, NULL},
 	 { (char *)"close_generic_object", _wrap_close_generic_object, METH_VARARGS, NULL},
 	 { (char *)"is_closed_generic_object_p", _wrap_is_closed_generic_object_p, METH_VARARGS, NULL},
-	 { (char *)"close_all_generic_objects", _wrap_close_all_generic_objects, METH_VARARGS, NULL},
 	 { (char *)"generic_object_clear", _wrap_generic_object_clear, METH_VARARGS, NULL},
-	 { (char *)"generic_objects_gui_wrapper", _wrap_generic_objects_gui_wrapper, METH_VARARGS, NULL},
 	 { (char *)"attach_generic_object_to_molecule", _wrap_attach_generic_object_to_molecule, METH_VARARGS, NULL},
 	 { (char *)"set_display_generic_objects_as_solid", _wrap_set_display_generic_objects_as_solid, METH_VARARGS, NULL},
 	 { (char *)"mtz_type_label_column_type_set", _wrap_mtz_type_label_column_type_set, METH_VARARGS, NULL},
@@ -69455,6 +69726,7 @@
 	 { (char *)"residue_spec_t_int_user_data_get", _wrap_residue_spec_t_int_user_data_get, METH_VARARGS, NULL},
 	 { (char *)"new_residue_spec_t", _wrap_new_residue_spec_t, METH_VARARGS, NULL},
 	 { (char *)"residue_spec_t_unset_p", _wrap_residue_spec_t_unset_p, METH_VARARGS, NULL},
+	 { (char *)"residue_spec_t_empty", _wrap_residue_spec_t_empty, METH_VARARGS, NULL},
 	 { (char *)"residue_spec_t_next", _wrap_residue_spec_t_next, METH_VARARGS, NULL},
 	 { (char *)"residue_spec_t_previous", _wrap_residue_spec_t_previous, METH_VARARGS, NULL},
 	 { (char *)"residue_spec_t_format", _wrap_residue_spec_t_format, METH_VARARGS, NULL},
@@ -69509,6 +69781,10 @@
 	 { (char *)"get_monomer_for_molecule", _wrap_get_monomer_for_molecule, METH_VARARGS, NULL},
 	 { (char *)"get_monomer_from_dictionary", _wrap_get_monomer_from_dictionary, METH_VARARGS, NULL},
 	 { (char *)"globularize", _wrap_globularize, METH_VARARGS, NULL},
+	 { (char *)"clear_generic_objects_dialog_pointer", _wrap_clear_generic_objects_dialog_pointer, METH_VARARGS, NULL},
+	 { (char *)"set_display_all_generic_objects", _wrap_set_display_all_generic_objects, METH_VARARGS, NULL},
+	 { (char *)"generic_objects_gui_wrapper", _wrap_generic_objects_gui_wrapper, METH_VARARGS, NULL},
+	 { (char *)"close_all_generic_objects", _wrap_close_all_generic_objects, METH_VARARGS, NULL},
 	 { (char *)"set_user_defined_atom_colour_by_residue_py", _wrap_set_user_defined_atom_colour_by_residue_py, METH_VARARGS, NULL},
 	 { (char *)"set_user_defined_atom_colour_py", _wrap_set_user_defined_atom_colour_py, METH_VARARGS, NULL},
 	 { (char *)"clear_user_defined_atom_colours", _wrap_clear_user_defined_atom_colours, METH_VARARGS, NULL},
diff -ruN coot-0.8.7/src/draw-generic-display-objects.cc coot-0.8.8-pre/src/draw-generic-display-objects.cc
--- coot-0.8.7/src/draw-generic-display-objects.cc	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/src/draw-generic-display-objects.cc	2017-01-23 10:30:04.000000000 -0800
@@ -0,0 +1,514 @@
+
+#ifdef USE_PYTHON
+#include "Python.h"  // before system includes to stop "POSIX_C_SOURCE" redefined problems
+#endif
+
+#include <GL/glu.h>
+
+#include "generic-display-object.hh"
+#include "graphics-info.h"
+#include "c-interface-widgets.hh"
+
+// ---------------------- generic objects -----------------------------
+
+void
+coot::generic_display_object_t::add_line(const coot::colour_holder &colour_in,
+					 const std::string &colour_name,
+					 const int &width_in, 
+					 const std::pair<clipper::Coord_orth, clipper::Coord_orth> &coords_in) {
+
+   int lines_set_index = -1; // magic unset value
+   
+   for (unsigned int ils=0; ils<lines_set.size(); ils++) {
+      if (lines_set[ils].colour_name == colour_name) {
+	 if (lines_set[ils].width == width_in) {
+	    lines_set_index = ils;
+	    break;
+	 }
+      }
+   }
+
+   if (lines_set_index == -1) {
+      generic_display_line_set_t t(colour_in, colour_name, width_in);
+      lines_set.push_back(t);
+      lines_set_index = lines_set.size() -1;
+   }
+
+   coot::generic_display_line_t line(coords_in);
+   lines_set[lines_set_index].add_line(line);
+   
+}
+
+void coot::generic_display_object_t::add_point(const coot::colour_holder &colour_in,
+					       const std::string &colour_name,
+					       const int &size_in, 
+					       const clipper::Coord_orth &coords_in) {
+
+   int points_set_index = -1; // magic unset number
+   for (unsigned int ips=0; ips<points_set.size(); ips++) {
+      if (points_set[ips].colour_name == colour_name) {
+	 if (points_set[ips].size == size_in) {
+	    points_set_index = ips;
+	    break;
+	 }
+      }
+   }
+   if (points_set_index == -1) {
+      coot::generic_display_point_set_t point_set(colour_in, colour_name, size_in);
+      point_set.add_point(coords_in);
+      points_set.push_back(point_set);
+   } else {
+      // normal case
+      points_set[points_set_index].add_point(coords_in);
+   }
+   
+}
+
+void
+coot::generic_display_object_t::add_dodecahedron(const colour_holder &colour_in,
+						 const std::string &colour_name,
+						 double radius,
+						 const clipper::Coord_orth &pos) {
+
+   dodec d;
+   dodec_t dod(d, radius, pos);
+   dod.col = colour_in;
+   dodecs.push_back(dod);
+}
+
+void
+coot::generic_display_object_t::add_pentakis_dodecahedron(const colour_holder &colour_in,
+							  const std::string &colour_name,
+							  double stellation_factor,
+							  double radius,
+							  const clipper::Coord_orth &pos) {
+
+   pentakis_dodec d(stellation_factor);
+   pentakis_dodec_t pdod(d, radius, pos);
+   pdod.col = colour_in;
+
+   pentakis_dodecs.push_back(pdod);
+}
+
+
+// static
+void
+graphics_info_t::draw_generic_objects() {
+   graphics_info_t g;
+   if (! g.display_generic_objects_as_solid_flag) 
+      g.draw_generic_objects_simple();
+   else 
+      g.draw_generic_objects_solid(); // gluCylinders and gluDisks
+}
+
+
+
+// static
+void
+graphics_info_t::draw_generic_objects_simple() {
+
+   // std::cout << "debug:: drawing " << generic_objects_p->size()
+   // << " generic objects" << std::endl;
+   
+   for (unsigned int i=0; i<generic_objects_p->size(); i++) {
+
+      if ((*generic_objects_p)[i].is_displayed_flag) {
+
+	 // if this is attached to a molecule that is not displayed, skip it.
+	 if ((*generic_objects_p)[i].is_valid_imol()) { // i.e. is not UNDEFINED
+	    int imol = (*generic_objects_p)[i].get_imol();
+	    if (is_valid_model_molecule(imol))
+	       if (! graphics_info_t::molecules[imol].is_displayed_p()) {
+		  continue;
+	       } 
+	 } 
+
+	 // Lines
+	 for (unsigned int ils=0; ils< (*generic_objects_p)[i].lines_set.size(); ils++) {
+	    glLineWidth((*generic_objects_p)[i].lines_set[ils].width);
+	    glColor3f((*generic_objects_p)[i].lines_set[ils].colour.red,
+		      (*generic_objects_p)[i].lines_set[ils].colour.green,
+		      (*generic_objects_p)[i].lines_set[ils].colour.blue);
+	    glBegin(GL_LINES);
+	    unsigned int s = (*generic_objects_p)[i].lines_set[ils].lines.size();
+	    for (unsigned int iline=0; iline<s; iline++) {
+	       glVertex3f((*generic_objects_p)[i].lines_set[ils].lines[iline].coords.first.x(),
+			  (*generic_objects_p)[i].lines_set[ils].lines[iline].coords.first.y(),
+			  (*generic_objects_p)[i].lines_set[ils].lines[iline].coords.first.z());
+	       glVertex3f((*generic_objects_p)[i].lines_set[ils].lines[iline].coords.second.x(),
+			  (*generic_objects_p)[i].lines_set[ils].lines[iline].coords.second.y(),
+			  (*generic_objects_p)[i].lines_set[ils].lines[iline].coords.second.z());
+	    }
+	    glEnd();
+	 }
+
+	 // Points
+	 for (unsigned int ips=0; ips<(*generic_objects_p)[i].points_set.size(); ips++) {
+	    glPointSize((*generic_objects_p)[i].points_set[ips].size);
+	    glColor3f((*generic_objects_p)[i].points_set[ips].colour.red,
+		      (*generic_objects_p)[i].points_set[ips].colour.green,
+		      (*generic_objects_p)[i].points_set[ips].colour.blue);
+	    glBegin(GL_POINTS);
+	    unsigned int npoints = (*generic_objects_p)[i].points_set[ips].points.size();
+	    for (unsigned int ipoint=0; ipoint<npoints; ipoint++) { 
+	       glVertex3f((*generic_objects_p)[i].points_set[ips].points[ipoint].x(),
+			  (*generic_objects_p)[i].points_set[ips].points[ipoint].y(),
+			  (*generic_objects_p)[i].points_set[ips].points[ipoint].z());
+	    }
+	    glEnd();
+	 }
+
+         // Display lists
+	 for (unsigned int idl=0; idl<(*generic_objects_p)[i].GL_display_list_handles.size(); idl++) {
+             glCallList((*generic_objects_p)[i].GL_display_list_handles[idl]);
+         }
+      }
+   }
+}
+
+// static
+void
+graphics_info_t::draw_generic_objects_solid() {
+
+   graphics_info_t g;
+   double radius = 0.02;
+
+   // Don't mess with the lighting if we aren't drawing anything
+   // 
+   if (generic_objects_p->size()) {
+
+      glEnable(GL_LIGHTING);
+      glEnable(GL_LIGHT1);
+      glEnable(GL_LIGHT0);
+      glDisable(GL_LIGHT2); // only for cut-glass mode
+      glDisable(GL_COLOR_MATERIAL);
+      glEnable(GL_NORMALIZE); // slows things, but makes the shiny nice
+
+      for (unsigned int i=0; i<generic_objects_p->size(); i++) {
+
+	 if ((*generic_objects_p)[i].is_displayed_flag) {
+
+
+	    // if this is attached to a molecule that is not displayed, skip it.
+	    if ((*generic_objects_p)[i].is_valid_imol()) { // i.e. is not UNDEFINED
+	       int imol = (*generic_objects_p)[i].get_imol();
+	       if (is_valid_model_molecule(imol))
+		  if (! graphics_info_t::molecules[imol].is_displayed_p()) {
+		     continue;
+		  } 
+	    } 
+	    
+
+	    // Previously (r4209) I had noted that
+	    // glEnable(GL_COLOR_MATERIAL) needed for correct tube
+	    // colours.
+	    // 
+	    // 20120903 but this creates problems when displaying
+	    // chemical features (they become solid yellow (with nvidia
+	    // drivers?)).  I currently don't understand what problems
+	    // result if we do not enable GL_COLOR_MATERIAL here. (Mogul
+	    // output markup seems OK?).  So comment out.
+	    // 
+	    // glEnable(GL_COLOR_MATERIAL);
+	 
+	    GLfloat  mat_specular[]  = {0.9, 0.9, 0.9, 1};
+	    GLfloat  mat_shininess[] = {80};
+	 
+	    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
+	    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
+	    
+	    // Lines
+	    for (unsigned int ils=0; ils< (*generic_objects_p)[i].lines_set.size(); ils++) {
+	    
+	       glLineWidth((*generic_objects_p)[i].lines_set[ils].width);
+	       // 	    glColor3f((*generic_objects_p)[i].lines_set[ils].colour.red,
+	       // 		      (*generic_objects_p)[i].lines_set[ils].colour.green,
+	       // 		      (*generic_objects_p)[i].lines_set[ils].colour.blue);
+
+	       GLfloat  mat_diffuse[]  = {float((*generic_objects_p)[i].lines_set[ils].colour.red   * 0.8),
+					  float((*generic_objects_p)[i].lines_set[ils].colour.green * 0.8),
+					  float((*generic_objects_p)[i].lines_set[ils].colour.blue  * 0.8),
+					  1.0};
+	       glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_diffuse);
+	       glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_diffuse);
+	    
+	       unsigned int s = (*generic_objects_p)[i].lines_set[ils].lines.size();
+	       for (unsigned int iline=0; iline<s; iline++) {
+
+		  g.graphics_object_internal_single_tube((*generic_objects_p)[i].lines_set[ils].lines[iline].coords.first,
+							 (*generic_objects_p)[i].lines_set[ils].lines[iline].coords.second,
+							 (*generic_objects_p)[i].lines_set[ils].width * radius,
+							 coot::ROUND_ENDS);
+	       }
+	    }
+	 
+	    // Points
+	    for (unsigned int ips=0; ips<(*generic_objects_p)[i].points_set.size(); ips++) {
+	       // 	    glColor3f((*generic_objects_p)[i].points_set[ips].colour.red,
+	       // 		      (*generic_objects_p)[i].points_set[ips].colour.green,
+	       // 		      (*generic_objects_p)[i].points_set[ips].colour.blue);
+	    
+	       int sphere_slices = 5;
+	       int sphere_stacks = 5;
+	       float feature_opacity = 1.0;
+	       unsigned int npoints = (*generic_objects_p)[i].points_set[ips].points.size();
+	       for (unsigned int ipoint=0; ipoint<npoints; ipoint++) {
+
+		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
+		  GLfloat  mat_specular[]  = {obj.points_set[ips].colour.red,
+					      obj.points_set[ips].colour.green,
+					      obj.points_set[ips].colour.blue,
+					      feature_opacity};
+		  GLfloat  mat_shininess[] = {15};
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_specular);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_specular);
+
+	       
+		  GLUquadric* sphere_quad = gluNewQuadric();
+		  glPushMatrix();
+		  glTranslatef((*generic_objects_p)[i].points_set[ips].points[ipoint].x(),
+			       (*generic_objects_p)[i].points_set[ips].points[ipoint].y(),
+			       (*generic_objects_p)[i].points_set[ips].points[ipoint].z());	 
+		  gluSphere(sphere_quad,
+			    (*generic_objects_p)[i].points_set[ips].size * radius,
+			    sphere_slices, sphere_stacks);
+		  gluDeleteQuadric(sphere_quad);
+		  glPopMatrix();	 
+	       }
+	    }
+
+	    // Other stuff:
+	    float feature_opacity = 0.6;
+	    // feature_opacity = 1.0; // hack for to fix shininess
+
+	    // spheres
+
+	    if ((*generic_objects_p)[i].spheres.size()) {
+	       glEnable (GL_BLEND); // these 2 lines are needed to make the transparency work.
+	       glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	       for (unsigned int isphere=0; isphere<(*generic_objects_p)[i].spheres.size(); isphere++) { 
+
+		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
+		  GLfloat  mat_specular[]  = {obj.spheres[isphere].col.col[0],
+					      obj.spheres[isphere].col.col[1],
+					      obj.spheres[isphere].col.col[2], 
+					      feature_opacity};
+		  GLfloat  mat_shininess[] = {15};
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_specular);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_specular);
+	       
+		  int sphere_slices = 10;
+		  int sphere_stacks = 10;
+		  GLUquadric* sphere_quad = gluNewQuadric();
+		  glPushMatrix();
+		  glTranslatef((*generic_objects_p)[i].spheres[isphere].centre.x(),
+			       (*generic_objects_p)[i].spheres[isphere].centre.y(),
+			       (*generic_objects_p)[i].spheres[isphere].centre.z());
+		  gluSphere(sphere_quad,
+			    (*generic_objects_p)[i].spheres[isphere].radius,
+			    sphere_slices, sphere_stacks);
+		  gluDeleteQuadric(sphere_quad);
+		  glPopMatrix();
+	       }
+	    }
+
+	    // arrows
+	    if ((*generic_objects_p)[i].arrows.size()) {
+	       glEnable (GL_BLEND);
+	       glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	       for (unsigned int iarrow=0; iarrow<(*generic_objects_p)[i].arrows.size(); iarrow++) {
+		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
+		  GLfloat  mat_specular[]  = {obj.arrows[iarrow].col.col[0],
+					      obj.arrows[iarrow].col.col[1],
+					      obj.arrows[iarrow].col.col[2], 
+					      feature_opacity};
+		  GLfloat  mat_shininess[] = {15};
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_specular);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_specular);
+		  g.graphics_object_internal_arrow((*generic_objects_p)[i].arrows[iarrow].start_point,
+						   (*generic_objects_p)[i].arrows[iarrow].end_point,
+						   0.3, 0.1); 
+	       }
+	    }
+
+	    // tori
+	    if ((*generic_objects_p)[i].tori.size()) {
+	       glEnable (GL_BLEND);
+	       glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	       for (unsigned int itor=0; itor<(*generic_objects_p)[i].tori.size(); itor++) {
+		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
+		  GLfloat  mat_diffuse[]  = {obj.tori[itor].col.col[0],
+					     obj.tori[itor].col.col[1],
+					     obj.tori[itor].col.col[2], 
+					     feature_opacity};
+		  GLfloat  mat_specular[]  = {0.1, 0.1, 0.1, 1.0};
+		  GLfloat  mat_shininess[] = {1};
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_diffuse);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_diffuse);
+
+		  g.graphics_object_internal_torus(obj.tori[itor].start_point,
+						   obj.tori[itor].end_point,
+						   obj.tori[itor].radius_1,
+						   obj.tori[itor].radius_2,
+						   obj.tori[itor].n_ring_atoms);
+	       }
+	    }
+
+	    // arcs
+	    if ((*generic_objects_p)[i].arcs.size()) {
+	    
+	       for (unsigned int iarc=0; iarc<(*generic_objects_p)[i].arcs.size(); iarc++) {
+		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
+
+		  // glEnable(GL_COLOR_MATERIAL);
+		  glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
+	       
+		  GLfloat  mat_diffuse[]  = {float(obj.arcs[iarc].col.col[0] * 0.8),
+					     float(obj.arcs[iarc].col.col[1] * 0.8),
+					     float(obj.arcs[iarc].col.col[2] * 0.8),
+					     1.0};
+		  // 	       GLfloat  mat_specular[]  = {obj.arcs[iarc].col.col[0],
+		  // 					   obj.arcs[iarc].col.col[1],
+		  // 					   obj.arcs[iarc].col.col[2], 
+		  // 					   1.0};
+		  GLfloat  mat_specular[]  = {0.6, 0.6, 0.6, 1};
+		  GLfloat  mat_shininess[] = {35};
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_diffuse);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_diffuse);
+
+		  g.graphics_object_internal_arc(obj.arcs[iarc].start_angle,
+						 obj.arcs[iarc].end_angle,
+						 obj.arcs[iarc].start_point,
+						 obj.arcs[iarc].start_dir,
+						 obj.arcs[iarc].normal,
+						 obj.arcs[iarc].radius,
+						 obj.arcs[iarc].radius_inner);
+	       }
+	    }
+
+
+	    // dodecahdrons
+	    //
+	    if ((*generic_objects_p)[i].dodecs.size()) {
+	       float feature_opacity = 0.7;
+	       glEnable (GL_BLEND);
+	       glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	       for (unsigned int idodec=0; idodec<(*generic_objects_p)[i].dodecs.size(); idodec++) {
+		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
+		  GLfloat  mat_diffuse[]  = {obj.dodecs[idodec].col.red,
+					     obj.dodecs[idodec].col.green,
+					     obj.dodecs[idodec].col.blue, 
+					     feature_opacity};
+		  GLfloat  mat_specular[]  = {0.3, 0.3, 0.3, 1.0};
+		  GLfloat  mat_shininess[] = {1};
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_diffuse);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_diffuse);
+
+		  g.graphics_object_internal_dodec(obj.dodecs[idodec]);
+	       }
+	    }
+
+	    // pentakis dodecahdrons
+	    //
+	    if ((*generic_objects_p)[i].pentakis_dodecs.size()) {
+	       float feature_opacity = 0.93;
+	       glEnable (GL_BLEND);
+	       glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	       for (unsigned int idodec=0; idodec<(*generic_objects_p)[i].pentakis_dodecs.size(); idodec++) {
+		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
+		  GLfloat  mat_diffuse[]  = {obj.pentakis_dodecs[idodec].col.red,
+					     obj.pentakis_dodecs[idodec].col.green,
+					     obj.pentakis_dodecs[idodec].col.blue, 
+					     feature_opacity};
+		  GLfloat  mat_specular[]  = {0.5, 0.5, 0.5, 1.0};
+		  GLfloat  mat_shininess[] = {40};
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_diffuse);
+		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_diffuse);
+
+		  g.graphics_object_internal_pentakis_dodec(obj.pentakis_dodecs[idodec]);
+	       }
+	    }
+
+	    
+	 }
+      }
+      glDisable(GL_LIGHTING);
+   }
+}
+
+
+
+/*! \brief return the number of generic display objects */
+int number_of_generic_objects() {
+
+   graphics_info_t g;
+   return g.generic_objects_p->size();
+}
+
+std::pair<short int, std::string>
+is_interesting_dots_object_next_p(const std::vector<std::string> &vs) {
+
+   std::pair<short int, std::string> r(0, "");
+
+   if (vs.size() == 3) {
+//       std::cout << "Looking at bits:  \n  "; 
+//       for (unsigned int i=0; i<3; i++) { 
+// 	 std::cout << ":" << vs[i] << ": ";
+//       }
+//       std::cout << "\n"; 
+      if ((vs[1] == "wide") && (vs[2] == "contact)")) {
+	 r.first = 1;
+	 r.second = "wide contact";
+      }
+      if ((vs[1] == "close") && (vs[2] == "contact)")) {
+	 r.first = 1;
+	 r.second = "close contact";
+      }
+      if ((vs[1] == "small") && (vs[2] == "overlap)")) {
+	 r.first = 1;
+	 r.second = "small overlap";
+      }
+      if ((vs[1] == "bad") && (vs[2] == "overlap)")) {
+	 r.first = 1;
+	 r.second = "bad overlap";
+      }
+      if (vs[1] == "H-bonds)") { 
+	 r.first = 1;
+	 r.second = "H-bonds";
+      }
+   }
+   return r;
+}
+
+std::string probe_dots_short_contact_name_to_expanded_name(const std::string &short_name) {
+
+   std::vector<std::pair<std::string, std::string> > names;
+   names.push_back(std::pair<std::string, std::string>("wc", "wide contact"));
+   names.push_back(std::pair<std::string, std::string>("cc", "close contact"));
+   names.push_back(std::pair<std::string, std::string>("so", "small overlap"));
+   names.push_back(std::pair<std::string, std::string>("bo", "bad overlap"));
+   names.push_back(std::pair<std::string, std::string>("hb", "H-bonds"));
+
+   std::string r = "unknown";
+   for (int i=0; i<5; i++) {
+      if (names[i].first == short_name) {
+	 r = names[i].second;
+	 break;
+      }
+   } 
+   return r;
+} 
diff -ruN coot-0.8.7/src/flev.cc coot-0.8.8-pre/src/flev.cc
--- coot-0.8.7/src/flev.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/src/flev.cc	2017-01-25 14:34:21.000000000 -0800
@@ -1008,7 +1008,7 @@
 			   float h_bond_dist_max) {
    
    std::vector<coot::fle_ligand_bond_t> v; // returned value
-   bool debug = false;
+   bool debug = true;
 
    if (debug) {
       std::cout << "::::::::::::::::::::: get_fle_ligand_bonds() inputs: " << std::endl;
@@ -1061,7 +1061,8 @@
 
       for (unsigned int i=0; i<hbonds.size(); i++) {
 	 if (debug)
-	    std::cout << coot::atom_spec_t(hbonds[i].donor) << "..."
+	    std::cout << "DEBUG:: in get_fle_ligand_bonds() hbond [" << i << "] "
+		      << coot::atom_spec_t(hbonds[i].donor) << "...to... "
 		      << coot::atom_spec_t(hbonds[i].acceptor) << " with ligand donor flag "
 		      << hbonds[i].ligand_atom_is_donor << std::endl;
 
@@ -1111,7 +1112,9 @@
 	 if (debug) 
 	    std::cout << "constructing fle ligand bond " << ligand_atom->name
 		      << " " << bond_type << " " << hbonds[i].dist << " " 
-		      << env_residue_atom << std::endl;
+		      << coot::atom_spec_t(env_residue_atom) << " "
+		      << env_residue_atom->GetResName()
+		      << std::endl;
 
 	 // we want to pass the atom specifics (not just the environ residue spec)
 	 // 
diff -ruN coot-0.8.7/src/generic-display-objects-c.h coot-0.8.8-pre/src/generic-display-objects-c.h
--- coot-0.8.7/src/generic-display-objects-c.h	2015-08-26 04:54:02.000000000 -0700
+++ coot-0.8.8-pre/src/generic-display-objects-c.h	2016-12-21 05:34:30.000000000 -0800
@@ -15,4 +15,13 @@
 
 void clear_generic_objects_dialog_pointer();
 
+/*! \brief display (1) or undisplay (0) all generic display objects */
+void set_display_all_generic_objects(int state);
+
+/*! \brief a kludgey thing, so that the generic objects gui can be
+  called from a callback.  */
+void generic_objects_gui_wrapper();
+
+void close_all_generic_objects();
+
 END_C_DECLS
diff -ruN coot-0.8.7/src/generic-objects.cc coot-0.8.8-pre/src/generic-objects.cc
--- coot-0.8.7/src/generic-objects.cc	2016-09-01 17:13:24.000000000 -0700
+++ coot-0.8.8-pre/src/generic-objects.cc	2016-12-21 05:34:30.000000000 -0800
@@ -41,6 +41,7 @@
 #include "c-interface-widgets.hh" // for generic_objects_dialog_table_add_object_internal()
 
 #include "graphics-info.h"
+#include "c-interface-generic-objects.h"
 
 
 /*  ----------------------------------------------------------------------- */
@@ -147,6 +148,24 @@
    } 
 }
 
+void to_generic_object_add_point_internal(int object_number, 
+					  const std::string &colour_name,
+					  const coot::colour_holder &colour,
+					  int point_width,
+					  const clipper::Coord_orth &pt) {
+
+   graphics_info_t g;
+
+   if (object_number >=0 && object_number < int(g.generic_objects_p->size())) { 
+
+      (*g.generic_objects_p)[object_number].add_point(colour, colour_name, point_width, pt);
+
+   } else {
+      std::cout << "BAD object_number in to_generic_object_add_point: "
+		<< object_number << std::endl;
+   }
+}
+
 
 void to_generic_object_add_dodecahedron(int object_number,
 					const char *colour_name,
@@ -247,12 +266,10 @@
       std::cout << "BAD object_number in to_generic_object_add_point: "
 		<< object_number << std::endl;
    } 
-   
-
 }
 
 
-void set_display_generic_object(int object_number, short int istate) {
+void set_display_generic_object_simple(int object_number, short int istate) {
 
    graphics_info_t g;
    if (object_number >=0  && object_number < int(g.generic_objects_p->size())) {
@@ -261,7 +278,6 @@
       std::cout << "BAD object_number in to_generic_object_add_point: "
 		<< object_number << std::endl;
    }
-   graphics_draw();
 
    if (g.generic_objects_dialog) {
       // get the togglebutton and set its state
@@ -270,6 +286,7 @@
 	 "_toggle_button";
       GtkWidget *toggle_button = lookup_widget(g.generic_objects_dialog,
 					       toggle_button_name.c_str());
+
       if (toggle_button) {
 	 if (istate)
 	    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toggle_button), TRUE);
@@ -279,14 +296,21 @@
    }
 }
 
+void set_display_generic_object(int object_number, short int istate) {
+   set_display_generic_object_simple(object_number, istate);
+   graphics_draw();
+}
+
+
 /*! \brief display (1) or undisplay (0) all generic display objects */
 void set_display_all_generic_objects(int state) {
 
    graphics_info_t g;
    unsigned int n_objs = g.generic_objects_p->size();
    for (unsigned int i=0; i<n_objs; i++) {
-      set_display_generic_object(i, state);
+      set_display_generic_object_simple(i, state);
    }
+   graphics_draw();
 }
 
 
@@ -449,7 +473,6 @@
 	 gtk_widget_hide(toggle_button);
       if (label)
 	 gtk_widget_hide(label);
-      
    }
 }
 
@@ -480,6 +503,17 @@
    }
 }
 
+void generic_objects_gui_wrapper() {
+
+   graphics_info_t g;
+   if (! g.generic_objects_dialog) { 
+      g.generic_objects_dialog = wrapped_create_generic_objects_dialog();
+   }
+   gtk_widget_show(g.generic_objects_dialog);
+} 
+
+
+
 /*! \brief attach the generic object to a particular molecule 
 
 one might do this if the generic object is specific to a molecule.
@@ -895,7 +929,7 @@
 		   std::string s = g.state_command(cmd_strings, coot::STATE_PYTHON);
 		   safe_python_command(s);
 #else
-#if defined USE_GUILE && !defined WINDOWS_MINGW
+#if defined USE_GUILE_GTK && !defined WINDOWS_MINGW
 		   graphics_info_t g;
 		   std::vector<std::string> cmd_strings;
 		   cmd_strings.push_back("interesting-things-gui");
@@ -905,10 +939,10 @@
 		   cmd_strings.push_back(ls);
 		   std::string s = g.state_command(cmd_strings, coot::STATE_SCM);
 		   safe_scheme_command(s);
-#endif // GUILE
+#endif // GUILE_GTK
 #endif // PYGTK
 		} else {
-#if defined USE_GUILE && !defined WINDOWS_MINGW
+#if defined USE_GUILE_GTK && !defined WINDOWS_MINGW
 		   graphics_info_t g;
 		   std::vector<std::string> cmd_strings;
 		   cmd_strings.push_back("interesting-things-gui");
diff -ruN coot-0.8.7/src/get-monomer.cc coot-0.8.8-pre/src/get-monomer.cc
--- coot-0.8.7/src/get-monomer.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/src/get-monomer.cc	2016-12-21 05:34:30.000000000 -0800
@@ -159,6 +159,9 @@
       move_molecule_to_screen_centre_internal(imol);
       graphics_draw();
       istat = imol;
+   } else {
+      std::cout << "WARNING:: Null mol from mol_from_dictionary() with comp_id " << comp_id << " "
+		<< idealised_flag << std::endl;
    }
    return istat;
 }
diff -ruN coot-0.8.7/src/git-revision-count.cc coot-0.8.8-pre/src/git-revision-count.cc
--- coot-0.8.7/src/git-revision-count.cc	2016-11-08 07:55:30.000000000 -0800
+++ coot-0.8.8-pre/src/git-revision-count.cc	2017-01-25 14:39:13.000000000 -0800
@@ -1 +1 @@
-extern "C" { int git_revision_count() { return 6498 ; } }
+extern "C" { int git_revision_count() { return 6603 ; } }
diff -ruN coot-0.8.7/src/globjects.cc coot-0.8.8-pre/src/globjects.cc
--- coot-0.8.7/src/globjects.cc	2016-11-01 08:46:49.000000000 -0700
+++ coot-0.8.8-pre/src/globjects.cc	2017-01-24 09:37:54.000000000 -0800
@@ -2308,7 +2308,7 @@
       }
 
 
-      // 
+      //
       draw_crosshairs_maybe();
 
       // 
@@ -2898,12 +2898,15 @@
    // 
    info.add_to_RotationCentre(vec_x_y, -x_diff*0.02, -y_diff*0.02);
 
-   if (info.GetActiveMapDrag() == 1) {
-      for (int ii=0; ii<info.n_molecules(); ii++) { 
-	 info.molecules[ii].update_map(); // to take account
-	 // of new rotation centre.
-      }
-   }
+//    if (info.GetActiveMapDrag() == 1) {
+//       for (int ii=0; ii<info.n_molecules(); ii++) {
+// 	 info.molecules[ii].update_map(); // to take account
+// 	 // of new rotation centre.
+//       }
+//    }
+
+   info.update_maps();
+
    for (int ii=0; ii<info.n_molecules(); ii++) { 
       info.molecules[ii].update_symmetry();
    }
@@ -3779,12 +3782,13 @@
       break;
       
    case GDK_c:
-   case GDK_C:
       if (graphics_info_t::control_is_pressed) {
 	 g.copy_active_atom_molecule();
       } else {
-	 g.draw_crosshairs_flag = 1 - g.draw_crosshairs_flag; 
-	 g.crosshairs_text();
+	 if (! graphics_info_t::shift_is_pressed) {
+	    g.draw_crosshairs_flag = 1 - g.draw_crosshairs_flag;
+	    g.crosshairs_text();
+	 }
       }
       g.graphics_draw();
       break;
diff -ruN coot-0.8.7/src/graphics-info-graphs.cc coot-0.8.8-pre/src/graphics-info-graphs.cc
--- coot-0.8.7/src/graphics-info-graphs.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/src/graphics-info-graphs.cc	2017-01-13 09:52:23.000000000 -0800
@@ -1491,7 +1491,7 @@
 	 if (this_resno > max_resno)
 	    max_resno = this_resno;
 
-	 mmdb::PAtom *residue_atoms;
+	 mmdb::PAtom *residue_atoms=0;
 	 int n_residue_atoms;
 
 	 SelResidues[ir]->GetAtomTable(residue_atoms, n_residue_atoms);
diff -ruN coot-0.8.7/src/graphics-info-gui.cc coot-0.8.8-pre/src/graphics-info-gui.cc
--- coot-0.8.7/src/graphics-info-gui.cc	2016-11-01 08:46:49.000000000 -0700
+++ coot-0.8.8-pre/src/graphics-info-gui.cc	2017-01-23 10:30:04.000000000 -0800
@@ -2636,7 +2636,7 @@
 
 }
 
-// static 
+// static
 void
 graphics_info_t::edit_backbone_peptide_changed_func(GtkAdjustment *adj, GtkWidget *window) { 
    
@@ -2654,17 +2654,17 @@
       
       double rad_angle = clipper::Util::d2rad(adj->value);
       clipper::Coord_orth new_c = 
-	 g.rotate_round_vector(backbone_torsion_end_ca_2 - backbone_torsion_end_ca_1,
-			       this_c.second,
-			       backbone_torsion_end_ca_1, rad_angle);
+	 coot::util::rotate_around_vector(backbone_torsion_end_ca_2 - backbone_torsion_end_ca_1,
+				this_c.second,
+				backbone_torsion_end_ca_1, rad_angle);
       clipper::Coord_orth new_o = 
-	 g.rotate_round_vector(backbone_torsion_end_ca_2 - backbone_torsion_end_ca_1,
-			       this_o.second,
-			       backbone_torsion_end_ca_1, rad_angle);
+	 coot::util::rotate_around_vector(backbone_torsion_end_ca_2 - backbone_torsion_end_ca_1,
+					  this_o.second,
+					  backbone_torsion_end_ca_1, rad_angle);
       clipper::Coord_orth new_n = 
-	 g.rotate_round_vector(backbone_torsion_end_ca_2 - backbone_torsion_end_ca_1,
-			       next_n.second,
-			       backbone_torsion_end_ca_1, rad_angle);
+	 coot::util::rotate_around_vector(backbone_torsion_end_ca_2 - backbone_torsion_end_ca_1,
+					  next_n.second,
+					  backbone_torsion_end_ca_1, rad_angle);
       n_atom_p->x = new_n.x();
       n_atom_p->y = new_n.y();
       n_atom_p->z = new_n.z();
@@ -2695,7 +2695,7 @@
 					  "resname", label, 1, "inscode", "chainid");
 	    vp.push_back(phipsi1);
 	 }
-	 if (pp.second.first > -200) { 
+	 if (pp.second.first > -200) {
 	    label = int_to_string(n_atom_p->GetSeqNum());
 	    label += n_atom_p->GetChainID();
 	    coot::util::phi_psi_t phipsi2(clipper::Util::rad2d(pp.second.first), 
@@ -2738,13 +2738,13 @@
 
       double rad_angle = clipper::Util::d2rad(adj->value);
       clipper::Coord_orth new_c = 
-	 g.rotate_round_vector(carbonyl_n_pos - backbone_torsion_end_ca_1,
-			       this_c.second,
-			       backbone_torsion_end_ca_1, rad_angle);
+	 coot::util::rotate_around_vector(carbonyl_n_pos - backbone_torsion_end_ca_1,
+					  this_c.second,
+					  backbone_torsion_end_ca_1, rad_angle);
       clipper::Coord_orth new_o = 
-	 g.rotate_round_vector(carbonyl_n_pos - backbone_torsion_end_ca_1,
-			       this_o.second,
-			       backbone_torsion_end_ca_1, rad_angle);
+	 coot::util::rotate_around_vector(carbonyl_n_pos - backbone_torsion_end_ca_1,
+					  this_o.second,
+					  backbone_torsion_end_ca_1, rad_angle);
 
       c_atom_p->x = new_c.x();
       c_atom_p->y = new_c.y();
@@ -2816,11 +2816,11 @@
    double rad_angle = clipper::Util::d2rad(angle);
    
    clipper::Coord_orth new_c = 
-      rotate_round_vector(carbonyl_n_pos - backbone_torsion_end_ca_1,
+      coot::util::rotate_around_vector(carbonyl_n_pos - backbone_torsion_end_ca_1,
 			  carbonyl_c_pos,
 			  carbonyl_n_pos, rad_angle);
    clipper::Coord_orth new_o = 
-      rotate_round_vector(carbonyl_n_pos - backbone_torsion_end_ca_1,
+      coot::util::rotate_around_vector(carbonyl_n_pos - backbone_torsion_end_ca_1,
 			  carbonyl_o_pos,
 			  carbonyl_n_pos, rad_angle);
 
@@ -2947,16 +2947,16 @@
    double rad_angle = clipper::Util::d2rad(angle);
 
    clipper::Coord_orth new_c = 
-      rotate_round_vector(backbone_torsion_end_ca_2 - backbone_torsion_end_ca_1,
+      coot::util::rotate_around_vector(backbone_torsion_end_ca_2 - backbone_torsion_end_ca_1,
 			  carbonyl_c_pos,
 			  backbone_torsion_end_ca_1, rad_angle);
    clipper::Coord_orth new_o = 
-      rotate_round_vector(backbone_torsion_end_ca_2 - backbone_torsion_end_ca_1,
+      coot::util::rotate_around_vector(backbone_torsion_end_ca_2 - backbone_torsion_end_ca_1,
 			  carbonyl_o_pos,
 			  backbone_torsion_end_ca_1, rad_angle);
 
    clipper::Coord_orth new_n = 
-      rotate_round_vector(backbone_torsion_end_ca_2 - backbone_torsion_end_ca_1,
+      coot::util::rotate_around_vector(backbone_torsion_end_ca_2 - backbone_torsion_end_ca_1,
 			  carbonyl_n_pos,
 			  backbone_torsion_end_ca_1, rad_angle);
 
diff -ruN coot-0.8.7/src/graphics-info-modelling.cc coot-0.8.8-pre/src/graphics-info-modelling.cc
--- coot-0.8.7/src/graphics-info-modelling.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/src/graphics-info-modelling.cc	2017-01-23 10:30:04.000000000 -0800
@@ -2916,7 +2916,7 @@
 				moving_atoms_asc->atom_selection[i]->y,
 				moving_atoms_asc->atom_selection[i]->z);
 	 clipper::Coord_orth new_pos = 
-	    g.rotate_round_vector(screen_vector, co, rotation_centre, x_diff * 0.018);
+	    coot::util::rotate_around_vector(screen_vector, co, rotation_centre, x_diff * 0.018);
 	 moving_atoms_asc->atom_selection[i]->x = new_pos.x();
 	 moving_atoms_asc->atom_selection[i]->y = new_pos.y();
 	 moving_atoms_asc->atom_selection[i]->z = new_pos.z();
diff -ruN coot-0.8.7/src/graphics-info-pick.cc coot-0.8.8-pre/src/graphics-info-pick.cc
--- coot-0.8.7/src/graphics-info-pick.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/src/graphics-info-pick.cc	2017-01-23 10:30:04.000000000 -0800
@@ -719,7 +719,7 @@
 				      moving_atoms_asc->atom_selection[i]->y,
 				      moving_atoms_asc->atom_selection[i]->z);
 	       clipper::Coord_orth new_pos = 
-		  rotate_round_vector(screen_vector, co, rotation_centre, angle);
+		  coot::util::rotate_around_vector(screen_vector, co, rotation_centre, angle);
 	       moving_atoms_asc->atom_selection[i]->x = new_pos.x();
 	       moving_atoms_asc->atom_selection[i]->y = new_pos.y();
 	       moving_atoms_asc->atom_selection[i]->z = new_pos.z();
@@ -779,7 +779,7 @@
 				      moving_atoms_asc->atom_selection[i]->y,
 				      moving_atoms_asc->atom_selection[i]->z);
 	       clipper::Coord_orth new_pos = 
-		  rotate_round_vector(screen_vector, co, rotation_centre, angle);
+		  coot::util::rotate_around_vector(screen_vector, co, rotation_centre, angle);
 	       moving_atoms_asc->atom_selection[i]->x = new_pos.x();
 	       moving_atoms_asc->atom_selection[i]->y = new_pos.y();
 	       moving_atoms_asc->atom_selection[i]->z = new_pos.z();
diff -ruN coot-0.8.7/src/graphics-info-render.cc coot-0.8.8-pre/src/graphics-info-render.cc
--- coot-0.8.7/src/graphics-info-render.cc	2016-08-16 05:58:38.000000000 -0700
+++ coot-0.8.8-pre/src/graphics-info-render.cc	2016-12-27 13:13:20.000000000 -0800
@@ -499,33 +499,37 @@
 		    << density_colour.col[2] << "\n";
    }
 
-   for (unsigned int ib=0; ib<bond_lines.size(); ib++) {
-      render_stream << "3" << "\n";
-      // coord1 radius coord2 dummy colour
-      render_stream << "  " 
-		    << bond_lines[ib].first.x() << " "
-		    << bond_lines[ib].first.y() << " "
-		    << bond_lines[ib].first.z() << " "
-		    << bond_thickness << " "
-		    << bond_lines[ib].second.x() << " "
-		    << bond_lines[ib].second.y() << " "
-		    << bond_lines[ib].second.z() << " "
-		    << bond_thickness << " "
-		    << bond_colour[ib].col[0] << " "
-		    << bond_colour[ib].col[1] << " "
-		    << bond_colour[ib].col[2] << "\n";
+   for (unsigned int iset=0; iset<bond_lines.size(); iset++) {
+      std::cout << "set " << iset << " colour " << bond_lines[iset].colour << std::endl;
+      for (unsigned int ib=0; ib<bond_lines[iset].bonds.size(); ib++) {
+         render_stream << "3" << "\n";
+         // coord1 radius coord2 dummy colour
+         render_stream << "  " 
+		       << bond_lines[iset].bonds[ib].begin_pos.x() << " "
+		       << bond_lines[iset].bonds[ib].begin_pos.y() << " "
+		       << bond_lines[iset].bonds[ib].begin_pos.z() << " "
+		       << bond_lines[iset].bonds[ib].bond_thickness << " "
+		       << bond_lines[iset].bonds[ib].end_pos.x() << " "
+		       << bond_lines[iset].bonds[ib].end_pos.y() << " "
+		       << bond_lines[iset].bonds[ib].end_pos.z() << " "
+   		       << bond_lines[iset].bonds[ib].bond_thickness << " "
+		       << bond_lines[iset].colour[0] << " "
+		       << bond_lines[iset].colour[1] << " "
+		       << bond_lines[iset].colour[2] << "\n";
+      }
    }
 
    if (graphics_info_t::renderer_show_atoms_flag) { 
-      for (unsigned int iat=0; iat<atom.size(); iat++) {
+      for (unsigned int iat=0; iat<balls.size(); iat++) {
+	 double r = balls[iat].radius;
 	 render_stream << "2" << "\n";
-	 render_stream << atom[iat].first.x() << " "
-		       << atom[iat].first.y() << " "
-		       << atom[iat].first.z() << " "
-		       << atom_radius
-		       << " " << atom[iat].second.col[0]
-		       << " " << atom[iat].second.col[1]
-		       << " " << atom[iat].second.col[2]
+	 render_stream << balls[iat].pos.x() << " "
+		       << balls[iat].pos.y() << " "
+		       << balls[iat].pos.z() << " "
+		       << r
+		       << " " << balls[iat].colour[0]
+		       << " " << balls[iat].colour[1]
+		       << " " << balls[iat].colour[2]
 		       << "\n";
       }
    }
@@ -595,44 +599,47 @@
 						  float density_thickness,
 						  float bone_thickness) {
 
-   for (unsigned int ib=0; ib<bond_lines.size(); ib++) {
-      render_stream << "# render a bond\n";
-      render_stream << "AttributeBegin\n";
-      render_stream << "   Color [" << bond_colour[ib].col[0] << " "
-		    << bond_colour[ib].col[1] << " "
-		    << bond_colour[ib].col[2] << "]\n";
-      render_stream << "   Surface \"plastic\" \"Ka\" [1] \"Kd\" [0.5] \"Ks\" 1 \"roughness\" 0.1\n";
-// 		    << bond_lines[ib].first.x() << " "
-// 		    << bond_lines[ib].first.y() << " "
-// 		    << bond_lines[ib].first.z() << " "
-// 		    << bond_lines[ib].second.x() << " "
-// 		    << bond_lines[ib].second.y() << " "
-// 		    << bond_lines[ib].second.z() << "\n";
-
-//       render_stream << "   TransformBegin\n"; // no need
-      render_stream << "   Translate "
-		    << bond_lines[ib].first.x() << " "
-		    << bond_lines[ib].first.y() << " "
-		    << bond_lines[ib].first.z() << "\n";
-      double l = (bond_lines[ib].second - bond_lines[ib].first).amplitude();
-
-      coot::Cartesian v = (bond_lines[ib].second - bond_lines[ib].first);
-      v.unit_vector_yourself();
-      coot::Cartesian axis = coot::Cartesian::CrossProduct(v,Cartesian(0,0,1));
-      double dp = coot::dot_product(v,coot::Cartesian(0,0,-1));
-      // std::cout << " dot product: " << dp << std::endl;
-      if (dp > 1.0)  dp =  1.0;
-      if (dp < -1.0) dp = -1.0;
-      double angle = -180.0/M_PI*acos(dp);
-      if(fabs(axis.length())<1e-7) axis = coot::Cartesian(0,1,0);
-      render_stream << "   Rotate "
-		    << angle << " " << axis.x() << " " << axis.y() << " " << axis.z() << "\n";
-      // Think about scaling the cylinder so that far away bonds are not tiny thin.
+   for (unsigned int iset=0; iset<bond_lines.size(); iset++) {
+      for (unsigned int ib=0; ib<bond_lines[iset].bonds.size(); ib++) {
+	 render_stream << "# render a bond\n";
+	 render_stream << "AttributeBegin\n";
+	 render_stream << "   Color ["
+		       << bond_lines[iset].colour[0] << " "
+		       << bond_lines[iset].colour[1] << " "
+		       << bond_lines[iset].colour[2] << "]\n";
+	 render_stream << "   Surface \"plastic\" \"Ka\" [1] \"Kd\" [0.5] \"Ks\" 1 \"roughness\" 0.1\n";
+	 // 		    << bond_lines[ib].first.x() << " "
+	 // 		    << bond_lines[ib].first.y() << " "
+	 // 		    << bond_lines[ib].first.z() << " "
+	 // 		    << bond_lines[ib].second.x() << " "
+	 // 		    << bond_lines[ib].second.y() << " "
+	 // 		    << bond_lines[ib].second.z() << "\n";
+
+	 //       render_stream << "   TransformBegin\n"; // no need
+	 render_stream << "   Translate "
+		       << bond_lines[iset].bonds[ib].begin_pos.x() << " "
+		       << bond_lines[iset].bonds[ib].begin_pos.y() << " "
+		       << bond_lines[iset].bonds[ib].begin_pos.z() << "\n";
+	 double l = (bond_lines[iset].bonds[ib].begin_pos - bond_lines[iset].bonds[ib].end_pos).amplitude();
+
+	 coot::Cartesian v = (bond_lines[iset].bonds[ib].begin_pos - bond_lines[iset].bonds[ib].end_pos);
+	 v.unit_vector_yourself();
+	 coot::Cartesian axis = coot::Cartesian::CrossProduct(v,Cartesian(0,0,1));
+	 double dp = coot::dot_product(v,coot::Cartesian(0,0,-1));
+	 // std::cout << " dot product: " << dp << std::endl;
+	 if (dp > 1.0)  dp =  1.0;
+	 if (dp < -1.0) dp = -1.0;
+	 double angle = -180.0/M_PI*acos(dp);
+	 if(fabs(axis.length())<1e-7) axis = coot::Cartesian(0,1,0);
+	 render_stream << "   Rotate "
+		       << angle << " " << axis.x() << " " << axis.y() << " " << axis.z() << "\n";
+	 // Think about scaling the cylinder so that far away bonds are not tiny thin.
       
       
-      render_stream << "   Cylinder 0.15 0 " << l << "  360\n";
-      //       render_stream << "   TransformEnd\n";  // no need
-      render_stream << "AttributeEnd\n";
+	 render_stream << "   Cylinder 0.15 0 " << l << "  360\n";
+	 //       render_stream << "   TransformEnd\n";  // no need
+	 render_stream << "AttributeEnd\n";
+      }
    }
 
 }
@@ -979,54 +986,57 @@
 	}
       }
    }
-   for (unsigned int ib=0; ib<bond_lines.size(); ib++) {
+
+   for (unsigned int iset=0; iset<bond_lines.size(); iset++) {
+      for (unsigned int ib=0; ib<bond_lines[iset].bonds.size(); iset++) {
       
-      Cartesian v1 = bond_lines[ib].first  - front_clipping_plane_point;
-      Cartesian v2 = bond_lines[ib].second - front_clipping_plane_point;
-      Cartesian v3 = bond_lines[ib].first  -  back_clipping_plane_point;
-      Cartesian v4 = bond_lines[ib].second -  back_clipping_plane_point;
-      float dp1 = coot::dot_product(v1, front_clip_to_centre_vec);
-      float dp2 = coot::dot_product(v2, front_clip_to_centre_vec);
-      float dp3 = coot::dot_product(v3,  back_clip_to_centre_vec);
-      float dp4 = coot::dot_product(v4,  back_clip_to_centre_vec);
-      if ((dp1 > 0.0) && (dp2 > 0.0) && (dp3 > 0.0) && (dp4 > 0.0)) { 
-	 render_stream << "cylinder{ <"
-		       << bond_lines[ib].first.x() << ", "
-		       << bond_lines[ib].first.y() << ", "
-		       << bond_lines[ib].first.z() << ">\n "
-		       << "         <"
-		       << bond_lines[ib].second.x() << ", "
-		       << bond_lines[ib].second.y() << ", "
-		       << bond_lines[ib].second.z() << ">\n"
-		       << "         " << bond_thickness
-		       << "   pigment { color <"
-		       << bond_colour[ib].col[0] <<", "
-		       << bond_colour[ib].col[1] <<", "
-		       << bond_colour[ib].col[2] <<"> " << "} "
-	    // 		    << "scale " << 1.0*(100.0/zoom)
-		       << "scale " << 1.0
-		       << "}\n";
+	 Cartesian v1 = bond_lines[iset].bonds[ib].begin_pos  - front_clipping_plane_point;
+	 Cartesian v2 = bond_lines[iset].bonds[ib].end_pos    - front_clipping_plane_point;
+	 Cartesian v3 = bond_lines[iset].bonds[ib].begin_pos  -  back_clipping_plane_point;
+	 Cartesian v4 = bond_lines[iset].bonds[ib].end_pos    -  back_clipping_plane_point;
+	 float dp1 = coot::dot_product(v1, front_clip_to_centre_vec);
+	 float dp2 = coot::dot_product(v2, front_clip_to_centre_vec);
+	 float dp3 = coot::dot_product(v3,  back_clip_to_centre_vec);
+	 float dp4 = coot::dot_product(v4,  back_clip_to_centre_vec);
+	 if ((dp1 > 0.0) && (dp2 > 0.0) && (dp3 > 0.0) && (dp4 > 0.0)) { 
+	    render_stream << "cylinder{ <"
+			  << bond_lines[iset].bonds[ib].begin_pos.x() << ", "
+			  << bond_lines[iset].bonds[ib].begin_pos.y() << ", "
+			  << bond_lines[iset].bonds[ib].begin_pos.z() << ">\n "
+			  << "         <"
+			  << bond_lines[iset].bonds[ib].end_pos.x() << ", "
+			  << bond_lines[iset].bonds[ib].end_pos.y() << ", "
+			  << bond_lines[iset].bonds[ib].end_pos.z() << ">\n"
+			  << "         " << bond_thickness
+			  << "   pigment { color <"
+			  << bond_lines[iset].colour[0] <<", "
+			  << bond_lines[iset].colour[1] <<", "
+			  << bond_lines[iset].colour[2] <<"> " << "} "
+	       // 		    << "scale " << 1.0*(100.0/zoom)
+			  << "scale " << 1.0
+			  << "}\n";
+	 }
       }
    }
 
    // 		       << " " << atom[iat].second.col[0]
    // cylinder{<0,0,0>, <0,1,0>, 0.1 pigment {colour <0.1,0.2,0.3>} }
    if (graphics_info_t::renderer_show_atoms_flag) { 
-      for (unsigned int iat=0; iat<atom.size(); iat++) {
+      for (unsigned int iat=0; iat<balls.size(); iat++) {
       
-	 Cartesian v1 = atom[iat].first  - front_clipping_plane_point;
-	 Cartesian v2 = atom[iat].first  -  back_clipping_plane_point;
+	 Cartesian v1 = balls[iat].pos  - front_clipping_plane_point;
+	 Cartesian v2 = balls[iat].pos  -  back_clipping_plane_point;
 	 float dp1 = coot::dot_product(v1, front_clip_to_centre_vec);
 	 float dp2 = coot::dot_product(v2,  back_clip_to_centre_vec);
 	 if ((dp1 > 0) && (dp2 > 0)) { 
 	    render_stream << "sphere{ <"
-			  << atom[iat].first.x() << ","
-			  << atom[iat].first.y() << ","
-			  << atom[iat].first.z() << ">"
+			  << balls[iat].pos.x() << ","
+			  << balls[iat].pos.y() << ","
+			  << balls[iat].pos.z() << ">"
 			  << "0.3   pigment { color <"
-			  << atom[iat].second.col[0] <<", "
-			  << atom[iat].second.col[1] <<", "
-			  << atom[iat].second.col[2] <<">} "
+			  << balls[iat].colour[0] <<", "
+			  << balls[iat].colour[1] <<", "
+			  << balls[iat].colour[2] <<">} "
 			  << ""
 			  << "} "
 			  << "\n";
diff -ruN coot-0.8.7/src/graphics-info.cc coot-0.8.8-pre/src/graphics-info.cc
--- coot-0.8.7/src/graphics-info.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/src/graphics-info.cc	2017-01-24 09:37:54.000000000 -0800
@@ -39,7 +39,7 @@
 #endif
 
 #include <gtk/gtk.h>  // must come after mmdb_manager on MacOS X Darwin
-#include <GL/glut.h>  // for some reason...  // Eh?
+#include <GL/glut.h>  // Timing
 
 #include <iostream>
 #include <dirent.h>   // for refmac dictionary files
@@ -2361,32 +2361,32 @@
       float inner_angle_step = 6;
       for (float iangle=0; iangle<=360.1; iangle+=inner_angle_step) {
 
-	 // rotate_round_vector() args: direction position origin_shift angle
+	 // rotate_around_vector() args: direction position origin_shift angle
 	 clipper::Coord_orth pt_multi_this =
-	    coot::util::rotate_round_vector(this_circle_tangent,
-					    pt_ring_this,
-					    pt_this,
-					    clipper::Util::d2rad(iangle));
+	    coot::util::rotate_around_vector(this_circle_tangent,
+					     pt_ring_this,
+					     pt_this,
+					     clipper::Util::d2rad(iangle));
 	 clipper::Coord_orth pt_multi_next =
-	    coot::util::rotate_round_vector(next_circle_tangent,
-					    pt_ring_next,
-					    pt_next,
-					    clipper::Util::d2rad(iangle));
+	    coot::util::rotate_around_vector(next_circle_tangent,
+					     pt_ring_next,
+					     pt_next,
+					     clipper::Util::d2rad(iangle));
 
 	 // and the inner next of those points, i.e. neighbours
 	 // on the same inner ring.
 	 // 
 	 clipper::Coord_orth pt_multi_this_plus =
-	    coot::util::rotate_round_vector(this_circle_tangent,
-					    pt_ring_this,
-					    pt_this,
-					    clipper::Util::d2rad(iangle+inner_angle_step));
+	    coot::util::rotate_around_vector(this_circle_tangent,
+					     pt_ring_this,
+					     pt_this,
+					     clipper::Util::d2rad(iangle+inner_angle_step));
 	       
 	 clipper::Coord_orth pt_multi_next_plus =
-	    coot::util::rotate_round_vector(next_circle_tangent,
-					    pt_ring_next,
-					    pt_next,
-					    clipper::Util::d2rad(iangle+inner_angle_step));
+	    coot::util::rotate_around_vector(next_circle_tangent,
+					     pt_ring_next,
+					     pt_next,
+					     clipper::Util::d2rad(iangle+inner_angle_step));
 
 	 // 4 GL_QUAD vertices
 	 // small radius direction
@@ -2895,23 +2895,91 @@
    return r;
 } 
 
+// for threading, static
+void
+graphics_info_t::update_maps_for_mols(const std::vector<int> &mol_idxs) {
+   for (unsigned int i=0; i<mol_idxs.size(); i++)
+      graphics_info_t::molecules[mol_idxs[i]].update_map();
+}
 
+// move (on) up
+#ifdef HAVE_CXX_THREAD
+#include <thread>
+#include <future>
+#endif // HAVE_CXX_THREAD
+// remember to link with -std=c++11 to get thread constructors
 
 void
-graphics_info_t::add_vector_to_RotationCentre(const coot::Cartesian &vec) { 
-   
-   rotation_centre_x += vec.x();
-   rotation_centre_y += vec.y();
-   rotation_centre_z += vec.z();
+call_from_thread() {
+    std::cout << "Hello World" << std::endl;
+}
+
+void
+call_from_thread_v2(int i) {
+   std::cout << "Hello World " << i << std::endl;
+}
+
+
+void
+graphics_info_t::update_maps() {
+
+   // put it in it's own file xxx_threaded.cc and
+   // link that with -std=c++11 (or use macros to work out correct flags)
 
    if (GetActiveMapDrag() == 1) {
+
+#ifndef HAVE_CXX_THREAD
       for (int ii=0; ii<n_molecules(); ii++) { 
 	 if (molecules[ii].has_xmap()) { 
 	    molecules[ii].update_map(); // to take account
 	                                // of new rotation centre.
 	 }
       }
-   }
+#else
+      // unsigned int n_threads = 4;
+      unsigned int n_threads = coot::get_max_number_of_threads();
+      // std::cout << "got n_threads: " << n_threads << std::endl;
+      std::vector<std::thread> threads;
+      std::vector<int> molecules_with_maps;
+      for (int ii=0; ii<n_molecules(); ii++) {
+	 if (molecules[ii].has_xmap()) {
+	    molecules_with_maps.push_back(ii);
+	 }
+      }
+
+      // we must make sure that the threads don't update the same map
+      //
+
+      std::vector<std::vector<int> > maps_vec_vec(n_threads);
+      unsigned int thread_idx = 0;
+      // put the maps in maps_vec_vec
+      for (unsigned int ii=0; ii<molecules_with_maps.size(); ii++) {
+	 maps_vec_vec[thread_idx].push_back(molecules_with_maps[ii]);
+	 thread_idx++;
+	 if (thread_idx == n_threads) thread_idx = 0;
+      }
+
+
+      for (unsigned int i_thread=0; i_thread<n_threads; i_thread++) {
+	 const std::vector<int> &mv = maps_vec_vec[i_thread];
+	 threads.push_back(std::thread(update_maps_for_mols, mv));
+      }
+      for (unsigned int i_thread=0; i_thread<n_threads; i_thread++)
+	 threads.at(i_thread).join();
+
+#endif // HAVE_CXX_THREAD
+
+   } // active map drag test
+}
+
+void
+graphics_info_t::add_vector_to_RotationCentre(const coot::Cartesian &vec) {
+
+   rotation_centre_x += vec.x();
+   rotation_centre_y += vec.y();
+   rotation_centre_z += vec.z();
+
+   update_maps();
    for (int ii=0; ii<n_molecules(); ii++) { 
       molecules[ii].update_symmetry();
    }
@@ -2944,18 +3012,6 @@
    return cat;
 }
 
-// Rotate position round direction
-// 
-clipper::Coord_orth
-graphics_info_t::rotate_round_vector(const clipper::Coord_orth &direction,
-				     const clipper::Coord_orth &position,
-				     const clipper::Coord_orth &origin_shift,
-				     double angle) const {
-
-   // moved this function down to utils
-   return coot::util::rotate_round_vector(direction, position, origin_shift, angle);
-}
-
 
 
 int
@@ -3383,10 +3439,10 @@
    coot::Cartesian front  = unproject_xyz(0, 0, 0.0);
    coot::Cartesian screen_z = (front - centre);
 
-   clipper::Coord_orth new_pos = rotate_round_vector(to_coord_orth(screen_z),
-						     to_coord_orth(baton_tip),
-						     to_coord_orth(baton_root),
-						     0.01*diff);
+   clipper::Coord_orth new_pos = coot::util::rotate_around_vector(to_coord_orth(screen_z),
+								  to_coord_orth(baton_tip),
+								  to_coord_orth(baton_root),
+								  0.01*diff);
 
    baton_tip = to_cartesian(new_pos);
    graphics_draw();
@@ -4666,450 +4722,12 @@
 }
 
 
-// ---------------------- generic objects -----------------------------
-
-void
-coot::generic_display_object_t::add_line(const coot::colour_holder &colour_in,
-					 const std::string &colour_name,
-					 const int &width_in, 
-					 const std::pair<clipper::Coord_orth, clipper::Coord_orth> &coords_in) {
-
-   int lines_set_index = -1; // magic unset value
-   
-   for (unsigned int ils=0; ils<lines_set.size(); ils++) {
-      if (lines_set[ils].colour_name == colour_name) {
-	 if (lines_set[ils].width == width_in) {
-	    lines_set_index = ils;
-	    break;
-	 }
-      }
-   }
-
-   if (lines_set_index == -1) {
-      generic_display_line_set_t t(colour_in, colour_name, width_in);
-      lines_set.push_back(t);
-      lines_set_index = lines_set.size() -1;
-   }
-
-   coot::generic_display_line_t line(coords_in);
-   lines_set[lines_set_index].add_line(line);
-   
-}
-
-void coot::generic_display_object_t::add_point(const coot::colour_holder &colour_in,
-					       const std::string &colour_name,
-					       const int &size_in, 
-					       const clipper::Coord_orth &coords_in) {
-   int points_set_index = -1; // magic unset number
-   for (unsigned int ips=0; ips<points_set.size(); ips++) {
-      if (points_set[ips].colour_name == colour_name) {
-	 if (points_set[ips].size == size_in) {
-	    points_set_index = ips;
-	    break;
-	 } 
-      }
-   }
-   if (points_set_index == -1) {
-      coot::generic_display_point_set_t point_set(colour_in, colour_name, size_in);
-      points_set.push_back(point_set);
-      points_set_index = points_set.size() -1;
-   }
-   points_set[points_set_index].add_point(coords_in);
-}
-
-void
-coot::generic_display_object_t::add_dodecahedron(const colour_holder &colour_in,
-						 const std::string &colour_name,
-						 double radius,
-						 const clipper::Coord_orth &pos) {
-
-   dodec d;
-   dodec_t dod(d, radius, pos);
-   dod.col = colour_in;
-   dodecs.push_back(dod);
-}
-
-void
-coot::generic_display_object_t::add_pentakis_dodecahedron(const colour_holder &colour_in,
-							  const std::string &colour_name,
-							  double stellation_factor,
-							  double radius,
-							  const clipper::Coord_orth &pos) {
-
-   pentakis_dodec d(stellation_factor);
-   pentakis_dodec_t pdod(d, radius, pos);
-   pdod.col = colour_in;
-
-   pentakis_dodecs.push_back(pdod);
-}
-
-
-// static
-void
-graphics_info_t::draw_generic_objects() {
-   graphics_info_t g;
-   if (! g.display_generic_objects_as_solid_flag) 
-      g.draw_generic_objects_simple();
-   else 
-      g.draw_generic_objects_solid(); // gluCylinders and gluDisks
-}
-
-
-
-// static
-void
-graphics_info_t::draw_generic_objects_simple() {
-
-   // std::cout << "debug:: drawing " << generic_objects_p->size()
-   // << " generic objects" << std::endl;
-   
-   for (unsigned int i=0; i<generic_objects_p->size(); i++) {
-
-      if ((*generic_objects_p)[i].is_displayed_flag) {
-
-	 // if this is attached to a molecule that is not displayed, skip it.
-	 if ((*generic_objects_p)[i].is_valid_imol()) { // i.e. is not UNDEFINED
-	    int imol = (*generic_objects_p)[i].get_imol();
-	    if (is_valid_model_molecule(imol))
-	       if (! graphics_info_t::molecules[imol].is_displayed_p()) {
-		  continue;
-	       } 
-	 } 
-
-	 // Lines
-	 for (unsigned int ils=0; ils< (*generic_objects_p)[i].lines_set.size(); ils++) {
-	    glLineWidth((*generic_objects_p)[i].lines_set[ils].width);
-	    glColor3f((*generic_objects_p)[i].lines_set[ils].colour.red,
-		      (*generic_objects_p)[i].lines_set[ils].colour.green,
-		      (*generic_objects_p)[i].lines_set[ils].colour.blue);
-	    glBegin(GL_LINES);
-	    unsigned int s = (*generic_objects_p)[i].lines_set[ils].lines.size();
-	    for (unsigned int iline=0; iline<s; iline++) {
-	       glVertex3f((*generic_objects_p)[i].lines_set[ils].lines[iline].coords.first.x(),
-			  (*generic_objects_p)[i].lines_set[ils].lines[iline].coords.first.y(),
-			  (*generic_objects_p)[i].lines_set[ils].lines[iline].coords.first.z());
-	       glVertex3f((*generic_objects_p)[i].lines_set[ils].lines[iline].coords.second.x(),
-			  (*generic_objects_p)[i].lines_set[ils].lines[iline].coords.second.y(),
-			  (*generic_objects_p)[i].lines_set[ils].lines[iline].coords.second.z());
-	    }
-	    glEnd();
-	 }
-
-	 // Points
-	 for (unsigned int ips=0; ips<(*generic_objects_p)[i].points_set.size(); ips++) {
-	    glPointSize((*generic_objects_p)[i].points_set[ips].size);
-	    glColor3f((*generic_objects_p)[i].points_set[ips].colour.red,
-		      (*generic_objects_p)[i].points_set[ips].colour.green,
-		      (*generic_objects_p)[i].points_set[ips].colour.blue);
-	    glBegin(GL_POINTS);
-	    unsigned int npoints = (*generic_objects_p)[i].points_set[ips].points.size();
-	    for (unsigned int ipoint=0; ipoint<npoints; ipoint++) { 
-	       glVertex3f((*generic_objects_p)[i].points_set[ips].points[ipoint].x(),
-			  (*generic_objects_p)[i].points_set[ips].points[ipoint].y(),
-			  (*generic_objects_p)[i].points_set[ips].points[ipoint].z());
-	    }
-	    glEnd();
-	 }
-
-         // Display lists
-	 for (unsigned int idl=0; idl<(*generic_objects_p)[i].GL_display_list_handles.size(); idl++) {
-             glCallList((*generic_objects_p)[i].GL_display_list_handles[idl]);
-         }
-      }
-   }
-}
-
-// static
-void
-graphics_info_t::draw_generic_objects_solid() {
-
-   graphics_info_t g;
-   double radius = 0.02;
-
-   // Don't mess with the lighting if we aren't drawing anything
-   // 
-   if (generic_objects_p->size()) {
-
-      glEnable(GL_LIGHTING);
-      glEnable(GL_LIGHT1);
-      glEnable(GL_LIGHT0);
-      glDisable(GL_LIGHT2); // only for cut-glass mode
-      glDisable(GL_COLOR_MATERIAL);
-      glEnable(GL_NORMALIZE); // slows things, but makes the shiny nice
-
-      for (unsigned int i=0; i<generic_objects_p->size(); i++) {
-
-	 if ((*generic_objects_p)[i].is_displayed_flag) {
-
-
-	    // if this is attached to a molecule that is not displayed, skip it.
-	    if ((*generic_objects_p)[i].is_valid_imol()) { // i.e. is not UNDEFINED
-	       int imol = (*generic_objects_p)[i].get_imol();
-	       if (is_valid_model_molecule(imol))
-		  if (! graphics_info_t::molecules[imol].is_displayed_p()) {
-		     continue;
-		  } 
-	    } 
-	    
-
-	    // Previously (r4209) I had noted that
-	    // glEnable(GL_COLOR_MATERIAL) needed for correct tube
-	    // colours.
-	    // 
-	    // 20120903 but this creates problems when displaying
-	    // chemical features (they become solid yellow (with nvidia
-	    // drivers?)).  I currently don't understand what problems
-	    // result if we do not enable GL_COLOR_MATERIAL here. (Mogul
-	    // output markup seems OK?).  So comment out.
-	    // 
-	    // glEnable(GL_COLOR_MATERIAL);
-	 
-	    GLfloat  mat_specular[]  = {0.9, 0.9, 0.9, 1};
-	    GLfloat  mat_shininess[] = {80};
-	 
-	    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
-	    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
-	    
-	    // Lines
-	    for (unsigned int ils=0; ils< (*generic_objects_p)[i].lines_set.size(); ils++) {
-	    
-	       glLineWidth((*generic_objects_p)[i].lines_set[ils].width);
-	       // 	    glColor3f((*generic_objects_p)[i].lines_set[ils].colour.red,
-	       // 		      (*generic_objects_p)[i].lines_set[ils].colour.green,
-	       // 		      (*generic_objects_p)[i].lines_set[ils].colour.blue);
-
-	       GLfloat  mat_diffuse[]  = {(*generic_objects_p)[i].lines_set[ils].colour.red   * 0.8,
-					  (*generic_objects_p)[i].lines_set[ils].colour.green * 0.8,
-					  (*generic_objects_p)[i].lines_set[ils].colour.blue  * 0.8, 
-					  1.0};
-	       glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_diffuse);
-	       glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_diffuse);
-	    
-	       unsigned int s = (*generic_objects_p)[i].lines_set[ils].lines.size();
-	       for (unsigned int iline=0; iline<s; iline++) {
-
-		  g.graphics_object_internal_single_tube((*generic_objects_p)[i].lines_set[ils].lines[iline].coords.first,
-							 (*generic_objects_p)[i].lines_set[ils].lines[iline].coords.second,
-							 (*generic_objects_p)[i].lines_set[ils].width * radius,
-							 coot::ROUND_ENDS);
-	       }
-	    }
-	 
-	    // Points
-	    for (unsigned int ips=0; ips<(*generic_objects_p)[i].points_set.size(); ips++) {
-	       // 	    glColor3f((*generic_objects_p)[i].points_set[ips].colour.red,
-	       // 		      (*generic_objects_p)[i].points_set[ips].colour.green,
-	       // 		      (*generic_objects_p)[i].points_set[ips].colour.blue);
-	    
-	       int sphere_slices = 5;
-	       int sphere_stacks = 5;
-	       float feature_opacity = 1.0;
-	       unsigned int npoints = (*generic_objects_p)[i].points_set[ips].points.size();
-	       for (unsigned int ipoint=0; ipoint<npoints; ipoint++) {
-
-		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
-		  GLfloat  mat_specular[]  = {obj.points_set[ips].colour.red,
-					      obj.points_set[ips].colour.green,
-					      obj.points_set[ips].colour.blue,
-					      feature_opacity};
-		  GLfloat  mat_shininess[] = {15};
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_specular);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_specular);
-
-	       
-		  GLUquadric* sphere_quad = gluNewQuadric();
-		  glPushMatrix();
-		  glTranslatef((*generic_objects_p)[i].points_set[ips].points[ipoint].x(),
-			       (*generic_objects_p)[i].points_set[ips].points[ipoint].y(),
-			       (*generic_objects_p)[i].points_set[ips].points[ipoint].z());	 
-		  gluSphere(sphere_quad,
-			    (*generic_objects_p)[i].points_set[ips].size * radius,
-			    sphere_slices, sphere_stacks);
-		  gluDeleteQuadric(sphere_quad);
-		  glPopMatrix();	 
-	       }
-	    }
-
-	    // Other stuff:
-	    float feature_opacity = 0.6;
-	    // feature_opacity = 1.0; // hack for to fix shininess
-
-	    // spheres
-
-	    if ((*generic_objects_p)[i].spheres.size()) {
-	       glEnable (GL_BLEND); // these 2 lines are needed to make the transparency work.
-	       glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-	       for (unsigned int isphere=0; isphere<(*generic_objects_p)[i].spheres.size(); isphere++) { 
-
-		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
-		  GLfloat  mat_specular[]  = {obj.spheres[isphere].col.col[0],
-					      obj.spheres[isphere].col.col[1],
-					      obj.spheres[isphere].col.col[2], 
-					      feature_opacity};
-		  GLfloat  mat_shininess[] = {15};
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_specular);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_specular);
-	       
-		  int sphere_slices = 10;
-		  int sphere_stacks = 10;
-		  GLUquadric* sphere_quad = gluNewQuadric();
-		  glPushMatrix();
-		  glTranslatef((*generic_objects_p)[i].spheres[isphere].centre.x(),
-			       (*generic_objects_p)[i].spheres[isphere].centre.y(),
-			       (*generic_objects_p)[i].spheres[isphere].centre.z());
-		  gluSphere(sphere_quad,
-			    (*generic_objects_p)[i].spheres[isphere].radius,
-			    sphere_slices, sphere_stacks);
-		  gluDeleteQuadric(sphere_quad);
-		  glPopMatrix();
-	       }
-	    }
-
-	    // arrows
-	    if ((*generic_objects_p)[i].arrows.size()) {
-	       glEnable (GL_BLEND);
-	       glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-	       for (unsigned int iarrow=0; iarrow<(*generic_objects_p)[i].arrows.size(); iarrow++) {
-		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
-		  GLfloat  mat_specular[]  = {obj.arrows[iarrow].col.col[0],
-					      obj.arrows[iarrow].col.col[1],
-					      obj.arrows[iarrow].col.col[2], 
-					      feature_opacity};
-		  GLfloat  mat_shininess[] = {15};
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_specular);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_specular);
-		  g.graphics_object_internal_arrow((*generic_objects_p)[i].arrows[iarrow].start_point,
-						   (*generic_objects_p)[i].arrows[iarrow].end_point,
-						   0.3, 0.1); 
-	       }
-	    }
-
-	    // tori
-	    if ((*generic_objects_p)[i].tori.size()) {
-	       glEnable (GL_BLEND);
-	       glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-	       for (unsigned int itor=0; itor<(*generic_objects_p)[i].tori.size(); itor++) {
-		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
-		  GLfloat  mat_diffuse[]  = {obj.tori[itor].col.col[0],
-					     obj.tori[itor].col.col[1],
-					     obj.tori[itor].col.col[2], 
-					     feature_opacity};
-		  GLfloat  mat_specular[]  = {0.1, 0.1, 0.1, 1.0};
-		  GLfloat  mat_shininess[] = {1};
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_diffuse);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_diffuse);
-
-		  g.graphics_object_internal_torus(obj.tori[itor].start_point,
-						   obj.tori[itor].end_point,
-						   obj.tori[itor].radius_1,
-						   obj.tori[itor].radius_2,
-						   obj.tori[itor].n_ring_atoms);
-	       }
-	    }
-
-	    // arcs
-	    if ((*generic_objects_p)[i].arcs.size()) {
-	    
-	       for (unsigned int iarc=0; iarc<(*generic_objects_p)[i].arcs.size(); iarc++) {
-		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
-
-		  // glEnable(GL_COLOR_MATERIAL);
-		  glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
-	       
-		  GLfloat  mat_diffuse[]  = {obj.arcs[iarc].col.col[0] * 0.8,
-					     obj.arcs[iarc].col.col[1] * 0.8,
-					     obj.arcs[iarc].col.col[2] * 0.8, 
-					     1.0};
-		  // 	       GLfloat  mat_specular[]  = {obj.arcs[iarc].col.col[0],
-		  // 					   obj.arcs[iarc].col.col[1],
-		  // 					   obj.arcs[iarc].col.col[2], 
-		  // 					   1.0};
-		  GLfloat  mat_specular[]  = {0.6, 0.6, 0.6, 1};
-		  GLfloat  mat_shininess[] = {35};
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_diffuse);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_diffuse);
-
-		  g.graphics_object_internal_arc(obj.arcs[iarc].start_angle,
-						 obj.arcs[iarc].end_angle,
-						 obj.arcs[iarc].start_point,
-						 obj.arcs[iarc].start_dir,
-						 obj.arcs[iarc].normal,
-						 obj.arcs[iarc].radius,
-						 obj.arcs[iarc].radius_inner);
-	       }
-	    }
-
-
-	    // dodecahdrons
-	    //
-	    if ((*generic_objects_p)[i].dodecs.size()) {
-	       float feature_opacity = 0.7;
-	       glEnable (GL_BLEND);
-	       glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-	       for (unsigned int idodec=0; idodec<(*generic_objects_p)[i].dodecs.size(); idodec++) {
-		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
-		  GLfloat  mat_diffuse[]  = {obj.dodecs[idodec].col.red,
-					     obj.dodecs[idodec].col.green,
-					     obj.dodecs[idodec].col.blue, 
-					     feature_opacity};
-		  GLfloat  mat_specular[]  = {0.3, 0.3, 0.3, 1.0};
-		  GLfloat  mat_shininess[] = {1};
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_diffuse);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_diffuse);
-
-		  g.graphics_object_internal_dodec(obj.dodecs[idodec]);
-	       }
-	    }
-
-	    // pentakis dodecahdrons
-	    //
-	    if ((*generic_objects_p)[i].pentakis_dodecs.size()) {
-	       float feature_opacity = 0.93;
-	       glEnable (GL_BLEND);
-	       glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-	       for (unsigned int idodec=0; idodec<(*generic_objects_p)[i].pentakis_dodecs.size(); idodec++) {
-		  const coot::generic_display_object_t &obj = (*generic_objects_p)[i];
-		  GLfloat  mat_diffuse[]  = {obj.pentakis_dodecs[idodec].col.red,
-					     obj.pentakis_dodecs[idodec].col.green,
-					     obj.pentakis_dodecs[idodec].col.blue, 
-					     feature_opacity};
-		  GLfloat  mat_specular[]  = {0.5, 0.5, 0.5, 1.0};
-		  GLfloat  mat_shininess[] = {40};
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   mat_diffuse);
-		  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   mat_diffuse);
-
-		  g.graphics_object_internal_pentakis_dodec(obj.pentakis_dodecs[idodec]);
-	       }
-	    }
-
-	    
-	 }
-      }
-      glDisable(GL_LIGHTING);
-   }
-}
-
-
 void
 graphics_info_t::draw_generic_text() {
 
    // should be const, I think.
 
-   if (generic_texts_p->size() > 0 ) { 
+   if (generic_texts_p->size() > 0 ) {
       // GLfloat pink[3] =  { 1.0, 0.8, 0.8 };
       GLfloat pink[3] =  { font_colour.red, font_colour.green, font_colour.blue };
       glColor3fv(pink);
@@ -5140,8 +4758,8 @@
    if (c.length() == 7) {
       if (c[0] == '#') {
 	 return coot::colour_holder(c); // hex colour string
-      } 
-   } 
+      }
+   }
 
    if (c == "blue") {
       colour.red = 0.1; 
@@ -5149,9 +4767,9 @@
       colour.blue = 0.8;
    } else {
       if (c == "sky") {
-	 colour.red = 0.4; 
-	 colour.green = 0.4; 
-	 colour.blue = 0.6;
+	 colour.red = 0.53 * 0.6; 
+	 colour.green = 0.81 * 0.6; 
+	 colour.blue = 0.92 * 0.6;
       } else {
 	 if (c == "green") {
 	    colour.red   = 0.05; 
@@ -5204,25 +4822,43 @@
 				       colour.blue = 0.6;
 				    } else {
 				       if (c == "forestgreen") {
-					  colour.red = 0.6; 
-					  colour.green = 0.8; 
-					  colour.blue = 0.1;
+					  colour.red   = 0.6;
+					  colour.green = 0.8;
+					  colour.blue  = 0.1;
 				       } else {
 					  if (c == "yellowgreen") {
-					     colour.red   = 0.6; 
-					     colour.green = 0.8; 
+					     colour.red   = 0.6;
+					     colour.green = 0.8;
 					     colour.blue  = 0.2;
 					  } else {
 					     if (c == "goldenrod") {
-						colour.red   = 0.85; 
-						colour.green = 0.65; 
+						colour.red   = 0.85;
+						colour.green = 0.65;
 						colour.blue  = 0.12;
 					     } else {
 						if (c == "orangered") {
-						   colour.red   = 0.9; 
-						   colour.green = 0.27; 
+						   colour.red   = 0.9;
+						   colour.green = 0.27;
 						   colour.blue  = 0.0;
-						}
+						} else {
+						   if (c == "magenta") {
+						      colour.red   = 0.7;
+						      colour.green = 0.2;
+						      colour.blue  = 0.7;
+						   } else {
+						      if (c == "cornflower") {
+							 colour.red   = 0.38;
+							 colour.green = 0.58;
+							 colour.blue  = 0.93;
+						      } else {
+							 if (c == "royalblue") {
+							    colour.red   = 0.25;
+							    colour.green = 0.41;
+							    colour.blue  = 0.88;
+							 }
+						      }
+						   }
+						} 
 					     }
 					  }
 				       }
diff -ruN coot-0.8.7/src/graphics-info.h coot-0.8.8-pre/src/graphics-info.h
--- coot-0.8.7/src/graphics-info.h	2016-11-01 08:46:49.000000000 -0700
+++ coot-0.8.8-pre/src/graphics-info.h	2017-01-24 09:37:54.000000000 -0800
@@ -648,6 +648,9 @@
 			   const std::string &molname);
    int create_empty_molecule(const std::string &molname);
 
+   // for multi-threading
+   static void update_maps_for_mols(const std::vector<int> &mol_idxs);
+
    // symm_atom_pick (public) uses this (private) function:
 
    void 
@@ -1619,7 +1622,9 @@
    static float RotationCentre_x() { return rotation_centre_x; }
    static float RotationCentre_y() { return rotation_centre_y; }
    static float RotationCentre_z() { return rotation_centre_z; }
-   
+
+   // possibly for multi-threading, public access.
+   void update_maps();
 
    // pointer: aka rotation centre:
    // 
@@ -2580,14 +2585,6 @@
    // we allow terminal fitting without rigid body refinement
    static short int terminal_residue_do_rigid_body_refine; 
 
-   // Rotate position round direction, direction is not necessarily a
-   // unit vector
-   // 
-   clipper::Coord_orth rotate_round_vector(const clipper::Coord_orth &direction,
-					   const clipper::Coord_orth &position,
-					   const clipper::Coord_orth &origin_shift,
-					   double angle) const; 
-
    // public (from globjects);
    // 
    void execute_db_main();
diff -ruN coot-0.8.7/src/mol-hierachy.cc coot-0.8.8-pre/src/mol-hierachy.cc
--- coot-0.8.7/src/mol-hierachy.cc	2015-11-04 05:26:55.000000000 -0800
+++ coot-0.8.8-pre/src/mol-hierachy.cc	2016-12-21 05:34:30.000000000 -0800
@@ -166,7 +166,7 @@
    // for(int imod = 1; imod<=asc.mol->GetNumberOfModels(); imod++) {
    int imod = 1;
    mmdb::Model *model_p = mol->GetModel(imod);
-   if (model_p) { 
+   if (model_p) {
       mmdb::Chain *chain_p;
       int n_chains = model_p->GetNumberOfChains();
       for (int ichain=0; ichain<n_chains; ichain++) {
@@ -174,7 +174,7 @@
 	 int nres = chain_p->GetNumberOfResidues();
 	 mmdb::Residue *residue_p;
 	 mmdb::Atom *at;
-	 for (int ires=0; ires<nres; ires++) { 
+	 for (int ires=0; ires<nres; ires++) {
 	    residue_p = chain_p->GetResidue(ires);
 	    int n_atoms = residue_p->GetNumberOfAtoms();
 	    for (int iat=0; iat<n_atoms; iat++) {
diff -ruN coot-0.8.7/src/molecule-class-info-build.cc coot-0.8.8-pre/src/molecule-class-info-build.cc
--- coot-0.8.7/src/molecule-class-info-build.cc	2016-09-01 17:13:24.000000000 -0700
+++ coot-0.8.8-pre/src/molecule-class-info-build.cc	2016-12-21 05:34:30.000000000 -0800
@@ -423,3 +423,53 @@
    }
 
 } 
+
+#include "coot-utils/reduce.hh"
+
+
+void
+molecule_class_info_t::reduce(coot::protein_geometry *geom_p) {
+
+   make_backup();
+   mmdb::Manager *mol = atom_sel.mol;
+   coot::reduce r(mol, imol_no);
+   r.add_geometry(geom_p);
+   r.add_hydrogen_atoms();
+   update_molecule_after_additions();
+   update_symmetry();
+
+}
+
+void
+molecule_class_info_t::switch_HIS_protonation(coot::residue_spec_t res_spec) {
+
+   mmdb::Residue *residue_p = get_residue(res_spec);
+   if (residue_p) {
+
+      mmdb::Atom *at = 0;
+      mmdb::Atom *atom_1 = 0;
+      mmdb::Atom *atom_2 = 0;
+      mmdb::Atom **residue_atoms = 0;
+      int n_residue_atoms;
+      residue_p->GetAtomTable(residue_atoms, n_residue_atoms);
+      for (int i=0; i<n_residue_atoms; i++) {
+	 mmdb::Atom *res_at = residue_atoms[i];
+	 std::string atom_name = res_at->name;
+	 if (atom_name == " HD1")
+	    atom_1 = res_at;
+	 if (atom_name == " HE2")
+	    atom_2 = res_at;
+      }
+      
+      if (atom_1 && ! atom_2) at = atom_1;
+      if (atom_2 && ! atom_1) at = atom_2;
+
+      if (at) {
+	 make_backup();
+	 coot::reduce r(atom_sel.mol, imol_no);
+	 r.switch_his_protonation(residue_p, at);
+	 update_molecule_after_additions();
+	 update_symmetry();
+      }
+   }
+}
diff -ruN coot-0.8.7/src/molecule-class-info-dots-internal.cc coot-0.8.8-pre/src/molecule-class-info-dots-internal.cc
--- coot-0.8.7/src/molecule-class-info-dots-internal.cc	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/src/molecule-class-info-dots-internal.cc	2016-12-21 05:34:30.000000000 -0800
@@ -0,0 +1,9 @@
+
+////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////
+//                 coot built-in contact dots
+////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////
+
+// no need for this file - we need to create generic display objects and that is best done
+// using the c-interface
diff -ruN coot-0.8.7/src/molecule-class-info-maps.cc coot-0.8.8-pre/src/molecule-class-info-maps.cc
--- coot-0.8.7/src/molecule-class-info-maps.cc	2016-10-23 20:10:15.000000000 -0700
+++ coot-0.8.8-pre/src/molecule-class-info-maps.cc	2017-01-23 10:30:04.000000000 -0800
@@ -707,7 +707,7 @@
       // normal solid 
    
       GLfloat  ambientLight[] = { 0.2f, 0.2f, 0.2f, 1.0f };
-      GLfloat  diffuseLight[] = { 0.7f, 0.7f, 0.7f, 1.0f };
+      GLfloat  diffuseLight[] = { 0.4f, 0.4f, 0.4f, 1.0f };
       GLfloat specularLight[] = { 0.1f, 0.1f, 0.1f, 1.0f };
    
       // Assign created components to GL_LIGHT2
@@ -721,11 +721,13 @@
       // narrowing from doubles to floats (there is no glMaterialdv).
 
       GLfloat  mat_specular[]  = {0.4f,  0.4f,  0.4f,  opacity}; // makes a difference
-      GLfloat  mat_ambient[]   = {0.3*map_colour[0][0],
-				  0.3*map_colour[0][1],
-				  0.3*map_colour[0][2],
+      GLfloat  mat_ambient[]   = {float(0.3*map_colour[0][0]),
+				  float(0.3*map_colour[0][1]),
+				  float(0.3*map_colour[0][2]),
 				  opacity};
-      GLfloat  mat_diffuse[]   = {map_colour[0][0], map_colour[0][1], map_colour[0][2], opacity};
+      GLfloat  mat_diffuse[]   = {float(map_colour[0][0]),
+				  float(map_colour[0][1]),
+				  float(map_colour[0][2]), opacity};
       GLfloat  mat_shininess[] = {100}; // makes a difference
 	 
       glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  mat_specular);
@@ -736,8 +738,12 @@
       if (is_neg) {
 	 // override
 	 GLfloat  mat_specular[]  = {0.4,  0.4,  0.4,  opacity};
-	 GLfloat  mat_ambient[]   = {.3*map_colour[1][0], 0.3*map_colour[1][1], 0.3*map_colour[1][2], opacity};
-	 GLfloat  mat_diffuse[]   = {map_colour[1][0], map_colour[1][1], map_colour[1][2], opacity};
+	 GLfloat  mat_ambient[]   = {float(0.3*map_colour[1][0]),
+				     float(0.3*map_colour[1][1]),
+				     float(0.3*map_colour[1][2]), opacity};
+	 GLfloat  mat_diffuse[]   = {float(map_colour[1][0]),
+				     float(map_colour[1][1]),
+				     float(map_colour[1][2]), opacity};
 	 GLfloat  mat_shininess[] = {100};
 
 // 	 std::cout << " is_neg with map_colour: "
diff -ruN coot-0.8.7/src/molecule-class-info-mutate.cc coot-0.8.8-pre/src/molecule-class-info-mutate.cc
--- coot-0.8.7/src/molecule-class-info-mutate.cc	2016-09-16 05:53:12.000000000 -0700
+++ coot-0.8.8-pre/src/molecule-class-info-mutate.cc	2017-01-23 10:30:04.000000000 -0800
@@ -1249,7 +1249,7 @@
 					    residue_atoms[iat]->y,
 					    residue_atoms[iat]->z);
 			
-		     clipper::Coord_orth co = coot::util::rotate_round_vector(dir, pt, orig, angle);
+		     clipper::Coord_orth co = coot::util::rotate_around_vector(dir, pt, orig, angle);
 		     residue_atoms[iat]->x = co.x();
 		     residue_atoms[iat]->y = co.y();
 		     residue_atoms[iat]->z = co.z();
diff -ruN coot-0.8.7/src/molecule-class-info-other.cc coot-0.8.8-pre/src/molecule-class-info-other.cc
--- coot-0.8.7/src/molecule-class-info-other.cc	2016-10-23 20:10:15.000000000 -0700
+++ coot-0.8.8-pre/src/molecule-class-info-other.cc	2017-01-25 14:34:21.000000000 -0800
@@ -464,12 +464,12 @@
 }
 
 void
-molecule_class_info_t::b_factor_representation() { 
+molecule_class_info_t::b_factor_representation() {
 
    Bond_lines_container::bond_representation_type bond_type =
       Bond_lines_container::COLOUR_BY_B_FACTOR;
 
-   Bond_lines_container bonds(atom_sel, bond_type);
+   Bond_lines_container bonds(atom_sel, imol_no, bond_type);
    bonds_box = bonds.make_graphical_bonds_no_thinning();
    bonds_box_type = coot::COLOUR_BY_B_FACTOR_BONDS;
 } 
@@ -493,7 +493,7 @@
    Bond_lines_container::bond_representation_type bond_type =
       Bond_lines_container::COLOUR_BY_OCCUPANCY;
 
-   Bond_lines_container bonds(atom_sel, bond_type);
+   Bond_lines_container bonds(atom_sel, imol_no, bond_type);
    bonds_box = bonds.make_graphical_bonds();
    bonds_box_type = coot::COLOUR_BY_OCCUPANCY_BONDS;
 } 
@@ -994,7 +994,9 @@
 //
 // model number is either a specific model number of mmdb::MinInt4, meaning:
 // any/all model(s).
-// 
+//
+// if we have delete_zone mode then we don't want to update the ghosts or the gui
+// or make backups
 short int
 molecule_class_info_t::delete_residue(int model_number,
 				      const std::string &chain_id, int resno,
@@ -1448,14 +1450,64 @@
 	 if (res1.model_number == res2.model_number)
 	    model_number_ANY = res1.model_number;
 
-   
-   for (int i=first_res; i<=last_res; i++)
-      // delete_residue_with_altconf(res1.chain, i, inscode, alt_conf);
-      delete_residue(model_number_ANY, res1.chain_id, i, inscode);
+   bool was_deleted = false;
+
+   std::vector<coot::residue_spec_t> deleted_residue_specs;
+   std::vector<mmdb::Residue *> deleted_residues;
+
+   // run over chains of the existing mol
+   int n_models = atom_sel.mol->GetNumberOfModels();
+   for (int imod=1; imod<=n_models; imod++) {
+
+      int nchains = atom_sel.mol->GetNumberOfChains(imod);
+      for (int ichain=0; ichain<nchains; ichain++) {
+
+	 mmdb::Chain *chain_p = atom_sel.mol->GetChain(imod, ichain);
+	 if (chain_p) {
+	    std::string mol_chain_id(chain_p->GetChainID());
+
+	    if (res1.chain_id == mol_chain_id) {
+
+	       int nres = chain_p->GetNumberOfResidues();
+	       // for (int ires=0; ires<nres; ires++) {
+	       for (int ires=nres-1; ires>=0; ires--) {
+		  mmdb::Residue *res = chain_p->GetResidue(ires);
+		  if (res) {
+		     int res_no = res->GetSeqNum();
+		     if (res_no >= first_res) {
+			if (res_no <= last_res) {
+			   was_deleted = true;
+			   deleted_residue_specs.push_back(coot::residue_spec_t(res));
+			   deleted_residues.push_back(res);
+			}
+		     }
+		  }
+	       }
+	       // delete multiple residues like this, rather than chain_p->DeleteResidue(ires);
+	       for (unsigned int i=0; i<deleted_residues.size(); i++)
+		  delete deleted_residues[i];
+	    }
+	 }
+      }
+   }
    backup_this_molecule = tmp_backup_this_molecule; // restore state
 
-   // bonds, have_unsaved_changes_flag etc dealt with by
-   // delete_residue_with_altconf().
+   if (was_deleted) {
+
+      std::cout << "INFO... deleting links..." << std::endl;
+      for (unsigned int ispec=0; ispec<deleted_residue_specs.size(); ispec++) {
+	 const coot::residue_spec_t &spec = deleted_residue_specs[ispec];
+	 delete_any_link_containing_residue(spec);
+      }
+      atom_sel.atom_selection = NULL;
+      atom_sel.mol->FinishStructEdit();
+      atom_sel = make_asc(atom_sel.mol);
+      have_unsaved_changes_flag = 1;
+      make_bonds_type_checked(); // calls update_ghosts()
+      trim_atom_label_table();
+      update_symmetry();
+   }
+
    return 0;
 }
 
@@ -1705,6 +1757,7 @@
       
       if (atoms_to_be_deleted.size() > 0) {
 
+	 make_backup();
 	 for (unsigned int iat=0; iat<atoms_to_be_deleted.size(); iat++) {
 	    delete atoms_to_be_deleted[iat];
 	    atoms_to_be_deleted[iat] = NULL;
@@ -2107,7 +2160,7 @@
 
 	       if (p.first) { 
 		  try {
-		  
+
 		     make_backup();
 		     mmdb::Residue *prev_res = coot::util::previous_residue(res);
 		     mmdb::Residue *next_res = coot::util::next_residue(res);
@@ -4015,25 +4068,28 @@
    if (has_model()) {
       if (draw_it) { 
 	 int restore_bonds = 0;
-	 graphics_info_t g; // bleugh
 	 if (g.raster3d_water_sphere_flag && bonds_box_type == coot::NORMAL_BONDS) {
 	    // remove waters
 	    bonds_no_waters_representation();
 	    restore_bonds = 1;
 	 }
+	 rtmi.bond_lines.resize(bonds_box.num_colours);
 	 for (int i=0; i<bonds_box.num_colours; i++) {
 	    set_bond_colour_by_mol_no(i, against_a_dark_background); //sets bond_colour_internal
+	    double thickness = g.raster3d_bond_thickness;
+	    if (bonds_box.bonds_[i].thin_lines_flag) thickness *= 0.5;
 	    for (int j=0; j<bonds_box.bonds_[i].num_lines; j++) {
-	       std::pair<coot::Cartesian, coot::Cartesian> p(bonds_box.bonds_[i].pair_list[j].positions.getStart(),
-							     bonds_box.bonds_[i].pair_list[j].positions.getFinish());
-	       rtmi.bond_lines.push_back(p);
-	       coot::colour_t c;
-	       c.col.resize(3);
-	       c.col[0] = bond_colour_internal[0];
-	       c.col[1] = bond_colour_internal[1];
-	       c.col[2] = bond_colour_internal[2];
-	       rtmi.bond_colour.push_back(c);
+	       coot::ray_trace_molecule_info::bond_t b(bonds_box.bonds_[i].pair_list[j].positions.getStart(),
+						       bonds_box.bonds_[i].pair_list[j].positions.getFinish(),
+						       thickness);
+	       rtmi.bond_lines[i].bonds.push_back(b);
 	    }
+	    coot::colour_t c;
+	    c.col.resize(3);
+	    c.col[0] = bond_colour_internal[0];
+	    c.col[1] = bond_colour_internal[1];
+	    c.col[2] = bond_colour_internal[2];
+	    rtmi.bond_lines[i].colour = c;
 	 }
 	 // restore bond_box_type
 	 if (restore_bonds) {
@@ -4052,8 +4108,18 @@
 	    c.col[0] = bond_colour_internal[0];
 	    c.col[1] = bond_colour_internal[1];
 	    c.col[2] = bond_colour_internal[2];
+	    // std::cout << " bonds_box for atoms " << i << " col " << c << std::endl;
 	    // here is the place to add tiny rastered hydrogen balls.
-	    rtmi.atom.push_back(std::pair<coot::Cartesian, coot::colour_t> (bonds_box.atom_centres_[i].second, c));
+	    // rtmi.atom.push_back(std::pair<coot::Cartesian, coot::colour_t>
+	    // (bonds_box.atom_centres_[i].second, c));
+	    double r = g.raster3d_atom_radius;
+	    std::cout << "comparing colours " << bonds_box.atom_centres_colour_[i] << " vs "
+		      << HYDROGEN_GREY_BOND << std::endl;
+	    if (bonds_box.atom_centres_colour_[i] == HYDROGEN_GREY_BOND)
+	       r *= 0.5;
+
+	    coot::ray_trace_molecule_info::ball_t b(bonds_box.atom_centres_[i].second, c, r);
+	    rtmi.balls.push_back(b);
 	 }
 	 rtmi.molecule_name = name_;
 	 rtmi.molecule_number = imol_no;
@@ -4188,8 +4254,8 @@
 	    for (unsigned int istep=0; istep<n_steps; istep++) {
 	       double angle_1 = step_frac * 2.0 * M_PI * istep;
 	       double angle_2 = step_frac * 2.0 * M_PI * (istep + 1);
-	       pt_1 = coot::util::rotate_round_vector(ppr.normal, first_pt, ppr.ring_centre, angle_1);
-	       pt_2 = coot::util::rotate_round_vector(ppr.normal, first_pt, ppr.ring_centre, angle_2);
+	       pt_1 = coot::util::rotate_around_vector(ppr.normal, first_pt, ppr.ring_centre, angle_1);
+	       pt_2 = coot::util::rotate_around_vector(ppr.normal, first_pt, ppr.ring_centre, angle_2);
 	       coot::Cartesian p1(pt_1);
 	       coot::Cartesian p2(pt_2);
 	       rti.add_extra_representation_line(p1, p2, c, thickness);
@@ -4200,8 +4266,8 @@
 	    for (unsigned int istep=0; istep<n_steps; istep++) {
 	       double angle_1 = step_frac * 2.0 * M_PI * istep;
 	       double angle_2 = step_frac * 2.0 * M_PI * (istep + 1);
-	       pt_1 = coot::util::rotate_round_vector(ppr.normal, first_pt_pp, ppr.plane_projection_point, angle_1);
-	       pt_2 = coot::util::rotate_round_vector(ppr.normal, first_pt_pp, ppr.plane_projection_point, angle_2);
+	       pt_1 = coot::util::rotate_around_vector(ppr.normal, first_pt_pp, ppr.plane_projection_point, angle_1);
+	       pt_2 = coot::util::rotate_around_vector(ppr.normal, first_pt_pp, ppr.plane_projection_point, angle_2);
 	       coot::Cartesian p1(pt_1);
 	       coot::Cartesian p2(pt_2);
 	       rti.add_extra_representation_line(p1, p2, c, thickness);
@@ -6331,10 +6397,10 @@
    //    std::cout << "draw_display_list_objects() add_reps.size() " << add_reps.size() << std::endl;
 
    GLfloat  ambientLight[] = { 0.1f, 0.1f, 0.1f, 0.f };
-   GLfloat  diffuseLight[] = { 0.5f, 0.5f, 0.5f, 0.f };
-   GLfloat specularLight[] = { 0.5f, 0.5f, 0.5f, 0.f };
+   GLfloat  diffuseLight[] = { 0.4f, 0.4f, 0.4f, 0.f };
+   GLfloat specularLight[] = { 0.4f, 0.4f, 0.4f, 0.f };
 
-   // Assign created components to GL_LIGHT2
+   // Assign created components to GL_LIGHT1
    glLightfv(GL_LIGHT1, GL_AMBIENT,  ambientLight);
    glLightfv(GL_LIGHT1, GL_DIFFUSE,  diffuseLight);
    glLightfv(GL_LIGHT1, GL_SPECULAR, specularLight);
@@ -6343,12 +6409,15 @@
    if (draw_it) { 
       if (display_list_tags.size() > 0) { 
 	 glEnable(GL_LIGHTING);
-	 glEnable(GL_LIGHT0);
-	 glEnable(GL_LIGHT1);
-	 glEnable(GL_LIGHT2);
+
+	 glEnable(GL_LIGHT0); // bright.
+	 glEnable(GL_LIGHT1); // dim, off axis
+	 glEnable(GL_LIGHT2); // very dark
+
 	 // glDisable(GL_LIGHT0);
 	 // glDisable(GL_LIGHT1);
 	 // glDisable(GL_LIGHT2);
+
 	 std::vector<coot::display_list_object_info>::const_iterator it;
 	 for (it=display_list_tags.begin(); it!=display_list_tags.end(); it++) {
 	    if (! it->is_closed) { 
diff -ruN coot-0.8.7/src/molecule-class-info.cc coot-0.8.8-pre/src/molecule-class-info.cc
--- coot-0.8.7/src/molecule-class-info.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/src/molecule-class-info.cc	2017-01-23 10:30:04.000000000 -0800
@@ -1155,8 +1155,8 @@
 	       for (unsigned int istep=0; istep<n_steps; istep++) {
 		  double angle_1 = step_frac * 2.0 * M_PI * istep;
 		  double angle_2 = step_frac * 2.0 * M_PI * (istep + 1);
-		  pt_1 = coot::util::rotate_round_vector(r.normal, first_pt, r.ring_centre, angle_1);
-		  pt_2 = coot::util::rotate_round_vector(r.normal, first_pt, r.ring_centre, angle_2);
+		  pt_1 = coot::util::rotate_around_vector(r.normal, first_pt, r.ring_centre, angle_1);
+		  pt_2 = coot::util::rotate_around_vector(r.normal, first_pt, r.ring_centre, angle_2);
 		  glVertex3f(pt_1.x(), pt_1.y(), pt_1.z());
 		  glVertex3f(pt_2.x(), pt_2.y(), pt_2.z());
 	       }
@@ -1166,8 +1166,8 @@
 	       for (unsigned int istep=0; istep<n_steps; istep++) {
 		  double angle_1 = step_frac * 2.0 * M_PI * istep;
 		  double angle_2 = step_frac * 2.0 * M_PI * (istep + 1);
-		  pt_1 = coot::util::rotate_round_vector(r.normal, first_pt_pp, r.plane_projection_point, angle_1);
-		  pt_2 = coot::util::rotate_round_vector(r.normal, first_pt_pp, r.plane_projection_point, angle_2);
+		  pt_1 = coot::util::rotate_around_vector(r.normal, first_pt_pp, r.plane_projection_point, angle_1);
+		  pt_2 = coot::util::rotate_around_vector(r.normal, first_pt_pp, r.plane_projection_point, angle_2);
 		  glVertex3f(pt_1.x(), pt_1.y(), pt_1.z());
 		  glVertex3f(pt_2.x(), pt_2.y(), pt_2.z());
 	       }
@@ -3124,6 +3124,10 @@
 void
 molecule_class_info_t::makebonds(float min_dist, float max_dist, const coot::protein_geometry *geom_p) {
 
+   // std::cout << "------------ this makebonds() " << max_dist << " " << max_dist << std::endl;
+   //
+   // debug_atom_selection_container(atom_sel);
+
    Bond_lines_container bonds(atom_sel, min_dist, max_dist);
    bonds_box.clear_up();
    bonds_box = bonds.make_graphical_bonds();
@@ -7524,10 +7528,12 @@
 
    if (has_model()) {
       mmdb::Model *model_p = atom_sel.mol->GetModel(1);
-      int n_chains = atom_sel.mol->GetNumberOfChains(1);
-      if (n_chains > 0) {
-	 mmdb::Chain *chain_p = model_p->GetChain(0);
-	 add_multiple_dummies(chain_p, pos_position);
+      if (model_p) {
+	 int n_chains = atom_sel.mol->GetNumberOfChains(1);
+	 if (n_chains > 0) {
+	    mmdb::Chain *chain_p = model_p->GetChain(0);
+	    add_multiple_dummies(chain_p, pos_position);
+	 }
       }
    }
 }
@@ -7565,23 +7571,23 @@
       res_p->seqNum = i + 1;
       res_p->SetResName("DUM");
 
-      // std::cout << atom_p << " added to molecule" << std::endl;
+      std::cout << atom_p << " added to molecule" << std::endl;
    }
 
-   // std::cout << "DEBUG:: add_multiple_dummies finishing.. "
-   // << pos_position.size() << std::endl;
-   // if (pos_position.size() > 0) {
+
+   std::cout << "DEBUG:: add_multiple_dummies finishing.. "
+	     << pos_position.size() << std::endl;
    
    // Actually, we want to run this code when there are no new guide
    // points too.  This sets atom_sel.SelectionHandle properly, which
    // is needed in close_yourself, where a DeleteSelection() is done
    // to give back the memory.
-      atom_sel.mol->PDBCleanup(mmdb::PDBCLEAN_SERIAL|mmdb::PDBCLEAN_INDEX);
-      atom_sel.mol->FinishStructEdit();
-      atom_sel = make_asc(atom_sel.mol);
-      have_unsaved_changes_flag = 1; 
-      makebonds(0.0, 0.0, geom_p);
-      // }
+   
+   atom_sel.mol->PDBCleanup(mmdb::PDBCLEAN_SERIAL|mmdb::PDBCLEAN_INDEX);
+   atom_sel.mol->FinishStructEdit();
+   atom_sel = make_asc(atom_sel.mol);
+   have_unsaved_changes_flag = 1; 
+   makebonds(0.0, 0.0, geom_p);
 } 
 
 void
diff -ruN coot-0.8.7/src/molecule-class-info.h coot-0.8.8-pre/src/molecule-class-info.h
--- coot-0.8.7/src/molecule-class-info.h	2016-10-23 20:10:15.000000000 -0700
+++ coot-0.8.8-pre/src/molecule-class-info.h	2016-12-21 05:34:30.000000000 -0800
@@ -3060,7 +3060,10 @@
    void set_user_defined_colour_indices_by_residues(const std::vector<std::pair<coot::residue_spec_t, int> > &cis);
    void set_user_defined_colour_indices(const std::vector<std::pair<coot::atom_spec_t, int> > &cis);
    void clear_user_defined_atom_colours();
-   
+
+   void switch_HIS_protonation(coot::residue_spec_t res_spec);
+   void reduce(coot::protein_geometry *geom_p);
+
 };
 
 #endif // MOLECULE_CLASS_INFO_T
diff -ruN coot-0.8.7/src/sdf-interface.cc coot-0.8.8-pre/src/sdf-interface.cc
--- coot-0.8.7/src/sdf-interface.cc	2016-10-10 08:56:19.000000000 -0700
+++ coot-0.8.8-pre/src/sdf-interface.cc	2016-12-21 05:34:30.000000000 -0800
@@ -41,6 +41,7 @@
 #include <istream> // for istream?
 
 #include "graphics-info.h"
+#include "c-interface-generic-objects.h"
 #include "sdf-interface.hh"
 
 #ifdef MAKE_ENHANCED_LIGAND_TOOLS
diff -ruN coot-0.8.7/src/testing.cc coot-0.8.8-pre/src/testing.cc
--- coot-0.8.7/src/testing.cc	2016-11-08 01:46:24.000000000 -0800
+++ coot-0.8.8-pre/src/testing.cc	2017-01-23 10:30:04.000000000 -0800
@@ -197,7 +197,7 @@
 				  "test peak search non-close"));
 
    functions.push_back(named_func(test_symop_card, "test symop card"));
-   functions.push_back(named_func(test_rotate_round_vector, "test rotate round vector"));
+   functions.push_back(named_func(test_rotate_around_vector, "test rotate round vector"));
    functions.push_back(named_func(test_ssm_sequence_formatting, "SSM sequence alignment output"));
    status = run_internal_tests(functions);
    return status;
@@ -310,9 +310,9 @@
       // status = test_map_tools();
       // status = test_minimol();
       // status = test_monomer_organic_set();
-      // status = test_COO_mod();
+      status = test_COO_mod();
       // status = test_output_link_distances_are_correct();
-      status = test_string_splitting();
+      // status = test_string_splitting();
    }
    catch (const std::runtime_error &mess) {
       std::cout << "FAIL: " << " " << mess.what() << std::endl;
@@ -1992,7 +1992,7 @@
 
 
 int 
-test_rotate_round_vector() {
+test_rotate_around_vector() {
 
    int r = 0;
    
@@ -2107,7 +2107,7 @@
 		  std::cout << "   D_pt " << D_pt.format() << std::endl;
 		  // Make sure that D_pt does not move when rotated:
 		  for (double a=0; a<7.0; a+=1.0) {
-		     clipper::Coord_orth D_pt_r =  coot::util::rotate_round_vector(ab, D_pt, rotate_pt_2, a);
+		     clipper::Coord_orth D_pt_r =  coot::util::rotate_around_vector(ab, D_pt, rotate_pt_2, a);
 		     std::cout << "   " << a << " " << D_pt_r.format() << std::endl;
 		  }
 	       }
@@ -2115,7 +2115,7 @@
 	       double test_angle = 20.0; // degrees
 
 	       clipper::Coord_orth C_prime_pt =
-		  coot::util::rotate_round_vector(ab, C_pt, rotate_pt_2, (M_PI/180.0)*test_angle);
+		  coot::util::rotate_around_vector(ab, C_pt, rotate_pt_2, (M_PI/180.0)*test_angle);
 
 	       clipper::Coord_orth dc(C_pt-D_pt);
 	       clipper::Coord_orth dc_prime(C_prime_pt-D_pt);
@@ -2727,7 +2727,7 @@
       
       mmdb::PResidue *SelResidues = new mmdb::PResidue[1];
       SelResidues[0] = asc.atom_selection[0]->residue;
-      
+
       residue_selection_t result =
 	 testing_func_probabilities_refine_fragment(asc, SelResidues,
 						    1, "A", 93, t.geom, 0, 0, 0, 0);
@@ -2762,7 +2762,7 @@
       std::cout << "OXT->O distance: " << oxt_dist << std::endl;
    
       if (d < 0.02)
-	 if (oxt_dist > 2.0) 
+	 if (oxt_dist > 2.0)
 	    status = 1;
 
    }
diff -ruN coot-0.8.7/src/testing.hh coot-0.8.8-pre/src/testing.hh
--- coot-0.8.7/src/testing.hh	2015-12-26 16:40:08.000000000 -0800
+++ coot-0.8.8-pre/src/testing.hh	2017-01-23 10:30:04.000000000 -0800
@@ -68,7 +68,7 @@
 int test_coot_atom_tree();
 int test_coot_atom_tree_2();
 int test_coot_atom_tree_proline();
-int test_rotate_round_vector();
+int test_rotate_around_vector();
 int test_ssm_sequence_formatting();
 int test_OXT_in_restraints();
 int test_relativise_file_name();
diff -ruN coot-0.8.7/surface/Makefile.in coot-0.8.8-pre/surface/Makefile.in
--- coot-0.8.7/surface/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/surface/Makefile.in	2017-01-25 14:39:06.000000000 -0800
@@ -40,6 +40,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -216,6 +219,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/tw/Makefile.in coot-0.8.8-pre/tw/Makefile.in
--- coot-0.8.7/tw/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/tw/Makefile.in	2017-01-25 14:39:06.000000000 -0800
@@ -66,6 +66,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -224,6 +227,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
diff -ruN coot-0.8.7/utils/Makefile.am coot-0.8.8-pre/utils/Makefile.am
--- coot-0.8.7/utils/Makefile.am	2016-07-14 04:25:42.000000000 -0700
+++ coot-0.8.8-pre/utils/Makefile.am	2017-01-24 09:37:54.000000000 -0800
@@ -33,7 +33,7 @@
 
 # for simple things:
 libcoot_utils_la_SOURCES = coot-utils.cc coot-fasta.cc atomic-numbers.cc \
-	gdk-keysyms.cc hsv-rgb.cc dodec.cc win-compat.cc
+	gdk-keysyms.cc hsv-rgb.cc dodec.cc win-compat.cc threads.cc
 
 libcoot_utils_la_LIBADD = \
 	$(GLOB_LIBS)
diff -ruN coot-0.8.7/utils/Makefile.in coot-0.8.8-pre/utils/Makefile.in
--- coot-0.8.7/utils/Makefile.in	2016-11-08 07:55:23.000000000 -0800
+++ coot-0.8.8-pre/utils/Makefile.in	2017-01-25 14:39:06.000000000 -0800
@@ -61,6 +61,9 @@
 am__aclocal_m4_deps = $(top_srcdir)/macros/aclocal-include.m4 \
 	$(top_srcdir)/macros/ax_boost_base.m4 \
 	$(top_srcdir)/macros/ax_boost_python.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/macros/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/macros/ax_cxx_have_thread.m4 \
 	$(top_srcdir)/macros/ax_openmp.m4 \
 	$(top_srcdir)/macros/ax_python_devel.m4 \
 	$(top_srcdir)/macros/ccp4srs.m4 \
@@ -121,7 +124,7 @@
 libcoot_utils_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
 am_libcoot_utils_la_OBJECTS = coot-utils.lo coot-fasta.lo \
 	atomic-numbers.lo gdk-keysyms.lo hsv-rgb.lo dodec.lo \
-	win-compat.lo
+	win-compat.lo threads.lo
 libcoot_utils_la_OBJECTS = $(am_libcoot_utils_la_OBJECTS)
 libcoot_utils_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
@@ -222,6 +225,7 @@
 GUILE_LDFLAGS = @GUILE_LDFLAGS@
 GUILE_TOOLS = @GUILE_TOOLS@
 GUILE_VERSION = @GUILE_VERSION@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -362,7 +366,7 @@
 
 # for simple things:
 libcoot_utils_la_SOURCES = coot-utils.cc coot-fasta.cc atomic-numbers.cc \
-	gdk-keysyms.cc hsv-rgb.cc dodec.cc win-compat.cc
+	gdk-keysyms.cc hsv-rgb.cc dodec.cc win-compat.cc threads.cc
 
 libcoot_utils_la_LIBADD = \
 	$(GLOB_LIBS)
@@ -448,6 +452,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dodec.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdk-keysyms.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hsv-rgb.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/threads.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/win-compat.Plo@am__quote@
 
 .cc.o:
diff -ruN coot-0.8.7/utils/coot-utils.hh coot-0.8.8-pre/utils/coot-utils.hh
--- coot-0.8.7/utils/coot-utils.hh	2016-05-10 04:47:50.000000000 -0700
+++ coot-0.8.8-pre/utils/coot-utils.hh	2017-01-24 09:37:54.000000000 -0800
@@ -38,6 +38,13 @@
    // Use this to find things in $prefix/share/RDKit
    std::string rdkit_package_data_dir();
 
+   // use env var COOT_N_THREADS (or fallback) to get the number of threads
+   unsigned int get_max_number_of_threads();
+   // sets this:
+   static unsigned int coot_n_threads;
+   // using this:
+   long get_number_of_threads_by_system_call();
+
    namespace sequence {
 
       class fasta {
diff -ruN coot-0.8.7/utils/threads.cc coot-0.8.8-pre/utils/threads.cc
--- coot-0.8.7/utils/threads.cc	1969-12-31 16:00:00.000000000 -0800
+++ coot-0.8.8-pre/utils/threads.cc	2017-01-24 09:37:54.000000000 -0800
@@ -0,0 +1,58 @@
+
+#include <stdexcept>
+#include <iostream>
+#include "coot-utils.hh"
+
+#ifdef  _WIN32
+#include <windows.h>
+#else
+#include <unistd.h>
+#endif
+
+// can return -1 if name is invalid
+//
+long coot::get_number_of_threads_by_system_call()  {
+
+#ifdef _WIN32
+SYSTEM_INFO sysinfo;
+  GetSystemInfo(&sysinfo);
+  return sysinfo.dwNumberOfProcessors;
+#else
+  return sysconf(_SC_NPROCESSORS_CONF);
+#endif
+
+}
+
+// unsigned int coot::coot_n_threads = 0;
+
+unsigned int coot::get_max_number_of_threads() {
+
+   unsigned int n_threads_default = 4;
+
+   // only do this once:
+   // (if coot_n_threads is unset, then set it)
+   //
+   // is this initially set to 0 by the compiler?
+   //
+   if (coot_n_threads == 0) {
+      const char *e = getenv("COOT_N_THREADS");
+      if (e) {
+	 try {
+	    // can throw an runtime_error exception on unable to convert
+	    unsigned int t = util::string_to_int(e);
+	    if (t > 1024) t = n_threads_default;
+	    coot_n_threads = t;
+	 }
+	 catch (const std::runtime_error &e) {
+	    coot_n_threads = 1;
+	 }
+      } else {
+	 // no environment variable, use system call.
+	 coot_n_threads = n_threads_default;
+	 long n = get_number_of_threads_by_system_call();
+	 if (n > 0)
+	    coot_n_threads = n;
+      }
+   }
+   return coot_n_threads;
+}
