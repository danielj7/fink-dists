diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/config.tests/unix/compile.test qt-everywhere-opensource-src-4.8.5/config.tests/unix/compile.test
--- qt-everywhere-opensource-src-4.8.5-orig/config.tests/unix/compile.test	2013-06-07 01:16:41.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/config.tests/unix/compile.test	2013-08-10 16:34:23.000000000 -0400
@@ -68,17 +68,17 @@
 
 cd "$OUTDIR/$TEST"
 
 test -r Makefile && $MAKE distclean >/dev/null 2>&1
 # Make sure output from possible previous tests is gone
 rm -f "$EXE" "${EXE}.exe"
 
 echo "QT_BUILD_TREE = $OUTDIR" > "$OUTDIR/$TEST/.qmake.cache"
-"$OUTDIR/bin/qmake" -spec "$QMKSPEC" "CONFIG+=$QMAKE_CONFIG" "CONFIG-=debug_and_release" "LIBS*=$LFLAGS" "LIBS+=$MAC_ARCH_LFLAGS" "INCLUDEPATH*=$INCLUDEPATH" "QMAKE_CXXFLAGS*=$CXXFLAGS" "QMAKE_CXXFLAGS+=$MAC_ARCH_CXXFLAGS" "$SRCDIR/$TEST/$EXE.pro" -o "$OUTDIR/$TEST/Makefile"
+"$OUTDIR/bin/qmake" -spec "$QMKSPEC" "CONFIG+=$QMAKE_CONFIG" "CONFIG-=debug_and_release app_bundle" "LIBS*=$LFLAGS" "LIBS+=$MAC_ARCH_LFLAGS" "INCLUDEPATH*=$INCLUDEPATH" "QMAKE_CFLAGS*=$CXXFLAGS" "QMAKE_CFLAGS+=$MAC_ARCH_CXXFLAGS" "QMAKE_OBJECTIVE_CFLAGS*=$CXXFLAGS" "QMAKE_OBJECTIVE_CFLAGS+=$MAC_ARCH_CXXFLAGS" "QMAKE_CXXFLAGS*=$CXXFLAGS" "QMAKE_CXXFLAGS+=$MAC_ARCH_CXXFLAGS" "$SRCDIR/$TEST/$EXE.pro" -o "$OUTDIR/$TEST/Makefile"
 
 if [ "$VERBOSE" = "yes" ]; then
     $MAKE
 else
     $MAKE >/dev/null 2>&1
 fi
 
 ( [ -x "$EXE" ] || [ -x "${EXE}.exe" ] ) && SUCCESS=yes
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/config.tests/unix/gnu-libiconv/gnu-libiconv.cpp qt-everywhere-opensource-src-4.8.5/config.tests/unix/gnu-libiconv/gnu-libiconv.cpp
--- qt-everywhere-opensource-src-4.8.5-orig/config.tests/unix/gnu-libiconv/gnu-libiconv.cpp	2013-06-07 01:16:41.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/config.tests/unix/gnu-libiconv/gnu-libiconv.cpp	2013-08-10 16:34:23.000000000 -0400
@@ -43,17 +43,17 @@
 #error "iconv not supported on IRIX"
 #else
 #include <iconv.h>
 
 int main(int, char **)
 {
     iconv_t x = iconv_open("", "");
 
-    const char *inp;
+    char *inp;
     char *outp;
     size_t inbytes, outbytes;
     iconv(x, &inp, &inbytes, &outp, &outbytes);
 
     iconv_close(x);
 
     return 0;
 }
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/config.tests/unix/precomp.test qt-everywhere-opensource-src-4.8.5/config.tests/unix/precomp.test
--- qt-everywhere-opensource-src-4.8.5-orig/config.tests/unix/precomp.test	2013-06-07 01:16:41.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/config.tests/unix/precomp.test	2013-08-10 16:34:23.000000000 -0400
@@ -22,17 +22,17 @@
     $COMPILER -pch-create header.pchi -include header.h -c header.cpp -o header.o >/dev/null 2>&1 \
         && $COMPILER -pch-use header.pchi -include header.h -c source.cpp -o source.o >/dev/null 2>&1 \
         && PRECOMP_SUPPORT=yes
 
     rm -f header.h header.cpp source.cpp
     rm -f header.pchi header.o source.o
     ;;
 
-*g++*|c++|*qcc*)
+*g++*|c++|*qcc*|*gcc*|cc)
     case `"$COMPILER" -dumpversion 2>/dev/null` in
     3.*)
         ;;
     *)
 
         >precomp_header.h
         if $COMPILER -x c-header precomp_header.h >/dev/null 2>&1; then
            $COMPILER -x c++-header precomp_header.h && PRECOMP_SUPPORT=yes
diff -ruN -U8 qt-everywhere-opensource-src-4.8.6-orig/configure qt-everywhere-opensource-src-4.8.6/configure
--- qt-everywhere-opensource-src-4.8.6-orig/configure	2014-04-10 13:37:08.000000000 -0500
+++ qt-everywhere-opensource-src-4.8.6/configure	2014-05-13 15:25:44.000000000 -0500
@@ -5005,41 +5005,32 @@
         fi
         if [ "$BUILD_ON_MAC" = "yes" ]; then
             case "$PLATFORM" in
             *macx-clang-libc++)
                 # Avoid overriding the default configuration settings when building with clang/libc++
                 ;;
             *)
                 # For all other configurations require a minimum of 10.5
-                echo "export MACOSX_DEPLOYMENT_TARGET = 10.5" >> "$mkfile"
+                echo "export MACOSX_DEPLOYMENT_TARGET = @MACOSX_DEPLOYMENT_TARGET@" >> "$mkfile"
                 ;;
             esac
 
             echo "CARBON_LFLAGS =-framework ApplicationServices" >>"$mkfile"
             echo "CARBON_CFLAGS =-fconstant-cfstrings" >>"$mkfile"
             EXTRA_LFLAGS="$EXTRA_LFLAGS \$(CARBON_LFLAGS)"
             EXTRA_CFLAGS="$EXTRA_CFLAGS \$(CARBON_CFLAGS)"
             EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS \$(CARBON_CFLAGS)"
             EXTRA_OBJS="qsettings_mac.o qcore_mac.o"
             EXTRA_SRCS="\"$relpath/src/corelib/io/qsettings_mac.cpp\" \"$relpath/src/corelib/kernel/qcore_mac.cpp\""
-	    if echo "$CFG_MAC_ARCHS" | grep x86 > /dev/null 2>&1; then # matches both x86 and x86_64
-		X86_CFLAGS="-arch i386"
-		X86_LFLAGS="-arch i386"
-		EXTRA_CFLAGS="$X86_CFLAGS $EXTRA_CFLAGS"
-		EXTRA_CXXFLAGS="$X86_CFLAGS $EXTRA_CXXFLAGS"
-                EXTRA_LFLAGS="$EXTRA_LFLAGS $X86_LFLAGS"
-            fi
-	    if echo "$CFG_MAC_ARCHS" | grep ppc > /dev/null 2>&1; then # matches both ppc and ppc64
-		PPC_CFLAGS="-arch ppc"
-		PPC_LFLAGS="-arch ppc"
-		EXTRA_CFLAGS="$PPC_CFLAGS $EXTRA_CFLAGS"
-		EXTRA_CXXFLAGS="$PPC_CFLAGS $EXTRA_CXXFLAGS"
-                EXTRA_LFLAGS="$EXTRA_LFLAGS $PPC_LFLAGS"
-            fi
+	    ARCH_CFLAGS="-arch @FINK_ARCH@"
+	    ARCH_LFLAGS="-arch @FINK_ARCH@"
+	    EXTRA_CFLAGS="$ARCH_CFLAGS $EXTRA_CFLAGS"
+	    EXTRA_CXXFLAGS="$ARCH_CFLAGS $EXTRA_CXXFLAGS"
+	    EXTRA_LFLAGS="$EXTRA_LFLAGS $ARCH_LFLAGS"
 	    if [ '!' -z "$CFG_SDK" ]; then
 		echo "SDK_LFLAGS =-Wl,-syslibroot,$CFG_SDK" >>"$mkfile"
 		echo "SDK_CFLAGS =-isysroot $CFG_SDK" >>"$mkfile"
 		EXTRA_CFLAGS="$EXTRA_CFLAGS \$(SDK_CFLAGS)"
 		EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS \$(SDK_CFLAGS)"
 		EXTRA_LFLAGS="$EXTRA_LFLAGS \$(SDK_LFLAGS)"
             fi
         fi
@@ -5564,19 +5555,19 @@
                         fi
                     fi
                 fi
             fi
             ;;
         psql)
             if [ "$CFG_SQL_psql" != "no" ]; then
                 # Be careful not to use native pg_config when cross building.
-                if [ "$XPLATFORM_MINGW" != "yes" ] && "$WHICH" pg_config >/dev/null 2>&1; then
-                    QT_CFLAGS_PSQL=`pg_config --includedir 2>/dev/null`
-                    QT_LFLAGS_PSQL=`pg_config --libdir 2>/dev/null`
+                if [ "$XPLATFORM_MINGW" != "yes" ] && "$WHICH" @PATH_TO_PG_CONFIG@/pg_config >/dev/null 2>&1; then
+                    QT_CFLAGS_PSQL=`@PATH_TO_PG_CONFIG@/pg_config --includedir 2>/dev/null`
+                    QT_LFLAGS_PSQL=`@PATH_TO_PG_CONFIG@/pg_config --libdir 2>/dev/null`
                 fi
                 [ -z "$QT_CFLAGS_PSQL" ] || QT_CFLAGS_PSQL="-I$QT_CFLAGS_PSQL"
                 [ -z "$QT_LFLAGS_PSQL" ] || QT_LFLAGS_PSQL="-L$QT_LFLAGS_PSQL"
                 # But, respect PSQL_LIBS if set
                 [ -z "$PSQL_LIBS" ] || QT_LFLAGS_PSQL="$PSQL_LIBS"
                 if compileTest unix/psql "PostgreSQL" $QT_LFLAGS_PSQL $QT_CFLAGS_PSQL; then
                     if [ "$CFG_SQL_psql" = "auto" ]; then
                         CFG_SQL_psql=plugin
@@ -7220,21 +7211,21 @@
 # set the global Mac deployment target. This is overridden on an arch-by-arch basis
 # in some cases, see code further down
 case "$PLATFORM,$CFG_MAC_COCOA" in
 *macx-clang-libc++,yes)
     # Avoid overriding the default configuration setting when building with clang/libc++
     ;;
 macx*,yes)
     # Cocoa
-    QMakeVar set QMAKE_MACOSX_DEPLOYMENT_TARGET 10.5
+    QMakeVar set QMAKE_MACOSX_DEPLOYMENT_TARGET @MACOSX_DEPLOYMENT_TARGET@
     ;;
 macx*,no)
     # gcc, Carbon
-    QMakeVar set QMAKE_MACOSX_DEPLOYMENT_TARGET 10.4
+    QMakeVar set QMAKE_MACOSX_DEPLOYMENT_TARGET @MACOSX_DEPLOYMENT_TARGET@
     ;;
 esac
 
 # disable Qt 3 support on VxWorks, Symbian and INTEGRITY
 case "$XPLATFORM" in
     unsupported/vxworks*|symbian*|unsupported/integrity*)
 	CFG_QT3SUPPORT="no"
     ;;
@@ -7988,20 +7979,20 @@
         fi
         if echo "$CFG_MAC_ARCHS" | grep '\<ppc\>' > /dev/null 2>&1; then
             QMakeVar add QMAKE_CFLAGS "-Xarch_ppc -mmacosx-version-min=10.4"
             QMakeVar add QMAKE_CXXFLAGS "-Xarch_ppc -mmacosx-version-min=10.4"
             QMakeVar add QMAKE_LFLAGS "-Xarch_ppc -mmacosx-version-min=10.4"
             QMakeVar add QMAKE_OBJECTIVE_CFLAGS_PPC "-arch ppc -Xarch_ppc -mmacosx-version-min=10.4"
         fi
         if echo "$CFG_MAC_ARCHS" | grep '\<x86_64\>' > /dev/null 2>&1; then
-            QMakeVar add QMAKE_CFLAGS "-Xarch_x86_64 -mmacosx-version-min=10.5"
-            QMakeVar add QMAKE_CXXFLAGS "-Xarch_x86_64 -mmacosx-version-min=10.5"
-            QMakeVar add QMAKE_LFLAGS "-Xarch_x86_64 -mmacosx-version-min=10.5"
-            QMakeVar add QMAKE_OBJECTIVE_CFLAGS_X86_64 "-arch x86_64 -Xarch_x86_64 -mmacosx-version-min=10.5"
+            QMakeVar add QMAKE_CFLAGS "-Xarch_x86_64 -mmacosx-version-min=@MACOSX_DEPLOYMENT_TARGET@"
+            QMakeVar add QMAKE_CXXFLAGS "-Xarch_x86_64 -mmacosx-version-min=@MACOSX_DEPLOYMENT_TARGET@"
+            QMakeVar add QMAKE_LFLAGS "-Xarch_x86_64 -mmacosx-version-min=@MACOSX_DEPLOYMENT_TARGET@"
+            QMakeVar add QMAKE_OBJECTIVE_CFLAGS_X86_64 "-arch x86_64 -Xarch_x86_64 -mmacosx-version-min=@MACOSX_DEPLOYMENT_TARGET@"
         fi
         if echo "$CFG_MAC_ARCHS" | grep '\<ppc64\>' > /dev/null 2>&1; then
             QMakeVar add QMAKE_CFLAGS "-Xarch_ppc64 -mmacosx-version-min=10.5"
             QMakeVar add QMAKE_CXXFLAGS "-Xarch_ppc64 -mmacosx-version-min=10.5"
             QMakeVar add QMAKE_LFLAGS "-Xarch_ppc64 -mmacosx-version-min=10.5"
             QMakeVar add QMAKE_OBJECTIVE_CFLAGS_PPC_64 "-arch ppc64 -Xarch_ppc64 -mmacosx-version-min=10.5"
         fi
         ;;
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/mkspecs/common/g++-macx.conf qt-everywhere-opensource-src-4.8.5/mkspecs/common/g++-macx.conf
--- qt-everywhere-opensource-src-4.8.5-orig/mkspecs/common/g++-macx.conf	2013-06-07 01:17:00.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/mkspecs/common/g++-macx.conf	2013-08-10 16:34:23.000000000 -0400
@@ -10,19 +10,21 @@
 
 include(g++-base.conf)
 
 QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_DWARF2
 QMAKE_CXXFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_DWARF2
 QMAKE_LFLAGS_RELEASE_WITH_DEBUGINFO += -g $$QMAKE_CFLAGS_DWARF2
 
 QMAKE_LFLAGS_STATIC_LIB += -all_load
+QMAKE_LFLAGS_PLUGIN -= -dynamiclib
+QMAKE_LFLAGS_PLUGIN += -bundle
 
-QMAKE_CFLAGS_X86_64 += -Xarch_x86_64 -mmacosx-version-min=10.5
-QMAKE_CFLAGS_PPC_64 += -Xarch_ppc64 -mmacosx-version-min=10.5
+QMAKE_CFLAGS_X86_64 += -Xarch_x86_64 -mmacosx-version-min=@MACOSX_DEPLOYMENT_TARGET@
+QMAKE_CFLAGS_PPC_64 += -Xarch_ppc64 -mmacosx-version-min=@MACOSX_DEPLOYMENT_TARGET@
 
 QMAKE_CXXFLAGS_X86_64         = $$QMAKE_CFLAGS_X86_64
 QMAKE_CXXFLAGS_PPC_64         = $$QMAKE_CFLAGS_PPC_64
 QMAKE_OBJECTIVE_CFLAGS_X86_64 = $$QMAKE_CFLAGS_X86_64
 QMAKE_OBJECTIVE_CFLAGS_PPC_64 = $$QMAKE_CFLAGS_PPC_64
 QMAKE_LFLAGS_X86_64           = $$QMAKE_CFLAGS_X86_64
 QMAKE_LFLAGS_PPC_64           = $$QMAKE_CFLAGS_PPC_64
 
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/mkspecs/common/mac.conf qt-everywhere-opensource-src-4.8.5/mkspecs/common/mac.conf
--- qt-everywhere-opensource-src-4.8.5-orig/mkspecs/common/mac.conf	2013-06-07 01:17:00.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/mkspecs/common/mac.conf	2013-08-10 16:34:23.000000000 -0400
@@ -1,15 +1,16 @@
 #
 # qmake configuration for common Mac OS X
 #
 
 QMAKE_RESOURCE		= /Developer/Tools/Rez
 
 QMAKE_EXTENSION_SHLIB	= dylib
+QMAKE_EXTENSION_PLUGIN = so
 
 QMAKE_LIBDIR		=
 QMAKE_INCDIR_QT		= $$[QT_INSTALL_HEADERS]
 QMAKE_LIBDIR_QT		= $$[QT_INSTALL_LIBS]
 QMAKE_INCDIR_OPENGL	= /System/Library/Frameworks/OpenGL.framework/Headers \
 	/System/Library/Frameworks/AGL.framework/Headers/
 
 QMAKE_FIX_RPATH         = install_name_tool -id 
@@ -33,12 +35,16 @@
 QMAKE_COPY		= cp -f
 QMAKE_COPY_FILE		= $$QMAKE_COPY
 QMAKE_COPY_DIR		= $$QMAKE_COPY -R
 QMAKE_MOVE		= mv -f
 QMAKE_DEL_FILE		= rm -f
 QMAKE_DEL_DIR		= rmdir
 QMAKE_CHK_DIR_EXISTS	= test -d
 QMAKE_MKDIR		= mkdir -p
-QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.4 # overridden to 10.5 for Cocoa on the compiler command line
+QMAKE_MACOSX_DEPLOYMENT_TARGET = @MACOSX_DEPLOYMENT_TARGET@
 
+# allow CC and CXX to use CCACHE;
+# use "make CCACHE=ccache" when building
+QMAKE_CC = $(CCACHE) $$QMAKE_CC
+QMAKE_CXX = $(CCACHE) $$QMAKE_CXX
 
 include(unix.conf)
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/mkspecs/features/moc.prf qt-everywhere-opensource-src-4.8.5/mkspecs/features/moc.prf
--- qt-everywhere-opensource-src-4.8.5-orig/mkspecs/features/moc.prf	2013-06-07 01:17:00.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/mkspecs/features/moc.prf	2013-08-10 16:34:23.000000000 -0400
@@ -78,18 +78,23 @@
 }
 silent:moc_source.commands = @echo moc ${QMAKE_FILE_IN} && $$moc_source.commands
 QMAKE_EXTRA_COMPILERS += moc_source
 INCREDIBUILD_XGE += moc_source
 
 #make sure we can include these files
 moc_dir_short = $$MOC_DIR
 contains(QMAKE_HOST.os,Windows):moc_dir_short ~= s,^.:,/,
-contains(moc_dir_short, ^[/\\\\].*):INCLUDEPATH += $$MOC_DIR
-else:INCLUDEPATH += $$OUT_PWD/$$MOC_DIR
+
+# order the local moc path -before- the others, since its headers
+# should -always be found locally so we want that path first.
+contains(moc_dir_short, ^[/\\\\].*):INCLUDEPATH = $$MOC_DIR $$INCLUDEPATH
+else:INCLUDEPATH = $$OUT_PWD/$$MOC_DIR $$INCLUDEPATH
+
+# message(MOC_DIR is $$MOC_DIR)
 
 # Backwards compatibility: Make shadow builds with default MOC_DIR work
 # if the user did not add the source dir explicitly.
 equals(MOC_DIR, .) {
     CONFIG -= include_source_dir
     CONFIG = include_source_dir $$CONFIG
 }
 
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/mkspecs/features/qt.prf qt-everywhere-opensource-src-4.8.5/mkspecs/features/qt.prf
--- qt-everywhere-opensource-src-4.8.5-orig/mkspecs/features/qt.prf	2013-06-07 01:17:00.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/mkspecs/features/qt.prf	2013-08-10 16:34:23.000000000 -0400
@@ -140,17 +140,25 @@
 
             DEPLOYMENT *= qt_additional_plugin_$${QTPLUG}
         }
     }
 }
 #specific module settings
 !isEmpty(QT_BUILD_TREE):QMAKE_LIBDIR = $$QT_BUILD_TREE/lib $$QMAKE_LIBDIR #as above, prepending prevents us from picking up "stale" libs
 QMAKE_LIBDIR += $$QMAKE_LIBDIR_QT
+
 for(QTLIB, $$list($$lower($$unique(QT)))) {
+
+#   message(qt: 'LIBS' qt before $$QTLIB is '$${LIBS}')
+#   message(qt: 'INCLUDEPATH' qt before $$QTLIB is '$${INCLUDEPATH}')
+#   message(qt: 'QMAKE_LFLAGS' qt before $$QTLIB is '$${QMAKE_LFLAGS}')
+#   message(qt: 'QMAKE_CFLAGS' qt before $$QTLIB is '$${QMAKE_CFLAGS}')
+#   message(qt: 'QMAKE_CXXFLAGS' qt before $$QTLIB is '$${QMAKE_CXXFLAGS}')
+
    unset(qlib_style)
    !qt_debug:!qt_release {
       CONFIG(debug, debug|release):qlib_style = debug
       else:qlib_style = release
    } else:CONFIG(qt_debug, qt_debug|qt_release) {
       qlib_style = debug
    } else {
       qlib_style = release
@@ -201,18 +209,53 @@
 	 isEqual(QTLIB, openvg):CONFIG += openvg
 	 isEqual(QTLIB, qt3support):DEFINES *= QT3_SUPPORT
          isEqual(QTLIB, testlib):CONFIG += console
          isEqual(QTLIB, dbus):CONFIG += dbusadaptors dbusinterfaces
 
      qtAddLibrary($$qlib)
       }
    }
+#   message(qt: 'LIBS' qt after $$QTLIB is '$${LIBS}')
+#   message(qt: 'INCLUDEPATH' qt after $$QTLIB is '$${INCLUDEPATH}')
+#   message(qt: 'QMAKE_LFLAGS' qt after $$QTLIB is '$${QMAKE_LFLAGS}')
+#   message(qt: 'QMAKE_CFLAGS' qt after $$QTLIB is '$${QMAKE_CFLAGS}')
+#   message(qt: 'QMAKE_CXXFLAGS' qt after $$QTLIB is '$${QMAKE_CXXFLAGS}')
+}
+
+# remove Qt's libdir from various flags; it is already part of LIBS,
+# and should be used only to find Qt's libraries.  Qt puts LIBDIR
+# before all other paths, so it is critical that this variable not
+# contain anything questionable.
+QMAKE_LIBDIR -= $$QMAKE_LIBDIR_QT
+QMAKE_LFLAGS -= -L$$QMAKE_LIBDIR_QT
+!isEqual($$QMAKE_LIBDIR_QT, $$[QT_INSTALL_PREFIX]/lib) {
+  QMAKE_LFLAGS -= -L$$[QT_INSTALL_PREFIX]/lib
+}
+
+# remove Qt's incdir from various flags; it is already part of
+# INCLUDEPATH.  C*FLAGS come before the INCPATH build from
+# INCLUDEPATH, so they should never have this -I in it (or, reall, any
+# other -I but instead just remove the the obvious choices)
+QMAKE_CFLAGS -= -I$$QMAKE_INCDIR_QT
+QMAKE_CXXFLAGS -= -I$$QMAKE_INCDIR_QT
+QMAKE_OBJECTIVE_CFLAGS -= -I$$QMAKE_INCDIR_QT
+QMAKE_OBJECTIVE_CXXFLAGS -= -I$$QMAKE_INCDIR_QT
+!isEqual($$QMAKE_INCDIR_QT, $$[QT_INSTALL_PREFIX]/include) {
+  QMAKE_CFLAGS -= -I$$[QT_INSTALL_PREFIX]/include
+  QMAKE_CXXFLAGS -= -I$$[QT_INSTALL_PREFIX]/include
+  QMAKE_OBJECTIVE_CFLAGS -= -I$$[QT_INSTALL_PREFIX]/include
+  QMAKE_OBJECTIVE_CXXFLAGS -= -I$$[QT_INSTALL_PREFIX]/include
 }
 
+#message(qt: QMAKE_CFLAGS at end is $${QMAKE_CFLAGS})
+#message(qt: QMAKE_CXXFLAGS at end is $${QMAKE_CXXFLAGS})
+#message(qt: QMAKE_OBJECTIVE_CFLAGS at end is $${QMAKE_OBJECTIVE_CFLAGS})
+#message(qt: QMAKE_OBJECTIVE_CXXFLAGS at end is $${QMAKE_OBJECTIVE_CXXFLAGS})
+
 qt_compat {
    !qt_compat_no_warning:QTDIR_build:warning(***USE of COMPAT inside of QTDIR!**) #just for us
    INCLUDEPATH *= $$QMAKE_INCDIR_QT/Qt
    DEFINES *= QT_COMPAT
 }
 
 wince*:static:gui {
    QTLIB += qmenu_wce.res
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/mkspecs/macx-g++/qmake.conf qt-everywhere-opensource-src-4.8.5/mkspecs/macx-g++/qmake.conf
--- qt-everywhere-opensource-src-4.8.5-orig/mkspecs/macx-g++/qmake.conf	2013-06-07 01:17:00.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/mkspecs/macx-g++/qmake.conf	2013-08-10 16:34:23.000000000 -0400
@@ -4,16 +4,16 @@
 # qmake configuration for macx-g++
 #
 # Mac OS X + command-line compiler
 #
 
 MAKEFILE_GENERATOR	= UNIX
 TARGET_PLATFORM		= macx
 TEMPLATE		= app
-CONFIG			+= qt warn_on release app_bundle incremental global_init_link_order lib_version_first plugin_no_soname link_prl
+CONFIG			+= qt warn_on release app_bundle incremental global_init_link_order lib_version_first plugin_no_soname link_prl absolute_library_soname
 QT			+= core gui
 QMAKE_INCREMENTAL_STYLE = sublib
 
 include(../common/mac.conf)
 include(../common/gcc-base-macx.conf)
 include(../common/g++-macx.conf)
 load(qt_config)
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/qmake/project.cpp qt-everywhere-opensource-src-4.8.5/qmake/project.cpp
--- qt-everywhere-opensource-src-4.8.5-orig/qmake/project.cpp	2013-06-07 01:17:01.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/qmake/project.cpp	2013-08-10 16:34:23.000000000 -0400
@@ -591,39 +591,44 @@
             if(QFile::exists(specdir.path() + QDir::separator() + "features")) {
                 for(QStringList::Iterator concat_it = concat.begin();
                     concat_it != concat.end(); ++concat_it)
                     feature_roots << (specdir.path() + (*concat_it));
                 break;
             }
         }
     }
-    for(QStringList::Iterator concat_it = concat.begin();
-        concat_it != concat.end(); ++concat_it)
+    QByteArray qmake_no_defaults = qgetenv("QMAKE_NO_DEFAULTS");
+    if (qmake_no_defaults.isNull()) {
+      for(QStringList::Iterator concat_it = concat.begin();
+	  concat_it != concat.end(); ++concat_it)
         feature_roots << (QLibraryInfo::location(QLibraryInfo::PrefixPath) +
                           mkspecs_concat + (*concat_it));
-    for(QStringList::Iterator concat_it = concat.begin();
-        concat_it != concat.end(); ++concat_it)
+      for(QStringList::Iterator concat_it = concat.begin();
+	  concat_it != concat.end(); ++concat_it)
         feature_roots << (QLibraryInfo::location(QLibraryInfo::DataPath) +
                           mkspecs_concat + (*concat_it));
+    }
     return feature_roots;
 }
 
 QStringList qmake_mkspec_paths()
 {
     QStringList ret;
     const QString concat = QDir::separator() + QString("mkspecs");
     QByteArray qmakepath = qgetenv("QMAKEPATH");
     if (!qmakepath.isEmpty()) {
         const QStringList lst = splitPathList(QString::fromLocal8Bit(qmakepath));
         for(QStringList::ConstIterator it = lst.begin(); it != lst.end(); ++it)
             ret << ((*it) + concat);
     }
-    ret << QLibraryInfo::location(QLibraryInfo::DataPath) + concat;
-
+    QByteArray qmake_no_defaults = qgetenv("QMAKE_NO_DEFAULTS");
+    if (qmake_no_defaults.isNull()) {
+      ret << QLibraryInfo::location(QLibraryInfo::DataPath) + concat;
+    }
     return ret;
 }
 
 QMakeProject::~QMakeProject()
 {
     if(own_prop)
         delete prop;
     for(QMap<QString, FunctionBlock*>::iterator it = replaceFunctions.begin(); it != replaceFunctions.end(); ++it) {
diff -ruN -U8 qt-everywhere-opensource-src-4.8.6-orig/qmake/qmake.pri qt-everywhere-opensource-src-4.8.6/qmake/qmake.pri
--- qt-everywhere-opensource-src-4.8.6-orig/qmake/qmake.pri	2014-04-10 13:37:13.000000000 -0500
+++ qt-everywhere-opensource-src-4.8.6/qmake/qmake.pri	2014-05-13 15:28:00.000000000 -0500
@@ -130,17 +130,17 @@
         qvector.h \
         qxmlstream.h \
         qxmlutils.h
 
     unix {
         SOURCES += qfilesystemengine_unix.cpp qfilesystemiterator_unix.cpp qfsfileengine_unix.cpp
         mac {
           SOURCES += qcore_mac.cpp qsettings_mac.cpp
-          QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.4 #enables weak linking for 10.4 (exported)
+          QMAKE_MACOSX_DEPLOYMENT_TARGET = @MACOSX_DEPLOYMENT_TARGET@
           LIBS += -framework ApplicationServices
         }
     } else:win32 {
         SOURCES += qfilesystemengine_win.cpp qfsfileengine_win.cpp qfilesystemiterator_win.cpp qsettings_win.cpp \
             qsystemlibrary.cpp
         win32-msvc*:LIBS += ole32.lib advapi32.lib
         win32-g++*:LIBS += -lole32 -luuid -ladvapi32 -lkernel32
     }
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/src/corelib/tools/qelapsedtimer_mac.cpp qt-everywhere-opensource-src-4.8.5/src/corelib/tools/qelapsedtimer_mac.cpp
--- qt-everywhere-opensource-src-4.8.5-orig/src/corelib/tools/qelapsedtimer_mac.cpp	2013-06-07 01:16:52.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/src/corelib/tools/qelapsedtimer_mac.cpp	2013-08-10 16:34:23.000000000 -0400
@@ -57,17 +57,17 @@
     return true;
 }
 
 static mach_timebase_info_data_t info = {0,0};
 static qint64 absoluteToNSecs(qint64 cpuTime)
 {
     if (info.denom == 0)
         mach_timebase_info(&info);
-    qint64 nsecs = cpuTime * info.numer / info.denom;
+    qint64 nsecs = (qint64)(((double) cpuTime) * ((double) info.numer) / ((double) info.denom));
     return nsecs;
 }
 
 static qint64 absoluteToMSecs(qint64 cpuTime)
 {
     return absoluteToNSecs(cpuTime) / 1000000;
 }
 
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/src/gui/dialogs/qfontdialog_mac.mm qt-everywhere-opensource-src-4.8.5/src/gui/dialogs/qfontdialog_mac.mm
--- qt-everywhere-opensource-src-4.8.5-orig/src/gui/dialogs/qfontdialog_mac.mm	2013-06-07 01:16:59.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/src/gui/dialogs/qfontdialog_mac.mm	2013-08-10 16:38:10.000000000 -0400
@@ -506,17 +506,17 @@
 {
     QMacCocoaAutoReleasePool pool;
     QFontEngine *fe = font.d->engineForScript(QUnicodeTables::Common);
     NSFontManager *mgr = [NSFontManager sharedFontManager];
     const NSFont *nsFont = 0;
 
 #if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
     if (qstrcmp(fe->name(), "CoreText") == 0) {
-        nsFont = reinterpret_cast<const NSFont *>(static_cast<QCoreTextFontEngineMulti *>(fe)->ctfont);
+        nsFont = const_cast<NSFont *>(reinterpret_cast<const NSFont *>(static_cast<QCoreTextFontEngineMulti *>(fe)->ctfont));
     } else
 #endif
     {
         int weight = 5;
         NSFontTraitMask mask = 0;
         if (font.style() == QFont::StyleItalic) {
             mask |= NSItalicFontMask;
         }
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/src/gui/kernel/qcocoamenuloader_mac.mm qt-everywhere-opensource-src-4.8.5/src/gui/kernel/qcocoamenuloader_mac.mm
--- qt-everywhere-opensource-src-4.8.5-orig/src/gui/kernel/qcocoamenuloader_mac.mm	2013-06-07 01:16:59.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/src/gui/kernel/qcocoamenuloader_mac.mm	2013-08-10 16:38:10.000000000 -0400
@@ -65,17 +65,17 @@
 
 - (void)awakeFromNib
 {
     servicesItem = [[appMenu itemWithTitle:@"Services"] retain];
     hideAllOthersItem = [[appMenu itemWithTitle:@"Hide Others"] retain];
     showAllItem = [[appMenu itemWithTitle:@"Show All"] retain];
 
     // Get the names in the nib to match the app name set by Qt.
-    const NSString *appName = reinterpret_cast<const NSString*>(QCFString::toCFStringRef(qAppName()));
+    const NSString *appName = const_cast<NSString *>(reinterpret_cast<const NSString*>(QCFString::toCFStringRef(qAppName())));
     [quitItem setTitle:[[quitItem title] stringByReplacingOccurrencesOfString:@"NewApplication"
                                                                    withString:const_cast<NSString *>(appName)]];
     [hideItem setTitle:[[hideItem title] stringByReplacingOccurrencesOfString:@"NewApplication"
                                                                    withString:const_cast<NSString *>(appName)]];
     [aboutItem setTitle:[[aboutItem title] stringByReplacingOccurrencesOfString:@"NewApplication"
                                                                    withString:const_cast<NSString *>(appName)]];
     [appName release];
     // Disable the items that don't do anything. If someone associates a QAction with them
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/src/plugins/bearer/corewlan/corewlan.pro qt-everywhere-opensource-src-4.8.5/src/plugins/bearer/corewlan/corewlan.pro
--- qt-everywhere-opensource-src-4.8.5-orig/src/plugins/bearer/corewlan/corewlan.pro	2013-06-07 01:17:00.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/src/plugins/bearer/corewlan/corewlan.pro	2013-08-10 16:34:23.000000000 -0400
@@ -1,16 +1,16 @@
 TARGET = qcorewlanbearer
 include(../../qpluginbase.pri)
 
 QT = core network
 LIBS += -framework Foundation -framework SystemConfiguration
 
 contains(QT_CONFIG, corewlan) {
-    isEmpty(QMAKE_MAC_SDK)|contains(QMAKE_MAC_SDK, "/Developer/SDKs/MacOSX10\.[67]\.sdk") {
+    isEmpty(QMAKE_MAC_SDK)|contains(QMAKE_MAC_SDK, "@SDK_PATH@") {
          LIBS += -framework CoreWLAN -framework Security
     }
 }
 
 HEADERS += qcorewlanengine.h \
            ../qnetworksession_impl.h \
            ../qbearerengine_impl.h
 
diff -ruN -U8 qt-everywhere-opensource-src-4.8.6-orig/src/plugins/qpluginbase.pri qt-everywhere-opensource-src-4.8.6/src/plugins/qpluginbase.pri
--- qt-everywhere-opensource-src-4.8.6-orig/src/plugins/qpluginbase.pri	2013-06-07 01:17:00.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.6/src/plugins/qpluginbase.pri	2013-08-10 16:34:23.000000000 -0400
@@ -1,15 +1,18 @@
 TEMPLATE = lib
 isEmpty(QT_MAJOR_VERSION) {
    VERSION=4.8.6
 } else {
    VERSION=$${QT_MAJOR_VERSION}.$${QT_MINOR_VERSION}.$${QT_PATCH_VERSION}
 }
 CONFIG += qt plugin
+QMAKE_LFLAGS_PLUGIN -= -dynamiclib
+QMAKE_LFLAGS_PLUGIN += -bundle
+QMAKE_EXTENSION_PLUGIN = so
 
 win32|mac:!wince*:!win32-msvc:!macx-xcode:CONFIG += debug_and_release
 TARGET = $$qtLibraryTarget($$TARGET)
 contains(QT_CONFIG, reduce_exports):CONFIG += hide_symbols
 
 include(../qt_targets.pri)
 
 wince*:LIBS += $$QMAKE_LIBS_GUI
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/src/qbase.pri qt-everywhere-opensource-src-4.8.5/src/qbase.pri
--- qt-everywhere-opensource-src-4.8.5-orig/src/qbase.pri	2013-06-07 01:17:00.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/src/qbase.pri	2013-08-10 16:34:23.000000000 -0400
@@ -132,33 +132,33 @@
 
 !static:PRL_EXPORT_DEFINES += QT_SHARED
 
 #install directives
 include(qt_install.pri)
 
 unix|win32-g++*:!symbian {
    CONFIG += create_pc
-   QMAKE_PKGCONFIG_LIBDIR = $$[QT_INSTALL_LIBS]
+   QMAKE_PKGCONFIG_LIBDIR = $$target.path
    QMAKE_PKGCONFIG_INCDIR = $$[QT_INSTALL_HEADERS]/$$TARGET
    QMAKE_PKGCONFIG_CFLAGS = -I$$[QT_INSTALL_HEADERS]
    QMAKE_PKGCONFIG_DESTDIR = pkgconfig
    include_replace.match = $$QMAKE_INCDIR_QT
    include_replace.replace = $$[QT_INSTALL_HEADERS]
    lib_replace.match = $$QMAKE_LIBDIR_QT
-   lib_replace.replace = $$[QT_INSTALL_LIBS]
+   lib_replace.replace = $$target.path
    prefix_replace.match = $$QT_BUILD_TREE
    prefix_replace.replace = $$[QT_INSTALL_PREFIX]
    QMAKE_PKGCONFIG_INSTALL_REPLACE += include_replace lib_replace prefix_replace
 }
 
 unix:!symbian {
    CONFIG += create_libtool explicitlib
-   QMAKE_LIBTOOL_LIBDIR = $$[QT_INSTALL_LIBS]
-   QMAKE_PRL_LIBDIR = $$[QT_INSTALL_LIBS]
+   QMAKE_LIBTOOL_LIBDIR = $$target.path
+   QMAKE_PRL_LIBDIR = $$target.path
    QMAKE_PRL_INSTALL_REPLACE += include_replace lib_replace
    QMAKE_LIBTOOL_INSTALL_REPLACE += include_replace lib_replace
 }
 
 contains(QT_PRODUCT, OpenSource.*):DEFINES *= QT_OPENSOURCE
 DEFINES *= QT_NO_CAST_TO_ASCII QT_ASCII_CAST_WARNINGS
 contains(QT_CONFIG, qt3support):DEFINES *= QT3_SUPPORT
 DEFINES *= QT_MOC_COMPAT #we don't need warnings from calling moc code in our generated code
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/src/tools/bootstrap/bootstrap.pro qt-everywhere-opensource-src-4.8.5/src/tools/bootstrap/bootstrap.pro
--- qt-everywhere-opensource-src-4.8.5-orig/src/tools/bootstrap/bootstrap.pro	2013-06-07 01:17:00.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/src/tools/bootstrap/bootstrap.pro	2013-08-10 16:34:23.000000000 -0400
@@ -98,17 +98,17 @@
                  ../../corelib/plugin/qsystemlibrary.cpp \
 
 mac: OBJECTIVE_SOURCES += ../../corelib/tools/qlocale_mac.mm
 else:symbian:SOURCES += ../../corelib/tools/qlocale_symbian.cpp
 else:unix:SOURCES += ../../corelib/tools/qlocale_unix.cpp
 else:win32:SOURCES += ../../corelib/tools/qlocale_win.cpp
 
 macx: {
-   QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.4 #enables weak linking for 10.4 (exported)
+   QMAKE_MACOSX_DEPLOYMENT_TARGET = @MACOSX_DEPLOYMENT_TARGET@
    SOURCES += ../../corelib/kernel/qcore_mac.cpp
    LIBS += -framework CoreServices
 }
 
 if(contains(QT_CONFIG, zlib)|cross_compile):include(../../3rdparty/zlib.pri)
 else:include(../../3rdparty/zlib_dependency.pri)
 
 lib.CONFIG = dummy_install
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/tools/assistant/lib/fulltextsearch/fulltextsearch.pro qt-everywhere-opensource-src-4.8.5/tools/assistant/lib/fulltextsearch/fulltextsearch.pro
--- qt-everywhere-opensource-src-4.8.5-orig/tools/assistant/lib/fulltextsearch/fulltextsearch.pro	2013-06-07 01:17:00.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/tools/assistant/lib/fulltextsearch/fulltextsearch.pro	2013-08-10 16:34:23.000000000 -0400
@@ -1,19 +1,19 @@
 
 QMAKE_TARGET_PRODUCT = QtCLucene
 QMAKE_TARGET_DESCRIPTION = QtCLucene full text search library wrapper.
 #if qt is built with frameworks in debug, we must build QtCLucene in debug and release 
 #that's a similar logic as in qbase.pri 
 mac:!static:contains(QT_CONFIG, qt_framework) { 
    CONFIG(debug, debug|release) { 
       !build_pass:CONFIG += build_all 
-   } 
+   }
 }
-QT_CONFIG -= qt_framework 
+# QT_CONFIG -= qt_framework 
 QT -= gui
 TEMPLATE = lib
 TARGET = QtCLucene
 DEFINES += QHELP_LIB
 include(../../../../src/qbase.pri)
 include(fulltextsearch.pri)
 
 CONFIG += qt warn_off
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/tools/assistant/lib/lib.pro qt-everywhere-opensource-src-4.8.5/tools/assistant/lib/lib.pro
--- qt-everywhere-opensource-src-4.8.5-orig/tools/assistant/lib/lib.pro	2013-06-07 01:17:00.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/tools/assistant/lib/lib.pro	2013-08-10 16:34:23.000000000 -0400
@@ -7,26 +7,25 @@
 CONFIG += qt \
     warn_on
 include(../../../src/qbase.pri)
 QMAKE_TARGET_PRODUCT = Help
 QMAKE_TARGET_DESCRIPTION = Help \
     application \
     framework.
 DEFINES -= QT_ASCII_CAST_WARNINGS
-qclucene = QtCLucene$${QT_LIBINFIX}
-if(!debug_and_release|build_pass):CONFIG(debug, debug|release) { 
-    mac:qclucene = $${qclucene}_debug
-    win32:qclucene = $${qclucene}d
-}
-linux-lsb-g++:LIBS_PRIVATE += --lsb-shared-libs=$$qclucene
+
+qtAddLibrary(QtCLucene)
+
 unix|win32-g++*:QMAKE_PKGCONFIG_REQUIRES += QtNetwork \
     QtSql \
-    QtXml
-LIBS_PRIVATE += -l$$qclucene
+    QtGui \
+    QtCore \
+    QtCLucene
+
 RESOURCES += helpsystem.qrc
 SOURCES += qhelpenginecore.cpp \
     qhelpengine.cpp \
     qhelpdbreader.cpp \
     qhelpcontentwidget.cpp \
     qhelpindexwidget.cpp \
     qhelpgenerator.cpp \
     qhelpdatainterface.cpp \
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/tools/designer/src/lib/lib.pro qt-everywhere-opensource-src-4.8.5/tools/designer/src/lib/lib.pro
--- qt-everywhere-opensource-src-4.8.5-orig/tools/designer/src/lib/lib.pro	2013-06-07 01:17:00.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/tools/designer/src/lib/lib.pro	2013-08-10 16:34:23.000000000 -0400
@@ -8,18 +8,16 @@
 !wince*:DLLDESTDIR = ../../../../bin
 
 isEmpty(QT_MAJOR_VERSION) {
    VERSION=4.3.0
 } else {
    VERSION=$${QT_MAJOR_VERSION}.$${QT_MINOR_VERSION}.$${QT_PATCH_VERSION}
 }
 
-unix|win32-g++*:QMAKE_PKGCONFIG_REQUIRES += QtXml
-
 include(../../../../src/qt_targets.pri)
 QMAKE_TARGET_PRODUCT = Designer
 QMAKE_TARGET_DESCRIPTION = Graphical user interface designer.
 
 !contains(CONFIG, static) {
     CONFIG += dll
 
     DEFINES += \
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/tools/designer/src/uitools/uitools.pro qt-everywhere-opensource-src-4.8.5/tools/designer/src/uitools/uitools.pro
--- qt-everywhere-opensource-src-4.8.5-orig/tools/designer/src/uitools/uitools.pro	2013-06-07 01:17:00.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/tools/designer/src/uitools/uitools.pro	2013-08-10 16:34:23.000000000 -0400
@@ -1,12 +1,12 @@
 TEMPLATE = lib
 TARGET = QtUiTools
 QT += xml
-CONFIG += qt staticlib
+CONFIG += qt qt_install_headers
 DESTDIR = ../../../../lib
 DLLDESTDIR = ../../../../bin
 
 symbian {
     TARGET.UID3 = 0x2001E628
     load(armcc_warnings)
 }
 
diff -ruN -U8 qt-everywhere-opensource-src-4.8.5-orig/tools/macdeployqt/macdeployqt/main.cpp qt-everywhere-opensource-src-4.8.5/tools/macdeployqt/macdeployqt/main.cpp
--- qt-everywhere-opensource-src-4.8.5-orig/tools/macdeployqt/macdeployqt/main.cpp	2013-06-07 01:17:01.000000000 -0400
+++ qt-everywhere-opensource-src-4.8.5/tools/macdeployqt/macdeployqt/main.cpp	2013-08-10 16:34:23.000000000 -0400
@@ -122,17 +122,17 @@
             return 0;
         }
      }
 
     DeploymentInfo deploymentInfo  = deployQtFrameworks(appBundlePath, additionalExecutables, useDebugLibs);
 
     if (plugins) {
         if (deploymentInfo.qtPath.isEmpty())
-            deploymentInfo.pluginPath = "/Developer/Applications/Qt/plugins"; // Assume binary package.
+            deploymentInfo.pluginPath = "@QT_PLUGINS_DIR@"; // Assume binary package.
         else
             deploymentInfo.pluginPath = deploymentInfo.qtPath + "/plugins";
 
         LogNormal();
         deployPlugins(appBundlePath, deploymentInfo, useDebugLibs);
         createQtConf(appBundlePath);
     }
 
From 8efb190a00419f49bb5687faf3b33fc04c544035 Mon Sep 17 00:00:00 2001
From: David Goodlad <david@goodlad.net>
Date: Wed, 10 Sep 2014 09:20:28 -0700
Subject: [PATCH] Patch qt4 for Yosemite

From upstream patch at https://codereview.qt-project.org/#/c/87515/

This patch changes references to `NSApp` to `[NSApplication sharedApplication]`, since `NSApp` is deprecated on Yosemite. I've excluded the part of the upstream patch against `tests/auto/qfontdialog/tst_qfontdialog_mac_helpers.mm`, since files in `tests/` are not included in release tarballs.
---
diff --git a/src/gui/dialogs/qcolordialog_mac.mm b/src/gui/dialogs/qcolordialog_mac.mm
index f65422f..df53f6f 100644
--- a/src/gui/dialogs/qcolordialog_mac.mm
+++ b/src/gui/dialogs/qcolordialog_mac.mm
@@ -318,7 +318,7 @@ QT_USE_NAMESPACE
         // It's important that the modal event loop is stopped before
         // we accept/reject QColorDialog, since QColorDialog has its
         // own event loop that needs to be stopped last. 
-        [NSApp stopModalWithCode:code];
+        [[NSApplication sharedApplication] stopModalWithCode:code];
     } else {
         // Since we are not in a modal event loop, we can safely close
         // down QColorDialog
@@ -350,7 +350,7 @@ QT_USE_NAMESPACE
     while (!modalEnded) {
 #ifndef QT_NO_EXCEPTIONS
         @try {
-            [NSApp runModalForWindow:mColorPanel];
+            [[NSApplication sharedApplication] runModalForWindow:mColorPanel];
             modalEnded = true;
         } @catch (NSException *) {
             // For some reason, NSColorPanel throws an exception when
@@ -358,7 +358,7 @@ QT_USE_NAMESPACE
             // palette (tab three).
         }
 #else
-        [NSApp runModalForWindow:mColorPanel];
+        [[NSApplication sharedApplication] runModalForWindow:mColorPanel];
         modalEnded = true;
 #endif
     }
@@ -469,10 +469,10 @@ void QColorDialogPrivate::mac_nativeDialogModalHelp()
     // Do a queued meta-call to open the native modal dialog so it opens after the new
     // event loop has started to execute (in QDialog::exec). Using a timer rather than
     // a queued meta call is intentional to ensure that the call is only delivered when
-    // [NSApp run] runs (timers are handeled special in cocoa). If NSApp is not
+    // [NSApplication run] runs (timers are handeled special in cocoa). If NSApplication is not
     // running (which is the case if e.g a top-most QEventLoop has been
     // interrupted, and the second-most event loop has not yet been reactivated (regardless
-    // if [NSApp run] is still on the stack)), showing a native modal dialog will fail.
+    // if [NSApplication run] is still on the stack)), showing a native modal dialog will fail.
     if (delegate){
         Q_Q(QColorDialog);
         QTimer::singleShot(1, q, SLOT(_q_macRunNativeAppModalPanel()));
diff --git a/src/gui/dialogs/qfiledialog_mac.mm b/src/gui/dialogs/qfiledialog_mac.mm
index cb9dc77..da15a61 100644
--- a/src/gui/dialogs/qfiledialog_mac.mm
+++ b/src/gui/dialogs/qfiledialog_mac.mm
@@ -229,7 +229,7 @@ QT_USE_NAMESPACE
     if ([mSavePanel respondsToSelector:@selector(close)])
         [mSavePanel close];
     if ([mSavePanel isSheet])
-        [NSApp endSheet: mSavePanel];
+        [[NSApplication sharedApplication] endSheet: mSavePanel];
 }
 
 - (void)showModelessPanel
@@ -1162,10 +1162,10 @@ void QFileDialogPrivate::mac_nativeDialogModalHelp()
     // Do a queued meta-call to open the native modal dialog so it opens after the new
     // event loop has started to execute (in QDialog::exec). Using a timer rather than
     // a queued meta call is intentional to ensure that the call is only delivered when
-    // [NSApp run] runs (timers are handeled special in cocoa). If NSApp is not
+    // [NSApplication run] runs (timers are handeled special in cocoa). If NSApplication is not
     // running (which is the case if e.g a top-most QEventLoop has been
     // interrupted, and the second-most event loop has not yet been reactivated (regardless
-    // if [NSApp run] is still on the stack)), showing a native modal dialog will fail.
+    // if [NSApplication run] is still on the stack)), showing a native modal dialog will fail.
     if (nativeDialogInUse){
         Q_Q(QFileDialog);
         QTimer::singleShot(1, q, SLOT(_q_macRunNativeAppModalPanel()));
diff --git a/src/gui/dialogs/qfontdialog_mac.mm b/src/gui/dialogs/qfontdialog_mac.mm
index f5484f0..75c37d2 100644
--- a/src/gui/dialogs/qfontdialog_mac.mm
+++ b/src/gui/dialogs/qfontdialog_mac.mm
@@ -230,7 +230,7 @@ static QFont qfontForCocoaFont(NSFont *cocoaFont, const QFont &resolveFont)
     mAppModal = true;
     NSWindow *ourPanel = [mStolenContentView window];
     [ourPanel setReleasedWhenClosed:NO];
-    [NSApp runModalForWindow:ourPanel];
+    [[NSApplication sharedApplication] runModalForWindow:ourPanel];
     QAbstractEventDispatcher::instance()->interrupt();
 
     if (mReturnCode == NSOKButton)
@@ -256,7 +256,7 @@ static QFont qfontForCocoaFont(NSFont *cocoaFont, const QFont &resolveFont)
 
     mAppModal = false;
     NSWindow *ourPanel = [mStolenContentView window];
-    [NSApp beginSheet:ourPanel
+    [[NSApplication sharedApplication] beginSheet:ourPanel
         modalForWindow:window
         modalDelegate:0
         didEndSelector:0
@@ -456,7 +456,7 @@ static QFont qfontForCocoaFont(NSFont *cocoaFont, const QFont &resolveFont)
 
     if (mAppModal) {
         mReturnCode = code;
-        [NSApp stopModalWithCode:code];
+        [[NSApplication sharedApplication] stopModalWithCode:code];
     } else {
         if (code == NSOKButton)
             mPriv->fontDialog()->accept();
@@ -636,10 +636,10 @@ void QFontDialogPrivate::mac_nativeDialogModalHelp()
     // Do a queued meta-call to open the native modal dialog so it opens after the new
     // event loop has started to execute (in QDialog::exec). Using a timer rather than
     // a queued meta call is intentional to ensure that the call is only delivered when
-    // [NSApp run] runs (timers are handeled special in cocoa). If NSApp is not
+    // [NSApplication run] runs (timers are handeled special in cocoa). If NSApplication is not
     // running (which is the case if e.g a top-most QEventLoop has been
     // interrupted, and the second-most event loop has not yet been reactivated (regardless
-    // if [NSApp run] is still on the stack)), showing a native modal dialog will fail.
+    // if [NSApplication run] is still on the stack)), showing a native modal dialog will fail.
     if (nativeDialogInUse) {
         Q_Q(QFontDialog);
         QTimer::singleShot(1, q, SLOT(_q_macRunNativeAppModalPanel()));
diff --git a/src/gui/kernel/qapplication_mac.mm b/src/gui/kernel/qapplication_mac.mm
index 445189d..e4516da 100644
--- a/src/gui/kernel/qapplication_mac.mm
+++ b/src/gui/kernel/qapplication_mac.mm
@@ -468,7 +468,7 @@ void qt_mac_set_app_icon(const QPixmap &pixmap)
         image = static_cast<NSImage *>(qt_mac_create_nsimage(pixmap));
     }
 
-    [NSApp setApplicationIconImage:image];
+    [[NSApplication sharedApplication] setApplicationIconImage:image];
     [image release];
 #endif
 }
@@ -750,7 +750,7 @@ void qt_event_request_showsheet(QWidget *w)
     Q_ASSERT(qt_mac_is_macsheet(w));
 #ifdef QT_MAC_USE_COCOA
     w->repaint();
-    [NSApp beginSheet:qt_mac_window_for(w) modalForWindow:qt_mac_window_for(w->parentWidget())
+    [[NSApplication sharedApplication] beginSheet:qt_mac_window_for(w) modalForWindow:qt_mac_window_for(w->parentWidget())
         modalDelegate:nil didEndSelector:nil contextInfo:0];
 #else
     qt_mac_event_remove(request_showsheet_pending);
@@ -992,7 +992,7 @@ Q_GUI_EXPORT void qt_mac_set_dock_menu(QMenu *menu)
 {
     qt_mac_dock_menu = menu;
 #ifdef QT_MAC_USE_COCOA
-    [NSApp setDockMenu:menu->macMenu()];
+    [[NSApplication sharedApplication] setDockMenu:menu->macMenu()];
 #else
     SetApplicationDockTileMenu(menu->macMenu());
 #endif
@@ -1011,7 +1011,7 @@ void qt_mac_event_release(QWidget *w)
 #ifndef QT_MAC_USE_COCOA
             SetApplicationDockTileMenu(0);
 #else
-            [NSApp setDockMenu:0];
+            [[NSApplication sharedApplication] setDockMenu:0];
 #endif
         }
     }
@@ -1463,7 +1463,7 @@ QWidget *QApplication::topLevelAt(const QPoint &p)
     NSWindowList(windowCount, windowList.data());
     int firstQtWindowFound = -1;
     for (int i = 0; i < windowCount; ++i) {
-        NSWindow *window = [NSApp windowWithWindowNumber:windowList[i]];
+        NSWindow *window = [[NSApplication sharedApplication] windowWithWindowNumber:windowList[i]];
         if (window) {
             QWidget *candidateWindow = [window QT_MANGLE_NAMESPACE(qt_qwidget)];
             if (candidateWindow && firstQtWindowFound == -1)
@@ -3071,7 +3071,7 @@ bool QApplicationPrivate::canQuit()
 #else
     Q_Q(QApplication);
 #ifdef QT_MAC_USE_COCOA
-    [[NSApp mainMenu] cancelTracking];
+    [[[NSApplication sharedApplication] mainMenu] cancelTracking];
 #else
     HiliteMenu(0);
 #endif
@@ -3146,7 +3146,7 @@ void onApplicationChangedActivation( bool activated )
         }
 
         if (!app->activeWindow()) {
-            OSWindowRef wp = [NSApp keyWindow];
+            OSWindowRef wp = [[NSApplication sharedApplication] keyWindow];
             if (QWidget *tmp_w = qt_mac_find_window(wp))
                 app->setActiveWindow(tmp_w);
         }
diff --git a/src/gui/kernel/qcocoaapplication_mac.mm b/src/gui/kernel/qcocoaapplication_mac.mm
index 473eec1..6af7b79 100644
--- a/src/gui/kernel/qcocoaapplication_mac.mm
+++ b/src/gui/kernel/qcocoaapplication_mac.mm
@@ -147,7 +147,7 @@ QT_USE_NAMESPACE
     if ([event type] == NSApplicationDefined) {
         switch ([event subtype]) {
             case QtCocoaEventSubTypePostMessage:
-                [NSApp QT_MANGLE_NAMESPACE(qt_sendPostedMessage):event];
+                [[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_sendPostedMessage):event];
                 return true;
             default:
                 break;
@@ -174,7 +174,7 @@ QT_USE_NAMESPACE
     // be called instead of sendEvent if redirection occurs.
     // 'self' will then be an instance of NSApplication
     // (and not QNSApplication)
-    if (![NSApp QT_MANGLE_NAMESPACE(qt_filterEvent):event])
+    if (![[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_filterEvent):event])
         [self QT_MANGLE_NAMESPACE(qt_sendEvent_original):event];
 }
 
@@ -182,7 +182,7 @@ QT_USE_NAMESPACE
 {
     // This method will be called if
     // no redirection occurs
-    if (![NSApp QT_MANGLE_NAMESPACE(qt_filterEvent):event])
+    if (![[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_filterEvent):event])
         [super sendEvent:event];
 }
 
@@ -194,7 +194,7 @@ QT_USE_NAMESPACE
     // visible on screen. Note: If Qt is used as a plugin, Qt will not use a 
     // native menu bar. Hence, we will also not need to do any redirection etc. as 
     // we do with sendEvent.
-    [[NSApp QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)] qtDispatcherToQAction:sender];
+    [[[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)] qtDispatcherToQAction:sender];
 }
 
 @end
@@ -203,7 +203,7 @@ QT_BEGIN_NAMESPACE
 
 void qt_redirectNSApplicationSendEvent()
 {
-    if ([NSApp isMemberOfClass:[QT_MANGLE_NAMESPACE(QNSApplication) class]]) {
+    if ([[NSApplication sharedApplication] isMemberOfClass:[QT_MANGLE_NAMESPACE(QNSApplication) class]]) {
         // No need to change implementation since Qt
         // already controls a subclass of NSApplication
         return;
diff --git a/src/gui/kernel/qcocoaapplicationdelegate_mac.mm b/src/gui/kernel/qcocoaapplicationdelegate_mac.mm
index d45f5f1..cf46a87 100644
--- a/src/gui/kernel/qcocoaapplicationdelegate_mac.mm
+++ b/src/gui/kernel/qcocoaapplicationdelegate_mac.mm
@@ -122,7 +122,7 @@ static void cleanupCocoaApplicationDelegate()
     [dockMenu release];
     [qtMenuLoader release];
     if (reflectionDelegate) {
-        [NSApp setDelegate:reflectionDelegate];
+        [[NSApplication sharedApplication] setDelegate:reflectionDelegate];
         [reflectionDelegate release];
     }
     [super dealloc];
@@ -183,7 +183,7 @@ static void cleanupCocoaApplicationDelegate()
     return [[qtMenuLoader retain] autorelease];
 }
 
-// This function will only be called when NSApp is actually running. Before
+// This function will only be called when NSApplication is actually running. Before
 // that, the kAEQuitApplication Apple event will be sent to
 // QApplicationPrivate::globalAppleEventProcessor in qapplication_mac.mm
 - (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
@@ -249,7 +249,7 @@ static void cleanupCocoaApplicationDelegate()
         && [reflectionDelegate respondsToSelector:
                             @selector(applicationShouldTerminateAfterLastWindowClosed:)])
         return [reflectionDelegate applicationShouldTerminateAfterLastWindowClosed:sender];
-    return NO; // Someday qApp->quitOnLastWindowClosed(); when QApp and NSApp work closer together.
+    return NO; // Someday qApp->quitOnLastWindowClosed(); when qApp and NSApplication work closer together.
 }
 
 
@@ -308,7 +308,7 @@ static void cleanupCocoaApplicationDelegate()
     QDesktopWidgetImplementation::instance()->onResize();
 }
 
-- (void)setReflectionDelegate:(NSObject <NSApplicationDelegate> *)oldDelegate
+- (void)setReflectionDelegate:(id <NSApplicationDelegate>)oldDelegate
 {
     [oldDelegate retain];
     [reflectionDelegate release];
@@ -355,12 +355,12 @@ static void cleanupCocoaApplicationDelegate()
 {
     Q_UNUSED(event);
     Q_UNUSED(replyEvent);
-    [NSApp terminate:self];
+    [[NSApplication sharedApplication] terminate:self];
 }
 
 - (void)qtDispatcherToQAction:(id)sender
 {
-    [[NSApp QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)] qtDispatcherToQAction:sender];
+    [[[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)] qtDispatcherToQAction:sender];
 }
 
 @end
diff --git a/src/gui/kernel/qcocoaapplicationdelegate_mac_p.h b/src/gui/kernel/qcocoaapplicationdelegate_mac_p.h
index 7ff08d2..5a43d36 100644
--- a/src/gui/kernel/qcocoaapplicationdelegate_mac_p.h
+++ b/src/gui/kernel/qcocoaapplicationdelegate_mac_p.h
@@ -113,7 +113,7 @@ QT_FORWARD_DECLARE_CLASS(QApplicationPrivate);
     QApplicationPrivate *qtPrivate;
     NSMenu *dockMenu;
     QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *qtMenuLoader;
-    NSObject <NSApplicationDelegate> *reflectionDelegate;
+    id <NSApplicationDelegate> reflectionDelegate;
     bool inLaunch;
 }
 + (QT_MANGLE_NAMESPACE(QCocoaApplicationDelegate)*)sharedDelegate;
@@ -122,7 +122,7 @@ QT_FORWARD_DECLARE_CLASS(QApplicationPrivate);
 - (QApplicationPrivate *)qAppPrivate;
 - (void)setMenuLoader:(QT_MANGLE_NAMESPACE(QCocoaMenuLoader)*)menuLoader;
 - (QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *)menuLoader;
-- (void)setReflectionDelegate:(NSObject <NSApplicationDelegate> *)oldDelegate;
+- (void)setReflectionDelegate:(id <NSApplicationDelegate>)oldDelegate;
 - (void)getUrl:(NSAppleEventDescriptor *)event withReplyEvent:(NSAppleEventDescriptor *)replyEvent;
 @end
 #endif
diff --git a/src/gui/kernel/qcocoamenuloader_mac.mm b/src/gui/kernel/qcocoamenuloader_mac.mm
index 03fed56..c712950 100644
--- a/src/gui/kernel/qcocoamenuloader_mac.mm
+++ b/src/gui/kernel/qcocoamenuloader_mac.mm
@@ -92,8 +92,8 @@ QT_USE_NAMESPACE
     // 'Quit' item. When changing menu bar (e.g when switching between
     // windows with different menu bars), we never recreate this menu, but
     // instead pull it out the current menu bar and place into the new one:
-    NSMenu *mainMenu = [NSApp mainMenu];
-    if ([NSApp mainMenu] == menu)
+    NSMenu *mainMenu = [[NSApplication sharedApplication] mainMenu];
+    if ([[NSApplication sharedApplication] mainMenu] == menu)
         return; // nothing to do (menu is the current menu bar)!
 
 #ifndef QT_NAMESPACE
@@ -201,27 +201,27 @@ QT_USE_NAMESPACE
 
 - (void)terminate:(id)sender
 {
-    [NSApp terminate:sender];
+    [[NSApplication sharedApplication] terminate:sender];
 }
 
 - (void)orderFrontStandardAboutPanel:(id)sender
 {
-    [NSApp orderFrontStandardAboutPanel:sender];
+    [[NSApplication sharedApplication] orderFrontStandardAboutPanel:sender];
 }
 
 - (void)hideOtherApplications:(id)sender
 {
-    [NSApp hideOtherApplications:sender];
+    [[NSApplication sharedApplication] hideOtherApplications:sender];
 }
 
 - (void)unhideAllApplications:(id)sender
 {
-    [NSApp unhideAllApplications:sender];
+    [[NSApplication sharedApplication] unhideAllApplications:sender];
 }
 
 - (void)hide:(id)sender
 {
-    [NSApp hide:sender];
+    [[NSApplication sharedApplication] hide:sender];
 }
 
 - (void)qtUpdateMenubar
@@ -258,7 +258,7 @@ QT_USE_NAMESPACE
 
  - (void)orderFrontCharacterPalette:(id)sender
  {
-     [NSApp orderFrontCharacterPalette:sender];
+     [[NSApplication sharedApplication] orderFrontCharacterPalette:sender];
  }
 
 - (BOOL)validateMenuItem:(NSMenuItem*)menuItem
@@ -266,7 +266,7 @@ QT_USE_NAMESPACE
     if ([menuItem action] == @selector(hide:)
         || [menuItem action] == @selector(hideOtherApplications:)
         || [menuItem action] == @selector(unhideAllApplications:)) {
-        return [NSApp validateMenuItem:menuItem];
+        return [[NSApplication sharedApplication] validateMenuItem:menuItem];
     } else {
         return [menuItem isEnabled];
     }
diff --git a/src/gui/kernel/qcocoasharedwindowmethods_mac_p.h b/src/gui/kernel/qcocoasharedwindowmethods_mac_p.h
index 02cd007..cec899b 100644
--- a/src/gui/kernel/qcocoasharedwindowmethods_mac_p.h
+++ b/src/gui/kernel/qcocoasharedwindowmethods_mac_p.h
@@ -143,7 +143,7 @@ QT_END_NAMESPACE
 {
     // This function is called from the quit item in the menubar when this window
     // is in the first responder chain (see also qtDispatcherToQAction above)
-    [NSApp terminate:sender];
+    [[NSApplication sharedApplication] terminate:sender];
 }
 
 - (void)setLevel:(NSInteger)windowLevel
@@ -364,7 +364,7 @@ QT_END_NAMESPACE
 
     if ([sender draggingSource] != nil) {
         // modifier flags might have changed, update it here since we don't send any input events.
-        QApplicationPrivate::modifier_buttons = qt_cocoaModifiers2QtModifiers([[NSApp currentEvent] modifierFlags]);
+        QApplicationPrivate::modifier_buttons = qt_cocoaModifiers2QtModifiers([[[NSApplication sharedApplication] currentEvent] modifierFlags]);
         modifiers = QApplication::keyboardModifiers();
     } else {
         // when the source is from another application the above technique will not work.
@@ -456,7 +456,7 @@ QT_END_NAMESPACE
 
     // Update modifiers:
     if ([sender draggingSource] != nil) {
-        QApplicationPrivate::modifier_buttons = qt_cocoaModifiers2QtModifiers([[NSApp currentEvent] modifierFlags]);
+        QApplicationPrivate::modifier_buttons = qt_cocoaModifiers2QtModifiers([[[NSApplication sharedApplication] currentEvent] modifierFlags]);
         modifiers = QApplication::keyboardModifiers();
     } else {
         modifiers = qt_cocoaDragOperation2QtModifiers(nsActions);
diff --git a/src/gui/kernel/qeventdispatcher_mac.mm b/src/gui/kernel/qeventdispatcher_mac.mm
index a35fb68..e830eba 100644
--- a/src/gui/kernel/qeventdispatcher_mac.mm
+++ b/src/gui/kernel/qeventdispatcher_mac.mm
@@ -461,7 +461,7 @@ static bool qt_mac_send_event(QEventLoop::ProcessEventsFlags, OSEventRef event,
     if (pt)
         [pt sendEvent:event];
     else
-        [NSApp sendEvent:event];
+        [[NSApplication sharedApplication] sendEvent:event];
     return true;
 #endif
 }
@@ -521,12 +521,12 @@ static inline void qt_mac_waitForMoreEvents()
     // (and free up cpu time) until at least one event occur.
     // This implementation is a bit on the edge, but seems to
     // work fine:
-    NSEvent* event = [NSApp nextEventMatchingMask:NSAnyEventMask
+    NSEvent* event = [[NSApplication sharedApplication] nextEventMatchingMask:NSAnyEventMask
         untilDate:[NSDate distantFuture]
         inMode:NSDefaultRunLoopMode
         dequeue:YES];
     if (event)
-        [NSApp postEvent:event atStart:YES];
+        [[NSApplication sharedApplication] postEvent:event atStart:YES];
 #endif
 }
 
@@ -537,12 +537,12 @@ static inline void qt_mac_waitForMoreModalSessionEvents()
     // (and free up cpu time) until at least one event occur.
     // This implementation is a bit on the edge, but seems to
     // work fine:
-    NSEvent* event = [NSApp nextEventMatchingMask:NSAnyEventMask
+    NSEvent* event = [[NSApplication sharedApplication] nextEventMatchingMask:NSAnyEventMask
         untilDate:[NSDate distantFuture]
         inMode:NSModalPanelRunLoopMode
         dequeue:YES];
     if (event)
-        [NSApp postEvent:event atStart:YES];
+        [[NSApplication sharedApplication] postEvent:event atStart:YES];
 }
 #endif
 
@@ -588,23 +588,23 @@ bool QEventDispatcherMac::processEvents(QEventLoop::ProcessEventsFlags flags)
         // done from the application itself. And if processEvents is called
         // manually (rather than from a QEventLoop), we cannot enter a tight
         // loop and block this call, but instead we need to return after one flush.
-        // Finally, if we are to exclude user input events, we cannot call [NSApp run]
+        // Finally, if we are to exclude user input events, we cannot call [NSApplication run]
         // as we then loose control over which events gets dispatched:
-        const bool canExec_3rdParty = d->nsAppRunCalledByQt || ![NSApp isRunning];
+        const bool canExec_3rdParty = d->nsAppRunCalledByQt || ![[NSApplication sharedApplication] isRunning];
         const bool canExec_Qt = !excludeUserEvents &&
                 (flags & QEventLoop::DialogExec || flags & QEventLoop::EventLoopExec) ;
 
         if (canExec_Qt && canExec_3rdParty) {
             // We can use exec-mode, meaning that we can stay in a tight loop until
             // interrupted. This is mostly an optimization, but it allow us to use
-            // [NSApp run], which is the normal code path for cocoa applications.
+            // [NSApplication run], which is the normal code path for cocoa applications.
             if (NSModalSession session = d->currentModalSession()) {
                 QBoolBlocker execGuard(d->currentExecIsNSAppRun, false);
-                while ([NSApp runModalSession:session] == NSRunContinuesResponse && !d->interrupt)
+                while ([[NSApplication sharedApplication] runModalSession:session] == NSRunContinuesResponse && !d->interrupt)
                     qt_mac_waitForMoreModalSessionEvents();
 
                 if (!d->interrupt && session == d->currentModalSessionCached) {
-                    // Someone called [NSApp stopModal:] from outside the event
+                    // Someone called [[NSApplication sharedApplication] stopModal:] from outside the event
                     // dispatcher (e.g to stop a native dialog). But that call wrongly stopped
                     // 'session' as well. As a result, we need to restart all internal sessions:
                     d->temporarilyStopAllModalSessions();
@@ -612,7 +612,7 @@ bool QEventDispatcherMac::processEvents(QEventLoop::ProcessEventsFlags flags)
             } else {
                 d->nsAppRunCalledByQt = true;
                 QBoolBlocker execGuard(d->currentExecIsNSAppRun, true);
-                [NSApp run];
+                [[NSApplication sharedApplication] run];
             }
             retVal = true;
         } else {
@@ -626,9 +626,9 @@ bool QEventDispatcherMac::processEvents(QEventLoop::ProcessEventsFlags flags)
                     // to use cocoa's native way of running modal sessions:
                     if (flags & QEventLoop::WaitForMoreEvents)
                         qt_mac_waitForMoreModalSessionEvents();
-                    NSInteger status = [NSApp runModalSession:session];
+                    NSInteger status = [[NSApplication sharedApplication] runModalSession:session];
                     if (status != NSRunContinuesResponse && session == d->currentModalSessionCached) {
-                        // INVARIANT: Someone called [NSApp stopModal:] from outside the event
+                        // INVARIANT: Someone called [NSApplication stopModal:] from outside the event
                         // dispatcher (e.g to stop a native dialog). But that call wrongly stopped
                         // 'session' as well. As a result, we need to restart all internal sessions:
                         d->temporarilyStopAllModalSessions();
@@ -637,8 +637,8 @@ bool QEventDispatcherMac::processEvents(QEventLoop::ProcessEventsFlags flags)
                 } else do {
                     // Dispatch all non-user events (but que non-user events up for later). In
                     // this case, we need more control over which events gets dispatched, and
-                    // cannot use [NSApp runModalSession:session]:
-                    event = [NSApp nextEventMatchingMask:NSAnyEventMask
+                    // cannot use [NSApplication runModalSession:session]:
+                    event = [[NSApplication sharedApplication] nextEventMatchingMask:NSAnyEventMask
                     untilDate:nil
                     inMode:NSModalPanelRunLoopMode
                     dequeue: YES];
@@ -655,7 +655,7 @@ bool QEventDispatcherMac::processEvents(QEventLoop::ProcessEventsFlags flags)
                 } while (!d->interrupt && event != nil);
             } else do {
                 // INVARIANT: No modal window is executing.
-                event = [NSApp nextEventMatchingMask:NSAnyEventMask
+                event = [[NSApplication sharedApplication] nextEventMatchingMask:NSAnyEventMask
                 untilDate:nil
                 inMode:NSDefaultRunLoopMode
                 dequeue: YES];
@@ -798,12 +798,12 @@ void QEventDispatcherMacPrivate::ensureNSAppInitialized()
     // we let Cocoa finish the initialization it seems to need. We'll only
     // apply this trick at most once for any application, and we avoid doing it
     // for the common case where main just starts QApplication::exec.
-    if (nsAppRunCalledByQt || [NSApp isRunning])
+    if (nsAppRunCalledByQt || [[NSApplication sharedApplication] isRunning])
         return;
     nsAppRunCalledByQt = true;
     QBoolBlocker block1(interrupt, true);
     QBoolBlocker block2(currentExecIsNSAppRun, true);
-    [NSApp run];
+    [[NSApplication sharedApplication] run];
 }
 
 void QEventDispatcherMacPrivate::temporarilyStopAllModalSessions()
@@ -812,8 +812,8 @@ void QEventDispatcherMacPrivate::temporarilyStopAllModalSessions()
     // such, make them pending again. The next call to
     // currentModalSession will recreate them again. The
     // reason to stop all session like this is that otherwise
-    // a call [NSApp stop] would not stop NSApp, but rather
-    // the current modal session. So if we need to stop NSApp
+    // a call [NSApplication stop] would not stop NSApplication, but rather
+    // the current modal session. So if we need to stop NSApplication
     // we need to stop all the modal session first. To avoid changing
     // the stacking order of the windows while doing so, we put
     // up a block that is used in QCocoaWindow and QCocoaPanel:
@@ -821,7 +821,7 @@ void QEventDispatcherMacPrivate::temporarilyStopAllModalSessions()
     for (int i=0; i<stackSize; ++i) {
         QCocoaModalSessionInfo &info = cocoaModalSessionStack[i];
         if (info.session) {
-            [NSApp endModalSession:info.session];
+            [[NSApplication sharedApplication] endModalSession:info.session];
             info.session = 0;
         }
     }
@@ -856,7 +856,7 @@ NSModalSession QEventDispatcherMacPrivate::currentModalSession()
             info.nswindow = window;
             [(NSWindow*) info.nswindow retain];
             int levelBeforeEnterModal = [window level];
-            info.session = [NSApp beginModalSessionForWindow:window];
+            info.session = [[NSApplication sharedApplication] beginModalSessionForWindow:window];
             // Make sure we don't stack the window lower that it was before
             // entering modal, in case it e.g. had the stays-on-top flag set:
             if (levelBeforeEnterModal > [window level])
@@ -926,7 +926,7 @@ void QEventDispatcherMacPrivate::cleanupModalSessions()
         cocoaModalSessionStack.remove(i);
         currentModalSessionCached = 0;
         if (info.session) {
-            [NSApp endModalSession:info.session];
+            [[NSApplication sharedApplication] endModalSession:info.session];
             [(NSWindow *)info.nswindow release];
         }
     }
@@ -1057,7 +1057,7 @@ inline static void processPostedEvents(QEventDispatcherMacPrivate *const d, cons
             // pending cocoa events first).
             if (d->currentModalSessionCached)
                 d->temporarilyStopAllModalSessions();
-            [NSApp stop:NSApp];
+            [[NSApplication sharedApplication] stop:[NSApplication sharedApplication]];
             d->cancelWaitForMoreEvents();
         }
 #endif
@@ -1093,7 +1093,8 @@ void QEventDispatcherMacPrivate::cancelWaitForMoreEvents()
     // In case the event dispatcher is waiting for more
     // events somewhere, we post a dummy event to wake it up:
     QMacCocoaAutoReleasePool pool;
-    [NSApp postEvent:[NSEvent otherEventWithType:NSApplicationDefined location:NSZeroPoint
+    [[NSApplication sharedApplication] postEvent:[NSEvent otherEventWithType:NSApplicationDefined
+        location:NSZeroPoint
         modifierFlags:0 timestamp:0. windowNumber:0 context:0
         subtype:QtCocoaEventSubTypeWakeup data1:0 data2:0] atStart:NO];
 }
@@ -1110,7 +1111,7 @@ void QEventDispatcherMac::interrupt()
 #else
     // We do nothing more here than setting d->interrupt = true, and
     // poke the event loop if it is sleeping. Actually stopping
-    // NSApp, or the current modal session, is done inside the send
+    // NSApplication, or the current modal session, is done inside the send
     // posted events callback. We do this to ensure that all current pending
     // cocoa events gets delivered before we stop. Otherwise, if we now stop
     // the last event loop recursion, cocoa will just drop pending posted
@@ -1165,7 +1166,7 @@ QtMacInterruptDispatcherHelp::QtMacInterruptDispatcherHelp() : cancelled(false)
     // The whole point of this class is that we enable a way to interrupt
     // the event dispatcher when returning back to a lower recursion level
     // than where interruptLater was called. This is needed to detect if
-    // [NSApp run] should still be running at the recursion level it is at.
+    // [NSApplication run] should still be running at the recursion level it is at.
     // Since the interrupt is canceled if processEvents is called before
     // this object gets deleted, we also avoid interrupting unnecessary.
     deleteLater();
diff --git a/src/gui/kernel/qt_cocoa_helpers_mac.mm b/src/gui/kernel/qt_cocoa_helpers_mac.mm
index 747a42a..cb4057c 100644
--- a/src/gui/kernel/qt_cocoa_helpers_mac.mm
+++ b/src/gui/kernel/qt_cocoa_helpers_mac.mm
@@ -1697,7 +1697,7 @@ void qt_cocoaPostMessage(id target, SEL selector, int argCount, id arg1, id arg2
     NSEvent *e = [NSEvent otherEventWithType:NSApplicationDefined
         location:NSZeroPoint modifierFlags:0 timestamp:0 windowNumber:0
         context:nil subtype:QtCocoaEventSubTypePostMessage data1:lower data2:upper];
-    [NSApp postEvent:e atStart:NO];
+    [[NSApplication sharedApplication] postEvent:e atStart:NO];
 }
 
 void qt_cocoaPostMessageAfterEventLoopExit(id target, SEL selector, int argCount, id arg1, id arg2)
@@ -1727,7 +1727,7 @@ void qt_mac_post_retranslateAppMenu()
 {
 #ifdef QT_MAC_USE_COCOA
     QMacCocoaAutoReleasePool pool;
-    qt_cocoaPostMessage([NSApp QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)], @selector(qtTranslateApplicationMenu));
+    qt_cocoaPostMessage([[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)], @selector(qtTranslateApplicationMenu));
 #endif
 }
 
diff --git a/src/gui/kernel/qwidget_mac.mm b/src/gui/kernel/qwidget_mac.mm
index f58a755..7e9ebb9 100644
--- a/src/gui/kernel/qwidget_mac.mm
+++ b/src/gui/kernel/qwidget_mac.mm
@@ -220,7 +220,7 @@ static QSize qt_mac_desktopSize()
 static NSDrawer *qt_mac_drawer_for(const QWidget *widget)
 {
     NSView *widgetView = reinterpret_cast<NSView *>(widget->window()->effectiveWinId());
-    NSArray *windows = [NSApp windows];
+    NSArray *windows = [[NSApplication sharedApplication] windows];
     for (NSWindow *window in windows) {
         NSArray *drawers = [window drawers];
         for (NSDrawer *drawer in drawers) {
@@ -254,7 +254,7 @@ static void qt_mac_destructWindow(OSWindowRef window)
 {
 #ifdef QT_MAC_USE_COCOA
     if ([window isVisible] && [window isSheet]){
-        [NSApp endSheet:window];
+        [[NSApplication sharedApplication] endSheet:window];
         [window orderOut:window];
     }
 
@@ -2439,7 +2439,7 @@ void QWidgetPrivate::recreateMacWindow()
     }
     if ([oldWindow isVisible]){
         if ([oldWindow isSheet])
-            [NSApp endSheet:oldWindow];
+            [[NSApplication sharedApplication] endSheet:oldWindow];
         [oldWindow orderOut:oldWindow];
         show_sys();
     }
@@ -3554,7 +3554,7 @@ void QWidgetPrivate::show_sys()
     }
 
 #ifdef QT_MAC_USE_COCOA
-    if ([NSApp isActive] && !qt_button_down && !QWidget::mouseGrabber()){
+    if ([[NSApplication sharedApplication] isActive] && !qt_button_down && !QWidget::mouseGrabber()){
         // Update enter/leave immidiatly, don't wait for a move event. But only
         // if no grab exists (even if the grab points to this widget, it seems, ref X11)
         QPoint qlocal, qglobal;
@@ -3605,7 +3605,7 @@ void QWidgetPrivate::hide_sys()
             else
                 HideSheetWindow(window);
 #else
-            [NSApp endSheet:window];
+            [[NSApplication sharedApplication] endSheet:window];
             [window orderOut:window];
 #endif
         } else if(qt_mac_is_macdrawer(q)) {
@@ -3716,7 +3716,7 @@ void QWidgetPrivate::hide_sys()
     }
 
 #ifdef QT_MAC_USE_COCOA
-    if ([NSApp isActive] && !qt_button_down && !QWidget::mouseGrabber()){
+    if ([[NSApplication sharedApplication] isActive] && !qt_button_down && !QWidget::mouseGrabber()){
         // Update enter/leave immidiatly, don't wait for a move event. But only
         // if no grab exists (even if the grab points to this widget, it seems, ref X11)
         QPoint qlocal, qglobal;
diff --git a/src/gui/styles/qmacstyle_mac.mm b/src/gui/styles/qmacstyle_mac.mm
index 78d0d19..ff3696c 100644
--- a/src/gui/styles/qmacstyle_mac.mm
+++ b/src/gui/styles/qmacstyle_mac.mm
@@ -780,7 +780,7 @@ static QSize qt_aqua_get_known_size(QStyle::ContentsType ct, const QWidget *widg
             if (!GetThemeMenuBarHeight(&size))
                 ret = QSize(-1, size);
 #else
-            ret = QSize(-1, [[NSApp mainMenu] menuBarHeight]);
+            ret = QSize(-1, [[[NSApplication sharedApplication] mainMenu] menuBarHeight]);
             // In the qt_mac_set_native_menubar(false) case,
             // we come it here with a zero-height main menu,
             // preventing the in-window menu from displaying.
diff --git a/src/gui/util/qsystemtrayicon_mac.mm b/src/gui/util/qsystemtrayicon_mac.mm
index 3d7ca14..07e3ea2 100644
--- a/src/gui/util/qsystemtrayicon_mac.mm
+++ b/src/gui/util/qsystemtrayicon_mac.mm
@@ -536,7 +536,7 @@ private:
 #ifndef QT_MAC_USE_COCOA
                 const short scale = GetMBarHeight();
 #else
-                const short scale = [[NSApp mainMenu] menuBarHeight];
+                const short scale = [[[NSApplication sharedApplication] mainMenu] menuBarHeight];
 #endif
                 NSImage *nsimage = static_cast<NSImage *>(qt_mac_create_nsimage(icon.pixmap(QSize(scale, scale))));
                 [item setImage: nsimage];
diff --git a/src/gui/widgets/qcocoamenu_mac.mm b/src/gui/widgets/qcocoamenu_mac.mm
index c31416a..54bf11c 100644
--- a/src/gui/widgets/qcocoamenu_mac.mm
+++ b/src/gui/widgets/qcocoamenu_mac.mm
@@ -202,7 +202,7 @@ QT_USE_NAMESPACE
      static SEL selForOFCP = NSSelectorFromString(@"orderFrontCharacterPalette:");
      if (index == -1 && selForOFCP == actionSelector) {
          // Check if the 'orderFrontCharacterPalette' SEL exists for QCocoaMenuLoader object
-         QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *loader = [NSApp QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)];
+         QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *loader = [[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)];
          return [super indexOfItemWithTarget:loader andAction:actionSelector];
      }
      return index;
diff --git a/src/gui/widgets/qmenu_mac.mm b/src/gui/widgets/qmenu_mac.mm
index 12ef70d..669f824 100644
--- a/src/gui/widgets/qmenu_mac.mm
+++ b/src/gui/widgets/qmenu_mac.mm
@@ -179,7 +179,7 @@ static void cancelAllMenuTracking()
 {
 #ifdef QT_MAC_USE_COCOA
     QMacCocoaAutoReleasePool pool;
-    NSMenu *mainMenu = [NSApp mainMenu];
+    NSMenu *mainMenu = [[NSApplication sharedApplication] mainMenu];
     [mainMenu cancelTracking];
     for (NSMenuItem *item in [mainMenu itemArray]) {
         if ([item submenu]) {
@@ -633,7 +633,7 @@ static inline void syncMenuBarItemsVisiblity(const QMenuBarPrivate::QMacMenuBarP
 
 static inline QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *getMenuLoader()
 {
-    return [NSApp QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)];
+    return [[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)];
 }
 
 static NSMenuItem *createNSMenuItem(const QString &title)
@@ -2033,7 +2033,7 @@ void qt_mac_clear_menubar()
     QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *loader = getMenuLoader();
     NSMenu *menu = [loader menu];
     [loader ensureAppMenuInMenu:menu];
-    [NSApp setMainMenu:menu];
+    [[NSApplication sharedApplication] setMainMenu:menu];
     const bool modal = qt_mac_should_disable_menu(0);
     if (qt_mac_current_menubar.qmenubar || modal != qt_mac_current_menubar.modal)
         qt_mac_set_modal_state(menu, modal);
@@ -2100,7 +2100,7 @@ bool QMenuBarPrivate::macUpdateMenuBarImmediatly()
 #else
             QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *loader = getMenuLoader();
             [loader ensureAppMenuInMenu:menu];
-            [NSApp setMainMenu:menu];
+            [[NSApplication sharedApplication] setMainMenu:menu];
             syncMenuBarItemsVisiblity(mb->d_func()->mac_menubar);
 
             if (OSMenuRef tmpMerge = QMenuPrivate::mergeMenuHash.value(menu)) {
@@ -2140,7 +2140,7 @@ bool QMenuBarPrivate::macUpdateMenuBarImmediatly()
 #else
                 QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *loader = getMenuLoader();
                 [loader ensureAppMenuInMenu:menu];
-                [NSApp setMainMenu:menu];
+                [[NSApplication sharedApplication] setMainMenu:menu];
                 syncMenuBarItemsVisiblity(qt_mac_current_menubar.qmenubar->d_func()->mac_menubar);
 #endif
                 qt_mac_set_modal_state(menu, modal);
