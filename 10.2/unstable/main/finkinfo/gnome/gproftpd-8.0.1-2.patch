diff -ruN gproftpd-8.0.1.orig/Makefile.in gproftpd-8.0.1/Makefile.in
--- gproftpd-8.0.1.orig/Makefile.in	2002-10-13 10:32:21.000000000 -0600
+++ gproftpd-8.0.1/Makefile.in	2002-10-23 23:21:08.000000000 -0600
@@ -428,21 +428,39 @@
 install-data-local:
 	@$(NORMAL_INSTALL)
 	if test -d $(srcdir)/pixmaps; then \
-	  $(mkinstalldirs) $(DESTDIR)$(datadir)/pixmaps/$(PACKAGE); \
+	  if test ! -d $(DESTDIR)$(datadir)/pixmaps/$(PACKAGE); then \
+	    $(mkinstalldirs) $(DESTDIR)$(datadir)/pixmaps/$(PACKAGE); \
+	  fi; \
 	  for pixmap in $(srcdir)/pixmaps/*; do \
 	    if test -f $$pixmap; then \
 	      $(INSTALL_DATA) $$pixmap $(DESTDIR)$(datadir)/pixmaps/$(PACKAGE); \
 	    fi \
 	  done \
 	fi
-	mv $(DESTDIR)$(datadir)/pixmaps/$(PACKAGE)/net-gproftpd.desktop /usr/share/applications/
-	if test ! -d /etc/gproftpd; then \
-	  $(mkinstalldirs) /etc/gproftpd; \
+
+	if test ! -d $(DESTDIR)$(datadir)/gnome/apps/Internet; then \
+	  $(mkinstalldirs) $(DESTDIR)$(datadir)/gnome/apps/Internet; \
+	fi
+
+	mv $(DESTDIR)$(datadir)/pixmaps/$(PACKAGE)/net-gproftpd.desktop $(DESTDIR)$(datadir)/gnome/apps/Internet/
+
+	if test ! -d $(DESTDIR)$(datadir)/applnk/Internet; then \
+	  $(mkinstalldirs) $(DESTDIR)$(datadir)/applnk/Internet; \
+	fi
+
+	cp $(DESTDIR)$(datadir)/gnome/apps/Internet/net-gproftpd.desktop $(DESKTOP)$(datadir)/applnk/Internet/
+
+	if test ! -d $(DESTDIR)$(sysconfdir)/gproftpd; then \
+	  $(mkinstalldirs) $(DESTDIR)$(sysconfdir)/gproftpd; \
+	fi
+
+	if test ! -d $(DESTDIR)$(datadir)/pixmaps; then \
+	  $(mkinstalldirs) $(DESTDIR)$(datadir)/pixmaps; \
 	fi
 
-	cp support/useradd-profile /etc/gproftpd
-	cp support/gproftpd.pem /etc/gproftpd
-	cp pixmaps/gproftpd.png /usr/share/pixmaps
+	cp support/useradd-profile $(DESTDIR)$(sysconfdir)/gproftpd
+	cp support/gproftpd.pem $(DESTDIR)$(sysconfdir)/gproftpd
+	cp pixmaps/gproftpd.png $(DESTDIR)$(datadir)/pixmaps
 	@echo ""
 	@echo "Start GProFTPD by typing gproftpd"
 	@echo "or start it from the menu panels internet section where i placed an application launcher."
diff -ruN gproftpd-8.0.1.orig/gproftpd.glade gproftpd-8.0.1/gproftpd.glade
--- gproftpd-8.0.1.orig/gproftpd.glade	2002-10-13 08:50:15.000000000 -0600
+++ gproftpd-8.0.1/gproftpd.glade	2002-10-25 10:47:33.000000000 -0600
@@ -12,7 +12,7 @@
   <property name="modal">False</property>
   <property name="resizable">True</property>
   <property name="destroy_with_parent">False</property>
-  <property name="icon">gproftpd36.xpm</property>
+  <property name="icon">gproftpd/gproftpd36.xpm</property>
 
   <child>
     <widget class="GtkVBox" id="vbox1">
@@ -3462,7 +3462,7 @@
 		  <child>
 		    <widget class="GtkLabel" id="label40">
 		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">This is the entire configuration. The backup / restore directory is /etc/gproftpd.</property>
+		      <property name="label" translatable="yes">This is the entire configuration. The backup / restore directory is @FINKPREFIX@/etc/gproftpd.</property>
 		      <property name="use_underline">False</property>
 		      <property name="use_markup">False</property>
 		      <property name="justify">GTK_JUSTIFY_CENTER</property>
@@ -4193,7 +4193,7 @@
 	  <property name="visible">True</property>
 	  <property name="label" translatable="yes">   1. Make sure that the user the server will run as exists on your
        system, also make sure this user has a /bin/false or nologin 
-       shell and is listed in /etc/ftpusers &quot;the usercontrol tab&quot;.
+       shell and is listed in @FINKPREFIX@/etc/ftpusers &quot;the usercontrol tab&quot;.
 
    2. The profiles tab is the settings the user will get when
        he / she is added to the system (edit as you wish).
diff -ruN gproftpd-8.0.1.orig/missing gproftpd-8.0.1/missing
--- gproftpd-8.0.1.orig/missing	2002-02-28 01:56:25.000000000 -0700
+++ gproftpd-8.0.1/missing	2002-10-25 11:17:32.000000000 -0600
@@ -1,7 +1,7 @@
 #! /bin/sh
 # Common stub for a few missing GNU programs while installing.
-# Copyright (C) 1996, 1997, 2001 Free Software Foundation, Inc.
-# Franc,ois Pinard <pinard@iro.umontreal.ca>, 1996.
+# Copyright (C) 1996, 1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+# Originally by Fran,cois Pinard <pinard@iro.umontreal.ca>, 1996.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -18,20 +18,38 @@
 # Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 # 02111-1307, USA.
 
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
 if test $# -eq 0; then
   echo 1>&2 "Try \`$0 --help' for more information"
   exit 1
 fi
 
+run=:
+
 # In the cases where this matters, `missing' is being run in the
 # srcdir already.
-if test -f configure.in; then
+if test -f configure.ac; then
   configure_ac=configure.ac
 else
   configure_ac=configure.in
 fi
 
 case "$1" in
+--run)
+  # Try to run requested program, and just exit if it succeeds.
+  run=
+  shift
+  "$@" && exit 0
+  ;;
+esac
+
+# If it does not exist, or fails to run (possibly an outdated version),
+# try to emulate it.
+case "$1" in
 
   -h|--h|--he|--hel|--help)
     echo "\
@@ -43,6 +61,7 @@
 Options:
   -h, --help      display this help and exit
   -v, --version   output version information and exit
+  --run           try to run the given command, and emulate it if it fails
 
 Supported PROGRAM values:
   aclocal      touch file \`aclocal.m4'
@@ -51,13 +70,15 @@
   automake     touch all \`Makefile.in' files
   bison        create \`y.tab.[ch]', if possible, from existing .[ch]
   flex         create \`lex.yy.c', if possible, from existing .c
+  help2man     touch the output file
   lex          create \`lex.yy.c', if possible, from existing .c
   makeinfo     touch the output file
+  tar          try tar, gnutar, gtar, then tar without non-portable flags
   yacc         create \`y.tab.[ch]', if possible, from existing .[ch]"
     ;;
 
   -v|--v|--ve|--ver|--vers|--versi|--versio|--version)
-    echo "missing - GNU libit 0.0"
+    echo "missing 0.4 - GNU automake"
     ;;
 
   -*)
@@ -66,31 +87,46 @@
     exit 1
     ;;
 
-  aclocal)
+  aclocal*)
+    if test -z "$run" && ($1 --version) > /dev/null 2>&1; then
+       # We have it, but it failed.
+       exit 1
+    fi
+
     echo 1>&2 "\
 WARNING: \`$1' is missing on your system.  You should only need it if
-         you modified \`acinclude.m4' or \`$configure_ac'.  You might want
+         you modified \`acinclude.m4' or \`${configure_ac}'.  You might want
          to install the \`Automake' and \`Perl' packages.  Grab them from
          any GNU archive site."
     touch aclocal.m4
     ;;
 
   autoconf)
+    if test -z "$run" && ($1 --version) > /dev/null 2>&1; then
+       # We have it, but it failed.
+       exit 1
+    fi
+
     echo 1>&2 "\
 WARNING: \`$1' is missing on your system.  You should only need it if
-         you modified \`$configure_ac'.  You might want to install the
+         you modified \`${configure_ac}'.  You might want to install the
          \`Autoconf' and \`GNU m4' packages.  Grab them from any GNU
          archive site."
     touch configure
     ;;
 
   autoheader)
+    if test -z "$run" && ($1 --version) > /dev/null 2>&1; then
+       # We have it, but it failed.
+       exit 1
+    fi
+
     echo 1>&2 "\
 WARNING: \`$1' is missing on your system.  You should only need it if
-         you modified \`acconfig.h' or \`$configure_ac'.  You might want
+         you modified \`acconfig.h' or \`${configure_ac}'.  You might want
          to install the \`Autoconf' and \`GNU m4' packages.  Grab them
          from any GNU archive site."
-    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\([^)]*\)).*/\1/p' $configure_ac`
+    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\([^)]*\)).*/\1/p' ${configure_ac}`
     test -z "$files" && files="config.h"
     touch_files=
     for f in $files; do
@@ -103,10 +139,15 @@
     touch $touch_files
     ;;
 
-  automake)
+  automake*)
+    if test -z "$run" && ($1 --version) > /dev/null 2>&1; then
+       # We have it, but it failed.
+       exit 1
+    fi
+
     echo 1>&2 "\
 WARNING: \`$1' is missing on your system.  You should only need it if
-         you modified \`Makefile.am', \`acinclude.m4' or \`$configure_ac'.
+         you modified \`Makefile.am', \`acinclude.m4' or \`${configure_ac}'.
          You might want to install the \`Automake' and \`Perl' packages.
          Grab them from any GNU archive site."
     find . -type f -name Makefile.am -print |
@@ -114,6 +155,34 @@
 	   while read f; do touch "$f"; done
     ;;
 
+  autom4te)
+    if test -z "$run" && ($1 --version) > /dev/null 2>&1; then
+       # We have it, but it failed.
+       exit 1
+    fi
+
+    echo 1>&2 "\
+WARNING: \`$1' is needed, and you do not seem to have it handy on your
+         system.  You might have modified some files without having the
+         proper tools for further handling them.
+         You can get \`$1Help2man' as part of \`Autoconf' from any GNU
+         archive site."
+
+    file=`echo "$*" | sed -n 's/.*--output[ =]*\([^ ]*\).*/\1/p'`
+    test -z "$file" && file=`echo "$*" | sed -n 's/.*-o[ ]*\([^ ]*\).*/\1/p'`
+    if test -f "$file"; then
+	touch $file
+    else
+	test -z "$file" || exec >$file
+	echo "#! /bin/sh"
+	echo "# Created by GNU Automake missing as a replacement of"
+	echo "#  $ $@"
+	echo "exit 0"
+	chmod +x $file
+	exit 1
+    fi
+    ;;
+
   bison|yacc)
     echo 1>&2 "\
 WARNING: \`$1' is missing on your system.  You should only need it if
@@ -167,7 +236,37 @@
     fi
     ;;
 
+  help2man)
+    if test -z "$run" && ($1 --version) > /dev/null 2>&1; then
+       # We have it, but it failed.
+       exit 1
+    fi
+
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+	 you modified a dependency of a manual page.  You may need the
+	 \`Help2man' package in order for those modifications to take
+	 effect.  You can get \`Help2man' from any GNU archive site."
+
+    file=`echo "$*" | sed -n 's/.*-o \([^ ]*\).*/\1/p'`
+    if test -z "$file"; then
+	file=`echo "$*" | sed -n 's/.*--output=\([^ ]*\).*/\1/p'`
+    fi
+    if [ -f "$file" ]; then
+	touch $file
+    else
+	test -z "$file" || exec >$file
+	echo ".ab help2man is required to generate this page"
+	exit 1
+    fi
+    ;;
+
   makeinfo)
+    if test -z "$run" && (makeinfo --version) > /dev/null 2>&1; then
+       # We have makeinfo, but it failed.
+       exit 1
+    fi
+
     echo 1>&2 "\
 WARNING: \`$1' is missing on your system.  You should only need it if
          you modified a \`.texi' or \`.texinfo' file, or any other file
@@ -183,6 +282,45 @@
     touch $file
     ;;
 
+  tar)
+    shift
+    if test -n "$run"; then
+      echo 1>&2 "ERROR: \`tar' requires --run"
+      exit 1
+    fi
+
+    # We have already tried tar in the generic part.
+    # Look for gnutar/gtar before invocation to avoid ugly error
+    # messages.
+    if (gnutar --version > /dev/null 2>&1); then
+       gnutar "$@" && exit 0
+    fi
+    if (gtar --version > /dev/null 2>&1); then
+       gtar "$@" && exit 0
+    fi
+    firstarg="$1"
+    if shift; then
+	case "$firstarg" in
+	*o*)
+	    firstarg=`echo "$firstarg" | sed s/o//`
+	    tar "$firstarg" "$@" && exit 0
+	    ;;
+	esac
+	case "$firstarg" in
+	*h*)
+	    firstarg=`echo "$firstarg" | sed s/h//`
+	    tar "$firstarg" "$@" && exit 0
+	    ;;
+	esac
+    fi
+
+    echo 1>&2 "\
+WARNING: I can't seem to be able to run \`tar' with the given arguments.
+         You may want to install GNU tar or Free paxutils, or check the
+         command line arguments."
+    exit 1
+    ;;
+
   *)
     echo 1>&2 "\
 WARNING: \`$1' is needed, and you do not seem to have it handy on your
diff -ruN gproftpd-8.0.1.orig/src/callback.c gproftpd-8.0.1/src/callback.c
--- gproftpd-8.0.1.orig/src/callback.c	1969-12-31 17:00:00.000000000 -0700
+++ gproftpd-8.0.1/src/callback.c	2002-10-25 11:32:46.000000000 -0600
@@ -0,0 +1,3963 @@
+/*
+ * GProFTPD - GNOME frontend for the ProFTPD standalone server.
+ * Copyright (C) 2001, 2002 Magnus-swe <magnus-swe@telia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define GTK_DISABLE_DEPRECATED
+  
+#include <gnome.h>
+#include "callbacks.h"
+#include "interface.h"
+#include "support.h"
+#include <stdio.h>
+#include <stdlib.h> // atoi
+#include <unistd.h> // usleep
+#include <string.h> // strtok str*
+
+// For the profile changer
+GtkWidget *user_profile_window;
+GtkWidget *profile_home_directory_entry;
+GtkWidget *profile_group_entry;
+GtkWidget *profile_require_password_entry;
+GtkWidget *profile_max_logins_entry;
+GtkWidget *profile_username_entry;
+GtkWidget *profile_password_entry;
+
+// These are ok
+GtkWidget *GProFTPD;
+GtkWidget *help;
+GtkWidget *dir_chmod_selection;
+GtkWidget *file_chmod_selection;
+GtkWidget *chmod_directory_entry;
+GtkWidget *chmod_file_entry;
+GtkWidget *shutdown_window;
+GtkWidget *new_login_disable_entry;
+GtkWidget *exist_user_disconnect_entry;
+GtkWidget *real_shutdown_entry;
+GtkWidget *user_name_entry;
+GtkWidget *password_entry;
+GtkWidget *directory_entry;
+GtkWidget *disc_treeview;
+GtkWidget *anon_path_entry;
+GtkWidget *anon_chmod_entry;
+GtkWidget *version_entry;
+GtkWidget *on_offline_entry;
+GtkWidget *credits_window;
+GtkWidget *anon_password_entry;
+GtkWidget *userlist_treeview;
+GtkWidget *security_successful_textview;
+GtkWidget *security_refused_textview;
+GtkWidget *Permissions_window;
+GtkWidget *permissions_textview;
+GtkWidget *show_chmod_window;
+GtkWidget *error_window;
+GtkWidget *error_textview;          
+GtkWidget *entire_config_textview;
+GtkWidget *user_control_textview;
+GtkWidget *profile_text;
+GtkWidget *entire_config_textview;
+GtkWidget *incoming_entry;
+GtkWidget *outgoing_entry;
+GtkWidget *ftp_who_textview;
+GtkWidget *files_textview;
+GtkWidget *temp_kick_entry;
+GtkWidget *kick_ban_entry;
+GtkWidget *open_user_profile_name_entry;
+GtkWidget *global_show_server_identity_on_off;
+GtkWidget *global_server_name;
+GtkWidget *global_server_port;
+GtkWidget *global_max_connect;
+GtkWidget *global_idle_timeout;
+GtkWidget *global_resume_uploads;
+GtkWidget *global_resume_downloads;
+GtkWidget *global_download_bandwidth;
+GtkWidget *global_upload_bandwidth;
+GtkWidget *global_show_server_identity;
+GtkWidget *global_reverse_lookups;
+GtkWidget *global_default_transfer_mode;
+GtkWidget *global_ident_lookups;
+GtkWidget *global_server_user;
+GtkWidget *global_server_group;
+GtkWidget *global_allow_fxp;
+GtkWidget *global_time_standard;
+GtkWidget *global_max_login_attempts;
+GtkWidget *global_timeout_login;
+GtkWidget *global_delete_aborted_stores;
+GtkWidget *global_read_free_bytes;
+GtkWidget *global_read_hard_bps;
+GtkWidget *global_write_free_bytes;
+GtkWidget *global_write_hard_bps;
+GtkWidget *global_server_admin_email;
+
+// I only need one
+G_CONST_RETURN gchar *file_chmod_path;                   // for the permissions-changer
+G_CONST_RETURN gchar *chmod_file_entry_permissions;      // for the permissions-changer
+G_CONST_RETURN gchar *chmod_directory_entry_permissions; // for the permissions-changer
+
+char info_buffer[4096]="";                // Text for the info/error window
+char profile_name[1024]="";               // for the user-search/changer (username)
+char do_chmod[4096]="";                   // for permission-changes (command and path)
+
+// OK For the speed function 
+int turns = 0;
+char in_speed_1_buffer[4096]="";
+char out_speed_1_buffer[4096]="";
+
+int update=1;
+
+// OK
+update_user_list                (GtkWidget       *widget,
+                                 gpointer         user_data)
+{
+   FILE *fp;
+   GtkListStore *model;
+   GtkTreeIter iter;
+   GtkCellRenderer *cell;
+   GtkTreeViewColumn *user_column, *group_column, *maxclients_column, *require_column, *maximum_column;
+   long size_buffer;
+   int user_counter = 0;
+   char *new_buffer;
+   char *old_buffer;
+   char *buf;
+   gchar *utf8=NULL;
+   userlist_treeview = lookup_widget (GTK_WIDGET (widget), "userlist_treeview");
+   model = gtk_list_store_new(5, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
+   gtk_tree_view_set_model(GTK_TREE_VIEW(userlist_treeview), GTK_TREE_MODEL (model));
+   cell = gtk_cell_renderer_text_new();
+   user_column = gtk_tree_view_column_new_with_attributes("User", cell, "text", 0, NULL);
+   group_column = gtk_tree_view_column_new_with_attributes("Group", cell, "text", 1, NULL);
+   maxclients_column = gtk_tree_view_column_new_with_attributes("Home directory", cell, "text", 2, NULL);
+   require_column = gtk_tree_view_column_new_with_attributes("Require password", cell, "text", 3, NULL);
+   maximum_column = gtk_tree_view_column_new_with_attributes("Maximum simultaneous connections", cell, "text", 4, NULL);
+   gtk_list_store_clear(model);
+
+   if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
+   {
+       // create info window and show info_buffer.
+       strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf\n");
+       strcat(info_buffer, "Run GProFTPD as root\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window); 
+       return;
+   }
+   fseek(fp, 0, SEEK_END);
+   size_buffer = ftell(fp);
+   rewind(fp);
+   old_buffer=(char *)malloc(size_buffer);
+   bzero(old_buffer, sizeof(char) * size_buffer);   
+
+   buf=(char *)malloc(1024);
+   bzero(buf, sizeof(char) * 1024);
+
+   new_buffer=(char *)malloc(1024);
+   bzero(new_buffer, sizeof(char) * 1024);   
+
+   while (fgets((char*)old_buffer, size_buffer, fp)!=NULL)
+   {
+      if (strstr((char*)old_buffer, "<Anonymous ")!=NULL)
+      {
+         sprintf((char*)new_buffer, old_buffer);
+         new_buffer[strlen(old_buffer)-1] = 0;
+         new_buffer[strlen(old_buffer)-2] = 10;
+         buf = strtok(new_buffer, " ");
+         buf = strtok(NULL, ">");
+         utf8 = g_locale_to_utf8(buf, strlen(buf), NULL, NULL, NULL);
+         gtk_list_store_append(GTK_LIST_STORE(model), &iter);
+         gtk_list_store_set(GTK_LIST_STORE(model), &iter, 2, utf8, -1);
+         user_counter = 1;
+      }
+      if ((strstr((char*)old_buffer, "User ")!=NULL) && user_counter == 1)  
+      {
+         sprintf((char*)new_buffer, old_buffer);
+         buf = strtok(new_buffer, " "); 
+         buf = strtok(NULL, "\n"); 
+         utf8 = g_locale_to_utf8(buf, strlen(buf), NULL, NULL, NULL);
+         gtk_list_store_set(GTK_LIST_STORE(model), &iter, 0, utf8, -1);
+      }
+      if ((strstr((char*)old_buffer, "Group ")!=NULL) && user_counter == 1)
+      {   
+         sprintf((char*)new_buffer, old_buffer);
+         buf = strtok(new_buffer, " ");
+         buf = strtok(NULL, "\n");
+         utf8 = g_locale_to_utf8(buf, strlen(buf), NULL, NULL, NULL);
+         gtk_list_store_set(GTK_LIST_STORE(model), &iter, 1, utf8, -1);
+      }
+      if ((strstr((char*)old_buffer, "AnonRequirePassword ")!=NULL) && user_counter == 1)
+      {   
+         sprintf((char*)new_buffer, old_buffer);
+         buf = strtok(new_buffer, " ");
+         buf = strtok(NULL, "\n");
+         utf8 = g_locale_to_utf8(buf, strlen(buf), NULL, NULL, NULL);
+         gtk_list_store_set(GTK_LIST_STORE(model), &iter, 3, utf8, -1);
+      }
+      if ((strstr((char*)old_buffer, "MaxClients ")!=NULL) && user_counter == 1)
+      {   
+         int i=11;
+         while(old_buffer[i]!=' ')
+         {
+            i++;
+            if (i>100) break;
+         }
+         strcpy(new_buffer, old_buffer);
+         new_buffer[i] = 10;
+         new_buffer[i+1] = 0;
+         buf = strtok(new_buffer, " ");
+         buf = strtok(NULL, "\n");
+         utf8 = g_locale_to_utf8(buf, strlen(buf), NULL, NULL, NULL);
+         gtk_list_store_set(GTK_LIST_STORE(model), &iter, 4, utf8, -1);
+      }
+  }
+  fclose(fp);
+  if(utf8 !=NULL)
+  g_free(utf8);
+  free(old_buffer);
+  free(new_buffer);
+  free(buf);       
+}
+
+
+//OK
+update_entire_configuration(GtkWidget       *widget,
+                            gpointer         user_data)
+{
+    // Updates the entire configuration tab from proftpd.conf
+    FILE *fp;
+    long size_buffer;
+    int length;
+    char *buffer;
+    char *get_buffer;
+    GtkTextBuffer *entire_text_buffer;
+    gchar *utf8=NULL;
+
+    if( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL )
+    {
+       strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf.\n\n");
+       strcat(info_buffer, "Are you running GProFTPD as root ?.\n");
+       strcat(info_buffer, "im unable to update the entire configuration tab\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    // Set the entire configuration from proftpd.conf
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+
+    buffer=(char *)malloc(size_buffer); 
+    bzero(buffer, sizeof(char) * size_buffer);
+
+    // There are no additional lines !
+    get_buffer=(char *)malloc(size_buffer); //+8192);
+    bzero(get_buffer, sizeof(char) * size_buffer); //+8192);
+
+    entire_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(entire_config_textview));
+
+    while (fgets(buffer, size_buffer, fp)!=NULL)
+    {
+       strcat(get_buffer, buffer);
+    }
+    utf8 = g_locale_to_utf8(get_buffer, strlen(get_buffer), NULL, NULL, NULL);
+    gtk_text_buffer_set_text(entire_text_buffer, utf8, strlen(utf8));
+    fclose(fp);
+
+    if(utf8 !=NULL)
+    g_free(utf8);
+    free(buffer);
+    free(get_buffer);
+}
+
+
+// OK
+update_global_configuration     (GtkWidget       *widget,
+                                 gpointer         user_data)
+{
+    // Update the global configuration tab
+    FILE *fp;
+    long size_buffer;
+    char *old_Buffer;
+    char *new_Buffer;
+    const gchar *length_buffer;
+    int begin = 0;
+    int end = 0;
+    int x;
+    int global_int;
+    int length=0;
+    // This can be improved .. ZZzzz .. :)
+    int counter1=0;
+    int counter2=0;
+    int counter3=0;
+    int counter4=0;
+    int counter5=0;
+    int counter6=0;
+    int counter7=0;
+    int counter8=0;
+    int counter9=0;
+    int counter10=0;
+    int counter11=0;
+    int counter12=0;
+    int counter13=0;
+    int counter14=0;
+    int counter15=0;
+    int counter16=0;
+    int counter17=0;
+    int counter18=0;
+    int counter19=0;
+    int counter20=0;
+    int counter21=0;
+    int counter22=0;
+    int counter23=0;
+    int counter24=0;
+    global_server_name = lookup_widget (GTK_WIDGET (widget), "global_server_name");
+    global_server_admin_email = lookup_widget (GTK_WIDGET (widget), "global_server_admin_email");
+    global_server_port = lookup_widget (GTK_WIDGET (widget), "global_server_port");
+    global_max_connect = lookup_widget (GTK_WIDGET (widget), "global_max_connect");
+    global_idle_timeout = lookup_widget (GTK_WIDGET (widget), "global_idle_timeout");
+    global_resume_uploads = lookup_widget (GTK_WIDGET (widget), "global_resume_uploads");
+    global_resume_downloads = lookup_widget (GTK_WIDGET (widget), "global_resume_downloads");
+    global_download_bandwidth = lookup_widget (GTK_WIDGET (widget), "global_download_bandwidth");
+    global_upload_bandwidth = lookup_widget (GTK_WIDGET (widget), "global_upload_bandwidth");
+    global_show_server_identity = lookup_widget (GTK_WIDGET (widget), "global_show_server_identity");
+    global_show_server_identity_on_off = lookup_widget (GTK_WIDGET (widget), "global_show_server_identity_on_off");
+    global_reverse_lookups = lookup_widget (GTK_WIDGET (widget), "global_reverse_lookups");
+    global_default_transfer_mode = lookup_widget (GTK_WIDGET (widget), "global_default_transfer_mode");
+    global_ident_lookups = lookup_widget (GTK_WIDGET (widget), "global_ident_lookups");
+    global_allow_fxp = lookup_widget (GTK_WIDGET (widget), "global_allow_fxp");
+    global_server_user = lookup_widget (GTK_WIDGET (widget), "global_server_user");
+    global_server_group = lookup_widget (GTK_WIDGET (widget), "global_server_group");
+    global_time_standard = lookup_widget (GTK_WIDGET (widget), "global_time_standard");
+    global_max_login_attempts = lookup_widget (GTK_WIDGET (widget), "global_max_login_attempts");
+    global_timeout_login = lookup_widget (GTK_WIDGET (widget), "global_timeout_login");
+    global_delete_aborted_stores = lookup_widget (GTK_WIDGET (widget), "global_delete_aborted_stores");
+    global_read_free_bytes = lookup_widget (GTK_WIDGET (widget), "global_read_free_bytes");
+    global_read_hard_bps = lookup_widget (GTK_WIDGET (widget), "global_read_hard_bps");
+    global_write_free_bytes = lookup_widget (GTK_WIDGET (widget), "global_write_free_bytes");
+    global_write_hard_bps = lookup_widget (GTK_WIDGET (widget), "global_write_hard_bps");
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
+    {
+       strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf\n\n");
+       strcat(info_buffer, "Are you running GProFTPD as root ?.\n");
+       strcat(info_buffer, "im unable to update the global configuration tab\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+    old_Buffer=(char *)malloc(size_buffer);
+    bzero(old_Buffer, sizeof(char) * size_buffer);   
+    new_Buffer=(char *)malloc(size_buffer);               
+    bzero(new_Buffer, sizeof(char) * size_buffer);           
+    while (fgets((char*)old_Buffer, size_buffer, fp)!=NULL)
+    {                                 
+   	   if ((strstr((char*)old_Buffer, "ServerName")!=NULL) && counter1==0)
+	   {   
+	       sprintf((char*)new_Buffer, old_Buffer);
+	       gtk_entry_set_text(GTK_ENTRY (global_server_name), new_Buffer);
+	       gtk_editable_delete_text(GTK_EDITABLE(global_server_name), 0, 12);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_server_name));  // bad
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_server_name), length -2, length);
+	       counter1=1;
+	   }
+   	   if ((strstr((char*)old_Buffer, "ServerAdmin")!=NULL) && counter24==0)
+	   {   
+	       sprintf((char*)new_Buffer, old_Buffer);
+	       gtk_entry_set_text(GTK_ENTRY (global_server_admin_email), new_Buffer);
+	       gtk_editable_delete_text(GTK_EDITABLE(global_server_admin_email), 0, 12);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_server_admin_email));  // bad
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_server_admin_email), length -1, length);
+	       counter24=1;
+	   }
+           // fixme mange set global text
+	   if ((strstr((char*)old_Buffer, "ServerIdent on ")!=NULL) && counter9==0)
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer);
+               gtk_entry_set_text (GTK_ENTRY (global_show_server_identity), new_Buffer);
+	       gtk_entry_set_text (GTK_ENTRY (global_show_server_identity_on_off), "on");
+	       gtk_editable_delete_text (GTK_EDITABLE (global_show_server_identity), 0, 16);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_show_server_identity));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_show_server_identity), length -2, length);
+	       counter9=1;
+	   }
+
+	   if ((strstr((char*)old_Buffer, "ServerIdent off ")!=NULL) && counter9==0)
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer);
+               gtk_entry_set_text (GTK_ENTRY (global_show_server_identity), new_Buffer);
+	       gtk_entry_set_text (GTK_ENTRY (global_show_server_identity_on_off), "off");
+	       gtk_editable_delete_text (GTK_EDITABLE (global_show_server_identity), 0, 17);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_show_server_identity));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_show_server_identity), length -2, length);
+	       counter9=1;
+	   }
+           // Only insert numbers in the spinbutton
+  	   if ((strstr((char*)old_Buffer, "Port ")!=NULL) && counter2==0) 
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_server_port), global_int);
+               counter2=1;
+               begin=0;
+               end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "MaxInstances ")!=NULL) && counter3==0)
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_max_connect), global_int);
+	       counter3=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "TimeoutNoTransfer ")!=NULL) && counter4==0)
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_idle_timeout), global_int);
+	       counter4=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "AllowStoreRestart ")!=NULL) && counter5==0)
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer);
+               gtk_entry_set_text (GTK_ENTRY (global_resume_uploads), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_resume_uploads), 0, 18);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_resume_uploads));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_resume_uploads), length -1, length);
+	       counter5=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "AllowRetrieveRestart ")!=NULL) && counter6==0)
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_resume_downloads), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_resume_downloads), 0, 21);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_resume_downloads));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_resume_downloads), length -1, length);
+	       counter6=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "RateReadBPS ")!=NULL) && counter7==0)
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_upload_bandwidth), global_int);
+	       counter7=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "RateWriteBPS ")!=NULL) && counter8==0)
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_download_bandwidth), global_int);
+	       counter8=1;
+	       begin=0;
+	       end=0;
+	   }
+           if ((strstr((char*)old_Buffer, "UseReverseDNS ")!=NULL) && counter10==0)
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_reverse_lookups), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_reverse_lookups), 0, 14);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_reverse_lookups));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_reverse_lookups), length -1, length);
+	       counter10=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "IdentLookups ")!=NULL) && counter11==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_ident_lookups), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_ident_lookups), 0, 13);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_ident_lookups));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_ident_lookups), length -1, length);
+	       counter11=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "DefaultTransferMode ")!=NULL) && counter12==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_default_transfer_mode), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_default_transfer_mode), 0, 20);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_default_transfer_mode));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_default_transfer_mode), length -1, length);
+	       counter12=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "User ")!=NULL) && counter13==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_server_user), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_server_user), 0, 5);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_server_user));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_server_user), length -1, length);
+	       counter13=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "Group ")!=NULL) && counter14==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_server_group), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_server_group), 0, 6);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_server_group));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_server_group), length -1, length);
+	       counter14=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "AllowForeignAddress ")!=NULL) && counter15==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_allow_fxp), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_allow_fxp), 0, 20);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_allow_fxp));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_allow_fxp), length -1, length);
+	       counter15=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "TimesGMT ")!=NULL) && counter16==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_time_standard), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_time_standard), 0, 9);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_time_standard));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_time_standard), length -1, length);
+	       counter16=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "MaxLoginAttempts ")!=NULL) && counter17==0) 
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_max_login_attempts), global_int);
+	       counter17=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "TimeoutLogin ")!=NULL) && counter18==0) 
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_timeout_login), global_int);
+	       counter18=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "DeleteAbortedStores ")!=NULL) && counter19==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_delete_aborted_stores), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_delete_aborted_stores), 0, 20);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_delete_aborted_stores));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_delete_aborted_stores), length -1, length);
+	       counter19=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "RateReadFreeBytes ")!=NULL) && counter20==0) 
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_read_free_bytes), global_int);
+	       counter20=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "RateReadHardBPS ")!=NULL) && counter21==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_read_hard_bps), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_read_hard_bps), 0, 16);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_read_hard_bps));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_read_hard_bps), length -1, length);
+	       counter21=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "RateWriteFreeBytes ")!=NULL) && counter22==0) 
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_write_free_bytes), global_int);
+	       counter22=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "RateWriteHardBPS ")!=NULL) && counter23==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer);
+               gtk_entry_set_text (GTK_ENTRY (global_write_hard_bps), new_Buffer);
+	       gtk_editable_delete_text (GTK_EDITABLE (global_write_hard_bps), 0, 17);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_write_hard_bps));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_write_hard_bps), length -1, length);
+	       counter23=1;
+	   }
+    }
+    fclose(fp);
+    free(old_Buffer);
+    free(new_Buffer);
+}
+
+
+// OK
+ftp_who_update()
+{
+    /* Timer update for ftpwho and on/offline status */
+    FILE *ftpwho;
+    FILE *status_file;
+    char *status_buffer;
+    int length;
+    int result=0;
+    gchar *utf8_text=NULL;
+    char ftp_who_buffer[BUFSIZ]=""; 
+    char ftp_who_get_buffer[BUFSIZ]="";
+    char string[]="proftpd:";
+    GtkTextBuffer *ftp_who_text_buffer;
+    /* FTP who update */
+    if ( (ftpwho = popen("ftpwho -v", "r")) == NULL)
+    {
+       return( 0 );
+    }
+    while (fgets(ftp_who_buffer, BUFSIZ, ftpwho)!=NULL)
+    {
+       strcat(ftp_who_get_buffer, ftp_who_buffer);
+    }
+    pclose(ftpwho);
+    strcat(ftp_who_get_buffer, "\n"); /* must end with newline */
+    utf8_text = g_locale_to_utf8(ftp_who_get_buffer, strlen(ftp_who_get_buffer), NULL, NULL, NULL);
+    ftp_who_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(ftp_who_textview));
+    gtk_text_buffer_set_text(ftp_who_text_buffer, utf8_text, strlen(utf8_text));
+    if(utf8_text !=NULL)
+    g_free(utf8_text);
+
+    /* On - offline checker */
+    if(update==1) /* so it wont draw unnessesary cpu or leve zombies of ps */
+    {
+        update=0;
+        if ( (status_file = popen("ps -aux |grep \"proftpd: (accept\" |awk '{print $11}'", "r")) == NULL)
+        {
+           printf("popen failed trying ps");   
+           exit(1);
+        }
+        status_buffer=(char *)malloc(1024);
+        bzero(status_buffer, sizeof(char) * 1024);
+        while (fgets(status_buffer, 1024, status_file)!=NULL)
+        {
+        }
+        result=strcmp(string, status_buffer);
+        free(status_buffer);
+        pclose(status_file);
+        if (result <= 0 )
+        {
+            gtk_entry_set_text(GTK_ENTRY (on_offline_entry), "  In an ON - LINE state");
+        }
+        else
+           {
+               gtk_entry_set_text(GTK_ENTRY (on_offline_entry), "  In an OFF - LINE state");
+           }
+           update=1;
+    } /* if it ready for an update */
+    return ( TRUE );
+}
+
+
+/* OK .. ETH0 .. doesnt show local ULs/DLs */
+speed_update()
+{
+    FILE *speed_file;
+    int int_speed_1, int_speed_2, int_speed;
+    turns++;
+    if ( turns == 1 )
+    {                            
+        // first round buffers null
+        strcpy(in_speed_1_buffer,"");
+        strcpy(out_speed_1_buffer,"");
+
+        // Get incoming speed 1 
+        if ( (speed_file = popen("netstat -i -n -b | grep en0 | head -n1 | awk '{print $7}' |tr -d \"\r\n\"", "r")) == NULL)
+        {
+           printf("cant open en0");
+           return( 0 );      
+        }
+        while (fgets(in_speed_1_buffer, 4096, speed_file)!=NULL)
+        {
+        }
+        pclose(speed_file);
+        // Get outgoing speed 1
+        if ( (speed_file = popen("netstat -i -n -b | grep en0 | head -n1 | awk '{print $10}' |tr -d \"\r\n\"", "r")) == NULL)
+        {
+           printf("cant open en0");
+           return( 0 );
+        }
+        while (fgets(out_speed_1_buffer, 4096, speed_file)!=NULL)
+        {
+        }
+        pclose(speed_file);
+    }
+    else
+       {
+          // After one second
+          if ( turns == 2 )
+          {                    
+             char total_in_speed_buffer[8192]="";
+             char total_out_speed_buffer[8192]="";
+
+             char in_speed_2_buffer[4096]="";
+             char out_speed_2_buffer[4096]="";
+       
+             // Get incoming speed 2
+             if ( (speed_file = popen("netstat -i -n -b | grep en0 | head -n1 | awk '{print $7}' |tr -d \"\r\n\"", "r")) == NULL)
+             {
+                printf("cant open en0");
+                return( 0 );   
+             }
+             while (fgets(in_speed_2_buffer, 4096, speed_file)!=NULL)
+             {
+             }
+             pclose(speed_file);
+
+             // Get outgoing speed 2
+             if ( (speed_file = popen("netstat -i -n -b | grep en0 | head -n1 | awk '{print $10}' |tr -d \"\r\n\"", "r")) == NULL)
+             {
+             printf("cant open en0");
+             return( 0 );      
+             }
+             while (fgets(out_speed_2_buffer, 4096, speed_file)!=NULL)
+             {
+             }
+             pclose(speed_file);
+             // In speed
+             // BUFFER to INT
+             int_speed_1 = atoi(in_speed_1_buffer);
+             int_speed_2 = atoi(in_speed_2_buffer);
+             int_speed = int_speed_2 - int_speed_1;
+             // INT to BUFFER
+             sprintf(total_in_speed_buffer, "%d", int_speed);
+             gtk_entry_set_text(GTK_ENTRY (incoming_entry), total_in_speed_buffer);
+
+             // Out speed
+             // BUFFER to INT
+             int_speed_1 = atoi(out_speed_1_buffer);
+             int_speed_2 = atoi(out_speed_2_buffer);
+             int_speed = int_speed_2 - int_speed_1;
+             // INT to BUFFER
+             sprintf(total_out_speed_buffer, "%d", int_speed);
+             gtk_entry_set_text(GTK_ENTRY (outgoing_entry), total_out_speed_buffer);
+             turns = 0;
+          }
+       }
+       return( TRUE );
+}
+
+
+// OK
+void
+on_on_offline_entry_map                (GtkWidget       *widget,
+                                        gpointer         user_data)
+{
+    incoming_entry = lookup_widget (GTK_WIDGET (widget), "incoming_entry");
+    outgoing_entry = lookup_widget (GTK_WIDGET (widget), "outgoing_entry");
+    on_offline_entry = lookup_widget (GTK_WIDGET (widget), "on_offline_entry");
+    ftp_who_textview = lookup_widget (GTK_WIDGET (widget), "ftp_who_textview");
+    gtk_timeout_add( 1000, (GtkFunction) ftp_who_update, user_data); // ftpwho and on offline status
+    gtk_timeout_add( 1000, (GtkFunction) speed_update, user_data); // Bytes / sec
+}
+
+
+// OK .. fgets error
+void
+on_version_entry_map                   (GtkWidget       *widget,
+                                        gpointer         user_data)
+{
+    // Insert version and profile 
+    FILE *fp;
+    int length;
+    char *profilebuffer;
+    char *versionbuffer;
+    char *get_buffer;
+    long size_buffer;
+    GtkTextBuffer *text_buffer;
+    gchar *utf8=NULL;            
+    // Inserts the user profile when gproftpd is started 
+    // ( because otherwise it wont have mapped if the user just adds a user not looking at the profile tab) 
+    if ( (fp = fopen("@FINKPREFIX@/etc/gproftpd/useradd-profile", "r")) == NULL)
+    {
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/etc/gproftpd/useradd-profile\n");
+       strcat(info_buffer, "dont add users if this happens.\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    // Set the profile_tab_text from @FINKPREFIX@/etc/gproftpd/useradd-profile
+    profile_text = lookup_widget (GTK_WIDGET (widget), "profile_text");
+
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+
+    profilebuffer=(char *)malloc(size_buffer);
+    bzero(profilebuffer, sizeof(char) * size_buffer);   
+
+    get_buffer=(char *)malloc(size_buffer+8192);
+    bzero(get_buffer, sizeof(char) * size_buffer+8192);   
+
+
+    versionbuffer=(char *)malloc(4096);	     
+    bzero(versionbuffer, sizeof(char) * 4096);   
+
+
+    text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(profile_text));
+
+    while (fgets(profilebuffer, size_buffer, fp)!=NULL)
+    {
+       strcat(get_buffer, profilebuffer);
+    }
+    strcat(get_buffer, "\n");
+    utf8 = g_locale_to_utf8(get_buffer, strlen(get_buffer), NULL, NULL, NULL);
+    gtk_text_buffer_set_text(text_buffer, utf8, strlen(utf8));
+    fclose (fp);
+    free(profilebuffer);
+
+    // Set version in the version entry
+    if ( (fp = popen("proftpd -v 2>&1 |awk '{print \"Proftpd version: \",$4}' |tr -d \"\r\n\" > /tmp/gproftpd_version", "r")) == NULL)
+    {
+        strcat(info_buffer, "Cant get status from \"proftpd -v\".\n");
+        strcat(info_buffer, "Try running GProFTPD as root.\n");
+        error_window = create_error_window ();
+        gtk_widget_show (error_window);
+        return; 
+    }
+    pclose(fp);
+
+    // Sometimes reading it in didnt show the value ??? 
+    if ( (fp = fopen("/tmp/gproftpd_version", "r")) == NULL)
+    {
+        strcat(info_buffer, "Cant get status from \"proftpd -v\".\n");
+        strcat(info_buffer, "Try running GProFTPD as root.\n");
+        error_window = create_error_window ();
+        gtk_widget_show (error_window);
+        return; 
+    }
+
+
+
+    version_entry = lookup_widget (GTK_WIDGET (widget), "version_entry");
+
+    // Crap
+    while((fgets(versionbuffer, 4096, fp)!=NULL))
+    {
+    }
+
+    utf8 = g_locale_to_utf8(versionbuffer, strlen(versionbuffer), NULL, NULL, NULL);
+    gtk_entry_set_text(GTK_ENTRY (version_entry), utf8);
+    fclose(fp);
+    system("rm -f /tmp/gproftpd_version");
+    free(versionbuffer);
+    if(utf8 !=NULL)
+    g_free(utf8);
+}
+
+
+// OK
+void
+on_server_info_entry_map               (GtkWidget       *widget,
+                                        gpointer         user_data)
+{
+    // Update the global configuration tab .. placed it here cause of unneccesary mappage
+    FILE *fp;
+    long size_buffer;
+    char *old_Buffer;
+    char *new_Buffer;
+    const gchar *length_buffer;
+    int begin = 0;
+    int end = 0;
+    int x;
+    int global_int;
+    int length=0;
+    int counter1=0;
+    int counter2=0;
+    int counter3=0;
+    int counter4=0;
+    int counter5=0;
+    int counter6=0;
+    int counter7=0;
+    int counter8=0;
+    int counter9=0;
+    int counter10=0;
+    int counter11=0;
+    int counter12=0;
+    int counter13=0;
+    int counter14=0;
+    int counter15=0;
+    int counter16=0;
+    int counter17=0;
+    int counter18=0;
+    int counter19=0;
+    int counter20=0;
+    int counter21=0;
+    int counter22=0;
+    int counter23=0;
+    int counter24=0;
+    global_server_name = lookup_widget (GTK_WIDGET (widget), "global_server_name");
+    global_server_admin_email = lookup_widget (GTK_WIDGET (widget), "global_server_admin_email");
+    global_server_port = lookup_widget (GTK_WIDGET (widget), "global_server_port");
+    global_max_connect = lookup_widget (GTK_WIDGET (widget), "global_max_connect");
+    global_idle_timeout = lookup_widget (GTK_WIDGET (widget), "global_idle_timeout");
+    global_resume_uploads = lookup_widget (GTK_WIDGET (widget), "global_resume_uploads");
+    global_resume_downloads = lookup_widget (GTK_WIDGET (widget), "global_resume_downloads");
+    global_download_bandwidth = lookup_widget (GTK_WIDGET (widget), "global_download_bandwidth");
+    global_upload_bandwidth = lookup_widget (GTK_WIDGET (widget), "global_upload_bandwidth");
+    global_show_server_identity = lookup_widget (GTK_WIDGET (widget), "global_show_server_identity");
+    global_show_server_identity_on_off = lookup_widget (GTK_WIDGET (widget), "global_show_server_identity_on_off");
+    global_reverse_lookups = lookup_widget (GTK_WIDGET (widget), "global_reverse_lookups");
+    global_default_transfer_mode = lookup_widget (GTK_WIDGET (widget), "global_default_transfer_mode");
+    global_ident_lookups = lookup_widget (GTK_WIDGET (widget), "global_ident_lookups");
+    global_allow_fxp = lookup_widget (GTK_WIDGET (widget), "global_allow_fxp");
+    global_server_user = lookup_widget (GTK_WIDGET (widget), "global_server_user");
+    global_server_group = lookup_widget (GTK_WIDGET (widget), "global_server_group");
+    global_time_standard = lookup_widget (GTK_WIDGET (widget), "global_time_standard");
+    global_max_login_attempts = lookup_widget (GTK_WIDGET (widget), "global_max_login_attempts");
+    global_timeout_login = lookup_widget (GTK_WIDGET (widget), "global_timeout_login");
+    global_delete_aborted_stores = lookup_widget (GTK_WIDGET (widget), "global_delete_aborted_stores");
+    global_read_free_bytes = lookup_widget (GTK_WIDGET (widget), "global_read_free_bytes");
+    global_read_hard_bps = lookup_widget (GTK_WIDGET (widget), "global_read_hard_bps");
+    global_write_free_bytes = lookup_widget (GTK_WIDGET (widget), "global_write_free_bytes");
+    global_write_hard_bps = lookup_widget (GTK_WIDGET (widget), "global_write_hard_bps");
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
+    {
+       strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf\n\n");
+       strcat(info_buffer, "If youre running GProFTPD as root, close this window then press\n");
+       strcat(info_buffer, "the entire configuration tab then press the default button\n"); 
+       strcat(info_buffer, "wich will set the default configuration to @FINKPREFIX@/etc/proftpd.conf\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+    old_Buffer=(char *)malloc(size_buffer);
+    bzero(old_Buffer, sizeof(char) * size_buffer);   
+    new_Buffer=(char *)malloc(size_buffer);               
+    bzero(new_Buffer, sizeof(char) * size_buffer);           
+    while (fgets((char*)old_Buffer, size_buffer, fp)!=NULL)
+    {                                 
+   	   if ((strstr((char*)old_Buffer, "ServerName")!=NULL) && counter1==0)
+	   {   
+	       sprintf((char*)new_Buffer, old_Buffer);
+	       gtk_entry_set_text(GTK_ENTRY (global_server_name), new_Buffer);
+	       gtk_editable_delete_text(GTK_EDITABLE(global_server_name), 0, 12);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_server_name));  // bad
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_server_name), length -2, length);
+	       counter1=1;
+	   }
+   	   if ((strstr((char*)old_Buffer, "ServerAdmin")!=NULL) && counter24==0)
+	   {   
+	       sprintf((char*)new_Buffer, old_Buffer);
+	       gtk_entry_set_text(GTK_ENTRY (global_server_admin_email), new_Buffer);
+	       gtk_editable_delete_text(GTK_EDITABLE(global_server_admin_email), 0, 12);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_server_admin_email));  // bad
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_server_admin_email), length -1, length);
+	       counter24=1;
+	   }
+	   // fixme mange
+	   if ((strstr((char*)old_Buffer, "ServerIdent on ")!=NULL) && counter9==0)
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer);
+               gtk_entry_set_text (GTK_ENTRY (global_show_server_identity), new_Buffer);    
+	       gtk_entry_set_text (GTK_ENTRY (global_show_server_identity_on_off), "on");    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_show_server_identity), 0, 16);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_show_server_identity));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_show_server_identity), length -2, length);
+	       counter9=1;
+	   }
+
+	   if ((strstr((char*)old_Buffer, "ServerIdent off ")!=NULL) && counter9==0)
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer);
+               gtk_entry_set_text (GTK_ENTRY (global_show_server_identity), new_Buffer);
+	       gtk_entry_set_text (GTK_ENTRY (global_show_server_identity_on_off), "off");    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_show_server_identity), 0, 17);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_show_server_identity));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_show_server_identity), length -2, length);
+	       counter9=1;
+	   }
+
+
+  	   if ((strstr((char*)old_Buffer, "Port ")!=NULL) && counter2==0) 
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_server_port), global_int);
+               counter2=1;
+               begin=0;
+               end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "MaxInstances ")!=NULL) && counter3==0)
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_max_connect), global_int);
+	       counter3=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "TimeoutNoTransfer ")!=NULL) && counter4==0)
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_idle_timeout), global_int);
+	       counter4=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "AllowStoreRestart ")!=NULL) && counter5==0)
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer);
+               gtk_entry_set_text (GTK_ENTRY (global_resume_uploads), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_resume_uploads), 0, 18);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_resume_uploads));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_resume_uploads), length -1, length);
+	       counter5=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "AllowRetrieveRestart ")!=NULL) && counter6==0)
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_resume_downloads), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_resume_downloads), 0, 21);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_resume_downloads));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_resume_downloads), length -1, length);
+	       counter6=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "RateReadBPS ")!=NULL) && counter7==0)
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_upload_bandwidth), global_int);
+	       counter7=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "RateWriteBPS ")!=NULL) && counter8==0)
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_download_bandwidth), global_int);
+	       counter8=1;
+	       begin=0;
+	       end=0;
+	   }
+           if ((strstr((char*)old_Buffer, "UseReverseDNS ")!=NULL) && counter10==0)
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_reverse_lookups), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_reverse_lookups), 0, 14);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_reverse_lookups));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_reverse_lookups), length -1, length);
+	       counter10=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "IdentLookups ")!=NULL) && counter11==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_ident_lookups), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_ident_lookups), 0, 13);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_ident_lookups));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_ident_lookups), length -1, length);
+	       counter11=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "DefaultTransferMode ")!=NULL) && counter12==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_default_transfer_mode), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_default_transfer_mode), 0, 20);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_default_transfer_mode));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_default_transfer_mode), length -1, length);
+	       counter12=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "User ")!=NULL) && counter13==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_server_user), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_server_user), 0, 5);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_server_user));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_server_user), length -1, length);
+	       counter13=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "Group ")!=NULL) && counter14==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_server_group), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_server_group), 0, 6);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_server_group));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_server_group), length -1, length);
+	       counter14=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "AllowForeignAddress ")!=NULL) && counter15==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_allow_fxp), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_allow_fxp), 0, 20);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_allow_fxp));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_allow_fxp), length -1, length);
+	       counter15=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "TimesGMT ")!=NULL) && counter16==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_time_standard), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_time_standard), 0, 9);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_time_standard));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_time_standard), length -1, length);
+	       counter16=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "MaxLoginAttempts ")!=NULL) && counter17==0) 
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_max_login_attempts), global_int);
+	       counter17=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "TimeoutLogin ")!=NULL) && counter18==0) 
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_timeout_login), global_int);
+	       counter18=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "DeleteAbortedStores ")!=NULL) && counter19==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_delete_aborted_stores), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_delete_aborted_stores), 0, 20);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_delete_aborted_stores));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_delete_aborted_stores), length -1, length);
+	       counter19=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "RateReadFreeBytes ")!=NULL) && counter20==0) 
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_read_free_bytes), global_int);
+	       counter20=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "RateReadHardBPS ")!=NULL) && counter21==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer); 
+               gtk_entry_set_text (GTK_ENTRY (global_read_hard_bps), new_Buffer);    
+	       gtk_editable_delete_text (GTK_EDITABLE (global_read_hard_bps), 0, 16);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_read_hard_bps));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_read_hard_bps), length -1, length);
+	       counter21=1;
+	   }
+	   if ((strstr((char*)old_Buffer, "RateWriteFreeBytes ")!=NULL) && counter22==0) 
+	   {
+               for (x = 0; x < strlen(old_Buffer); x++) 
+               {
+                  if (begin == 0 && (old_Buffer[x] >= '0' && old_Buffer[x] <= '9')) 
+                  {
+                     begin = x;
+                     continue;
+                  }
+                  end = x;
+               }
+               snprintf(new_Buffer, end-begin+1, "%s", old_Buffer+begin);
+               global_int = atoi(new_Buffer);
+               gtk_spin_button_set_value(GTK_SPIN_BUTTON(global_write_free_bytes), global_int);
+	       counter22=1;
+	       begin=0;
+	       end=0;
+	   }
+	   if ((strstr((char*)old_Buffer, "RateWriteHardBPS ")!=NULL) && counter23==0) 
+	   {
+	       sprintf((char*)new_Buffer, old_Buffer);
+               gtk_entry_set_text (GTK_ENTRY (global_write_hard_bps), new_Buffer);
+	       gtk_editable_delete_text (GTK_EDITABLE (global_write_hard_bps), 0, 17);
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(global_write_hard_bps));
+	       length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(global_write_hard_bps), length -1, length);
+	       counter23=1;
+	   }
+    }
+    fclose(fp);
+    free(old_Buffer);
+    free(new_Buffer);
+}
+
+
+// OK
+void
+on_global_change_button_clicked        (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    // The Global tabs "change all" button.
+    FILE *fp;
+    char *szBuffer;
+    char *edited_config;
+    char *profile_buffer;
+    char *change_srv_ident;
+    long size_buffer;
+    int length;
+    char *buffer;
+    int counter1=0;
+    int counter2=0;
+    int counter3=0;
+    int counter4=0;
+    int counter5=0;
+    int counter6=0;
+    int counter7=0;
+    int counter8=0;
+    int counter9=0;
+    int counter10=0;
+    int counter11=0;
+    int counter12=0;
+    int counter13=0;
+    int counter14=0;
+    int counter15=0;
+    int counter16=0;
+    int counter17=0;
+    int counter18=0;
+    int counter19=0;
+    int counter20=0;
+    int counter21=0;
+    int counter22=0;
+    int counter23=0;
+    int counter24=0;
+    G_CONST_RETURN gchar *current_change_name;
+    G_CONST_RETURN gchar *current_change_server_admin;
+    G_CONST_RETURN gchar *current_change_port;
+    G_CONST_RETURN gchar *current_change_max_connect;
+    G_CONST_RETURN gchar *current_change_no_transfer;
+    G_CONST_RETURN gchar *current_change_identity;
+
+    // fixme mange
+    G_CONST_RETURN gchar *current_change_identity_on_off;
+
+    G_CONST_RETURN gchar *current_change_transfer_mode;
+    G_CONST_RETURN gchar *current_change_ident_lookups;
+    G_CONST_RETURN gchar *current_change_reverse_lookups;
+    G_CONST_RETURN gchar *current_change_server_user;
+    G_CONST_RETURN gchar *current_change_server_group;
+    G_CONST_RETURN gchar *current_change_allow_fxp;
+    G_CONST_RETURN gchar *current_change_time_standard;
+    G_CONST_RETURN gchar *current_change_max_login_attempts;
+    G_CONST_RETURN gchar *current_change_timeout_login;
+    G_CONST_RETURN gchar *current_change_resume_dl;
+    G_CONST_RETURN gchar *current_change_download_bandwidth;
+    G_CONST_RETURN gchar *current_change_read_free_bytes;
+    G_CONST_RETURN gchar *current_change_read_hard_bps;
+    G_CONST_RETURN gchar *current_change_resume_ul;
+    G_CONST_RETURN gchar *current_change_upload_bandwidth;
+    G_CONST_RETURN gchar *current_change_write_free_bytes;
+    G_CONST_RETURN gchar *current_change_write_hard_bps;
+    G_CONST_RETURN gchar *current_change_delete_aborted_stores;
+    global_server_name = lookup_widget (GTK_WIDGET (button), "global_server_name");
+    global_server_admin_email = lookup_widget (GTK_WIDGET (button), "global_server_admin_email");    
+    global_server_port = lookup_widget (GTK_WIDGET (button), "global_server_port");
+    global_max_connect = lookup_widget (GTK_WIDGET (button), "global_max_connect");
+    global_idle_timeout = lookup_widget (GTK_WIDGET (button), "global_idle_timeout");
+    global_resume_uploads = lookup_widget (GTK_WIDGET (button), "global_resume_uploads");
+    global_resume_downloads = lookup_widget (GTK_WIDGET (button), "global_resume_downloads");
+    global_download_bandwidth = lookup_widget (GTK_WIDGET (button), "global_download_bandwidth");
+    global_upload_bandwidth = lookup_widget (GTK_WIDGET (button), "global_upload_bandwidth");
+    global_show_server_identity = lookup_widget (GTK_WIDGET (button), "global_show_server_identity");
+    global_show_server_identity_on_off = lookup_widget (GTK_WIDGET (button), "global_show_server_identity_on_off");
+    global_reverse_lookups = lookup_widget (GTK_WIDGET (button), "global_reverse_lookups");
+    global_default_transfer_mode = lookup_widget (GTK_WIDGET (button), "global_default_transfer_mode");
+    global_ident_lookups = lookup_widget (GTK_WIDGET (button), "global_ident_lookups");
+    global_allow_fxp = lookup_widget (GTK_WIDGET (button), "global_allow_fxp");
+    global_server_user = lookup_widget (GTK_WIDGET (button), "global_server_user");
+    global_server_group = lookup_widget (GTK_WIDGET (button), "global_server_group");
+    global_time_standard = lookup_widget (GTK_WIDGET (button), "global_time_standard");
+    global_max_login_attempts = lookup_widget (GTK_WIDGET (button), "global_max_login_attempts");
+    global_timeout_login = lookup_widget (GTK_WIDGET (button), "global_timeout_login");
+    global_delete_aborted_stores = lookup_widget (GTK_WIDGET (button), "global_delete_aborted_stores");
+    global_read_free_bytes = lookup_widget (GTK_WIDGET (button), "global_read_free_bytes");
+    global_read_hard_bps = lookup_widget (GTK_WIDGET (button), "global_read_hard_bps");
+    global_write_free_bytes = lookup_widget (GTK_WIDGET (button), "global_write_free_bytes");
+    global_write_hard_bps = lookup_widget (GTK_WIDGET (button), "global_write_hard_bps");
+    entire_config_textview = lookup_widget (GTK_WIDGET (button), "entire_config_textview");
+    current_change_name = gtk_entry_get_text(GTK_ENTRY(global_server_name));
+    current_change_server_admin = gtk_entry_get_text(GTK_ENTRY(global_server_admin_email));
+    current_change_port = gtk_entry_get_text(GTK_ENTRY(global_server_port));
+    current_change_max_connect = gtk_entry_get_text(GTK_ENTRY(global_max_connect));
+    current_change_no_transfer = gtk_entry_get_text(GTK_ENTRY(global_idle_timeout));
+    current_change_resume_ul = gtk_entry_get_text(GTK_ENTRY(global_resume_uploads));
+    current_change_resume_dl = gtk_entry_get_text(GTK_ENTRY(global_resume_downloads));
+    current_change_upload_bandwidth = gtk_entry_get_text(GTK_ENTRY(global_upload_bandwidth));
+    current_change_download_bandwidth = gtk_entry_get_text(GTK_ENTRY(global_download_bandwidth));
+    current_change_identity = gtk_entry_get_text(GTK_ENTRY(global_show_server_identity));
+
+    // fixme mange
+    current_change_identity_on_off = gtk_entry_get_text(GTK_ENTRY(global_show_server_identity_on_off));
+    
+    current_change_reverse_lookups = gtk_entry_get_text(GTK_ENTRY(global_reverse_lookups));
+    current_change_transfer_mode = gtk_entry_get_text(GTK_ENTRY(global_default_transfer_mode));
+    current_change_ident_lookups = gtk_entry_get_text(GTK_ENTRY(global_ident_lookups));
+    current_change_server_user = gtk_entry_get_text(GTK_ENTRY(global_server_user));
+    current_change_server_group = gtk_entry_get_text(GTK_ENTRY(global_server_group));
+    current_change_allow_fxp = gtk_entry_get_text(GTK_ENTRY(global_allow_fxp));
+    current_change_time_standard = gtk_entry_get_text(GTK_ENTRY(global_time_standard));
+    current_change_max_login_attempts = gtk_entry_get_text(GTK_ENTRY(global_max_login_attempts));
+    current_change_timeout_login = gtk_entry_get_text(GTK_ENTRY(global_timeout_login));
+    current_change_delete_aborted_stores = gtk_entry_get_text(GTK_ENTRY(global_delete_aborted_stores));
+    current_change_read_free_bytes = gtk_entry_get_text(GTK_ENTRY(global_read_free_bytes));
+    current_change_read_hard_bps = gtk_entry_get_text(GTK_ENTRY(global_read_hard_bps));       // disqualified :)
+    current_change_write_free_bytes = gtk_entry_get_text(GTK_ENTRY(global_write_free_bytes));
+    current_change_write_hard_bps = gtk_entry_get_text(GTK_ENTRY(global_write_hard_bps));
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
+    {
+       strcpy(info_buffer, "\nCant open @FINKPREFIX@/etc/proftpd.conf\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+
+    // fixme mange
+    change_srv_ident=(char *)malloc(1024);        
+    bzero(change_srv_ident, sizeof(char) * 1024); 
+
+    profile_buffer=(char *)malloc(size_buffer + 4096);
+    bzero(profile_buffer, sizeof(char) * size_buffer + 4096);
+    edited_config=(char *)malloc(size_buffer + 4096);
+    bzero(edited_config, sizeof(char) * size_buffer + 4096);
+    szBuffer=(char *)malloc(size_buffer + 4096);        
+    bzero(szBuffer, sizeof(char) * size_buffer + 4096); 
+    while (fgets((char*)szBuffer, size_buffer, fp)!=NULL)
+    {
+         if ((strstr((char*)szBuffer, "ServerName")!=NULL) && counter1==0) 
+         {          	
+            sprintf((char*)szBuffer, "ServerName \"%s\"\n",current_change_name );
+            strcat(edited_config, szBuffer);
+            counter1=1;                 
+         }
+         if ((strstr((char*)szBuffer, "ServerAdmin")!=NULL) && counter24==0)
+         {
+            sprintf((char*)szBuffer, "ServerAdmin %s\n",current_change_server_admin );
+            strcat(edited_config, szBuffer);
+            counter24=1;
+         }
+         if ((strstr((char*)szBuffer, "Port")!=NULL) && counter2==0)
+         {
+            sprintf((char*)szBuffer, "Port %s\n",current_change_port );
+            strcat(edited_config, szBuffer);
+            counter2=1;
+         }
+         if ((strstr((char*)szBuffer, "MaxInstances")!=NULL) && counter3==0)
+         {
+	      sprintf((char*)szBuffer, "MaxInstances %s\n",current_change_max_connect);
+              strcat(edited_config, szBuffer);
+	      counter3=1;
+         }
+         if ((strstr((char*)szBuffer, "TimeoutNoTransfer")!=NULL) && counter4==0)
+         {
+	      sprintf((char*)szBuffer, "TimeoutNoTransfer %s\n",current_change_no_transfer);
+              strcat(edited_config, szBuffer);
+	      counter4=1;
+	 }
+         if ((strstr((char*)szBuffer, "AllowStoreRestart")!=NULL) && counter5==0)
+         {
+	      sprintf((char*)szBuffer, "AllowStoreRestart %s\n",current_change_resume_ul);
+              strcat(edited_config, szBuffer);
+	      counter5=1;
+	 }
+         if ((strstr((char*)szBuffer, "AllowRetrieveRestart")!=NULL) && counter6==0)
+	 {
+	      sprintf((char*)szBuffer, "AllowRetrieveRestart %s\n",current_change_resume_dl);
+              strcat(edited_config, szBuffer);
+	      counter6=1;
+	 }
+         if ((strstr((char*)szBuffer, "RateReadBPS")!=NULL) && counter7==0)
+	 {
+	      sprintf((char*)szBuffer, "RateReadBPS %s\n",current_change_download_bandwidth);
+              strcat(edited_config, szBuffer);
+	      counter7=1;
+	 }
+         if ((strstr((char*)szBuffer, "RateWriteBPS")!=NULL) && counter8==0)
+	 {
+	      sprintf((char*)szBuffer, "RateWriteBPS %s\n",current_change_upload_bandwidth);
+              strcat(edited_config, szBuffer);
+	      counter8=1;
+	 }
+	 
+	 // fixme mange
+         if ((strstr((char*)szBuffer, "ServerIdent ")!=NULL) && counter9==0)
+	 {
+            strcat(change_srv_ident, current_change_identity_on_off);
+	    strcat(change_srv_ident, " \"");
+	    strcat(change_srv_ident, current_change_identity);
+	    strcat(change_srv_ident, "\"");
+	    
+	    sprintf((char*)szBuffer, "ServerIdent %s\n",change_srv_ident);
+            strcat(edited_config, szBuffer);
+	    counter9=1;
+	 }
+         if ((strstr((char*)szBuffer, "UseReverseDNS ")!=NULL) && counter10==0)
+	 {
+	    sprintf((char*)szBuffer, "UseReverseDNS %s\n",current_change_reverse_lookups);
+            strcat(edited_config, szBuffer);
+	    counter10=1;
+	 }
+         if ((strstr((char*)szBuffer, "IdentLookups ")!=NULL) && counter11==0) 
+	 {
+	    sprintf((char*)szBuffer, "IdentLookups %s\n",current_change_ident_lookups);
+            strcat(edited_config, szBuffer);
+	    counter11=1;
+	 }
+         if ((strstr((char*)szBuffer, "DefaultTransferMode ")!=NULL) && counter12==0) 
+	 {
+	    sprintf((char*)szBuffer, "DefaultTransferMode %s\n",current_change_transfer_mode);
+            strcat(edited_config, szBuffer);
+	    counter12=1;
+	 }
+         if ((strstr((char*)szBuffer, "User ")!=NULL) && counter13==0) 
+	 {
+	    sprintf((char*)szBuffer, "User %s\n",current_change_server_user);
+            strcat(edited_config, szBuffer);
+	    counter13=1;
+	 }
+         if ((strstr((char*)szBuffer, "Group ")!=NULL) && counter14==0) 
+	 {
+	    sprintf((char*)szBuffer, "Group %s\n",current_change_server_group);
+            strcat(edited_config, szBuffer);
+	    counter14=1;
+	 }
+         if ((strstr((char*)szBuffer, "AllowForeignAddress ")!=NULL) && counter15==0) 
+	 {
+	    sprintf((char*)szBuffer, "AllowForeignAddress %s\n",current_change_allow_fxp);
+            strcat(edited_config, szBuffer);
+	    counter15=1;
+	 }
+         if ((strstr((char*)szBuffer, "TimesGMT ")!=NULL) && counter16==0) 
+	 {
+	    sprintf((char*)szBuffer, "TimesGMT %s\n",current_change_time_standard);
+            strcat(edited_config, szBuffer);
+	    counter16=1;
+	 }
+         if ((strstr((char*)szBuffer, "MaxLoginAttempts ")!=NULL) && counter17==0) 
+	 {
+	    sprintf((char*)szBuffer, "MaxLoginAttempts %s\n",current_change_max_login_attempts);
+            strcat(edited_config, szBuffer);
+	    counter17=1;
+	 }
+         if ((strstr((char*)szBuffer, "TimeoutLogin ")!=NULL) && counter18==0) 
+	 {
+	    sprintf((char*)szBuffer, "TimeoutLogin %s\n",current_change_timeout_login);
+            strcat(edited_config, szBuffer);
+	    counter18=1;
+	 }
+         if ((strstr((char*)szBuffer, "DeleteAbortedStores ")!=NULL) && counter19==0) 
+	 {
+	      sprintf((char*)szBuffer, "DeleteAbortedStores %s\n",current_change_delete_aborted_stores);
+              strcat(edited_config, szBuffer);
+	      counter19=1;
+	 }
+         if ((strstr((char*)szBuffer, "RateReadFreeBytes ")!=NULL) && counter20==0) 
+	 {
+	      sprintf((char*)szBuffer, "RateReadFreeBytes %s\n",current_change_read_free_bytes);
+              strcat(edited_config, szBuffer);
+	      counter20=1;
+	 }
+         if ((strstr((char*)szBuffer, "RateReadHardBPS ")!=NULL) && counter21==0) 
+	 {
+	      sprintf((char*)szBuffer, "RateReadHardBPS %s\n",current_change_read_hard_bps);
+              strcat(edited_config, szBuffer);
+	      counter21=1;
+	 }
+         if ((strstr((char*)szBuffer, "RateWriteFreeBytes ")!=NULL) && counter22==0) 
+	 {
+	      sprintf((char*)szBuffer, "RateWriteFreeBytes %s\n",current_change_write_free_bytes);
+              strcat(edited_config, szBuffer);
+	      counter22=1;
+	 }
+         if ((strstr((char*)szBuffer, "RateWriteHardBPS ")!=NULL) && counter23==0) 
+         {
+	      sprintf((char*)szBuffer, "RateWriteHardBPS %s\n",current_change_write_hard_bps);
+              strcat(edited_config, szBuffer);
+	      counter23=1;
+	 }
+         strcat(profile_buffer, szBuffer);
+    }
+    fclose(fp);
+    free(szBuffer);
+    free(change_srv_ident);
+    // Write the edited configuration to proftpd.conf
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "w+")) == NULL)
+    {
+       strcpy(info_buffer, "\nCant open @FINKPREFIX@/etc/proftpd.conf for writing\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    strcpy(edited_config, profile_buffer);
+    fputs(edited_config, fp);
+    fclose(fp);
+    free(edited_config);
+    free(profile_buffer);
+    userlist_treeview = lookup_widget (GTK_WIDGET (button), "userlist_treeview");
+    update_user_list(userlist_treeview, NULL);
+    entire_config_textview = lookup_widget (GTK_WIDGET (button), "entire_config_textview");
+    update_entire_configuration(GProFTPD, NULL);
+    // There is no need to update the global tab.
+    system("killall -1 proftpd");
+}
+
+
+// OK
+void
+on_UserADD_clicked                     (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    // Adds the user and updates the userlist and the entire configuration tab.
+    FILE *fp;
+    long size_buffer;
+    char *second_part_profile;
+    char *old_buffer;
+    char *new_buffer;
+    char *check_buffer;
+    char *user_check;
+    char *buffer;
+    char *string;
+    int length;
+    int result;
+    G_CONST_RETURN gchar *username_add;
+    G_CONST_RETURN gchar *password;
+    G_CONST_RETURN gchar *dir;
+    char fix_dir[4096]="";
+    char useradd_command[4096]="";
+    char passwd_user[4096]="";
+    char first_part_profile[4096]="";
+    int user_counter = 0;
+    int group_counter = 0;
+    user_name_entry = lookup_widget (GTK_WIDGET (button), "user_name_entry");
+    password_entry = lookup_widget (GTK_WIDGET (button), "password_entry");
+    directory_entry = lookup_widget (GTK_WIDGET (button), "directory_entry");
+    username_add = gtk_entry_get_text(GTK_ENTRY(user_name_entry));
+    password = gtk_entry_get_text(GTK_ENTRY(password_entry));
+    dir = gtk_entry_get_text(GTK_ENTRY(directory_entry));
+    // if the namefield in username_add is empty inform that this cant be done.
+    length = strlen(username_add = gtk_entry_get_text(GTK_ENTRY(user_name_entry)));
+    if ( length == 0 ) 
+    {
+       strcpy(info_buffer, "\n     You must specify a username.\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    // if the password field has less then 6 chars (No can do dude:)
+    length = strlen(password = gtk_entry_get_text(GTK_ENTRY(password_entry)));
+    if ( length < 6 ) 
+    {
+       strcpy(info_buffer, "\n     The minimum password length is 6 chars.\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    // Add the user. 
+    strcpy(useradd_command, "adduser ");
+    strcat(useradd_command, username_add);
+    strcat(useradd_command, " -d /home/ftp ");
+    strcat(useradd_command, "-c ftp-user -s /usr/bin/false ");
+    fp = popen(useradd_command, "r");
+    pclose(fp);
+    // set the users password
+    strcpy(passwd_user, "passwd ");
+    strcat(passwd_user, username_add);
+    if ( (fp = popen(passwd_user,"w")) == NULL){
+    printf("\nerror adding user\n");
+    }
+    usleep(100000);
+    fputs(password, fp);
+    usleep(100000);
+    fseek(fp, 0, SEEK_END);
+    fputs(password, fp);
+    usleep(100000);
+    pclose(fp);
+    // make the first part of the profile ready for insertion before the user-profile
+    strcpy(first_part_profile, "\n\n<Anonymous ");
+    strcat(first_part_profile, dir);
+    strcat(first_part_profile, "> \n"); // a space so the userlist looks good
+    strcat(first_part_profile, "User ");
+    strcat(first_part_profile, username_add);
+    strcat(first_part_profile, "\nGroup ");
+    strcat(first_part_profile, username_add);
+    strcat(first_part_profile, "\n");
+    // checks if the user exists in @FINKPREFIX@/etc/proftpd.conf put result to a buffer. (its the exact username)
+    user_check=(char *)malloc(4096);
+    bzero(user_check, sizeof(char) * 4096);
+    strcpy(user_check, "grep -w \"User\" @FINKPREFIX@/etc/proftpd.conf |grep -w \"");
+    strcat(user_check, username_add);
+    strcat(user_check, "\" |cut -f2 -d\" \"");
+    fp = popen(user_check, "r");
+    check_buffer=(char *)malloc(4096);
+    bzero(check_buffer, sizeof(char) * 4096);
+    while (fgets(check_buffer, 4096, fp)!=NULL)
+    {
+    }
+    pclose(fp);
+    string=(char *)malloc(4096);
+    bzero(string, sizeof(char) * 4096);
+    strcpy(string, username_add);
+    result = strcmp(username_add = gtk_entry_get_text(GTK_ENTRY(user_name_entry)), check_buffer);
+    if ( result <= 0 )
+    {
+       printf("\nUser EXISTS -- No Profile Created\n");
+       free(user_check);
+       free(check_buffer);
+       free(string);
+       return;
+    }
+    free(user_check);
+    free(check_buffer);
+    free(string);
+    printf("\nUser does NOT exist -- Creating a profile\n");
+    // Get the second part profile from @FINKPREFIX@/etc/gproftpd/useradd-profile and combine
+    fp = fopen("@FINKPREFIX@/etc/gproftpd/useradd-profile", "r");
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+    second_part_profile=(char *)malloc(size_buffer);
+    bzero(second_part_profile, sizeof(char) * size_buffer);
+    while (fgets(second_part_profile, size_buffer, fp)!=NULL)
+    {
+      strcat(first_part_profile, second_part_profile);
+    }
+    fclose (fp);
+    free(second_part_profile);
+    fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "a");
+    fputs(first_part_profile, fp);
+    fclose(fp);
+    // make a ftp homedirectory for the user
+    strcpy(fix_dir, "mkdir ");
+    strcat(fix_dir, dir);
+    if ( (fp = popen(fix_dir, "r")) == NULL)
+    {
+        return;
+    }
+    pclose(fp);
+    system("killall -1 proftpd"); // reread 
+    strcpy(fix_dir, "chmod 755 ");
+    strcat(fix_dir, dir);
+    if ( (fp = popen(fix_dir, "r")) == NULL)
+    {
+       printf("\nChmod doesnt work\n");
+       return;
+    }
+    pclose(fp);
+    // delete some unused files
+    strcpy(fix_dir, "rm -f /home/ftp/.bash_profile");
+    strcat(fix_dir, " ; rm -f /home/ftp/.bash_logout");
+    strcat(fix_dir, " ; rm -f /home/ftp/.bashrc");
+    strcat(fix_dir, " ; rm -f /home/ftp/.gtkrc");
+    if ( (fp = popen(fix_dir, "r")) == NULL)
+    {
+       return;
+    }
+    pclose(fp);
+    // updating the userlist and the entire configuration tab.
+    userlist_treeview = lookup_widget (GTK_WIDGET (button), "userlist_treeview");
+    update_user_list(userlist_treeview, NULL);
+    entire_config_textview = lookup_widget (GTK_WIDGET (button), "entire_config_textview");
+    update_entire_configuration(GProFTPD, NULL);
+}
+
+
+// OK
+void
+on_anon_access_button_clicked          (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    // Adds anonymous access  
+    FILE *fp;
+    long size_buffer;
+    G_CONST_RETURN gchar *anon_chmod_value;
+    G_CONST_RETURN gchar *anon_directory_path;
+    char useradd_command[4096]="";
+    char anon_profile[4096]="";
+    const gchar *anon_passwd;
+    char do_chmod[4096]="";
+    char make_dir[4096]="";
+    char fix_dir[4096]="";
+    char *old_buffer;
+    int length;
+    anon_chmod_entry = lookup_widget (GTK_WIDGET (button), "anon_chmod_entry");
+    anon_path_entry = lookup_widget (GTK_WIDGET (button), "anon_path_entry");
+    anon_password_entry = lookup_widget (GTK_WIDGET (button), "anon_password_entry");
+    // Check if "User anonymous" already exists then return.
+    fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r");
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+    old_buffer=(char *)malloc(size_buffer);
+    bzero(old_buffer, sizeof(char) * size_buffer);
+    while (fgets((char*)old_buffer, size_buffer, fp)!=NULL)
+    {
+        if (strstr((char*)old_buffer, "User anonymous")!=NULL)
+        {
+           strcpy(info_buffer, "\nYou cant have 2 different anonymous users.\n");
+           strcat(info_buffer, "delete the old one first.\n\n");
+           error_window = create_error_window ();
+           gtk_widget_show (error_window);
+           fclose(fp);
+           free(old_buffer);           
+           return; 
+        }
+    }
+    fclose(fp);
+    free(old_buffer);
+    // Make the anonymous user to add.
+    strcpy(useradd_command, "adduser anonymous");
+    strcat(useradd_command, " -d /home/ftp ");
+    strcat(useradd_command, "-c ftp-user -s /usr/bin/false");
+    // Check that we have a sane length password.
+    length = strlen(gtk_entry_get_text(GTK_ENTRY(anon_password_entry)));
+    if(length < 6){
+    strcpy(info_buffer, "\nThe anonymous password must\n");
+    strcat(info_buffer, "be six chars or longer.\n\n");
+    error_window = create_error_window ();
+    gtk_widget_show (error_window);
+    return;
+    }
+    // Add the user.
+    fp = popen(useradd_command, "r");
+    pclose(fp);
+    // Set the anonymous users password.
+    if ( (fp = popen("passwd anonymous", "w")) == NULL){
+    printf("\nError adding anonymous user\n");
+    }
+    anon_passwd = gtk_entry_get_text(GTK_ENTRY(anon_password_entry));
+    usleep(100000);
+    fputs(anon_passwd, fp);
+    usleep(100000);
+    fseek(fp, 0, SEEK_END);
+    fputs(anon_passwd, fp);
+    usleep(100000);
+    pclose(fp);
+    // Delete some unused files.
+    strcpy(fix_dir, "rm -f /home/ftp/.bash_profile");
+    strcat(fix_dir, " ; rm -f /home/ftp/.bash_logout");
+    strcat(fix_dir, " ; rm -f /home/ftp/.bashrc");
+    strcat(fix_dir, " ; rm -f /home/ftp/.gtkrc");
+    fp = popen(fix_dir, "r");
+    pclose(fp);
+    // Add the anonymous profile to @FINKPREFIX@/etc/proftpd.conf. 
+    strcpy(anon_profile, "\n");
+    strcat(anon_profile, "<Anonymous ");
+    strcat(anon_profile, anon_directory_path = gtk_entry_get_text(GTK_ENTRY(anon_path_entry)));
+    strcat(anon_profile, "> \n"); // a space to make the userlist look good
+    strcat(anon_profile, "User anonymous\n");
+    strcat(anon_profile, "Group anonymous\n");
+    strcat(anon_profile, "AnonRequirePassword off\n");
+    strcat(anon_profile, "MaxClients 20 \"No more anonymous users allowed, hosting %m users\"\n");
+    strcat(anon_profile, "DisplayLogin welcome.msg\n");
+    strcat(anon_profile, "DisplayFirstChdir directory.msg\n");
+    strcat(anon_profile, "<Limit WRITE DELE MKD RMD SITE_CHMOD>\n");
+    strcat(anon_profile, "DenyAll\n");
+    strcat(anon_profile, "</Limit>\n");
+    strcat(anon_profile, "</Anonymous>\n");
+    fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "a");
+    fputs(anon_profile, fp);
+    fclose(fp);
+    // Add the directory if it doesnt exist.
+    strcpy(make_dir, "mkdir ");
+    strcat(make_dir, anon_directory_path = gtk_entry_get_text(GTK_ENTRY(anon_path_entry)));
+    fp = popen(make_dir, "r");
+    pclose(fp);
+    // chmod the directory.
+    strcpy(do_chmod, "chmod ");
+    strcat(do_chmod, anon_chmod_value = gtk_entry_get_text(GTK_ENTRY(anon_chmod_entry)));
+    strcat(do_chmod, " ");    
+    strcat(do_chmod, anon_directory_path = gtk_entry_get_text(GTK_ENTRY(anon_path_entry)));
+    fp = popen(do_chmod, "r");
+    pclose(fp);
+    system("killall -1 proftpd");
+    // Update the user_list and entire_configuration.  
+    userlist_treeview = lookup_widget (GTK_WIDGET (button), "userlist_treeview");
+    update_user_list(userlist_treeview, NULL);
+    entire_config_textview = lookup_widget (GTK_WIDGET (button), "entire_config_textview");
+    update_entire_configuration(GProFTPD, NULL);
+    // Create info window and show a SuccessFully happified info_buffer :).
+    strcpy(info_buffer, "\nThe anonymous user must not be listed under\n");
+    strcat(info_buffer, "the usercontrol tab (check that).\n\n");
+    strcat(info_buffer, "Users can now login as anonymous with no password.\n");
+    error_window = create_error_window ();
+    gtk_widget_show (error_window);
+}
+
+
+// OK
+void
+on_Online_clicked                      (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    system("killall -9 proftpd");
+    system("rm -f @FINKPREFIX@/etc/shutmsg");
+    system("proftpd -c @FINKPREFIX@/etc/proftpd.conf");
+}
+
+
+// OK
+void
+on_Offline_clicked                     (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    system("killall -9 proftpd");
+}
+
+
+// OK
+void
+on_ReRead_clicked                      (GtkButton       *button,
+                                        gpointer         user_data)
+{ 
+    system("killall -1 proftpd");
+}
+
+
+// OK
+void
+on_quit_clicked                        (GtkButton       *button,
+                                        gpointer         user_data)
+{
+  //quits the app via main
+}
+
+
+// OK .. Breaks !!!
+void
+on_entire_config_textview_map    (GtkWidget       *widget,
+                                  gpointer         user_data)
+{ 
+    // Inserts the entire configuration tab from proftpd.conf
+    FILE *fp;
+    long size_buffer;
+    char *buffer;
+    char *get_buffer;
+    GtkTextBuffer *entire_text_buffer;
+    gchar *utf8=NULL;
+    int length;
+    entire_config_textview = lookup_widget (GTK_WIDGET (widget), "entire_config_textview");
+    if( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL )
+    {
+        strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf.\n\n");
+        strcat(info_buffer, "If youre running GProFTPD as root\n");
+        strcat(info_buffer, "press the default button.\n\n");
+        strcat(info_buffer, "This will add the default configuration\n");
+        strcat(info_buffer, "overwriting @FINKPREFIX@/etc/proftpd.conf.\n");
+        error_window = create_error_window ();
+        gtk_widget_show (error_window);
+        return;
+    }
+    // Set the entire configuration from proftpd.conf
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+    buffer=(char *)malloc(size_buffer);
+    bzero(buffer, sizeof(char) * size_buffer);
+    get_buffer=(char *)malloc(size_buffer+1024); // make room for \n
+    bzero(get_buffer, sizeof(char) * size_buffer+1024);
+    entire_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(entire_config_textview));
+    while (fgets(buffer, size_buffer, fp)!=NULL)
+    {
+       strcat(get_buffer, buffer);
+    }
+    strcat(get_buffer, "\n"); // otherwise itll break !
+
+    // Breaks !!!
+    utf8 = g_locale_to_utf8(get_buffer, strlen(get_buffer), NULL, NULL, NULL);
+    gtk_text_buffer_set_text(entire_text_buffer, utf8, strlen(utf8));
+    fclose(fp);
+    if(utf8 !=NULL)
+    g_free(utf8);
+    free(buffer);
+    free(get_buffer);
+}
+
+
+// OK .. breaks locale !!!
+void
+on_save_and_reread_clicked             (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    // Entire configuration tab save and reread, update global, update userlist.
+    FILE *fp;
+    GtkTextBuffer *entire_config_text_buffer; // not to be freed
+    GtkTextIter start, end;                   // not to be freed
+    gchar *config_buffer=NULL;                // free it
+
+    entire_config_textview = lookup_widget (GTK_WIDGET (button), "entire_config_textview");
+    entire_config_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(entire_config_textview));
+    gtk_text_buffer_get_bounds(entire_config_text_buffer, &start, &end);
+    config_buffer = gtk_text_iter_get_text(&start, &end);
+    // Put the newly written entire_configuration text to @FINKPREFIX@/etc/proftpd.conf
+    fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "w+");
+    fputs (config_buffer, fp);
+    fclose (fp);
+
+    // Update global tab, userlist, and to see something has happened -> update the entire tab
+    GProFTPD = lookup_widget (GTK_WIDGET (button), "GProFTPD");
+    userlist_treeview = lookup_widget (GTK_WIDGET (button), "userlist_treeview");
+    entire_config_textview = lookup_widget (GTK_WIDGET (button), "entire_config_textview");
+    update_user_list(userlist_treeview, NULL);
+    update_entire_configuration(GProFTPD, NULL);
+    update_global_configuration(GProFTPD, NULL);
+    system("killall -1 proftpd");
+    if(config_buffer !=NULL)
+    g_free(config_buffer);
+}
+
+
+// OK
+void
+on_help_clicked                        (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    help = create_help ();
+    gtk_widget_show (help);
+}
+
+
+// OK
+void
+on_files_textview_map                  (GtkWidget       *widget,
+                                        gpointer         user_data)
+{
+    FILE *fp;
+    long size_buffer;
+    char *file_buffer;
+    char *get_file_buffer;
+    gchar *utf8=NULL;
+    GtkTextBuffer *file_text_buffer;
+    files_textview = lookup_widget (GTK_WIDGET (widget), "files_textview");
+    if( (fp = fopen("@FINKPREFIX@/var/log/xferlog", "r")) == NULL)
+    {
+       strcpy(info_buffer, "Cant find @FINKPREFIX@/var/log/xferlog.\n\n");
+       strcat(info_buffer, "If youre running GProFTPD as root\n");
+       strcat(info_buffer, "the xferlog has been added for you.\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       system("touch @FINKPREFIX@/var/log/xferlog");
+       return;
+    }
+    fclose(fp);
+
+
+    if( (fp = fopen("@FINKPREFIX@/var/log/xferlog", "r")) == NULL)
+    {
+       printf("\nopen @FINKPREFIX@/var/log/xferlog failed\n");
+    }
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+
+    file_buffer=(char *)malloc(size_buffer+8192);
+    bzero(file_buffer, sizeof(char) * size_buffer+8192);
+          
+    get_file_buffer=(char *)malloc(size_buffer+8192);  
+    bzero(get_file_buffer, sizeof(char) * size_buffer+8192);
+    
+
+    while (fgets(file_buffer, sizeof(file_buffer), fp)!=NULL)
+    {
+       strcat(get_file_buffer, file_buffer);
+    }
+    strcat(get_file_buffer, "\n"); // hmmz
+    utf8 = g_locale_to_utf8(get_file_buffer, strlen(get_file_buffer), NULL, NULL, NULL);
+    file_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(files_textview));
+    gtk_text_buffer_set_text(file_text_buffer, utf8, strlen(utf8));
+    fclose(fp);
+    free(file_buffer);
+    free(get_file_buffer);
+    if(utf8 !=NULL)
+    g_free(utf8);
+}
+
+
+// OK
+void
+on_transferred_files_button_clicked    (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    FILE *fp;
+    long size_buffer;
+    char *file_buffer;
+    char *get_file_buffer;
+    gchar *utf8=NULL;
+    GtkTextBuffer *file_text_buffer;
+    files_textview = lookup_widget (GTK_WIDGET (button), "files_textview");
+    if( (fp = fopen("@FINKPREFIX@/var/log/xferlog", "r")) == NULL)
+    {
+       strcpy(info_buffer, "Cant find @FINKPREFIX@/var/log/xferlog.\n\n");
+       strcat(info_buffer, "If youre running GProFTPD as root\n");
+       strcat(info_buffer, "the xferlog has been added for you.\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       system("touch @FINKPREFIX@/var/log/xferlog");
+       return;
+    }
+    fclose(fp);
+
+    if( (fp = fopen("@FINKPREFIX@/var/log/xferlog", "r")) == NULL)
+    {
+       printf("\nopen @FINKPREFIX@/var/log/xferlog failed\n");
+    }
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+    file_buffer=(char *)malloc(size_buffer+8192);
+    bzero(file_buffer, sizeof(char) * size_buffer+8192);
+    get_file_buffer=(char *)malloc(size_buffer+8192);  
+    bzero(get_file_buffer, sizeof(char) * size_buffer+8192);
+
+    while (fgets(file_buffer, sizeof(file_buffer), fp)!=NULL)
+    {
+       strcat(get_file_buffer, file_buffer);
+    }
+    strcat(get_file_buffer, "\n"); // hmmz
+    utf8 = g_locale_to_utf8(get_file_buffer, strlen(get_file_buffer), NULL, NULL, NULL);
+    file_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(files_textview));
+    gtk_text_buffer_set_text(file_text_buffer, utf8, strlen(utf8));
+    fclose(fp);
+    free(file_buffer);
+    free(get_file_buffer);
+    if(utf8 !=NULL)
+    g_free(utf8);
+}
+
+
+// OK
+void
+on_transferred_files_clear_button_clicked    (GtkButton       *button,
+                                              gpointer         user_data)
+{
+    // xferlog update (cleared, but maybe not)
+    FILE *fp;
+    int length;
+    long size_buffer;
+    char *file_buffer;
+    char *get_file_buffer;
+    gchar *utf8=NULL;
+    GtkTextBuffer *file_text_buffer;
+    system("rm -f @FINKPREFIX@/var/log/xferlog");
+    system("touch @FINKPREFIX@/var/log/xferlog");
+    files_textview = lookup_widget (GTK_WIDGET (button), "files_textview");
+    if( (fp = fopen("@FINKPREFIX@/var/log/xferlog", "r")) == NULL)
+    {
+       strcpy(info_buffer, "Cant find @FINKPREFIX@/var/log/xferlog.\n\n");
+       strcat(info_buffer, "If youre running GProFTPD as root\n");
+       strcat(info_buffer, "the xferlog has been added for you.\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       system("touch @FINKPREFIX@/var/log/xferlog");
+       return;
+    }
+    fclose(fp);
+
+    if( (fp = fopen("@FINKPREFIX@/var/log/xferlog", "r")) == NULL)
+    {
+       printf("\nopen @FINKPREFIX@/var/log/xferlog failed\n");
+    }
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+    file_buffer=(char *)malloc(size_buffer+8192);
+    bzero(file_buffer, sizeof(char) * size_buffer+8192);
+    get_file_buffer=(char *)malloc(size_buffer+8192);  
+    bzero(get_file_buffer, sizeof(char) * size_buffer+8192);
+
+    while (fgets(file_buffer, sizeof(file_buffer), fp)!=NULL)
+    {
+       strcat(get_file_buffer, file_buffer);
+    }
+    strcat(get_file_buffer, "\n"); // hmmz
+    utf8 = g_locale_to_utf8(get_file_buffer, strlen(get_file_buffer), NULL, NULL, NULL);
+    file_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(files_textview));
+    gtk_text_buffer_set_text(file_text_buffer, utf8, strlen(utf8));
+    fclose(fp);
+    free(file_buffer);
+    free(get_file_buffer);
+    if(utf8 !=NULL)
+    g_free(utf8);
+}
+
+
+// OK
+void
+on_save_profile_clicked                (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    // Just save the profile.
+    FILE *fp;
+    GtkTextBuffer *profile_text_buffer;
+    GtkTextIter start, end;
+    gchar *profile;
+    profile_text = lookup_widget (GTK_WIDGET (button), "profile_text"); // text_view
+    profile_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(profile_text));
+    gtk_text_buffer_get_bounds(profile_text_buffer, &start, &end);
+    profile = gtk_text_iter_get_text(&start, &end);
+    // Put the newly written profile text to @FINKPREFIX@/etc/gproftpd/useradd-profile
+    fp = fopen("@FINKPREFIX@/etc/gproftpd/useradd-profile", "w+");
+    fputs (profile, fp);
+    fclose (fp);
+    if(profile !=NULL)
+    g_free(profile);
+}
+
+
+// OK 
+void
+on_user_control_textview_map           (GtkWidget       *widget,
+                                        gpointer         user_data)
+{
+    // Ftpusers update .. if no @FINKPREFIX@/etc/ftpusers one is created and all existing users put there. 
+    FILE *fp;
+    FILE *cat_file;
+    char *access_buffer;
+    char *get_access_buffer;
+    GtkTextBuffer *user_control_text_buffer;
+    gchar *utf8_access=NULL;
+    long size_buffer;
+    user_control_textview = lookup_widget (GTK_WIDGET (widget), "user_control_textview");
+    if( (fp = fopen("@FINKPREFIX@/etc/ftpusers", "r")) == NULL )
+    {
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/etc/ftpusers\n");
+       strcat(info_buffer, "so i made that file and added\n");
+       strcat(info_buffer, "all the users on the system to it.\n\n");
+       strcat(info_buffer, "This in an auto security feature.\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       // add all system users to @FINKPREFIX@/etc/ftpusers
+       cat_file = popen("cat /etc/passwd |cut -f1 -d\":\" > @FINKPREFIX@/etc/ftpusers", "r");
+       pclose(cat_file);
+    }
+    // If the previous didnt work, inform.
+    if( (fp = fopen("@FINKPREFIX@/etc/ftpusers", "r")) == NULL )
+    {
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/etc/ftpusers\n");
+       strcat(info_buffer, "Run GProFTPD as root.\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+    access_buffer=(char *)malloc(size_buffer);
+    get_access_buffer=(char *)malloc(size_buffer+10);
+    bzero(access_buffer, sizeof(char) * size_buffer);   
+    bzero(get_access_buffer, sizeof(char) * size_buffer+10);   
+    while (fgets(access_buffer, size_buffer, fp)!=NULL)
+    {
+       strcat(get_access_buffer, access_buffer);
+    }
+    // Add an empty line so it can be conveniently filled. 
+    strcat(get_access_buffer, "\n");
+    user_control_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(user_control_textview));
+    utf8_access = g_locale_to_utf8(get_access_buffer, strlen(get_access_buffer), NULL, NULL, NULL);
+    gtk_text_buffer_set_text(user_control_text_buffer, utf8_access, strlen(utf8_access));
+    fclose (fp);
+    free(access_buffer);
+    free(get_access_buffer);
+    if(utf8_access !=NULL)
+    g_free(utf8_access);
+}
+
+
+// OK 
+void
+on_access_ok_clicked                   (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    // Save the usercontrol tab to @FINKPREFIX@/etc/ftpusers
+    FILE *fp;
+    GtkTextBuffer *access_text_buffer;
+    GtkTextIter start, end;
+    gchar *profile;
+    user_control_textview = lookup_widget (GTK_WIDGET (button), "user_control_textview");
+    access_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(user_control_textview));
+    gtk_text_buffer_get_bounds(access_text_buffer, &start, &end);
+    profile = gtk_text_iter_get_text(&start, &end);
+    // Put the (newly) written profile text to @FINKPREFIX@/etc/gproftpd/useradd-profile
+    if ( (fp = fopen("@FINKPREFIX@/etc/ftpusers", "w+")) == NULL)
+    {
+       strcpy(info_buffer, "Couldnt open @FINKPREFIX@/etc/ftpusers for writing\n");
+       strcat(info_buffer, "This is not good, Run GProFTPD as root\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       printf("\nError saving @FINKPREFIX@/etc/ftpusers\n");
+       return;
+    }
+    fputs (profile, fp);
+    fclose (fp);
+    if(profile !=NULL)
+    g_free(profile);
+}
+
+
+// OK
+void
+on_temp_kick_clicked                   (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    FILE *fp;
+    char *get_kick_pid;
+    char *kick_pid;
+    char *kick;
+    G_CONST_RETURN gchar *kick_username;
+    temp_kick_entry = lookup_widget (GTK_WIDGET (button), "temp_kick_entry");
+    kick_username = gtk_entry_get_text(GTK_ENTRY(temp_kick_entry));
+    // getting the pid to kill
+    get_kick_pid=(char *)malloc(1024);
+    bzero(get_kick_pid, sizeof(char) * 1024);   
+    strcpy(get_kick_pid, "ps -aux |grep \"proftpd: "); 
+    strcat(get_kick_pid, kick_username);
+    strcat(get_kick_pid, "\" |awk '{print $2}'");
+    if ( (fp = popen(get_kick_pid, "r")) == NULL)
+    {
+       printf("\nCant get access to ps .. user not kicked\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    kick_pid=(char *)malloc(1024);
+    bzero(kick_pid, sizeof(char) * 1024);   
+    while (fgets(kick_pid, 1024, fp)!=NULL)
+    {
+    }
+    fclose(fp);
+    free(get_kick_pid);
+    free(kick_pid);
+    // Kill the user pid
+    kick=(char *)malloc(1024);
+    bzero(kick, sizeof(char) * 1024);   
+    strcpy(kick, "kill "); 
+    strcat(kick, kick_pid);
+    system(kick);
+    free(kick);
+}
+
+
+// OK
+void
+on_kick_ban_clicked                    (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    FILE *fp;
+    char *get_kick_ban_pid;
+    char *kick_ban_pid;
+    char *kick_ban;
+    char *access_buffer;
+    char *get_access_buffer;
+    long size_buffer;
+    G_CONST_RETURN gchar *kick_ban_username;
+    GtkTextBuffer *user_control_text_buffer;
+    gchar *utf8_access=NULL;
+    user_control_textview = lookup_widget (GTK_WIDGET (button), "user_control_textview");
+    kick_ban_entry = lookup_widget (GTK_WIDGET (button), "kick_ban_entry");
+    kick_ban_username = gtk_entry_get_text(GTK_ENTRY(kick_ban_entry));
+    // Put the banned user in @FINKPREFIX@/etc/ftpusers
+    fp = fopen("@FINKPREFIX@/etc/ftpusers", "a");
+    fputs("\n", fp);
+    fputs(kick_ban_username, fp);
+    fclose(fp);
+    // Get the pid to kill
+    kick_ban_pid=(char *)malloc(4096);
+    bzero(kick_ban_pid, sizeof(char) * 4096);   
+    get_kick_ban_pid=(char *)malloc(4096);
+    bzero(get_kick_ban_pid, sizeof(char) * 4096);   
+    strcpy(get_kick_ban_pid, "ps -aux |grep \"proftpd: "); 
+    strcat(get_kick_ban_pid, kick_ban_username);
+    strcat(get_kick_ban_pid, "\" |awk '{print $2}'");
+    if ( (fp = popen(get_kick_ban_pid, "r")) == NULL)
+    {
+       printf("\nCant get access to ps .. user not kicked\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    while (fgets(kick_ban_pid, 4096, fp)!=NULL)
+    {
+    }
+    pclose(fp);
+    // Kill the the users pid
+    kick_ban=(char *)malloc(4096);
+    bzero(kick_ban, sizeof(char) * 4096);   
+    strcpy(kick_ban, "kill "); 
+    strcat(kick_ban, kick_ban_pid);
+    system(kick_ban);
+    free(get_kick_ban_pid);
+    free(kick_ban_pid);
+    free(kick_ban);
+    // Update user control tab from @FINKPREFIX@/etc/ftpusers
+    if( (fp = fopen("@FINKPREFIX@/etc/ftpusers", "r")) == NULL )
+    {
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/etc/ftpusers\n");
+       strcat(info_buffer, "This is not good, run GProFTPD as root.\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+    access_buffer=(char *)malloc(size_buffer);
+    get_access_buffer=(char *)malloc(size_buffer+10);
+    bzero(access_buffer, sizeof(char) * size_buffer);   
+    bzero(get_access_buffer, sizeof(char) * size_buffer+10);   
+    while (fgets(access_buffer, size_buffer, fp)!=NULL)
+    {
+       strcat(get_access_buffer, access_buffer);
+    }
+    // Add an empty line so it can be conveniently filled. 
+    strcat(get_access_buffer, "\n");
+    user_control_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(user_control_textview));
+    utf8_access = g_locale_to_utf8(get_access_buffer, strlen(get_access_buffer), NULL, NULL, NULL);
+    gtk_text_buffer_set_text(user_control_text_buffer, utf8_access, strlen(utf8_access));
+    fclose(fp);
+    free(access_buffer);
+    free(get_access_buffer);
+    if(utf8_access !=NULL)
+    g_free(utf8_access);
+}
+
+
+// OK .. fixme mange
+void
+on_permissions_textview_map            (GtkWidget       *widget,
+                                        gpointer         user_data)
+{
+    // show permission changes in a popup window
+    FILE *fp;
+    char *show_buffer;
+    char line_buffer[8192]="";
+    long size_buffer;
+    GtkTextBuffer *permissions_text_buffer;
+    gchar *utf8=NULL;
+    permissions_textview = lookup_widget (GTK_WIDGET (widget), "permissions_textview");
+    fp = popen(do_chmod,"w");
+    pclose(fp);
+    if ( (fp=fopen("/tmp/do_chmod", "r"))==NULL)
+    {
+      printf("Error opening /tmp/do_chmod\n");
+      return;
+    }
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+
+    show_buffer=(char *)malloc(size_buffer+1024);
+    bzero(show_buffer, sizeof(char) * size_buffer+1024);   
+
+    while (fgets(line_buffer, size_buffer, fp)!=NULL)
+    {
+       strcat(show_buffer, line_buffer);
+    }
+    strcat(show_buffer, "\n");
+    permissions_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(permissions_textview));
+    utf8 = g_locale_to_utf8(show_buffer, strlen(show_buffer), NULL, NULL, NULL);
+    gtk_text_buffer_set_text(permissions_text_buffer, utf8, strlen(utf8));
+    fclose(fp);
+    if(utf8 !=NULL)
+    g_free(utf8);
+    system("rm -f /tmp/do_chmod");
+}
+
+
+// OK
+void
+on_Permissions_clicked                 (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    Permissions_window = create_Permissions_window ();
+    gtk_widget_show (Permissions_window);
+}
+
+
+// OK
+void
+on_close_permissions_window_button_clicked
+                                        (GtkButton       *button,
+                                         gpointer         user_data)
+{
+   // close the window
+}
+
+
+// OK
+void
+on_set_dir_recurse_clicked             (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    //Get chmod permissions then show the dir selection 
+    chmod_directory_entry = lookup_widget (GTK_WIDGET (button), "chmod_directory_entry");
+    chmod_directory_entry_permissions = gtk_entry_get_text(GTK_ENTRY(chmod_directory_entry));
+    dir_chmod_selection = create_dir_chmod_selection ();
+    gtk_widget_show (dir_chmod_selection);
+}
+
+
+// OK
+void
+on_set_file_recurse_clicked            (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    // Get permissions then show the file selection
+    chmod_file_entry = lookup_widget (GTK_WIDGET (button), "chmod_file_entry");
+    chmod_file_entry_permissions = gtk_entry_get_text(GTK_ENTRY(chmod_file_entry));
+    file_chmod_selection = create_file_chmod_selection ();
+    gtk_widget_show (file_chmod_selection);
+}
+
+
+// OK
+void
+on_ok_dir_chmod_button_clicked         (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    // chmodding directories recursively
+    G_CONST_RETURN gchar *dir_chmod_path;
+    dir_chmod_selection = lookup_widget (GTK_WIDGET (button), "dir_chmod_selection");
+    dir_chmod_path = gtk_file_selection_get_filename(GTK_FILE_SELECTION(dir_chmod_selection));
+    strcpy(do_chmod, "find \"");
+    strcat(do_chmod, dir_chmod_path);
+    strcat(do_chmod, "\" -type d -exec chmod -v ");
+    strcat(do_chmod, chmod_directory_entry_permissions); // both are globals
+    strcat(do_chmod, " {} \\;");
+    strcat(do_chmod, " > /tmp/do_chmod");
+    gtk_widget_hide(dir_chmod_selection);
+    show_chmod_window = create_show_chmod_window ();
+    gtk_widget_show (show_chmod_window);
+}
+
+
+// OK
+void
+on_ok_file_chmod_button_clicked        (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    // Chmodding files recursively
+    G_CONST_RETURN gchar *file_chmod_path;
+    file_chmod_selection = lookup_widget (GTK_WIDGET (button), "file_chmod_selection");
+    file_chmod_path = gtk_file_selection_get_filename(GTK_FILE_SELECTION(file_chmod_selection));
+    strcpy(do_chmod, "find \"");
+    strcat(do_chmod, file_chmod_path);
+    strcat(do_chmod, "\" -type f -exec chmod -v ");
+    strcat(do_chmod, chmod_file_entry_permissions);
+    strcat(do_chmod, " {} \\;");
+    strcat(do_chmod, " > /tmp/do_chmod");
+    gtk_widget_hide(file_chmod_selection);
+    show_chmod_window = create_show_chmod_window ();
+    gtk_widget_show (show_chmod_window);
+}
+
+
+// OK
+void
+on_shutdown_button_clicked             (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    shutdown_window = create_shutdown_window ();
+    gtk_widget_show (shutdown_window);
+}
+
+
+// OK
+void
+on_shutdown_ok_button_clicked          (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    FILE *shutdown_file;
+    G_CONST_RETURN gchar *get_new_login_disable;
+    G_CONST_RETURN gchar *get_exist_user_disconnect;
+    G_CONST_RETURN gchar *get_real_shutdown_entry;
+    char *shutdown;
+    new_login_disable_entry = lookup_widget (GTK_WIDGET (button), "new_login_disable_entry");
+    exist_user_disconnect_entry = lookup_widget (GTK_WIDGET (button), "exist_user_disconnect_entry");
+    real_shutdown_entry = lookup_widget (GTK_WIDGET (button), "real_shutdown_entry");
+    get_new_login_disable = gtk_entry_get_text(GTK_ENTRY(new_login_disable_entry));
+    get_exist_user_disconnect = gtk_entry_get_text(GTK_ENTRY(exist_user_disconnect_entry));
+    get_real_shutdown_entry = gtk_entry_get_text(GTK_ENTRY(real_shutdown_entry));
+    shutdown=(char *)malloc(4096);
+    bzero(shutdown, sizeof(char) * 4096);
+    strcpy(shutdown, "ftpshut -l ");
+    strcat(shutdown, get_new_login_disable);
+    strcat(shutdown, " -d ");
+    strcat(shutdown, get_exist_user_disconnect);
+    strcat(shutdown, " ");
+    strcat(shutdown, get_real_shutdown_entry);
+    shutdown_file = popen(shutdown,"r");
+    pclose(shutdown_file);    
+    free(shutdown);
+    gtk_widget_hide(shutdown_window);
+}  
+
+
+// OK .. for now
+void
+on_open_user_profile_button_clicked    (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    open_user_profile_name_entry = lookup_widget (GTK_WIDGET (button), "open_user_profile_name_entry");
+    strcpy(profile_name,  gtk_entry_get_text(GTK_ENTRY(open_user_profile_name_entry)));
+    user_profile_window = create_user_profile_window ();
+    gtk_widget_show (user_profile_window);
+}
+
+
+// OK
+void
+on_add_default_config_button_clicked   (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    // Overwrite @FINKPREFIX@/etc/proftpd.conf with the default configuration, update the global tab, entire tab and user tab.
+    FILE *fp;
+    char *old_Buffer;
+    char *new_Buffer;
+    char *default_buffer;
+    // Default configuration list
+    default_buffer=(char *)malloc(8192);
+    bzero(default_buffer, sizeof(char) * 8192);   
+    strcpy(default_buffer, "ServerType standalone\n");
+    strcat(default_buffer, "DefaultServer on\n");
+    strcat(default_buffer, "Umask 022\n");
+    strcat(default_buffer, "\n");
+    strcat(default_buffer, "ServerName \"My FTP Server\"\n");
+    strcat(default_buffer, "ServerAdmin Admin@this.domain.topdomain\n");
+    strcat(default_buffer, "ServerIdent on \"Show this instead ?\"\n");
+    strcat(default_buffer, "IdentLookups off\n");
+    strcat(default_buffer, "UseReverseDNS off\n");
+    strcat(default_buffer, "Port 21\n");
+    strcat(default_buffer, "TimesGMT off\n");
+    strcat(default_buffer, "MaxInstances 10\n");
+    strcat(default_buffer, "MaxLoginAttempts 3\n");
+    strcat(default_buffer, "TimeoutLogin 300\n");
+    strcat(default_buffer, "TimeoutNoTransfer 300\n");
+    strcat(default_buffer, "User nobody\n");
+    strcat(default_buffer, "Group nobody\n");
+    strcat(default_buffer, "DefaultTransferMode ascii\n");
+    strcat(default_buffer, "AllowForeignAddress on\n");
+    strcat(default_buffer, "AllowRetrieveRestart on\n");
+    strcat(default_buffer, "RateReadBPS 30000\n");
+    strcat(default_buffer, "RateReadHardBPS off\n");
+    strcat(default_buffer, "RateReadFreeBytes 0\n");
+    strcat(default_buffer, "AllowStoreRestart on\n");
+    strcat(default_buffer, "RateWriteBPS 30000\n");
+    strcat(default_buffer, "RateWriteHardBPS off\n");
+    strcat(default_buffer, "RateWriteFreeBytes 0\n");
+    strcat(default_buffer, "DeleteAbortedStores on\n");
+    strcat(default_buffer, "<Directory /*>\n");
+    strcat(default_buffer, "AllowOverwrite off\n");
+    strcat(default_buffer, "</Directory>\n");
+    strcat(default_buffer, "#--- End of the global configuration ---#\n");
+    // Set the default configuration overwriting .. if one exists.
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "w+")) == NULL)
+    {
+        strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf for writing\n");
+        strcat(info_buffer, "Run GProFTPD as root\n");
+        error_window = create_error_window ();
+        gtk_widget_show (error_window);
+        free(default_buffer);
+        return;
+    }
+    fputs(default_buffer, fp);
+    fclose(fp);
+    free(default_buffer);
+    // Update the global tab, userlist tab and the entire configuration
+    userlist_treeview = lookup_widget (GTK_WIDGET (button), "userlist_treeview");
+    update_user_list(userlist_treeview, NULL);
+    entire_config_textview = lookup_widget (GTK_WIDGET (button), "entire_config_textview");
+    update_entire_configuration(GProFTPD, NULL);
+    GProFTPD = lookup_widget (GTK_WIDGET (button), "GProFTPD");
+    update_global_configuration(GProFTPD, NULL);
+}
+
+
+// OK
+void
+on_backup_proftpd_conf_button_clicked  (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    system("cp @FINKPREFIX@/etc/proftpd.conf @FINKPREFIX@/etc/gproftpd"); 
+}
+
+
+// OK
+void
+on_restore_config_button_clicked       (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    system("cp @FINKPREFIX@/etc/gproftpd/proftpd.conf @FINKPREFIX@/etc");
+    // Updating the userlist and the entire configuration tab.
+    userlist_treeview = lookup_widget (GTK_WIDGET (button), "userlist_treeview");
+    update_user_list(userlist_treeview, NULL);
+    entire_config_textview = lookup_widget (GTK_WIDGET (button), "entire_config_textview");
+    update_entire_configuration(GProFTPD, NULL);
+    GProFTPD = lookup_widget (GTK_WIDGET (button), "GProFTPD");
+    update_global_configuration(GProFTPD, NULL);
+}
+
+
+// OK
+void
+on_credits_button_clicked              (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    credits_window = create_credits_window();
+    gtk_widget_show (credits_window);
+}
+
+
+// OK
+void
+on_close_credits_button_hide           (GtkWidget       *widget,
+                                        gpointer         user_data)
+{
+  // closes the credits window
+}
+
+
+// OK
+void
+on_check_config_button_clicked         (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    FILE *fp;
+    char *check_conf_buffer;
+    if ( (fp = popen("proftpd -t -c @FINKPREFIX@/etc/proftpd.conf 2>&1", "r")) == NULL)
+    {
+       strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);       
+       return;
+    }
+    check_conf_buffer=(char *)malloc(8192);
+    bzero(check_conf_buffer, sizeof(char) * 8192);   
+    while (fgets(check_conf_buffer, 8192, fp)!=NULL)
+    {
+    }
+    strcpy(info_buffer, "If there are no complaints the configuration is ok.\n\n\n");
+    strcat(info_buffer, check_conf_buffer);
+    pclose(fp);
+    free(check_conf_buffer);
+    error_window = create_error_window();
+    gtk_widget_show (error_window);
+}
+
+
+// OK
+void
+on_userlist_treeview_map               (GtkWidget       *widget,
+                                        gpointer         user_data)
+{
+   FILE *fp;
+   GtkListStore *model;
+   GtkTreeIter iter;
+   GtkCellRenderer *cell;
+   GtkTreeViewColumn *user_column, *group_column, *maxclients_column, *require_column, *maximum_column;
+   GtkTreePath *path;
+   gboolean edit;
+
+   long size_buffer;
+   int user_counter = 0;
+   char *new_buffer;
+   char *old_buffer;
+   char *user_buffer;
+   char *buf;
+   char *shell;
+   gchar *utf8=NULL;
+   int found=0;
+   userlist_treeview = lookup_widget (GTK_WIDGET (widget), "userlist_treeview");
+   model = gtk_list_store_new(5, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
+   gtk_tree_view_set_model(GTK_TREE_VIEW(userlist_treeview), GTK_TREE_MODEL (model));
+   cell = gtk_cell_renderer_text_new();
+   user_column = gtk_tree_view_column_new_with_attributes("User", cell, "text", 0, NULL);
+   group_column = gtk_tree_view_column_new_with_attributes("Group", cell, "text", 1, NULL);
+   maxclients_column = gtk_tree_view_column_new_with_attributes("Home directory", cell, "text", 2, NULL);
+   require_column = gtk_tree_view_column_new_with_attributes("Require password", cell, "text", 3, NULL);
+   maximum_column = gtk_tree_view_column_new_with_attributes("Maximum simultaneous connections", cell, "text", 4, NULL);
+   gtk_list_store_clear(model);
+   // Check if the line /usr/bin/false is in /etc/shells, if its not .. add that line.
+   // strstr doesnt work in append mode, doh !
+   if( (fp = fopen("/etc/shells", "r"))==NULL)
+   {
+      printf("\nCant open /etc/shells for reading\n");
+      return;
+   }
+   fseek(fp, 0, SEEK_END);
+   size_buffer = ftell(fp);
+   rewind(fp);
+   shell=(char *)malloc(size_buffer);          
+   bzero(shell, sizeof(char) * size_buffer);   
+   while (fgets(shell, size_buffer, fp)!=NULL) 
+   {
+     if (strstr((char*)shell, "/usr/bin/false")!=NULL)
+     {
+        found=1;
+     }
+   }
+   fclose(fp);
+   free(shell);
+   if (found==0)
+   {
+     if( (fp = fopen("/etc/shells", "a"))==NULL)
+     {
+        printf("\nCant open /etc/shells for append/write\n");
+        return; 
+     }
+     fputs("/usr/bin/false", fp);
+     printf("\nCouldnt find the line /usr/bin/false in /etc/shells .. added it.\n");
+     strcpy(info_buffer, "Cant find the line /usr/bin/false in /etc/shells.\n\n");
+     strcat(info_buffer, "If youre running GProFTPD as root\n");
+     strcat(info_buffer, "that line has been added for you.\n");
+     error_window = create_error_window ();
+     gtk_widget_show (error_window);
+     fclose(fp);
+  }
+  // Update the userlist
+  if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
+  {
+     // create info window and show info_buffer.
+     strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf\n");
+     strcat(info_buffer, "Run GProFTPD as root\n");
+     error_window = create_error_window ();
+     gtk_widget_show (error_window);
+     return;
+  }
+  fseek(fp, 0, SEEK_END);
+  size_buffer = ftell(fp);
+  rewind(fp);
+
+  old_buffer=(char *)malloc(size_buffer);
+  bzero(old_buffer, sizeof(char) * size_buffer);   
+
+  new_buffer=(char *)malloc(size_buffer+1024);
+  bzero(new_buffer, sizeof(char) * size_buffer+1024);   
+
+  user_buffer=(char *)malloc(size_buffer);
+  bzero(user_buffer, sizeof(char) * size_buffer);   
+
+  buf=(char *)malloc(4096);
+  bzero(buf, sizeof(char) * 4096);   
+
+  while (fgets((char*)old_buffer, size_buffer, fp)!=NULL)
+  {
+     if (strstr((char*)old_buffer, "<Anonymous ")!=NULL)
+     {
+        sprintf((char*)new_buffer, old_buffer);
+        new_buffer[strlen(old_buffer)-1] = 0;
+        new_buffer[strlen(old_buffer)-2] = 10;
+
+        buf = strtok(new_buffer, " ");
+        buf = strtok(NULL, ">");
+
+        utf8 = g_locale_to_utf8(buf, strlen(buf), NULL, NULL, NULL);
+        gtk_list_store_append(GTK_LIST_STORE(model), &iter);
+        gtk_list_store_set(GTK_LIST_STORE(model), &iter, 2, utf8, -1);
+
+        user_counter = 1;
+     }
+     if ((strstr((char*)old_buffer, "User ")!=NULL) && user_counter == 1)  
+     {
+        sprintf((char*)new_buffer, old_buffer);
+
+        buf = strtok(new_buffer, " ");
+        buf = strtok(NULL, "\n");
+
+        utf8 = g_locale_to_utf8(buf, strlen(buf), NULL, NULL, NULL);
+        gtk_list_store_set(GTK_LIST_STORE(model), &iter, 0, utf8, -1);
+
+     }
+     if ((strstr((char*)old_buffer, "Group ")!=NULL) && user_counter == 1)
+     {   
+        sprintf((char*)new_buffer, old_buffer);
+
+        buf = strtok(new_buffer, " ");
+        buf = strtok(NULL, "\n");
+
+        utf8 = g_locale_to_utf8(buf, strlen(buf), NULL, NULL, NULL);
+        gtk_list_store_set(GTK_LIST_STORE(model), &iter, 1, utf8, -1);
+     }
+     if (strstr((char*)old_buffer, "AnonRequirePassword ")!=NULL)
+     {   
+        sprintf((char*)new_buffer, old_buffer);
+
+        buf = strtok(new_buffer, " ");
+        buf = strtok(NULL, "\n");
+
+        utf8 = g_locale_to_utf8(buf, strlen(buf), NULL, NULL, NULL);
+        gtk_list_store_set(GTK_LIST_STORE(model), &iter, 3, utf8, -1);
+     }
+     if (strstr((char*)old_buffer, "MaxClients ")!=NULL)
+     {   
+        int i=11;
+        while(old_buffer[i]!=' ')
+        {
+           i++;
+           if (i>100) break;
+        }
+        strcpy(new_buffer, old_buffer);
+        new_buffer[i] = 10;
+        new_buffer[i+1] = 0;
+
+        buf = strtok(new_buffer, " ");
+        buf = strtok(NULL, "\n");
+
+        utf8 = g_locale_to_utf8(buf, strlen(buf), NULL, NULL, NULL);
+        gtk_list_store_set(GTK_LIST_STORE(model), &iter, 4, utf8, -1);
+     }
+  }
+  fclose(fp);
+  free(old_buffer);
+  free(new_buffer);
+  free(buf);
+  
+  gtk_tree_view_append_column(GTK_TREE_VIEW(userlist_treeview), GTK_TREE_VIEW_COLUMN(user_column));
+  gtk_tree_view_append_column(GTK_TREE_VIEW(userlist_treeview), GTK_TREE_VIEW_COLUMN(group_column));
+  gtk_tree_view_append_column(GTK_TREE_VIEW(userlist_treeview), GTK_TREE_VIEW_COLUMN(maxclients_column));
+  gtk_tree_view_append_column(GTK_TREE_VIEW(userlist_treeview), GTK_TREE_VIEW_COLUMN(require_column));
+  gtk_tree_view_append_column(GTK_TREE_VIEW(userlist_treeview), GTK_TREE_VIEW_COLUMN(maximum_column));
+
+
+  // Cant set treepath if there are no rows so keep this
+  if(user_counter == 0)
+  {
+//     printf("\nNo user profiles found.\n");
+     if(utf8 !=NULL)
+     g_free(utf8);
+     return;
+  }
+//  printf("\nUser profiles found.\n");
+
+  if(utf8 !=NULL)
+  g_free(utf8);
+
+  path = gtk_tree_path_new_first();
+  gtk_tree_view_set_cursor(GTK_TREE_VIEW(userlist_treeview), path, NULL, edit);
+  gtk_tree_path_free(path);
+}
+
+
+// OK
+void
+on_error_textview_map                  (GtkWidget       *widget,
+                                        gpointer         user_data)
+{
+    // Show a popup information window
+    GtkTextBuffer *error_text_buffer;
+    gchar *utf8=NULL;
+    error_textview = lookup_widget (GTK_WIDGET (widget), "error_textview");
+    error_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(error_textview));
+    utf8 = g_locale_to_utf8(info_buffer, strlen(info_buffer), NULL, NULL, NULL);
+    gtk_text_buffer_set_text(error_text_buffer, utf8, strlen(utf8));
+    if(utf8 !=NULL)
+    g_free(utf8);
+}
+
+
+
+
+// Fixxa layouten
+void
+on_security_successful_textview_map    (GtkWidget       *widget,
+                                        gpointer         user_data)
+{
+    FILE *fp;
+    int length;
+    long sizebuffer;
+    char *s_buf;
+    char *get_s_buf;
+    gchar *utf8=NULL;
+    GtkTextBuffer *security_text_buffer;
+    if( (fp = fopen("@FINKPREFIX@/var/log/secure", "r")) == NULL) 
+    {
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/var/log/secure\n\n");
+       strcat(info_buffer, "so i added it.\n");
+       system("touch @FINKPREFIX@/var/log/secure");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    security_successful_textview = lookup_widget (GTK_WIDGET (widget), "security_successful_textview");
+    security_refused_textview = lookup_widget (GTK_WIDGET (widget), "security_refused_textview");
+    fseek(fp, 0, SEEK_END);
+    sizebuffer = ftell(fp);
+    rewind(fp);
+    s_buf=(char *)malloc(sizebuffer);
+    bzero(s_buf, sizeof(char) * sizebuffer);   
+    get_s_buf=(char *)malloc(sizebuffer+1024); // nope
+    bzero(get_s_buf, sizeof(char) * sizebuffer+1024);   
+    while (fgets(s_buf, sizebuffer, fp)!=NULL)
+    {
+      if(strstr(s_buf, "Login successful"))
+      {
+         strcat(get_s_buf, s_buf);
+      }
+    }
+    security_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(security_successful_textview));
+    utf8 = g_locale_to_utf8(get_s_buf, strlen(get_s_buf), NULL, NULL, NULL);
+    gtk_text_buffer_set_text(security_text_buffer, utf8, strlen(utf8));
+    fclose(fp);
+
+    if( (fp = fopen("@FINKPREFIX@/var/log/secure", "r")) == NULL) 
+    {
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/var/log/secure\n\n");
+       strcat(info_buffer, "so i added it.\n");
+       system("touch @FINKPREFIX@/var/log/secure");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    bzero(s_buf, sizeof(char) * sizebuffer);   
+    bzero(get_s_buf, sizeof(char) * sizebuffer+1024);   
+    while (fgets(s_buf, sizebuffer, fp)!=NULL)
+    {
+      if(strstr(s_buf, "Login failed"))
+      {
+         strcat(get_s_buf, s_buf);
+      }
+
+      if(strstr(s_buf, "refused"))
+      {
+         strcat(get_s_buf, s_buf);
+      }
+
+      if(strstr(s_buf, "no such user"))
+      {
+         strcat(get_s_buf, s_buf);
+      }
+
+      if(strstr(s_buf, "Maximum login attempts"))
+      {
+         strcat(get_s_buf, s_buf);
+      }
+
+      if(strstr(s_buf, "SECURITY VIOLATION"))
+      {
+         strcat(get_s_buf, s_buf);
+      }
+    }
+    security_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(security_refused_textview));
+    utf8 = g_locale_to_utf8(get_s_buf, strlen(get_s_buf), NULL, NULL, NULL);
+    gtk_text_buffer_set_text(security_text_buffer, utf8, strlen(utf8));
+    fclose(fp);
+    if(utf8 !=NULL)
+    g_free(utf8);
+    free(s_buf);
+    free(get_s_buf);
+}
+
+
+// layout
+void
+on_refresh_security_button_clicked     (GtkButton       *button,
+                                        gpointer         user_data)
+{
+    FILE *fp;
+    int length;
+    long sizebuffer;
+    char *s_buf;
+    char *get_s_buf;
+    gchar *utf8=NULL;
+    GtkTextBuffer *security_text_buffer;
+    if( (fp = fopen("@FINKPREFIX@/var/log/secure", "r")) == NULL) 
+    {
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/var/log/secure\n\n");
+       strcat(info_buffer, "so i added it.\n");
+       system("touch @FINKPREFIX@/var/log/secure");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    security_successful_textview = lookup_widget (GTK_WIDGET (button), "security_successful_textview");
+    security_refused_textview = lookup_widget (GTK_WIDGET (button), "security_refused_textview");
+    fseek(fp, 0, SEEK_END);
+    sizebuffer = ftell(fp);
+    rewind(fp);
+    s_buf=(char *)malloc(sizebuffer);
+    bzero(s_buf, sizeof(char) * sizebuffer);   
+    get_s_buf=(char *)malloc(sizebuffer+1024); // nope
+    bzero(get_s_buf, sizeof(char) * sizebuffer+1024);   
+    while (fgets(s_buf, sizebuffer, fp)!=NULL)
+    {
+      if(strstr(s_buf, "Login successful"))
+      {
+         strcat(get_s_buf, s_buf);
+      }
+    }
+    security_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(security_successful_textview));
+    utf8 = g_locale_to_utf8(get_s_buf, strlen(get_s_buf), NULL, NULL, NULL);
+    gtk_text_buffer_set_text(security_text_buffer, utf8, strlen(utf8));
+    fclose(fp);
+
+    if( (fp = fopen("@FINKPREFIX@/var/log/secure", "r")) == NULL) 
+    {
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/var/log/secure\n\n");
+       strcat(info_buffer, "so i added it.\n");
+       system("touch @FINKPREFIX@/var/log/secure");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    bzero(s_buf, sizeof(char) * sizebuffer);   
+    bzero(get_s_buf, sizeof(char) * sizebuffer+1024);   
+    while (fgets(s_buf, sizebuffer, fp)!=NULL)
+    {
+      if(strstr(s_buf, "Login failed"))
+      {
+         strcat(get_s_buf, s_buf);
+      }
+
+      if(strstr(s_buf, "refused"))
+      {
+         strcat(get_s_buf, s_buf);
+      }
+
+      if(strstr(s_buf, "no such user"))
+      {
+         strcat(get_s_buf, s_buf);
+      }
+
+      if(strstr(s_buf, "Maximum login attempts"))
+      {
+         strcat(get_s_buf, s_buf);
+      }
+
+      if(strstr(s_buf, "SECURITY VIOLATION"))
+      {
+         strcat(get_s_buf, s_buf);
+      }
+    }
+    security_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(security_refused_textview));
+    utf8 = g_locale_to_utf8(get_s_buf, strlen(get_s_buf), NULL, NULL, NULL);
+    gtk_text_buffer_set_text(security_text_buffer, utf8, strlen(utf8));
+    fclose(fp);
+    if(utf8 !=NULL)
+    g_free(utf8);
+    free(s_buf);
+    free(get_s_buf);
+}
+
+
+// OK .. take it away
+void
+on_disc_treeview_map                   (GtkWidget       *widget,
+                                        gpointer         user_data)
+{
+}
+
+
+// Let this be
+gboolean
+on_userlist_treeview_button_press_event (GtkWidget       *widget,
+                                         GdkEventButton  *event,
+                                         gpointer         user_data)
+{
+// thought a rightclick did more harm then good, right...
+   return FALSE;
+}
+
+
+// If the row was doubleclicked
+void
+on_userlist_treeview_row_activated     (GtkTreeView     *treeview,
+                                        GtkTreePath     *arg1,
+                                        GtkTreeViewColumn *arg2,
+                                        gpointer         user_data)
+{
+   GtkTreeIter iter;
+   GtkTreeModel *list_store;
+   GtkTreeViewColumn *user_column;
+   gchar *username;
+   GtkTreePath *path;
+   list_store = gtk_tree_view_get_model(GTK_TREE_VIEW(userlist_treeview));
+   gtk_tree_view_get_cursor(GTK_TREE_VIEW(userlist_treeview), &path, &user_column);
+   gtk_tree_model_get_iter(list_store, &iter, path);
+   gtk_tree_model_get(list_store, &iter, 0, &username, -1);
+//   g_print("The username is: %s\n", username); // stays for a while just for the coolness of it heh.
+   strcpy(profile_name, username);
+
+   // Show the profile window.
+   GProFTPD = lookup_widget (GTK_WIDGET (treeview), "GProFTPD");
+   userlist_treeview = lookup_widget (GTK_WIDGET (treeview), "userlist_treeview");
+   entire_config_textview = lookup_widget (GTK_WIDGET (treeview), "entire_config_textview");
+
+   user_profile_window = create_user_profile_window ();
+   gtk_widget_show (user_profile_window);
+
+   if(username !=NULL)
+   g_free(username);
+   gtk_tree_path_free(path);
+}
+
+
+//OK .. fixme .. more values !! :)
+void
+on_profile_username_entry_map (GtkWidget       *widget,
+                               gpointer         user_data)
+{
+    // Adds the values to the user profile window.
+    FILE *fp;
+    char *new_buffer;
+    char *old_buffer;
+    char *user_buffer;
+    long size_buffer;
+    int profile_window_counter = 0;
+    int length;
+    G_CONST_RETURN char *length_buffer;
+    profile_home_directory_entry = lookup_widget (GTK_WIDGET (widget), "profile_home_directory_entry");
+    profile_username_entry = lookup_widget (GTK_WIDGET (widget), "profile_username_entry");
+    profile_group_entry = lookup_widget (GTK_WIDGET (widget), "profile_group_entry");
+    profile_require_password_entry = lookup_widget (GTK_WIDGET (widget), "profile_require_password_entry");
+    profile_max_logins_entry = lookup_widget (GTK_WIDGET (widget), "profile_max_logins_entry");
+
+    if ((fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
+    {
+        error_window = create_error_window ();
+        gtk_widget_show (error_window);       
+        return;
+    }
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+
+    old_buffer=(char *)malloc(size_buffer);
+    new_buffer=(char *)malloc(size_buffer);   
+    user_buffer=(char *)malloc(4096);        // good enough to hold one profile line heh
+
+    bzero(old_buffer, sizeof(char) * size_buffer);
+    bzero(user_buffer, sizeof(char) * 4096);
+    bzero(new_buffer, sizeof(char) * size_buffer);
+
+    sprintf(user_buffer, "User %s", profile_name); // profile_name is ~"global"
+    strcat(user_buffer, "\n"); // avoiding similar user error
+
+    // First of all .. get the home directory.
+    while (fgets((char*)old_buffer, size_buffer, fp)!=NULL)
+    {                                              
+       if (strstr((char*)old_buffer, user_buffer)!=NULL) // User USERNAME
+       {
+           // Set homedirectory
+           if (strlen(old_buffer)>0) old_buffer[strlen(old_buffer)-2] = 0;
+           {
+	       gtk_entry_set_text(GTK_ENTRY(profile_home_directory_entry), &new_buffer[11]); // cut away <Anonymous
+               
+               length_buffer = gtk_entry_get_text(GTK_ENTRY(profile_home_directory_entry));
+               length = strlen((char*)length_buffer);
+               gtk_editable_delete_text(GTK_EDITABLE(profile_home_directory_entry), length -3, length); // -1
+	       break;
+           }
+       }
+    strcpy(new_buffer, old_buffer);
+    }
+
+    rewind(fp);
+    while (fgets((char*)old_buffer, size_buffer, fp)!=NULL)
+    {
+              if (strstr((char*)old_buffer, user_buffer)!=NULL) // User_UserName
+              {
+                  strcpy(new_buffer, old_buffer);
+                  gtk_entry_set_text(GTK_ENTRY (profile_username_entry), &new_buffer[5]);
+		  length_buffer = gtk_entry_get_text(GTK_ENTRY(profile_username_entry));
+                  length = strlen((char*)length_buffer);
+                  gtk_editable_delete_text(GTK_EDITABLE(profile_username_entry), length -1, length);
+		  profile_window_counter = 1;
+    	      }
+              if ((strstr((char*)old_buffer, "Group")!=NULL && profile_window_counter == 1)) 
+              {
+                  strcpy(new_buffer, old_buffer);
+                  gtk_entry_set_text(GTK_ENTRY (profile_group_entry), &new_buffer[6]);
+		  length_buffer = gtk_entry_get_text(GTK_ENTRY(profile_group_entry));
+                  length = strlen((char*)length_buffer);
+                  gtk_editable_delete_text(GTK_EDITABLE(profile_group_entry), length -1, length);
+
+              }
+              if ((strstr((char*)old_buffer, "AnonRequirePassword")!=NULL && profile_window_counter == 1)) 
+              {
+                  strcpy(new_buffer, old_buffer);
+                  gtk_entry_set_text(GTK_ENTRY (profile_require_password_entry), &new_buffer[20]);
+		  length_buffer = gtk_entry_get_text(GTK_ENTRY(profile_require_password_entry));
+                  length = strlen((char*)length_buffer);
+                  gtk_editable_delete_text(GTK_EDITABLE(profile_require_password_entry), length -1, length);
+              }
+              if ((strstr((char*)old_buffer, "MaxClients")!=NULL && profile_window_counter == 1)) 
+              {
+                  strcpy(new_buffer, old_buffer);
+                  gtk_entry_set_text(GTK_ENTRY (profile_max_logins_entry), &new_buffer[11]);
+		  length_buffer = gtk_entry_get_text(GTK_ENTRY(profile_max_logins_entry));
+                  length = strlen((char*)length_buffer);
+                  gtk_editable_delete_text(GTK_EDITABLE(profile_max_logins_entry), length -1, length);
+              }
+              if ((strstr((char*)old_buffer, "</Anonymous>")!=NULL && profile_window_counter == 1)) // break at the end
+              { 
+                  break;    
+              }
+    }
+    fclose(fp);
+    free(old_buffer);
+    free(new_buffer);
+    free(user_buffer);
+}
+
+
+// OK .. fixme and more values .. mange
+void
+on_user_profile_window_change_button_clicked  (GtkButton       *button,
+                                               gpointer         user_data)
+{
+    // Change a profile from the profile window
+    FILE *fp;
+    long size_buffer;
+    char *changed_buffer;
+    char *old_buffer;
+    char UserUsername[1024]="";
+    char *szLineBuffer;
+    char *szUserBuffer;
+    char *config;
+    G_CONST_RETURN gchar *directory_profile_change;
+    G_CONST_RETURN gchar *username_profile_change;
+    G_CONST_RETURN gchar *group_profile_change;
+    G_CONST_RETURN gchar *require_password_profile_change;
+    G_CONST_RETURN gchar *max_clients_profile_change;
+    int i=0;
+
+
+    char passwd_user[1024]="";
+    G_CONST_RETURN gchar *password;
+    G_CONST_RETURN gchar *username;
+    int length=0;
+
+
+user_profile_window = lookup_widget(GTK_WIDGET(button), "user_profile_window");
+profile_password_entry = lookup_widget(GTK_WIDGET(button), "profile_password_entry");
+profile_username_entry = lookup_widget(GTK_WIDGET(button), "profile_username_entry");
+
+    length = strlen(password = gtk_entry_get_text(GTK_ENTRY(profile_password_entry)));
+    // If the user has written a password thats too short 
+    if ( length < 6 && length > 0 )
+    {
+       strcpy(info_buffer, "\n     The minimum password length is 6 chars.\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       printf("\nError changing password showing a popup\n");
+       return;
+    }
+    // This is used later
+    username = gtk_entry_get_text(GTK_ENTRY(profile_username_entry));
+
+    // If the user has written a new username
+    if (length >= 6)
+    {
+       password = gtk_entry_get_text(GTK_ENTRY(profile_password_entry));
+       // Change the users password
+       strcpy(passwd_user, "passwd ");
+       strcat(passwd_user, username);
+//       strcpy(pass, password);
+       if ( (fp = popen(passwd_user,"w")) == NULL)
+       {
+          strcpy(info_buffer, "\n     Error changing the password.\n");
+          error_window = create_error_window ();
+          gtk_widget_show (error_window);
+          printf("\nError changing the password\n");
+       }
+       usleep(100000);
+       fputs(password, fp);
+       usleep(100000);
+       fseek(fp, 0, SEEK_END);
+       fputs(password, fp);
+       usleep(100000);
+       pclose(fp);
+    }
+
+
+
+// OK
+
+    strcpy(UserUsername, "User ");
+    strcat(UserUsername, username);
+    strcat(UserUsername, "\n");  // Avoiding similar user deletion 
+    // Get the users ENTIRE profile and make the requested changes to it
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
+    {
+       strcpy(info_buffer, "\nCant open @FINKPREFIX@/etc/proftpd.conf\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+
+    changed_buffer=(char *)malloc(size_buffer + 4096);
+    bzero(changed_buffer, sizeof(char) * size_buffer + 4096);
+
+    old_buffer=(char *)malloc(size_buffer + 4096);        
+    bzero(old_buffer, sizeof(char) * size_buffer + 4096); 
+
+    // Perhaps the whole thing needs to be done a bit better.
+    while (fgets((char*)old_buffer, size_buffer, fp)!=NULL)
+    {
+          // If the username is found, start editing its profile
+          if (strstr((char*)old_buffer, UserUsername)!=NULL)
+          {
+             // Set the new home directory path
+	     strcpy(changed_buffer, "\n<Anonymous ");
+	     strcat(changed_buffer, directory_profile_change = gtk_entry_get_text(GTK_ENTRY(profile_home_directory_entry)));
+             strcat(changed_buffer, "> \n"); // extra space or the userlist will look bloated .. (return char ?)
+	     strcat(changed_buffer, UserUsername); // set username(Has a Newline) ( NO CHANGE )
+             strcat(changed_buffer, "Group ");
+             strcat(changed_buffer, group_profile_change = gtk_entry_get_text(GTK_ENTRY(profile_group_entry)));
+	     strcat(changed_buffer, "\n");
+             strcat(changed_buffer, "AnonRequirePassword ");
+	     strcat(changed_buffer, require_password_profile_change = gtk_entry_get_text(GTK_ENTRY(profile_require_password_entry)));
+	     strcat(changed_buffer, "\n");
+	     strcat(changed_buffer, "MaxClients ");
+	     strcat(changed_buffer, max_clients_profile_change = gtk_entry_get_text(GTK_ENTRY(profile_max_logins_entry)));
+	     strcat(changed_buffer, "\n");
+             i=1;
+	  }
+
+          if(i>0) // Get everything else to the end of the profile at the right place (maybe a bit sloppy)
+	  {
+	     i++;
+             if(i>5)
+             {
+	        strcat(changed_buffer, old_buffer);
+             }
+	  }
+	
+	  // if </Anonymous> stop gathering artifacts :)
+          if ((strstr((char*)old_buffer, "</Anonymous>")!=NULL) && i>1) 
+	  {
+             break;
+          }
+    }
+    fclose(fp);
+    free(old_buffer);
+
+    // Delete the users profile
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
+    {
+       strcpy(info_buffer, "\nCant open @FINKPREFIX@/etc/proftpd.conf\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+
+    config=(char *)malloc(size_buffer+8192);   // for the profile changes
+    szLineBuffer=(char *)malloc(size_buffer);
+    szUserBuffer=(char *)malloc(size_buffer);
+    bzero(config, sizeof(char) * size_buffer+8192);
+    bzero(szLineBuffer, sizeof(char) * size_buffer);
+    bzero(szUserBuffer, sizeof(char) * size_buffer);
+
+    while (fgets(szLineBuffer, size_buffer, fp) !=NULL)
+    {
+        if (strstr(szLineBuffer, "<Anonymous ")!=NULL)  
+        {
+            strcpy(szUserBuffer, szLineBuffer);        
+	    	    
+            while(strstr(szLineBuffer, "</Anonymous>")==NULL) 
+	    {
+	       if (fgets(szLineBuffer, size_buffer, fp)==NULL)
+	       {
+		   break;
+	       }
+               strcat(szUserBuffer, szLineBuffer); 
+	    }
+            if (strstr(szUserBuffer, UserUsername)==NULL)   
+            {
+                strcat(config, szUserBuffer); 
+            }
+         }
+         else
+            strcat(config, szLineBuffer);
+    } 	  
+    fclose(fp);
+    free(szLineBuffer);
+    free(szUserBuffer);
+
+    // Add the new config with the changed profile
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "w+")) == NULL) 
+    {
+        return;
+    }
+    strcat(config, changed_buffer); 
+    fputs(config, fp);
+    fclose(fp);
+    free(changed_buffer);
+
+    free(config);
+
+    update_user_list(userlist_treeview, NULL);
+    update_entire_configuration(GProFTPD, NULL);
+    // There is no need to update the global tab.
+    gtk_widget_destroy(user_profile_window);
+    system("killall -1 proftpd");
+}
+
+
+void
+on_delete_profile_window_button_clicked (GtkButton       *button,
+                                         gpointer         user_data)
+{
+    //  Delete the user and profile
+    FILE *fp;
+    int length;
+    long size_buffer;
+    G_CONST_RETURN gchar *username_del;
+    char *szLineBuffer;
+    char *szUserBuffer;
+    char *userdel_buffer;
+    char *UserUsername;
+    char *config;
+
+    profile_username_entry = lookup_widget(GTK_WIDGET(button), "profile_username_entry");
+    username_del = gtk_entry_get_text(GTK_ENTRY(profile_username_entry));
+
+    // If the namefield in username_del is empty inform that this cant be done.
+    length = strlen(username_del = gtk_entry_get_text(GTK_ENTRY(profile_username_entry)));
+    if ( length == 0 ) 
+    {
+       strcpy(info_buffer, "\nThe profile didnt exist.\n");
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    // Delete the selected user           
+    userdel_buffer=(char *)malloc(4096);
+    bzero(userdel_buffer, sizeof(char) * 4096);   
+    strcpy(userdel_buffer, "userdel ");
+    strcat(userdel_buffer, username_del);
+    if ( (fp = popen(userdel_buffer, "r")) == NULL)
+    {
+       printf("\nManually delete that user, couldnt delete it for some reason\n");
+       free(userdel_buffer);
+       return;
+    }
+    pclose(fp);
+    free(userdel_buffer);
+    UserUsername=(char *)malloc(4096);
+    bzero(UserUsername, sizeof(char) * 4096);   
+    strcpy(UserUsername, "User ");
+    strcat(UserUsername, username_del = gtk_entry_get_text(GTK_ENTRY(profile_username_entry)));
+    strcat(UserUsername, "\n"); // this is very important, or it will delete similar users.
+    // Delete the configuration for the deleted user
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
+    {
+       strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf\n");
+       strcat(info_buffer, "Run GProFTPD as root\n");
+       free(UserUsername);
+       error_window = create_error_window ();
+       gtk_widget_show (error_window);
+       return;
+    }
+    printf("\nDeleting the profile\n");
+    fseek(fp, 0, SEEK_END);
+    size_buffer = ftell(fp);
+    rewind(fp);
+    config=(char *)malloc(size_buffer); 
+    bzero(config, sizeof(char) * size_buffer);
+    szLineBuffer=(char *)malloc(size_buffer);
+    szUserBuffer=(char *)malloc(size_buffer);
+    bzero(szLineBuffer, sizeof(char) * size_buffer);
+    bzero(szUserBuffer, sizeof(char) * size_buffer);
+    while (fgets(szLineBuffer, size_buffer, fp) !=NULL)
+    {
+        if (strstr(szLineBuffer, "<Anonymous ")!=NULL)  
+        {
+            strcpy(szUserBuffer, szLineBuffer);        
+	    	    
+            while(strstr(szLineBuffer, "</Anonymous>")==NULL) 
+	    {
+	       if (fgets(szLineBuffer, size_buffer, fp)==NULL)
+	       {
+		   break;
+	       }
+               strcat(szUserBuffer, szLineBuffer); 
+	    }
+            if (strstr(szUserBuffer, UserUsername)==NULL)   
+            {
+                strcat(config, szUserBuffer); 
+            }
+         }
+         else
+            strcat(config, szLineBuffer);
+    } 	  
+    fclose(fp);
+    free(UserUsername);
+    free(szLineBuffer);
+    free(szUserBuffer);
+    // Add the new config without the deleted profile
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "w+")) == NULL) 
+    {
+        return;
+    }
+    fputs(config, fp);
+    fclose(fp);
+    free(config);
+    // Update the userlist and entire_configuration.  
+    printf("\nThe user and profile has been deleted.\n");
+    update_user_list(userlist_treeview, NULL);
+    update_entire_configuration(GProFTPD, NULL);
+    system("killall -1 proftpd");
+    gtk_widget_destroy(user_profile_window);
+}
+
+
+// OK .. make a size_check .. 8192 is big though
+// Change entry name
+void
+on_entry289_map                        (GtkWidget       *widget,
+                                        gpointer         user_data)
+{
+   // Update the disc tab .. the entry is "the server is currently" (change the entrybox name)
+   FILE *fp;
+   GtkListStore *model;
+   GtkTreeIter iter;
+   GtkCellRenderer *cell;
+   GtkTreeViewColumn *mount_column, *free_column, *used_column, *total_column, *percent_column, *device_column;
+   GtkTreePath *path;
+   gboolean edit;
+   gchar *utf8=NULL;
+   int counter = 0;
+   char buf[8192]="";
+   char new_buf[8192]="";
+   char insert_buf[8192]="";
+   int i=0;
+   int begin=0;
+   int end=0;
+
+   disc_treeview = lookup_widget (GTK_WIDGET (widget), "disc_treeview");
+   model = gtk_list_store_new(6, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
+   gtk_tree_view_set_model(GTK_TREE_VIEW(disc_treeview), GTK_TREE_MODEL (model));
+   cell = gtk_cell_renderer_text_new();
+   gtk_list_store_clear(model);
+
+   mount_column = gtk_tree_view_column_new_with_attributes("Mounted on", cell, "text", 0, NULL);
+   free_column = gtk_tree_view_column_new_with_attributes("Free space", cell, "text", 1, NULL);
+   used_column = gtk_tree_view_column_new_with_attributes("Used space", cell, "text", 2, NULL);
+   total_column = gtk_tree_view_column_new_with_attributes("Total space", cell, "text", 3, NULL);
+   percent_column = gtk_tree_view_column_new_with_attributes("Percent used", cell, "text", 4, NULL);
+   device_column = gtk_tree_view_column_new_with_attributes("Device", cell, "text", 5, NULL);
+
+   // This was hard work. 
+   if ( (fp = popen("df -h |grep / > /tmp/gproftpd_disc", "r")) == NULL)
+   {
+     printf("\nError running df -h\n");
+   }
+   pclose(fp);
+
+   // Ugly "workaround" for popen borkage
+   if ( (fp = fopen("/tmp/gproftpd_disc", "r")) == NULL)
+   {
+     printf("\nError running df -h\n");
+   }
+
+   strcpy(new_buf, " "); // Add space before.
+   while(fgets(buf, BUFSIZ, fp)!=NULL)
+   {
+      if(new_buf[i]==' ') // making sure that it has spaces
+      strcat(new_buf, " ");
+      strcat(new_buf, buf);
+   }
+   strcat(new_buf, " "); // Add space after.
+
+   // Get each value from df and insert them and new lines after each 6:th value 
+   for(i = 0; i <= strlen(new_buf); i++) // Step line by char
+   {
+      if(new_buf[i]!=' ') // If Space
+      {
+         begin=i;
+         counter++;	
+
+         while(new_buf[i]) // while parsing new_buf chars
+         {
+            i++;
+            if(new_buf[i]==' ') // If Space
+            {
+               end=i;
+	     
+               if(counter ==1) // FileSystem
+	       {
+                  snprintf(insert_buf, end-begin+1, "%s", new_buf+begin);
+                  utf8 = g_locale_to_utf8(insert_buf, strlen(insert_buf), NULL, NULL, NULL);
+                  gtk_list_store_append(GTK_LIST_STORE(model), &iter); // add lines
+                  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 5, utf8, -1);
+	       }
+
+               if(counter ==2) // Total Size
+  	       {
+                  snprintf(insert_buf, end-begin+1, "%s", new_buf+begin);
+                  utf8 = g_locale_to_utf8(insert_buf, strlen(insert_buf), NULL, NULL, NULL);
+                  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 3, utf8, -1);
+ 	       }
+
+               if(counter ==3)
+	       {
+                  snprintf(insert_buf, end-begin+1, "%s", new_buf+begin);
+                  utf8 = g_locale_to_utf8(insert_buf, strlen(insert_buf), NULL, NULL, NULL);
+                  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 2, utf8, -1);
+	       }
+
+               if(counter ==4) // Free Space
+	       {
+                  snprintf(insert_buf, end-begin+1, "%s", new_buf+begin);
+                  utf8 = g_locale_to_utf8(insert_buf, strlen(insert_buf), NULL, NULL, NULL);
+                  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 1, utf8, -1);
+	       }
+
+               if(counter ==5) // Percent Used
+	       {
+                  snprintf(insert_buf, end-begin+1, "%s", new_buf+begin);
+                  utf8 = g_locale_to_utf8(insert_buf, strlen(insert_buf), NULL, NULL, NULL);
+                  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 4, utf8, -1);
+	       }
+
+               if(counter ==6) // Mounted On
+	       {
+                  snprintf(insert_buf, end-begin+1, "%s", new_buf+begin);
+                  utf8 = g_locale_to_utf8(insert_buf, strlen(insert_buf), NULL, NULL, NULL);
+                  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 0, utf8, -1);
+	          counter=0;
+	       }
+               break;
+            } 
+         }
+      }
+      continue;
+   }
+   gtk_tree_view_append_column(GTK_TREE_VIEW(disc_treeview), GTK_TREE_VIEW_COLUMN(mount_column));
+   gtk_tree_view_append_column(GTK_TREE_VIEW(disc_treeview), GTK_TREE_VIEW_COLUMN(free_column));
+   gtk_tree_view_append_column(GTK_TREE_VIEW(disc_treeview), GTK_TREE_VIEW_COLUMN(used_column));
+   gtk_tree_view_append_column(GTK_TREE_VIEW(disc_treeview), GTK_TREE_VIEW_COLUMN(total_column));
+   gtk_tree_view_append_column(GTK_TREE_VIEW(disc_treeview), GTK_TREE_VIEW_COLUMN(percent_column));
+   gtk_tree_view_append_column(GTK_TREE_VIEW(disc_treeview), GTK_TREE_VIEW_COLUMN(device_column));
+   fclose(fp);
+   if(utf8 !=NULL)
+   g_free(utf8);
+   system("rm -f /tmp/gproftpd_disc");
+}
+
+
+// OK
+void
+on_disc_refresh_button_clicked         (GtkButton       *button,
+                                        gpointer         user_data)
+{
+   // Update the disc tab .. the entry is "the server is currently" (change the entrybox name)
+   FILE *fp;
+   GtkListStore *model;
+   GtkTreeIter iter;
+   GtkCellRenderer *cell;
+   GtkTreeViewColumn *mount_column, *free_column, *used_column, *total_column, *percent_column, *device_column;
+   GtkTreePath *path;
+   gboolean edit;
+   gchar *utf8=NULL;
+   int counter = 0;
+   char buf[8192]="";
+   char new_buf[8192]="";
+   char insert_buf[8192]="";
+   // Must have these set when updating.
+   int i=0;
+   int begin=0;
+   int end=0;
+
+   disc_treeview = lookup_widget (GTK_WIDGET (button), "disc_treeview");
+   model = gtk_list_store_new(6, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
+   gtk_tree_view_set_model(GTK_TREE_VIEW(disc_treeview), GTK_TREE_MODEL (model));
+   cell = gtk_cell_renderer_text_new();
+   gtk_list_store_clear(model);
+   mount_column = gtk_tree_view_column_new_with_attributes("Mounted on", cell, "text", 0, NULL);
+   free_column = gtk_tree_view_column_new_with_attributes("Free space", cell, "text", 1, NULL);
+   used_column = gtk_tree_view_column_new_with_attributes("Used space", cell, "text", 2, NULL);
+   total_column = gtk_tree_view_column_new_with_attributes("Total space", cell, "text", 3, NULL);
+   percent_column = gtk_tree_view_column_new_with_attributes("Percent used", cell, "text", 4, NULL);
+   device_column = gtk_tree_view_column_new_with_attributes("Device", cell, "text", 5, NULL);
+
+   // This was hard work. 
+   if ( (fp = popen("df -h |grep /", "r")) == NULL) // was r
+   {
+     printf("\nError running df -h\n");
+   }
+   fflush(stdin); // stdio FILE streams are buffered
+   fflush(stdout);
+
+   strcpy(new_buf, " "); // Add space before.
+   while(fgets(buf, BUFSIZ, fp)!=NULL)
+   {
+      if(new_buf[i]==' ') // making sure that it has spaces
+      strcat(new_buf, " ");
+      strcat(new_buf, buf);
+   }
+   strcat(new_buf, " "); // Add space after.
+
+   // Get each value from df and insert them and new lines after each 6:th value 
+   for(i = 0; i <= strlen(new_buf); i++) // Step line by char
+   {
+      if(new_buf[i]!=' ') // If Space
+      {
+         begin=i;
+         counter++;	  // No space
+
+         while(new_buf[i]) // while parsing new_buf chars
+         {
+            i++;
+            if(new_buf[i]==' ') // If Space
+            {
+               end=i;
+	     
+               if(counter ==1) // FileSystem
+	       {
+                  snprintf(insert_buf, end-begin+1, "%s", new_buf+begin);
+                  utf8 = g_locale_to_utf8(insert_buf, strlen(insert_buf), NULL, NULL, NULL);
+                  gtk_list_store_append(GTK_LIST_STORE(model), &iter); // add lines
+                  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 5, utf8, -1);
+	       }
+
+               if(counter ==2) // Total Size
+  	       {
+                  snprintf(insert_buf, end-begin+1, "%s", new_buf+begin);
+                  utf8 = g_locale_to_utf8(insert_buf, strlen(insert_buf), NULL, NULL, NULL);
+                  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 3, utf8, -1);
+ 	       }
+
+               if(counter ==3)
+	       {
+                  snprintf(insert_buf, end-begin+1, "%s", new_buf+begin);
+                  utf8 = g_locale_to_utf8(insert_buf, strlen(insert_buf), NULL, NULL, NULL);
+                  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 2, utf8, -1);
+	       }
+
+               if(counter ==4) // Free Space
+	       {
+                  snprintf(insert_buf, end-begin+1, "%s", new_buf+begin);
+                  utf8 = g_locale_to_utf8(insert_buf, strlen(insert_buf), NULL, NULL, NULL);
+                  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 1, utf8, -1);
+	       }
+
+               if(counter ==5) // Percent Used
+	       {
+                  snprintf(insert_buf, end-begin+1, "%s", new_buf+begin);
+                  utf8 = g_locale_to_utf8(insert_buf, strlen(insert_buf), NULL, NULL, NULL);
+                  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 4, utf8, -1);
+	       }
+
+               if(counter ==6) // Mounted On
+	       {
+                  snprintf(insert_buf, end-begin+1, "%s", new_buf+begin);
+                  utf8 = g_locale_to_utf8(insert_buf, strlen(insert_buf), NULL, NULL, NULL);
+                  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 0, utf8, -1);
+	          counter=0;
+	       }
+               break;
+            } 
+         }
+      }
+      continue;
+   }
+   pclose(fp);
+   if(utf8 !=NULL)
+   g_free(utf8);
+}
diff -ruN gproftpd-8.0.1.orig/src/callbacks.c gproftpd-8.0.1/src/callbacks.c
--- gproftpd-8.0.1.orig/src/callbacks.c	2002-10-10 07:13:03.000000000 -0600
+++ gproftpd-8.0.1/src/callbacks.c	2002-10-25 11:33:03.000000000 -0600
@@ -150,10 +150,10 @@
    maximum_column = gtk_tree_view_column_new_with_attributes("Maximum simultaneous connections", cell, "text", 4, NULL);
    gtk_list_store_clear(model);
 
-   if ( (fp = fopen("/etc/proftpd.conf", "r")) == NULL)
+   if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
    {
        // create info window and show info_buffer.
-       strcpy(info_buffer, "Cant open /etc/proftpd.conf\n");
+       strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf\n");
        strcat(info_buffer, "Run GProFTPD as root\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window); 
@@ -248,9 +248,9 @@
     GtkTextBuffer *entire_text_buffer;
     gchar *utf8=NULL;
 
-    if( (fp = fopen("/etc/proftpd.conf", "r")) == NULL )
+    if( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL )
     {
-       strcpy(info_buffer, "Cant open /etc/proftpd.conf.\n\n");
+       strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf.\n\n");
        strcat(info_buffer, "Are you running GProFTPD as root ?.\n");
        strcat(info_buffer, "im unable to update the entire configuration tab\n");
        error_window = create_error_window ();
@@ -351,9 +351,9 @@
     global_read_hard_bps = lookup_widget (GTK_WIDGET (widget), "global_read_hard_bps");
     global_write_free_bytes = lookup_widget (GTK_WIDGET (widget), "global_write_free_bytes");
     global_write_hard_bps = lookup_widget (GTK_WIDGET (widget), "global_write_hard_bps");
-    if ( (fp = fopen("/etc/proftpd.conf", "r")) == NULL)
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
     {
-       strcpy(info_buffer, "Cant open /etc/proftpd.conf\n\n");
+       strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf\n\n");
        strcat(info_buffer, "Are you running GProFTPD as root ?.\n");
        strcat(info_buffer, "im unable to update the global configuration tab\n");
        error_window = create_error_window ();
@@ -778,9 +778,9 @@
         strcpy(out_speed_1_buffer,"");
 
         // Get incoming speed 1 
-        if ( (speed_file = popen("cat /proc/net/dev |grep eth0 |cut -c8- |awk '{print $1}' |tr -d \"\r\n\"", "r")) == NULL)
+        if ( (speed_file = popen("netstat -i -n -b | grep en0 | head -n1 | awk '{print $7}' |tr -d \"\r\n\"", "r")) == NULL)
         {
-           printf("cant open /proc/net/dev");
+           printf("cant open en0");
            return( 0 );      
         }
         while (fgets(in_speed_1_buffer, 4096, speed_file)!=NULL)
@@ -788,9 +788,9 @@
         }
         pclose(speed_file);
         // Get outgoing speed 1
-        if ( (speed_file = popen("cat /proc/net/dev |grep eth0 |cut -c8- |awk '{print $9}' |tr -d \"\r\n\"", "r")) == NULL)
+        if ( (speed_file = popen("netstat -i -n -b | grep en0 | head -n1 | awk '{print $10}' |tr -d \"\r\n\"", "r")) == NULL)
         {
-           printf("cant open /proc/net/dev");
+           printf("cant open en0");
            return( 0 );
         }
         while (fgets(out_speed_1_buffer, 4096, speed_file)!=NULL)
@@ -810,9 +810,9 @@
              char out_speed_2_buffer[4096]="";
        
              // Get incoming speed 2
-             if ( (speed_file = popen("cat /proc/net/dev |grep eth0 |cut -c8- |awk '{print $1}' |tr -d \"\r\n\"", "r")) == NULL)
+             if ( (speed_file = popen("netstat -i -n -b | grep en0 | head -n1 | awk '{print $7}' |tr -d \"\r\n\"", "r")) == NULL)
              {
-                printf("cant open /proc/net/dev");
+                printf("cant open en0");
                 return( 0 );   
              }
              while (fgets(in_speed_2_buffer, 4096, speed_file)!=NULL)
@@ -821,9 +821,9 @@
              pclose(speed_file);
 
              // Get outgoing speed 2
-             if ( (speed_file = popen("cat /proc/net/dev |grep eth0 |cut -c8- |awk '{print $9}' |tr -d \"\r\n\"", "r")) == NULL)
+             if ( (speed_file = popen("netstat -i -n -b | grep en0 | head -n1 | awk '{print $10}' |tr -d \"\r\n\"", "r")) == NULL)
              {
-             printf("cant open /proc/net/dev");
+             printf("cant open en0");
              return( 0 );      
              }
              while (fgets(out_speed_2_buffer, 4096, speed_file)!=NULL)
@@ -884,15 +884,15 @@
     gchar *utf8=NULL;            
     // Inserts the user profile when gproftpd is started 
     // ( because otherwise it wont have mapped if the user just adds a user not looking at the profile tab) 
-    if ( (fp = fopen("/etc/gproftpd/useradd-profile", "r")) == NULL)
+    if ( (fp = fopen("@FINKPREFIX@/etc/gproftpd/useradd-profile", "r")) == NULL)
     {
-       strcpy(info_buffer, "Couldnt find /etc/gproftpd/useradd-profile\n");
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/etc/gproftpd/useradd-profile\n");
        strcat(info_buffer, "dont add users if this happens.\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
        return;
     }
-    // Set the profile_tab_text from /etc/gproftpd/useradd-profile
+    // Set the profile_tab_text from @FINKPREFIX@/etc/gproftpd/useradd-profile
     profile_text = lookup_widget (GTK_WIDGET (widget), "profile_text");
 
     fseek(fp, 0, SEEK_END);
@@ -1027,12 +1027,12 @@
     global_read_hard_bps = lookup_widget (GTK_WIDGET (widget), "global_read_hard_bps");
     global_write_free_bytes = lookup_widget (GTK_WIDGET (widget), "global_write_free_bytes");
     global_write_hard_bps = lookup_widget (GTK_WIDGET (widget), "global_write_hard_bps");
-    if ( (fp = fopen("/etc/proftpd.conf", "r")) == NULL)
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
     {
-       strcpy(info_buffer, "Cant open /etc/proftpd.conf\n\n");
+       strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf\n\n");
        strcat(info_buffer, "If youre running GProFTPD as root, close this window then press\n");
        strcat(info_buffer, "the entire configuration tab then press the default button\n"); 
-       strcat(info_buffer, "wich will set the default configuration to /etc/proftpd.conf\n");
+       strcat(info_buffer, "wich will set the default configuration to @FINKPREFIX@/etc/proftpd.conf\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
        return;
@@ -1501,9 +1501,9 @@
     current_change_read_hard_bps = gtk_entry_get_text(GTK_ENTRY(global_read_hard_bps));       // disqualified :)
     current_change_write_free_bytes = gtk_entry_get_text(GTK_ENTRY(global_write_free_bytes));
     current_change_write_hard_bps = gtk_entry_get_text(GTK_ENTRY(global_write_hard_bps));
-    if ( (fp = fopen("/etc/proftpd.conf", "r")) == NULL)
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
     {
-       strcpy(info_buffer, "\nCant open /etc/proftpd.conf\n");
+       strcpy(info_buffer, "\nCant open @FINKPREFIX@/etc/proftpd.conf\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
        return;
@@ -1681,9 +1681,9 @@
     free(szBuffer);
     free(change_srv_ident);
     // Write the edited configuration to proftpd.conf
-    if ( (fp = fopen("/etc/proftpd.conf", "w+")) == NULL)
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "w+")) == NULL)
     {
-       strcpy(info_buffer, "\nCant open /etc/proftpd.conf for writing\n");
+       strcpy(info_buffer, "\nCant open @FINKPREFIX@/etc/proftpd.conf for writing\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
        return;
@@ -1756,7 +1756,7 @@
     strcpy(useradd_command, "adduser ");
     strcat(useradd_command, username_add);
     strcat(useradd_command, " -d /home/ftp ");
-    strcat(useradd_command, "-c ftp-user -s /bin/false ");
+    strcat(useradd_command, "-c ftp-user -s /usr/bin/false ");
     fp = popen(useradd_command, "r");
     pclose(fp);
     // set the users password
@@ -1781,10 +1781,10 @@
     strcat(first_part_profile, "\nGroup ");
     strcat(first_part_profile, username_add);
     strcat(first_part_profile, "\n");
-    // checks if the user exists in /etc/proftpd.conf put result to a buffer. (its the exact username)
+    // checks if the user exists in @FINKPREFIX@/etc/proftpd.conf put result to a buffer. (its the exact username)
     user_check=(char *)malloc(4096);
     bzero(user_check, sizeof(char) * 4096);
-    strcpy(user_check, "grep -w \"User\" /etc/proftpd.conf |grep -w \"");
+    strcpy(user_check, "grep -w \"User\" @FINKPREFIX@/etc/proftpd.conf |grep -w \"");
     strcat(user_check, username_add);
     strcat(user_check, "\" |cut -f2 -d\" \"");
     fp = popen(user_check, "r");
@@ -1810,8 +1810,8 @@
     free(check_buffer);
     free(string);
     printf("\nUser does NOT exist -- Creating a profile\n");
-    // Get the second part profile from /etc/gproftpd/useradd-profile and combine
-    fp = fopen("/etc/gproftpd/useradd-profile", "r");
+    // Get the second part profile from @FINKPREFIX@/etc/gproftpd/useradd-profile and combine
+    fp = fopen("@FINKPREFIX@/etc/gproftpd/useradd-profile", "r");
     fseek(fp, 0, SEEK_END);
     size_buffer = ftell(fp);
     rewind(fp);
@@ -1823,7 +1823,7 @@
     }
     fclose (fp);
     free(second_part_profile);
-    fp = fopen("/etc/proftpd.conf", "a");
+    fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "a");
     fputs(first_part_profile, fp);
     fclose(fp);
     // make a ftp homedirectory for the user
@@ -1883,7 +1883,7 @@
     anon_path_entry = lookup_widget (GTK_WIDGET (button), "anon_path_entry");
     anon_password_entry = lookup_widget (GTK_WIDGET (button), "anon_password_entry");
     // Check if "User anonymous" already exists then return.
-    fp = fopen("/etc/proftpd.conf", "r");
+    fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r");
     fseek(fp, 0, SEEK_END);
     size_buffer = ftell(fp);
     rewind(fp);
@@ -1907,7 +1907,7 @@
     // Make the anonymous user to add.
     strcpy(useradd_command, "adduser anonymous");
     strcat(useradd_command, " -d /home/ftp ");
-    strcat(useradd_command, "-c ftp-user -s /bin/false");
+    strcat(useradd_command, "-c ftp-user -s /usr/bin/false");
     // Check that we have a sane length password.
     length = strlen(gtk_entry_get_text(GTK_ENTRY(anon_password_entry)));
     if(length < 6){
@@ -1939,7 +1939,7 @@
     strcat(fix_dir, " ; rm -f /home/ftp/.gtkrc");
     fp = popen(fix_dir, "r");
     pclose(fp);
-    // Add the anonymous profile to /etc/proftpd.conf. 
+    // Add the anonymous profile to @FINKPREFIX@/etc/proftpd.conf. 
     strcpy(anon_profile, "\n");
     strcat(anon_profile, "<Anonymous ");
     strcat(anon_profile, anon_directory_path = gtk_entry_get_text(GTK_ENTRY(anon_path_entry)));
@@ -1954,7 +1954,7 @@
     strcat(anon_profile, "DenyAll\n");
     strcat(anon_profile, "</Limit>\n");
     strcat(anon_profile, "</Anonymous>\n");
-    fp = fopen("/etc/proftpd.conf", "a");
+    fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "a");
     fputs(anon_profile, fp);
     fclose(fp);
     // Add the directory if it doesnt exist.
@@ -1990,8 +1990,8 @@
                                         gpointer         user_data)
 {
     system("killall -9 proftpd");
-    system("rm -f /etc/shutmsg");
-    system("proftpd -c /etc/proftpd.conf");
+    system("rm -f @FINKPREFIX@/etc/shutmsg");
+    system("proftpd -c @FINKPREFIX@/etc/proftpd.conf");
 }
 
 
@@ -2036,13 +2036,13 @@
     gchar *utf8=NULL;
     int length;
     entire_config_textview = lookup_widget (GTK_WIDGET (widget), "entire_config_textview");
-    if( (fp = fopen("/etc/proftpd.conf", "r")) == NULL )
+    if( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL )
     {
-        strcpy(info_buffer, "Cant open /etc/proftpd.conf.\n\n");
+        strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf.\n\n");
         strcat(info_buffer, "If youre running GProFTPD as root\n");
         strcat(info_buffer, "press the default button.\n\n");
         strcat(info_buffer, "This will add the default configuration\n");
-        strcat(info_buffer, "overwriting /etc/proftpd.conf.\n");
+        strcat(info_buffer, "overwriting @FINKPREFIX@/etc/proftpd.conf.\n");
         error_window = create_error_window ();
         gtk_widget_show (error_window);
         return;
@@ -2088,8 +2088,8 @@
     entire_config_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(entire_config_textview));
     gtk_text_buffer_get_bounds(entire_config_text_buffer, &start, &end);
     config_buffer = gtk_text_iter_get_text(&start, &end);
-    // Put the newly written entire_configuration text to /etc/proftpd.conf
-    fp = fopen("/etc/proftpd.conf", "w+");
+    // Put the newly written entire_configuration text to @FINKPREFIX@/etc/proftpd.conf
+    fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "w+");
     fputs (config_buffer, fp);
     fclose (fp);
 
@@ -2128,22 +2128,22 @@
     gchar *utf8=NULL;
     GtkTextBuffer *file_text_buffer;
     files_textview = lookup_widget (GTK_WIDGET (widget), "files_textview");
-    if( (fp = fopen("/var/log/xferlog", "r")) == NULL)
+    if( (fp = fopen("@FINKPREFIX@/var/log/xferlog", "r")) == NULL)
     {
-       strcpy(info_buffer, "Cant find /var/log/xferlog.\n\n");
+       strcpy(info_buffer, "Cant find @FINKPREFIX@/var/log/xferlog.\n\n");
        strcat(info_buffer, "If youre running GProFTPD as root\n");
        strcat(info_buffer, "the xferlog has been added for you.\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
-       system("touch /var/log/xferlog");
+       system("touch @FINKPREFIX@/var/log/xferlog");
        return;
     }
     fclose(fp);
 
 
-    if( (fp = fopen("/var/log/xferlog", "r")) == NULL)
+    if( (fp = fopen("@FINKPREFIX@/var/log/xferlog", "r")) == NULL)
     {
-       printf("\nopen /var/log/xferlog failed\n");
+       printf("\nopen @FINKPREFIX@/var/log/xferlog failed\n");
     }
     fseek(fp, 0, SEEK_END);
     size_buffer = ftell(fp);
@@ -2184,21 +2184,21 @@
     gchar *utf8=NULL;
     GtkTextBuffer *file_text_buffer;
     files_textview = lookup_widget (GTK_WIDGET (button), "files_textview");
-    if( (fp = fopen("/var/log/xferlog", "r")) == NULL)
+    if( (fp = fopen("@FINKPREFIX@/var/log/xferlog", "r")) == NULL)
     {
-       strcpy(info_buffer, "Cant find /var/log/xferlog.\n\n");
+       strcpy(info_buffer, "Cant find @FINKPREFIX@/var/log/xferlog.\n\n");
        strcat(info_buffer, "If youre running GProFTPD as root\n");
        strcat(info_buffer, "the xferlog has been added for you.\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
-       system("touch /var/log/xferlog");
+       system("touch @FINKPREFIX@/var/log/xferlog");
        return;
     }
     fclose(fp);
 
-    if( (fp = fopen("/var/log/xferlog", "r")) == NULL)
+    if( (fp = fopen("@FINKPREFIX@/var/log/xferlog", "r")) == NULL)
     {
-       printf("\nopen /var/log/xferlog failed\n");
+       printf("\nopen @FINKPREFIX@/var/log/xferlog failed\n");
     }
     fseek(fp, 0, SEEK_END);
     size_buffer = ftell(fp);
@@ -2237,24 +2237,24 @@
     char *get_file_buffer;
     gchar *utf8=NULL;
     GtkTextBuffer *file_text_buffer;
-    system("rm -f /var/log/xferlog");
-    system("touch /var/log/xferlog");
+    system("rm -f @FINKPREFIX@/var/log/xferlog");
+    system("touch @FINKPREFIX@/var/log/xferlog");
     files_textview = lookup_widget (GTK_WIDGET (button), "files_textview");
-    if( (fp = fopen("/var/log/xferlog", "r")) == NULL)
+    if( (fp = fopen("@FINKPREFIX@/var/log/xferlog", "r")) == NULL)
     {
-       strcpy(info_buffer, "Cant find /var/log/xferlog.\n\n");
+       strcpy(info_buffer, "Cant find @FINKPREFIX@/var/log/xferlog.\n\n");
        strcat(info_buffer, "If youre running GProFTPD as root\n");
        strcat(info_buffer, "the xferlog has been added for you.\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
-       system("touch /var/log/xferlog");
+       system("touch @FINKPREFIX@/var/log/xferlog");
        return;
     }
     fclose(fp);
 
-    if( (fp = fopen("/var/log/xferlog", "r")) == NULL)
+    if( (fp = fopen("@FINKPREFIX@/var/log/xferlog", "r")) == NULL)
     {
-       printf("\nopen /var/log/xferlog failed\n");
+       printf("\nopen @FINKPREFIX@/var/log/xferlog failed\n");
     }
     fseek(fp, 0, SEEK_END);
     size_buffer = ftell(fp);
@@ -2294,8 +2294,8 @@
     profile_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(profile_text));
     gtk_text_buffer_get_bounds(profile_text_buffer, &start, &end);
     profile = gtk_text_iter_get_text(&start, &end);
-    // Put the newly written profile text to /etc/gproftpd/useradd-profile
-    fp = fopen("/etc/gproftpd/useradd-profile", "w+");
+    // Put the newly written profile text to @FINKPREFIX@/etc/gproftpd/useradd-profile
+    fp = fopen("@FINKPREFIX@/etc/gproftpd/useradd-profile", "w+");
     fputs (profile, fp);
     fclose (fp);
     if(profile !=NULL)
@@ -2308,7 +2308,7 @@
 on_user_control_textview_map           (GtkWidget       *widget,
                                         gpointer         user_data)
 {
-    // Ftpusers update .. if no /etc/ftpusers one is created and all existing users put there. 
+    // Ftpusers update .. if no @FINKPREFIX@/etc/ftpusers one is created and all existing users put there. 
     FILE *fp;
     FILE *cat_file;
     char *access_buffer;
@@ -2317,22 +2317,22 @@
     gchar *utf8_access=NULL;
     long size_buffer;
     user_control_textview = lookup_widget (GTK_WIDGET (widget), "user_control_textview");
-    if( (fp = fopen("/etc/ftpusers", "r")) == NULL )
+    if( (fp = fopen("@FINKPREFIX@/etc/ftpusers", "r")) == NULL )
     {
-       strcpy(info_buffer, "Couldnt find /etc/ftpusers\n");
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/etc/ftpusers\n");
        strcat(info_buffer, "so i made that file and added\n");
        strcat(info_buffer, "all the users on the system to it.\n\n");
        strcat(info_buffer, "This in an auto security feature.\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
-       // add all system users to /etc/ftpusers
-       cat_file = popen("cat /etc/passwd |cut -f1 -d\":\" > /etc/ftpusers", "r");
+       // add all system users to @FINKPREFIX@/etc/ftpusers
+       cat_file = popen("cat /etc/passwd |cut -f1 -d\":\" > @FINKPREFIX@/etc/ftpusers", "r");
        pclose(cat_file);
     }
     // If the previous didnt work, inform.
-    if( (fp = fopen("/etc/ftpusers", "r")) == NULL )
+    if( (fp = fopen("@FINKPREFIX@/etc/ftpusers", "r")) == NULL )
     {
-       strcpy(info_buffer, "Couldnt find /etc/ftpusers\n");
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/etc/ftpusers\n");
        strcat(info_buffer, "Run GProFTPD as root.\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
@@ -2367,7 +2367,7 @@
 on_access_ok_clicked                   (GtkButton       *button,
                                         gpointer         user_data)
 {
-    // Save the usercontrol tab to /etc/ftpusers
+    // Save the usercontrol tab to @FINKPREFIX@/etc/ftpusers
     FILE *fp;
     GtkTextBuffer *access_text_buffer;
     GtkTextIter start, end;
@@ -2376,14 +2376,14 @@
     access_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(user_control_textview));
     gtk_text_buffer_get_bounds(access_text_buffer, &start, &end);
     profile = gtk_text_iter_get_text(&start, &end);
-    // Put the (newly) written profile text to /etc/gproftpd/useradd-profile
-    if ( (fp = fopen("/etc/ftpusers", "w+")) == NULL)
+    // Put the (newly) written profile text to @FINKPREFIX@/etc/gproftpd/useradd-profile
+    if ( (fp = fopen("@FINKPREFIX@/etc/ftpusers", "w+")) == NULL)
     {
-       strcpy(info_buffer, "Couldnt open /etc/ftpusers for writing\n");
+       strcpy(info_buffer, "Couldnt open @FINKPREFIX@/etc/ftpusers for writing\n");
        strcat(info_buffer, "This is not good, Run GProFTPD as root\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
-       printf("\nError saving /etc/ftpusers\n");
+       printf("\nError saving @FINKPREFIX@/etc/ftpusers\n");
        return;
     }
     fputs (profile, fp);
@@ -2454,8 +2454,8 @@
     user_control_textview = lookup_widget (GTK_WIDGET (button), "user_control_textview");
     kick_ban_entry = lookup_widget (GTK_WIDGET (button), "kick_ban_entry");
     kick_ban_username = gtk_entry_get_text(GTK_ENTRY(kick_ban_entry));
-    // Put the banned user in /etc/ftpusers
-    fp = fopen("/etc/ftpusers", "a");
+    // Put the banned user in @FINKPREFIX@/etc/ftpusers
+    fp = fopen("@FINKPREFIX@/etc/ftpusers", "a");
     fputs("\n", fp);
     fputs(kick_ban_username, fp);
     fclose(fp);
@@ -2487,10 +2487,10 @@
     free(get_kick_ban_pid);
     free(kick_ban_pid);
     free(kick_ban);
-    // Update user control tab from /etc/ftpusers
-    if( (fp = fopen("/etc/ftpusers", "r")) == NULL )
+    // Update user control tab from @FINKPREFIX@/etc/ftpusers
+    if( (fp = fopen("@FINKPREFIX@/etc/ftpusers", "r")) == NULL )
     {
-       strcpy(info_buffer, "Couldnt find /etc/ftpusers\n");
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/etc/ftpusers\n");
        strcat(info_buffer, "This is not good, run GProFTPD as root.\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
@@ -2708,7 +2708,7 @@
 on_add_default_config_button_clicked   (GtkButton       *button,
                                         gpointer         user_data)
 {
-    // Overwrite /etc/proftpd.conf with the default configuration, update the global tab, entire tab and user tab.
+    // Overwrite @FINKPREFIX@/etc/proftpd.conf with the default configuration, update the global tab, entire tab and user tab.
     FILE *fp;
     char *old_Buffer;
     char *new_Buffer;
@@ -2749,9 +2749,9 @@
     strcat(default_buffer, "</Directory>\n");
     strcat(default_buffer, "#--- End of the global configuration ---#\n");
     // Set the default configuration overwriting .. if one exists.
-    if ( (fp = fopen("/etc/proftpd.conf", "w+")) == NULL)
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "w+")) == NULL)
     {
-        strcpy(info_buffer, "Cant open /etc/proftpd.conf for writing\n");
+        strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf for writing\n");
         strcat(info_buffer, "Run GProFTPD as root\n");
         error_window = create_error_window ();
         gtk_widget_show (error_window);
@@ -2776,7 +2776,7 @@
 on_backup_proftpd_conf_button_clicked  (GtkButton       *button,
                                         gpointer         user_data)
 {
-    system("cp /etc/proftpd.conf /etc/gproftpd"); 
+    system("cp @FINKPREFIX@/etc/proftpd.conf @FINKPREFIX@/etc/gproftpd"); 
 }
 
 
@@ -2785,7 +2785,7 @@
 on_restore_config_button_clicked       (GtkButton       *button,
                                         gpointer         user_data)
 {
-    system("cp /etc/gproftpd/proftpd.conf /etc");
+    system("cp @FINKPREFIX@/etc/gproftpd/proftpd.conf @FINKPREFIX@/etc");
     // Updating the userlist and the entire configuration tab.
     userlist_treeview = lookup_widget (GTK_WIDGET (button), "userlist_treeview");
     update_user_list(userlist_treeview, NULL);
@@ -2822,9 +2822,9 @@
 {
     FILE *fp;
     char *check_conf_buffer;
-    if ( (fp = popen("proftpd -t -c /etc/proftpd.conf 2>&1", "r")) == NULL)
+    if ( (fp = popen("proftpd -t -c @FINKPREFIX@/etc/proftpd.conf 2>&1", "r")) == NULL)
     {
-       strcpy(info_buffer, "Cant open /etc/proftpd.conf\n");
+       strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);       
        return;
@@ -2875,7 +2875,7 @@
    require_column = gtk_tree_view_column_new_with_attributes("Require password", cell, "text", 3, NULL);
    maximum_column = gtk_tree_view_column_new_with_attributes("Maximum simultaneous connections", cell, "text", 4, NULL);
    gtk_list_store_clear(model);
-   // Check if the line /bin/false is in /etc/shells, if its not .. add that line.
+   // Check if the line /usr/bin/false is in /etc/shells, if its not .. add that line.
    // strstr doesnt work in append mode, doh !
    if( (fp = fopen("/etc/shells", "r"))==NULL)
    {
@@ -2889,7 +2889,7 @@
    bzero(shell, sizeof(char) * size_buffer);   
    while (fgets(shell, size_buffer, fp)!=NULL) 
    {
-     if (strstr((char*)shell, "/bin/false")!=NULL)
+     if (strstr((char*)shell, "/usr/bin/false")!=NULL)
      {
         found=1;
      }
@@ -2901,10 +2901,11 @@
      if( (fp = fopen("/etc/shells", "a"))==NULL)
      {
         printf("\nCant open /etc/shells for append/write\n");
+        return;
      }
-     fputs("/bin/false", fp);
-     printf("\nCouldnt find the line /bin/false in /etc/shells .. added it.\n");
-     strcpy(info_buffer, "Cant find the line /bin/false in /etc/shells.\n\n");
+     fputs("/usr/bin/false", fp);
+     printf("\nCouldnt find the line /usr/bin/false in /etc/shells .. added it.\n");
+     strcpy(info_buffer, "Cant find the line /usr/bin/false in /etc/shells.\n\n");
      strcat(info_buffer, "If youre running GProFTPD as root\n");
      strcat(info_buffer, "that line has been added for you.\n");
      error_window = create_error_window ();
@@ -2912,10 +2913,10 @@
      fclose(fp);
   }
   // Update the userlist
-  if ( (fp = fopen("/etc/proftpd.conf", "r")) == NULL)
+  if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
   {
      // create info window and show info_buffer.
-     strcpy(info_buffer, "Cant open /etc/proftpd.conf\n");
+     strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf\n");
      strcat(info_buffer, "Run GProFTPD as root\n");
      error_window = create_error_window ();
      gtk_widget_show (error_window);
@@ -3066,11 +3067,11 @@
     char *get_s_buf;
     gchar *utf8=NULL;
     GtkTextBuffer *security_text_buffer;
-    if( (fp = fopen("/var/log/secure", "r")) == NULL) 
+    if( (fp = fopen("@FINKPREFIX@/var/log/secure", "r")) == NULL) 
     {
-       strcpy(info_buffer, "Couldnt find /var/log/secure\n\n");
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/var/log/secure\n\n");
        strcat(info_buffer, "so i added it.\n");
-       system("touch /var/log/secure");
+       system("touch @FINKPREFIX@/var/log/secure");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
        return;
@@ -3096,11 +3097,11 @@
     gtk_text_buffer_set_text(security_text_buffer, utf8, strlen(utf8));
     fclose(fp);
 
-    if( (fp = fopen("/var/log/secure", "r")) == NULL) 
+    if( (fp = fopen("@FINKPREFIX@/var/log/secure", "r")) == NULL) 
     {
-       strcpy(info_buffer, "Couldnt find /var/log/secure\n\n");
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/var/log/secure\n\n");
        strcat(info_buffer, "so i added it.\n");
-       system("touch /var/log/secure");
+       system("touch @FINKPREFIX@/var/log/secure");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
        return;
@@ -3157,11 +3158,11 @@
     char *get_s_buf;
     gchar *utf8=NULL;
     GtkTextBuffer *security_text_buffer;
-    if( (fp = fopen("/var/log/secure", "r")) == NULL) 
+    if( (fp = fopen("@FINKPREFIX@/var/log/secure", "r")) == NULL) 
     {
-       strcpy(info_buffer, "Couldnt find /var/log/secure\n\n");
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/var/log/secure\n\n");
        strcat(info_buffer, "so i added it.\n");
-       system("touch /var/log/secure");
+       system("touch @FINKPREFIX@/var/log/secure");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
        return;
@@ -3187,11 +3188,11 @@
     gtk_text_buffer_set_text(security_text_buffer, utf8, strlen(utf8));
     fclose(fp);
 
-    if( (fp = fopen("/var/log/secure", "r")) == NULL) 
+    if( (fp = fopen("@FINKPREFIX@/var/log/secure", "r")) == NULL) 
     {
-       strcpy(info_buffer, "Couldnt find /var/log/secure\n\n");
+       strcpy(info_buffer, "Couldnt find @FINKPREFIX@/var/log/secure\n\n");
        strcat(info_buffer, "so i added it.\n");
-       system("touch /var/log/secure");
+       system("touch @FINKPREFIX@/var/log/secure");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
        return;
@@ -3308,7 +3309,7 @@
     profile_require_password_entry = lookup_widget (GTK_WIDGET (widget), "profile_require_password_entry");
     profile_max_logins_entry = lookup_widget (GTK_WIDGET (widget), "profile_max_logins_entry");
 
-    if ((fp = fopen("/etc/proftpd.conf", "r")) == NULL)
+    if ((fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
     {
         error_window = create_error_window ();
         gtk_widget_show (error_window);       
@@ -3474,9 +3475,9 @@
     strcat(UserUsername, username);
     strcat(UserUsername, "\n");  // Avoiding similar user deletion 
     // Get the users ENTIRE profile and make the requested changes to it
-    if ( (fp = fopen("/etc/proftpd.conf", "r")) == NULL)
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
     {
-       strcpy(info_buffer, "\nCant open /etc/proftpd.conf\n");
+       strcpy(info_buffer, "\nCant open @FINKPREFIX@/etc/proftpd.conf\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
        return;
@@ -3533,9 +3534,9 @@
     free(old_buffer);
 
     // Delete the users profile
-    if ( (fp = fopen("/etc/proftpd.conf", "r")) == NULL)
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
     {
-       strcpy(info_buffer, "\nCant open /etc/proftpd.conf\n");
+       strcpy(info_buffer, "\nCant open @FINKPREFIX@/etc/proftpd.conf\n");
        error_window = create_error_window ();
        gtk_widget_show (error_window);
        return;
@@ -3578,7 +3579,7 @@
     free(szUserBuffer);
 
     // Add the new config with the changed profile
-    if ( (fp = fopen("/etc/proftpd.conf", "w+")) == NULL) 
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "w+")) == NULL) 
     {
         return;
     }
@@ -3643,9 +3644,9 @@
     strcat(UserUsername, username_del = gtk_entry_get_text(GTK_ENTRY(profile_username_entry)));
     strcat(UserUsername, "\n"); // this is very important, or it will delete similar users.
     // Delete the configuration for the deleted user
-    if ( (fp = fopen("/etc/proftpd.conf", "r")) == NULL)
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "r")) == NULL)
     {
-       strcpy(info_buffer, "Cant open /etc/proftpd.conf\n");
+       strcpy(info_buffer, "Cant open @FINKPREFIX@/etc/proftpd.conf\n");
        strcat(info_buffer, "Run GProFTPD as root\n");
        free(UserUsername);
        error_window = create_error_window ();
@@ -3689,7 +3690,7 @@
     free(szLineBuffer);
     free(szUserBuffer);
     // Add the new config without the deleted profile
-    if ( (fp = fopen("/etc/proftpd.conf", "w+")) == NULL) 
+    if ( (fp = fopen("@FINKPREFIX@/etc/proftpd.conf", "w+")) == NULL) 
     {
         return;
     }
diff -ruN gproftpd-8.0.1.orig/src/interface.c gproftpd-8.0.1/src/interface.c
--- gproftpd-8.0.1.orig/src/interface.c	2002-10-13 08:50:16.000000000 -0600
+++ gproftpd-8.0.1/src/interface.c	2002-10-25 11:23:08.000000000 -0600
@@ -304,7 +304,7 @@
   gtk_widget_set_usize (GProFTPD, -2, 424);
   gtk_window_set_title (GTK_WINDOW (GProFTPD), "GProFTPD");
   gtk_window_set_position (GTK_WINDOW (GProFTPD), GTK_WIN_POS_CENTER);
-  GProFTPD_icon_pixbuf = create_pixbuf ("gproftpd36.xpm");
+  GProFTPD_icon_pixbuf = create_pixbuf ("gproftpd/gproftpd36.xpm");
   if (GProFTPD_icon_pixbuf)
     {
       gtk_window_set_icon (GTK_WINDOW (GProFTPD), GProFTPD_icon_pixbuf);
@@ -1601,7 +1601,7 @@
   gtk_widget_show (vbox18);
   gtk_container_add (GTK_CONTAINER (notebook1), vbox18);
 
-  label40 = gtk_label_new ("This is the entire configuration. The backup / restore directory is /etc/gproftpd.");
+  label40 = gtk_label_new ("This is the entire configuration. The backup / restore directory is @FINKPREFIX@/etc/gproftpd.");
   gtk_widget_set_name (label40, "label40");
   gtk_widget_show (label40);
   gtk_box_pack_start (GTK_BOX (vbox18), label40, FALSE, FALSE, 0);
@@ -2264,7 +2264,7 @@
   gtk_widget_show (label5);
   gtk_box_pack_start (GTK_BOX (vbox13), label5, FALSE, FALSE, 0);
 
-  label148 = gtk_label_new ("   1. Make sure that the user the server will run as exists on your\n       system, also make sure this user has a /bin/false or nologin \n       shell and is listed in /etc/ftpusers \"the usercontrol tab\".\n\n   2. The profiles tab is the settings the user will get when\n       he / she is added to the system (edit as you wish).\n\n   3. After you have added a user it will have a profile in\n       the entire configuration tab wich you can edit as you like.\n\n   4. Changing a users password is done by writing the username\n       in the username field supplying the new password for that\n       user in the password field and pressing the add button. \n\n   5. If you add a file or directory into the ftp directory, not\n       uploading it locally thru Proftpd you will have to set the\n       right permissions on it if you want other users to be able\n       to be able to download, use the permissions tab for that\n       and chmod the added directories and or files.\n\n   6. I hope this helped a bit, everything is pretty much automated\n       and self explaining but send me a mail if you have any questions.  ");
+  label148 = gtk_label_new ("   1. Make sure that the user the server will run as exists on your\n       system, also make sure this user has a /bin/false or nologin \n       shell and is listed in @FINKPREFIX@/etc/ftpusers \"the usercontrol tab\".\n\n   2. The profiles tab is the settings the user will get when\n       he / she is added to the system (edit as you wish).\n\n   3. After you have added a user it will have a profile in\n       the entire configuration tab wich you can edit as you like.\n\n   4. Changing a users password is done by writing the username\n       in the username field supplying the new password for that\n       user in the password field and pressing the add button. \n\n   5. If you add a file or directory into the ftp directory, not\n       uploading it locally thru Proftpd you will have to set the\n       right permissions on it if you want other users to be able\n       to be able to download, use the permissions tab for that\n       and chmod the added directories and or files.\n\n   6. I hope this helped a bit, everything is pretty much automated\n       and self explaining but send me a mail if you have any questions.  ");
   gtk_widget_set_name (label148, "label148");
   gtk_widget_show (label148);
   gtk_box_pack_start (GTK_BOX (vbox13), label148, TRUE, TRUE, 0);
