diff -ruN ccp4-5.0.2-orig/ccp4i/bin/osx_ccp4_mail ccp4-5.0.2/ccp4i/bin/osx_ccp4_mail
--- ccp4-5.0.2-orig/ccp4i/bin/osx_ccp4_mail	1969-12-31 16:00:00.000000000 -0800
+++ ccp4-5.0.2/ccp4i/bin/osx_ccp4_mail	2004-10-20 15:16:09.000000000 -0700
@@ -0,0 +1,164 @@
+#!/usr/bin/perl
+# Drop-in replacement for /usr/bin/mail that uses Mail.app (via an
+# applescript) rather than sendmail to send mail.  Unlike /usr/bin/mail,
+# you can't use it for reading mail.
+#
+# usage: mail [<options>] <recipients>
+#     options:
+#         -v           be verbose
+#         -g           activate Mail.app to approve the message
+#         -F <from>    specify the From: address
+#         -b <bcc>     specify Bcc: recipients in a comma-separated list
+#         -c <cc>      specify Cc: recipients in a comma-separated list
+#         -s <subject> specify the message subject
+#
+# The body of the message is read from standard input.
+#
+# Author: Nathaniel Nystrom <nystrom@cs.cornell.edu>
+# This software is in the public domain.
+#
+# Version 1.0,   21 Aug 2003 -- initial version
+# Version 1.0.1, 22 Aug 2003 -- fixes some quoting problems
+# Version 1.0.2, 23 Aug 2003 -- removed -R <reply-to> option; |reply to|
+#                               is a property of _incoming_ messages
+# Version 1.0.3, 17 Sep 2003 -- fixed escaping of \ in message body;
+#                               escape the subject too
+
+use strict;
+$|++;
+
+my ($verbose, $gui);
+my ($from, @to, @cc, @bcc, $subject, $body);
+my $prog;
+($prog = $0) =~ s|.*/||;
+
+while (@ARGV) {
+    my $arg = shift @ARGV;
+
+    if ($arg eq '-v') {
+        $verbose++;
+    }
+    elsif ($arg eq '-g') {
+        $gui++;
+    }
+    elsif ($arg eq '-F') {
+        $from = shift @ARGV || &usage("missing sender");
+    }
+    elsif ($arg eq '-i' || $arg eq '-l' || $arg eq '-n') {
+        # ignore; for /usr/bin/mail compatibility
+    }
+    elsif ($arg eq '-N' || $arg eq '-f' || $arg eq '-u') {
+        &usage("invalid option $arg; $prog cannot be used for reading mail");
+    }
+    elsif ($arg eq '-s') {
+        $subject = shift @ARGV || &usage("missing subject");
+    }
+    elsif ($arg eq '-c') {
+        my $list = shift @ARGV || &usage("missing Cc list");
+        @cc = split /\s*,\s*/, $list;
+    }
+    elsif ($arg eq '-b') {
+        my $list = shift @ARGV || &usage("missing Bcc list");
+        @bcc = split /\s*,\s*/, $list;
+    }
+    elsif ($arg =~ /^-/) {
+        &usage("invalid option $arg");
+    }
+    else {
+        @to = ($arg, @ARGV);
+        last;
+    }
+}
+
+&usage("missing recipients") unless @to;
+
+unless (defined $subject) {
+    print "Subject: ";
+    $subject = <STDIN> || '';
+    chomp $subject;
+}
+
+$body = '';
+
+while (<STDIN>) {
+    $body .= $_;
+}
+
+$body = &escape($body);
+$subject = &escape($subject);
+
+my $script = <<"EOS";
+tell application "Mail"
+    set newMessage to make new outgoing message
+    tell newMessage
+        set subject to "$subject"
+        set content to "$body"
+EOS
+
+for (@to)  { $script .= &recipient('to', $_); }
+for (@cc)  { $script .= &recipient('cc', $_); }
+for (@bcc) { $script .= &recipient('bcc', $_); }
+
+my $visible = $gui ? "true" : "false";
+my $activate = $gui ? "activate" : "send newMessage";
+my $fromln = $from ? "set sender to \"$from\"" : "";
+
+$script .= <<"EOS";
+        $fromln
+        set visible to $visible
+    end tell
+    $activate
+end tell
+EOS
+
+if ($verbose >= 1) {
+    print "From: $from\n" if $from;
+    print "To: ", join(',', @to), "\n" if @to;
+    print "Cc: ", join(',', @cc), "\n" if @cc;
+    print "Bcc: ", join(',', @bcc), "\n" if @bcc;
+
+    if ($verbose >= 2) {
+        print "Script >>>\n";
+        print $script;
+        print "<<<\n";
+        print "\n";
+        print $body;
+    }
+}
+
+open(SCRIPT, "| osascript > /dev/null") || die "Couldn't fork osascript: $!\n";
+print SCRIPT $script;
+close SCRIPT;
+
+exit 0;
+
+sub escape {
+    my $x = shift;
+    $x =~ s/\\/\\\\/gm;
+    $x =~ s/"/\\"/gm;
+    $x =~ s/\n/\\n/gm;
+    $x;
+}
+
+sub recipient {
+    my ($type,$addr) = @_;
+    return <<"EOS"
+        make new $type recipient at end of $type recipients with properties {address: "$addr"}
+EOS
+}
+
+sub usage {
+    my $error = shift;
+    print STDERR "Error: $error\n" if $error;
+    print STDERR <<"EOS";
+usage: $prog [<options>] <recipients>
+    options:
+        -v           be verbose
+        -g           activate Mail.app to approve the message
+        -F <from>    specify the From: address
+        -b <bcc>     specify Bcc: recipients in a comma-separated list
+        -c <cc>      specify Cc: recipients in a comma-separated list
+        -s <subject> specify the message subject
+EOS
+    exit 1;
+}
diff -ruN ccp4-5.0.2-orig/ccp4i/etc/configure.def.dist ccp4-5.0.2/ccp4i/etc/configure.def.dist
--- ccp4-5.0.2-orig/ccp4i/etc/configure.def.dist	2004-01-26 03:13:25.000000000 -0800
+++ ccp4-5.0.2/ccp4i/etc/configure.def.dist	2004-08-08 14:56:41.000000000 -0700
@@ -53,8 +53,8 @@
 MESSAGE                   _text				""
 BLT_LIBRARY               _text                     ""
 MENU_LENGTH               _positiveint              25
-HYPERTEXT_VIEWER          _text                     netscape
-START_NETSCAPE	          _text			    netscape
+HYPERTEXT_VIEWER          _text                     Safari  
+START_NETSCAPE	          _text			    open    
 O_MAPMAN                  _text                     mapman
 MAPMAN_MAXSIZE		  _positiveint		    4194304
 QUANTA_MBKALL             _text                     mbkall
diff -ruN ccp4-5.0.2-orig/ccp4i/scripts/ncsref.script ccp4-5.0.2/ccp4i/scripts/ncsref.script
--- ccp4-5.0.2-orig/ccp4i/scripts/ncsref.script	2004-01-26 03:18:50.000000000 -0800
+++ ccp4-5.0.2/ccp4i/scripts/ncsref.script	2005-02-14 13:15:05.000000000 -0800
@@ -135,7 +135,7 @@
     DeleteFile $HKLTMP
 
   }  else {
-
+    set TMPPDB $XYZIN
     set status [Execute "[BinPath cad] HKLIN1 $HKLIN HKLOUT $CURRENT_MTZ"  \
         $cad0_com program_status report ]
 
diff -ruN ccp4-5.0.2-orig/ccp4i/src/CCP4_utils.tcl ccp4-5.0.2/ccp4i/src/CCP4_utils.tcl
--- ccp4-5.0.2-orig/ccp4i/src/CCP4_utils.tcl	2004-05-26 07:43:11.000000000 -0700
+++ ccp4-5.0.2/ccp4i/src/CCP4_utils.tcl	2004-09-14 13:53:40.000000000 -0700
@@ -1257,7 +1257,10 @@
     return $status
   }
 
-  set data $MTZ_file_data($param)
+  if { [ catch { set data $MTZ_file_data($param) } result ] } {
+    return 0
+  }
+
   return 1
 
 }
@@ -1359,6 +1362,11 @@
     WarningMessage "ERROR extracting data from $file"
     return {}
   }
+  # Return failure if there are no datasets
+  set ndatasets $MTZ_file_data(NDATASETS)
+  if { $ndatasets < 1 } {
+    return {}
+  }
   # Sort the XNAMES list and return only the unique items i.e.
   # no duplicates 
   return [lsort -unique $MTZ_file_data(XNAMES)]
@@ -1379,6 +1387,11 @@
     WarningMessage "ERROR extracting data from $file"
     return {}
   }
+  # Return failure if there are no datasets
+  set ndatasets $MTZ_file_data(NDATASETS)
+  if { $ndatasets < 1 } {
+    return {}
+  }
   # Get a list of dataset names belonging to this crystal
   set i -1; set datasets {}
   foreach xname $MTZ_file_data(XNAMES) {
@@ -1543,7 +1556,6 @@
         return -2
       }
    }
-
    set MTZ_file_data(LOADED) 0
    set MTZ_file_data(FILE) $file
    set MTZ_file_data(CHANGED) $changed
diff -ruN ccp4-5.0.2-orig/ccp4i/src/local.tcl ccp4-5.0.2/ccp4i/src/local.tcl
--- ccp4-5.0.2-orig/ccp4i/src/local.tcl	2004-01-26 02:37:16.000000000 -0800
+++ ccp4-5.0.2/ccp4i/src/local.tcl	2004-10-20 15:29:46.000000000 -0700
@@ -28,13 +28,13 @@
 #----------------------------------------------------------------
 proc  SendMail { subject tmp_file mail_address } {
 #----------------------------------------------------------------
-#d_sum Send email using system Mail utility
+#d_sum Send email using perl script/osascript that sends through Apple email program.
 #d_arg subject Subject of mail message
 #d_arg tmp_file Temporary file containing the text of the message
 #d_arg mail_address Mail addressee
 
 return [expr 1 - [catch \
-   "exec Mail -s \"$subject\" $mail_address < $tmp_file"  ]]
+   "exec osx_ccp4_mail  -s \"$subject\" $mail_address < $tmp_file"  ]]
 }
 
 #d_index_title Interaction with Netscape
diff -ruN ccp4-5.0.2-orig/ccp4i/tasks/refmac5.tcl ccp4-5.0.2/ccp4i/tasks/refmac5.tcl
--- ccp4-5.0.2-orig/ccp4i/tasks/refmac5.tcl	2004-06-10 03:33:39.000000000 -0700
+++ ccp4-5.0.2/ccp4i/tasks/refmac5.tcl	2004-08-16 22:40:53.000000000 -0700
@@ -185,14 +185,18 @@
 	  # parameters are set such that keywords will be generated
 	  # in the keyworded script for this domain
 	  if { $array(NGROUPS,$i) > 0 } {
+	      set ngroups 0
 	      for { set j 1 } { $j <= $array(NGROUPS,$i) } { incr j } {
 		  if { $array(RES1,[subst $i]_[subst $j]) != "" && \
 			   $array(RES2,[subst $i]_[subst $j]) != "" && \
 			   $array(CHAIN1,[subst $i]_[subst $j]) != "" } {
-		      # Domain is defined
-		      incr ndomains
+		      # This group is defined
+		      incr ngroups
 		  }
 	      }
+	      # If all the groups in the domain are defined, then
+	      # the domain is also defined
+	      if { $array(NGROUPS,$i) == $ngroups } { incr ndomains }
 	  }
       }
       # Check that all domains are defined
diff -ruN ccp4-5.0.2-orig/ccp4i/tasks/truncate.def ccp4-5.0.2/ccp4i/tasks/truncate.def
--- ccp4-5.0.2-orig/ccp4i/tasks/truncate.def	2004-01-26 03:24:18.000000000 -0800
+++ ccp4-5.0.2/ccp4i/tasks/truncate.def	2005-03-15 21:37:13.000000000 -0800
@@ -6,7 +6,7 @@
 #     A copy of the CCP4 licence can be obtained by writing to the
 #     CCP4 Secretary, Daresbury Laboratory, Warrington WA4 4AD, UK.
 #
-#CCP4i_cvs_Id $Id: truncate.def,v 1.6 2004/01/26 11:24:18 mdw Exp $
+#CCP4i_cvs_Id $Id: truncate.def,v 1.7 2005/03/02 10:46:12 pjx Exp $
 #CCP4I SCRIPT DEF truncate
 #CCP4I DATE  25/10/97 16:05:30
 #CCP4I USER lizp
@@ -23,10 +23,10 @@
 
 IMEANIN         _mtz_label_j            ""
 SIGIMEANIN      _mtz_label_sig          ""
-I+		_mtz_label_j		""
-SIGI+	 	_mtz_label_sig		""
-I-		_mtz_label_j		""
-SIGI-		_mtz_label_sig		""
+Ipp		_mtz_label_j		""
+SIGIpp	 	_mtz_label_sig		""
+Imm		_mtz_label_j		""
+SIGImm		_mtz_label_sig		""
 FMEANIN         _mtz_label_f            ""
 SIGFMEANIN      _mtz_label_sig          ""
 
diff -ruN ccp4-5.0.2-orig/ccp4i/tasks/truncate.tcl ccp4-5.0.2/ccp4i/tasks/truncate.tcl
--- ccp4-5.0.2-orig/ccp4i/tasks/truncate.tcl	2004-01-26 03:24:18.000000000 -0800
+++ ccp4-5.0.2/ccp4i/tasks/truncate.tcl	2005-03-15 21:37:39.000000000 -0800
@@ -6,7 +6,7 @@
 #     A copy of the CCP4 licence can be obtained by writing to the
 #     CCP4 Secretary, Daresbury Laboratory, Warrington WA4 4AD, UK.
 #
-#CCP4i_cvs_Id $Id: truncate.tcl,v 1.8 2004/01/26 11:24:18 mdw Exp $
+#CCP4i_cvs_Id $Id: truncate.tcl,v 1.9 2005/03/02 10:46:12 pjx Exp $
 # ======================================================================
 # truncate.tcl --
 #
@@ -352,13 +352,13 @@
 
   CreateLabinLine line \
     "Choose input anomalous intensity (I(+)) and sigma (SIGI(+))" \
-     HKLIN "I(+)" I+  "I(+)" \
-     -sigma "SigI(+)" SIGI+  {} 
+     HKLIN "I(+)" Ipp  "I(+)" \
+     -sigma "SigI(+)" SIGIpp  {} 
 
     CreateLabinLine line \
     "Choose input anomalous intensity (I(-)) and sigma (SIGI(-))" \
-     HKLIN "I(-)" I-  "I(-)" \
-     -sigma "SigI(-)" SIGI-  {}
+     HKLIN "I(-)" Imm  "I(-)" \
+     -sigma "SigI(-)" SIGImm  {}
 
   CloseSubFrame
 
diff -ruN ccp4-5.0.2-orig/ccp4i/templates/mapmask.com ccp4-5.0.2/ccp4i/templates/mapmask.com
--- ccp4-5.0.2-orig/ccp4i/templates/mapmask.com	2004-01-26 03:27:54.000000000 -0800
+++ ccp4-5.0.2/ccp4i/templates/mapmask.com	2004-10-11 08:18:35.000000000 -0700
@@ -12,7 +12,7 @@
 
 $IFXYZLIM xyzlim $XYZLIM_1 $XYZLIM_2 $XYZLIM_3 $XYZLIM_4 $XYZLIM_5 $XYZLIM_6
 $IFASU XYZLIM ASU
-{[IfSet XYZLIM_MODE]} XYZLIM $XYZLIM_MODE
+{[IfSet $XYZLIM_MODE]} XYZLIM $XYZLIM_MODE
 
 $IFBORDER BORDER $BORDER
 { ![StringSame $EXTEND_MODE DEFAULT] }  EXTEND $EXTEND_MODE
diff -ruN ccp4-5.0.2-orig/ccp4i/templates/truncate.com ccp4-5.0.2/ccp4i/templates/truncate.com
--- ccp4-5.0.2-orig/ccp4i/templates/truncate.com	2004-01-26 03:27:58.000000000 -0800
+++ ccp4-5.0.2/ccp4i/templates/truncate.com	2005-03-15 21:37:54.000000000 -0800
@@ -6,7 +6,7 @@
 #     A copy of the CCP4 licence can be obtained by writing to the
 #     CCP4 Secretary, Daresbury Laboratory, Warrington WA4 4AD, UK.
 #
-#CCP4i_cvs_Id $Id: truncate.com,v 1.4 2004/01/26 11:27:58 mdw Exp $
+#CCP4i_cvs_Id $Id: truncate.com,v 1.5 2005/03/02 10:46:42 pjx Exp $
 { [ IfSet $TITLE ] } title  $TITLE
 $SYMMETRY symmetry $SPACE_GROUP
 $CELL cell $CELL_1 $CELL_2 $CELL_3 $CELL_4 $CELL_5 $CELL_6
@@ -44,8 +44,8 @@
 IF { ![StringSame $INPUT_DATA AMPLITUDES] }
   1 labin IMEAN=$IMEANIN SIGIMEAN=$SIGIMEANIN
     IF $ANOMALOUS
-    - 1 I(+)= $I+ I(-)= $I-
-    - 1 SIGI(+)= $SIGI+ SIGI(-) = $SIGI-
+    - 1 I(+)=$Ipp I(-)=$Imm
+    - 1 SIGI(+)=$SIGIpp SIGI(-)=$SIGImm
     ENDIF
 ELSE
   1 labin F=$FMEANIN SIGF=$SIGFMEANIN
diff -ruN ccp4-5.0.2-orig/ccp4i/utils/pdb_utils.tcl ccp4-5.0.2/ccp4i/utils/pdb_utils.tcl
--- ccp4-5.0.2-orig/ccp4i/utils/pdb_utils.tcl	2004-01-26 03:33:53.000000000 -0800
+++ ccp4-5.0.2/ccp4i/utils/pdb_utils.tcl	2004-09-19 14:35:40.000000000 -0700
@@ -14,7 +14,7 @@
 #
 #=========================================================================
 
-#CCP4i_cvs_Id $Id: pdb_utils.tcl,v 1.18 2004/01/26 11:33:53 mdw Exp $
+#CCP4i_cvs_Id $Id: pdb_utils.tcl,v 1.19 2004/09/17 10:16:54 mdw Exp $
 
 #d_index_title Coordinate Handling Utilities (utils/pdb_utils.tcl)
 #-------------------------------------------------------------------------
@@ -1294,7 +1294,7 @@
     } else {
       if { $Mol(linkDistance,$n) == "" } { set dist "" } else { \
 		set dist [format %10.5f $Mol(linkDistance,$n)] }
-      append text [format "LINK        %-4s%1s%3s %1s%4i%1s   %10s   %-4s%1s%3s %1s%4i%1s  %6s %6s%8s\n"  \
+      append text [format "LINK        %-4s%1s%3s %1s%4i%1s  %10s   %-4s%1s%3s %1s%4i%1s  %6s %6s%8s\n"  \
 	$Mol(linkAtom1,$n) \
 	$Mol(linkAlt1,$n) \
 	$Mol(linkRes1,$n) \
diff -ruN ccp4-5.0.2-orig/ccp4i/utils/start_netscape.csh ccp4-5.0.2/ccp4i/utils/start_netscape.csh
--- ccp4-5.0.2-orig/ccp4i/utils/start_netscape.csh	2002-02-22 05:50:38.000000000 -0800
+++ ccp4-5.0.2/ccp4i/utils/start_netscape.csh	2004-08-06 21:07:50.000000000 -0700
@@ -1,7 +1,5 @@
 #!/bin/csh
-setenv MOZILLA_HOME /usr/local/netscape
+setenv MOZILLA_HOME open                       
 # Its advisable to undo what was done in ccp4.setup
-setenv XUSERFILESEARCHPATH " "
-setenv XFILESEARCHPATH " "
-netscape file:$CCP4I_HELP/index.html >& /dev/null &
+open $CCP4I_HELP/index.html >& /dev/null &
 #netscape30 file:$CCP4I_HELP/start.html >& /dev/null &
diff -ruN ccp4-5.0.2-orig/configure ccp4-5.0.2/configure
--- ccp4-5.0.2-orig/configure	2004-07-01 07:07:29.000000000 -0700
+++ ccp4-5.0.2/configure	2005-04-13 07:45:25.000000000 -0700
@@ -1612,7 +1612,7 @@
   XMKMF="IMAKECPP=/usr/bin/cpp xmkmf"
   if test "$shared_lib" = yes; then
     SHARED_LIB_CFLAGS=${SHARED_LIB_CFLAGS:-'-fPIC -fno-common'}
-    SHARE_LIB='${CXX} -dynamiclib -flat_namespace -undefined suppress ${SHARED_LIB_CFLAGS} -install_name libmmdb.dylib -all_load libmmdb.a -o libmmdb.dylib; ${CC} -dynamiclib -flat_namespace -undefined suppress ${SHARED_LIB_CFLAGS} -install_name libccp4c.dylib -all_load libccp4c.a  -o libccp4c.dylib'
+    SHARE_LIB='${CXX} -dynamiclib -flat_namespace -undefined suppress ${SHARED_LIB_CFLAGS} -install_name SW_PREFIX/lib/ccp4-5.0.2/libmmdb.dylib -all_load libmmdb.a -o libmmdb.dylib; ${CC} -dynamiclib -flat_namespace -undefined suppress ${SHARED_LIB_CFLAGS} -install_name SW_PREFIX/lib/ccp4-5.0.2/libccp4c.dylib -all_load libccp4c.a  -o libccp4c.dylib'
     SHARE_INST='${INSTALL_DATA} `pwd`/libmmdb.dylib ${libdir}/libmmdb.dylib; ${INSTALL_DATA} `pwd`/libccp4c.dylib ${libdir}/libccp4c.dylib'
   fi     
 #need -lcc_dynamic to get restFP and saveFP for g77 3.4
@@ -1654,7 +1654,7 @@
 #cc_dynamic resolves restFP and saveFP
 #dylib1.o is dyld_stub_binding_helper
 #disable fortran shared library to allow access to common blocks
-    SHARE_LIB='${CXX} -qmkshrobj -flat_namespace -undefined suppress -Wl,-install_name,libmmdb.dylib bfgs_min.o mmdb_chain.o mmdb_manager.o mmdb_symop.o file_.o mmdb_cifdefs.o mmdb_mask.o mmdb_title.o linalg_.o mmdb_coormngr.o mmdb_mmcif.o mmdb_utils.o machine_.o mmdb_cryst.o mmdb_model.o stream_.o mattype_.o mmdb_file.o mmdb_rwbrook.o mmdb_atom.o mmdb_graph.o mmdb_selmngr.o mmdb_align.o mmdb_tables.o math_.o mmdb_sbase.o mmdb_uddata.o mmdb_xml.o mmdb_bondmngr.o mmdb_ficif.o random_n.o -o libmmdb.dylib; ${LD} -dylib -dynamic -flat_namespace -undefined suppress -install_name:libccp4c.dylib -all_load libccp4c.a -o libccp4c.dylib -lcc_dynamic -ldylib1.o;'
+    SHARE_LIB='${CXX} -qmkshrobj -flat_namespace -undefined suppress -Wl,-install_name,SW_PREFIX/lib/ccp4-5.0.2/libmmdb.dylib bfgs_min.o mmdb_chain.o mmdb_manager.o mmdb_symop.o file_.o mmdb_cifdefs.o mmdb_mask.o mmdb_title.o linalg_.o mmdb_coormngr.o mmdb_mmcif.o mmdb_utils.o machine_.o mmdb_cryst.o mmdb_model.o stream_.o mattype_.o mmdb_file.o mmdb_rwbrook.o mmdb_atom.o mmdb_graph.o mmdb_selmngr.o mmdb_align.o mmdb_tables.o math_.o mmdb_sbase.o mmdb_uddata.o mmdb_xml.o mmdb_bondmngr.o mmdb_ficif.o random_n.o -o libmmdb.dylib; ${LD} -dylib -dynamic -flat_namespace -undefined suppress -install_name:SW_PREFIX/lib/ccp4-5.0.2/libccp4c.dylib -all_load libccp4c.a -o libccp4c.dylib -lcc_dynamic -ldylib1.o;'
     SHARE_INST='${INSTALL_DATA} `pwd`/libmmdb.dylib ${libdir}/libmmdb.dylib; ${INSTALL_DATA} `pwd`/libccp4c.dylib ${libdir}/libccp4c.dylib;'
   fi
   LDFLAGS="-lccp4f -lccp4c -lmmdb \$(XCIF_LIB) \$(XLAPACK_LIB) \$(XLDFLAGS)"
diff -ruN ccp4-5.0.2-orig/etc/ccp4help ccp4-5.0.2/etc/ccp4help
--- ccp4-5.0.2-orig/etc/ccp4help	1969-12-31 16:00:00.000000000 -0800
+++ ccp4-5.0.2/etc/ccp4help	2004-09-21 14:11:05.000000000 -0700
@@ -0,0 +1,8 @@
+#!/bin/zsh -f
+# replaces csh alias ccp4help
+        if [[ $# = 0 ]]
+        then
+                $CCP4_BROWSER $CHTML/INDEX.html
+        else
+                $CCP4_BROWSER $CHTML/$1.html
+        fi
diff -ruN ccp4-5.0.2-orig/etc/uniqueify ccp4-5.0.2/etc/uniqueify
--- ccp4-5.0.2-orig/etc/uniqueify	2004-06-17 03:19:45.000000000 -0700
+++ ccp4-5.0.2/etc/uniqueify	2004-08-08 15:00:50.000000000 -0700
@@ -124,10 +124,10 @@
 temp3=$CCP4_SCR/uniq3$$.mtz
 
 # find awk executable
-for myawk in nawk gawk awk
-do
-    test -f $myawk && break
-done
+
+myawk=/usr/bin/awk
+
+# fink's awk is gawk creating problems, system's awk works fine 
 
 # extract first crystal name from the input file
 xname=`mtzdmp $1 -n 0 | $myawk '                  
diff -ruN ccp4-5.0.2-orig/etc/xloggraph ccp4-5.0.2/etc/xloggraph
--- ccp4-5.0.2-orig/etc/xloggraph	1969-12-31 16:00:00.000000000 -0800
+++ ccp4-5.0.2/etc/xloggraph	2004-09-15 07:45:17.000000000 -0700
@@ -0,0 +1,6 @@
+#!/bin/zsh
+export XUSERFILESEARCHPATH=$CLIB/X11/app-defaults/XCCPJiffy
+xloggraph.exe "$@" &
+export XUSERFILESEARCHPATH=""
+print "Plot button sends pdf to Preview.  Print or save pdf in Preview window."
+exit 0
diff -ruN ccp4-5.0.2-orig/etc/xplot84 ccp4-5.0.2/etc/xplot84
--- ccp4-5.0.2-orig/etc/xplot84	1969-12-31 16:00:00.000000000 -0800
+++ ccp4-5.0.2/etc/xplot84	2004-09-15 07:42:59.000000000 -0700
@@ -0,0 +1,6 @@
+#!/bin/zsh
+export XUSERFILESEARCHPATH=$CLIB/X11/app-defaults/XCCPJiffy
+xplot84driver.exe "$@" &
+export XUSERFILESEARCHPATH=""
+print "Plot button sends pdf to Preview.  Print or save pdf in Preview window."
+exit 0
diff -ruN ccp4-5.0.2-orig/etc/xplot84driver ccp4-5.0.2/etc/xplot84driver
--- ccp4-5.0.2-orig/etc/xplot84driver	1969-12-31 16:00:00.000000000 -0800
+++ ccp4-5.0.2/etc/xplot84driver	2004-09-15 07:43:34.000000000 -0700
@@ -0,0 +1,6 @@
+#!/bin/zsh
+export XUSERFILESEARCHPATH=$CLIB/X11/app-defaults/XCCPJiffy
+xplot84driver.exe "$@" &
+export XUSERFILESEARCHPATH=""
+print "Plot button sends pdf to Preview.  Print or save pdf in Preview window."
+exit 0
diff -ruN ccp4-5.0.2-orig/include/ccp4.setup-dist ccp4-5.0.2/include/ccp4.setup-dist
--- ccp4-5.0.2-orig/include/ccp4.setup-dist	2004-08-05 04:47:45.000000000 -0700
+++ ccp4-5.0.2/include/ccp4.setup-dist	2004-09-22 01:06:40.000000000 -0700
@@ -57,7 +57,7 @@
 #               For 'standard' installations this is /usr/local/bin
 #               but note the SGI distributed version of Tcl/Tk is not 
 #               appropriate version
-setenv CCP4I_TCLTK /usr/local/bin        
+setenv CCP4I_TCLTK /swprefix/bin        
 # CCP4I_HELP - directory contain ccp4i help - default is $CCP4I_TOP/help
 setenv CCP4I_HELP ${CCP4I_TOP}/help
 
@@ -107,7 +107,7 @@
     setenv CBIN      $CCP4/bin		
     setenv CLIB      $CCP4/lib	
 
-    setenv CCP4_BROWSER  netscape             
+    setenv CCP4_BROWSER  open        
 
     if (${?MANPATH}) then
       if ($ccp4_first_in_path) then
@@ -158,8 +158,8 @@
 endif
 
 ### PLOT_COMMAND PRINT_COMMAND for the XCCPJIFFY programs to compile ###
-setenv PLOT_COMMAND   'lp -s -dmicrolaser'  
-setenv PRINT_COMMAND  'lp -s -denscript'    
+setenv PLOT_COMMAND   'lpr'  
+setenv PRINT_COMMAND  'lpr'    
 
 # HARVESTHOME specifies location of harvesting files (defaults to $HOME)
 #setenv HARVESTHOME     
@@ -181,52 +181,6 @@
 #
 #  setenv BINSORT_MEM     8388608
 
-# LD_LIBRARY_PATH specifies where to find dynamic libraries (e.g. libccp4.so)
-# at runtime
-if (${?LD_LIBRARY_PATH}) then
-  if ($ccp4_first_in_path) then
-    setenv LD_LIBRARY_PATH ${CLIB}:${LD_LIBRARY_PATH}
-  else
-    setenv LD_LIBRARY_PATH ${LD_LIBRARY_PATH}:${CLIB}
-  endif
-else
-  setenv LD_LIBRARY_PATH ${CLIB}
-endif
-
-# DYLD_LIBRARY_PATH specifies where to find dynamic libraries (e.g. libccp4.dylib)
-# at runtime (used on Mac OS X)
-if (${?DYLD_LIBRARY_PATH}) then
-  if ($ccp4_first_in_path) then
-    setenv DYLD_LIBRARY_PATH ${CLIB}:${DYLD_LIBRARY_PATH}
-  else
-    setenv DYLD_LIBRARY_PATH ${DYLD_LIBRARY_PATH}:${CLIB}
-  endif
-else
-  setenv DYLD_LIBRARY_PATH ${CLIB}
-endif
-
-### XAPPLRESDIR ###
-
-# If you want to use xloggraph/xplot84driver, you need to get the application
-# defaults picked up somehow.  As distributed, the file can't just live in an
-# application defaults directory since it requires reading by xrdb to sort out
-# the differences for monochrome displays.  At Daresbury a version of the file
-# assuming a monochrome display is kept in the directory
-# $CCP4_LIB/X11/app-defaults and this is picked up through the
-# XUSERFILESEARCHPATH environment variable.  That means you only see black and
-# white on a colour display.  Alternatively you might make sure that it is
-# read by xrdb on startup of the X Windows system or delegate the
-# responsibility to users to run it.  There are disadvantages to putting an
-# invocation of xrdb in here, one being that the correct value of DISPLAY may
-# not be set at the time this file is read.  Thus edit this part as
-# appropriate.  (SunOS will normally want to use /usr/openwin or $OPENWINHOME
-# instead of /usr; others may want /usr/local/lib or somw such):
-if ($?XUSERFILESEARCHPATH) then
-  setenv XUSERFILESEARCHPATH $CCP4_LIB/X11/app-defaults/%N:$XUSERFILESEARCHPATH
-else
-  setenv XUSERFILESEARCHPATH $CCP4_LIB/X11/app-defaults/%N:/usr/lib/X11/app-defaults
-endif
-
 ### TRAPPFE ###
 # TRAPFPE is set to ensure (in collaboration with -lfpe) an abort on floating
 # point exceptions under IRIX.  It shouldn't cause harm on other systems, but
@@ -277,8 +231,8 @@
 # confusion with `.' or whatever in the path:
 #
 # This construct prevents the path getting longer each time ccp4.setup is
-# executed (A. Perrakis)
-set ccp4pathlist = "${CCP4}/etc ${CBIN} ${CCP4I_TOP}/bin "
+# executed (A. Perrakis).  I've corrected the erronious syntax.
+set ccp4pathlist = "${CCP4}/etc:${CBIN}:${CCP4I_TOP}/bin"
 #
 foreach dir ( ${ccp4pathlist} )
   if ( ${?PATH} ) then
@@ -319,7 +273,8 @@
   alias cexam  'pushd $CEXAM>/dev/null'
   alias cdoc   'pushd $CDOC>/dev/null'
   alias chtml  'pushd $CHTML>/dev/null'
-  alias ccp4help '$CCP4_BROWSER $CHTML/INDEX.html &'
+# replace this with a shell script in $CCP4/etc/ccp4help
+# alias ccp4help '$CCP4_BROWSER $CHTML/INDEX.html &'
 
 ### laue, lget, linkimages ###
 # Essential aliases for the Laue software suite
@@ -344,3 +299,15 @@
   alias lgnoms 'pushd $CCP4_MASTER/laue/gnom/src>/dev/null'
   alias lbin   'pushd $CBIN>/dev/null'
 #
+
+# completions
+
+ complete xplot84 'p/*/f:*.plt/'
+ complete xplot84driver 'p/*/f:*.plt/'
+ complete mtzdmp 'p/*/f:*.mtz/'
+
+# completion for ccp4help -- requires $CCP4/etc/ccp4help shell script of my zsh function 
+ set junklist= ( $CHTML/* )
+ set newjunklist=($junklist:r:t)
+ complete ccp4help 'p/1/$newjunklist/'
+
diff -ruN ccp4-5.0.2-orig/include/ccp4.setup-sh ccp4-5.0.2/include/ccp4.setup-sh
--- ccp4-5.0.2-orig/include/ccp4.setup-sh	2004-08-06 20:28:18.000000000 -0700
+++ ccp4-5.0.2/include/ccp4.setup-sh	2004-09-22 01:05:49.000000000 -0700
@@ -1,9 +1,16 @@
 #! /bin/sh
 # [The above is just for emacs -- this file should not be executed.]
 
-# CCP4 setup file for bash or ksh (untested) users.  Actually, the aliases 
-# can't work asis in ksh.  Should use builtins instead and not worry about
-# ease of keeping in step with the csh one.
+# NOTE:  If you have installed ccp4 on OS X with fink, you should not need to
+# change this file or to source it (fink takes care of sourcing it for you).
+
+# CCP4 setup file for bash or zsh users.  zsh is similar to ksh so should work
+# with ksh.
+
+# Contains some hacks by W G Scott to facilitate OS X fink installation, but
+# should work with any zsh or bash system with appropriate prefixes
+
+# Also contains a few bash and zsh-specific functions and command-completions
 
 # $Id: ccp4.setup-sh,v 1.3.4.1 2004/08/05 11:47:45 pjx Exp $
 
@@ -18,7 +25,7 @@
 # shareable files (such as this one) via shared file systems with NFS, RFS
 # etc.  Non-shareable files reside in $CBIN and $CLIB (see below).
 
-# Copy this file to ccp4.setup and customise it for your needs. There are
+# Copy this file to ccp4.setup-sh and customise it for your needs. There are
 # three sections. You MUST check the first section. You may want to check
 # the second. You don't need to look at the third.
 
@@ -49,7 +56,7 @@
 #               For 'standard' installations this is /usr/local/bin
 #               but note the SGI distributed version of Tcl/Tk is not 
 #               appropriate version
-export CCP4I_TCLTK=/sw/bin        
+export CCP4I_TCLTK=/swprefix/bin        
 # CCP4I_HELP - directory contain ccp4i help - default is $CCP4I_TOP/help
 export CCP4I_HELP=$CCP4I_TOP/help
 
@@ -91,8 +98,17 @@
     export CBIN=$CCP4/bin		
     export CLIB=$CCP4/lib	
 
-    export CCP4_BROWSER=safari             
-    export MANPATH=$CCP4/man:$MANPATH           # edit this if necessary
+    
+    if [ $(uname) = Darwin ]; then
+        export CCP4_BROWSER=open
+    else
+        export CCP4_BROWSER=netscape
+    fi 
+    
+    
+                 
+           MANPATH=$CCP4/man:$MANPATH           # edit this if necessary
+    export MANPATH
     export MCTYPE=unix 			# (only for Laue)
 #     ;;
 #   *)
@@ -107,11 +123,12 @@
 export CCP4_BIN=$CBIN
 
 # CLASSPATH for Java
-export CLASSPATH=$CBIN:$CLASSPATH                      # edit this if necessary
+       CLASSPATH=$CBIN:$CLASSPATH               # edit this if necessary
+export CLASSPATH
 
 ### PLOT_COMMAND PRINT_COMMAND for the XCCPJIFFY programs to compile ###
-export PLOT_COMMAND='lp -s'  
-export PRINT_COMMAND='lp -s'    
+export PLOT_COMMAND='lpr'  
+export PRINT_COMMAND='lpr'    
 
 # HARVESTHOME specifies location of harvesting files (defaults to $HOME)
 export HARVESTHOME=$HOME     
@@ -133,39 +150,6 @@
 #
 #  export BINSORT_MEM=8388608
 
-# LD_LIBRARY_PATH specifies where to find dynamic libraries (e.g. libccp4.so)
-# at runtime
-if test "LD_LIBRARY_PATH"; then
-  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$CLIB
-else
-  export LD_LIBRARY_PATH=$CLIB
-fi
-# DYLD_LIBRARY_PATH specifies where to find dynamic libraries
-# (e.g. libccp4.dylib) at runtime
-if test "DYLD_LIBRARY_PATH"; then
-  export DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH:$CLIB
-else
-  export DYLD_LIBRARY_PATH=$CLIB
-fi
-
-### XAPPLRESDIR ###
-
-# If you want to use xloggraph/xplot84driver, you need to get the application
-# defaults picked up somehow.  As distributed, the file can't just live in an
-# application defaults directory since it requires reading by xrdb to sort out
-# the differences for monochrome displays.  At Daresbury a version of the file
-# assuming a monochrome display is kept in the directory
-# $CCP4_LIB/X11/app-defaults and this is picked up through the
-# XUSERFILESEARCHPATH environment variable.  That means you only see black and
-# white on a colour display.  Alternatively you might make sure that it is
-# read by xrdb on startup of the X Windows system or delegate the
-# responsibility to users to run it.  There are disadvantages to putting an
-# invocation of xrdb in here, one being that the correct value of DISPLAY may
-# not be set at the time this file is read.  Thus edit this part as
-# appropriate.  (SunOS will normally want to use /usr/openwin or $OPENWINHOME
-# instead of /usr; others may want /usr/local/lib or somw such):
-
-export XAPPLRESDIR=/sw/etc/app-defaults/
 
 ### TRAPPFE ###
 # TRAPFPE is set to ensure (in collaboration with -lfpe) an abort on floating
@@ -217,15 +201,23 @@
 # confusion with `.' or whatever in the path:
 #
 # This construct prevents the path getting longer each time ccp4.setup is
-# executed (A. Perrakis)
-ccp4pathlist="${CCP4}/etc ${CBIN} ${CCP4I_TOP}/bin "
-#
-for dir in ${ccp4pathlist}
-do
-  if [ `expr ":${PATH}:" : ".*:${dir}:"` -eq 0 ]; then
-    PATH=${PATH}:${dir}
-  fi
-done
+# executed in bash (WG Scott corrected version).  zsh has a better mechanism.
+
+ccp4pathlist="${CCP4}/etc:${CBIN}:${CCP4I_TOP}/bin"
+
+if test x$ZSH_VERSION = x; then  
+    for dir in ${ccp4pathlist}
+    do
+      if [ `expr ":${PATH}:" : ".*:${dir}:"` -eq 0 ]; then
+        PATH=${PATH}:${dir}
+      fi
+    done
+else
+    PATH=$ccp4pathlist:$PATH
+    typeset -U path
+fi
+
+export PATH
 
 # Optional (useful) additional environment variables
   export CCP4=$CCP4
@@ -276,3 +268,74 @@
   alias lgnom='pushd $CCP4_MASTER/laue/gnom>/dev/null'
   alias lgnoms='pushd $CCP4_MASTER/laue/gnom/src>/dev/null'
   alias lbin='pushd $CBIN>/dev/null'
+  
+# Get rid of the ccp4help alias and make a more useful function
+
+    alias ccp4help="" ; unalias ccp4help
+    function ccp4help {
+        if [[ $# = 0 ]]; then
+            $CCP4_BROWSER $CHTML/INDEX.html
+        else
+            $CCP4_BROWSER $CHTML/$1.html
+        fi 
+        }  
+
+# Test if we are using bash, and if so, define some completions
+
+if test x$BASH_VERSION != x; then
+
+getccp4progs () {
+        for progpage in $CHTML/*.html
+        do
+                progpage_t=${progpage#$CHTML/}
+                progpage_t_r=${progpage_t%.*}       
+                echo $progpage_t_r
+        done
+        }
+
+        
+  complete -f  -W '$(getccp4progs)' ccp4help 
+
+  complete -f  -X '!*.mtz' mtzdmp
+
+  complete -f  -X '!*.plt' xplot84
+  complete -f  -X '!*.plt' xplot84driver
+
+fi        
+        
+# Stop reading the file here unless we are using zsh
+
+if test x$ZSH_VERSION = x; then  
+ return 0
+fi
+
+
+
+# zsh specific stuff
+  
+if [[ -n $ZSH_VERSION ]]; then
+
+     # ZSH_VERSION is only defined within zsh.  
+        
+  function getccp4progs { 
+        foreach progpage ($CHTML/*.html) 
+            print $progpage:t:r
+        end 
+        }
+        
+  compctl -g "$(getccp4progs)" ccp4help 
+
+  compctl -g '*.mtz' mtzdmp
+
+  compctl -g '*.plt' xplot84
+  compctl -g '*.plt' xplot84driver
+  
+    # Avoid repeats in the path
+ 
+    typeset -U path
+    typeset -U manpath
+    typeset -U classpath
+     
+fi   # End of zsh specific functions and completions
+
+
diff -ruN ccp4-5.0.2-orig/lib/ccif/configure ccp4-5.0.2/lib/ccif/configure
--- ccp4-5.0.2-orig/lib/ccif/configure	2004-03-25 03:05:02.000000000 -0800
+++ ccp4-5.0.2/lib/ccif/configure	2005-04-13 07:45:25.000000000 -0700
@@ -1875,7 +1875,7 @@
          SHARED_LIB_PATH='LD_LIBRARY_PATH=`pwd`'
          SHARED_LIB_CMD='$(CC) $(SHARED_LIB_CFLAGS) -dynamiclib -flat_namespace \\\
                                -undefined suppress -install_name \\\
-                                $(SHARED_LIB_NAME) \\\
+                                SW_PREFIX/lib/ccp4-5.0.2/$(SHARED_LIB_NAME) \\\
                                -all_load $L \\\
                                -o $(SHARED_LIB_NAME)'
          SHARED_LIB_EXPORTS_CMD=''
diff -ruN ccp4-5.0.2-orig/lib/clipper/configure ccp4-5.0.2/lib/clipper/configure
--- ccp4-5.0.2-orig/lib/clipper/configure	2004-04-30 05:54:18.000000000 -0700
+++ ccp4-5.0.2/lib/clipper/configure	2005-04-13 07:45:25.000000000 -0700
@@ -6847,16 +6847,16 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
       # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
         if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         else
-          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         fi
           module_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       hardcode_direct=no
@@ -9688,17 +9688,17 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds_CXX='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds_CXX='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds_CXX='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds_CXX='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds_CXX='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
 
     # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
       if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       else
-        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       fi
         module_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
     hardcode_direct_CXX=no
@@ -13476,16 +13476,16 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds_F77='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds_F77='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds_F77='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds_F77='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds_F77='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
       # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
         if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         else
-          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         fi
           module_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       hardcode_direct_F77=no
@@ -15816,16 +15816,16 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds_GCJ='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds_GCJ='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds_GCJ='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds_GCJ='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds_GCJ='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
       # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
         if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         else
-          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         fi
           module_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       hardcode_direct_GCJ=no
diff -ruN ccp4-5.0.2-orig/lib/src/ccp4_parser.c ccp4-5.0.2/lib/src/ccp4_parser.c
--- ccp4-5.0.2-orig/lib/src/ccp4_parser.c	2004-04-06 07:16:52.000000000 -0700
+++ ccp4-5.0.2/lib/src/ccp4_parser.c	2004-08-28 18:57:47.000000000 -0700
@@ -1298,14 +1298,18 @@
 	is_frc = 1;
 
       } else if (toupper(this_char) == 'E') {
+        char next_char = (ichar+1 < lstr ) ? str[ichar+1] : '\0';
+        if ( next_char == '+' || next_char == '-')
+           next_char = (ichar+2 < lstr ) ? str[ichar+2] : '\0';
+        /* require the next active character after E to be a digit */
+        if ( !isdigit(next_char) )  return 0;
 	/* Exponent? i.e. e or E
 	   There can only be one exponent */
-	if (exponent > -1) return 0;
-	exponent = ichar;
-	is_int = 0;
-	is_frc = 0;
-	is_exp = 1;
-
+        if (exponent > -1) return 0;
+        exponent = ichar;
+        is_int = 0;
+        is_frc = 0;
+        is_exp = 1;
       } else {
 	/* Not a permissible character
 	   This is not a number so get out now */
diff -ruN ccp4-5.0.2-orig/lib/src/cmtzlib_f.c ccp4-5.0.2/lib/src/cmtzlib_f.c
--- ccp4-5.0.2-orig/lib/src/cmtzlib_f.c	2004-07-05 06:23:54.000000000 -0700
+++ ccp4-5.0.2/lib/src/cmtzlib_f.c	2005-01-17 14:52:03.000000000 -0800
@@ -98,7 +98,7 @@
 #include "csymlib.h"
 #include "ccp4_program.h"
 #include "ccp4_general.h"
-static char rcsid[] = "$Id: cmtzlib_f.c,v 1.62 2004/07/05 13:23:54 mdw Exp $";
+static char rcsid[] = "$Id: cmtzlib_f.c,v 1.62.2.3 2005/01/14 11:32:44 mdw Exp $";
 
 #define MFILES 4
 #define MAXSYM 192
@@ -1127,7 +1127,7 @@
  /* lrrefl / lrreff will increment this */
  irref[*mindx-1] = *nrefl - 1;
  if (!cmtz_in_memory) {
-   respos = *nrefl * MtzNumSourceCol(mtzdata[*mindx-1]) + SIZE1 + 1;
+   respos = (*nrefl - 1) * MtzNumSourceCol(mtzdata[*mindx-1]) + SIZE1;
    ccp4_file_seek(mtzdata[*mindx-1]->filein, respos, SEEK_SET); 
  }
 }
@@ -2299,47 +2299,61 @@
 	       (const int *mindx, fpstr lsprgo, const int *nlprgo, fpstr ctprgo, int *iappnd),
 	       (const int *mindx, fpstr lsprgo, int lsprgo_len, const int *nlprgo, 
                       fpstr ctprgo, int ctprgo_len, int *iappnd))
-{int i,j,istart;
+{   int i,j,istart;
     char *label;
     char *type;
     MTZCOL **colarray, *colsort[5];
 
     CMTZLIB_DEBUG(puts("CMTZLIB_F: LWASSN");)
 
-        if (MtzCheckSubInput(*mindx,"LWASSN",2)) return;
+    if (MtzCheckSubInput(*mindx,"LWASSN",2)) return;
 
     label = (char *) ccp4_utils_malloc((*nlprgo)*31*sizeof(char));
     type = (char *) ccp4_utils_malloc((*nlprgo)*3*sizeof(char));
 
-    /* to retain primacy of read structure for copy/rename
-        the read assignments should be done first, then
-        column information should be updated
-        */
+    /* Construct label array to pass to ccp4_lwassn.
+       This has undergone several iterations. Watch out for
+       special cases: 
+         output assignment is taken from LABIN e.g. revise
+           (same prog label in lsprgi and lsprgo, and iappnd = 0)
+         dm has same prog label FDM in lsprgi and lsprgo, and 
+           iappnd = 1 so these are distinct columns
+         sfall has "labout allin" which should be sorted out by
+           sfall itself
+     */
     for (i = 0; i < *nlprgo; ++i) {
-        for (j = 0; j != lsprgo_len && lsprgo[lsprgo_len*i+j] != ' ' ; ++j) {
-            label[i*31+j] = lsprgo[lsprgo_len*i+j];
-        }
-        label[i*31+j] = '\0';
-        for (j = 0; j < MCOLUMNS; ++j) {
-            if (strcmp(user_label_in[*mindx-1][j][1],"") && !strcmp(user_label_in[*mindx-1][j][0],label+i*31)) {
-                strcpy(label+i*31,user_label_in[*mindx-1][j][1]);
-                break;
-            } /* strcmp if */
-        }   /* MCOLUMNS loop */ 
-/* use invariance of j */
-        if (j == MCOLUMNS) {
-          if (strcmp(user_label_out[*mindx-1][i][1],"") != 0) {
-            strcpy(label+i*31,user_label_out[*mindx-1][i][1]);
-          }
-        }
-	/* check for duplicated labels */
-        for (j = 0; j < i; ++j)
-          if ( ! strncmp(label+i*31,label+j*31,31) ) {
-            printf("LWASSN: duplicate column labels in output file, columns %d and %d both have the label %s \n",j,i,label+i*31);
-            ccperror(1,"Duplicate column labels in output file");
+
+      /* set label to program default */
+      for (j = 0; j != 30 && j != lsprgo_len && lsprgo[lsprgo_len*i+j] != ' ' ; ++j) {
+        label[i*31+j] = lsprgo[lsprgo_len*i+j];
+      }
+      label[i*31+j] = '\0';
+
+      /* if there was a user output assignment (LABOUT), overwrite
+         with this */
+      if (strcmp(user_label_out[*mindx-1][i][1],"")) {
+        strcpy(label+i*31,user_label_out[*mindx-1][i][1]);
+      } else {
+
+	/* else check for input assignment (see e.g. revise.exam) */
+	for (j = 0; j < MCOLUMNS; ++j) {
+	  if (strcmp(user_label_in[*mindx-1][j][1],"") && !strcmp(user_label_in[*mindx-1][j][0],label+i*31)) {
+	    strcpy(label+i*31,user_label_in[*mindx-1][j][1]);
+	    break;
 	  }
+	}
+
+      }
+
+      /* check for duplicated labels */
+      for (j = 0; j < i; ++j)
+        if ( ! strncmp(label+i*31,label+j*31,31) ) {
+          printf("LWASSN: duplicate column labels in output file, columns %d and %d both have the label %s \n",j,i,label+i*31);
+          ccperror(1,"Duplicate column labels in output file");
+        }
+
+    } /* end of labels loop */
 
-    } /* nlprgo for */
   /* types loop */
   for (i = 0; i < *nlprgo; ++i) {
       for (j = 0; j < 2; ++j) {
@@ -2358,6 +2372,7 @@
     
     /* assign new columns for output */
     colarray = ccp4_lwassn(mtzdata[*mindx-1],label,*nlprgo,type,*iappnd); 
+
     for (j = 0; j < 5; ++j)
         colsort[j] = NULL;
     for (i = 0; i < *nlprgo; ++i) {
@@ -2367,12 +2382,12 @@
             if (sortorder[*mindx-1][j] == (i + 1))
                 colsort[j] = colarray[i];
     }
-    MtzSetSortOrder(mtzdata[*mindx-1],colsort);
-    
-    /* now must update col data for write */
-    for (i = 0; i < *nlprgo; ++i)
-        if (strcmp(user_label_out[*mindx-1][i][1],"") ) strcpy(colarray[i]->label,user_label_out[*mindx-1][i][1]);
-    /*should confirm ctype */
+
+    /* If LWSORT has been called, then sortorder[][] should be set, and we make
+       sure sort order is up-to-date with output columns. If sortorder[][] not
+       set, we retain sort order of input file. */
+    if (sortorder[*mindx-1][0]) 
+      MtzSetSortOrder(mtzdata[*mindx-1],colsort);
     
     free(colarray);
     free(label);
@@ -2435,6 +2450,7 @@
 
   /* assign new columns for output */
   colarray = ccp4_lwassn(mtzdata[*mindx-1],label,*nlprgo,type,*iappnd); 
+
   for (j = 0; j < 5; ++j)
     colsort[j] = NULL;
   for (i = 0; i < *nlprgo; ++i) {
@@ -2444,7 +2460,12 @@
       if (sortorder[*mindx-1][j] == (i + 1)) 
         colsort[j] = colarray[i];
   }
-  MtzSetSortOrder(mtzdata[*mindx-1],colsort);
+
+  /* If LWSORT has been called, then sortorder[][] should be set, and we make
+     sure sort order is up-to-date with output columns. If sortorder[][] not
+     set, we retain sort order of input file. */
+  if (sortorder[*mindx-1][0]) 
+    MtzSetSortOrder(mtzdata[*mindx-1],colsort);
 
   free(colarray);
   free(label);
diff -ruN ccp4-5.0.2-orig/lib/src/cmtzlib_f.c.orig ccp4-5.0.2/lib/src/cmtzlib_f.c.orig
--- ccp4-5.0.2-orig/lib/src/cmtzlib_f.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ ccp4-5.0.2/lib/src/cmtzlib_f.c.orig	2005-01-17 14:51:52.000000000 -0800
@@ -0,0 +1,3019 @@
+/*
+     cmtzlib_f.c: Fortran API to CMTZlib
+     Copyright (C) 2001  CCLRC, Martyn Winn
+
+     This library is free software and is distributed under the terms and
+     conditions of the CCP4 licence agreement as `Part 0' (Annex 2)
+     software, which is version 2.1 of the GNU Lesser General Public
+     Licence (LGPL) with the following additional clause:
+
+        `You may also combine or link a "work that uses the Library" to
+        produce a work containing portions of the Library, and distribute
+        that work under terms of your choice, provided that you give
+        prominent notice with each copy of the work that the specified
+        version of the Library is used in it, and that you include or
+        provide public access to the complete corresponding
+        machine-readable source code for the Library including whatever
+        changes were used in the work. (i.e. If you make changes to the
+        Library you must distribute those, but you do not need to
+        distribute source or object code to those portions of the work
+        not covered by this licence.)'
+
+     Note that this clause grants an additional right and does not impose
+     any additional restriction, and so does not affect compatibility
+     with the GNU General Public Licence (GPL). If you wish to negotiate
+     other terms, please contact the maintainer.
+
+     You can redistribute it and/or modify the library under the terms of
+     the GNU Lesser General Public License as published by the Free Software
+     Foundation; either version 2.1 of the License, or (at your option) any
+     later version.
+
+     This library is distributed in the hope that it will be useful, but
+     WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+     Lesser General Public License for more details.
+
+     You should have received a copy of the CCP4 licence and/or GNU
+     Lesser General Public License along with this library; if not, write
+     to the CCP4 Secretary, Daresbury Laboratory, Warrington WA4 4AD, UK.
+     The GNU Lesser General Public can also be obtained by writing to the
+     Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+     MA 02111-1307 USA
+*/
+
+/** @page cmtz_f_page Fortran API to CMTZ 
+ *
+ *  @section cmtz_f_file_list File list
+
+<ul>
+<li>cmtzlib_f.c
+</ul>
+
+ *  @section cmtz_f_overview Overview
+
+This library consists of a set of wrappers to the CMTZ library
+giving the same API as the original mtzlib.f For details of the
+API, see the original <a href="../mtzlib.html">documentation</a>.
+This document covers some peculiarities of the C implementation.
+
+*   @section cmtz_f_batches Batches
+
+Batch headers are held as a linked list in the MTZ data structure.
+Upon reading an MTZ file, a list is created holding the all the batch
+headers from the input file (mtz->n_orig_bat holds the number read
+in). LRBATS will return a list of batch numbers. LRBAT can be used
+to read the batch headers one at a time.
+<p>
+LWBAT can be used to write new or updated batch headers. Updated
+batch headers are in fact added as new batch headers at the end of the
+list of input batch headers. This mimics the use of RBATW/CBATW in
+the Fortran routines. There are problems with this approach, and
+this may be re-implemented.
+
+ */
+ 
+/** @file cmtzlib_f.c
+ *
+ *  @brief Fortran API for input, output and manipulation of MTZ files.
+ *
+ *  @author Martyn Winn 
+ */
+
+/*#define FORTRAN_CALL_DEBUG 1*/
+
+#if defined (FORTRAN_CALL_DEBUG)
+#  define CMTZLIB_DEBUG(x) x
+#else
+#  define CMTZLIB_DEBUG(x)
+#endif
+
+#include <math.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "ccp4_fortran.h"
+#include "ccp4_utils.h"
+#include "cmtzlib.h"
+#include "csymlib.h"
+#include "ccp4_program.h"
+#include "ccp4_general.h"
+static char rcsid[] = "$Id: cmtzlib_f.c,v 1.62.2.3 2005/01/14 11:32:44 mdw Exp $";
+
+#define MFILES 4
+#define MAXSYM 192
+
+static int cmtz_in_memory = 0;
+static int rlun[MFILES] = {0};
+static int wlun[MFILES] = {0};
+static MTZ *mtzdata[MFILES] = {NULL};         /* cf. Eugene's channel for rwbrook */
+static char fileout[MFILES][MAXFLEN];
+static int irref[MFILES] = {0};
+static int iwref[MFILES] = {0};
+static char user_label_in[MFILES][MCOLUMNS][2][31];
+static char user_label_out[MFILES][MCOLUMNS][2][31];
+static MTZCOL *collookup[MFILES][MCOLUMNS];
+static MTZCOL *collookup_out[MFILES][MCOLUMNS];
+static int sortorder[MFILES][5] = {0};
+static int logmss[MFILES][MCOLUMNS];
+static int ndatmss[MFILES];
+static MTZBAT *rbat[MFILES];
+static int nbatw[MFILES] = {0};
+static double coefhkl[MFILES][6] = {0};
+
+/* MVS defaults to int and doesn't like it */
+#ifdef _MVS
+ void __stdcall CCP4H_INIT_LIB(int *ihtml, int *isumm);
+#endif
+
+void MtzMemTidy(void) {
+
+  int i;
+
+  /* free any existing Mtz struct */
+  for (i = 0; i < MFILES; ++i) 
+    if (mtzdata[i]) MtzFree(mtzdata[i]);
+}
+
+/* Utility function for checking subroutine input 
+   rwmode = 1 for read file, 2 for write file ... */
+int MtzCheckSubInput(const int mindx, const char *subname, const int rwmode) {
+
+ if (mindx <= 0 || mindx > MFILES) {
+   printf("Error in %s: mindx %d out of range!\n",subname,mindx);
+   return 1;
+ }
+
+ if (rwmode == 1 && rlun[mindx-1] == 0) {
+   printf("Error in %s: mindx %d not open for read!\n",subname,mindx);
+   return 1;
+ }
+
+ if (rwmode == 2 && wlun[mindx-1] == 0) {
+   printf("Error in %s: mindx %d not open for write!\n",subname,mindx);
+   return 1;
+ }
+
+ return 0;
+}
+
+/** Mainly for backwards compatibility. The only thing it does now is
+ * initialise the html/summary stuff, which is usually done by CCPFYP
+ * anyway.
+ */
+FORTRAN_SUBR ( MTZINI, mtzini,
+               ( ),
+               ( ),
+               ( ))
+{ int ihtml, isumm;
+
+  /* initialise html/summary stuff */
+  ihtml = 0;
+  isumm = 0;
+  FORTRAN_CALL (CCP4H_INIT_LIB, ccp4h_init_lib, (&ihtml,&isumm), (&ihtml,&isumm), (&ihtml,&isumm));
+  return;
+}
+
+/** Open an MTZ file for reading. This is a wrapper to MtzGet.
+ * @param mindx (I) MTZ file index
+ * @param filename (I) Filename to open (real or logical)
+ * @param iprint (I) Specifies how much header information to print out.
+ * @param ifail (O) Returns 0 if successful, non-zero otherwise.
+ */
+FORTRAN_SUBR ( LROPEN, lropen,
+               (int *mindx, fpstr filename, int *iprint, int *ifail, int filename_len),
+               (int *mindx, fpstr filename, int *iprint, int *ifail),
+               (int *mindx, fpstr filename, int filename_len, int *iprint, int *ifail))
+
+{ 
+  int i;
+  char *temp_name, *fullfilename;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LROPEN");)
+
+ *ifail = 0;
+
+ if (*mindx <= 0 || *mindx > MFILES) {
+   printf("Error: mindx out of range!\n");
+   *ifail = 1;
+   return;
+ }
+
+ if (rlun[*mindx-1] != 0) {
+   printf("Error: mindx already used for read!\n");
+   *ifail = 1;
+   return;
+ }
+
+ if (wlun[*mindx-1] != 0) {
+   printf("Error: mindx already used for write!\n");
+   *ifail = 1;
+   return;
+ }
+
+ temp_name = ccp4_FtoCString(FTN_STR(filename), FTN_LEN(filename));
+ if (getenv(temp_name) != NULL) {
+   fullfilename = strdup(getenv(temp_name));
+ } else {
+   fullfilename = strdup(temp_name);
+ }
+
+ /* In-memory mode not tested so well. Think it might be broken for
+    some Fortran programs, e.g. when generating extra reflections. */
+ if (getenv("CMTZ_IN_MEMORY")) cmtz_in_memory = 1;
+
+ /* open file and read into memory */
+ mtzdata[*mindx-1] = MtzGet(temp_name,cmtz_in_memory);
+ if (mtzdata[*mindx-1] == NULL) {
+   printf("Error: failed to open file for read!\n");
+   *ifail = -1;
+   return;
+ }
+ rlun[*mindx-1] = 1;
+
+ /* Make sure HKL are in base dataset */
+ MtzAssignHKLtoBase(mtzdata[*mindx-1]);
+
+ printf("\n OPENED INPUT MTZ FILE \n");
+ printf(" Logical Name: %s   Filename: %s \n\n",temp_name,fullfilename);
+ if (*iprint > 0) ccp4_lhprt(mtzdata[*mindx-1], *iprint);
+
+ /* set some control variables for Fortran calls */
+ irref[*mindx-1] = 0;
+ if (mtzdata[*mindx-1]->n_orig_bat > 0)
+   rbat[*mindx-1] = mtzdata[*mindx-1]->batch;
+
+ /* calculate hkl coefficients and store in coefhkl */
+ for (i = 0; i < mtzdata[*mindx-1]->nxtal; ++i)
+   if (mtzdata[*mindx-1]->xtal[i]->cell[0] > 0.001) {
+     MtzHklcoeffs(mtzdata[*mindx-1]->xtal[i]->cell, coefhkl[*mindx-1]);
+     break;
+   }
+
+ free(fullfilename); 
+ free(temp_name);
+
+}
+
+/** Get title from MTZ file opened for read.
+ * @param mindx (I) MTZ file index
+ * @param ftitle (O) Title.
+ * @param len (O) Length of returned title.
+ */
+FORTRAN_SUBR ( LRTITL, lrtitl,
+	       (int *mindx, fpstr ftitle, int *len, int ftitle_len),
+	       (int *mindx, fpstr ftitle, int *len),
+	       (int *mindx, fpstr ftitle, int ftitle_len, int *len))
+{
+  char temp_title[71];
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRTITL");)
+  if (MtzCheckSubInput(*mindx,"LRTITL",1)) return;
+
+  *len = ccp4_lrtitl(mtzdata[*mindx-1], temp_title);
+  ccp4_CtoFString(FTN_STR(ftitle),FTN_LEN(ftitle),temp_title);
+
+}
+
+/** Get history lines from MTZ file opened for read.
+ * @param mindx (I) MTZ file index
+ * @param hstrng (O) History lines.
+ * @param nlines (O) Number of history lines returned.
+ */
+FORTRAN_SUBR ( LRHIST, lrhist,
+	       (int *mindx, fpstr hstrng, int *nlines, int hstrng_len),
+	       (int *mindx, fpstr hstrng, int *nlines),
+	       (int *mindx, fpstr hstrng, int hstrng_len, int *nlines))
+
+{
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRHIST");)
+
+ if (MtzCheckSubInput(*mindx,"LRHIST",1)) return;
+
+ *nlines = ccp4_lrhist(mtzdata[*mindx-1], hstrng, *nlines);
+
+}
+
+/** Fortran wrapper to functions returning number of reflections, columns
+ * and ranges. In fact, it returns current values on MINDX rather than 
+ * those of the input file.
+ * @param mindx MTZ file index
+ * @param versnx MTZ version.
+ * @param ncolx Number of columns.
+ * @param nreflx Number of reflections.
+ * @param ranges Array of column ranges.
+ */
+FORTRAN_SUBR ( LRINFO, lrinfo,
+	       (int *mindx, fpstr versnx, int *ncolx, int *nreflx, float *ranges, int versnx_len),
+	       (int *mindx, fpstr versnx, int *ncolx, int *nreflx, float *ranges),
+	       (int *mindx, fpstr versnx, int versnx_len, int *ncolx, int *nreflx, float *ranges))
+
+{
+  int i,j,k,iarray;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRINFO");)
+
+ if (MtzCheckSubInput(*mindx,"LRINFO",1)) return;
+
+  ccp4_CtoFString(FTN_STR(versnx),FTN_LEN(versnx),MTZVERSN);
+  *ncolx = MtzNumActiveCol(mtzdata[*mindx-1]);
+  *nreflx = MtzNref(mtzdata[*mindx-1]);
+
+  /* get ranges of active columns */
+  iarray = 0;
+  for (i = 0; i < mtzdata[*mindx-1]->nxtal; ++i) 
+   for (j = 0; j < mtzdata[*mindx-1]->xtal[i]->nset; ++j) 
+    for (k = 0; k < mtzdata[*mindx-1]->xtal[i]->set[j]->ncol; ++k) 
+      if (mtzdata[*mindx-1]->xtal[i]->set[j]->col[k]->active) {
+        ranges[iarray*2] = mtzdata[*mindx-1]->xtal[i]->set[j]->col[k]->min;
+        ranges[iarray*2+1] = mtzdata[*mindx-1]->xtal[i]->set[j]->col[k]->max;
+        iarray++;
+      }
+}
+
+/** Fortran wrapper to function returning number of columns read in
+ * from input file.
+ * @param mindx MTZ file index
+ * @param ncolx Number of columns.
+ */
+FORTRAN_SUBR ( LRNCOL, lrncol,
+	       (int *mindx, int *ncolx),
+	       (int *mindx, int *ncolx),
+	       (int *mindx, int *ncolx))
+
+{
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRNCOL");)
+
+ if (MtzCheckSubInput(*mindx,"LRNCOL",1)) return;
+
+ *ncolx = MtzNumSourceCol(mtzdata[*mindx-1]);
+
+}
+
+/** Returns the current reflection number from an
+ *  MTZ file opened for read. Files are normally read sequentially,
+ *  the number returned is the number of the *NEXT* reflection
+ *  record to be read. If you are going to jump about the file
+ *  with LRSEEK then use this to record the current position before
+ *  you start, so that it can be restored afterwards, if required.
+ * @param mindx MTZ file index
+ * @param nreflx the reflection record number of the next reflection to be read
+ */
+FORTRAN_SUBR ( LRNREF, lrnref,
+	       (int *mindx, int *nreflx),
+	       (int *mindx, int *nreflx),
+	       (int *mindx, int *nreflx))
+
+{
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRNREF");)
+
+ if (MtzCheckSubInput(*mindx,"LRNREF",1)) return;
+
+  *nreflx = irref[*mindx-1] + 1;
+}
+
+/* Fortran wrapper for ccp4_lrsort */
+FORTRAN_SUBR ( LRSORT, lrsort,
+	       (int *mindx, int sortx[5]),
+	       (int *mindx, int sortx[5]),
+	       (int *mindx, int sortx[5]))
+
+{
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRSORT");)
+
+ if (MtzCheckSubInput(*mindx,"LRSORT",1)) return;
+
+  ccp4_lrsort(mtzdata[*mindx-1], sortx);
+
+}
+
+/** Fortran wrapper for ccp4_lrbats.
+ * May be called for non-multirecord file, just to check there are 
+ * no batches.
+ * @param mindx MTZ file index
+ * @param nbatx Number of batches found.
+ * @param batchx Array of batch numbers.
+ */
+FORTRAN_SUBR ( LRBATS, lrbats,
+	       (int *mindx, int *nbatx, int batchx[]),
+	       (int *mindx, int *nbatx, int batchx[]),
+	       (int *mindx, int *nbatx, int batchx[]))
+
+{
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRBATS");)
+
+ if (MtzCheckSubInput(*mindx,"LRBATS",1)) return;
+
+  ccp4_lrbats(mtzdata[*mindx-1], nbatx, batchx);
+
+}
+
+/* Fortran wrapper for MtzListColumn */
+FORTRAN_SUBR ( LRCLAB, lrclab,
+	       (int *mindx, fpstr clabs, fpstr ctyps, int *ncol, int clabs_len, int ctyps_len),
+	       (int *mindx, fpstr clabs, fpstr ctyps, int *ncol),
+	       (int *mindx, fpstr clabs, int clabs_len, fpstr ctyps, int ctyps_len, int *ncol))
+
+{
+ int i,j,k;
+ char cclabs[MCOLUMNS][31]={{0}}, cctyps[MCOLUMNS][3]={{0}};
+ int ccsetid[MCOLUMNS];
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRCLAB");)
+
+ if (MtzCheckSubInput(*mindx,"LRCLAB",1)) return;
+
+  *ncol = MtzListInputColumn(mtzdata[*mindx-1], cclabs, cctyps, ccsetid);
+
+  for (i = 0; i < *ncol; ++i) {
+    for (j = 0; j < clabs_len; ++j) {
+      if (cclabs[i][j] == '\0') {
+        for (k = j; k < clabs_len; ++k) {
+          clabs[clabs_len*i+k] = ' ';
+        }
+        break;
+      } else {
+        clabs[clabs_len*i+j] = cclabs[i][j];
+      }
+    }
+  }
+
+  for (i = 0; i < *ncol; ++i) {
+    for (j = 0; j < ctyps_len; ++j) {
+      if (cctyps[i][j] == '\0') {
+        for (k = j; k < ctyps_len; ++k) {
+          ctyps[ctyps_len*i+k] = ' ';
+        }
+        break;
+      } else {
+        ctyps[ctyps_len*i+j] = cctyps[i][j];
+      }
+    }
+  }
+}
+
+/* Fortran wrapper for MtzListColumn */
+FORTRAN_SUBR ( LRCLID, lrclid,
+	       (int *mindx, int csetid[], int *ncol),
+	       (int *mindx, int csetid[], int *ncol),
+	       (int *mindx, int csetid[], int *ncol))
+
+{
+ char cclabs[MCOLUMNS][31]={{0}}, cctyps[MCOLUMNS][3]={{0}};
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRCLID");)
+
+ if (MtzCheckSubInput(*mindx,"LRCLID",1)) return;
+
+  *ncol = MtzListInputColumn(mtzdata[*mindx-1], cclabs, cctyps, csetid);
+}
+
+/** Return the nominal cell dimensions of the MTZ structure. In
+ * fact, these are the cell dimensions of the 1st crystal in the
+ * MTZ structure. It is better to use the cell dimensions of the
+ * correct crystal, as obtained from LRIDX.
+ * @param mindx (I) MTZ file index
+ * @param cell (O) Cell dimensions.
+ */
+FORTRAN_SUBR ( LRCELL, lrcell,
+	       (int *mindx, float cell[]),
+	       (int *mindx, float cell[]),
+	       (int *mindx, float cell[]))
+
+{
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRCELL");)
+
+ if (MtzCheckSubInput(*mindx,"LRCELL",1)) return;
+
+  ccp4_lrcell(mtzdata[*mindx-1]->xtal[0], cell);
+
+}
+
+/** Return the overall resolution limits of the MTZ structure.
+ * These are the widest limits over all crystals present.
+ * @param mindx (I) MTZ file index
+ * @param minres (O) minimum resolution
+ * @param maxres (O) maximum resolution
+ */
+FORTRAN_SUBR ( LRRSOL, lrrsol,
+	       (int *mindx, float *minres, float *maxres),
+	       (int *mindx, float *minres, float *maxres),
+	       (int *mindx, float *minres, float *maxres))
+
+{
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRRSOL");)
+
+ if (MtzCheckSubInput(*mindx,"LRRSOL",1)) return;
+
+  MtzResLimits(mtzdata[*mindx-1], minres, maxres);
+
+}
+
+/* Fortran wrapper for ccp4_lrsymi */
+FORTRAN_SUBR ( LRSYMI, lrsymi,
+	       (int *mindx, int *nsympx, fpstr ltypex, int *nspgrx, fpstr spgrnx,
+                  fpstr pgnamx, int ltypex_len, int spgrnx_len, int pgnamx_len),
+	       (int *mindx, int *nsympx, fpstr ltypex, int *nspgrx, fpstr spgrnx,
+                  fpstr pgnamx),
+	       (int *mindx, int *nsympx, fpstr ltypex, int ltypex_len, int *nspgrx, 
+                  fpstr spgrnx, int spgrnx_len, fpstr pgnamx, int pgnamx_len))
+
+{ 
+ char ltypex_temp[2],spgrnx_temp[MAXSPGNAMELENGTH+1], pgnamx_temp[11];
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRSYMI");)
+
+ if (MtzCheckSubInput(*mindx,"LRSYMI",1)) return;
+
+  ccp4_lrsymi(mtzdata[*mindx-1], nsympx, ltypex_temp, nspgrx, spgrnx_temp, pgnamx_temp);
+
+  ccp4_CtoFString(FTN_STR(ltypex),FTN_LEN(ltypex),ltypex_temp);
+  ccp4_CtoFString(FTN_STR(spgrnx),FTN_LEN(spgrnx),spgrnx_temp);
+  ccp4_CtoFString(FTN_STR(pgnamx),FTN_LEN(pgnamx),pgnamx_temp);
+}
+
+/** Get symmetry matrices from MTZ structure.
+ * @param mindx (I) MTZ file index.
+ * @param nsymx (O) Number of symmetry operators held in MTZ header.
+ * @param rsymx (O) Symmetry operators as 4 x 4 matrices, in the order they
+ *   are held in the MTZ header. Each matrix has translations in
+ *   elements [3][*]. Note that a Fortran application will reverse
+ *   the order of indices.
+ */
+FORTRAN_SUBR ( LRSYMM, lrsymm,
+	       (int *mindx, int *nsymx, float rsymx[MAXSYM][4][4]),
+	       (int *mindx, int *nsymx, float rsymx[MAXSYM][4][4]),
+	       (int *mindx, int *nsymx, float rsymx[MAXSYM][4][4]))
+
+{
+  int i,j,k;
+  float rsym[MAXSYM][4][4];
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRSYMM");)
+
+  if (MtzCheckSubInput(*mindx,"LRSYMM",1)) return;
+
+  ccp4_lrsymm(mtzdata[*mindx-1], nsymx, rsym);
+
+  /* ccp4_lrsymm returns matrices in C order, so swap here */
+  for (i = 0; i < *nsymx; ++i)
+    for (j = 0; j < 4; ++j)
+      for (k = 0; k < 4; ++k) 
+        rsymx[i][j][k] = rsym[i][k][j];
+
+  /* register this spacegroup with csymlib_f */
+  ccp4spg_register_by_symops(mtzdata[*mindx-1]->mtzsymm.nsym,mtzdata[*mindx-1]->mtzsymm.sym);
+
+}
+
+/** Fortran wrapper to MtzParseLabin. This matches tokens from the LABIN
+ * line against the program labels supplied by the program.
+ * @param mindx (I) MTZ file index.
+ * @param lsprgi (I) Array of program column labels. These are the column
+ *  labels used by the program, as opposed to the column labels in the file.
+ * @param nlprgi (I) Number of input program labels.
+ * @param ntok (I) From Parser: number of tokens on line
+ * @param labin_line (I) From Parser: input line
+ * @param ibeg (I) From Parser: array of starting delimiters for each token
+ * @param iend (I) From Parser: array of ending delimiters for each token
+ */
+FORTRAN_SUBR ( LKYIN, lkyin,
+	       (const int *mindx, const fpstr lsprgi, const int *nlprgi, 
+                   const int *ntok, const fpstr labin_line, const int ibeg[], 
+                   const int iend[], int lsprgi_len, int labin_line_len),
+	       (const int *mindx, const fpstr lsprgi, const int *nlprgi, 
+                   const int *ntok, const fpstr labin_line, const int ibeg[], 
+                   const int iend[]),
+	       (const int *mindx, const fpstr lsprgi, int lsprgi_len, 
+                   const int *nlprgi, const int *ntok, const fpstr labin_line, 
+                   int labin_line_len, const int ibeg[], const int iend[] ))
+
+{ int i,j;
+  char *label;
+  char *temp_name;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LKYIN");)
+
+ if (*mindx <= 0 || *mindx > MFILES) {
+   printf("Error: mindx out of range!\n");
+   return;
+ }
+  label = (char *) ccp4_utils_malloc((*nlprgi)*31*sizeof(char));
+
+ temp_name = ccp4_FtoCString(FTN_STR(labin_line), FTN_LEN(labin_line));
+
+  for (i = 0; i < *nlprgi; ++i) {
+    for (j = 0; j < lsprgi_len; ++j) {
+      if (lsprgi[lsprgi_len*i+j] == ' ') {
+        break;
+      } else {
+        label[i*31+j] = lsprgi[lsprgi_len*i+j];
+      }
+    }
+    label[i*31+j] = '\0';
+  }
+ 
+  if (MtzParseLabin(temp_name,label,*nlprgi,user_label_in[*mindx-1]) == -1) 
+    ccperror(1,"Error in label assignments in LABIN");
+
+  free(temp_name);
+  free(label);
+}
+
+/* Fortran wrapper for MtzParseLabin */
+FORTRAN_SUBR ( LKYOUT, lkyout,
+	       (const int *mindx, const fpstr lsprgo, const int *nlprgo, 
+                   const int *ntok, const fpstr labin_line, const int ibeg[], 
+                   const int iend[], int lsprgo_len, int labin_line_len),
+	       (const int *mindx, const fpstr lsprgo, const int *nlprgo, 
+                   const int *ntok, const fpstr labin_line, const int ibeg[], 
+                   const int iend[]),
+	       (const int *mindx, const fpstr lsprgo, int lsprgo_len, 
+                   const int *nlprgo, const int *ntok, const fpstr labin_line, 
+                   int labin_line_len, const int ibeg[], const int iend[] ))
+
+{ int i,j;
+  char *label;
+  char *temp_name;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LKYOUT");)
+
+ if (*mindx <= 0 || *mindx > MFILES) {
+   printf("Error: mindx out of range!\n");
+   return;
+ }
+
+ if (*nlprgo <= 0) {
+   printf("Warning from LKYOUT: no program output labels !\n");
+   return;
+ }
+
+ if (*ntok <= 1) {
+   printf("Warning from LKYOUT: no arguments to LABOUT !\n");
+   return;
+ }
+  label = (char *) ccp4_utils_malloc((*nlprgo)*31*sizeof(char));
+
+ temp_name = ccp4_FtoCString(FTN_STR(labin_line), FTN_LEN(labin_line));
+
+  for (i = 0; i < *nlprgo; ++i) {
+    for (j = 0; j < lsprgo_len; ++j) {
+      if (lsprgo[lsprgo_len*i+j] == ' ') {
+        break;
+      } else {
+        label[i*31+j] = lsprgo[lsprgo_len*i+j];
+      }
+    }
+    label[i*31+j] = '\0';
+  }
+ 
+  if (MtzParseLabin(temp_name,label,*nlprgo,user_label_out[*mindx-1]) == -1) 
+    ccperror(1,"Error in label assignments in LABOUT");
+
+  free(temp_name);
+  free(label);
+}
+
+/* Fortran wrapper for MtzParseLabin */
+FORTRAN_SUBR ( LKYSET, lkyset,
+	       (const fpstr lsprgi, const int *nlprgi, 
+                   fpstr lsusrj, int kpoint[],
+                   const int *itok, const int *ntok, const fpstr labin_line, 
+                   const int ibeg[], const int iend[], 
+                   int lsprgi_len, int lsusrj_len, int labin_line_len),
+	       (const fpstr lsprgi, const int *nlprgi, 
+                   fpstr lsusrj, int kpoint[],
+                   const int *itok, const int *ntok, const fpstr labin_line, 
+                   const int ibeg[], const int iend[]),
+	       (const fpstr lsprgi, int lsprgi_len, const int *nlprgi, 
+                   fpstr lsusrj, int lsusrj_len, int kpoint[],
+                   const int *itok, const int *ntok, const fpstr labin_line, 
+                   int labin_line_len, const int ibeg[], const int iend[] ))
+
+{ int i,j,k;
+  char *label;
+  char *user_lab;
+  char *temp_name;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LKYSET");)
+
+ temp_name = ccp4_FtoCString(FTN_STR(labin_line), FTN_LEN(labin_line));
+  label = (char *) ccp4_utils_malloc((*nlprgi)*31*sizeof(char));
+  user_lab = (char *) ccp4_utils_malloc((*nlprgi)*62*sizeof(char));
+
+  for (i = 0; i < *nlprgi; ++i) {
+    for (j = 0; j < 30; ++j) {
+      if (lsprgi[lsprgi_len*i+j] == ' ') {
+        break;
+      } else {
+        label[i*31+j] = lsprgi[lsprgi_len*i+j];
+      }
+    }
+    label[i*31+j] = '\0';
+  }
+ 
+  if (MtzParseLabin(temp_name,label,*nlprgi,user_lab) == -1) 
+    ccperror(1,"Error in label assignments in LKYSET");
+
+  for (i = 0; i < *nlprgi; ++i) {
+    /* leave kpoint unchanged unless user label exists */
+    if (strcmp(user_lab+31+i*62,"") != 0)
+      kpoint[i] = -1;
+    for (j = 0; j < lsprgi_len; ++j) {
+      if (user_lab[31+i*62+j] == '\0') {
+        for (k = j; k < lsprgi_len; ++k) {
+          lsusrj[lsprgi_len*i+k] = ' ';
+        }
+        break;
+      } else {
+        lsusrj[lsprgi_len*i+j] = user_lab[31+i*62+j];
+      }
+    }
+  }
+
+ free(temp_name);
+ free(label);
+ free(user_lab);
+}
+
+/** Fortran wrapper to ccp4_lrassn. First this updates labels from 
+ * user_label_in if set by lkyin, then sets collookup array of pointers 
+ * to columns.
+ * @param mindx (I) MTZ file index.
+ * @param lsprgi (I) Array of program column labels. These are the column
+ *  labels used by the program, as opposed to the column labels in the file.
+ * @param nlprgi (I) Number of input program labels.
+ * @param lookup (I/O) On input, indicates whether a column is compulsory
+ *  or not (-1 = hard compulsory - program will fail if column not found,
+ *  1 = soft compulsory - program will attempt to find column even if not
+ *  assigned on LABIN, 0 = optional). On output, gives the index of the
+ *  column in the input file.
+ * @param ctprgi (I) Array of column types.
+ */
+FORTRAN_SUBR ( LRASSN, lrassn,
+	       (const int *mindx, fpstr lsprgi, int *nlprgi, int lookup[], fpstr ctprgi, 
+                      int lsprgi_len, int ctprgi_len),
+	       (const int *mindx, fpstr lsprgi, int *nlprgi, int lookup[], fpstr ctprgi),
+	       (const int *mindx, fpstr lsprgi, int lsprgi_len, int *nlprgi, 
+                      int lookup[], fpstr ctprgi, int ctprgi_len))
+
+{ int i,j,k,l,err;
+  char *label;
+  char *type;
+  MTZCOL **colarray;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRASSN");)
+
+  err = 0;
+  if (MtzCheckSubInput(*mindx,"LRASSN",1)) return;
+
+  label = (char *) ccp4_utils_malloc((*nlprgi)*31*sizeof(char));
+  type = (char *) ccp4_utils_malloc((*nlprgi)*3*sizeof(char));
+
+ /* if lkyin has been called, used those labels */
+ /* for soft and hard compulsory labels, use program labels */
+  for (i = 0; i < *nlprgi; ++i) {
+    if (strcmp(user_label_in[*mindx-1][i][1],"") != 0) {
+
+      if (!MtzColLookup(mtzdata[*mindx-1],user_label_in[*mindx-1][i][1])) {
+       printf("Error in LABIN: label %s not found in file!\n",user_label_in[*mindx-1][i][1]);
+       err++;
+      }
+      strcpy(label+i*31,user_label_in[*mindx-1][i][1]);
+
+    } else if (lookup[i] != 0) {
+      for (j = 0; j < 30; ++j) {
+        if (j == lsprgi_len || lsprgi[lsprgi_len*i+j] == ' ') {
+          break;
+        } else {
+          label[i*31+j] = lsprgi[lsprgi_len*i+j];
+        }
+      }
+      label[i*31+j] = '\0';
+    } else {
+      label[i*31] = '\0';
+    }
+  }
+
+  /* Exit on error */
+  if (err) {
+    ccperror(1,"Error in label assignments in LABIN");
+  }
+
+  for (i = 0; i < *nlprgi; ++i) {
+    for (j = 0; j < 2; ++j) {
+      if (j == ctprgi_len || ctprgi[ctprgi_len*i+j] == ' ') {
+        break;
+      } else {
+        type[i*3+j] = ctprgi[ctprgi_len*i+j];
+      }
+    }
+    type[i*3+j] = '\0';
+  }
+
+  colarray = ccp4_lrassn(mtzdata[*mindx-1],label,*nlprgi,type);
+  for (l = 0; l < *nlprgi; ++l) {
+    collookup[*mindx-1][l] = colarray[l];
+  }
+
+  for (l = 0; l < *nlprgi; ++l) {
+ /* Loop over all columns */
+   for (i = 0; i < mtzdata[*mindx-1]->nxtal; ++i) {
+    for (j = 0; j < mtzdata[*mindx-1]->xtal[i]->nset; ++j) {
+     for (k = 0; k < mtzdata[*mindx-1]->xtal[i]->set[j]->ncol; ++k) {
+       if (mtzdata[*mindx-1]->xtal[i]->set[j]->col[k] == collookup[*mindx-1][l]) {
+         lookup[l] = mtzdata[*mindx-1]->xtal[i]->set[j]->col[k]->source;
+         goto next_label;
+       } 
+     }
+    }
+   }
+   /* label not assigned */ 
+   /* Have compulsory labels been found? */
+   if (lookup[l] == -1) {
+     printf("Error: label %s not found in file!\n",label+l*31);
+     err++;
+   }
+   lookup[l] = 0;
+   next_label:
+   ;
+  }
+
+  free(colarray);
+  free(label);
+  free(type);
+
+  /* Exit on error */
+  if (err) {
+    ccperror(1,"Error in label assignments");
+  }
+
+  return;
+}
+
+/** Fortran wrapper for ccp4_lridx.
+ * Return dataset information. Note requirement to input how much
+ * memory allocated in calling routine.
+ * @param mindx MTZ file index
+ * @param project_name
+ * @param crystal_name
+ * @param dataset_name
+ * @param isets
+ * @param datcell
+ * @param datwave
+ * @param ndatasets On input: space reserved for dataset information.
+ *  On output: number of datasets found.
+ */
+FORTRAN_SUBR ( LRIDX, lridx,
+	       (const int *mindx, fpstr project_name, 
+                  fpstr crystal_name, fpstr dataset_name,
+		  int *isets, float *datcell, float *datwave,
+                  int *ndatasets, int project_name_len, 
+                  int crystal_name_len, int dataset_name_len),
+	       (const int *mindx, fpstr project_name, 
+                  fpstr crystal_name, fpstr dataset_name,
+		  int *isets, float *datcell, float *datwave,
+                  int *ndatasets),
+	       (const int *mindx, fpstr project_name, int project_name_len, 
+	          fpstr crystal_name, int crystal_name_len,
+		  fpstr dataset_name, int dataset_name_len,
+		  int *isets, float *datcell, float *datwave,
+                  int *ndatasets))
+{
+  int i,j,k,x,d,iset;
+  char cxname[64], cdname[64], cpname[64];
+  int cisets;
+  float cdatcell[6], cdatwave;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRIDX");)
+
+  if (MtzCheckSubInput(*mindx,"LRIDX",1)) return;
+
+  /* Loop over crystals */
+  for (iset = 0, x = 0; x < mtzdata[*mindx-1]->nxtal; ++x) {
+   /* Loop over datasets for each crystal */
+   for (d = 0; d < mtzdata[*mindx-1]->xtal[x]->nset; ++d ) {
+      ccp4_lridx(mtzdata[*mindx-1], mtzdata[*mindx-1]->xtal[x]->set[d], 
+		 cxname, cdname, cpname, &cisets, cdatcell, &cdatwave);
+
+      /* check calling Fortran has assigned enough memory */
+      if (iset+1 > *ndatasets) {
+       printf("Warning in LRIDX. You have only reserved enough memory for %d datasets but there are more in the MTZ file. \n",*ndatasets);
+       printf("Only returning partial dataset information. \n");
+       *ndatasets = -1;
+       return;
+      }
+
+      for (j = 0; j < project_name_len; ++j) {
+       if (cpname[j] == '\0') {
+        for (k = j; k < project_name_len; ++k) {
+          project_name[project_name_len*iset+k] = ' ';
+        }
+        break;
+       } else {
+         project_name[project_name_len*iset+j] = cpname[j];
+       }
+      }
+
+      for (j = 0; j < crystal_name_len; ++j) {
+       if (cxname[j] == '\0') {
+        for (k = j; k < crystal_name_len; ++k) {
+          crystal_name[crystal_name_len*iset+k] = ' ';
+        }
+        break;
+       } else {
+         crystal_name[crystal_name_len*iset+j] = cxname[j];
+       }
+      }
+
+      for (j = 0; j < dataset_name_len; ++j) {
+       if (cdname[j] == '\0') {
+        for (k = j; k < dataset_name_len; ++k) {
+          dataset_name[dataset_name_len*iset+k] = ' ';
+        }
+        break;
+       } else {
+         dataset_name[dataset_name_len*iset+j] = cdname[j];
+       }
+      }
+
+      isets[iset] = cisets;
+      for (j = 0; j < 6; ++j) 
+        datcell[iset*6+j] = cdatcell[j];
+      datwave[iset] = cdatwave;
+
+      ++iset;
+   }
+  }
+  *ndatasets = iset;
+
+}
+
+/* Return cell parameters associated with the specified dataset
+ * @param mindx On input: MTZ file index
+ * @param iset On input: integer specifying the setid for which the
+ * cell parameters are required.
+ * @param mtzcell Array of 6 reals. On output: populated with the 
+ * required cell parameters.
+ */
+FORTRAN_SUBR ( LRCELX, lrcelx,
+	       (const int *mindx, const int *iset, float *mtzcell),
+	       (const int *mindx, const int *iset, float *mtzcell),
+	       (const int *mindx, const int *iset, float *mtzcell))
+{
+  MTZ *mtz;
+  MTZXTAL *xtal;
+  MTZSET *set;
+  int i,j,k;
+
+  /* NB This function interacts directly with the mtz data structure stored
+     in memory */
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRCELX");)
+
+  if (MtzCheckSubInput(*mindx,"LRCELX",1)) return;
+
+  mtz = mtzdata[*mindx-1];
+  for (i = 0; i < mtz->nxtal; ++i) {
+    xtal = mtz->xtal[i];
+    for (j = 0; j < xtal->nset; ++j) {
+      set = xtal->set[j];
+      /* Check if we have found the set in question */
+      if (set->setid == *iset) {
+	/* Copy the cell for the crystal that the dataset belongs to */
+	for (k = 0; k < 6; ++k) {
+	  mtzcell[k] = xtal->cell[k];
+	}
+	/* Job done - escape! */
+	return;
+      }
+    }
+  }
+  printf("LRCELX: error, dataset %d not found\n",*iset);
+  return;
+}
+
+/* Fortran wrapper for ccp4_lridx */
+FORTRAN_SUBR ( LRIDC, lridc,
+	       (const int *mindx, fpstr project_name, fpstr dataset_name,
+		  int *isets, float *datcell, float *datwave,
+                  int *ndatasets, int project_name_len, int dataset_name_len),
+	       (const int *mindx, fpstr project_name, fpstr dataset_name,
+		  int *isets, float *datcell, float *datwave,
+                  int *ndatasets),
+	       (const int *mindx, fpstr project_name, int project_name_len,
+		  fpstr dataset_name, int dataset_name_len,
+		  int *isets, float *datcell, float *datwave,
+                  int *ndatasets))
+{
+  int i,j,k,x,d,iset;
+  char cxname[64], cdname[64], cpname[64];
+  int cisets;
+  float cdatcell[6], cdatwave;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRIDC");)
+
+  if (MtzCheckSubInput(*mindx,"LRIDC",1)) return;
+
+  /* Loop over crystals */
+  for (iset = 0, x = 0; x < mtzdata[*mindx-1]->nxtal; ++x) {
+   /* Loop over datasets for each crystal */
+   for (d = 0; d < mtzdata[*mindx-1]->xtal[x]->nset; ++d ) {
+      ccp4_lridx(mtzdata[*mindx-1], mtzdata[*mindx-1]->xtal[x]->set[d], 
+		 cxname, cdname, cpname, &cisets, cdatcell, &cdatwave);
+
+      for (j = 0; j < project_name_len; ++j) {
+       if (cpname[j] == '\0') {
+        for (k = j; k < project_name_len; ++k) {
+          project_name[project_name_len*iset+k] = ' ';
+        }
+        break;
+       } else {
+         project_name[project_name_len*iset+j] = cpname[j];
+       }
+      }
+
+      for (j = 0; j < dataset_name_len; ++j) {
+       if (cdname[j] == '\0') {
+        for (k = j; k < dataset_name_len; ++k) {
+          dataset_name[dataset_name_len*iset+k] = ' ';
+        }
+        break;
+       } else {
+         dataset_name[dataset_name_len*iset+j] = cdname[j];
+       }
+      }
+
+      isets[iset] = cisets;
+      for (j = 0; j < 6; ++j) 
+        datcell[iset*6+j] = cdatcell[j];
+      datwave[iset] = cdatwave;
+
+      ++iset;
+   }
+  }
+  *ndatasets = iset;
+}
+
+/* Fortran wrapper for ccp4_lridx */
+FORTRAN_SUBR ( LRID, lrid,
+	       (const int *mindx, fpstr project_name, fpstr dataset_name,
+		  int *isets, int *ndatasets, 
+                  int project_name_len, int dataset_name_len),
+	       (const int *mindx, fpstr project_name, fpstr dataset_name,
+		  int *isets, int *ndatasets),
+	       (const int *mindx, fpstr project_name, int project_name_len,
+		  fpstr dataset_name, int dataset_name_len,
+		  int *isets, int *ndatasets))
+{
+  int i,j,k,x,d,iset;
+  char cxname[64], cdname[64], cpname[64];
+  int cisets;
+  float cdatcell[6], cdatwave;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRID");)
+
+  if (MtzCheckSubInput(*mindx,"LRID",1)) return;
+
+  /* Loop over crystals */
+  for (iset = 0, x = 0; x < mtzdata[*mindx-1]->nxtal; ++x) {
+   /* Loop over datasets for each crystal */
+   for (d = 0; d < mtzdata[*mindx-1]->xtal[x]->nset; ++d ) {
+      ccp4_lridx(mtzdata[*mindx-1], mtzdata[*mindx-1]->xtal[x]->set[d], 
+		 cxname, cdname, cpname, &cisets, cdatcell, &cdatwave);
+
+      for (j = 0; j < project_name_len; ++j) {
+       if (cpname[j] == '\0') {
+        for (k = j; k < project_name_len; ++k) {
+          project_name[project_name_len*iset+k] = ' ';
+        }
+        break;
+       } else {
+         project_name[project_name_len*iset+j] = cpname[j];
+       }
+      }
+
+      for (j = 0; j < dataset_name_len; ++j) {
+       if (cdname[j] == '\0') {
+        for (k = j; k < dataset_name_len; ++k) {
+          dataset_name[dataset_name_len*iset+k] = ' ';
+        }
+        break;
+       } else {
+         dataset_name[dataset_name_len*iset+j] = cdname[j];
+       }
+      }
+
+      isets[iset] = cisets;
+
+      ++iset;
+   }
+  }
+  *ndatasets = iset;
+}
+
+/* If we are reading from memory rather than file, this simply sets irref */
+FORTRAN_SUBR ( LRSEEK, lrseek,
+	       (const int *mindx, int *nrefl),
+	       (const int *mindx, int *nrefl),
+	       (const int *mindx, int *nrefl))
+{
+  int respos;
+
+ CMTZLIB_DEBUG(puts("CMTZLIB_F: LRSEEK");)
+
+ if (MtzCheckSubInput(*mindx,"LRSEEK",1)) return;
+
+ /* lrrefl / lrreff will increment this */
+ irref[*mindx-1] = *nrefl - 1;
+ if (!cmtz_in_memory) {
+   respos = (*nrefl - 1) * MtzNumSourceCol(mtzdata[*mindx-1]) + SIZE1;
+   ccp4_file_seek(mtzdata[*mindx-1]->filein, respos, SEEK_SET); 
+ }
+}
+
+/* Fortran wrapper for ccp4_lrrefl */
+/* adata returned in file order */
+FORTRAN_SUBR ( LRREFL, lrrefl,
+	       (const int *mindx, float *resol, float adata[], ftn_logical *eof),
+	       (const int *mindx, float *resol, float adata[], ftn_logical *eof),
+	       (const int *mindx, float *resol, float adata[], ftn_logical *eof))
+{
+ int ieof,biomol,mindex;
+
+ /*CMTZLIB_DEBUG(puts("CMTZLIB_F: LRREFL");)*/
+
+ /* BIOMOL compatibility */
+ if (*mindx > 1000) {
+   biomol = 1;
+   mindex = *mindx - 1000;
+ } else {
+   biomol = 0;
+   mindex = *mindx;
+ }
+
+ if (MtzCheckSubInput(mindex,"LRREFL",1)) return;
+
+ ndatmss[mindex-1] = MtzNumSourceCol(mtzdata[mindex-1]);
+
+ ++irref[mindex-1];
+ ieof = ccp4_lrrefl(mtzdata[mindex-1], resol, adata, logmss[mindex-1], irref[mindex-1]);
+
+ if (ieof) {
+   *eof = FORTRAN_LOGICAL_TRUE;
+ } else {
+   *eof = FORTRAN_LOGICAL_FALSE;
+ }
+}
+
+/* Fortran wrapper for ccp4_lrreff */
+/* adata returned in order of requested columns */
+FORTRAN_SUBR ( LRREFF, lrreff,
+	       (const int *mindx, float *resol, float adata[], ftn_logical *eof),
+	       (const int *mindx, float *resol, float adata[], ftn_logical *eof),
+	       (const int *mindx, float *resol, float adata[], ftn_logical *eof))
+{
+ int i,ieof,mcol,biomol,mindex;
+
+  /*   CMTZLIB_DEBUG(puts("CMTZLIB_F: LRREFF");) */
+
+ /* BIOMOL compatibility */
+ if (*mindx > 1000) {
+   biomol = 1;
+   mindex = *mindx - 1000;
+ } else {
+   biomol = 0;
+   mindex = *mindx;
+ }
+
+ if (MtzCheckSubInput(mindex,"LRREFF",1)) return;
+
+ /* Get maximum number of columns to read
+    This is done by cycling backwards through the array until
+    we find the first active column
+ */
+ for (i = (MCOLUMNS-1); i >= 0; --i) 
+   if (collookup[mindex-1][i]) {
+     mcol = i+1;
+     break;
+   }
+ ndatmss[mindex-1] = mcol;
+
+ ++irref[mindex-1];
+ ieof = ccp4_lrreff(mtzdata[mindex-1], resol, adata, logmss[mindex-1], 
+             collookup[mindex-1], mcol, irref[mindex-1]);
+ if (ieof) {
+   *eof = FORTRAN_LOGICAL_TRUE;
+ } else {
+   *eof = FORTRAN_LOGICAL_FALSE;
+ }
+}
+
+/* Fortran wrapper for ccp4_lrrefm */
+FORTRAN_SUBR ( LRREFM, lrrefm,
+	       (const int *mindx, ftn_logical logmiss[]),
+	       (const int *mindx, ftn_logical logmiss[]),
+	       (const int *mindx, ftn_logical logmiss[]))
+{
+ int i;
+
+ if (MtzCheckSubInput(*mindx,"LRREFM",1)) return;
+
+  for (i = 0; i < ndatmss[*mindx-1]; ++i) {
+   if (logmss[*mindx-1][i]) {
+     logmiss[i] = FORTRAN_LOGICAL_TRUE;
+   } else {
+     logmiss[i] = FORTRAN_LOGICAL_FALSE;
+   }
+  }
+
+}
+
+/* Check for MNFs in array of ndata reals. Results returned in logmiss. */
+FORTRAN_SUBR ( MTZ_CHECK_FOR_MNF, mtz_check_for_mnf,
+	       (const int *mindx, const int *ndata, float adata[], ftn_logical logmiss[]),
+	       (const int *mindx, const int *ndata, float adata[], ftn_logical logmiss[]),
+	       (const int *mindx, const int *ndata, float adata[], ftn_logical logmiss[]))
+{
+ int i;
+
+ if (MtzCheckSubInput(*mindx,"MTZ_CHECK_FOR_MNF",1)) return;
+
+ for (i = 0; i < *ndata; ++i) {
+   if (ccp4_ismnf(mtzdata[*mindx-1], adata[i])) {
+     logmiss[i] = FORTRAN_LOGICAL_TRUE;
+   } else {
+     logmiss[i] = FORTRAN_LOGICAL_FALSE;
+   }
+ }
+}
+/* print out header information */
+FORTRAN_SUBR ( LHPRT, lhprt,
+	       (const int *mindx, const int *iprint), 
+	       (const int *mindx, const int *iprint), 
+	       (const int *mindx, const int *iprint))
+{
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LHPRT");)
+
+ if (MtzCheckSubInput(*mindx,"LHPRT",1)) return;
+ 
+ ccp4_lhprt(mtzdata[*mindx-1], *iprint);
+
+}
+
+/* print out header information */
+FORTRAN_SUBR ( LHPRT_ADV, lhprt_adv,
+	       (const int *mindx, const int *iprint), 
+	       (const int *mindx, const int *iprint), 
+	       (const int *mindx, const int *iprint))
+{
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LHPRT_ADV");)
+
+ if (MtzCheckSubInput(*mindx,"LHPRT_ADV",1)) return;
+ 
+ ccp4_lhprt_adv(mtzdata[*mindx-1], *iprint);
+
+}
+
+/** Fortran wrapper for ccp4_lrbat. Returns the header info for the next 
+ * batch from the multi-record MTZ file open on index MINDX, as
+ * the two arrays RBATCH (for numbers) and CBATCH (for characters).
+ * @param mindx MTZ file index
+ * @param batno On return, batch number
+ * @param rbatch On return, real and integer batch data.
+ * @param cbatch On return, character batch data (title and axes names).
+ * @param iprint =0 no printing, =1 print title only, >1 print full header.
+ */
+FORTRAN_SUBR ( LRBAT, lrbat,
+	       (const int *mindx, int *batno, float rbatch[], fpstr cbatch, 
+                        const int *iprint, int cbatch_len),
+	       (const int *mindx, int *batno, float rbatch[], fpstr cbatch, 
+                        const int *iprint),
+	       (const int *mindx, int *batno, float rbatch[], fpstr cbatch, 
+                        int cbatch_len, const int *iprint))
+
+{
+  MTZBAT *batch;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRBAT");)
+
+ if (MtzCheckSubInput(*mindx,"LRBAT",1)) return;
+
+ if (mtzdata[*mindx-1]->n_orig_bat <= 0) {
+   printf("Error: file on mindx is not a multi-record file! \n");
+   return;
+ }
+
+ if (rbat[*mindx-1] == NULL) {
+   *batno = -1;
+   return;
+ }
+
+ batch = rbat[*mindx-1];
+ *batno = batch->num;
+
+ ccp4_lrbat(batch, rbatch, cbatch, *iprint); 
+
+ /* advance to next batch (may be NULL) */
+ rbat[*mindx-1] = batch->next;
+
+}
+
+/* Print batch header information. In principle, this need not be
+   connected to existing data structure */
+FORTRAN_SUBR ( LBPRT, lbprt,
+	       (const int *ibatch, const int *iprint, float rbatch[], fpstr cbatch, 
+                        int cbatch_len),
+               (const int *ibatch, const int *iprint, float rbatch[], fpstr cbatch),
+               (const int *ibatch, const int *iprint, float rbatch[], fpstr cbatch, 
+                        int cbatch_len))
+{
+  char btitle[71];
+
+  /* For batches */
+  int *intbuf = (int *) rbatch;
+  float *fltbuf = rbatch + NBATCHINTEGERS;
+  MTZBAT *batch;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LBPRT");)
+
+  if (! *iprint) return;
+
+  if (*iprint == 1) {
+    strncpy(btitle,cbatch,70);
+    btitle[70] = '\0';
+    printf(" Batch number: \n");
+    printf(" %6d    %s\n",*ibatch,btitle);
+  }
+
+  batch = MtzMallocBatch();
+
+  strncpy(batch->title,cbatch,70); 
+  strncpy(batch->gonlab[0],cbatch+70,8); 
+  strncpy(batch->gonlab[1],cbatch+78,8); 
+  strncpy(batch->gonlab[2],cbatch+86,8); 
+  batch->num = *ibatch;
+  MtzArrayToBatch(intbuf, fltbuf, batch);
+
+  MtzPrintBatchHeader(batch);
+
+  MtzFreeBatch(batch);
+
+  return;
+}
+
+/* Set batch pointer to batch number batno. This is
+   held in the static rbat[]. If batno == 0 then
+   set rbat[] to mtz->batch */
+FORTRAN_SUBR ( LRBRES, lrbres,
+	       (const int *mindx, const int *batno),
+	       (const int *mindx, const int *batno),
+	       (const int *mindx, const int *batno))
+
+{ int istat=-1;
+  MTZBAT *batch;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRBRES");)
+
+ if (MtzCheckSubInput(*mindx,"LRBRES",1)) return;
+
+ if (mtzdata[*mindx-1]->n_orig_bat <= 0) {
+   printf("Error: file on mindx is not a multi-record file! \n");
+   return;
+ }
+
+ if (*batno == 0) {
+   rbat[*mindx-1] = mtzdata[*mindx-1]->batch;
+ } else {
+   batch = mtzdata[*mindx-1]->batch;
+   while (batch != NULL) {
+     if (*batno == batch->num) {
+       rbat[*mindx-1] = batch;
+       istat = 0;
+       break;
+     }
+     batch = batch->next;
+   }
+   if (istat == -1) 
+    printf("Error: file on %d has no batch %d ! \n",*mindx,*batno);
+ }
+
+}
+
+/* Fortran wrapper for ccp4_lrbat */
+FORTRAN_SUBR ( LRBTIT, lrbtit,
+	       (const int *mindx, const int *batno, fpstr tbatch, 
+                        const int *iprint, int tbatch_len),
+	       (const int *mindx, const int *batno, fpstr tbatch, 
+                        const int *iprint),
+	       (const int *mindx, const int *batno, fpstr tbatch, 
+                        int tbatch_len, const int *iprint))
+
+{ int istat=-1;
+  MTZBAT *batch;
+  float rbatch[NBATCHWORDS];
+  char cbatch[94];
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRBTIT");)
+
+ if (MtzCheckSubInput(*mindx,"LRBTIT",1)) return;
+
+ if (mtzdata[*mindx-1]->n_orig_bat <= 0) {
+   printf("Error: file on mindx is not a multi-record file! \n");
+   return;
+ }
+
+ batch = mtzdata[*mindx-1]->batch;
+ while (batch != NULL) {
+   if (*batno == batch->num) {
+     rbat[*mindx-1] = batch;
+     istat = 0;
+     ccp4_lrbat(batch, rbatch, cbatch, *iprint); 
+     break;
+   }
+   batch = batch->next;
+ }
+ if (istat == -1) 
+    printf("Error: file on %d has no batch %d ! \n",*mindx,*batno);
+
+ /* advance to next batch (may be NULL) */
+ rbat[*mindx-1] = batch->next;
+
+ strncpy(tbatch,cbatch,70);
+
+}
+
+/* Fortran wrapper for ccp4_lrbat */
+FORTRAN_SUBR ( LRBSCL, lrbscl,
+	       (const int *mindx, const int *batno, float batscl[], int *nbatsc),
+	       (const int *mindx, const int *batno, float batscl[], int *nbatsc),
+	       (const int *mindx, const int *batno, float batscl[], int *nbatsc))
+
+{ int istat=-1, nbscal, iprint=0;
+  MTZBAT *batch;
+  float rbatch[NBATCHWORDS];
+  int *intbatch = (int *) rbatch;
+  char cbatch[94];
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRBSCL");)
+
+ if (MtzCheckSubInput(*mindx,"LRBSCL",1)) return;
+
+ if (mtzdata[*mindx-1]->n_orig_bat <= 0) {
+   printf("Error in lrbscl: file on mindx is not a multi-record file! \n");
+   return;
+ }
+
+ batch = mtzdata[*mindx-1]->batch;
+ while (batch != NULL) {
+   if (*batno == batch->num) {
+     rbat[*mindx-1] = batch;
+     istat = 0;
+     ccp4_lrbat(batch, rbatch, cbatch, iprint); 
+     break;
+   }
+   batch = batch->next;
+ }
+ if (istat == -1) {
+    printf("Error: file on %d has no batch %d ! \n",*mindx,*batno);
+   return;
+ }
+
+ /* advance to next batch (may be NULL) */
+ rbat[*mindx-1] = batch->next;
+
+ nbscal = intbatch[16];
+ if (nbscal > *nbatsc) {
+   printf("From LRBSCL : %d too many batch scales in orientation block for batch %d, maximum %d \n",nbscal,*batno,*nbatsc);
+   return;
+ }
+ *nbatsc = nbscal;
+ batscl[0] = rbatch[72];
+ batscl[1] = rbatch[73];
+ batscl[2] = rbatch[74];
+ batscl[3] = rbatch[75];
+
+}
+
+/* Fortran wrapper for ccp4_lrbat */
+FORTRAN_SUBR ( LRBSETID, lrbsetid,
+	       (const int *mindx, const int *batno, int *bsetid),
+	       (const int *mindx, const int *batno, int *bsetid),
+	       (const int *mindx, const int *batno, int *bsetid))
+
+{ int istat=-1, iprint=0;
+  MTZBAT *batch;
+  float rbatch[NBATCHWORDS];
+  int *intbatch = (int *) rbatch;
+  char cbatch[94];
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LRBSETID");)
+
+ if (MtzCheckSubInput(*mindx,"LRBSETID",1)) return;
+
+ if (mtzdata[*mindx-1]->n_orig_bat <= 0) {
+   printf("Error: file on mindx is not a multi-record file! \n");
+   return;
+ }
+
+ batch = mtzdata[*mindx-1]->batch;
+ while (batch != NULL) {
+   if (*batno == batch->num) {
+     istat = 0;
+     ccp4_lrbat(batch, rbatch, cbatch, iprint); 
+     break;
+   }
+   batch = batch->next;
+ }
+ if (istat == -1) 
+    printf("Error: file on %d has no batch %d ! \n",*mindx,*batno);
+
+ *bsetid = intbatch[20];
+
+}
+
+/* Rewind to first reflection */
+FORTRAN_SUBR ( LRREWD, lrrewd,
+	       (const int *mindx), 
+	       (const int *mindx), 
+	       (const int *mindx))
+
+{ 
+
+ if (MtzCheckSubInput(*mindx,"LRREWD",1)) return;
+ 
+ irref[*mindx-1] = 0;
+ /* Position file at start of reflections */
+ if (!cmtz_in_memory)
+   ccp4_file_seek(mtzdata[*mindx-1]->filein, SIZE1, SEEK_SET); 
+
+}
+
+/* Fortran wrapper for MtzHklcoeffs */
+FORTRAN_SUBR ( LSTRSL, lstrsl,
+	       (const int *mindx, const float *a, const float *b, const float *c,
+                    const float *alpha, const float *beta, const float *gamma ), 
+	       (const int *mindx, const float *a, const float *b, const float *c,
+                    const float *alpha, const float *beta, const float *gamma ), 
+	       (const int *mindx, const float *a, const float *b, const float *c,
+                    const float *alpha, const float *beta, const float *gamma ))
+
+{ float cell[6];
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LSTRSL");)
+
+ cell[0] = *a;
+ cell[1] = *b;
+ cell[2] = *c;
+ cell[3] = *alpha;
+ cell[4] = *beta;
+ cell[5] = *gamma;
+
+ /* calculate hkl coefficients and store in coefhkl */
+ MtzHklcoeffs(cell, coefhkl[*mindx-1]);
+
+}
+
+/* Fortran wrapper for MtzInd2reso */
+FORTRAN_FUN (float, LSTLSQ, lstlsq,
+	       (const int *mindx, const int *ih, const int *ik, const int *il),
+               (const int *mindx, const int *ih, const int *ik, const int *il),
+               (const int *mindx, const int *ih, const int *ik, const int *il))
+{
+  int in[3];
+  float reso;
+
+/*   CMTZLIB_DEBUG(puts("CMTZLIB_F: LSTLSQ");) */
+
+  in[0] = *ih;
+  in[1] = *ik;
+  in[2] = *il;
+
+  reso = MtzInd2reso(in, coefhkl[*mindx-1]);
+
+  return reso/4.0;
+
+}
+
+/* In fact, already closed, so free memory */
+FORTRAN_SUBR ( LRCLOS, lrclos,
+	       (const int *mindx), 
+	       (const int *mindx), 
+	       (const int *mindx))
+
+{ 
+
+ if (MtzCheckSubInput(*mindx,"LRCLOS",1)) return;
+ 
+ rlun[*mindx-1] = 0;
+ if (wlun[*mindx-1] == 0) {
+   MtzFree(mtzdata[*mindx-1]);
+   mtzdata[*mindx-1] = NULL;
+ }
+
+}
+
+/** Fortran wrapper to open output MTZ file. In fact, if 
+ * reflection data is being held in memory, defer opening
+ * until MtzPut call. But if reflections are written
+ * immediately to file, need to open now.
+ * @param mindx MTZ file index.
+ * @param filename Output file name.
+ * @param ifail (O) Returns 0 if successful, non-zero otherwise.
+ */
+FORTRAN_SUBR ( LWOPEN_NOEXIT, lwopen_noexit,
+	       (const int *mindx, fpstr filename, int *ifail, int filename_len),
+	       (const int *mindx, fpstr filename, int *ifail),
+	       (const int *mindx, fpstr filename, int filename_len, int *ifail))
+
+{ 
+  char *temp_name, err_str[200];
+  int nxtal=1, nset[1]={1};
+  int i,j,k,icol;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWOPEN_NOEXIT");)
+
+ *ifail = 0;
+
+ if (*mindx <= 0 || *mindx > MFILES) {
+   printf("Error: mindx out of range!\n");
+   *ifail = 1;
+   return;
+ }
+
+ temp_name = ccp4_FtoCString(FTN_STR(filename), FTN_LEN(filename));
+
+ if (getenv("CMTZ_IN_MEMORY")) cmtz_in_memory = 1;
+
+ /* no corresponding read file, so set up empty structure with
+    HKL_base crystal and dataset. Label set ID 0, so added ones
+    start at 1. */
+ if (rlun[*mindx-1] == 0) {
+  mtzdata[*mindx-1] = MtzMalloc(nxtal,nset);
+  strcpy(mtzdata[*mindx-1]->xtal[0]->xname,"HKL_base");
+  strcpy(mtzdata[*mindx-1]->xtal[0]->pname,"HKL_base");
+  mtzdata[*mindx-1]->xtal[0]->set[0]->setid = 0;
+  strcpy(mtzdata[*mindx-1]->xtal[0]->set[0]->dname,"HKL_base");
+  mtzdata[*mindx-1]->refs_in_memory = cmtz_in_memory;
+ }
+
+ wlun[*mindx-1] = 1;
+ strcpy(fileout[*mindx-1],temp_name);
+ iwref[*mindx-1] = 0;
+
+ if (!cmtz_in_memory) {
+   if ( !(mtzdata[*mindx-1]->fileout = MtzOpenForWrite(temp_name)) ) {
+     strcpy(err_str,"LWOPEN_NOEXIT: failed to open output file ");
+     strncat(err_str,temp_name,160);
+     ccperror(2,err_str);
+     free(temp_name);
+     *ifail = 1;
+     return;
+   }
+
+   /* assign existing columns for output */
+   /* if lwclab/lwassn are called with iappnd=0 then these are overwritten */
+   /* needs to be here for those rare progs which don't call lwclab/lwassn */
+   for (i = 0; i < mtzdata[*mindx-1]->nxtal; ++i)
+    for (j = 0; j < mtzdata[*mindx-1]->xtal[i]->nset; ++j)
+     for (k = 0; k < mtzdata[*mindx-1]->xtal[i]->set[j]->ncol; ++k)
+       if (icol = mtzdata[*mindx-1]->xtal[i]->set[j]->col[k]->source)
+         collookup_out[*mindx-1][icol-1] = mtzdata[*mindx-1]->xtal[i]->set[j]->col[k];
+ }
+
+ free(temp_name);
+}
+
+/** Fortran wrapper to open output MTZ file. In fact, if 
+ * reflection data is being held in memory, defer opening
+ * until MtzPut call. But if reflections are written
+ * immediately to file, need to open now.
+ * @param mindx MTZ file index.
+ * @param filename Output file name.
+ */
+FORTRAN_SUBR ( LWOPEN, lwopen,
+	       (const int *mindx, fpstr filename, int filename_len),
+	       (const int *mindx, fpstr filename),
+	       (const int *mindx, fpstr filename, int filename_len))
+
+{ 
+  int ifail;
+
+  FORTRAN_CALL ( LWOPEN_NOEXIT, lwopen_noexit,
+	       (mindx, filename, &ifail, filename_len),
+	       (mindx, filename, &ifail),
+	       (mindx, filename, filename_len, &ifail));
+
+ if ( ifail )
+   ccperror(1,"LWOPEN: failed to open output file");
+}
+
+/* Fortran wrapper for ccp4_lwtitl */
+FORTRAN_SUBR ( LWTITL, lwtitl,
+	       (const int *mindx, const fpstr ftitle, const int *flag, int ftitle_len),
+	       (const int *mindx, const fpstr ftitle, const int *flag),
+	       (const int *mindx, const fpstr ftitle, int ftitle_len, const int *flag))
+
+{
+ char *temp_title;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWTITL");)
+
+ if (MtzCheckSubInput(*mindx,"LWTITL",2)) return;
+
+ temp_title = ccp4_FtoCString(FTN_STR(ftitle), FTN_LEN(ftitle));
+
+ ccp4_lwtitl(mtzdata[*mindx-1], temp_title, *flag);
+ free(temp_title);
+
+}
+
+/** Set sort order for output file. The integer array is stored
+ * as static. Try to set sort order now, but may not be possible
+ * if LWCLAB/LWASSN not yet called.
+ * @param mindx MTZ file index.
+ * @param sortx Sort order as integer array.
+ */
+FORTRAN_SUBR ( LWSORT, lwsort,
+	       (const int *mindx, int sortx[5]),
+	       (const int *mindx, int sortx[5]),
+	       (const int *mindx, int sortx[5]))
+
+{ int i,j,k,l,icol=0;
+  MTZCOL *colsort[5];
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWSORT");)
+
+ if (MtzCheckSubInput(*mindx,"LWSORT",2)) return;
+
+ for (i = 0; i < 5; ++i) {
+   sortorder[*mindx-1][i] = sortx[i];
+   colsort[i] = NULL;
+ }
+ for (i = 0; i < mtzdata[*mindx-1]->nxtal; ++i) 
+   for (j = 0; j < mtzdata[*mindx-1]->xtal[i]->nset; ++j) 
+     for (k = 0; k < mtzdata[*mindx-1]->xtal[i]->set[j]->ncol; ++k) {
+       ++icol;
+       for (l = 0; l < 5; ++l)
+         if (sortx[l] == icol)
+           colsort[l] = mtzdata[*mindx-1]->xtal[i]->set[j]->col[k];
+     }
+
+  MtzSetSortOrder(mtzdata[*mindx-1],colsort);
+
+}
+
+/* Fortran wrapper for MtzAddHistory */
+FORTRAN_SUBR ( LWHIST, lwhist,
+	       (int *mindx, fpstr hstrng, int *nlines, int hstrng_len),
+	       (int *mindx, fpstr hstrng, int *nlines),
+	       (int *mindx, fpstr hstrng, int hstrng_len, int *nlines))
+
+{
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWHIST");)
+
+ if (MtzCheckSubInput(*mindx,"LWHIST",2)) return;
+
+ MtzAddHistory(mtzdata[*mindx-1], hstrng, *nlines);
+
+}
+
+/* Fortran wrapper for MtzAddHistory */
+/* Also includes progname and date */
+FORTRAN_SUBR ( LWHSTL, lwhstl,
+	       (int *mindx, const fpstr hstrng, int hstrng_len),
+	       (int *mindx, const fpstr hstrng),
+	       (int *mindx, const fpstr hstrng, int hstrng_len))
+
+{
+ char hline[MTZRECORDLENGTH],date[11],time[9],*temp_hstrng;
+ size_t len=0, Length;
+ int i;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWHSTL");)
+
+ if (*mindx <= 0 || *mindx > MFILES) {
+   printf("Error in lwhstl: mindx out of range!\n");
+   return;
+ }
+
+ if (!mtzdata[*mindx-1]) {
+   printf("Error in lwhstl: mindx not open for write (or read)!\n");
+   return;
+ }
+
+ strcpy(hline,"From ");
+ if (ccp4ProgramName(NULL)) {
+   len = strlen(strcpy(hline+5,ccp4ProgramName(NULL))) + 5;
+   hline[len++] = ' ';
+ }
+ if (ccp4_utils_date(date)) {
+   len = len + strlen(strcpy(hline+len,date));
+   hline[len++] = ' ';
+ }
+ if (ccp4_utils_time(time)) {
+   len = len + strlen(strcpy(hline+len,time));
+   hline[len++] = ' ';
+ }
+
+/* append hstrng to hline - hline is not necessarily null-terminated */
+/* MtzAddHistory assumes that hline is either null-terminated, or 
+ * full - otherwise, garbage may be added 
+ */
+ temp_hstrng = ccp4_FtoCString(FTN_STR(hstrng), FTN_LEN(hstrng));
+ Length = strlen(temp_hstrng);
+ if (Length > MTZRECORDLENGTH-len) Length = MTZRECORDLENGTH-len;
+ strncpy(hline+len,temp_hstrng,Length);
+ for (i = len+Length; i < MTZRECORDLENGTH; ++i) hline[i] = '\0';
+
+ MtzAddHistory(mtzdata[*mindx-1], hline, 1);
+
+ free(temp_hstrng);
+}
+
+/** Fortran wrapper to ccp4_lwidx for writing dataset header information.
+ * As for LWIDX except crystal name is not provided, and defaults to
+ * supplied project name. Also cell and wavelength are not provided and
+ * default to zero. This exists for backwards-compatibility - use LWIDX
+ * instead.
+ * @param mindx MTZ file index.
+ * @param project_name Name of project that parent crystal belongs to.
+ * @param dataset_name Name of dataset.
+ */
+FORTRAN_SUBR ( LWID, lwid,
+	       (const int *mindx, const fpstr project_name, const fpstr dataset_name, 
+                  int project_name_len, int dataset_name_len),
+	       (const int *mindx, const fpstr project_name, const fpstr dataset_name),
+	       (const int *mindx, const fpstr project_name, int project_name_len,
+                  const fpstr dataset_name, int dataset_name_len))
+
+{ char *temp_xname, *temp_pname, *temp_dname;
+  float datcell[6]={0.0},datwave=0.0;
+ MTZ *mtz;
+ int i;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWID");)
+
+ if (MtzCheckSubInput(*mindx,"LWID",2)) return;
+
+ temp_pname = ccp4_FtoCString(FTN_STR(project_name), FTN_LEN(project_name));
+ temp_dname = ccp4_FtoCString(FTN_STR(dataset_name), FTN_LEN(dataset_name));
+
+ /* default crystal name to project name */
+ temp_xname = strdup(temp_pname);
+
+ mtz = mtzdata[*mindx-1];
+
+ /* if it's a new crystal, then default cell dimensions to existing ones */
+ if (MtzXtalLookup(mtz,temp_xname) == NULL && 
+     mtz->nxtal > 0 && mtz->xtal[0]->cell[0] != 0.0) 
+  for (i = 0; i < 6; ++i) 
+    datcell[i] = mtz->xtal[0]->cell[i];
+
+  ccp4_lwidx(mtz, temp_xname, temp_dname, temp_pname, datcell, &datwave);
+  free(temp_xname); 
+  free(temp_pname); 
+  free(temp_dname); 
+}
+
+/** Fortran wrapper to ccp4_lwidx for writing dataset header information.
+ * As for LWIDX except crystal name is not provided, and defaults to
+ * supplied project name. This exists for backwards-compatibility - use LWIDX
+ * instead.
+ * @param mindx MTZ file index.
+ * @param project_name Name of project that parent crystal belongs to.
+ * @param dataset_name Name of dataset.
+ * @param datcell Cell dimensions of parent crystal.
+ * @param datwave Wavelength of dataset.
+ */
+FORTRAN_SUBR ( LWIDC, lwidc,
+	       (const int *mindx, const fpstr project_name, const fpstr dataset_name,
+		  float datcell[6], float *datwave,
+                  int project_name_len, int dataset_name_len),
+	       (const int *mindx, const fpstr project_name, const fpstr dataset_name,
+		  float datcell[6], float *datwave),
+	       (const int *mindx, const fpstr project_name, int project_name_len,
+		  const fpstr dataset_name, int dataset_name_len,
+		  float datcell[6], float *datwave))
+
+{ char *temp_xname, *temp_pname, *temp_dname;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWIDC");)
+
+ if (MtzCheckSubInput(*mindx,"LWIDC",2)) return;
+
+ temp_pname = ccp4_FtoCString(FTN_STR(project_name), FTN_LEN(project_name));
+ temp_dname = ccp4_FtoCString(FTN_STR(dataset_name), FTN_LEN(dataset_name));
+
+  /* default crystal name to project name */
+ temp_xname = strdup(temp_pname);
+
+  ccp4_lwidx(mtzdata[*mindx-1], temp_xname, temp_dname, temp_pname, datcell, datwave);
+  free(temp_xname); 
+  free(temp_pname); 
+  free(temp_dname); 
+}
+
+/** Fortran wrapper to ccp4_lwidx for writing dataset header information.
+ * @param mindx MTZ file index.
+ * @param project_name Name of project that parent crystal belongs to.
+ * @param crystal_name Name of parent crystal.
+ * @param dataset_name Name of dataset.
+ * @param datcell Cell dimensions of parent crystal.
+ * @param datwave Wavelength of dataset.
+ */
+FORTRAN_SUBR ( LWIDX, lwidx,
+	       (const int *mindx, const fpstr project_name, const fpstr crystal_name,
+		  const fpstr dataset_name, float datcell[6], float *datwave,
+                  int project_name_len, int crystal_name_len, int dataset_name_len),
+	       (const int *mindx, const fpstr project_name, const fpstr crystal_name,
+		  const fpstr dataset_name, float datcell[6], float *datwave),
+	       (const int *mindx, const fpstr project_name, int project_name_len,
+		  const fpstr crystal_name, int crystal_name_len,
+		  const fpstr dataset_name, int dataset_name_len,
+		  float datcell[6], float *datwave))
+
+{ char *temp_xname, *temp_pname, *temp_dname;
+
+ CMTZLIB_DEBUG(puts("CMTZLIB_F: LWIDX");)
+
+ if (MtzCheckSubInput(*mindx,"LWIDX",2)) return;
+
+ temp_pname = ccp4_FtoCString(FTN_STR(project_name), FTN_LEN(project_name));
+ temp_xname = ccp4_FtoCString(FTN_STR(crystal_name), FTN_LEN(crystal_name));
+ temp_dname = ccp4_FtoCString(FTN_STR(dataset_name), FTN_LEN(dataset_name));
+
+  ccp4_lwidx(mtzdata[*mindx-1], temp_xname, temp_dname, temp_pname, datcell, datwave);
+  free(temp_xname); 
+  free(temp_pname); 
+  free(temp_dname); 
+}
+
+/** Fortran wrapper to update cell of output MTZ file. Overall
+ * cell is obsolete - we only store crystal cell dimensions.
+ * Therefore this simply writes the cell dimensions for any
+ * crystal which has not yet been set. Crystal cell dimensions
+ * should be set directly with lwidc.
+ * @param mindx MTZ file index.
+ * @param cell Output cell dimensions.
+ */
+FORTRAN_SUBR ( LWCELL, lwcell,
+	       (const int *mindx, float cell[6]),
+	       (const int *mindx, float cell[6]),
+	       (const int *mindx, float cell[6]))
+
+{
+ MTZ *mtz;
+ int i,j;
+ char xname[200]="unknown", pname[200]="unknown", dname[200]="unknown";
+ float datwave = 0.0;
+
+ CMTZLIB_DEBUG(puts("CMTZLIB_F: LWCELL");)
+
+ if (MtzCheckSubInput(*mindx,"LWCELL",2)) return;
+
+ /* nothing to do if input cell is zero */
+ if (cell[0] < 0.001) return;
+
+ mtz = mtzdata[*mindx-1];
+ if (mtz->nxtal == 0) {
+  ccp4_lwidx(mtz, xname, dname, pname, cell, &datwave);
+ } else {
+  for (i = 0; i < mtz->nxtal; ++i) {
+   if (mtz->xtal[i]->cell[0] == 0.0) 
+     for (j = 0; j < 6; ++j) 
+       mtz->xtal[i]->cell[j] = cell[j];
+  }
+ }
+
+ /* calculate hkl coefficients and store in coefhkl */
+ MtzHklcoeffs(cell, coefhkl[*mindx-1]);
+}
+
+/** Obsolete - use LWIDASX.
+ * @param mindx MTZ file index.
+ * @param nlprgo Number of output columns.
+ * @param pname Array of project names.
+ * @param dname Array of dataset names.
+ * @param iappnd If 0 then assign all columns, if 1 then assign appended columns.
+ */
+FORTRAN_SUBR ( LWIDAS, lwidas,
+	       (const int *mindx, int *nlprgo, fpstr pname, fpstr dname, int *iappnd,
+                      int pname_len, int dname_len),
+	       (const int *mindx, int *nlprgo, fpstr pname, fpstr dname, int *iappnd),
+	       (const int *mindx, int *nlprgo, fpstr pname, int pname_len, 
+                      fpstr dname, int dname_len, int *iappnd))
+{int i,j,k,istart;
+  char *project_name;
+  char *crystal_name;
+  char *dataset_name;
+  MTZSET *baseset=NULL;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWIDAS");)
+
+  if (MtzCheckSubInput(*mindx,"LWIDAS",2)) return;
+
+  project_name = (char *) ccp4_utils_malloc((*nlprgo)*(pname_len+1)*sizeof(char));
+  crystal_name = (char *) ccp4_utils_malloc((*nlprgo)*(pname_len+1)*sizeof(char));
+  dataset_name = (char *) ccp4_utils_malloc((*nlprgo)*(dname_len+1)*sizeof(char));
+
+  for (i = 0; i < *nlprgo; ++i) {
+    for (j = 0; j < pname_len; ++j) {
+      if (pname[pname_len*i+j] == ' ') {
+        break;
+      } else {
+       project_name[i*(pname_len+1)+j] = pname[pname_len*i+j];
+      }
+    }
+    project_name[i*(pname_len+1)+j] = '\0';
+  /* default crystal name to project name */
+    strcpy(crystal_name+i*(pname_len+1),project_name+i*(pname_len+1));
+  }
+
+  for (i = 0; i < *nlprgo; ++i) {
+    for (j = 0; j < dname_len; ++j) {
+      if (dname[dname_len*i+j] == ' ') {
+        break;
+      } else {
+        dataset_name[i*(dname_len+1)+j] = dname[dname_len*i+j];
+      }
+    }
+    dataset_name[i*(dname_len+1)+j] = '\0';
+  }
+
+  /* assignment request is in terms of pname/dname but data structure
+     is in terms of xname/dname. We need to find appropriate xname.
+     Use first crystal of correct pname/dname. If none found, above
+     default is used. */
+  for (i = 0; i < *nlprgo; ++i) 
+   for (j = 0; j < mtzdata[*mindx-1]->nxtal; ++j) 
+    if (!strcmp(mtzdata[*mindx-1]->xtal[j]->pname,
+                project_name+i*(pname_len+1))) 
+     for (k = 0; k < mtzdata[*mindx-1]->xtal[j]->nset; ++k) 
+      if (!strcmp(mtzdata[*mindx-1]->xtal[j]->set[k]->dname,
+                  dataset_name+i*(dname_len+1))) {
+        strncpy(crystal_name+i*(pname_len+1),
+                mtzdata[*mindx-1]->xtal[j]->xname,pname_len);
+        *(crystal_name+i*(pname_len+1)+pname_len) = '\0';
+      }
+
+  /* if we are appending columns, shift collookup_out */
+  istart = 0;
+  if (*iappnd == 1) istart = MtzNumSourceCol(mtzdata[*mindx-1]);
+
+  /* get base dataset if it exists */
+  baseset = MtzSetLookup(mtzdata[*mindx-1],"HKL_base/HKL_base");
+
+  for (i = 0; i < *nlprgo; ++i) {
+
+    /* sanity check */
+    if (!collookup_out[*mindx-1][i+istart]) {
+      printf(" LWIDAS: severe warning - column %d does not exist. \n",i);
+      continue;
+    }
+
+    if (baseset && (strcmp(collookup_out[*mindx-1][i+istart]->type,"H") == 0) ) {
+      MtzAssignColumn(mtzdata[*mindx-1], collookup_out[*mindx-1][i+istart], 
+          "HKL_base","HKL_base");
+    } else if (strlen(crystal_name+i*(pname_len+1)) && 
+               strlen(dataset_name+i*(dname_len+1))) {
+      MtzAssignColumn(mtzdata[*mindx-1], collookup_out[*mindx-1][i+istart], 
+          crystal_name+i*(pname_len+1), dataset_name+i*(dname_len+1));
+    }
+  }
+
+  free(project_name);
+  free(crystal_name);
+  free(dataset_name);
+
+}
+
+/** Assign output columns to crystal/datasets.
+ * @param mindx MTZ file index.
+ * @param nlprgo Number of output columns.
+ * @param xname Array of crystal names for columns.
+ * @param dname Array of dataset names for columns.
+ * @param iappnd If 0 then assign all columns, if 1 then assign appended columns.
+ */
+FORTRAN_SUBR ( LWIDASX, lwidasx,
+	       (const int *mindx, int *nlprgo, fpstr xname, fpstr dname, int *iappnd,
+                      int xname_len, int dname_len),
+	       (const int *mindx, int *nlprgo, fpstr xname, fpstr dname, int *iappnd),
+	       (const int *mindx, int *nlprgo, fpstr xname, int xname_len, 
+                      fpstr dname, int dname_len, int *iappnd))
+{int i,j,k,istart;
+  char *crystal_name;
+  char *dataset_name;
+  MTZSET *baseset=NULL;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWIDASX");)
+
+  if (MtzCheckSubInput(*mindx,"LWIDASX",2)) return;
+
+  crystal_name = (char *) ccp4_utils_malloc((*nlprgo)*(xname_len+1)*sizeof(char));
+  dataset_name = (char *) ccp4_utils_malloc((*nlprgo)*(dname_len+1)*sizeof(char));
+
+  for (i = 0; i < *nlprgo; ++i) {
+    for (j = 0; j < xname_len; ++j) {
+      if (xname[xname_len*i+j] == ' ') {
+        break;
+      } else {
+       crystal_name[i*(xname_len+1)+j] = xname[xname_len*i+j];
+      }
+    }
+    crystal_name[i*(xname_len+1)+j] = '\0';
+  }
+
+  for (i = 0; i < *nlprgo; ++i) {
+    for (j = 0; j < dname_len; ++j) {
+      if (dname[dname_len*i+j] == ' ') {
+        break;
+      } else {
+        dataset_name[i*(dname_len+1)+j] = dname[dname_len*i+j];
+      }
+    }
+    dataset_name[i*(dname_len+1)+j] = '\0';
+  }
+
+  /* if we are appending columns, shift collookup_out */
+  istart = 0;
+  if (*iappnd == 1) istart = MtzNumSourceCol(mtzdata[*mindx-1]);
+
+  /* get base dataset if it exists */
+  baseset = MtzSetLookup(mtzdata[*mindx-1],"HKL_base/HKL_base");
+
+  for (i = 0; i < *nlprgo; ++i) {
+
+    /* sanity check */
+    if (!collookup_out[*mindx-1][i+istart]) {
+      printf(" LWIDASX: severe warning - column %d does not exist. \n",i);
+      continue;
+    }
+
+    if (baseset && (strcmp(collookup_out[*mindx-1][i+istart]->type,"H") == 0) ) {
+      MtzAssignColumn(mtzdata[*mindx-1], collookup_out[*mindx-1][i+istart], 
+          "HKL_base","HKL_base");
+    } else if (strlen(crystal_name+i*(xname_len+1)) && 
+               strlen(dataset_name+i*(dname_len+1))) {
+      MtzAssignColumn(mtzdata[*mindx-1], collookup_out[*mindx-1][i+istart], 
+          crystal_name+i*(xname_len+1), dataset_name+i*(dname_len+1));
+    }
+  }
+
+  free(crystal_name);
+  free(dataset_name);
+}
+
+/** Assign output columns to crystal/datasets.
+ * This is a simpler version of LWIDASX to assign all columns to one dataset 
+ * (except for HKL which are assigned to base dataset). 
+ * @param mindx MTZ file index.
+ * @param xname Crystal name for all columns.
+ * @param dname Dataset name for all columns.
+ */
+FORTRAN_SUBR ( LWIDALL, lwidall,
+	       (const int *mindx, fpstr xname, fpstr dname,
+                      int xname_len, int dname_len),
+	       (const int *mindx, fpstr xname, fpstr dname),
+	       (const int *mindx, fpstr xname, int xname_len, 
+                      fpstr dname, int dname_len))
+{ int i,j,k,l=0;
+  MTZCOL **colarray;
+  char *crystal_name;
+  char *dataset_name;
+  MTZSET *baseset=NULL;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWIDALL");)
+  if (MtzCheckSubInput(*mindx,"LWIDALL",2)) return;
+
+  crystal_name = ccp4_FtoCString(FTN_STR(xname), FTN_LEN(xname));
+  dataset_name = ccp4_FtoCString(FTN_STR(dname), FTN_LEN(dname));
+
+  /* get base dataset if it exists */
+  baseset = MtzSetLookup(mtzdata[*mindx-1],"HKL_base/HKL_base");
+
+  if (strlen(crystal_name) && strlen(dataset_name)) {
+
+   /* need direct pointers to columns as we are going to mess with xtal/set hierarchy */
+   colarray = (MTZCOL **) ccp4_utils_malloc(MtzNcol(mtzdata[*mindx-1])*sizeof(MTZCOL *));
+
+   for (i = 0; i < mtzdata[*mindx-1]->nxtal; ++i)
+    for (j = 0; j < mtzdata[*mindx-1]->xtal[i]->nset; ++j)
+      for (k = 0; k < mtzdata[*mindx-1]->xtal[i]->set[j]->ncol; ++k)
+        colarray[l++] = mtzdata[*mindx-1]->xtal[i]->set[j]->col[k];
+
+   for (l = 0; l < MtzNcol(mtzdata[*mindx-1]); ++l) {
+     if (baseset && (strcmp(colarray[l]->type,"H") == 0) ) {
+       MtzAssignColumn(mtzdata[*mindx-1], colarray[l], "HKL_base","HKL_base");
+     } else {
+       MtzAssignColumn(mtzdata[*mindx-1], colarray[l], crystal_name, dataset_name);
+     }
+   }
+
+   free(colarray);
+
+  }
+
+  free(crystal_name);
+  free(dataset_name);
+}
+
+/** Write or update symmetry information for MTZ header. 
+ * @param mindx (I) MTZ file index.
+ * @param nsymx (I) number of symmetry operators
+ * @param nsympx (I) number of primitive symmetry operators
+ * @param rsymx (I) Array of symmetry operators as 4 x 4 matrices. Each matrix 
+ *   is input with translations in elements [3][*] (i.e. reversed with respect
+ *   to the way the Fortran application sees it). This function reverses
+ *   the order before passing to ccp4_lwsymm.
+ * @param ltypex (I) lattice type
+ * @param nspgrx (I) spacegroup number
+ * @param spgrnx (I) spacegroup name
+ * @param pgnamx (I) point group name
+ */
+FORTRAN_SUBR ( LWSYMM, lwsymm,
+	       (int *mindx, int *nsymx, int *nsympx, float rsymx[MAXSYM][4][4],
+                  fpstr ltypex, int *nspgrx, fpstr spgrnx, fpstr pgnamx, 
+                  int ltypex_len, int spgrnx_len, int pgnamx_len),
+	       (int *mindx, int *nsymx, int *nsympx, float rsymx[MAXSYM][4][4],
+                  fpstr ltypex, int *nspgrx, fpstr spgrnx, fpstr pgnamx),
+	       (int *mindx, int *nsymx, int *nsympx, float rsymx[MAXSYM][4][4],
+                  fpstr ltypex, int ltypex_len, int *nspgrx, fpstr spgrnx, 
+		int spgrnx_len, fpstr pgnamx, int pgnamx_len))
+{
+ char *temp_ltypex, *temp_spgrnx, *temp_pgnamx;
+ int i,j,k,nsym;
+ float rsym[MAXSYM][4][4];
+
+ CMTZLIB_DEBUG(puts("CMTZLIB_F: LWSYMM");)
+
+ if (MtzCheckSubInput(*mindx,"LWSYMM",2)) return;
+
+ temp_ltypex = ccp4_FtoCString(FTN_STR(ltypex), FTN_LEN(ltypex));
+ temp_spgrnx = ccp4_FtoCString(FTN_STR(spgrnx), FTN_LEN(spgrnx));
+ temp_pgnamx = ccp4_FtoCString(FTN_STR(pgnamx), FTN_LEN(pgnamx));
+
+ /* deal with array conventions */
+ nsym = *nsymx;
+ if (nsym > MAXSYM) nsym = MAXSYM;
+ for (i = 0; i < nsym; ++i)
+   for (j = 0; j < 4; ++j)
+     for (k = 0; k < 4; ++k) 
+       rsym[i][j][k] = rsymx[i][k][j];
+
+ /* if there is a cell, check specified symmetry is consistent with it */
+ if (mtzdata[*mindx-1]->xtal[0]->cell[0] != 0.0 ) 
+   if (!ccp4spg_check_symm_cell(nsym,rsym,mtzdata[*mindx-1]->xtal[0]->cell)) {
+     printf(" LWSYMM: severe warning - specified symmetry not consistent with cell dimensions! \n");
+     printf(" Spacegroup %s \n",temp_spgrnx);
+     printf(" Cell dimensions %f %f %f %f %f %f \n",mtzdata[*mindx-1]->xtal[0]->cell[0],
+       mtzdata[*mindx-1]->xtal[0]->cell[1],mtzdata[*mindx-1]->xtal[0]->cell[2],
+       mtzdata[*mindx-1]->xtal[0]->cell[3],mtzdata[*mindx-1]->xtal[0]->cell[4],
+	    mtzdata[*mindx-1]->xtal[0]->cell[5]);
+     ccperror(1,"Error in spacegroup or cell dimensions.");
+   }
+
+  ccp4_lwsymm(mtzdata[*mindx-1], nsym, *nsympx, rsym, temp_ltypex, 
+            *nspgrx, temp_spgrnx, temp_pgnamx);
+
+  free(temp_ltypex);
+  free(temp_spgrnx);
+  free(temp_pgnamx);
+
+}
+
+/** Fortran wrapper to assign columns of output MTZ file. 
+ * First this updates labels from user_label_out if set by lkyout,
+ * then sets collookup_out array of pointers to columns.
+ * @param mindx MTZ file index.
+ * @param lsprgo array of output labels
+ * @param nlprgo number of output labels
+ * @param ctprgo array of output column types
+ * @param iappnd if = 0 replace all existing columns, else if = 1 "append" to 
+ *   existing columns. Note that columns are appended to the relevant datasets
+ *   and are not therefore necessarily at the end of the list of columns.
+ */
+FORTRAN_SUBR ( LWASSN, lwassn,
+	       (const int *mindx, fpstr lsprgo, const int *nlprgo, fpstr ctprgo, int *iappnd,
+                      int lsprgo_len, int ctprgo_len),
+	       (const int *mindx, fpstr lsprgo, const int *nlprgo, fpstr ctprgo, int *iappnd),
+	       (const int *mindx, fpstr lsprgo, int lsprgo_len, const int *nlprgo, 
+                      fpstr ctprgo, int ctprgo_len, int *iappnd))
+{   int i,j,istart;
+    char *label;
+    char *type;
+    MTZCOL **colarray, *colsort[5];
+
+    CMTZLIB_DEBUG(puts("CMTZLIB_F: LWASSN");)
+
+    if (MtzCheckSubInput(*mindx,"LWASSN",2)) return;
+
+    label = (char *) ccp4_utils_malloc((*nlprgo)*31*sizeof(char));
+    type = (char *) ccp4_utils_malloc((*nlprgo)*3*sizeof(char));
+
+    /* Construct label array to pass to ccp4_lwassn.
+       This has undergone several iterations. Watch out for
+       special cases: 
+         output assignment is taken from LABIN e.g. revise
+           (same prog label in lsprgi and lsprgo, and iappnd = 0)
+         dm has same prog label FDM in lsprgi and lsprgo, and 
+           iappnd = 1 so these are distinct columns
+         sfall has "labout allin" which should be sorted out by
+           sfall itself
+     */
+    for (i = 0; i < *nlprgo; ++i) {
+
+      /* set label to program default */
+      for (j = 0; j != 30 && j != lsprgo_len && lsprgo[lsprgo_len*i+j] != ' ' ; ++j) {
+        label[i*31+j] = lsprgo[lsprgo_len*i+j];
+      }
+      label[i*31+j] = '\0';
+
+      /* if there was a user output assignment (LABOUT), overwrite
+         with this */
+      if (strcmp(user_label_out[*mindx-1][i][1],"")) {
+        strcpy(label+i*31,user_label_out[*mindx-1][i][1]);
+      } else {
+
+	/* else check for input assignment (see e.g. revise.exam) */
+	for (j = 0; j < MCOLUMNS; ++j) {
+	  if (strcmp(user_label_in[*mindx-1][j][1],"") && !strcmp(user_label_in[*mindx-1][j][0],label+i*31)) {
+	    strcpy(label+i*31,user_label_in[*mindx-1][j][1]);
+	    break;
+	  }
+	}
+
+      }
+
+      /* check for duplicated labels */
+      for (j = 0; j < i; ++j)
+        if ( ! strncmp(label+i*31,label+j*31,31) ) {
+          printf("LWASSN: duplicate column labels in output file, columns %d and %d both have the label %s \n",j,i,label+i*31);
+          ccperror(1,"Duplicate column labels in output file");
+        }
+
+    } /* end of labels loop */
+
+  /* types loop */
+  for (i = 0; i < *nlprgo; ++i) {
+      for (j = 0; j < 2; ++j) {
+          if (j == ctprgo_len || ctprgo[ctprgo_len*i+j] == ' ') {
+              break;
+          } else {
+              type[i*3+j] = ctprgo[ctprgo_len*i+j];
+          }
+      }
+      type[i*3+j] = '\0';
+  } /* type loop */
+
+  /* if we are appending columns, shift collookup_out */
+    istart = 0;
+    if (*iappnd == 1) istart = MtzNumSourceCol(mtzdata[*mindx-1]);
+    
+    /* assign new columns for output */
+    colarray = ccp4_lwassn(mtzdata[*mindx-1],label,*nlprgo,type,*iappnd); 
+
+    for (j = 0; j < 5; ++j)
+        colsort[j] = NULL;
+    for (i = 0; i < *nlprgo; ++i) {
+        collookup_out[*mindx-1][i+istart] = colarray[i];
+        /* register sort order */
+        for (j = 0; j < 5; ++j)
+            if (sortorder[*mindx-1][j] == (i + 1))
+                colsort[j] = colarray[i];
+    }
+
+    /* If LWSORT has been called, then sortorder[][] should be set, and we make
+       sure sort order is up-to-date with output columns. If sortorder[][] not
+       set, we retain sort order of input file. */
+    if (sortorder[*mindx-1][0]) 
+      MtzSetSortOrder(mtzdata[*mindx-1],colsort);
+    
+    free(colarray);
+    free(label);
+    free(type);
+    
+    }
+
+/* Fortran wrapper for ccp4_lwassn */
+/* As lwassn except doesn't check user_label_out */
+FORTRAN_SUBR ( LWCLAB, lwclab,
+	       (const int *mindx, fpstr lsprgo, const int *nlprgo, fpstr ctprgo, int *iappnd,
+                      int lsprgo_len, int ctprgo_len),
+	       (const int *mindx, fpstr lsprgo, const int *nlprgo, fpstr ctprgo, int *iappnd),
+	       (const int *mindx, fpstr lsprgo, int lsprgo_len, const int *nlprgo, 
+                      fpstr ctprgo, int ctprgo_len, int *iappnd))
+{int i,j,istart;
+  char *label;
+  char *type;
+  MTZCOL **colarray, *colsort[5];
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWCLAB");)
+
+ if (MtzCheckSubInput(*mindx,"LWCLAB",2)) return;
+
+  label = (char *) ccp4_utils_malloc((*nlprgo)*31*sizeof(char));
+  type = (char *) ccp4_utils_malloc((*nlprgo)*3*sizeof(char));
+
+  for (i = 0; i < *nlprgo; ++i) {
+    for (j = 0; j < 30; ++j) {
+      if (j == lsprgo_len || lsprgo[lsprgo_len*i+j] == ' ') {
+        break;
+      } else {
+       label[i*31+j] = lsprgo[lsprgo_len*i+j];
+      }
+    }
+    label[i*31+j] = '\0';
+
+    /* check for duplicated labels */
+    for (j = 0; j < i; ++j)
+      if ( ! strncmp(label+i*31,label+j*31,31) ) {
+        printf("LWCLAB: duplicate column labels in output file, columns %d and %d both have the label %s \n",j,i,label+i*31);
+        ccperror(1,"Duplicate column labels in output file");
+      }
+  }
+
+  for (i = 0; i < *nlprgo; ++i) {
+    for (j = 0; j < 3; ++j) {
+      if (j == ctprgo_len || ctprgo[ctprgo_len*i+j] == ' ') {
+        break;
+      } else {
+        type[i*3+j] = ctprgo[ctprgo_len*i+j];
+      }
+    }
+    type[i*3+j] = '\0';
+  }
+
+  /* if we are appending columns, shift collookup_out */
+  istart = 0;
+  if (*iappnd == 1) istart = MtzNumSourceCol(mtzdata[*mindx-1]);
+
+  /* assign new columns for output */
+  colarray = ccp4_lwassn(mtzdata[*mindx-1],label,*nlprgo,type,*iappnd); 
+
+  for (j = 0; j < 5; ++j)
+    colsort[j] = NULL;
+  for (i = 0; i < *nlprgo; ++i) {
+    collookup_out[*mindx-1][i+istart] = colarray[i];
+    /* register sort order */
+    for (j = 0; j < 5; ++j)
+      if (sortorder[*mindx-1][j] == (i + 1)) 
+        colsort[j] = colarray[i];
+  }
+
+  /* If LWSORT has been called, then sortorder[][] should be set, and we make
+     sure sort order is up-to-date with output columns. If sortorder[][] not
+     set, we retain sort order of input file. */
+  if (sortorder[*mindx-1][0]) 
+    MtzSetSortOrder(mtzdata[*mindx-1],colsort);
+
+  free(colarray);
+  free(label);
+  free(type);
+
+}
+
+/** Write batch header for batch number batno.
+ * @param mindx MTZ file index
+ * @param batno Serial number of batch.
+ * @param rbatch Real/integer batch information.
+ * @param cbatch Character batch information.
+ */
+FORTRAN_SUBR ( LWBAT, lwbat,
+	       (const int *mindx, int *batno, float rbatch[], fpstr cbatch, 
+                        int cbatch_len),
+	       (const int *mindx, int *batno, float rbatch[], fpstr cbatch),
+	       (const int *mindx, int *batno, float rbatch[], fpstr cbatch, 
+                        int cbatch_len))
+
+{
+  MTZBAT *batch;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWBAT");)
+
+ if (MtzCheckSubInput(*mindx,"LWBAT",2)) return;
+
+ /* No check on mtzdata[*mindx-1]->n_orig_bat  It might be 0 if this is the
+    first batch written. */
+
+ /* batno = 0 is special flag to remove batch information */
+ /* Used for example in SCALA to write merged file from unmerged input */
+
+ if (*batno == 0) {
+   mtzdata[*mindx-1]->n_orig_bat = 0;
+   MtzFreeBatch(mtzdata[*mindx-1]->batch);
+   mtzdata[*mindx-1]->batch = NULL;
+   return;
+ }
+
+ /* add as new batch */
+ batch = NULL;
+
+ ccp4_lwbat(mtzdata[*mindx-1], batch, *batno, rbatch, cbatch); 
+
+ /* record number of batch headers for output */
+ ++nbatw[*mindx-1];
+}
+
+/** Write batch header for batch number batno. Only the batch title
+ * is provided, so dummy header is written.
+ * @param mindx MTZ file index
+ * @param batno Serial number of batch.
+ * @param tbatch Batch title.
+ */
+FORTRAN_SUBR ( LWBTIT, lwbtit,
+	       (const int *mindx, int *batno, fpstr tbatch, int tbatch_len),
+	       (const int *mindx, int *batno, fpstr tbatch),
+	       (const int *mindx, int *batno, fpstr tbatch, int tbatch_len))
+
+{
+  char cbatch[95]=" ";
+  int length;
+  float rbatch[NBATCHWORDS]={0.0};
+  int *intbuf = (int *) rbatch;
+  MTZBAT *batch;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWBTIT");)
+
+ if (MtzCheckSubInput(*mindx,"LWBTIT",2)) return;
+
+ /* No check on mtzdata[*mindx-1]->n_orig_bat  It might be 0 if this is the
+    first batch written. */
+
+ /* batno = 0 is special flag to remove batch information */
+ /* Used for example in SCALA to write merged file from unmerged input */
+
+ if (*batno == 0) {
+   mtzdata[*mindx-1]->n_orig_bat = 0;
+   MtzFreeBatch(mtzdata[*mindx-1]->batch);
+   mtzdata[*mindx-1]->batch = NULL;
+   return;
+ }
+
+ length = (FTN_LEN(tbatch) < 70) ? FTN_LEN(tbatch) : 70 ;
+ strncpy(cbatch,FTN_STR(tbatch),length);
+ cbatch[length] = '\0';
+ intbuf[0] = NBATCHWORDS;
+ intbuf[1] = NBATCHINTEGERS;
+ intbuf[2] = NBATCHREALS;
+
+ /* add as new batch */
+ batch = NULL;
+
+ ccp4_lwbat(mtzdata[*mindx-1], batch, *batno, rbatch, cbatch); 
+
+ /* record number of batch headers for output */
+ ++nbatw[*mindx-1];
+}
+
+/** Write batch header for batch number batno. New batch scales
+ * are set. batno must correspond to pre-existing batch.
+ * @param mindx MTZ file index
+ * @param batno Serial number of batch.
+ * @param batscl Array of batch scales.
+ * @param nbatsc Number of batch scales.
+ */
+FORTRAN_SUBR ( LWBSCL, lwbscl,
+	       (const int *mindx, int *batno, float batscl[], int *nbatsc),
+	       (const int *mindx, int *batno, float batscl[], int *nbatsc),
+	       (const int *mindx, int *batno, float batscl[], int *nbatsc))
+
+{
+  int i,istat=-1, iprint=0;
+  MTZBAT *batch;
+  float rbatch[NBATCHWORDS];
+  int *intbatch = (int *) rbatch;
+  char cbatch[94];
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWBSCL");)
+
+ if (MtzCheckSubInput(*mindx,"LWBSCL",2)) return;
+
+ /* No check on mtzdata[*mindx-1]->n_orig_bat  It might be 0 if this is the
+    first batch written. */
+
+ batch = mtzdata[*mindx-1]->batch;
+ while (batch != NULL) {
+   if (*batno == batch->num) {
+     istat = 0;
+     ccp4_lrbat(batch, rbatch, cbatch, iprint); 
+     break;
+   }
+   batch = batch->next;
+ }
+ if (istat == -1) {
+   printf("Error: file on %d has no batch %d ! \n",*mindx,*batno);
+   return;
+ }
+
+ /* add as new batch */
+ batch = NULL;
+
+ intbatch[16] = *nbatsc;
+ for (i = 0; i < *nbatsc; ++i) 
+   rbatch[72+i] = batscl[i];
+
+ ccp4_lwbat(mtzdata[*mindx-1], batch, *batno, rbatch, cbatch); 
+}
+
+/* Fortran wrapper for ccp4_lwbat */
+FORTRAN_SUBR ( LWBSETID, lwbsetid,
+	       (const int *mindx, const int *batno, const fpstr project_name, 
+                  const fpstr dataset_name, 
+                  int project_name_len, int dataset_name_len),
+	       (const int *mindx, const int *batno, const fpstr project_name, 
+                  const fpstr dataset_name),
+	       (const int *mindx, const int *batno, const fpstr project_name, 
+                  int project_name_len,
+                  const fpstr dataset_name, int dataset_name_len))
+
+{ char *temp_xname, *temp_pname, *temp_dname;
+  int i,istat=-1;
+  MTZBAT *batch;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWBSETID");)
+  if (MtzCheckSubInput(*mindx,"LWBSETID",2)) return;
+
+  /* No check on mtzdata[*mindx-1]->n_orig_bat  It might be 0 if this is the
+    first batch written. */
+
+  temp_pname = ccp4_FtoCString(FTN_STR(project_name), FTN_LEN(project_name));
+  temp_dname = ccp4_FtoCString(FTN_STR(dataset_name), FTN_LEN(dataset_name));
+
+  /* default crystal name to project name */
+  temp_xname = strdup(temp_pname);
+
+  batch = mtzdata[*mindx-1]->batch;
+  /* if new batch headers have been written, skip the old ones */
+  if (MtzNbat(mtzdata[*mindx-1]) > mtzdata[*mindx-1]->n_orig_bat) {
+     for (i=0; i < mtzdata[*mindx-1]->n_orig_bat; ++i)
+       batch = batch->next;
+  }
+
+  while (batch != NULL) {
+    if (*batno == batch->num) {
+     istat = 0;
+     break;
+    }
+    batch = batch->next;
+  }
+  if (istat == -1) {
+    printf("Error in lwbsetid: file on %d has no batch %d ! \n",*mindx,*batno);
+  } else {
+    ccp4_lwbsetid(mtzdata[*mindx-1], batch, temp_xname, temp_dname);
+  }
+
+  free(temp_xname); 
+  free(temp_pname); 
+  free(temp_dname); 
+}
+
+/* Fortran wrapper for ccp4_lwbsetid */
+FORTRAN_SUBR ( LWBSETIDX, lwbsetidx,
+	       (const int *mindx, const int *batno, const fpstr crystal_name, 
+                  const fpstr dataset_name, 
+                  int crystal_name_len, int dataset_name_len),
+	       (const int *mindx, const int *batno, const fpstr crystal_name, 
+                  const fpstr dataset_name),
+	       (const int *mindx, const int *batno, const fpstr crystal_name, 
+                  int crystal_name_len,
+                  const fpstr dataset_name, int dataset_name_len))
+
+{ char *temp_xname, *temp_dname;
+  int i,istat=-1;
+  MTZBAT *batch;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWBSETIDX");)
+  if (MtzCheckSubInput(*mindx,"LWBSETIDX",2)) return;
+
+  /* No check on mtzdata[*mindx-1]->n_orig_bat  It might be 0 if this is the
+    first batch written. */
+
+  temp_xname = ccp4_FtoCString(FTN_STR(crystal_name), FTN_LEN(crystal_name));
+  temp_dname = ccp4_FtoCString(FTN_STR(dataset_name), FTN_LEN(dataset_name));
+
+  batch = mtzdata[*mindx-1]->batch;
+  /* if new batch headers have been written, skip the old ones */
+  if (MtzNbat(mtzdata[*mindx-1]) > mtzdata[*mindx-1]->n_orig_bat) {
+     for (i=0; i < mtzdata[*mindx-1]->n_orig_bat; ++i)
+       batch = batch->next;
+  }
+
+  while (batch != NULL) {
+    if (*batno == batch->num) {
+     istat = 0;
+     break;
+    }
+    batch = batch->next;
+  }
+  if (istat == -1) {
+    printf("Error in lwbsetidx: file on %d has no batch %d ! \n",*mindx,*batno);
+  } else {
+    ccp4_lwbsetid(mtzdata[*mindx-1], batch, temp_xname, temp_dname);
+  }
+
+  free(temp_xname); 
+  free(temp_dname); 
+}
+
+/* Set whole array to MNF  */
+FORTRAN_SUBR ( EQUAL_MAGIC, equal_magic,
+	       (const int *mindx, float adata[], const int *ncol),
+	       (const int *mindx, float adata[], const int *ncol),
+	       (const int *mindx, float adata[], const int *ncol))
+{ int i;
+  union float_uint_uchar uf;
+
+  /* CMTZLIB_DEBUG(puts("CMTZLIB_F: EQUAL_MAGIC");)*/
+
+ if (*mindx <= 0 || *mindx > MFILES) {
+   printf("Error in equal_magic: mindx out of range!\n");
+   return;
+ }
+
+ if ( ! mtzdata[*mindx-1] ) {
+   printf("Error in equal_magic: mindx %d not open yet!\n",*mindx);
+   return;
+ }
+
+ if (strncmp (mtzdata[*mindx-1]->mnf.amnf,"NAN",3) == 0) {
+   uf = ccp4_nan();
+ } else {
+   uf.f = mtzdata[*mindx-1]->mnf.fmnf;
+ }
+ for (i = 0; i < *ncol; ++i) {
+   adata[i] = uf.f;
+ }
+
+}
+
+/** Set or get MNF of file.
+ * @param mindx MTZ file index
+ * @param val_magic Value of MNF
+ * @param setval If true, set the MNF with the value in val_magic.
+ * If false, return value of MNF in val_magic. Returned as true, unless
+ * there is an error.
+ */
+FORTRAN_SUBR ( SET_MAGIC, set_magic,
+	       (const int *mindx, float *val_magic, ftn_logical *setval),
+	       (const int *mindx, float *val_magic, ftn_logical *setval),
+	       (const int *mindx, float *val_magic, ftn_logical *setval))
+{
+  union float_uint_uchar uf;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: SET_MAGIC");)
+
+ if (*mindx <= 0 || *mindx > MFILES) {
+   printf("Error in set_magic: mindx out of range!\n");
+   return;
+ }
+
+ if ( ! mtzdata[*mindx-1] ) {
+   printf("Warning in set_magic: mindx %d not open yet! MNF not set.\n",*mindx);
+   return;
+ }
+
+ if (*setval == FORTRAN_LOGICAL_FALSE) {
+   /* return current MNF */
+   if (strncmp (mtzdata[*mindx-1]->mnf.amnf,"NAN",3) == 0) {
+     uf = ccp4_nan();
+   } else {
+     uf.f = mtzdata[*mindx-1]->mnf.fmnf;
+   }
+   *val_magic = uf.f;
+
+ } else {
+   /* set the current MNF */
+   if (ccp4_utils_isnan((union float_uint_uchar *) val_magic)) {
+     sprintf(mtzdata[*mindx-1]->mnf.amnf,"NAN");
+   } else {
+     mtzdata[*mindx-1]->mnf.fmnf = *val_magic;
+   }
+ }
+
+ *setval = FORTRAN_LOGICAL_TRUE;
+}
+
+/* Change value of MNF in an array  */
+FORTRAN_SUBR ( RESET_MAGIC, reset_magic,
+	       (const int *mindx, const float adata[], float bdata[], 
+                 const int *ncol, const float *val_magica, const float *val_magicb),
+	       (const int *mindx, const float adata[], float bdata[], 
+                 const int *ncol, const float *val_magica, const float *val_magicb),
+	       (const int *mindx, const float adata[], float bdata[], 
+                 const int *ncol, const float *val_magica, const float *val_magicb))
+{ int i;
+  float val_magic;
+  union float_uint_uchar uf;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: RESET_MAGIC");)
+
+  val_magic = *val_magica;
+  /* replace val_magica by file value if appropriate */
+ if (*mindx > 0) {
+  if (rlun[*mindx-1] > 0 || wlun[*mindx-1] > 0) {
+   if (strncmp (mtzdata[*mindx-1]->mnf.amnf,"NAN",3) == 0) {
+     uf = ccp4_nan();
+     val_magic = uf.f;
+   } else {
+     val_magic = mtzdata[*mindx-1]->mnf.fmnf;
+   }
+  }
+ }
+
+ /* if adata[i] is a MNF replace it's value */
+ for (i = 0; i < *ncol; ++i) {
+   bdata[i] = adata[i];
+   if (ccp4_utils_isnan((union float_uint_uchar *) &val_magic)) {
+     if (ccp4_utils_isnan((union float_uint_uchar *) &adata[i])) bdata[i] = *val_magicb;
+   } else {
+     if (adata[i] == val_magic) bdata[i] = *val_magicb;
+   }
+ }
+
+}
+
+/** Write a one array of reflection data to output file. 
+ * This is a wrapper for ccp4_lwrefl.
+ * @param mindx (I) MTZ file index
+ * @param adata (I) Array of reflection data to write.
+ * @param ifail (O) Returns 0 if successful, non-zero otherwise.
+ */
+FORTRAN_SUBR ( LWREFL_NOEXIT, lwrefl_noexit,
+	       (const int *mindx, const float adata[], int *ifail),
+	       (const int *mindx, const float adata[], int *ifail),
+	       (const int *mindx, const float adata[], int *ifail))
+{
+ /*  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWREFL_NOEXIT");) */
+
+ *ifail = 0;
+
+ if (MtzCheckSubInput(*mindx,"LWREFL_NOEXIT",2)) {
+   *ifail = 1;
+   return;
+ }
+
+ ++iwref[*mindx-1];
+ if (!ccp4_lwrefl(mtzdata[*mindx-1],adata,collookup_out[*mindx-1],
+		  MtzNumActiveCol(mtzdata[*mindx-1]),iwref[*mindx-1]) ) {
+   *ifail = 1;
+   return;
+ }
+}
+
+/** Write a one array of reflection data to output file. 
+ * This is a wrapper for ccp4_lwrefl. This routine exits upon
+ * failure.
+ * @param mindx (I) MTZ file index
+ * @param adata (I) Array of reflection data to write.
+ */
+FORTRAN_SUBR ( LWREFL, lwrefl,
+	       (const int *mindx, const float adata[]),
+	       (const int *mindx, const float adata[]),
+	       (const int *mindx, const float adata[]))
+{
+  int ifail;
+
+  FORTRAN_CALL ( LWREFL_NOEXIT, lwrefl_noexit,
+	       (mindx, adata, &ifail),
+	       (mindx, adata, &ifail),
+	       (mindx, adata, &ifail));
+
+ if ( ifail )
+   ccperror(1,"LWREFL: failed to write reflection");
+}
+
+/** Write MTZ file header and close output file. Wrapper for MtzPut.
+ * @param mindx (I) MTZ file index
+ * @param iprint (I) Specify whether to write output file header to log.
+ * @param ifail (O) Returns 0 if successful, non-zero otherwise.
+ */
+FORTRAN_SUBR ( LWCLOS_NOEXIT, lwclos_noexit,
+	       (const int *mindx, int *iprint, int *ifail),
+	       (const int *mindx, int *iprint, int *ifail),
+	       (const int *mindx, int *iprint, int *ifail))
+
+{
+  char *fullfilename;
+
+  CMTZLIB_DEBUG(puts("CMTZLIB_F: LWCLOS_NOEXIT");)
+
+ *ifail = 0;
+
+ if (MtzCheckSubInput(*mindx,"LWCLOS_NOEXIT",2)) {
+   *ifail = 1;
+   return;
+ }
+
+ /* fix number of reflections at the number "written out" */
+ mtzdata[*mindx-1]->nref = iwref[*mindx-1];
+ if ( !MtzPut(mtzdata[*mindx-1],fileout[*mindx-1]) ) {
+   *ifail = 1;
+   return;
+ }
+
+ if (getenv(fileout[*mindx-1]) != NULL) {
+   fullfilename = strdup(getenv(fileout[*mindx-1]));
+ } else {
+   fullfilename = strdup(fileout[*mindx-1]);
+ }
+ printf("\n WRITTEN OUTPUT MTZ FILE \n");
+ printf(" Logical Name: %s   Filename: %s \n\n",fileout[*mindx-1],fullfilename);
+ if (*iprint > 0) ccp4_lhprt(mtzdata[*mindx-1], *iprint);
+
+ wlun[*mindx-1] = 0;
+ if (rlun[*mindx-1] == 0) {
+   MtzFree(mtzdata[*mindx-1]);
+   mtzdata[*mindx-1] = NULL;
+ }
+
+ free(fullfilename); 
+}
+
+/** Write MTZ file header and close output file. Wrapper for MtzPut.
+ * @param mindx (I) MTZ file index
+ * @param iprint (I) Specify whether to write output file header to log.
+ */
+FORTRAN_SUBR ( LWCLOS, lwclos,
+	       (const int *mindx, int *iprint),
+	       (const int *mindx, int *iprint),
+	       (const int *mindx, int *iprint))
+
+{
+  int ifail;
+
+  FORTRAN_CALL ( LWCLOS_NOEXIT, lwclos_noexit,
+	       (mindx, iprint, &ifail),
+	       (mindx, iprint, &ifail),
+	       (mindx, iprint, &ifail));
+
+ if ( ifail )
+   ccperror(1,"LWCLOS: failed to write output file");
+}
+
+/* old internal routines - obsolete! */
+
+FORTRAN_SUBR ( RBATHD, rbathd,
+	       (),(),())
+{
+   printf("RBATHD: Obsolete internal routine: you should not be calling this!\n");
+   return;
+}
+
+FORTRAN_SUBR ( WBATHD, wbathd,
+	       (),(),())
+{
+   printf("WBATHD: Obsolete internal routine: you should not be calling this!\n");
+   return;
+}
+
+FORTRAN_SUBR ( LRHDRL, lrhdrl,
+	       (),(),())
+{
+   printf("LRHDRL: Obsolete internal routine: you should not be calling this!\n");
+   return;
+}
+
+FORTRAN_SUBR ( LABPRT, labprt,
+	       (),(),())
+{
+   printf("LABPRT: Obsolete internal routine: you should not be calling this!\n");
+   return;
+}
+
+FORTRAN_SUBR ( LBPRTH, lbprth,
+	       (),(),())
+{
+   printf("LBPRTH: Obsolete internal routine: you should not be calling this!\n");
+   return;
+}
+
+FORTRAN_SUBR ( SORTUP, sortup,
+	       (),(),())
+{
+   printf("SORTUP: Obsolete internal routine: you should not be calling this!\n");
+   return;
+}
+
+FORTRAN_SUBR ( ADDLIN, addlin,
+	       (),(),())
+{
+   printf("ADDLIN: Obsolete internal routine: you should not be calling this!\n");
+   return;
+}
+
+FORTRAN_FUN (int, NEXTLN, nextln,
+	       (),(),())
+{
+   printf("NEXTLN: Obsolete internal function: you should not be using this!\n");
+   return -1;
+}
+
+FORTRAN_SUBR ( IS_MAGIC, is_magic,
+	       (const float *val_magic, const float *valtst, ftn_logical *lvalms),
+	       (const float *val_magic, const float *valtst, ftn_logical *lvalms),
+	       (const float *val_magic, const float *valtst, ftn_logical *lvalms))
+{
+   printf("IS_MAGIC: Obsolete internal routine: you should not be calling this!\n");
+   return;
+}
diff -ruN ccp4-5.0.2-orig/src/abs.f ccp4-5.0.2/src/abs.f
--- ccp4-5.0.2-orig/src/abs.f	2004-01-26 02:08:16.000000000 -0800
+++ ccp4-5.0.2/src/abs.f	2004-08-19 17:51:14.000000000 -0700
@@ -20,10 +20,12 @@
 	PROGRAM ABSC
 	PARAMETER(MAXREF=90000)
 	PARAMETER(MAXDATA=4194304)
+        PARAMETER(MCOLS=500)
 	COMPLEX FF(MAXREF),DATA(MAXDATA)
 	INTEGER*2 IH(MAXREF),IK(MAXREF),IL(MAXREF)
 	LOGICAL EOF, LVALMS
-	CHARACTER*4 KEY, CCVAL(20),KEYWORD(4)
+        LOGICAL LOGMSS(MCOLS)
+	CHARACTER*4 KEY, CCVAL(20),KEYWORD(5)
 	CHARACTER*400 LINE
 	CHARACTER*80 TITLE
 	INTEGER NTOK, IBEG(20), IEND(20), ITYP(20), IDEC(20)
@@ -34,14 +36,14 @@
 	CHARACTER*1 CTYP1(7)
         REAL RSYM(4,4,64),HKL(3)
 	DATA LAB1/'H','K','L','F','SIGF','DANO','SIGDANO'/
-	DATA KEYWORD/'TITL','ATOM','LABI','RESO'/
+	DATA KEYWORD/'TITL','ATOM','LABI','RESO','END'/
 	DATA CTYP1/'H','H','H','F','Q','D','Q'/
 	DATA IPOINT1/3*-1,4*0/
 	DATA OCU/480*1.0/
-        CALL CCPRCS (6, 'ABS', '$Date: 2004/01/26 10:08:16 $')
+        CALL CCPRCS (6, 'ABS', '$Date: 2004/08/18 10:52:59 $')
 	CALL CCPFYP
 C   Set default - currently NAN
-             CALL QNAN (VAL_MAGIC)
+C            CALL QNAN (VAL_MAGIC)
 	WRITE(6,*)  
         WRITE(6,*)' Program:  ABS   ' 
         WRITE(6,*)' Last update: 10/2/2001'
@@ -55,9 +57,9 @@
      +                         IDEC,NTOK,EOF,.FALSE.)
 	IF (EOF) GOTO 10 
 	CALL CCPUPC(KEY)
-	DO I = 1 , 4
+	DO I = 1 , 5
 	   IF (KEY.EQ.KEYWORD(I)) THEN
-	      GOTO (3,4,5,6) I
+	      GOTO (3,4,5,6,10) I
 	   END IF
 	END DO
 	CALL CCPERR(1,'----------- illegal keyword ------------')
@@ -103,11 +105,14 @@
    	cen = 0.
  20	CALL LRREFF(1,RESOL,ADATA1,EOF)
         IF (EOF) GOTO 50
-        CALL IS_MAGIC (VAL_MAGIC,adata1(4),LVALMS)
-	IF (lvalms) goto 20
+        CALL LRREFM(1,LOGMSS)
+C       CALL IS_MAGIC (VAL_MAGIC,adata1(4),LVALMS)
+C       IF (lvalms) goto 20
+	IF (LOGMSS(4)) goto 20
 	if (adata1(4).lt.0.) GOTO 20
-        CALL IS_MAGIC (VAL_MAGIC,adata1(6),LVALMS)
-	IF (lvalms) adata1(6) = 0.0 
+C       CALL IS_MAGIC (VAL_MAGIC,adata1(6),LVALMS)
+C       IF (lvalms) adata1(6) = 0.0 
+        IF (LOGMSS(6)) adata1(6) = 0.0
 	if(1./sqrt(resol).lt.resolim) goto 20
 	NREF = NREF + 1
         SUM_R = 0.0
diff -ruN ccp4-5.0.2-orig/src/dmmulti_/dmmulti.f ccp4-5.0.2/src/dmmulti_/dmmulti.f
--- ccp4-5.0.2-orig/src/dmmulti_/dmmulti.f	2004-01-22 08:58:58.000000000 -0800
+++ ccp4-5.0.2/src/dmmulti_/dmmulti.f	2004-08-12 21:11:24.000000000 -0700
@@ -973,14 +973,14 @@
       character colnam(nhklc)*6
 c
       integer in(3),nfile,nhires,nsysab,notasu,nunobs,ncen,ncenerr
-      integer ih,ik,il,inasu,i
+      integer ih,ik,il,inasuold,i
       integer ifo,isfo,iphio,ifomo,ihla,ihlb,ihlc,ihld
       integer ifdm,iphidm,ifomdm,ifree
       real s,eps,phicen,fo,sfo,phio,fomo,fdm,phidm,fomdm,fpc,phipc
       real rrand,flag,hla,hlb,hlc,hld,x,atanh,siminv
       logical assigned(nhklc)
 c
-      external inasu,rrand,atanh,siminv
+      external inasuold,rrand,atanh,siminv
 c
       data colnam/'H','K','L','S','EPS','FO','PHIO','FOMO',
      +            'HL-A','HL-B','HL-C','HL-D',2*'x',
@@ -1054,7 +1054,7 @@
           nsysab=nsysab+1
           goto 100
         endif
-        if (inasu(in,nlaue).ne.1) then
+        if (inasuold(in,nlaue).ne.1) then
           notasu=notasu+1
           goto 100
         endif
diff -ruN ccp4-5.0.2-orig/src/dmmulti_/dmmulti_dmlib.f ccp4-5.0.2/src/dmmulti_/dmmulti_dmlib.f
--- ccp4-5.0.2-orig/src/dmmulti_/dmmulti_dmlib.f	2004-03-31 05:39:53.000000000 -0800
+++ ccp4-5.0.2/src/dmmulti_/dmmulti_dmlib.f	2004-08-12 21:10:42.000000000 -0700
@@ -254,10 +254,10 @@
 c
       real reso
 c
-      integer in(3),ih,ik,il,n,inasu
+      integer in(3),ih,ik,il,n,inasuold
       real s12,s13,s23,s2,s3,s,slim,eps,phicen
       logical centre,sysabs
-      external inasu
+      external inasuold
       equivalence (in(1),ih)
       equivalence (in(2),ik)
       equivalence (in(3),il)
@@ -275,7 +275,7 @@
       do 100 ih=-hmax,hmax
       s  = ih*(ih*rcm11 + s12) + s2
       if (s.gt.0.0.and.s.le.slim) then
-       if (inasu(in,nlaue).eq.1) then
+       if (inasuold(in,nlaue).eq.1) then
         call epscen(ih,ik,il,centre,sysabs,eps,phicen,nsym,rsym)
         if (.not.sysabs) n=n+1
        endif
@@ -1131,4 +1131,283 @@
 c
 c ----------------------------------------------------------------------
 c
-
+C
+      INTEGER FUNCTION INASUold(IH, NLAUE)
+C     =================================
+C
+C   This used to be FUNCTION XRY173(NLAUE,IH,ISGN)
+C***********************************************************************
+C***********************************************************************
+C*****                         *****************************************
+C***** ROUTINE ( XRY173        *****************************************
+C*****                         *****************************************
+C*****     From XRAY77 or something like it ****************************
+C***********************************************************************
+C***********************************************************************
+C
+C  Arguments:
+C   NLAUE - code number for this pointgroup
+C   IH(3) - indices
+C
+C Returns:
+C   INASU = +1  if  h k l chosen
+C   INASU = -1  if -h-k-l chosen
+C   INASU =  0   if reflection is out-of-bounds
+C
+C  Reciprocal space zones: please check spacegroup numbers.
+C
+Code:3 pg1     1bar      hkl:l>=0  hk0:h>=0  0k0:k>=0
+C           Space group numbers :   1,2
+Code:4 pg2    2/m        hkl:k>=0, l>=0  hk0:h>=0       3/b,4/b....
+C           Space group numbers :   3 -15 B axis unique.
+Code:5 pg2    2/m        hkl:k>=0, l>=0  h0l:>=0        1003,1004
+C           Space group numbers :   3 -15 C axis unique.
+Code:6 pg222  mmm        hkl:h>=0, k>=0, l>=0            16 ...
+C           Space group numbers :   16-74
+Code:7 pg4    4/m        hkl:h>=0, l>=0 with k>=0 if  h=0  and
+C                                           k> 0 if  h>0.
+C           Space group numbers :   75-88
+Code:8 pg422 4/mmm       hkl:h>=0, k>=0, l>=0 and h>=k
+C           Space group numbers :   89-142
+Code:9  pg3     3bar      hkl:h>=0, k>0  00l:l>0
+C           Space group numbers :   143-148
+Code:  10 pg312  3/m        hkl:h>=0, k>=0 with k<=h for all l.
+C                           if k = 0  l>=0
+C           Space group numbers :   149-151-153
+Code:  11 pg321  3/m        hkl:h>=0, k>=0 with k<=h for all l.
+C                           if h = k  l>=0
+C           Space group numbers :   150-152-154
+Code:12 pg6    6/m        hkl:h>=0, k>=0, l>=0 with k>=0 if  h=0
+C                                            and  k> 0 if  h>0.
+C           Space group numbers :   168-176
+Code:13 pg622 6/mmm       hkl:h>=0, k>=0, l>=0 with h>=k
+C           Space group numbers :   177-194
+Code:14 pg23   m3         hkl:h>=0, k>=0, l>=0 with l>=h,
+C                                                 k>=h if l=h
+C                                                 k> h if l>h.
+C           Space group numbers :   195-206
+Code:15 pg432  m3m        hkl:h>=0, k>=0, l>=0 with k>=l, and l>=h.
+C           Space group numbers :   207-232
+C
+C -- TEST FOR HKL IN ASYMMETRIC UNIT
+C     INCORPORATED INTO DATCO5 JUNE 70
+C
+C Arguments
+      INTEGER IH(3), NLAUE
+C Locals
+      INTEGER J,K,L,ISGN
+C
+C----MOVE INDICES INTO J,K, AND L
+      J = IH(1)
+      K = IH(2)
+      L = IH(3)
+      ISGN=1
+C----GO TO TEST IF INDICES ARE IN DESIRED UNIT
+1     GO TO (100,150,200,250,300,350,400,450,550,570,600,650,700,750,
+     1  800),NLAUE
+ 100  CONTINUE
+C----1 BAR (ALTERNATE 1)
+C     HKL --    H.GE.0
+C     0KL --    K.GE.0
+C     00L --    L.GE.0
+      IF (J) 7,105,5
+ 105  IF (K) 7,110,5
+ 110  IF (L) 7,5,5
+C
+ 150  CONTINUE
+C----1 BAR (ALTERNATE I)
+C     HKL --    K.GE.0
+C     H0L --    L.GE.0
+C     H00 --    H.GE.0
+      IF (K) 7,155,5
+ 155  IF (L) 7,160,5
+ 160  IF (J) 7,5,5
+C
+C  Corresponds to Data reduction unique set for  pg1
+C   3 pg1     1bar      hkl:l>=0  hk0:h>=0  0k0:k>=0   1,2
+ 200  CONTINUE
+C----1 BAR (ALTERNATE 3)
+C     HKL --    L.GE.0
+C     HK0 --    H.GE.0
+C     0K0 --    K.GE.0
+      IF (L) 7,205,5
+ 205  IF (J) 7,210,5
+ 210  IF (K) 7,5,5
+C
+C  Corresponds to Data reduction unique set for  pg2
+C   4 pg2    2/m        hkl:k>=0, l>=0  hk0:h>=0       3/b,4/b....
+ 250  CONTINUE
+C----2/M (ALTERNATE 1)
+C     HKL --    K.GE.0 AND L.GE.0
+C     HK0 --    H.GE.0
+      IF (K) 7,255,255
+ 255  IF (L) 7,260,5
+ 260  IF (J) 7,5,5
+C
+C  Corresponds to Data reduction unique set for  pg2
+C   5 pg2    2/m        hkl:k>=0, l>=0  h0l:h>=0       1003,1004
+ 300  CONTINUE
+C----2/M (ALTERNATE 2)
+C     HKL --    L.GE.0 AND H.GE.0
+C     H0L --    H.GE.0
+      IF (L) 7,305,305
+ 305  IF (K) 7,310,5
+ 310  IF (J) 7,5,5
+C
+C  Corresponds to Data reduction unique set for  pg222
+C   6 pg222  mmm        hkl:h>=0, k>=0, l>=0            16 ...
+ 350  CONTINUE
+C----MMM
+C     HKL --    H.GE.0, K.GE.0, AND L.GE.0
+      IF (J) 7,355,355
+ 355  IF (K) 7,361,361
+C****NO 3-SICKLIES PLEASE
+ 361  IF (L) 7,5,5
+C
+C  Corresponds to Data reduction unique set for  pg4
+C   7 pg4    4/m        hkl:h>=0, l>=0 with k>=0 if  h=0  and
+C                                           k> 0 if  h>0.
+ 400  CONTINUE
+C----4/M
+C     HKL --    H.GE.0, L.GE.0, WITH K.GE.0 IF H.EQ.0 OR
+C               K.GE.1 IF H.GT.0
+      IF (L) 7,405,405
+ 405  IF (J) 7,410,415
+ 410  IF (K) 7,5,5
+ 415  IF (K) 7,7,5
+C
+C  Corresponds to Data reduction unique set for  pg422
+C   8 pg422 4/mmm       hkl:h>=0, k>=0, l>=0 and h>=k   89..
+ 450  CONTINUE
+C----4/MMM
+C     HKL --    H.GE.0, K.GE.0, AND L.GE.0 WITH H.GE.K
+      IF (J) 7,455,455
+ 455  IF (K) 7,460,460
+ 460  IF (L) 7,465,465
+ 465  IF (J-K) 7,5,5
+C
+C 500  CONTINUE
+C----3 BAR
+C      HKL ---   H.LE.0, L.GE.0, WITH K.GE.0 IF H.LE.0 OR
+C               K.GE.1 IF H.LT.0
+C      HK0  --  K.GT.-H
+CC
+C  1978 CHANGED TO FIT N.ISAACS
+C  INCLUDE 0 0 L,  HK0 K.LT.0 H.GE.-K     HKL H.GE.0 K.LT.0
+CC
+CCC      IF(J)7,505,505
+CCC505   IF(K)510,510,7
+CCC510   IF(L)7,515,520
+CCC515   IF(K)516,7,7
+CCC516   IF(J+K)7,5,5
+CCC520   IF(J-K)521,5,521
+CCC521   IF(K)5,7,7
+C
+C  Corresponds to Data reduction unique set for  pg3
+C  9 pg3     3bar      hkl:h>=0, k>0  00l:l>0         143..
+550   CONTINUE
+C   ALTERNATIVE FOR R3
+C  H.GE.0 K.GT.0    ALL L
+C  H=0 K=0 L.GT.0
+      IF(J)7,555,556
+555   IF(K)7,557,5
+556   IF(K)7,7,5
+557   IF(L)7,7,5
+C
+C  Corresponds to Data reduction unique set for  pg312 
+C  10 pg312        hkl:h>=0, k>=0 with k<=h for all l.
+C                           if k = 0  l>=0
+ 570  CONTINUE
+C----3 BAR M
+C  H.GE.0 K.GE.0 K.LE.H   ALL L
+C  H=K  L.GE.0
+      IF(J)7,575,575
+575   IF(K)7,577,576
+576   IF(J-K)7,5,5
+577   IF(L)7,5,5
+C
+C  Corresponds to Data reduction unique set for  pg321
+C  11 pg321        hkl:h>=0, k>=0 with k<=h for all l.
+C                           if h = k  l>=0
+ 600  CONTINUE
+C----3 BAR M
+C  H.GE.0 K.GE.0 K.LE.H   ALL L
+C  H=K  L.GE.0
+      IF(J)7,605,605
+605   IF(K)7,606,606
+606   IF(J-K)7,607,5
+607   IF(L)7,5,5
+C
+C  Corresponds to Data reduction unique set for  pg6
+C  12 pg6    6/m        hkl:h>=0, k>=0, l>=0 with k>=0 if  h=0
+C                                            and  k> 0 if  h>0.
+ 650  CONTINUE
+C----6/M
+C     HKL --    H.GE.0, L.GE.0, WITH K.GE.0 IF H.EQ.0 OR
+C               K.GE.1 IF H.GT.0
+      IF (L) 7,655,655
+ 655  IF (J) 7,660,665
+ 660  IF (K) 7,5,5
+ 665  IF (K) 7,7,5
+C
+C  Corresponds to Data reduction unique set for  pg622
+C  13 pg622 6/mmm       hkl:h>=0, k>=0, l>=0 with h>=k 177..
+  700 CONTINUE
+C----6/MMM
+C     HKL --    H.GE.0, K.GE.0, AND L.GE.0 WITH H.GE.K
+      IF (J) 7,705,705
+ 705  IF (K) 7,710,710
+710   IF(J-K)7,715,715
+715   IF(L)7,5,5
+C
+C  Corresponds to Data reduction unique set for  pg23
+C  14 pg23   m3         hkl:h>=0, k>=0, l>=0 with l>=h,
+C                                                 k>=h if l=h
+C                                                 k> h if l>h.
+ 750  CONTINUE
+C----M3
+C     HKL --    H.GE.0, K.GE.0, AND L.GE.0 WITH L.GE.H AND WITH
+C               K.GE.H IF L.EQ.H OR K.GT.H IF L.GT.H
+      IF (J) 7,755,755
+ 755  IF (K) 7,760,760
+ 760  IF (L) 7,765,765
+ 765  IF (L-J) 7,770,775
+ 770  IF (K-J) 7,5,5
+ 775  IF (K-J) 7,7,5
+C
+C  Corresponds to Data reduction unique set for  pg432
+C  15 pg432  m3m        hkl:h>=0, k>=0, l>=0 with k>=l, and l>=h.
+ 800  CONTINUE
+C----M3M
+C     HKL --    H.GE.0, K.GE.0, AND L.GE.0 WITH
+C              K.GE.L AND L.GE.H
+      IF (J) 7,805,805
+ 805  IF (K) 7,810,810
+ 810  IF (L) 7,815,815
+ 815  IF (K-L) 7,820,820
+ 820  IF (L-J) 7,5,5
+C
+C----REFLECTION IS IN BOUNDS
+ 5    INASUold = ISGN
+      RETURN
+C     ======
+C
+C----REFLECTION IS OUT OF BOUNDS
+ 7    IF (ISGN .EQ. +1) THEN
+C     TRY -H -K -L
+        ISGN=-1
+        J=-J
+        K=-K
+        L=-L
+        GO TO 1
+      ENDIF
+C Index failed, exit
+      INASUold = 0
+      RETURN
+C     ======
+C
+      END
+C
+c
+c ----------------------------------------------------------------------
+c
diff -ruN ccp4-5.0.2-orig/src/lsqkab.f ccp4-5.0.2/src/lsqkab.f
--- ccp4-5.0.2-orig/src/lsqkab.f	2004-01-23 09:15:33.000000000 -0800
+++ ccp4-5.0.2/src/lsqkab.f	2004-08-11 23:00:29.000000000 -0700
@@ -90,7 +90,7 @@
       CALL XYZINIT
       NATOMS = NATOM
       NOUT = 6
-      CALL CCPRCS(NOUT,'LSQKAB','$Date: 2004/01/23 17:15:33 $')
+      CALL CCPRCS(NOUT,'LSQKAB','$Date: 2004/08/09 15:28:53 $')
       CALL RCARDSLSQ
 C
 C     Initilaise TER info
@@ -548,6 +548,20 @@
         IF (THETA2.EQ.0) CHI = THETA3
         IF (THETA2.EQ.180.0) CHI = 180.0
 C
+C---- Special case: pure rotation around Z-axis
+C     In this case Beta (=Theta2) is either 0 or 180,
+C     Alpha (=Theta1) is zero, and Gamma is any value
+C     between 0 and 180deg.
+C     i.e. the rotation axis is parallel to the Z-axis
+        DC(1) = 0.0
+        DC(2) = 0.0
+        IF (THETA2.EQ.0.0) THEN
+          DC(3) = 1.0
+        ELSE
+          DC(3) = -1.0
+        ENDIF
+        GOTO 20
+C
 C---- IF CHI =180  COSCHI=-1,SINCHI=0
 C
    10   DC(1) = SQRT(ABS(TRMAT(1,1)*0.5+0.5))
@@ -568,7 +582,7 @@
         SOMEGA = SQRT(ABS(1.0-DC(3)*DC(3)))
         OMEGA = ATAN2(SOMEGA,DC(3))*CONV
         CHK = DC(2)*DC(2) + DC(1)*DC(1)
-        PHI = 999
+        PHI = 0.0
         IF (CHK.GT.0.0) PHI = CONV*ATAN2(DC(2),DC(1))
       END IF
       WRITE (6,FMT=6006) THETA1,THETA2,THETA3,OMEGA,PHI,CHI,
diff -ruN ccp4-5.0.2-orig/src/mapmask_/mapmask.f ccp4-5.0.2/src/mapmask_/mapmask.f
--- ccp4-5.0.2-orig/src/mapmask_/mapmask.f	2004-06-16 02:06:23.000000000 -0700
+++ ccp4-5.0.2/src/mapmask_/mapmask.f	2004-09-29 08:42:14.000000000 -0700
@@ -40,7 +40,7 @@
       data types /'R','R'/
 c
       call ccpfyp
-      call ccprcs (6, 'mapmask', '$Date: 2004/06/16 09:06:23 $')
+      call ccprcs (6, 'mapmask', '$Date: 2004/09/20 11:57:16 $')
       call XYZINIT
 c
       idum=0
@@ -348,7 +348,8 @@
        ouvwlim13=int(uvwlim(1,3))
        ouvwlim23=int(uvwlim(2,3))
       endif
-      if (lxyzmtc) call ccpmaplim('MAPLIM')
+cmdw argument to ccpmaplim needs to be 8 charcters long, hence spaces
+      if (lxyzmtc) call ccpmaplim('MAPLIM  ')
       write (lpt,510)
      +  iuvwlim11,iuvwlim21,iuvwlim12,iuvwlim22,iuvwlim13,iuvwlim23,
      +  ouvwlim11,ouvwlim21,ouvwlim12,ouvwlim22,ouvwlim13,ouvwlim23
diff -ruN ccp4-5.0.2-orig/src/maprot_/maprot.f ccp4-5.0.2/src/maprot_/maprot.f
--- ccp4-5.0.2-orig/src/maprot_/maprot.f	2004-01-22 07:15:14.000000000 -0800
+++ ccp4-5.0.2/src/maprot_/maprot.f	2004-09-29 08:41:39.000000000 -0700
@@ -39,7 +39,7 @@
       data types /'R','R','R','R','R','R','R','R'/
 c
       call ccpfyp
-      call ccprcs (6, 'maprot', '$Date: 2004/01/22 15:15:14 $')
+      call ccprcs (6, 'maprot', '$Date: 2004/09/20 11:13:19 $')
 c
       idum=0
       lpt=lunsto(idum)
@@ -72,7 +72,7 @@
       real map(nmap),wrk(nwrk),wrk1(nwrk1),wrk2(nwrk2)
 c
       integer i
-      integer lu1,lv1,lw1,lu2,lv2,lw2
+      integer lu1,lv1,lw1,lu2,lv2,lw2,cutspgrp
       character*240 title,title1
 c
       do 100 i=1,nmap
@@ -130,7 +130,8 @@
      +  wu,wv,ww,wu1,wv1,ww1,wu2,wv2,ww2,wu1,wv1,ww1,wu2,wv2,ww2)
       if (lmapout) call ccpmapout('MAPOUT',title,map,mspgrp,mcell,
      +  mu,mv,mw,mu1,mv1,mw1,mu2,mv2,mw2,mu1,mv1,mw1,mu2,mv2,mw2)
-      if (lcutout) call ccpmapout('CUTOUT',title,map,1,mcell,
+      cutspgrp=1
+      if (lcutout) call ccpmapout('CUTOUT',title,map,cutspgrp,mcell,
      +  mu,mv,mw,mu1,mv1,mw1,mu2,mv2,mw2,lu1,lv1,lw1,lu2,lv2,lw2)
 c
       return
diff -ruN ccp4-5.0.2-orig/src/mtzutils.f ccp4-5.0.2/src/mtzutils.f
--- ccp4-5.0.2-orig/src/mtzutils.f	2004-04-21 09:18:36.000000000 -0700
+++ ccp4-5.0.2/src/mtzutils.f	2005-05-11 21:49:58.000000000 -0700
@@ -418,7 +418,7 @@
       CALL UTILINI
       CALL CCPOPN(LUNIN,'DATA',5,1,LDUM,IFAIL)
       CALL CCPOPN(LUNOUT,'PRINTER',6,1,LDUM,IFAIL)
-      CALL CCPRCS(LUNOUT,'MTZUTILS','$Date: 2004/04/21 16:18:36 $')
+      CALL CCPRCS(LUNOUT,'MTZUTILS','$Date: 2005/05/11 12:49:28 $')
       CALL KEYIN
       CALL OPENIP
       CALL GENEDT
@@ -1218,12 +1218,11 @@
 C     ***********************************
 C     
         DO_NEW_CELL = .TRUE.
-C     
-        DO 66 I = 1,6
-          WRITE(LUNOUT,FMT=64)CELL_NEW(I)
- 64       FORMAT(' New value for Cell is ',F10.4)
- 66     CONTINUE
-C     
+
+        WRITE(6,6042)
+ 6042   FORMAT(/,' WARNING: updating all dataset cell dimensions',
+     +       ' for all input files with values from',/,
+     +       ' CELL keyword. If you want finer control, use CAD.',/)
 C     
         GO TO 10
 C     
@@ -1874,6 +1873,8 @@
       PARAMETER (MAXHIS=30)
       INTEGER MCOLS
       PARAMETER (MCOLS=500)
+      INTEGER MSETS
+      PARAMETER (MSETS=MCOLS)
       INTEGER MFILES_IN
       PARAMETER (MFILES_IN=2)
       INTEGER MAXBAT
@@ -1895,7 +1896,7 @@
      +          PGNAME_OUT*10,  TITOUT*70
 C     ..
 C     .. Arrays in Common ..
-      REAL    CELL_NEW,   CELMTZ,     CELOUT,     RNGMTZ,  RSYM,
+      REAL    CELL_NEW,   CELMTZ,     RNGMTZ,  RSYM,
      +        RSYMT_NEW,  RSYM_NEW,   RSYM_OUT
       INTEGER ISYMM_NEW,  ISYMST_NEW, ISYM_NEW,   LENTIT,  LMSYM_NEW,
      +        MSORTX,     MSORTX_NEW, MSORTX_OUT, MTZBLS,  NBATX,
@@ -1987,7 +1988,6 @@
      +         RNGMTZ(2,MCOLS,MFILES_IN),
      +         RSYM(4,4,MAXSYM,MFILES_IN)
       COMMON /REL_MTZOUT/
-     +         CELOUT(6),
      +         RSYM_OUT(4,4,MAXSYM)
       COMMON /REL_UTILS/   CELL_NEW(6)
       COMMON /UNEW_SYMM/
@@ -2003,6 +2003,16 @@
       COMMON /U_INOUT/
      +       LUNIN,  LUNOUT,  MTZIN1,  MTZIN2,  MTZOUT,
      +       MTZPRT, MTZERR
+
+      INTEGER NDATASETS(MFILES_IN),ISETS(MSETS,MFILES_IN),
+     +        CSETID_NFILE(MCOLS,MFILES_IN)
+      REAL    DCELL(6,MSETS,MFILES_IN),DWAVEL(MSETS,MFILES_IN)
+      CHARACTER*64 PNAME(MSETS,MFILES_IN),XNAME(MSETS,MFILES_IN),
+     +        DNAME(MSETS,MFILES_IN),
+     +        XNAME_OUT(MCOLS),DNAME_OUT(MCOLS)
+      COMMON /SETS_IO/ NDATASETS,ISETS,CSETID_NFILE,DCELL,DWAVEL,
+     +        PNAME,XNAME,DNAME,XNAME_OUT,DNAME_OUT
+
 C     ..
 C     .. Save statement ..
       SAVE
@@ -2044,64 +2054,46 @@
       IF (LWORK2.EQ.0) LWORK2 = 1
       TITOUT = TITWRK(1) (1:LWORK1)//' '//TITWRK(2) (1:LWORK2)
 C
-C---- Final CELL output
+C---- Update DCELL output if CELL keyword given
 C
       IF (DO_NEW_CELL) THEN
-        DO 20 JDO20 = 1,6
-          CELOUT(JDO20) = CELL_NEW(JDO20)
-   20   CONTINUE
-        GO TO 70
-      END IF
-C
-C---- Use CELL values from File_1
-C
-      IF (CELMTZ(1,1).LE.0.0) THEN
-C
-C---- Use CELL values from File_2 if available
-C
+
+        IF (NDATASETS(1).GE.1) THEN
+
+          WRITE(6,6000)
+6000      FORMAT(/,' Warning: updating all dataset cell dimensions',
+     +       ' for file 1 with values from',/,
+     +       ' CELL keyword If you want finer control, use CAD.',/)
+
+          DO 30 JDO30 = 1,NDATASETS(1)
+           DO 20 JDO20 = 1,6
+            DCELL(JDO20,JDO30,1) = CELL_NEW(JDO20)
+   20      CONTINUE
+   30     CONTINUE
+
+        ENDIF
+
         IF (DO_TWO_FILES) THEN
-          IF (CELMTZ(1,2).LE.0.0) THEN
-            WRITE (LUNOUT,FMT=6000)
- 6000 FORMAT (' Warning NO-cell values in either input files')
-C
-C---- Just set cellout to 0.0
-C
-            DO 30 JDO30 = 1,6
-              CELOUT(JDO30) = 0.0
-   30       CONTINUE
-            GO TO 70
-          END IF
-C
-C---- now use cell values from file 2
-C
-          DO 40 JDO40 = 1,6
-            CELOUT(JDO40) = CELMTZ(JDO40,2)
-   40     CONTINUE
-C
-          GO TO 70
-        END IF
-C
-C--- OK not two files
-C
-        WRITE (LUNOUT,FMT=6002)
- 6002 FORMAT (' Warning NO-cell values in Input file')
-C
-C---- Just set cellout to 0.0
-C
-        DO 50 JDO50 = 1,6
-          CELOUT(JDO50) = 0.0
-   50   CONTINUE
-        GO TO 70
+
+          IF (NDATASETS(2).GE.1) THEN
+
+            WRITE(6,6100)
+6100        FORMAT(/,' Warning: updating all dataset cell dimensions',
+     +         ' for file 2 with values from',/,
+     +         ' CELL keyword If you want finer control, use CAD.',/)
+
+            DO 50 JDO50 = 1,NDATASETS(2)
+             DO 40 JDO40 = 1,6
+              DCELL(JDO40,JDO50,2) = CELL_NEW(JDO40)
+   40        CONTINUE
+   50       CONTINUE
+
+          ENDIF
+
+        ENDIF
+
       END IF
 C
-C---- now use cell values from file 1
-C
-      DO 60 JDO60 = 1,6
-        CELOUT(JDO60) = CELMTZ(JDO60,1)
-   60 CONTINUE
-C
-   70 CONTINUE
-C
 C---- Set up symmetry (RDSYMM must be called first )
 C
       IF (DO_NEW_SYMM) THEN
@@ -3473,7 +3465,7 @@
      +        DO_UNIQUE
 C     ..
 C     .. arrays in common ..
-      REAL    CELOUT,    RSYM_OUT
+      REAL    RSYM_OUT
       INTEGER MSORTX_OUT
       CHARACTER CTYPS_OUT*1,  CLABS_OUT*30,  HISTOUT*80
       LOGICAL DO_EDT_COL_NAMES,     DO_EDT_TITLE,
@@ -3485,7 +3477,7 @@
       INTEGER MTITOT
 C     ..
 C     .. external subroutines ..
-      EXTERNAL LWCELL,LWHIST,LWHSTL,LWOPEN,LWSORT,LWSYMM,LWTITL,WRBATS
+      EXTERNAL LWHIST,LWHSTL,LWOPEN,LWSORT,LWSYMM,LWTITL,WRBATS
 C     ..
 C     .. common blocks ..
       COMMON /CHR_MTZOUT/TITOUT,
@@ -3501,7 +3493,6 @@
      +          NSYM_OUT,             NSYMP_OUT,
      +          NSPGRP_OUT,           MSORTX_OUT(5)
       COMMON /REL_MTZOUT/
-     +         CELOUT(6),
      +         RSYM_OUT(4,4,MAXSYM)
       COMMON /U_INOUT/
      +       LUNIN,  LUNOUT,  MTZIN1,  MTZIN2,  MTZOUT,
@@ -3555,8 +3546,6 @@
 C
       END IF
 C
-C          **************************
-      CALL LWCELL(MTZOUT,CELOUT)
       CALL LWSORT(MTZOUT,MSORTX_OUT)
 
       MLOOP = 1
diff -ruN ccp4-5.0.2-orig/src/topp_/autosnd.f ccp4-5.0.2/src/topp_/autosnd.f
--- ccp4-5.0.2-orig/src/topp_/autosnd.f	2004-03-31 05:40:28.000000000 -0800
+++ ccp4-5.0.2/src/topp_/autosnd.f	2004-11-17 22:43:23.000000000 -0800
@@ -419,7 +419,7 @@
 c
       if (fistat .eq. ok) then
 c       **Process file
-         open(unit = errfi, status = 'SCRATCH')
+         CALL CCPDPN(errfi,'TOPPTMP1','SCRATCH','F',80,0)
          readok = .true.
          caonly = .true.
          astruc = .false.
@@ -674,7 +674,7 @@
       if (keywd .eq. hlxkey .or. keywd .eq. shtkey .or.
      +    keywd .eq. trnkey .or. keywd .eq. dsfkey) then
          if (.not. astruc) then
-            open(unit = authfi, status = 'SCRATCH')
+            CALL CCPDPN(authfi,'TOPPTMP2','SCRATCH','F',80,0)
             astruc = .true.
          end if
          write(authfi,'(a)') brkrec
diff -ruN ccp4-5.0.2-orig/unsupported/src/Makefile.in ccp4-5.0.2/unsupported/src/Makefile.in
--- ccp4-5.0.2-orig/unsupported/src/Makefile.in	2003-12-01 03:02:44.000000000 -0800
+++ ccp4-5.0.2/unsupported/src/Makefile.in	2004-08-11 23:02:57.000000000 -0700
@@ -1,7 +1,7 @@
 
 # Makefile tail for CCP4 unsupported programs.  This will be modified by configure.
 
-# $Id: Makefile.in,v 1.23 2003/12/01 11:02:44 mdw Exp $
+# $Id: Makefile.in,v 1.24 2004/08/11 15:59:56 pjx Exp $
 
 # variables which should be set by configure: top_srcdir, CC, CFLAGS,
 # FC, FFLAGS, F, LNS, SETFLAGS, EVAL, LDFLAGS, INSTALL_PROGRAM
@@ -22,7 +22,7 @@
 # end if adding to this list)
 FTARGETS = \
 angles asc2p84 axissearch compar \
-difres havecs hbond helixang \
+difres extends havecs hbond helixang \
 mapexchange mapreplace p842asc postref \
 refindex reforigin rotaprep symfit \
 vecsum zeroed
diff -ruN ccp4-5.0.2-orig/x-windows/libjwc/libjwc_c/configure ccp4-5.0.2/x-windows/libjwc/libjwc_c/configure
--- ccp4-5.0.2-orig/x-windows/libjwc/libjwc_c/configure	2004-06-04 08:40:40.000000000 -0700
+++ ccp4-5.0.2/x-windows/libjwc/libjwc_c/configure	2005-04-13 07:45:25.000000000 -0700
@@ -6882,16 +6882,16 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
       # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
         if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         else
-          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         fi
           module_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       hardcode_direct=no
@@ -9723,17 +9723,17 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds_CXX='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds_CXX='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds_CXX='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds_CXX='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds_CXX='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
 
     # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
       if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       else
-        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       fi
         module_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
     hardcode_direct_CXX=no
@@ -13511,16 +13511,16 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds_F77='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds_F77='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds_F77='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds_F77='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds_F77='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
       # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
         if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         else
-          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         fi
           module_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       hardcode_direct_F77=no
@@ -15851,16 +15851,16 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds_GCJ='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds_GCJ='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds_GCJ='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds_GCJ='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds_GCJ='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
       # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
         if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         else
-          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         fi
           module_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       hardcode_direct_GCJ=no
diff -ruN ccp4-5.0.2-orig/x-windows/libjwc/libjwc_f/configure ccp4-5.0.2/x-windows/libjwc/libjwc_f/configure
--- ccp4-5.0.2-orig/x-windows/libjwc/libjwc_f/configure	2004-06-04 08:41:11.000000000 -0700
+++ ccp4-5.0.2/x-windows/libjwc/libjwc_f/configure	2005-04-13 07:45:25.000000000 -0700
@@ -6921,16 +6921,16 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
       # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
         if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         else
-          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         fi
           module_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       hardcode_direct=no
@@ -9762,17 +9762,17 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds_CXX='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds_CXX='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds_CXX='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds_CXX='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds_CXX='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
 
     # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
       if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       else
-        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       fi
         module_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
     hardcode_direct_CXX=no
@@ -13555,16 +13555,16 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds_F77='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds_F77='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds_F77='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds_F77='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds_F77='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
       # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
         if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         else
-          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         fi
           module_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       hardcode_direct_F77=no
@@ -15895,16 +15895,16 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds_GCJ='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds_GCJ='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds_GCJ='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds_GCJ='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds_GCJ='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
       # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
         if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         else
-          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         fi
           module_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       hardcode_direct_GCJ=no
diff -ruN ccp4-5.0.2-orig/x-windows/xdl_view/src/configure ccp4-5.0.2/x-windows/xdl_view/src/configure
--- ccp4-5.0.2-orig/x-windows/xdl_view/src/configure	2004-06-04 08:47:27.000000000 -0700
+++ ccp4-5.0.2/x-windows/xdl_view/src/configure	2005-04-13 07:45:25.000000000 -0700
@@ -7831,16 +7831,16 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
       # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
         if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         else
-          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         fi
           module_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       hardcode_direct=no
@@ -10726,17 +10726,17 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds_CXX='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds_CXX='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds_CXX='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds_CXX='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds_CXX='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
 
     # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
       if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       else
-        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+        archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       fi
         module_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
     hardcode_direct_CXX=no
@@ -14556,16 +14556,16 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds_F77='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds_F77='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds_F77='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds_F77='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds_F77='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
       # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
         if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         else
-          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         fi
           module_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       hardcode_direct_F77=no
@@ -16908,16 +16908,16 @@
     	  lt_int_apple_cc_single_mod=yes
     	fi
     	if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-    	  archive_cmds_GCJ='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+    	  archive_cmds_GCJ='$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
     	else
-        archive_cmds_GCJ='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        archive_cmds_GCJ='$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring'
       fi
       module_cmds_GCJ='$CC -bundle $archargs ${wl}-bind_at_load $allow_undefined_flag -o $lib $libobjs $deplibs$compiler_flags'
       # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin ld's
         if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
-          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -dynamiclib $archargs -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         else
-          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -r ${wl}-bind_at_load -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs${_S_}$CC -dynamiclib $archargs $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name SW_PREFIX/lib/ccp4-5.0.2/$soname $verstring${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
         fi
           module_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym${_S_}$CC -bundle $archargs $allow_undefined_flag  -o $lib $libobjs $deplibs$compiler_flags${_S_}nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       hardcode_direct_GCJ=no
