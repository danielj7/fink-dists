diff -c -r prcs-1.3.2/prcs-1.3gcc3.diffs prcs-1.3.2-patched/prcs-1.3gcc3.diffs
*** prcs-1.3.2/prcs-1.3gcc3.diffs	Fri Apr 26 10:28:33 2002
--- prcs-1.3.2-patched/prcs-1.3gcc3.diffs	Mon Sep  9 00:01:41 2002
***************
*** 1,884 ****
! Index: 1.3.1-release.6/src/prcserror.cc
! *** 1.3.1-release.6/src/prcserror.cc Fri, 26 Apr 2002 18:24:52 +0400 jmacd (prcs/1_prcserror.cc 1.8.1.11.1.3.1.7.1.11.2.2 644)
! --- 1.3.1-release.6(w)/src/prcserror.cc Fri, 26 Apr 2002 18:26:45 +0400 jmacd (prcs/1_prcserror.cc 1.8.1.11.1.3.1.7.1.11.2.2 644)
! ***************
! *** 52,59 ****
!    stdiobuf stdout_stream(STDOUT_FILENO);
!    stdiobuf stderr_stream(STDERR_FILENO);
!   #else
! !  stdiobuf stdout_stream(stdout);
! !  stdiobuf stderr_stream(stderr);
!   #endif /* if defined(__APPLE__) */
!   strstreambuf query_stream;
!   
! --- 52,59 ----
!    stdiobuf stdout_stream(STDOUT_FILENO);
!    stdiobuf stderr_stream(STDERR_FILENO);
!   #else
! !  filebuf stdout_stream(stdout, ios::out);
! !  filebuf stderr_stream(stderr, ios::out);
!   #endif /* if defined(__APPLE__) */
!   strstreambuf query_stream;
!   
  ***************
! *** 101,117 ****
!   {
!       line_buffer.append(c);
!       if(isspace(c))
! ! 	xsputn(NULL, 0);
    
!       return 1;
!   }
    
!   int PrettyStreambuf::xsputn(const char* s0, int n0)
!   {
! - #ifndef __GNUG__
! - #  define xsputn sputn
! - #endif
! - 
!       if (dont_print && *dont_print)
!   	return n0;
    
! --- 101,113 ----
    {
!       line_buffer.append(c);
!       if(isspace(c))
! ! 	sputn(NULL, 0);
    
!       return 1;
!   }
    
!   int PrettyStreambuf::xsputn(const char* s0, int n0)
!   {
!       if (dont_print && *dont_print)
!   	return n0;
    
  ***************
! *** 137,147 ****
!   
!   		if(!new_line) {
!   		    for(int j = prefix.length(); j; j -= 1) {
! ! 			forward->xsputn(" ", 1);
!   			col += 1;
!   		    }
!   		} else {
! ! 		    forward->xsputn(prefix.cast(), prefix.length());
!   		    col += prefix.length();
!   		}
!   
! --- 133,143 ----
    
!   		if(!new_line) {
!   		    for(int j = prefix.length(); j; j -= 1) {
! ! 			forward->sputn(" ", 1);
!   			col += 1;
!   		    }
!   		} else {
! ! 		    forward->sputn(prefix.cast(), prefix.length());
!   		    col += prefix.length();
!   		}
    
! ***************
! *** 161,208 ****
!   	    if(wordlen == 0) {
!   		if(*s == '\n' || (col + 1 > width)) {
!   		    new_line = false;
! ! 		    forward->xsputn("\n", 1);
!   		    advance_buffer(s, n, col, 1);
!   		    col = 0;
!   		} else {
! ! 		    forward->xsputn(s, 1);
!   		    advance_buffer(s, n, col, 1);
!   		}
!   	    } else if(wordlen + col <= width) {
! ! 		forward->xsputn(s, wordlen);
!   		advance_buffer(s, n, col, wordlen);
!   	    } else if((wordlen + prefix.length() >= width) && (col == prefix.length())) {
! ! 		forward->xsputn(s, wordlen);
!   		advance_buffer(s, n, col, wordlen);
!   	    } else if(wordlen == 1 && col == width) {
!   		new_line = false;
! ! 		forward->xsputn(s, 1);
!   		advance_buffer(s, n, col, wordlen);
! ! 		forward->xsputn("\n", 1);
!   		col = 0;
!   	    } else {
!   		new_line = false;
! ! 		forward->xsputn("\n", 1);
!   		col = 0;
!   	    }
!   	}
!       }
    
!       return n;
! - 
! - #ifndef __GNUG__
! - #  undef xsputn
! - #endif
!   }
    
!   int PrettyStreambuf::sync()
!   {
! !     xsputn(NULL, 0);
! ! #ifdef __GNUG__
! !     return forward->sync();
! ! #else
!       return forward->pubsync();
! - #endif
!   }
    
!   static int tty_width(int fileno)
! --- 157,196 ----
!   	    if(wordlen == 0) {
!   		if(*s == '\n' || (col + 1 > width)) {
!   		    new_line = false;
! ! 		    forward->sputn("\n", 1);
!   		    advance_buffer(s, n, col, 1);
!   		    col = 0;
!   		} else {
! ! 		    forward->sputn(s, 1);
!   		    advance_buffer(s, n, col, 1);
!   		}
!   	    } else if(wordlen + col <= width) {
! ! 		forward->sputn(s, wordlen);
!   		advance_buffer(s, n, col, wordlen);
!   	    } else if((wordlen + prefix.length() >= width) && (col == prefix.length())) {
! ! 		forward->sputn(s, wordlen);
!   		advance_buffer(s, n, col, wordlen);
!   	    } else if(wordlen == 1 && col == width) {
!   		new_line = false;
! ! 		forward->sputn(s, 1);
!   		advance_buffer(s, n, col, wordlen);
! ! 		forward->sputn("\n", 1);
!   		col = 0;
!   	    } else {
!   		new_line = false;
! ! 		forward->sputn("\n", 1);
!   		col = 0;
!   	    }
!   	}
!       }
    
!       return n;
!   }
    
!   int PrettyStreambuf::sync()
!   {
! !     sputn(NULL, 0);
!       return forward->pubsync();
!   }
    
-   static int tty_width(int fileno)
  ***************
! *** 220,232 ****
    
!   void re_query()
!   {
! - #ifdef __GNUG__
! -     stdout_stream.xsputn(re_query_message, re_query_len);
! -     stdout_stream.sync();
! - #else
!       stdout_stream.sputn(re_query_message, re_query_len);
!       stdout_stream.pubsync();
! - #endif
!   }
    
!   void continue_handler(SIGNAL_ARG_TYPE)
! --- 208,215 ----
! ***************
! *** 324,334 ****
!   {
!       PrettyStreambuf& ps = ((PrettyOstream&)o).ostreambuf();
    
! - #ifdef __GNUG__
! -     ps.xsputn(NULL, 0);
! - #else
!       ps.sputn(NULL, 0);
! - #endif
!       ps.set_column(col);
    
!       return o;
! --- 307,313 ----
! ***************
! *** 389,395 ****
    
!       Dstring spaces(' ', diff);
!       bool cb = set_fill_break(false);
! !     xsputn(spaces.cast(), diff);
!       set_fill_break(cb);
    
!       return col0;
! --- 368,374 ----
    
!       Dstring spaces(' ', diff);
!       bool cb = set_fill_break(false);
! !     sputn(spaces.cast(), diff);
!       set_fill_break(cb);
    
!       return col0;
  ***************
! *** 405,418 ****
!   {
!       PrettyStreambuf &ps = ((PrettyOstream&)s).ostreambuf();
!   
! - #ifdef __GNUG__
! -     ps.xsputn("\n", 1);
! - #else
!       ps.sputn("\n", 1);
! - #endif
    
!       ps.reset_column();
    
!       return s;
    }
    
! --- 384,395 ----
!   {
!       PrettyStreambuf &ps = ((PrettyOstream&)s).ostreambuf();
!   
!       ps.sputn("\n", 1);
!   
!       ps.reset_column();
!   
! +     ps.pubsync ();
! + 
!       return s;
!   }
    
  ***************
! *** 420,433 ****
!   {
!       PrettyStreambuf &ps = ((PrettyOstream&)s).ostreambuf();
    
! - #ifdef __GNUG__
! -     ps.xsputn(".\n", 2);
  - #else
!       ps.sputn(".\n", 2);
  - #endif
!   
!       ps.reset_column();
!   
!       return s;
!   }
!   
! --- 397,408 ----
!   {
!       PrettyStreambuf &ps = ((PrettyOstream&)s).ostreambuf();
!   
!       ps.sputn(".\n", 2);
!   
!       ps.reset_column();
!   
! +     ps.pubsync ();
! + 
!       return s;
!   }
!   
  ***************
! *** 439,444 ****
! --- 414,421 ----
!   
!       ps.reset_column();
    
! +     ps.pubsync ();
! + 
!       return s;
!   }
    
  ***************
! *** 454,465 ****
!   /* QueryOstream */
!   QueryOstream::QueryOstream(strstreambuf* base_stream0,
!   			   PrettyStreambuf* query_stream0,
! ! 			   stdiobuf* stdout_stream0,
! ! 			   stdiobuf* stderr_stream0)
! !     :
  ! #ifndef __GNUG__
! !      ios(query_stream0),
  ! #endif
!        PrettyOstream(query_stream0, NoError),
!        base_stream(base_stream0),
!        query_stream(query_stream0),
! --- 431,439 ----
!   /* QueryOstream */
!   QueryOstream::QueryOstream(strstreambuf* base_stream0,
!   			   PrettyStreambuf* query_stream0,
! ! 			   filebuf         *stdout_stream0,
! ! 			   filebuf         *stderr_stream0)
! !     :ios(query_stream0),
!        PrettyOstream(query_stream0, NoError),
!        base_stream(base_stream0),
!        query_stream(query_stream0),
  ***************
! *** 516,550 ****
!   
!   ostream& QueryOstream::string_query_manip(const char* message)
!   {
! - #ifndef __GNUG__
! - #  define xsputn       sputn
! - #  define sync         pubsync
! - #  define seekoff(p,w) pubseekoff((p),(w), ios::out)
! - #endif
!       if(option_force_resolution && option_be_silent) {
!   	/* silence */
!       } else if(option_force_resolution) {
!   	*this << " -- " << default_input << prcsendl;
!   	string_val = PrConstCharPtrError(default_input);
! ! 	stderr_stream->xsputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stderr_stream->sync();
!       } else if(option_report_actions) {
!   	*this << " -- " << default_input << prcsendl;
!   	string_val = PrConstCharPtrError(default_input);
! ! 	stdout_stream->xsputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stdout_stream->sync();
!       } else {
!   	*this << "[" << default_input << "] " << message;
! ! 	query_stream->sync();
!   
!   	re_query_message = base_stream->str();
!   	re_query_len = base_stream->out_waiting();
!   
!   	while(true) {
! ! 	    stdout_stream->xsputn(re_query_message, re_query_len);
! ! 	    stdout_stream->sync();
!   
!   	    Dstring *ans = new Dstring; /* leak */
    
! --- 490,519 ----
    
!   ostream& QueryOstream::string_query_manip(const char* message)
!   {
!       if(option_force_resolution && option_be_silent) {
!   	/* silence */
!       } else if(option_force_resolution) {
!   	*this << " -- " << default_input << prcsendl;
!   	string_val = PrConstCharPtrError(default_input);
! ! 	stderr_stream->sputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stderr_stream->pubsync();
!       } else if(option_report_actions) {
!   	*this << " -- " << default_input << prcsendl;
!   	string_val = PrConstCharPtrError(default_input);
! ! 	stdout_stream->sputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stdout_stream->pubsync();
!       } else {
!   	*this << "[" << default_input << "] " << message;
! ! 	query_stream->pubsync();
    
!   	re_query_message = base_stream->str();
!   	re_query_len = base_stream->out_waiting();
    
!   	while(true) {
! ! 	    stdout_stream->sputn(re_query_message, re_query_len);
! ! 	    stdout_stream->pubsync();
    
!   	    Dstring *ans = new Dstring; /* leak */
    
  ***************
! *** 570,587 ****
!   
!       query_stream->reset_column();
!       base_stream->freeze(0);
! !     base_stream->seekoff(0, ios::beg);
!       option_count = 0;
!       force_option = 0;
!       bang_flag = NULL;
!       help_string = NULL;
!   
!       return *this;
! - #ifndef __GNUG__
! - #  undef xsputn
! - #  undef sync
! - #  undef seekoff
! - #endif
!   }
    
!   ostream& QueryOstream::help_manip(const char* message)
! --- 539,551 ----
    
!       query_stream->reset_column();
!       base_stream->freeze(0);
! !     base_stream->pubseekoff(0, ios::beg, ios::out);
!       option_count = 0;
!       force_option = 0;
!       bang_flag = NULL;
!       help_string = NULL;
    
!       return *this;
!   }
    
!   ostream& QueryOstream::help_manip(const char* message)
! ***************
! *** 592,602 ****
    
!   ostream& QueryOstream::query_manip(const char* message)
!   {
! - #ifndef __GNUG__
! - #  define xsputn  sputn
! - #  define sync    pubsync
! - #  define seekoff(p,w) pubseekoff((p),(w), ios::out)
! - #endif
!       if(force_option != 0 && option_force_resolution) {
!           for (int i = 0; i < option_count; i += 1) {
!   	    if (force_option == options[i].let) {
! --- 556,561 ----
! ***************
! *** 611,634 ****
!   	val = options[default_option].val;
!       } else if(option_report_actions) {
!   	*this << report_message << dotendl;
! ! 	query_stream->sync();
! ! 	stdout_stream->xsputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stdout_stream->sync();
!   	val = options[default_option].val;
!       } else if(option_force_resolution) {
!   	*this << force_message << dotendl;
! ! 	query_stream->sync();
! ! 	stderr_stream->xsputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stderr_stream->sync();
!   	val = options[default_option].val;
!       } else if(bang_flag && bang_flag->flag) {
!   	*this << force_message << dotendl;
! ! 	query_stream->sync();
! ! 	stdout_stream->xsputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stdout_stream->sync();
!   	val = options[default_option].val;
!       } else {
!   	char query_buf[40];
! --- 570,593 ----
!   	val = options[default_option].val;
!       } else if(option_report_actions) {
!   	*this << report_message << dotendl;
! ! 	query_stream->pubsync();
! ! 	stdout_stream->sputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stdout_stream->pubsync();
!   	val = options[default_option].val;
!       } else if(option_force_resolution) {
!   	*this << force_message << dotendl;
! ! 	query_stream->pubsync();
! ! 	stderr_stream->sputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stderr_stream->pubsync();
!   	val = options[default_option].val;
!       } else if(bang_flag && bang_flag->flag) {
!   	*this << force_message << dotendl;
! ! 	query_stream->pubsync();
! ! 	stdout_stream->sputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stdout_stream->pubsync();
!   	val = options[default_option].val;
!       } else {
!   	char query_buf[40];
! ***************
! *** 657,663 ****
    
!   	*this << message << query_buf;
    
! ! 	query_stream->sync();
    
!   	re_query_message = base_stream->str();
!   	re_query_len = base_stream->out_waiting();
! --- 616,622 ----
    
!   	*this << message << query_buf;
    
! ! 	query_stream->pubsync();
    
!   	re_query_message = base_stream->str();
!   	re_query_len = base_stream->out_waiting();
  ***************
! *** 666,673 ****
!   	    char c;
!   	    int found = false;
    
! ! 	    stdout_stream->xsputn(re_query_message, re_query_len);
! ! 	    stdout_stream->sync();
    
!   	    c = get_user_char();
    
! --- 625,632 ----
!   	    char c;
!   	    int found = false;
    
! ! 	    stdout_stream->sputn(re_query_message, re_query_len);
! ! 	    stdout_stream->pubsync();
    
!   	    c = get_user_char();
    
  ***************
! *** 718,735 ****
    
!       query_stream->reset_column();
!       base_stream->freeze(0);
! !     base_stream->seekoff(0, ios::beg);
!       force_option = 0;
!       option_count = 0;
!       bang_flag = NULL;
!       help_string = NULL;
    
!       return *this;
  - #ifndef __GNUG__
  - #  undef xsputn
- - #  undef sync
- - #  undef seekoff
  - #endif
    }
    
!   ostream& __omanip_query(ostream& s, const char* message) {
! --- 677,689 ----
    
!       query_stream->reset_column();
!       base_stream->freeze(0);
! !     base_stream->pubseekoff(0, ios::beg, ios::out);
!       force_option = 0;
!       option_count = 0;
!       bang_flag = NULL;
!       help_string = NULL;
    
!       return *this;
    }
    
!   ostream& __omanip_query(ostream& s, const char* message) {
! Index: 1.3.1-release.6/src/dstring.cc
! *** 1.3.1-release.6/src/dstring.cc Fri, 26 Apr 2002 18:22:42 +0400 jmacd (prcs/0_dstring.cc 1.2.1.3.1.1.1.6.2.3 644)
! --- 1.3.1-release.6(w)/src/dstring.cc Fri, 26 Apr 2002 18:25:50 +0400 jmacd (prcs/0_dstring.cc 1.2.1.3.1.1.1.6.2.3 644)
! ***************
! *** 25,38 ****
    
!   #include "prcs.h"
    
! ! #if defined(__GNUG__) || defined(__MWERKS__)
! ! #if defined(__GNUG__)
! ! #include <strstream.h>
! ! #else
! ! #include "be-strstream.h"
! ! #endif
! ! static ostrstream sprintfbuf;
! ! #endif
    
!   ostream& operator<<(ostream& os, const Dstring* S)
    {
! --- 25,37 ----
    
!   #include "prcs.h"
    
! ! static strstreambuf sprintfbuf;
! ! 
! ! /* I used to use strstreambuf::vform to get printf-like formatting
! !  * into a growing buffer, but that's been taken away.  So there's
! !  * this, which can buffer-overrun. @@@ */
! ! const int DSTRSZ = (1<<12);
! ! char hack_buf[DSTRSZ];
    
!   ostream& operator<<(ostream& os, const Dstring* S)
!   {
  ***************
! *** 61,75 ****
!       va_start(args, fmt);
    
!       sprintfbuf.freeze(0);
! ! #ifdef __GNUG__
! !     sprintfbuf.rdbuf()->seekoff(0, ios::beg);
! ! #else
! !     sprintfbuf.rdbuf()->pubseekoff(0, ios::beg, ios::out);
! ! #endif
! ! 
! !     sprintfbuf.vform(fmt, args);
    
! !     sprintfbuf << '\0';
    
!       append(sprintfbuf.str());
    
! --- 60,71 ----
!       va_start(args, fmt);
    
!       sprintfbuf.freeze(0);
! !     sprintfbuf.pubseekoff(0, ios::beg, ios::out);
    
! !     hack_buf[DSTRSZ-1] = '\0';
! !     vsprintf(hack_buf, fmt, args);
! !     ASSERT('\0' == hack_buf[DSTRSZ-1], "Output buffer bounds exceeded");
! !     sprintfbuf.sputn (hack_buf, strlen (hack_buf) + 1);
    
!       append(sprintfbuf.str());
    
  ***************
! *** 85,99 ****
!       truncate(0);
    
!       sprintfbuf.freeze(0);
! ! #ifdef __GNUG__
! !     sprintfbuf.rdbuf()->seekoff(0, ios::beg);
! ! #else
! !     sprintfbuf.rdbuf()->pubseekoff(0, ios::beg, ios::out);
! ! #endif
! ! 
! !     sprintfbuf.vform(fmt, args);
    
! !     sprintfbuf << '\0';
    
!       append(sprintfbuf.str());
    
! --- 81,92 ----
!       truncate(0);
    
!       sprintfbuf.freeze(0);
! !     sprintfbuf.pubseekoff(0, ios::beg, ios::out);
    
! !     hack_buf[DSTRSZ-1] = '\0';
! !     vsprintf(hack_buf, fmt, args);
! !     ASSERT('\0' == hack_buf[DSTRSZ-1], "Output buffer bounds exceeded");
! !     sprintfbuf.sputn (hack_buf, strlen (hack_buf)+1);
    
!       append(sprintfbuf.str());
    
- Index: 1.3.1-release.6/src/include/prcs.h
- *** 1.3.1-release.6/src/include/prcs.h Thu, 07 Feb 2002 07:57:16 +0300 jmacd (prcs/0_prcs.h 1.16.1.15.1.6.1.12.1.21.1.2 644)
- --- 1.3.1-release.6(w)/src/include/prcs.h Fri, 26 Apr 2002 18:25:50 +0400 jmacd (prcs/0_prcs.h 1.16.1.15.1.6.1.12.1.21.1.2 644)
  ***************
! *** 41,48 ****
!   #include "utils.h"
!   }
    
! ! #include <iostream.h>
! ! #include <fstream.h>
    
!   #ifdef NULL
!   #undef NULL
! --- 41,80 ----
!   #include "utils.h"
    }
    
- ! #include <iostream>
- ! #include <fstream>
- ! #include <streambuf>
- ! #include <sstream>
- ! 
- ! using std::ostream;
- ! using std::streambuf;
- ! using std::char_traits;
- ! using std::basic_streambuf;
- ! using std::filebuf;
- ! using std::ofstream;
- ! using std::ifstream;
- ! using std::cout;
- ! using std::cerr;
- ! using std::ios;
- ! using std::stringbuf;
- ! using std::string;
- ! using std::ostringstream;
- ! 
- ! /* Backwards C++ compatibility, thanks to Lars Duening <lars@bearnip.com>
- !  * I can't explain why I used so many different, overlapping C++
- !  * features to begin with.  */
- ! class strstreambuf : public stringbuf {
- !   private:
- !     string tmpstr; // holds result of str()
- !   public:
- !     int out_waiting() { return pptr() - pbase() - (0 == *pptr() ? 1 : 0); }
- !     const char * str() {
- !       tmpstr = stringbuf::str();
- !       return tmpstr.c_str();
- !     }
- !     void freeze(int n=1)
- !       { ASSERT(n==0, "strstreambuf::freeze(1) not implemented."); }
- ! };
-   
-   #ifdef NULL
-   #undef NULL
- Index: 1.3.1-release.6/src/include/prcserror.h
- *** 1.3.1-release.6/src/include/prcserror.h Fri, 26 Apr 2002 18:24:52 +0400 jmacd (prcs/1_prcserror.h 1.14.1.5.1.11.2.1 644)
- --- 1.3.1-release.6(w)/src/include/prcserror.h Fri, 26 Apr 2002 18:27:48 +0400 jmacd (prcs/1_prcserror.h 1.14.1.5.1.11.2.1 644)
  ***************
! *** 24,46 ****
!   #define _PRCSERROR_H_
!   
    
! - #include <iostream.h>
! - #include <iomanip.h>
! - #if defined(__GNUG__)
! - # if defined(__APPLE__)
! - #  include <streambuf.h>
! -    typedef filebuf stdiobuf;
! - # else
! - #  include <stdiostream.h>
! - # endif /* if defined(__APPLE__) */
! - # include <strstream.h>
! - #else
! - # include <fstream.h>
! -   typedef filebuf stdiobuf;
! - # include "be-strstream.h"
  - #endif
! - 
! - 
!   extern "C" {
!   #include <stdio.h>
!   #include <string.h>
! --- 24,29 ----
! ***************
! *** 291,299 ****
!    *     streambuf from breaking lines at whitespace inside the quotes.
!    *     It forwards all output to another stremabuf.  Currently, there
!    *     are three of these used in PRCS.  The ostream prcserror's
! !  *     streambuf forwards its output to a stdiobuf(stderr).  The
!    *     ostream prcsout's streambuf forwards its output to a
! !  *     stdiobuf(stdout).  The ostream prcsquery's streambuf forwards
!    *     its output to a ostrstreambuf, since prcsquery doesn't know
!    *     whether to send its output to stdout or stderr until the query
!    *     is received.  */
! --- 274,282 ----
!    *     streambuf from breaking lines at whitespace inside the quotes.
!    *     It forwards all output to another stremabuf.  Currently, there
!    *     are three of these used in PRCS.  The ostream prcserror's
! !  *     streambuf forwards its output to a filebuf(stderr).  The
!    *     ostream prcsout's streambuf forwards its output to a
! !  *     filebuf(stdout).  The ostream prcsquery's streambuf forwards
!    *     its output to a ostrstreambuf, since prcsquery doesn't know
!    *     whether to send its output to stdout or stderr until the query
!    *     is received.  */
  ***************
! *** 310,318 ****
!       const char* fill_prefix() const;
!       bool fill_pretty() const;
    
  - #ifndef __GNUG__
!   protected:
! ! #endif
!       virtual int xsputn(const char* s, int n);
!       virtual int overflow(int c = EOF);
!       virtual int sync();
! --- 293,300 ----
!       const char* fill_prefix() const;
!       bool fill_pretty() const;
    
!   protected:
! ! 
!       virtual int xsputn(const char* s, int n);
!       virtual int overflow(int c = EOF);
!       virtual int sync();
  ***************
! *** 335,352 ****
!   class PrettyOstream : public ostream {
!   public:
!       PrettyOstream(PrettyStreambuf* stream, ErrorToken err)
! ! 	:
! ! #ifndef __GNUG__
! !          ios(stream),
! ! #endif
! !          ostream(stream), _buf(stream), _err(err)
!           { }
!       PrettyOstream(PrettyStreambuf* stream, NonErrorToken err)
! !         :
! ! #ifndef __GNUG__
! !          ios(stream),
! ! #endif
! ! 	 ostream(stream), _buf(stream), _err(err)
!           { }
!       PrettyStreambuf& ostreambuf() const { return *_buf; }
!       PrVoidError error() const { return _err; }
! --- 317,330 ----
!   class PrettyOstream : public ostream {
!   public:
!       PrettyOstream(PrettyStreambuf* stream, ErrorToken err)
! ! 	:ostream(stream),
! ! 	 _buf(stream),
! ! 	 _err(err)
!           { }
!       PrettyOstream(PrettyStreambuf* stream, NonErrorToken err)
! !         : ostream(stream),
! ! 	  _buf(stream),
! ! 	  _err(err)
!           { }
!       PrettyStreambuf& ostreambuf() const { return *_buf; }
!       PrVoidError error() const { return _err; }
  ***************
! *** 457,464 ****
!   public:
!       QueryOstream(strstreambuf *base_stream0,
!   		 PrettyStreambuf* query_stream0,
! ! 		 stdiobuf* stdout_stream0,
! ! 		 stdiobuf* stderr_stream0);
    
!       /*
!        * Manipulator methods.
! --- 435,442 ----
!   public:
!       QueryOstream(strstreambuf *base_stream0,
!   		 PrettyStreambuf* query_stream0,
! ! 		 filebuf          *stdout_stream0,
! ! 		 filebuf          *stderr_stream0);
    
!       /*
!        * Manipulator methods.
! ***************
! *** 481,487 ****
    
!       strstreambuf *base_stream;
!       PrettyStreambuf* query_stream;
! !     stdiobuf *stdout_stream, *stderr_stream;
!       PrCharError val;
!       PrConstCharPtrError string_val;
    
! --- 459,465 ----
    
!       strstreambuf *base_stream;
!       PrettyStreambuf* query_stream;
! !     filebuf         *stdout_stream, *stderr_stream;
!       PrCharError val;
!       PrConstCharPtrError string_val;
    
  ***************
! *** 499,514 ****
    
!   extern char const default_fail_query_message[];
    
! ! #if !defined(__GNUG__) && !defined(__MWERKS__)
!   template <class TP> class omanip {
!       ostream& (*_f)(ostream&, TP);
!       TP _a;
!   public:
!       omanip(ostream& (*f)(ostream&, TP), TP a) : _f(f), _a(a) { }
    
! !     friend ostream& operator<<(ostream& o, const omanip<TP>& m);
!   };
! ! #endif
    
!   ostream& __omanip_query(ostream& s, const char* message);
!   omanip<const char*> query(const char* message);
! --- 477,499 ----
    
!   extern char const default_fail_query_message[];
    
! ! template <class TP> class omanip;
! ! 
! ! template <class TP> ostream& operator<< (ostream& o, const omanip<TP>& m);
! ! 
!   template <class TP> class omanip {
!       ostream& (*_f)(ostream&, TP);
!       TP _a;
!   public:
!       omanip(ostream& (*f)(ostream&, TP), TP a) : _f(f), _a(a) { }
    
! !     friend ostream& operator<< <>(ostream& o, const omanip<TP>& m);
!   };
! ! 
! ! template <class TP> ostream& operator<< (ostream& o, const omanip<TP>& m)
! ! {
! !     return (*m._f)(o, m._a);
! ! }
    
!   ostream& __omanip_query(ostream& s, const char* message);
!   omanip<const char*> query(const char* message);
! Index: 1.3.1-release.6/src/prcserror.tl
! *** 1.3.1-release.6/src/prcserror.tl Sun, 31 Oct 1999 07:26:02 +0300 jmacd (prcs/0_prcserror.tl 1.1.1.6.1.3.1.8 644)
! --- 1.3.1-release.6(w)/src/prcserror.tl Fri, 26 Apr 2002 18:27:03 +0400 jmacd (prcs/0_prcserror.tl 1.1.1.6.1.3.1.8 644)
  ***************
  *** 52,66 ****
    template class PrError<FileEntry*>;
--- 1,889 ----
! diff -c -r prcs-1.3.2/src/dstring.cc prcs-1.3.2-patched/src/dstring.cc
! *** prcs-1.3.2/src/dstring.cc	Fri Apr 26 10:22:42 2002
! --- prcs-1.3.2-patched/src/dstring.cc	Sun Sep  8 23:38:46 2002
  ***************
! *** 25,38 ****
    
!   #include "prcs.h"
    
! ! #if defined(__GNUG__) || defined(__MWERKS__)
! ! #if defined(__GNUG__)
! ! #include <strstream.h>
! ! #else
! ! #include "be-strstream.h"
! ! #endif
! ! static ostrstream sprintfbuf;
! ! #endif
    
!   ostream& operator<<(ostream& os, const Dstring* S)
    {
! --- 25,37 ----
    
!   #include "prcs.h"
    
! ! static strstreambuf sprintfbuf;
! ! 
! ! /* I used to use strstreambuf::vform to get printf-like formatting
! !  * into a growing buffer, but that's been taken away.  So there's
! !  * this, which can buffer-overrun. @@@ */
! ! const int DSTRSZ = (1<<12);
! ! char hack_buf[DSTRSZ];
    
+   ostream& operator<<(ostream& os, const Dstring* S)
+   {
  ***************
! *** 61,75 ****
!       va_start(args, fmt);
    
!       sprintfbuf.freeze(0);
! ! #ifdef __GNUG__
! !     sprintfbuf.rdbuf()->seekoff(0, ios::beg);
! ! #else
! !     sprintfbuf.rdbuf()->pubseekoff(0, ios::beg, ios::out);
! ! #endif
! ! 
! !     sprintfbuf.vform(fmt, args);
    
! !     sprintfbuf << '\0';
    
!       append(sprintfbuf.str());
    
! --- 60,71 ----
!       va_start(args, fmt);
    
!       sprintfbuf.freeze(0);
! !     sprintfbuf.pubseekoff(0, ios::beg, ios::out);
    
! !     hack_buf[DSTRSZ-1] = '\0';
! !     vsprintf(hack_buf, fmt, args);
! !     ASSERT('\0' == hack_buf[DSTRSZ-1], "Output buffer bounds exceeded");
! !     sprintfbuf.sputn (hack_buf, strlen (hack_buf) + 1);
    
!       append(sprintfbuf.str());
    
  ***************
! *** 85,99 ****
!       truncate(0);
    
!       sprintfbuf.freeze(0);
! ! #ifdef __GNUG__
! !     sprintfbuf.rdbuf()->seekoff(0, ios::beg);
! ! #else
! !     sprintfbuf.rdbuf()->pubseekoff(0, ios::beg, ios::out);
! ! #endif
! ! 
! !     sprintfbuf.vform(fmt, args);
    
! !     sprintfbuf << '\0';
    
!       append(sprintfbuf.str());
    
! --- 81,92 ----
!       truncate(0);
    
!       sprintfbuf.freeze(0);
! !     sprintfbuf.pubseekoff(0, ios::beg, ios::out);
    
! !     hack_buf[DSTRSZ-1] = '\0';
! !     vsprintf(hack_buf, fmt, args);
! !     ASSERT('\0' == hack_buf[DSTRSZ-1], "Output buffer bounds exceeded");
! !     sprintfbuf.sputn (hack_buf, strlen (hack_buf)+1);
    
!       append(sprintfbuf.str());
    
! diff -c -r prcs-1.3.2/src/include/prcs.h prcs-1.3.2-patched/src/include/prcs.h
! *** prcs-1.3.2/src/include/prcs.h	Wed Feb  6 23:57:16 2002
! --- prcs-1.3.2-patched/src/include/prcs.h	Sun Sep  8 23:38:46 2002
  ***************
! *** 41,48 ****
!   #include "utils.h"
!   }
    
! ! #include <iostream.h>
! ! #include <fstream.h>
    
!   #ifdef NULL
!   #undef NULL
! --- 41,80 ----
!   #include "utils.h"
    }
    
! ! #include <iostream>
! ! #include <fstream>
! ! #include <streambuf>
! ! #include <sstream>
! ! 
! ! using std::ostream;
! ! using std::streambuf;
! ! using std::char_traits;
! ! using std::basic_streambuf;
! ! using std::filebuf;
! ! using std::ofstream;
! ! using std::ifstream;
! ! using std::cout;
! ! using std::cerr;
! ! using std::ios;
! ! using std::stringbuf;
! ! using std::string;
! ! using std::ostringstream;
! ! 
! ! /* Backwards C++ compatibility, thanks to Lars Duening <lars@bearnip.com>
! !  * I can't explain why I used so many different, overlapping C++
! !  * features to begin with.  */
! ! class strstreambuf : public stringbuf {
! !   private:
! !     string tmpstr; // holds result of str()
! !   public:
! !     int out_waiting() { return pptr() - pbase() - (0 == *pptr() ? 1 : 0); }
! !     const char * str() {
! !       tmpstr = stringbuf::str();
! !       return tmpstr.c_str();
! !     }
! !     void freeze(int n=1)
! !       { ASSERT(n==0, "strstreambuf::freeze(1) not implemented."); }
! ! };
    
+   #ifdef NULL
+   #undef NULL
+ diff -c -r prcs-1.3.2/src/include/prcserror.h prcs-1.3.2-patched/src/include/prcserror.h
+ *** prcs-1.3.2/src/include/prcserror.h	Fri Apr 26 10:24:52 2002
+ --- prcs-1.3.2-patched/src/include/prcserror.h	Sun Sep  8 23:38:46 2002
  ***************
! *** 24,46 ****
!   #define _PRCSERROR_H_
    
!   
! - #include <iostream.h>
! - #include <iomanip.h>
! - #if defined(__GNUG__)
! - # if defined(__APPLE__)
! - #  include <streambuf.h>
! -    typedef filebuf stdiobuf;
! - # else
! - #  include <stdiostream.h>
! - # endif /* if defined(__APPLE__) */
! - # include <strstream.h>
  - #else
! - # include <fstream.h>
! -   typedef filebuf stdiobuf;
! - # include "be-strstream.h"
  - #endif
! - 
! - 
!   extern "C" {
!   #include <stdio.h>
!   #include <string.h>
! --- 24,29 ----
  ***************
! *** 291,299 ****
!    *     streambuf from breaking lines at whitespace inside the quotes.
!    *     It forwards all output to another stremabuf.  Currently, there
!    *     are three of these used in PRCS.  The ostream prcserror's
! !  *     streambuf forwards its output to a stdiobuf(stderr).  The
!    *     ostream prcsout's streambuf forwards its output to a
! !  *     stdiobuf(stdout).  The ostream prcsquery's streambuf forwards
!    *     its output to a ostrstreambuf, since prcsquery doesn't know
!    *     whether to send its output to stdout or stderr until the query
!    *     is received.  */
! --- 274,282 ----
!    *     streambuf from breaking lines at whitespace inside the quotes.
!    *     It forwards all output to another stremabuf.  Currently, there
!    *     are three of these used in PRCS.  The ostream prcserror's
! !  *     streambuf forwards its output to a filebuf(stderr).  The
!    *     ostream prcsout's streambuf forwards its output to a
! !  *     filebuf(stdout).  The ostream prcsquery's streambuf forwards
!    *     its output to a ostrstreambuf, since prcsquery doesn't know
!    *     whether to send its output to stdout or stderr until the query
!    *     is received.  */
! ***************
! *** 310,318 ****
!       const char* fill_prefix() const;
!       bool fill_pretty() const;
    
! - #ifndef __GNUG__
!   protected:
! ! #endif
!       virtual int xsputn(const char* s, int n);
!       virtual int overflow(int c = EOF);
!       virtual int sync();
! --- 293,300 ----
!       const char* fill_prefix() const;
!       bool fill_pretty() const;
    
+   protected:
+ ! 
+       virtual int xsputn(const char* s, int n);
+       virtual int overflow(int c = EOF);
+       virtual int sync();
  ***************
! *** 335,352 ****
!   class PrettyOstream : public ostream {
!   public:
!       PrettyOstream(PrettyStreambuf* stream, ErrorToken err)
! ! 	:
  ! #ifndef __GNUG__
! !          ios(stream),
  ! #endif
! !          ostream(stream), _buf(stream), _err(err)
!           { }
!       PrettyOstream(PrettyStreambuf* stream, NonErrorToken err)
! !         :
! ! #ifndef __GNUG__
! !          ios(stream),
! ! #endif
! ! 	 ostream(stream), _buf(stream), _err(err)
!           { }
!       PrettyStreambuf& ostreambuf() const { return *_buf; }
!       PrVoidError error() const { return _err; }
! --- 317,330 ----
!   class PrettyOstream : public ostream {
!   public:
!       PrettyOstream(PrettyStreambuf* stream, ErrorToken err)
! ! 	:ostream(stream),
! ! 	 _buf(stream),
! ! 	 _err(err)
!           { }
!       PrettyOstream(PrettyStreambuf* stream, NonErrorToken err)
! !         : ostream(stream),
! ! 	  _buf(stream),
! ! 	  _err(err)
!           { }
!       PrettyStreambuf& ostreambuf() const { return *_buf; }
!       PrVoidError error() const { return _err; }
  ***************
! *** 457,464 ****
!   public:
!       QueryOstream(strstreambuf *base_stream0,
!   		 PrettyStreambuf* query_stream0,
! ! 		 stdiobuf* stdout_stream0,
! ! 		 stdiobuf* stderr_stream0);
    
!       /*
!        * Manipulator methods.
! --- 435,442 ----
!   public:
!       QueryOstream(strstreambuf *base_stream0,
!   		 PrettyStreambuf* query_stream0,
! ! 		 filebuf          *stdout_stream0,
! ! 		 filebuf          *stderr_stream0);
    
!       /*
!        * Manipulator methods.
! ***************
! *** 481,487 ****
    
!       strstreambuf *base_stream;
!       PrettyStreambuf* query_stream;
! !     stdiobuf *stdout_stream, *stderr_stream;
!       PrCharError val;
!       PrConstCharPtrError string_val;
    
! --- 459,465 ----
    
!       strstreambuf *base_stream;
!       PrettyStreambuf* query_stream;
! !     filebuf         *stdout_stream, *stderr_stream;
!       PrCharError val;
!       PrConstCharPtrError string_val;
    
  ***************
! *** 499,514 ****
    
!   extern char const default_fail_query_message[];
    
! ! #if !defined(__GNUG__) && !defined(__MWERKS__)
!   template <class TP> class omanip {
!       ostream& (*_f)(ostream&, TP);
!       TP _a;
!   public:
!       omanip(ostream& (*f)(ostream&, TP), TP a) : _f(f), _a(a) { }
    
! !     friend ostream& operator<<(ostream& o, const omanip<TP>& m);
!   };
! ! #endif
    
!   ostream& __omanip_query(ostream& s, const char* message);
!   omanip<const char*> query(const char* message);
! --- 477,499 ----
    
!   extern char const default_fail_query_message[];
    
! ! template <class TP> class omanip;
! ! 
! ! template <class TP> ostream& operator<< (ostream& o, const omanip<TP>& m);
! ! 
!   template <class TP> class omanip {
!       ostream& (*_f)(ostream&, TP);
!       TP _a;
!   public:
!       omanip(ostream& (*f)(ostream&, TP), TP a) : _f(f), _a(a) { }
    
! !     friend ostream& operator<< <>(ostream& o, const omanip<TP>& m);
!   };
! ! 
! ! template <class TP> ostream& operator<< (ostream& o, const omanip<TP>& m)
! ! {
! !     return (*m._f)(o, m._a);
! ! }
    
!   ostream& __omanip_query(ostream& s, const char* message);
!   omanip<const char*> query(const char* message);
! diff -c -r prcs-1.3.2/src/prcserror.cc prcs-1.3.2-patched/src/prcserror.cc
! *** prcs-1.3.2/src/prcserror.cc	Fri Apr 26 10:24:52 2002
! --- prcs-1.3.2-patched/src/prcserror.cc	Sun Sep  8 23:43:17 2002
! ***************
! *** 48,60 ****
!   int return_if_fail_if_ne_val;
!   #endif
!   
! ! #if defined(__APPLE__)
! !  stdiobuf stdout_stream(STDOUT_FILENO);
! !  stdiobuf stderr_stream(STDERR_FILENO);
! ! #else
! !  stdiobuf stdout_stream(stdout);
! !  stdiobuf stderr_stream(stderr);
! ! #endif /* if defined(__APPLE__) */
!   strstreambuf query_stream;
    
!   static PrettyStreambuf pretty_stdout_stream(&stdout_stream, NULL);
! --- 48,55 ----
!   int return_if_fail_if_ne_val;
!   #endif
    
! ! filebuf stdout_stream(stdout, ios::out);
! ! filebuf stderr_stream(stderr, ios::out);
!   strstreambuf query_stream;
    
!   static PrettyStreambuf pretty_stdout_stream(&stdout_stream, NULL);
  ***************
! *** 101,117 ****
!   {
!       line_buffer.append(c);
!       if(isspace(c))
! ! 	xsputn(NULL, 0);
    
!       return 1;
!   }
    
!   int PrettyStreambuf::xsputn(const char* s0, int n0)
!   {
! - #ifndef __GNUG__
! - #  define xsputn sputn
! - #endif
! - 
!       if (dont_print && *dont_print)
!   	return n0;
    
! --- 96,108 ----
!   {
!       line_buffer.append(c);
!       if(isspace(c))
! ! 	sputn(NULL, 0);
    
!       return 1;
!   }
    
!   int PrettyStreambuf::xsputn(const char* s0, int n0)
!   {
!       if (dont_print && *dont_print)
!   	return n0;
    
  ***************
! *** 137,147 ****
    
!   		if(!new_line) {
!   		    for(int j = prefix.length(); j; j -= 1) {
! ! 			forward->xsputn(" ", 1);
!   			col += 1;
!   		    }
!   		} else {
! ! 		    forward->xsputn(prefix.cast(), prefix.length());
!   		    col += prefix.length();
!   		}
    
! --- 128,138 ----
!   
!   		if(!new_line) {
!   		    for(int j = prefix.length(); j; j -= 1) {
! ! 			forward->sputn(" ", 1);
!   			col += 1;
!   		    }
!   		} else {
! ! 		    forward->sputn(prefix.cast(), prefix.length());
!   		    col += prefix.length();
!   		}
!   
! ***************
! *** 161,208 ****
!   	    if(wordlen == 0) {
!   		if(*s == '\n' || (col + 1 > width)) {
!   		    new_line = false;
! ! 		    forward->xsputn("\n", 1);
!   		    advance_buffer(s, n, col, 1);
!   		    col = 0;
!   		} else {
! ! 		    forward->xsputn(s, 1);
!   		    advance_buffer(s, n, col, 1);
!   		}
!   	    } else if(wordlen + col <= width) {
! ! 		forward->xsputn(s, wordlen);
!   		advance_buffer(s, n, col, wordlen);
!   	    } else if((wordlen + prefix.length() >= width) && (col == prefix.length())) {
! ! 		forward->xsputn(s, wordlen);
!   		advance_buffer(s, n, col, wordlen);
!   	    } else if(wordlen == 1 && col == width) {
!   		new_line = false;
! ! 		forward->xsputn(s, 1);
!   		advance_buffer(s, n, col, wordlen);
! ! 		forward->xsputn("\n", 1);
!   		col = 0;
!   	    } else {
!   		new_line = false;
! ! 		forward->xsputn("\n", 1);
!   		col = 0;
!   	    }
!   	}
!       }
!   
!       return n;
! - 
  - #ifndef __GNUG__
  - #  undef xsputn
  - #endif
    }
    
!   int PrettyStreambuf::sync()
!   {
! !     xsputn(NULL, 0);
! ! #ifdef __GNUG__
! !     return forward->sync();
! ! #else
!       return forward->pubsync();
! - #endif
!   }
    
!   static int tty_width(int fileno)
! --- 152,191 ----
!   	    if(wordlen == 0) {
!   		if(*s == '\n' || (col + 1 > width)) {
!   		    new_line = false;
! ! 		    forward->sputn("\n", 1);
!   		    advance_buffer(s, n, col, 1);
!   		    col = 0;
!   		} else {
! ! 		    forward->sputn(s, 1);
!   		    advance_buffer(s, n, col, 1);
!   		}
!   	    } else if(wordlen + col <= width) {
! ! 		forward->sputn(s, wordlen);
!   		advance_buffer(s, n, col, wordlen);
!   	    } else if((wordlen + prefix.length() >= width) && (col == prefix.length())) {
! ! 		forward->sputn(s, wordlen);
!   		advance_buffer(s, n, col, wordlen);
!   	    } else if(wordlen == 1 && col == width) {
!   		new_line = false;
! ! 		forward->sputn(s, 1);
!   		advance_buffer(s, n, col, wordlen);
! ! 		forward->sputn("\n", 1);
!   		col = 0;
!   	    } else {
!   		new_line = false;
! ! 		forward->sputn("\n", 1);
!   		col = 0;
!   	    }
!   	}
!       }
    
!       return n;
    }
    
!   int PrettyStreambuf::sync()
!   {
! !     sputn(NULL, 0);
!       return forward->pubsync();
!   }
    
!   static int tty_width(int fileno)
! ***************
! *** 220,232 ****
    
!   void re_query()
!   {
! - #ifdef __GNUG__
! -     stdout_stream.xsputn(re_query_message, re_query_len);
! -     stdout_stream.sync();
! - #else
!       stdout_stream.sputn(re_query_message, re_query_len);
!       stdout_stream.pubsync();
! - #endif
!   }
    
!   void continue_handler(SIGNAL_ARG_TYPE)
! --- 203,210 ----
! ***************
! *** 324,334 ****
    {
!       PrettyStreambuf& ps = ((PrettyOstream&)o).ostreambuf();
    
! - #ifdef __GNUG__
! -     ps.xsputn(NULL, 0);
! - #else
!       ps.sputn(NULL, 0);
! - #endif
!       ps.set_column(col);
    
!       return o;
! --- 302,308 ----
! ***************
! *** 389,395 ****
    
!       Dstring spaces(' ', diff);
!       bool cb = set_fill_break(false);
! !     xsputn(spaces.cast(), diff);
!       set_fill_break(cb);
!   
!       return col0;
! --- 363,369 ----
!   
!       Dstring spaces(' ', diff);
!       bool cb = set_fill_break(false);
! !     sputn(spaces.cast(), diff);
!       set_fill_break(cb);
!   
!       return col0;
  ***************
! *** 405,418 ****
!   {
!       PrettyStreambuf &ps = ((PrettyOstream&)s).ostreambuf();
    
! - #ifdef __GNUG__
! -     ps.xsputn("\n", 1);
! - #else
!       ps.sputn("\n", 1);
! - #endif
    
!       ps.reset_column();
    
!       return s;
!   }
    
! --- 379,390 ----
!   {
!       PrettyStreambuf &ps = ((PrettyOstream&)s).ostreambuf();
    
!       ps.sputn("\n", 1);
    
!       ps.reset_column();
    
! +     ps.pubsync ();
! + 
!       return s;
!   }
    
  ***************
! *** 420,433 ****
!   {
!       PrettyStreambuf &ps = ((PrettyOstream&)s).ostreambuf();
    
! - #ifdef __GNUG__
! -     ps.xsputn(".\n", 2);
! - #else
!       ps.sputn(".\n", 2);
! - #endif
    
!       ps.reset_column();
    
!       return s;
!   }
    
! --- 392,403 ----
!   {
!       PrettyStreambuf &ps = ((PrettyOstream&)s).ostreambuf();
    
!       ps.sputn(".\n", 2);
    
!       ps.reset_column();
    
! +     ps.pubsync ();
! + 
!       return s;
!   }
    
  ***************
! *** 439,444 ****
! --- 409,416 ----
    
!       ps.reset_column();
    
! +     ps.pubsync ();
! + 
!       return s;
    }
    
  ***************
! *** 454,465 ****
!   /* QueryOstream */
!   QueryOstream::QueryOstream(strstreambuf* base_stream0,
!   			   PrettyStreambuf* query_stream0,
! ! 			   stdiobuf* stdout_stream0,
! ! 			   stdiobuf* stderr_stream0)
! !     :
! ! #ifndef __GNUG__
! !      ios(query_stream0),
! ! #endif
!        PrettyOstream(query_stream0, NoError),
!        base_stream(base_stream0),
!        query_stream(query_stream0),
! --- 426,434 ----
!   /* QueryOstream */
!   QueryOstream::QueryOstream(strstreambuf* base_stream0,
!   			   PrettyStreambuf* query_stream0,
! ! 			   filebuf         *stdout_stream0,
! ! 			   filebuf         *stderr_stream0)
! !     :ios(query_stream0),
!        PrettyOstream(query_stream0, NoError),
!        base_stream(base_stream0),
!        query_stream(query_stream0),
! ***************
! *** 516,550 ****
    
!   ostream& QueryOstream::string_query_manip(const char* message)
!   {
! - #ifndef __GNUG__
! - #  define xsputn       sputn
! - #  define sync         pubsync
! - #  define seekoff(p,w) pubseekoff((p),(w), ios::out)
  - #endif
!       if(option_force_resolution && option_be_silent) {
!   	/* silence */
!       } else if(option_force_resolution) {
!   	*this << " -- " << default_input << prcsendl;
!   	string_val = PrConstCharPtrError(default_input);
! ! 	stderr_stream->xsputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stderr_stream->sync();
!       } else if(option_report_actions) {
!   	*this << " -- " << default_input << prcsendl;
!   	string_val = PrConstCharPtrError(default_input);
! ! 	stdout_stream->xsputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stdout_stream->sync();
!       } else {
!   	*this << "[" << default_input << "] " << message;
! ! 	query_stream->sync();
!   
!   	re_query_message = base_stream->str();
!   	re_query_len = base_stream->out_waiting();
!   
!   	while(true) {
! ! 	    stdout_stream->xsputn(re_query_message, re_query_len);
! ! 	    stdout_stream->sync();
!   
!   	    Dstring *ans = new Dstring; /* leak */
!   
! --- 485,514 ----
!   
!   ostream& QueryOstream::string_query_manip(const char* message)
!   {
!       if(option_force_resolution && option_be_silent) {
!   	/* silence */
!       } else if(option_force_resolution) {
!   	*this << " -- " << default_input << prcsendl;
!   	string_val = PrConstCharPtrError(default_input);
! ! 	stderr_stream->sputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stderr_stream->pubsync();
!       } else if(option_report_actions) {
!   	*this << " -- " << default_input << prcsendl;
!   	string_val = PrConstCharPtrError(default_input);
! ! 	stdout_stream->sputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stdout_stream->pubsync();
!       } else {
!   	*this << "[" << default_input << "] " << message;
! ! 	query_stream->pubsync();
!   
!   	re_query_message = base_stream->str();
!   	re_query_len = base_stream->out_waiting();
!   
!   	while(true) {
! ! 	    stdout_stream->sputn(re_query_message, re_query_len);
! ! 	    stdout_stream->pubsync();
!   
!   	    Dstring *ans = new Dstring; /* leak */
!   
  ***************
! *** 570,587 ****
!   
!       query_stream->reset_column();
!       base_stream->freeze(0);
! !     base_stream->seekoff(0, ios::beg);
!       option_count = 0;
!       force_option = 0;
!       bang_flag = NULL;
!       help_string = NULL;
    
+       return *this;
  - #ifndef __GNUG__
! - #  undef xsputn
! - #  undef sync
! - #  undef seekoff
! - #endif
!   }
    
!   ostream& QueryOstream::help_manip(const char* message)
! --- 534,546 ----
!   
!       query_stream->reset_column();
!       base_stream->freeze(0);
! !     base_stream->pubseekoff(0, ios::beg, ios::out);
!       option_count = 0;
!       force_option = 0;
!       bang_flag = NULL;
!       help_string = NULL;
!   
!       return *this;
!   }
!   
!   ostream& QueryOstream::help_manip(const char* message)
  ***************
! *** 592,602 ****
!   
!   ostream& QueryOstream::query_manip(const char* message)
!   {
! - #ifndef __GNUG__
! - #  define xsputn  sputn
! - #  define sync    pubsync
! - #  define seekoff(p,w) pubseekoff((p),(w), ios::out)
! - #endif
!       if(force_option != 0 && option_force_resolution) {
!           for (int i = 0; i < option_count; i += 1) {
!   	    if (force_option == options[i].let) {
! --- 551,556 ----
  ***************
! *** 611,634 ****
!   	val = options[default_option].val;
!       } else if(option_report_actions) {
!   	*this << report_message << dotendl;
! ! 	query_stream->sync();
! ! 	stdout_stream->xsputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stdout_stream->sync();
!   	val = options[default_option].val;
!       } else if(option_force_resolution) {
!   	*this << force_message << dotendl;
! ! 	query_stream->sync();
! ! 	stderr_stream->xsputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stderr_stream->sync();
!   	val = options[default_option].val;
!       } else if(bang_flag && bang_flag->flag) {
!   	*this << force_message << dotendl;
! ! 	query_stream->sync();
! ! 	stdout_stream->xsputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stdout_stream->sync();
!   	val = options[default_option].val;
!       } else {
!   	char query_buf[40];
! --- 565,588 ----
!   	val = options[default_option].val;
!       } else if(option_report_actions) {
!   	*this << report_message << dotendl;
! ! 	query_stream->pubsync();
! ! 	stdout_stream->sputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stdout_stream->pubsync();
!   	val = options[default_option].val;
!       } else if(option_force_resolution) {
!   	*this << force_message << dotendl;
! ! 	query_stream->pubsync();
! ! 	stderr_stream->sputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stderr_stream->pubsync();
!   	val = options[default_option].val;
!       } else if(bang_flag && bang_flag->flag) {
!   	*this << force_message << dotendl;
! ! 	query_stream->pubsync();
! ! 	stdout_stream->sputn(base_stream->str(),
!   			      base_stream->out_waiting());
! ! 	stdout_stream->pubsync();
!   	val = options[default_option].val;
!       } else {
!   	char query_buf[40];
! ***************
! *** 657,663 ****
    
!   	*this << message << query_buf;
    
! ! 	query_stream->sync();
    
!   	re_query_message = base_stream->str();
!   	re_query_len = base_stream->out_waiting();
! --- 611,617 ----
    
!   	*this << message << query_buf;
    
! ! 	query_stream->pubsync();
    
+   	re_query_message = base_stream->str();
+   	re_query_len = base_stream->out_waiting();
  ***************
! *** 666,673 ****
!   	    char c;
!   	    int found = false;
    
! ! 	    stdout_stream->xsputn(re_query_message, re_query_len);
! ! 	    stdout_stream->sync();
    
!   	    c = get_user_char();
    
! --- 620,627 ----
!   	    char c;
!   	    int found = false;
    
! ! 	    stdout_stream->sputn(re_query_message, re_query_len);
! ! 	    stdout_stream->pubsync();
    
!   	    c = get_user_char();
    
! ***************
! *** 718,735 ****
    
!       query_stream->reset_column();
!       base_stream->freeze(0);
! !     base_stream->seekoff(0, ios::beg);
!       force_option = 0;
!       option_count = 0;
!       bang_flag = NULL;
!       help_string = NULL;
    
!       return *this;
! - #ifndef __GNUG__
! - #  undef xsputn
! - #  undef sync
! - #  undef seekoff
! - #endif
!   }
!   
!   ostream& __omanip_query(ostream& s, const char* message) {
! --- 672,684 ----
!   
!       query_stream->reset_column();
!       base_stream->freeze(0);
! !     base_stream->pubseekoff(0, ios::beg, ios::out);
!       force_option = 0;
!       option_count = 0;
!       bang_flag = NULL;
!       help_string = NULL;
!   
!       return *this;
!   }
!   
!   ostream& __omanip_query(ostream& s, const char* message) {
! diff -c -r prcs-1.3.2/src/prcserror.tl prcs-1.3.2-patched/src/prcserror.tl
! *** prcs-1.3.2/src/prcserror.tl	Sun Oct 31 00:26:02 1999
! --- prcs-1.3.2-patched/src/prcserror.tl	Sun Sep  8 23:38:46 2002
  ***************
  *** 52,66 ****
    template class PrError<FileEntry*>;
***************
*** 923,925 ****
--- 928,945 ----
    
    MkTemplate(const char*);
    MkTemplate(CharAndStr);
+ diff -c -r prcs-1.3.2/src/regex.c prcs-1.3.2-patched/src/regex.c
+ *** prcs-1.3.2/src/regex.c	Mon Apr  8 04:19:50 2002
+ --- prcs-1.3.2-patched/src/regex.c	Sun Sep  8 23:48:35 2002
+ ***************
+ *** 298,304 ****
+ --- 298,306 ----
+   
+   /* Integer type for pointers.  */
+   # if !defined _LIBC
+ + #   if !defined __APPLE__
+   typedef unsigned long int uintptr_t;
+ + #   endif
+   # endif
+   
+   /* Should we use malloc or alloca?  If REG2EX2_MALLOC is not defined, we
