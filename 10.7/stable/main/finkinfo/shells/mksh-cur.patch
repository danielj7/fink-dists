Index: src/bin/mksh/Build.sh
diff -u src/bin/mksh/Build.sh:1.669.2.2 src/bin/mksh/Build.sh:1.672
--- src/bin/mksh/Build.sh:1.669.2.2	Sun Mar  1 15:42:50 2015
+++ src/bin/mksh/Build.sh	Mon Dec  8 12:20:40 2014
@@ -1,5 +1,5 @@
 #!/bin/sh
-srcversion='$MirOS: src/bin/mksh/Build.sh,v 1.669.2.2 2015/03/01 15:42:50 tg Exp $'
+srcversion='$MirOS: src/bin/mksh/Build.sh,v 1.672 2014/12/08 12:20:40 tg Exp $'
 #-
 # Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 #		2011, 2012, 2013, 2014
@@ -1784,7 +1784,7 @@
 		#define EXTERN
 		#define MKSH_INCLUDES_ONLY
 		#include "sh.h"
-		__RCSID("$MirOS: src/bin/mksh/Build.sh,v 1.669.2.2 2015/03/01 15:42:50 tg Exp $");
+		__RCSID("$MirOS: src/bin/mksh/Build.sh,v 1.672 2014/12/08 12:20:40 tg Exp $");
 		int main(void) { printf("Hello, World!\n"); return (isatty(0)); }
 EOF
 	case $cm in
@@ -2325,7 +2325,7 @@
 addsrcs USE_PRINTF_BUILTIN printf.c
 test 1 = "$USE_PRINTF_BUILTIN" && add_cppflags -DMKSH_PRINTF_BUILTIN
 test 1 = "$HAVE_CAN_VERB" && CFLAGS="$CFLAGS -verbose"
-add_cppflags -DMKSH_BUILD_R=505
+add_cppflags -DMKSH_BUILD_R=509
 
 $e $bi$me: Finished configuration testing, now producing output.$ao
 
Index: src/bin/mksh/check.pl
diff -u src/bin/mksh/check.pl:1.37 src/bin/mksh/check.pl:1.38
--- src/bin/mksh/check.pl:1.37	Tue Aug 19 07:43:32 2014
+++ src/bin/mksh/check.pl	Sun Mar  8 22:54:31 2015
@@ -1,8 +1,8 @@
-# $MirOS: src/bin/mksh/check.pl,v 1.37 2014/08/19 07:43:32 tg Exp $
+# $MirOS: src/bin/mksh/check.pl,v 1.38 2015/03/08 22:54:31 tg Exp $
 # $OpenBSD: th,v 1.1 2013/12/02 20:39:44 millert Exp $
 #-
 # Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011,
-#		2012, 2013, 2014
+#		2012, 2013, 2014, 2015
 #	Thorsten Glaser <tg@mirbsd.org>
 #
 # Provided that these terms and disclaimer and all copyright notices
@@ -568,7 +568,7 @@
 	}
 	push(@argv, $temps) if defined $test{'script'};
 
-	#XXX realpathise, use which/whence -p, or sth. like that
+	#XXX realpathise, use command -v/whence -p/which, or sth. like that
 	#XXX if !$program_kludge, we get by with not doing it for now tho
 	$new_env{'__progname'} = $argv[0];
 
Index: src/bin/mksh/check.t
diff -u src/bin/mksh/check.t:1.667.2.3 src/bin/mksh/check.t:1.687
--- src/bin/mksh/check.t:1.667.2.3	Sun Mar  1 15:42:51 2015
+++ src/bin/mksh/check.t	Fri Mar 20 23:37:52 2015
@@ -1,4 +1,4 @@
-# $MirOS: src/bin/mksh/check.t,v 1.667.2.3 2015/03/01 15:42:51 tg Exp $
+# $MirOS: src/bin/mksh/check.t,v 1.687 2015/03/20 23:37:52 tg Exp $
 # -*- mode: sh -*-
 #-
 # Copyright © 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
@@ -30,7 +30,7 @@
 # (2013/12/02 20:39:44) http://openbsd.cs.toronto.edu/cgi-bin/cvsweb/src/regress/bin/ksh/?sortby=date
 
 expected-stdout:
-	@(#)MIRBSD KSH R50 2015/03/01
+	@(#)MIRBSD KSH R50 2015/03/20
 description:
 	Check version of shell.
 stdin:
@@ -39,7 +39,7 @@
 category: shell:legacy-no
 ---
 expected-stdout:
-	@(#)LEGACY KSH R50 2015/03/01
+	@(#)LEGACY KSH R50 2015/03/20
 description:
 	Check version of legacy shell.
 stdin:
@@ -257,6 +257,19 @@
 expected-stdout:
 	hello world
 ---
+name: alias-11
+description:
+	Check that special argument handling still applies with escaped aliases
+stdin:
+	alias local='\typeset'
+	function foo {
+		local x=$1 y=z
+		print -r -- "$x,$y"
+	}
+	foo 'bar - baz'
+expected-stdout:
+	bar - baz,z
+---
 name: arith-lazy-1
 description:
 	Check that only one side of ternary operator is evaluated
@@ -4548,11 +4561,11 @@
 ---
 name: integer-base-check-numeric-from
 description:
-	Check behaviour for base one to 36, and that 37 errors out
+	Check behaviour for base one to 36, and that 37 degrades to 10
 stdin:
 	echo 1:$((1#1))0.
 	i=1
-	while (( ++i <= 36 )); do
+	while (( ++i <= 37 )); do
 		eval 'echo '$i':$(('$i'#10)).'
 	done
 	echo 37:$($__progname -c 'echo $((37#10))').$?:
@@ -4593,13 +4606,12 @@
 	34:34.
 	35:35.
 	36:36.
-	37:.0:
-expected-stderr-pattern:
-	/.*bad number '37#10'/
+	37:10.
+	37:10.0:
 ---
 name: integer-base-check-numeric-to
 description:
-	Check behaviour for base one to 36, and that 37 errors out
+	Check behaviour for base one to 36, and that 37 degrades to 10
 stdin:
 	i=0
 	while (( ++i <= 37 )); do
@@ -4644,9 +4656,7 @@
 	34:34#1U.64.
 	35:35#1T.64.
 	36:36#1S.64.
-	37:36#1S.64.
-expected-stderr-pattern:
-	/.*bad integer base: 37/
+	37:64.64.
 ---
 name: integer-arithmetic-span
 description:
@@ -7373,19 +7383,19 @@
 	alias
 	typeset -f
 expected-stdout:
-	autoload='typeset -fu'
-	functions='typeset -f'
-	hash='alias -t'
-	history='fc -l'
-	integer='typeset -i'
-	local=typeset
-	login='exec login'
-	nameref='typeset -n'
+	autoload='\typeset -fu'
+	functions='\typeset -f'
+	hash='\builtin alias -t'
+	history='\builtin fc -l'
+	integer='\typeset -i'
+	local='\typeset'
+	login='\exec login'
+	nameref='\typeset -n'
 	nohup='nohup '
-	r='fc -e -'
-	source='PATH=$PATH:. command .'
-	stop='kill -STOP'
-	type='whence -v'
+	r='\builtin fc -e -'
+	source='PATH=$PATH:. \command .'
+	stop='\kill -STOP'
+	type='\builtin whence -v'
 ---
 name: aliases-1-hartz4
 description:
@@ -7395,42 +7405,18 @@
 	alias
 	typeset -f
 expected-stdout:
-	autoload='typeset -fu'
-	functions='typeset -f'
-	hash='alias -t'
-	history='fc -l'
-	integer='typeset -i'
-	local=typeset
-	login='exec login'
-	nameref='typeset -n'
+	autoload='\typeset -fu'
+	functions='\typeset -f'
+	hash='\builtin alias -t'
+	history='\builtin fc -l'
+	integer='\typeset -i'
+	local='\typeset'
+	login='\exec login'
+	nameref='\typeset -n'
 	nohup='nohup '
-	r='fc -e -'
-	source='PATH=$PATH:. command .'
-	type='whence -v'
----
-name: aliases-2a
-description:
-	Check if “set -o sh” disables built-in aliases (except a few)
-category: disabled
-arguments: !-o!sh!
-stdin:
-	alias
-	typeset -f
-expected-stdout:
-	integer='typeset -i'
-	local=typeset
----
-name: aliases-3a
-description:
-	Check if running as sh disables built-in aliases (except a few)
-category: disabled
-stdin:
-	cp "$__progname" sh
-	./sh -c 'alias; typeset -f'
-	rm -f sh
-expected-stdout:
-	integer='typeset -i'
-	local=typeset
+	r='\builtin fc -e -'
+	source='PATH=$PATH:. \command .'
+	type='\builtin whence -v'
 ---
 name: aliases-2b
 description:
@@ -7441,19 +7427,19 @@
 	alias
 	typeset -f
 expected-stdout:
-	autoload='typeset -fu'
-	functions='typeset -f'
-	hash='alias -t'
-	history='fc -l'
-	integer='typeset -i'
-	local=typeset
-	login='exec login'
-	nameref='typeset -n'
+	autoload='\typeset -fu'
+	functions='\typeset -f'
+	hash='\builtin alias -t'
+	history='\builtin fc -l'
+	integer='\typeset -i'
+	local='\typeset'
+	login='\exec login'
+	nameref='\typeset -n'
 	nohup='nohup '
-	r='fc -e -'
-	source='PATH=$PATH:. command .'
-	stop='kill -STOP'
-	type='whence -v'
+	r='\builtin fc -e -'
+	source='PATH=$PATH:. \command .'
+	stop='\kill -STOP'
+	type='\builtin whence -v'
 ---
 name: aliases-3b
 description:
@@ -7464,19 +7450,19 @@
 	./sh -c 'alias; typeset -f'
 	rm -f sh
 expected-stdout:
-	autoload='typeset -fu'
-	functions='typeset -f'
-	hash='alias -t'
-	history='fc -l'
-	integer='typeset -i'
-	local=typeset
-	login='exec login'
-	nameref='typeset -n'
+	autoload='\typeset -fu'
+	functions='\typeset -f'
+	hash='\builtin alias -t'
+	history='\builtin fc -l'
+	integer='\typeset -i'
+	local='\typeset'
+	login='\exec login'
+	nameref='\typeset -n'
 	nohup='nohup '
-	r='fc -e -'
-	source='PATH=$PATH:. command .'
-	stop='kill -STOP'
-	type='whence -v'
+	r='\builtin fc -e -'
+	source='PATH=$PATH:. \command .'
+	stop='\kill -STOP'
+	type='\builtin whence -v'
 ---
 name: aliases-2b-hartz4
 description:
@@ -7487,18 +7473,18 @@
 	alias
 	typeset -f
 expected-stdout:
-	autoload='typeset -fu'
-	functions='typeset -f'
-	hash='alias -t'
-	history='fc -l'
-	integer='typeset -i'
-	local=typeset
-	login='exec login'
-	nameref='typeset -n'
+	autoload='\typeset -fu'
+	functions='\typeset -f'
+	hash='\builtin alias -t'
+	history='\builtin fc -l'
+	integer='\typeset -i'
+	local='\typeset'
+	login='\exec login'
+	nameref='\typeset -n'
 	nohup='nohup '
-	r='fc -e -'
-	source='PATH=$PATH:. command .'
-	type='whence -v'
+	r='\builtin fc -e -'
+	source='PATH=$PATH:. \command .'
+	type='\builtin whence -v'
 ---
 name: aliases-3b-hartz4
 description:
@@ -7509,18 +7495,18 @@
 	./sh -c 'alias; typeset -f'
 	rm -f sh
 expected-stdout:
-	autoload='typeset -fu'
-	functions='typeset -f'
-	hash='alias -t'
-	history='fc -l'
-	integer='typeset -i'
-	local=typeset
-	login='exec login'
-	nameref='typeset -n'
+	autoload='\typeset -fu'
+	functions='\typeset -f'
+	hash='\builtin alias -t'
+	history='\builtin fc -l'
+	integer='\typeset -i'
+	local='\typeset'
+	login='\exec login'
+	nameref='\typeset -n'
 	nohup='nohup '
-	r='fc -e -'
-	source='PATH=$PATH:. command .'
-	type='whence -v'
+	r='\builtin fc -e -'
+	source='PATH=$PATH:. \command .'
+	type='\builtin whence -v'
 ---
 name: aliases-cmdline
 description:
@@ -7536,6 +7522,20 @@
 name: aliases-funcdef-1
 description:
 	Check if POSIX functions take precedences over aliases
+category: shell:legacy-no
+stdin:
+	alias foo='echo makro'
+	foo() {
+		echo funktion
+	}
+	foo
+expected-stdout:
+	makro
+---
+name: aliases-funcdef-1-legacy
+description:
+	Check if POSIX functions take precedences over aliases
+category: shell:legacy-yes
 stdin:
 	alias foo='echo makro'
 	foo() {
@@ -7548,6 +7548,20 @@
 name: aliases-funcdef-2
 description:
 	Check if POSIX functions take precedences over aliases
+category: shell:legacy-no
+stdin:
+	alias foo='echo makro'
+	foo () {
+		echo funktion
+	}
+	foo
+expected-stdout:
+	makro
+---
+name: aliases-funcdef-2-legacy
+description:
+	Check if POSIX functions take precedences over aliases
+category: shell:legacy-yes
 stdin:
 	alias foo='echo makro'
 	foo () {
@@ -7577,8 +7591,8 @@
 	:|| local() { :; }
 	alias local
 expected-stdout:
-	local=typeset
-	local=typeset
+	local='\typeset'
+	local='\typeset'
 ---
 name: arrays-1
 description:
@@ -8713,28 +8727,87 @@
 expected-stderr-pattern:
 	/\.: missing argument.*\n.*\.: missing argument/
 ---
-name: alias-function-no-conflict
+name: alias-function-no-conflict-legacy
 description:
-	make aliases not conflict with functions
-	note: for ksh-like functions, the order of preference is
-	different; bash outputs baz instead of bar in line 2 below
+	make aliases not conflict with functions, legacy version:
+	undefine these aliases upon definition of the function
+	note: for ksh functions, the order of preference differs in GNU bash
+category: shell:legacy-yes
 stdin:
+	# POSIX function overrides and removes alias
 	alias foo='echo bar'
+	foo
 	foo() {
 		echo baz
 	}
+	foo
+	unset -f foo
+	foo 2>/dev/null || echo rab
+	# alias overrides ksh function
 	alias korn='echo bar'
+	korn
 	function korn {
 		echo baz
 	}
-	foo
 	korn
+	# alias temporarily overrides POSIX function
+	bla() {
+		echo bfn
+	}
+	bla
+	alias bla='echo bal'
+	bla
+	unalias bla
+	bla
+expected-stdout:
+	bar
+	baz
+	rab
+	bar
+	bar
+	bfn
+	bal
+	bfn
+---
+name: alias-function-no-conflict
+description:
+	make aliases not conflict with function definitions
+category: shell:legacy-no
+stdin:
+	# POSIX function can be defined, but alias overrides it
+	alias foo='echo bar'
+	foo
+	foo() {
+		echo baz
+	}
+	foo
 	unset -f foo
 	foo 2>/dev/null || echo rab
+	# alias overrides ksh function
+	alias korn='echo bar'
+	korn
+	function korn {
+		echo baz
+	}
+	korn
+	# alias temporarily overrides POSIX function
+	bla() {
+		echo bfn
+	}
+	bla
+	alias bla='echo bal'
+	bla
+	unalias bla
+	bla
 expected-stdout:
-	baz
 	bar
-	rab
+	bar
+	bar
+	bar
+	bar
+	bfn
+	bal
+	bfn
 ---
 name: bash-function-parens
 description:
@@ -8746,12 +8819,13 @@
 		echo "$1 {"
 		echo '	echo "bar='\''$0'\'\"
 		echo '}'
-		echo ${2:-foo}
+		print -r -- "${2:-foo}"
 	}
 	mk 'function foo' >f-korn
 	mk 'foo ()' >f-dash
 	mk 'function foo ()' >f-bash
-	mk 'function stop ()' stop >f-stop
+	# lksh can do without the backslash, too (cf. aliases-funcdef-2-legacy)
+	mk 'function stop ()' '\stop' >f-stop
 	print '#!'"$__progname"'\nprint -r -- "${0%/f-argh}"' >f-argh
 	chmod +x f-*
 	u=$(./f-argh)
@@ -9770,25 +9844,33 @@
 	Verify that file descriptors > 2 are private for Korn shells
 	AT&T ksh93 does this still, which means we must keep it as well
 category: shell:legacy-no
-file-setup: file 644 "test.sh"
-	echo >&3 Fowl
 stdin:
-	exec 3>&1
-	"$__progname" test.sh
+	cat >cld <<-EOF
+		#!$__perlname
+		open(my \$fh, ">&", 9) or die "E: open \$!";
+		syswrite(\$fh, "Fowl\\n", 5) or die "E: write \$!";
+	EOF
+	chmod +x cld
+	exec 9>&1
+	./cld
 expected-exit: e != 0
 expected-stderr-pattern:
-	/bad file descriptor/
+	/E: open /
 ---
 name: fd-cloexec-2
 description:
 	Verify that file descriptors > 2 are not private for POSIX shells
 	See Debian Bug #154540, Closes: #499139
-file-setup: file 644 "test.sh"
-	echo >&3 Fowl
 stdin:
-	test -n "$POSH_VERSION" || set -o sh
-	exec 3>&1
-	"$__progname" test.sh
+	cat >cld <<-EOF
+		#!$__perlname
+		open(my \$fh, ">&", 9) or die "E: open \$!";
+		syswrite(\$fh, "Fowl\\n", 5) or die "E: write \$!";
+	EOF
+	chmod +x cld
+	test -n "$POSH_VERSION" || set -o posix
+	exec 9>&1
+	./cld
 expected-stdout:
 	Fowl
 ---
@@ -9796,11 +9878,15 @@
 description:
 	Verify that file descriptors > 2 are not private for LEGACY KSH
 category: shell:legacy-yes
-file-setup: file 644 "test.sh"
-	echo >&3 Fowl
 stdin:
-	exec 3>&1
-	"$__progname" test.sh
+	cat >cld <<-EOF
+		#!$__perlname
+		open(my \$fh, ">&", 9) or die "E: open \$!";
+		syswrite(\$fh, "Fowl\\n", 5) or die "E: write \$!";
+	EOF
+	chmod +x cld
+	exec 9>&1
+	./cld
 expected-stdout:
 	Fowl
 ---
@@ -10180,7 +10266,7 @@
 	}
 	inline_TWHILE() {
 		i=1 
-		while let] " i < 10 " 
+		while \let] " i < 10 " 
 		do
 			echo $i 
 			let ++i 
@@ -10190,20 +10276,20 @@
 		i=1; while (( i < 10 )); do echo $i; let ++i; done
 	); }
 	function comsub_TWHILE {
-		x=$(i=1 ; while let] " i < 10 " ; do echo $i ; let ++i ; done ) 
+		x=$(i=1 ; while \let] " i < 10 " ; do echo $i ; let ++i ; done ) 
 	} 
 	function reread_TWHILE { x=$((
 		i=1; while (( i < 10 )); do echo $i; let ++i; done
 	)|tr u x); }
 	function reread_TWHILE {
-		x=$(( i=1 ; while let] " i < 10 " ; do echo $i ; let ++i ; done ) | tr u x ) 
+		x=$(( i=1 ; while \let] " i < 10 " ; do echo $i ; let ++i ; done ) | tr u x ) 
 	} 
 	inline_TUNTIL() {
 		i=10; until  (( !--i )) ; do echo $i; done
 	}
 	inline_TUNTIL() {
 		i=10 
-		until let] " !--i " 
+		until \let] " !--i " 
 		do
 			echo $i 
 		done 
@@ -10212,13 +10298,13 @@
 		i=10; until  (( !--i )) ; do echo $i; done
 	); }
 	function comsub_TUNTIL {
-		x=$(i=10 ; until let] " !--i " ; do echo $i ; done ) 
+		x=$(i=10 ; until \let] " !--i " ; do echo $i ; done ) 
 	} 
 	function reread_TUNTIL { x=$((
 		i=10; until  (( !--i )) ; do echo $i; done
 	)|tr u x); }
 	function reread_TUNTIL {
-		x=$(( i=10 ; until let] " !--i " ; do echo $i ; done ) | tr u x ) 
+		x=$(( i=10 ; until \let] " !--i " ; do echo $i ; done ) | tr u x ) 
 	} 
 	inline_TCOPROC() {
 		cat  *  |&  ls
@@ -10594,7 +10680,7 @@
 		case x in
 		(x)
 			a+=b 
-			set -A c+ -- d e 
+			\set -A c+ -- d e 
 			;;
 		esac 
 	} 
@@ -10604,7 +10690,7 @@
 		esac
 	); }
 	function comsub_wdarrassign {
-		x=$(case x in (x) a+=b ; set -A c+ -- d e  ;; esac ) 
+		x=$(case x in (x) a+=b ; \set -A c+ -- d e  ;; esac ) 
 	} 
 	function reread_wdarrassign { x=$((
 		case x in
@@ -10612,7 +10698,7 @@
 		esac
 	)|tr u x); }
 	function reread_wdarrassign {
-		x=$(( case x in (x) a+=b ; set -A c+ -- d e  ;; esac ) | tr u x ) 
+		x=$(( case x in (x) a+=b ; \set -A c+ -- d e  ;; esac ) | tr u x ) 
 	} 
 ---
 name: comsub-torture-io
@@ -10832,7 +10918,7 @@
 	}
 	inline_TWHILE() {
 		i=1 
-		while let] " i < 10 " >&3 
+		while \let] " i < 10 " >&3 
 		do
 			echo $i 
 			let ++i 
@@ -10842,20 +10928,20 @@
 		i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
 	); }
 	function comsub_TWHILE {
-		x=$(i=1 ; while let] " i < 10 " >&3 ; do echo $i ; let ++i ; done >&3 ) 
+		x=$(i=1 ; while \let] " i < 10 " >&3 ; do echo $i ; let ++i ; done >&3 ) 
 	} 
 	function reread_TWHILE { x=$((
 		i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
 	)|tr u x); }
 	function reread_TWHILE {
-		x=$(( i=1 ; while let] " i < 10 " >&3 ; do echo $i ; let ++i ; done >&3 ) | tr u x ) 
+		x=$(( i=1 ; while \let] " i < 10 " >&3 ; do echo $i ; let ++i ; done >&3 ) | tr u x ) 
 	} 
 	inline_TUNTIL() {
 		i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
 	}
 	inline_TUNTIL() {
 		i=10 
-		until let] " !--i " >&3 
+		until \let] " !--i " >&3 
 		do
 			echo $i 
 		done >&3 
@@ -10864,13 +10950,13 @@
 		i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
 	); }
 	function comsub_TUNTIL {
-		x=$(i=10 ; until let] " !--i " >&3 ; do echo $i ; done >&3 ) 
+		x=$(i=10 ; until \let] " !--i " >&3 ; do echo $i ; done >&3 ) 
 	} 
 	function reread_TUNTIL { x=$((
 		i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
 	)|tr u x); }
 	function reread_TUNTIL {
-		x=$(( i=10 ; until let] " !--i " >&3 ; do echo $i ; done >&3 ) | tr u x ) 
+		x=$(( i=10 ; until \let] " !--i " >&3 ; do echo $i ; done >&3 ) | tr u x ) 
 	} 
 	inline_TCOPROC() {
 		cat  *  >&3 |&  >&3 ls
Index: src/bin/mksh/dot.mkshrc
diff -u src/bin/mksh/dot.mkshrc:1.89.2.1 src/bin/mksh/dot.mkshrc:1.94
--- src/bin/mksh/dot.mkshrc:1.89.2.1	Sun Jan 11 22:39:44 2015
+++ src/bin/mksh/dot.mkshrc	Sat Mar 14 05:23:14 2015
@@ -1,5 +1,5 @@
 # $Id$
-# $MirOS: src/bin/mksh/dot.mkshrc,v 1.89.2.1 2015/01/11 22:39:44 tg Exp $
+# $MirOS: src/bin/mksh/dot.mkshrc,v 1.94 2015/03/14 05:23:14 tg Exp $
 #-
 # Copyright (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2010,
 #		2011, 2012, 2013, 2014, 2015
@@ -25,123 +25,123 @@
 # catch non-mksh (including lksh) trying to shell this file
 case $KSH_VERSION in
 *MIRBSD\ KSH*) ;;
-*) return 0 ;;
+*) \return 0 ;;
 esac
 
-PS1='#'; (( USER_ID )) && PS1='$'; [[ ${HOSTNAME:=$(ulimit -c 0; hostname -s \
-    2>/dev/null)} = *([	 ]|localhost) ]] && HOSTNAME=$(ulimit -c 0; hostname \
-    2>/dev/null); : ${EDITOR:=/bin/ed} ${HOSTNAME:=nil} ${TERM:=vt100}
-: ${MKSH:=$(whence -p mksh)}; PS4='[$EPOCHREALTIME] '; PS1=$'\001\r''${|
-	local e=$?
+PS1='#'; (( USER_ID )) && PS1='$'; [[ ${HOSTNAME:=$(\ulimit -c 0; hostname -s \
+    2>/dev/null)} = *([	 ]|localhost) ]] && HOSTNAME=$(\ulimit -c 0; hostname \
+    2>/dev/null); \: ${EDITOR:=/bin/ed} ${HOSTNAME:=nil} ${TERM:=vt100}
+\: ${MKSH:=$(\builtin whence -p mksh)}; PS4='[$EPOCHREALTIME] '; PS1=$'\001\r''${|
+	\typeset e=$?
 
 	(( e )) && REPLY+="$e|"
-	REPLY+=${USER:=$(ulimit -c 0; id -un 2>/dev/null || echo \?)}
+	REPLY+=${USER:=$(\ulimit -c 0; id -un 2>/dev/null || \echo \?)}
 	REPLY+=@${HOSTNAME%%.*}:
 
-	local d=${PWD:-?} p=~; [[ $p = ?(*/) ]] || d=${d/#$p/~}
-	local m=${%d} n p=...; (( m > 0 )) || m=${#d}
+	\typeset d=${PWD:-?} p=~; [[ $p = ?(*/) ]] || d=${d/#$p/~}
+	\typeset m=${%d} n p=...; (( m > 0 )) || m=${#d}
 	(( m > (n = (COLUMNS/3 < 7 ? 7 : COLUMNS/3)) )) && d=${d:(-n)} || p=
 	REPLY+=$p$d
 
-	return $e
-} '"$PS1 "; export EDITOR HOSTNAME MKSH TERM USER
-alias ls=ls
-unalias ls
-alias l='ls -F'
-alias la='l -a'
-alias ll='l -l'
-alias lo='l -alo'
-alias doch='sudo mksh -c "$(fc -ln -1)"'
-whence -p rot13 >/dev/null || alias rot13='tr \
+	\return $e
+} '"$PS1 "; \export EDITOR HOSTNAME MKSH TERM USER
+\alias ls=ls
+\unalias ls
+\alias l='ls -F'
+\alias la='l -a'
+\alias ll='l -l'
+\alias lo='l -alo'
+\alias doch='sudo mksh -c "$(\builtin fc -ln -1)"'
+\command -v rot13 >/dev/null || \alias rot13='tr \
     abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ \
     nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM'
-if whence -p hd >/dev/null; then :; elif whence -p hexdump >/dev/null; then
+if \command -v hd >/dev/null; then \:; elif \command -v hexdump >/dev/null; then
 	function hd {
 		hexdump -e '"%08.8_ax  " 8/1 "%02X " " - " 8/1 "%02X "' \
 		    -e '"  |" "%_p"' -e '"|\n"' "$@"
 	}
 else
 	function hd {
-		local -Uui16 -Z11 pos=0
-		local -Uui16 -Z5 hv=2147483647
-		local dasc line i
+		\typeset -Uui16 -Z11 pos=0
+		\typeset -Uui16 -Z5 hv=2147483647
+		\typeset dasc line i
 
-		cat "$@" | { set +U; if read -arN -1 line; then
-			typeset -i1 'line[*]'
+		\cat "$@" | { \set +U; if \read -arN -1 line; then
+			\typeset -i1 'line[*]'
 			i=0
 			while (( i < ${#line[*]} )); do
 				hv=${line[i++]}
 				if (( (pos & 15) == 0 )); then
-					(( pos )) && print -r -- "$dasc|"
-					print -n "${pos#16#}  "
+					(( pos )) && \builtin print -r -- "$dasc|"
+					\builtin print -n "${pos#16#}  "
 					dasc=' |'
 				fi
-				print -n "${hv#16#} "
+				\builtin print -n "${hv#16#} "
 				if (( (hv < 32) || (hv > 126) )); then
 					dasc+=.
 				else
 					dasc+=${line[i-1]#1#}
 				fi
-				(( (pos++ & 15) == 7 )) && print -n -- '- '
+				(( (pos++ & 15) == 7 )) && \builtin print -n -- '- '
 			done
 			while (( pos & 15 )); do
-				print -n '   '
-				(( (pos++ & 15) == 7 )) && print -n -- '- '
+				\builtin print -n '   '
+				(( (pos++ & 15) == 7 )) && \builtin print -n -- '- '
 			done
-			(( hv == 2147483647 )) || print -r -- "$dasc|"
+			(( hv == 2147483647 )) || \builtin print -r -- "$dasc|"
 		fi; }
 	}
 fi
 
 # Berkeley C shell compatible dirs, popd, and pushd functions
 # Z shell compatible chpwd() hook, used to update DIRSTACK[0]
-DIRSTACKBASE=$(realpath ~/. 2>/dev/null || print -nr -- "${HOME:-/}")
+DIRSTACKBASE=$(\builtin realpath ~/. 2>/dev/null || \builtin print -nr -- "${HOME:-/}")
 set -A DIRSTACK
 function chpwd {
-	DIRSTACK[0]=$(realpath . 2>/dev/null || print -r -- "$PWD")
+	DIRSTACK[0]=$(\builtin realpath . 2>/dev/null || \builtin print -r -- "$PWD")
 	[[ $DIRSTACKBASE = ?(*/) ]] || \
 	    DIRSTACK[0]=${DIRSTACK[0]/#$DIRSTACKBASE/~}
-	:
+	\:
 }
-chpwd .
+\chpwd .
 function cd {
-	builtin cd "$@" || return $?
-	chpwd "$@"
+	\builtin cd "$@" || \return $?
+	\chpwd "$@"
 }
 function cd_csh {
-	local d t=${1/#~/$DIRSTACKBASE}
+	\typeset d t=${1/#~/$DIRSTACKBASE}
 
-	if ! d=$(builtin cd "$t" 2>&1); then
-		print -u2 "${1}: ${d##*cd: $t: }."
-		return 1
+	if ! d=$(\builtin cd "$t" 2>&1); then
+		\builtin print -u2 "${1}: ${d##*cd: $t: }."
+		\return 1
 	fi
-	cd "$t"
+	\cd "$t"
 }
 function dirs {
-	local d dwidth
-	local -i fl=0 fv=0 fn=0 cpos=0
+	\typeset d dwidth
+	\typeset -i fl=0 fv=0 fn=0 cpos=0
 
-	while getopts ":lvn" d; do
+	while \getopts ":lvn" d; do
 		case $d {
 		(l)	fl=1 ;;
 		(v)	fv=1 ;;
 		(n)	fn=1 ;;
-		(*)	print -u2 'Usage: dirs [-lvn].'
-			return 1 ;;
+		(*)	\builtin print -u2 'Usage: dirs [-lvn].'
+			\return 1 ;;
 		}
 	done
-	shift $((OPTIND - 1))
+	\shift $((OPTIND - 1))
 	if (( $# > 0 )); then
-		print -u2 'Usage: dirs [-lvn].'
-		return 1
+		\builtin print -u2 'Usage: dirs [-lvn].'
+		\return 1
 	fi
 	if (( fv )); then
 		fv=0
 		while (( fv < ${#DIRSTACK[*]} )); do
 			d=${DIRSTACK[fv]}
 			(( fl )) && d=${d/#~/$DIRSTACKBASE}
-			print -r -- "$fv	$d"
-			let fv++
+			\builtin print -r -- "$fv	$d"
+			\builtin let fv++
 		done
 	else
 		fv=0
@@ -151,138 +151,138 @@
 			(( dwidth = (${%d} > 0 ? ${%d} : ${#d}) ))
 			if (( fn && (cpos += dwidth + 1) >= 79 && \
 			    dwidth < 80 )); then
-				print
+				\builtin print
 				(( cpos = dwidth + 1 ))
 			fi
-			print -nr -- "$d "
-			let fv++
+			\builtin print -nr -- "$d "
+			\builtin let fv++
 		done
-		print
+		\builtin print
 	fi
-	return 0
+	\return 0
 }
 function popd {
-	local d fa
-	local -i n=1
+	\typeset d fa
+	\typeset -i n=1
 
-	while getopts ":0123456789lvn" d; do
+	while \getopts ":0123456789lvn" d; do
 		case $d {
 		(l|v|n)	fa+=" -$d" ;;
 		(+*)	n=2
-			break ;;
-		(*)	print -u2 'Usage: popd [-lvn] [+<n>].'
-			return 1 ;;
+			\break ;;
+		(*)	\builtin print -u2 'Usage: popd [-lvn] [+<n>].'
+			\return 1 ;;
 		}
 	done
-	shift $((OPTIND - n))
+	\shift $((OPTIND - n))
 	n=0
 	if (( $# > 1 )); then
-		print -u2 popd: Too many arguments.
-		return 1
+		\builtin print -u2 popd: Too many arguments.
+		\return 1
 	elif [[ $1 = ++([0-9]) && $1 != +0 ]]; then
 		if (( (n = ${1#+}) >= ${#DIRSTACK[*]} )); then
-			print -u2 popd: Directory stack not that deep.
-			return 1
+			\builtin print -u2 popd: Directory stack not that deep.
+			\return 1
 		fi
 	elif [[ -n $1 ]]; then
-		print -u2 popd: Bad directory.
-		return 1
+		\builtin print -u2 popd: Bad directory.
+		\return 1
 	fi
 	if (( ${#DIRSTACK[*]} < 2 )); then
-		print -u2 popd: Directory stack empty.
-		return 1
+		\builtin print -u2 popd: Directory stack empty.
+		\return 1
 	fi
-	unset DIRSTACK[n]
-	set -A DIRSTACK -- "${DIRSTACK[@]}"
-	cd_csh "${DIRSTACK[0]}" || return 1
-	dirs $fa
+	\unset DIRSTACK[n]
+	\set -A DIRSTACK -- "${DIRSTACK[@]}"
+	\cd_csh "${DIRSTACK[0]}" || \return 1
+	\dirs $fa
 }
 function pushd {
-	local d fa
-	local -i n=1
+	\typeset d fa
+	\typeset -i n=1
 
-	while getopts ":0123456789lvn" d; do
+	while \getopts ":0123456789lvn" d; do
 		case $d {
 		(l|v|n)	fa+=" -$d" ;;
 		(+*)	n=2
-			break ;;
-		(*)	print -u2 'Usage: pushd [-lvn] [<dir>|+<n>].'
-			return 1 ;;
+			\break ;;
+		(*)	\builtin print -u2 'Usage: pushd [-lvn] [<dir>|+<n>].'
+			\return 1 ;;
 		}
 	done
-	shift $((OPTIND - n))
+	\shift $((OPTIND - n))
 	if (( $# == 0 )); then
 		if (( ${#DIRSTACK[*]} < 2 )); then
-			print -u2 pushd: No other directory.
-			return 1
+			\builtin print -u2 pushd: No other directory.
+			\return 1
 		fi
 		d=${DIRSTACK[1]}
 		DIRSTACK[1]=${DIRSTACK[0]}
-		cd_csh "$d" || return 1
+		\cd_csh "$d" || \return 1
 	elif (( $# > 1 )); then
-		print -u2 pushd: Too many arguments.
-		return 1
+		\builtin print -u2 pushd: Too many arguments.
+		\return 1
 	elif [[ $1 = ++([0-9]) && $1 != +0 ]]; then
 		if (( (n = ${1#+}) >= ${#DIRSTACK[*]} )); then
-			print -u2 pushd: Directory stack not that deep.
-			return 1
+			\builtin print -u2 pushd: Directory stack not that deep.
+			\return 1
 		fi
 		while (( n-- )); do
 			d=${DIRSTACK[0]}
-			unset DIRSTACK[0]
-			set -A DIRSTACK -- "${DIRSTACK[@]}" "$d"
+			\unset DIRSTACK[0]
+			\set -A DIRSTACK -- "${DIRSTACK[@]}" "$d"
 		done
-		cd_csh "${DIRSTACK[0]}" || return 1
+		\cd_csh "${DIRSTACK[0]}" || \return 1
 	else
-		set -A DIRSTACK -- placeholder "${DIRSTACK[@]}"
-		cd_csh "$1" || return 1
+		\set -A DIRSTACK -- placeholder "${DIRSTACK[@]}"
+		\cd_csh "$1" || \return 1
 	fi
-	dirs $fa
+	\dirs $fa
 }
 
 # pager (not control character safe)
 function smores {
 	(
-		set +m
-		cat "$@" |&
-		trap "rv=\$?; kill $! >/dev/null 2>&1; exit \$rv" EXIT
-		while IFS= read -pr line; do
+		\set +m
+		\cat "$@" |&
+		\trap "rv=\$?; 'kill' $! >/dev/null 2>&1; 'exit' \$rv" EXIT
+		while IFS= \read -pr line; do
 			llen=${%line}
 			(( llen == -1 )) && llen=${#line}
 			(( llen = llen ? (llen + COLUMNS - 1) / COLUMNS : 1 ))
 			if (( (curlin += llen) >= LINES )); then
-				print -n -- '\033[7m--more--\033[0m'
-				read -u1 || exit $?
-				[[ $REPLY = [Qq]* ]] && exit 0
+				\builtin print -n -- '\033[7m--more--\033[0m'
+				\read -u1 || \exit $?
+				[[ $REPLY = [Qq]* ]] && \exit 0
 				curlin=$llen
 			fi
-			print -r -- "$line"
+			\builtin print -r -- "$line"
 		done
 	)
 }
 
 # base64 encoder and decoder, RFC compliant, NUL safe
 function Lb64decode {
-	[[ -o utf8-mode ]]; local u=$? c s="$*" t
-	set +U
-	[[ -n $s ]] || { s=$(cat; print x); s=${s%x}; }
-	local -i i=0 j=0 n=${#s} p=0 v x
-	local -i16 o
+	[[ -o utf8-mode ]]; \typeset u=$? c s="$*" t
+	\set +U
+	[[ -n $s ]] || { s=$(\cat; \builtin print x); s=${s%x}; }
+	\typeset -i i=0 j=0 n=${#s} p=0 v x
+	\typeset -i16 o
 
 	while (( i < n )); do
 		c=${s:(i++):1}
 		case $c {
-		(=)	break ;;
+		(=)	\break ;;
 		([A-Z])	(( v = 1#$c - 65 )) ;;
 		([a-z])	(( v = 1#$c - 71 )) ;;
 		([0-9])	(( v = 1#$c + 4 )) ;;
 		(+)	v=62 ;;
 		(/)	v=63 ;;
-		(*)	continue ;;
+		(*)	\continue ;;
 		}
 		(( x = (x << 6) | v ))
 		case $((p++)) {
-		(0)	continue ;;
+		(0)	\continue ;;
 		(1)	(( o = (x >> 4) & 255 )) ;;
 		(2)	(( o = (x >> 2) & 255 )) ;;
 		(3)	(( o = x & 255 ))
@@ -290,26 +290,26 @@
 			;;
 		}
 		t+=\\x${o#16#}
-		(( ++j & 4095 )) && continue
-		print -n $t
+		(( ++j & 4095 )) && \continue
+		\builtin print -n $t
 		t=
 	done
-	print -n $t
-	(( u )) || set -U
+	\builtin print -n $t
+	(( u )) || \set -U
 }
 
-set -A Lb64encode_code -- A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
+\set -A Lb64encode_code -- A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
     a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 + /
 function Lb64encode {
-	[[ -o utf8-mode ]]; local u=$? c s t
-	set +U
+	[[ -o utf8-mode ]]; \typeset u=$? c s t
+	\set +U
 	if (( $# )); then
-		read -raN-1 s <<<"$*"
-		unset s[${#s[*]}-1]
+		\read -raN-1 s <<<"$*"
+		\unset s[${#s[*]}-1]
 	else
-		read -raN-1 s
+		\read -raN-1 s
 	fi
-	local -i i=0 n=${#s[*]} j v
+	\typeset -i i=0 n=${#s[*]} j v
 
 	while (( i < n )); do
 		(( v = s[i++] << 16 ))
@@ -327,76 +327,267 @@
 			t+===
 		fi
 		if (( ${#t} == 76 || i >= n )); then
-			print $t
+			\builtin print $t
 			t=
 		fi
 	done
-	(( u )) || set -U
+	(( u )) || \set -U
 }
 
 # Better Avalanche for the Jenkins Hash
-typeset -Z11 -Uui16 Lbafh_v
+\typeset -Z11 -Uui16 Lbafh_v
 function Lbafh_init {
 	Lbafh_v=0
 }
 function Lbafh_add {
-	[[ -o utf8-mode ]]; local u=$? s
-	set +U
+	[[ -o utf8-mode ]]; \typeset u=$? s
+	\set +U
 	if (( $# )); then
-		read -raN-1 s <<<"$*"
-		unset s[${#s[*]}-1]
+		\read -raN-1 s <<<"$*"
+		\unset s[${#s[*]}-1]
 	else
-		read -raN-1 s
+		\read -raN-1 s
 	fi
-	local -i i=0 n=${#s[*]}
+	\typeset -i i=0 n=${#s[*]}
 
 	while (( i < n )); do
 		((# Lbafh_v = (Lbafh_v + s[i++] + 1) * 1025 ))
 		((# Lbafh_v ^= Lbafh_v >> 6 ))
 	done
 
-	(( u )) || set -U
+	(( u )) || \set -U
 }
 function Lbafh_finish {
-	local -Ui t
+	\typeset -Ui t
 
 	((# t = (((Lbafh_v >> 7) & 0x01010101) * 0x1B) ^ \
 	    ((Lbafh_v << 1) & 0xFEFEFEFE) ))
 	((# Lbafh_v = t ^ (t >>> 8) ^ (Lbafh_v >>> 8) ^ \
 	    (Lbafh_v >>> 16) ^ (Lbafh_v >>> 24) ))
-	:
+	\:
 }
 
 # strip comments (and leading/trailing whitespace if IFS is set) from
 # any file(s) given as argument, or stdin if none, and spew to stdout
 function Lstripcom {
-	cat "$@" | { set -o noglob; while read _line; do
+	\cat "$@" | { \set -o noglob; while \read _line; do
 		_line=${_line%%#*}
-		[[ -n $_line ]] && print -r -- $_line
+		[[ -n $_line ]] && \builtin print -r -- $_line
 	done; }
 }
 
 # give MidnightBSD's laffer1 a bit of csh feeling
 function setenv {
-	eval export "\"$1\""'="$2"'
+	\eval "'export' \"$1\""'="$2"'
 }
 
-: place customisations below this line
+# toggle built-in aliases and utilities, and aliases and functions from here
+function enable {
+	\typeset doprnt=0 mode=1 x y z rv=0
+	\typeset b_alias i_alias i_func nalias=0 nfunc=0 i_all
+	\set -A b_alias
+	\set -A i_alias
+	\set -A i_func
+
+	# accumulate mksh built-in aliases, in ASCIIbetical order
+	i_alias[nalias]=autoload; b_alias[nalias++]='\typeset -fu'
+	i_alias[nalias]=functions; b_alias[nalias++]='\typeset -f'
+	i_alias[nalias]=hash; b_alias[nalias++]='\builtin alias -t'
+	i_alias[nalias]=history; b_alias[nalias++]='\builtin fc -l'
+	i_alias[nalias]=integer; b_alias[nalias++]='\typeset -i'
+	i_alias[nalias]=local; b_alias[nalias++]='\typeset'
+	i_alias[nalias]=login; b_alias[nalias++]='\exec login'
+	i_alias[nalias]=nameref; b_alias[nalias++]='\typeset -n'
+	i_alias[nalias]=nohup; b_alias[nalias++]='nohup '
+	i_alias[nalias]=r; b_alias[nalias++]='\builtin fc -e -'
+	i_alias[nalias]=source; b_alias[nalias++]='PATH=$PATH:. \command .'
+	i_alias[nalias]=stop; b_alias[nalias++]='\kill -STOP'
+	i_alias[nalias]=type; b_alias[nalias++]='\builtin whence -v'
+
+	# accumulate mksh built-in utilities, in definition order, even ifndef
+	i_func[nfunc++]=.
+	i_func[nfunc++]=:
+	i_func[nfunc++]='['
+	i_func[nfunc++]=alias
+	i_func[nfunc++]=break
+	i_func[nfunc++]=builtin
+	i_func[nfunc++]=cat
+	i_func[nfunc++]=cd
+	i_func[nfunc++]=chdir
+	i_func[nfunc++]=command
+	i_func[nfunc++]=continue
+	i_func[nfunc++]=echo
+	i_func[nfunc++]=eval
+	i_func[nfunc++]=exec
+	i_func[nfunc++]=exit
+	i_func[nfunc++]=export
+	i_func[nfunc++]=false
+	i_func[nfunc++]=fc
+	i_func[nfunc++]=getopts
+	i_func[nfunc++]=global
+	i_func[nfunc++]=jobs
+	i_func[nfunc++]=kill
+	i_func[nfunc++]=let
+	i_func[nfunc++]='let]'
+	i_func[nfunc++]=print
+	i_func[nfunc++]=pwd
+	i_func[nfunc++]=read
+	i_func[nfunc++]=readonly
+	i_func[nfunc++]=realpath
+	i_func[nfunc++]=rename
+	i_func[nfunc++]=return
+	i_func[nfunc++]=set
+	i_func[nfunc++]=shift
+	i_func[nfunc++]=suspend
+	i_func[nfunc++]=test
+	i_func[nfunc++]=times
+	i_func[nfunc++]=trap
+	i_func[nfunc++]=true
+	i_func[nfunc++]=typeset
+	i_func[nfunc++]=ulimit
+	i_func[nfunc++]=umask
+	i_func[nfunc++]=unalias
+	i_func[nfunc++]=unset
+	i_func[nfunc++]=wait
+	i_func[nfunc++]=whence
+	i_func[nfunc++]=bg
+	i_func[nfunc++]=fg
+	i_func[nfunc++]=bind
+	i_func[nfunc++]=mknod
+	i_func[nfunc++]=printf
+	i_func[nfunc++]=sleep
+	i_func[nfunc++]=domainname
+
+	# accumulate aliases from dot.mkshrc, in definition order
+	i_alias[nalias]=l; b_alias[nalias++]='ls -F'
+	i_alias[nalias]=la; b_alias[nalias++]='l -a'
+	i_alias[nalias]=ll; b_alias[nalias++]='l -l'
+	i_alias[nalias]=lo; b_alias[nalias++]='l -alo'
+	i_alias[nalias]=doch; b_alias[nalias++]='sudo mksh -c "$(\builtin fc -ln -1)"'
+	i_alias[nalias]=rot13; b_alias[nalias++]='tr abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM'
+	i_alias[nalias]=cls; b_alias[nalias++]='\builtin print -n \\033c'
+
+	# accumulate functions from dot.mkshrc, in definition order
+	i_func[nfunc++]=hd
+	i_func[nfunc++]=chpwd
+	i_func[nfunc++]=cd_csh
+	i_func[nfunc++]=dirs
+	i_func[nfunc++]=popd
+	i_func[nfunc++]=pushd
+	i_func[nfunc++]=smores
+	i_func[nfunc++]=Lb64decode
+	i_func[nfunc++]=Lb64encode
+	i_func[nfunc++]=Lbafh_init
+	i_func[nfunc++]=Lbafh_add
+	i_func[nfunc++]=Lbafh_finish
+	i_func[nfunc++]=Lstripcom
+	i_func[nfunc++]=setenv
+	i_func[nfunc++]=enable
+
+	# collect all identifiers, sorted ASCIIbetically
+	\set -sA i_all -- "${i_alias[@]}" "${i_func[@]}"
+
+	# handle options, we don't do dynamic loading
+	while \getopts "adf:nps" x; do
+		case $x {
+		(a)
+			mode=-1
+			;;
+		(d)
+			# deliberately causing an error, like bash-static
+			;|
+		(f)
+			\builtin print -u2 enable: dynamic loading not available
+			\return 2
+			;;
+		(n)
+			mode=0
+			;;
+		(p)
+			doprnt=1
+			;;
+		(s)
+			\set -sA i_all -- . : break continue eval exec exit \
+			    export readonly return set shift times trap unset
+			;;
+		(*)
+			\builtin print -u2 enable: usage: \
+			    "enable [-adnps] [-f filename] [name ...]"
+			return 2
+			;;
+		}
+	done
+	\shift $((OPTIND - 1))
+
+	# display builtins enabled/disabled/all/special?
+	if (( doprnt || ($# == 0) )); then
+		for x in "${i_all[@]}"; do
+			y=$(\alias "$x") || y=
+			[[ $y = "$x='\\builtin whence -p $x >/dev/null || (\\builtin print mksh: $x: not found; exit 127) && \$(\\builtin whence -p $x)'" ]]; z=$?
+			case $mode:$z {
+			(-1:0|0:0)
+				\print -r -- "enable -n $x"
+				;;
+			(-1:1|1:1)
+				\print -r -- "enable $x"
+				;;
+			}
+		done
+		\return 0
+	fi
+
+	for x in "$@"; do
+		z=0
+		for y in "${i_alias[@]}" "${i_func[@]}"; do
+			[[ $x = "$y" ]] || \continue
+			z=1
+			\break
+		done
+		if (( !z )); then
+			\builtin print -ru2 enable: "$x": not a shell builtin
+			rv=1
+			\continue
+		fi
+		if (( !mode )); then
+			# disable this
+			\alias "$x=\\builtin whence -p $x >/dev/null || (\\builtin print mksh: $x: not found; exit 127) && \$(\\builtin whence -p $x)"
+		else
+			# find out if this is an alias or not, first
+			z=0
+			y=-1
+			while (( ++y < nalias )); do
+				[[ $x = "${i_alias[y]}" ]] || \continue
+				z=1
+				\break
+			done
+			if (( z )); then
+				# re-enable the original alias body
+				\alias "$x=${b_alias[y]}"
+			else
+				# re-enable the original utility/function
+				\unalias "$x"
+			fi
+		fi
+	done
+	\return $rv
+}
+
+\: place customisations below this line
 
 for p in ~/.etc/bin ~/bin; do
-	[[ -d $p/. ]] || continue
+	[[ -d $p/. ]] || \continue
 	[[ :$PATH: = *:$p:* ]] || PATH=$p:$PATH
 done
 
-export SHELL=$MKSH MANWIDTH=80 LESSHISTFILE=-
-alias cls='print -n \\033c'
+\export SHELL=$MKSH MANWIDTH=80 LESSHISTFILE=-
+\alias cls='\builtin print -n \\033c'
 
-#unset LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_IDENTIFICATION LC_MONETARY \
+#\unset LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_IDENTIFICATION LC_MONETARY \
 #    LC_NAME LC_NUMERIC LC_TELEPHONE LC_TIME
 #p=en_GB.UTF-8
-#set -U
-#export LANG=C LC_CTYPE=$p LC_MEASUREMENT=$p LC_MESSAGES=$p LC_PAPER=$p
+#\set -U
+#\export LANG=C LC_CTYPE=$p LC_MEASUREMENT=$p LC_MESSAGES=$p LC_PAPER=$p
 
-unset p
+\unset p
 
-: place customisations above this line
+\: place customisations above this line
Index: src/bin/mksh/edit.c
diff -u src/bin/mksh/edit.c:1.276.2.3 src/bin/mksh/edit.c:1.283
--- src/bin/mksh/edit.c:1.276.2.3	Sun Mar  1 15:42:56 2015
+++ src/bin/mksh/edit.c	Sat Mar 14 05:17:16 2015
@@ -1,4 +1,4 @@
-/*	$OpenBSD: edit.c,v 1.39 2013/12/17 16:37:05 deraadt Exp $	*/
+/*	$OpenBSD: edit.c,v 1.40 2015/03/12 10:20:30 sthen Exp $	*/
 /*	$OpenBSD: edit.h,v 1.9 2011/05/30 17:14:35 martynas Exp $	*/
 /*	$OpenBSD: emacs.c,v 1.49 2015/02/16 01:44:41 tedu Exp $	*/
 /*	$OpenBSD: vi.c,v 1.28 2013/12/18 16:45:46 deraadt Exp $	*/
@@ -28,7 +28,7 @@
 
 #ifndef MKSH_NO_CMDLINE_EDITING
 
-__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.276.2.3 2015/03/01 15:42:56 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.283 2015/03/14 05:17:16 tg Exp $");
 
 /*
  * in later versions we might use libtermcap for this, but since external
Index: src/bin/mksh/eval.c
diff -u src/bin/mksh/eval.c:1.158.2.4 src/bin/mksh/eval.c:1.166
--- src/bin/mksh/eval.c:1.158.2.4	Sun Mar  1 15:42:58 2015
+++ src/bin/mksh/eval.c	Fri Feb 20 07:14:29 2015
@@ -23,7 +23,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.158.2.4 2015/03/01 15:42:58 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.166 2015/02/20 07:14:29 tg Exp $");
 
 /*
  * string expansion
Index: src/bin/mksh/exec.c
diff -u src/bin/mksh/exec.c:1.137.2.2 src/bin/mksh/exec.c:1.147
--- src/bin/mksh/exec.c:1.137.2.2	Sun Mar  1 15:42:59 2015
+++ src/bin/mksh/exec.c	Fri Mar 20 23:37:54 2015
@@ -23,7 +23,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.137.2.2 2015/03/01 15:42:59 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.147 2015/03/20 23:37:54 tg Exp $");
 
 #ifndef MKSH_DEFAULT_EXECSHELL
 #define MKSH_DEFAULT_EXECSHELL	"/bin/sh"
@@ -1020,11 +1020,13 @@
 
 	nhash = hash(name);
 
+#ifdef MKSH_LEGACY_MODE
 	if (t != NULL && !tobool(t->u.ksh_func)) {
 		/* drop same-name aliases for POSIX functions */
 		if ((tp = ktsearch(&aliases, name, nhash)))
 			ktdelete(tp);
 	}
+#endif
 
 	while (/* CONSTCOND */ 1) {
 		tp = findfunc(name, nhash, true);
Index: src/bin/mksh/expr.c
diff -u src/bin/mksh/expr.c:1.76.2.1 src/bin/mksh/expr.c:1.77
--- src/bin/mksh/expr.c:1.76.2.1	Sun Jan 25 15:44:05 2015
+++ src/bin/mksh/expr.c	Mon Dec 15 23:26:36 2014
@@ -23,7 +23,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.76.2.1 2015/01/25 15:44:05 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.77 2014/12/15 23:26:36 tg Exp $");
 
 /* the order of these enums is constrained by the order of opinfo[] */
 enum token {
Index: src/bin/mksh/funcs.c
diff -u src/bin/mksh/funcs.c:1.259.2.2 src/bin/mksh/funcs.c:1.266
--- src/bin/mksh/funcs.c:1.259.2.2	Sun Jan 25 15:35:44 2015
+++ src/bin/mksh/funcs.c	Fri Mar 20 21:01:41 2015
@@ -38,7 +38,7 @@
 #endif
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.259.2.2 2015/01/25 15:35:44 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.266 2015/03/20 21:01:41 tg Exp $");
 
 #if HAVE_KILLPG
 /*
@@ -138,7 +138,7 @@
 	{"ulimit", c_ulimit},
 	{"umask", c_umask},
 	{Tunalias, c_unalias},
-	{Tsgunset, c_unset},
+	{"*=unset", c_unset},
 	{"=wait", c_wait},
 	{"whence", c_whence},
 #ifndef MKSH_UNEMPLOYED
@@ -778,9 +778,13 @@
 
 	if (fieldstr && !bi_getn(fieldstr, &field))
 		return (1);
-	if (basestr && (!bi_getn(basestr, &base) || base < 1 || base > 36)) {
-		bi_errorf("%s: %s", "bad integer base", basestr);
-		return (1);
+	if (basestr) {
+		if (!bi_getn(basestr, &base)) {
+			bi_errorf("%s: %s", "bad integer base", basestr);
+			return (1);
+		}
+		if (base < 1 || base > 36)
+			base = 10;
 	}
 
 	if (!(builtin_opt.info & GI_MINUSMINUS) && wp[builtin_opt.optind] &&
@@ -1855,7 +1859,7 @@
 		if (!bi_getn(builtin_opt.optarg, &c))
 			return (2);
 		if (c == -1) {
-			readmode = READALL;
+			readmode = readmode == BYTES ? READALL : UPTO;
 			bytesleft = 1024;
 		} else
 			bytesleft = (unsigned int)c;
Index: src/bin/mksh/histrap.c
diff -u src/bin/mksh/histrap.c:1.134.2.3 src/bin/mksh/histrap.c:1.140
--- src/bin/mksh/histrap.c:1.134.2.3	Sun Mar  1 15:43:00 2015
+++ src/bin/mksh/histrap.c	Sat Mar  7 20:46:28 2015
@@ -27,7 +27,7 @@
 #include <sys/file.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.134.2.3 2015/03/01 15:43:00 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.140 2015/03/07 20:46:28 tg Exp $");
 
 Trap sigtraps[NSIG + 1];
 static struct sigaction Sigact_ign;
@@ -563,7 +563,7 @@
 		return;
 
 	/* if the name is the same as the name we have */
-	if (hname && strcmp(hname, name) == 0)
+	if (hname && name && !strcmp(hname, name))
 		return;
 
 	/*
@@ -581,7 +581,8 @@
 		hist_source->line = 0;
 	}
 
-	hist_init(hist_source);
+	if (name)
+		hist_init(hist_source);
 }
 #endif
 
@@ -712,8 +713,10 @@
 	hist_source = s;
 
 #if HAVE_PERSISTENT_HISTORY
-	if ((hname = str_val(global("HISTFILE"))) == NULL)
+	if (((hname = str_val(global("HISTFILE"))) == NULL) || !*hname) {
+		hname = NULL;
 		return;
+	}
 	strdupx(hname, hname, APERM);
 	hs = hist_init_first;
 
Index: src/bin/mksh/jobs.c
diff -u src/bin/mksh/jobs.c:1.105.2.1 src/bin/mksh/jobs.c:1.110
--- src/bin/mksh/jobs.c:1.105.2.1	Sun Jan 25 15:44:06 2015
+++ src/bin/mksh/jobs.c	Sun Mar  1 16:02:48 2015
@@ -2,7 +2,7 @@
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011,
- *		 2012, 2013, 2014
+ *		 2012, 2013, 2014, 2015
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -23,7 +23,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.105.2.1 2015/01/25 15:44:06 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.110 2015/03/01 16:02:48 tg Exp $");
 
 #if HAVE_KILLPG
 #define mksh_killpg		killpg
@@ -1111,6 +1111,7 @@
     int flags,
     const char *where)
 {
+	Proc *p;
 	int rv;
 #ifdef MKSH_NO_SIGSUSPEND
 	sigset_t omask;
@@ -1238,9 +1239,10 @@
 	j_systime = j->systime;
 	rv = j->status;
 
-	if ((flags & JW_PIPEST) && (j->proc_list != NULL)) {
+	if (!(p = j->proc_list)) {
+		;	/* nothing */
+	} else if (flags & JW_PIPEST) {
 		uint32_t num = 0;
-		Proc *p = j->proc_list;
 		struct tbl *vp;
 
 		unset(vp_pipest, 1);
@@ -1270,15 +1272,13 @@
 				rv = vp->val.i;
 			p = p->next;
 		}
-	} else if (Flag(FPIPEFAIL) && (j->proc_list != NULL)) {
-		Proc *p = j->proc_list;
-		int i;
+	} else if (Flag(FPIPEFAIL)) {
+		do {
+			const int i = proc_errorlevel(p);
 
-		while (p != NULL) {
-			if ((i = proc_errorlevel(p)))
+			if (i)
 				rv = i;
-			p = p->next;
-		}
+		} while ((p = p->next));
 	}
 
 	if (!(flags & JW_ASYNCNOTIFY)
Index: src/bin/mksh/lalloc.c
diff -u src/bin/mksh/lalloc.c:1.20.2.1 src/bin/mksh/lalloc.c:1.21
--- src/bin/mksh/lalloc.c:1.20.2.1	Sun Jan 25 15:35:47 2015
+++ src/bin/mksh/lalloc.c	Tue Nov 25 20:00:39 2014
@@ -20,7 +20,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.20.2.1 2015/01/25 15:35:47 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.21 2014/11/25 20:00:39 tg Exp $");
 
 /* build with CPPFLAGS+= -DUSE_REALLOC_MALLOC=0 on ancient systems */
 #if defined(USE_REALLOC_MALLOC) && (USE_REALLOC_MALLOC == 0)
Index: src/bin/mksh/lex.c
diff -u src/bin/mksh/lex.c:1.193.2.1 src/bin/mksh/lex.c:1.198
--- src/bin/mksh/lex.c:1.193.2.1	Sun Jan 11 22:39:50 2015
+++ src/bin/mksh/lex.c	Fri Mar 20 23:37:39 2015
@@ -2,7 +2,7 @@
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
- *		 2011, 2012, 2013, 2014
+ *		 2011, 2012, 2013, 2014, 2015
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -23,7 +23,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.193.2.1 2015/01/11 22:39:50 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.198 2015/03/20 23:37:39 tg Exp $");
 
 /*
  * states while lexing word
@@ -1044,13 +1044,16 @@
 	} else
 		while ((dp - ident) < IDENT && (c = *sp++) == CHAR)
 			*dp++ = *sp++;
-	/* make sure the ident array stays NUL padded */
-	memset(dp, 0, (ident + IDENT) - dp + 1);
 	if (c != EOS)
 		/* word is not unquoted */
-		*ident = '\0';
+		dp = ident;
+	/* make sure the ident array stays NUL padded */
+	memset(dp, 0, (ident + IDENT) - dp + 1);
+
+	if (!(cf & (KEYWORD | ALIAS)))
+		return (LWORD);
 
-	if (*ident != '\0' && (cf & (KEYWORD | ALIAS))) {
+	if (*ident != '\0') {
 		struct tbl *p;
 		uint32_t h = hash(ident);
 
@@ -1077,8 +1080,7 @@
 				 * pushed into an SREREAD) which is what
 				 * we want here anyway: find out whether
 				 * the alias name is followed by a POSIX
-				 * function definition (only the opening
-				 * parenthesis is checked though)
+				 * function definition
 				 */
 				++cp;
 			/* prefer functions over aliases */
@@ -1106,6 +1108,11 @@
 				goto Again;
 			}
 		}
+	} else if (cf & ALIAS) {
+		/* retain typeset et al. even when quoted */
+		if (assign_command((dp = wdstrip(yylval.cp, 0))))
+			strlcpy(ident, dp, sizeof(ident));
+		afree(dp, ATEMP);
 	}
 
 	return (LWORD);
@@ -1161,7 +1168,7 @@
 	if (iop->flag & IOSKIP) {
 		/* skip over leading tabs */
 		while ((c = getsc()) == '\t')
-			/* nothing */;
+			;	/* nothing */
 		goto heredoc_parse_char;
 	}
  heredoc_read_char:
Index: src/bin/mksh/lksh.1
diff -u src/bin/mksh/lksh.1:1.5 src/bin/mksh/lksh.1:1.8
--- src/bin/mksh/lksh.1:1.5	Wed May 22 18:18:06 2013
+++ src/bin/mksh/lksh.1	Sat Mar 21 00:12:46 2015
@@ -1,6 +1,6 @@
-.\" $MirOS: src/bin/mksh/lksh.1,v 1.5 2013/05/22 18:18:06 tg Exp $
+.\" $MirOS: src/bin/mksh/lksh.1,v 1.8 2015/03/21 00:12:46 tg Exp $
 .\"-
-.\" Copyright (c) 2008, 2009, 2010, 2012, 2013
+.\" Copyright (c) 2008, 2009, 2010, 2012, 2013, 2015
 .\"	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
 .\"
 .\" Provided that these terms and disclaimer and all copyright notices
@@ -72,7 +72,7 @@
 .\" with -mandoc, it might implement .Mx itself, but we want to
 .\" use our own definition. And .Dd must come *first*, always.
 .\"
-.Dd $Mdocdate: May 22 2013 $
+.Dd $Mdocdate: March 21 2015 $
 .\"
 .\" Check which macro package we use, and do other -mdoc setup.
 .\"
@@ -175,7 +175,7 @@
 since the MirBSD Korn Shell scripting language is much more consistent.
 .Sh LEGACY MODE
 .Nm
-has the following differences from
+currently has the following differences from
 .Nm mksh :
 .Bl -bullet
 .It
@@ -195,6 +195,11 @@
 .Dq LEGACY KSH
 instead of
 .Dq MIRBSD KSH .
+Note that the rest of the version string is identical between
+the two shell flavours, and the behaviour and differences can
+change between versions; see the accompanying manual page
+.Xr mksh 1
+for the versions this document applies to.
 .It
 .Nm
 only offers the traditional ten file descriptors to scripts.
@@ -245,11 +250,28 @@
 .Xr getopt 1
 command.
 .It
-.Nm lksh ,
-unlike
+Unlike
 .At
 .Nm ksh ,
-does not keep file descriptors \*(Gt 2 private.
+.Nm mksh
+in
+.Fl o Ic posix
+or
+.Fl o Ic sh
+mode and
+.Nm lksh
+do not keep file descriptors \*(Gt 2 private from sub-processes.
+.It
+.Nm lksh
+undefines an alias when a
+.Tn POSIX
+function with the same name is defined,
+to make that function immediately callable.
+In
+.Nm mksh ,
+aliases have precedence; the name must be quoted or
+.Ic unalias Ns ed
+to access it.
 .El
 .Sh SEE ALSO
 .Xr mksh 1
Index: src/bin/mksh/main.c
diff -u src/bin/mksh/main.c:1.285.2.2 src/bin/mksh/main.c:1.290
--- src/bin/mksh/main.c:1.285.2.2	Sun Mar  1 15:43:01 2015
+++ src/bin/mksh/main.c	Sat Mar 14 05:23:15 2015
@@ -5,7 +5,7 @@
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
- *		 2011, 2012, 2013, 2014
+ *		 2011, 2012, 2013, 2014, 2015
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -34,7 +34,7 @@
 #include <locale.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/main.c,v 1.285.2.2 2015/03/01 15:43:01 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/main.c,v 1.290 2015/03/14 05:23:15 tg Exp $");
 
 extern char **environ;
 
@@ -66,24 +66,24 @@
 	Ttypeset, "-x", "HOME", "PATH", "SHELL", NULL,
 	Ttypeset, "-i10", "COLUMNS", "LINES", "SECONDS", "TMOUT", NULL,
 	Talias,
-	"integer=typeset -i",
-	Tlocal_typeset,
+	"integer=\\typeset -i",
+	"local=\\typeset",
 	/* not "alias -t --": hash -r needs to work */
-	"hash=alias -t",
-	"type=whence -v",
+	"hash=\\builtin alias -t",
+	"type=\\builtin whence -v",
 #if !defined(ANDROID) && !defined(MKSH_UNEMPLOYED)
 	/* not in Android for political reasons */
 	/* not in ARGE mksh due to no job control */
-	"stop=kill -STOP",
+	"stop=\\kill -STOP",
 #endif
-	"autoload=typeset -fu",
-	"functions=typeset -f",
-	"history=fc -l",
-	"nameref=typeset -n",
+	"autoload=\\typeset -fu",
+	"functions=\\typeset -f",
+	"history=\\builtin fc -l",
+	"nameref=\\typeset -n",
 	"nohup=nohup ",
-	Tr_fc_e_dash,
-	"source=PATH=$PATH:. command .",
-	"login=exec login",
+	"r=\\builtin fc -e -",
+	"source=PATH=$PATH:. \\command .",
+	"login=\\exec login",
 	NULL,
 	 /* this is what AT&T ksh seems to track, with the addition of emacs */
 	Talias, "-tU",
Index: src/bin/mksh/misc.c
diff -u src/bin/mksh/misc.c:1.219.2.2 src/bin/mksh/misc.c:1.226
--- src/bin/mksh/misc.c:1.219.2.2	Sun Mar  1 15:43:02 2015
+++ src/bin/mksh/misc.c	Fri Mar 20 21:46:40 2015
@@ -1,4 +1,4 @@
-/*	$OpenBSD: misc.c,v 1.39 2015/01/16 06:39:32 deraadt Exp $	*/
+/*	$OpenBSD: misc.c,v 1.40 2015/03/18 15:12:36 tedu Exp $	*/
 /*	$OpenBSD: path.c,v 1.12 2005/03/30 17:16:37 deraadt Exp $	*/
 
 /*-
@@ -30,7 +30,7 @@
 #include <grp.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.219.2.2 2015/03/01 15:43:02 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.226 2015/03/20 21:46:40 tg Exp $");
 
 #define KSH_CHVT_FLAG
 #ifdef MKSH_SMALL
@@ -1289,32 +1289,27 @@
 	afree(str, ATEMP);
 }
 
-/* Strip any nul bytes from buf - returns new length (nbytes - # of nuls) */
+/* strip all NUL bytes from buf; output is NUL-terminated if stripped */
 void
-strip_nuls(char *buf, int nbytes)
+strip_nuls(char *buf, size_t len)
 {
-	char *dst;
+	char *cp, *dp, *ep;
 
-	/*
-	 * nbytes check because some systems (older FreeBSDs) have a
-	 * buggy memchr()
-	 */
-	if (nbytes && (dst = memchr(buf, '\0', nbytes))) {
-		char *end = buf + nbytes;
-		char *p, *q;
-
-		for (p = dst; p < end; p = q) {
-			/* skip a block of nulls */
-			while (++p < end && *p == '\0')
-				;
-			/* find end of non-null block */
-			if (!(q = memchr(p, '\0', end - p)))
-				q = end;
-			memmove(dst, p, q - p);
-			dst += q - p;
-		}
-		*dst = '\0';
-	}
+	if (!len || !(dp = memchr(buf, '\0', len)))
+		return;
+
+	ep = buf + len;
+	cp = dp;
+
+ cp_has_nul_byte:
+	while (cp++ < ep && *cp == '\0')
+		;	/* nothing */
+	while (cp < ep && *cp != '\0')
+		*dp++ = *cp++;
+	if (cp < ep)
+		goto cp_has_nul_byte;
+
+	*dp = '\0';
 }
 
 /*
Index: src/bin/mksh/mksh.1
diff -u src/bin/mksh/mksh.1:1.344.2.3 src/bin/mksh/mksh.1:1.357
--- src/bin/mksh/mksh.1:1.344.2.3	Sun Mar  1 15:43:03 2015
+++ src/bin/mksh/mksh.1	Sat Mar 21 00:12:46 2015
@@ -1,5 +1,5 @@
-.\" $MirOS: src/bin/mksh/mksh.1,v 1.344.2.3 2015/03/01 15:43:03 tg Exp $
-.\" $OpenBSD: ksh.1,v 1.156 2015/01/16 15:32:32 schwarze Exp $
+.\" $MirOS: src/bin/mksh/mksh.1,v 1.357 2015/03/21 00:12:46 tg Exp $
+.\" $OpenBSD: ksh.1,v 1.158 2015/03/15 14:33:21 jmc Exp $
 .\"-
 .\" Copyright © 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
 .\"		2010, 2011, 2012, 2013, 2014, 2015
@@ -74,7 +74,7 @@
 .\" with -mandoc, it might implement .Mx itself, but we want to
 .\" use our own definition. And .Dd must come *first*, always.
 .\"
-.Dd $Mdocdate: March 1 2015 $
+.Dd $Mdocdate: March 21 2015 $
 .\"
 .\" Check which macro package we use, and do other -mdoc setup.
 .\"
@@ -1120,18 +1120,19 @@
 .Pp
 The following command aliases are defined automatically by the shell:
 .Bd -literal -offset indent
-autoload=\*(aqtypeset \-fu\*(aq
-functions=\*(aqtypeset \-f\*(aq
-hash=\*(aqalias \-t\*(aq
-history=\*(aqfc \-l\*(aq
-integer=\*(aqtypeset \-i\*(aq
-local=\*(aqtypeset\*(aq
-login=\*(aqexec login\*(aq
-nameref=\*(aqtypeset \-n\*(aq
+autoload=\*(aq\etypeset \-fu\*(aq
+functions=\*(aq\etypeset \-f\*(aq
+hash=\*(aq\ebuiltin alias \-t\*(aq
+history=\*(aq\ebuiltin fc \-l\*(aq
+integer=\*(aq\etypeset \-i\*(aq
+local=\*(aq\etypeset\*(aq
+login=\*(aq\eexec login\*(aq
+nameref=\*(aq\etypeset \-n\*(aq
 nohup=\*(aqnohup \*(aq
-r=\*(aqfc \-e \-\*(aq
-stop=\*(aqkill \-STOP\*(aq
-type=\*(aqwhence \-v\*(aq
+r=\*(aq\ebuiltin fc \-e \-\*(aq
+source=\*(aqPATH=$PATH:. \ecommand .'
+stop=\*(aq\ekill \-STOP\*(aq
+type=\*(aq\ebuiltin whence \-v\*(aq
 .Ed
 .Pp
 Tracked aliases allow the shell to remember where it found a particular
@@ -1254,10 +1255,8 @@
 .Sq D .
 Note that if the
 .Ev IFS
-parameter is set to the
-.Dv NULL
-string, no field splitting is done; if the parameter is unset, the default
-value of space, tab, and newline is used.
+parameter is set to the empty string, no field splitting is done;
+if it is unset, the default value of space, tab, and newline is used.
 .Pp
 Also, note that the field splitting applies only to the immediate result of
 the substitution.
@@ -1795,21 +1794,16 @@
 .It Ev BASHPID
 The PID of the shell or subshell.
 .It Ev CDPATH
-Search path for the
+Like
+.Ev PATH ,
+but used to resolve the argument to the
 .Ic cd
 built-in command.
-It works the same way as
-.Ev PATH
-for those directories not beginning with
-.Ql /
-in
-.Ic cd
-commands.
 Note that if
 .Ev CDPATH
 is set and does not contain
 .Sq \&.
-or contains an empty path, the current directory is not searched.
+or an empty string element, the current directory is not searched.
 Also, the
 .Ic cd
 built-in command will display the resulting directory when a match is found
@@ -1862,7 +1856,8 @@
 below for more information.
 .It Ev HISTFILE
 The name of the file used to store command history.
-When assigned to, history is loaded from the specified file.
+When assigned to or unset, the file is opened, history is truncated
+then loaded from the file; subsequent new lines are appended.
 Also, several invocations of the shell will share history if their
 .Ev HISTFILE
 parameters all point to the same file.
@@ -1870,7 +1865,7 @@
 .Sy Note :
 If
 .Ev HISTFILE
-isn't set, no history file is used.
+is unset or empty, no history file is used.
 This is different from
 .At
 .Nm ksh .
@@ -2908,10 +2903,6 @@
 inside a function interferes with using
 .Ic getopts
 outside the function).
-.It
-Bourne-style function definitions take precedence over alias dereferences
-and remove alias definitions upon encounter, while aliases take precedence
-over Korn-style functions.
 .El
 .Pp
 In the future, the following differences may also be added:
@@ -6500,9 +6491,22 @@
 $ /bin/sleep 666 && echo fubar
 .Ed
 .Pp
+The truncation process involved when changing
+.Ev HISTFILE
+does not free old history entries (leaks memory) and leaks
+old entries into the new history if their line numbers are
+not overwritten by same-numer entries from the persistent
+history file; truncating the on-disc file to
+.Ev HISTSIZE
+lines has always been broken and prone to history file corruption
+when multiple shells are accessing the file; the rollover process
+for the in-memory portion of the history is slow, should use
+.Xr memmove 3 .
+.Pp
 This document attempts to describe
-.Nm mksh\ R50e
+.Nm mksh\ R51
 and up,
+.\" with vendor patches from insert-your-name-here,
 compiled without any options impacting functionality, such as
 .Dv MKSH_SMALL ,
 when not called as
Index: src/bin/mksh/sh.h
diff -u src/bin/mksh/sh.h:1.701.2.4 src/bin/mksh/sh.h:1.721
--- src/bin/mksh/sh.h:1.701.2.4	Sun Mar  1 15:43:05 2015
+++ src/bin/mksh/sh.h	Fri Mar 20 23:37:55 2015
@@ -169,9 +169,9 @@
 #endif
 
 #ifdef EXTERN
-__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.701.2.4 2015/03/01 15:43:05 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.721 2015/03/20 23:37:55 tg Exp $");
 #endif
-#define MKSH_VERSION "R50 2015/03/01"
+#define MKSH_VERSION "R50 2015/03/20"
 
 /* arithmetic types: C implementation */
 #if !HAVE_CAN_INTTYPES
@@ -537,7 +537,7 @@
 #define mkssert(e)	do { } while (/* CONSTCOND */ 0)
 #endif
 
-#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 505)
+#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 509)
 #error Must run Build.sh to compile this.
 extern void thiswillneverbedefinedIhope(void);
 int
@@ -802,18 +802,12 @@
 EXTERN const char Tsynerr[] E_INIT("syntax error");
 #endif
 EXTERN const char Tselect[] E_INIT("select");
-EXTERN const char Tr_fc_e_dash[] E_INIT("r=fc -e -");
-#define Tfc_e_dash	(Tr_fc_e_dash + 2)	/* "fc -e -" */
-#define Zfc_e_dash	7			/* strlen(Tfc_e_dash) */
-EXTERN const char Tlocal_typeset[] E_INIT("local=typeset");
-#define T_typeset	(Tlocal_typeset + 5)	/* "=typeset" */
-#define Ttypeset	(Tlocal_typeset + 6)	/* "typeset" */
+EXTERN const char T_typeset[] E_INIT("=typeset");
+#define Ttypeset	(T_typeset + 1)		/* "typeset" */
 EXTERN const char Talias[] E_INIT("alias");
 EXTERN const char Tunalias[] E_INIT("unalias");
 EXTERN const char Tsgset[] E_INIT("*=set");
 #define Tset		(Tsgset + 2)		/* "set" */
-EXTERN const char Tsgunset[] E_INIT("*=unset");
-#define Tunset		(Tsgunset + 2)		/* "unset" */
 EXTERN const char Tsgexport[] E_INIT("*=export");
 #define Texport		(Tsgexport + 2)		/* "export" */
 EXTERN const char Tsgreadonly[] E_INIT("*=readonly");
@@ -1582,10 +1576,9 @@
 #define VARASN		BIT(5)	/* check for var=word */
 #define ARRAYVAR	BIT(6)	/* parse x[1 & 2] as one word */
 #define ESACONLY	BIT(7)	/* only accept esac keyword */
-#define CMDWORD		BIT(8)	/* parsing simple command (alias related) */
-#define HEREDELIM	BIT(9)	/* parsing <<,<<- delimiter */
-#define LQCHAR		BIT(10)	/* source string contains QCHAR */
-#define HEREDOC 	BIT(11)	/* parsing a here document body */
+#define HEREDELIM	BIT(8)	/* parsing <<,<<- delimiter */
+#define LQCHAR		BIT(9)	/* source string contains QCHAR */
+#define HEREDOC 	BIT(10)	/* parsing a here document body */
 
 #define HERES		10	/* max number of << in line */
 
@@ -1876,7 +1869,8 @@
 void print_columns(struct shf *, unsigned int,
     char *(*)(char *, size_t, unsigned int, const void *),
     const void *, size_t, size_t, bool);
-void strip_nuls(char *, int);
+void strip_nuls(char *, size_t)
+    MKSH_A_BOUNDED(__string__, 1, 2);
 ssize_t blocking_read(int, char *, size_t)
     MKSH_A_BOUNDED(__buffer__, 2, 3);
 int reset_nonblock(int);
@@ -1923,6 +1917,7 @@
 ssize_t shf_vfprintf(struct shf *, const char *, va_list)
     MKSH_A_FORMAT(__printf__, 2, 0);
 /* syn.c */
+int assign_command(const char *);
 void initkeywords(void);
 struct op *compile(Source *, bool);
 bool parse_usec(const char *, struct timeval *);
Index: src/bin/mksh/shf.c
diff -u src/bin/mksh/shf.c:1.62.2.2 src/bin/mksh/shf.c:1.64
--- src/bin/mksh/shf.c:1.62.2.2	Sun Mar  1 15:43:07 2015
+++ src/bin/mksh/shf.c	Fri Feb  6 10:09:07 2015
@@ -25,7 +25,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.62.2.2 2015/03/01 15:43:07 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.64 2015/02/06 10:09:07 tg Exp $");
 
 /* flags to shf_emptybuf() */
 #define EB_READSW	0x01	/* about to switch to reading */
Index: src/bin/mksh/syn.c
diff -u src/bin/mksh/syn.c:1.94.2.1 src/bin/mksh/syn.c:1.99
--- src/bin/mksh/syn.c:1.94.2.1	Sun Jan 25 15:35:54 2015
+++ src/bin/mksh/syn.c	Sat Mar 14 05:23:18 2015
@@ -2,7 +2,7 @@
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009,
- *		 2011, 2012, 2013, 2014
+ *		 2011, 2012, 2013, 2014, 2015
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -23,7 +23,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.94.2.1 2015/01/25 15:35:54 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.99 2015/03/14 05:23:18 tg Exp $");
 
 struct nesting_state {
 	int start_token;	/* token than began nesting (eg, FOR) */
@@ -58,7 +58,6 @@
 static void syntaxerr(const char *) MKSH_A_NORETURN;
 static void nesting_push(struct nesting_state *, int);
 static void nesting_pop(struct nesting_state *);
-static int assign_command(const char *);
 static int inalias(struct source *) MKSH_A_PURE;
 static Test_op dbtestp_isa(Test_env *, Test_meta);
 static const char *dbtestp_getopnd(Test_env *, Test_op, bool);
@@ -244,10 +243,10 @@
 }
 
 static const char let_cmd[] = {
-	CHAR, 'l', CHAR, 'e', CHAR, 't', CHAR, ']', EOS
+	QCHAR, 'l', CHAR, 'e', CHAR, 't', CHAR, ']', EOS
 };
 static const char setA_cmd0[] = {
-	CHAR, 's', CHAR, 'e', CHAR, 't', EOS
+	QCHAR, 's', CHAR, 'e', CHAR, 't', EOS
 };
 static const char setA_cmd1[] = {
 	CHAR, '-', CHAR, 'A', EOS
@@ -289,7 +288,7 @@
 		t->lineno = source->line;
 		while (/* CONSTCOND */ 1) {
 			cf = (t->u.evalflags ? ARRAYVAR : 0) |
-			    (XPsize(args) == 0 ? sALIAS|VARASN : CMDWORD);
+			    (XPsize(args) == 0 ? sALIAS|VARASN : 0);
 			switch (tpeek(cf)) {
 			case REDIR:
 				while ((iop = synio(cf)) != NULL) {
@@ -713,7 +712,7 @@
 		/* (2 * sizeof(char *)) is small enough */
 		t->left->args = alloc(2 * sizeof(char *), ATEMP);
 		t->left->args[0] = tv = alloc(3, ATEMP);
-		tv[0] = CHAR;
+		tv[0] = QCHAR;
 		tv[1] = ':';
 		tv[2] = EOS;
 		t->left->args[1] = NULL;
@@ -927,7 +926,7 @@
  *	a=a
  *	$
  */
-static int
+int
 assign_command(const char *s)
 {
 	if (!*s)
Index: src/bin/mksh/var.c
diff -u src/bin/mksh/var.c:1.183.2.2 src/bin/mksh/var.c:1.187
--- src/bin/mksh/var.c:1.183.2.2	Sun Mar  1 15:43:07 2015
+++ src/bin/mksh/var.c	Sat Mar  7 20:46:31 2015
@@ -1,4 +1,4 @@
-/*	$OpenBSD: var.c,v 1.38 2013/12/20 17:53:09 zhuk Exp $	*/
+/*	$OpenBSD: var.c,v 1.40 2014/12/12 05:00:55 jsg Exp $	*/
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
@@ -28,7 +28,7 @@
 #include <sys/sysctl.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/var.c,v 1.183.2.2 2015/03/01 15:43:07 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/var.c,v 1.187 2015/03/07 20:46:31 tg Exp $");
 
 /*-
  * Variables
@@ -513,7 +513,7 @@
 			neg = true;
 			continue;
 		} else if (c == '#') {
-			if (have_base || num < 1 || num > 36)
+			if (have_base || num < 1)
 				return (-1);
 			if ((base = num) == 1) {
 				unsigned int wc;
@@ -530,7 +530,8 @@
 					wc = 0xEF00 + *(const unsigned char *)s;
 				nump->u = (mksh_uari_t)wc;
 				return (1);
-			}
+			} else if (base > 36)
+				base = 10;
 			num = 0;
 			have_base = true;
 			continue;
@@ -1350,6 +1351,11 @@
 	 */
 
 	switch (special(vp->name)) {
+#if HAVE_PERSISTENT_HISTORY
+	case V_HISTFILE:
+		sethistfile(NULL);
+		return;
+#endif
 	case V_IFS:
 		setctypes(TC_IFSWS, C_IFS);
 		ifs0 = ' ';
