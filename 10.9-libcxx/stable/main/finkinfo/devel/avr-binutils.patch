diff -Naur old/bfd/archures.c new/bfd/archures.c
--- old/bfd/archures.c	2013-11-08 10:02:26.000000000 +0000
+++ new/bfd/archures.c	2014-08-07 14:43:00.000000000 +0100
@@ -398,6 +398,7 @@
 .#define bfd_mach_avr5		5
 .#define bfd_mach_avr51		51
 .#define bfd_mach_avr6		6
+.#define bfd_mach_avrtiny10 100 
 .#define bfd_mach_avrxmega1 101
 .#define bfd_mach_avrxmega2 102
 .#define bfd_mach_avrxmega3 103
diff -Naur old/bfd/bfd-in2.h new/bfd/bfd-in2.h
--- old/bfd/bfd-in2.h	2013-11-18 08:40:15.000000000 +0000
+++ new/bfd/bfd-in2.h	2014-08-07 14:43:00.000000000 +0100
@@ -2153,6 +2153,7 @@
 #define bfd_mach_avr5          5
 #define bfd_mach_avr51         51
 #define bfd_mach_avr6          6
+#define bfd_mach_avrtiny10 100 
 #define bfd_mach_avrxmega1 101
 #define bfd_mach_avrxmega2 102
 #define bfd_mach_avrxmega3 103
@@ -4251,6 +4252,18 @@
 in .byte hlo8(symbol)  */
   BFD_RELOC_AVR_8_HLO,
 
+/* This is a 7 bit reloc for the AVR that stores a SRAM address for 
+the sts and lds instructions  */
+  BFD_RELOC_AVR_LDS_STS_16,
+
+/* This is a 6 bit reloc for the AVR that stores an I/O register
+number for the IN and OUT instructions  */
+  BFD_RELOC_AVR_PORT6,
+
+/* This is a 5 bit reloc for the AVR that stores an I/O register
+number for the SBIC, SBIS, SBI and CBI instructions  */
+  BFD_RELOC_AVR_PORT5,
+
 /* Renesas RL78 Relocations.  */
   BFD_RELOC_RL78_NEG8,
   BFD_RELOC_RL78_NEG16,
diff -Naur old/bfd/cpu-avr.c new/bfd/cpu-avr.c
--- old/bfd/cpu-avr.c	2013-11-04 15:33:37.000000000 +0000
+++ new/bfd/cpu-avr.c	2014-08-07 14:43:00.000000000 +0100
@@ -136,23 +136,26 @@
   /* 3-Byte PC.  */
   N (22, bfd_mach_avr6, "avr:6", FALSE, & arch_info_struct[10]),
 
+  /* attiny 10 */
+  N (16, bfd_mach_avrtiny10, "avr:100", FALSE, & arch_info_struct[11]),
+  
   /* Xmega 1 */
-  N (24, bfd_mach_avrxmega1, "avr:101", FALSE, & arch_info_struct[11]),
+  N (24, bfd_mach_avrxmega1, "avr:101", FALSE, & arch_info_struct[12]),
 
   /* Xmega 2 */
-  N (24, bfd_mach_avrxmega2, "avr:102", FALSE, & arch_info_struct[12]),
+  N (24, bfd_mach_avrxmega2, "avr:102", FALSE, & arch_info_struct[13]),
 
   /* Xmega 3 */
-  N (24, bfd_mach_avrxmega3, "avr:103", FALSE, & arch_info_struct[13]),
+  N (24, bfd_mach_avrxmega3, "avr:103", FALSE, & arch_info_struct[14]),
 
   /* Xmega 4 */
-  N (24, bfd_mach_avrxmega4, "avr:104", FALSE, & arch_info_struct[14]),
+  N (24, bfd_mach_avrxmega4, "avr:104", FALSE, & arch_info_struct[15]),
 
   /* Xmega 5 */
-  N (24, bfd_mach_avrxmega5, "avr:105", FALSE, & arch_info_struct[15]),
+  N (24, bfd_mach_avrxmega5, "avr:105", FALSE, & arch_info_struct[16]),
 
   /* Xmega 6 */
-  N (24, bfd_mach_avrxmega6, "avr:106", FALSE, & arch_info_struct[16]),
+  N (24, bfd_mach_avrxmega6, "avr:106", FALSE, & arch_info_struct[17]),
 
   /* Xmega 7 */
   N (24, bfd_mach_avrxmega7, "avr:107", FALSE, NULL)
diff -Naur old/bfd/doc/reloc.texi new/bfd/doc/reloc.texi
--- old/bfd/doc/reloc.texi	2013-11-18 08:49:27.000000000 +0000
+++ new/bfd/doc/reloc.texi	2014-08-07 14:43:00.000000000 +0100
@@ -2233,6 +2233,18 @@
 This is a 8 bit reloc for the AVR that stores bits 16..23 of a symbol
 in .byte hlo8(symbol)
 @end deffn
+@deffn {} BFD_RELOC_AVR_LDS_STS_16
+This is a 7 bit reloc for the AVR that stores a SRAM address for 
+the sts and lds instructions
+@end deffn
+@deffn {} BFD_RELOC_AVR_PORT6
+This is a 6 bit reloc for the AVR that stores an I/O register
+number for the IN and OUT instructions
+@end deffn
+@deffn {} BFD_RELOC_AVR_PORT5
+This is a 5 bit reloc for the AVR that stores an I/O register
+number for the SBIC, SBIS, SBI and CBI instructions
+@end deffn
 @deffn {} BFD_RELOC_RL78_NEG8
 @deffnx {} BFD_RELOC_RL78_NEG16
 @deffnx {} BFD_RELOC_RL78_NEG24
diff -Naur old/bfd/elf32-avr.c new/bfd/elf32-avr.c
--- old/bfd/elf32-avr.c	2013-11-08 10:13:48.000000000 +0000
+++ new/bfd/elf32-avr.c	2014-08-07 14:43:00.000000000 +0100
@@ -557,6 +557,45 @@
 	 0xffffff,		/* src_mask */
 	 0xffffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
+  HOWTO (R_AVR_LDS_STS_16,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 7,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_AVR_LDS_STS_16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffff,		/* src_mask */
+	 0xffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+  HOWTO (R_AVR_PORT6,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 6,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_AVR_PORT6",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffff,		/* src_mask */
+	 0xffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+  HOWTO (R_AVR_PORT5,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_AVR_PORT5",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffff,		/* src_mask */
+	 0xffffff,		/* dst_mask */
+	 FALSE) 		/* pcrel_offset */
 };
 
 /* Map BFD reloc types to AVR ELF reloc types.  */
@@ -598,7 +637,10 @@
   { BFD_RELOC_8,                    R_AVR_8 },
   { BFD_RELOC_AVR_8_LO,             R_AVR_8_LO8 },
   { BFD_RELOC_AVR_8_HI,             R_AVR_8_HI8 },
-  { BFD_RELOC_AVR_8_HLO,            R_AVR_8_HLO8 }
+  { BFD_RELOC_AVR_8_HLO,            R_AVR_8_HLO8 },
+  { BFD_RELOC_AVR_LDS_STS_16,       R_AVR_LDS_STS_16},
+  { BFD_RELOC_AVR_PORT6,            R_AVR_PORT6},
+  { BFD_RELOC_AVR_PORT5,            R_AVR_PORT5}
 };
 
 /* Meant to be filled one day with the wrap around address for the
@@ -1100,7 +1142,7 @@
       srel = (bfd_signed_vma) relocation + rel->r_addend;
       srel = -srel;
       if (srel & 1)
-	return bfd_reloc_outofrange;
+        return bfd_reloc_outofrange;
       srel = srel >> 1;
       srel = (srel >> 16) & 0xff;
       x = bfd_get_16 (input_bfd, contents);
@@ -1144,10 +1186,41 @@
         }
 
       if (srel & 1)
-	return bfd_reloc_outofrange;
+        return bfd_reloc_outofrange;
       srel = srel >> 1;
       bfd_put_16 (input_bfd, (bfd_vma) srel &0x00ffff, contents);
       break;
+    
+    case R_AVR_LDS_STS_16:
+      contents += rel->r_offset;
+      srel = (bfd_signed_vma) relocation + rel->r_addend;
+      if ((srel & 0xffff) < 0x40 || (srel & 0xffff)  > 0x139)
+        return bfd_reloc_outofrange;
+      x = bfd_get_16 (input_bfd, contents);
+      x = (x & 0xf8f0) | ((srel & 0x40) << 2) | ((srel & 0x30) << 5) |
+              (srel & 0x0f);
+      bfd_put_16 (input_bfd, x, contents);
+      break;
+
+    case R_AVR_PORT6:
+      contents += rel->r_offset;
+      srel = (bfd_signed_vma) relocation + rel->r_addend;
+      if ((srel & 0xffff) > 0x3f)
+        return bfd_reloc_outofrange;
+      x = bfd_get_16 (input_bfd, contents);
+      x = (x & 0xf9f0) | ((srel & 0x30) << 5) | (srel & 0x0f);
+      bfd_put_16 (input_bfd, x, contents);
+      break;
+
+    case R_AVR_PORT5:
+      contents += rel->r_offset;
+      srel = (bfd_signed_vma) relocation + rel->r_addend;
+      if ((srel & 0xffff) > 0x1f)
+        return bfd_reloc_outofrange;
+      x = bfd_get_16 (input_bfd, contents);
+      x = (x & 0xff07) | ((srel & 0x1f) << 3);
+      bfd_put_16 (input_bfd, x, contents);
+      break;
 
     default:
       r = _bfd_final_link_relocate (howto, input_bfd, input_section,
@@ -1361,6 +1434,10 @@
     case bfd_mach_avrxmega7:
       val = E_AVR_MACH_XMEGA7;
       break;
+
+    case bfd_mach_avrtiny10:
+      val = E_AVR_MACH_AVRTINY10;
+      break;
     }
 
   elf_elfheader (abfd)->e_machine = EM_AVR;
@@ -1451,6 +1528,10 @@
 	case E_AVR_MACH_XMEGA7:
 	  e_set = bfd_mach_avrxmega7;
 	  break;
+
+	case E_AVR_MACH_AVRTINY10:
+	  e_set = bfd_mach_avrtiny10;
+	  break;
 	}
     }
   return bfd_default_set_arch_mach (abfd, bfd_arch_avr,
diff -Naur old/bfd/libbfd.h new/bfd/libbfd.h
--- old/bfd/libbfd.h	2013-11-18 08:40:15.000000000 +0000
+++ new/bfd/libbfd.h	2014-08-07 14:43:00.000000000 +0100
@@ -1947,6 +1947,9 @@
   "BFD_RELOC_AVR_8_LO",
   "BFD_RELOC_AVR_8_HI",
   "BFD_RELOC_AVR_8_HLO",
+  "BFD_RELOC_AVR_LDS_STS_16",
+  "BFD_RELOC_AVR_PORT6",
+  "BFD_RELOC_AVR_PORT5",
   "BFD_RELOC_RL78_NEG8",
   "BFD_RELOC_RL78_NEG16",
   "BFD_RELOC_RL78_NEG24",
diff -Naur old/bfd/reloc.c new/bfd/reloc.c
--- old/bfd/reloc.c	2013-11-18 08:40:15.000000000 +0000
+++ new/bfd/reloc.c	2014-08-07 14:43:00.000000000 +0100
@@ -4510,6 +4510,21 @@
 ENUMDOC
   This is a 8 bit reloc for the AVR that stores bits 16..23 of a symbol
   in .byte hlo8(symbol)
+ENUM
+  BFD_RELOC_AVR_LDS_STS_16
+ENUMDOC
+  This is a 7 bit reloc for the AVR that stores a SRAM address for 
+  the sts and lds instructions
+ENUM
+  BFD_RELOC_AVR_PORT6
+ENUMDOC
+  This is a 6 bit reloc for the AVR that stores an I/O register
+  number for the IN and OUT instructions
+ENUM
+  BFD_RELOC_AVR_PORT5
+ENUMDOC
+  This is a 5 bit reloc for the AVR that stores an I/O register
+  number for the SBIC, SBIS, SBI and CBI instructions
 
 ENUM
   BFD_RELOC_RL78_NEG8
diff -Naur old/gas/config/tc-avr.c new/gas/config/tc-avr.c
--- old/gas/config/tc-avr.c	2013-11-04 15:33:37.000000000 +0000
+++ new/gas/config/tc-avr.c	2014-08-07 15:33:03.000000000 +0100
@@ -33,7 +33,7 @@
   char *        constraints;
   char *        opcode;
   int           insn_size;		/* In words.  */
-  int           isa;
+  long          isa;
   unsigned int  bin_opcode;
 };
 
@@ -54,7 +54,7 @@
 struct mcu_type_s
 {
   char *name;
-  int isa;
+  long isa;
   int mach;
 };
 
@@ -89,6 +89,7 @@
   {"avrxmega5",  AVR_ISA_XMEGA,   bfd_mach_avrxmega5},
   {"avrxmega6",  AVR_ISA_XMEGA,   bfd_mach_avrxmega6},
   {"avrxmega7",  AVR_ISA_XMEGA,   bfd_mach_avrxmega7},
+  {"avrtiny10",  AVR_ISA_AVRTINY10, bfd_mach_avrtiny10},
   {"at90s1200",  AVR_ISA_1200,    bfd_mach_avr1},
   {"attiny11",   AVR_ISA_AVR1,    bfd_mach_avr1},
   {"attiny12",   AVR_ISA_AVR1,    bfd_mach_avr1},
@@ -280,6 +281,12 @@
   {"atxmega256d3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
   {"atxmega128a1", AVR_ISA_XMEGA, bfd_mach_avrxmega7},
   {"atxmega128a1u", AVR_ISA_XMEGAU, bfd_mach_avrxmega7},
+  {"attiny4",      AVR_ISA_AVRTINY10, bfd_mach_avrtiny10},
+  {"attiny5",      AVR_ISA_AVRTINY10, bfd_mach_avrtiny10},
+  {"attiny9",      AVR_ISA_AVRTINY10, bfd_mach_avrtiny10},
+  {"attiny10",     AVR_ISA_AVRTINY10, bfd_mach_avrtiny10},
+  {"attiny20",     AVR_ISA_AVRTINY10, bfd_mach_avrtiny10},
+  {"attiny40",     AVR_ISA_AVRTINY10, bfd_mach_avrtiny10},
   {NULL, 0, 0}
 };
 
@@ -462,6 +469,7 @@
 	"                   avrxmega5 - XMEGA, > 64K, <= 128K FLASH, > 64K RAM\n"
 	"                   avrxmega6 - XMEGA, > 128K, <= 256K FLASH, <= 64K RAM\n"
 	"                   avrxmega7 - XMEGA, > 128K, <= 256K FLASH, > 64K RAM\n"
+	"                   avrtiny10 - tiny devices with 16 gp registers\n"
 	"                   or immediate microcontroller name.\n"));
   fprintf (stream,
       _("  -mall-opcodes    accept all AVR opcodes, even if not supported by MCU\n"
@@ -788,26 +796,41 @@
     case 'r':
     case 'a':
     case 'v':
-      if (*str == 'r' || *str == 'R')
 	{
+	  char *old_str = str;
+	  char *lower;
 	  char r_name[20];
-
 	  str = extract_word (str, r_name, sizeof (r_name));
-	  op_mask = 0xff;
-	  if (ISDIGIT (r_name[1]))
+	  for (lower = r_name; *lower; ++lower)
 	    {
-	      if (r_name[2] == '\0')
-		op_mask = r_name[1] - '0';
-	      else if (r_name[1] != '0'
-		       && ISDIGIT (r_name[2])
-		       && r_name[3] == '\0')
-		op_mask = (r_name[1] - '0') * 10 + r_name[2] - '0';
+	      if (*lower >= 'A' && *lower <= 'Z')
+	        *lower += 'a' - 'A';
+	    }
+	  if (r_name[0] == 'r' && ISDIGIT (r_name[1]) && r_name[2] == 0)
+	  	/* Single-digit register number, ie r0-r9 */
+	    op_mask = r_name[1] - '0';
+	  else if (r_name[0] == 'r' && ISDIGIT (r_name[1]) &&
+	    ISDIGIT (r_name[2]) && r_name[3] == 0)
+	  	/* Double-digit register number, ie r10 - r32 */
+	    op_mask = (r_name[1] - '0') * 10 + r_name[2] - '0';
+	  else if (r_name[0] >= 'x' && r_name[0] <= 'z' &&
+	    (r_name[1] == 'l' || r_name[1] == 'h') && r_name[2] == 0)
+	    /* registers r26-r31 referred to by name, ie xl, xh, yl, yh, zl, zh */
+	    op_mask = (r_name[0] - 'x') * 2 + (r_name[1] == 'h') + 26;
+	  else if ((*op == 'v' || *op == 'w') &&
+	    r_name[0] >= 'x' && r_name[0] <= 'z' && r_name[1] == 0)
+	    /* For the movw and addiw instructions, refer to registers x, y and z by name */
+	    op_mask = (r_name[0] - 'x') * 2 + 26;
+	  else
+	    {
+	      op_mask = avr_get_constant (old_str, 31);
+	      str = input_line_pointer;
 	    }
 	}
-      else
+	  if (avr_mcu->isa & AVR_ISA_FEW_REGS)
 	{
-	  op_mask = avr_get_constant (str, 31);
-	  str = input_line_pointer;
+		  if(op_mask < 16)
+		  as_bad (_("register number above 15 required"));
 	}
 
       if (op_mask <= 31)
@@ -959,6 +982,12 @@
 		     &op_expr, FALSE, r_type);
       }
       break;
+    
+    case 'm':
+      str = parse_exp (str, &op_expr);
+      fix_new_exp (frag_now, where, opcode->insn_size * 2,
+		     &op_expr, FALSE, BFD_RELOC_AVR_LDS_STS_16);
+	  break;
 
     case 'n':
       {
@@ -992,23 +1021,15 @@
       break;
 
     case 'P':
-      {
-	unsigned int x;
-
-	x = avr_get_constant (str, 63);
-	str = input_line_pointer;
-	op_mask |= (x & 0xf) | ((x & 0x30) << 5);
-      }
+      str = parse_exp (str, &op_expr);
+      fix_new_exp (frag_now, where, opcode->insn_size * 2,
+		     &op_expr, FALSE, BFD_RELOC_AVR_PORT6);
       break;
 
     case 'p':
-      {
-	unsigned int x;
-
-	x = avr_get_constant (str, 31);
-	str = input_line_pointer;
-	op_mask |= x << 3;
-      }
+      str = parse_exp (str, &op_expr);
+      fix_new_exp (frag_now, where, opcode->insn_size * 2,
+		     &op_expr, FALSE, BFD_RELOC_AVR_PORT5);
       break;
 
     case 'E':
@@ -1353,6 +1374,28 @@
           *where = 0xff & (value >> 16);
           break;
 
+    case BFD_RELOC_AVR_LDS_STS_16:
+	  if ((value < 64) || (value > 191))
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("operand out of range: %ld"), value);
+      bfd_putl16 ((bfd_vma) insn | ((value & 0x40) << 2) | ((value & 0x30) << 5) |
+              (value & 0x0f), where);
+	  break;
+
+    case BFD_RELOC_AVR_PORT6:
+	  if (value > 63)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("operand out of range: %ld"), value);
+      bfd_putl16 ((bfd_vma) insn | ((value & 0x30) << 5) | (value & 0x0f), where);
+	  break;
+
+    case BFD_RELOC_AVR_PORT5:
+	  if (value > 31)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("operand out of range: %ld"), value);
+      bfd_putl16 ((bfd_vma) insn | ((value & 0x1f) << 3), where);
+	  break;
+
         default:
 	  as_fatal (_("line %d: unknown relocation type: 0x%x"),
 		    fixP->fx_line, fixP->fx_r_type);
@@ -1446,6 +1489,10 @@
 
   if (*str && *opcode->constraints == '?')
     ++opcode;
+  
+  /* Special case for opcodes STS and LDS that come in 16-bit and 32-bit versions */
+  if (*str && (opcode->isa & AVR_ISA_BIGRAM) && !(avr_mcu->isa & AVR_ISA_BIGRAM))
+    ++opcode;
 
   if (!avr_opt.all_opcodes && (opcode->isa & avr_mcu->isa) != opcode->isa)
    as_bad (_("illegal opcode %s for mcu %s"), opcode->name, avr_mcu->name);
diff -Naur old/include/elf/avr.h new/include/elf/avr.h
--- old/include/elf/avr.h	2013-11-04 15:33:39.000000000 +0000
+++ new/include/elf/avr.h	2014-08-07 14:43:00.000000000 +0100
@@ -41,6 +41,7 @@
 #define E_AVR_MACH_AVR5     5
 #define E_AVR_MACH_AVR51   51
 #define E_AVR_MACH_AVR6     6 
+#define E_AVR_MACH_AVRTINY10 100 
 #define E_AVR_MACH_XMEGA1 101
 #define E_AVR_MACH_XMEGA2 102
 #define E_AVR_MACH_XMEGA3 103
@@ -69,18 +70,21 @@
      RELOC_NUMBER (R_AVR_LO8_LDI_PM_NEG,       15)
      RELOC_NUMBER (R_AVR_HI8_LDI_PM_NEG,       16)
      RELOC_NUMBER (R_AVR_HH8_LDI_PM_NEG,       17)
-     RELOC_NUMBER (R_AVR_CALL,		       18)
+     RELOC_NUMBER (R_AVR_CALL,	               18)
      RELOC_NUMBER (R_AVR_LDI,                  19)
      RELOC_NUMBER (R_AVR_6,                    20)
      RELOC_NUMBER (R_AVR_6_ADIW,               21)
      RELOC_NUMBER (R_AVR_MS8_LDI,              22)
      RELOC_NUMBER (R_AVR_MS8_LDI_NEG,          23)
-     RELOC_NUMBER (R_AVR_LO8_LDI_GS,	       24)
-     RELOC_NUMBER (R_AVR_HI8_LDI_GS,	       25)
-     RELOC_NUMBER (R_AVR_8, 		       26)
+     RELOC_NUMBER (R_AVR_LO8_LDI_GS,           24)
+     RELOC_NUMBER (R_AVR_HI8_LDI_GS,           25)
+     RELOC_NUMBER (R_AVR_8,                    26)
      RELOC_NUMBER (R_AVR_8_LO8,                27)
      RELOC_NUMBER (R_AVR_8_HI8,                28)
      RELOC_NUMBER (R_AVR_8_HLO8,               29)
+     RELOC_NUMBER (R_AVR_LDS_STS_16,           30)
+     RELOC_NUMBER (R_AVR_PORT6,                31)
+     RELOC_NUMBER (R_AVR_PORT5,                32)
 END_RELOC_NUMBERS (R_AVR_max)
 
 #endif /* _ELF_AVR_H */
diff -Naur old/include/opcode/avr.h new/include/opcode/avr.h
--- old/include/opcode/avr.h	2013-11-04 15:33:39.000000000 +0000
+++ new/include/opcode/avr.h	2014-08-07 14:55:35.000000000 +0100
@@ -18,25 +18,27 @@
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
    MA 02110-1301, USA.  */
 
-#define AVR_ISA_1200  0x0001 /* In the beginning there was ...  */
-#define AVR_ISA_LPM   0x0002 /* device has LPM */
-#define AVR_ISA_LPMX  0x0004 /* device has LPM Rd,Z[+] */
-#define AVR_ISA_SRAM  0x0008 /* device has SRAM (LD, ST, PUSH, POP, ...) */
-#define AVR_ISA_MEGA  0x0020 /* device has >8K program memory (JMP and CALL
+#define AVR_ISA_1200     0x00001 /* In the beginning there was ...  */
+#define AVR_ISA_LPM      0x00002 /* device has LPM */
+#define AVR_ISA_LPMX     0x00004 /* device has LPM Rd,Z[+] */
+#define AVR_ISA_SRAM     0x00008 /* device has SRAM (LD, ST, PUSH, POP, ...) */
+#define AVR_ISA_MEGA     0x00020 /* device has >8K program memory (JMP and CALL
 				supported, no 8K wrap on RJMP and RCALL) */
-#define AVR_ISA_MUL   0x0040 /* device has new core (MUL, FMUL, ...) */
-#define AVR_ISA_ELPM  0x0080 /* device has >64K program memory (ELPM) */
-#define AVR_ISA_ELPMX 0x0100 /* device has ELPM Rd,Z[+] */
-#define AVR_ISA_SPM   0x0200 /* device can program itself */
-#define AVR_ISA_BRK   0x0400 /* device has BREAK (on-chip debug) */
-#define AVR_ISA_EIND  0x0800 /* device has >128K program memory (none yet) */
-#define AVR_ISA_MOVW  0x1000 /* device has MOVW */
-#define AVR_ISA_SPMX  0x2000 /* device has SPM Z[+] */
-#define AVR_ISA_DES   0x4000 /* device has DES */
-#define AVR_ISA_RMW   0x8000 /* device has RMW instructions XCH,LAC,LAS,LAT */
+#define AVR_ISA_MUL      0x00040 /* device has new core (MUL, FMUL, ...) */
+#define AVR_ISA_ELPM     0x00080 /* device has >64K program memory (ELPM) */
+#define AVR_ISA_ELPMX    0x00100 /* device has ELPM Rd,Z[+] */
+#define AVR_ISA_SPM      0x00200 /* device can program itself */
+#define AVR_ISA_BRK      0x00400 /* device has BREAK (on-chip debug) */
+#define AVR_ISA_EIND     0x00800 /* device has >128K program memory (none yet) */
+#define AVR_ISA_MOVW     0x01000 /* device has MOVW */
+#define AVR_ISA_SPMX     0x02000 /* device has SPM Z[+] */
+#define AVR_ISA_DES      0x04000 /* device has DES */
+#define AVR_ISA_RMW      0x08000 /* device has RMW instructions XCH,LAC,LAS,LAT */
+#define AVR_ISA_BIGRAM   0x10000 /* device has 32-bit STS and LDS */
+#define AVR_ISA_FEW_REGS 0x20000 /* device has only r16 - r31 */
 
 #define AVR_ISA_TINY1 (AVR_ISA_1200 | AVR_ISA_LPM)
-#define AVR_ISA_2xxx  (AVR_ISA_TINY1 | AVR_ISA_SRAM)
+#define AVR_ISA_2xxx  (AVR_ISA_TINY1 | AVR_ISA_SRAM | AVR_ISA_BIGRAM)
 /* For the attiny26 which is missing LPM Rd,Z+.  */
 #define AVR_ISA_2xxe  (AVR_ISA_2xxx | AVR_ISA_LPMX)
 #define AVR_ISA_RF401 (AVR_ISA_2xxx | AVR_ISA_MOVW | AVR_ISA_LPMX)
@@ -70,7 +72,10 @@
 #define AVR_ISA_AVR6   (AVR_ISA_1200 | AVR_ISA_LPM | AVR_ISA_LPMX | \
                         AVR_ISA_SRAM | AVR_ISA_MEGA | AVR_ISA_MUL | \
                         AVR_ISA_ELPM | AVR_ISA_ELPMX | AVR_ISA_SPM | \
-                        AVR_ISA_BRK | AVR_ISA_EIND | AVR_ISA_MOVW)
+                        AVR_ISA_BRK | AVR_ISA_EIND | AVR_ISA_MOVW | \
+                        AVR_ISA_BIGRAM)
+#define AVR_ISA_AVRTINY10 (AVR_ISA_1200 | AVR_ISA_BRK | AVR_ISA_SRAM | \
+                           AVR_ISA_FEW_REGS)
 
 #define REGISTER_P(x) ((x) == 'r'		\
 		       || (x) == 'd'		\
@@ -104,6 +109,7 @@
    b - base pointer register and displacement ([YZ]+disp)
    z - Z pointer register (for [e]lpm Rd,Z[+])
    M - immediate value from 0 to 255
+   m - immediate value from 64 to 192
    n - immediate value from 0 to 255 ( n = ~M ). Relocation impossible
    s - immediate value from 0 to 7
    P - Port address value from 0 to 63. (in, out)
@@ -138,163 +144,165 @@
    "11111xxxxxxx1xxx" (1024) 0xf[8-9a-f][0-9a-f][8-9a-f]
  */
 
-AVR_INSN (clc,  "",    "1001010010001000", 1, AVR_ISA_1200, 0x9488)
-AVR_INSN (clh,  "",    "1001010011011000", 1, AVR_ISA_1200, 0x94d8)
-AVR_INSN (cli,  "",    "1001010011111000", 1, AVR_ISA_1200, 0x94f8)
-AVR_INSN (cln,  "",    "1001010010101000", 1, AVR_ISA_1200, 0x94a8)
-AVR_INSN (cls,  "",    "1001010011001000", 1, AVR_ISA_1200, 0x94c8)
-AVR_INSN (clt,  "",    "1001010011101000", 1, AVR_ISA_1200, 0x94e8)
-AVR_INSN (clv,  "",    "1001010010111000", 1, AVR_ISA_1200, 0x94b8)
-AVR_INSN (clz,  "",    "1001010010011000", 1, AVR_ISA_1200, 0x9498)
-
-AVR_INSN (sec,  "",    "1001010000001000", 1, AVR_ISA_1200, 0x9408)
-AVR_INSN (seh,  "",    "1001010001011000", 1, AVR_ISA_1200, 0x9458)
-AVR_INSN (sei,  "",    "1001010001111000", 1, AVR_ISA_1200, 0x9478)
-AVR_INSN (sen,  "",    "1001010000101000", 1, AVR_ISA_1200, 0x9428)
-AVR_INSN (ses,  "",    "1001010001001000", 1, AVR_ISA_1200, 0x9448)
-AVR_INSN (set,  "",    "1001010001101000", 1, AVR_ISA_1200, 0x9468)
-AVR_INSN (sev,  "",    "1001010000111000", 1, AVR_ISA_1200, 0x9438)
-AVR_INSN (sez,  "",    "1001010000011000", 1, AVR_ISA_1200, 0x9418)
+AVR_INSN (clc,    "",    "1001010010001000", 1, AVR_ISA_1200,   0x9488)
+AVR_INSN (clh,    "",    "1001010011011000", 1, AVR_ISA_1200,   0x94d8)
+AVR_INSN (cli,    "",    "1001010011111000", 1, AVR_ISA_1200,   0x94f8)
+AVR_INSN (cln,    "",    "1001010010101000", 1, AVR_ISA_1200,   0x94a8)
+AVR_INSN (cls,    "",    "1001010011001000", 1, AVR_ISA_1200,   0x94c8)
+AVR_INSN (clt,    "",    "1001010011101000", 1, AVR_ISA_1200,   0x94e8)
+AVR_INSN (clv,    "",    "1001010010111000", 1, AVR_ISA_1200,   0x94b8)
+AVR_INSN (clz,    "",    "1001010010011000", 1, AVR_ISA_1200,   0x9498)
+
+AVR_INSN (sec,    "",    "1001010000001000", 1, AVR_ISA_1200,   0x9408)
+AVR_INSN (seh,    "",    "1001010001011000", 1, AVR_ISA_1200,   0x9458)
+AVR_INSN (sei,    "",    "1001010001111000", 1, AVR_ISA_1200,   0x9478)
+AVR_INSN (sen,    "",    "1001010000101000", 1, AVR_ISA_1200,   0x9428)
+AVR_INSN (ses,    "",    "1001010001001000", 1, AVR_ISA_1200,   0x9448)
+AVR_INSN (set,    "",    "1001010001101000", 1, AVR_ISA_1200,   0x9468)
+AVR_INSN (sev,    "",    "1001010000111000", 1, AVR_ISA_1200,   0x9438)
+AVR_INSN (sez,    "",    "1001010000011000", 1, AVR_ISA_1200,   0x9418)
 
    /* Same as {cl,se}[chinstvz] above.  */
-AVR_INSN (bclr, "S",   "100101001SSS1000", 1, AVR_ISA_1200, 0x9488)
-AVR_INSN (bset, "S",   "100101000SSS1000", 1, AVR_ISA_1200, 0x9408)
+AVR_INSN (bclr,   "S",   "100101001SSS1000", 1, AVR_ISA_1200,   0x9488)
+AVR_INSN (bset,   "S",   "100101000SSS1000", 1, AVR_ISA_1200,   0x9408)
 
-AVR_INSN (icall,"",    "1001010100001001", 1, AVR_ISA_2xxx, 0x9509)
-AVR_INSN (ijmp, "",    "1001010000001001", 1, AVR_ISA_2xxx, 0x9409)
+AVR_INSN (icall,  "",    "1001010100001001", 1, AVR_ISA_SRAM,   0x9509)
+AVR_INSN (ijmp,   "",    "1001010000001001", 1, AVR_ISA_SRAM,   0x9409)
 
-AVR_INSN (lpm,  "?",   "1001010111001000", 1, AVR_ISA_TINY1,0x95c8)
-AVR_INSN (lpm,  "r,z", "1001000ddddd010+", 1, AVR_ISA_LPMX, 0x9004)
-AVR_INSN (elpm, "?",   "1001010111011000", 1, AVR_ISA_ELPM, 0x95d8)
-AVR_INSN (elpm, "r,z", "1001000ddddd011+", 1, AVR_ISA_ELPMX,0x9006)
-
-AVR_INSN (nop,  "",    "0000000000000000", 1, AVR_ISA_1200, 0x0000)
-AVR_INSN (ret,  "",    "1001010100001000", 1, AVR_ISA_1200, 0x9508)
-AVR_INSN (reti, "",    "1001010100011000", 1, AVR_ISA_1200, 0x9518)
-AVR_INSN (sleep,"",    "1001010110001000", 1, AVR_ISA_1200, 0x9588)
-AVR_INSN (break,"",    "1001010110011000", 1, AVR_ISA_BRK,  0x9598)
-AVR_INSN (wdr,  "",    "1001010110101000", 1, AVR_ISA_1200, 0x95a8)
-AVR_INSN (spm,  "?",   "1001010111101000", 1, AVR_ISA_SPM,  0x95e8)
-AVR_INSN (spm,  "z",   "10010101111+1000", 1, AVR_ISA_SPMX, 0x95e8)
-
-AVR_INSN (adc,  "r,r", "000111rdddddrrrr", 1, AVR_ISA_1200, 0x1c00)
-AVR_INSN (add,  "r,r", "000011rdddddrrrr", 1, AVR_ISA_1200, 0x0c00)
-AVR_INSN (and,  "r,r", "001000rdddddrrrr", 1, AVR_ISA_1200, 0x2000)
-AVR_INSN (cp,   "r,r", "000101rdddddrrrr", 1, AVR_ISA_1200, 0x1400)
-AVR_INSN (cpc,  "r,r", "000001rdddddrrrr", 1, AVR_ISA_1200, 0x0400)
-AVR_INSN (cpse, "r,r", "000100rdddddrrrr", 1, AVR_ISA_1200, 0x1000)
-AVR_INSN (eor,  "r,r", "001001rdddddrrrr", 1, AVR_ISA_1200, 0x2400)
-AVR_INSN (mov,  "r,r", "001011rdddddrrrr", 1, AVR_ISA_1200, 0x2c00)
-AVR_INSN (mul,  "r,r", "100111rdddddrrrr", 1, AVR_ISA_MUL,  0x9c00)
-AVR_INSN (or,   "r,r", "001010rdddddrrrr", 1, AVR_ISA_1200, 0x2800)
-AVR_INSN (sbc,  "r,r", "000010rdddddrrrr", 1, AVR_ISA_1200, 0x0800)
-AVR_INSN (sub,  "r,r", "000110rdddddrrrr", 1, AVR_ISA_1200, 0x1800)
+AVR_INSN (lpm,    "?",   "1001010111001000", 1, AVR_ISA_TINY1,  0x95c8)
+AVR_INSN (lpm,    "r,z", "1001000ddddd010+", 1, AVR_ISA_LPMX,   0x9004)
+AVR_INSN (elpm,   "?",   "1001010111011000", 1, AVR_ISA_ELPM,   0x95d8)
+AVR_INSN (elpm,   "r,z", "1001000ddddd011+", 1, AVR_ISA_ELPMX,  0x9006)
+
+AVR_INSN (nop,    "",    "0000000000000000", 1, AVR_ISA_1200,   0x0000)
+AVR_INSN (ret,    "",    "1001010100001000", 1, AVR_ISA_1200,   0x9508)
+AVR_INSN (reti,   "",    "1001010100011000", 1, AVR_ISA_1200,   0x9518)
+AVR_INSN (sleep,  "",    "1001010110001000", 1, AVR_ISA_1200,   0x9588)
+AVR_INSN (break,  "",    "1001010110011000", 1, AVR_ISA_BRK,    0x9598)
+AVR_INSN (wdr,    "",    "1001010110101000", 1, AVR_ISA_1200,   0x95a8)
+AVR_INSN (spm,    "?",   "1001010111101000", 1, AVR_ISA_SPM,    0x95e8)
+AVR_INSN (spm,    "z",   "10010101111+1000", 1, AVR_ISA_SPMX,   0x95e8)
+
+AVR_INSN (adc,    "r,r", "000111rdddddrrrr", 1, AVR_ISA_1200,   0x1c00)
+AVR_INSN (add,    "r,r", "000011rdddddrrrr", 1, AVR_ISA_1200,   0x0c00)
+AVR_INSN (and,    "r,r", "001000rdddddrrrr", 1, AVR_ISA_1200,   0x2000)
+AVR_INSN (cp,     "r,r", "000101rdddddrrrr", 1, AVR_ISA_1200,   0x1400)
+AVR_INSN (cpc,    "r,r", "000001rdddddrrrr", 1, AVR_ISA_1200,   0x0400)
+AVR_INSN (cpse,   "r,r", "000100rdddddrrrr", 1, AVR_ISA_1200,   0x1000)
+AVR_INSN (eor,    "r,r", "001001rdddddrrrr", 1, AVR_ISA_1200,   0x2400)
+AVR_INSN (mov,    "r,r", "001011rdddddrrrr", 1, AVR_ISA_1200,   0x2c00)
+AVR_INSN (mul,    "r,r", "100111rdddddrrrr", 1, AVR_ISA_MUL,    0x9c00)
+AVR_INSN (or,     "r,r", "001010rdddddrrrr", 1, AVR_ISA_1200,   0x2800)
+AVR_INSN (sbc,    "r,r", "000010rdddddrrrr", 1, AVR_ISA_1200,   0x0800)
+AVR_INSN (sub,    "r,r", "000110rdddddrrrr", 1, AVR_ISA_1200,   0x1800)
 
    /* Shorthand for {eor,add,adc,and} r,r above.  */
-AVR_INSN (clr,  "r=r", "001001rdddddrrrr", 1, AVR_ISA_1200, 0x2400)
-AVR_INSN (lsl,  "r=r", "000011rdddddrrrr", 1, AVR_ISA_1200, 0x0c00)
-AVR_INSN (rol,  "r=r", "000111rdddddrrrr", 1, AVR_ISA_1200, 0x1c00)
-AVR_INSN (tst,  "r=r", "001000rdddddrrrr", 1, AVR_ISA_1200, 0x2000)
+AVR_INSN (clr,    "r=r", "001001rdddddrrrr", 1, AVR_ISA_1200,   0x2400)
+AVR_INSN (lsl,    "r=r", "000011rdddddrrrr", 1, AVR_ISA_1200,   0x0c00)
+AVR_INSN (rol,    "r=r", "000111rdddddrrrr", 1, AVR_ISA_1200,   0x1c00)
+AVR_INSN (tst,    "r=r", "001000rdddddrrrr", 1, AVR_ISA_1200,   0x2000)
 
-AVR_INSN (andi, "d,M", "0111KKKKddddKKKK", 1, AVR_ISA_1200, 0x7000)
+AVR_INSN (andi,   "d,M", "0111KKKKddddKKKK", 1, AVR_ISA_1200,   0x7000)
   /*XXX special case*/
-AVR_INSN (cbr,  "d,n", "0111KKKKddddKKKK", 1, AVR_ISA_1200, 0x7000)
+AVR_INSN (cbr,    "d,n", "0111KKKKddddKKKK", 1, AVR_ISA_1200,   0x7000)
 
-AVR_INSN (ldi,  "d,M", "1110KKKKddddKKKK", 1, AVR_ISA_1200, 0xe000)
-AVR_INSN (ser,  "d",   "11101111dddd1111", 1, AVR_ISA_1200, 0xef0f)
+AVR_INSN (ldi,    "d,M", "1110KKKKddddKKKK", 1, AVR_ISA_1200,   0xe000)
+AVR_INSN (ser,    "d",   "11101111dddd1111", 1, AVR_ISA_1200,   0xef0f)
 
-AVR_INSN (ori,  "d,M", "0110KKKKddddKKKK", 1, AVR_ISA_1200, 0x6000)
-AVR_INSN (sbr,  "d,M", "0110KKKKddddKKKK", 1, AVR_ISA_1200, 0x6000)
+AVR_INSN (ori,    "d,M", "0110KKKKddddKKKK", 1, AVR_ISA_1200,   0x6000)
+AVR_INSN (sbr,    "d,M", "0110KKKKddddKKKK", 1, AVR_ISA_1200,   0x6000)
 
-AVR_INSN (cpi,  "d,M", "0011KKKKddddKKKK", 1, AVR_ISA_1200, 0x3000)
-AVR_INSN (sbci, "d,M", "0100KKKKddddKKKK", 1, AVR_ISA_1200, 0x4000)
-AVR_INSN (subi, "d,M", "0101KKKKddddKKKK", 1, AVR_ISA_1200, 0x5000)
-
-AVR_INSN (sbrc, "r,s", "1111110rrrrr0sss", 1, AVR_ISA_1200, 0xfc00)
-AVR_INSN (sbrs, "r,s", "1111111rrrrr0sss", 1, AVR_ISA_1200, 0xfe00)
-AVR_INSN (bld,  "r,s", "1111100ddddd0sss", 1, AVR_ISA_1200, 0xf800)
-AVR_INSN (bst,  "r,s", "1111101ddddd0sss", 1, AVR_ISA_1200, 0xfa00)
-
-AVR_INSN (in,   "r,P", "10110PPdddddPPPP", 1, AVR_ISA_1200, 0xb000)
-AVR_INSN (out,  "P,r", "10111PPrrrrrPPPP", 1, AVR_ISA_1200, 0xb800)
-
-AVR_INSN (adiw, "w,K", "10010110KKddKKKK", 1, AVR_ISA_2xxx, 0x9600)
-AVR_INSN (sbiw, "w,K", "10010111KKddKKKK", 1, AVR_ISA_2xxx, 0x9700)
-
-AVR_INSN (cbi,  "p,s", "10011000pppppsss", 1, AVR_ISA_1200, 0x9800)
-AVR_INSN (sbi,  "p,s", "10011010pppppsss", 1, AVR_ISA_1200, 0x9a00)
-AVR_INSN (sbic, "p,s", "10011001pppppsss", 1, AVR_ISA_1200, 0x9900)
-AVR_INSN (sbis, "p,s", "10011011pppppsss", 1, AVR_ISA_1200, 0x9b00)
-
-AVR_INSN (brcc, "l",   "111101lllllll000", 1, AVR_ISA_1200, 0xf400)
-AVR_INSN (brcs, "l",   "111100lllllll000", 1, AVR_ISA_1200, 0xf000)
-AVR_INSN (breq, "l",   "111100lllllll001", 1, AVR_ISA_1200, 0xf001)
-AVR_INSN (brge, "l",   "111101lllllll100", 1, AVR_ISA_1200, 0xf404)
-AVR_INSN (brhc, "l",   "111101lllllll101", 1, AVR_ISA_1200, 0xf405)
-AVR_INSN (brhs, "l",   "111100lllllll101", 1, AVR_ISA_1200, 0xf005)
-AVR_INSN (brid, "l",   "111101lllllll111", 1, AVR_ISA_1200, 0xf407)
-AVR_INSN (brie, "l",   "111100lllllll111", 1, AVR_ISA_1200, 0xf007)
-AVR_INSN (brlo, "l",   "111100lllllll000", 1, AVR_ISA_1200, 0xf000)
-AVR_INSN (brlt, "l",   "111100lllllll100", 1, AVR_ISA_1200, 0xf004)
-AVR_INSN (brmi, "l",   "111100lllllll010", 1, AVR_ISA_1200, 0xf002)
-AVR_INSN (brne, "l",   "111101lllllll001", 1, AVR_ISA_1200, 0xf401)
-AVR_INSN (brpl, "l",   "111101lllllll010", 1, AVR_ISA_1200, 0xf402)
-AVR_INSN (brsh, "l",   "111101lllllll000", 1, AVR_ISA_1200, 0xf400)
-AVR_INSN (brtc, "l",   "111101lllllll110", 1, AVR_ISA_1200, 0xf406)
-AVR_INSN (brts, "l",   "111100lllllll110", 1, AVR_ISA_1200, 0xf006)
-AVR_INSN (brvc, "l",   "111101lllllll011", 1, AVR_ISA_1200, 0xf403)
-AVR_INSN (brvs, "l",   "111100lllllll011", 1, AVR_ISA_1200, 0xf003)
+AVR_INSN (cpi,    "d,M", "0011KKKKddddKKKK", 1, AVR_ISA_1200,   0x3000)
+AVR_INSN (sbci,   "d,M", "0100KKKKddddKKKK", 1, AVR_ISA_1200,   0x4000)
+AVR_INSN (subi,   "d,M", "0101KKKKddddKKKK", 1, AVR_ISA_1200,   0x5000)
+
+AVR_INSN (sbrc,   "r,s", "1111110rrrrr0sss", 1, AVR_ISA_1200,   0xfc00)
+AVR_INSN (sbrs,   "r,s", "1111111rrrrr0sss", 1, AVR_ISA_1200,   0xfe00)
+AVR_INSN (bld,    "r,s", "1111100ddddd0sss", 1, AVR_ISA_1200,   0xf800)
+AVR_INSN (bst,    "r,s", "1111101ddddd0sss", 1, AVR_ISA_1200,   0xfa00)
+
+AVR_INSN (in,     "r,P", "10110PPdddddPPPP", 1, AVR_ISA_1200,   0xb000)
+AVR_INSN (out,    "P,r", "10111PPrrrrrPPPP", 1, AVR_ISA_1200,   0xb800)
+
+AVR_INSN (adiw,   "w,K", "10010110KKddKKKK", 1, AVR_ISA_2xxx,   0x9600)
+AVR_INSN (sbiw,   "w,K", "10010111KKddKKKK", 1, AVR_ISA_2xxx,   0x9700)
+
+AVR_INSN (cbi,    "p,s", "10011000pppppsss", 1, AVR_ISA_1200,   0x9800)
+AVR_INSN (sbi,    "p,s", "10011010pppppsss", 1, AVR_ISA_1200,   0x9a00)
+AVR_INSN (sbic,   "p,s", "10011001pppppsss", 1, AVR_ISA_1200,   0x9900)
+AVR_INSN (sbis,   "p,s", "10011011pppppsss", 1, AVR_ISA_1200,   0x9b00)
+
+AVR_INSN (brcc,   "l",   "111101lllllll000", 1, AVR_ISA_1200,   0xf400)
+AVR_INSN (brcs,   "l",   "111100lllllll000", 1, AVR_ISA_1200,   0xf000)
+AVR_INSN (breq,   "l",   "111100lllllll001", 1, AVR_ISA_1200,   0xf001)
+AVR_INSN (brge,   "l",   "111101lllllll100", 1, AVR_ISA_1200,   0xf404)
+AVR_INSN (brhc,   "l",   "111101lllllll101", 1, AVR_ISA_1200,   0xf405)
+AVR_INSN (brhs,   "l",   "111100lllllll101", 1, AVR_ISA_1200,   0xf005)
+AVR_INSN (brid,   "l",   "111101lllllll111", 1, AVR_ISA_1200,   0xf407)
+AVR_INSN (brie,   "l",   "111100lllllll111", 1, AVR_ISA_1200,   0xf007)
+AVR_INSN (brlo,   "l",   "111100lllllll000", 1, AVR_ISA_1200,   0xf000)
+AVR_INSN (brlt,   "l",   "111100lllllll100", 1, AVR_ISA_1200,   0xf004)
+AVR_INSN (brmi,   "l",   "111100lllllll010", 1, AVR_ISA_1200,   0xf002)
+AVR_INSN (brne,   "l",   "111101lllllll001", 1, AVR_ISA_1200,   0xf401)
+AVR_INSN (brpl,   "l",   "111101lllllll010", 1, AVR_ISA_1200,   0xf402)
+AVR_INSN (brsh,   "l",   "111101lllllll000", 1, AVR_ISA_1200,   0xf400)
+AVR_INSN (brtc,   "l",   "111101lllllll110", 1, AVR_ISA_1200,   0xf406)
+AVR_INSN (brts,   "l",   "111100lllllll110", 1, AVR_ISA_1200,   0xf006)
+AVR_INSN (brvc,   "l",   "111101lllllll011", 1, AVR_ISA_1200,   0xf403)
+AVR_INSN (brvs,   "l",   "111100lllllll011", 1, AVR_ISA_1200,   0xf003)
 
    /* Same as br?? above.  */
-AVR_INSN (brbc, "s,l", "111101lllllllsss", 1, AVR_ISA_1200, 0xf400)
-AVR_INSN (brbs, "s,l", "111100lllllllsss", 1, AVR_ISA_1200, 0xf000)
+AVR_INSN (brbc,   "s,l", "111101lllllllsss", 1, AVR_ISA_1200,   0xf400)
+AVR_INSN (brbs,   "s,l", "111100lllllllsss", 1, AVR_ISA_1200,   0xf000)
 
-AVR_INSN (rcall, "L",  "1101LLLLLLLLLLLL", 1, AVR_ISA_1200, 0xd000)
-AVR_INSN (rjmp,  "L",  "1100LLLLLLLLLLLL", 1, AVR_ISA_1200, 0xc000)
+AVR_INSN (rcall,  "L",   "1101LLLLLLLLLLLL", 1, AVR_ISA_1200,   0xd000)
+AVR_INSN (rjmp,   "L",   "1100LLLLLLLLLLLL", 1, AVR_ISA_1200,   0xc000)
 
-AVR_INSN (call, "h",   "1001010hhhhh111h", 2, AVR_ISA_MEGA, 0x940e)
-AVR_INSN (jmp,  "h",   "1001010hhhhh110h", 2, AVR_ISA_MEGA, 0x940c)
+AVR_INSN (call,   "h",   "1001010hhhhh111h", 2, AVR_ISA_MEGA,   0x940e)
+AVR_INSN (jmp,    "h",   "1001010hhhhh110h", 2, AVR_ISA_MEGA,   0x940c)
 
-AVR_INSN (asr,  "r",   "1001010rrrrr0101", 1, AVR_ISA_1200, 0x9405)
-AVR_INSN (com,  "r",   "1001010rrrrr0000", 1, AVR_ISA_1200, 0x9400)
-AVR_INSN (dec,  "r",   "1001010rrrrr1010", 1, AVR_ISA_1200, 0x940a)
-AVR_INSN (inc,  "r",   "1001010rrrrr0011", 1, AVR_ISA_1200, 0x9403)
-AVR_INSN (lsr,  "r",   "1001010rrrrr0110", 1, AVR_ISA_1200, 0x9406)
-AVR_INSN (neg,  "r",   "1001010rrrrr0001", 1, AVR_ISA_1200, 0x9401)
-AVR_INSN (pop,  "r",   "1001000rrrrr1111", 1, AVR_ISA_2xxx, 0x900f)
-AVR_INSN (push, "r",   "1001001rrrrr1111", 1, AVR_ISA_2xxx, 0x920f)
-AVR_INSN (ror,  "r",   "1001010rrrrr0111", 1, AVR_ISA_1200, 0x9407)
-AVR_INSN (swap, "r",   "1001010rrrrr0010", 1, AVR_ISA_1200, 0x9402)
+AVR_INSN (asr,    "r",   "1001010rrrrr0101", 1, AVR_ISA_1200,   0x9405)
+AVR_INSN (com,    "r",   "1001010rrrrr0000", 1, AVR_ISA_1200,   0x9400)
+AVR_INSN (dec,    "r",   "1001010rrrrr1010", 1, AVR_ISA_1200,   0x940a)
+AVR_INSN (inc,    "r",   "1001010rrrrr0011", 1, AVR_ISA_1200,   0x9403)
+AVR_INSN (lsr,    "r",   "1001010rrrrr0110", 1, AVR_ISA_1200,   0x9406)
+AVR_INSN (neg,    "r",   "1001010rrrrr0001", 1, AVR_ISA_1200,   0x9401)
+AVR_INSN (pop,    "r",   "1001000rrrrr1111", 1, AVR_ISA_SRAM,   0x900f)
+AVR_INSN (push,   "r",   "1001001rrrrr1111", 1, AVR_ISA_SRAM,   0x920f)
+AVR_INSN (ror,    "r",   "1001010rrrrr0111", 1, AVR_ISA_1200,   0x9407)
+AVR_INSN (swap,   "r",   "1001010rrrrr0010", 1, AVR_ISA_1200,   0x9402)
 
    /* Atomic memory operations for XMEGA.  List before `sts'.  */
-AVR_INSN (xch,  "z,r",   "1001001rrrrr0100", 1, AVR_ISA_RMW, 0x9204)
-AVR_INSN (las,  "z,r",   "1001001rrrrr0101", 1, AVR_ISA_RMW, 0x9205)
-AVR_INSN (lac,  "z,r",   "1001001rrrrr0110", 1, AVR_ISA_RMW, 0x9206)
-AVR_INSN (lat,  "z,r",   "1001001rrrrr0111", 1, AVR_ISA_RMW, 0x9207)
+AVR_INSN (xch,    "z,r", "1001001rrrrr0100", 1, AVR_ISA_RMW,    0x9204)
+AVR_INSN (las,    "z,r", "1001001rrrrr0101", 1, AVR_ISA_RMW,    0x9205)
+AVR_INSN (lac,    "z,r", "1001001rrrrr0110", 1, AVR_ISA_RMW,    0x9206)
+AVR_INSN (lat,    "z,r", "1001001rrrrr0111", 1, AVR_ISA_RMW,    0x9207)
 
    /* Known to be decoded as `nop' by the old core.  */
-AVR_INSN (movw, "v,v", "00000001ddddrrrr", 1, AVR_ISA_MOVW, 0x0100)
-AVR_INSN (muls, "d,d", "00000010ddddrrrr", 1, AVR_ISA_MUL,  0x0200)
-AVR_INSN (mulsu,"a,a", "000000110ddd0rrr", 1, AVR_ISA_MUL,  0x0300)
-AVR_INSN (fmul, "a,a", "000000110ddd1rrr", 1, AVR_ISA_MUL,  0x0308)
-AVR_INSN (fmuls,"a,a", "000000111ddd0rrr", 1, AVR_ISA_MUL,  0x0380)
-AVR_INSN (fmulsu,"a,a","000000111ddd1rrr", 1, AVR_ISA_MUL,  0x0388)
-
-AVR_INSN (sts,  "i,r", "1001001ddddd0000", 2, AVR_ISA_2xxx, 0x9200)
-AVR_INSN (lds,  "r,i", "1001000ddddd0000", 2, AVR_ISA_2xxx, 0x9000)
+AVR_INSN (movw,   "v,v", "00000001ddddrrrr", 1, AVR_ISA_MOVW,   0x0100)
+AVR_INSN (muls,   "d,d", "00000010ddddrrrr", 1, AVR_ISA_MUL,    0x0200)
+AVR_INSN (mulsu,  "a,a", "000000110ddd0rrr", 1, AVR_ISA_MUL,    0x0300)
+AVR_INSN (fmul,   "a,a", "000000110ddd1rrr", 1, AVR_ISA_MUL,    0x0308)
+AVR_INSN (fmuls,  "a,a", "000000111ddd0rrr", 1, AVR_ISA_MUL,    0x0380)
+AVR_INSN (fmulsu, "a,a", "000000111ddd1rrr", 1, AVR_ISA_MUL,    0x0388)
+
+AVR_INSN (sts,    "i,r", "1001001ddddd0000", 2, AVR_ISA_BIGRAM, 0x9200)
+AVR_INSN (sts,    "m,d", "10101KKKddddKKKK", 1, AVR_ISA_SRAM,   0xa800)
+AVR_INSN (lds,    "r,i", "1001000ddddd0000", 2, AVR_ISA_BIGRAM, 0x9000)
+AVR_INSN (lds,    "d,m", "10100KKKddddKKKK", 1, AVR_ISA_SRAM,   0xa000)
 
    /* Special case for b+0, `e' must be next entry after `b',
       b={Y=1,Z=0}, ee={X=11,Y=10,Z=00}, !=1 if -e or e+ or X.  */
-AVR_INSN (ldd,  "r,b", "10o0oo0dddddbooo", 1, AVR_ISA_2xxx, 0x8000)
-AVR_INSN (ld,   "r,e", "100!000dddddee-+", 1, AVR_ISA_1200, 0x8000)
-AVR_INSN (std,  "b,r", "10o0oo1rrrrrbooo", 1, AVR_ISA_2xxx, 0x8200)
-AVR_INSN (st,   "e,r", "100!001rrrrree-+", 1, AVR_ISA_1200, 0x8200)
+AVR_INSN (ldd,    "r,b", "10o0oo0dddddbooo", 1, AVR_ISA_2xxx,   0x8000)
+AVR_INSN (ld,     "r,e", "100!000dddddee-+", 1, AVR_ISA_1200,   0x8000)
+AVR_INSN (std,    "b,r", "10o0oo1rrrrrbooo", 1, AVR_ISA_2xxx,   0x8200)
+AVR_INSN (st,     "e,r", "100!001rrrrree-+", 1, AVR_ISA_1200,   0x8200)
 
    /* These are for devices that don't exist yet
       (>128K program memory, PC = EIND:Z).  */
-AVR_INSN (eicall, "",  "1001010100011001", 1, AVR_ISA_EIND, 0x9519)
-AVR_INSN (eijmp, "",   "1001010000011001", 1, AVR_ISA_EIND, 0x9419)
+AVR_INSN (eicall, "",   "1001010100011001", 1, AVR_ISA_EIND,    0x9519)
+AVR_INSN (eijmp,  "",   "1001010000011001", 1, AVR_ISA_EIND,    0x9419)
 
 /* DES instruction for encryption and decryption */
-AVR_INSN (des,  "E",   "10010100EEEE1011", 1, AVR_ISA_DES,  0x940B)
+AVR_INSN (des,    "E",  "10010100EEEE1011", 1, AVR_ISA_DES,     0x940B)
 
diff -Naur old/ld/Makefile.am new/ld/Makefile.am
--- old/ld/Makefile.am	2013-11-26 11:37:33.000000000 +0000
+++ new/ld/Makefile.am	2014-08-07 14:43:00.000000000 +0100
@@ -190,6 +190,7 @@
 	eavrxmega5.c \
 	eavrxmega6.c \
 	eavrxmega7.c \
+	eavrtiny10.c \
 	ecoff_i860.c \
 	ecoff_sparc.c \
 	ecrisaout.c \
@@ -873,6 +874,10 @@
   $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} avrxmega7 "$(tdir_avr2)"
+eavrtiny10.c: $(srcdir)/emulparams/avrtiny10.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avrtiny10.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrtiny10 "$(tdir_avr2)"
 ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} coff_i860 "$(tdir_coff_i860)"
diff -Naur old/ld/Makefile.in new/ld/Makefile.in
--- old/ld/Makefile.in	2013-11-26 11:37:33.000000000 +0000
+++ new/ld/Makefile.in	2014-08-07 14:43:00.000000000 +0100
@@ -498,6 +498,7 @@
 	eavrxmega5.c \
 	eavrxmega6.c \
 	eavrxmega7.c \
+	eavrtiny10.c \
 	ecoff_i860.c \
 	ecoff_sparc.c \
 	ecrisaout.c \
@@ -1134,6 +1135,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrxmega5.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrxmega6.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrxmega7.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrtiny10.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ecoff_i860.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ecoff_sparc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ecrisaout.Po@am__quote@
@@ -2357,6 +2359,10 @@
   $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} avrxmega7 "$(tdir_avr2)"
+eavrtiny10.c: $(srcdir)/emulparams/avrtiny10.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrtiny10 "$(tdir_avr2)"
 ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} coff_i860 "$(tdir_coff_i860)"
diff -Naur old/ld/configure.tgt new/ld/configure.tgt
--- old/ld/configure.tgt	2013-11-26 11:37:33.000000000 +0000
+++ new/ld/configure.tgt	2014-08-07 14:43:00.000000000 +0100
@@ -138,7 +138,7 @@
 arm-*-vxworks)		targ_emul=armelf_vxworks ;;
 arm*-*-conix*)		targ_emul=armelf ;;
 avr-*-*)		targ_emul=avr2
-			targ_extra_emuls="avr1 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega1 avrxmega2 avrxmega3 avrxmega4 avrxmega5 avrxmega6 avrxmega7"
+			targ_extra_emuls="avr1 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega1 avrxmega2 avrxmega3 avrxmega4 avrxmega5 avrxmega6 avrxmega7 avrtiny10"
 			;;
 bfin-*-elf)		targ_emul=elf32bfin;
 			targ_extra_emuls="elf32bfinfd"
diff -Naur old/ld/emulparams/avrtiny10.sh new/ld/emulparams/avrtiny10.sh
--- old/ld/emulparams/avrtiny10.sh	1970-01-01 01:00:00.000000000 +0100
+++ new/ld/emulparams/avrtiny10.sh	2014-08-07 14:43:00.000000000 +0100
@@ -0,0 +1,13 @@
+ARCH=avr:100
+MACHINE=
+SCRIPT_NAME=avrtiny10
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=elf32
+
+TEXT_ORIGIN=0x0
+TEXT_LENGTH=4K
+DATA_ORIGIN=0x0800040
+DATA_LENGTH=0x1F
+EXTRA_EM_FILE=avrelf
diff -Naur old/ld/scripttempl/avrtiny10.sc new/ld/scripttempl/avrtiny10.sc
--- old/ld/scripttempl/avrtiny10.sc	1970-01-01 01:00:00.000000000 +0100
+++ new/ld/scripttempl/avrtiny10.sc	2014-08-07 14:43:00.000000000 +0100
@@ -0,0 +1,240 @@
+cat <<EOF
+OUTPUT_FORMAT("${OUTPUT_FORMAT}","${OUTPUT_FORMAT}","${OUTPUT_FORMAT}")
+OUTPUT_ARCH(${ARCH})
+
+MEMORY
+{
+  text   (rx)   : ORIGIN = $TEXT_ORIGIN, LENGTH = $TEXT_LENGTH
+  data   (rw!x) : ORIGIN = $DATA_ORIGIN, LENGTH = $DATA_LENGTH
+  lock      (rw!x) : ORIGIN = 0x3F00, LENGTH = 2
+  signature (rw!x) : ORIGIN = 0x3FC0, LENGTH = 4
+/* REVISIT: fuse(rw!x) : */
+}
+
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  ${TEXT_DYNAMIC+${DYNAMIC}}
+  .hash        ${RELOCATING-0} : { *(.hash)		}
+  .dynsym      ${RELOCATING-0} : { *(.dynsym)		}
+  .dynstr      ${RELOCATING-0} : { *(.dynstr)		}
+  .gnu.version ${RELOCATING-0} : { *(.gnu.version)	}
+  .gnu.version_d ${RELOCATING-0} : { *(.gnu.version_d)	}
+  .gnu.version_r ${RELOCATING-0} : { *(.gnu.version_r)	}
+
+  .rel.init    ${RELOCATING-0} : { *(.rel.init)		}
+  .rela.init   ${RELOCATING-0} : { *(.rela.init)	}
+  .rel.text    ${RELOCATING-0} :
+    {
+      *(.rel.text)
+      ${RELOCATING+*(.rel.text.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.t*)}
+    }
+  .rela.text   ${RELOCATING-0} :
+    {
+      *(.rela.text)
+      ${RELOCATING+*(.rela.text.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.t*)}
+    }
+  .rel.fini    ${RELOCATING-0} : { *(.rel.fini)		}
+  .rela.fini   ${RELOCATING-0} : { *(.rela.fini)	}
+  .rel.rodata  ${RELOCATING-0} :
+    {
+      *(.rel.rodata)
+      ${RELOCATING+*(.rel.rodata.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.r*)}
+    }
+  .rela.rodata ${RELOCATING-0} :
+    {
+      *(.rela.rodata)
+      ${RELOCATING+*(.rela.rodata.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.r*)}
+    }
+  .rel.data    ${RELOCATING-0} :
+    {
+      *(.rel.data)
+      ${RELOCATING+*(.rel.data.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.d*)}
+    }
+  .rela.data   ${RELOCATING-0} :
+    {
+      *(.rela.data)
+      ${RELOCATING+*(.rela.data.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.d*)}
+    }
+  .rel.ctors   ${RELOCATING-0} : { *(.rel.ctors)	}
+  .rela.ctors  ${RELOCATING-0} : { *(.rela.ctors)	}
+  .rel.dtors   ${RELOCATING-0} : { *(.rel.dtors)	}
+  .rela.dtors  ${RELOCATING-0} : { *(.rela.dtors)	}
+  .rel.got     ${RELOCATING-0} : { *(.rel.got)		}
+  .rela.got    ${RELOCATING-0} : { *(.rela.got)		}
+  .rel.bss     ${RELOCATING-0} : { *(.rel.bss)		}
+  .rela.bss    ${RELOCATING-0} : { *(.rela.bss)		}
+  .rel.plt     ${RELOCATING-0} : { *(.rel.plt)		}
+  .rela.plt    ${RELOCATING-0} : { *(.rela.plt)		}
+
+  /* Internal text space or external memory.  */
+  .text ${RELOCATING-0} : ${RELOCATING+ AT (0x0)}
+  {
+    *(.vectors)
+    KEEP(*(.vectors))
+
+    /* For data that needs to reside in the lower 64k of progmem.  */
+    *(.progmem.gcc*)
+    *(.progmem*)
+    ${RELOCATING+. = ALIGN(2);}
+
+    ${CONSTRUCTING+ __trampolines_start = . ; }
+    /* The jump trampolines for the 16-bit limited relocs will reside here.  */
+    *(.trampolines)
+    *(.trampolines*)
+    ${CONSTRUCTING+ __trampolines_end = . ; }
+
+    /* For future tablejump instruction arrays for 3 byte pc devices.
+       We don't relax jump/call instructions within these sections.  */
+    *(.jumptables) 
+    *(.jumptables*) 
+
+    /* For code that needs to reside in the lower 128k progmem.  */
+    *(.lowtext)
+    *(.lowtext*)
+
+    ${CONSTRUCTING+ __ctors_start = . ; }
+    ${CONSTRUCTING+ *(.ctors) }
+    ${CONSTRUCTING+ __ctors_end = . ; }
+    ${CONSTRUCTING+ __dtors_start = . ; }
+    ${CONSTRUCTING+ *(.dtors) }
+    ${CONSTRUCTING+ __dtors_end = . ; }
+    KEEP(SORT(*)(.ctors))
+    KEEP(SORT(*)(.dtors))
+
+    /* From this point on, we don't bother about wether the insns are
+       below or above the 16 bits boundary.  */
+    *(.init0)  /* Start here after reset.  */
+    KEEP (*(.init0))
+    *(.init1)
+    KEEP (*(.init1))
+    *(.init2)  /* Clear __zero_reg__, set up stack pointer.  */
+    KEEP (*(.init2))
+    *(.init3)
+    KEEP (*(.init3))
+    *(.init4)  /* Initialize data and BSS.  */
+    KEEP (*(.init4))
+    *(.init5)
+    KEEP (*(.init5))
+    *(.init6)  /* C++ constructors.  */
+    KEEP (*(.init6))
+    *(.init7)
+    KEEP (*(.init7))
+    *(.init8)
+    KEEP (*(.init8))
+    *(.init9)  /* Call main().  */
+    KEEP (*(.init9))
+    *(.text)
+    ${RELOCATING+. = ALIGN(2);}
+    *(.text.*)
+    ${RELOCATING+. = ALIGN(2);}
+    *(.fini9)  /* _exit() starts here.  */
+    KEEP (*(.fini9))
+    *(.fini8)
+    KEEP (*(.fini8))
+    *(.fini7)
+    KEEP (*(.fini7))
+    *(.fini6)  /* C++ destructors.  */
+    KEEP (*(.fini6))
+    *(.fini5)
+    KEEP (*(.fini5))
+    *(.fini4)
+    KEEP (*(.fini4))
+    *(.fini3)
+    KEEP (*(.fini3))
+    *(.fini2)
+    KEEP (*(.fini2))
+    *(.fini1)
+    KEEP (*(.fini1))
+    *(.fini0)  /* Infinite loop after program termination.  */
+    KEEP (*(.fini0))
+    ${RELOCATING+ _etext = . ; }
+  } ${RELOCATING+ > text}
+
+  .data	${RELOCATING-0} : ${RELOCATING+AT (ADDR (.text) + SIZEOF (.text))}
+  {
+    ${RELOCATING+ PROVIDE (__data_start = .) ; }
+    *(.data)
+    *(.data*)
+    *(.rodata)  /* We need to include .rodata here if gcc is used */
+    *(.rodata*) /* with -fdata-sections.  */
+    *(.gnu.linkonce.d*)
+    ${RELOCATING+. = ALIGN(2);}
+    ${RELOCATING+ _edata = . ; }
+    ${RELOCATING+ PROVIDE (__data_end = .) ; }
+  } ${RELOCATING+ > data}
+
+  .bss ${RELOCATING-0} :${RELOCATING+ AT (ADDR (.bss))}
+  {
+    ${RELOCATING+ PROVIDE (__bss_start = .) ; }
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+    ${RELOCATING+ PROVIDE (__bss_end = .) ; }
+  } ${RELOCATING+ > data}
+
+  ${RELOCATING+ __data_load_start = LOADADDR(.data); }
+  ${RELOCATING+ __data_load_end = __data_load_start + SIZEOF(.data); }
+
+  /* Global data not cleared after reset.  */
+  .noinit ${RELOCATING-0}:
+  {
+    ${RELOCATING+ PROVIDE (__noinit_start = .) ; }
+    *(.noinit*)
+    ${RELOCATING+ PROVIDE (__noinit_end = .) ; }
+    ${RELOCATING+ _end = . ;  }
+    ${RELOCATING+ PROVIDE (__heap_start = .) ; }
+  } ${RELOCATING+ > data}
+
+  .lock ${RELOCATING-0}:
+  {
+    KEEP(*(.lock*))
+  } ${RELOCATING+ > lock}
+
+  .signature ${RELOCATING-0}:
+  {
+    KEEP(*(.signature*))
+  } ${RELOCATING+ > signature}
+
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+ 
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+
+  /* DWARF 1 */
+  .debug          0 : { *(.debug) }
+  .line           0 : { *(.line) }
+
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info) *(.gnu.linkonce.wi.*) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+}
+EOF
+
diff -Naur old/opcodes/avr-dis.c new/opcodes/avr-dis.c
--- old/opcodes/avr-dis.c	2013-11-04 15:33:40.000000000 +0000
+++ new/opcodes/avr-dis.c	2014-08-07 14:43:00.000000000 +0100
@@ -33,7 +33,7 @@
   char *constraints;
   char *opcode;
   int insn_size;		/* In words.  */
-  int isa;
+  long isa;
   unsigned int bin_opcode;
 };
 
@@ -192,6 +192,13 @@
       sprintf (buf, "0x%02X", ((insn & 0xf00) >> 4) | (insn & 0xf));
       sprintf (comment, "%d", ((insn & 0xf00) >> 4) | (insn & 0xf));
       break;
+    
+    case 'm':
+      sprintf (buf, "0x%02X", ((~insn & 0x100) >> 1) | ((insn & 0x100) >> 2) | 
+                               ((insn & 0x600) >> 5) | (insn & 0xf));
+      sprintf (comment, "%d", ((~insn & 0x100) >> 1) | ((insn & 0x100) >> 2) | 
+                               ((insn & 0x600) >> 5) | (insn & 0xf));
+      break;
 
     case 'n':
       sprintf (buf, "??");
