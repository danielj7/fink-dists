diff -uNr emacs/Emacs.finkwrap emacs22-carbon/Emacs.finkwrap
--- emacs/Emacs.finkwrap	1970-01-01 09:00:00.000000000 +0900
+++ emacs22-carbon/Emacs.finkwrap	2005-09-26 13:39:05.000000000 +0900
@@ -0,0 +1,3 @@
+#!/bin/bash
+source @PREFIX@/bin/init.sh
+exec -a "$0" "$0.bin" "$@"
diff -uNr emacs/Makefile.in emacs22-carbon/Makefile.in
--- emacs/Makefile.in	2005-09-26 13:23:32.000000000 +0900
+++ emacs22-carbon/Makefile.in	2005-09-26 13:39:05.000000000 +0900
@@ -420,7 +420,7 @@
 	      (cd $${dir}; tar -chf - . ) \
 		| (cd $${dest}; umask 022; \
                    tar -xvf - && cat > /dev/null) || exit 1; \
-	      find $${dest} -exec chown $${LOGNAME:-$$USERNAME} {} ';' ;\
+	      find $${dest} -exec chown root:admin {} ';' ;\
 	      for subdir in `find $${dest} -type d ! -name RCS ! -name CVS -print` ; do \
 		chmod a+rx $${subdir} ; \
 		rm -rf $${subdir}/RCS ; \
@@ -460,7 +460,7 @@
 	   echo "Copying etc/DOC-* to ${docdir} ..." ; \
 	   (cd ./etc; tar -chf - DOC*) \
 	     |(cd ${docdir}; umask 022; tar -xvf - && cat > /dev/null) || exit 1; \
-	   (cd $(docdir); chown $${LOGNAME:-$$USERNAME} DOC*; chmod a+r DOC*; \
+	   (cd $(docdir); chown root:admin DOC*; chmod a+r DOC*; \
 	    if test "`echo DOC-*`" != "DOC-*"; then rm DOC; fi); \
 	else true; fi
 	-unset CDPATH; \
@@ -472,7 +472,7 @@
 	   echo "Copying lisp/*.el and lisp/*.elc to ${lispdir} ..." ; \
 	   (cd lisp; tar -chf - *.el *.elc) \
 	     |(cd ${lispdir}; umask 022; tar -xvf - && cat > /dev/null) || exit 1; \
-	   (cd ${lispdir}; find . -exec chown $${LOGNAME:-$$USERNAME} {} ';') ; \
+	   (cd ${lispdir}; find . -exec chown root:admin {} ';') ; \
 	else true; fi
 	-unset CDPATH; \
 	thisdir=`/bin/pwd`; \
diff -uNr emacs/fix-info emacs22-carbon/fix-info
--- emacs/fix-info	1970-01-01 09:00:00.000000000 +0900
+++ emacs22-carbon/fix-info	2005-09-26 13:39:05.000000000 +0900
@@ -0,0 +1,10 @@
+#!/bin/sh
+
+THE_INFO_PREFIX=$1
+
+for file in ada-mode autotype ccmode cl dired-x ebrowse ediff efaq \
+            emacs emacs-mime eshell eudc forms gnus idlwave info message mh-e \
+            pcl-cvs reftex sc speedbar vip viper widget woman
+do
+    ./mangle-info ${THE_INFO_PREFIX}/${file}
+done
diff -uNr emacs/lisp/loadup.el emacs22-carbon/lisp/loadup.el
--- emacs/lisp/loadup.el	2005-07-05 18:37:23.000000000 +0900
+++ emacs22-carbon/lisp/loadup.el	2005-09-26 14:45:36.000000000 +0900
@@ -188,6 +188,9 @@
 (if (fboundp 'atan)	; preload some constants and
     (progn		; floating pt. functions if we have float support.
       (load "emacs-lisp/float-sup")))
+(if (eq system-type 'darwin)
+    (progn
+      (load "term/mac-im")))
 (message "%s" (garbage-collect))
 
 (load "vc-hooks")
diff -uNr emacs/lisp/startup.el emacs22-carbon/lisp/startup.el
--- emacs/lisp/startup.el	2005-09-26 13:23:50.000000000 +0900
+++ emacs22-carbon/lisp/startup.el	2005-09-26 13:39:05.000000000 +0900
@@ -289,6 +289,10 @@
 
 (defvar default-frame-background-mode)
 
+(defconst fink-emacs-flavor 'emacs22
+  "A symbol representing the particular fink flavor of emacs running.
+Something like 'emacs20, 'xemacs20, etc.")
+
 (defvar pure-space-overflow nil
   "Non-nil if building Emacs overflowed pure space.")
 
@@ -783,8 +787,20 @@
     ;; Run the site-start library if it exists.  The point of this file is
     ;; that it is run before .emacs.  There is no point in doing this after
     ;; .emacs; that is useless.
+
+    ;; (if site-run-file
+    ;;     (load site-run-file t t))
+
+    ;; Fink version of site-start.
     (if site-run-file
-	(load site-run-file t t))
+        (progn
+          ;; Load all the fink package snippets.
+          ;; It's in here because we want -q to kill it too.
+          (if (load "fink-startup" t t nil)
+              (fink-startup fink-emacs-flavor))
+          ;; Now the normal site file...
+          (load site-run-file t t nil)))
+
 
     ;; Sites should not disable this.  Only individuals should disable
     ;; the startup message.
diff -uNr emacs/lisp/startup.el.orig emacs22-carbon/lisp/startup.el.orig
--- emacs/lisp/startup.el.orig	1970-01-01 09:00:00.000000000 +0900
+++ emacs22-carbon/lisp/startup.el.orig	2005-09-26 13:39:05.000000000 +0900
@@ -0,0 +1,1782 @@
+;;; startup.el --- process Emacs shell arguments
+
+;; Copyright (C) 1985, 1986, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
+;;   2001, 2002, 2004, 2005  Free Software Foundation, Inc.
+
+;; Maintainer: FSF
+;; Keywords: internal
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 2, or (at your option)
+;; any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs; see the file COPYING.  If not, write to the
+;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+;; Boston, MA 02110-1301, USA.
+
+;;; Commentary:
+
+;; This file parses the command line and gets Emacs running.  Options
+;; on the command line are handled in precedence order.  For priorities
+;; see the structure standard_args in the emacs.c file.
+
+;;; Code:
+
+(setq top-level '(normal-top-level))
+
+(defvar command-line-processed nil
+  "Non-nil once command line has been processed.")
+
+(defgroup initialization nil
+  "Emacs start-up procedure."
+  :group 'internal)
+
+(defcustom inhibit-startup-message nil
+  "*Non-nil inhibits the initial startup message.
+This is for use in your personal init file, once you are familiar
+with the contents of the startup message."
+  :type 'boolean
+  :group 'initialization)
+
+(defvaralias 'inhibit-splash-screen 'inhibit-startup-message)
+
+(defcustom inhibit-startup-echo-area-message nil
+  "*Non-nil inhibits the initial startup echo area message.
+Setting this variable takes effect
+only if you do it with the customization buffer
+or if your `.emacs' file contains a line of this form:
+ (setq inhibit-startup-echo-area-message \"YOUR-USER-NAME\")
+If your `.emacs' file is byte-compiled, use the following form instead:
+ (eval '(setq inhibit-startup-echo-area-message \"YOUR-USER-NAME\"))
+Thus, someone else using a copy of your `.emacs' file will see
+the startup message unless he personally acts to inhibit it."
+  :type '(choice (const :tag "Don't inhibit")
+		 (string :tag "Enter your user name, to inhibit"))
+  :group 'initialization)
+
+(defcustom inhibit-default-init nil
+  "*Non-nil inhibits loading the `default' library."
+  :type 'boolean
+  :group 'initialization)
+
+(defcustom inhibit-startup-buffer-menu nil
+  "*Non-nil inhibits display of buffer list when more than 2 files are loaded."
+  :type 'boolean
+  :group 'initialization)
+
+(defvar command-switch-alist nil
+  "Alist of command-line switches.
+Elements look like (SWITCH-STRING . HANDLER-FUNCTION).
+HANDLER-FUNCTION receives the switch string as its sole argument;
+the remaining command-line args are in the variable `command-line-args-left'.")
+
+(defvar command-line-args-left nil
+  "List of command-line args not yet processed.")
+
+(defvar command-line-functions nil    ;; lrs 7/31/89
+  "List of functions to process unrecognized command-line arguments.
+Each function should access the dynamically bound variables
+`argi' (the current argument) and `command-line-args-left' (the remaining
+arguments).  The function should return non-nil only if it recognizes and
+processes `argi'.  If it does so, it may consume successive arguments by
+altering `command-line-args-left' to remove them.")
+
+(defvar command-line-default-directory nil
+  "Default directory to use for command line arguments.
+This is normally copied from `default-directory' when Emacs starts.")
+
+;;; This is here, rather than in x-win.el, so that we can ignore these
+;;; options when we are not using X.
+(defconst command-line-x-option-alist
+  '(("-bw" 1 x-handle-numeric-switch border-width)
+    ("-d" 1 x-handle-display)
+    ("-display" 1 x-handle-display)
+    ("-name" 1 x-handle-name-switch)
+    ("-title" 1 x-handle-switch title)
+    ("-T" 1 x-handle-switch title)
+    ("-r" 0 x-handle-switch reverse t)
+    ("-rv" 0 x-handle-switch reverse t)
+    ("-reverse" 0 x-handle-switch reverse t)
+    ("-reverse-video" 0 x-handle-switch reverse t)
+    ("-fn" 1 x-handle-switch font)
+    ("-font" 1 x-handle-switch font)
+    ("-fs" 0 x-handle-initial-switch fullscreen fullboth)
+    ("-fw" 0 x-handle-initial-switch fullscreen fullwidth)
+    ("-fh" 0 x-handle-initial-switch fullscreen fullheight)
+    ("-ib" 1 x-handle-numeric-switch internal-border-width)
+    ("-g" 1 x-handle-geometry)
+    ("-lsp" 1 x-handle-numeric-switch line-spacing)
+    ("-geometry" 1 x-handle-geometry)
+    ("-fg" 1 x-handle-switch foreground-color)
+    ("-foreground" 1 x-handle-switch foreground-color)
+    ("-bg" 1 x-handle-switch background-color)
+    ("-background" 1 x-handle-switch background-color)
+    ("-ms" 1 x-handle-switch mouse-color)
+    ("-itype" 0 x-handle-switch icon-type t)
+    ("-i" 0 x-handle-switch icon-type t)
+    ("-iconic" 0 x-handle-iconic)
+    ("-xrm" 1 x-handle-xrm-switch)
+    ("-cr" 1 x-handle-switch cursor-color)
+    ("-vb" 0 x-handle-switch vertical-scroll-bars t)
+    ("-hb" 0 x-handle-switch horizontal-scroll-bars t)
+    ("-bd" 1 x-handle-switch)
+    ("--border-width" 1 x-handle-numeric-switch border-width)
+    ("--display" 1 x-handle-display)
+    ("--name" 1 x-handle-name-switch)
+    ("--title" 1 x-handle-switch title)
+    ("--reverse-video" 0 x-handle-switch reverse t)
+    ("--font" 1 x-handle-switch font)
+    ("--fullscreen" 0 x-handle-initial-switch fullscreen fullboth)
+    ("--fullwidth" 0 x-handle-initial-switch fullscreen fullwidth)
+    ("--fullheight" 0 x-handle-initial-switch fullscreen fullheight)
+    ("--internal-border" 1 x-handle-numeric-switch internal-border-width)
+    ("--geometry" 1 x-handle-geometry)
+    ("--foreground-color" 1 x-handle-switch foreground-color)
+    ("--background-color" 1 x-handle-switch background-color)
+    ("--mouse-color" 1 x-handle-switch mouse-color)
+    ("--icon-type" 0 x-handle-switch icon-type t)
+    ("--iconic" 0 x-handle-iconic)
+    ("--xrm" 1 x-handle-xrm-switch)
+    ("--cursor-color" 1 x-handle-switch cursor-color)
+    ("--vertical-scroll-bars" 0 x-handle-switch vertical-scroll-bars t)
+    ("--line-spacing" 1 x-handle-numeric-switch line-spacing)
+    ("--border-color" 1 x-handle-switch border-color)
+    ("--smid" 1 x-handle-smid))
+  "Alist of X Windows options.
+Each element has the form
+  (NAME NUMARGS HANDLER FRAME-PARAM VALUE)
+where NAME is the option name string, NUMARGS is the number of arguments
+that the option accepts, HANDLER is a function to call to handle the option.
+FRAME-PARAM (optional) is the frame parameter this option specifies,
+and VALUE is the value which is given to that frame parameter
+\(most options use the argument for this, so VALUE is not present).")
+
+(defvar before-init-hook nil
+  "Normal hook run after handling urgent options but before loading init files.")
+
+(defvar after-init-hook nil
+  "Normal hook run after loading the init files, `~/.emacs' and `default.el'.
+There is no `condition-case' around the running of these functions;
+therefore, if you set `debug-on-error' non-nil in `.emacs',
+an error in one of these functions will invoke the debugger.")
+
+(defvar emacs-startup-hook nil
+  "Normal hook run after loading init files and handling the command line.")
+
+(defvar term-setup-hook nil
+  "Normal hook run after loading terminal-specific Lisp code.
+It also follows `emacs-startup-hook'.  This hook exists for users to set,
+so as to override the definitions made by the terminal-specific file.
+Emacs never sets this variable itself.")
+
+(defvar inhibit-startup-hooks nil
+  "Non-nil means don't run `term-setup-hook' and `emacs-startup-hook'.
+This is because we already did so.")
+
+(defvar keyboard-type nil
+  "The brand of keyboard you are using.
+This variable is used to define the proper function and keypad
+keys for use under X.  It is used in a fashion analogous to the
+environment variable TERM.")
+
+(defvar window-setup-hook nil
+  "Normal hook run to initialize window system display.
+Emacs runs this hook after processing the command line arguments and loading
+the user's init file.")
+
+(defcustom initial-major-mode 'lisp-interaction-mode
+  "Major mode command symbol to use for the initial *scratch* buffer."
+  :type 'function
+  :group 'initialization)
+
+(defcustom init-file-user nil
+  "Identity of user whose `.emacs' file is or was read.
+The value is nil if `-q' or `--no-init-file' was specified,
+meaning do not load any init file.
+
+Otherwise, the value may be the null string, meaning use the init file
+for the user that originally logged in, or it may be a
+string containing a user's name meaning use that person's init file.
+
+In either of the latter cases, `(concat \"~\" init-file-user \"/\")'
+evaluates to the name of the directory where the `.emacs' file was
+looked for.
+
+Setting `init-file-user' does not prevent Emacs from loading
+`site-start.el'.  The only way to do that is to use `--no-site-file'."
+  :type '(choice (const :tag "none" nil) string)
+  :group 'initialization)
+
+(defcustom site-run-file "site-start"
+  "File containing site-wide run-time initializations.
+This file is loaded at run-time before `~/.emacs'.  It contains inits
+that need to be in place for the entire site, but which, due to their
+higher incidence of change, don't make sense to load into Emacs's
+dumped image.  Thus, the run-time load order is: 1. file described in
+this variable, if non-nil; 2. `~/.emacs'; 3. `default.el'.
+
+Don't use the `site-start.el' file for things some users may not like.
+Put them in `default.el' instead, so that users can more easily
+override them.  Users can prevent loading `default.el' with the `-q'
+option or by setting `inhibit-default-init' in their own init files,
+but inhibiting `site-start.el' requires `--no-site-file', which
+is less convenient.
+
+This variable is defined for customization so as to make
+it visible in the relevant context.  However, actually customizing it
+is not allowed, since it would not work anyway.  The only way to set
+this variable usefully is to set it while building and dumping Emacs."
+  :type '(choice (const :tag "none" nil) string)
+  :group 'initialization
+  :initialize 'custom-initialize-default
+  :set '(lambda (variable value)
+	  (error "Customizing `site-run-file' does not work")))
+
+(defcustom mail-host-address nil
+  "*Name of this machine, for purposes of naming users."
+  :type '(choice (const nil) string)
+  :group 'mail)
+
+(defcustom user-mail-address (if command-line-processed
+				 (concat (user-login-name) "@"
+					 (or mail-host-address
+					     (system-name)))
+			       ;; Empty string means "not set yet".
+			       "")
+  "*Full mailing address of this user.
+This is initialized based on `mail-host-address',
+after your init file is read, in case it sets `mail-host-address'."
+  :type 'string
+  :group 'mail)
+
+(defcustom auto-save-list-file-prefix
+  (cond ((eq system-type 'ms-dos)
+	 ;; MS-DOS cannot have initial dot, and allows only 8.3 names
+	 "~/_emacs.d/auto-save.list/_s")
+	(t
+	 "~/.emacs.d/auto-save-list/.saves-"))
+  "Prefix for generating `auto-save-list-file-name'.
+This is used after reading your `.emacs' file to initialize
+`auto-save-list-file-name', by appending Emacs's pid and the system name,
+if you have not already set `auto-save-list-file-name' yourself.
+Directories in the prefix will be created if necessary.
+Set this to nil if you want to prevent `auto-save-list-file-name'
+from being initialized."
+  :type '(choice (const :tag "Don't record a session's auto save list" nil)
+		 string)
+  :group 'auto-save)
+
+(defvar emacs-quick-startup nil)
+
+(defvar emacs-basic-display nil)
+
+(defvar init-file-debug nil)
+
+(defvar init-file-had-error nil)
+
+(defvar normal-top-level-add-subdirs-inode-list nil)
+
+(defvar no-blinking-cursor nil)
+
+(defvar default-frame-background-mode)
+
+(defvar pure-space-overflow nil
+  "Non-nil if building Emacs overflowed pure space.")
+
+(defun normal-top-level-add-subdirs-to-load-path ()
+  "Add all subdirectories of current directory to `load-path'.
+More precisely, this uses only the subdirectories whose names
+start with letters or digits; it excludes any subdirectory named `RCS'
+or `CVS', and any subdirectory that contains a file named `.nosearch'."
+  (let (dirs
+	attrs
+	(pending (list default-directory)))
+    ;; This loop does a breadth-first tree walk on DIR's subtree,
+    ;; putting each subdir into DIRS as its contents are examined.
+    (while pending
+      (push (pop pending) dirs)
+      (let* ((this-dir (car dirs))
+	     (contents (directory-files this-dir))
+	     (default-directory this-dir)
+	     (canonicalized (if (fboundp 'untranslated-canonical-name)
+				(untranslated-canonical-name this-dir))))
+	;; The Windows version doesn't report meaningful inode
+	;; numbers, so use the canonicalized absolute file name of the
+	;; directory instead.
+	(setq attrs (or canonicalized
+			(nthcdr 10 (file-attributes this-dir))))
+	(unless (member attrs normal-top-level-add-subdirs-inode-list)
+	  (push attrs normal-top-level-add-subdirs-inode-list)
+	  (dolist (file contents)
+	    ;; The lower-case variants of RCS and CVS are for DOS/Windows.
+	    (unless (member file '("." ".." "RCS" "CVS" "rcs" "cvs"))
+	      (when (and (string-match "\\`[[:alnum:]]" file)
+			 ;; Avoid doing a `stat' when it isn't necessary
+			 ;; because that can cause trouble when an NFS server
+			 ;; is down.
+			 (not (string-match "\\.elc?\\'" file))
+			 (file-directory-p file))
+		(let ((expanded (expand-file-name file)))
+		  (unless (file-exists-p (expand-file-name ".nosearch"
+							   expanded))
+		    (setq pending (nconc pending (list expanded)))))))))))
+    (normal-top-level-add-to-load-path (cdr (nreverse dirs)))))
+
+;; This function is called from a subdirs.el file.
+;; It assumes that default-directory is the directory
+;; in which the subdirs.el file exists,
+;; and it adds to load-path the subdirs of that directory
+;; as specified in DIRS.  Normally the elements of DIRS are relative.
+(defun normal-top-level-add-to-load-path (dirs)
+  (let ((tail load-path)
+	(thisdir (directory-file-name default-directory)))
+    (while (and tail
+		;;Don't go all the way to the nil terminator.
+		(cdr tail)
+		(not (equal thisdir (car tail)))
+		(not (and (memq system-type '(ms-dos windows-nt))
+			  (equal (downcase thisdir) (downcase (car tail))))))
+      (setq tail (cdr tail)))
+    ;;Splice the new section in.
+    (when tail
+      (setcdr tail (append (mapcar 'expand-file-name dirs) (cdr tail))))))
+
+(defun normal-top-level ()
+  (if command-line-processed
+      (message "Back to top level.")
+    (setq command-line-processed t)
+    ;; Give *Messages* the same default-directory as *scratch*,
+    ;; just to keep things predictable.
+    (let ((dir default-directory))
+      (with-current-buffer "*Messages*"
+	(setq default-directory dir)))
+    ;; `user-full-name' is now known; reset its standard-value here.
+    (put 'user-full-name 'standard-value
+	 (list (default-value 'user-full-name)))
+    ;; For root, preserve owner and group when editing files.
+    (if (equal (user-uid) 0)
+	(setq backup-by-copying-when-mismatch t))
+    ;; Look in each dir in load-path for a subdirs.el file.
+    ;; If we find one, load it, which will add the appropriate subdirs
+    ;; of that dir into load-path,
+    ;; Look for a leim-list.el file too.  Loading it will register
+    ;; available input methods.
+    (let ((tail load-path) dir)
+      (while tail
+        (setq dir (car tail))
+        (let ((default-directory dir))
+          (load (expand-file-name "subdirs.el") t t t))
+        (let ((default-directory dir))
+          (load (expand-file-name "leim-list.el") t t t))
+        ;; We don't use a dolist loop and we put this "setq-cdr" command at
+        ;; the end, because the subdirs.el files may add elements to the end
+        ;; of load-path and we want to take it into account.
+        (setq tail (cdr tail))))
+    (unless (eq system-type 'vax-vms)
+      ;; If the PWD environment variable isn't accurate, delete it.
+      (let ((pwd (getenv "PWD")))
+	(and (stringp pwd)
+	     ;; Use FOO/., so that if FOO is a symlink, file-attributes
+	     ;; describes the directory linked to, not FOO itself.
+	     (or (equal (file-attributes
+			 (concat (file-name-as-directory pwd) "."))
+			(file-attributes
+			 (concat (file-name-as-directory default-directory)
+				 ".")))
+		 (setq process-environment
+		       (delete (concat "PWD=" pwd)
+			       process-environment))))))
+    (setq default-directory (abbreviate-file-name default-directory))
+    (let ((menubar-bindings-done nil))
+      (unwind-protect
+	  (command-line)
+	;; Do this again, in case .emacs defined more abbreviations.
+	(setq default-directory (abbreviate-file-name default-directory))
+	;; Specify the file for recording all the auto save files of this session.
+	;; This is used by recover-session.
+	(or auto-save-list-file-name
+	    (and auto-save-list-file-prefix
+		 (setq auto-save-list-file-name
+		       ;; Under MS-DOS our PID is almost always reused between
+		       ;; Emacs invocations.  We need something more unique.
+		       (cond ((eq system-type 'ms-dos)
+			      ;; We are going to access the auto-save
+			      ;; directory, so make sure it exists.
+			      (make-directory
+			       (file-name-directory auto-save-list-file-prefix)
+			       t)
+			      (concat
+			       (make-temp-name
+				(expand-file-name
+				 auto-save-list-file-prefix))
+			       "~"))
+			     (t
+			      (expand-file-name
+			       (format "%s%d-%s~"
+				       auto-save-list-file-prefix
+				       (emacs-pid)
+				       (system-name))))))))
+	(unless inhibit-startup-hooks
+	  (run-hooks 'emacs-startup-hook)
+	  (and term-setup-hook
+	       (run-hooks 'term-setup-hook)))
+
+	;; Don't do this if we failed to create the initial frame,
+	;; for instance due to a dense colormap.
+	(when (or frame-initial-frame
+		  ;; If frame-initial-frame has no meaning, do this anyway.
+		  (not (and window-system
+			    (not noninteractive)
+			    (not (eq window-system 'pc)))))
+	  ;; Modify the initial frame based on what .emacs puts into
+	  ;; ...-frame-alist.
+	  (if (fboundp 'frame-notice-user-settings)
+	      (frame-notice-user-settings))
+	  (if (fboundp 'frame-set-background-mode)
+	      ;; Set the faces for the initial background mode even if
+	      ;; frame-notice-user-settings didn't (such as on a tty).
+	      ;; frame-set-background-mode is idempotent, so it won't
+	      ;; cause any harm if it's already been done.
+	      (let ((frame (selected-frame))
+		    term)
+		(when (and (null window-system)
+			   ;; Don't override default set by files in lisp/term.
+			   (null default-frame-background-mode)
+			   (let ((bg (frame-parameter frame 'background-color)))
+			     (or (null bg)
+				 (member bg '(unspecified "unspecified-bg"
+							  "unspecified-fg")))))
+
+		  (setq term (getenv "TERM"))
+		  ;; Some files in lisp/term do a better job with the
+		  ;; background mode, but we leave this here anyway, in
+		  ;; case they remove those files.
+		  (if (string-match "^\\(xterm\\|rxvt\\|dtterm\\|eterm\\)"
+				    term)
+		      (setq default-frame-background-mode 'light)))
+		(frame-set-background-mode (selected-frame)))))
+
+	;; Now we know the user's default font, so add it to the menu.
+	(if (fboundp 'font-menu-add-default)
+	    (font-menu-add-default))
+	(and window-setup-hook
+	     (run-hooks 'window-setup-hook))
+	(or menubar-bindings-done
+	    (if (display-popup-menus-p)
+		(precompute-menubar-bindings)))))))
+
+;; Precompute the keyboard equivalents in the menu bar items.
+(defun precompute-menubar-bindings ()
+  (let ((submap (lookup-key global-map [menu-bar])))
+    (while submap
+      (and (consp (car submap))
+	   (symbolp (car (car submap)))
+	   (stringp (car-safe (cdr (car submap))))
+	   (keymapp (cdr (cdr (car submap))))
+	   (progn
+	     (x-popup-menu nil (cdr (cdr (car submap))))
+	     (if purify-flag
+		 (garbage-collect))))
+      (setq submap (cdr submap))))
+    (setq define-key-rebound-commands t))
+
+;; Command-line options supported by tty's:
+(defconst tty-long-option-alist
+  '(("--name"		  . "-name")
+    ("--title"		  . "-T")
+    ("--reverse-video"	  . "-reverse")
+    ("--foreground-color" . "-fg")
+    ("--background-color" . "-bg")
+    ("--color"		  . "-color")))
+
+(defconst tool-bar-images-pixel-height 24
+  "Height in pixels of images in the tool bar.")
+
+(defvar tool-bar-originally-present nil
+  "Non-nil if tool-bars are present before user and site init files are read.")
+
+;; Handle the X-like command-line arguments "-fg", "-bg", "-name", etc.
+(defun tty-handle-args (args)
+  (let (rest)
+    (message "%s" args)
+    (while (and args
+		(not (equal (car args) "--")))
+      (let* ((argi (pop args))
+	     (orig-argi argi)
+	     argval completion)
+	;; Check for long options with attached arguments
+	;; and separate out the attached option argument into argval.
+	(when (string-match "^\\(--[^=]*\\)=" argi)
+          (setq argval (substring argi (match-end 0))
+                argi (match-string 1 argi)))
+	(when (string-match "^--" argi)
+	  (setq completion (try-completion argi tty-long-option-alist))
+	  (if (eq completion t)
+	      ;; Exact match for long option.
+	      (setq argi (cdr (assoc argi tty-long-option-alist)))
+	    (if (stringp completion)
+		(let ((elt (assoc completion tty-long-option-alist)))
+		  ;; Check for abbreviated long option.
+		  (or elt
+		      (error "Option `%s' is ambiguous" argi))
+		  (setq argi (cdr elt)))
+	      ;; Check for a short option.
+	      (setq argval nil
+                    argi orig-argi))))
+	(cond ((member argi '("-fg" "-foreground"))
+	       (push (cons 'foreground-color (or argval (pop args)))
+                     default-frame-alist))
+	      ((member argi '("-bg" "-background"))
+	       (push (cons 'background-color (or argval (pop args)))
+                     default-frame-alist))
+	      ((member argi '("-T" "-name"))
+	       (unless argval (setq argval (pop args)))
+	       (push (cons 'title
+                           (if (stringp argval)
+                               argval
+                             (let ((case-fold-search t)
+                                   i)
+                               (setq argval (invocation-name))
+
+                               ;; Change any . or * characters in name to
+                               ;; hyphens, so as to emulate behavior on X.
+                               (while
+                                   (setq i (string-match "[.*]" argval))
+                                 (aset argval i ?-))
+                               argval)))
+                     default-frame-alist))
+	      ((member argi '("-r" "-rv" "-reverse"))
+	       (push '(reverse . t)
+                     default-frame-alist))
+	      ((equal argi "-color")
+	       (unless argval (setq argval 8)) ; default --color means 8 ANSI colors
+	       (push (cons 'tty-color-mode
+                           (cond
+                            ((numberp argval) argval)
+                            ((string-match "-?[0-9]+" argval)
+                             (string-to-number argval))
+                            (t (intern argval))))
+                     default-frame-alist))
+	      (t
+               (push argi rest)))))
+    (nreverse rest)))
+
+(defun command-line ()
+  (setq command-line-default-directory default-directory)
+
+  ;; Choose a reasonable location for temporary files.
+  (custom-reevaluate-setting 'temporary-file-directory)
+  (custom-reevaluate-setting 'small-temporary-file-directory)
+  (custom-reevaluate-setting 'auto-save-file-name-transforms)
+
+  ;; See if we should import version-control from the environment variable.
+  (let ((vc (getenv "VERSION_CONTROL")))
+    (cond ((eq vc nil))			;don't do anything if not set
+	  ((member vc '("t" "numbered"))
+	   (setq version-control t))
+	  ((member vc '("nil" "existing"))
+	   (setq version-control nil))
+	  ((member vc '("never" "simple"))
+	   (setq version-control 'never))))
+
+  ;;! This has been commented out; I currently find the behavior when
+  ;;! split-window-keep-point is nil disturbing, but if I can get used
+  ;;! to it, then it would be better to eliminate the option.
+  ;;! ;; Choose a good default value for split-window-keep-point.
+  ;;! (setq split-window-keep-point (> baud-rate 2400))
+
+  ;; Set the default strings to display in mode line for
+  ;; end-of-line formats that aren't native to this platform.
+  (cond
+   ((memq system-type '(ms-dos windows-nt emx))
+    (setq eol-mnemonic-unix "(Unix)"
+          eol-mnemonic-mac  "(Mac)"))
+   ;; Both Mac and Unix EOLs are now "native" on Mac OS so keep the
+   ;; abbreviated strings `/' and `:' set in coding.c for them.
+   ((eq system-type 'macos)
+    (setq eol-mnemonic-dos  "(DOS)"))
+   (t                                   ; this is for Unix/GNU/Linux systems
+    (setq eol-mnemonic-dos  "(DOS)"
+          eol-mnemonic-mac  "(Mac)")))
+
+  ;; Read window system's init file if using a window system.
+  (condition-case error
+      (if (and window-system (not noninteractive))
+	  (load (concat term-file-prefix
+			(symbol-name window-system)
+			"-win")
+		;; Every window system should have a startup file;
+		;; barf if we can't find it.
+		nil t))
+    ;; If we can't read it, print the error message and exit.
+    (error
+     (princ
+      (if (eq (car error) 'error)
+	  (apply 'concat (cdr error))
+	(if (memq 'file-error (get (car error) 'error-conditions))
+	    (format "%s: %s"
+                    (nth 1 error)
+                    (mapconcat (lambda (obj) (prin1-to-string obj t))
+                               (cdr (cdr error)) ", "))
+	  (format "%s: %s"
+                  (get (car error) 'error-message)
+                  (mapconcat (lambda (obj) (prin1-to-string obj t))
+                             (cdr error) ", "))))
+      'external-debugging-output)
+     (terpri 'external-debugging-output)
+     (setq window-system nil)
+     (kill-emacs)))
+
+  ;; Windowed displays do this inside their *-win.el.
+  (unless (or (display-graphic-p) noninteractive)
+    (setq command-line-args (tty-handle-args command-line-args)))
+
+  (set-locale-environment nil)
+
+  ;; Convert the arguments to Emacs internal representation.
+  (let ((args (cdr command-line-args)))
+    (while args
+      (setcar args
+	      (decode-coding-string (car args) locale-coding-system t))
+      (pop args)))
+
+  (let ((done nil)
+	(args (cdr command-line-args)))
+
+    ;; Figure out which user's init file to load,
+    ;; either from the environment or from the options.
+    (setq init-file-user (if noninteractive nil (user-login-name)))
+    ;; If user has not done su, use current $HOME to find .emacs.
+    (and init-file-user
+         (equal init-file-user (user-real-login-name))
+	 (setq init-file-user ""))
+
+    ;; Process the command-line args, and delete the arguments
+    ;; processed.  This is consistent with the way main in emacs.c
+    ;; does things.
+    (while (and (not done) args)
+      (let* ((longopts '(("--no-init-file") ("--no-site-file") ("--debug-init")
+                         ("--user") ("--iconic") ("--icon-type") ("--quick")
+			 ("--no-blinking-cursor") ("--basic-display")))
+             (argi (pop args))
+             (orig-argi argi)
+             argval)
+	;; Handle --OPTION=VALUE format.
+	(when (string-match "^\\(--[^=]*\\)=" argi)
+	  (setq argval (substring argi (match-end 0))
+                argi (match-string 1 argi)))
+	(unless (equal argi "--")
+	  (let ((completion (try-completion argi longopts)))
+	    (if (eq completion t)
+		(setq argi (substring argi 1))
+	      (if (stringp completion)
+		  (let ((elt (assoc completion longopts)))
+		    (or elt
+			(error "Option `%s' is ambiguous" argi))
+		    (setq argi (substring (car elt) 1)))
+		(setq argval nil
+                      argi orig-argi)))))
+	(cond
+	 ((member argi '("-Q" "-quick"))
+	  (setq init-file-user nil
+		site-run-file nil
+		emacs-quick-startup t))
+	 ((member argi '("-D" "-basic-display"))
+	  (setq no-blinking-cursor t
+		emacs-basic-display t)
+	  (push '(vertical-scroll-bars . nil) initial-frame-alist))
+	 ((member argi '("-q" "-no-init-file"))
+	  (setq init-file-user nil))
+	 ((member argi '("-u" "-user"))
+	  (setq init-file-user (or argval (pop args))
+		argval nil))
+	 ((equal argi "-no-site-file")
+	  (setq site-run-file nil))
+	 ((equal argi "-debug-init")
+	  (setq init-file-debug t))
+	 ((equal argi "-iconic")
+	  (push '(visibility . icon) initial-frame-alist))
+	 ((member argi '("-icon-type" "-i" "-itype"))
+	  (push '(icon-type . t) default-frame-alist))
+	 ((member argi '("-nbc" "-no-blinking-cursor"))
+	  (setq no-blinking-cursor t))
+	 ;; Push the popped arg back on the list of arguments.
+	 (t
+          (push argi args)
+          (setq done t)))
+	;; Was argval set but not used?
+	(and argval
+	     (error "Option `%s' doesn't allow an argument" argi))))
+
+    ;; Re-attach the program name to the front of the arg list.
+    (and command-line-args
+         (setcdr command-line-args args)))
+
+  ;; Under X Window, this creates the X frame and deletes the terminal frame.
+  (when (fboundp 'frame-initialize)
+    (frame-initialize))
+
+  ;; Turn off blinking cursor if so specified in X resources.  This is here
+  ;; only because all other settings of no-blinking-cursor are here.
+  (unless (or noninteractive
+	      emacs-basic-display
+	      (and (memq window-system '(x w32 mac))
+		   (not (member (x-get-resource "cursorBlink" "CursorBlink")
+				'("off" "false")))))
+    (setq no-blinking-cursor t))
+
+  ;; If frame was created with a menu bar, set menu-bar-mode on.
+  (unless (or noninteractive
+	      emacs-basic-display
+              (and (memq window-system '(x w32))
+                   (<= (frame-parameter nil 'menu-bar-lines) 0)))
+    (menu-bar-mode 1))
+
+  ;; If frame was created with a tool bar, switch tool-bar-mode on.
+  (unless (or noninteractive
+	      emacs-basic-display
+              (not (display-graphic-p))
+              (<= (frame-parameter nil 'tool-bar-lines) 0))
+    (tool-bar-mode 1))
+
+  ;; Can't do this init in defcustom because the relevant variables
+  ;; are not set.
+  (custom-reevaluate-setting 'blink-cursor-mode)
+  (custom-reevaluate-setting 'normal-erase-is-backspace)
+  (custom-reevaluate-setting 'tooltip-mode)
+
+  ;; Register default TTY colors for the case the terminal hasn't a
+  ;; terminal init file.
+  (unless (memq window-system '(x w32))
+    ;; We do this regardles of whether the terminal supports colors
+    ;; or not, since they can switch that support on or off in
+    ;; mid-session by setting the tty-color-mode frame parameter.
+    (tty-register-default-colors))
+
+  ;; Record whether the tool-bar is present before the user and site
+  ;; init files are processed.  frame-notice-user-settings uses this
+  ;; to determine if the tool-bar has been disabled by the init files,
+  ;; and the frame needs to be resized.
+  (when (fboundp 'frame-notice-user-settings)
+    (let ((tool-bar-lines (or (assq 'tool-bar-lines initial-frame-alist)
+                              (assq 'tool-bar-lines default-frame-alist))))
+      (setq tool-bar-originally-present
+            (and tool-bar-lines
+                 (cdr tool-bar-lines)
+                 (not (eq 0 (cdr tool-bar-lines)))))))
+
+  (let ((old-scalable-fonts-allowed scalable-fonts-allowed)
+	(old-font-list-limit font-list-limit)
+	(old-face-ignored-fonts face-ignored-fonts))
+
+    (run-hooks 'before-init-hook)
+
+    ;; Run the site-start library if it exists.  The point of this file is
+    ;; that it is run before .emacs.  There is no point in doing this after
+    ;; .emacs; that is useless.
+    (if site-run-file
+	(load site-run-file t t))
+
+    ;; Sites should not disable this.  Only individuals should disable
+    ;; the startup message.
+    (setq inhibit-startup-message nil)
+
+    ;; Warn for invalid user name.
+    (and init-file-user
+	 (not (file-directory-p (expand-file-name (concat "~" init-file-user))))
+	 (display-warning 'initialization
+			  (format "User %s has no home directory"
+				  init-file-user)
+			  :error))
+
+    ;; Load that user's init file, or the default one, or none.
+    (let (debug-on-error-from-init-file
+	  debug-on-error-should-be-set
+	  (debug-on-error-initial
+	   (if (eq init-file-debug t) 'startup init-file-debug))
+	  (orig-enable-multibyte default-enable-multibyte-characters))
+      (let ((debug-on-error debug-on-error-initial)
+	    ;; This function actually reads the init files.
+	    (inner
+	     (function
+	      (lambda ()
+		(if init-file-user
+		    (let ((user-init-file-1
+			   (cond
+			    ((eq system-type 'ms-dos)
+			     (concat "~" init-file-user "/_emacs"))
+			    ((eq system-type 'windows-nt)
+			     ;; Prefer .emacs on Windows.
+			     (if (directory-files "~" nil "^\\.emacs\\(\\.elc?\\)?$")
+				 "~/.emacs"
+			       ;; Also support _emacs for compatibility.
+			       (if (directory-files "~" nil "^_emacs\\(\\.elc?\\)?$")
+				   "~/_emacs"
+				 ;; But default to .emacs if _emacs does not exist.
+				 "~/.emacs")))
+			    ((eq system-type 'vax-vms)
+			     "sys$login:.emacs")
+			    (t
+			     (concat "~" init-file-user "/.emacs")))))
+		      ;; This tells `load' to store the file name found
+		      ;; into user-init-file.
+		      (setq user-init-file t)
+		      (load user-init-file-1 t t)
+
+		      (when (eq user-init-file t)
+			;; If we did not find ~/.emacs, try
+			;; ~/.emacs.d/.emacs.
+			(let ((otherfile
+			       (expand-file-name
+				(file-name-nondirectory user-init-file-1)
+				(file-name-as-directory
+				 (expand-file-name
+				  ".emacs.d"
+				  (file-name-directory user-init-file-1))))))
+			  (load otherfile t t)
+
+			  ;; If we did not find the user's init file,
+			  ;; set user-init-file conclusively.
+			  ;; Don't let it be set from default.el.
+			  (when (eq user-init-file t)
+			    (setq user-init-file user-init-file-1))))
+
+		      ;; If we loaded a compiled file, set
+		      ;; `user-init-file' to the source version if that
+		      ;; exists.
+		      (when (and user-init-file
+				 (equal (file-name-extension user-init-file)
+					"elc"))
+			(let* ((source (file-name-sans-extension user-init-file))
+			       (alt (concat source ".el")))
+			  (setq source (cond ((file-exists-p alt) alt)
+					     ((file-exists-p source) source)
+					     (t nil)))
+			  (when source
+			    (when (file-newer-than-file-p source user-init-file)
+			      (message "Warning: %s is newer than %s"
+				       source user-init-file)
+			      (sit-for 1))
+			    (setq user-init-file source))))
+
+		      (unless inhibit-default-init
+                        (let ((inhibit-startup-message nil))
+                          ;; Users are supposed to be told their rights.
+                          ;; (Plus how to get help and how to undo.)
+                          ;; Don't you dare turn this off for anyone
+                          ;; except yourself.
+                          (load "default" t t)))))))))
+	(if init-file-debug
+	    ;; Do this without a condition-case if the user wants to debug.
+	    (funcall inner)
+	  (condition-case error
+	      (progn
+		(funcall inner)
+		(setq init-file-had-error nil))
+	    (error
+	     (let ((message-log-max nil))
+	       (save-excursion
+		 (set-buffer (get-buffer-create "*Messages*"))
+		 (insert "\n\n"
+			 (format "An error has occurred while loading `%s':\n\n"
+				 user-init-file)
+			 (format "%s%s%s"
+				 (get (car error) 'error-message)
+				 (if (cdr error) ": " "")
+				 (mapconcat (lambda (s) (prin1-to-string s t)) (cdr error) ", "))
+			 "\n\n"
+			 "To ensure normal operation, you should investigate and remove the\n"
+			 "cause of the error in your initialization file.  Start Emacs with\n"
+			 "the `--debug-init' option to view a complete error backtrace.\n\n"))
+	       (message "Error in init file: %s%s%s"
+			(get (car error) 'error-message)
+			(if (cdr error) ": " "")
+			(mapconcat 'prin1-to-string (cdr error) ", "))
+	       (let ((pop-up-windows nil))
+		 (pop-to-buffer "*Messages*"))
+	       (setq init-file-had-error t)))))
+
+	;; If the user has a file of abbrevs, read it.
+	(if (file-exists-p abbrev-file-name)
+	    (quietly-read-abbrev-file abbrev-file-name))
+
+	;; If the abbrevs came entirely from the init file or the
+	;; abbrevs file, they do not need saving.
+	(setq abbrevs-changed nil)
+
+	;; If we can tell that the init file altered debug-on-error,
+	;; arrange to preserve the value that it set up.
+	(or (eq debug-on-error debug-on-error-initial)
+	    (setq debug-on-error-should-be-set t
+		  debug-on-error-from-init-file debug-on-error)))
+      (if debug-on-error-should-be-set
+	  (setq debug-on-error debug-on-error-from-init-file))
+      (unless (or default-enable-multibyte-characters
+		  (eq orig-enable-multibyte default-enable-multibyte-characters))
+	;; Init file changed to unibyte.  Reset existing multibyte
+	;; buffers (probably *scratch*, *Messages*, *Minibuff-0*).
+	;; Arguably this should only be done if they're free of
+	;; multibyte characters.
+	(mapcar (lambda (buffer)
+		  (with-current-buffer buffer
+		    (if enable-multibyte-characters
+			(set-buffer-multibyte nil))))
+		(buffer-list))
+	;; Also re-set the language environment in case it was
+	;; originally done before unibyte was set and is sensitive to
+	;; unibyte (display table, terminal coding system &c).
+	(set-language-environment current-language-environment)))
+
+    ;; Do this here in case the init file sets mail-host-address.
+    (if (equal user-mail-address "")
+	(setq user-mail-address (concat (user-login-name) "@"
+					(or mail-host-address
+					    (system-name)))))
+
+    ;; If parameter have been changed in the init file which influence
+    ;; face realization, clear the face cache so that new faces will
+    ;; be realized.
+    (unless (and (eq scalable-fonts-allowed old-scalable-fonts-allowed)
+		 (eq font-list-limit old-font-list-limit)
+		 (eq face-ignored-fonts old-face-ignored-fonts))
+      (clear-face-cache)))
+
+  (run-hooks 'after-init-hook)
+
+  ;; Decode all default-directory.
+  (if (and default-enable-multibyte-characters locale-coding-system)
+      (save-excursion
+	(dolist (elt (buffer-list))
+	  (set-buffer elt)
+	  (if default-directory
+	      (setq default-directory
+		    (decode-coding-string default-directory
+					  locale-coding-system t))))
+	(setq command-line-default-directory
+	      (decode-coding-string command-line-default-directory
+				    locale-coding-system t))))
+
+  ;; If *scratch* exists and init file didn't change its mode, initialize it.
+  (if (get-buffer "*scratch*")
+      (with-current-buffer "*scratch*"
+	(if (eq major-mode 'fundamental-mode)
+	    (funcall initial-major-mode))))
+
+  ;; Load library for our terminal type.
+  ;; User init file can set term-file-prefix to nil to prevent this.
+  (unless (or noninteractive
+              window-system
+              (null term-file-prefix))
+    (let ((term (getenv "TERM"))
+          hyphend)
+      (while (and term
+                  (not (load (concat term-file-prefix term) t t)))
+        ;; Strip off last hyphen and what follows, then try again
+        (setq term
+              (if (setq hyphend (string-match "[-_][^-_]+$" term))
+                  (substring term 0 hyphend)
+                nil)))
+      (when term
+	;; The terminal file has been loaded, now call the terminal
+	;; specific initialization function.
+	(let ((term-init-func (intern (concat "terminal-init-" term))))
+	  (when (fboundp term-init-func)
+	    (funcall term-init-func))))))
+
+  ;; Update the out-of-memory error message based on user's key bindings
+  ;; for save-some-buffers.
+  (setq memory-signal-data
+	(list 'error
+	      (substitute-command-keys "Memory exhausted--use \\[save-some-buffers] then exit and restart Emacs")))
+
+  ;; Process the remaining args.
+  (command-line-1 (cdr command-line-args))
+
+  ;; If -batch, terminate after processing the command options.
+  (if noninteractive (kill-emacs t))
+
+  ;; Run emacs-session-restore (session management) if started by
+  ;; the session manager and we have a session manager connection.
+  (if (and (boundp 'x-session-previous-id)
+           (stringp x-session-previous-id))
+      (with-no-warnings
+	(emacs-session-restore x-session-previous-id))))
+
+(defcustom initial-scratch-message (purecopy "\
+;; This buffer is for notes you don't want to save, and for Lisp evaluation.
+;; If you want to create a file, visit that file with C-x C-f,
+;; then enter the text in that file's own buffer.
+
+")
+  "Initial message displayed in *scratch* buffer at startup.
+If this is nil, no message will be displayed."
+  :type '(choice (text :tag "Message")
+		 (const :tag "none" nil))
+  :group 'initialization)
+
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;; Fancy splash screen
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(defvar fancy-splash-text
+  '((:face variable-pitch
+	   "You can do basic editing with the menu bar and scroll bar \
+using the mouse.\n\n"
+	   :face (variable-pitch :weight bold)
+	   "Important Help menu items:\n"
+	   :face variable-pitch
+           (lambda ()
+             (let* ((en "TUTORIAL")
+                    (tut (or (get-language-info current-language-environment
+                                                'tutorial)
+                             en))
+                    (title (with-temp-buffer
+                             (insert-file-contents
+                              (expand-file-name tut data-directory)
+                              nil 0 256)
+                             (search-forward ".")
+                             (buffer-substring (point-min) (1- (point))))))
+               ;; If there is a specific tutorial for the current language
+               ;; environment and it is not English, append its title.
+               (concat
+                "Emacs Tutorial\tLearn how to use Emacs efficiently"
+                (if (string= en tut)
+                    ""
+                  (concat " (" title ")"))
+                "\n")))
+           :face variable-pitch "\
+Emacs FAQ\tFrequently asked questions and answers
+Read the Emacs Manual\tView the Emacs manual using Info
+\(Non)Warranty\tGNU Emacs comes with "
+	   :face (variable-pitch :slant oblique)
+	   "ABSOLUTELY NO WARRANTY\n"
+	   :face variable-pitch
+	   "\
+Copying Conditions\tConditions for redistributing and changing Emacs
+Getting New Versions\tHow to obtain the latest version of Emacs
+More Manuals / Ordering Manuals       Buying printed manuals from the FSF\n")
+  (:face variable-pitch
+	   "You can do basic editing with the menu bar and scroll bar \
+using the mouse.\n\n"
+	   :face (variable-pitch :weight bold)
+	   "Useful File menu items:\n"
+	   :face variable-pitch "\
+Exit Emacs\t(Or type Control-x followed by Control-c)
+Recover Crashed Session\tRecover files you were editing before a crash
+
+
+
+
+"
+	   ))
+  "A list of texts to show in the middle part of splash screens.
+Each element in the list should be a list of strings or pairs
+`:face FACE', like `fancy-splash-insert' accepts them.")
+
+
+(defgroup fancy-splash-screen ()
+  "Fancy splash screen when Emacs starts."
+  :version "21.1"
+  :group 'initialization)
+
+
+(defcustom fancy-splash-delay 7
+  "*Delay in seconds between splash screens."
+  :group 'fancy-splash-screen
+  :type 'integer)
+
+
+(defcustom fancy-splash-max-time 30
+  "*Show splash screens for at most this number of seconds.
+Values less than twice `fancy-splash-delay' are ignored."
+  :group 'fancy-splash-screen
+  :type 'integer)
+
+
+(defcustom fancy-splash-image nil
+  "*The image to show in the splash screens, or nil for defaults."
+  :group 'fancy-splash-screen
+  :type '(choice (const :tag "Default" nil)
+		 (file :tag "File")))
+
+
+;; These are temporary storage areas for the splash screen display.
+
+(defvar fancy-current-text nil)
+(defvar fancy-splash-help-echo nil)
+(defvar fancy-splash-stop-time nil)
+(defvar fancy-splash-outer-buffer nil)
+
+(defun fancy-splash-insert (&rest args)
+  "Insert text into the current buffer, with faces.
+Arguments from ARGS should be either strings, functions called
+with no args that return a string, or pairs `:face FACE',
+where FACE is a valid face specification, as it can be used with
+`put-text-property'."
+  (let ((current-face nil))
+    (while args
+      (if (eq (car args) :face)
+	  (setq args (cdr args) current-face (car args))
+	(insert (propertize (let ((it (car args)))
+                              (if (functionp it)
+                                  (funcall it)
+                                it))
+			    'face current-face
+			    'help-echo fancy-splash-help-echo)))
+      (setq args (cdr args)))))
+
+
+(defun fancy-splash-head ()
+  "Insert the head part of the splash screen into the current buffer."
+  (let* ((image-file (cond ((stringp fancy-splash-image)
+			    fancy-splash-image)
+			   ((and (display-color-p)
+				 (image-type-available-p 'xpm))
+			    (if (and (fboundp 'x-display-planes)
+				     (= (funcall 'x-display-planes) 8))
+				"splash8.xpm"
+			      "splash.xpm"))
+			   (t "splash.pbm")))
+	 (img (create-image image-file))
+	 (image-width (and img (car (image-size img))))
+	 (window-width (window-width (selected-window))))
+    (when img
+      (when (> window-width image-width)
+	;; Center the image in the window.
+	(insert (propertize " " 'display
+			    `(space :align-to (+ center (-0.5 . ,img)))))
+
+	;; Change the color of the XPM version of the splash image
+	;; so that it is visible with a dark frame background.
+	(when (and (memq 'xpm img)
+		   (eq (frame-parameter nil 'background-mode) 'dark))
+	  (setq img (append img '(:color-symbols (("#000000" . "gray30"))))))
+
+	;; Insert the image with a help-echo and a keymap.
+	(let ((map (make-sparse-keymap))
+	      (help-echo "mouse-2: browse http://www.gnu.org/"))
+	  (define-key map [mouse-2]
+	    (lambda ()
+	      (interactive)
+	      (browse-url "http://www.gnu.org/")
+	      (throw 'exit nil)))
+	  (define-key map [down-mouse-2] 'ignore)
+	  (define-key map [up-mouse-2] 'ignore)
+	  (insert-image img (propertize "xxx" 'help-echo help-echo
+					'keymap map)))
+	(insert "\n"))))
+  (fancy-splash-insert
+   :face '(variable-pitch :foreground "red")
+   (if (eq system-type 'gnu/linux)
+       "GNU Emacs is one component of the GNU/Linux operating system."
+     "GNU Emacs is one component of the GNU operating system."))
+  (insert "\n")
+  (unless (equal (buffer-name fancy-splash-outer-buffer) "*scratch*")
+    (fancy-splash-insert :face 'variable-pitch
+			 (substitute-command-keys
+			  "Type \\[recenter] to begin editing your file.\n"))))
+
+
+(defun fancy-splash-tail ()
+  "Insert the tail part of the splash screen into the current buffer."
+  (let ((fg (if (eq (frame-parameter nil 'background-mode) 'dark)
+		"cyan" "darkblue")))
+    (fancy-splash-insert :face `(variable-pitch :foreground ,fg)
+			 "\nThis is "
+			 (emacs-version)
+			 "\n"
+			 :face '(variable-pitch :height 0.5)
+			 "Copyright (C) 2005 Free Software Foundation, Inc.")
+    (and auto-save-list-file-prefix
+	 ;; Don't signal an error if the
+	 ;; directory for auto-save-list files
+	 ;; does not yet exist.
+	 (file-directory-p (file-name-directory
+			    auto-save-list-file-prefix))
+	 (directory-files
+	  (file-name-directory auto-save-list-file-prefix)
+	  nil
+	  (concat "\\`"
+		  (regexp-quote (file-name-nondirectory
+				 auto-save-list-file-prefix)))
+	  t)
+	 (fancy-splash-insert :face '(variable-pitch :foreground "red")
+			      "\n\nIf an Emacs session crashed recently, "
+			      "type M-x recover-session RET\nto recover"
+			      " the files you were editing."))))
+
+(defun fancy-splash-screens-1 (buffer)
+  "Timer function displaying a splash screen."
+  (when (> (float-time) fancy-splash-stop-time)
+    (throw 'stop-splashing nil))
+  (unless fancy-current-text
+    (setq fancy-current-text fancy-splash-text))
+  (let ((text (car fancy-current-text)))
+    (set-buffer buffer)
+    (erase-buffer)
+    (if pure-space-overflow
+	(insert "Warning Warning  Pure space overflow   Warning Warning\n"))
+    (fancy-splash-head)
+    (apply #'fancy-splash-insert text)
+    (fancy-splash-tail)
+    (unless (current-message)
+      (message fancy-splash-help-echo))
+    (set-buffer-modified-p nil)
+    (goto-char (point-min))
+    (force-mode-line-update)
+    (setq fancy-current-text (cdr fancy-current-text))))
+
+
+(defun fancy-splash-default-action ()
+  "Stop displaying the splash screen buffer.
+This is an internal function used to turn off the splash screen after
+the user caused an input event by hitting a key or clicking with the
+mouse."
+  (interactive)
+  (push last-command-event unread-command-events)
+  (throw 'exit nil))
+
+
+(defun fancy-splash-screens ()
+  "Display fancy splash screens when Emacs starts."
+  (setq fancy-splash-help-echo (startup-echo-area-message))
+  (let ((old-hourglass display-hourglass)
+	(fancy-splash-outer-buffer (current-buffer))
+	splash-buffer
+	(old-minor-mode-map-alist minor-mode-map-alist)
+	(frame (fancy-splash-frame))
+	timer)
+    (save-selected-window
+      (select-frame frame)
+      (switch-to-buffer "GNU Emacs")
+      (setq tab-width 20)
+      (setq splash-buffer (current-buffer))
+      (catch 'stop-splashing
+	(unwind-protect
+	    (let ((map (make-sparse-keymap)))
+	      (use-local-map map)
+	      (define-key map [switch-frame] 'ignore)
+	      (define-key map [t] 'fancy-splash-default-action)
+	      (define-key map [mouse-movement] 'ignore)
+	      (define-key map [mode-line t] 'ignore)
+	      (setq cursor-type nil
+		    display-hourglass nil
+		    minor-mode-map-alist nil
+		    buffer-undo-list t
+		    mode-line-format (propertize "---- %b %-"
+						 'face '(:weight bold))
+		    fancy-splash-stop-time (+ (float-time)
+					      fancy-splash-max-time)
+		    timer (run-with-timer 0 fancy-splash-delay
+					  #'fancy-splash-screens-1
+					  splash-buffer))
+	      (recursive-edit))
+	  (cancel-timer timer)
+	  (setq display-hourglass old-hourglass
+		minor-mode-map-alist old-minor-mode-map-alist)
+	  (kill-buffer splash-buffer))))))
+
+(defun fancy-splash-frame ()
+  "Return the frame to use for the fancy splash screen.
+Returning non-nil does not mean we should necessarily
+use the fancy splash screen, but if we do use it,
+we put it on this frame."
+  (let (chosen-frame)
+    (dolist (frame (append (frame-list) (list (selected-frame))))
+      (if (and (frame-visible-p frame)
+	       (not (window-minibuffer-p (frame-selected-window frame))))
+	  (setq chosen-frame frame)))
+    chosen-frame))
+
+(defun use-fancy-splash-screens-p ()
+  "Return t if fancy splash screens should be used."
+  (when (and (display-graphic-p)
+             (or (and (display-color-p)
+		 (image-type-available-p 'xpm))
+                 (image-type-available-p 'pbm)))
+    (let ((frame (fancy-splash-frame)))
+      (when frame
+	(let* ((img (create-image (or fancy-splash-image
+				      (if (and (display-color-p)
+					       (image-type-available-p 'xpm))
+					  "splash.xpm" "splash.pbm"))))
+	       (image-height (and img (cdr (image-size img))))
+	       (window-height (1- (window-height (frame-selected-window frame)))))
+	  (> window-height (+ image-height 19)))))))
+
+
+(defun normal-splash-screen ()
+  "Display splash screen when Emacs starts."
+  (let ((prev-buffer (current-buffer)))
+    (unwind-protect
+	(with-current-buffer (get-buffer-create "GNU Emacs")
+	  (let ((tab-width 8)
+		(mode-line-format (propertize "---- %b %-"
+					      'face '(:weight bold))))
+
+	    (if pure-space-overflow
+		(insert "Warning Warning  Pure space overflow   Warning Warning\n"))
+
+	    ;; The convention for this piece of code is that
+	    ;; each piece of output starts with one or two newlines
+	    ;; and does not end with any newlines.
+	    (insert "Welcome to GNU Emacs")
+	    (insert
+	     (if (eq system-type 'gnu/linux)
+		 ", one component of the GNU/Linux operating system.\n"
+	       ", a part of the GNU operating system.\n"))
+
+	    (unless (equal (buffer-name prev-buffer) "*scratch*")
+	      (insert (substitute-command-keys
+		       "\nType \\[recenter] to begin editing your file.\n")))
+
+	    (if (display-mouse-p)
+		;; The user can use the mouse to activate menus
+		;; so give help in terms of menu items.
+		(progn
+		  (insert "\
+You can do basic editing with the menu bar and scroll bar using the mouse.
+
+Useful File menu items:
+Exit Emacs		(or type Control-x followed by Control-c)
+Recover Crashed Session	Recover files you were editing before a crash
+
+Important Help menu items:
+Emacs Tutorial		Learn how to use Emacs efficiently
+Emacs FAQ		Frequently asked questions and answers
+Read the Emacs Manual	View the Emacs manual using Info
+\(Non)Warranty		GNU Emacs comes with ABSOLUTELY NO WARRANTY
+Copying Conditions	Conditions for redistributing and changing Emacs
+Getting New Versions	How to obtain the latest version of Emacs
+More Manuals / Ordering Manuals    How to order printed manuals from the FSF
+")
+		  (insert "\n\n" (emacs-version)
+			  "
+Copyright (C) 2005 Free Software Foundation, Inc."))
+
+	      ;; No mouse menus, so give help using kbd commands.
+
+	      ;; If keys have their default meanings,
+	      ;; use precomputed string to save lots of time.
+	      (if (and (eq (key-binding "\C-h") 'help-command)
+		       (eq (key-binding "\C-xu") 'advertised-undo)
+		       (eq (key-binding "\C-x\C-c") 'save-buffers-kill-emacs)
+		       (eq (key-binding "\C-ht") 'help-with-tutorial)
+		       (eq (key-binding "\C-hi") 'info)
+		       (eq (key-binding "\C-hr") 'info-emacs-manual)
+		       (eq (key-binding "\C-h\C-n") 'view-emacs-news))
+		  (insert "
+Get help	   C-h  (Hold down CTRL and press h)
+Emacs manual	   C-h r
+Emacs tutorial	   C-h t           Undo changes     C-x u
+Buy manuals        C-h C-m         Exit Emacs	    C-x C-c
+Browse manuals     C-h i")
+
+		(insert (substitute-command-keys
+			 (format "\n
+Get help	   %s
+Emacs manual	   \\[info-emacs-manual]
+Emacs tutorial	   \\[help-with-tutorial]\tUndo changes\t\\[advertised-undo]
+Buy manuals        \\[view-order-manuals]\tExit Emacs\t\\[save-buffers-kill-emacs]
+Browse manuals     \\[info]"
+				 (let ((where (where-is-internal
+					       'help-command nil t)))
+				   (if where
+				       (key-description where)
+				     "M-x help"))))))
+
+	      ;; Say how to use the menu bar with the keyboard.
+	      (if (and (eq (key-binding "\M-`") 'tmm-menubar)
+		       (eq (key-binding [f10]) 'tmm-menubar))
+		  (insert "
+Activate menubar   F10  or  ESC `  or   M-`")
+		(insert (substitute-command-keys "
+Activate menubar     \\[tmm-menubar]")))
+
+	      ;; Many users seem to have problems with these.
+	      (insert "
+\(`C-' means use the CTRL key.  `M-' means use the Meta (or Alt) key.
+If you have no Meta key, you may instead type ESC followed by the character.)")
+
+	      (insert "\n\n" (emacs-version)
+		      "
+Copyright (C) 2005 Free Software Foundation, Inc.")
+
+	      (if (and (eq (key-binding "\C-h\C-c") 'describe-copying)
+		       (eq (key-binding "\C-h\C-d") 'describe-distribution)
+		       (eq (key-binding "\C-h\C-w") 'describe-no-warranty))
+		  (insert
+		   "\n
+GNU Emacs comes with ABSOLUTELY NO WARRANTY; type C-h C-w for full details.
+Emacs is Free Software--Free as in Freedom--so you can redistribute copies
+of Emacs and modify it; type C-h C-c to see the conditions.
+Type C-h C-d for information on getting the latest version.")
+		(insert (substitute-command-keys
+			 "\n
+GNU Emacs comes with ABSOLUTELY NO WARRANTY; type \\[describe-no-warranty] for full details.
+Emacs is Free Software--Free as in Freedom--so you can redistribute copies
+of Emacs and modify it; type \\[describe-copying] to see the conditions.
+Type \\[describe-distribution] for information on getting the latest version."))))
+
+	    ;; The rest of the startup screen is the same on all
+	    ;; kinds of terminals.
+
+	    ;; Give information on recovering, if there was a crash.
+	    (and auto-save-list-file-prefix
+		 ;; Don't signal an error if the
+		 ;; directory for auto-save-list files
+		 ;; does not yet exist.
+		 (file-directory-p (file-name-directory
+				    auto-save-list-file-prefix))
+		 (directory-files
+		  (file-name-directory auto-save-list-file-prefix)
+		  nil
+		  (concat "\\`"
+			  (regexp-quote (file-name-nondirectory
+					 auto-save-list-file-prefix)))
+		  t)
+		 (insert "\n\nIf an Emacs session crashed recently, "
+			 "type M-x recover-session RET\nto recover"
+			 " the files you were editing."))
+
+	    ;; Display the input that we set up in the buffer.
+	    (set-buffer-modified-p nil)
+	    (goto-char (point-min))
+	    (save-window-excursion
+	      (switch-to-buffer (current-buffer))
+	      (sit-for 120))))
+      ;; Unwind ... ensure splash buffer is killed
+      (kill-buffer "GNU Emacs"))))
+
+
+(defun startup-echo-area-message ()
+  (if (eq (key-binding "\C-h\C-p") 'describe-project)
+      "For information about the GNU Project and its goals, type C-h C-p."
+    (substitute-command-keys
+     "For information about the GNU Project and its goals, type \
+\\[describe-project].")))
+
+
+(defun display-startup-echo-area-message ()
+  (let ((resize-mini-windows t))
+    (message (startup-echo-area-message))))
+
+
+(defun display-splash-screen ()
+  "Display splash screen according to display.
+Fancy splash screens are used on graphic displays,
+normal otherwise."
+  (interactive)
+  (if (use-fancy-splash-screens-p)
+      (fancy-splash-screens)
+    (normal-splash-screen)))
+
+
+(defun command-line-1 (command-line-args-left)
+  (or noninteractive (input-pending-p) init-file-had-error
+      ;; t if the init file says to inhibit the echo area startup message.
+      (and inhibit-startup-echo-area-message
+	   user-init-file
+	   (or (and (get 'inhibit-startup-echo-area-message 'saved-value)
+		    (equal inhibit-startup-echo-area-message
+			   (if (equal init-file-user "")
+			       (user-login-name)
+			     init-file-user)))
+	       ;; Wasn't set with custom; see if .emacs has a setq.
+	       (let ((buffer (get-buffer-create " *temp*")))
+		 (prog1
+		     (condition-case nil
+			 (save-excursion
+			   (set-buffer buffer)
+			   (insert-file-contents user-init-file)
+			   (re-search-forward
+			    (concat
+			     "([ \t\n]*setq[ \t\n]+"
+			     "inhibit-startup-echo-area-message[ \t\n]+"
+			     (regexp-quote
+			      (prin1-to-string
+			       (if (equal init-file-user "")
+				   (user-login-name)
+				 init-file-user)))
+			     "[ \t\n]*)")
+			    nil t))
+		       (error nil))
+		   (kill-buffer buffer)))))
+      ;; display-splash-screen at the end of command-line-1 calls
+      ;; use-fancy-splash-screens-p. This can cause image.el to be
+      ;; loaded, putting "Loading image... done" in the echo area.
+      ;; This hides startup-echo-area-message. So
+      ;; use-fancy-splash-screens-p is called here simply to get the
+      ;; loading of image.el (if needed) out of the way before
+      ;; display-startup-echo-area-message runs.
+      (progn
+        (use-fancy-splash-screens-p)
+        (display-startup-echo-area-message)))
+
+  ;; Delay 2 seconds after an init file error message
+  ;; was displayed, so user can read it.
+  (when init-file-had-error
+    (sit-for 2))
+
+  (when command-line-args-left
+    ;; We have command args; process them.
+    (let ((dir command-line-default-directory)
+          (file-count 0)
+          first-file-buffer
+          tem
+          ;; This approach loses for "-batch -L DIR --eval "(require foo)",
+          ;; if foo is intended to be found in DIR.
+          ;;
+          ;; ;; The directories listed in --directory/-L options will *appear*
+          ;; ;; at the front of `load-path' in the order they appear on the
+          ;; ;; command-line.  We cannot do this by *placing* them at the front
+          ;; ;; in the order they appear, so we need this variable to hold them,
+          ;; ;; temporarily.
+          ;; extra-load-path
+          ;;
+          ;; To DTRT we keep track of the splice point and modify `load-path'
+          ;; straight away upon any --directory/-L option.
+          splice
+          just-files ;; t if this follows the magic -- option.
+          ;; This includes our standard options' long versions
+          ;; and long versions of what's on command-switch-alist.
+          (longopts
+           (append '(("--funcall") ("--load") ("--insert") ("--kill")
+                     ("--directory") ("--eval") ("--execute") ("--no-splash")
+                     ("--find-file") ("--visit") ("--file"))
+                   (mapcar (lambda (elt)
+                             (list (concat "-" (car elt))))
+                           command-switch-alist)))
+          (line 0)
+          (column 0))
+
+      ;; Add the long X options to longopts.
+      (dolist (tem command-line-x-option-alist)
+        (if (string-match "^--" (car tem))
+            (push (list (car tem)) longopts)))
+
+      ;; Loop, processing options.
+      (while command-line-args-left
+        (let* ((argi (car command-line-args-left))
+               (orig-argi argi)
+               argval completion)
+          (setq command-line-args-left (cdr command-line-args-left))
+
+          ;; Do preliminary decoding of the option.
+          (if just-files
+              ;; After --, don't look for options; treat all args as files.
+              (setq argi "")
+            ;; Convert long options to ordinary options
+            ;; and separate out an attached option argument into argval.
+            (when (string-match "^\\(--[^=]*\\)=" argi)
+              (setq argval (substring argi (match-end 0))
+                    argi (match-string 1 argi)))
+            (if (equal argi "--")
+                (setq completion nil)
+              (setq completion (try-completion argi longopts)))
+            (if (eq completion t)
+                (setq argi (substring argi 1))
+              (if (stringp completion)
+                  (let ((elt (assoc completion longopts)))
+                    (or elt
+                        (error "Option `%s' is ambiguous" argi))
+                    (setq argi (substring (car elt) 1)))
+                (setq argval nil
+                      argi orig-argi))))
+
+          ;; Execute the option.
+          (cond ((setq tem (assoc argi command-switch-alist))
+                 (if argval
+                     (let ((command-line-args-left
+                            (cons argval command-line-args-left)))
+                       (funcall (cdr tem) argi))
+                   (funcall (cdr tem) argi)))
+
+                ((equal argi "-no-splash")
+                 (setq inhibit-startup-message t))
+
+                ((member argi '("-f"	; what the manual claims
+                                "-funcall"
+                                "-e"))  ; what the source used to say
+                 (setq tem (intern (or argval (pop command-line-args-left))))
+                 (if (commandp tem)
+                     (command-execute tem)
+                   (funcall tem)))
+
+                ((member argi '("-eval" "-execute"))
+                 (eval (read (or argval (pop command-line-args-left)))))
+
+                ((member argi '("-L" "-directory"))
+                 (setq tem (expand-file-name
+                            (command-line-normalize-file-name
+                             (or argval (pop command-line-args-left)))))
+                 (cond (splice (setcdr splice (cons tem (cdr splice)))
+                               (setq splice (cdr splice)))
+                       (t (setq load-path (cons tem load-path)
+                                splice load-path))))
+
+                ((member argi '("-l" "-load"))
+                 (let* ((file (command-line-normalize-file-name
+                               (or argval (pop command-line-args-left))))
+                        ;; Take file from default dir if it exists there;
+                        ;; otherwise let `load' search for it.
+                        (file-ex (expand-file-name file)))
+                   (when (file-exists-p file-ex)
+                     (setq file file-ex))
+                   (load file nil t)))
+
+                ((equal argi "-insert")
+                 (setq tem (or argval (pop command-line-args-left)))
+                 (or (stringp tem)
+                     (error "File name omitted from `-insert' option"))
+                 (insert-file-contents (command-line-normalize-file-name tem)))
+
+                ((equal argi "-kill")
+                 (kill-emacs t))
+
+                ((string-match "^\\+[0-9]+\\'" argi)
+                 (setq line (string-to-number argi)))
+
+                ((string-match "^\\+\\([0-9]+\\):\\([0-9]+\\)\\'" argi)
+                 (setq line (string-to-number (match-string 1 argi))
+                       column (string-to-number (match-string 2 argi))))
+
+                ((setq tem (assoc argi command-line-x-option-alist))
+                 ;; Ignore X-windows options and their args if not using X.
+                 (setq command-line-args-left
+                       (nthcdr (nth 1 tem) command-line-args-left)))
+
+                ((member argi '("-find-file" "-file" "-visit"))
+                 ;; An explicit option to specify visiting a file.
+                 (setq tem (or argval (pop command-line-args-left)))
+                 (unless (stringp tem)
+                   (error "File name omitted from `%s' option" argi))
+                 (setq file-count (1+ file-count))
+                 (let ((file (expand-file-name
+                              (command-line-normalize-file-name tem) dir)))
+                   (if (= file-count 1)
+                       (setq first-file-buffer (find-file file))
+                     (find-file-other-window file)))
+                 (or (zerop line)
+                     (goto-line line))
+                 (setq line 0)
+                 (unless (< column 1)
+                   (move-to-column (1- column)))
+                 (setq column 0))
+
+                ((equal argi "--")
+                 (setq just-files t))
+                (t
+                 ;; We have almost exhausted our options. See if the
+                 ;; user has made any other command-line options available
+                 (let ((hooks command-line-functions) ;; lrs 7/31/89
+                       (did-hook nil))
+                   (while (and hooks
+                               (not (setq did-hook (funcall (car hooks)))))
+                     (setq hooks (cdr hooks)))
+                   (if (not did-hook)
+                       ;; Presume that the argument is a file name.
+                       (progn
+                         (if (string-match "\\`-" argi)
+                             (error "Unknown option `%s'" argi))
+                         (setq file-count (1+ file-count))
+                         (let ((file
+                                (expand-file-name
+                                 (command-line-normalize-file-name orig-argi)
+                                 dir)))
+                           (if (= file-count 1)
+                               (setq first-file-buffer (find-file file))
+                             (find-file-other-window file)))
+                         (or (zerop line)
+                             (goto-line line))
+                         (setq line 0)
+                         (unless (< column 1)
+                           (move-to-column (1- column)))
+                         (setq column 0))))))))
+
+      ;; If 3 or more files visited, and not all visible,
+      ;; show user what they all are.  But leave the last one current.
+      (and (> file-count 2)
+           (not noninteractive)
+           (not inhibit-startup-buffer-menu)
+           (or (get-buffer-window first-file-buffer)
+               (list-buffers)))))
+
+  ;; Maybe display a startup screen.
+  (unless (or inhibit-startup-message
+	      noninteractive
+	      emacs-quick-startup
+	     ;; Don't display startup screen if init file
+	     ;; has started some sort of server.
+	     (and (fboundp 'process-list)
+		  (process-list)))
+    ;; Display a startup screen, after some preparations.
+
+    ;; If there are no switches to process, we might as well
+    ;; run this hook now, and there may be some need to do it
+    ;; before doing any output.
+    (run-hooks 'emacs-startup-hook)
+    (and term-setup-hook
+	 (run-hooks 'term-setup-hook))
+    (setq inhibit-startup-hooks t)
+
+    ;; It's important to notice the user settings before we
+    ;; display the startup message; otherwise, the settings
+    ;; won't take effect until the user gives the first
+    ;; keystroke, and that's distracting.
+    (when (fboundp 'frame-notice-user-settings)
+      (frame-notice-user-settings))
+
+    ;; If there are no switches to process, we might as well
+    ;; run this hook now, and there may be some need to do it
+    ;; before doing any output.
+    (when window-setup-hook
+      (run-hooks 'window-setup-hook)
+      ;; Don't let the hook be run twice.
+      (setq window-setup-hook nil))
+
+    ;; Do this now to avoid an annoying delay if the user
+    ;; clicks the menu bar during the sit-for.
+    (when (display-popup-menus-p)
+      (precompute-menubar-bindings))
+    (with-no-warnings
+     (setq menubar-bindings-done t))
+
+    ;; If *scratch* is selected and it is empty, insert an
+    ;; initial message saying not to create a file there.
+    (when (and initial-scratch-message
+	       (equal (buffer-name) "*scratch*")
+	       (= 0 (buffer-size)))
+      (insert initial-scratch-message)
+      (set-buffer-modified-p nil))
+
+    ;; If user typed input during all that work,
+    ;; abort the startup screen.  Otherwise, display it now.
+    (unless (input-pending-p)
+      (display-splash-screen))))
+
+
+(defun command-line-normalize-file-name (file)
+  "Collapse multiple slashes to one, to handle non-Emacs file names."
+  (save-match-data
+    ;; Use arg 1 so that we don't collapse // at the start of the file name.
+    ;; That is significant on some systems.
+    ;; However, /// at the beginning is supposed to mean just /, not //.
+    (if (string-match "^///+" file)
+	(setq file (replace-match "/" t t file)))
+    (while (string-match "//+" file 1)
+      (setq file (replace-match "/" t t file)))
+    file))
+
+;; arch-tag: 7e294698-244d-4758-984b-4047f887a5db
+;;; startup.el ends here
diff -uNr emacs/lisp/term/mac-im.el emacs22-carbon/lisp/term/mac-im.el
--- emacs/lisp/term/mac-im.el	1970-01-01 09:00:00.000000000 +0900
+++ emacs22-carbon/lisp/term/mac-im.el	2005-09-26 14:45:36.000000000 +0900
@@ -0,0 +1,162 @@
+;; mac-im.el --- Input Method for Mac OS X -*-coding: iso-2022-7bit;-*-
+
+;; Copyright (C) 2005 HASHIMOTO Taiichi <taiichi2@mac.com>
+;; Keywords: input method, Mac OS X
+
+;; This file is not part of GNU Emacs.
+
+;; GNU Emacs is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 2, or (at your option)
+;; any later version.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs; see the file COPYING.  If not, write to the
+;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+;; Boston, MA 02111-1307, USA.
+
+;; Written by Taiichi Hashimoto (taiichi2@mac.com).
+
+;;
+;; Faces for inline input method on MacOSX.
+;;
+(make-face 'mac-input-method-face)
+(set-face-underline-p 'mac-input-method-face t)
+
+(make-face 'mac-input-method-selection-face)
+(set-face-foreground 'mac-input-method-selection-face "black")
+(set-face-background 'mac-input-method-selection-face "light sky blue")
+(set-face-underline-p 'mac-input-method-selection-face t)
+
+
+;;
+;; Variables for inline input method on MacOSX.
+;;
+(defvar mac-input-method-preedit-start (make-marker)
+  "Start position on buffer for inline input method preedit.")
+(make-variable-buffer-local 'mac-input-method-preedit-start)
+
+(defvar  mac-input-method-preedit-end (make-marker)
+  "End position on buffer for inline input method preedit.")
+(make-variable-buffer-local 'mac-input-method-preedit-end)
+
+(defconst mac-input-method-face-alist
+  '((1 . nil)                             ; kTSMHiliteCaretPosition
+    (2 . mac-input-method-face)           ; kTSMHiliteRawText
+    (3 . mac-input-method-face)           ; kTSMHiliteSelectedRawText
+    (4 . mac-input-method-face)           ; kTSMHiliteConvertedText
+    (5 . mac-input-method-selection-face) ; kTSMHiliteSelectedConvertedText
+    (6 . mac-input-method-face)           ; kTSMHiliteBlockFillText
+    (7 . mac-input-method-face)           ; kTSMHiliteOutlineText
+    (8 . mac-input-method-selection-face) ; kTSMHiliteSelectedText
+    (9 . nil))                            ; kTSMHiliteNoteHilite
+  "An alist of property type of input method vs face.")
+
+(defconst mac-input-method-property-function-alist
+  '((1 . mac-move-caret)                  ; kTSMHiliteCaretPosition
+    (2 . mac-set-input-method-face)       ; kTSMHiliteRawText
+    (3 . mac-set-input-method-face)       ; kTSMHiliteSelectedRawText
+    (4 . mac-set-input-method-face)       ; kTSMHiliteConvertedText
+    (5 . mac-set-input-method-face)       ; kTSMHiliteSelectedConvertedText
+    (6 . mac-set-input-method-face)       ; kTSMHiliteBlockFillText
+    (7 . mac-set-input-method-face)       ; kTSMHiliteOutlineText
+    (8 . mac-set-input-method-face)       ; kTSMHiliteSelectedText
+    (9 . nil))                            ; kTSMHiliteNoteHilite
+  "An alist of property type of input method vs function.")
+
+
+;;
+;; Functions for inline input method on MacOSX.
+;;
+(defun mac-set-input-method-property (str coding-system prop)
+  "Function to add property to string inserted on buffer."
+  (let* ((type (nth 0 prop))
+	 (pos (marker-position mac-input-method-preedit-start))
+	 (beg (+ pos (length (decode-coding-string
+			      (substring str 0 (nth 1 prop))
+			      coding-system))))
+	 (end (+ pos (length (decode-coding-string
+			      (substring str 0 (nth 2 prop))
+			      coding-system))))
+	 (func (assq type mac-input-method-property-function-alist)))
+    (and func (cdr func) (funcall (cdr func) type beg end))))
+
+(defun mac-set-input-method-face (type beg end)
+  "Function to set face to string inserted on buffer."
+  (let* ((face (assq type mac-input-method-face-alist))
+	 (obj (make-overlay beg end)))
+    (if (and face (cdr face))
+	(overlay-put obj 'face (cdr face)))))
+
+(defun mac-move-caret (type beg end)
+  "Function to set face to string inserted on buffer."
+  (goto-char beg))
+
+(defun mac-input-method-preedit (event)
+  "Function to insert input method preedit string and set property of it."
+  (interactive "e")
+
+  (let* ((coding-system (keyboard-coding-system))
+	 (arg (cdr event))
+	 (str (car arg))
+	 (fix (cadr arg))
+	 (prop (cddr arg)))
+
+    ;; initialize start/end marker for input method
+    (if (equal mac-input-method-preedit-start mac-input-method-preedit-end)
+	(progn
+	  (set-marker mac-input-method-preedit-start (point))
+	  (set-marker mac-input-method-preedit-end (point))
+	  (set-marker-insertion-type mac-input-method-preedit-start nil)
+	  (set-marker-insertion-type mac-input-method-preedit-end t))
+      (delete-region mac-input-method-preedit-start mac-input-method-preedit-end))
+
+    ;; insert character to current buffer 
+    (let ((l (string-to-list (decode-coding-string str coding-system))))
+      (while l
+	(insert (if (and (eq coding-system 'japanese-shift-jis)
+			 (eq (car l) ?\x80))
+		    ?\\
+		  (car l)))
+	(setq l (cdr l))))
+    
+    (if prop
+	(let ((p prop))
+	  (while p
+	    (mac-set-input-method-property str coding-system (car p))
+	    (setq p (cdr p))))
+      (set-marker mac-input-method-preedit-start nil nil)
+      (set-marker mac-input-method-preedit-end nil nil))))
+
+
+(defun mac-input-method-isearch-mode (event)
+  "Function to change from isearch-mode to isearch-edit-string 
+for inline input method on MacOSX."
+  (interactive "e")
+  (let ((minibuffer-setup-hook nil))
+    (setq unread-command-events (cons event unread-command-events))
+    (isearch-edit-string)))
+
+(defun mac-input-method-isearch-edit-string (event)
+  "Function is isearch-edit-string for inline input method on MacOSX."
+  (interactive "e")
+  (mac-input-method-preedit event)
+  (if (equal mac-input-method-preedit-start mac-input-method-preedit-end)
+      (exit-minibuffer)))
+
+(defun mac-toggle-input-method ()
+  "Function to toggle input method on MacOSX."
+  (interactive)
+  (mac-set-key-script -1))
+
+(defun mac-change-language-to-us ()
+  "Function to change language (Apple Key Script) to us."
+  (interactive)
+  (mac-set-key-script -17))
+
+;;
+;; Key binding for inline input method on MacOSX.
+;;
+(define-key global-map [mac-input-method] 'mac-input-method-preedit)
+(define-key isearch-mode-map [mac-input-method] 'mac-input-method-isearch-mode)
+(define-key minibuffer-local-isearch-map [mac-input-method] 'mac-input-method-isearch-edit-string)
diff -uNr emacs/mangle-info emacs22-carbon/mangle-info
--- emacs/mangle-info	1970-01-01 09:00:00.000000000 +0900
+++ emacs22-carbon/mangle-info	2005-09-26 13:39:05.000000000 +0900
@@ -0,0 +1,17 @@
+#!/usr/bin/perl -w -i
+
+use English;
+use strict;
+
+$RS = undef;
+
+my $prefix = "emacs-22";
+
+my $x = <>;
+if(!($x =~ m/^(\s*START-INFO-DIR-ENTRY\s+\*\s*[^:]+:\s*)\(([^\)]+)\)/mo)) {
+  die "Couldn't find START-INFO-DIR-ENTRY.";
+}
+   
+print ${PREMATCH};
+print "$1($prefix/$2)";
+print ${POSTMATCH};
diff -uNr emacs/src/Makefile.in emacs22-carbon/src/Makefile.in
--- emacs/src/Makefile.in	2005-07-05 18:38:53.000000000 +0900
+++ emacs22-carbon/src/Makefile.in	2005-09-26 14:45:36.000000000 +0900
@@ -570,7 +570,7 @@
 
 #ifdef HAVE_CARBON
 mac = $(dot)$(dot)/mac/
-MAC_OBJ = mac.o macterm.o macfns.o macmenu.o macselect.o fontset.o fringe.o image.o
+MAC_OBJ = mac.o macterm.o macfns.o macmenu.o macselect.o fontset.o fringe.o image.o macim.o
 emacsapp = $(PWD)/$(mac)Emacs.app/
 emacsappsrc = ${srcdir}/../mac/Emacs.app/
 #endif
@@ -597,7 +597,7 @@
    in case they are needed there.  */
 SOME_MACHINE_OBJECTS = sunfns.o dosfns.o msdos.o \
   xterm.o xfns.o xmenu.o xselect.o xrdb.o xsmfns.o fringe.o image.o \
-  mac.o macterm.o macfns.o macmenu.o macselect.o fontset.o \
+  mac.o macterm.o macfns.o macmenu.o macselect.o macim.o fontset.o \
   w32.o w32bdf.o w32console.o w32fns.o w32heap.o w32inevt.o \
   w32menu.o w32proc.o w32reg.o w32select.o w32term.o w32xfns.o
 
@@ -1247,6 +1247,10 @@
   frame.h charset.h ccl.h dispextern.h fontset.h termhooks.h termopts.h \
   termchar.h gnu.h disptab.h buffer.h window.h keyboard.h $(INTERVAL_SRC) \
   process.h coding.h $(config_h)
+macim.o: blockinput.h atimer.h systime.h syssignal.h macterm.h macgui.h \
+  frame.h charset.h ccl.h dispextern.h fontset.h termhooks.h termopts.h \
+  termchar.h gnu.h disptab.h buffer.h window.h keyboard.h $(INTERVAL_SRC) \
+  process.h coding.h $(config_h)
 macselect.o: blockinput.h macterm.h macgui.h frame.h $(config_h)
 
 ${emacsapp}Contents/Resources/English.lproj:
diff -uNr emacs/src/keyboard.c emacs22-carbon/src/keyboard.c
--- emacs/src/keyboard.c	2005-09-26 13:24:26.000000000 +0900
+++ emacs22-carbon/src/keyboard.c	2005-09-26 14:45:36.000000000 +0900
@@ -528,6 +528,9 @@
 #if defined (WINDOWSNT) || defined (MAC_OS)
 Lisp_Object Qlanguage_change;
 #endif
+#if defined (MAC_OSX)
+Lisp_Object Qmac_input_method;
+#endif
 Lisp_Object Qdrag_n_drop;
 Lisp_Object Qsave_session;
 
@@ -4047,6 +4050,15 @@
 	  kbd_fetch_ptr = event + 1;
 	}
 #endif
+#if defined (MAC_OSX)
+      else if (event->kind == MAC_INPUT_METHOD_EVENT)
+	{
+	  /* Make an event (mac-input-method (STRING FIXED_LEN 
+	     (HILITE_TYPE1 START1 END1) (HILITE_TYPE2 START2 END2) ...). */
+	  obj = Fcons (Qmac_input_method, event->arg);
+	  kbd_fetch_ptr = event + 1;
+	}
+#endif
       else if (event->kind == SAVE_SESSION_EVENT)
         {
           obj = Fcons (Qsave_session, Qnil);
@@ -10843,6 +10855,10 @@
   Qlanguage_change = intern ("language-change");
   staticpro (&Qlanguage_change);
 #endif
+#if defined (MAC_OSX)
+  Qmac_input_method = intern ("mac-input-method");
+  staticpro (&Qmac_input_method);
+#endif
   Qdrag_n_drop = intern ("drag-n-drop");
   staticpro (&Qdrag_n_drop);
 
diff -uNr emacs/src/macim.c emacs22-carbon/src/macim.c
--- emacs/src/macim.c	1970-01-01 09:00:00.000000000 +0900
+++ emacs22-carbon/src/macim.c	2005-09-26 14:45:36.000000000 +0900
@@ -0,0 +1,376 @@
+/* Implementation of Inline Input Method for MacOS X.
+   Copyright (C) 2004, 2005 Taiichi Hashimoto <taiichi2@mac.com>.
+
+This file is not part of GNU Emacs.
+
+GNU Emacs is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Emacs is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Emacs; see the file COPYING.  If not, write to
+the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Written by Taiichi Hashimoto (taiichi2@mac.com).  */
+
+
+#include <config.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "lisp.h"
+#include "charset.h"
+#include "blockinput.h"
+
+#include "macterm.h"
+
+#ifndef MAC_OSX
+#include <alloca.h>
+#endif
+
+#ifdef MAC_OSX
+#undef mktime
+#undef DEBUG
+#undef free
+#undef malloc
+#undef realloc
+/* Macros max and min defined in lisp.h conflict with those in
+   precompiled header Carbon.h.  */
+#undef max
+#undef min
+#undef init_process
+#include <Carbon/Carbon.h>
+#undef free
+#define free unexec_free
+#undef malloc
+#define malloc unexec_malloc
+#undef realloc
+#define realloc unexec_realloc
+#undef min
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#undef max
+#define max(a, b) ((a) > (b) ? (a) : (b))
+#undef init_process
+#define init_process emacs_init_process
+/* USE_CARBON_EVENTS determines if the Carbon Event Manager is used to
+   obtain events from the event queue.  If set to 0, WaitNextEvent is
+   used instead.  */
+#define USE_CARBON_EVENTS 1
+#else /* not MAC_OSX */
+#include <Quickdraw.h>
+#include <ToolUtils.h>
+#include <Sound.h>
+#include <Events.h>
+#include <Script.h>
+#include <Resources.h>
+#include <Fonts.h>
+#include <TextUtils.h>
+#include <LowMem.h>
+#include <Controls.h>
+#if defined (__MRC__) || (__MSL__ >= 0x6000)
+#include <ControlDefinitions.h>
+#endif
+#include <Gestalt.h>
+
+#if __profile__
+#include <profiler.h>
+#endif
+#endif /* not MAC_OSX */
+
+#include "systty.h"
+#include "systime.h"
+#include "atimer.h"
+#include "keymap.h"
+
+#include <ctype.h>
+#include <errno.h>
+#include <setjmp.h>
+#include <sys/stat.h>
+
+#include "keyboard.h"
+#include "frame.h"
+#include "dispextern.h"
+#include "fontset.h"
+#include "termhooks.h"
+#include "termopts.h"
+#include "termchar.h"
+#include "gnu.h"
+#include "disptab.h"
+#include "buffer.h"
+#include "window.h"
+#include "intervals.h"
+#include "composite.h"
+#include "coding.h"
+
+#ifdef USE_CARBON_EVENTS && defined (MAC_OSX)
+
+static EventTypeSpec events[] = {
+  { kEventClassTextInput, kEventTextInputOffsetToPos },
+  { kEventClassTextInput, kEventTextInputUpdateActiveInputArea },
+  { kEventClassTextInput, kEventTextInputUnicodeForKeyEvent },
+  { kEventClassTextInput, kEventTextInputPosToOffset },
+  { kEventClassTextInput, kEventTextInputGetSelectedText }
+};
+
+static EventHandlerRef mac_input_method_handler = NULL;
+static EventHandlerUPP mac_input_method_handlerUPP = NULL;
+static TSMDocumentID mac_tsm_doc_id;
+
+pascal OSStatus mac_handle_input_method_event (EventHandlerCallRef, EventRef, void *);
+void init_input_method (void);
+
+
+DEFUN ("mac-set-key-script", Fmac_set_key_script,
+       Smac_set_key_script, 1, 1, 0,
+       doc: /* change languge environment of MacOSX */)
+     (code)
+     Lisp_Object code;
+{
+  BLOCK_INPUT;
+  KeyScript (XINT(code));
+  UNBLOCK_INPUT;
+
+  return Qnil;
+}
+
+DEFUN ("mac-get-key-script", Fmac_get_key_script,
+       Smac_get_key_script, 0, 0, 0,
+       doc: /* get current languge environment of MacOSX */)
+     ()
+{
+  SInt16 current_key_script;
+
+  BLOCK_INPUT;
+  current_key_script = GetScriptManagerVariable (smKeyScript);
+  UNBLOCK_INPUT;
+
+  return make_number (current_key_script);
+}
+
+DEFUN ("mac-set-inline-input-method", Fmac_set_inline_input_method,
+       Smac_set_inline_input_method, 1, 1, 0,
+       doc: /* set inline input method on/off */)
+     (on_p)
+     Lisp_Object on_p;
+{
+  extern Lisp_Object Vmac_use_inline_input_method;
+
+  BLOCK_INPUT;
+
+  if (NILP(on_p))
+    {
+      DeactivateTSMDocument (mac_tsm_doc_id);
+      Vmac_use_inline_input_method = Qnil;
+    }
+  else
+    {
+      ActivateTSMDocument (mac_tsm_doc_id);
+      Vmac_use_inline_input_method = Qt;
+    }
+  UNBLOCK_INPUT;
+
+  return on_p;
+}
+
+void
+mac_store_change_language_event (unsigned long timestamp)
+{
+  static SInt16 last_key_script = -1;
+  SInt16 current_key_script;
+  
+  BLOCK_INPUT;
+  current_key_script = GetScriptManagerVariable (smKeyScript);
+  UNBLOCK_INPUT;
+
+  if (last_key_script != current_key_script)
+    {
+      struct input_event event;
+      
+      EVENT_INIT (event);
+      event.kind = LANGUAGE_CHANGE_EVENT;
+      event.arg = Qnil;
+      event.code = current_key_script;
+      event.timestamp = timestamp;
+      kbd_buffer_store_event (&event);
+    }
+
+  last_key_script = current_key_script;
+}
+
+int
+mac_ignore_input_method ()
+{
+  if (this_command_key_count
+      || !NILP (current_buffer->read_only)
+      || cursor_in_echo_area)
+    return FALSE;
+
+  return TRUE;
+}
+
+pascal OSStatus
+mac_handle_input_method_event(EventHandlerCallRef er, EventRef event, void *data)
+{
+  UInt32 ekind = GetEventKind (event), eclass = GetEventClass (event);
+  OSStatus ret = noErr, err;
+  unsigned long timestamp = GetEventTime (event) / kEventDurationMillisecond;
+  static int converting = FALSE;
+
+  BLOCK_INPUT;
+  switch (eclass) {
+  case kEventClassTextInput:
+    switch (ekind) {
+    case kEventTextInputOffsetToPos:
+      {
+	struct frame *f = one_mac_display_info.x_focus_frame;
+	struct window *w = XWINDOW (f->selected_window);
+	Point pt;
+
+	/* set position of candidates window */
+	pt.h = WINDOW_TO_FRAME_PIXEL_X (w, w->phys_cursor.x);
+	pt.v = WINDOW_TO_FRAME_PIXEL_Y (w, w->phys_cursor.y) + w->phys_cursor_height;
+	LocalToGlobal (&pt);
+
+	SetEventParameter (event, kEventParamTextInputReplyPoint,
+			   typeQDPoint, sizeof(pt), &pt);
+      }
+      break;
+    case kEventTextInputPosToOffset:
+      break;
+    case kEventTextInputUpdateActiveInputArea:
+      {
+	UInt32 src_nbytes = 0, array_nbytes = 0, fixed_nbytes = 0;
+	unsigned char *src = NULL;
+	TextRangeArray *array = NULL;
+	Lisp_Object argv[1024], triple[3];
+	int argc = 0, i = 0;
+	
+
+	GetEventParameter (event, kEventParamTextInputSendText,
+			   typeChar,
+			   NULL, 0,
+			   &src_nbytes, NULL);
+	
+	if (src_nbytes) 
+	  {
+	    /* get converting string from TSM */
+	    src = (unsigned char *) xmalloc (src_nbytes + 1);
+	    memset (src, 0, src_nbytes + 1);
+	    GetEventParameter (event, kEventParamTextInputSendText,
+			       typeChar,
+			       NULL, src_nbytes,
+			       NULL, src);
+	    argv[argc++] = make_string_from_bytes (src, src_nbytes, src_nbytes);
+	    
+	    /* get fixed string length (bytes) from TSM */
+	    GetEventParameter (event, kEventParamTextInputSendFixLen,
+			       typeLongInteger, 
+			       NULL, sizeof(fixed_nbytes), 
+			       NULL, &fixed_nbytes);
+	    argv[argc++] = make_number (fixed_nbytes);
+
+	    /* get properties of string from TSM */
+	    GetEventParameter (event, kEventParamTextInputSendHiliteRng,
+			       typeTextRangeArray,
+			       NULL, 0,
+			       &array_nbytes, NULL);
+	    
+	    if (array_nbytes)
+	      {
+		array = (TextRangeArray *) xmalloc (array_nbytes);
+		
+		GetEventParameter (event, kEventParamTextInputSendHiliteRng,
+				   typeTextRangeArray,
+				   NULL, array_nbytes,
+				   NULL, array);
+
+		for (i = 0; i < array->fNumOfRanges && argc < 1024; i++)
+		  {
+		    triple[0] = make_number (array->fRange[i].fHiliteStyle);
+		    triple[1] = make_number (array->fRange[i].fStart);
+		    triple[2] = make_number (array->fRange[i].fEnd);
+		    argv[argc++] = list3 (make_number (array->fRange[i].fHiliteStyle),
+					  make_number (array->fRange[i].fStart),
+					  make_number (array->fRange[i].fEnd));
+		  }
+	      }
+	    if (src) xfree(src);
+	    if (array) xfree(array);
+
+	    if (fixed_nbytes) converting = FALSE;
+	    else converting = TRUE;
+	  }
+	else
+	  { /* src_nbytes == 0 */
+	    argv[argc++] = make_string("", 0);
+	    argv[argc++] = make_number(0);
+
+	    converting = FALSE;
+	  }
+
+	{
+	  struct input_event inev;
+	  
+	  EVENT_INIT (inev);
+	  inev.kind = MAC_INPUT_METHOD_EVENT;
+	  inev.arg = Flist (argc, argv);
+	  inev.timestamp = timestamp;
+	  kbd_buffer_store_event (&inev);
+	}
+      }
+      break;
+    case kEventTextInputGetSelectedText:
+      break;
+    case kEventTextInputUnicodeForKeyEvent:
+      if (!converting) ret = eventNotHandledErr;
+      break;
+    default:
+      break;
+    }
+    break;
+  default:
+    break;
+  }
+  UNBLOCK_INPUT;
+
+  return ret;
+}
+
+void init_input_method (void)
+{
+  if(!mac_input_method_handler) {
+    OSErr err;
+    InterfaceTypeList itl = { kTextService };
+
+    BLOCK_INPUT;
+    err = NewTSMDocument (1, itl, &mac_tsm_doc_id, 715);
+    if (err != noErr) abort (); 
+    
+    err = ActivateTSMDocument (mac_tsm_doc_id);
+    if (err != noErr) abort ();
+    
+    err = InstallEventHandler(GetApplicationEventTarget (),
+			      NewEventHandlerUPP (mac_handle_input_method_event),
+			      GetEventTypeCount (events),
+			      events,
+			      NULL,
+			      &mac_input_method_handler);
+    if (err != noErr) abort ();
+    UNBLOCK_INPUT;
+  }
+  
+  defsubr (&Smac_set_inline_input_method);
+  defsubr (&Smac_set_key_script);
+  defsubr (&Smac_get_key_script);
+
+}
+
+#endif
+
diff -uNr emacs/src/macterm.c emacs22-carbon/src/macterm.c
--- emacs/src/macterm.c	2005-09-26 13:24:26.000000000 +0900
+++ emacs22-carbon/src/macterm.c	2005-09-26 14:45:36.000000000 +0900
@@ -103,6 +103,9 @@
 /* If Non-nil, the text will be rendered using Core Graphics text rendering which may anti-alias the text.  */
 Lisp_Object Vmac_use_core_graphics;
 
+/* If Non-nil, the users can use inline input method on MacOSX. */
+Lisp_Object Vmac_use_inline_input_method;
+
 
 /* Non-zero means that a HELP_EVENT has been generated since Emacs
    start.  */
@@ -8740,8 +8743,8 @@
   /*0x5C*/ 0xb9 /*kp-9*/, 0, 0, 0,
 
   /*0x60*/ 0xc2 /*f5*/, 0xc3 /*f6*/, 0xc4 /*f7*/, 0xc0 /*f3*/,
-  /*0x64*/ 0xc5 /*f8*/, 0xc6 /*f9*/, 0, 0xc8 /*f11*/,
-  /*0x68*/ 0, 0xca /*f13*/, 0, 0xcb /*f14*/,
+  /*0x64*/ 0xc5 /*f8*/, 0xc6 /*f9*/, 0x2f /*eisu-shift*/, 0xc8 /*f11*/,
+  /*0x68*/ 0x2e /*kana-shift*/, 0xca /*f13*/, 0, 0xcb /*f14*/,
   /*0x6C*/ 0, 0xc7 /*f10*/, 0x0a /*fn+enter on laptops*/, 0xc9 /*f12*/,
 
   /*0x70*/ 0, 0xcc /*f15*/, 0x6a /*help*/, 0x50 /*home*/,
@@ -9289,6 +9292,9 @@
 	    int xkeysym;
 
 #if USE_CARBON_EVENTS && defined (MAC_OSX)
+	    Fmac_set_inline_input_method (Vmac_use_inline_input_method);
+	    mac_store_change_language_event (timestamp);
+
 	    /* When using Carbon Events, we need to pass raw keyboard
 	       events to the TSM ourselves.  If TSM handles it, it
 	       will pass back noErr, otherwise it will pass back
@@ -9300,10 +9306,14 @@
 		    || !(er.modifiers & controlKey))
 		&& (!NILP (Vmac_command_key_is_meta)
 		    && NILP (Vmac_option_modifier)
-		    || !(er.modifiers & optionKey)))
+		    || !(er.modifiers & optionKey))
+		&& (er.modifiers
+		    || mac_ignore_input_method ()))
 	      if (SendEventToEventTarget (eventRef, toolbox_dispatcher)
-		  != eventNotHandledErr)
+		  != eventNotHandledErr) {
+		mac_store_change_language_event (timestamp);
 		break;
+	      }
 #endif
 
 #if 0
@@ -9316,6 +9326,7 @@
 	      }
 #endif
 
+#if 0
 	    {
 	      static SInt16 last_key_script = -1;
 	      SInt16 current_key_script = GetScriptManagerVariable (smKeyScript);
@@ -9334,6 +9345,7 @@
 		}
 	      last_key_script = current_key_script;
 	    }
+#endif
 
 	    ObscureCursor ();
 
@@ -10006,6 +10018,8 @@
   init_service_handler ();
 
   init_quit_char_handler ();
+  
+  init_input_method();
 #endif	/* MAC_OSX */
 
   init_command_handler ();
@@ -10119,6 +10133,9 @@
 Toolbox for processing before Emacs sees it.  */);
   Vmac_pass_control_to_system = Qt;
 
+  DEFVAR_LISP ("mac-use-inline-input-method", &Vmac_use_inline_input_method,
+   doc: /* If Non-nil, the users can use inline input method on MacOSX. */);
+  Vmac_use_inline_input_method = Qt;
 #endif
 
   DEFVAR_LISP ("mac-allow-anti-aliasing", &Vmac_use_core_graphics,
diff -uNr emacs/src/termhooks.h emacs22-carbon/src/termhooks.h
--- emacs/src/termhooks.h	2005-07-05 18:39:18.000000000 +0900
+++ emacs22-carbon/src/termhooks.h	2005-09-26 14:45:36.000000000 +0900
@@ -259,6 +259,10 @@
 				   language is changed by the
 				   user.  */
 #endif
+#if defined (MAC_OSX)
+  MAC_INPUT_METHOD_EVENT,	/* A MAC_INPUT_METHOD_EVENT is generated 
+				   for inline input method using TSM. */
+#endif
   SCROLL_BAR_CLICK_EVENT,	/* .code gives the number of the mouse button
 				   that was clicked.
 				   .modifiers holds the state of the modifier