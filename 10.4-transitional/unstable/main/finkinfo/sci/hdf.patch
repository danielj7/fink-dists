diff -urN HDF4.1r5/config/mh-darwin hdf-new/config/mh-darwin
--- HDF4.1r5/config/mh-darwin	Wed Dec 31 19:00:00 1969
+++ hdf-new/config/mh-darwin	Mon Dec  8 19:45:34 2003
@@ -0,0 +1,180 @@
+# $Id: hdf-4.1r4-2.patch,v 1.1 2001/09/19 14:46:18 jswhit Exp $
+
+# You can override the following variables here
+#
+# Sections in Host makefile fragments
+# ----------------------------------:
+# 1. General Macros for HDF
+# 2. Macros for Pablo Instrumentation
+# 3. Macros for File Cache
+# 4. General macros for NETCDF
+# 4.1 XDR Macros for NETCDF
+# 4.2 libsrc Macros for NETCDF
+# 4.3 Port Macros for NETCDF
+#
+
+# ------------ General Macros for HDF --------------------
+# Version of the library
+PACKAGE	 = HDF
+VERSION  = 4.0
+#
+# Compiliers:
+# For gcc version
+CC=cc
+CFLAGS=-ansi -D_ANSI_SOURCE -O -no-cpp-precomp
+
+# Fortran compilier
+#FC = f77
+FC = fort77
+#FC = g77
+FFLAGS = -O -Nx800
+
+# Name of achive randomizer, usually ranlib (use 'true' if non-existant)
+RANLIB = ranlib
+
+# Name of library archiver and flags to send, default 'AR=ar', 'ARFLAGS=r'
+AR = ar
+ARFLAGS = r
+
+# Name of remove utility, default 'RM=/bin/rm', 'RMFLAGS=-f'
+RM = /bin/rm
+RMFLAGS = -f
+
+# Extra libraries to be include like '-lm' for fabs()
+# e.g with naitve HP-ANSI compilier
+#LIBSX = -lm
+
+# ------------ Macros for Pablo Instrumentation  --------------------
+# Uncomment the following lines to create a Pablo Instrumentation
+# version of the HDF core library called 'libdf-inst.a'
+# See the documentation in the directory 'hdf/pablo' for further 
+# information about Pablo and what platforms it is supported on
+# before enabling. 
+# You need to set 'PABLO_INCDIR' to the Pablo distribution 
+# include directory to get to files 'IOTrace.h', 'IOTrace_SD.h' and others.
+
+#PABLO_FLAGS  = -DHAVE_PABLO
+#PABLO_INCDIR = /usr/local/include/pablo-5.1
+#PABLO_INCLUDE = -I$(PABLO_INCDIR)
+
+# ------------ Macros for File Cache(fmpool) ------
+# Uncomment the following lines to enable shared memory file buffer pool
+# version of the HDF core library libdf.a. Please read the
+# documentation before enabling this feature.
+
+#FMPOOL_FLAGS  = -DHAVE_FMPOOL
+
+# ------------ General Macros for NETCDF --------------------
+# Operating system, Used in fortran directory to generate fortran
+# wrappers. Possible values are osf, aix, hpux, irix, sunos, ultrix
+# unicos, convex, Linux, freebsd
+OS	= Linux
+
+CPP	      = $(CC) -E
+
+# for endianess, for little endian byte order need -DSWAP
+# for FreeBSD and Linux(anny x86 UNIX)
+#SWAP          = -DSWAP
+#SWAP          = 
+
+# for 32bit 'network long' integer, possible value -DNETLONG=int
+NETLONG       = 
+
+# additional CFLAGS
+CFLAGS_NETCDF = 
+
+# Additional flags for preproccesor. Some no longer used because
+#   library now requires ANSI compilier.
+#
+# for no function prototypes add -DNO_HAVE_PROTOTYPES
+# for no strerror()          add -DNO_STRERROR
+# for no variadic function support add -DNO_STDARG
+#
+# They all require -DHDF and -DNDEBUG 
+# Any special preprocessor requirements go here
+#
+# for Unicos 
+# CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -DBIG_SHORTS -DBIG_LONGS
+#
+# for OSF(dec alpha) 
+# CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -DBIG_LONGS -std1
+#
+# for IRIX6(64-bit) 
+# CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -DBIG_LONGS
+#
+# for AIX
+# CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -D_ALL_SOURCE
+#
+# for Sunos and Linux
+#CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -DNO_STRERROR
+#
+# for IRIX6.0 (32-bit mode). If you prefer other 32 bit option like -n32, 
+#  replace '-32' below
+# CPPFLAGS_HDF  = -32 $(FMPOOL_FLAGS) -DNDEBUG -DHDF
+#
+# normal
+CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF
+
+#
+# Unix commands/utilities
+#
+# neqn(1)
+NEQN	= neqn
+# tbl(1)
+TBL	= tbl
+# which(1)
+WHICH	= which
+# lex(1)
+#LEX	= lex    # GNU flex?
+LEX	= flex    # GNU flex?
+# yacc(1)
+YACC	= yacc   # GNU bison?
+
+#diff(1)
+DIFF    = diff   # GNU diff?
+DIFF_FLAGS = -w
+
+# Other Macros
+NCDUMP	= 
+NCGEN	= 
+FTPDIR	= 
+VERSION_NETCDF	= 2.3.2
+
+# ------------ XDR Macros for NETCDF --------------------
+# This is where the location of system XDR library includes
+# and location of the library are set
+#
+# Location of <xdr.h> if you are using the system
+# one, Else you need to comment it out
+CPP_XDR		= -I/usr/include/rpc
+
+# If XDR library not present on the system then you need
+# uncomment the following and comment the one below it
+#XDR_LIBOBJS    = xdr.o xdrfloat.o xdrstdio.o xdrarray.o
+XDR_LIBOBJS     =
+
+# Location of library, sometimes the sunos requires -lsun
+LD_XDR		= 
+
+#
+XDR_INSTALL_DEPS =
+
+# ------------ libsrc Macros for NETCDF --------------------
+# Possible values are xdrposix and xdrstdio
+# This sets which version of the XDR interface to use.
+XDRFILE		= xdrposix
+
+# ------------ Port Macros for NETCDF --------------------
+# Major and Minor numbe of NETCDF library version
+MAJOR_NO	= 2
+MINOR_NO	= 3
+PORT_CFORTRAN	= 
+NEED_FORTC	= 
+FORTC		= 
+
+# possible values are limits.h, float.h, stddef.h, stdlib.h,
+# string.h time.h signal.h unistd.h
+PORT_HEADERS	= 
+PORT_SUBDIRS    =
+LIBOBJS		= uddummy.o 
+
diff -urN HDF4.1r5/config/mh-darwin~ hdf-new/config/mh-darwin~
--- HDF4.1r5/config/mh-darwin~	Wed Dec 31 19:00:00 1969
+++ hdf-new/config/mh-darwin~	Mon Dec  8 19:43:58 2003
@@ -0,0 +1,180 @@
+# $Id: hdf-4.1r4-2.patch,v 1.1 2001/09/19 14:46:18 jswhit Exp $
+
+# You can override the following variables here
+#
+# Sections in Host makefile fragments
+# ----------------------------------:
+# 1. General Macros for HDF
+# 2. Macros for Pablo Instrumentation
+# 3. Macros for File Cache
+# 4. General macros for NETCDF
+# 4.1 XDR Macros for NETCDF
+# 4.2 libsrc Macros for NETCDF
+# 4.3 Port Macros for NETCDF
+#
+
+# ------------ General Macros for HDF --------------------
+# Version of the library
+PACKAGE	 = HDF
+VERSION  = 4.0
+#
+# Compiliers:
+# For gcc version
+CC=cc
+CFLAGS=-ansi -D_BSD_SOURCE -O -no-cpp-precomp
+
+# Fortran compilier
+#FC = f77
+FC = fort77
+#FC = g77
+FFLAGS = -O -Nx800
+
+# Name of achive randomizer, usually ranlib (use 'true' if non-existant)
+RANLIB = ranlib
+
+# Name of library archiver and flags to send, default 'AR=ar', 'ARFLAGS=r'
+AR = ar
+ARFLAGS = r
+
+# Name of remove utility, default 'RM=/bin/rm', 'RMFLAGS=-f'
+RM = /bin/rm
+RMFLAGS = -f
+
+# Extra libraries to be include like '-lm' for fabs()
+# e.g with naitve HP-ANSI compilier
+#LIBSX = -lm
+
+# ------------ Macros for Pablo Instrumentation  --------------------
+# Uncomment the following lines to create a Pablo Instrumentation
+# version of the HDF core library called 'libdf-inst.a'
+# See the documentation in the directory 'hdf/pablo' for further 
+# information about Pablo and what platforms it is supported on
+# before enabling. 
+# You need to set 'PABLO_INCDIR' to the Pablo distribution 
+# include directory to get to files 'IOTrace.h', 'IOTrace_SD.h' and others.
+
+#PABLO_FLAGS  = -DHAVE_PABLO
+#PABLO_INCDIR = /usr/local/include/pablo-5.1
+#PABLO_INCLUDE = -I$(PABLO_INCDIR)
+
+# ------------ Macros for File Cache(fmpool) ------
+# Uncomment the following lines to enable shared memory file buffer pool
+# version of the HDF core library libdf.a. Please read the
+# documentation before enabling this feature.
+
+#FMPOOL_FLAGS  = -DHAVE_FMPOOL
+
+# ------------ General Macros for NETCDF --------------------
+# Operating system, Used in fortran directory to generate fortran
+# wrappers. Possible values are osf, aix, hpux, irix, sunos, ultrix
+# unicos, convex, Linux, freebsd
+OS	= Linux
+
+CPP	      = $(CC) -E
+
+# for endianess, for little endian byte order need -DSWAP
+# for FreeBSD and Linux(anny x86 UNIX)
+#SWAP          = -DSWAP
+#SWAP          = 
+
+# for 32bit 'network long' integer, possible value -DNETLONG=int
+NETLONG       = 
+
+# additional CFLAGS
+CFLAGS_NETCDF = 
+
+# Additional flags for preproccesor. Some no longer used because
+#   library now requires ANSI compilier.
+#
+# for no function prototypes add -DNO_HAVE_PROTOTYPES
+# for no strerror()          add -DNO_STRERROR
+# for no variadic function support add -DNO_STDARG
+#
+# They all require -DHDF and -DNDEBUG 
+# Any special preprocessor requirements go here
+#
+# for Unicos 
+# CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -DBIG_SHORTS -DBIG_LONGS
+#
+# for OSF(dec alpha) 
+# CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -DBIG_LONGS -std1
+#
+# for IRIX6(64-bit) 
+# CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -DBIG_LONGS
+#
+# for AIX
+# CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -D_ALL_SOURCE
+#
+# for Sunos and Linux
+#CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF -DNO_STRERROR
+#
+# for IRIX6.0 (32-bit mode). If you prefer other 32 bit option like -n32, 
+#  replace '-32' below
+# CPPFLAGS_HDF  = -32 $(FMPOOL_FLAGS) -DNDEBUG -DHDF
+#
+# normal
+CPPFLAGS_HDF  = $(FMPOOL_FLAGS) -DNDEBUG -DHDF
+
+#
+# Unix commands/utilities
+#
+# neqn(1)
+NEQN	= neqn
+# tbl(1)
+TBL	= tbl
+# which(1)
+WHICH	= which
+# lex(1)
+#LEX	= lex    # GNU flex?
+LEX	= flex    # GNU flex?
+# yacc(1)
+YACC	= yacc   # GNU bison?
+
+#diff(1)
+DIFF    = diff   # GNU diff?
+DIFF_FLAGS = -w
+
+# Other Macros
+NCDUMP	= 
+NCGEN	= 
+FTPDIR	= 
+VERSION_NETCDF	= 2.3.2
+
+# ------------ XDR Macros for NETCDF --------------------
+# This is where the location of system XDR library includes
+# and location of the library are set
+#
+# Location of <xdr.h> if you are using the system
+# one, Else you need to comment it out
+CPP_XDR		= -I/usr/include/rpc
+
+# If XDR library not present on the system then you need
+# uncomment the following and comment the one below it
+#XDR_LIBOBJS    = xdr.o xdrfloat.o xdrstdio.o xdrarray.o
+XDR_LIBOBJS     =
+
+# Location of library, sometimes the sunos requires -lsun
+LD_XDR		= 
+
+#
+XDR_INSTALL_DEPS =
+
+# ------------ libsrc Macros for NETCDF --------------------
+# Possible values are xdrposix and xdrstdio
+# This sets which version of the XDR interface to use.
+XDRFILE		= xdrposix
+
+# ------------ Port Macros for NETCDF --------------------
+# Major and Minor numbe of NETCDF library version
+MAJOR_NO	= 2
+MINOR_NO	= 3
+PORT_CFORTRAN	= 
+NEED_FORTC	= 
+FORTC		= 
+
+# possible values are limits.h, float.h, stddef.h, stdlib.h,
+# string.h time.h signal.h unistd.h
+PORT_HEADERS	= 
+PORT_SUBDIRS    =
+LIBOBJS		= uddummy.o 
+
diff -urN HDF4.1r5/configure.in hdf-new/configure.in
--- HDF4.1r5/configure.in	Wed Jun 27 15:11:07 2001
+++ hdf-new/configure.in	Mon Dec  8 19:43:58 2003
@@ -94,6 +94,7 @@
   *-cray-unicos*)         host_makefile_frag=config/mh-unicos ;;
   t3*-cray-craympp)       host_makefile_frag=config/mh-t3e ;;
   S370-fujitsu-sysv*)     host_makefile_frag=config/mh-fujivp ;;
+  *-apple-darwin*)	  host_makefile_frag=config/mh-darwin ;;
   *-mac-*)                host_makefile_frag=config/mh-mac ;;
 esac
 fi
@@ -169,6 +170,7 @@
   *-cray-unicos*)         files="mfhdf/libsrc/config/netcdf-unicos.h mfhdf/fortran/config/jackets-unicos.c mfhdf/fortran/config/netcdf-unicos.inc mfhdf/fortran/config/ftest-unicos.f" ;;
   t3*-cray-craympp)       files="mfhdf/libsrc/config/netcdf-t3e.h mfhdf/fortran/config/jackets-t3e.c mfhdf/fortran/config/netcdf-t3e.inc mfhdf/fortran/config/ftest-t3e.f" ;;
   S370-fujitsu-sysv*)     files="mfhdf/libsrc/config/netcdf-fujivp.h mfhdf/fortran/config/jackets-fujivp.c mfhdf/fortran/config/netcdf-fujivp.inc mfhdf/fortran/config/ftest-fujivp.f" ;;
+  *-apple-darwin*)	  files="mfhdf/libsrc/config/netcdf-darwin.h mfhdf/fortran/config/jackets-darwin.c mfhdf/fortran/config/netcdf-darwin.inc mfhdf/fortran/config/ftest-darwin.f" ;;
   *-mac-*)		          files="mfhdf/libsrc/config/netcdf-mac.h mfhdf/fortran/config/jackets-mac.c mfhdf/fortran/config/netcdf-mac.inc mfhdf/fortran/config/ftest-mac.f" ;;
 esac
 fi
diff -urN HDF4.1r5/configure.in.orig hdf-new/configure.in.orig
--- HDF4.1r5/configure.in.orig	Wed Dec 31 19:00:00 1969
+++ hdf-new/configure.in.orig	Wed Jun 27 15:11:07 2001
@@ -0,0 +1,203 @@
+##############################################################################
+## This file was taken from the Cygnus Toolkit distribution and used as
+## as a template.
+
+## This file is a Bourne shell script fragment that supplies the information
+## necessary to tailor a template configure script into the configure
+## script appropriate for this directory.  For more information, check
+## any existing configure script.  
+
+## Be warned, there are two types of configure.in files.  There are those
+## used by Autoconf, which are macros which are expanded into a configure
+## script by autoconf.  The other sort, of which this is one, is executed
+## by Cygnus configure.  
+
+## For more information on these two systems, check out the documentation
+## for 'Autoconf' (autoconf.texi) and 'Configure' (configure.texi) or
+## the official documentation on these packages.  
+
+##############################################################################
+
+# Right now the JPEG has still needs a seperate makefile fragmenet
+# So we run configure here i.e we use configure.in and config/ 
+# directory found in the hdf/jpeg to build the configuration.
+host_libs="hdf/jpeg"
+
+# The followin features Not yet implemented
+#echo "without options are $withoutoptions"
+# without options for packages e.g 'jpeg'
+for wooption in $withoutoptions ; do
+if [ "$wooption" = "--without-jpeg" ] ; then 
+   host_libs=""
+fi
+done
+
+# Add file cache directory as a directory to run configure in also
+# since this is a self contained package that was setup 
+# using Cygnus configuration software.
+host_libs="$host_libs hdf/fmpool"
+
+# Not yet implemented
+#echo "enabled options are $enableoptions"
+# enabled options 'fmpool', 'pablo'
+#for eoption in $enableoptions ; do
+#if [ "$eoption" = "--enable-pablo" ] ; then 
+#   host_libs="$host_libs hdf/pablo"
+#fi
+#if [ "$eoption" = "--enable-fmpool" ] ; then 
+#   host_libs="$host_libs hdf/fmpool"
+#fi
+#done
+#echo "host libs are $host_libs"
+
+## We assign ${configdirs} this way to remove all embedded newlines.  This
+## is important because configure will choke if they ever get through.
+#
+configdirs=`echo ${host_libs}`
+
+#
+#Directories we want configure to generate Makefiles from Makefile.in
+#
+subdirs="hdf man hdf/src hdf/zlib hdf/test hdf/util hdf/pablo mfhdf mfhdf/xdr mfhdf/port mfhdf/libsrc mfhdf/dumper mfhdf/nctest mfhdf/ncgen mfhdf/ncdump mfhdf/fortran mfhdf/doc mfhdf/pablo"
+
+################################################################################
+
+srctrigger=move-if-change
+srcname="HDF/netCDF library"
+
+# This gets set non-empty for some net releases of packages.
+appdirs=""
+
+# per-host:
+
+# Work in distributions for each host makefile fragment
+host_makefile_frag=""
+if [ -d ${srcdir}/config ]; then
+case "${host}" in
+  alpha-*-*)         	  host_makefile_frag=config/mh-alpha ;;
+  mips*-dec-ultrix*)      host_makefile_frag=config/mh-decstation ;;
+  mips*-sgi-irix6.*)      host_makefile_frag=config/mh-irix6 ;;
+  mips*-sgi-irix6_32*)    host_makefile_frag=config/mh-irix32 ;;
+  mips*-sgi-irix5*)       host_makefile_frag=config/mh-irix5 ;;
+  mips*-sgi-irix4*)       host_makefile_frag=config/mh-irix4 ;;
+  i[3456]86-*-linux*)     host_makefile_frag=config/mh-linux ;;
+  i[3456]86-*-freebsd*)   host_makefile_frag=config/mh-fbsd ;;
+  ia64-*-*)               host_makefile_frag=config/mh-ia64 ;;
+  *-ibm-aix*)             host_makefile_frag=config/mh-aix ;;
+  i386-*-solaris2*)       host_makefile_frag=config/mh-solarisx86 ;;
+  sparc64-*-solaris2*)    host_makefile_frag=config/mh-solaris64 ;;
+  *-*-solaris2*)          host_makefile_frag=config/mh-solaris ;;
+  *-sun-*)                host_makefile_frag=config/mh-sun ;;
+  *-hp-hpux11*)           host_makefile_frag=config/mh-hpux11 ;;
+  *-hp-hpux*)             host_makefile_frag=config/mh-hpux ;;
+  *-convex-bsd*)          host_makefile_frag=config/mh-convex ;;
+  *-cray-unicos*)         host_makefile_frag=config/mh-unicos ;;
+  t3*-cray-craympp)       host_makefile_frag=config/mh-t3e ;;
+  S370-fujitsu-sysv*)     host_makefile_frag=config/mh-fujivp ;;
+  *-mac-*)                host_makefile_frag=config/mh-mac ;;
+esac
+fi
+
+# Check for valid platfroms before we continue
+if [ "${host_makefile_frag}" = "" ] ; then
+    echo '***' "The HDF/netCDF library is not supported on host ${host}" 1>&2
+    exit 1
+fi
+
+# make sure makefile fragment is there
+if [ ! -f ${srcdir}/${host_makefile_frag} ]; then
+    echo '***' "We are missing makefile fragment ${host_makefile_frag}" 1>&2
+    echo '***' "Please read the installation docs" 1>&2
+    exit 1
+fi
+
+
+# The Solaris /usr/ucb/cc compiler does not appear to work.
+case "${host}" in
+  sparc*-sun-solaris2*)
+      if [ "`/usr/bin/which ${CC-cc}`" = "/usr/ucb/cc" ] ; then
+          could_use=
+          [ -d /opt/SUNWspro/bin ] && could_use="/opt/SUNWspro/bin"
+          if [ -d /opt/cygnus/bin ] ; then
+              if [ "$could_use" == "" ] ; then
+                  could_use="/opt/cygnus/bin"
+              else
+                  could_use="$could_use or /opt/cygnus/bin"
+              fi
+          fi
+        if [ "$could_use" = "" ] ; then
+            echo "Warning: compilation may fail because you're using"
+            echo "/usr/ucb/cc.  You should change your PATH or CC "
+            echo "variable and rerun configure."
+        else
+            echo "Warning: compilation may fail because you're using"
+            echo "/usr/ucb/cc, when you should use the C compiler from"
+            echo "$could_use.  You should change your"
+            echo "PATH or CC variable and rerun configure."
+        fi
+      fi
+  ;;
+esac
+
+# per-target:
+
+# 
+# Set proper files that need to linked to the correct pre-generated
+# configuration files. These are mainly on the MFHDF side as 
+# the HDF side stuff is taken care of in the configure.in found
+# in two directories hdf/fmpool and hdf/jpeg respectively.
+files=
+links="mfhdf/libsrc/netcdf.h mfhdf/fortran/jackets.c mfhdf/fortran/netcdf.inc mfhdf/fortran/ftest.f"
+if [ -d ${srcdir}/config ]; then
+case "${host}" in
+  alpha-*-*)              files="mfhdf/libsrc/config/netcdf-alpha.h mfhdf/fortran/config/jackets-alpha.c mfhdf/fortran/config/netcdf-alpha.inc mfhdf/fortran/config/ftest-alpha.f" ;;
+  mips*-dec-ultrix*)      files="mfhdf/libsrc/config/netcdf-dec.h mfhdf/fortran/config/jackets-dec.c mfhdf/fortran/config/netcdf-dec.inc mfhdf/fortran/config/ftest-dec.f" ;;
+  mips*-sgi-irix6.*)      files="mfhdf/libsrc/config/netcdf-irix6.h mfhdf/fortran/config/jackets-irix6.c mfhdf/fortran/config/netcdf-irix6.inc mfhdf/fortran/config/ftest-irix6.f" ;;
+  mips*-sgi-irix6_32*)    files="mfhdf/libsrc/config/netcdf-irix32.h mfhdf/fortran/config/jackets-irix32.c mfhdf/fortran/config/netcdf-irix32.inc mfhdf/fortran/config/ftest-irix32.f" ;;
+  mips*-sgi-irix5*)       files="mfhdf/libsrc/config/netcdf-irix5.h mfhdf/fortran/config/jackets-irix5.c mfhdf/fortran/config/netcdf-irix5.inc mfhdf/fortran/config/ftest-irix5.f" ;;
+  mips*-sgi-irix4*)       files="mfhdf/libsrc/config/netcdf-irix4.h mfhdf/fortran/config/jackets-irix4.c mfhdf/fortran/config/netcdf-irix4.inc mfhdf/fortran/config/ftest-irix4.f" ;;
+  i[3456]86-*-linux*)     files="mfhdf/libsrc/config/netcdf-linux.h mfhdf/fortran/config/jackets-linux.c mfhdf/fortran/config/netcdf-linux.inc mfhdf/fortran/config/ftest-linux.f" ;;
+  i[3456]86-*-freebsd*)   files="mfhdf/libsrc/config/netcdf-fbsd.h mfhdf/fortran/config/jackets-fbsd.c mfhdf/fortran/config/netcdf-fbsd.inc mfhdf/fortran/config/ftest-fbsd.f" ;;
+  ia64-*-*)               files="mfhdf/libsrc/config/netcdf-ia64.h mfhdf/fortran/config/jackets-ia64.c mfhdf/fortran/config/netcdf-ia64.inc mfhdf/fortran/config/ftest-ia64.f" ;;
+  *-ibm-aix*)             files="mfhdf/libsrc/config/netcdf-aix.h mfhdf/fortran/config/jackets-aix.c mfhdf/fortran/config/netcdf-aix.inc mfhdf/fortran/config/ftest-aix.f" ;;
+  i386-*-solaris2*)       files="mfhdf/libsrc/config/netcdf-solarisx86.h mfhdf/fortran/config/jackets-solarisx86.c mfhdf/fortran/config/netcdf-solarisx86.inc mfhdf/fortran/config/ftest-solarisx86.f" ;;
+  sparc64-*-solaris2*)          files="mfhdf/libsrc/config/netcdf-solaris64.h mfhdf/fortran/config/jackets-solaris64.c mfhdf/fortran/config/netcdf-solaris64.inc mfhdf/fortran/config/ftest-solaris64.f";;
+  *-*-solaris2*)          files="mfhdf/libsrc/config/netcdf-solaris.h mfhdf/fortran/config/jackets-solaris.c mfhdf/fortran/config/netcdf-solaris.inc mfhdf/fortran/config/ftest-solaris.f";;
+  *-sun-*)		          files="mfhdf/libsrc/config/netcdf-sun.h mfhdf/fortran/config/jackets-sun.c mfhdf/fortran/config/netcdf-sun.inc mfhdf/fortran/config/ftest-sun.f";;
+  *-hp-hpux*)             files="mfhdf/libsrc/config/netcdf-hpux.h mfhdf/fortran/config/jackets-hpux.c mfhdf/fortran/config/netcdf-hpux.inc mfhdf/fortran/config/ftest-hpux.f";;
+  *-convex-bsd*)          files="mfhdf/libsrc/config/netcdf-convex.h mfhdf/fortran/config/jackets-convex.c mfhdf/fortran/config/netcdf-convex.inc mfhdf/fortran/config/ftest-convex.f" ;;
+  *-cray-unicos*)         files="mfhdf/libsrc/config/netcdf-unicos.h mfhdf/fortran/config/jackets-unicos.c mfhdf/fortran/config/netcdf-unicos.inc mfhdf/fortran/config/ftest-unicos.f" ;;
+  t3*-cray-craympp)       files="mfhdf/libsrc/config/netcdf-t3e.h mfhdf/fortran/config/jackets-t3e.c mfhdf/fortran/config/netcdf-t3e.inc mfhdf/fortran/config/ftest-t3e.f" ;;
+  S370-fujitsu-sysv*)     files="mfhdf/libsrc/config/netcdf-fujivp.h mfhdf/fortran/config/jackets-fujivp.c mfhdf/fortran/config/netcdf-fujivp.inc mfhdf/fortran/config/ftest-fujivp.f" ;;
+  *-mac-*)		          files="mfhdf/libsrc/config/netcdf-mac.h mfhdf/fortran/config/jackets-mac.c mfhdf/fortran/config/netcdf-mac.inc mfhdf/fortran/config/ftest-mac.f" ;;
+esac
+fi
+
+# make sure host specific files are there
+#if [ ! -f ${srcdir}/${files} ]; then
+#    echo '***' "We are missing host specific customize file ${files}" 1>&2
+#    echo '***' "Please read the installation docs" 1>&2
+#    exit 1
+#fi
+
+# Decided to copy files instead of using symbolic links.
+#
+# Now for Mac and PC configurations we want to copy and not use symbolic
+# links. You can use this also for any platfrom you want.
+if [ -d ${srcdir}/config ]; then
+case "${host}" in
+  *-mac-*)             symbolic_link="cp -p" ;;
+  *-win-*)             symbolic_link="cp -p" ;;
+  *)                   symbolic_link="cp" ;;
+esac
+fi
+
+# post-target:
+
+# We don't have anything
+
+#
+# Local Variables:
+# fill-column: 131
+# End:
+#
diff -urN HDF4.1r5/hdf/fmpool/config/fmpdarwin.h hdf-new/hdf/fmpool/config/fmpdarwin.h
--- HDF4.1r5/hdf/fmpool/config/fmpdarwin.h	Wed Dec 31 19:00:00 1969
+++ hdf-new/hdf/fmpool/config/fmpdarwin.h	Mon Dec  8 19:43:58 2003
@@ -0,0 +1,44 @@
+/****************************************************************************
+ * NCSA HDF                                                                 *
+ * Software Development Group                                               *
+ * National Center for Supercomputing Applications                          *
+ * University of Illinois at Urbana-Champaign                               *
+ * 605 E. Springfield, Champaign IL 61820                                   *
+ *                                                                          *
+ * For conditions of distribution and use, see the accompanying             *
+ * hdf/COPYING file.                                                        *
+ *                                                                          *
+ ****************************************************************************/
+
+/*****************************************************************************
+ * File: fmpsun.h
+ *
+ *****************************************************************************/ 
+
+/* $Id: hdf-4.1r4-2.patch,v 1.1 2001/09/19 14:46:18 jswhit Exp $ */
+
+#ifndef _FMPCONF_H
+#define _FMPCONF_H
+
+#define HAVE_PROTOTYPES
+#define HAVE_UCHAR
+#define HAVE_UINT
+#define HAVE_ULONG
+#define HAVE_USHORT
+#define HAVE_SIZE_T
+#define HAVE_SSIZE_T
+#define HAVE_SIGSET_T
+#define HAVE_LIMITS_H
+#define HAVE_UNISTD_H
+#define HAVE_STDLIB
+#define HAVE_STDIO_H
+#define HAVE_FCNTL
+#define HAVE_STAT
+#define HAVE_MIN_MAX
+#define HAVE_CDEFS_H
+
+#endif /* _FMPCONF_H */
+
+
+
+
diff -urN HDF4.1r5/hdf/fmpool/config/mh-darwin hdf-new/hdf/fmpool/config/mh-darwin
--- HDF4.1r5/hdf/fmpool/config/mh-darwin	Wed Dec 31 19:00:00 1969
+++ hdf-new/hdf/fmpool/config/mh-darwin	Mon Dec  8 19:43:58 2003
@@ -0,0 +1,40 @@
+# This makefile fragemnt will override the default options found at the top
+# of the 'Makefile' in the source directory. See 'Makefile.in'
+# for discussion of the various options.
+#
+
+# Gnu GCC
+CC=cc
+CFLAGS= -O -ansi -no-cpp-precomp
+
+# -DPURIFY     -> when using purify
+# -DSTATISTICS -> when you want statistics
+# -DMPOOL_DEBUG -> debugging fmpool_xxx interface
+# -DMP_DEBUG    -> debugging MPxxx interface
+# 
+#AUXFLAGS= -DPURIFY -DSTATISTICS -DMPOOL_DEBUG -DMP_DEBUG -DDEBUG
+#AUXFLAGS= -DPURIFY -DSTATISTICS -DMPOOL_DEBUG -DMP_DEBUG -DCIRCLEQ_DEBUG
+#AUXFLAGS= -DPURIFY -DSTATISTICS -DMP_DEBUG -DDEBUG
+#AUXFLAGS= -DPURIFY -DSTATISTICS -DSTAT_DEBUG
+#AUXFLAGS= -DHAVE_GETRUSAGE -DSTATISTICS
+#AUXFLAGS= -DDEBUG
+#AUXFLAGS= 
+
+LDFLAGS= 
+LDLIBS= 
+
+# Name of achive randomizer, usually ranlib (use 'true' if non-existant)
+RANLIB = ranlib
+
+# Name of library archiver and flags to send, default 'AR=ar', 'ARFLAGS=r'
+AR = ar
+ARFLAGS = r
+
+# Name of remove utility, default 'RM=/bin/rm', 'RMFLAGS=-f'
+RM = /bin/rm
+RMFLAGS = -f
+
+# Move command
+MV= mv
+
+
diff -urN HDF4.1r5/hdf/fmpool/configure.in hdf-new/hdf/fmpool/configure.in
--- HDF4.1r5/hdf/fmpool/configure.in	Tue May 23 14:03:23 2000
+++ hdf-new/hdf/fmpool/configure.in	Mon Dec  8 19:43:58 2003
@@ -49,6 +49,7 @@
   *-cray-unicos*)         host_makefile_frag=config/mh-unicos ;;
   t3*-cray-craympp)       host_makefile_frag=config/mh-t3e ;;
   S370*)                  host_makefile_frag=config/mh-fujivp ;;
+  *-apple-darwin*)	  host_makefile_frag=config/mh-darwin ;;
   *-mac-*)		          host_makefile_frag=config/mh-mac ;;
 esac
 fi
@@ -120,6 +121,7 @@
   *-cray-unicos*)         files=config/fmpunicos.h ;;
   t3*-cray-craympp)       files=config/fmpt3e.h ;;
   S370*)                  files=config/fmpfujivp.h ;;
+  *-apple-darwin*)	  files=config/fmpdarwin.h ;;
   *-mac-*)		          files=config/fmpmac.h ;;
 esac
 fi
diff -urN HDF4.1r5/hdf/jpeg/config/jdarwin.h hdf-new/hdf/jpeg/config/jdarwin.h
--- HDF4.1r5/hdf/jpeg/config/jdarwin.h	Wed Dec 31 19:00:00 1969
+++ hdf-new/hdf/jpeg/config/jdarwin.h	Mon Dec  8 19:43:58 2003
@@ -0,0 +1,45 @@
+/* jconfig.h.  Generated automatically by configure.  */
+/* jconfig.cfg --- source file edited by configure script */
+/* see jconfig.doc for explanations */
+
+#define HAVE_PROTOTYPES 
+#define HAVE_UNSIGNED_CHAR 
+#define HAVE_UNSIGNED_SHORT 
+#undef void
+#undef const
+#undef CHAR_IS_UNSIGNED
+#define HAVE_STDDEF_H 
+#define HAVE_STDLIB_H 
+#undef NEED_BSD_STRINGS
+#undef NEED_SYS_TYPES_H
+#undef NEED_FAR_POINTERS
+#undef NEED_SHORT_EXTERNAL_NAMES
+/* Define this if you get warnings about undefined structures. */
+#undef INCOMPLETE_TYPES_BROKEN
+
+#ifdef JPEG_INTERNALS
+
+#undef RIGHT_SHIFT_IS_UNSIGNED
+#undef INLINE
+/* These are for configuring the JPEG memory manager. */
+#undef DEFAULT_MAX_MEM
+#undef NO_MKTEMP
+
+#endif /* JPEG_INTERNALS */
+
+#ifdef JPEG_CJPEG_DJPEG
+
+#define BMP_SUPPORTED		/* BMP image file format */
+#define GIF_SUPPORTED		/* GIF image file format */
+#define PPM_SUPPORTED		/* PBMPLUS PPM/PGM image file format */
+#undef RLE_SUPPORTED		/* Utah RLE image file format */
+#define TARGA_SUPPORTED		/* Targa image file format */
+
+#undef TWO_FILE_COMMANDLINE
+#undef NEED_SIGNAL_CATCHER
+#undef DONT_USE_B_MODE
+
+/* Define this if you want percent-done progress reports from cjpeg/djpeg. */
+#undef PROGRESS_REPORT
+
+#endif /* JPEG_CJPEG_DJPEG */
diff -urN HDF4.1r5/hdf/jpeg/config/mh-darwin hdf-new/hdf/jpeg/config/mh-darwin
--- HDF4.1r5/hdf/jpeg/config/mh-darwin	Wed Dec 31 19:00:00 1969
+++ hdf-new/hdf/jpeg/config/mh-darwin	Mon Dec  8 19:43:58 2003
@@ -0,0 +1,41 @@
+# This makefile fragemnt will override the default options found at the top
+# of the 'Makefile' in the jpeg source directory. See 'Makefile.in'
+# for discussion of the various options.
+#
+
+ANSI2KNRFLAGS= 
+LDFLAGS= 
+LDLIBS= 
+SYSDEPMEM= jmemnobs.o
+RM = /bin/rm 
+RMFLAGS = -f
+MV= mv
+AR = ar
+ARFLAGS = rc
+
+# The following segment should not really be the fragments but I 
+# couldn't find a way to avoid this.-GV
+#
+# Uncomment the following line if you don't have an ANSI compilier
+# and comment out the one below it
+#all: @ANSI2KNR@ libjpeg.a cjpeg djpeg rdjpgcom wrjpgcom
+all: libjpeg.a cjpeg djpeg rdjpgcom wrjpgcom
+
+# Uncomment the following rule if you don't have an ANSI compilier
+# This rule causes ansi2knr to be invoked.
+# .c.o:
+# 	./ansi2knr $(srcdir)/$*.c T$*.c
+# 	$(CC) $(CFLAGS) -c T$*.c
+# 	$(RM) $(RMFLAGS) T$*.c $*.o
+# 	$(MV) T$*.o $*.o
+
+ansi2knr: ansi2knr.c
+	$(CC) $(CFLAGS) $(ANSI2KNRFLAGS) -o ansi2knr ansi2knr.c
+
+# Uncomment the following line if you don't have an ANSI compilier
+# and comment out the one below it
+#libjpeg.a: @ANSI2KNR@ $(LIBOBJECTS)
+libjpeg.a: $(LIBOBJECTS)
+	$(RM) $(RMFLAGS) libjpeg.a
+	$(AR) $(ARFLAGS) libjpeg.a  $(LIBOBJECTS)
+	$(AR2) libjpeg.a
diff -urN HDF4.1r5/hdf/jpeg/configure.in hdf-new/hdf/jpeg/configure.in
--- HDF4.1r5/hdf/jpeg/configure.in	Tue May 23 14:03:26 2000
+++ hdf-new/hdf/jpeg/configure.in	Mon Dec  8 19:43:58 2003
@@ -49,6 +49,7 @@
   *-cray-unicos*)         host_makefile_frag=config/mh-unicos ;;
   t3*-cray-craympp)       host_makefile_frag=config/mh-t3e ;;
   S370*)                  host_makefile_frag=config/mh-fujivp ;;
+  *-apple-darwin*)	  host_makefile_frag=config/mh-darwin ;;
   *-mac-*)		          host_makefile_frag=config/mh-mac ;;
 esac
 fi
@@ -120,6 +121,7 @@
   *-cray-unicos*)         files=config/junicos.h ;;
   t3*-cray-craympp)       files=config/jt3e.h ;;
   S370*)                  files=config/jfujivp.h ;;
+  *-apple-darwin*)	  files=config/jdarwin.h ;;
   *-mac-*)	              files=config/jmac.h ;;
 esac
 fi
diff -urN HDF4.1r5/hdf/src/hdfi.h hdf-new/hdf/src/hdfi.h
--- HDF4.1r5/hdf/src/hdfi.h	Thu Sep 20 17:37:31 2001
+++ hdf-new/hdf/src/hdfi.h	Mon Dec  8 19:43:58 2003
@@ -958,7 +958,7 @@
 #endif /* INTEL86 */
 #endif /* !(defined(macintosh) || defined(MAC)) */
 
-#if defined(NEXT) || defined(NeXT)
+#if defined(NEXT) || defined(NeXT) || defined(__APPLE__)
 
 #ifndef NEXT
 #define NEXT
diff -urN HDF4.1r5/hdf/src/hdfi.h.orig hdf-new/hdf/src/hdfi.h.orig
--- HDF4.1r5/hdf/src/hdfi.h.orig	Wed Dec 31 19:00:00 1969
+++ hdf-new/hdf/src/hdfi.h.orig	Thu Sep 20 17:37:31 2001
@@ -0,0 +1,1473 @@
+/****************************************************************************
+ * NCSA HDF                                                                 *
+ * Software Development Group                                               *
+ * National Center for Supercomputing Applications                          *
+ * University of Illinois at Urbana-Champaign                               *
+ * 605 E. Springfield, Champaign IL 61820                                   *
+ *                                                                          *
+ * For conditions of distribution and use, see the accompanying             *
+ * hdf/COPYING file.                                                        *
+ *                                                                          *
+ ****************************************************************************/
+
+/* $Id: hdfi.h,v 1.148 2001/09/20 21:37:31 ymuqun Exp $ */
+
+#ifndef HDFI_H
+#define HDFI_H
+
+#ifdef GOT_MACHINE
+#undef GOT_MACHINE
+#endif
+
+/*--------------------------------------------------------------------------*/
+/*                              MT/NT constants                             */
+/*  Four MT nibbles represent double, float, int, uchar (from most          */
+/*      significant to least significant).                                  */
+/*  Each "column" in the "table" below is essentially independant of the    */
+/*      other "columns", for example the CONVEXNATIVE entry means that the  */
+/*      floating point formats are in Convex native format but the integers */
+/*      are big-endian and standard sizes                                   */
+/*  If you add another value to this "table", you need to add another       */
+/*      DFNTF_xxx entry in hntdefs.h                                        */
+/*  The values for each nibble are:                                         */
+/*      1 - Big Endian                                                      */
+/*          (i.e. Big-Endian, 32-bit architecture w/IEEE Floats)            */
+/*      2 - VAX                                                             */
+/*          (i.e. Middle-Endian, 32-bit architecture w/VAX Floats)          */
+/*      3 - Cray                                                            */
+/*          (i.e. Big-Endian, all 64-bit architecture w/Cray Floats)        */
+/*      4 - Little Endian                                                   */
+/*          (i.e. Little-Endian, 32-bit architecture w/IEEE Floats)         */
+/*      5 - Convex                                                          */
+/*          (i.e. Big-Endian, 32-bit architecture w/Convex Native Floats)   */
+/*      6 - Fujitsu VP                                                      */
+/*          (i.e. Big-Endian, 32-bit architecture w/Fujitsu Native Floats)  */
+/*      7 - Cray MPP                                                        */
+/*          (i.e. Big-Endian, 32-bit architecture w/IEEE Floats, but no 16-bit type)            */
+/*      8 - Cray IEEE                                                       */
+/*          (i.e. Big-Endian, all 64-bit architecture w/IEEE Floats)        */
+/*--------------------------------------------------------------------------*/
+#define     DFMT_SUN            0x1111
+#define     DFMT_ALLIANT        0x1111
+#define     DFMT_IRIX           0x1111
+#define     DFMT_APOLLO         0x1111
+#define     DFMT_IBM6000        0x1111
+#define     DFMT_HP9000         0x1111
+#define     DFMT_CONVEXNATIVE   0x5511
+#define     DFMT_CONVEX         0x1111
+#define     DFMT_UNICOS         0x3331
+#define     DFMT_UNICOSIEEE     0x1831
+#define     DFMT_CTSS           0x3331
+#define     DFMT_VAX            0x2221
+#define     DFMT_MIPSEL         0x4441
+#define     DFMT_PC             0x4441
+#define     DFMT_MAC            0x1111
+#define     DFMT_SUN386         0x4441
+#define     DFMT_NEXT           0x1111
+#define     DFMT_MOTOROLA       0x1111
+#define     DFMT_ALPHA          0x4441
+#define     DFMT_VP             0x6611
+#define     DFMT_I860           0x4441
+#define     DFMT_CRAYMPP        0x1171
+#define     DFMT_IA64           0x4441
+
+/* I/O library constants */
+#define UNIXUNBUFIO 1
+#define UNIXBUFIO   2
+#define MACIO       3
+#define PCIO        4    /* 16-bit MS-DOS File I/O (deprecated) */
+#define WINIO       5    /* 16-bit Windows File I/O (deprecated) */
+#define PAGEBUFIO   6    /* page buffering - fmpool */
+#define WINNTIO     7    /* 32-bit Windows File I/O (deprecated, WinNT now uses UNIXBUFIO) */ 
+
+/* IBM RS6000 AIX hack */
+#if defined(IBM6000) || defined(_AIX)
+#define _POSIX_SOURCE
+#endif 
+
+/* Standard header files needed all the time */
+#include <stdio.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <string.h>
+
+/* PABLO support files */
+#ifdef HAVE_PABLO
+#define HDFIOTRACE
+#include "HDFIOTrace.h"
+#endif  /* HAVE_PABLO */
+
+/**
+ * Provide the macros to adapt the HDF public functions to
+ * dll entry points.
+ * In addition it provides error lines if the configuration is incorrect.
+ **/
+
+#ifdef WIN32
+/**
+ * Under WIN32 we have single threaded static libraries, or
+ * mutli-threaded DLLs using the multithreaded runtime DLLs.
+ **/
+#	if defined(_MT) &&	defined(_DLL) &&!defined(_HDFDLL_)
+/*		If the user really ment to use _HDFDLL_, but he forgot, just define it. */
+#		define _HDFDLL_
+#	endif
+
+#	if defined(_MT) && !defined(_HDFDLL_)
+#		error To use the HDF libraries from a multithreaded project, you must use the HDF DLLs
+#		error Use the Mutlithreaded DLL runtime libraries (prefered), or define the macro "_HDFDLL_"
+#	endif
+
+#	if !defined(_MT) && defined(_HDFDLL_)
+#		error To use the HDF libraries from a single-threaded project, you must use static HDF libraries
+#		error Undefine the macro "_HDFDLL_"
+#	endif
+
+#	if defined(_HDFDLL_)
+#		pragma warning( disable: 4273 )	/* Disable the stupid dll linkage warnings */
+
+#		if !defined(_HDFLIB_)
+#			define HDFPUBLIC __declspec(dllimport)
+#		else
+#			define HDFPUBLIC __declspec(dllexport)
+#		endif
+
+#		if !defined(_MFHDFLIB_) && !defined(_HDFLIB_)
+#			define HDFLIBAPI __declspec(dllimport) extern
+#		else
+#			define HDFLIBAPI __declspec(dllexport) extern
+#		endif 
+#	else
+#		define HDFPUBLIC
+#		define HDFLIBAPI extern
+#	endif
+#else	/* !defined( WIN32 ) */
+#	define HDFPUBLIC
+#	define HDFLIBAPI extern
+#endif
+
+
+/*-------------------------------------------------------------------------
+ * Define options for each platform
+ *-------------------------------------------------------------------------*/
+
+/*
+ * Meaning of each defined macros (not completed yet)
+ *
+ * BIG_LONGS--Define when long is not "equal" to int32.  True in cases
+ *      where (int32 *) is not compatible with (long *).  Should
+ *      be renamed as LONGNEINT32.
+ */
+
+#if (defined(SUN) || defined(sun) || defined(__sun__) || defined(__SUNPRO_C)) & !defined(__i386)
+#ifdef __STDC__
+#define ANSISUN
+#else /* __STDC__ */
+#define KNRSUN
+#endif /* __STDC__ */
+#endif /* SUN || sun */
+
+#if defined(ANSISUN)
+
+#if !defined(SUN)
+#define SUN
+#endif
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE
+
+#include <unistd.h>                 /* for some file I/O stuff */
+#include <sys/time.h>
+#include <sys/file.h>               /* for unbuffered i/o stuff */
+#include <sys/stat.h>
+#define DF_MT             DFMT_SUN
+typedef void              VOID;
+typedef void              *VOIDP;
+typedef char              *_fcd;
+typedef char              char8;
+typedef unsigned char     uchar8;
+typedef char              int8;
+typedef unsigned char     uint8;
+typedef short int         int16;
+typedef unsigned short int uint16;
+#ifdef _LP64 /* 64-bit environment */
+typedef int               int32;
+typedef unsigned int      uint32;
+#else /* 32-bit environment */
+typedef long int          int32;
+typedef unsigned long int uint32;
+#endif
+typedef int               intn;
+typedef unsigned int      uintn;
+typedef int               intf;     /* size of INTEGERs in Fortran compiler */
+typedef float             float32;
+typedef double            float64;
+#ifdef _LP64 /* 64-bit environment */
+typedef long              hdf_pint_t;   /* an integer the same size as a pointer */
+#else /* 32-bit environment */
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+#endif
+#define FNAME_POST_UNDERSCORE
+#define _fcdtocp(desc) (desc)
+#ifdef  HAVE_FMPOOL
+#define FILELIB PAGEBUFIO  /* enable page buffering */
+#else
+#define FILELIB UNIXBUFIO
+#endif
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+#define HAVE_STDC
+#define INCLUDES_ARE_ANSI
+
+#endif /* ANSISUN */
+
+#if defined(KNRSUN)
+
+#if !defined(SUN)
+#define SUN
+#endif
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE
+
+#   define BSD
+#define DUMBCC 	/* because it is.  for later use in macros */
+#ifndef __GNUC__
+#include <memory.h>
+#endif /* __GNUC__ */
+#include <unistd.h>
+#include <sys/file.h>               /* for unbuffered i/o stuff */
+#include <sys/stat.h>
+#define DF_MT             DFMT_SUN
+typedef void              VOID;
+typedef char              *VOIDP;
+typedef char              *_fcd;
+typedef char              char8;
+typedef unsigned char     uchar8;
+typedef char              int8;
+typedef unsigned char     uint8;
+typedef short int         int16;
+typedef unsigned short int uint16;
+typedef long int          int32;
+typedef unsigned long int uint32;
+typedef int               intn;
+typedef unsigned int      uintn;
+typedef int               intf;     /* size of INTEGERs in Fortran compiler */
+typedef float             float32;
+typedef double            float64;
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+#define FNAME_POST_UNDERSCORE
+#define _fcdtocp(desc) (desc)
+#ifdef  HAVE_FMPOOL
+#define FILELIB PAGEBUFIO  /* enable page buffering */
+#else
+#define FILELIB UNIXBUFIO
+#endif
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+
+#ifdef __GNUC__
+#define HAVE_STDC
+#define INCLUDES_ARE_ANSI
+#endif
+
+#endif /* SUN */
+
+
+#if defined(IBM6000) || defined(_AIX)
+
+#ifndef IBM6000
+#define IBM6000
+#endif
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE
+
+#   define BSD
+
+#ifndef __GNUC__
+#include <memory.h>
+#endif /* __GNUC__ */
+#include <sys/file.h>               /* for unbuffered i/o stuff */
+#include <sys/stat.h>
+#define DF_MT             DFMT_IBM6000
+typedef void              VOID;
+typedef void              *VOIDP;
+typedef char              *_fcd;
+#ifndef _ALL_SOURCE       
+typedef char              int8;
+typedef short int         int16; 
+typedef long int          int32; 
+#endif  
+typedef char              char8;
+typedef unsigned char     uchar8;
+typedef unsigned char     uint8;
+typedef unsigned short int uint16;
+typedef unsigned long int uint32;
+typedef int               intn;
+typedef unsigned int      uintn;
+typedef float             float32;
+typedef double            float64;
+typedef int               intf;     /* size of INTEGERs in Fortran compiler */
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+#define _fcdtocp(desc) (desc)
+#ifdef  HAVE_FMPOOL
+#define FILELIB PAGEBUFIO  /* enable page buffering */
+#else
+#define FILELIB UNIXBUFIO
+#endif
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+
+#define HAVE_STDC
+#define INCLUDES_ARE_ANSI
+
+#endif /* IBM6000 */
+
+#if defined(HP9000) || (!defined(__convexc__) && (defined(hpux) || defined(__hpux)))
+
+#ifndef HP9000
+#define HP9000
+#endif
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE
+
+#ifndef HAVE_UNISTD_H
+#define HAVE_UNISTD_H  /* unistd.h - close, fork,..etc */
+#endif
+
+#   define BSD
+#ifndef __GNUC__
+#include <memory.h>
+#endif /* __GNUC__ */
+#include <sys/file.h>               /* for unbuffered i/o stuff */
+#include <sys/stat.h>
+#define DF_MT             DFMT_HP9000
+typedef void              VOID;
+typedef void              *VOIDP;
+typedef char              *_fcd;
+typedef char              char8;
+typedef unsigned char     uchar8;
+typedef char              int8;
+typedef unsigned char     uint8;
+typedef short int         int16;
+typedef unsigned short int uint16;
+typedef long int          int32;
+typedef unsigned long int uint32;
+typedef int               intn;
+typedef unsigned int      uintn;
+typedef float             float32;
+typedef double            float64;
+typedef int               intf;     /* size of INTEGERs in Fortran compiler */
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+#define _fcdtocp(desc) (desc)
+#ifdef  HAVE_FMPOOL
+#define FILELIB PAGEBUFIO  /* enable page buffering */
+#else
+#define FILELIB UNIXBUFIO
+#endif
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+
+#endif /* HP9000 */
+
+
+#if defined(IRIX) || defined(IRIS4) || defined(sgi) || defined(__sgi__) || defined(__sgi)
+
+#ifndef IRIX
+#define IRIX
+#endif
+
+#if (_MIPS_SZLONG == 64)
+/* IRIX 64 bits objects.  It is nearly the same as the conventional
+ * 32 bits objects.  Let them share IRIX definitions for now.
+ */
+#define IRIX64
+#endif
+
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE 1
+
+/*
+ * BSD was originally defined with no value.  But some newer SGI system
+ * header files (e.g., resolv.h) assume it has a value and evaluate it
+ * in expressions, thus causing compiling errors.  This has been reported
+ * to SGI as bug #781568.  SGI could not provide a list of the semantics
+ * of BSD values and suggested a work around of setting BSD to 1.
+ */
+#   define BSD 1
+#ifndef __GNUC__
+#include <memory.h>
+#endif /* __GNUC__ */
+#include <sys/file.h>               /* for unbuffered i/o stuff */
+#include <sys/stat.h>
+#define DF_MT              DFMT_IRIX
+typedef void               VOID;
+typedef void               *VOIDP;
+typedef char               *_fcd;
+typedef signed char        char8;
+typedef unsigned char      uchar8;
+typedef signed char        int8;
+typedef unsigned char      uint8;
+typedef short int          int16;
+typedef unsigned short int uint16;
+typedef int                int32;
+typedef unsigned int       uint32;
+typedef int                intn;
+typedef unsigned int       uintn;
+typedef float              float32;
+typedef double             float64;
+typedef int                intf;     /* size of INTEGERs in Fortran compiler */
+typedef long               hdf_pint_t;   /* an integer the same size as a pointer */
+#define FNAME_POST_UNDERSCORE
+#define _fcdtocp(desc) (desc)
+#ifdef  HAVE_FMPOOL
+#define FILELIB PAGEBUFIO  /* enable page buffering */
+#else
+#define FILELIB UNIXBUFIO
+#endif
+#ifdef IRIX64
+#define BIG_LONGS
+#endif
+
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+
+#define HAVE_STDC
+#define INCLUDES_ARE_ANSI
+
+#endif /* IRIX */
+
+#if (defined(UNICOS) || defined(_UNICOS)) && !defined(_CRAYMPP)
+
+#ifndef UNICOS
+#define UNICOS
+#endif
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE 1
+
+#include <memory.h>
+#include <fortran.h>
+#ifndef O_RDONLY
+#include <fcntl.h>              /* for unbuffered i/o stuff */
+#define L_INCR  1
+#include <sys/stat.h>
+#endif /*O_RDONLY*/
+
+#ifdef _CRAYIEEE
+#define DF_MT   DFMT_UNICOSIEEE
+#else
+#define DF_MT   DFMT_UNICOS
+#endif
+typedef void            VOID;
+typedef void            *VOIDP;
+#ifdef OLD_WAY /* May need to be included on other machines than the C-90 */
+typedef char            *_fcd;
+#endif /* OLD_WAY */
+typedef signed char     char8;
+typedef unsigned char   uchar8;
+typedef signed char     int8;
+typedef unsigned char   uint8;
+typedef int             int16;
+typedef unsigned int    uint16;
+typedef int             int32;
+typedef unsigned int    uint32;
+typedef int             intn;
+typedef unsigned int    uintn;
+typedef float           float32;
+typedef double          float64;
+typedef int             intf;     /* size of INTEGERs in Fortran compiler */
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+
+#define DF_CAPFNAMES            /* fortran names are in all caps */
+#ifdef  HAVE_FMPOOL
+#define FILELIB PAGEBUFIO  /* enable page buffering */
+#else
+#define FILELIB UNIXBUFIO
+#endif
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+#define RIGHT_SHIFT_IS_UNSIGNED
+#define CHAR_IS_UNSIGNED
+
+#endif /* UNICOS */
+
+#if defined(_CRAYMPP)
+
+#ifndef CRAYMPP
+#define CRAYMPP
+#endif
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE 1
+
+#include <string.h>
+#include <limits.h>
+#include <memory.h>
+#include <fortran.h>
+#ifndef O_RDONLY
+#include <fcntl.h>              /* for unbuffered i/o stuff */
+#define L_INCR  1
+#include <sys/stat.h>
+#endif /*O_RDONLY*/
+
+#define DF_MT   DFMT_CRAYMPP
+typedef void            VOID;
+typedef void            *VOIDP;
+#ifdef OLD_WAY /* May need to be included on other machines than the C-90 */
+typedef char            *_fcd;
+#endif /* OLD_WAY */
+typedef signed char     char8;
+typedef unsigned char   uchar8;
+typedef signed char     int8;
+typedef unsigned char   uint8;
+typedef short           int16;
+typedef unsigned short  uint16;
+typedef short           int32;
+typedef unsigned short  uint32;
+typedef int             intn;
+typedef unsigned int    uintn;
+typedef float           float32;
+typedef double          float64;
+typedef int             intf;     /* size of INTEGERs in Fortran compiler */
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+
+#define _HUGE              /* This should only be defined to a value on the PC */
+#define DF_CAPFNAMES            /* fortran names are in all caps */
+#ifdef  HAVE_FMPOOL
+#define FILELIB PAGEBUFIO  /* enable page buffering */
+#else
+#define FILELIB UNIXBUFIO
+#endif
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+#define RIGHT_SHIFT_IS_UNSIGNED
+#define CHAR_IS_UNSIGNED
+
+#endif /* CRAYMPP */
+
+#if defined(VMS) || defined(vms)
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE 1
+#include <file.h>               /* for unbuffered i/o stuff */
+#include <sys/stat.h>
+#define DF_MT              DFMT_VAX
+typedef void               VOID;
+typedef void               *VOIDP;
+typedef char               *_fcd;
+typedef char               char8;
+typedef unsigned char      uchar8;
+typedef char               int8;
+typedef unsigned char      uint8;
+typedef short int          int16;
+typedef unsigned short int uint16;
+#ifdef __alpha
+typedef int                int32;
+typedef unsigned int       uint32;
+typedef long              hdf_pint_t;   /* an integer the same size as a pointer */
+#else
+typedef long int           int32;
+typedef unsigned long int  uint32;
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+#endif
+typedef int                intn;
+typedef unsigned int       uintn;
+typedef float              float32;
+typedef double             float64;
+typedef int                intf;     /* size of INTEGERs in Fortran compiler */
+#define _fcdtocp(desc)  ((char *) *((char **) &desc[4]))
+
+/* 
+  Redef a couple of C routine names to avoid conflicts
+  since the VMS link command is case-insensitive
+*/
+#define FILELIB UNIXBUFIO
+#define DF_CAPFNAMES            /* fortran names are in all caps */
+#include "dfivms.h"
+
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+
+#endif /* VMS */
+
+#if defined(CONVEX) || defined(CONVEXNATIVE) || defined(__convexc__)
+
+#ifndef CONVEX
+#define CONVEX
+#endif
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE
+
+#include <sys/types.h>
+#include <sys/stat.h>
+/* For Convex machines with native format floats */
+#ifdef CONVEXNATIVE
+#define DF_MT             DFMT_CONVEXNATIVE
+#else
+#define DF_MT             DFMT_CONVEX
+#endif
+typedef void              VOID;
+typedef void              *VOIDP;
+typedef char              *_fcd;
+typedef char              char8;
+typedef unsigned char     uchar8;
+typedef char              int8;
+typedef unsigned char     uint8;
+typedef short int         int16;
+typedef unsigned short int uint16;
+typedef long int          int32;
+typedef unsigned long int uint32;
+typedef int               intn;
+typedef unsigned int      uintn;
+typedef float             float32;
+typedef double            float64;
+typedef int               intf;     /* size of INTEGERs in Fortran compiler */
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+#define _fcdtocp(desc) (desc)
+#ifdef  HAVE_FMPOOL
+#define FILELIB PAGEBUFIO  /* enable page buffering */
+#else
+#define FILELIB UNIXBUFIO
+#endif
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+#define RIGHT_SHIFT_IS_UNSIGNED
+#define INCLUDES_ARE_ANSI
+#define HAVE_STDC
+
+#endif /* CONVEX */
+
+
+#if defined(MIPSEL) || ((defined(mips) || defined(__mips)) && (defined(ultrix) || defined(__ultrix)))
+
+#ifndef MIPSEL
+#define MIPSEL
+#endif
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE 1
+
+#ifndef __GNUC__
+#define DUMBCC 	/* because it is.  for later use in macros */
+#endif /* __GNUC__ */
+
+#include <sys/types.h>
+#include <sys/file.h>               /* for unbuffered i/o stuff */
+#include <sys/stat.h>
+#define DF_MT   DFMT_MIPSEL
+typedef void            VOID;
+typedef void            *VOIDP;
+typedef char            *_fcd;
+typedef char            char8;
+typedef unsigned char   uchar8;
+typedef char            int8;
+typedef unsigned char   uint8;
+typedef short           int16;
+typedef unsigned short  uint16;
+typedef int             int32;
+typedef unsigned int    uint32;
+typedef int             intn;
+typedef unsigned int    uintn;
+typedef float           float32;
+typedef double          float64;
+typedef int             intf;     /* size of INTEGERs in Fortran compiler */
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+#define _fcdtocp(desc) (desc)
+#define FNAME_POST_UNDERSCORE
+#ifdef  HAVE_FMPOOL
+#define FILELIB PAGEBUFIO  /* enable page buffering */
+#else
+#define FILELIB UNIXBUFIO
+#endif
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+
+#endif /* MIPSEL */
+
+#if defined(MAC) || defined(macintosh) || defined (SYMANTEC_C)
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE 1
+
+#include <memory.h>             /* malloc stuff for MPW */
+#include <fcntl.h>              /* unbuffered I/O stuff for MPW */
+#ifdef __MWERKS__				/* Metrowerks */
+#include <sioux.h>
+#include <console.h>
+#endif
+#ifdef SYMANTEC_C				/* for SYMANTEC C */
+#include <unix.h>
+#define isascii(c)  (isprint(c) || iscntrl(c))
+#else  /* MPW, possibly others */
+#include <Files.h>              /* for unbuffered I/O stuff */
+#endif /* SYMANTEC_C*/
+#ifndef ABSOFT
+#define DF_CAPFNAMES            /* fortran names are in all caps */
+#endif /* ABSOFT */
+#define DF_DYNAMIC              /* use dynamic allocation */
+#define DF_MT   DFMT_MAC
+
+typedef void              VOID;
+typedef void              *VOIDP;
+typedef char              *_fcd;
+typedef char              char8;
+typedef unsigned char     uchar8;
+typedef char              int8;
+typedef unsigned char     uint8;
+typedef short int         int16;
+typedef unsigned short int uint16;
+typedef long int          int32;
+typedef unsigned long int uint32;
+typedef int               intn;
+typedef unsigned int      uintn;
+typedef float             float32;
+typedef double            float64;
+typedef int               intf;     /* size of INTEGERs in Fortran compiler */
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+#define _fcdtocp(desc) (desc)
+void exit(int status);
+
+#define FILELIB MACIO
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+
+#endif /*MAC*/
+
+/* Metrowerks Mac compiler defines some PC stuff so need to exclude this on the Mac */
+#if !(defined(macintosh) || defined(MAC))
+
+#if defined _M_ALPHA || defined _M_IX86 || defined INTEL86 || defined M_I86 || defined M_I386 || defined DOS386 || defined __i386 || defined UNIX386 || defined i386
+#ifndef INTEL86
+#define INTEL86
+#endif /* INTEL86 */
+
+#if !defined UNIX386 && (defined unix || defined __unix)
+#define UNIX386
+#endif /* UNIX386 */
+
+#if !defined DOS386 && defined M_I386
+#define DOS386
+#endif /* M_I386 && !DOS386 */
+
+#if defined _WINDOWS || defined WIN32
+#define WIN386
+#endif  /* _WINDOWS | WIN32 */
+
+#if defined WIN386 || defined DOS386 || defined UNIX386
+#define INTEL386
+#endif /* WIN386 | DOS386 | UNIX386 */
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE 1
+
+#if defined _WINDOWS || defined WIN32
+#pragma comment( lib, "oldnames" )
+#endif
+
+#include <fcntl.h>
+#ifdef UNIX386
+#include <sys/types.h>      /* for unbuffered file I/O */
+#include <sys/stat.h>
+#include <unistd.h>
+#else /* !UNIX386 */
+#include <sys\types.h>      /* for unbuffered file I/O */
+#include <sys\stat.h>
+#include <io.h>
+#include <conio.h>          /* for debugging getch() calls */
+#include <malloc.h>
+#endif /* UNIX386 */
+#include <ctype.h>          /* for character macros */
+#ifdef __WATCOMC__
+#include <stddef.h>         /* for the 'fortran' pragma */
+#endif
+
+#if defined(_MSC_VER) && !defined(_MFHDFLIB_) && !defined(_HDFLIB_)	/* Auto-link when possible */
+#	define HDF_LIB_VER	"415"
+#	if !defined(_DEBUG)
+#		if !defined(_HDFDLL_)
+#			define HDF_LIB_NAME	"HD" HDF_LIB_VER ".lib"
+#			pragma message( "Automatic linking with the static single-threaded HDF library - " HDF_LIB_NAME )
+#		else
+#			define HDF_LIB_NAME	"HD" HDF_LIB_VER "m.lib"
+#			pragma message( "Automatic linking with the multithreaded HDF DLL - " HDF_LIB_NAME )
+#		endif
+#	else
+#		if !defined(_HDFDLL_)
+#			define HDF_LIB_NAME	"HD" HDF_LIB_VER "d.lib"
+#			pragma message( "Automatic linking with the debug static single-threaded HDF library - " HDF_LIB_NAME  )
+#		else
+#			define HDF_LIB_NAME	"HD" HDF_LIB_VER "md.lib"
+#			pragma message( "Automatic linking with the debug multithreaded HDF DLL - " HDF_LIB_NAME  )
+#		endif
+#	endif
+#	pragma comment(lib, HDF_LIB_NAME )
+#endif /* defined(_MSC_VER) && !defined(_MFHDFLIB_) && !defined(_HDFLIB_) */
+
+#if defined WIN386
+#ifndef GMEM_MOVEABLE       /* check if windows header is already included */
+#include <windows.h>        /* include the windows headers */
+#include <winnt.h>
+#define HAVE_BOOLEAN
+#endif /* GMEM_MOVEABLE */
+#endif /* WIN386 */
+
+#define DF_MT             DFMT_PC
+
+#ifndef VOID    /* The stupid windows.h header file uses a #define instead of a typedef */
+typedef void              VOID;
+#endif  /* end VOID */
+typedef void *            VOIDP;
+typedef char *            _fcd;
+typedef char              char8;
+typedef unsigned char     uchar8;
+typedef char              int8;
+typedef unsigned char     uint8;
+typedef short int         int16;
+typedef unsigned short int uint16;
+typedef long int          int32;
+typedef unsigned long int uint32;
+typedef int               intn;
+typedef unsigned int      uintn;
+typedef float             float32;
+typedef double            float64;
+typedef long              intf;     /* size of INTEGERs in Fortran compiler */
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+
+#if defined _M_ALPHA
+#define FNAME_PRE_UNDERSCORE
+#endif
+
+#if defined UNIX386
+#define FNAME_POST_UNDERSCORE
+#elif defined INTEL386
+#define DF_CAPFNAMES
+#endif
+#define _fcdtocp(desc) (desc)
+
+#ifdef  HAVE_FMPOOL
+#define FILELIB PAGEBUFIO  /* enable page buffering */
+#else
+#define FILELIB UNIXBUFIO
+#endif
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+#define HAVE_STDC
+#define INCLUDES_ARE_ANSI
+
+#endif /* INTEL86 */
+#endif /* !(defined(macintosh) || defined(MAC)) */
+
+#if defined(NEXT) || defined(NeXT)
+
+#ifndef NEXT
+#define NEXT
+#endif
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE
+
+#define isascii(c)  (isprint(c) || iscntrl(c))
+#ifndef __GNUC__
+#include <memory.h>
+#endif /* __GNUC__ */
+#include <sys/file.h>               /* for unbuffered i/o stuff */
+#include <sys/stat.h>
+#define DF_MT             DFMT_NEXT
+typedef void              VOID;
+typedef void              *VOIDP;
+typedef char              *_fcd;
+typedef char              char8;
+typedef unsigned char     uchar8;
+typedef char              int8;
+typedef unsigned char     uint8;
+typedef short int         int16;
+typedef unsigned short int uint16;
+typedef long int          int32;
+typedef unsigned long int uint32;
+typedef int               intn;
+typedef unsigned int      uintn;
+typedef int               intf;     /* size of INTEGERs in Fortran compiler */
+typedef float             float32;
+typedef double            float64;
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+#define FNAME_POST_UNDERSCORE
+#define _fcdtocp(desc) (desc)
+#ifdef  HAVE_FMPOOL
+#define FILELIB PAGEBUFIO  /* enable page buffering */
+#else
+#define FILELIB UNIXBUFIO
+#endif
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+
+#define HAVE_STDC
+#define INCLUDES_ARE_ANSI
+
+#endif /* NEXT */
+
+#if defined(MOTOROLA) || defined(m88k)
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE
+
+#ifndef __GNUC__
+#include <memory.h>
+#endif /* __GNUC__ */
+#include <unistd.h>
+#include <sys/file.h>               /* for unbuffered i/o stuff */
+#include <sys/stat.h>
+#ifndef O_RDONLY
+#include <fcntl.h>              /* for unbuffered i/o stuff */
+#endif /*O_RDONLY*/
+#define DF_MT             DFMT_MOTOROLA
+typedef void              VOID;
+typedef void              *VOIDP;
+typedef char              *_fcd;
+typedef char              char8;
+typedef unsigned char     uchar8;
+typedef char              int8;
+typedef unsigned char     uint8;
+typedef short int         int16;
+typedef unsigned short int uint16;
+typedef long int          int32;
+typedef unsigned long int uint32;
+typedef int               intn;
+typedef unsigned int      uintn;
+typedef int               intf;     /* size of INTEGERs in Fortran compiler */
+typedef float             float32;
+typedef double            float64;
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+#define FNAME_POST_UNDERSCORE
+#define _fcdtocp(desc) (desc)
+#define FILELIB UNIXBUFIO
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+
+#endif /* MOTOROLA */
+
+#if defined DEC_ALPHA || (defined __alpha && defined __unix__)
+
+#ifndef DEC_ALPHA
+#define DEC_ALPHA
+#endif
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE
+
+#include <sys/file.h>               /* for unbuffered i/o stuff */
+#include <sys/stat.h>
+#define DF_MT             DFMT_ALPHA
+typedef void              VOID;
+typedef void              *VOIDP;
+typedef char              *_fcd;
+typedef char              char8;
+typedef unsigned char     uchar8;
+typedef char              int8;
+typedef unsigned char     uint8;
+typedef short int         int16;
+typedef unsigned short int uint16;
+#ifndef __rpc_types_h
+typedef int               int32;
+typedef unsigned int      uint32;
+#endif /* __rpc_types_h */
+typedef int               intn;
+typedef unsigned int      uintn;
+typedef int               intf;     /* size of INTEGERs in Fortran compiler */
+typedef float             float32;
+typedef double            float64;
+typedef long              hdf_pint_t;   /* an integer the same size as a pointer */
+#define FNAME_POST_UNDERSCORE
+#define _fcdtocp(desc) (desc)
+#ifdef  HAVE_FMPOOL
+#define FILELIB PAGEBUFIO  /* enable page buffering */
+#else
+#define FILELIB UNIXBUFIO
+#endif
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+
+#ifdef __GNUC__
+#define HAVE_STDC
+#define INCLUDES_ARE_ANSI
+#endif
+
+#endif /* DEC_ALPHA */
+
+#if defined VP | defined __uxpm__
+
+#ifndef VP
+#define VP
+#endif
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE 1
+
+#include <memory.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#define DF_MT              DFMT_VP
+typedef void                VOID;
+typedef void               *VOIDP;
+typedef char               *_fcd;
+typedef char               char8;
+typedef unsigned char      uchar8;
+typedef char               int8;
+typedef unsigned char      uint8;
+typedef short int          int16;
+typedef unsigned short int uint16;
+typedef long int           int32;
+typedef unsigned long int  uint32;
+typedef int                intn;
+typedef unsigned int       uintn;
+typedef int                intf;     /* size of INTEGERs in Fortran compiler */
+typedef float              float32;
+typedef double             float64;
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+#define FNAME_POST_UNDERSCORE
+#define _fcdtocp(desc) (desc)
+#define FILELIB UNIXBUFIO
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+
+#endif /* VP */
+
+#if defined I860 | defined i860
+
+#ifndef I860
+#define I860
+#endif
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE 1
+
+#include <sys/types.h>
+#include <sys/file.h>           /* for unbuffered i/o stuff */
+#include <sys/stat.h>
+#include <unistd.h>             /* mis-using def. for SEEK_SET, but oh well */
+#define DF_MT   DFMT_I860
+typedef void            VOID;
+typedef void            *VOIDP;
+typedef char            *_fcd;
+typedef char            char8;
+typedef unsigned char   uchar8;
+typedef char            int8;
+typedef unsigned char   uint8;
+typedef short           int16;
+typedef unsigned short  uint16;
+typedef int             int32;
+typedef unsigned int    uint32;
+typedef int             intn;
+typedef unsigned int    uintn;
+typedef float           float32;
+typedef double          float64;
+typedef int             intf;     /* size of INTEGERs in Fortran compiler */
+typedef int               hdf_pint_t;   /* an integer the same size as a pointer */
+#define _fcdtocp(desc) (desc)
+#define FNAME_POST_UNDERSCORE
+#define FILELIB UNIXBUFIO
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+
+#endif /* I860 */
+
+
+/* IA64 running Linux */
+#if defined IA64
+
+#ifdef GOT_MACHINE
+If you get an error on this line more than one machine type has been defined.
+Please check your Makefile.
+#endif
+#define GOT_MACHINE
+
+#include <sys/file.h>               /* for unbuffered i/o stuff */
+#include <sys/stat.h>
+#define DF_MT             DFMT_IA64
+typedef void              VOID;
+typedef void              *VOIDP;
+typedef char              *_fcd;
+typedef char              char8;
+typedef unsigned char     uchar8;
+typedef char              int8;
+typedef unsigned char     uint8;
+typedef short int         int16;
+typedef unsigned short int uint16;
+typedef int               int32;
+typedef unsigned int      uint32;
+typedef int               intn;
+typedef unsigned int      uintn;
+typedef int               intf;     /* size of INTEGERs in Fortran compiler */
+typedef float             float32;
+typedef double            float64;
+typedef long              hdf_pint_t;   /* an integer the same size as a pointer */
+#define FNAME_POST_UNDERSCORE
+#define _fcdtocp(desc) (desc)
+#ifdef  HAVE_FMPOOL
+#define FILELIB PAGEBUFIO  /* enable page buffering */
+#else
+#define FILELIB UNIXBUFIO
+#endif
+
+/* JPEG #define's - Look in the JPEG docs before changing - (Q) */
+
+/* Determine the memory manager we are going to use. Valid values are: */
+/*  MEM_DOS, MEM_ANSI, MEM_NAME, MEM_NOBS.  See the JPEG docs for details on */
+/*  what each does */
+#define JMEMSYS         MEM_ANSI
+
+#ifdef __GNUC__
+#define HAVE_STDC
+#define INCLUDES_ARE_ANSI
+#endif
+
+#endif /* IA64 */
+
+#ifndef GOT_MACHINE
+No machine type has been defined.  Your Makefile needs to have someing like
+-DSUN or -DUNICOS in order for the HDF internal structures to be defined
+correctly.
+#endif
+
+/*-----------------------------------------------------*/
+/*              encode and decode macros               */
+/*-----------------------------------------------------*/
+
+#   define INT16ENCODE(p, i) \
+{ *(p) = (uint8)(((uintn)(i) >> 8) & 0xff); (p)++; \
+        *(p) = (uint8)((uintn)(i) & 0xff); (p)++; }
+
+#   define UINT16ENCODE(p, i) \
+{ *(p) = (uint8)(((uintn)(i) >> 8) & 0xff); (p)++; *(p) = (uint8)((i) & 0xff); (p)++; }
+
+#   define INT32ENCODE(p, i) \
+{ *(p) = (uint8)(((uint32)(i) >> 24) & 0xff); (p)++; \
+        *(p) = (uint8)(((uint32)(i) >> 16) & 0xff); (p)++; \
+        *(p) = (uint8)(((uint32)(i) >> 8) & 0xff); (p)++; \
+        *(p) = (uint8)((uint32)(i) & 0xff); (p)++; }
+
+#   define UINT32ENCODE(p, i) \
+{ *(p) = (uint8)(((i) >> 24) & 0xff); (p)++; \
+        *(p) = (uint8)(((i) >> 16) & 0xff); (p)++; \
+        *(p) = (uint8)(((i) >> 8) & 0xff); (p)++; \
+        *(p) = (uint8)((i) & 0xff); (p)++; }
+
+#   define NBYTEENCODE(d, s, n) \
+{   HDmemcpy(d,s,n); p+=n }
+
+/* DECODE converts big endian bytes pointed by p to integer values and store
+ * it in i.  For signed values, need to do sign-extension when converting
+ * the 1st byte which carries the sign bit.
+ * The macros does not require i be of a certain byte sizes.  It just requires
+ * i be big enough to hold the intended value range.  E.g. INT16DECODE works
+ * correctly even if i is actually a 64bit int like in a Cray.
+ */
+
+#   define INT16DECODE(p, i) \
+{ (i) = ((*(p) & 0x80) ? ~0xffff : 0x00) | ((int16)(*(p) & 0xff) << 8); (p)++; \
+        (i) |= (int16)((*(p) & 0xff)); (p)++; }
+
+#   define UINT16DECODE(p, i) \
+{ (i) = (uint16)((*(p) & 0xff) << 8); (p)++; \
+        (i) |= (uint16)(*(p) & 0xff); (p)++; }
+
+#   define INT32DECODE(p, i) \
+{ (i) = ((*(p) & 0x80) ? ~0xffffffff : 0x00) | ((int32)(*(p) & 0xff) << 24); (p)++; \
+        (i) |= ((int32)(*(p) & 0xff) << 16); (p)++; \
+        (i) |= ((int32)(*(p) & 0xff) << 8); (p)++; \
+        (i) |= (*(p) & 0xff); (p)++; }
+
+#   define UINT32DECODE(p, i) \
+{ (i) = ((uint32)(*(p) & 0xff) << 24); (p)++; \
+        (i) |= ((uint32)(*(p) & 0xff) << 16); (p)++; \
+        (i) |= ((uint32)(*(p) & 0xff) << 8); (p)++; \
+        (i) |= (uint32)(*(p) & 0xff); (p)++; }
+
+/* Note! the NBYTEDECODE macro is backwards from the memcpy() routine, */
+/*      in the spirit of the other DECODE macros */
+#   define NBYTEDECODE(s, d, n) \
+{   HDmemcpy(d,s,n); p+=n }
+
+/*----------------------------------------------------------------
+** MACRO FCALLKEYW for any special fortran-C stub keyword
+**
+** MacIntosh MPW LS-fortran needs pascal since it can interface
+**  best with pascal functions.
+** Microsoft C and Fortran need __fortran for Fortran callable C
+**  routines.
+**
+** MACRO FRETVAL for any return value from a fortran-C stub function
+**  Replaces the older FCALLKEYW macro.
+**---------------------------------------------------------------*/
+#ifdef FRETVAL
+#undef FRETVAL
+#endif
+
+#if defined(MAC)                /* with LS FORTRAN */
+#ifndef ABSOFT
+#   define FCALLKEYW    pascal
+#   define FRETVAL(x)   pascal x
+#endif /* ABSOFT */
+#endif
+
+#ifndef FRETVAL /* !MAC */
+#   define FCALLKEYW    /*NONE*/
+#   define FRETVAL(x)   x
+#endif
+
+
+/*----------------------------------------------------------------
+** MACRO FNAME for any fortran callable routine name.
+**
+**  This macro prepends, appends, or does not modify a name
+**  passed as a macro parameter to it based on the FNAME_PRE_UNDERSCORE,
+**  FNAME_POST_UNDERSCORE macros set for a specific system.
+**
+**---------------------------------------------------------------*/
+#if defined(FNAME_PRE_UNDERSCORE) && defined(FNAME_POST_UNDERSCORE)
+#   define FNAME(x)     _##x##_
+#endif
+#if defined(FNAME_PRE_UNDERSCORE) && !defined(FNAME_POST_UNDERSCORE)
+#   define FNAME(x)     _##x
+#endif
+#if !defined(FNAME_PRE_UNDERSCORE) && defined(FNAME_POST_UNDERSCORE)
+#   define FNAME(x)     x##_
+#endif
+#if !defined(FNAME_PRE_UNDERSCORE) && !defined(FNAME_POST_UNDERSCORE)
+#   define FNAME(x)     x
+#endif
+
+/**************************************************************************
+*  Generally useful macro definitions
+**************************************************************************/
+#ifndef MIN
+#define MIN(a,b)    (((a)<(b)) ? (a) : (b))
+#endif
+#ifndef MAX
+#define MAX(a,b)    (((a)>(b)) ? (a) : (b))
+#endif
+
+/**************************************************************************
+*  Debugging Allocation functions
+**************************************************************************/
+#ifdef MALDEBUG
+#include "maldebug.h"
+#endif
+
+/**************************************************************************
+*  Macros to work around ANSI C portability problems.
+**************************************************************************/
+#ifdef DUMBCC
+#define CONSTR(v,s) char *v=s
+#else
+#define CONSTR(v,s) static const char v[]=s
+#endif
+
+/* Old-style memory allocation function aliases -QAK */
+#define HDgetspace HDmalloc
+#define HDclearspace HDcalloc
+#define HDregetspace HDrealloc
+#define HDfreespace HDfree
+
+/**************************************************************************
+*  Allocation functions defined differently 
+**************************************************************************/
+#if !defined(MALLOC_CHECK) && !defined(_HDFDLL_)
+#  define HDmalloc(s)      (malloc((size_t)s))
+#  define HDcalloc(a,b)    (calloc((size_t)a,(size_t)b))
+#  define HDfree(p)        (free((void*)p))
+#  define HDrealloc(p,s)   (realloc((void*)p,(size_t)s))
+#endif /* !defined MALLOC_CHECK */
+/* Macro to free space and clear pointer to NULL */
+#define HDfreenclear(p) { if((p)!=NULL) HDfree(p); p=NULL; }
+
+/**************************************************************************
+*  String functions defined differently 
+**************************************************************************/
+
+#  define HDstrcat(s1,s2)   (strcat((s1),(s2)))
+#  define HDstrcmp(s,t)     (strcmp((s),(t)))
+#  define HDstrcpy(s,d)     (strcpy((s),(d)))
+#  define HDstrlen(s)       (strlen((const char *)(s)))
+#  define HDstrncmp(s1,s2,n)    (strncmp((s1),(s2),(n)))
+#  define HDstrncpy(s1,s2,n)    (strncpy((s1),(s2),(n)))
+#  define HDstrchr(s,c)         (strchr((s),(c)))
+#  define HDstrrchr(s,c)        (strrchr((s),(c)))
+#  define HDstrtol(s,e,b)       (strtol((s),(e),(b)))
+/* non-standard function, not defined on the following machines - */
+#if !(defined VMS || defined macintosh || defined MAC || defined SYMANTEC_C || defined MIPSEL || defined NEXT || defined CONVEX || defined IBM6000 || defined ANSISUN || defined IRIX || defined _HDFDLL_ )
+#  define HDstrdup(s)      ((char *)strdup((const char *)(s)))
+#endif /* !(VMS | etc..) */
+
+
+/**************************************************************************
+*  Memory functions defined differently
+**************************************************************************/
+
+# define HDmemcpy(dst,src,n)   (memcpy((void *)(dst),(const void *)(src),(size_t)(n)))
+# define HDmemset(dst,c,n)     (memset((void *)(dst),(intn)(c),(size_t)(n)))
+# define HDmemcmp(dst,src,n)   (memcmp((const void *)(dst),(const void *)(src),(size_t)(n)))
+
+
+/**************************************************************************
+*  Misc. functions
+**************************************************************************/
+#if defined (MAC) || defined (macintosh) || defined (SYMANTEC_C)
+#define HDstat(path, result)	(mstat(path))
+#else /* !macintosh */
+#define HDstat(path, result)	(stat(path, result))
+#endif /* !macintosh */
+#define HDgetenv(s1)            (getenv(s1))
+#define HDputenv(s1)            (putenv(s1))
+#define HDltoa(v)               (ltoa(v))
+#if defined (SUN) && defined(__GNUC__)
+#define HDatexit(f)             (0) /* we punt on the SUN using gcc */
+#else /* !SUN & GCC */
+#define HDatexit(f)             (atexit(f))
+#endif /* !SUN & GCC */
+
+/* Compatibility #define for V3.3, should be taken out by v4.0 - QAK */
+#define DFSDnumber DFSDndatasets
+
+#endif /* HDFI_H */
+
diff -urN HDF4.1r5/hdf/util/he_main.c hdf-new/hdf/util/he_main.c
--- HDF4.1r5/hdf/util/he_main.c	Wed Dec  3 20:50:05 1997
+++ hdf-new/hdf/util/he_main.c	Mon Dec  8 19:47:45 2003
@@ -73,10 +73,11 @@
 #include "he.h"
 
 #include <stdio.h>
-#ifndef WIN32
-#include <unistd.h>
-#endif
-
+/*
+  #ifndef WIN32
+  #include <unistd.h>
+  #endif
+*/
 /* the return status of last command executed */
 int         he_status = HE_OK;
 
diff -urN HDF4.1r5/mfhdf/fortran/config/ftest-darwin.f hdf-new/mfhdf/fortran/config/ftest-darwin.f
--- HDF4.1r5/mfhdf/fortran/config/ftest-darwin.f	Wed Dec 31 19:00:00 1969
+++ hdf-new/mfhdf/fortran/config/ftest-darwin.f	Mon Dec  8 19:43:58 2003
@@ -0,0 +1,1220 @@
+c********************************************************************
+c   Copyright 1993, UCAR/Unidata
+c   See netcdf/COPYRIGHT file for copying and redistribution conditions.
+c   $Id: hdf-4.1r4-2.patch,v 1.1 2001/09/19 14:46:18 jswhit Exp $
+c********************************************************************/
+
+
+
+c
+c     program to test the Sun Fortran jacket interface to the netCDF
+c
+      program ftest
+      
+      include 'netcdf.inc'
+
+c     name of first test cdf
+      character*31 name
+c     name of second test cdf
+      character*31 name2
+      
+c     Returned error code.
+      integer iret 
+c     netCDF ID
+      integer ncid
+c     ID of dimension lat
+      integer  latdim
+c     ID of dimension lon
+      integer londim
+c     ID of dimension level
+      integer leveldim
+c     ID of dimension time
+      integer timedim
+c     ID of dimension len
+      integer lendim
+
+c     variable used to control error-handling behavior
+      integer ncopts
+      integer dimsiz(MAXNCDIM)
+C      allowable roundoff 
+      real epsilon
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+      data name/'test.nc'/
+      data name2/'copy.nc'/
+      data epsilon /.000001/
+      
+100   format('*** Testing ', a, ' ...')
+c     set error-handling to verbose and non-fatal
+      ncopts = NCVERBOS
+      call ncpopt(ncopts)
+
+c     create a netCDF named 'test.nc'
+      write(*,100) 'nccre'
+      ncid = nccre(name, NCCLOB, iret)
+
+c     test ncddef
+      write(*,100) 'ncddef'
+      call tncddef(ncid)
+
+c     test ncvdef
+      write(*,100) 'ncvdef'
+      call tncvdef(ncid)
+
+c     test ncapt
+      write(*, 100) 'ncapt, ncaptc'
+      call tncapt(ncid)
+
+c     close 'test.nc'
+      write(*, 100) 'ncclos'
+      call ncclos(ncid, iret)
+
+c     test ncvpt1
+      write(*, 100) 'ncvpt1'
+      call tncvpt1(name)
+
+c     test ncvgt1
+      write(*, 100) 'ncvgt1'
+      call tncvgt1(name)
+
+c     test ncvpt
+      write(*, 100) 'ncvpt'
+      call tncvpt(name)
+
+c     test ncinq
+      write(*, 100) 'ncopn, ncinq, ncdinq, ncvinq, ncanam, ncainq'
+      call tncinq(name)
+
+c     test ncvgt
+      write(*, 100) 'ncvgt, ncvgtc'
+      call tncvgt(name)
+
+c     test ncagt
+      write(*, 100) 'ncagt, ncagtc'
+      call tncagt(name)
+
+c     test ncredf
+      write(*, 100) 'ncredf, ncdren, ncvren, ncaren, ncendf'
+      call tncredf(name)
+
+      call tncinq(name)
+
+c     test ncacpy
+      write(*, 100) 'ncacpy'
+      call tncacpy(name, name2)
+
+c     test ncadel
+      write(*, 100) 'ncadel'
+      call tncadel(name2)
+      end
+c
+c     subroutine to test ncacpy
+c
+      subroutine tncacpy(iname, oname)
+      character*31 iname, oname
+      include 'netcdf.inc'
+      integer ndims, nvars, natts, recdim, iret
+      character*31 vname, attnam
+      integer attype, attlen
+      integer vartyp, nvdims, vdims(MAXVDIMS), nvatts
+      integer lenstr
+c     existing netCDF id
+      integer incdf
+c     netCDF id of the output netCDF file to which the attribute
+c     will be copied
+      integer outcdf
+
+      integer mattlen
+      parameter (mattlen = 80)
+      character*80 charval
+      double precision doubval(2)
+      real flval(2)
+      integer lngval(2)
+      integer*2 shval(2)
+      integer i, j, k
+      character*31 varnam, attname(2,7), gattnam(2)
+      byte bytval(2)
+      common /atts/attname, gattnam
+      integer*2 svalidrg(2)
+      real rvalidrg(2)
+      integer lvalidrg(2)
+      double precision dvalidrg(2)
+      byte bvalidrg(2)
+      character*31 gavalue(2), cavalue(2)
+      real epsilon
+
+      data bvalidrg/1,110/
+      data svalidrg/-100,100/
+      data lvalidrg/0,360/
+      data rvalidrg/0.0, 5000.0/
+      data dvalidrg/0D0,500D0/
+      data gavalue/'NWS', '88/10/25 12:00:00'/
+      data cavalue/'test string', 'a'/
+      data lenstr/80/	
+      data epsilon /.000001/
+
+      incdf = ncopn(iname, NCNOWRIT, iret)
+      outcdf = nccre(oname, NCCLOB, iret)
+      call tncddef(outcdf)
+      call tncvdef(outcdf)
+      call ncinq (incdf, ndims, nvars, natts, recdim, iret)
+      do 5 j = 1, natts
+         call ncanam (incdf, NCGLOBAL, j, attnam, iret)
+         call ncacpy (incdf, NCGLOBAL, attnam, outcdf, NCGLOBAL, iret)
+ 5    continue
+      do 10 i = 1, nvars
+         call ncvinq (incdf, i, vname, vartyp, nvdims,
+     +        vdims, nvatts, iret)
+         do 20 k = 1, nvatts
+            call ncanam (incdf, i, k, attnam, iret)
+            call ncacpy (incdf, i, attnam, outcdf, i, iret)
+ 20      continue
+ 10   continue
+c     
+c     get global attributes first
+c     
+      do 100 i = 1, natts
+         call ncanam (outcdf, NCGLOBAL, i, attnam, iret)
+         call ncainq (outcdf, NCGLOBAL, attnam, attype, attlen,
+     +        iret)
+         if (attlen .gt. mattlen) then
+            write (*,*) 'global attribute too big!', attlen, mattlen
+            stop 'Stopped'
+         else if (attype .eq. NCBYTE) then
+            call ncagt (outcdf, NCBYTE, attnam, bytval, iret)
+         else if (attype .eq. NCCHAR) then
+            call ncagtc (outcdf, NCGLOBAL, attnam, charval, 
+     +           lenstr, iret)
+            if (attnam .ne. gattnam(i)) write(*,*) 'error in ncagt G'
+            if (charval .ne. gavalue(i))
+     + write(*,*) 'error in ncagt G2', lenstr, charval, gavalue(i)
+                  charval = ' '                                    
+         else if (attype .eq. NCSHORT) then
+            call ncagt (outcdf, NCGLOBAL, attnam, shval, iret) 
+         else if (attype .eq. NCLONG) then
+            call ncagt (outcdf, NCGLOBAL, attnam, lngval, iret)            
+         else if (attype .eq. NCFLOAT) then
+            call ncagt (outcdf, NCGLOBAL, attnam, flval, iret)
+         else 
+            call ncagt (outcdf, NCGLOBAL, attnam, doubval,iret)          
+         end if
+ 100   continue
+c
+c     get variable attributes
+c
+      do 200 i = 1, nvars
+         call ncvinq (outcdf, i, varnam, vartyp, nvdims, vdims,
+     +                nvatts, iret)
+         do 250 j = 1, nvatts
+            call ncanam (outcdf, i, j, attnam, iret)
+            call ncainq (outcdf, i, attnam, attype, attlen,
+     +                   iret)
+            if (attlen .gt. mattlen) then
+               write (*,*) 'variable ', i,  'attribute too big !'
+               stop 'Stopped'
+            else 
+               if (attype .eq. NCBYTE) then
+                  call ncagt (outcdf, i, attnam, bytval, 
+     +                 iret)
+                  if (attnam .ne. attname(j,i))
+     +       write(*,*) 'error in ncagt BYTE N'
+                  if (bytval(j) .ne. bvalidrg(j)) write(*,*)
+     + 'ncacpy: byte ', bytval(j), ' .ne. ', bvalidrg(j)
+               else if (attype .eq. NCCHAR) then
+                  call ncagtc (outcdf, i, attnam, charval, 
+     +                 lenstr, iret)
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     +  'error in ncagt CHAR N'
+                  if (charval .ne. cavalue(j)) write(*,*)
+     +  'error in ncagt'
+                  charval = ' '                                   
+               else if (attype .eq. NCSHORT) then
+                  call ncagt (outcdf, i, attnam, shval, 
+     +                 iret)  
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt SHORT N'
+                  if (shval(j) .ne. svalidrg(j)) then
+                     write(*,*) 'error in ncagt SHORT'
+                  end if
+               else if (attype .eq. NCLONG) then
+                  call ncagt (outcdf, i, attnam, lngval, 
+     +                 iret)
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt LONG N'
+                  if (lngval(j) .ne. lvalidrg(j)) write(*,*)
+     + 'error in ncagt LONG'
+               else if (attype .eq. NCFLOAT) then
+                  call ncagt (outcdf, i, attnam, flval, 
+     +                 iret)            
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt FLOAT N'
+                  if (flval(j) .ne. rvalidrg(j)) write(*,*)
+     + 'error in ncagt FLOAT'
+               else if (attype .eq. NCDOUBLE) then
+                  call ncagt (outcdf, i, attnam, doubval,
+     +                 iret)          
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt DOUBLE N'
+                  if ( abs(doubval(j) - dvalidrg(j)) .gt. epsilon)
+     + write(*,*) 'error in ncagt DOUBLE'
+               end if
+            end if
+ 250     continue
+ 200   continue
+      call ncclos(incdf, iret)
+      call ncclos(outcdf, iret)
+      return
+      end
+
+
+      
+c     
+c     subroutine to test ncadel
+c
+      subroutine tncadel (cdfname)
+      character*31 cdfname
+      include 'netcdf.inc'
+      
+      integer  bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+      integer ncid, iret, i, j
+      integer ndims, nvars, natts, recdim
+      integer vartyp, nvdims, vdims(MAXVDIMS), nvatts
+      character*31 varnam, attnam
+
+      ncid = ncopn(cdfname, NCWRITE, iret)
+c     put cdf in define mode
+      call ncredf (ncid,iret)
+c     get number of global attributes
+      call ncinq (ncid, ndims, nvars, natts, recdim, iret)
+      do 10 i = natts, 1, -1
+c     get name of global attribute
+         call ncanam (ncid, NCGLOBAL, i, attnam, iret)
+c     delete global attribute
+         call ncadel (ncid, NCGLOBAL, attnam, iret)
+ 10   continue
+
+      do 100 i = 1, nvars
+c     get number of variable attributes
+         call ncvinq (ncid, i, varnam, vartyp, nvdims, vdims,
+     +        nvatts, iret)
+         do 200 j = nvatts, 1, -1
+            call ncanam (ncid, i, j, attnam, iret)
+            call ncadel (ncid, i, attnam, iret)
+ 200     continue
+ 100  continue
+      call ncinq (ncid, ndims, nvars, natts, recdim, iret)
+      if (natts .ne. 0) write(*,*) 'error in ncadel'
+c     put netCDF into data mode
+      call ncendf (ncid, iret)
+      call ncclos (ncid, iret)
+      return
+      end
+
+c
+c     subroutine to test ncagt and ncagtc
+
+      subroutine tncagt(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+            
+c     maximum length of an attribute
+      integer mattlen
+      parameter (mattlen = 80)
+      integer ncid, ndims, nvars, natts, recdim
+      integer bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+      integer i, j
+      integer attype, attlen, lenstr, iret
+      character*31 attnam
+      character*80 charval
+      double precision doubval(2)
+      real flval(2)
+      integer lngval(2)
+      integer*2 shval(2)
+      byte bytval(2)
+      integer vartyp, nvdims, vdims(MAXVDIMS), nvatts
+
+      character*31 varnam, attname(2,7), gattnam(2)
+      common /atts/attname, gattnam
+      integer*2 svalidrg(2)
+      real rvalidrg(2)
+      integer lvalidrg(2)
+      double precision dvalidrg(2)
+      byte bvalidrg(2)
+      character*31 gavalue(2), cavalue(2)
+      real epsilon
+
+      data bvalidrg/1,110/
+      data svalidrg/-100,100/
+      data lvalidrg/0,360/
+      data rvalidrg/0.0, 5000.0/
+      data dvalidrg/0D0,500D0/
+      data gavalue/'NWS', '88/10/25 12:00:00'/
+      data cavalue/'test string', 'a'/
+      data lenstr/80/	
+      data epsilon /.000001/
+      
+      ncid = ncopn (cdfname, NCNOWRIT, iret)
+      call ncinq (ncid, ndims, nvars, natts, recdim, iret)
+c     
+c     get global attributes first
+c     
+      do 10 i = 1, natts
+c     get name of attribute
+         call ncanam (ncid, NCGLOBAL, i, attnam, iret)
+c     get attribute type and length
+         call ncainq (ncid, NCGLOBAL, attnam, attype, attlen,
+     +        iret)
+         if (attlen .gt. mattlen) then
+            write (*,*) 'global attribute too big!'
+            stop 'Stopped'
+         else if (attype .eq. NCBYTE) then
+            call ncagt (ncid, NCBYTE, attnam, bytval, iret)
+         else if (attype .eq. NCCHAR) then
+            call ncagtc (ncid, NCGLOBAL, attnam, charval, 
+     +           lenstr, iret)
+            if (attnam .ne. gattnam(i)) write(*,*) 'error in ncagt'
+            if (charval .ne. gavalue(i)) write(*,*) 'error in ncagt'
+            charval = '                                        '
+         else if (attype .eq. NCSHORT) then
+            call ncagt (ncid, NCGLOBAL, attnam, shval, iret) 
+         else if (attype .eq. NCLONG) then
+            call ncagt (ncid, NCGLOBAL, attnam, lngval, iret)            
+         else if (attype .eq. NCFLOAT) then
+            call ncagt (ncid, NCGLOBAL, attnam, flval, iret)
+         else 
+            call ncagt (ncid, NCGLOBAL, attnam, doubval,iret)          
+         end if
+ 10   continue
+
+c
+c     get variable attributes
+c
+      do 20 i = 1, nvars
+         call ncvinq (ncid, i, varnam, vartyp, nvdims, vdims,
+     +                nvatts, iret)
+         do 25 j = 1, nvatts
+            call ncanam (ncid, i, j, attnam, iret)
+            call ncainq (ncid, i, attnam, attype, attlen,
+     +                   iret)
+            if (attlen .gt. mattlen) then
+               write (*,*) 'variable ', i,  'attribute too big !'
+               stop 'Stopped'
+            else 
+               if (attype .eq. NCBYTE) then
+                  call ncagt (ncid, i, attnam, bytval, 
+     +                 iret)
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt BYTE name'
+                  if (bytval(j) .ne. bvalidrg(j)) write(*,*)
+     + 'ncacpy: byte ', bytval(j), ' .ne. ', bvalidrg(j)
+               else if (attype .eq. NCCHAR) then
+                  call ncagtc (ncid, i, attnam, charval, 
+     +                 lenstr, iret)
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt CHAR name'
+                  if (charval .ne. cavalue(j)) write(*,*)
+     + 'error in ncagt CHAR name'
+	         charval = '                                        '
+               else if (attype .eq. NCSHORT) then
+                  call ncagt (ncid, i, attnam, shval, 
+     +                 iret)  
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt SHORT name'
+                  if (shval(j) .ne. svalidrg(j)) then
+                     write(*,*) 'error in ncagt SHORT'
+                  end if
+               else if (attype .eq. NCLONG) then
+                  call ncagt (ncid, i, attnam, lngval, 
+     +                 iret)
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt LONG name'
+                  if (lngval(j) .ne. lvalidrg(j)) write(*,*)
+     + 'error in ncagt LONG'
+               else if (attype .eq. NCFLOAT) then
+                  call ncagt (ncid, i, attnam, flval, 
+     +                 iret)            
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt FLOAT name'
+                  if (flval(j) .ne. rvalidrg(j)) write(*,*)
+     + 'error in ncagt FLOAT'
+               else if (attype .eq. NCDOUBLE) then
+                  call ncagt (ncid, i, attnam, doubval,
+     +                 iret)          
+                  if (attnam .ne. attname(j,i)) write(*,*)
+     + 'error in ncagt DOUBLE name'
+                  if ( abs(doubval(j) - dvalidrg(j)) .gt. epsilon)
+     + write(*,*) 'error in ncagt DOUBLE'
+               end if
+            end if
+ 25      continue
+ 20   continue
+      call ncclos(ncid, iret)
+      return
+      end
+c
+c     subroutine to test ncapt
+c
+      subroutine tncapt (ncid)
+      include 'netcdf.inc'
+      integer ncid, iret
+
+c attribute vectors
+      integer*2 svalidrg(2)
+      real rvalidrg(2)
+      integer lvalidrg(2)
+      double precision dvalidrg(2)
+      byte bvalidrg(2)
+
+c     variable ids
+      integer  bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+
+c assign attributes
+      
+c
+c     byte
+c
+      
+      bvalidrg(1) = 1
+      bvalidrg(2) = 250
+      call ncapt (ncid, bid, 'validrange', NCBYTE, 2,
+     +bvalidrg, iret)
+
+c
+c     short
+c
+
+      svalidrg(1) = -100
+      svalidrg(2) = 100
+      call ncapt (ncid, sid, 'validrange', NCSHORT, 2, 
+     +svalidrg, iret)
+
+c
+c     long
+c
+
+      lvalidrg(1) = 0
+      lvalidrg(2) = 360
+      call ncapt (ncid, lid, 'validrange', NCLONG, 2,
+     +lvalidrg, iret)
+      
+c
+c     float
+c
+
+      rvalidrg(1) = 0.0
+      rvalidrg(2) = 5000.0
+      call ncapt (ncid, fid, 'validrange', NCFLOAT, 2,
+     +rvalidrg, iret)
+
+c
+c     double
+c
+
+      dvalidrg(1) = 0D0
+      dvalidrg(2) = 500D0
+      call ncapt (ncid, did, 'validrange', NCDOUBLE, 2,
+     +dvalidrg, iret)
+
+c
+c     global
+c
+
+      call ncaptc (ncid, NCGLOBAL, 'source', NCCHAR, 3, 
+     +'NWS', iret)
+      call ncaptc (ncid, NCGLOBAL, 'basetime', NCCHAR, 17, 
+     +'88/10/25 12:00:00', iret)
+
+c
+c     char
+c
+
+      call ncaptc (ncid, chid, 'longname', NCCHAR, 11,
+     +'test string', iret)
+
+      call ncaptc (ncid, chid, 'id', NCCHAR, 1,
+     +'a', iret)
+
+      return
+      end
+
+c
+c     initialize variables in labelled common blocks
+c
+      block data
+      common /cdims/ dimnam
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+      common /varn/varnam
+      common /atts/attname, gattnam
+      integer  latdim, londim, leveldim, timedim, lendim
+
+c     should include 'netcdf.inc' for MAXNCDIM, but it has EXTERNAL
+c     declaration, which is not permitted in a BLOCK DATA unit.
+
+c      integer dimsiz(MAXNCDIM)
+      integer dimsiz(32)
+c      character*31 dimnam(MAXNCDIM)
+      character*31 dimnam(32)
+      character*31 varnam(7)
+      character*31 attname(2,7)
+      character*31 gattnam(2)
+
+      data dimnam /'time', 'lat', 'lon', 'level',
+     + 'length', 27*'0'/
+      data dimsiz /4, 5, 5, 4, 80, 27*0/
+      data varnam/'bytev', 'shortv', 'longv', 'floatv', 'doublev', 
+     + 'chv', 'cv'/
+      
+      data attname/'validrange', '0', 'validrange', '0', 'validrange',
+     + '0', 'validrange', '0', 'validrange', '0', 'longname', 'id',
+     + '0', '0'/
+      data gattnam/'source','basetime'/
+      end
+
+
+c
+c     subroutine to test ncddef
+c
+
+      subroutine tncddef(ncid)
+      include 'netcdf.inc'
+      integer ncid
+
+c     sizes of dimensions of 'test.nc' and 'copy.nc'
+      integer  ndims
+      parameter(ndims=5)
+c dimension ids
+      integer  latdim, londim, leveldim, timedim, lendim
+      integer iret
+c     function to define a netCDF dimension
+      integer dimsiz(MAXNCDIM)
+      character*31 dimnam(MAXNCDIM)
+      
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+      common /cdims/ dimnam
+
+c define dimensions
+      timedim = ncddef(ncid, dimnam(1), NCUNLIM, iret)
+      latdim = ncddef(ncid, dimnam(2), dimsiz(2), iret)
+      londim = ncddef(ncid, dimnam(3), dimsiz(3), iret)
+      leveldim = ncddef(ncid, dimnam(4), dimsiz(4), iret)
+      lendim = ncddef(ncid, dimnam(5), dimsiz(5), iret)
+      return
+      end
+c
+c     subroutine to test ncinq, ncdinq, ncdid, ncvinq, ncanam
+c     and ncainq
+c
+      subroutine tncinq(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+
+c     netCDF id
+      integer ncid
+c     returned number of dimensions
+      integer ndims
+c     returned number of variables
+      integer nvars
+c     returned number of global attributes
+      integer natts
+c     returned id of the unlimited dimension
+      integer recdim
+c     returned error code
+      integer iret
+c     returned name of record dimension
+      character*31 recnam
+c     returned size of record dimension
+      integer recsiz
+c     loop control variables
+      integer i, j, k
+c     returned size of dimension
+      integer dsize
+c     returned dimension ID
+      integer dimid
+c     returned dimension name
+      character*31 dname
+c     returned variable name
+      character*31 vname
+c     returned attribute name
+      character*31 attnam
+c     returned netCDF datatype of variable
+      integer vartyp
+c     returned number of variable dimensions
+      integer nvdims
+c     returned number of variable attributes
+      integer nvatts
+c     returned vector of nvdims dimension IDS corresponding to the
+c     variable dimensions
+      integer vdims(MAXNCDIM)
+c     returned attribute length
+      integer attlen
+c     returned attribute type
+      integer attype
+      character*31 dimnam(MAXNCDIM)
+      character*31 varnam(7)
+      character*31 attname(2,7)
+      character*31 gattnam(2)
+      integer vdlist(5,7), vtyp(7), vndims(7), vnatts(7)
+      integer attyp(2,7),atlen(2,7),gattyp(2),gatlen(2)
+      integer timedim,latdim,londim,leveldim,lendim
+      integer dimsiz(MAXNCDIM)
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+      common /varn/varnam
+      common /atts/attname, gattnam
+      common /cdims/ dimnam
+
+      data vdlist/1,0,0,0,0,1,0,0,0,0,2,0,0,0,0,4,3,2,1,0,4,3,2,1,0,
+     + 5,1,0,0,0,1,0,0,0,0/
+      data vtyp/NCBYTE, NCSHORT, NCLONG, NCFLOAT, NCDOUBLE, NCCHAR,
+     + NCCHAR/
+      data vndims/1,1,1,4,4,2,1/
+      data vnatts/1,1,1,1,1,2,0/
+      data attyp/NCBYTE, 0, NCSHORT, 0, NCLONG, 0, NCFLOAT, 0,
+     + NCDOUBLE, 0, NCCHAR, NCCHAR, 0, 0/
+      data atlen/2,0,2,0,2,0,2,0,2,0,11,1, 0, 0/
+      data gattyp/NCCHAR,NCCHAR/
+      data gatlen/3,17/
+
+      ncid = ncopn (cdfname, NCNOWRIT, iret)
+      call ncinq (ncid, ndims, nvars, natts, recdim, iret)
+      if (ndims .ne. 5) write(*,*) 'error in ncinq or ncddef'
+      if (nvars .ne. 7) write(*,*) 'error in ncinq or ncvdef'
+      if (natts .ne. 2) write(*,*) 'error in ncinq or ncapt'
+      call ncdinq (ncid, recdim, recnam, recsiz, iret)
+      if (recnam .ne. 'time') write(*,*) 'error: bad recdim from ncinq'
+c
+c     dimensions
+c
+      do 10 i = 1, ndims
+         call ncdinq (ncid, i, dname, dsize, iret)
+         if (dname .ne. dimnam(i)) write(*,*)
+     + 'error in ncdinq or ncddef, dname=', dname
+         if (dsize .ne. dimsiz(i)) write(*,*)
+     + 'error in ncdinq or ncddef, dsize=',dsize
+         dimid = ncdid (ncid, dname, iret)
+         if (dimid .ne. i) write(*,*)
+     +      'error in ncdinq or ncddef, dimid=', dimid
+ 10   continue
+c
+c     variables
+c
+      do 30 i = 1, nvars
+         call ncvinq (ncid, i, vname, vartyp, nvdims,
+     +        vdims, nvatts, iret)
+         if (vname .ne. varnam(i)) write(*,*)
+     +  'error: from ncvinq, wrong  name returned: ', vname,
+     +  ' .ne. ', varnam(i)
+         if (vartyp .ne. vtyp(i)) write(*,*)
+     + 'error: from ncvinq, wrong type returned: ', vartyp,
+     + ' .ne. ', vtyp(i)
+         if (nvdims .ne. vndims(i)) write(*,*)
+     + 'error: from ncvinq, wrong num dims returned: ', vdims,
+     + ' .ne. ', vndims(i)
+         do 35 j = 1, nvdims
+            if (vdims(j) .ne. vdlist(j,i)) write(*,*)
+     + 'error: from ncvinq wrong dimids: ', vdims(j),
+     + ' .ne. ', vdlist(j,i)
+ 35      continue
+         if (nvatts .ne. vnatts(i)) write(*,*)
+     + 'error in ncvinq or ncvdef'
+c
+c     attributes
+c
+         do 45 k = 1, nvatts
+            call ncanam (ncid, i, k, attnam, iret)
+            call ncainq (ncid, i, attnam, attype, attlen, iret)
+            if (attnam .ne. attname(k,i)) write(*,*)
+     + 'error in ncanam or ncapt'
+            if (attype .ne. attyp(k,i)) write(*,*)
+     + 'error in ncainq or ncapt'
+            if (attlen .ne. atlen(k,i)) write(*,*)
+     + 'error in ncainq or ncapt'
+ 45      continue
+ 30   continue
+      do 40 i = 1, natts
+         call ncanam (ncid, NCGLOBAL, i, attnam, iret)
+         call ncainq (ncid, NCGLOBAL, attnam, attype, attlen, iret)
+         if (attnam .ne. gattnam(i)) write(*,*)
+     + 'error in ncanam or ncapt'
+         if (attype .ne. gattyp(i)) write(*,*)
+     + 'error in ncainq or ncapt'
+         if (attlen .ne. gatlen(i)) write(*,*)
+     + 'error in ncainq or ncapt'
+ 40   continue
+      call ncclos(ncid, iret)
+      return
+      end
+      
+      
+      
+c     subroutine to test ncredf, ncdren, ncvren, ncaren, and 
+c     ncendf
+
+      subroutine tncredf(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+      character*31 attname(2,7)
+      character*31 gattnam(2)
+      common /atts/attname, gattnam
+      common /cdims/ dimnam
+      character*31 dimnam(MAXNCDIM)
+      character*31 varnam(7)
+      common /varn/varnam
+      integer ncid, iret, latid, varid
+
+      dimnam(2) = 'latitude'
+      varnam(4) = 'realv'
+      attname(1,6) = 'stringname'
+      gattnam(1) = 'agency'
+      ncid = ncopn(cdfname, NCWRITE, iret)
+      call ncredf(ncid, iret)
+      latid = ncdid(ncid, 'lat', iret)
+      call ncdren(ncid, latid, 'latitude', iret)
+      varid = ncvid(ncid, 'floatv', iret)
+      call ncvren(ncid, varid, 'realv', iret)
+      varid = ncvid(ncid, 'chv', iret)
+      call ncaren(ncid, varid, 'longname', 'stringname', iret)
+      call ncaren(ncid, NCGLOBAL, 'source', 'agency', iret)
+      call ncendf(ncid, iret)
+      call ncclos(ncid, iret)
+      return
+      end
+c     
+c     subroutine to test ncvdef
+c
+
+      subroutine tncvdef(ncid)
+      include 'netcdf.inc'
+      integer ncid
+
+c     function to define a netCDF variable
+      integer dimsiz(MAXNCDIM)
+      integer  latdim, londim, leveldim, timedim, lendim
+      common /dims/timedim, latdim, londim, leveldim, lendim, 
+     + dimsiz
+
+c variable ids
+      integer  bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+
+c variable shapes
+      integer  bdims(1), fdims(4), ddims(4), ldims(1), sdims(1) 
+      integer chdims(2), cdims(1)
+
+      integer iret
+c
+c define variables
+c
+c     byte
+c 
+      bdims(1) = timedim
+      bid = ncvdef(ncid, 'bytev', NCBYTE, 1, bdims, iret)
+c
+c     short
+c
+      sdims(1) = timedim
+      sid = ncvdef (ncid, 'shortv', NCSHORT, 1, sdims, iret)
+c
+c     long
+c
+      ldims(1) = latdim
+      lid = ncvdef (ncid, 'longv', NCLONG, 1, ldims, iret)
+c
+c     float
+c
+      fdims(4) = timedim
+      fdims(1) = leveldim
+      fdims(2) = londim
+      fdims(3) = latdim
+      fid = ncvdef (ncid, 'floatv', NCFLOAT, 4, fdims, iret)
+c
+c     double
+c
+      ddims(4) = timedim
+      ddims(1) = leveldim
+      ddims(2) = londim
+      ddims(3) = latdim
+      did = ncvdef (ncid, 'doublev', NCDOUBLE, 4, ddims, iret)
+c
+c     char
+c
+      chdims(2) = timedim
+      chdims(1) = lendim
+      chid = ncvdef (ncid, 'chv', NCCHAR, 2, chdims, iret)
+
+      cdims(1) = timedim
+      cid = ncvdef (ncid, 'cv', NCCHAR, 1, cdims, iret)
+
+
+      return
+      end
+
+
+c    
+c     subroutine to test ncvgt and ncvgtc
+c
+      subroutine tncvgt(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+
+      integer ndims, times, lats, lons, levels, lenstr
+      parameter (times=4, lats=5, lons=5, levels=4)
+
+      integer start(MAXNCDIM), count(MAXNCDIM)
+      integer ncid, iret, i, m
+      integer  latdim, londim, leveldim, timedim, lendim
+      integer dimsiz(MAXNCDIM)
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+
+      integer bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+      integer itime, ilev, ilat, ilon
+
+c     arrays of data values to be read
+      byte barray(times), byval(times)
+      integer*2 sarray(times), shval(times)
+      integer larray(lats)
+      real farray(levels, lats, lons, times)
+      double precision darray(levels, lats, lons, times)
+c     character array of data values to be read
+      character*31 string
+      character*31 varnam
+      integer nvars, natts, recdim
+      integer vartyp, nvdims, vdims(MAXVDIMS), nvatts
+
+      data start/1,1,1,1, 28*0/, count/levels, lats, lons, times, 28*0/
+      data byval /97, 98, 99, 100/
+      data shval /10, 11, 12, 13/
+
+      ncid = ncopn (cdfname, NCWRITE, iret)
+c     get number of variables in netCDF
+      call ncinq (ncid, ndims, nvars, natts, recdim, iret)
+      do 5 m = 1, nvars-1
+c     get variable name, datatype, number of dimensions
+c     vector of dimension ids, and number of variable attributes
+         call ncvinq (ncid, m, varnam, vartyp, nvdims, vdims,
+     +                nvatts, iret)
+         if (vartyp .eq. NCBYTE) then
+c
+c     byte
+c
+            count(1) = times
+            call ncvgt (ncid, m, start, count, barray, iret)
+            do 10 i = 1, times
+               if (barray(i) .ne. byval(i)) then 
+                  write(*,*) 'ncvgt of bytes, got ', barray(i), ' .ne. '
+     +			     , byval(i)
+               end if
+ 10         continue
+         else if (vartyp .eq. NCSHORT) then
+c
+c     short
+c
+            count(1) = times
+            call ncvgt (ncid, m, start, count, sarray, iret)
+            do 20 i = 1, times
+               if (sarray(i) .ne. shval(i)) then 
+                  write(*,*) 'ncvgt of short, got ', sarray(i), ' .ne. '
+     +			     , shval(i)
+               end if
+ 20         continue
+         else if (vartyp .eq. NCLONG) then
+c     
+c     long
+c
+            count(1) = lats
+            call ncvgt (ncid, m, start, count, larray, iret)
+            do 30 i = 1, lats
+               if (larray(i) .ne. 1000) then 
+                  write(*,*) 'long error in ncvgt'
+               end if
+ 30         continue
+         else if (vartyp .eq. NCFLOAT) then
+c     
+c     float
+c
+            count(1) = levels
+            call ncvgt (ncid, m, start, count, farray, iret)
+            i = 0
+            do 40 itime = 1,times
+               do 40 ilon = 1, lons
+                  do 40 ilat = 1, lats
+                     do 40 ilev = 1, levels
+                        i = i + 1
+                        if (farray(ilev, ilat, ilon, itime) .ne.
+     + real(i)) then
+                           write (*,*) 'float error in ncvgt'
+                        end if
+ 40         continue
+         else if (vartyp .eq. NCDOUBLE) then
+c
+c     double
+c
+            count(1) = levels
+            call ncvgt (ncid, m, start, count, darray, iret)
+            i = 0
+            do 50 itime = 1, times
+               do 50 ilon = 1, lons
+                  do 50 ilat = 1, lats
+                     do 50 ilev = 1, levels
+                        i = i + 1
+                        if (darray(ilev, ilat, ilon, itime) .ne.
+     +                       real(i)) then
+                           write(*,*) 'double error in ncvgt:', i,
+     +              darray(ilev, ilat, ilon, itime), '.ne.', real(i)
+                        end if
+ 50         continue
+         else 
+c     
+c     char
+c
+	    count(1) = 3
+	    count(2) = 4
+	    lenstr = 31
+            call ncvgtc (ncid, m, start, count, string, lenstr, iret)
+            if (string .ne. 'testhikin of') then 
+               write(*,*) 'error in ncvgt, returned string =', string
+            end if
+         end if
+ 5    continue
+      call ncclos(ncid, iret)
+      return
+      end
+
+      
+      subroutine tncvgt1(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+
+      integer ncid, iret
+      integer  latdim, londim, leveldim, timedim, lendim
+      integer dimsiz(MAXNCDIM)
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+
+      integer bindx, sindx, lindx, findx(4), dindx(4), cindx
+
+      integer bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+
+      byte bvalue
+      integer*2 svalue
+      integer lvalue
+      real fvalue
+      double precision dvalue
+      character*1 c
+      real epsilon
+      double precision onethird
+
+      data epsilon /.000001/
+      data lindx/1/, bindx/1/, sindx/1/, findx/1,1,1,1/
+     +dindx/1,1,1,1/, cindx/1/
+      data onethird/0.3333333333D0/
+      
+      ncid = ncopn (cdfname, NCNOWRIT, iret)
+c
+c     test ncvgt1 for byte
+c
+      call ncvgt1 (ncid, bid, bindx, bvalue, iret)
+      if (bvalue .ne. ichar('z')) write(*,*) 'error in ncvgt1 byte:',
+     + bvalue, ' .ne.', ichar('z')
+c
+c     test ncvgt1 for short
+c
+      call ncvgt1 (ncid, sid, sindx, svalue, iret)
+      if (svalue .ne. 10) write(*,*) 'error in ncvgt1 short:',
+     + svalue, ' .ne.', 10
+c     
+c     test ncvgt1 for long
+c
+      call ncvgt1 (ncid, lid, lindx, lvalue, iret)
+      if (lvalue .ne. 1000) write(*,*) 'error in ncvgt1 long:',
+     + lvalue,  ' .ne.', 1000
+c
+c     test ncvgt1 for float
+c
+      call ncvgt1 (ncid, fid, findx, fvalue, iret)
+      if (abs(fvalue - 3.14159) .gt. epsilon) write(*,*)
+     + 'error in ncvgt1 float:', fvalue, ' not close to', 3.14159
+c
+c     test ncvgt1 for double
+c
+      call ncvgt1 (ncid, did, dindx, dvalue, iret)
+      if (abs(dvalue - onethird) .gt. epsilon) write(*,*)
+     + 'error in ncvgt1 double:', dvalue, ' not close to',
+     +     onethird
+c
+c     test ncvg1c for char
+c
+      call ncvg1c (ncid, cid, cindx, c, iret)
+      if (c .ne. 'a') write(*,*) 'error in ncvg1c'
+      call ncclos(ncid, iret)
+      return
+      end
+
+      
+      
+c
+c     subroutine to test ncvpt and ncvptc
+c
+      subroutine tncvpt(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+
+c     size of dimensions
+      integer times, lats, lons, levels
+      parameter (times=4, lats=5, lons=5, levels=4)
+
+      integer ncid, iret
+c     loop control variables
+      integer itime, ilev, ilon, ilat, i
+      integer  latdim, londim, leveldim, timedim, lendim
+      integer dimsiz(MAXNCDIM)
+      common /dims/timedim, latdim, londim, leveldim, lendim,
+     + dimsiz
+      integer lenstr
+      integer bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+
+c     vector of integers specifying the corner of the  hypercube
+c     where the first of the data values will be written
+      integer start(MAXNCDIM)
+c     vector of integers specifying the edge lengths from the
+c     corner of the hypercube where the first of the data values
+c     will be written
+      integer count(MAXNCDIM)
+
+c     arrays of data values to be written
+      byte barray(times)
+      integer*2 sarray(times)
+      integer larray(lats)
+      real farray(levels, lats, lons, times)
+      double precision darray(levels, lats, lons, times)
+      character*31 string
+
+      data start/1,1,1,1, 28*0/, count/levels, lats, lons, times, 28*0/
+      data barray /97, 98, 99, 100/
+      data sarray /10, 11, 12, 13/
+
+      ncid = ncopn (cdfname, NCWRITE, iret)
+
+c
+c     byte
+c
+      count(1) = times
+      call ncvpt (ncid, bid, start, count, barray, iret)
+c
+c     short
+c
+      count(1) = times
+      call ncvpt (ncid, sid, start, count, sarray, iret)
+c
+c     long
+c
+      do 30 i = 1,lats
+         larray(i) = 1000
+ 30   continue
+      count(1) = lats
+      call ncvpt (ncid, lid, start, count, larray, iret)
+c
+c     float
+c
+      i = 0
+      do 40 itime = 1,times
+         do 40 ilon = 1, lons
+            do 40 ilat = 1, lats
+               do 40 ilev = 1, levels
+                  i = i + 1
+                  farray(ilev, ilat, ilon, itime) = real(i)
+ 40   continue
+      count(1) = levels
+      call ncvpt (ncid, fid, start, count, farray, iret)
+c
+c     double
+c
+      i = 0
+      do 50 itime = 1, times
+         do 50 ilon = 1, lons
+            do 50 ilat = 1, lats
+               do 50 ilev = 1, levels
+                  i = i + 1
+                  darray(ilev, ilat, ilon, itime) = real(i)
+ 50   continue
+      count(1) = levels
+      call ncvpt (ncid, did, start, count, darray, iret)
+c
+c     char
+c
+      start(1) = 1
+      start(2) = 1
+      count(1) = 4
+      count(2) = 4
+      lenstr = 31	
+      string = 'testthiskind of '
+      call ncvptc (ncid, chid,start, count, string, lenstr, iret)
+      call ncclos(ncid, iret)
+      return
+      end
+
+      
+      subroutine tncvpt1(cdfname)
+      include 'netcdf.inc'
+      character*31 cdfname
+
+
+      integer iret, ncid
+      integer  latdim, londim, leveldim, timedim, lendim
+      integer dimsiz(MAXNCDIM)
+      common /dims/timedim, latdim, londim, leveldim, lendim, 
+     + dimsiz
+
+      integer bindx, sindx, lindx, findx(4), dindx(4), cindx
+
+      integer lvalue
+      integer*2 svalue
+      byte bvalue
+      double precision onethird
+      integer bid, sid, lid, fid, did, cid, chid
+      common /vars/bid, sid, lid, fid, did, cid, chid
+      data lindx/1/, bindx/1/, sindx/1/, findx/1,1,1,1/
+     +dindx/1,1,1,1/, cindx/1/
+      data lvalue /1000/
+      data svalue/10/
+      data onethird/0.3333333333D0/
+
+      bvalue = ichar('z')
+      
+      ncid = ncopn (cdfname, NCWRITE, iret)
+c
+c     test ncvpt1 for byte
+c
+      call ncvpt1 (ncid, bid, bindx, bvalue, iret)
+c
+c     test ncvpt1 for short
+c
+      call ncvpt1 (ncid, sid, sindx, svalue, iret)
+c     
+c     test ncvpt1 for long
+c
+      call ncvpt1 (ncid, lid, lindx, lvalue, iret)
+c
+c     test ncvpt1 for float
+c
+      call ncvpt1 (ncid, fid, findx, 3.14159, iret)
+c
+c     test ncvpt1 for double
+c
+      call ncvpt1 (ncid, did, dindx, onethird, iret)
+c
+c     test ncvp1c for char
+c
+      call ncvp1c (ncid, cid, cindx, 'a', iret)
+      call ncclos (ncid, iret)
+      return
+      end
diff -urN HDF4.1r5/mfhdf/fortran/config/jackets-darwin.c hdf-new/mfhdf/fortran/config/jackets-darwin.c
--- HDF4.1r5/mfhdf/fortran/config/jackets-darwin.c	Wed Dec 31 19:00:00 1969
+++ hdf-new/mfhdf/fortran/config/jackets-darwin.c	Mon Dec  8 19:43:58 2003
@@ -0,0 +1,2196 @@
+/*
+ *	Copyright 1990, University Corporation for Atmospheric Research
+ *      See netcdf/COPYRIGHT file for copying and redistribution conditions.
+ */
+/* $Id: hdf-4.1r4-2.patch,v 1.1 2001/09/19 14:46:18 jswhit Exp $ */
+/*
+ * OVERVIEW
+ *
+ * This file contains jacket routines written in C for interfacing Fortran
+ * netCDF function calls to the actual C binding for the NetCDF.  This code
+ * is written explicitly for Sun.  In general, these functions handle
+ * character-string parameter conventions, convert between
+ * column-major-order arrays and row-major-order arrays, and map between
+ * array indices beginning at one and array indices beginning at zero.
+ *
+ */
+
+/* LINTLIBRARY */
+#include	<ctype.h>
+#include        <string.h>
+#include	<stdlib.h>
+#include	<stdio.h>
+#ifdef HDF
+#include        "local_nc.h"
+#else /* HDF */
+#include	"netcdf.h"
+#endif /* HDF */
+
+
+
+
+
+#if !NC_OLD_FILLVALUES
+
+struct ncfils {			/* This will be a common block from Fortran */
+    double dd;
+#ifdef __alpha
+    int ll;
+#else
+    long ll;
+#endif
+    float ff;
+    short ss;
+    char cc;
+    char bb;
+} ncfils_ = {
+    FILL_DOUBLE,
+    FILL_LONG,
+    FILL_FLOAT,
+    FILL_SHORT,
+    FILL_CHAR,
+    FILL_BYTE
+};
+
+#else	/* NC_OLD_FILLVALUES below */
+
+/*
+ * This section is provided for backward compatibility only.  Using
+ * XDR infinities for floating-point fill values has caused more problems
+ * than it has solved.  We encourage you to define your own data-specific
+ * fill values rather than use default ones.  
+ * If, however, you *must* use default fill values, then you should use
+ * the above fill values rather than the ones in this section.
+ */
+
+struct ncfils {			/* This will be a common block from Fortran */
+    double dd;
+#ifdef __alpha
+    int ll;
+#else
+    long ll;
+#endif
+    float ff;
+    short ss;
+    char cc;
+    char bb;
+} ncfils_ = {
+    XDR_D_INFINITY,		/* You may have to insert a constant here */
+    FILL_LONG,
+    XDR_F_INFINITY,		/* You may have to insert a constant here */
+    FILL_SHORT,
+    FILL_CHAR,
+    FILL_BYTE
+};
+
+#endif	/* NC_OLD_FILLVALUES above */
+
+
+/*
+ * global integer used for suppressing error messages and determining
+ * the fatality of errors.
+ */
+extern int ncopts;		/* default is (NC_FATAL | NC_VERBOSE) */
+
+/* global integer that contains a netCDF-specific error code */
+extern int ncerr;
+
+/* blank fill C string to make FORTRAN string */
+static void
+fcdcpy (fstring, fslen, sstring)
+    char *fstring;		/* output string to be blank-filled */
+    int fslen;			/* length of output string */
+    char *sstring;		/* input string, null-terminated */
+{
+    int i, len = strlen(sstring);
+
+    for (i = 0; i < len; i++)
+	*(fstring + i) = *(sstring + i);
+    for (i = len; i < fslen; i++)
+	*(fstring + i) = ' ';
+}
+
+
+static void
+reverse (array, length)
+    int array[];		/* array to be reversed */
+    int length;			/* length of array */
+{
+    int temp, i, j;
+
+    for (i = 0, j = length - 1; i < j; i++, j--) {
+	temp = array[i];
+	array[i] = array[j];
+	array[j] = temp;
+    }
+}
+
+
+static void
+revlongs (array, length)
+    long array[];		/* array to be reversed */
+    int length;			/* length of array */
+{
+    int i, j;
+    long temp;
+
+    for (i = 0, j = length - 1; i < j; i++, j--) {
+	temp = array[i];
+	array[i] = array[j];
+	array[j] = temp;
+    }
+}
+
+
+/* error handling function */
+static void
+handle_err (pname, rcode)
+    char *pname;		/* procedure name */
+    int rcode;			/* error return */
+{
+    cdf_routine_name = pname;
+    NCadvise(rcode, "string won't fit in CHARACTER variable provided");
+}
+
+/* copy function used to copy strings with embedded blanks */
+static void
+fstrncpy (target, source, maxlen)
+    char *target;		/* space to be copied into */
+    char *source;		/* string to be copied */
+    int maxlen;			/* maximum length of *source */
+{
+    while (maxlen-- && *source != '\0')
+	*target++ = *source++;
+    *target = '\0';
+}
+
+/* copy function used to copy strings terminated with blanks */
+static void
+nstrncpy (target, source, maxlen)
+    char *target;		/* space to be copied into */
+    char *source;		/* string to be copied */
+    int maxlen;			/* maximum length of *source */
+{
+    while (maxlen-- && *source != ' ')
+	*target++ = *source++;
+    *target = '\0';
+}
+
+
+/*
+ * Compute product of dimensions.
+ */
+static long
+dimprod (dims, ndims)
+     long *dims;			/* list of dimensions */
+     int ndims;			/* number of dimensions in list */
+{
+    long *ip;
+    long prod = 1;
+
+    for (ip = dims; ip < &dims[ndims]; ip++)
+      prod *= *ip;
+    return prod;
+}
+
+
+#ifdef FORTRAN_HAS_NO_BYTE
+/*
+ * Convert multi-dimensional array of bytes stored in ints to packed array of
+ * bytes, in malloc'ed space.  Returns pointer to bytes or NULL if malloc
+ * failed.
+ */
+static char *
+itob(ints, dims, ndims)
+     int *ints;			/* multi-dimensional array of integers */
+     long *dims;			/* list of dimensions */
+     int ndims;			/* number of dimensions in list */
+{
+    long iocount = dimprod (dims, ndims);	/* product of dimensions */
+    char *bytes = (char *) malloc (iocount * sizeof (char));
+    int *ip;
+    char *bp = bytes;
+
+    if (bytes != NULL)
+      for (ip = ints; iocount > 0; iocount--)
+	*bp++ = (char) *ip++;
+    return bytes;
+}
+
+/*
+ * Convert a generalized multi-dimensional array of bytes stored in ints to 
+ * packed array of bytes, in malloc'ed space.  Returns pointer to bytes or 
+ * NULL if malloc failed.
+ */
+static char *
+itobg(ints, dims, basis, ndims)
+     int *ints;			/* multi-dimensional array of integers */
+     long *dims;			/* list of dimensions */
+     long *basis;			/* memory access basis vector */
+     int ndims;			/* number of dimensions in list */
+{
+    long iocount = dimprod (dims, ndims);	/* product of dimensions */
+    char *bytes = (char *) malloc (iocount * sizeof (char));
+
+    if (bytes != NULL && iocount > 0) {
+	int	idim;
+	char	*bp	= bytes;
+	char	*ip	= (char*)ints;
+	long	length[MAX_NC_DIMS];
+	long	coords[MAX_NC_DIMS];
+
+	for (idim = 0; idim < ndims; ++idim) {
+	    length[idim]	= dims[idim]*basis[idim];
+	    coords[idim]	= 0;
+	}
+
+	for (;;) {
+	    *bp++	= (char)*(int*)ip;
+	    idim	= ndims - 1;
+	carry:
+	    ip	+= basis[idim];
+	    if (++coords[idim] >= dims[idim]) {
+		coords[idim]	= 0;
+		ip		-= length[idim];
+		if (--idim < 0)
+		    break;
+		goto carry;
+	    }
+        }
+    }
+
+    return bytes;
+}
+
+/*
+ * Convert a packed array of bytes into a generalized multi-dimensional array
+ * of ints.
+ */
+static void
+btoig(bytes, ints, dims, basis, ndims)
+     char *bytes;		/* packed array of bytes */
+     int *ints;			/* multi-dimensional array of integers */
+     long *dims;		/* list of dimensions */
+     long *basis;		/* memory access basis vector */
+     int ndims;			/* number of dimensions in list */
+{
+    if (dimprod (dims, ndims) > 0) {
+	int	idim;
+	char	*bp	= bytes;
+	char	*ip	= (char*)ints;
+	long	length[MAX_NC_DIMS];
+	long	coords[MAX_NC_DIMS];
+
+	for (idim = 0; idim < ndims; ++idim) {
+	    length[idim]	= dims[idim]*basis[idim];
+	    coords[idim]	= 0;
+	}
+
+	for (;;) {
+	    *(int*)ip	= *bp++;
+	    idim	= ndims - 1;
+	carry:
+	    ip	+= basis[idim];
+	    if (++coords[idim] >= dims[idim]) {
+		coords[idim]	= 0;
+		ip		-= length[idim];
+		if (--idim < 0)
+		    break;
+		goto carry;
+	    }
+        }
+    }
+}
+#endif /* FORTRAN_HAS_NO_BYTE */
+
+#ifdef FORTRAN_HAS_NO_SHORT
+/*
+ * Convert multi-dimensional array of shorts stored in ints to packed array of
+ * shorts, in malloc'ed space.  Returns pointer to shorts or NULL if malloc
+ * failed.
+ */
+static short *
+itos(ints, dims, ndims)
+     int *ints;		/* multi-dimensional array of ints */
+     long *dims;			/* list of dimensions */
+     int ndims;			/* number of dimensions in list */
+{
+    long iocount = dimprod (dims, ndims);	/* product of dimensions */
+    short *shorts = (short *) malloc (iocount * sizeof (short));
+    int *ip;
+    short *sp = shorts;
+
+    if (shorts != NULL)
+      for (ip = ints; iocount > 0; iocount--)
+	*sp++ = (short) *ip++;
+    return shorts;
+}
+
+/*
+ * Convert a generalized multi-dimensional array of shorts stored in ints to 
+ * packed array of shorts, in malloc'ed space.  Returns pointer to shorts or 
+ * NULL if malloc failed.
+ */
+static short *
+itosg(ints, dims, basis, ndims)
+     int *ints;			/* multi-dimensional array of integers */
+     long *dims;			/* list of dimensions */
+     long *basis;			/* memory access basis vector */
+     int ndims;			/* number of dimensions in list */
+{
+    long iocount = dimprod (dims, ndims);	/* product of dimensions */
+    short *shorts = (short *) malloc (iocount * sizeof (short));
+
+    if (shorts != NULL && iocount > 0) {
+	int	idim;
+	char	*ip	= (char*)ints;
+	short	*sp	= shorts;
+	long	length[MAX_NC_DIMS];
+	long	coords[MAX_NC_DIMS];
+
+	for (idim = 0; idim < ndims; ++idim) {
+	    length[idim]	= dims[idim]*basis[idim];
+	    coords[idim]	= 0;
+	}
+
+	for (;;) {
+	    *sp++	= (short)*(int*)ip;
+	    idim	= ndims - 1;
+	carry:
+	    ip	+= basis[idim];
+	    if (++coords[idim] >= dims[idim]) {
+		coords[idim]	= 0;
+		ip		-= length[idim];
+		if (--idim < 0)
+		    break;
+		goto carry;
+	    }
+        }
+    }
+
+    return shorts;
+}
+
+/*
+ * Convert a packed array of shorts into a generalized multi-dimensional array
+ * of ints.
+ */
+static void
+stoig(shorts, ints, dims, basis, ndims)
+     short *shorts;		/* packed array of shorts */
+     int *ints;			/* multi-dimensional array of integers */
+     long *dims;		/* list of dimensions */
+     long *basis;		/* memory access basis vector */
+     int ndims;			/* number of dimensions in list */
+{
+    if (dimprod (dims, ndims) > 0) {
+	int	idim;
+	short	*sp	= shorts;
+	char	*ip	= (char*)ints;
+	long	length[MAX_NC_DIMS];
+	long	coords[MAX_NC_DIMS];
+
+	for (idim = 0; idim < ndims; ++idim) {
+	    length[idim]	= dims[idim]*basis[idim];
+	    coords[idim]	= 0;
+	}
+
+	for (;;) {
+	    *(int*)ip	= *sp++;
+	    idim	= ndims - 1;
+	carry:
+	    ip	+= basis[idim];
+	    if (++coords[idim] >= dims[idim]) {
+		coords[idim]	= 0;
+		ip		-= length[idim];
+		if (--idim < 0)
+		    break;
+		goto carry;
+	    }
+        }
+    }
+}
+#endif /* FORTRAN_HAS_NO_SHORT */
+
+#ifdef __alpha
+/*
+ * Convert multi-dimensional array of NCLONGs stored in ints to packed
+ * array of longs, in malloc'ed space.  Returns pointer to longs or NULL
+ * if malloc failed.
+ */
+static long *
+itol(ints, dims, ndims)
+    int		*ints;		/* multi-dimensional array of ints */
+    long	*dims;		/* list of dimensions */
+    int		ndims;		/* number of dimensions in list */
+{
+    long	iocount = dimprod (dims, ndims);
+    long	*longs = (long *) malloc (iocount * sizeof (long));
+    int		*ip;
+    long	*lp = longs;
+
+    if (longs != NULL)
+	for (ip = ints; iocount > 0; iocount--)
+	    *lp++ = (long) *ip++;
+    return longs;
+}
+
+/*
+ * Convert a generalized multi-dimensional array of longs stored in ints to 
+ * packed array of longs, in malloc'ed space.  Returns pointer to longs or 
+ * NULL if malloc failed.
+ */
+static long *
+itolg(ints, dims, imap, ndims)
+    int		*ints;		/* multi-dimensional array of integers */
+    long	*dims;		/* list of dimensions */
+    long	*imap;		/* memory access index mapping vector */
+    int		ndims;		/* number of dimensions in list */
+{
+    long	iocount = dimprod (dims, ndims);
+    long	*longs = (long *) malloc (iocount * sizeof (long));
+
+    if (longs != NULL && iocount > 0) {
+	int	idim;
+	char	*ip	= (char*)ints;
+	long	*lp	= longs;
+	long	length[MAX_NC_DIMS];
+	long	coords[MAX_NC_DIMS];
+
+	for (idim = 0; idim < ndims; ++idim) {
+	    length[idim]	= dims[idim]*imap[idim];
+	    coords[idim]	= 0;
+	}
+
+	for (;;) {
+	    *lp++	= (long)*(int*)ip;
+	    idim	= ndims - 1;
+	carry:
+	    ip	+= imap[idim];
+	    if (++coords[idim] >= dims[idim]) {
+		coords[idim]	= 0;
+		ip		-= length[idim];
+		if (--idim < 0)
+		    break;
+		goto carry;
+	    }
+        }
+    }
+
+    return longs;
+}
+
+/*
+ * Convert a packed array of longs into a generalized multi-dimensional array
+ * of ints.
+ */
+static void
+ltoig(longs, ints, dims, imap, ndims)
+    long	*longs;		/* packed array of longs */
+    int		*ints;		/* multi-dimensional array of integers */
+    long	*dims;		/* list of dimensions */
+    long	*imap;		/* memory access index mapping vector */
+    int		ndims;		/* number of dimensions in list */
+{
+    if (dimprod (dims, ndims) > 0) {
+	int	idim;
+	long	*lp	= longs;
+	char	*ip	= (char*)ints;
+	long	length[MAX_NC_DIMS];
+	long	coords[MAX_NC_DIMS];
+
+	for (idim = 0; idim < ndims; ++idim) {
+	    length[idim]	= dims[idim]*imap[idim];
+	    coords[idim]	= 0;
+	}
+
+	for (;;) {
+	    *(int*)ip	= *lp++;
+	    idim	= ndims - 1;
+	carry:
+	    ip	+= imap[idim];
+	    if (++coords[idim] >= dims[idim]) {
+		coords[idim]	= 0;
+		ip		-= length[idim];
+		if (--idim < 0)
+		    break;
+		goto carry;
+	    }
+        }
+    }
+}
+#endif	/* Alpha platform above */
+
+/* ------------ Sun FORTRAN jackets for netCDF Functions ------------ */
+
+/* used to set the C global variable ncopts from Fortran */
+void
+ncpopt_(val)
+    int		*val;	
+{
+    ncopts = *val;
+}
+
+
+/* used to get the C global variable ncopts from Fortran */
+void
+ncgopt_(val)
+    int		*val;	
+{
+    *val = ncopts;
+}
+
+/*
+ * creates a new netCDF file, returning a netCDF ID.  New netCDF
+ * file is placed in define mode.
+ */
+int
+nccre_(pathname, clobmode, rcode, pathnamelen)
+    char	*pathname;	
+    int		pathnamelen;
+    int		*clobmode;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int cdfid;
+
+    nstrncpy (name, pathname, pathnamelen);
+    if ((cdfid = nccreate (name, *clobmode)) != -1) {
+	*rcode = 0;
+	return (cdfid);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+
+/* opens an existing netCDF file for access */
+int
+ncopn_(pathname, rwmode, rcode, pathnamelen)
+    char	*pathname;	
+    int		pathnamelen;
+    int		*rwmode;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int cdfid;
+
+    nstrncpy (name, pathname, pathnamelen);
+    if ((cdfid = ncopen (name, *rwmode)) != -1) {
+	*rcode = 0;
+	return (cdfid);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+
+/* adds a new dimension to an open netCDF file in define mode */
+int
+ncddef_(cdfid, dimname, dimlen, rcode, dimnamelen)
+    int		*cdfid;	
+    char	*dimname;	
+    int		dimnamelen;
+    int		*dimlen;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int dimid;
+
+    nstrncpy (name, dimname, dimnamelen);
+    if ((dimid = ncdimdef (*cdfid, name, (long)*dimlen)) != -1) {
+	*rcode = 0;
+	return (dimid + 1);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+
+/*
+ * returns the ID of a netCDF dimension, given the name of the
+ * dimension
+ */
+int
+ncdid_(cdfid, dimname, rcode, dimnamelen)
+    int		*cdfid;	
+    char	*dimname;	
+    int		dimnamelen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int dimid;
+
+    nstrncpy (name, dimname, dimnamelen);
+    if ((dimid = ncdimid (*cdfid, name)) != -1) {
+	*rcode = 0;
+	return (dimid + 1);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+
+/* adds a new variable to an open netCDF file in define mode */
+int
+ncvdef_(cdfid, varname, datatype, ndims, dimarray, rcode, varnamelen)
+    int		*cdfid;	
+    char	*varname;	
+    int		varnamelen;
+    int		*datatype;	
+    int		*ndims;	
+    int		*dimarray;	
+    int		*rcode;	
+{
+    int varid, i, dimid[MAX_VAR_DIMS];
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, varname, varnamelen);
+    for (i = 0; i < *ndims; i++)
+	dimid[i] = dimarray[i] - 1;
+    reverse (dimid, *ndims);
+    if ((varid = ncvardef (*cdfid, name, (nc_type) *datatype, *ndims,
+			   dimid)) != -1) {
+	*rcode = 0;
+	return (varid + 1);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+
+/* returns the ID of a netCDF variable given its name */
+int
+ncvid_(cdfid, varname, rcode, varnamelen)
+    int		*cdfid;	
+    char	*varname;	
+    int		varnamelen;
+    int		*rcode;	
+{
+    int varid;
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, varname, varnamelen);
+    if ((varid = ncvarid (*cdfid, name)) != -1) {
+	*rcode = 0;
+	return (varid + 1);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+
+/* returns number of bytes per netCDF data type */
+int
+nctlen_(datatype, rcode)
+    int		*datatype;	
+    int		*rcode;	
+{
+    int itype;
+
+    if ((itype = nctypelen ((nc_type) *datatype)) != -1) {
+	*rcode = 0;
+	return (itype);
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
+/* closes an open netCDF file */
+void
+ncclos_(cdfid, rcode)
+    int		*cdfid;	
+    int		*rcode;	
+{
+    *rcode = 0;
+    if (ncclose (*cdfid) == -1)
+	*rcode = ncerr;
+}
+
+/* puts an open netCDF into define mode */
+void
+ncredf_(cdfid, rcode)
+    int		*cdfid;	
+    int		*rcode;	
+{
+    *rcode = 0;
+    if (ncredef (*cdfid) == -1)
+	*rcode = ncerr;
+}
+
+/* takes an open netCDF out of define mode */
+void
+ncendf_(cdfid, rcode)
+    int		*cdfid;	
+    int		*rcode;	
+{
+    *rcode = 0;
+    if (ncendef (*cdfid) == -1)
+	*rcode = ncerr;
+}
+
+/* returns information about an open netCDF file given its netCDF ID */
+void
+ncinq_(cdfid, ndims, nvars, natts, recdim, rcode)
+    int		*cdfid;	
+    int		*ndims;	
+    int		*nvars;	
+    int		*natts;	
+    int		*recdim;	
+    int		*rcode;	
+{
+    *rcode = 0;
+    if (ncinquire (*cdfid, ndims, nvars, natts, recdim) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    if (*recdim != -1)
+	(*recdim)++;
+}
+
+/*
+ * makes sure that the disk copy of a netCDF file open for writing
+ * is current
+ */
+void
+ncsnc_(cdfid, rcode)
+    int		*cdfid;	
+    int		*rcode;	
+{
+    *rcode = 0;
+    if (ncsync (*cdfid) == -1)
+	*rcode = ncerr;
+}
+
+/*
+ * restores the netCDF to a known consistent state in case anything
+ * goes wrong during the definition of new dimensions, variables
+ * or attributes
+ */
+void
+ncabor_(cdfid, rcode)
+    int		*cdfid;	
+    int		*rcode;	
+{
+    *rcode = 0;
+    if (ncabort (*cdfid) == -1)
+	*rcode = ncerr;
+}
+
+/* returns the name and size of a dimension, given its ID */
+void
+ncdinq_(cdfid, dimid, dimname, size, rcode, dimnamelen)
+    int		*cdfid;	
+    int		*dimid;	
+    char	*dimname;	
+    int		dimnamelen;
+    int		*size;	
+    int		*rcode;	
+{
+    long siz;
+    char name[MAX_NC_NAME + 1];
+
+    *rcode = 0;
+    if (ncdiminq (*cdfid, *dimid - 1, name, &siz) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    *size = siz;
+    if (strlen (name) > dimnamelen) {
+	*rcode = NC_ESTS;
+	handle_err ("NCDINQ", *rcode);
+	return;
+    }
+    /* blank fill the input character string */
+    fcdcpy (dimname, dimnamelen, name);
+}
+
+/* renames an existing dimension in a netCDF open for writing */
+void
+ncdren_(cdfid, dimid, dimname, rcode, dimnamelen)
+    int		*cdfid;	
+    int		*dimid;	
+    char	*dimname;	
+    int		dimnamelen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, dimname, dimnamelen);
+    *rcode = 0;
+    if (ncdimrename (*cdfid, *dimid - 1, name) == -1)
+	*rcode = ncerr;
+}
+
+/* returns information about a netCDF variable, given its ID */
+void
+ncvinq_(cdfid, varid, varname, datatype, ndims, dimarray, natts, rcode, varnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*varname;	
+    int		varnamelen;
+    int		*datatype;	
+    int		*ndims;	
+    int		*dimarray;	
+    int		*natts;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int dimid[MAX_VAR_DIMS], i;
+
+    *rcode = 0;
+    if (ncvarinq (*cdfid, *varid - 1, name, (nc_type *) datatype, ndims, dimid,
+		  natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < *ndims; i++)
+	dimarray[i] = dimid[i] + 1;
+    reverse (dimarray, *ndims);
+    if (strlen (name) > varnamelen) {
+	*rcode = NC_ESTS;
+	handle_err ("NCVINQ", *rcode);
+	return;
+    }
+    fcdcpy (varname, varnamelen, name);
+}
+
+/* puts a single numeric data value into a variable of an open netCDF */
+void
+ncvpt1_(cdfid, varid, indices, value, rcode)
+    int		*cdfid;	
+    int		*varid;	
+    int		*indices;	
+    void	*value;	
+    int		*rcode;	
+{
+    int datatype, ndims, natts, i;
+    long nindices[MAX_VAR_DIMS];
+    int dimid[MAX_VAR_DIMS];
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0,
+		  (nc_type *) & datatype, &ndims, dimid, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++)
+	nindices[i] = indices[i] - 1;
+    revlongs (nindices, ndims);
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {	/* pack ints into bytes */
+	char           bytes = *(int *) value;
+	if (ncvarput1(*cdfid, *varid - 1, nindices,
+		      (ncvoid *) &bytes) == -1) {
+	    *rcode = ncerr;
+	}
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) {	/* pack ints into shorts */
+	short          shorts = *(int *)value;
+	if (ncvarput1(*cdfid, *varid - 1, nindices, (ncvoid *) &shorts) == -1) {
+	    *rcode = ncerr;
+	}
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long          longs = *(int *)value;
+	if (ncvarput1(*cdfid, *varid - 1, nindices, (ncvoid *) &longs) == -1) {
+	    *rcode = ncerr;
+	}
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long          longs = *(int *)value;
+	if (ncvarput1(*cdfid, *varid - 1, nindices, (ncvoid *) &longs) == -1) {
+	    *rcode = ncerr;
+	}
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncvarput1 (*cdfid, *varid - 1, nindices, value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/* puts a single character into an open netCDF file */
+void
+ncvp1c_(cdfid, varid, indices, chval, rcode, chvallen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*indices;	
+    char	*chval;	
+    int		chvallen;
+    int		*rcode;	
+{
+    int datatype, ndims, natts, i;
+    long nindices[MAX_VAR_DIMS];
+    int dimid[MAX_VAR_DIMS];
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0,
+		  (nc_type *) & datatype, &ndims, dimid, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++)
+	nindices[i] = indices[i] - 1;
+    revlongs (nindices, ndims);
+    *rcode = 0;
+    if (ncvarput1 (*cdfid, *varid - 1, nindices, (ncvoid *) chval) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * writes a hypercube of numeric values into a netCDF variable of an open
+ * netCDF file
+ */
+void
+ncvpt_(cdfid, varid, start, count, value, rcode)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    void	*value;	
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS], i;
+    int ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {	/* pack ints into bytes */
+	char *bytes = itob (value, ncount, ndims);
+	if (bytes == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarput (*cdfid, *varid - 1, nstart, ncount,
+	              (ncvoid *) bytes) == -1) {
+	    *rcode = ncerr;
+	}
+	free (bytes);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) { /* pack ints into shorts */
+	short *shorts = itos (value, ncount, ndims);
+	if (shorts == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarput (*cdfid, *varid - 1, nstart, ncount,
+		      (ncvoid *) shorts) == -1) {
+	    *rcode = ncerr;
+	}
+	free (shorts);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long *longs = itol (value, ncount, ndims);
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarput (*cdfid, *varid - 1, nstart, ncount,
+	              (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	}
+	free (longs);
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long *longs = itol (value, ncount, ndims);
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarput (*cdfid, *varid - 1, nstart, ncount,
+	              (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	}
+	free (longs);
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncvarput (*cdfid, *varid - 1, nstart, ncount, value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/* writes a hypercube of character values into an open netCDF file */
+void
+ncvptc_(cdfid, varid, start, count, string, lenstr, rcode, stringlen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    char	*string;	
+    int		stringlen;
+    int		*lenstr;	
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS], i;
+    int ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0,
+		  (nc_type *) & datatype, &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+    if (dimprod(ncount,ndims) > *lenstr) {
+	*rcode = NC_ESTS;
+	handle_err ("NCVPTC", *rcode);
+	return;
+    }
+    *rcode = 0;
+    if (ncvarput (*cdfid, *varid - 1, nstart, ncount, (ncvoid *) string) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * writes a generalized hypercube of numeric values into a netCDF variable of 
+ * an open netCDF file
+ */
+void
+ncvptg_(cdfid, varid, start, count, stride, basis, value, rcode)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    int		*stride;	
+    int		*basis;	
+    void	*value;	
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS], i;
+    long nstride[MAX_VAR_DIMS], nbasis[MAX_VAR_DIMS];
+    long tmpbasis;
+    int ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+#ifdef FORTRAN_HAS_NO_BYTE
+    if (datatype == NC_CHAR || datatype == NC_BYTE)
+	tmpbasis	= nctypelen(NC_LONG);
+    else
+#endif
+#ifdef FORTRAN_HAS_NO_SHORT
+    if (datatype == NC_SHORT)
+	tmpbasis	= nctypelen(NC_LONG);
+    else
+#endif
+#ifdef __alpha
+    if (datatype == NC_LONG)
+	tmpbasis	= sizeof(int);
+    else
+#endif
+	tmpbasis	= nctypelen(datatype);
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+	nstride[i] = stride[0] == 0 ? 1 : stride[i];
+	nbasis[i] = basis[0] == 0 ? tmpbasis : basis[i];
+	tmpbasis *= count[i];
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+    revlongs (nstride, ndims);
+    revlongs (nbasis, ndims);
+
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {	/* pack ints into bytes */
+	/*
+	 * Release 2.3.1 had a bug in the following line: it used count
+	 * rather than ncount.
+	 */
+	char *bytes = itobg (value, ncount, nbasis, ndims);
+	if (bytes == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarputg (*cdfid, *varid - 1, nstart, ncount, nstride, 
+		       (long*)NULL, (ncvoid *) bytes) == -1) {
+	    *rcode = ncerr;
+	}
+	free (bytes);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) { /* pack ints into shorts */
+	/*
+	 * Release 2.3.1 had a bug in the following line: it used count
+	 * rather than ncount.
+	 */
+	short *shorts = itosg (value, ncount, nbasis, ndims);
+	if (shorts == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarputg (*cdfid, *varid - 1, nstart, ncount, nstride,
+		      (long*)NULL, (ncvoid *) shorts) == -1) {
+	    *rcode = ncerr;
+	}
+	free (shorts);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long *longs = itolg (value, ncount, nbasis, ndims);
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarputg (*cdfid, *varid - 1, nstart, ncount, nstride,
+		      (long*)NULL, (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	}
+	free (longs);
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long *longs = itolg (value, ncount, nbasis, ndims);
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	    }
+	if (ncvarputg (*cdfid, *varid - 1, nstart, ncount, nstride,
+		      (long*)NULL, (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	}
+	free (longs);
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncvarputg (*cdfid, *varid - 1, nstart, ncount, nstride, nbasis,
+		   value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * writes a generalized hypercube of character values into a netCDF variable of 
+ * an open netCDF file
+ */
+void
+ncvpgc_(cdfid, varid, start, count, stride, basis, string, rcode, stringlen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    int		*stride;	
+    int		*basis;	
+    char	*string;	
+    int		stringlen;
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS], i;
+    long nstride[MAX_VAR_DIMS], nbasis[MAX_VAR_DIMS];
+    long tmpbasis;
+    int ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    tmpbasis	= nctypelen(datatype);
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+	nstride[i] = stride[0] == 0 ? 1 : stride[i];
+	nbasis[i] = basis[0] == 0 ? tmpbasis : basis[i];
+	tmpbasis *= count[i];
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+    revlongs (nstride, ndims);
+    revlongs (nbasis, ndims);
+
+    *rcode = 0;
+    if (ncvarputg (*cdfid, *varid - 1, nstart, ncount, nstride, nbasis,
+		   (ncvoid*)string) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/* gets a single numeric value from a variable of an open netCDF file */
+void
+ncvgt1_(cdfid, varid, indices, value, rcode)
+    int		*cdfid;	
+    int		*varid;	
+    int		*indices;	
+    void	*value;	
+    int		*rcode;	
+{
+    long nindices[MAX_VAR_DIMS], i;
+    int datatype, ndims, dimarray[MAX_VAR_DIMS], natts;
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++) {
+	nindices[i] = indices[i] - 1;
+    }
+    revlongs (nindices, ndims);
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {
+	char           bytes;
+	int            *ip = (int *) value;
+	char           *bp = &bytes;
+
+	if (ncvarget1(*cdfid, *varid - 1, nindices, (ncvoid *) &bytes) == -1) {
+	    *rcode = ncerr;
+	    return;
+	}
+	*ip = *bp;
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) {
+	short          shorts;
+	int            *ip = (int *) value;
+	short          *sp = &shorts;
+
+	if (ncvarget1(*cdfid, *varid - 1, nindices, (ncvoid *) &shorts) == -1) {
+	    *rcode = ncerr;
+	    return;
+	}
+	*ip = *sp;
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long          longs;
+	int           *ip = (int *) value;
+
+	if (ncvarget1(*cdfid, *varid - 1, nindices, (ncvoid *) &longs) == -1) {
+	    *rcode = ncerr;
+	    return;
+	}
+	*ip = longs;
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long          longs;
+	int           *ip = (int *) value;
+
+	if (ncvarget1(*cdfid, *varid - 1, nindices, (ncvoid *) &longs) == -1) {
+	    *rcode = ncerr;
+	    return;
+	}
+	*ip = longs;
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncvarget1 (*cdfid, *varid - 1, nindices, value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * gets a single character data value from a variable of an open
+ * netCDF file
+ */
+void
+ncvg1c_(cdfid, varid, indices, chval, rcode, chvallen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*indices;	
+    char	*chval;	
+    int		chvallen;
+    int		*rcode;	
+{
+    long nindices[MAX_VAR_DIMS];
+    int i, datatype, ndims, dimarray[MAX_VAR_DIMS], natts;
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0,
+		  (nc_type *) & datatype, &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+
+    for (i = 0; i < ndims; i++) {
+	nindices[i] = indices[i] - 1;
+    }
+    revlongs (nindices, ndims);
+    *rcode = 0;
+    if (ncvarget1 (*cdfid, *varid - 1, nindices, (ncvoid *) chval) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * reads a hypercube of numeric values from a netCDF variable of an open
+ * netCDF file
+ */
+void
+ncvgt_(cdfid, varid, start, count, value, rcode)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    void	*value;	
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS];
+    int i, ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	char *bytes = (char *) malloc (iocount * sizeof (char));
+	int *ip;
+	char *bp = bytes;
+
+	if (bytes == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvarget (*cdfid, *varid - 1, nstart, ncount,
+		      (ncvoid *) bytes) == -1) {
+	    *rcode = ncerr;
+	    free (bytes);
+	    return;
+	}
+	for (ip = (int *) value; iocount > 0; iocount--)
+	  *ip++ = *bp++;
+	free (bytes);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	short *shorts = (short *) malloc (iocount * sizeof (short));
+	int *ip;
+	short *sp = shorts;
+
+	if (shorts == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvarget (*cdfid, *varid - 1, nstart, ncount,
+		      (ncvoid *) shorts) == -1) {
+	    *rcode = ncerr;
+	    free (shorts);
+	    return;
+	}
+	for (ip = (int *) value; iocount > 0; iocount--)
+	    *ip++ = *sp++;
+	free (shorts);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	long *longs = (long *) malloc (iocount * sizeof (long));
+	int *ip;
+	long *lp = longs;
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvarget (*cdfid, *varid - 1, nstart, ncount,
+		      (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	    free (longs);
+	    return;
+	}
+	for (ip = (int *) value; iocount > 0; iocount--)
+	    *ip++ = *lp++;
+	free (longs);
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	long *longs = (long *) malloc (iocount * sizeof (long));
+	int *ip;
+	long *lp = longs;
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvarget (*cdfid, *varid - 1, nstart, ncount,
+		      (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	    free (longs);
+	    return;
+	}
+	for (ip = (int *) value; iocount > 0; iocount--)
+	    *ip++ = *lp++;
+	free (longs);
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncvarget (*cdfid, *varid - 1, nstart, ncount, value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/* reads a hypercube of character values from a netCDF variable */
+void
+ncvgtc_(cdfid, varid, start, count, string, lenstr, rcode, stringlen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    char	*string;	
+    int		stringlen;
+    int		*lenstr;	
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS];
+    int i, ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+    int prod = 1;
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0,
+		  (nc_type *) & datatype, &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+	prod *= count[i];
+    }
+    if (prod > *lenstr) {
+	*rcode = NC_ESTS;
+	handle_err ("NCVGTC", *rcode);
+	return;
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+    *rcode = 0;
+    if (ncvarget (*cdfid, *varid - 1, nstart, ncount, (ncvoid *) string) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+
+    for (i = prod; i < *lenstr; i++)
+	string[i] = ' ';
+}
+
+/*
+ * reads a generalized hypercube of numeric values from a netCDF variable of an 
+ * open netCDF file
+ */
+void
+ncvgtg_(cdfid, varid, start, count, stride, basis, value, rcode)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    int		*stride;	
+    int		*basis;	
+    void	*value;	
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS];
+    long nstride[MAX_VAR_DIMS], nbasis[MAX_VAR_DIMS];
+    long tmpbasis;
+    int i, ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+#ifdef FORTRAN_HAS_NO_BYTE
+    if (datatype == NC_CHAR || datatype == NC_BYTE)
+	tmpbasis	= nctypelen(NC_LONG);
+    else
+#endif
+#ifdef FORTRAN_HAS_NO_SHORT
+    if (datatype == NC_SHORT)
+	tmpbasis	= nctypelen(NC_LONG);
+    else
+#endif
+#ifdef __alpha
+    if (datatype == NC_LONG)
+	tmpbasis	= sizeof(int);
+    else
+#endif
+	tmpbasis	= nctypelen(datatype);
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+	nstride[i] = stride[0] == 0 ? 1 : stride[i];
+	nbasis[i] = basis[0] == 0 ? tmpbasis : basis[i];
+	tmpbasis *= count[i];
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+    revlongs (nstride, ndims);
+    revlongs (nbasis, ndims);
+
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	char *bytes = (char *) malloc (iocount * sizeof (char));
+	int *ip;
+	char *bp = bytes;
+
+	if (bytes == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvargetg (*cdfid, *varid - 1, nstart, ncount, nstride,
+		      (long*)NULL, (ncvoid *) bytes) == -1) {
+	    *rcode = ncerr;
+	    free (bytes);
+	    return;
+	}
+	/*
+	 * Release 2.3.1 had a bug in the following line: it used basis
+	 * rather than nbasis.
+	 */
+	btoig(bytes, (int*)value, ncount, nbasis, ndims);
+	free (bytes);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	short *shorts = (short *) malloc (iocount * sizeof (short));
+	int *ip;
+	short *sp = shorts;
+
+	if (shorts == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvargetg (*cdfid, *varid - 1, nstart, ncount, nstride, 
+		       (long*)NULL, (ncvoid *) shorts) == -1) {
+	    *rcode = ncerr;
+	    free (shorts);
+	    return;
+	}
+	/*
+	 * Release 2.3.1 had a bug in the following line: it used basis
+	 * rather than nbasis.
+	 */
+	stoig(shorts, (int*)value, ncount, nbasis, ndims);
+	free (shorts);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	long *longs = (long *) malloc (iocount * sizeof (long));
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvargetg (*cdfid, *varid - 1, nstart, ncount, nstride, 
+		       (long*)NULL, (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	    free (longs);
+	    return;
+	}
+	ltoig(longs, (int*)value, ncount, nbasis, ndims);
+	free (longs);
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long iocount = dimprod (ncount, ndims);	/* product of dimensions */
+	long *longs = (long *) malloc (iocount * sizeof (long));
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncvargetg (*cdfid, *varid - 1, nstart, ncount, nstride, 
+		       (long*)NULL, (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	    free (longs);
+	    return;
+	}
+	ltoig(longs, (int*)value, ncount, nbasis, ndims);
+	free (longs);
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncvargetg (*cdfid, *varid - 1, nstart, ncount, nstride,
+		   nbasis, value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * reads a generalized hypercube of character values from a netCDF variable 
+ * of an open netCDF file
+ */
+void
+ncvggc_(cdfid, varid, start, count, stride, basis, string, rcode, stringlen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*start;	
+    int		*count;	
+    int		*stride;	
+    int		*basis;	
+    char	*string;	
+    int		stringlen;
+    int		*rcode;	
+{
+    long ncount[MAX_VAR_DIMS], nstart[MAX_VAR_DIMS];
+    long nstride[MAX_VAR_DIMS], nbasis[MAX_VAR_DIMS];
+    long tmpbasis;
+    int i, ndims, datatype, dimarray[MAX_VAR_DIMS], natts;
+
+    if (ncvarinq (*cdfid, *varid - 1, (char *) 0, (nc_type *) & datatype,
+		  &ndims, dimarray, &natts) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    tmpbasis	= nctypelen(datatype);
+    for (i = 0; i < ndims; i++) {
+	ncount[i] = count[i];
+	nstart[i] = start[i] - 1;
+	nstride[i] = stride[0] == 0 ? 1 : stride[i];
+	nbasis[i] = basis[0] == 0 ? tmpbasis : basis[i];
+	tmpbasis *= count[i];
+    }
+    revlongs (ncount, ndims);
+    revlongs (nstart, ndims);
+    revlongs (nstride, ndims);
+    revlongs (nbasis, ndims);
+
+    *rcode = 0;
+    if (ncvargetg (*cdfid, *varid - 1, nstart, ncount, nstride,
+		   nbasis, (ncvoid*)string) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/* changes the name of a netCDF variable in an open netCDF file */
+void
+ncvren_(cdfid, varid, varname, rcode, varnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*varname;	
+    int		varnamelen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, varname, varnamelen);
+    *rcode = 0;
+    if (ncvarrename (*cdfid, *varid - 1, name) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * adds or changes a numeric variable or global attribute of an open
+ * netCDF file
+ */
+void
+ncapt_(cdfid, varid, attname, datatype, attlen, value, rcode, attnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    int		*datatype;	
+    int		*attlen;	
+    void	*value;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    nstrncpy (name, attname, attnamelen);
+
+    *rcode = 0;
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) *datatype == NC_BYTE) {	/* pack ints into bytes */
+	char *bytes = itob (value, attlen, 1);
+
+	if (bytes == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattput (*cdfid, *varid - 1, name, (nc_type) *datatype, *attlen,
+		      (ncvoid *) bytes) == -1) {
+	    *rcode = ncerr;
+	}
+	free (bytes);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) *datatype == NC_SHORT) {	/* pack ints into shorts */
+	short *shorts = itos (value, attlen, 1);
+
+	if (shorts == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattput (*cdfid, *varid - 1, name, (nc_type) *datatype, *attlen,
+		      (ncvoid *) shorts) == -1) {
+	    *rcode = ncerr;
+	}
+	free (shorts);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) *datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long *longs = itol (value, attlen, 1);
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattput (*cdfid, *varid - 1, name, (nc_type) *datatype, *attlen,
+		      (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	}
+	free (longs);
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) *datatype == NC_LONG) {
+	long *longs = itol (value, attlen, 1);
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattput (*cdfid, *varid - 1, name, (nc_type) *datatype, *attlen,
+		      (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	}
+	free (longs);
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncattput (*cdfid, *varid - 1, name, (nc_type) *datatype, *attlen,
+		  value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * adds or changes a character variable or global attribute
+ * of an open netCDF file
+ */
+void
+ncaptc_(cdfid, varid, attname, datatype, lenstr, string, rcode, attnamelen, stringlen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    int		*datatype;	
+    int		*lenstr;	
+    char	*string;	
+    int		stringlen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    char *value;
+
+    nstrncpy (name, attname, attnamelen);
+    if (((value = malloc ((unsigned) *lenstr + 1)) == NULL) || (*lenstr == 0)) {
+	*rcode = NC_ESTS;
+	handle_err ("NCAPTC", *rcode);
+	return;
+    }
+    (void) fstrncpy (value, string, *lenstr);
+    *rcode = 0;
+    if (ncattput (*cdfid, *varid - 1, name, (nc_type) *datatype, *lenstr,
+		  (ncvoid *) value) == -1) {
+	*rcode = ncerr;
+    }
+    free (value);
+}
+
+/*
+ * returns information about a netCDF attribute given its variable
+ * ID and name
+ */
+void
+ncainq_(cdfid, varid, attname, datatype, attlen, rcode, attnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    int		*datatype;	
+    int		*attlen;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, attname, attnamelen);
+    *rcode = 0;
+    if (ncattinq (*cdfid, *varid - 1, name, (nc_type *) datatype, attlen) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * gets the value of a netCDF attribute given its variable ID
+ * and name
+ */
+void
+ncagt_(cdfid, varid, attname, value, rcode, attnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    void	*value;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int datatype;
+    int attlen;
+#ifdef HDF
+    NC *handle=NC_check_id(*cdfid);
+#endif /* HDF */
+
+    nstrncpy (name, attname, attnamelen);
+    *rcode = 0;
+    if (ncattinq (*cdfid, *varid - 1, name, (nc_type *) &datatype, &attlen)
+	    == -1) {
+	*rcode = ncerr;
+	return;
+    }
+#ifdef FORTRAN_HAS_NO_BYTE
+    if ((nc_type) datatype == NC_BYTE) {
+	char *bytes = (char *) malloc (attlen);
+	int *ip;
+	char *bp = bytes;
+
+	if (bytes == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattget (*cdfid, *varid - 1, name, (ncvoid *) bytes) == -1) {
+	    *rcode = ncerr;
+	    free (bytes);
+	    return;
+	}
+	for (ip = (int *) value; attlen > 0; attlen--)
+	    *ip++ = *bp++;
+	free (bytes);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_BYTE */
+#ifdef FORTRAN_HAS_NO_SHORT
+    if ((nc_type) datatype == NC_SHORT) {
+	short *shorts = (short *) malloc (attlen * sizeof (short));
+	int *ip;
+	short *sp = shorts;
+
+	if (shorts == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattget (*cdfid, *varid - 1, name, (ncvoid *) shorts) == -1) {
+	    *rcode = ncerr;
+	    free (shorts);
+	    return;
+	}
+	for (ip = (int *) value; attlen > 0; attlen--)
+	    *ip++ = *sp++;
+	free (shorts);
+	return;
+    }				/* else */
+#endif				/* FORTRAN_HAS_NO_SHORT */
+#ifdef __alpha
+#ifdef HDF
+    if ((nc_type) datatype == NC_LONG && handle->file_type!=HDF_FILE) {
+	long *longs = (long *) malloc (attlen * sizeof (long));
+	int *ip;
+	long *lp = longs;
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattget (*cdfid, *varid - 1, name, (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	    free (longs);
+	    return;
+	}
+	for (ip = (int *) value; attlen > 0; attlen--)
+	    *ip++ = *lp++;
+	free (longs);
+	return;
+    }				/* else */
+#else /* HDF */
+    if ((nc_type) datatype == NC_LONG) {
+	long *longs = (long *) malloc (attlen * sizeof (long));
+	int *ip;
+	long *lp = longs;
+
+	if (longs == NULL) {
+	    *rcode = NC_SYSERR;
+	    return;
+	}
+	if (ncattget (*cdfid, *varid - 1, name, (ncvoid *) longs) == -1) {
+	    *rcode = ncerr;
+	    free (longs);
+	    return;
+	}
+	for (ip = (int *) value; attlen > 0; attlen--)
+	    *ip++ = *lp++;
+	free (longs);
+	return;
+    }				/* else */
+#endif /* HDF */
+#endif
+    if (ncattget (*cdfid, *varid - 1, name, value) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * gets the value of a netCDF character attribute given its variable
+ * ID and name
+ */
+void
+ncagtc_(cdfid, varid, attname, string, lenstr, rcode, attnamelen, stringlen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    char	*string;	
+    int		stringlen;
+    int		*lenstr;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+    int datatype;
+    int attlen;
+    int i;
+
+    nstrncpy (name, attname, attnamelen);
+    *rcode = 0;
+    if (ncattinq (*cdfid, *varid - 1, name, (nc_type *) &datatype, &attlen) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    if (attlen > *lenstr) {
+	*rcode = NC_ESTS;
+	handle_err ("NCAGTC", *rcode);
+	return;
+    }
+    if (ncattget (*cdfid, *varid - 1, name, (ncvoid *) string) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+
+    for (i = attlen; i < *lenstr; i++)
+	string[i] = ' ';
+}
+
+/* copies an attribute from one open netCDF file to another */
+void
+ncacpy_(incdfid, invarid, attname, outcdfid, outvarid, rcode, attnamelen)
+    int		*incdfid;	
+    int		*invarid;	
+    char	*attname;	
+    int		attnamelen;
+    int		*outcdfid;	
+    int		*outvarid;	
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, attname, attnamelen);
+    *rcode = 0;
+    if (ncattcopy (*incdfid, *invarid - 1, name,
+		   *outcdfid, *outvarid - 1) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * gets the name of an attribute given its variable ID and number
+ * as an attribute of that variable
+ */
+void
+ncanam_(cdfid, varid, attnum, attname, rcode, attnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    int		*attnum;	
+    char	*attname;	
+    int		attnamelen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+
+    *rcode = 0;
+    if (ncattname (*cdfid, *varid - 1, *attnum - 1, name) == -1) {
+	*rcode = ncerr;
+	return;
+    }
+    if (strlen (name) > attnamelen) {
+	*rcode = NC_ESTS;
+	handle_err ("NCANAM", *rcode);
+	return;
+    }
+    fcdcpy (attname, attnamelen, name);
+}
+
+
+/* renames an attribute in an open netCDF file */
+void
+ncaren_(cdfid, varid, attname, newname, rcode, attnamelen, newnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    char	*newname;	
+    int		newnamelen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1], nname[MAX_NC_NAME + 1];
+
+    nstrncpy (name, attname, attnamelen);
+    nstrncpy (nname, newname, newnamelen);
+    *rcode = 0;
+    if (ncattrename (*cdfid, *varid - 1, name, nname) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+/*
+ * deletes an attribute from an open netCDF file given the attribute
+ * name
+ */
+void
+ncadel_(cdfid, varid, attname, rcode, attnamelen)
+    int		*cdfid;	
+    int		*varid;	
+    char	*attname;	
+    int		attnamelen;
+    int		*rcode;	
+{
+    char name[MAX_NC_NAME + 1];
+
+    nstrncpy (name, attname, attnamelen);
+    *rcode = 0;
+    if (ncattdel (*cdfid, *varid - 1, name) == -1) {
+	*rcode = ncerr;
+    }
+}
+
+
+/*
+ * sets the fill mode of a netCDF file open for writing
+ */
+int
+ncsfil_(cdfid, fillmode, rcode)
+    int		*cdfid;	
+    int		*fillmode;	
+    int		*rcode;	
+{
+    int retval;
+
+    if ((retval = ncsetfill (*cdfid, *fillmode)) != -1) {
+	*rcode = 0;
+	return retval;
+    }
+    *rcode = ncerr;
+    return (-1);
+}
+
diff -urN HDF4.1r5/mfhdf/fortran/config/netcdf-darwin.inc hdf-new/mfhdf/fortran/config/netcdf-darwin.inc
--- HDF4.1r5/mfhdf/fortran/config/netcdf-darwin.inc	Wed Dec 31 19:00:00 1969
+++ hdf-new/mfhdf/fortran/config/netcdf-darwin.inc	Mon Dec  8 19:43:58 2003
@@ -0,0 +1,147 @@
+c      
+c     Functions in the FORTRAN interface
+
+      integer nccre, ncopn, ncddef, ncdid, ncvdef, ncvid, nctlen
+      integer ncsfil
+      external nccre, ncopn, ncddef, ncdid, ncvdef, ncvid, nctlen
+      external ncsfil
+
+      integer NCRDWR,NCCREAT,NCEXCL,NCINDEF,NCNSYNC,NCHSYNC
+      integer NCNDIRTY,NCHDIRTY,NCLINK,NCNOWRIT,NCWRITE
+      integer NCCLOB,NCNOCLOB,NCGLOBAL,NCFILL,NCNOFILL
+      integer MAXNCOP,MAXNCDIM,MAXNCATT,MAXNCVAR
+      integer MAXNCNAM,MAXVDIMS,NCNOERR,NCEBADID
+      integer NCENFILE,NCEEXIST,NCEINVAL,NCEPERM,NCENOTIN
+      integer NCEINDEF,NCECOORD,NCEMAXDS,NCENAME
+      integer NCENOATT,NCEMAXAT,NCEBADTY,NCEBADD, NCESTS
+      integer NCEUNLIM,NCEMAXVS,NCENOTVR,NCEGLOB,NCENOTNC
+      integer NCFOOBAR,NCSYSERR,NCFATAL,NCVERBOS, NCENTOOL
+      
+      integer NCBYTE,NCCHAR,NCSHORT,NCLONG,NCFLOAT,NCDOUBLE
+      
+      parameter(NCBYTE = 1)
+      parameter(NCCHAR = 2)
+      parameter(NCSHORT = 3)
+      parameter(NCLONG = 4)
+      parameter(NCFLOAT = 5)
+      parameter(NCDOUBLE = 6)
+      
+c     
+c     masks for the struct NC flag field; passed in as 'mode' arg to
+c     nccreate and ncopen.
+c     
+      
+c     read/write, 0 => readonly 
+      parameter(NCRDWR = 1)
+c     in create phase, cleared by ncendef 
+      parameter(NCCREAT = 2)
+c     on create destroy existing file 
+      parameter(NCEXCL = 4)
+c     in define mode, cleared by ncendef 
+      parameter(NCINDEF = 8)
+c     synchronise numrecs on change (X'10')
+      parameter(NCNSYNC = 16)
+c     synchronise whole header on change (X'20')
+      parameter(NCHSYNC = 32)
+c     numrecs has changed (X'40')
+      parameter(NCNDIRTY = 64)	
+c     header info has changed (X'80')
+      parameter(NCHDIRTY = 128)
+c     prefill vars on endef and increase of record, the default behavior
+      parameter(NCFILL = 0)
+c     don't fill vars on endef and increase of record (X'100')
+      parameter(NCNOFILL = 256)
+c     isa link (X'8000')
+      parameter(NCLINK = 32768)
+      
+c     
+c     'mode' arguments for nccreate and ncopen
+c     
+      
+      parameter(NCNOWRIT = 0)
+      parameter(NCWRITE = NCRDWR)
+      parameter(NCCLOB = 11)
+      parameter(NCNOCLOB = 15)
+c     
+c     'size' argument to ncdimdef for an unlimited dimension
+c     
+      integer NCUNLIM
+      parameter(NCUNLIM = 0)
+      
+c     
+c     attribute id to put/get a global attribute
+c     
+      parameter(NCGLOBAL  = 0)
+c     
+c     Advisory Maximums
+c     
+      parameter(MAXNCOP = 32)
+      parameter(MAXNCDIM = 32)
+      parameter(MAXNCATT = 512)
+      parameter(MAXNCVAR = 512)
+c     Not enforced 
+      parameter(MAXNCNAM = 128)
+      parameter(MAXVDIMS = MAXNCDIM)
+      
+      
+c     
+c     The netcdf data types
+c     
+      
+c     
+c     Global netcdf error status variable
+c     Initialized in error.c
+c     
+      
+c     No Error 
+      parameter(NCNOERR = 0)
+c     Not a netcdf id 
+      parameter(NCEBADID = 1)
+c     Too many netcdfs open 
+      parameter(NCENFILE = 2)	
+c     netcdf file exists && NCNOCLOB
+      parameter(NCEEXIST = 3)
+c     Invalid Argument 
+      parameter(NCEINVAL = 4)
+c     Write to read only 
+      parameter(NCEPERM = 5)
+c     Operation not allowed in data mode 
+      parameter(NCENOTIN = 6)	
+c     Operation not allowed in define mode 
+      parameter(NCEINDEF = 7)	
+c     Coordinates out of Domain 
+      parameter(NCECOORD = 8)
+c     MAXNCDIMS exceeded 
+      parameter(NCEMAXDS = 9)
+c     String match to name in use 
+      parameter(NCENAME = 10)	
+c     Attribute not found 
+      parameter(NCENOATT = 11)
+c     MAXNCATTRS exceeded 
+      parameter(NCEMAXAT = 12)
+c     Not a netcdf data type 
+      parameter(NCEBADTY = 13)
+c     Invalid dimension id 
+      parameter(NCEBADD = 14)	
+c     NCUNLIMITED in the wrong index 
+      parameter(NCEUNLIM = 15)
+c     MAXNCVARS exceeded 
+      parameter(NCEMAXVS = 16)
+c     Variable not found 
+      parameter(NCENOTVR = 17)
+c     Action prohibited on NCGLOBAL varid 
+      parameter(NCEGLOB = 18)
+c     Not a netcdf file 
+      parameter(NCENOTNC = 19)
+      parameter(NCESTS = 20)
+      parameter (NCENTOOL = 21)	
+      parameter(NCFOOBAR = 32)
+      parameter(NCSYSERR = -1)
+      
+      
+c     
+c     Global options variable. Used to determine behavior of error handler.
+c     Initialized in lerror.c
+c     
+      parameter(NCFATAL = 1)
+      parameter(NCVERBOS = 2)
diff -urN HDF4.1r5/mfhdf/libsrc/config/netcdf-darwin.h hdf-new/mfhdf/libsrc/config/netcdf-darwin.h
--- HDF4.1r5/mfhdf/libsrc/config/netcdf-darwin.h	Wed Dec 31 19:00:00 1969
+++ hdf-new/mfhdf/libsrc/config/netcdf-darwin.h	Mon Dec  8 19:43:58 2003
@@ -0,0 +1,590 @@
+/* Generated automatically from netcdf.h.in by configure. */
+/*
+ *	Copyright 1993, University Corporation for Atmospheric Research
+ *
+ *  Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose without fee is hereby granted, provided
+ * that the above copyright notice appear in all copies, that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of UCAR/Unidata not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  UCAR makes no
+ * representations about the suitability of this software for any purpose.
+ * It is provided "as is" without express or implied warranty.  It is
+ * provided with no support and without obligation on the part of UCAR
+ * Unidata, to assist in its use, correction, modification, or enhancement.
+ *
+ */
+/* "$Id: hdf-4.1r4-2.patch,v 1.1 2001/09/19 14:46:18 jswhit Exp $" */
+
+#ifndef _NETCDF_
+#define _NETCDF_
+
+#ifdef __MWERKS__
+#ifndef HDF
+#define HDF
+#endif
+#endif /* __MWERKS__ */
+
+/*
+ * The definitions ncvoid, USE_ENUM, and MAX_NC_OPEN, may need to be set
+ * properly for your installation.
+ */
+
+/*
+ * Argument type in user functions (deprecated, backward compatibility)
+ */
+#ifndef UD_NO_VOID
+#define ncvoid    void
+#else
+/* system doesn't have void type */
+#define ncvoid    char
+#endif
+
+
+/*
+ *   If xdr_enum works properly on your system, you can define 
+ * USE_ENUM so that nc_type is an enum. 
+ * Otherwise, delete this definition so that the nc_type is
+ * an int and the valid values are #defined.
+ */
+#ifndef __MWERKS__
+#define USE_ENUM
+#endif
+
+
+/*
+ * The following macro is provided for backward compatibility only.  If you
+ * are a new user of netCDF, then you may safely ignore it.  If, however,
+ * you have an existing archive of netCDF files that use default
+ * floating-point fill values, then you should know that the definition of
+ * the default floating-point fill values changed with version 2.3 of the
+ * netCDF package.  Prior to this release, the default floating-point fill
+ * values were not very portable:  their correct behavior depended not only
+ * upon the particular platform, but also upon the compilation
+ * environment.  This led to the definition of new, default floating-point
+ * fill values that are portable across all platforms and compilation
+ * environments.  If you wish, however, to obtain the old, non-portable
+ * floating-point fill values, then the following macro should have a true
+ * value PRIOR TO BUILDING THE netCDF LIBRARY.
+ *
+ * Implementation details are contained in the section below on fill values.
+ */
+#define NC_OLD_FILLVALUES	0
+
+/*
+ * 	Fill values
+ * These values are stuffed into newly allocated space as appropriate.
+ * The hope is that one might use these to notice that a particular datum
+ * has not been set.
+ */
+
+#define FILL_BYTE	((char)-127)		/* Largest Negative value */
+#define FILL_CHAR	((char)0)
+#define FILL_SHORT	((short)-32767)
+#define FILL_LONG	((long)-2147483647)
+
+#if !NC_OLD_FILLVALUES
+
+#   define FILL_FLOAT	9.9692099683868690e+36 /* near 15 * 2^119 */
+#   define FILL_DOUBLE	9.9692099683868690e+36
+
+#else	/* NC_OLD_FILLVALUES below */
+
+/*
+ * This section is provided for backward compatibility only.  Using
+ * XDR infinities for floating-point fill values has caused more problems
+ * than it has solved.  We encourage you to define your own data-specific
+ * fill values rather than use default ones (see `_FillValue' below).
+ * If, however, you *must* use default fill values, then you should use
+ * the above fill values rather than the ones in this section.
+ */
+
+/*
+ * XDR_F_INFINITY is a float value whose EXTERNAL (xdr)
+ * represention is ieee floating infinity.
+ * XDR_D_INFINITY is a double value whose EXTERNAL (xdr)
+ * represention is ieee double floating point infinity.
+ * These are used as default fill values below.
+ *
+ * This section shows three techniques for setting these:
+ *  Direct assignment (vax, cray) - works for non IEEE machines
+ *		Doesn't work when IEEE machines don't allow
+ *      float or double constants whose values are infinity.
+ *  Use of a union (preferred portable method) - should work on
+ *      any ANSI compiler with IEEE floating point representations,
+ *      modulo byte order and sizeof() considerations.
+ *  Use of pointer puns - may work with many older compilers
+ *      which don't allow intialization of unions.
+ *      Often doesn't work with compilers which have strict
+ *      alignment rules.
+ */ 
+
+    /* Direct assignment. All cases should be mutually exclusive */
+
+#ifdef vax
+#define	XDR_D_INFINITY	1.7014118346046923e+38
+#define	XDR_F_INFINITY	1.70141173e+38
+#endif /* vax */
+
+#ifdef cray
+#define	XDR_D_INFINITY	1.797693134862313000e+308
+#define	XDR_F_INFINITY	XDR_D_INFINITY
+#endif /* cray */
+
+#ifdef notdef /* you might want to try these, on an IEEE machine */
+#define XDR_D_INFINITY	1.797693134862315900e+308
+#define XDR_F_INFINITY	3.40282357e+38
+#endif
+
+#ifdef __STDC__
+    /* Use of a union, assumes IEEE representation and 1 byte unsigned char */
+
+#ifndef    XDR_D_INFINITY
+#define USE_D_UNION
+     union xdr_d_union {unsigned char bb[8]; double dd;} ;
+     extern union xdr_d_union xdr_d_infs ;  /* instantiated in array.c */
+#define XDR_D_INFINITY    (xdr_d_infs.dd)
+#endif /* !XDR_D_INFINITY */
+
+#ifndef    XDR_F_INFINITY
+#define USE_F_UNION
+     union xdr_f_union {unsigned char bb[4]; float ff;} ;
+     extern union xdr_f_union xdr_f_infs ;  /* instantiated in array.c */
+#define  XDR_F_INFINITY    (xdr_f_infs.ff)
+#endif /* !XDR_F_INFINITY */
+
+
+#else /* __STDC__ */
+    /* Use of a pointer pun, assumes IEEE representation, 4 byte long */
+
+#ifndef    XDR_D_INFINITY
+#define USE_D_LONG_PUN
+     extern long xdr_d_infinity[] ;  /* instantiated in array.c */
+#define XDR_D_INFINITY *(double *)xdr_d_infinity
+#endif /* !XDR_D_INFINITY */
+
+#ifndef    XDR_F_INFINITY
+#define USE_F_LONG_PUN
+     extern long xdr_f_infinity ;  /* instantiated in array.c */
+#define XDR_F_INFINITY *((float *)&xdr_f_infinity)
+#endif /* !XDR_F_INFINITY */
+
+#endif /* __STDC__ */
+
+/* End of INFINITY           section */
+
+#define FILL_FLOAT	XDR_F_INFINITY	/* IEEE Infinity */
+#define FILL_DOUBLE	XDR_D_INFINITY
+
+#endif	/* NC_OLD_FILLVALUES above */
+
+
+/*
+ *  masks for the struct NC flags field; passed in as 'mode' arg to
+ * nccreate and ncopen.
+ *
+ */
+#define NC_RDWR  1		/* read/write, 0 => readonly */
+#define NC_CREAT 2		/* in create phase, cleared by ncendef */
+#define NC_EXCL  4		/* on create, don't destroy existing file */
+#define NC_INDEF 8		/* in define mode, cleared by ncendef */
+#define NC_NSYNC 0x10	/* synchronise numrecs on change */
+#define NC_HSYNC 0x20	/* synchronise whole header on change */
+#define NC_NDIRTY 0x40	/* numrecs has changed */
+#define NC_HDIRTY 0x80  /* header info has changed */
+#define NC_NOFILL 0x100	/* Don't fill vars on endef and increase of record */
+#define NC_LINK 0x8000	/* isa link */
+
+#define NC_FILL 0	/* argument to ncsetfill to clear NC_NOFILL */
+
+/*
+ * 'mode' arguments for nccreate and ncopen
+ */
+#define NC_NOWRITE   0
+#define NC_WRITE     NC_RDWR
+#define NC_CLOBBER   (NC_INDEF | NC_CREAT | NC_RDWR)
+#define NC_NOCLOBBER (NC_INDEF | NC_EXCL | NC_CREAT | NC_RDWR)
+
+/*
+ * 'size' argument to ncdimdef for an unlimited dimension
+ */
+#define NC_UNLIMITED 0L
+
+/*
+ * attribute id to put/get a global attribute
+ */
+#define NC_GLOBAL -1
+
+#ifndef HDF
+/*
+ * This can be as large as the maximum number of stdio streams
+ * you can have open on your system.
+ */
+#define MAX_NC_OPEN 32
+
+/*
+ * These maximums are enforced by the interface, to facilitate writing
+ * applications and utilities.  However, nothing is statically allocated to
+ * these sizes internally.
+ */
+#define MAX_NC_DIMS 5000	 /* max dimensions per file */
+#define MAX_NC_ATTRS 3000	 /* max global or per variable attributes */
+#define MAX_NC_VARS 5000	 /* max variables per file */
+#define MAX_NC_NAME 256		 /* max length of a name */
+#define MAX_VAR_DIMS 32          /* max per variable dimensions */
+
+/*
+ * Added feature. 
+ * If you wish a variable to use a different value than the above
+ * defaults, create an attribute with the same type as the variable
+ * and the following reserved name. The value you give the attribute
+ * will be used as the fill value for that variable.
+ */
+#define _FillValue	"_FillValue"
+
+#else /* HDF */
+
+#include "hlimits.h"  /* Hard coded constants for HDF library */
+
+#endif /* HDF */
+
+#ifdef USE_ENUM
+/*
+ *  The netcdf data types
+ */
+typedef enum {
+	NC_UNSPECIFIED, /* private */
+	NC_BYTE,
+	NC_CHAR,
+	NC_SHORT,
+	NC_LONG,
+	NC_FLOAT,
+	NC_DOUBLE,
+	/* private */
+	NC_BITFIELD,
+	NC_STRING,
+	NC_IARRAY,
+	NC_DIMENSION,
+	NC_VARIABLE,
+	NC_ATTRIBUTE
+} nc_type ;
+#else
+typedef int nc_type ;
+#define	NC_UNSPECIFIED 0 /* private */
+#define	NC_BYTE 1
+#define	NC_CHAR 2
+#define	NC_SHORT 3
+#define	NC_LONG 4
+#define	NC_FLOAT 5
+#define	NC_DOUBLE 6
+	/* private */
+#define	NC_BITFIELD 7
+#define	NC_STRING 8
+#define	NC_IARRAY 9
+#define	NC_DIMENSION 10
+#define	NC_VARIABLE 11
+#define	NC_ATTRIBUTE 12
+#endif
+
+
+/*
+ * C data types corresponding to netCDF data types:
+ */
+/* Don't use these or the C++ interface gets confused
+typedef char  ncchar;
+typedef char  ncbyte;
+typedef short ncshort;
+typedef float ncfloat;
+typedef double        ncdouble;
+*/
+
+/* 
+ * Variables/attributes of type NC_LONG should use the C type 'nclong'
+ */
+#if defined _CRAYMPP
+typedef short	nclong;
+#elif defined __alpha || (_MIPS_SZLONG == 64)
+typedef int     nclong;   
+#else
+typedef long    nclong;         /* default, compatible type */
+#endif
+
+
+/*
+ * Global netcdf error status variable
+ *  Initialized in error.c
+ */
+#define	NC_NOERR	0	/* No Error */
+#define	NC_EBADID	1	/* Not a netcdf id */
+#define	NC_ENFILE	2	/* Too many netcdfs open */
+#define	NC_EEXIST	3	/* netcdf file exists && NC_NOCLOBBER */
+#define	NC_EINVAL	4	/* Invalid Argument */
+#define	NC_EPERM	5	/* Write to read only */
+#define	NC_ENOTINDEFINE	6	/* Operation not allowed in data mode */
+#define	NC_EINDEFINE	7	/* Operation not allowed in define mode */
+#define	NC_EINVALCOORDS	8	/* Coordinates out of Domain */
+#define	NC_EMAXDIMS	9	/* MAX_NC_DIMS exceeded */
+#define	NC_ENAMEINUSE	10	/* String match to name in use */
+#define NC_ENOTATT	11	/* Attribute not found */
+#define	NC_EMAXATTS	12	/* MAX_NC_ATTRS exceeded */
+#define NC_EBADTYPE	13	/* Not a netcdf data type */
+#define NC_EBADDIM	14	/* Invalid dimension id */
+#define NC_EUNLIMPOS	15	/* NC_UNLIMITED in the wrong index */
+#define	NC_EMAXVARS	16	/* MAX_NC_VARS exceeded */
+#define NC_ENOTVAR	17	/* Variable not found */
+#define NC_EGLOBAL	18	/* Action prohibited on NC_GLOBAL varid */
+#define NC_ENOTNC	19	/* Not a netcdf file */
+#define NC_ESTS         20      /* In Fortran, string too short */
+#define NC_EMAXNAME     21      /* MAX_NC_NAME exceeded */
+#define NC_ENTOOL       NC_EMAXNAME   /* Backward compatibility */
+#define NC_EUNLIMIT     22      /* NC_UNLIMITED size already in use */
+
+#define	NC_EXDR		32	/* */
+#define	NC_SYSERR	-1
+
+extern int ncerr ;
+
+/*
+ * Global options variable. Used to determine behavior of error handler.
+ *  Initialized in lerror.c
+ */
+#define	NC_FATAL	1
+#define	NC_VERBOSE	2
+
+extern int ncopts ;	/* default is (NC_FATAL | NC_VERBOSE) */
+
+/*
+ * NB: The following feature-test line is too long in order to accomodate a 
+ * bug in the VMS 5.3 C compiler.
+ */
+#ifndef HAVE_PROTOTYPES
+#   if defined(__STDC__) || defined(__GNUC__) || defined(__cplusplus) || defined(c_plusplus)
+#       define	HAVE_PROTOTYPES
+#   endif
+#endif
+
+#undef PROTO
+#ifdef HAVE_PROTOTYPES 
+#   define	PROTO(x)	x
+#else
+#   define	PROTO(x)	()
+#endif
+
+#include "hdf2netcdf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int nccreate	PROTO((
+    const char*	path,
+    int		cmode
+));
+extern int ncopen	PROTO((
+    const char*	path,
+    int		mode
+));
+extern int ncredef	PROTO((
+    int		cdfid
+));
+extern int ncendef	PROTO((
+    int		cdfid
+));
+extern int ncclose	PROTO((
+    int		cdfid
+));
+extern int ncinquire	PROTO((
+    int		cdfid,
+    int*	ndims,
+    int*	nvars,
+    int*	natts, 
+    int*	recdim
+));
+extern int ncsync	PROTO((
+    int		cdfid
+));
+extern int ncabort	PROTO((
+    int		cdfid
+));
+extern int ncnobuf	PROTO((
+    int		cdfid
+));
+extern int ncdimdef	PROTO((
+    int		cdfid,
+    const char*	name,
+    long	length
+));
+extern int ncdimid	PROTO((
+    int		cdfid,
+    const char*	name
+));
+extern int ncdiminq	PROTO((
+    int		cdfid,
+    int		dimid,
+    char*	name,
+    long*	length
+));
+extern int ncdimrename	PROTO((
+    int		cdfid,
+    int		dimid,
+    const char*	name
+));
+extern int ncvardef	PROTO((
+    int		cdfid,
+    const char*	name,
+    nc_type	datatype, 
+    int		ndims,
+    const int*	dim
+));
+extern int ncvarid	PROTO((
+    int		cdfid,
+    const char*	name
+));
+extern int ncvarinq	PROTO((
+    int		cdfid,
+    int		varid,
+    char*	name,
+    nc_type*	datatype,
+    int*	ndims,
+    int*	dim,
+    int*	natts
+));
+extern int ncvarput1	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	coords,
+    const void*	value
+));
+extern int ncvarget1	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	coords,
+    void*	value
+));
+extern int ncvarput	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	start,
+    const long*	count, 
+    void*	value
+));
+extern int ncvarget	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	start,
+    const long*	count, 
+    void*	value
+));
+extern int ncvarputs	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	start,
+    const long*	count,
+    const long*	stride,
+    void*	values
+));
+extern int ncvargets	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	start,
+    const long*	count,
+    const long*	stride,
+    void*	values
+));
+extern int ncvarputg	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	start,
+    const long*	count,
+    const long*	stride,
+    const long*	imap,
+    void* values
+));
+extern int ncvargetg	PROTO((
+    int		cdfid,
+    int		varid,
+    const long*	start,
+    const long*	count,
+    const long*	stride,
+    const long*	imap,
+    void*	values
+));
+extern int ncvarrename	PROTO((
+    int		cdfid,
+    int		varid,
+    const char*	name
+));
+extern int ncattput	PROTO((
+    int		cdfid,
+    int		varid,
+    const char*	name, 
+    nc_type	datatype,
+    int		len,
+    const void*	value
+));
+extern int ncattinq	PROTO((
+    int		cdfid,
+    int		varid,
+    const char*	name, 
+    nc_type*	datatype,
+    int*	len
+));
+extern int ncattget	PROTO((
+    int		cdfid,
+    int		varid,
+    const char*	name, 
+    void*	value
+));
+extern int ncattcopy	PROTO((
+    int		incdf,
+    int		invar,
+    const char*	name, 
+    int		outcdf,
+    int		outvar
+));
+extern int ncattname	PROTO((
+    int		cdfid,
+    int		varid,
+    int		attnum,
+    char*	name
+));
+extern int ncattrename	PROTO((
+    int		cdfid,
+    int		varid,
+    const char*	name, 
+    const char*	newname
+));
+extern int ncattdel	PROTO((
+    int		cdfid,
+    int		varid,
+    const char*	name
+));
+extern int nctypelen	PROTO((
+    nc_type	datatype
+));
+extern int ncsetfill	PROTO((
+    int		cdfid,
+    int		fillmode
+));
+extern int ncrecinq		PROTO((
+    int		cdfid,
+    int*	nrecvars,
+    int*	recvarids,
+    long*	recsizes
+));
+extern int ncrecget		PROTO((
+    int		cdfid,
+    long	recnum,
+    void**	datap
+));
+extern int ncrecput		PROTO((
+    int		cdfid,
+    long	recnum,
+    void* * datap
+));
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _NETCDF_ */
diff -urN HDF4.1r5/mfhdf/libsrc/xdrposix.c hdf-new/mfhdf/libsrc/xdrposix.c
--- HDF4.1r5/mfhdf/libsrc/xdrposix.c	Wed Jun 27 15:17:39 2001
+++ hdf-new/mfhdf/libsrc/xdrposix.c	Mon Dec  8 20:26:48 2003
@@ -39,10 +39,12 @@
 #   else
 #       if defined (__MWERKS__)
 #            include <unistd.h>
+/*
 #       else
 #           if !(defined(macintosh) || defined (SYMANTEC_C))
 #               include <unistd.h>
 #           endif
+*/
 #       endif
 #   endif
 #   include <fcntl.h>
