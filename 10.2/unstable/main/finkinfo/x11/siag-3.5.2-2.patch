--- siag-3.5.1.ori/common/common.scm	Mon Jan  7 16:10:24 2002
+++ siag-3.5.1/common/common.scm	Sat Apr 13 23:40:14 2002
@@ -177,8 +177,8 @@
 
 (define (do-help helpfile)
 ;  (putenv (string-append "SIAGHELP=" help-command))
-;  (spawn (string-append "siaghelp file:" docdir "/" helpfile)))
-  (spawn (string-append "siagrun help file:" docdir "/" helpfile)))
+;  (spawn (string-append "siaghelp " docdir "/" helpfile)))
+  (spawn (string-append "siagrun help " docdir "/" helpfile)))
 
 (define (do-link url)
 ;  (putenv (string-append "SIAGHELP=" help-command))
--- siag-3.5.1.ori/common/docs/siaghelp	Wed May 23 19:14:14 2001
+++ siag-3.5.1/common/docs/siaghelp	Sat Apr 13 23:37:19 2002
@@ -6,6 +6,8 @@
 # Put this script in a directory in your PATH. Then do:
 # SIAGHELP=siaghelp; export SIAGHELP
 
+# Modified to look for dillo, links, and lynx.
+
 if [ "$SIAGHELP" = "siaghelp" ]; then
 	unset SIAGHELP
 fi
@@ -13,8 +15,10 @@
 WS=`which "$SIAGHELP" 2> /dev/null`
 
 if [ "$SIAGHELP" = "" -o ! -x "$WS" ]; then
-	if which netscape > /dev/null; then
-		SIAGHELP=netscape
+	if which dillo > /dev/null; then
+		SIAGHELP=dillo
+        elif which links > /dev/null; then
+	        SIAGHELP="xterm -e links"
 	elif which lynx > /dev/null; then
 		SIAGHELP="xterm -e lynx"
 	else
--- siag-3.4.10/xfiler/Eexec.c	Thu Jan  1 01:00:00 1970
+++ siag-3.4.10/xfiler/Eexec.c	Wed Sep  5 22:53:47 2001
@@ -0,0 +1,102 @@
+/*---------------------------------------------------------------------------
+  Module FmExec
+
+  (c) Simon Marlow 1990-92
+  (c) Albert Graef 1994
+
+  Procedures for executing files
+---------------------------------------------------------------------------*/
+#include <stdio.h>
+#include <memory.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+
+#include <X11/Intrinsic.h>
+
+#include "Files.h"
+
+ExecMapRec *exec_map = NULL;
+int n_exec_maps = 0;
+
+/*---------------------------------------------------------------------------
+  PUBLIC FUNCTIONS
+---------------------------------------------------------------------------*/
+
+char **makeArgv(char *action)
+{
+  char **argv;
+  int i = 0;
+
+  argv = (char **) XtMalloc( (user.arg0flag ? 5 : 4) * sizeof(char *));
+
+  argv[i++] = XtNewString(user.shell);
+  argv[i++] = XtNewString("-c");
+  argv[i++] = XtNewString(action);
+  if (user.arg0flag)
+    argv[i++] = XtNewString(user.shell);
+  argv[i] = NULL;
+
+  return argv;
+}
+
+/*---------------------------------------------------------------------------*/
+
+void freeArgv(char **argv)
+{
+  int j;
+
+  for (j=0; argv[j]; j++)
+    XTFREE(argv[j]);
+  XTFREE(argv);
+}
+
+/*---------------------------------------------------------------------------*/
+
+static void echoarg(char *arg)
+{
+  char *s;
+  for (s = arg; *s; s++)
+    if (isspace(*s)) {
+      fprintf(stderr, " '%s'", arg);
+      return;
+    }
+  fprintf(stderr, " %s", arg);
+}
+
+/*---------------------------------------------------------------------------*/
+
+void executeApplication(char *path, char *directory, char **argv)
+{
+  int pid;
+
+  zzz();
+  XFlush(XtDisplay(toplevel));
+  if (chdir(directory)) {
+    wakeUp();
+    sysError("Can't chdir:");
+  } else if ((pid = fork()) == -1) {
+    wakeUp();
+    sysError("Can't fork:");
+  } else {
+    if (!pid) {
+      if (resources.echo_actions) {
+	char **arg;
+	fprintf(stderr, "[%s] %s", directory, path);
+	for (arg = argv+1; *arg; arg++)
+	  echoarg(*arg);
+	fprintf(stderr, "\n");
+      }
+      /* Make sure that child processes don't lock up xfm with keyboard
+	 input. This is certainly a kludge and if you know of any better
+	 way to do this, please let me know. -ag */
+      freopen("/dev/null", "r", stdin);
+      execvp(path, argv);
+      perror("Exec failed");
+      exit(1);
+    } else {
+      sleep(1);
+      wakeUp();
+    }
+  }    
+}

